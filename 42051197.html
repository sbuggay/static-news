<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730883683750" as="style"/><link rel="stylesheet" href="styles.css?v=1730883683750"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://codspeed.io/blog/state-of-python-3-13-performance-free-threading">State of Python 3.13 performance: Free-threading</a> <span class="domain">(<a href="https://codspeed.io">codspeed.io</a>)</span></div><div class="subtext"><span>art049</span> | <span>134 comments</span></div><br/><div><div id="42051523" class="c"><input type="checkbox" id="c-42051523" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42053094">next</a><span>|</span><label class="collapse" for="c-42051523">[-]</label><label class="expand" for="c-42051523">[112 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really have a dog in this race as I don&#x27;t use Python much, but this sort of thing always seemed to be of questionable utility to me.<p>Python is never really going to be &#x27;fast&#x27; no matter what is done to it because its semantics make most important optimizations impossible, so high performance &quot;python&quot; is actually going to always rely on restricted subsets of the language that don&#x27;t actually match language&#x27;s &quot;real&quot; semantics.<p>On the other hand, a lot of these changes to try and speed up the base language are going to be highly disruptive. E.g. disabling the GIL will break tonnes of code, lots of compilation projects involve changes to the ABI, etc.<p>I guess getting loops in Python to run 5-10x faster will still save some people time, but it&#x27;s also never going to be a replacement for the zoo of specialized python-like compilers because it&#x27;ll never get to actual high performance territory, and it&#x27;s not clear that it&#x27;s worth all the ecosystem churn it might cause.</div><br/><div id="42052106" class="c"><input type="checkbox" id="c-42052106" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42058137">next</a><span>|</span><label class="collapse" for="c-42052106">[-]</label><label class="expand" for="c-42052106">[32 more]</label></div><br/><div class="children"><div class="content">There was a discussion the other day about how Python devs apparently don&#x27;t care enough for backwards compatibility. I pointed out that I&#x27;ve often gotten Python 2 code running on Python 3 by just changing print to print().<p>But then a few hours later, I tried running a very small project I wrote <i>last year</i> and it turned out that a bunch of my dependencies had changed their APIs. I&#x27;ve had similar (and much worse) experiences trying to get older code with dependencies running.<p>My meaning with this comment is, that if the average developer&#x27;s reality is that backwards compatibility isn&#x27;t really a thing anyway, then we are already paying for that downside so we might as well get some upside there, is my reasoning.</div><br/><div id="42058119" class="c"><input type="checkbox" id="c-42058119" checked=""/><div class="controls bullet"><span class="by">kwertzzz</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42052535">next</a><span>|</span><label class="collapse" for="c-42058119">[-]</label><label class="expand" for="c-42058119">[1 more]</label></div><br/><div class="children"><div class="content">Sadly, several python projects do not use semantic versioning, for example xarray [0] and dask. Numpy can make backward incompatible changes after a warning for two releases[1]. In general, the python packaging docs do not really read as an endorsement of semantic versioning [2]:<p>&gt; A majority of Python projects use a scheme that resembles semantic versioning. However, most projects, especially larger ones, do not strictly adhere to semantic versioning, since many changes are technically breaking changes but affect only a small fraction of users...<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;pydata&#x2F;xarray&#x2F;issues&#x2F;6176">https:&#x2F;&#x2F;github.com&#x2F;pydata&#x2F;xarray&#x2F;issues&#x2F;6176</a><p>[1] <a href="https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;dev&#x2F;depending_on_numpy.html" rel="nofollow">https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;dev&#x2F;depending_on_numpy.html</a><p>[2] <a href="https:&#x2F;&#x2F;packaging.python.org&#x2F;en&#x2F;latest&#x2F;discussions&#x2F;versioning&#x2F;" rel="nofollow">https:&#x2F;&#x2F;packaging.python.org&#x2F;en&#x2F;latest&#x2F;discussions&#x2F;versionin...</a></div><br/></div></div><div id="42052535" class="c"><input type="checkbox" id="c-42052535" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42058119">prev</a><span>|</span><a href="#42052439">next</a><span>|</span><label class="collapse" for="c-42052535">[-]</label><label class="expand" for="c-42052535">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to comment on this without knowing more about the dependencies and when&#x2F;how they changed their APIs. I would say if it was a major version change, that isn&#x27;t too shocking. For a minor version change, it should be.<p>Stuff that is actually included with Python tends to be more stable than random Pypi packages, though.<p>NPM packages also sometimes change. That&#x27;s the world.</div><br/><div id="42053290" class="c"><input type="checkbox" id="c-42053290" checked=""/><div class="controls bullet"><span class="by">Timon3</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052535">parent</a><span>|</span><a href="#42053366">next</a><span>|</span><label class="collapse" for="c-42053290">[-]</label><label class="expand" for="c-42053290">[6 more]</label></div><br/><div class="children"><div class="content">The big difference is that npm will automatically (since 2017) save a version range to the project metadata, and will automatically create this metadata file if it doesn&#x27;t exist. Same for other package managers in the Node world.<p>I just installed Python 3.13 with pip 24.2, created a venv and installed a package - and nothing, no file was created and nothing was saved. Even if I touch requirements.txt and pyproject.toml, pip doesn&#x27;t save anything about the package.<p>This creates a massive gap in usability of projects by people not very familiar with the languages. Node-based projects sometimes have issues because dependencies changed without respecting semver, but Python projects often <i>can&#x27;t be installed</i> and you have no idea why without spending lots of time looking through versions.<p>Of course there are other package managers for Python that do this better, but pip is still the de-facto default and is often used in tutorials for new developers. Hopefully uv can improve things!</div><br/><div id="42056952" class="c"><input type="checkbox" id="c-42056952" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053290">parent</a><span>|</span><a href="#42056483">next</a><span>|</span><label class="collapse" for="c-42056952">[-]</label><label class="expand" for="c-42056952">[2 more]</label></div><br/><div class="children"><div class="content">I recommend to start using UV.<p>It is very fast and tracks the libraries you are using.<p>After years of venv&#x2F;pip, I&#x27;m not going back (unless a client requires it).</div><br/><div id="42057998" class="c"><input type="checkbox" id="c-42057998" checked=""/><div class="controls bullet"><span class="by">jessekv</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056952">parent</a><span>|</span><a href="#42056483">next</a><span>|</span><label class="collapse" for="c-42057998">[-]</label><label class="expand" for="c-42057998">[1 more]</label></div><br/><div class="children"><div class="content">Another nice thing about uv is it can install python itself in the venv.<p>So no need to mess around with brew&#x2F;deadsnakes and multiple global python versions on your dev system.<p>This is actually an improvement over the node&#x2F;nvm approach.</div><br/></div></div></div></div><div id="42056483" class="c"><input type="checkbox" id="c-42056483" checked=""/><div class="controls bullet"><span class="by">elashri</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053290">parent</a><span>|</span><a href="#42056952">prev</a><span>|</span><a href="#42053366">next</a><span>|</span><label class="collapse" for="c-42056483">[-]</label><label class="expand" for="c-42056483">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Of course there are other package managers for Python that do this better<p>I think if you are comparing with what NPM does then you would have to say that native pip can do that too. It is just one command<p>`pip freeze &gt; requirements.txt`<p>It does include everything in the venv (or in you environment in general) but if you stick to only add required things (one venv for each project) then you will get requirements.txt  files</div><br/><div id="42057994" class="c"><input type="checkbox" id="c-42057994" checked=""/><div class="controls bullet"><span class="by">whyever</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056483">parent</a><span>|</span><a href="#42053366">next</a><span>|</span><label class="collapse" for="c-42057994">[-]</label><label class="expand" for="c-42057994">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is the same. Does it also cover transitive dependencies?</div><br/><div id="42058080" class="c"><input type="checkbox" id="c-42058080" checked=""/><div class="controls bullet"><span class="by">elashri</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42057994">parent</a><span>|</span><a href="#42053366">next</a><span>|</span><label class="collapse" for="c-42058080">[-]</label><label class="expand" for="c-42058080">[1 more]</label></div><br/><div class="children"><div class="content">Sorry if what I said about NPM is not accurate. But in reality if you are pinning the dependencies (all of them actual get pinned) then when pip is installing it will grab the correct version of the transitive dependency (both packages are pinned)<p>So I am not sure when this will become a problem.</div><br/></div></div></div></div></div></div></div></div><div id="42053366" class="c"><input type="checkbox" id="c-42053366" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052535">parent</a><span>|</span><a href="#42053290">prev</a><span>|</span><a href="#42052439">next</a><span>|</span><label class="collapse" for="c-42053366">[-]</label><label class="expand" for="c-42053366">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I guess I should have done a pip freeze to specify the versions in the requirements file. I wasn&#x27;t thinking ahead.<p>Turns out one dependency had 3 major releases in the span of a year! (Which basically confirms what I was saying, though I don&#x27;t know how typical that is.)</div><br/><div id="42057893" class="c"><input type="checkbox" id="c-42057893" checked=""/><div class="controls bullet"><span class="by">cdchn</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053366">parent</a><span>|</span><a href="#42052439">next</a><span>|</span><label class="collapse" for="c-42057893">[-]</label><label class="expand" for="c-42057893">[1 more]</label></div><br/><div class="children"><div class="content">3rd party package maintainers usually don&#x27;t do as good a job of maintaining backwards compatibility or doing it right as do the core library maintainers, thats why you were able to upgrade from 2 to 3 by changing print to print() but then sometimes dependencies you install with pip break for inexplicable reasons.</div><br/></div></div></div></div></div></div><div id="42052439" class="c"><input type="checkbox" id="c-42052439" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42052535">prev</a><span>|</span><a href="#42056575">next</a><span>|</span><label class="collapse" for="c-42052439">[-]</label><label class="expand" for="c-42052439">[13 more]</label></div><br/><div class="children"><div class="content">So pin your deps? Language backwards compatibility and an API from some random package changing are completely distinct.</div><br/><div id="42053126" class="c"><input type="checkbox" id="c-42053126" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052439">parent</a><span>|</span><a href="#42056182">next</a><span>|</span><label class="collapse" for="c-42053126">[-]</label><label class="expand" for="c-42053126">[11 more]</label></div><br/><div class="children"><div class="content">Pinning deps is discouraged by years of Python practice. And going back to a an old project and finding versions that work, a year or more later, might be nigh on impossible.<p>Last week I was trying to install snakemake via Conda, and couldn&#x27;t find any way to satisfy dependencies at all, so it&#x27;s not just pypi, and pip tends to be one of the more forgiving version dependency managers.<p>It&#x27;s not just Python, trying to get npm to load the requirements has stopped me from compiling about half of the projects I&#x27;ve tried to build (which is not a ton of projects). And CRAN in the R universe can have similar problems as projects age.</div><br/><div id="42053550" class="c"><input type="checkbox" id="c-42053550" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053126">parent</a><span>|</span><a href="#42053412">next</a><span>|</span><label class="collapse" for="c-42053550">[-]</label><label class="expand" for="c-42053550">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Pinning deps is discouraged by years of Python practice.<p>I&#x27;m not sure it is discouraged so much as just not what people did in Python-land for a long time. It&#x27;s obviously the right thing to do, it&#x27;s totally doable, it&#x27;s just inertia and habit that might mean it isn&#x27;t done.</div><br/><div id="42057411" class="c"><input type="checkbox" id="c-42057411" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053550">parent</a><span>|</span><a href="#42053412">next</a><span>|</span><label class="collapse" for="c-42057411">[-]</label><label class="expand" for="c-42057411">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure it is discouraged so much as just not what people did in Python-land for a long time. It&#x27;s obviously the right thing to do, it&#x27;s totally doable, it&#x27;s just inertia and habit that might mean it isn&#x27;t done.<p>Pinning obviously the wrong thing, it only works if everyone does it and if everyone does it then making changes becomes very hard. The right thing is to have deterministic dependency resolution so that dependencies don&#x27;t change under you.</div><br/><div id="42057500" class="c"><input type="checkbox" id="c-42057500" checked=""/><div class="controls bullet"><span class="by">WillDaSilva</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42057411">parent</a><span>|</span><a href="#42053412">next</a><span>|</span><label class="collapse" for="c-42057500">[-]</label><label class="expand" for="c-42057500">[3 more]</label></div><br/><div class="children"><div class="content">When they suggest you pin your dependencies, they don&#x27;t just mean your direct dependencies, but rather all transitive dependencies. You can take this further by having a lock file that account for different Python versions, operating systems, and CPI architectures – for instance , by using UV or Poetry – but a simple `pip freeze` is often sufficient.</div><br/><div id="42057706" class="c"><input type="checkbox" id="c-42057706" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42057500">parent</a><span>|</span><a href="#42053412">next</a><span>|</span><label class="collapse" for="c-42057706">[-]</label><label class="expand" for="c-42057706">[2 more]</label></div><br/><div class="children"><div class="content">That works for your project, but then nobody can include you as a library without conflicts.<p>But having that lock file will allow somebody to reconstruct your particular moment in time in the future. Its just that those lock files do not exist for 99.9% of Python projects in time.</div><br/><div id="42058244" class="c"><input type="checkbox" id="c-42058244" checked=""/><div class="controls bullet"><span class="by">dagw</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42057706">parent</a><span>|</span><a href="#42053412">next</a><span>|</span><label class="collapse" for="c-42058244">[-]</label><label class="expand" for="c-42058244">[1 more]</label></div><br/><div class="children"><div class="content"><i>That works for your project, but then nobody can include you as a library without conflicts.</i><p>I think this is the core to much misunderstandings and arguments around this question. Some people are writing code that only they will run, on a python they&#x27;ve installed, on hardware they control. Others are writing code that has to work on lots of different versions of python, on lots of different hardware, and when being run in all kinds of strange scenarios. These two groups have quite different needs and don&#x27;t always understand each other and the problems they face.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42053412" class="c"><input type="checkbox" id="c-42053412" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053126">parent</a><span>|</span><a href="#42053550">prev</a><span>|</span><a href="#42053915">next</a><span>|</span><label class="collapse" for="c-42053412">[-]</label><label class="expand" for="c-42053412">[1 more]</label></div><br/><div class="children"><div class="content">That doesn’t match my experience at all. I have many Python projects going back years that all work fine with pinned dependencies</div><br/></div></div><div id="42053915" class="c"><input type="checkbox" id="c-42053915" checked=""/><div class="controls bullet"><span class="by">nicce</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053126">parent</a><span>|</span><a href="#42053412">prev</a><span>|</span><a href="#42056067">next</a><span>|</span><label class="collapse" for="c-42053915">[-]</label><label class="expand" for="c-42053915">[1 more]</label></div><br/><div class="children"><div class="content">It took me few days to get some old Jupyter Notebooks working. I had to find the correct older version of Jupyter, correct version of the every plugin&#x2F;extension that notebook used and then I had to find the correct version of every dependency of these extensions. Only way to get it working was a bunch of pinned dependencies.</div><br/></div></div><div id="42056067" class="c"><input type="checkbox" id="c-42056067" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053126">parent</a><span>|</span><a href="#42053915">prev</a><span>|</span><a href="#42056182">next</a><span>|</span><label class="collapse" for="c-42056067">[-]</label><label class="expand" for="c-42056067">[3 more]</label></div><br/><div class="children"><div class="content">I’m curious as to which packages you are unable to find older versions for. You mention snakemake, but that doesn’t seem to have any sort of issues.<p><a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;snakemake&#x2F;#history" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;snakemake&#x2F;#history</a></div><br/><div id="42056273" class="c"><input type="checkbox" id="c-42056273" checked=""/><div class="controls bullet"><span class="by">epistasis</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056067">parent</a><span>|</span><a href="#42056182">next</a><span>|</span><label class="collapse" for="c-42056273">[-]</label><label class="expand" for="c-42056273">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about finding old packages, it&#x27;s about not finding the magical compatible set of package versions.<p>Pip is nice in that you can install packages individually to get around some version conflicts. But with conda and npm and CRAN I have always found my stuck without being able to install dependencies after 15 minutes of mucking.<p>Its rare that somebody has left the equivalent of the output of a `pip freeze` around to document their state.<p>With snakemake, I abandoned conda and went with pip in a venv, without filing an issue. Perhaps it was user error from being unfamiliar with conda, but I did not have more time to spend on the issue, much less doing the research to be able to file a competent issue and follow up later on.</div><br/><div id="42058279" class="c"><input type="checkbox" id="c-42058279" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056273">parent</a><span>|</span><a href="#42056182">next</a><span>|</span><label class="collapse" for="c-42058279">[-]</label><label class="expand" for="c-42058279">[1 more]</label></div><br/><div class="children"><div class="content">It’s a little hard for me to talk about Python setups which don’t use Poetry as that is basically the standard around here. I would argue that not controlling your packages regardless of the package manager you use is very poor practice.<p>How can you reasonably expect to work with any tech that breaks itself by not controlling its dependencies?</div><br/></div></div></div></div></div></div></div></div><div id="42056182" class="c"><input type="checkbox" id="c-42056182" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052439">parent</a><span>|</span><a href="#42053126">prev</a><span>|</span><a href="#42056575">next</a><span>|</span><label class="collapse" for="c-42056182">[-]</label><label class="expand" for="c-42056182">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So pin your deps?<p>Which is, fairly often, pinning your python version.</div><br/></div></div></div></div><div id="42056575" class="c"><input type="checkbox" id="c-42056575" checked=""/><div class="controls bullet"><span class="by">salomonk_mur</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42052439">prev</a><span>|</span><a href="#42056060">next</a><span>|</span><label class="collapse" for="c-42056575">[-]</label><label class="expand" for="c-42056575">[2 more]</label></div><br/><div class="children"><div class="content">What APIs were broken? They couldn&#x27;t be in the standard library.<p>If the dependency was in external modules and you didn&#x27;t have pinned versions, then it is to be expected (in almost any active language) that some APIs will break.</div><br/><div id="42057593" class="c"><input type="checkbox" id="c-42057593" checked=""/><div class="controls bullet"><span class="by">dagw</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056575">parent</a><span>|</span><a href="#42056060">next</a><span>|</span><label class="collapse" for="c-42057593">[-]</label><label class="expand" for="c-42057593">[1 more]</label></div><br/><div class="children"><div class="content"><i>They couldn&#x27;t be in the standard library.</i><p>Why not? Python does make breaking changes to the standard library when going from 3.X to 3.X+1 quite regularly.</div><br/></div></div></div></div><div id="42056060" class="c"><input type="checkbox" id="c-42056060" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42056575">prev</a><span>|</span><a href="#42054480">next</a><span>|</span><label class="collapse" for="c-42056060">[-]</label><label class="expand" for="c-42056060">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Python 2 code running on Python 3 by just changing print to print().<p>This was very much the opposite of my experience. Consider yourself lucky.</div><br/><div id="42056250" class="c"><input type="checkbox" id="c-42056250" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056060">parent</a><span>|</span><a href="#42054480">next</a><span>|</span><label class="collapse" for="c-42056250">[-]</label><label class="expand" for="c-42056250">[2 more]</label></div><br/><div class="children"><div class="content">This migration took the industry years because it was not that simple.</div><br/><div id="42056611" class="c"><input type="checkbox" id="c-42056611" checked=""/><div class="controls bullet"><span class="by">selcuka</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056250">parent</a><span>|</span><a href="#42054480">next</a><span>|</span><label class="collapse" for="c-42056611">[-]</label><label class="expand" for="c-42056611">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This migration took the industry years because it was not that simple.<p>It was not that simple, but it was not that hard either.<p>It took the industry years because Python 2.7 was still good enough, and the tangible benefits of migrating to Python 3 didn&#x27;t justify the effort for most projects.<p>Also some dependencies such as MySQL-python never updated to Python 3, which was also an issue for projects with many dependencies.</div><br/></div></div></div></div></div></div><div id="42054480" class="c"><input type="checkbox" id="c-42054480" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42056060">prev</a><span>|</span><a href="#42052274">next</a><span>|</span><label class="collapse" for="c-42054480">[-]</label><label class="expand" for="c-42054480">[1 more]</label></div><br/><div class="children"><div class="content">The Python 2 to 3 thing was worse when they started: people who made the mistake of falling for the rhetoric to port to python3 early on had a much more difficult time as basic things like u&quot;&quot; were broken under an argument that they weren&#x27;t needed anymore; over time the porting process got better as they acquiesced and unified the two languages a bit.<p>I thereby kind of feel like this might have happened in the other direction: a ton of developers seem to have become demoralized by python3 and threw up their hands in defeat of &quot;backwards compatibility isn&#x27;t going to happen anyway&quot;, and now we live in a world with frozen dependencies running in virtual environments tied to specific copies of Python.</div><br/></div></div><div id="42052274" class="c"><input type="checkbox" id="c-42052274" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052106">parent</a><span>|</span><a href="#42054480">prev</a><span>|</span><a href="#42058137">next</a><span>|</span><label class="collapse" for="c-42052274">[-]</label><label class="expand" for="c-42052274">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I pointed out that I&#x27;ve often gotten Python 2 code running on Python 3 by just changing print to print().<p>...<p>&gt; I wrote last year and it turned out that a bunch of my dependencies had changed their APIs<p>these two things have absolutely nothing to do with each other - couldn&#x27;t be a more apples to oranges comparison if you tried</div><br/><div id="42053388" class="c"><input type="checkbox" id="c-42053388" checked=""/><div class="controls bullet"><span class="by">andai</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052274">parent</a><span>|</span><a href="#42058137">next</a><span>|</span><label class="collapse" for="c-42053388">[-]</label><label class="expand" for="c-42053388">[1 more]</label></div><br/><div class="children"><div class="content">I ran into both of these things in the same context, which is &quot;the difficulty involved in getting old code working on the latest Python environment&quot;, which I understood as the context of this discussion.</div><br/></div></div></div></div></div></div><div id="42058137" class="c"><input type="checkbox" id="c-42058137" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42052106">prev</a><span>|</span><a href="#42052677">next</a><span>|</span><label class="collapse" for="c-42058137">[-]</label><label class="expand" for="c-42058137">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Python is never really going to be &#x27;fast&#x27; no matter what is done to it because its semantics make most important optimizations impossible, so high performance &quot;python&quot; is actually going to always rely on restricted subsets of the language that don&#x27;t actually match language&#x27;s &quot;real&quot; semantics.<p>Have you heard of Mojo? It is a very performant superset of Python. <a href="https:&#x2F;&#x2F;www.modular.com&#x2F;mojo" rel="nofollow">https:&#x2F;&#x2F;www.modular.com&#x2F;mojo</a></div><br/></div></div><div id="42052677" class="c"><input type="checkbox" id="c-42052677" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42058137">prev</a><span>|</span><a href="#42056322">next</a><span>|</span><label class="collapse" for="c-42052677">[-]</label><label class="expand" for="c-42052677">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Python is never really going to be &#x27;fast&#x27; no matter what is done to it because its semantics make most important optimizations impossible<p>Scientific computing community have a bunch of code calling numpy or whatever stuff. They are pretty fast because, well, numpy isn&#x27;t written in Python. However, there is a scalability issue: they can only drive so many threads (not 1, but not many) in a process due to GIL.<p>Okay, you may ask, why not just use a lot of processes and message-passing? That&#x27;s how historically people work around the GIL issue. However, you need to either swallow the cost of serializing data over and over again (pickle is quite slow, even it&#x27;s not, it&#x27;s wasting precious memory bandwidth), or do very complicated dance with shared memory.<p>It&#x27;s not for web app bois, who may just write TypeScript.</div><br/><div id="42056479" class="c"><input type="checkbox" id="c-42056479" checked=""/><div class="controls bullet"><span class="by">willseth</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052677">parent</a><span>|</span><a href="#42052808">next</a><span>|</span><label class="collapse" for="c-42056479">[-]</label><label class="expand" for="c-42056479">[3 more]</label></div><br/><div class="children"><div class="content">This is misleading. Most of the compute intensive work in Numpy releases the GIL, and you can use traditional multithreading. That is the case for many other compute intensive compiled extensions as well.</div><br/><div id="42057702" class="c"><input type="checkbox" id="c-42057702" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056479">parent</a><span>|</span><a href="#42056572">next</a><span>|</span><label class="collapse" for="c-42057702">[-]</label><label class="expand" for="c-42057702">[1 more]</label></div><br/><div class="children"><div class="content">No. Like the siblings said, say, you have a program which spends 10% time in Python code <i>between</i> these numpy calls. The code is still not scalable, because you can run at most 10 such threads in a Python process before you hit the hard limit imposed by GIL.<p>There is no need to eliminate the 10% or make it 5% or whatever, people happily pay 10% overhead for convenience, but being limited to 10 threads is a showstopper.</div><br/></div></div><div id="42056572" class="c"><input type="checkbox" id="c-42056572" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056479">parent</a><span>|</span><a href="#42057702">prev</a><span>|</span><a href="#42052808">next</a><span>|</span><label class="collapse" for="c-42056572">[-]</label><label class="expand" for="c-42056572">[1 more]</label></div><br/><div class="children"><div class="content">It’s an Amdahl’s law sort of thing,  you can extract some of the parallelism with scikit-learn but what’s left is serialized.  Particularly for those interactive jobs where you might write plain ordinary Python snippets that could get a 12x speedup (string parsing for a small ‘data lake’)<p>In so far as it is all threaded for C and Python you can parallelize it all with one paradigm that also makes a mean dynamic web server.</div><br/></div></div></div></div><div id="42052808" class="c"><input type="checkbox" id="c-42052808" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052677">parent</a><span>|</span><a href="#42056479">prev</a><span>|</span><a href="#42056322">next</a><span>|</span><label class="collapse" for="c-42052808">[-]</label><label class="expand" for="c-42052808">[2 more]</label></div><br/><div class="children"><div class="content">Numpy is not fast enough for actual performance sensitive scientific computing. Yes threading can help, but at the end of the day the single threaded perf isn&#x27;t where it needs to be, and is held back too much by the python glue between Numpy calls. This makes interproceedural optimizations impossible.<p>Accellerated sub-languages like Numba, Jax, Pytorch, etc. or just whole new languages are really the only way forward here unless massive semantic changes are made to Python.</div><br/><div id="42053920" class="c"><input type="checkbox" id="c-42053920" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052808">parent</a><span>|</span><a href="#42056322">next</a><span>|</span><label class="collapse" for="c-42053920">[-]</label><label class="expand" for="c-42053920">[1 more]</label></div><br/><div class="children"><div class="content">These &quot;accelerated sub-languages&quot; are still driven by, well, Python glue. That&#x27;s why we need free-threading and faster Python. We want the glue to be faster because it&#x27;s currently the most accessible glue to the community.<p>In fact, Sam, the man behind free-threading, works on PyTorch. From my understanding he decided to explore nogil because GIL is holding DL trainings written in PyTorch back. Namely, the PyTorch DataLoader code itself and almost all data loading pipelines in real training codebases are hopeless bloody mess <i>just because</i> all of the IPC&#x2F;SHM nonsense.</div><br/></div></div></div></div></div></div><div id="42056322" class="c"><input type="checkbox" id="c-42056322" checked=""/><div class="controls bullet"><span class="by">6gvONxR4sf7o</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42052677">prev</a><span>|</span><a href="#42058051">next</a><span>|</span><label class="collapse" for="c-42056322">[-]</label><label class="expand" for="c-42056322">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so high performance &quot;python&quot; is actually going to always rely on restricted subsets of the language that don&#x27;t actually match language&#x27;s &quot;real&quot; semantics.<p>I don&#x27;t even understand what this means. If I write `def foo(x):` versus `def foo(x: int) -&gt; float:`, one is a restricted subset of the other, but both are the language&#x27;s &quot;real&quot; semantics. Restricted subsets of languages are wildly popular in programming languages, and for very varied reasons. Why should that be a barrier here?<p>Personally, if I have to annotate some of my code that run with C style semantics, but in return that part runs with C speed, for example, then I just don&#x27;t really mind it. Different tools for different jobs.</div><br/></div></div><div id="42058051" class="c"><input type="checkbox" id="c-42058051" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42056322">prev</a><span>|</span><a href="#42051703">next</a><span>|</span><label class="collapse" for="c-42058051">[-]</label><label class="expand" for="c-42058051">[2 more]</label></div><br/><div class="children"><div class="content">I do use Python and I am not that bothered about speed.<p>Very little of what I use it for has performance bottlenecks in the Python. Its the database or the network or IO or whatever.<p>On the few occasions when it does I can rewrite critical bits of code.<p>I definitely care more about backward compatibility than I do about performance.<p>It feels like Python development is being driven by the needs of one particular group (people who use ML heavily, possibly because they have deep pockets) and I wonder whether this, and a few other things will make it less attractive a language for me and others.</div><br/><div id="42058090" class="c"><input type="checkbox" id="c-42058090" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42058051">parent</a><span>|</span><a href="#42051703">next</a><span>|</span><label class="collapse" for="c-42058090">[-]</label><label class="expand" for="c-42058090">[1 more]</label></div><br/><div class="children"><div class="content">Your DB is probably faster than you think. I rewrote an API in Python to Java and it is around 6x faster with just same dumb N+1 queries, and the new API also includes all the frontend calculations that Python wasn&#x27;t doing before.</div><br/></div></div></div></div><div id="42051703" class="c"><input type="checkbox" id="c-42051703" checked=""/><div class="controls bullet"><span class="by">wormlord</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42058051">prev</a><span>|</span><a href="#42052340">next</a><span>|</span><label class="collapse" for="c-42051703">[-]</label><label class="expand" for="c-42051703">[4 more]</label></div><br/><div class="children"><div class="content">&gt; On the other hand, a lot of these changes to try and speed up the base language are going to be highly disruptive. E.g. disabling the GIL will break tonnes of code, lots of compilation projects involve changes to the ABI, etc.<p>Kind of related, the other day I was cursing like a sailor because I was having issues with some code I wrote that uses StrEnum not working with older versions of Python, and wondering why I did that, and trying to find the combination of packages that would work for the version of Python I needed-- wondering why there was so much goddamn churn in this stupid [expletive] scripting language.<p>But then I took a step back and realized that, actually, I should be glad about the churn because it means that there is a community of developers who care enough about the language to add new features and maintain this language so that I can just pipe PyQt and Numpy into each other and get paid.<p>I don&#x27;t have any argument, just trying to give an optimistic perspective.</div><br/><div id="42054851" class="c"><input type="checkbox" id="c-42054851" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051703">parent</a><span>|</span><a href="#42057484">next</a><span>|</span><label class="collapse" for="c-42054851">[-]</label><label class="expand" for="c-42054851">[2 more]</label></div><br/><div class="children"><div class="content">At least bugfix versions could have kept Enum behavior the same. Postponing breaking changes until the next minor version. Some Enum features work differently (incompatible) in Python 3.11.x versions.</div><br/><div id="42054899" class="c"><input type="checkbox" id="c-42054899" checked=""/><div class="controls bullet"><span class="by">wormlord</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42054851">parent</a><span>|</span><a href="#42057484">next</a><span>|</span><label class="collapse" for="c-42054899">[-]</label><label class="expand" for="c-42054899">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Some Enum features work differently (incompatible) in Python 3.11.x versions.<p>I wasn&#x27;t aware of that, that&#x27;s actually insane. It&#x27;s odd to me that it took so long to get f-strings and Enums right in Python, I assumed those would be pretty easy language features to implement.</div><br/></div></div></div></div><div id="42057484" class="c"><input type="checkbox" id="c-42057484" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051703">parent</a><span>|</span><a href="#42054851">prev</a><span>|</span><a href="#42052340">next</a><span>|</span><label class="collapse" for="c-42057484">[-]</label><label class="expand" for="c-42057484">[1 more]</label></div><br/><div class="children"><div class="content">Meh. Anyone can improve a language if they don&#x27;t care about keeping backward compatibility, just like new programming languages and new codebases always look gloriously clean. The part that requires actual discipline and expertise is improving it while keeping the breakages under control.</div><br/></div></div></div></div><div id="42052340" class="c"><input type="checkbox" id="c-42052340" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42051703">prev</a><span>|</span><a href="#42051696">next</a><span>|</span><label class="collapse" for="c-42052340">[-]</label><label class="expand" for="c-42052340">[16 more]</label></div><br/><div class="children"><div class="content">Why does python have to be slow? Improvements over the last few releases have made it quite a bit faster. So that kind of counters that a bit. Apparently it didn&#x27;t need to be quite as slow all along. Other languages can be fast. So, why not python?<p>I think with the GIL some people are overreacting: most python code is single threaded because of the GIL. So removing it doesn&#x27;t actually break anything. The GIL was just making the use of threads kind of pointless. Removing it and making a lot of code thread safe benefits people who do want to use threads.<p>It&#x27;s very simple. Either you did not care about performance anyway and nothing really changes for you. You&#x27;d need to add threading to your project to see any changes. Unless you do that, there&#x27;s no practical reason to disable the GIL for you. Or to re-enable that once disabled becomes the default. If your python project doesn&#x27;t spawn threads now, it won&#x27;t matter to you either way. Your code won&#x27;t have deadlocking threads because it has only 1 thread and there was never anything to do for the GIL anyway. For code like that compatibility issues would be fairly minimal.<p>If it does use threads, against most popular advise of that being quite pointless in python (because of the GIL), you might see some benefits and you might have to deal with some threading issues.<p>I don&#x27;t see why a lot of packages would break. At best some of them would be not thread safe and it&#x27;s probably a good idea to mark the ones that are thread safe as such in some way. Some nice package management challenge there. And probably you&#x27;d want to know which packages you can safely use.</div><br/><div id="42052402" class="c"><input type="checkbox" id="c-42052402" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052340">parent</a><span>|</span><a href="#42051696">next</a><span>|</span><label class="collapse" for="c-42052402">[-]</label><label class="expand" for="c-42052402">[15 more]</label></div><br/><div class="children"><div class="content">&gt; Why does python have to be slow?<p>Because the language&#x27;s semantics promise that a bunch of insane stuff can happen at any time during the running of a program, including but not limited to the fields of classes changing at any time. Furthermore, they promise that their integers are aribtrary precision which are fundamentally slower to do operations with than fixed precision machine integers, etc.<p>The list of stuff like this goes on and on and on. You fundamentally just cannot compile most python programs to efficient machine code without making (sometimes subtle) changes to its semantics.<p>_________<p>&gt; I don&#x27;t see why a lot of packages would break. At best some of them would be not thread safe and it&#x27;s probably a good idea to mark the ones that are thread safe as such in some way. Some nice package management challenge there. And probably you&#x27;d want to know which packages you can safely use.<p>They&#x27;re not thread safe because it was semantically guaranteed to them that it was okay to write code that&#x27;s not thread safe.</div><br/><div id="42058158" class="c"><input type="checkbox" id="c-42058158" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052402">parent</a><span>|</span><a href="#42057421">next</a><span>|</span><label class="collapse" for="c-42058158">[-]</label><label class="expand" for="c-42058158">[1 more]</label></div><br/><div class="children"><div class="content">SELF, Smalltalk, Common Lisp are even crazier and have good performance, that has always been a common excuse, which is being proven false as proper resources are now being addressed into CPython.<p>And that while ignoring all the engineering that has gone into PyPy, largely ignored by the community.</div><br/></div></div><div id="42057421" class="c"><input type="checkbox" id="c-42057421" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052402">parent</a><span>|</span><a href="#42058158">prev</a><span>|</span><a href="#42052575">next</a><span>|</span><label class="collapse" for="c-42057421">[-]</label><label class="expand" for="c-42057421">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because the language&#x27;s semantics promise that a bunch of insane stuff can happen at any time during the running of a program, including but not limited to the fields of classes changing at any time. Furthermore, they promise that their integers are aribtrary precision which are fundamentally slower to do operations with than fixed precision machine integers, etc.<p>&gt; The list of stuff like this goes on and on and on. You fundamentally just cannot compile most python programs to efficient machine code without making (sometimes subtle) changes to its semantics.<p>People said the same thing about JavaScript, where object prototypes can change at any time, dramatically changing everything. But it turned out JavaScript can run fast if you try hard enough. I suspect the same would be true for Python if a similar amount of resources was poured into it (probably with a similar &quot;try the fast path, abort and fall back to a slow path in the extremely rare case that someone actually is doing funky metaprogramming&quot; approach).</div><br/></div></div><div id="42052575" class="c"><input type="checkbox" id="c-42052575" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052402">parent</a><span>|</span><a href="#42057421">prev</a><span>|</span><a href="#42051696">next</a><span>|</span><label class="collapse" for="c-42052575">[-]</label><label class="expand" for="c-42052575">[12 more]</label></div><br/><div class="children"><div class="content">There are different definitions of slow, though. You might want arbitrary precision numbers but want it to be reasonable fast in that context.<p>I don&#x27;t agree that it is &quot;insane stuff&quot;, but I agree that Python is not where you go if you need super fast execution. It can be a great solution for &quot;hack together something in a day that is correct, but maybe not fast&quot;, though. There are a lot of situations where that is, by far, the preferred solution.</div><br/><div id="42052634" class="c"><input type="checkbox" id="c-42052634" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052575">parent</a><span>|</span><a href="#42056206">next</a><span>|</span><label class="collapse" for="c-42052634">[-]</label><label class="expand" for="c-42052634">[10 more]</label></div><br/><div class="children"><div class="content">There are ways to design languages to be dynamic while still being friendly to optimizing compilers. Typically what you want to do is promise that various things are dynamic, but then static <i>within</i> a single compilation context.<p>julia is a great example of a highly dynamic language which is still able to compile complicated programs to C-equivalent machine code. An older (and less performant but still quite fast) example of such a language is Common Lisp.<p>Python makes certain choices though that make this stuff pretty much impossible.</div><br/><div id="42052765" class="c"><input type="checkbox" id="c-42052765" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052634">parent</a><span>|</span><a href="#42052769">next</a><span>|</span><label class="collapse" for="c-42052765">[-]</label><label class="expand" for="c-42052765">[3 more]</label></div><br/><div class="children"><div class="content">Not disputing it, but people don&#x27;t pick Python because they need the fastest language, they pick it for friendly syntax and extensive and well-supported libraries. I loved Lisp, but none of the lisps have anything like Python&#x27;s ecology. Julia, even less so.<p>People don&#x27;t pick languages for language features, mostly. They pick them for their ecosystems -- the quality of libraries, compiler&#x2F;runtime support, the network of humans you can ask questions of, etc.</div><br/><div id="42052857" class="c"><input type="checkbox" id="c-42052857" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052765">parent</a><span>|</span><a href="#42056040">next</a><span>|</span><label class="collapse" for="c-42052857">[-]</label><label class="expand" for="c-42052857">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  loved Lisp, but none of the lisps have anything like Python&#x27;s ecology. Julia, even less so.<p>None of the lisps have anything close to julia&#x27;s ecology in numerical computing at least. Can&#x27;t really speak to other niches though.<p>&gt; People don&#x27;t pick languages for language features, mostly. They pick them for their ecosystems -- the quality of libraries, compiler&#x2F;runtime support, the network of humans you can ask questions of, etc.<p>Sure. And that&#x27;s why Python is both popular and slow.</div><br/></div></div><div id="42056040" class="c"><input type="checkbox" id="c-42056040" checked=""/><div class="controls bullet"><span class="by">JodieBenitez</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052765">parent</a><span>|</span><a href="#42052857">prev</a><span>|</span><a href="#42052769">next</a><span>|</span><label class="collapse" for="c-42056040">[-]</label><label class="expand" for="c-42056040">[1 more]</label></div><br/><div class="children"><div class="content">I think that to a certain extent the quality of libraries can depend on language features.</div><br/></div></div></div></div><div id="42052769" class="c"><input type="checkbox" id="c-42052769" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052634">parent</a><span>|</span><a href="#42052765">prev</a><span>|</span><a href="#42056206">next</a><span>|</span><label class="collapse" for="c-42052769">[-]</label><label class="expand" for="c-42052769">[6 more]</label></div><br/><div class="children"><div class="content">Common Lisp is probably not a good point of comparison. It offers comparable (if not more) dynamism to Python and still remains fast (for most implementations). You can redefine class definitions and function definitions on the fly in a Common Lisp program and other than the obvious overhead of invoking those things the whole system remains fast.</div><br/><div id="42052926" class="c"><input type="checkbox" id="c-42052926" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052769">parent</a><span>|</span><a href="#42054393">next</a><span>|</span><label class="collapse" for="c-42052926">[-]</label><label class="expand" for="c-42052926">[4 more]</label></div><br/><div class="children"><div class="content">Common lisp is in fact a good point of comparison once you look at how it&#x27;s fast. The trick with Common Lisp is that they made a foundation of stuff that can actually be optimized pretty well by a compiler, and made that stuff exempt from being changed on the fly (or in some cases, just made the the compiler assume that they won&#x27;t change on the fly even if they do, resulting in seg-faults unless you recompile code and re-generate data after changing stuff).<p>This is how Common Lisp people can claim that the language is both performant and flexible. The performant parts and the flexible parts are more disjoint than one might expect based on the way people talk about it.<p>But anyways, Common Lisp <i>does</i> manage to give a high degree of dynamism and performance to a point that it surely can be used for any of the dynamic stuff you&#x27;d want to do in Python, while also giving the possibility of writing high performance code.<p>Python did not do this, and so it&#x27;ll be impossible for them to offer something like common lisp perf without breaking changes, or by just introducing a whole new set of alternatives to slow builtins like class, int, call, etc.</div><br/><div id="42053003" class="c"><input type="checkbox" id="c-42053003" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052926">parent</a><span>|</span><a href="#42054393">next</a><span>|</span><label class="collapse" for="c-42053003">[-]</label><label class="expand" for="c-42053003">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; Why does python have to be slow?<p>&gt; Because the language&#x27;s semantics promise that a bunch of insane stuff can happen at any time during the running of a program, including but not limited to the fields of classes changing at any time.<p>You originally claimed Python is slow because of its semantics and then compare later to CL. CL has a very similar degree of dynamism and remains fast. That&#x27;s what I&#x27;m saying makes for a poor comparison.<p>CL is a demonstration that Python, contrary to your initial claim, doesn&#x27;t have to forfeit dynamism to become fast.</div><br/><div id="42053292" class="c"><input type="checkbox" id="c-42053292" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053003">parent</a><span>|</span><a href="#42053244">next</a><span>|</span><label class="collapse" for="c-42053292">[-]</label><label class="expand" for="c-42053292">[1 more]</label></div><br/><div class="children"><div class="content">&gt; CL has a very similar degree of dynamism and remains fast.<p>But not the dynamic parts remain &quot;really&quot; fast. Common Lisp introduced very early a lot of features to support optimizing compilers -&gt; some of those reduce &quot;dynamism&quot;. Code inlining (-&gt; inline declarations), file compiler semantics, type declarations, optimization qualities (speed, compilation-speed, space, safety, debug, ...), stack allocation, tail call optimization, type inferencing, ...</div><br/></div></div><div id="42053244" class="c"><input type="checkbox" id="c-42053244" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053003">parent</a><span>|</span><a href="#42053292">prev</a><span>|</span><a href="#42054393">next</a><span>|</span><label class="collapse" for="c-42053244">[-]</label><label class="expand" for="c-42053244">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re missing the point. Common Lisp is very dynamic yes, but it was designed in a very careful way to make sure that dynamism does not make an optimizing compiler impossible. That is not the case for Python.<p>Not all dynamism is the same, even if the end result can feel the same. Python has a particularly difficult brand of dynamism to deal with.</div><br/></div></div></div></div></div></div><div id="42054393" class="c"><input type="checkbox" id="c-42054393" checked=""/><div class="controls bullet"><span class="by">Archit3ch</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052769">parent</a><span>|</span><a href="#42052926">prev</a><span>|</span><a href="#42056206">next</a><span>|</span><label class="collapse" for="c-42054393">[-]</label><label class="expand" for="c-42054393">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can redefine class definitions and function definitions on the fly in a Common Lisp program and other than the obvious overhead of invoking those things the whole system remains fast.<p>You can also treat Julia as C and recompile vtables on the fly.</div><br/></div></div></div></div></div></div><div id="42056206" class="c"><input type="checkbox" id="c-42056206" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052575">parent</a><span>|</span><a href="#42052634">prev</a><span>|</span><a href="#42051696">next</a><span>|</span><label class="collapse" for="c-42056206">[-]</label><label class="expand" for="c-42056206">[1 more]</label></div><br/><div class="children"><div class="content">&quot;hack together something in a day&quot; 
JPM Athena trading platform had 35 million lines of code in 2019
with about 20k commits a week</div><br/></div></div></div></div></div></div></div></div><div id="42051696" class="c"><input type="checkbox" id="c-42051696" checked=""/><div class="controls bullet"><span class="by">sneed_chucker</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42052340">prev</a><span>|</span><a href="#42051569">next</a><span>|</span><label class="collapse" for="c-42051696">[-]</label><label class="expand" for="c-42051696">[5 more]</label></div><br/><div class="children"><div class="content">If JavaScript (V8) and PyPy can be fast, then CPython can be fast too.<p>It&#x27;s just that the CPython developers and much of the Python community sat on their hands for 15 years and said stuff like &quot;performance isn&#x27;t a primary goal&quot; and &quot;speed doesn&#x27;t really matter since most workloads are IO-bound anyway&quot;.</div><br/><div id="42051757" class="c"><input type="checkbox" id="c-42051757" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051696">parent</a><span>|</span><a href="#42051569">next</a><span>|</span><label class="collapse" for="c-42051757">[-]</label><label class="expand" for="c-42051757">[4 more]</label></div><br/><div class="children"><div class="content">In this context, V8 and PyPy <i>aren&#x27;t</i> fast. Or at least, not generally; they may actually do well on this task because pure number tasks are the only things they can sometimes, as long as you don&#x27;t mess them up, get to compiled language-like performance. But they don&#x27;t in general to compiled language performance, despite common belief to the contrary.</div><br/><div id="42052692" class="c"><input type="checkbox" id="c-42052692" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051757">parent</a><span>|</span><a href="#42057493">next</a><span>|</span><label class="collapse" for="c-42052692">[-]</label><label class="expand" for="c-42052692">[1 more]</label></div><br/><div class="children"><div class="content">This gets into the whole &quot;fast for what purpose&quot; discussion. For many purposes, JavaScript is quite acceptably fast. But it isn&#x27;t C or Rust.</div><br/></div></div><div id="42057493" class="c"><input type="checkbox" id="c-42057493" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051757">parent</a><span>|</span><a href="#42052692">prev</a><span>|</span><a href="#42052225">next</a><span>|</span><label class="collapse" for="c-42057493">[-]</label><label class="expand" for="c-42057493">[1 more]</label></div><br/><div class="children"><div class="content">Do you have any objective evidence for that claim, or is this just you guessing?</div><br/></div></div><div id="42052225" class="c"><input type="checkbox" id="c-42052225" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051757">parent</a><span>|</span><a href="#42057493">prev</a><span>|</span><a href="#42051569">next</a><span>|</span><label class="collapse" for="c-42052225">[-]</label><label class="expand" for="c-42052225">[1 more]</label></div><br/><div class="children"><div class="content">Let&#x27;s make this more concrete because assigning speed to languages is a fools errand. Python is doing <i>a lot</i> more per line of code than compiled languages to enable its very flexible semantics. In cases where this flexibility is desired you won&#x27;t see much more performance in a compiled language as you&#x27;ll have just implemented Python-like semantics on top of your compiled language— GObject is a good example of this. More famously this is Greenspun&#x27;s tenth rule.<p>&gt; Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.<p>But where this flexibility isn&#x27;t required, which is a lot of performance sensitive number crunching code the cost of the flexibility bites you. You can&#x27;t &quot;turn it off&quot; when you want control down to the instruction for a truly massive performance win. Which is why I think the model Python has of highly expressive and flexible language backed by high-performance compiled libraries is so successful.<p>Python will never be number crunching or parsing with the best of them because it would require essentially a whole new language to express the low-level constraints but for high-level code that relies on Python&#x27;s semantics you can get performance wins that can&#x27;t be accomplished just by switching to a compiled language. We&#x27;ve just taken the &quot;embedded scripting language&quot; and made
it the primary interface.</div><br/></div></div></div></div></div></div><div id="42051569" class="c"><input type="checkbox" id="c-42051569" checked=""/><div class="controls bullet"><span class="by">the__alchemist</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42051696">prev</a><span>|</span><a href="#42051539">next</a><span>|</span><label class="collapse" for="c-42051569">[-]</label><label class="expand" for="c-42051569">[29 more]</label></div><br/><div class="children"><div class="content">This is a good question, and I think about it as well. My best guess for a <i>simple</i> explanation: Python is very popular; it makes sense to improve performance for python users, given many do not wish to learn to use a more performant language, or to use a more performant Python implementation. Becoming proficient in a range of tools so you can use the right one for the right job is high enough friction that it is not the path chosen by many.</div><br/><div id="42056210" class="c"><input type="checkbox" id="c-42056210" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051569">parent</a><span>|</span><a href="#42051606">next</a><span>|</span><label class="collapse" for="c-42056210">[-]</label><label class="expand" for="c-42056210">[2 more]</label></div><br/><div class="children"><div class="content">You should really add that Python is also a very good tool for people who know more performant languages. I think one of the sides which often gets forgotten is that a lot of software will never actually need to be very performant and often you’re not going to know the bottlenecks beforehand.
If you even get to the bottlenecks it means you’ve succeeded enough to get to the bottlenecks. Somewhere you might not have gotten if you over engineered things before you needed it.<p>What makes Python brilliant is that it’s easy to deliver on business needs. It’s easy to include people who aren’t actually software engineers but can write Python to do their stuff. It’s easy to make that Wild West code sane. Most importantly, however, it’s extremely easy to replace parts of your Python code with something like C (or Zig).<p>So even if you know performant languages, you can still use Python for most things and then as glue for heavy computation.<p>Now I may have made it sound like I think Python is brilliant so I’d like to add that I actually think it’s absolute trash. Loveable trash.</div><br/><div id="42056249" class="c"><input type="checkbox" id="c-42056249" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056210">parent</a><span>|</span><a href="#42051606">next</a><span>|</span><label class="collapse" for="c-42056249">[-]</label><label class="expand" for="c-42056249">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it’s extremely easy to replace parts of your Python code with something like C<p>I tend to use C++, so use SWIG [1] to make python code to interface with C++ (or C). You can <i>nearly</i> just give it a header file, and a python class pops out, with native types and interfaces. It&#x27;s really magical.<p>[1] <a href="https:&#x2F;&#x2F;www.swig.org" rel="nofollow">https:&#x2F;&#x2F;www.swig.org</a></div><br/></div></div></div></div><div id="42051606" class="c"><input type="checkbox" id="c-42051606" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051569">parent</a><span>|</span><a href="#42056210">prev</a><span>|</span><a href="#42051539">next</a><span>|</span><label class="collapse" for="c-42051606">[-]</label><label class="expand" for="c-42051606">[26 more]</label></div><br/><div class="children"><div class="content">Oh yeah, I totally get the motivation behind it. It&#x27;s always very tempting to want to make things faster. But I can&#x27;t help but wondering if these attempts to make it faster might end up just making it worse.<p>On the other hand though, Python is so big and there&#x27;s so many corps using it with so much cash that maybe they can get away with just breaking shit every few releases and people will just go adapt packages to the changes.</div><br/><div id="42051722" class="c"><input type="checkbox" id="c-42051722" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051606">parent</a><span>|</span><a href="#42051539">next</a><span>|</span><label class="collapse" for="c-42051722">[-]</label><label class="expand" for="c-42051722">[25 more]</label></div><br/><div class="children"><div class="content">Python famously has a community that does NOT adapt to changes well. See the Python 2 to 3 transition.</div><br/><div id="42052598" class="c"><input type="checkbox" id="c-42052598" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051722">parent</a><span>|</span><a href="#42051745">next</a><span>|</span><label class="collapse" for="c-42052598">[-]</label><label class="expand" for="c-42052598">[2 more]</label></div><br/><div class="children"><div class="content">That was, in many ways, a crazy difficult transition. I don&#x27;t think most languages have gone through such a thing. Perl tried and died. So I don&#x27;t agree that it reflects poorly on the community; I think the plan itself was too ambitious.</div><br/><div id="42053581" class="c"><input type="checkbox" id="c-42053581" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052598">parent</a><span>|</span><a href="#42051745">next</a><span>|</span><label class="collapse" for="c-42053581">[-]</label><label class="expand" for="c-42053581">[1 more]</label></div><br/><div class="children"><div class="content">Many languages have. There were significant breaks in C++ when stringabi changed, Swift has had major language changes, rust has editions.<p>The difference is in what motivates getting to the other end of that transition bump and how big the bump is. That’s why it took till past 2.7’s EOL to actually get people on to 3 in a big way because they’d drag their feet if they don’t see a big enough change.<p>Compiled languages have it easier because they don’t need to mix source between dependencies, they just have to be ABI compatible.</div><br/></div></div></div></div><div id="42051745" class="c"><input type="checkbox" id="c-42051745" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051722">parent</a><span>|</span><a href="#42052598">prev</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42051745">[-]</label><label class="expand" for="c-42051745">[20 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s community was significantly smaller and less flushed with cash during the 2 to 3 transition. Since then there has been numerous 3.x releases that were breaking and people seem to have been sucking it up and dealing with it quietly so far.<p>The main thing is that unlike the 2 to 3 transition, they&#x27;re not breaking syntax (for the most part?), which everyone experiences and has an opinion on, they&#x27;re breaking rather deep down things that for the most part only the big packages rely on so most users don&#x27;t experience it much at all.</div><br/><div id="42051815" class="c"><input type="checkbox" id="c-42051815" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051745">parent</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42051815">[-]</label><label class="expand" for="c-42051815">[19 more]</label></div><br/><div class="children"><div class="content">I disagree with this entire comment.<p>The Python community consisted of tons of developers including very wealthy companies. At what point in the last few years would you even say they became “rich enough” to do the migration? Because people are STILL talking about trying to fork 2.7 into a 2.8.<p>I also disagree with your assertion that 3.x releases have significant breaking changes.  Could you point to any specific major breaking changes between 3.x releases?<p>2 to 3 didn’t break syntax for most code either. It largely cleaned house on sensible API defaults.</div><br/><div id="42052582" class="c"><input type="checkbox" id="c-42052582" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051815">parent</a><span>|</span><a href="#42051959">next</a><span>|</span><label class="collapse" for="c-42052582">[-]</label><label class="expand" for="c-42052582">[3 more]</label></div><br/><div class="children"><div class="content"><i>Could you point to any specific major breaking changes between 3.x releases?</i><p>I can not, but I can tell you that anything AI often requires finding a proper combination of python + cuXXX + some library. And while I understand cu-implications, for some reason python version is also in this formula.<p>I literally have four python versions installed and removed from PATH, because if I delete 3.9-3.11, they will be needed next day again and there’s no meaningful default.</div><br/><div id="42053534" class="c"><input type="checkbox" id="c-42053534" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052582">parent</a><span>|</span><a href="#42051959">next</a><span>|</span><label class="collapse" for="c-42053534">[-]</label><label class="expand" for="c-42053534">[2 more]</label></div><br/><div class="children"><div class="content">Those are ABI changes and not changes to the language.</div><br/><div id="42055271" class="c"><input type="checkbox" id="c-42055271" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053534">parent</a><span>|</span><a href="#42051959">next</a><span>|</span><label class="collapse" for="c-42055271">[-]</label><label class="expand" for="c-42055271">[1 more]</label></div><br/><div class="children"><div class="content">If these were just ABI changes, packagers would simply re-package under a new ABI. Instead they specify ranges of versions in which &quot;it works&quot;. The upper end often doesn&#x27;t include the last python version and may be specified as &quot;up to 3.x.y&quot; even.<p>Sure I&#x27;m not that knowledgeable in this topic (in python). But you&#x27;re telling me they go to the lengths of supporting e.g. 3.9-3.11.2, but out of lazyness won&#x27;t just compile it to 3.12?<p>I can only hypothesize that 3.9-3.xxx had the same ABI and they don&#x27;t support multiple ABIs out of principle, but that sounds like a very strange idea.</div><br/></div></div></div></div></div></div><div id="42051959" class="c"><input type="checkbox" id="c-42051959" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051815">parent</a><span>|</span><a href="#42052582">prev</a><span>|</span><a href="#42052647">next</a><span>|</span><label class="collapse" for="c-42051959">[-]</label><label class="expand" for="c-42051959">[8 more]</label></div><br/><div class="children"><div class="content">Fair enough. You may be totally right here, as I mentioned I don&#x27;t use Python much at all since like 2017 and haven&#x27;t paid it much attention in a while. I retract my comment.<p>Regarding breakage in 3.x, all I know is that I recall several times where I did a linux system update (rolling release), and that updated my Python to a newly released version which broke various things in my system. I&#x27;m pretty sure one of these was v3.10, but I forget which others caused me problems which I could only solve by pinning Python to an older release.<p>It&#x27;s entirely possible though that no actual APIs were broken and that this was just accidentaly bugs in the release, or the packages were being naughty and relying on internals they shouldn&#x27;t have relied on or something else.</div><br/><div id="42052015" class="c"><input type="checkbox" id="c-42052015" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051959">parent</a><span>|</span><a href="#42052647">next</a><span>|</span><label class="collapse" for="c-42052015">[-]</label><label class="expand" for="c-42052015">[7 more]</label></div><br/><div class="children"><div class="content">To your last point: it’s neither the language nor the packages but rather it’s the ABI.<p>Python isn’t fully ABI stable (though it’s improved greatly) so you can’t just intermix compiled dependencies between different versions of Python.<p>This is true for many packages in your distro as well.</div><br/><div id="42052480" class="c"><input type="checkbox" id="c-42052480" checked=""/><div class="controls bullet"><span class="by">dbsmith83</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052015">parent</a><span>|</span><a href="#42052159">next</a><span>|</span><label class="collapse" for="c-42052480">[-]</label><label class="expand" for="c-42052480">[5 more]</label></div><br/><div class="children"><div class="content">There have been many breaking changes throughout python 3.x releases:<p>- standard library modules removed<p>- zip error handling behaves differently<p>- changes to collections module<p>- new reserved keywords (async, await, etc.)<p>You can argue how big of a deal it is or isn&#x27;t, but there were definitely breakages that violate semantic versioning</div><br/><div id="42056576" class="c"><input type="checkbox" id="c-42056576" checked=""/><div class="controls bullet"><span class="by">maleldil</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052480">parent</a><span>|</span><a href="#42052693">next</a><span>|</span><label class="collapse" for="c-42056576">[-]</label><label class="expand" for="c-42056576">[2 more]</label></div><br/><div class="children"><div class="content">Python doesn&#x27;t follow SemVer, that&#x27;s why.<p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-2026&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-2026&#x2F;</a></div><br/><div id="42057424" class="c"><input type="checkbox" id="c-42057424" checked=""/><div class="controls bullet"><span class="by">dbsmith83</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42056576">parent</a><span>|</span><a href="#42052693">next</a><span>|</span><label class="collapse" for="c-42057424">[-]</label><label class="expand" for="c-42057424">[1 more]</label></div><br/><div class="children"><div class="content">Clearly, which is what I was showing.  A poor design decision imo</div><br/></div></div></div></div><div id="42052693" class="c"><input type="checkbox" id="c-42052693" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052480">parent</a><span>|</span><a href="#42056576">prev</a><span>|</span><a href="#42052159">next</a><span>|</span><label class="collapse" for="c-42052693">[-]</label><label class="expand" for="c-42052693">[2 more]</label></div><br/><div class="children"><div class="content">They removed entire standard library modules? Wut.</div><br/><div id="42056125" class="c"><input type="checkbox" id="c-42056125" checked=""/><div class="controls bullet"><span class="by">heisenzombie</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052693">parent</a><span>|</span><a href="#42052159">next</a><span>|</span><label class="collapse" for="c-42056125">[-]</label><label class="expand" for="c-42056125">[1 more]</label></div><br/><div class="children"><div class="content">Yes, e.g. <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0594&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0594&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42052159" class="c"><input type="checkbox" id="c-42052159" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052015">parent</a><span>|</span><a href="#42052480">prev</a><span>|</span><a href="#42052647">next</a><span>|</span><label class="collapse" for="c-42052159">[-]</label><label class="expand" for="c-42052159">[1 more]</label></div><br/><div class="children"><div class="content">Ah I see. Yeah, I guess I just think that for a language that&#x27;s so dependent on FFI, instability in the ABI is defacto instability in the language as far as I&#x27;m concerned. But I understand that not everyone feels the same.<p>Almost every major noteworthy Python package uses the ABI, so instability there is going to constantly be felt ecosystem wide.</div><br/></div></div></div></div></div></div><div id="42052647" class="c"><input type="checkbox" id="c-42052647" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051815">parent</a><span>|</span><a href="#42051959">prev</a><span>|</span><a href="#42052681">next</a><span>|</span><label class="collapse" for="c-42052647">[-]</label><label class="expand" for="c-42052647">[2 more]</label></div><br/><div class="children"><div class="content">2 to 3 broke lots of code. Print became a function. Imports moved around. And there were subtle changes in the semantics of some things. Famously, strings changed, and that definitely affected a lot of packages.<p>Quite a bit of that could be fixed by automated tooling, but not all of it, and the testing burden was huge, which meant a lot of smaller packages did not convert very quickly and there were ripple effects.</div><br/><div id="42053545" class="c"><input type="checkbox" id="c-42053545" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052647">parent</a><span>|</span><a href="#42052681">next</a><span>|</span><label class="collapse" for="c-42053545">[-]</label><label class="expand" for="c-42053545">[1 more]</label></div><br/><div class="children"><div class="content">Yes 2 to 3 changed things. We’re discussing what changed in between different versions of 3.</div><br/></div></div></div></div><div id="42052681" class="c"><input type="checkbox" id="c-42052681" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051815">parent</a><span>|</span><a href="#42052647">prev</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42052681">[-]</label><label class="expand" for="c-42052681">[5 more]</label></div><br/><div class="children"><div class="content">Most of those are some old long deprecated things and in general those are all straight up improvements. Python is not my main thing so I&#x27;m not really good to answer this, but I listed a few that I am sure triggered errors in some code bases (I&#x27;m not saying they are all <i>major</i>). Python&#x27;s philosophy makes most of those pretty easy to handle, for example instead of foo now you have to be explicit and choose either foo_bar or foo_baz. For example in C there still is a completely bonkers function &#x27;gets&#x27; which is deprecated for a long time and it will be there probably for a long time as well. C standard library, Windows C API and Linux C API to large extent are add only, because things should stay bug-to-bug compatible. Python is not like that. This has its perks, but it may cause your old Python code to just not run. It may be easy to modify, but easy is significantly harder than nothing at all.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.3.html#porting-to-python-3-3" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.3.html#porting-to-pytho...</a><p>&gt; Hash randomization is enabled by default. Set the PYTHONHASHSEED environment variable to 0 to disable hash randomization. See also the object.__hash__() method.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.4.html#porting-to-python-3-4" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.4.html#porting-to-pytho...</a><p>&gt; The deprecated urllib.request.Request getter and setter methods add_data, has_data, get_data, get_type, get_host, get_selector, set_proxy, get_origin_req_host, and is_unverifiable have been removed (use direct attribute access instead).<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.5.html#porting-to-python-3-5" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.5.html#porting-to-pytho...</a><p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.6.html#removed" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.6.html#removed</a><p>&gt; All optional arguments of the dump(), dumps(), load() and loads() functions and JSONEncoder and JSONDecoder class constructors in the json module are now keyword-only. (Contributed by Serhiy Storchaka in bpo-18726.)<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.7.html#api-and-feature-removals" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.7.html#api-and-feature-...</a><p>&gt; Removed support of the exclude argument in tarfile.TarFile.add(). It was deprecated in Python 2.7 and 3.2. Use the filter argument instead.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.8.html#api-and-feature-removals" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.8.html#api-and-feature-...</a><p>&gt; The function time.clock() has been removed, after having been deprecated since Python 3.3: use time.perf_counter() or time.process_time() instead, depending on your requirements, to have well-defined behavior. (Contributed by Matthias Bussonnier in bpo-36895.)<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.9.html#removed" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.9.html#removed</a><p>&gt; array.array: tostring() and fromstring() methods have been removed. They were aliases to tobytes() and frombytes(), deprecated since Python 3.2. (Contributed by Victor Stinner in bpo-38916.)<p>&gt; Methods getchildren() and getiterator() of classes ElementTree and Element in the ElementTree module have been removed. They were deprecated in Python 3.2. Use iter(x) or list(x) instead of x.getchildren() and x.iter() or list(x.iter()) instead of x.getiterator(). (Contributed by Serhiy Storchaka in bpo-36543.)<p>&gt; The encoding parameter of json.loads() has been removed. As of Python 3.1, it was deprecated and ignored; using it has emitted a DeprecationWarning since Python 3.8. (Contributed by Inada Naoki in bpo-39377)<p>&gt; The asyncio.Task.current_task() and asyncio.Task.all_tasks() have been removed. They were deprecated since Python 3.7 and you can use asyncio.current_task() and asyncio.all_tasks() instead. (Contributed by Rémi Lapeyre in bpo-40967)<p>&gt; The unescape() method in the html.parser.HTMLParser class has been removed (it was deprecated since Python 3.4). html.unescape() should be used for converting character references to the corresponding unicode characters.<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.10.html#removed" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.10.html#removed</a><p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.11.html#removed" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.11.html#removed</a><p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.12.html#removed" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;whatsnew&#x2F;3.12.html#removed</a></div><br/><div id="42053597" class="c"><input type="checkbox" id="c-42053597" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42052681">parent</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42053597">[-]</label><label class="expand" for="c-42053597">[4 more]</label></div><br/><div class="children"><div class="content">Thanks. That’s a good list, though I think the majority of the changes were from deprecations early in the 3.x days and are API changes, whereas the OP was talking about syntax changes for the most part.</div><br/><div id="42054200" class="c"><input type="checkbox" id="c-42054200" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42053597">parent</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42054200">[-]</label><label class="expand" for="c-42054200">[3 more]</label></div><br/><div class="children"><div class="content">No I wasn&#x27;t?</div><br/><div id="42054288" class="c"><input type="checkbox" id="c-42054288" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42054200">parent</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42054288">[-]</label><label class="expand" for="c-42054288">[2 more]</label></div><br/><div class="children"><div class="content">Maybe i misunderstood your argument here where you scope it tightly to syntax changes being an issue but internal changes being fine.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42051745">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42051745</a></div><br/><div id="42054788" class="c"><input type="checkbox" id="c-42054788" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42054288">parent</a><span>|</span><a href="#42051761">next</a><span>|</span><label class="collapse" for="c-42054788">[-]</label><label class="expand" for="c-42054788">[1 more]</label></div><br/><div class="children"><div class="content">What I meant by that is that because the changes mostly aren&#x27;t syntax changes, they won&#x27;t upset most users who are just using big packages that are actively maintained and keeping ahead of the breakage.<p>But I still find the high level of instability in Python land rather disturbing, and I would be unhappy if the languages I used constantly did these sorts of breaking changes<p>I&#x27;m even more extreme in that I also think the ABI instability is bad. Even though Python gives no guarantee of its stability, it&#x27;s used by so many people it seems like a bad thing to constantly break and it probably <i>should</i> be stabilized.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42051761" class="c"><input type="checkbox" id="c-42051761" checked=""/><div class="controls bullet"><span class="by">Yossarrian22</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051722">parent</a><span>|</span><a href="#42051745">prev</a><span>|</span><a href="#42051539">next</a><span>|</span><label class="collapse" for="c-42051761">[-]</label><label class="expand" for="c-42051761">[2 more]</label></div><br/><div class="children"><div class="content">Are there communities that handle such a change well? At least that went better than Perl and Raku</div><br/><div id="42051839" class="c"><input type="checkbox" id="c-42051839" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051761">parent</a><span>|</span><a href="#42051539">next</a><span>|</span><label class="collapse" for="c-42051839">[-]</label><label class="expand" for="c-42051839">[1 more]</label></div><br/><div class="children"><div class="content">Anything where the language frontend isn’t tied to the ABI compatibility of the artifacts I think. They can mix versions&#x2F;editions without worry.<p>I think it’s a larger problem with interpreted languages where all the source has to be in a single version. In that case I cant think of much.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42051539" class="c"><input type="checkbox" id="c-42051539" checked=""/><div class="controls bullet"><span class="by">willvarfar</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42051569">prev</a><span>|</span><a href="#42056530">next</a><span>|</span><label class="collapse" for="c-42051539">[-]</label><label class="expand" for="c-42051539">[4 more]</label></div><br/><div class="children"><div class="content">(As a happy pypy user in previous jobs, I want to chime in and say python _can_ be fast.<p>It can be so fast that it completely mooted the discussions that often happen when wanting to move from a python prototype to &#x27;fast enough for production&#x27;.)</div><br/><div id="42051587" class="c"><input type="checkbox" id="c-42051587" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051539">parent</a><span>|</span><a href="#42056530">next</a><span>|</span><label class="collapse" for="c-42051587">[-]</label><label class="expand" for="c-42051587">[3 more]</label></div><br/><div class="children"><div class="content">PyPy is still slow compared to actual fast languages. It&#x27;s just fast compared to Python, <i>and</i> it achieves that speed by not being compatible with most of the Python ecosystem.<p>Seems like a lose-lose to me. (which is presumably why it never caught on)</div><br/><div id="42051657" class="c"><input type="checkbox" id="c-42051657" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051587">parent</a><span>|</span><a href="#42056530">next</a><span>|</span><label class="collapse" for="c-42051657">[-]</label><label class="expand" for="c-42051657">[2 more]</label></div><br/><div class="children"><div class="content">What isn&#x27;t compatible with PyPy? I can run large frameworks using pypy no problem. There certainly will be package that aren&#x27;t compatible. But far and away most of the ecosystem is fully comaptible.</div><br/><div id="42055907" class="c"><input type="checkbox" id="c-42055907" checked=""/><div class="controls bullet"><span class="by">artemisart</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051657">parent</a><span>|</span><a href="#42056530">next</a><span>|</span><label class="collapse" for="c-42055907">[-]</label><label class="expand" for="c-42055907">[1 more]</label></div><br/><div class="children"><div class="content">This depends a lot on your domain, e.g. pypy is not compatible with pytorch or tensorflow so DL is out of the picture.</div><br/></div></div></div></div></div></div></div></div><div id="42056530" class="c"><input type="checkbox" id="c-42056530" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42051539">prev</a><span>|</span><a href="#42052747">next</a><span>|</span><label class="collapse" for="c-42056530">[-]</label><label class="expand" for="c-42056530">[1 more]</label></div><br/><div class="children"><div class="content">As a Java dev I think people don’t always appreciate the flexiblity of threads for manage parallelism, concurrency, and memory.  In particular with threads you can have a large number of thread share a large data structure.  Say you have an ML inference model that takes 1GB of RAM.  No way can you let 25 Celery workers each have a copy of that model, so if you are using Python you have to introduce a special worker class.  It’s one more thing to worry about and more parameters to tune.  With Java all your “workers” could be in one process, even the same process as your web server and that will be the case in Python.<p>Threads break down so many bottlenecks of CPU resources, memory, data serialization, waiting for communications, etc.  I have a 16-core computer on my desk and getting a 12x speed-up is possible for many jobs and often worth worse less efficient use of the individual CPU.  Java has many primitives for threads that include tools for specialized communications (e.g. barrier synchronization) that are necessary to really get those speed-ups and I hope Python gets those too.</div><br/></div></div><div id="42052747" class="c"><input type="checkbox" id="c-42052747" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42056530">prev</a><span>|</span><a href="#42056975">next</a><span>|</span><label class="collapse" for="c-42052747">[-]</label><label class="expand" for="c-42052747">[1 more]</label></div><br/><div class="children"><div class="content">You may be right. I personally think this work is net beneficial, and although I never expected to be in MP or threads, I now find doing a lot of DNS (processing end of day logs of 300m records per day, trying to farm them out over public DNS resolvers doing multiple RR checks per FQDN) that the MP efficiency is lower than threads, because of this serialisation cost. So, improving threading has shown me I could be 4-5x faster in this solution space, IFF I learn how to use the thread.lock to gatekeep updates on the shared structures.<p>My alternative is to serialise in heavy processes and then incur a post process unification pass, because the cost of serialise send&#x2F;receive deserialise to unify this stuff is too much. If somebody showed me how to use shm models to do this so it came back to the cost of threading.lock I&#x27;d do the IPC over a shared memory dict, but I can&#x27;t find examples and now suspect multiprocessing in Python3 just doesn&#x27;t do that (happy, delighted even to be proved wrong)</div><br/></div></div><div id="42056975" class="c"><input type="checkbox" id="c-42056975" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42052747">prev</a><span>|</span><a href="#42051548">next</a><span>|</span><label class="collapse" for="c-42056975">[-]</label><label class="expand" for="c-42056975">[1 more]</label></div><br/><div class="children"><div class="content">I think the reasoning is like this:<p>- People choose Python to get ease of programming, knowing that they give up performance.<p>- With multi-core machines now the norm, they’re relatively giving up more performance to get the same amount of ease of programming.<p>- so, basically, the price of ease of programming has gone up.<p>- economics 101 is that rising prices will decrease demand, in this case demand for programming in Python.<p>- that may be problematic for the long-term survival of Python, especially with new other languages aiming to provide python’s ease of use while supporting multi-processing.<p>So, Python must get even easier to use and&#x2F;or it must get faster.</div><br/></div></div><div id="42051548" class="c"><input type="checkbox" id="c-42051548" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42056975">prev</a><span>|</span><a href="#42053185">next</a><span>|</span><label class="collapse" for="c-42051548">[-]</label><label class="expand" for="c-42051548">[2 more]</label></div><br/><div class="children"><div class="content">Python 3.12 will be officially supported until October 2028, so there&#x27;s plenty of time to migrate to no-GIL if anyone wants to.</div><br/><div id="42051583" class="c"><input type="checkbox" id="c-42051583" checked=""/><div class="controls bullet"><span class="by">zurfer</span><span>|</span><a href="#42051523">root</a><span>|</span><a href="#42051548">parent</a><span>|</span><a href="#42053185">next</a><span>|</span><label class="collapse" for="c-42051583">[-]</label><label class="expand" for="c-42051583">[1 more]</label></div><br/><div class="children"><div class="content">Python 3.13 is not removing the GIL. You just have an option to run without it.</div><br/></div></div></div></div><div id="42053185" class="c"><input type="checkbox" id="c-42053185" checked=""/><div class="controls bullet"><span class="by">emgeee</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42051548">prev</a><span>|</span><a href="#42052980">next</a><span>|</span><label class="collapse" for="c-42053185">[-]</label><label class="expand" for="c-42053185">[1 more]</label></div><br/><div class="children"><div class="content">One area where this absolutely makes a difference is when embedding python. Like it or not Python is extreme popular in data&#x2F;AI&#x2F;ML so if you want to build an experience where users can deploy custom functions, removing the GIL allows you to more efficiently scale these workloads.</div><br/></div></div><div id="42052980" class="c"><input type="checkbox" id="c-42052980" checked=""/><div class="controls bullet"><span class="by">runeblaze</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42053185">prev</a><span>|</span><a href="#42056422">next</a><span>|</span><label class="collapse" for="c-42052980">[-]</label><label class="expand" for="c-42052980">[1 more]</label></div><br/><div class="children"><div class="content">For machine learning (un)fortunately, lots of the stack runs on Python. Lots of ceremony was done to circumvent GIL (e.g. PyTorch data loader). “Reasonable performance Python” I imagine is actually something in huge demand for lots of ML shops</div><br/></div></div><div id="42056422" class="c"><input type="checkbox" id="c-42056422" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42052980">prev</a><span>|</span><a href="#42053380">next</a><span>|</span><label class="collapse" for="c-42056422">[-]</label><label class="expand" for="c-42056422">[1 more]</label></div><br/><div class="children"><div class="content">Given the scale at which python is run, how much energy are we saving by improving its performance by 1%?</div><br/></div></div><div id="42053380" class="c"><input type="checkbox" id="c-42053380" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42056422">prev</a><span>|</span><a href="#42051974">next</a><span>|</span><label class="collapse" for="c-42053380">[-]</label><label class="expand" for="c-42053380">[1 more]</label></div><br/><div class="children"><div class="content">Since Python has become the new Lisp, the minimum is to have the performance tooling Common Lisp has had for several decades, in native code generation and multithreading (yes I know that in CL this is implementation specific).</div><br/></div></div><div id="42051974" class="c"><input type="checkbox" id="c-42051974" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42053380">prev</a><span>|</span><a href="#42051833">next</a><span>|</span><label class="collapse" for="c-42051974">[-]</label><label class="expand" for="c-42051974">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really get this. They have already made Python faster in the past while maintaining the same semantics. Seems like a good goal to me.</div><br/></div></div><div id="42051833" class="c"><input type="checkbox" id="c-42051833" checked=""/><div class="controls bullet"><span class="by">yunohn</span><span>|</span><a href="#42051523">parent</a><span>|</span><a href="#42051974">prev</a><span>|</span><a href="#42053094">next</a><span>|</span><label class="collapse" for="c-42051833">[-]</label><label class="expand" for="c-42051833">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I guess getting loops in Python to run 5-10x faster will still save some people time<p>I would recommend being less reductively dismissive, after claiming you “don’t really have a dog in this race”.<p>Edit: Lots of recent changes have done way more than just loop unrolling JIT stuff.</div><br/></div></div></div></div><div id="42053094" class="c"><input type="checkbox" id="c-42053094" checked=""/><div class="controls bullet"><span class="by">Decabytes</span><span>|</span><a href="#42051523">prev</a><span>|</span><a href="#42051733">next</a><span>|</span><label class="collapse" for="c-42053094">[-]</label><label class="expand" for="c-42053094">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad the Python community is focusing more on CPython&#x27;s performance. Getting speed ups on existing code for free feels great. As much as I hate how slow Python is, I do think its popularity indicates it made the correct tradeoffs in regards to developer ease vs being fast enough.<p>Learning it has only continued to be a huge benefit to my career, as it&#x27;s used everywhere which underlies how important popularity of a language can be for developers when evaluating languages for career choices</div><br/></div></div><div id="42051733" class="c"><input type="checkbox" id="c-42051733" checked=""/><div class="controls bullet"><span class="by">ijl</span><span>|</span><a href="#42053094">prev</a><span>|</span><a href="#42057509">next</a><span>|</span><label class="collapse" for="c-42051733">[-]</label><label class="expand" for="c-42051733">[2 more]</label></div><br/><div class="children"><div class="content">Performance for python3.14t alpha 1 is more like 3.11 in what I&#x27;ve tested. Not good enough if Python doesn&#x27;t meet your needs, but this comes after 3.12 and 3.13 have both performed worse for me.<p>3.13t doesn&#x27;t seem to have been meant for any serious use. Bugs in gc and so on are reported, and not all fixes will be backported apparently. And 3.14t still has unavoidable crashes. Just too early.</div><br/><div id="42053505" class="c"><input type="checkbox" id="c-42053505" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#42051733">parent</a><span>|</span><a href="#42057509">next</a><span>|</span><label class="collapse" for="c-42053505">[-]</label><label class="expand" for="c-42053505">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 3.13t doesn&#x27;t seem to have been meant for any serious use.<p>I don&#x27;t think anyone would suggest using it in production. The point was to put something usable out into the world so package maintainers could kick the tires and start working on building compatible versions. Now is exactly the time for weird bug reports! It&#x27;s a thirty year old runtime and one of its oldest constraints is being removed!</div><br/></div></div></div></div><div id="42057509" class="c"><input type="checkbox" id="c-42057509" checked=""/><div class="controls bullet"><span class="by">aitchnyu</span><span>|</span><a href="#42051733">prev</a><span>|</span><a href="#42052796">next</a><span>|</span><label class="collapse" for="c-42057509">[-]</label><label class="expand" for="c-42057509">[1 more]</label></div><br/><div class="children"><div class="content">Are there web frameworks taking advantage of subinterpreters and free threading yet?</div><br/></div></div><div id="42052796" class="c"><input type="checkbox" id="c-42052796" checked=""/><div class="controls bullet"><span class="by">runjake</span><span>|</span><a href="#42057509">prev</a><span>|</span><a href="#42056592">next</a><span>|</span><label class="collapse" for="c-42052796">[-]</label><label class="expand" for="c-42052796">[3 more]</label></div><br/><div class="children"><div class="content">If it were ever open sourced, I could see Mojo filling the performance niche for Python programmers. I&#x27;m hopeful because Lattner certainly has the track record, if he doesn&#x27;t move on beforehand.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mojo_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mojo_(programming_language)</a></div><br/><div id="42056216" class="c"><input type="checkbox" id="c-42056216" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#42052796">parent</a><span>|</span><a href="#42056592">next</a><span>|</span><label class="collapse" for="c-42056216">[-]</label><label class="expand" for="c-42056216">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo&#x2F;blob&#x2F;main&#x2F;LICENSE">https:&#x2F;&#x2F;github.com&#x2F;modularml&#x2F;mojo&#x2F;blob&#x2F;main&#x2F;LICENSE</a></div><br/><div id="42057543" class="c"><input type="checkbox" id="c-42057543" checked=""/><div class="controls bullet"><span class="by">kaanyalova</span><span>|</span><a href="#42052796">root</a><span>|</span><a href="#42056216">parent</a><span>|</span><a href="#42056592">next</a><span>|</span><label class="collapse" for="c-42057543">[-]</label><label class="expand" for="c-42057543">[1 more]</label></div><br/><div class="children"><div class="content">The source code for the compiler hasn&#x27;t released yet</div><br/></div></div></div></div></div></div><div id="42056592" class="c"><input type="checkbox" id="c-42056592" checked=""/><div class="controls bullet"><span class="by">the5avage</span><span>|</span><a href="#42052796">prev</a><span>|</span><a href="#42056778">next</a><span>|</span><label class="collapse" for="c-42056592">[-]</label><label class="expand" for="c-42056592">[6 more]</label></div><br/><div class="children"><div class="content">Can someone share insight into what was technically done to enable this? What replaced the global lock? Is the GC stopping all threads during collection or an other locking mechanism?</div><br/><div id="42056616" class="c"><input type="checkbox" id="c-42056616" checked=""/><div class="controls bullet"><span class="by">nas</span><span>|</span><a href="#42056592">parent</a><span>|</span><a href="#42056780">next</a><span>|</span><label class="collapse" for="c-42056616">[-]</label><label class="expand" for="c-42056616">[4 more]</label></div><br/><div class="children"><div class="content">The key enabling tech is thread safe reference counting. There are many other problems that Sam Gross solved in order to make it happen but the reference counting was one of the major blockers.</div><br/><div id="42057032" class="c"><input type="checkbox" id="c-42057032" checked=""/><div class="controls bullet"><span class="by">the5avage</span><span>|</span><a href="#42056592">root</a><span>|</span><a href="#42056616">parent</a><span>|</span><a href="#42056780">next</a><span>|</span><label class="collapse" for="c-42057032">[-]</label><label class="expand" for="c-42057032">[3 more]</label></div><br/><div class="children"><div class="content">Is this implemented with lockless programming? Is it a reason for the performance drop in single thread code?<p>Does it eliminate the need for a GC pause completely?</div><br/><div id="42057401" class="c"><input type="checkbox" id="c-42057401" checked=""/><div class="controls bullet"><span class="by">nas</span><span>|</span><a href="#42056592">root</a><span>|</span><a href="#42057032">parent</a><span>|</span><a href="#42056780">next</a><span>|</span><label class="collapse" for="c-42057401">[-]</label><label class="expand" for="c-42057401">[2 more]</label></div><br/><div class="children"><div class="content">You should probably just read the PEP, which explains these things:<p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#reference-counting" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#reference-counting</a><p>If by GC you mean the cyclic GC, free-threaded Python currently stops all threads while the cyclic GC is running.</div><br/><div id="42057615" class="c"><input type="checkbox" id="c-42057615" checked=""/><div class="controls bullet"><span class="by">the5avage</span><span>|</span><a href="#42056592">root</a><span>|</span><a href="#42057401">parent</a><span>|</span><a href="#42056780">next</a><span>|</span><label class="collapse" for="c-42057615">[-]</label><label class="expand" for="c-42057615">[1 more]</label></div><br/><div class="children"><div class="content">Thank you:)</div><br/></div></div></div></div></div></div></div></div><div id="42056780" class="c"><input type="checkbox" id="c-42056780" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#42056592">parent</a><span>|</span><a href="#42056616">prev</a><span>|</span><a href="#42056778">next</a><span>|</span><label class="collapse" for="c-42056780">[-]</label><label class="expand" for="c-42056780">[1 more]</label></div><br/><div class="children"><div class="content">Lots of little locks littered all over the place.</div><br/></div></div></div></div><div id="42056778" class="c"><input type="checkbox" id="c-42056778" checked=""/><div class="controls bullet"><span class="by">0xDEADFED5</span><span>|</span><a href="#42056592">prev</a><span>|</span><a href="#42056285">next</a><span>|</span><label class="collapse" for="c-42056778">[-]</label><label class="expand" for="c-42056778">[1 more]</label></div><br/><div class="children"><div class="content">Nice benchmarks.  Hopefully some benevolent soul with more spare time than I can pitch in on threadsafe CFFI</div><br/></div></div><div id="42056285" class="c"><input type="checkbox" id="c-42056285" checked=""/><div class="controls bullet"><span class="by">biglost</span><span>|</span><a href="#42056778">prev</a><span>|</span><a href="#42051214">next</a><span>|</span><label class="collapse" for="c-42056285">[-]</label><label class="expand" for="c-42056285">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not smart nor have any university title butmy opinion is this it&#x27;s very good, but efforts should also go into remove features, not just python, i get it, it would breake anything.</div><br/></div></div></div></div></div></div></div></body></html>