<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714726863964" as="style"/><link rel="stylesheet" href="styles.css?v=1714726863964"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.funcall.org//lisp%20psychoacoustics/2024/05/01/worlds-loudest-lisp-program/">The world&#x27;s loudest Lisp program to the rescue</a> <span class="domain">(<a href="https://blog.funcall.org">blog.funcall.org</a>)</span></div><div class="subtext"><span>kryptiskt</span> | <span>67 comments</span></div><br/><div><div id="40243063" class="c"><input type="checkbox" id="c-40243063" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40241281">next</a><span>|</span><label class="collapse" for="c-40243063">[-]</label><label class="expand" for="c-40243063">[26 more]</label></div><br/><div class="children"><div class="content">This is a really cool story!<p>Perhaps a slight segue, but I recently tried to learn CL for the first time and I was genuinely surprised by all the decades of accumulated cruft (mainly masses of semi-redundant and soft-depreciated standard library functions, with bizarre names). The way people talk about Lisp, I&#x27;d expected something more elegant. I suppose I should try something like Scheme or Racket, but it&#x27;s hard to find an introduction to those that isn&#x27;t bone dry. (Recommendations welcome!)<p>I&#x27;ve also heard people say reading Lisp functions, inside out, ensconced (heya) in their parentheses, is somehow more comprehensible than sequential C style, but this state of enlightenment thus far eludes me. I can only speak for myself, but I definitely reason about code outside in rather than inside out.</div><br/><div id="40244937" class="c"><input type="checkbox" id="c-40244937" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40245527">next</a><span>|</span><label class="collapse" for="c-40244937">[-]</label><label class="expand" for="c-40244937">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve also heard people say reading Lisp functions, inside out, ensconced (heya) in their parentheses, is somehow more comprehensible than sequential C style, but this state of enlightenment thus far eludes me. I can only speak for myself, but I definitely reason about code outside in rather than inside out.<p>Based on my years tutoring university students in various programming languages throughout their courses, I suspect some of this is personal preference that&#x27;s set before one starts programming.<p>Some people who start with C-style languages find Lisp-style languages more intuitive, while some people who start with Lisp-style languages breathe a sigh of relief when they discover C-style languages. I haven&#x27;t found any predictor of this ahead of time – as far as I can tell it&#x27;s just something one discovers as one tries different languages.</div><br/><div id="40245248" class="c"><input type="checkbox" id="c-40245248" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40244937">parent</a><span>|</span><a href="#40245527">next</a><span>|</span><label class="collapse" for="c-40245248">[-]</label><label class="expand" for="c-40245248">[1 more]</label></div><br/><div class="children"><div class="content">As I posted on the &quot;cognition&quot; lexer thread, some users prefer &quot;left handed scissors&quot;. Just as it is not equally intuitive for everyone to write with a particular hand, it is not equally intuitive for everyone to program with a particular language.</div><br/></div></div></div></div><div id="40245527" class="c"><input type="checkbox" id="c-40245527" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40244937">prev</a><span>|</span><a href="#40245385">next</a><span>|</span><label class="collapse" for="c-40245527">[-]</label><label class="expand" for="c-40245527">[1 more]</label></div><br/><div class="children"><div class="content">On thing to keep in mind when you see the language, which evolved of several decades: it has low-level (go to, ...), mid-level (macros, ...) and high-level (CLOS + MOP) elements in one language. A reason for that: the low-level parts are   code generation building blocks for the higher level parts. Example: The SERIES library (a  higher-level way to think about loops and sequences) uses macros (mid-level) to transform code into efficient loops (-&gt; low-level): <a href="https:&#x2F;&#x2F;github.com&#x2F;rtoy&#x2F;cl-series">https:&#x2F;&#x2F;github.com&#x2F;rtoy&#x2F;cl-series</a><p>So one reason for all this functionality is: the language is its own compilation target. One is not supposed to write all the code, but we can write code which writes the lower-level code.</div><br/></div></div><div id="40245385" class="c"><input type="checkbox" id="c-40245385" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40245527">prev</a><span>|</span><a href="#40243255">next</a><span>|</span><label class="collapse" for="c-40245385">[-]</label><label class="expand" for="c-40245385">[1 more]</label></div><br/><div class="children"><div class="content">Have you seen <a href="https:&#x2F;&#x2F;stevelosh.com&#x2F;blog&#x2F;2018&#x2F;08&#x2F;a-road-to-common-lisp&#x2F;" rel="nofollow">https:&#x2F;&#x2F;stevelosh.com&#x2F;blog&#x2F;2018&#x2F;08&#x2F;a-road-to-common-lisp&#x2F;</a> ? &quot;Kludges&quot; everywhere is applicable. On the other hand, having a function like &quot;row-major-aref&quot; that allows accessing any multi-dimensional array as if it were one dimensional is &quot;sweeter than the honeycomb&quot;.<p>I still think CL code can be beautiful. Norvig&#x27;s in PAIP <a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp</a> is nice.<p>As for the inside-out remark, while technically you do it for even basic syntax, you don&#x27;t always exactly have to, and it&#x27;s very convenient to not do. Clojure has its semi-famous arrow macro that lets you write things in a more sequential style, it exists in CL too, and there&#x27;s always the venerable let* binding. e.g. 3 options:<p><pre><code>    (loop (print (eval (read))))
    (-&gt; (read) (eval) (print) (loop))
    (loop
      (let* ((r (read))
             (e (eval r)))
        (print e)))
</code></pre>
And even the first one isn&#x27;t that bad to read. For the really annoying cases like a lot of arithmetic, just use the reader macro from the 90s that lets you write in infix mode rather than complain how the quadratic equation is harder to read in prefix notation.</div><br/></div></div><div id="40243255" class="c"><input type="checkbox" id="c-40243255" checked=""/><div class="controls bullet"><span class="by">hickelpickle</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40245385">prev</a><span>|</span><a href="#40244301">next</a><span>|</span><label class="collapse" for="c-40243255">[-]</label><label class="expand" for="c-40243255">[8 more]</label></div><br/><div class="children"><div class="content">Little schemer is good, some people hate it some people love it. But it is a fairly light read the slowly teaches some syntax at a time, questions you about assumptions then revels the information as it goes on. It would be the least dry read. There is also sketchy scheme for a more thorough text, or even the rs7s standard, which are both pretty dry but short.<p>What made me appreciate scheme was watching some of the SICP lectures (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2Op3QLzMgSY&amp;list=PL8FE88AA54363BC46&amp;index=1" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2Op3QLzMgSY&amp;list=PL8FE88AA54...</a>) and the little schemer to learn more. I also read some of the SICP along with it, though I put it down due to not having the time to work through it.<p>Scheme is interesting and toying with recursion is fun, but the path a mentioned above is only really enjoyable if you are looking to toy around with CS concepts and recursion. You can do a lot more in modern scheme as well, and you can build anything out of CL. But learning the basics of scheme&#x2F;lisp is can be pretty dry if you are just looking to build something right away like you already can in a traditional imperative language. But it is interesting if you are interested in a different perspective. But even RS7S scheme is still far from the batteries included you get with CL.<p>I personal found the most enjoyment using Kawa scheme, which is jvm based and using it for scripting with java programs as it has great interop. I used it some for a game back end in the event system to be able to emit events while developing and script behaviors, I&#x27;ve also used it for configurations as well with a graphical terminal app, I used hooks into the ascii display&#x2F;table libraries then kawa to configure the tables&#x2F;outputs and how to format the data.</div><br/><div id="40243410" class="c"><input type="checkbox" id="c-40243410" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243255">parent</a><span>|</span><a href="#40244301">next</a><span>|</span><label class="collapse" for="c-40243410">[-]</label><label class="expand" for="c-40243410">[7 more]</label></div><br/><div class="children"><div class="content">Interesting, thank you!<p>I suppose what draws me to Lisp is that insight people say it gives them on programming. I already do much of my programming in functional style, so I&#x27;m trying to discover what it is about Lisp that&#x27;s so beloved above and beyond that - I&#x27;m gathering it&#x27;s a mix of recursion and the pleasantness of being able to get &#x27;inside&#x27; the program, so to speak, with a REPL?<p>I must also admit that I tend to run into a bit of a roadblock over Lisp&#x27;s apparent view that programming is, or should be, or should look like, maths. I cut my teeth on assembly, so for me programming isn&#x27;t maths, but giving instructions to silicon, where that silicon is only somewhat loosely based on maths. It tends to make me bounce off Lisp resources which by Chapter 2 are trying to show the advantages of Lisp by implementing some arcane algorithm with tail-end recursion.* But I&#x27;m very open to being persuaded I&#x27;m missing the bigger picture here, hence my ongoing effort to grok Lisp.<p>(*Isn&#x27;t tail-end recursion just an obfuscated goto?)</div><br/><div id="40245565" class="c"><input type="checkbox" id="c-40245565" checked=""/><div class="controls bullet"><span class="by">MarceColl</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243410">parent</a><span>|</span><a href="#40243939">next</a><span>|</span><label class="collapse" for="c-40245565">[-]</label><label class="expand" for="c-40245565">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp is not a functional programming language in most current definition of the word. It&#x27;s as procedural as they come, then libraries on top build other paradigms.<p>Scheme tends to approach things more math-like. While common lisp is less academic and more practical.</div><br/></div></div><div id="40243939" class="c"><input type="checkbox" id="c-40243939" checked=""/><div class="controls bullet"><span class="by">Tevo</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243410">parent</a><span>|</span><a href="#40245565">prev</a><span>|</span><a href="#40245377">next</a><span>|</span><label class="collapse" for="c-40243939">[-]</label><label class="expand" for="c-40243939">[3 more]</label></div><br/><div class="children"><div class="content">&gt;recursion<p>I think one of the reasons recursion is often emphasized in relation to Lisp is because one of Lisp&#x27;s core data structures, the linked list, can be defined inductively, and thus lends itself well to transformations expressed recursively (since they follow the structure of the data to the letter). But recursion in itself isn&#x27;t something particularly special. Though it is more general than loops, and so it is nice to have some grasp on it, and how looping and iteration relate to each other, and it is often easier to reason about a problem in terms of a base case and a recursive case rather than a loop, at a higher level you will usually come to find bare recursion mostly counterproductive. You want to abstract it out, such that you can then compose your data transformations out of higher level operations which you can pick and match at will, APL-style. Think reductions, onto which you build mappings and filters and groupings and scans and whichever odd transformations one could devise, at which point recursion isn&#x27;t much more than an implementation detail. This is about collections, but anything inductive would follow a similar pattern. Most functional languages will edge you towards the latter, and I find Lisp won&#x27;t particularly, unless you actively seek it out (though Clojure encourages it most explicitly, if you consider that a Lisp).<p>&gt;the pleasantness of being able to get &#x27;inside&#x27; the program<p>Indeed, that&#x27;s one of the things makes Common Lisp in specific particularly great (and it is something other contemporary dialects seem to miss, to varying degrees). It lets you sit within your program and sculpt it from the inside, in a Smalltalk sort of way, and the whole language is designed towards that. Pervasive late-binding means redefining mostly anything takes effect pretty much immediately, not having to bother recompiling or reloading anything else depending on it. The object system specifies things such as class redefinitions and instance morphing and dependencies and so on, such that you can start with a simple class definition, then go on to to interactively add or remove slots, or play with the inheritance chain, and have all of the existing instances just do the right thing, most of the time. Many provided functions that let you poke and prod the state of your image don&#x27;t make much sense outside of an interactive environment.<p>There is a point to be made about abstraction, maths, and giving instructions to silicon (and metaprogramming!), but I&#x27;ll have to pass for now. I apologize if this is too rambly, I tend to get verbose when tired.</div><br/><div id="40245324" class="c"><input type="checkbox" id="c-40245324" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243939">parent</a><span>|</span><a href="#40244024">next</a><span>|</span><label class="collapse" for="c-40245324">[-]</label><label class="expand" for="c-40245324">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think one of the reasons recursion is often emphasized in relation to Lisp is because one of Lisp&#x27;s core data structures, the linked list, can be defined inductively<p>Lisp was used in computer science education to teach &quot;recursion&quot;. We are not talking about software engineering, but learning new ways to think about programming. That can be seen in SICP, which is not a Lisp&#x2F;Scheme text, but a computer science education book, teaching students ways to think, from the basics upwards.<p>Personally I would not use recursion in programs everywhaere, unless the recursive solution is somewhat easier to think about. Typically I would use a higher order function or some extended loop construct.</div><br/></div></div><div id="40244024" class="c"><input type="checkbox" id="c-40244024" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243939">parent</a><span>|</span><a href="#40245324">prev</a><span>|</span><a href="#40245377">next</a><span>|</span><label class="collapse" for="c-40244024">[-]</label><label class="expand" for="c-40244024">[1 more]</label></div><br/><div class="children"><div class="content">Not at all too rambly, very interesting, thank you. Your answer makes intuitive sense to me; I&#x27;ll ponder over it.</div><br/></div></div></div></div><div id="40245377" class="c"><input type="checkbox" id="c-40245377" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243410">parent</a><span>|</span><a href="#40243939">prev</a><span>|</span><a href="#40245157">next</a><span>|</span><label class="collapse" for="c-40245377">[-]</label><label class="expand" for="c-40245377">[1 more]</label></div><br/><div class="children"><div class="content">There are a bunch of things to learn from Lisp:<p>* list processing -&gt; model data as lists and process those<p>* list processing applied to Lisp -&gt; model programs as lists and process those -&gt; EVAL and COMPILE<p>* EVAL, the interpreter as a Lisp program<p>* write programs to process programs -&gt; code generators, macros, ...<p>* write programs in a more declarative way -&gt; a code generator transforms the description into working code -&gt; embedded domain specific language<p>* interactive software development -&gt; bottom up programming, prototyping, interactive error handling, evolving programs, ...<p>and so on...<p>The pioneering things of Lisp from the end 50s &#x2F; early 60s: list processing, automatic memory management (garbage collection), symbol expressions, programming with recursive procedures, higher order procedures, interactive development with a Read Eval Print Loop, the EVAL interpreter for Lisp in  Lisp, the compiler for Lisp in Lisp, native code generation and code loading, saving&#x2F;starting program state (the &quot;image&quot;), macros for code transformations, embedded languages, ...<p>That&#x27;s was a lot of stuff, which has found its way into many languages and is now a part of what many people use. Example: Garbage Collection now is naturally a part of infrastructure, like .net or languages like Java and JavaScript. It had its roots in Lisp, because the need arose to process dynamic lists in complex programs, getting rid of the burden of manual memory management. Lisp got a mark &amp; sweep garbage collector. That&#x27;s why we say Lisp is not invented but discovered.<p>Similar the first Lisp source interpreter. John McCarthy came up with the idea of EVAL, but thought it only to be a mathematical idea. His team picked up the idea and implemented it. The result was the first Lisp source interpreter. Alan Kay said about this: &quot;Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!. EVAL is the E in REPL.<p>Then Lisp had s-expressions (symbol expressions -&gt; nested lists of &quot;atoms&quot;), which could be read (R) and printed.<p>This is the &quot;REP&quot; part of the REPL. Looping it was easy, then.<p>People then hooked up Lisp to early terminals. In 1963 an 17 year old kid ( <a href="https:&#x2F;&#x2F;de.wikipedia.org&#x2F;wiki&#x2F;L_Peter_Deutsch" rel="nofollow">https:&#x2F;&#x2F;de.wikipedia.org&#x2F;wiki&#x2F;L_Peter_Deutsch</a> ) wrote a Lisp interpreter and attached it to a terminal: the interactive REPL.<p>A really good, but large, book to teach the larger picture of Lisp programming is PAIP, Paradigms of Artificial Intelligence Programming, Case Studies in Common Lisp by Peter Norvig ( -&gt; <a href="https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp">https:&#x2F;&#x2F;github.com&#x2F;norvig&#x2F;paip-lisp</a> ).<p>A beginner&#x2F;mid-level book, for people with some programming experience, on the practical side is: PCL, Practical Common Lisp by Peter Seibel ( -&gt; <a href="https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;" rel="nofollow">https:&#x2F;&#x2F;gigamonkeys.com&#x2F;book&#x2F;</a> )<p>Both are available online at no cost.</div><br/></div></div><div id="40245157" class="c"><input type="checkbox" id="c-40245157" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243410">parent</a><span>|</span><a href="#40245377">prev</a><span>|</span><a href="#40244301">next</a><span>|</span><label class="collapse" for="c-40245157">[-]</label><label class="expand" for="c-40245157">[1 more]</label></div><br/><div class="children"><div class="content">You might already be aware, but there is a DISASSEMBLE function in the CL spec: <a href="http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;f_disass.htm" rel="nofollow">http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;f_disass.htm</a><p>The details are implementation and platform dependent, but on e.g. SBCL someone who understands assembly could use this to dig into what the compiler does and tune their functions.<p>I was also drawn in on the promise of insight, but I&#x27;m not so sure that&#x27;s what I got out of it. What keeps me hooked is more the ease with which I can study somewhat advanced programming and computer science topics. There has been aha-moments for sure, like when many moons ago it clicked how object and closure can be considered very, very similar and serve pretty much the same purpose in an application. But it&#x27;s the unhinged amount of power and flexiblity that keeps me interested.<p>Give me three days and I would most likely fail horribly at inventing a concurrency library in Java even though it&#x27;s one of the languages that pays my bills, but with Common Lisp or Racket I would probably have something to show. As someone who hasn&#x27;t spent any time studying these things at uni (my subjects were theology and law) I find these languages and the tooling they provide awesome. It&#x27;s not uncommon that I prototype in them and then transfer parts of it back to the algolians, which these days usually have somewhat primitive or clumsy implementations of parts of the functional languages.<p>I think the reason why tail call optimisation crops up in introductory material is because it makes succinct recursive functions viable in practice. Without it the application would explode on sufficiently large inputs, while TCO allows streaming data of unknown, theoretically unlimited, size. Things like while and for are kind of special, somewhat limited, cases of recursion, and getting fluent with recursive functions means you can craft your own looping structures that fit the problem precisely. Though in CL you also have the LOOP macro, which is a small programming language in itself.</div><br/></div></div></div></div></div></div><div id="40244301" class="c"><input type="checkbox" id="c-40244301" checked=""/><div class="controls bullet"><span class="by">superdisk</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40243255">prev</a><span>|</span><a href="#40244955">next</a><span>|</span><label class="collapse" for="c-40244301">[-]</label><label class="expand" for="c-40244301">[1 more]</label></div><br/><div class="children"><div class="content">As someone else said, Scheme is the one that warrants the &quot;pure, elegant&quot; reputation. CL is full of crazy features and weird functions but it&#x27;s because it&#x27;s basically the continued lineage of the original Lisp from 1960. It can even run those old 60s vintage programs with minimal tweaks.<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150217111426&#x2F;http:&#x2F;&#x2F;www.informatimago.com&#x2F;develop&#x2F;lisp&#x2F;com&#x2F;informatimago&#x2F;small-cl-pgms&#x2F;wang.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20150217111426&#x2F;http:&#x2F;&#x2F;www.inform...</a><p>If you just want to play with macros and learn what makes the Lisp thing so special I&#x27;d recommend Clojure, it&#x27;s like a stripped down CL with only functional features, and it&#x27;s extremely nice and ergonomic.</div><br/></div></div><div id="40244955" class="c"><input type="checkbox" id="c-40244955" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40244301">prev</a><span>|</span><a href="#40243751">next</a><span>|</span><label class="collapse" for="c-40244955">[-]</label><label class="expand" for="c-40244955">[1 more]</label></div><br/><div class="children"><div class="content">CL does have some weird stuff, after all it&#x27;s coming from the 1960&#x27;s LISP tradition.
But after you get past some basic weird stuff, it&#x27;s a quite wonderful language.<p>&gt; I can only speak for myself, but I definitely reason about code outside in rather than inside out.<p>You can indent code to make it much easier to &quot;parse&quot;, and use some macros that turn the code inside&#x2F;out, it&#x27;s more readable than most other languages.<p>The CL cookbook is an excellent resource, and this page links to several other excellent resources and books you can read for free online: <a href="https:&#x2F;&#x2F;lispcookbook.github.io&#x2F;cl-cookbook&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lispcookbook.github.io&#x2F;cl-cookbook&#x2F;</a><p>The &quot;new docs&quot; also present the documentation in a &quot;modern&quot; looking way (rather than the 90&#x27;s looks of what you get if you Google around): <a href="https:&#x2F;&#x2F;lisp-docs.github.io&#x2F;cl-language-reference&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lisp-docs.github.io&#x2F;cl-language-reference&#x2F;</a><p>About other Lisps...<p>The Racket Guide is definitely not &quot;bone-dry&quot;: <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;intro.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;intro.html</a><p>It is well written and looks very beautiful to me.<p>On another Scheme, I find Guile docs also great: <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;manual&#x2F;html_node&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;manual&#x2F;html_node&#x2F;index.ht...</a><p>They may be a bit more &quot;dry&quot; but they&#x27;re to the point and very readable! In fact, I think Lisp languages tend to have great documentation.
The guy who wrote is an excellent writer (he has written Racket books which are equally great) and I believe is the author of the Racket docs tool!</div><br/></div></div><div id="40243751" class="c"><input type="checkbox" id="c-40243751" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40244955">prev</a><span>|</span><a href="#40243536">next</a><span>|</span><label class="collapse" for="c-40243751">[-]</label><label class="expand" for="c-40243751">[8 more]</label></div><br/><div class="children"><div class="content">How do you know the functions are &quot;semi-redundant&quot; and &quot;soft-depreciated&quot;, if you&#x27;ve not worked in this before?</div><br/><div id="40243882" class="c"><input type="checkbox" id="c-40243882" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243751">parent</a><span>|</span><a href="#40243536">next</a><span>|</span><label class="collapse" for="c-40243882">[-]</label><label class="expand" for="c-40243882">[7 more]</label></div><br/><div class="children"><div class="content">Clever question, but a boring answer - the learning resource I was using simply said so (in fact, several did!). It seems common for learning resources to somewhat apologetically explain that Common Lisp has many functions with similar names but subtly different behaviours (e.g. (=) v (eq) v (eql) v (equal) v (equalp) v (string-equal)), before telling you which ones are in vogue.</div><br/><div id="40244256" class="c"><input type="checkbox" id="c-40244256" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243882">parent</a><span>|</span><a href="#40243536">next</a><span>|</span><label class="collapse" for="c-40244256">[-]</label><label class="expand" for="c-40244256">[6 more]</label></div><br/><div class="children"><div class="content">There is no &quot;vogue&quot; about it. Those functions test for different equalities. It&#x27;s not the case that any of them are new versions of the others.<p>(eq x y) tests whether x and y are the same object. It is very fast because typically all it has to do is do a machine word comparison, and that comparison is conclusive. (When it is false, there is no more work to do to rule out sameness.)<p>If x and y are the same number, of the same type, it is not required to report true. Even if they are the the same number that you might think fits into a machine word, though on most implementations that situation will be <i>eq</i>. ANSI Lisp allows for implementations in which small, identical integer values like 7 are not necessarily <i>eq</i>. A Lisp implementation in which all numbers are &quot;boxed&quot; quantities on the heap could be conforming to ANSI.<p>The <i>eql</i> function is like <i>eq</i>, but the same characters and same numbers of the same type are required to be equal under <i>eql</i>. For all other objects it is like <i>eq</i>. <i>eql</i> might be implemented in terms of doing an <i>eq</i> comparison, and then when that is false, doing more work to rule out sameness of numbers and characters.<p>Common Lisp&#x27;s hash tables can use different equalities; that is where it can make a bigger difference. Objects in an <i>eq</i> hash table can use a very simple, fast hashing function. Whereas objects in an <i>eql</i> hash table have to be hashed in such a way that equal integer or floating-point values have the same hash. A value that is a pointer to a boxed bignum integer has to be dereferenced to access some of the value bits of that object.<p>There are some exotic functions in Lisp that you might never end up using, particularly in the list processing area like <i>pairlis</i> or <i>revappend</i> and whatnot.</div><br/><div id="40244473" class="c"><input type="checkbox" id="c-40244473" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40244256">parent</a><span>|</span><a href="#40243536">next</a><span>|</span><label class="collapse" for="c-40244473">[-]</label><label class="expand" for="c-40244473">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, I am aware of the differences. I equivocated about specifying examples, because I worried someone would try to explain them, rather than engage with my overall point.<p>My overall point is two-fold. (1) There is nothing in the function name that would indicate the difference between, say, (eq) and (eql) and (equal), any more than you could guess what the difference between (colorise), (clrise) and (clrs) would be on sight. Lisp seems to love doing this. To me, it just seems like an obvious source of very painful bugs (works as expected 99% of the time and then it doesn&#x27;t).<p>(2) In many (most?) day-to-day cases, the distinction isn&#x27;t material, and for those the ecosystem is going to end up preferring one more than the others (which may change over time - hence, &#x27;in vogue&#x27;). The references I&#x27;ve seen tend to suggest sticking to (eq) and (equal), for instance, and avoiding (eql) unless you have specific need of it.<p>For a language that is reputed to be elegant and beautiful, this - well, isn&#x27;t that. Hence my initial surprise.</div><br/><div id="40244623" class="c"><input type="checkbox" id="c-40244623" checked=""/><div class="controls bullet"><span class="by">kgwgk</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40244473">parent</a><span>|</span><a href="#40244719">next</a><span>|</span><label class="collapse" for="c-40244623">[-]</label><label class="expand" for="c-40244623">[3 more]</label></div><br/><div class="children"><div class="content">&gt; (1) There is nothing in the function name that would indicate the difference between, say, (eq) and (eql) and (equal), any more than you could guess what the difference between (colorise), (clrise) and (clrs) would be on sight. Lisp seems to love doing this. To me, it just seems like an obvious source of subtle bugs.<p>What alternative would you suggest?<p>Giving paragraph-length names to the functions? Common Lisp already has some of the more descriptive function names around and they can be inconvenient if the function is used often. (By the way, there is something that helps to remember what those functions do: shorter names are correlated with more primitive and restrictive checks.)<p>Having a single function that performs different checks depending on a parameter? If you don’t know which function to use you don’t know which parameter to use either.<p>Removing the ability to perform different kinds of checks entirely?</div><br/><div id="40244723" class="c"><input type="checkbox" id="c-40244723" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40244623">parent</a><span>|</span><a href="#40244719">next</a><span>|</span><label class="collapse" for="c-40244723">[-]</label><label class="expand" for="c-40244723">[2 more]</label></div><br/><div class="children"><div class="content">I think troad is trying to explain how they feel about learning CL and what they&#x27;ve discovered. They aren&#x27;t criticising CL. Of course naming things over a long period of time is a complex problem, that&#x27;s why they acknowledged that there is a lot of cruft from the 60s.<p>I&#x27;ve found their comments, and the constructive responses to them, interesting because I am interested in Lisp but have never learned it.<p>What I don&#x27;t find interesting is seeing troad&#x27;s observations strongly challenged, as you are doing, as if somehow by sharing their observations, they now owe us detailed solutions as well.<p>It&#x27;s not cool.</div><br/><div id="40244965" class="c"><input type="checkbox" id="c-40244965" checked=""/><div class="controls bullet"><span class="by">kgwgk</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40244723">parent</a><span>|</span><a href="#40244719">next</a><span>|</span><label class="collapse" for="c-40244965">[-]</label><label class="expand" for="c-40244965">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough. In fact I agree with the broad point that having functions that do things is a source of bugs and CL is a huge language with less than perfect names. My point is that having less functions that do less things does not obviously reduce the number of bugs in the end if those things still need to be done. Anyway. I see how a logical argument may be out of place if the thread is understood about sharing feelings and not about challenging claims.</div><br/></div></div></div></div></div></div><div id="40244719" class="c"><input type="checkbox" id="c-40244719" checked=""/><div class="controls bullet"><span class="by">kgwgk</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40244473">parent</a><span>|</span><a href="#40244623">prev</a><span>|</span><a href="#40243536">next</a><span>|</span><label class="collapse" for="c-40244719">[-]</label><label class="expand" for="c-40244719">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (2) In many (most?) day-to-day cases, the distinction isn&#x27;t material, and for those the ecosystem is going to end up preferring one more than the others (which may change over time - hence, &#x27;in vogue&#x27;). The references I&#x27;ve seen tend to suggest sticking to (eq) and (equal), for instance, and avoiding (eql) unless you have specific need of it.<p>I guess they suggest two instead of one because in most cases the difference is material. And I imagine that they also suggest using = to compare numbers.<p>When the distinction doesn’t matter one could just use eq. I’m not sure that this covers most uses though.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40243536" class="c"><input type="checkbox" id="c-40243536" checked=""/><div class="controls bullet"><span class="by">adonovan</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40243751">prev</a><span>|</span><a href="#40243104">next</a><span>|</span><label class="collapse" for="c-40243536">[-]</label><label class="expand" for="c-40243536">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d expected something more elegant.<p>Common Lisp is sort of the union of all dialects of Lisp, and some might say of all possible programming language paradigms. Scheme is more like the intersection of dialects, and is thus closer to the platonic ideal of Lisp. If you&#x27;ve never seen any dialect of Lisp before, Scheme may be a better introduction to the flavor as it&#x27;s much easier to learn.</div><br/></div></div><div id="40243104" class="c"><input type="checkbox" id="c-40243104" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#40243063">parent</a><span>|</span><a href="#40243536">prev</a><span>|</span><a href="#40241281">next</a><span>|</span><label class="collapse" for="c-40243104">[-]</label><label class="expand" for="c-40243104">[2 more]</label></div><br/><div class="children"><div class="content">The funny names all have history. They had history even at the time when Common Lisp was standardized.</div><br/><div id="40243234" class="c"><input type="checkbox" id="c-40243234" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40243063">root</a><span>|</span><a href="#40243104">parent</a><span>|</span><a href="#40241281">next</a><span>|</span><label class="collapse" for="c-40243234">[-]</label><label class="expand" for="c-40243234">[1 more]</label></div><br/><div class="children"><div class="content">No doubt! I look forward to learning it in due course, but it&#x27;s not exactly penetrable for a newcomer, particularly amidst a sea of parentheses.</div><br/></div></div></div></div></div></div><div id="40241281" class="c"><input type="checkbox" id="c-40241281" checked=""/><div class="controls bullet"><span class="by">mark_l_watson</span><span>|</span><a href="#40243063">prev</a><span>|</span><a href="#40241735">next</a><span>|</span><label class="collapse" for="c-40241281">[-]</label><label class="expand" for="c-40241281">[2 more]</label></div><br/><div class="children"><div class="content">Great writeup! I am a long time user and fan of Common Lisp, and this is one of the more interesting use cases I have seen!</div><br/><div id="40241790" class="c"><input type="checkbox" id="c-40241790" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40241281">parent</a><span>|</span><a href="#40241735">next</a><span>|</span><label class="collapse" for="c-40241790">[-]</label><label class="expand" for="c-40241790">[1 more]</label></div><br/><div class="children"><div class="content">Thank you Mark! There are blessed and cursed projects out there, and this one has definitely been the former.</div><br/></div></div></div></div><div id="40241735" class="c"><input type="checkbox" id="c-40241735" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40241281">prev</a><span>|</span><a href="#40241936">next</a><span>|</span><label class="collapse" for="c-40241735">[-]</label><label class="expand" for="c-40241735">[9 more]</label></div><br/><div class="children"><div class="content">Author here, if you have any questions.</div><br/><div id="40245552" class="c"><input type="checkbox" id="c-40245552" checked=""/><div class="controls bullet"><span class="by">fellerts</span><span>|</span><a href="#40241735">parent</a><span>|</span><a href="#40245343">next</a><span>|</span><label class="collapse" for="c-40245552">[-]</label><label class="expand" for="c-40245552">[1 more]</label></div><br/><div class="children"><div class="content">What are the tunnels strung with (physical layer) that allows a 10 km+ network to work reliably?</div><br/></div></div><div id="40245343" class="c"><input type="checkbox" id="c-40245343" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#40241735">parent</a><span>|</span><a href="#40245552">prev</a><span>|</span><a href="#40243095">next</a><span>|</span><label class="collapse" for="c-40245343">[-]</label><label class="expand" for="c-40245343">[2 more]</label></div><br/><div class="children"><div class="content">Given that this is a safety-critical application, are condition&#x2F;restarts being used?  If so, what is your take on the value of those and can an example of restarts be listed?  If not, have they been considered and if, can you share the reason not to use them?</div><br/><div id="40245502" class="c"><input type="checkbox" id="c-40245502" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40241735">root</a><span>|</span><a href="#40245343">parent</a><span>|</span><a href="#40243095">next</a><span>|</span><label class="collapse" for="c-40245502">[-]</label><label class="expand" for="c-40245502">[1 more]</label></div><br/><div class="children"><div class="content">We certainly do use both. For example in communication we process socket layer conditions and remote operation results together to synthesize Evacsound&#x27;s own nomenclature of conditions in distributed operation terms. They are then re-signaled and can be handled by a small set of our wrapper macros and constructs.<p>Our process&#x2F;tasks abstraction naturally also uses conditions to handle the lifecycle.<p>As for restarts you can see their invocations in the last code snippet in the article.</div><br/></div></div></div></div><div id="40243095" class="c"><input type="checkbox" id="c-40243095" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#40241735">parent</a><span>|</span><a href="#40245343">prev</a><span>|</span><a href="#40242895">next</a><span>|</span><label class="collapse" for="c-40243095">[-]</label><label class="expand" for="c-40243095">[3 more]</label></div><br/><div class="children"><div class="content">What does the evacuation alarm actually sound like? Does it reuse any of the sounds mentioned in the Tronstad study, or did you come up with your own?</div><br/><div id="40244942" class="c"><input type="checkbox" id="c-40244942" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40241735">root</a><span>|</span><a href="#40243095">parent</a><span>|</span><a href="#40244310">next</a><span>|</span><label class="collapse" for="c-40244942">[-]</label><label class="expand" for="c-40244942">[1 more]</label></div><br/><div class="children"><div class="content">It is a bell sound as the sister comment points out. We found that a multitude of sounds work with negligible difference in perception. The bell however was consistently voted the most comfortable in post trial questionnaire.</div><br/></div></div><div id="40244310" class="c"><input type="checkbox" id="c-40244310" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#40241735">root</a><span>|</span><a href="#40243095">parent</a><span>|</span><a href="#40244942">prev</a><span>|</span><a href="#40242895">next</a><span>|</span><label class="collapse" for="c-40244310">[-]</label><label class="expand" for="c-40244310">[1 more]</label></div><br/><div class="children"><div class="content">A ringing bell:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;MmrihxFhWJw?t=57" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;MmrihxFhWJw?t=57</a></div><br/></div></div></div></div><div id="40242895" class="c"><input type="checkbox" id="c-40242895" checked=""/><div class="controls bullet"><span class="by">mtreis86</span><span>|</span><a href="#40241735">parent</a><span>|</span><a href="#40243095">prev</a><span>|</span><a href="#40241936">next</a><span>|</span><label class="collapse" for="c-40242895">[-]</label><label class="expand" for="c-40242895">[2 more]</label></div><br/><div class="children"><div class="content">How was working with posix threads? I&#x27;ve only dug into SBCL&#x27;s various thread tools</div><br/><div id="40244923" class="c"><input type="checkbox" id="c-40244923" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#40241735">root</a><span>|</span><a href="#40242895">parent</a><span>|</span><a href="#40241936">next</a><span>|</span><label class="collapse" for="c-40244923">[-]</label><label class="expand" for="c-40244923">[1 more]</label></div><br/><div class="children"><div class="content">Fortunately it was uneventful, as the idiom is the same as in any other programming language that support them. We used bordeaux-threads package for portability across the implementations.</div><br/></div></div></div></div></div></div><div id="40241936" class="c"><input type="checkbox" id="c-40241936" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#40241735">prev</a><span>|</span><a href="#40244462">next</a><span>|</span><label class="collapse" for="c-40241936">[-]</label><label class="expand" for="c-40241936">[1 more]</label></div><br/><div class="children"><div class="content">On Common Lisp, I loaded a nearly 30 yo eliza Chatbot written in CL, 
it ran almost straight under SBCL with just omitting an error:<p><a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;afs&#x2F;cs&#x2F;project&#x2F;ai-repository&#x2F;ai&#x2F;areas&#x2F;classics&#x2F;eliza&#x2F;bg&#x2F;eliza.lsp" rel="nofollow">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;afs&#x2F;cs&#x2F;project&#x2F;ai-repository&#x2F;ai&#x2F;areas...</a><p><pre><code>       sbcl --load eliza.lsp
       (top-level)
       (hello how are you)
</code></pre>
Do not use punctuation. Use (goodbye) to exit.<p>From a Unix user like me, SBCL&#x2F;CL looks a bit bloaty and non-Unix, but I have to acknowledge that CL and Emacs&#x27; Elisp had a great history on compatibility and easyness due to the homoiconicity. In plain English: 
everything it&#x27;s handled in the same way everywhere.
The syntax will be the same on every function.</div><br/></div></div><div id="40244462" class="c"><input type="checkbox" id="c-40244462" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#40241936">prev</a><span>|</span><a href="#40240979">next</a><span>|</span><label class="collapse" for="c-40244462">[-]</label><label class="expand" for="c-40244462">[1 more]</label></div><br/><div class="children"><div class="content">I would love to read more on these topics.  I keep getting told that lisp isn&#x27;t &quot;used anymore&quot; (Even though I actively do).</div><br/></div></div><div id="40240979" class="c"><input type="checkbox" id="c-40240979" checked=""/><div class="controls bullet"><span class="by">nemoniac</span><span>|</span><a href="#40244462">prev</a><span>|</span><label class="collapse" for="c-40240979">[-]</label><label class="expand" for="c-40240979">[27 more]</label></div><br/><div class="children"><div class="content">Is it really established wisdom that multiple inheritance might be an anti-pattern? Anyone care to elaborate?</div><br/><div id="40241154" class="c"><input type="checkbox" id="c-40241154" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#40240979">parent</a><span>|</span><a href="#40241092">next</a><span>|</span><label class="collapse" for="c-40241154">[-]</label><label class="expand" for="c-40241154">[1 more]</label></div><br/><div class="children"><div class="content">A nice pattern from Common Lisp is to inherit the parts of an object from different superclasses.  Method combination means one can write methods for those superclasses and then have them automatically combined in a subclass.<p>Example:  if one has tree nodes with various slots that represent children and you want to write a tree traversal function, you put each slot in a superclass, inherit from those superclasses in the correct order, and then write a method for each superclass that calls the child at that slot.  The methods are combined in the right order automatically in a PROGN method combination.</div><br/></div></div><div id="40241092" class="c"><input type="checkbox" id="c-40241092" checked=""/><div class="controls bullet"><span class="by">mark_undoio</span><span>|</span><a href="#40240979">parent</a><span>|</span><a href="#40241154">prev</a><span>|</span><a href="#40241085">next</a><span>|</span><label class="collapse" for="c-40241092">[-]</label><label class="expand" for="c-40241092">[5 more]</label></div><br/><div class="children"><div class="content">I think the implementation in C++ put it out of fashion, as later languages (e.g. Java) deliberately restricted it to avoid the complexity.  The main criticism I saw was the potential for (variants of) the &quot;diamond&quot; where A is subclassed by B and C, then both of those are subclassed by D.  Does D get two copies of A&#x27;s state?  It&#x27;s hard to come up with an intuitive behaviour.<p>More recently, the move seems to be away from class based object orientation (including inheritance) entirely.<p>On the other side of things, I&#x27;ve never heard people talk about Python&#x27;s multiple inheritance with the same tone used for C++ - but then there are cultural differences in the language communities too.</div><br/><div id="40241753" class="c"><input type="checkbox" id="c-40241753" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241092">parent</a><span>|</span><a href="#40242058">next</a><span>|</span><label class="collapse" for="c-40241753">[-]</label><label class="expand" for="c-40241753">[3 more]</label></div><br/><div class="children"><div class="content">Something I’ve found interesting is that most widely-used class-based inheritance languages eventually added multiple inheritance of implementations back in: PHP added traits that can contain method implementations; Java added default implementations on interfaces; etc.</div><br/><div id="40242080" class="c"><input type="checkbox" id="c-40242080" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241753">parent</a><span>|</span><a href="#40242058">next</a><span>|</span><label class="collapse" for="c-40242080">[-]</label><label class="expand" for="c-40242080">[2 more]</label></div><br/><div class="children"><div class="content">The famous &quot;super considered harmful&quot; post ( <a href="https:&#x2F;&#x2F;fuhm.net&#x2F;super-harmful&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fuhm.net&#x2F;super-harmful&#x2F;</a> ) pointed out the key problem with diamonds, and it&#x27;s mainly a problem with constructors. Allowing mixins that can have method implementations but only allowing one class parent with a constructor is a pretty good spot in the design space, and is what a lot of languages have converged on.</div><br/><div id="40242211" class="c"><input type="checkbox" id="c-40242211" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40242080">parent</a><span>|</span><a href="#40242058">next</a><span>|</span><label class="collapse" for="c-40242211">[-]</label><label class="expand" for="c-40242211">[1 more]</label></div><br/><div class="children"><div class="content">I like CL’s solution to constructors which is basically “specialize this generic function (SHARED-INITIALIZE or INITIALIZE-INSTANCE) with an :AFTER method”. You reliably run all the initialization code for each class involved and you don’t have to remember to call CALL-NEXT-METHOD (CL’s spelling of super)<p>Edit: I see that post refers to Dylan, which is more like CL than python in the important ways. IMO, sleeping on CL’s object system CLOS was a huge mistake of the “Java&#x2F;C++ era” of our industry.</div><br/></div></div></div></div></div></div><div id="40242058" class="c"><input type="checkbox" id="c-40242058" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241092">parent</a><span>|</span><a href="#40241753">prev</a><span>|</span><a href="#40241085">next</a><span>|</span><label class="collapse" for="c-40242058">[-]</label><label class="expand" for="c-40242058">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does D get two copies of A&#x27;s state? It&#x27;s hard to come up with an intuitive behaviour.<p>C++ gonna C++, which means the language covers <i>all</i> the bases because some programmer might get mad if their use case wasn&#x27;t accounted for.<p>C++ has something called virtual inheritance, wherein if subclasses B and C inherit <i>virtually</i> from A, any subclasses of both B and C will get one copy of A&#x27;s state. Otherwise, they will get two copies: one from B and one from C.<p>This solves the problem of addressing concerns of all programmers w.r.t. the diamond inheritance problem, but makes the language more complex (and triggers my CPPPTSD).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_inheritance" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_inheritance</a></div><br/></div></div></div></div><div id="40241085" class="c"><input type="checkbox" id="c-40241085" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#40240979">parent</a><span>|</span><a href="#40241092">prev</a><span>|</span><a href="#40241171">next</a><span>|</span><label class="collapse" for="c-40241085">[-]</label><label class="expand" for="c-40241085">[7 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it the ambiguity of the Diamond Problem?  Suppose B and C are both children of A, and D is a child of both B and C.<p>If B and C both have methods foo(), which gets called when you do d.foo()?<p>Seems like a real footgun requiring extra effort to avoid.</div><br/><div id="40241196" class="c"><input type="checkbox" id="c-40241196" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241085">parent</a><span>|</span><a href="#40241171">next</a><span>|</span><label class="collapse" for="c-40241196">[-]</label><label class="expand" for="c-40241196">[6 more]</label></div><br/><div class="children"><div class="content">In CL&#x27;s solution, the order of superclasses matter to avoid ambiguity. If D is defined like (defclass d (b c) ...) then a method specialized on B is called; if like (defclass d (c b) ...) then it&#x27;s otherwise.</div><br/><div id="40242183" class="c"><input type="checkbox" id="c-40242183" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241196">parent</a><span>|</span><a href="#40241221">next</a><span>|</span><label class="collapse" for="c-40242183">[-]</label><label class="expand" for="c-40242183">[2 more]</label></div><br/><div class="children"><div class="content">In this case the problem becomes that while one can define a 100% consistent, coherent order for the compiler to use, the <i>human&#x27;s</i> ability to understand what will happen when they call a method of a particular name, and also what that resolution method will do as the code is refactored and changed over time, exceeds anything a human can be reasonably expected to have.<p>Really, all the problems with multiple inheritance are that the humans can&#x27;t handle the complexity that results. The compilers can be made to do &quot;something&quot; that is arguably sensible.</div><br/><div id="40245247" class="c"><input type="checkbox" id="c-40245247" checked=""/><div class="controls bullet"><span class="by">Jach</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40242183">parent</a><span>|</span><a href="#40241221">next</a><span>|</span><label class="collapse" for="c-40245247">[-]</label><label class="expand" for="c-40245247">[1 more]</label></div><br/><div class="children"><div class="content">Fortunately in Lisp the compiler is available at runtime!<p>I mean, it&#x27;s just not that bad. I believe the commercial Lisp IDEs will just show you relevant info much like, say, Java IDEs, but even with a free Lisp you can still ask for it so you don&#x27;t actually need to wonder what will happen as you&#x27;re looking at a line. You just ask. The worst part of Lisp vs. C++ on multiple inheritance, I think, where it can be more confusing for Lisp is that Lisp will just overwrite slots (fields) sharing the same name, whereas C++ will shadow them. On the other hand methods aren&#x27;t owned by individual classes in Lisp, so you get multiple dispatch by default. Lastly the presence of :before &#x2F; :after &#x2F; :around methods, combined with multiple dispatch, make it pretty straightforward to achieve behaviors through mixins that require pretty complex contortions otherwise in C++. (Or Java.) The behavior of those &quot;auxiliary methods&quot; is straightforward to reason about. <i>All</i> :before methods run before the most specific primary method, in most-specific-first order, and <i>all</i> :after methods run after the least specific primary method, in least-specific-first order.<p>I&#x27;m probably going to convince some people otherwise by giving some more specifics, but as a minor example, consider a silly &quot;game object&quot; style class. I can always ask any class (e.g. an asteroid), hey, what&#x27;s your class precedence list? (closer-mop:class-precedence-list (find-class &#x27;asteroid)) returns a list of class objects: asteroid, game-object, sprite, add-groups-mixin, cleaned-on-kill-mixin, standard-object, slot-object, and T. From the source code where the defclass is, only game-object is shown. If you look at game-object, only sprite and the two mixins are shown as an example of multiple inheritance.<p>I don&#x27;t need to call that function to get the info either, it&#x27;s readily available by calling &#x27;describe on the class. (I think even free editors like Lem or emacs can be configured to automatically show the description of things if you hover over them, I just type ,s in vim.) The description includes the same class precedence list info, tells me the direct superclasses, any subclasses, direct slots (fields directly defined on the class), inherited slots...<p>If I&#x27;m wondering what could happen if I call #&#x27;kill on an asteroid before I actually call it, I can ask with the built-in &#x27;compute-applicable-methods function or &#x27;closer-mop:compute-applicable-methods-using-classes, and it will show me the applicable methods are firstly the primary defined method, then an :after method due to the mixin.<p>I can also compute the actual effective method that will be called with &#x27;closer-mop:compute-effective-method. For something like #&#x27;kill, it shows what happens first is the primary #&#x27;kill method, then the :after method. For something like #&#x27;draw, let&#x27;s say I overwrote the base implementation, now it shows there&#x27;s just one method call, with the potential for the next base class method if the specialized method happens to use &#x27;call-next-method.<p>So in summary, the tools exist in various forms to wrestle the complexity and make it amenable to human understanding. Just like with tools such as cross-referencing, they help understand and create bigger systems, we don&#x27;t have to limit ourselves to what can easily be done with physical code printouts and hand-made indexes.</div><br/></div></div></div></div><div id="40241221" class="c"><input type="checkbox" id="c-40241221" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241196">parent</a><span>|</span><a href="#40242183">prev</a><span>|</span><a href="#40241171">next</a><span>|</span><label class="collapse" for="c-40241221">[-]</label><label class="expand" for="c-40241221">[3 more]</label></div><br/><div class="children"><div class="content">And sometimes more than one method is invoked, using a sophisticated method combination infrastructure.</div><br/><div id="40241298" class="c"><input type="checkbox" id="c-40241298" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241221">parent</a><span>|</span><a href="#40241171">next</a><span>|</span><label class="collapse" for="c-40241298">[-]</label><label class="expand" for="c-40241298">[2 more]</label></div><br/><div class="children"><div class="content">Right, I assumed the default method combination, and also the simplest case of it with no around&#x2F;before&#x2F;after methods being defined... Golly, CL object system is complicated, now that I look at it from this perspective.</div><br/><div id="40241741" class="c"><input type="checkbox" id="c-40241741" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241298">parent</a><span>|</span><a href="#40241171">next</a><span>|</span><label class="collapse" for="c-40241741">[-]</label><label class="expand" for="c-40241741">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s simple when you want it, and powerful when you need it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40241171" class="c"><input type="checkbox" id="c-40241171" checked=""/><div class="controls bullet"><span class="by">jolt42</span><span>|</span><a href="#40240979">parent</a><span>|</span><a href="#40241085">prev</a><span>|</span><a href="#40241136">next</a><span>|</span><label class="collapse" for="c-40241171">[-]</label><label class="expand" for="c-40241171">[1 more]</label></div><br/><div class="children"><div class="content">Meh. Probably a reaction to getting &quot;burned&quot; by it. But show me something you can&#x27;t get burned by.</div><br/></div></div><div id="40241767" class="c"><input type="checkbox" id="c-40241767" checked=""/><div class="controls bullet"><span class="by">copx</span><span>|</span><a href="#40240979">parent</a><span>|</span><a href="#40243227">prev</a><span>|</span><label class="collapse" for="c-40241767">[-]</label><label class="expand" for="c-40241767">[10 more]</label></div><br/><div class="children"><div class="content">90s-style Java OOP showed everyone that heavy use of multiple inheritance is the worst thing since 80s-style BASIC where ever third line was a GOTO.<p>Imagine one class inheriting from 50 other classes through multiple inheritance..<p>People really used to construct classes like:<p>&quot;Iron Sword inherits from Iron which inherits from Metal which inherits from Meltable (which inherits from Temperature) and Material. But of course it also inherits from Sword which inherits from Weapon and Edged. Meanwhile Weapon inherits from Equipment which inherits from Ownable and Item which..&quot; and so on.<p>Basically you make every aspect and attribute of an entity a class and then create your entity&#x27;s class by mushing together all those classes through multiple inheritance. The results are..not pretty.<p>Such code quickly becomes very hard to comprehend and maintain.</div><br/><div id="40241863" class="c"><input type="checkbox" id="c-40241863" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241767">parent</a><span>|</span><a href="#40241809">next</a><span>|</span><label class="collapse" for="c-40241863">[-]</label><label class="expand" for="c-40241863">[1 more]</label></div><br/><div class="children"><div class="content">90s Java did not have multiple inheritance (nor does today&#x27;s Java). It did have multiple interfaces, but they only carried a spec of the interface and no implementation details beyond that. C++ was the one with multiple inheritance, if you are trying to reference a popular 90s OO language.</div><br/></div></div><div id="40242002" class="c"><input type="checkbox" id="c-40242002" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241767">parent</a><span>|</span><a href="#40241809">prev</a><span>|</span><a href="#40241805">next</a><span>|</span><label class="collapse" for="c-40242002">[-]</label><label class="expand" for="c-40242002">[3 more]</label></div><br/><div class="children"><div class="content">90s Java didn&#x27;t do that because Java doesn&#x27;t support multiple class inheritance.<p>90s C++, however, did.<p>Funny you should cite a game example. I once read about how the developers of StarCraft[0] ran into the same Goddamn inheritance problems I did when trying to build a custom game engine and a game with that engine. Adding behaviors via inheritance <i>seemed</i> like a good idea <i>at the time</i> (mid-late 90s), especially given all the propaganda we read from our C++ compiler manuals and such. But it turned into a situation where you either accepted multiple inheritance with all of its complexity and suck, including &quot;which of the multiple base classes that implement &#x27;foo&#x27; do I want when I call derived::foo()?&quot; -- or resorting to delegates or other methods of composing behavior.<p>Me, for gaming, I became an ECS convert and haven&#x27;t looked back. There are some pain points when writing a game in ECS style... but the advantages pay for the relatively minor pain many times over.<p>[0] <a href="https:&#x2F;&#x2F;www.codeofhonor.com&#x2F;blog&#x2F;tough-times-on-the-road-to-starcraft" rel="nofollow">https:&#x2F;&#x2F;www.codeofhonor.com&#x2F;blog&#x2F;tough-times-on-the-road-to-...</a><p>CFlingy is a particle spawner. Why does that have to be in the inheritance chain, instead of a trait you <i>add</i> to an object?</div><br/><div id="40242496" class="c"><input type="checkbox" id="c-40242496" checked=""/><div class="controls bullet"><span class="by">hprotagonist</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40242002">parent</a><span>|</span><a href="#40241805">next</a><span>|</span><label class="collapse" for="c-40242496">[-]</label><label class="expand" for="c-40242496">[2 more]</label></div><br/><div class="children"><div class="content">the canonical blog post series:<a href="https:&#x2F;&#x2F;ericlippert.com&#x2F;2015&#x2F;04&#x2F;27&#x2F;wizards-and-warriors-part-one&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ericlippert.com&#x2F;2015&#x2F;04&#x2F;27&#x2F;wizards-and-warriors-part...</a></div><br/><div id="40243542" class="c"><input type="checkbox" id="c-40243542" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40242496">parent</a><span>|</span><a href="#40241805">next</a><span>|</span><label class="collapse" for="c-40243542">[-]</label><label class="expand" for="c-40243542">[1 more]</label></div><br/><div class="children"><div class="content">Why “canonical”? From what I can see, Entity-Component-System (ECS), long pre-date this blog series by Eric, and he doesn’t even reference the term.<p>I did enjoy the read however! My own programming has evolved towards data oriented design over the years.</div><br/></div></div></div></div></div></div><div id="40241805" class="c"><input type="checkbox" id="c-40241805" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241767">parent</a><span>|</span><a href="#40242002">prev</a><span>|</span><a href="#40241994">next</a><span>|</span><label class="collapse" for="c-40241805">[-]</label><label class="expand" for="c-40241805">[1 more]</label></div><br/><div class="children"><div class="content">Yup. No amount of generated documentation or static analysis can make up for the cognitive load required to reason about where a particular method is actually being dispatched to under those conditions.</div><br/></div></div><div id="40241994" class="c"><input type="checkbox" id="c-40241994" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241767">parent</a><span>|</span><a href="#40241805">prev</a><span>|</span><label class="collapse" for="c-40241994">[-]</label><label class="expand" for="c-40241994">[3 more]</label></div><br/><div class="children"><div class="content">OOP would work fine for a text adventure, such as Inform6 against the Z-Machine, which pretty much the gameplay rooms-&gt;objects it&#x27;s perfect for this. For everything else... well... maybe just CLOS it&#x27;s usable enough.</div><br/><div id="40244967" class="c"><input type="checkbox" id="c-40244967" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40241994">parent</a><span>|</span><label class="collapse" for="c-40244967">[-]</label><label class="expand" for="c-40244967">[2 more]</label></div><br/><div class="children"><div class="content">The MUD-family of games are usually built in a C-like OOP-language, LPC. I think it&#x27;s rather nice.</div><br/><div id="40245109" class="c"><input type="checkbox" id="c-40245109" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#40240979">root</a><span>|</span><a href="#40244967">parent</a><span>|</span><label class="collapse" for="c-40245109">[-]</label><label class="expand" for="c-40245109">[1 more]</label></div><br/><div class="children"><div class="content">Under Inform6 the inheritance and OOP features are literally that, objects have attributes and you can create in-game objects (rooms are objects too) which are instances of defined ones.
Such as always &#x27;lighted&#x27; rooms, a furniture class by defining as object as &#x27;scenery&#x27; (you can&#x27;t take it).<p>That&#x27;s an elegant example on coding Inform6 which transpiles against the Z Machine, but overall I won&#x27;t use OOP outside gaming.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>