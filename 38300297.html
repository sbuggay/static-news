<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700384457070" as="style"/><link rel="stylesheet" href="styles.css?v=1700384457070"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pganalyze.com/blog/automatic-indexing-system-postgres-pganalyze-indexing-engine">An automatic indexing system for Postgres</a> <span class="domain">(<a href="https://pganalyze.com">pganalyze.com</a>)</span></div><div class="subtext"><span>ako</span> | <span>38 comments</span></div><br/><div><div id="38325384" class="c"><input type="checkbox" id="c-38325384" checked=""/><div class="controls bullet"><span class="by">lfittl</span><span>|</span><a href="#38325695">next</a><span>|</span><label class="collapse" for="c-38325384">[-]</label><label class="expand" for="c-38325384">[1 more]</label></div><br/><div class="children"><div class="content">OP here (happy to see this on HN!) - if you&#x27;re interested in our work in this area, I hosted a webinar earlier this week where we walked through a new constraint programming based system (utilizing CP-SAT) for Postgres index selection that we&#x27;re starting to roll out in pganalyze:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=SlNQTtfjlnI">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=SlNQTtfjlnI</a><p>Compared to the initial version, this updated version is both more configurable, as well as has better handling of competing objectives in index selection (write overhead vs query performance).<p>If you want to give this a try, and have pganalyze set up &#x2F; want to try it out, feel free to send me a message (email in profile).</div><br/></div></div><div id="38325695" class="c"><input type="checkbox" id="c-38325695" checked=""/><div class="controls bullet"><span class="by">hamilyon2</span><span>|</span><a href="#38325384">prev</a><span>|</span><a href="#38322759">next</a><span>|</span><label class="collapse" for="c-38325695">[-]</label><label class="expand" for="c-38325695">[2 more]</label></div><br/><div class="children"><div class="content">Ok, from battle trenches: even if there is a <i>perfect</i> index for your query, the slower plan might still win and there is little you can do about it. So, often you rewrite query or even restructure tables to archive performance.<p>If rewriting query and remodelling data are out of question, the options are much more limited.<p>Second, not only queries have rps, they have hourly, weekly and seasonal distributions. They evolve, become deprecated, and have different SLAs, tables have different write to read ratios. There was an instance recently when I slowed down a query, quite intentionally by deleting a very good index for the query and substituted it with worse, but smaller BRIN index.<p>The thing is, this particular query did not matter as much and SLA permitted slowdown, write path was far more important.</div><br/><div id="38330092" class="c"><input type="checkbox" id="c-38330092" checked=""/><div class="controls bullet"><span class="by">joelthelion</span><span>|</span><a href="#38325695">parent</a><span>|</span><a href="#38322759">next</a><span>|</span><label class="collapse" for="c-38330092">[-]</label><label class="expand" for="c-38330092">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ok, from battle trenches: even if there is a perfect index for your query, the slower plan might still win and there is little you can do about it<p>I often wonder why, in addition to sql, we don&#x27;t have a low level language allowing you to specify exactly how you want your query executed?</div><br/></div></div></div></div><div id="38322759" class="c"><input type="checkbox" id="c-38322759" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#38325695">prev</a><span>|</span><a href="#38322328">next</a><span>|</span><label class="collapse" for="c-38322759">[-]</label><label class="expand" for="c-38322759">[13 more]</label></div><br/><div class="children"><div class="content">I’ve often wondered why we don’t put a thin tiny proxy in front of psql (or augment pgbouncer, other proxies) to collect telemetry on all real world queries against the db. Being a middle man there would give you lots of visibility into every single query being made as well as how long it takes. I guess the modern integrated stats tools help.<p>I think the real problem is not indexing correctly but rather modeling your problem correctly. You can throw indexes at the problem but that is sometimes just a bandaid to a more integral issue which would be inventing a new schema, new access patterns etc.</div><br/><div id="38323011" class="c"><input type="checkbox" id="c-38323011" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38324778">next</a><span>|</span><label class="collapse" for="c-38323011">[-]</label><label class="expand" for="c-38323011">[5 more]</label></div><br/><div class="children"><div class="content">Most databases will allow you to collect statistics on every query run by users, e.g., pg_stat_statements: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;pgstatstatements.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;pgstatstatements.htm...</a><p>A relational database really shines when you have all sorts of queries on tables, so it’s hard to optimize your model for every potentially future desired query. Precalculating these, caching the results in separate tables is not very efficient, and requires you to predetermine every query you want to answer.<p>Indexing in this situation is often the better alternative.</div><br/><div id="38323532" class="c"><input type="checkbox" id="c-38323532" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#38322759">root</a><span>|</span><a href="#38323011">parent</a><span>|</span><a href="#38324778">next</a><span>|</span><label class="collapse" for="c-38323532">[-]</label><label class="expand" for="c-38323532">[4 more]</label></div><br/><div class="children"><div class="content">Lots of apps however do the same N kind of queries, but the data under them can change over time without anyone noticing</div><br/><div id="38324412" class="c"><input type="checkbox" id="c-38324412" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38322759">root</a><span>|</span><a href="#38323532">parent</a><span>|</span><a href="#38324778">next</a><span>|</span><label class="collapse" for="c-38324412">[-]</label><label class="expand" for="c-38324412">[3 more]</label></div><br/><div class="children"><div class="content">So? Just make sure you regularly refresh the statistics...</div><br/><div id="38325613" class="c"><input type="checkbox" id="c-38325613" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#38322759">root</a><span>|</span><a href="#38324412">parent</a><span>|</span><a href="#38324778">next</a><span>|</span><label class="collapse" for="c-38325613">[-]</label><label class="expand" for="c-38325613">[2 more]</label></div><br/><div class="children"><div class="content">Ideally yes, but sometimes your tables get so monstrously large that the auto-analyze is sampling thousandths of a percent of rows, and fiddling with sampling targets can throw off seemingly unconnected queries.<p>Planners are mysterious black boxes, which we can at best influence.</div><br/><div id="38326017" class="c"><input type="checkbox" id="c-38326017" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38322759">root</a><span>|</span><a href="#38325613">parent</a><span>|</span><a href="#38324778">next</a><span>|</span><label class="collapse" for="c-38326017">[-]</label><label class="expand" for="c-38326017">[1 more]</label></div><br/><div class="children"><div class="content">Yes, a bit like machine learning models.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38324778" class="c"><input type="checkbox" id="c-38324778" checked=""/><div class="controls bullet"><span class="by">ahachete</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38323011">prev</a><span>|</span><a href="#38322868">next</a><span>|</span><label class="collapse" for="c-38324778">[-]</label><label class="expand" for="c-38324778">[1 more]</label></div><br/><div class="children"><div class="content">Have a look at the Postgres filter for the Envoy proxy: [1] (blog announcement post).<p>While it&#x27;s not capturing as of today query performance, it collects notable telemetry for Postgres in exactly the way you mention: just because the traffic flows through it, making it a way to collect data &quot;for free&quot; and definitely without taking any resources from the upstream database.<p>It can also offload SSL from Postgres. The filter could be extended for other use cases.<p>Disclaimer: my company developed this plugin for Envoy with the help of Envoy&#x27;s awesome community.<p>[1]: <a href="https:&#x2F;&#x2F;www.cncf.io&#x2F;blog&#x2F;2020&#x2F;08&#x2F;13&#x2F;envoy-1-15-introduces-a-new-postgres-extension-with-monitoring-support&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cncf.io&#x2F;blog&#x2F;2020&#x2F;08&#x2F;13&#x2F;envoy-1-15-introduces-a-...</a></div><br/></div></div><div id="38322868" class="c"><input type="checkbox" id="c-38322868" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38324778">prev</a><span>|</span><a href="#38327328">next</a><span>|</span><label class="collapse" for="c-38322868">[-]</label><label class="expand" for="c-38322868">[1 more]</label></div><br/><div class="children"><div class="content">We have this with APM monitoring, where every SQL query in the application becomes a span in a trace. It is very useful. We can quickly see the specific parameters that make an otherwise fast query slow.</div><br/></div></div><div id="38327328" class="c"><input type="checkbox" id="c-38327328" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38322868">prev</a><span>|</span><a href="#38324595">next</a><span>|</span><label class="collapse" for="c-38327328">[-]</label><label class="expand" for="c-38327328">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the real problem is not indexing correctly but rather modeling your problem correctly.<p>There&#x27;s also the issue that usage might change over time due to events outside of your control, that affects what the correct solution should look like.<p>For example, there&#x27;s always a tradeoff between development effort and performance. It doesn&#x27;t make financial sense spending tons of engineering time on optimizing a process that&#x27;s done once per day and for which the simple solution is more than fast enough even though it takes an hour.<p>But if external circumstances change and that process suddenly needs to run every minute... perhaps not so easy to accommodate without drastic changes.</div><br/></div></div><div id="38324595" class="c"><input type="checkbox" id="c-38324595" checked=""/><div class="controls bullet"><span class="by">bbminner</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38327328">prev</a><span>|</span><a href="#38323759">next</a><span>|</span><label class="collapse" for="c-38324595">[-]</label><label class="expand" for="c-38324595">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, I have always been curious about the same thing - if we have live statistics on queries then what stops us from cloning data (to correctly capture statics such as skew, etc.) and running these live queries with a bunch of knobs tuned  automatically (which indexes, on which columns, etc.), and reporting the cost-throughput paretto optimum to the user? The configuration space is too large to explore randomly? And it&#x27;s structure is too complex to produce automatic suggestions?</div><br/></div></div><div id="38323759" class="c"><input type="checkbox" id="c-38323759" checked=""/><div class="controls bullet"><span class="by">jes5199</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38324595">prev</a><span>|</span><a href="#38323098">next</a><span>|</span><label class="collapse" for="c-38323759">[-]</label><label class="expand" for="c-38323759">[1 more]</label></div><br/><div class="children"><div class="content">you can get a long way just checking the slow query log every few days</div><br/></div></div><div id="38323098" class="c"><input type="checkbox" id="c-38323098" checked=""/><div class="controls bullet"><span class="by">ellisv</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38323759">prev</a><span>|</span><a href="#38325523">next</a><span>|</span><label class="collapse" for="c-38323098">[-]</label><label class="expand" for="c-38323098">[1 more]</label></div><br/><div class="children"><div class="content">I definitely agree on problems not being modeled correctly, although I also frequently see application developers forego indexes. I think this is fundamentally a lack of understanding or inexperience.</div><br/></div></div><div id="38325523" class="c"><input type="checkbox" id="c-38325523" checked=""/><div class="controls bullet"><span class="by">nijave</span><span>|</span><a href="#38322759">parent</a><span>|</span><a href="#38323098">prev</a><span>|</span><a href="#38322328">next</a><span>|</span><label class="collapse" for="c-38325523">[-]</label><label class="expand" for="c-38325523">[1 more]</label></div><br/><div class="children"><div class="content">MaxScale does this for MariaDB</div><br/></div></div></div></div><div id="38322328" class="c"><input type="checkbox" id="c-38322328" checked=""/><div class="controls bullet"><span class="by">gavinray</span><span>|</span><a href="#38322759">prev</a><span>|</span><a href="#38324784">next</a><span>|</span><label class="collapse" for="c-38322328">[-]</label><label class="expand" for="c-38322328">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; This is powered by a modified version of the Postgres planner that runs as part of the pganalyze app. This modified planner can generate EXPLAIN-like data from just a query and schema information - and most importantly, that means we can take query statistics data from pg_stat_statements and generate a generic query plan from it. You can read more about that in our blog post &quot;How we deconstructed the Postgres planner&quot;.
</code></pre>
Having something like this available as a library inside of Postgres seems really beneficial for tool authors. I wonder what the odds of getting it upstreamed are?</div><br/><div id="38325458" class="c"><input type="checkbox" id="c-38325458" checked=""/><div class="controls bullet"><span class="by">lfittl</span><span>|</span><a href="#38322328">parent</a><span>|</span><a href="#38324784">next</a><span>|</span><label class="collapse" for="c-38325458">[-]</label><label class="expand" for="c-38325458">[2 more]</label></div><br/><div class="children"><div class="content">Author here - what we call &quot;pg_plan&quot; internally, is essentially very similar in spirit to what we do with pg_query [0], but the difference is that we pull in a lot more code from Postgres, and have more overrides in places that are not needed for the use case (e.g. MVCC handling, etc).<p>My gut feeling tells me that the chances of having an upstream library that contains the parser&#x2F;parse analysis&#x2F;planner are slim. Mainly from there being a lot of entanglement with reading files on disk, memory management, etc - I suspect one of the pushbacks would be it would complicate development work for Postgres itself, to the point its not worth the benefits.<p>For the pg_query library on the other hand I have hopes that we can upstream this eventually - there are enough third-party users out there to clearly show the need, and its much more contained (i.e. raw parser + AST structs). Hopefully something we can spend a bit of time on next year.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;pganalyze&#x2F;libpg_query">https:&#x2F;&#x2F;github.com&#x2F;pganalyze&#x2F;libpg_query</a></div><br/><div id="38326628" class="c"><input type="checkbox" id="c-38326628" checked=""/><div class="controls bullet"><span class="by">anarazel</span><span>|</span><a href="#38322328">root</a><span>|</span><a href="#38325458">parent</a><span>|</span><a href="#38324784">next</a><span>|</span><label class="collapse" for="c-38326628">[-]</label><label class="expand" for="c-38326628">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My gut feeling tells me that the chances of having an upstream library that contains the parser&#x2F;parse analysis&#x2F;planner are slim.<p>Yea. The parser alone would be doable and not even that hard. But once you get to parse analysis and planning, you need to access the catalogs (for parse analysis to look up object names and do permission checks, for planning to access operator definitions, statistics etc). Which in turn needs a lot of the catalog &#x2F; relation cache infrastructure.  By that point you&#x27;ve pulled in a lot of postgres.<p>Of course you could try to introduce a &quot;data provider&quot; layer between parse analysis and catalogs, but that&#x27;d be a lot of work. And it&#x27;d be quite hard to get right in places - e.g. doing name lookups without acquiring heavyweight locks on objects, before having done permission checks, in a concurrency safe way, relies on a bunch of subsystems working together.</div><br/></div></div></div></div></div></div><div id="38324784" class="c"><input type="checkbox" id="c-38324784" checked=""/><div class="controls bullet"><span class="by">colincooke</span><span>|</span><a href="#38322328">prev</a><span>|</span><a href="#38328846">next</a><span>|</span><label class="collapse" for="c-38324784">[-]</label><label class="expand" for="c-38324784">[5 more]</label></div><br/><div class="children"><div class="content">I had no idea what was going on under the hood but used PGAnalyze for about 6 months after launching a new product. It was excellent at suggesting indexes and monitoring unused ones.<p>However, after a few months the ROI crept down until it wasn&#x27;t worth it anymore (access patterns stabilized). I&#x27;m tempted to bring it back once and a while but the price tag keeps me from having it always on.</div><br/><div id="38325228" class="c"><input type="checkbox" id="c-38325228" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#38324784">parent</a><span>|</span><a href="#38329615">next</a><span>|</span><label class="collapse" for="c-38325228">[-]</label><label class="expand" for="c-38325228">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense, if the structure of your queries is largely static per commit of your codebase. You&#x27;d probably get more benefit out of a tool like this by running it as part of a CI pipeline, since that&#x27;s the best time to test code changes including new queries. But then the challenge becomes simulating user activity and traffic levels during the CI pipeline.  That&#x27;s a solvable problem, but it&#x27;s not as easy as just observing the real traffic in your prod network.</div><br/></div></div><div id="38329615" class="c"><input type="checkbox" id="c-38329615" checked=""/><div class="controls bullet"><span class="by">rc_kas</span><span>|</span><a href="#38324784">parent</a><span>|</span><a href="#38325228">prev</a><span>|</span><a href="#38329582">next</a><span>|</span><label class="collapse" for="c-38329615">[-]</label><label class="expand" for="c-38329615">[2 more]</label></div><br/><div class="children"><div class="content">How much is it? They don&#x27;t list prices on their site.</div><br/><div id="38329901" class="c"><input type="checkbox" id="c-38329901" checked=""/><div class="controls bullet"><span class="by">lfittl</span><span>|</span><a href="#38324784">root</a><span>|</span><a href="#38329615">parent</a><span>|</span><a href="#38329582">next</a><span>|</span><label class="collapse" for="c-38329901">[-]</label><label class="expand" for="c-38329901">[1 more]</label></div><br/><div class="children"><div class="content">You can find our pricing on the website [0] - generally $100&#x2F;month per instance (though note our smallest plan is $150&#x2F;mo). pganalyze Index Advisor, which is the subject of the post is available with all plans.<p>Generally I (Founder and CEO) feel the pricing is fair for the value provided for production databases, and it allows us to run the business as an independent company without external investors, whilst continuing to invest in product improvements. That said, it may not be a good fit if you have a small production database, or only make database-related changes infrequently.<p>[0]: <a href="https:&#x2F;&#x2F;pganalyze.com&#x2F;pricing" rel="nofollow noreferrer">https:&#x2F;&#x2F;pganalyze.com&#x2F;pricing</a></div><br/></div></div></div></div><div id="38329582" class="c"><input type="checkbox" id="c-38329582" checked=""/><div class="controls bullet"><span class="by">vira28</span><span>|</span><a href="#38324784">parent</a><span>|</span><a href="#38329615">prev</a><span>|</span><a href="#38328846">next</a><span>|</span><label class="collapse" for="c-38329582">[-]</label><label class="expand" for="c-38329582">[1 more]</label></div><br/><div class="children"><div class="content">Same value prop I felt with Ottertune too.</div><br/></div></div></div></div><div id="38328846" class="c"><input type="checkbox" id="c-38328846" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#38324784">prev</a><span>|</span><a href="#38323396">next</a><span>|</span><label class="collapse" for="c-38328846">[-]</label><label class="expand" for="c-38328846">[5 more]</label></div><br/><div class="children"><div class="content">I mean, great it catches more easy wins but until you do an EXPLAIN ANALYZE your plan analysis is worth sh*t (sorry I am highly skeptical of those solutions based on personnal experience). I have seen so many cases where you add a &quot;perfect&quot; index for one query and it completely wreck the performances of another query because the planner decides to change and it makes a worst decision. It is very common in postgres to intentionally not add a good index or modify the query because we dont have query planner hints (rant for another day).<p>We need better tooling around indexes but it needs to take into account all the queries and run them against the real dataset IMO. I think AWS Aurora plan manager is on the right track if it would be combined it with your tech.</div><br/><div id="38328956" class="c"><input type="checkbox" id="c-38328956" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#38328846">parent</a><span>|</span><a href="#38323396">next</a><span>|</span><label class="collapse" for="c-38328956">[-]</label><label class="expand" for="c-38328956">[4 more]</label></div><br/><div class="children"><div class="content">how long until we can postgresql “query with this plan and these indices”?</div><br/><div id="38329229" class="c"><input type="checkbox" id="c-38329229" checked=""/><div class="controls bullet"><span class="by">rrrrrrrrrrrryan</span><span>|</span><a href="#38328846">root</a><span>|</span><a href="#38328956">parent</a><span>|</span><a href="#38323396">next</a><span>|</span><label class="collapse" for="c-38329229">[-]</label><label class="expand" for="c-38329229">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a weirdo here on hacker news because I&#x27;ve mainly worked with Microsoft SQL databases my entire career, but it absolutely blows my mind when I remember that postgres can&#x27;t lock in a query plan.<p>It&#x27;s <i>so</i> nice being able to sleep at night and not have to that an ultra important won&#x27;t randomly shit the bed.<p>One of my buddies that works at a PostgreSQL powered place once bitched about how they had a maintenance job that truncated a big table, then another job refreshed statistics, then the table rapidly filled up again and ask the query plans were awful because the table is usually massive.<p>I get the religion behind the open source stuff: with SQL, you shouldn&#x27;t <i>have</i> to tell the thing how to build the query plan, you should just tell it what you want and let it figure out how to do it.<p>But if humans are expected to perform maintenance on the database, setting up scheduled jobs, refreshing statistics, identifying missing indexes, etc., then those same humans should be able to specify a query plan and&#x2F;or specific indexes to use in a query.</div><br/><div id="38329600" class="c"><input type="checkbox" id="c-38329600" checked=""/><div class="controls bullet"><span class="by">tornato7</span><span>|</span><a href="#38328846">root</a><span>|</span><a href="#38329229">parent</a><span>|</span><a href="#38329796">next</a><span>|</span><label class="collapse" for="c-38329600">[-]</label><label class="expand" for="c-38329600">[1 more]</label></div><br/><div class="children"><div class="content">I worked at a company with a big, complex Postgres database behind the back end, probably half of all the incidents we had were related to the query planner suddenly deciding to change its approach.<p>Eventually you get a vague idea of how to coax Postgres to make the plans you want it to, but the fact that you can&#x27;t at least lock it in and the plan might change with any number of factors at any time... That&#x27;s just bad design.</div><br/></div></div><div id="38329796" class="c"><input type="checkbox" id="c-38329796" checked=""/><div class="controls bullet"><span class="by">liquidpele</span><span>|</span><a href="#38328846">root</a><span>|</span><a href="#38329229">parent</a><span>|</span><a href="#38329600">prev</a><span>|</span><a href="#38323396">next</a><span>|</span><label class="collapse" for="c-38329796">[-]</label><label class="expand" for="c-38329796">[1 more]</label></div><br/><div class="children"><div class="content">There’s a command to force it to update table statistics…  you just run that, especially after doing manual stuff.  Pretty common, but easy to forget.</div><br/></div></div></div></div></div></div></div></div><div id="38323396" class="c"><input type="checkbox" id="c-38323396" checked=""/><div class="controls bullet"><span class="by">brunoqc</span><span>|</span><a href="#38328846">prev</a><span>|</span><a href="#38324339">next</a><span>|</span><label class="collapse" for="c-38323396">[-]</label><label class="expand" for="c-38323396">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;ankane&#x2F;dexter">https:&#x2F;&#x2F;github.com&#x2F;ankane&#x2F;dexter</a></div><br/></div></div><div id="38324339" class="c"><input type="checkbox" id="c-38324339" checked=""/><div class="controls bullet"><span class="by">VeejayRampay</span><span>|</span><a href="#38323396">prev</a><span>|</span><a href="#38322963">next</a><span>|</span><label class="collapse" for="c-38324339">[-]</label><label class="expand" for="c-38324339">[1 more]</label></div><br/><div class="children"><div class="content">the guys at pganalyze do a fantastic job explaining the inner workings of postgresql on their YouTube channel, especially the 5 minutes of postgre series</div><br/></div></div><div id="38322963" class="c"><input type="checkbox" id="c-38322963" checked=""/><div class="controls bullet"><span class="by">monlockandkey</span><span>|</span><a href="#38324339">prev</a><span>|</span><a href="#38322517">next</a><span>|</span><label class="collapse" for="c-38322963">[-]</label><label class="expand" for="c-38322963">[2 more]</label></div><br/><div class="children"><div class="content">Any open source alternatives to PGAnalyze?</div><br/></div></div><div id="38322517" class="c"><input type="checkbox" id="c-38322517" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#38322963">prev</a><span>|</span><a href="#38321715">next</a><span>|</span><label class="collapse" for="c-38322517">[-]</label><label class="expand" for="c-38322517">[1 more]</label></div><br/><div class="children"><div class="content">I might try something like this indexing method</div><br/></div></div><div id="38321715" class="c"><input type="checkbox" id="c-38321715" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38322517">prev</a><span>|</span><label class="collapse" for="c-38321715">[-]</label><label class="expand" for="c-38321715">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>A fundamental decision we&#x27;ve made for the pganalyze Indexing Engine is that we break down queries into smaller parts we call &quot;scans&quot;. Scans are always on a single table, and you may be familiar with this concept from reading an EXPLAIN plan. For example, in an EXPLAIN plan you could see a Sequential Scan or Index Scan, both representing a different scan method for the same scan on a given table.</i><p>Sequential scan == Full table scan: 
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Full_table_scan" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Full_table_scan</a></div><br/><div id="38321834" class="c"><input type="checkbox" id="c-38321834" checked=""/><div class="controls bullet"><span class="by">financltravsty</span><span>|</span><a href="#38321715">parent</a><span>|</span><a href="#38322111">next</a><span>|</span><label class="collapse" for="c-38321834">[-]</label><label class="expand" for="c-38321834">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and a neat thing about indexes: sometimes it’s faster to do a sequential scan than load an index into memory.</div><br/></div></div></div></div></div></div></div></div></div></body></html>