<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704186060864" as="style"/><link rel="stylesheet" href="styles.css?v=1704186060864"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.aaronballman.com/2023/12/musings-on-the-c-charter/">Musings on the C Charter</a> <span class="domain">(<a href="https://blog.aaronballman.com">blog.aaronballman.com</a>)</span></div><div class="subtext"><span>steveklabnik</span> | <span>11 comments</span></div><br/><div><div id="38838667" class="c"><input type="checkbox" id="c-38838667" checked=""/><div class="controls bullet"><span class="by">sgbeal</span><span>|</span><a href="#38838310">next</a><span>|</span><label class="collapse" for="c-38838667">[-]</label><label class="expand" for="c-38838667">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would love to see this principle updated to set a time limit, along the lines of: existing code that has been maintained to not use features marked deprecated, obsolescent, or removed in the past ten years is important; unmaintained code and existing implementations are not. If you cannot update your code to stop relying on deprecated functionality, your code is not actually economically important — people spend time and money maintaining things that are economically important.<p>i have been posting FOSS code since 1998, much of it in C, and not one line of it is something i would dare classify as &quot;economically important.&quot; It was written for fun and much of the fun of writing in a language is lost when updates in the language break old code. (The reason i won&#x27;t touch PHP anymore is because updates broke my long-working code too many times.)<p>C Charter folks: by all means, break long-standing features when folks build with -std=cNEW_VERSION, but keep in mind that -std=c89 or -std=c99 are holy contracts with decades of code behind them, all of which should still compile in 30 years when built in -std=c89&#x2F;c99 modes, regardless of whether they&#x27;re &quot;economically important.&quot;</div><br/></div></div><div id="38838310" class="c"><input type="checkbox" id="c-38838310" checked=""/><div class="controls bullet"><span class="by">AdamH12113</span><span>|</span><a href="#38838667">prev</a><span>|</span><a href="#38838165">next</a><span>|</span><label class="collapse" for="c-38838310">[-]</label><label class="expand" for="c-38838310">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; If you cannot update your code to stop relying on deprecated functionality, your code is not actually economically important — people spend time and money maintaining things that are economically important.</i><p>I think this view is mistaken. Tools that only need small changes rarely are some of the most valuable, because they produce value at minimal cost.<p><i>&gt; ...existing code that has been maintained to not use features marked deprecated, obsolescent, or removed in the past ten years is important; unmaintained code and existing implementations are not.</i><p>I understand that you can&#x27;t support legacy code forever, but we need to get away from this idea that ten years is a long time for software to run, or that only software undergoing constant churn is worth anything.</div><br/><div id="38838761" class="c"><input type="checkbox" id="c-38838761" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#38838310">parent</a><span>|</span><a href="#38838165">next</a><span>|</span><label class="collapse" for="c-38838761">[-]</label><label class="expand" for="c-38838761">[2 more]</label></div><br/><div class="children"><div class="content">Aaron is speaking from experience in trying to get support for prototype-less functions in C removed, something which imposes a surprisingly high burden in the compiler and has been deprecated for over 30 years... and still received a lot of pushback because of the potential of breaking code that hadn&#x27;t been touched in that time.<p>&gt; I understand that you can&#x27;t support legacy code forever, but we need to get away from this idea that ten years is a long time for software to run, or that only software undergoing constant churn is worth anything.<p>The specific issue here is the code which lies at the intersection of the three categories:<p>1. Code that is N decades old and still in active use.<p>2. Code that needs to be compiled by the latest and greatest compiler versions.<p>3. Code that no one is willing to invest the resources in to make any changes to keep compiling.<p>That intersection is quite small, if not empty entirely. Consider the programming language with the longest pedigree, Fortran, nearing its 70th birthday, with a large amount of code very firmly meeting the first criterion... and yet I don&#x27;t think any modern compiler supports anything pre-Fortran 77.</div><br/><div id="38839542" class="c"><input type="checkbox" id="c-38839542" checked=""/><div class="controls bullet"><span class="by">fauigerzigerk</span><span>|</span><a href="#38838310">root</a><span>|</span><a href="#38838761">parent</a><span>|</span><a href="#38838165">next</a><span>|</span><label class="collapse" for="c-38839542">[-]</label><label class="expand" for="c-38839542">[1 more]</label></div><br/><div class="children"><div class="content">There could be larger codebases that are under active development but contain some ancient source files that no one dares to touch any longer.<p>If the latest compilers were to stop supporting old code then some new code could be cut off from further compiler upgrades as well.</div><br/></div></div></div></div></div></div><div id="38838165" class="c"><input type="checkbox" id="c-38838165" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38838310">prev</a><span>|</span><a href="#38839025">next</a><span>|</span><label class="collapse" for="c-38838165">[-]</label><label class="expand" for="c-38838165">[4 more]</label></div><br/><div class="children"><div class="content">The post asks the following question, which brought out a visceral and immediate answer from me:<p>‘When two implementations support the same notional feature with slightly differing semantics, should the committee use undefined behavior to resolve the conflict so no users have to change code, or should the committee push for well-defined behavior despite knowing it will break some users?’<p>I lurched towards the second option for ‘well-defined behavior’. And I would answer that way not just despite knowing breakage, but I would say that is the correct choice even in the event of large breakages for some percentage of active code bases. I have a hard time figuring out who would choose to accept more undefined behavior for new semantic constructs.<p>While I may not be accepting of the authors stance and conclusions to the question of ‘Trust the Programmer’, I do agree with his thoughts about the inherent positives of full throated argument in favor of increasing semantic constructs being ‘well-‘ and ‘implementation-‘ defined.<p>I may even go a step further and reach for an ultimate position that if it merely degrades performance metrics by some percentage, then instances of undefined behavior should be eliminated if at all possible. At a minimum, the goal should be to move to, at the most liberal, implementation-defined behavior for any given semantic construct. This would force compiler writers to specify and particularize what syntactic and semantic constructions they were taking advantage of to generate performance gains and allow developers the ability to decide if they could adhere to the implementation’s semantic guarantees.</div><br/><div id="38839503" class="c"><input type="checkbox" id="c-38839503" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38838165">parent</a><span>|</span><a href="#38838260">next</a><span>|</span><label class="collapse" for="c-38839503">[-]</label><label class="expand" for="c-38839503">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ‘When two implementations support the same notional feature with slightly differing semantics, should the committee use undefined behavior to resolve the conflict so no users have to change code, or should the committee push for well-defined behavior despite knowing it will break some users?’<p>That&#x27;s a false dichotomy.  You could also use implementation defined behaviour.  Or specify that these n behaviours would be valid.<p>&#x27;Undefined behaviour&#x27; is too big of a sledgehammer.</div><br/></div></div><div id="38838260" class="c"><input type="checkbox" id="c-38838260" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#38838165">parent</a><span>|</span><a href="#38839503">prev</a><span>|</span><a href="#38839025">next</a><span>|</span><label class="collapse" for="c-38838260">[-]</label><label class="expand" for="c-38838260">[2 more]</label></div><br/><div class="children"><div class="content">Yeah. I think it&#x27;s disingenuous to talk about breaking things for users, as though people are <i>forced</i> to use a newer language standard.<p>C99 &quot;broke&quot; implicit declarations, but few if any people were forced to use C99 and it never became the default in, say, GCC (-std=gnu11 became the default in GCC 5.5, released in 2017).</div><br/><div id="38838378" class="c"><input type="checkbox" id="c-38838378" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38838165">root</a><span>|</span><a href="#38838260">parent</a><span>|</span><a href="#38839025">next</a><span>|</span><label class="collapse" for="c-38838378">[-]</label><label class="expand" for="c-38838378">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, the biggest concern with this point of view is that the developer then has to ensure the older version of the compiler stays functional as OS’s and execution environments progress. That may be a reach, but I think one of the heavy imperatives of going to a more defined standard for the semantics of C would be forcing compiler implementations to be very clear about what standard they are supporting and what kind of guarantees they are making about support timeframes for that standard.<p>The above is because I would hope that one result of pushing a nearly fully ‘defined’ (well or implementation) standard would be a strong interconnectedness and compositionality of semantics between all semantic constructions. This should mean compiler implementers can not just fall back on a mish-mash of standards compliance and then claim undefined behavior lets them just omit certain semantic constructs. I would like to think having the language be very clearly defined would almost require a complete adoption of some given standard to ensure the compiler was compliant.<p>I am aware the possibility of such a radical realignment of C’s structure is nearly impossible, but if C can not or will not do it, there may be the option for an incredibly similar language to piggy back it’s way to common use. This may also satisfy some of the arguments&#x2F;positions in TFA concerning ‘Trust the Programmer’, where this superseding language can ‘unsafe&#x2F;non-conforming’ out to C directly in C syntax in the event a non-conforming semantic construction is needed or desired by a developer.</div><br/></div></div></div></div></div></div><div id="38839025" class="c"><input type="checkbox" id="c-38839025" checked=""/><div class="controls bullet"><span class="by">buserror</span><span>|</span><a href="#38838165">prev</a><span>|</span><a href="#38836964">next</a><span>|</span><label class="collapse" for="c-38839025">[-]</label><label class="expand" for="c-38839025">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll start caring about c standards above gnu99 as soon as they add case range values to switch statements, like case A ... B: -- which I&#x27;ve only been using for what, 35 years now?<p>All that time, I really wondered what the flip they are on about. Adding extensions that really, I really raise eyebrows at while ignoring complete elephants in the room, like the above feature.<p>Last year they were pontificating about something something adding some sort of (complicated) syntax to support destructor functions and were wondering about prior implementations, and <i>I</i> had to point to them the support of destructor function had been there as an extension of gcc for countless years.<p>It&#x27;s like they aren&#x27;t actually using the language, just speccing it. Kinda like linux maintainers who are more like some sort of priesthood and gatekeepers than actual users of the system.</div><br/></div></div></div></div></div></div></div></body></html>