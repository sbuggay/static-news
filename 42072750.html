<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730970052096" as="style"/><link rel="stylesheet" href="styles.css?v=1730970052096"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://purplesyringa.moe/blog/bringing-faster-exceptions-to-rust/">Bringing Faster Exceptions to Rust</a> <span class="domain">(<a href="https://purplesyringa.moe">purplesyringa.moe</a>)</span></div><div class="subtext"><span>stpn</span> | <span>5 comments</span></div><br/><div><div id="42074769" class="c"><input type="checkbox" id="c-42074769" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42074855">next</a><span>|</span><label class="collapse" for="c-42074769">[-]</label><label class="expand" for="c-42074769">[1 more]</label></div><br/><div class="children"><div class="content">Great analysis of unwinding overhead in Rust. The framing of exceptions as &quot;alternate returns&quot; is enlightening - they <i>should</i> be cheap in theory, which makes the current ~2.3μs overhead particularly interesting to dissect. The optimization journey from removing unnecessary type erasure to using thread-locals is well explained. While the 4.3x speedup is impressive, I think the bigger takeaway isn&#x27;t about replacing Result with panics, but rather identifying where non-local control flow genuinely makes sense. Looking forward to the deep dive into unwinder implementations.</div><br/></div></div><div id="42074855" class="c"><input type="checkbox" id="c-42074855" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#42074769">prev</a><span>|</span><label class="collapse" for="c-42074855">[-]</label><label class="expand" for="c-42074855">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Returning to an alternate address shouldn’t be significantly more expensive than returning to the default address, so this has to be cheap.<p>Modern CPUs add complications to arguments like this. Branches stall the execution pipeline, so branch prediction was invented to keep the pipeline flowing. Return instructions are <i>perfectly</i> predicted, which makes them literally free. At the very least, any alternate return scheme has to pay for a full misprediction. That can be expensive.</div><br/><div id="42074899" class="c"><input type="checkbox" id="c-42074899" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#42074855">parent</a><span>|</span><label class="collapse" for="c-42074899">[-]</label><label class="expand" for="c-42074899">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t really make sense. The branch predictor relies on a history of previous executions of that branch, or on explicit hints, to decide if a <i>branch</i> will be taken or not. Based on this prediction, the speculative execution hardware then sees the jump (return&#x2F;panic) and loads the code from that address into the icache. There is 0 difference between `if (condition) jump $panic_recover_address` and `if (condition) jump $function_return_address` in terms of how easy or hard it is to predict or speculatively load based on the prediction.</div><br/><div id="42074946" class="c"><input type="checkbox" id="c-42074946" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#42074855">root</a><span>|</span><a href="#42074899">parent</a><span>|</span><label class="collapse" for="c-42074946">[-]</label><label class="expand" for="c-42074946">[1 more]</label></div><br/><div class="children"><div class="content">On x86, ret and call are explicit instructions. Ret always predicts the address of the last call, which is (usually) 100% accurate. Your example of `if (condition) jump $panic_recover_address` contains two branches, either of which can be mispredicted.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>