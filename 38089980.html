<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698829260396" as="style"/><link rel="stylesheet" href="styles.css?v=1698829260396"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.datomic.com/2017/01/the-ten-rules-of-schema-growth.html">Rules of schema growth (2017)</a> <span class="domain">(<a href="https://blog.datomic.com">blog.datomic.com</a>)</span></div><div class="subtext"><span>iamwil</span> | <span>78 comments</span></div><br/><div><div id="38090937" class="c"><input type="checkbox" id="c-38090937" checked=""/><div class="controls bullet"><span class="by">d3ckard</span><span>|</span><a href="#38092887">next</a><span>|</span><label class="collapse" for="c-38090937">[-]</label><label class="expand" for="c-38090937">[21 more]</label></div><br/><div class="children"><div class="content">Going to take the risk and politely say I do not agree with this article at all.<p>Alternative advice: <i>never</i> allow more than one app to share the db and expose data through APIs, not queries. Then you can actually remove cruft and solve compatibility through API versioning that you probably need to do anyway. Also, never maintain more than two versions at the time.</div><br/><div id="38095272" class="c"><input type="checkbox" id="c-38095272" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38095210">next</a><span>|</span><label class="collapse" for="c-38095272">[-]</label><label class="expand" for="c-38095272">[1 more]</label></div><br/><div class="children"><div class="content">There are databases (and data warehouses) that need to provide random query api’s, e.g, for reporting, analytics, etc. Databases can be considered to provide an api layer themselves, way more flexible than most standards APIs provide. Graphql and odata go a long way to solve this. Also, database views can provide a data api layer for a database. Views provide a stable datamodel, that allow the underlying tables to be changed.</div><br/></div></div><div id="38095210" class="c"><input type="checkbox" id="c-38095210" checked=""/><div class="controls bullet"><span class="by">oconnore</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38095272">prev</a><span>|</span><a href="#38091177">next</a><span>|</span><label class="collapse" for="c-38095210">[-]</label><label class="expand" for="c-38095210">[1 more]</label></div><br/><div class="children"><div class="content">This reminds me of the microservices trend where the main justification is modularity —- which is of course perfectly possible to implement in a programming language using standard language constructs.<p>Similarly: any separation of concerns you can implement with APIs and multiple databases you can also implement with a schema. The difference being you have to reimplement a bunch of capabilities that are baked into an rdbms (and will probably never correctly implement something like a hash join).</div><br/></div></div><div id="38091177" class="c"><input type="checkbox" id="c-38091177" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38095210">prev</a><span>|</span><a href="#38093617">next</a><span>|</span><label class="collapse" for="c-38091177">[-]</label><label class="expand" for="c-38091177">[10 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so simple!  If you never delete or change things in your schema, you never have to worry about changing it.<p>The article is pretty devoid of actionable advice.</div><br/><div id="38091298" class="c"><input type="checkbox" id="c-38091298" checked=""/><div class="controls bullet"><span class="by">plandis</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091177">parent</a><span>|</span><a href="#38092850">next</a><span>|</span><label class="collapse" for="c-38091298">[-]</label><label class="expand" for="c-38091298">[7 more]</label></div><br/><div class="children"><div class="content">The article lists fairly sensible rules for backwards compatibility and growth in my opinion.</div><br/><div id="38091351" class="c"><input type="checkbox" id="c-38091351" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091298">parent</a><span>|</span><a href="#38092850">next</a><span>|</span><label class="collapse" for="c-38091351">[-]</label><label class="expand" for="c-38091351">[6 more]</label></div><br/><div class="children"><div class="content">The central thesis revolves around continuous growth with no advice given for removal&#x2F;cleanup.  This is not a sound strategy for a database schema, at least for the SQL side.  Column bloat, trigger bloat, index bloat... Schemas cannot continuously grow, there needs to be DROPs along the way.</div><br/><div id="38092699" class="c"><input type="checkbox" id="c-38092699" checked=""/><div class="controls bullet"><span class="by">slowmovintarget</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091351">parent</a><span>|</span><a href="#38091611">next</a><span>|</span><label class="collapse" for="c-38092699">[-]</label><label class="expand" for="c-38092699">[2 more]</label></div><br/><div class="children"><div class="content">Datomic is not a SQL database. You can simulate tabular data, but it is a very different beast. Datomic schemas are always EAVT. If you add an attribute, or deprecate one, there may still be values tagged to that attribute. <i>That should be fine.</i><p>That something as simple as change--a universal condition of all systems--defeats so many schema designs in SQL databases should suggest that there&#x27;s something wrong with the SQL databases.</div><br/><div id="38093698" class="c"><input type="checkbox" id="c-38093698" checked=""/><div class="controls bullet"><span class="by">cakoose</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38092699">parent</a><span>|</span><a href="#38091611">next</a><span>|</span><label class="collapse" for="c-38093698">[-]</label><label class="expand" for="c-38093698">[1 more]</label></div><br/><div class="children"><div class="content">But the article claims it applies to SQL databases as well.<p>&gt; Are these rules specific to a particular database?
&gt;
&gt; No. These rules apply to almost any SQL or NoSQL database. The rules even apply to the so-called &quot;schemaless&quot; databases.</div><br/></div></div></div></div><div id="38091611" class="c"><input type="checkbox" id="c-38091611" checked=""/><div class="controls bullet"><span class="by">plandis</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091351">parent</a><span>|</span><a href="#38092699">prev</a><span>|</span><a href="#38092850">next</a><span>|</span><label class="collapse" for="c-38091611">[-]</label><label class="expand" for="c-38091611">[3 more]</label></div><br/><div class="children"><div class="content">Yes you eventually need to do the things you mention but probably less frequently than a normal application needs to add new columns or the like to support new use cases.<p>The article thesis is essentially make breaking changes as infrequently as possible. The easiest way to do that is never change your data but that’s a sure way to have your competitors crush you as you stagnate. The next best thing you can do is make sure existing producers and consumers are not impacted when you make changes. For most changes being made the advice in the article gives a set of things you can do to achieve this goal.<p>For times where your database itself is not scaling which are the types of things you’re mentioning, I think there are other things you can do to, if not eliminate backwards incompatibility, at least make the transition easier. For example fronting your DB via an API and gate all producers&#x2F;consumers through that. If you’re frequently having to handle scaling issues perhaps it’s time to reevaluate your system design all together.</div><br/><div id="38091737" class="c"><input type="checkbox" id="c-38091737" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091611">parent</a><span>|</span><a href="#38092850">next</a><span>|</span><label class="collapse" for="c-38091737">[-]</label><label class="expand" for="c-38091737">[2 more]</label></div><br/><div class="children"><div class="content">From the article:<p><pre><code>    never break it

    Never remove a name

    Never reuse a name
</code></pre>
Your point is a very reasonable statement, but you are really disrespecting the author by putting a reasonable statement in their mouth. They had every chance to say the reasonable thing, and they clearly made a choice to say the unreasonable thing. Respect that decision (and tell them that they&#x27;re wrong).</div><br/><div id="38094489" class="c"><input type="checkbox" id="c-38094489" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091737">parent</a><span>|</span><a href="#38092850">next</a><span>|</span><label class="collapse" for="c-38094489">[-]</label><label class="expand" for="c-38094489">[1 more]</label></div><br/><div class="children"><div class="content">Never removing a name is relatively straightforward with views and aliases. Never breaking it is somewhat harder, but is still possible for well designed tables - especially if you use updateable views. Never reusing a name is also straightforward. It does require planning your schema evolution years if not decades in advance of course.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38092850" class="c"><input type="checkbox" id="c-38092850" checked=""/><div class="controls bullet"><span class="by">slowmovintarget</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091177">parent</a><span>|</span><a href="#38091298">prev</a><span>|</span><a href="#38095275">next</a><span>|</span><label class="collapse" for="c-38092850">[-]</label><label class="expand" for="c-38092850">[1 more]</label></div><br/><div class="children"><div class="content">This advice is rock solid... for Datomic. Not for Postgres or other traditional relational DBs.</div><br/></div></div><div id="38095275" class="c"><input type="checkbox" id="c-38095275" checked=""/><div class="controls bullet"><span class="by">ako</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091177">parent</a><span>|</span><a href="#38092850">prev</a><span>|</span><a href="#38093617">next</a><span>|</span><label class="collapse" for="c-38095275">[-]</label><label class="expand" for="c-38095275">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t this the same versioning approach that graphql proposes?</div><br/></div></div></div></div><div id="38093617" class="c"><input type="checkbox" id="c-38093617" checked=""/><div class="controls bullet"><span class="by">skeeter2020</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38091177">prev</a><span>|</span><a href="#38091091">next</a><span>|</span><label class="collapse" for="c-38093617">[-]</label><label class="expand" for="c-38093617">[1 more]</label></div><br/><div class="children"><div class="content">I agree that the article is pretty bad, but it&#x27;s not like &quot;make this the API team&#x27;s problem&quot; is really an answer. API versioning is probably tougher than database schema versioning IME.</div><br/></div></div><div id="38091091" class="c"><input type="checkbox" id="c-38091091" checked=""/><div class="controls bullet"><span class="by">n0w</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38093617">prev</a><span>|</span><a href="#38093560">next</a><span>|</span><label class="collapse" for="c-38091091">[-]</label><label class="expand" for="c-38091091">[5 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve got more than one app sharing a db when you deploy a new version. Unless you&#x27;re happy with downtime during deploys as the cost of not having to manage how your schema evolves.<p>These kinds of best practices make sense regardless of how many apps access a db.<p>Following the advice doesn&#x27;t also prevent you from enforcing a strict contract for external access and modification of the data.</div><br/><div id="38091849" class="c"><input type="checkbox" id="c-38091849" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091091">parent</a><span>|</span><a href="#38093560">next</a><span>|</span><label class="collapse" for="c-38091849">[-]</label><label class="expand" for="c-38091849">[4 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;ve got more than one app sharing a db when you deploy a new version. Unless you&#x27;re happy with downtime during deploys as the cost of not having to manage how your schema evolves.<p>2 deploys is all it takes to solve this problem.<p><pre><code>    * 1 to deploy the new schema for the new version.
    * 1 to remove the old schema.
</code></pre>
This sort of &quot;tick tock&quot; pattern for removing stuff is common sense.  Be it a database or a rest API, the first step is to grow with a new one and the second is to kill the old one which allows destructive schema actions without downtime.</div><br/><div id="38092252" class="c"><input type="checkbox" id="c-38092252" checked=""/><div class="controls bullet"><span class="by">koreth1</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38091849">parent</a><span>|</span><a href="#38093560">next</a><span>|</span><label class="collapse" for="c-38092252">[-]</label><label class="expand" for="c-38092252">[3 more]</label></div><br/><div class="children"><div class="content">2 deploys isn&#x27;t enough for robustness. It depends on what the change is, but the full sequence is often more like<p>* Add the new schema<p>* Write to both the new and old schemas, keep reading from the old one (can be combined with the previous step if you&#x27;re using something like Flyway)<p>* Backfill the new schema; if there are conflicts, prefer the data from the old schema<p>* Keep writing to both schemas, but switch to reading from the new one (can often be combined with the previous step)<p>* Stop writing to the old schema<p>* Remove the old schema<p>Leave out any one of those steps and you can hit situations where it&#x27;s possible to lose data that&#x27;s written while the new code is rolling out. Though again, it depends on the change; if you&#x27;re, say, dropping a column that no client ever reads or writes, obviously it gets simpler.</div><br/><div id="38092346" class="c"><input type="checkbox" id="c-38092346" checked=""/><div class="controls bullet"><span class="by">reissbaker</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38092252">parent</a><span>|</span><a href="#38093560">next</a><span>|</span><label class="collapse" for="c-38092346">[-]</label><label class="expand" for="c-38092346">[2 more]</label></div><br/><div class="children"><div class="content">Yup, it depends on the change. Sometimes two deploys is enough — e.g. making a non-nullable column nullable — and sometimes you need a more involved process (e.g. backfilling).<p>Nonetheless, I agree with the OP that the article&#x27;s advice is pretty bad. If you ensure that multiple apps&#x2F;services aren&#x27;t sharing the same DB tables, refactoring your schema to better support business needs or reduce tech debt is<p>a. tractable, and<p>b. good.<p>The rules from the article make sense if you have a bunch of different apps and services sharing a database + schema, especially if the apps&#x2F;services are maintained by different teams. But... you really just shouldn&#x27;t put yourself in that situation in the first place. Share data via APIs, not by direct access to the same tables.</div><br/><div id="38093347" class="c"><input type="checkbox" id="c-38093347" checked=""/><div class="controls bullet"><span class="by">sokoloff</span><span>|</span><a href="#38090937">root</a><span>|</span><a href="#38092346">parent</a><span>|</span><a href="#38093560">next</a><span>|</span><label class="collapse" for="c-38093347">[-]</label><label class="expand" for="c-38093347">[1 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t one deploy be enough to convert a non-nullable column to nullable? Going the other way takes two deploys I can see, but this way seems like is entirely backwards compatible.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38093560" class="c"><input type="checkbox" id="c-38093560" checked=""/><div class="controls bullet"><span class="by">sheepscreek</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38091091">prev</a><span>|</span><a href="#38095780">next</a><span>|</span><label class="collapse" for="c-38093560">[-]</label><label class="expand" for="c-38093560">[1 more]</label></div><br/><div class="children"><div class="content">Aside from DBs, there are many other communication tools that use a schema. I can think of at least two: Kafka and serialization libraries like Protobuf and Thrift.</div><br/></div></div><div id="38095780" class="c"><input type="checkbox" id="c-38095780" checked=""/><div class="controls bullet"><span class="by">IceDane</span><span>|</span><a href="#38090937">parent</a><span>|</span><a href="#38093560">prev</a><span>|</span><a href="#38092887">next</a><span>|</span><label class="collapse" for="c-38095780">[-]</label><label class="expand" for="c-38095780">[1 more]</label></div><br/><div class="children"><div class="content">Most of this advice is this bad because it&#x27;s entirely based on the idea that you interact with your database using an extremely dynamic language: clojure. Like most of Hickey&#x27;s advice, it&#x27;s terrible and founded in dogma.</div><br/></div></div></div></div><div id="38092887" class="c"><input type="checkbox" id="c-38092887" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38090937">prev</a><span>|</span><a href="#38090557">next</a><span>|</span><label class="collapse" for="c-38092887">[-]</label><label class="expand" for="c-38092887">[6 more]</label></div><br/><div class="children"><div class="content">Many of these rules are things that only became obvious after I worked on an extremely large production database where downtime was counted in millions of dollars an hour, we didn&#x27;t know who all our users were, some unknown users were load-bearing, and we had a bunch of postmortems describing historical incidents.<p>I don&#x27;t think the article mentions it, but one other technique we used- which still is a big question mark to me- is that we &quot;trickled&quot; changes to the database.  Instead of changing all the rows in a single big transaction, the change was broken into thousands of little changes that were rolled out over a series of days.  The reason for this is that if there is an unexpected problem, you have more time to stop the change and mitigate the damage.</div><br/><div id="38093422" class="c"><input type="checkbox" id="c-38093422" checked=""/><div class="controls bullet"><span class="by">cdchn</span><span>|</span><a href="#38092887">parent</a><span>|</span><a href="#38093938">next</a><span>|</span><label class="collapse" for="c-38093422">[-]</label><label class="expand" for="c-38093422">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Instead of changing all the rows in a single big transaction, the change was broken into thousands of little changes that were rolled out over a series of days.<p>Having been in a situation where a large schema update required migrating data in a transaction, which then broke for some data, but the data was so big that rolling back the transaction caused the database to become totally hosed, I can see this technique being very attractive.</div><br/></div></div><div id="38093938" class="c"><input type="checkbox" id="c-38093938" checked=""/><div class="controls bullet"><span class="by">smfjaw</span><span>|</span><a href="#38092887">parent</a><span>|</span><a href="#38093422">prev</a><span>|</span><a href="#38092911">next</a><span>|</span><label class="collapse" for="c-38093938">[-]</label><label class="expand" for="c-38093938">[1 more]</label></div><br/><div class="children"><div class="content">I really really like partitioned data formats like Parquet&#x2F;Delta etc that allow this for this reason. Often do stuff like this in our data warehouse but hadn&#x27;t thought of &#x27;psuedo partitioning&#x27; the data like this on an operational DB</div><br/></div></div><div id="38092911" class="c"><input type="checkbox" id="c-38092911" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#38092887">parent</a><span>|</span><a href="#38093938">prev</a><span>|</span><a href="#38090557">next</a><span>|</span><label class="collapse" for="c-38092911">[-]</label><label class="expand" for="c-38092911">[3 more]</label></div><br/><div class="children"><div class="content">&gt; the change was broken into thousands of little changes<p>Could you elaborate on how this worked?</div><br/><div id="38093077" class="c"><input type="checkbox" id="c-38093077" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#38092887">root</a><span>|</span><a href="#38092911">parent</a><span>|</span><a href="#38093250">next</a><span>|</span><label class="collapse" for="c-38093077">[-]</label><label class="expand" for="c-38093077">[1 more]</label></div><br/><div class="children"><div class="content">Not OP but here what we have is some routine to get a fact from the DB (eg Customer-&gt;getOrders()) and the routine is schema aware. On v0 it queries a table with one rules, on v1 it&#x27;s a different slightly different query.  So, one small schema mod to eg add a column. Roll out. Another schema mod to populate, possibly a few days later, then roll out queries over a few days, then, later slowly remove the dead parts of the schema and then later drop the legacy code using the old columns. The process can take weeks. And some throwaway code (scaffolding I say) has to pass through the system. I recently was able to clean up and old view that took months to process through (we&#x27;re a small team)<p>One recent one was moving from bitflags in an int column to flags in a jsonb column. Tedious.<p>What makes it work? Testing, testing, testing and management that gives time for that process.</div><br/></div></div><div id="38093250" class="c"><input type="checkbox" id="c-38093250" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38092887">root</a><span>|</span><a href="#38092911">parent</a><span>|</span><a href="#38093077">prev</a><span>|</span><a href="#38090557">next</a><span>|</span><label class="collapse" for="c-38093250">[-]</label><label class="expand" for="c-38093250">[1 more]</label></div><br/><div class="children"><div class="content">Literally, there were many thousands of &quot;UPDATE WHERE&quot; each targeting a different row, and the file was sharded, and then some process would read through a shard and apply statements one at a time with a delay.  It would export stats (# of updates, # of errors) and could be easily paused&#x2F;resumed.<p>We called it trickling, see <a href="https:&#x2F;&#x2F;www.vertica.com&#x2F;docs&#x2F;9.3.x&#x2F;HTML&#x2F;Content&#x2F;Authoring&#x2F;AdministratorsGuide&#x2F;TrickleLoading&#x2F;TrickleLoadingData.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.vertica.com&#x2F;docs&#x2F;9.3.x&#x2F;HTML&#x2F;Content&#x2F;Authoring&#x2F;Ad...</a></div><br/></div></div></div></div></div></div><div id="38090557" class="c"><input type="checkbox" id="c-38090557" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#38092887">prev</a><span>|</span><a href="#38093651">next</a><span>|</span><label class="collapse" for="c-38090557">[-]</label><label class="expand" for="c-38090557">[1 more]</label></div><br/><div class="children"><div class="content">Interesting aside on rules 7 and 8: many Clojure users (myself included) did not often use namespaced keywords until clojure.spec was released, and in clojure.spec, you absolutely need namespacing since specs reside in a global registry. Though in the case of clojure.spec, we typically use the same namespace as our current ns, and there is syntax sugar for this. e.g.<p><pre><code>  ::foo 
</code></pre>
resolves to<p><pre><code>  (keyword *ns* &quot;foo&quot;)
</code></pre>
In Datomic, namespaces tend to represent your application&#x27;s models, like :person&#x2F;date-of-birth.<p>I find it very useful mostly for human readability, it offers a way to distinguish what exactly :name refers to in your application&#x27;s model. It also helps with editor autocomplete since you can type a namespace and see all keys up front, no need to consult a keys spec itself (or the schema of your database in Datomic). And when in doubt, in Datomic, you can always pull, and it is not too hard to run a query that extracts all attributes that exist in your database (this is actually an exercise in Learn Datalog Today[1], highly recommend going through this tutorial yourself if you want to play with databases like Datomic or XTDB).<p>[1] Exercise 2 in <a href="https:&#x2F;&#x2F;www.learndatalogtoday.org&#x2F;chapter&#x2F;4" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.learndatalogtoday.org&#x2F;chapter&#x2F;4</a></div><br/></div></div><div id="38093651" class="c"><input type="checkbox" id="c-38093651" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#38090557">prev</a><span>|</span><a href="#38092088">next</a><span>|</span><label class="collapse" for="c-38093651">[-]</label><label class="expand" for="c-38093651">[1 more]</label></div><br/><div class="children"><div class="content">Postulate #1: your most valuable resource is strong types, well defined business vocabulary, and the follow on generations of developers understanding these concepts<p>Postulate #2: once in production, a schema is likely to outlive you. Spend an enormous amount of time minimizing its scope and making sure it’s correct.<p>Postulate #3: you data has a schema no matter what the mongodb users try to say otherwise.</div><br/></div></div><div id="38092088" class="c"><input type="checkbox" id="c-38092088" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38093651">prev</a><span>|</span><a href="#38094083">next</a><span>|</span><label class="collapse" for="c-38092088">[-]</label><label class="expand" for="c-38092088">[1 more]</label></div><br/><div class="children"><div class="content">In cloud native arrangements, we are looking at the database as the <i>ultimate</i> integration tool. These schema are not owned by any specific service. There is a totally separate universe responsible for how all of that works outside code. Allowing <i>code</i> to drive schema (and permitting the implication that this is the best way) is the biggest frustration I have with ORMs &amp; their higher-order consequences.<p>In my view, if the schema must change so radically that traditional migrations and other &#x27;grow-only&#x27; techniques fall apart, you are probably looking at a properly-dead canary and in need of evacuating the entire coal mine.<p>The Quote regarding flowcharts and tables applies here - if you radically alter the foundation, everything built upon it absolutely must adapt. Every flowchart into the trashcan instantly. Don&#x27;t even think about it. They&#x27;re as good as a ball &amp; chain now. Allowing parts of the structure to dictate parts of the foundation is where we find ourselves with circular firing squads.<p>Take things to the extreme - There is a reason you will start to find roles like &quot;Schema Owner&quot; in large, legacy org charts. These people <i>cannot</i> see the code or they will become tainted. They only have one class of allegiance - LOB owners. These are who they engage to develop &amp; refine schema over time. The schema owner themselves has a <i>full time job</i> that is entirely dedicated to minimizing the impact of change over time to the org. This person is ideally the most ancient wizard in the org chart and has the prior Fred Brooks quote framed on their wall.<p>You can make schema change a top-down event that touches the entire organization. This happens quite often in banking when the central system is <i>completely</i> swapped for a different vendor &amp; tech stack. Most of a bank is just a SQL database, but every vendor has a different schema that has to be adapted to. This is known as &quot;core conversion&quot; in the industry and is one of the more hellish experiences I have ever seen. If a bank with 4 decades of digital records can pull something like this off with regularity, there aren&#x27;t many excuses that remain for a hole-in-the-wall SaaS app with 6 months of customer data.</div><br/></div></div><div id="38094083" class="c"><input type="checkbox" id="c-38094083" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#38092088">prev</a><span>|</span><a href="#38090319">next</a><span>|</span><label class="collapse" for="c-38094083">[-]</label><label class="expand" for="c-38094083">[2 more]</label></div><br/><div class="children"><div class="content">Compare with the usual rules for protobuf evolution:<p>All fields are optional. This is because fields have a lifecycle. Your code might be reading data generated by some other code written before the field was defined, or generated by some other code written after the field became obsolete.<p>With protobufs, you can never reuse a field number. However, you can remove a field (keeping its number reserved), which effectively means ignoring it in new applications. It&#x27;s neither read nor written, which is fine because see above.<p>You can also rename the field itself. This doesn&#x27;t affect the wire protocol.<p>It seems more sensible than having misleading names around for people to trip over. Maybe we&#x27;d be better off if databases used field numbers to refer to columns in the wire protocol?</div><br/><div id="38094231" class="c"><input type="checkbox" id="c-38094231" checked=""/><div class="controls bullet"><span class="by">sundbry</span><span>|</span><a href="#38094083">parent</a><span>|</span><a href="#38090319">next</a><span>|</span><label class="collapse" for="c-38094231">[-]</label><label class="expand" for="c-38094231">[1 more]</label></div><br/><div class="children"><div class="content">This is one nice property of Apache Iceberg (a data lake format, built on top of Parquet). The schemas in the data are evolvable, and require both a name and a field ID to identify the field. The names are changeable, but the ID&#x27;s are immutable, so you can remove a field, and add a new field by the same name, having a different type.</div><br/></div></div></div></div><div id="38090319" class="c"><input type="checkbox" id="c-38090319" checked=""/><div class="controls bullet"><span class="by">Swizec</span><span>|</span><a href="#38094083">prev</a><span>|</span><a href="#38093130">next</a><span>|</span><label class="collapse" for="c-38090319">[-]</label><label class="expand" for="c-38090319">[15 more]</label></div><br/><div class="children"><div class="content">&gt; 5.  Never remove a name.
&gt; Removing a named schema component at any level is a breaking change for programs that depend on that name. Never remove a name.<p>I agree with this in theory and have seen it go oh so very wrong in practice. Tables with dozens of columns, some of which may be unusued, invalid, actively deceiving, or at the very least confusing. Then a new developer joins and goes &quot;A-ha! <i>This</i> is the way to get my data.&quot; ... except it&#x27;s not and now their query is lying to users, analysts, leadership, anyone who thinks they&#x27;re looking at the right data but isn&#x27;t.<p>You absolutely <i>have to</i> make time to deprecate and remove parts of the schema that are no longer valid. Even if it means breaking a few eggs (hopefully during a thorough test run or phased rollout)</div><br/><div id="38091017" class="c"><input type="checkbox" id="c-38091017" checked=""/><div class="controls bullet"><span class="by">BWStearns</span><span>|</span><a href="#38090319">parent</a><span>|</span><a href="#38091143">next</a><span>|</span><label class="collapse" for="c-38091017">[-]</label><label class="expand" for="c-38091017">[2 more]</label></div><br/><div class="children"><div class="content">This x100. The most miserable and frustrating periods of my career have been in places that never deprecated anything. You could spend hours doing something that looked quite sensible, get a working draft that seemed to work, and then be told &quot;oh yeah, that&#x27;s deprecated, that data isn&#x27;t even populated anymore, those rows just _happened_ to have data in dev.&quot; Then you either start sanity checking everything before doing anything and your velocity sucks, or just keep stepping on landmines and losing whole afternoons.<p>Edited to add: docs can help, but only so much. Environments that cluttered also tend to have layers of docs that are equally misleading.</div><br/><div id="38094763" class="c"><input type="checkbox" id="c-38094763" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38091017">parent</a><span>|</span><a href="#38091143">next</a><span>|</span><label class="collapse" for="c-38094763">[-]</label><label class="expand" for="c-38094763">[1 more]</label></div><br/><div class="children"><div class="content">There are few things more important than comprehensive and up to date database documentation.  Otherwise you don&#x27;t even know what your data means. An organization that cannot produce documentation like that is somewhere between amateurish and waiting for a disaster to happen, unfortunately.</div><br/></div></div></div></div><div id="38091143" class="c"><input type="checkbox" id="c-38091143" checked=""/><div class="controls bullet"><span class="by">__jem</span><span>|</span><a href="#38090319">parent</a><span>|</span><a href="#38091017">prev</a><span>|</span><a href="#38095606">next</a><span>|</span><label class="collapse" for="c-38091143">[-]</label><label class="expand" for="c-38091143">[2 more]</label></div><br/><div class="children"><div class="content">Reclaiming the physical storage of an unused column is often a costly and sometimes impossible operation, which is why many legacy applications end up with the equivalent of my_column_final_final_v2. Database administration requires compromises like this sometimes in the name of uptime and data integrity. Big migrations are always inherently a little risky, and from the view of many DBAs, why even risk it just for a bit of clean up? Your schema shouldn&#x27;t be totally transparent to your application&#x27;s business logic anyway, so there are better places to enforce naming hygiene.</div><br/><div id="38094821" class="c"><input type="checkbox" id="c-38094821" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38091143">parent</a><span>|</span><a href="#38095606">next</a><span>|</span><label class="collapse" for="c-38094821">[-]</label><label class="expand" for="c-38094821">[1 more]</label></div><br/><div class="children"><div class="content">I believe in most relational databases you can just alter a column to allow null values and run a series of transactions in the background to set that column value to null, and that will quite effectively free up most of the physical overhead of the column in question. I would be reluctant to delete, rename, or even clear all the data out of a column without providing an alias though.</div><br/></div></div></div></div><div id="38095606" class="c"><input type="checkbox" id="c-38095606" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#38090319">parent</a><span>|</span><a href="#38091143">prev</a><span>|</span><a href="#38093066">next</a><span>|</span><label class="collapse" for="c-38095606">[-]</label><label class="expand" for="c-38095606">[1 more]</label></div><br/><div class="children"><div class="content">worse, I&#x27;ve seen supposedly unused columns be used for some other purpose, and then existing analytics fall apart.</div><br/></div></div><div id="38093066" class="c"><input type="checkbox" id="c-38093066" checked=""/><div class="controls bullet"><span class="by">tootie</span><span>|</span><a href="#38090319">parent</a><span>|</span><a href="#38095606">prev</a><span>|</span><a href="#38092867">next</a><span>|</span><label class="collapse" for="c-38093066">[-]</label><label class="expand" for="c-38093066">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this how you grow to the point of destruction. Your schema is half noise and nobody understands it. Then someone says you need to start from scratch.</div><br/></div></div><div id="38092867" class="c"><input type="checkbox" id="c-38092867" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#38090319">parent</a><span>|</span><a href="#38093066">prev</a><span>|</span><a href="#38090591">next</a><span>|</span><label class="collapse" for="c-38092867">[-]</label><label class="expand" for="c-38092867">[1 more]</label></div><br/><div class="children"><div class="content">Hyrum&#x27;s law in action.</div><br/></div></div><div id="38090591" class="c"><input type="checkbox" id="c-38090591" checked=""/><div class="controls bullet"><span class="by">tkiolp4</span><span>|</span><a href="#38090319">parent</a><span>|</span><a href="#38092867">prev</a><span>|</span><a href="#38093130">next</a><span>|</span><label class="collapse" for="c-38090591">[-]</label><label class="expand" for="c-38090591">[7 more]</label></div><br/><div class="children"><div class="content">But then why not addressing the real problem? If a table has a few columns which are not used or invalid or deceiving, why did we let developers introduce them? Lack of planning? Lack of peer review? Lack of talent?<p>I understand these “ten rules” as: as long as you have a decent codebase and decent engineers, these ten rules will make your life easier.<p>These rules are nothing if you are dealing with crap codebases (they can help, sure, but they will be just patches)</div><br/><div id="38090726" class="c"><input type="checkbox" id="c-38090726" checked=""/><div class="controls bullet"><span class="by">striking</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38090591">parent</a><span>|</span><a href="#38091187">next</a><span>|</span><label class="collapse" for="c-38090726">[-]</label><label class="expand" for="c-38090726">[1 more]</label></div><br/><div class="children"><div class="content">Because sometimes you make assumptions that are seemingly correct but eventually found to be wrong or based on flawed inputs from sources beyond your control.<p>Any system that ultimately relies on &quot;engineers need to always do the right thing&quot; is a flawed, brittle, ineffectual system. Because even the best engineers will make a mistake somewhere, and because you can&#x27;t exclusively hire &quot;the best&quot; engineers.<p>Let&#x27;s spend our time figuring out how to recover from mistakes rather than trying to pretend they&#x27;ll never happen.</div><br/></div></div><div id="38091187" class="c"><input type="checkbox" id="c-38091187" checked=""/><div class="controls bullet"><span class="by">__jem</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38090591">parent</a><span>|</span><a href="#38090726">prev</a><span>|</span><a href="#38094555">next</a><span>|</span><label class="collapse" for="c-38091187">[-]</label><label class="expand" for="c-38091187">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked with some databases that are 20+ years old and have outlived multiple application iterations. There&#x27;s always going to be cruft in this kind of situation, it just comes with territory of supporting applications with real production users for a long time.</div><br/></div></div><div id="38094555" class="c"><input type="checkbox" id="c-38094555" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38090591">parent</a><span>|</span><a href="#38091187">prev</a><span>|</span><a href="#38090790">next</a><span>|</span><label class="collapse" for="c-38094555">[-]</label><label class="expand" for="c-38094555">[1 more]</label></div><br/><div class="children"><div class="content">Developers without special training should generally not do database design for the sort of databases that are intended to last decades.  It is a similar task to developing a complex file format that is usable twenty years later - not something to be done off the cuff, and if you want schema stability database design requires more care than most file formats.</div><br/></div></div><div id="38090790" class="c"><input type="checkbox" id="c-38090790" checked=""/><div class="controls bullet"><span class="by">phtrivier</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38090591">parent</a><span>|</span><a href="#38094555">prev</a><span>|</span><a href="#38091495">next</a><span>|</span><label class="collapse" for="c-38090790">[-]</label><label class="expand" for="c-38090790">[1 more]</label></div><br/><div class="children"><div class="content">Even the best team make design decision that turns out suboptimal when the requirement changes.<p>Also, even the best team will sometimes make mistake.<p>Db schemas are unforgiving.</div><br/></div></div><div id="38091495" class="c"><input type="checkbox" id="c-38091495" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38090591">parent</a><span>|</span><a href="#38090790">prev</a><span>|</span><a href="#38093130">next</a><span>|</span><label class="collapse" for="c-38091495">[-]</label><label class="expand" for="c-38091495">[2 more]</label></div><br/><div class="children"><div class="content">Requirements change over time. Domain understanding change over tim. Business change over time. Environments change over time. Unless you are a seer with perfect precognition, most of what you have done will be invalidated over time.<p>Hence: make your code and data easy to change, but simple, as you cannot predict in what way it will change.</div><br/><div id="38092502" class="c"><input type="checkbox" id="c-38092502" checked=""/><div class="controls bullet"><span class="by">Swizec</span><span>|</span><a href="#38090319">root</a><span>|</span><a href="#38091495">parent</a><span>|</span><a href="#38093130">next</a><span>|</span><label class="collapse" for="c-38092502">[-]</label><label class="expand" for="c-38092502">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unless you are a seer with perfect precognition<p>Even then ain&#x27;t nobody in a 10 person seed-stage startup got time, resources, or need to build the database you&#x27;ll want to have when you&#x27;re a 600 person Series C monster.</div><br/></div></div></div></div></div></div></div></div><div id="38093130" class="c"><input type="checkbox" id="c-38093130" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#38090319">prev</a><span>|</span><a href="#38090709">next</a><span>|</span><label class="collapse" for="c-38093130">[-]</label><label class="expand" for="c-38093130">[6 more]</label></div><br/><div class="children"><div class="content">Wow these are shockingly bad rules. This is how we end up with DBs with hundreds of tables and duplicate columns like `name` and `name2`.<p>My number one rule of growing schemas is to design your schemas and applications with a good custom field system. Some kind of flexible way of being able to add fields to items as data.</div><br/><div id="38093307" class="c"><input type="checkbox" id="c-38093307" checked=""/><div class="controls bullet"><span class="by">JackMorgan</span><span>|</span><a href="#38093130">parent</a><span>|</span><a href="#38093144">next</a><span>|</span><label class="collapse" for="c-38093307">[-]</label><label class="expand" for="c-38093307">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen some horror stories at companies with that sort of custom column schema. Today I think just adding a new column is a lot better in the long term. Custom fields systems will quickly contain several different &quot;versions&quot; of the records, but there is no easy way to see which is what. At some point it feels like re-inventing a datalog or key-value database, but those have query systems better-suited to the task.</div><br/></div></div><div id="38093144" class="c"><input type="checkbox" id="c-38093144" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#38093130">parent</a><span>|</span><a href="#38093307">prev</a><span>|</span><a href="#38093883">next</a><span>|</span><label class="collapse" for="c-38093144">[-]</label><label class="expand" for="c-38093144">[3 more]</label></div><br/><div class="children"><div class="content">Ahhh the entity-attribute-value pattern.<p>When your sql database needs another sql engine to translate to actual EAV queries.<p>But they are fun schemas!<p>The old joke that there are two actually hard problems in CS: caching and naming things. The older I get, naming things IMO is far more difficult.</div><br/><div id="38095321" class="c"><input type="checkbox" id="c-38095321" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#38093130">root</a><span>|</span><a href="#38093144">parent</a><span>|</span><a href="#38093431">next</a><span>|</span><label class="collapse" for="c-38095321">[-]</label><label class="expand" for="c-38095321">[1 more]</label></div><br/><div class="children"><div class="content">The thing about naming is that it is so closely related to how the problem domain (not business domain, though they are of course related) is understood, and how well it is conceptualized.</div><br/></div></div><div id="38093431" class="c"><input type="checkbox" id="c-38093431" checked=""/><div class="controls bullet"><span class="by">cdchn</span><span>|</span><a href="#38093130">root</a><span>|</span><a href="#38093144">parent</a><span>|</span><a href="#38095321">prev</a><span>|</span><a href="#38093883">next</a><span>|</span><label class="collapse" for="c-38093431">[-]</label><label class="expand" for="c-38093431">[1 more]</label></div><br/><div class="children"><div class="content">When you start looking at SQL tables that are just id,key,val then you know you&#x27;ve teleported into this forbidden realm.<p>There are 2 hard problems in computer science: caching, naming things, and off-by-one errors.</div><br/></div></div></div></div><div id="38093883" class="c"><input type="checkbox" id="c-38093883" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#38093130">parent</a><span>|</span><a href="#38093144">prev</a><span>|</span><a href="#38090709">next</a><span>|</span><label class="collapse" for="c-38093883">[-]</label><label class="expand" for="c-38093883">[1 more]</label></div><br/><div class="children"><div class="content">Custom fields system is generally a bad idea imo. Just do JSON if you want that</div><br/></div></div></div></div><div id="38090709" class="c"><input type="checkbox" id="c-38090709" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#38093130">prev</a><span>|</span><a href="#38092900">next</a><span>|</span><label class="collapse" for="c-38090709">[-]</label><label class="expand" for="c-38090709">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Data outlives code, and a valuable database supports many applications over time.<p>Probably an unpopular opinion, but I think having a central database that <i>directly</i> interfaces with multiple applications is an enormous source of technical debt and other risks, and unnecessary for most organizations. Read-only users are fine for exploratory&#x2F;analytical stuff, but multiple independent writers&#x2F;cooks is a recipe for disaster.<p>I prefer an architecture where the central &quot;database&quot; is a central, monolithic Django&#x2F;Rails&#x2F;NodeJS&#x2F;Spring app that <i>totally</i> owns the actual database, and if someone needs access to the data, you whip up an HTTPS API for them.<p>Yes, it is a tiny bit of effort to &quot;whip up an API&quot; but it deals with so many of the footguns implied by this article. &quot;I need X+Y tables formatted as Z JSON&quot; is a 5 minute dev task in a modern framework.</div><br/><div id="38090875" class="c"><input type="checkbox" id="c-38090875" checked=""/><div class="controls bullet"><span class="by">gwn7</span><span>|</span><a href="#38090709">parent</a><span>|</span><a href="#38093676">next</a><span>|</span><label class="collapse" for="c-38090875">[-]</label><label class="expand" for="c-38090875">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think having a central database that directly interfaces with multiple applications is an enormous source of technical debt and other risks, and unnecessary for most organizations.<p>I think that the operative word here is &quot;over time&quot;. So what is meant is not necessarily supporting many applications at the same time, but rather serially.<p>So the message is supposed to be: Apps come and go as they can be rewritten for so many reasons, but there will be a lot less reasons to redesign &#x2F; replace a &quot;valuable&quot; database.</div><br/></div></div><div id="38093676" class="c"><input type="checkbox" id="c-38093676" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#38090709">parent</a><span>|</span><a href="#38090875">prev</a><span>|</span><a href="#38090907">next</a><span>|</span><label class="collapse" for="c-38093676">[-]</label><label class="expand" for="c-38093676">[3 more]</label></div><br/><div class="children"><div class="content">&gt;Probably an unpopular opinion, but I think having a central database that directly interfaces with multiple applications is an enormous source of technical debt and other risks, and unnecessary for most organizations. Read-only users are fine for exploratory&#x2F;analytical stuff, but multiple independent writers&#x2F;cooks is a recipe for disaster.<p>In my org I&#x27;ve felt the pain of having centralized DBs (with many writers and many readers) a lot of our woes come because of legacy debt some of these databases are quite old - a number date back to the mid 90&#x27;s so over time they&#x27;ve ballooned considerably.<p>The Architecture I&#x27;ve found which makes things less painful is to transition the the centralized database into two databases.<p>On Database A you keep the legacy schemas etc and restrict access only to the DB writers (in our case we have A2A messaging queues as well as some compiled binaries which directly write to the DB). Then you have data replicated from database A into database B. Database B is where the data consumers (BI tools, reporting, etc) interface with the data.<p>You can exercise greater control over the schema on B which is exposed to the data consumers without needing to mass recompile binaries which can continue writing to Database A.<p>I&#x27;m not sure how &quot;proper&quot; DBAs feel about this split but it works for my usecase and has helped control ballooning legacy databases somewhat.</div><br/><div id="38093755" class="c"><input type="checkbox" id="c-38093755" checked=""/><div class="controls bullet"><span class="by">rawgabbit</span><span>|</span><a href="#38090709">root</a><span>|</span><a href="#38093676">parent</a><span>|</span><a href="#38090907">next</a><span>|</span><label class="collapse" for="c-38093755">[-]</label><label class="expand" for="c-38093755">[2 more]</label></div><br/><div class="children"><div class="content">What you did is CQRS architect ure pattern and is the recommended path. It separates command writes from query reads.</div><br/><div id="38094170" class="c"><input type="checkbox" id="c-38094170" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#38090709">root</a><span>|</span><a href="#38093755">parent</a><span>|</span><a href="#38090907">next</a><span>|</span><label class="collapse" for="c-38094170">[-]</label><label class="expand" for="c-38094170">[1 more]</label></div><br/><div class="children"><div class="content">Thankyou - good to know there is a name for the pattern I&#x27;m reading more about it now.</div><br/></div></div></div></div></div></div><div id="38090907" class="c"><input type="checkbox" id="c-38090907" checked=""/><div class="controls bullet"><span class="by">timeagain</span><span>|</span><a href="#38090709">parent</a><span>|</span><a href="#38093676">prev</a><span>|</span><a href="#38090805">next</a><span>|</span><label class="collapse" for="c-38090907">[-]</label><label class="expand" for="c-38090907">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. When a company outgrows its monolith this component you describe is normally the hardest part to figure out. All those sneaky little joins and stored procedures and undocumented use cases come pouring out. If your data layer has an API from the start it makes everyone act honestly about data access and provides more accountability. An API layer also allows for more options when dealing with caching, noisy neighbors, retention, consistency, and security.</div><br/><div id="38094582" class="c"><input type="checkbox" id="c-38094582" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#38090709">root</a><span>|</span><a href="#38090907">parent</a><span>|</span><a href="#38090805">next</a><span>|</span><label class="collapse" for="c-38094582">[-]</label><label class="expand" for="c-38094582">[1 more]</label></div><br/><div class="children"><div class="content">what is noisy neighbors, and what&#x27;s the issue with consistency?</div><br/></div></div></div></div><div id="38090805" class="c"><input type="checkbox" id="c-38090805" checked=""/><div class="controls bullet"><span class="by">wrs</span><span>|</span><a href="#38090709">parent</a><span>|</span><a href="#38090907">prev</a><span>|</span><a href="#38091689">next</a><span>|</span><label class="collapse" for="c-38090805">[-]</label><label class="expand" for="c-38090805">[2 more]</label></div><br/><div class="children"><div class="content">In that architecture, the central API effectively becomes “the database”, because apps depend on it just as much. Most of the same rules would apply to the central API’s schema.</div><br/><div id="38091086" class="c"><input type="checkbox" id="c-38091086" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#38090709">root</a><span>|</span><a href="#38090805">parent</a><span>|</span><a href="#38091689">next</a><span>|</span><label class="collapse" for="c-38091086">[-]</label><label class="expand" for="c-38091086">[1 more]</label></div><br/><div class="children"><div class="content">Conceptually, yes they are the same unit. Which is part of the beauty of it; it&#x27;s not a radical paradigm shift like monolith-&gt;microservices or systemd-&gt;k8s. But the developer experience&#x2F;productivity of bending Django or Rails in different ways is far superior to bending e.g. MySQL or PostgreSQL*. HTTPS is plainly a much better, and more widely available, integration protocol than N different SQL dialects.<p>*much respect to what the Crunchy Data folks have accomplished</div><br/></div></div></div></div><div id="38091689" class="c"><input type="checkbox" id="c-38091689" checked=""/><div class="controls bullet"><span class="by">plandis</span><span>|</span><a href="#38090709">parent</a><span>|</span><a href="#38090805">prev</a><span>|</span><a href="#38090961">next</a><span>|</span><label class="collapse" for="c-38091689">[-]</label><label class="expand" for="c-38091689">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, it’s less risk to take the advice in the article because even if you only have a monolith as the sole producer&#x2F;consumer you could still mess up and make a backwards incompatible change. Humans are fallible, so try to minimize human error.<p>One way to minimize the human error is by only extending the schema rather than changing it and forcing your monolith to correctly make changes to existing queries.<p>I’m not saying adding an API is bad, because it’s not. I just think it’s solving a different set of problems.</div><br/></div></div><div id="38090961" class="c"><input type="checkbox" id="c-38090961" checked=""/><div class="controls bullet"><span class="by">vb-8448</span><span>|</span><a href="#38090709">parent</a><span>|</span><a href="#38091689">prev</a><span>|</span><a href="#38092900">next</a><span>|</span><label class="collapse" for="c-38090961">[-]</label><label class="expand" for="c-38090961">[2 more]</label></div><br/><div class="children"><div class="content">&gt; is an enormous source of technical debt<p>I totally agree with you, but I think in the real world (mostly in monolithic apps, microservices shouldn&#x27;t be affected) at some point someone will try to access directly the database. There are several reasons for doing this: API are too slow, it&#x27;s simpler and more immediate writing some SQL vs a http client, the team responsible for APIs it&#x27;s no more around and similar.</div><br/><div id="38094619" class="c"><input type="checkbox" id="c-38094619" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38090709">root</a><span>|</span><a href="#38090961">parent</a><span>|</span><a href="#38092900">next</a><span>|</span><label class="collapse" for="c-38094619">[-]</label><label class="expand" for="c-38094619">[1 more]</label></div><br/><div class="children"><div class="content">Every non-trivial API has a data model, and API stability requires that it be as carefully designed as any database, unless you are going to start rolling incompatible API versions off the photocopier, which is no small task.<p>The entire idea of an unanticipated JOIN is beyond the ken of most APIs as well, unfortunately. For an external API that may not be much of a problem, but for an internal one you might end up creating a new de facto schema with a new query language.</div><br/></div></div></div></div></div></div><div id="38090287" class="c"><input type="checkbox" id="c-38090287" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#38092900">prev</a><span>|</span><a href="#38093160">next</a><span>|</span><label class="collapse" for="c-38090287">[-]</label><label class="expand" for="c-38090287">[4 more]</label></div><br/><div class="children"><div class="content">I wish there were open source, less Clojure-centric implementations of Datomic, particularly as a plugin over something like Postgres. It has many good ideas</div><br/><div id="38090448" class="c"><input type="checkbox" id="c-38090448" checked=""/><div class="controls bullet"><span class="by">sweetsocks21</span><span>|</span><a href="#38090287">parent</a><span>|</span><a href="#38093163">next</a><span>|</span><label class="collapse" for="c-38090448">[-]</label><label class="expand" for="c-38090448">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been keeping an eye on <a href="https:&#x2F;&#x2F;github.com&#x2F;cozodb&#x2F;cozo">https:&#x2F;&#x2F;github.com&#x2F;cozodb&#x2F;cozo</a> which is pretty close to something I&#x27;ve wanted, a sqlite version of datalog&#x2F;datomic.</div><br/></div></div><div id="38093163" class="c"><input type="checkbox" id="c-38093163" checked=""/><div class="controls bullet"><span class="by">stcg</span><span>|</span><a href="#38090287">parent</a><span>|</span><a href="#38090448">prev</a><span>|</span><a href="#38090401">next</a><span>|</span><label class="collapse" for="c-38093163">[-]</label><label class="expand" for="c-38093163">[1 more]</label></div><br/><div class="children"><div class="content">Datahike [0] provides similar functionality to datomic and is open source. It lacks some features however that Datomic does have [1].<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;replikativ&#x2F;datahike">https:&#x2F;&#x2F;github.com&#x2F;replikativ&#x2F;datahike</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;replikativ&#x2F;datahike#when-to-choose-datahike-vs-datomic-vs-datascript">https:&#x2F;&#x2F;github.com&#x2F;replikativ&#x2F;datahike#when-to-choose-datahi...</a></div><br/></div></div><div id="38090401" class="c"><input type="checkbox" id="c-38090401" checked=""/><div class="controls bullet"><span class="by">yayitswei</span><span>|</span><a href="#38090287">parent</a><span>|</span><a href="#38093163">prev</a><span>|</span><a href="#38093160">next</a><span>|</span><label class="collapse" for="c-38090401">[-]</label><label class="expand" for="c-38090401">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s XTDB which is still Clojure-centric but is at least open-source. It supports SQL queries.</div><br/></div></div></div></div><div id="38093160" class="c"><input type="checkbox" id="c-38093160" checked=""/><div class="controls bullet"><span class="by">riffic</span><span>|</span><a href="#38090287">prev</a><span>|</span><a href="#38092840">next</a><span>|</span><label class="collapse" for="c-38093160">[-]</label><label class="expand" for="c-38093160">[2 more]</label></div><br/><div class="children"><div class="content">why is no one talking about modeling or ERD or anything of that sort?</div><br/><div id="38094710" class="c"><input type="checkbox" id="c-38094710" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38093160">parent</a><span>|</span><a href="#38092840">next</a><span>|</span><label class="collapse" for="c-38094710">[-]</label><label class="expand" for="c-38094710">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t design a non-trivial API without doing a data model of some sort, personally, because every non-trivial API exposes one.</div><br/></div></div></div></div><div id="38092840" class="c"><input type="checkbox" id="c-38092840" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#38093160">prev</a><span>|</span><label class="collapse" for="c-38092840">[-]</label><label class="expand" for="c-38092840">[5 more]</label></div><br/><div class="children"><div class="content">They completely lost me when they said the database is the definite source of the schema.<p>Sounds like 90s DB admins making a case for the bad old way of doing things.</div><br/><div id="38094704" class="c"><input type="checkbox" id="c-38094704" checked=""/><div class="controls bullet"><span class="by">butlerm</span><span>|</span><a href="#38092840">parent</a><span>|</span><a href="#38094591">next</a><span>|</span><label class="collapse" for="c-38094704">[-]</label><label class="expand" for="c-38094704">[1 more]</label></div><br/><div class="children"><div class="content">It has never been standard practice to store the database schema and its history, notes, and documentation in the database, although data dictionaries come close.  There are database catalogs that can carry a subset of that information, but a more traditional &quot;90s&quot; approach is to use a data modeling tool.<p>If you want detailed change history it is hard to avoid using DDL files with source code control, although notes go a long way.  Most databases are not good at change history - not even good at representing it, unfortunately.<p>It is also quite easy to do a mediocre job of anything, and I would be careful of counting anything as the &quot;bad old way&quot; with out a careful evaluation of the pros and cons of the &quot;new good way&quot; as well.  A casual observer might wonder why so many modern web apps have response times that are ten to twenty times longer than they were two decades ago, for example. Perhaps - on occasion - the new good way isn&#x27;t so good.</div><br/></div></div><div id="38094591" class="c"><input type="checkbox" id="c-38094591" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#38092840">parent</a><span>|</span><a href="#38094704">prev</a><span>|</span><a href="#38093185">next</a><span>|</span><label class="collapse" for="c-38094591">[-]</label><label class="expand" for="c-38094591">[1 more]</label></div><br/><div class="children"><div class="content">Same. Why is having the schema in the db a bad idea?</div><br/></div></div><div id="38093185" class="c"><input type="checkbox" id="c-38093185" checked=""/><div class="controls bullet"><span class="by">JackMorgan</span><span>|</span><a href="#38092840">parent</a><span>|</span><a href="#38094591">prev</a><span>|</span><label class="collapse" for="c-38093185">[-]</label><label class="expand" for="c-38093185">[2 more]</label></div><br/><div class="children"><div class="content">Could you elaborate on this?</div><br/><div id="38094833" class="c"><input type="checkbox" id="c-38094833" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#38092840">root</a><span>|</span><a href="#38093185">parent</a><span>|</span><label class="collapse" for="c-38094833">[-]</label><label class="expand" for="c-38094833">[1 more]</label></div><br/><div class="children"><div class="content">As another commenter on this posted, you should keep your schema in version control just like your code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>