<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692435656830" as="style"/><link rel="stylesheet" href="styles.css?v=1692435656830"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://loup-vaillant.fr/articles/hsm-done-right">Fixing the TPM: Hardware Security Modules Done Right</a> <span class="domain">(<a href="https://loup-vaillant.fr">loup-vaillant.fr</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>59 comments</span></div><br/><div><div id="37186652" class="c"><input type="checkbox" id="c-37186652" checked=""/><div class="controls bullet"><span class="by">mrnoone</span><span>|</span><a href="#37186390">next</a><span>|</span><label class="collapse" for="c-37186652">[-]</label><label class="expand" for="c-37186652">[1 more]</label></div><br/><div class="children"><div class="content">This article simplifies the problem and commits factual errors.<p>TPM is not HSM, not enclave, and it does not allow running arbitrary computation. TPM is a specification of a secure element, that provides some cryptographic primitives, secure storage, signing mechanism (endorsement key), and a few more. Since it is available since very early boot stage it is used for storing and signing integrity measurements.<p>HSM or TPM never release the signing key as authors writes. DICE does not release the initial seed used to derive the inital hash&#x2F;key.<p>DICE addresses different market. It was designed by the same organization that designed TPM but addresses IoT devices. Microsoft extended the spec so that one gets chain of signed measurements instead of an aggregated hash as an attestation proof (at a high level).<p>DICE gets more popular in TEE designs because one does not have to rely on an external chip vulnerable to physical attacks. However, it is the same set of features needed for DICE and TPM to enable attestation. TPM offers additional features, like mono tonic counters, secure storage, sealing, etc, that can be used for other use cases.<p>Finally, TPM became a standard and has been implemented as part of complex processor’s firmware (Intel PTT), discrete TPM (what the author of the article is familiar with), software TPMs enabling attestation for VMs and recently used also for confidential computing VMs (check Intel TDX). Linux kernel supports runtime integrity measurements with IMA security subsystem that relies on TPM protocol for attestation.</div><br/></div></div><div id="37186390" class="c"><input type="checkbox" id="c-37186390" checked=""/><div class="controls bullet"><span class="by">JoachimS</span><span>|</span><a href="#37186652">prev</a><span>|</span><a href="#37181621">next</a><span>|</span><label class="collapse" for="c-37186390">[-]</label><label class="expand" for="c-37186390">[1 more]</label></div><br/><div class="children"><div class="content">This is soo cool! Very happy to see this.<p>One thing I mentioned in a talk about at the TKey at FOSS-North this spring was that the internal name for the project at Mullvad that ultimately lead to the TKey was &quot;TPM-ish&quot;. The idea was to develop a evice with just the parts of the TPM API needed to perform measured boot, but that we could control and trust.<p>This idea got simplified into a hardware Root of Trust device that could only do Ed25519 signing. Basically an iCE 40 UP FPGA mounted on a PCB talking SPI or LPC. And since it was based on RISC-V it didn&#x27;t take long until Mullvad founder Fredrik Strömberg proposed that by combining with the DICE concept we could generalize it into what has become the Tkey.<p>The TKey Unlocked will be available very soon. These devices are not provisioned and not locked by Tillitis. This allows you to provision the UDS and UDI yourself, and do anything else you want with the TKey. This includes modifying the FW and the FPGA design. There will also be a TKey programmer to allow you to program TKey devices:<p><a href="https:&#x2F;&#x2F;shop.tillitis.se&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;shop.tillitis.se&#x2F;</a></div><br/></div></div><div id="37181621" class="c"><input type="checkbox" id="c-37181621" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#37186390">prev</a><span>|</span><a href="#37182874">next</a><span>|</span><label class="collapse" for="c-37181621">[-]</label><label class="expand" for="c-37181621">[29 more]</label></div><br/><div class="children"><div class="content">Hmmmm...<p>I could not care less about Microsoft&#x27;s problem, but could this approach fix the major problem that I have with TPM?<p>TPM allows software to leverage my machine against me. If DICE allows me to revoke keys that have been stored for other applications (or, even better, to prevent the HSM from being used by anything without my overt permission), that might go a long way toward reducing that issue.</div><br/><div id="37182522" class="c"><input type="checkbox" id="c-37182522" checked=""/><div class="controls bullet"><span class="by">DistractionRect</span><span>|</span><a href="#37181621">parent</a><span>|</span><a href="#37183101">next</a><span>|</span><label class="collapse" for="c-37182522">[-]</label><label class="expand" for="c-37182522">[17 more]</label></div><br/><div class="children"><div class="content">Similar sentiments, I&#x27;m already seeing this with Android and custom roms.<p>Right now you get away with spoofing basic integrity checks, but custom roms cannot pass hardware attestation. It&#x27;s not a hard requirement right now in order to maintain backwards compatibility required to target 90%+ of android devices, but give it a few generations and it will be. At that piont I expect a majority of apps will simply be unusable on custom roms, and we&#x27;ll have no choice but to embrace planned obsolescence.</div><br/><div id="37184836" class="c"><input type="checkbox" id="c-37184836" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182522">parent</a><span>|</span><a href="#37182893">next</a><span>|</span><label class="collapse" for="c-37184836">[-]</label><label class="expand" for="c-37184836">[2 more]</label></div><br/><div class="children"><div class="content">Yeah. We used to have complete control over our android devices <i>and</i> the apps that ran on them. This hardware attestation business is gonna destroy all that. Right now I can&#x27;t even launch my bank&#x27;s app if I have developer mode enabled. They say it&#x27;s only gonna be for the apps that &quot;really need it&quot; but that&#x27;s just Google boiling the frog slowly.<p>Might as well buy an iPhone if that&#x27;s how it&#x27;s going to be.</div><br/><div id="37186242" class="c"><input type="checkbox" id="c-37186242" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37184836">parent</a><span>|</span><a href="#37182893">next</a><span>|</span><label class="collapse" for="c-37186242">[-]</label><label class="expand" for="c-37186242">[1 more]</label></div><br/><div class="children"><div class="content">That’s a sad jump. I’d say support&#x2F;embrace Linux mobile, but we know the app makers won’t support it (and shitty apps like Signal <i>require</i> a primary device running one of the mobile duopoly OSs) &amp; we we know Google with its Web Integrity wants to lock down our web browsing sanctuary that runs on any platform. Yeah, we might be forced into it… or be prepared to go low-tech like going to the bank &amp; calling.<p>For me this will be really bad if I’m traveling abroad since the website requires 2FA &amp; SMS is the only option which will be roaming &amp; even the annual number swap I do when I get a new SIM requires paperwork &amp; waiting a week for processing. But maybe owning a phone is more of a burden due to lack of device control &amp; privacy concerns.</div><br/></div></div></div></div><div id="37182893" class="c"><input type="checkbox" id="c-37182893" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182522">parent</a><span>|</span><a href="#37184836">prev</a><span>|</span><a href="#37182701">next</a><span>|</span><label class="collapse" for="c-37182893">[-]</label><label class="expand" for="c-37182893">[6 more]</label></div><br/><div class="children"><div class="content">&gt; custom roms cannot pass hardware attestation.<p>So this is going to be the interesting question, because obviously they can, they just have to extract the keys from something first. Devices are made by all kinds of vendors and it only takes one vulnerability before you have a market for keys. There are &lt;$200 phones, those cheap phones are <i>more</i> likely to have a vulnerability, and when one of them gets a cracked screen the market value drops to near-zero which makes it cheap to buy one to extract the key.<p>Which is also why remote attestation is totally worthless. An attacker can do the same thing, so relying on the attestation is completely insecure because in practice anyone with a couple bucks will be able to spoof it.<p>But if extracting a key is mildly inconvenient or legally questionable, it will be enough to deter honest casual users but not profit-motivated attackers, and you get the worst of both worlds.<p>So we need to do everything to make sure that doesn&#x27;t happen. One way is to make extracting keys as easy as possible, of course.<p>Another is to make sure that everybody understands the perversity of this nonsense. It&#x27;s snake oil the likes of export-grade encryption or EV certificates. Anyone caught using it should be mocked mercilessly and added to a list of disfavored vendors with uninformed security staff. Anything in a position to do so should warn if anything attempts to use it, or disable it to make it more difficult for anything else to rely on its availability. Warnings should emphasize that using it is a security risk that can enable hard to detect malware and is an indication of malice or incompetence.<p>It needs to go away.</div><br/><div id="37183714" class="c"><input type="checkbox" id="c-37183714" checked=""/><div class="controls bullet"><span class="by">DistractionRect</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182893">parent</a><span>|</span><a href="#37183702">next</a><span>|</span><label class="collapse" for="c-37183714">[-]</label><label class="expand" for="c-37183714">[2 more]</label></div><br/><div class="children"><div class="content">$200 dollar phones likely aren&#x27;t rolling their own HSMs. It&#x27;ll probably be one of a few made big Co.s like Google, Samsung, Qualcomm, etc. I expect it&#x27;ll be about as hard as getting them off $2000 dollar phones.<p>Even if it&#x27;s possible, that too will be a cat and mouse game which won&#x27;t work for long. Hardware DRM has been an evolving industry, and now with the commonality of TPMs and HSMs it&#x27;s here to stay.</div><br/><div id="37183928" class="c"><input type="checkbox" id="c-37183928" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37183714">parent</a><span>|</span><a href="#37183702">next</a><span>|</span><label class="collapse" for="c-37183928">[-]</label><label class="expand" for="c-37183928">[1 more]</label></div><br/><div class="children"><div class="content">&gt; $200 dollar phones likely aren&#x27;t rolling their own HSMs. It&#x27;ll probably be one of a few made big Co.s like Google, Samsung, Qualcomm, etc. I expect it&#x27;ll be about as hard as getting them off $2000 dollar phones.<p>HSMs often misbehave or leak data when operated out of spec, as when the OEM&#x27;s cheap logic board has voltage drop. Moreover, using the same piece of hardware across a hundred million devices is its own vulnerability, because then that&#x27;s the one everyone is focused on breaking, and when anyone succeeds now they can extract the keys from a hundred million devices.<p>&gt; Even if it&#x27;s possible, that too will be a cat and mouse game which won&#x27;t work for long.<p>The nature of it is to be physical hardware, so vulnerabilities commonly require the hardware to be replaced. Now you&#x27;ve got an active vulnerability for the lifetime of that hardware, which is typically at least 3 years. Meanwhile they find new ones every year.<p>Preventing this may not even be physically possible. The key has to be inside the device and the attacker has physical control over the device. Even if the equipment needed to extract it is expensive, the device itself can&#x27;t be if you expect everyone to have one, so someone with that equipment makes a business out of extracting keys and selling them over the internet.<p>&gt; now with the commonality of TPMs and HSMs it&#x27;s here to stay.<p>Nothing lasts forever. Especially if you make a good show of burning it to the ground.</div><br/></div></div></div></div><div id="37183702" class="c"><input type="checkbox" id="c-37183702" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182893">parent</a><span>|</span><a href="#37183714">prev</a><span>|</span><a href="#37182947">next</a><span>|</span><label class="collapse" for="c-37183702">[-]</label><label class="expand" for="c-37183702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But if extracting a key is mildly inconvenient or legally questionable, it will be enough to deter honest casual users but not profit-motivated attackers, and you get the worst of both worlds.<p>it will also create a market for people selling and buying keys<p>it&#x27;ll be like buying a grey market software key, you hop onto aliexpress, pay $5 and you&#x27;ll have an iphone 11 attestation key<p>remote attestation as a process sows the seeds of its own destruction</div><br/></div></div><div id="37182947" class="c"><input type="checkbox" id="c-37182947" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182893">parent</a><span>|</span><a href="#37183702">prev</a><span>|</span><a href="#37182701">next</a><span>|</span><label class="collapse" for="c-37182947">[-]</label><label class="expand" for="c-37182947">[2 more]</label></div><br/><div class="children"><div class="content">The keys would just be revoked and the cheap phones you got the keys from would no longer pass attestation either.</div><br/><div id="37182986" class="c"><input type="checkbox" id="c-37182986" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182947">parent</a><span>|</span><a href="#37182701">next</a><span>|</span><label class="collapse" for="c-37182986">[-]</label><label class="expand" for="c-37182986">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t tell them which keys you extracted. If they have to revoke every phone of that model then lots of normal users have them and vendors can&#x27;t rely on people having phones that support it anymore, so good.<p>And the attacker doesn&#x27;t care if the key gets revoked <i>after</i> they&#x27;ve stolen your money.</div><br/></div></div></div></div></div></div><div id="37182701" class="c"><input type="checkbox" id="c-37182701" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182522">parent</a><span>|</span><a href="#37182893">prev</a><span>|</span><a href="#37182822">next</a><span>|</span><label class="collapse" for="c-37182701">[-]</label><label class="expand" for="c-37182701">[6 more]</label></div><br/><div class="children"><div class="content">That issue with Android is what made me decide to give up smartphones. I cannot adequately secure a phone without installing a custom ROM (and even then, it&#x27;s iffier than ever), and the integrity&#x2F;attestation checks make custom ROMs very problematic.<p>So, once my smartphone dies, I&#x27;ll be switching to a dumbphone.</div><br/><div id="37182851" class="c"><input type="checkbox" id="c-37182851" checked=""/><div class="controls bullet"><span class="by">mrd3v0</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182701">parent</a><span>|</span><a href="#37182896">next</a><span>|</span><label class="collapse" for="c-37182851">[-]</label><label class="expand" for="c-37182851">[2 more]</label></div><br/><div class="children"><div class="content">You should take a look at GNU&#x2F;Linux mobile operating systems every once in a while. They&#x27;re making great strides and both popular GUIs KDE and GNOME have been working on making mobile a target in their ecosystems.<p>Fairphone comes with a five-year guarantee for repairs and parts, so none of that early planned obsolescence, and it works with all the Linux mobile distributions I have had my eyes on.</div><br/><div id="37186257" class="c"><input type="checkbox" id="c-37186257" checked=""/><div class="controls bullet"><span class="by">toastal</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182851">parent</a><span>|</span><a href="#37182896">next</a><span>|</span><label class="collapse" for="c-37186257">[-]</label><label class="expand" for="c-37186257">[1 more]</label></div><br/><div class="children"><div class="content">No planned obsolescence but they removed the headphone jack &amp; started selling the earbuds which are one of the kings of e-waste compared to getting a nice pair of headphones or IEMs that will last a decade or more.</div><br/></div></div></div></div><div id="37182896" class="c"><input type="checkbox" id="c-37182896" checked=""/><div class="controls bullet"><span class="by">euniceee3</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182701">parent</a><span>|</span><a href="#37182851">prev</a><span>|</span><a href="#37185587">next</a><span>|</span><label class="collapse" for="c-37182896">[-]</label><label class="expand" for="c-37182896">[2 more]</label></div><br/><div class="children"><div class="content">Even then you are yellow booting and that is another security issue.<p>What dumbphones you looking at? Everything retail I am seeing is a stripped down version of Android.</div><br/><div id="37183307" class="c"><input type="checkbox" id="c-37183307" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182896">parent</a><span>|</span><a href="#37185587">next</a><span>|</span><label class="collapse" for="c-37183307">[-]</label><label class="expand" for="c-37183307">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;skysedge.com&#x2F;unsmartphones&#x2F;RUSP&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;skysedge.com&#x2F;unsmartphones&#x2F;RUSP&#x2F;</a><p>Some assembly required.</div><br/></div></div></div></div><div id="37185587" class="c"><input type="checkbox" id="c-37185587" checked=""/><div class="controls bullet"><span class="by">mindslight</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182701">parent</a><span>|</span><a href="#37182896">prev</a><span>|</span><a href="#37182822">next</a><span>|</span><label class="collapse" for="c-37185587">[-]</label><label class="expand" for="c-37185587">[1 more]</label></div><br/><div class="children"><div class="content">But remote attestation doesn&#x27;t completely prevent you from running custom ROMs. Rather the problem is if you want to use various proprietary crapps&#x2F;websites that insist on performing attestation. So there doesn&#x27;t seem to be a point into choosing a &quot;dumb phone&quot; besides as some sort of protest. Rather for each of your devices you&#x27;ll choose having a libre user-representing (ie secure) OS, or a locked down web TV equivalent. I&#x27;d personally choose my pocket device to be running secure libre software, and then use any proprietary crapps on a tablet that stays at home. If remote attestation gets so bad that I can&#x27;t even do things like access store apps on a libre&#x2F;secure device, then I&#x27;ll carry two, with the libre&#x2F;secure device supplying wifi AP to the other.<p>(this comment is most certainly not meant as any sort of defense of remote attestation)</div><br/></div></div></div></div><div id="37182822" class="c"><input type="checkbox" id="c-37182822" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182522">parent</a><span>|</span><a href="#37182701">prev</a><span>|</span><a href="#37183101">next</a><span>|</span><label class="collapse" for="c-37182822">[-]</label><label class="expand" for="c-37182822">[2 more]</label></div><br/><div class="children"><div class="content">A device that can&#x27;t watch Netflix in HD isn&#x27;t &quot;unusable&quot;. If your bank complains about custom ROMs for wireless payments, the exact same feature can work perfectly fine with your bank card (better even, in some cases).<p>I&#x27;m quite annoyed that I can&#x27;t watch HD movies on my phone but it&#x27;s not as if I should toss it into the bin now.</div><br/><div id="37183507" class="c"><input type="checkbox" id="c-37183507" checked=""/><div class="controls bullet"><span class="by">DistractionRect</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182822">parent</a><span>|</span><a href="#37183101">next</a><span>|</span><label class="collapse" for="c-37183507">[-]</label><label class="expand" for="c-37183507">[1 more]</label></div><br/><div class="children"><div class="content">The issue is that it likely won&#x27;t stop at Netflix and banking. McDonald&#x27;s won&#x27;t let you use their app with an unlocked bootloader [0].<p>My comment was suggesting that the majority of apps, not just banking&#x2F;Netflix will likely adopt and require hardware attestation when 90%+ of Androids in use support it. Things like Uber&#x2F;Lyft, Metro, food ordering, email, social media, etc are just as likely to pick it up and that&#x27;s my point. No, it won&#x27;t be a brick, but you&#x27;ll likely lose quite a few apps.<p>[0] <a href="https:&#x2F;&#x2F;forum.xda-developers.com&#x2F;t&#x2F;mcdonalds-app.4067887&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;forum.xda-developers.com&#x2F;t&#x2F;mcdonalds-app.4067887&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37183101" class="c"><input type="checkbox" id="c-37183101" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37181621">parent</a><span>|</span><a href="#37182522">prev</a><span>|</span><a href="#37184390">next</a><span>|</span><label class="collapse" for="c-37183101">[-]</label><label class="expand" for="c-37183101">[5 more]</label></div><br/><div class="children"><div class="content">Sorry, a DICE-enhanced TPM would be just as evil as a regular TPM I&#x27;m afraid.  You can think of DICE as  giving you a gazillion TPMs for the price of one actual TPM, one per program you care to load.  What would happen is, your bootloader would just inject the standard Treacherous Computing™ firmware into the TPM, and since its keys is tied to it being what it is, in the end you end up with a regular Treacherous Platform Module, same as today.<p>I would _love_ to stop programs from using my TPM against me, but I&#x27;m afraid DICE isn&#x27;t it.</div><br/><div id="37183843" class="c"><input type="checkbox" id="c-37183843" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37183101">parent</a><span>|</span><a href="#37184390">next</a><span>|</span><label class="collapse" for="c-37183843">[-]</label><label class="expand" for="c-37183843">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Their motivation however was different: they wanted to better protect the device secret. Many devices store their secret in a fuse bank, and changing it is often impossible. Leaking it is especially bad, because it can render the entire device forever unusable: no one wants an HSM with a leaked secret, or a remote IoT device that can be impersonated.<p>A computer I cannot choose what software I run and what state I expose to the software, and allow the software to impersonate the original software, is a SafetyNet locked-down device controlled by the owner of the TPM keys and programs running on it.</div><br/><div id="37184106" class="c"><input type="checkbox" id="c-37184106" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37183843">parent</a><span>|</span><a href="#37184390">next</a><span>|</span><label class="collapse" for="c-37184106">[-]</label><label class="expand" for="c-37184106">[3 more]</label></div><br/><div class="children"><div class="content">I’m sorry, did you reply to the wrong comment? Or did you quote the wrong quote? I genuinely can’t make link your response with either my previous comment or what you just quoted.<p>Taken in isolation your sentence is correct, I agree 100% with it: of course I want control over what runs on my computer.  Of course the TPM is often used to steal that control away from me.  <i>Of course that is bad.</i><p>What made you think I don’t think that?</div><br/><div id="37184892" class="c"><input type="checkbox" id="c-37184892" checked=""/><div class="controls bullet"><span class="by">nyanpasu64</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37184106">parent</a><span>|</span><a href="#37184390">next</a><span>|</span><label class="collapse" for="c-37184892">[-]</label><label class="expand" for="c-37184892">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not upset at you, I&#x27;m agreeing with the comment you wrote. But since I found out you&#x27;re the author of the article, I find it odd you&#x27;re now upset about the idea of TPMs and remote attestation, when your article praises an alternative TPM architecture fully capable of remote attestations and disobeying the user.</div><br/><div id="37186827" class="c"><input type="checkbox" id="c-37186827" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37184892">parent</a><span>|</span><a href="#37184390">next</a><span>|</span><label class="collapse" for="c-37186827">[-]</label><label class="expand" for="c-37186827">[1 more]</label></div><br/><div class="children"><div class="content">I see, I ma have separated those two separate subjects a bit too much.  The TPM is two things: <i>evil</i>, and <i>bloated</i>.  This post focused on the &quot;bloated&quot; part, with only the slightest recognition of the evil at the very end of my post. I understand it therefore looks like I&#x27;m approving the evils of the TPM.<p>The evil part would need its own post, but frankly, other people have addressed this part much better than I ever could.  Cory Doctorow&#x27;s talk on <i>The Coming War on General Computation</i> is as relevant as ever.<p>Even then, TPM-like hardware can still be useful to me as a user, even if my computer is 100% Free Software.  It is a shame though that its main use is stripping me of my freedoms instead.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37184390" class="c"><input type="checkbox" id="c-37184390" checked=""/><div class="controls bullet"><span class="by">zauguin</span><span>|</span><a href="#37181621">parent</a><span>|</span><a href="#37183101">prev</a><span>|</span><a href="#37182787">next</a><span>|</span><label class="collapse" for="c-37184390">[-]</label><label class="expand" for="c-37184390">[2 more]</label></div><br/><div class="children"><div class="content">&gt; or, even better, to prevent the HSM from being used by anything without my overt permission<p>Can&#x27;t you already do that with an existing TPM? You just set an owner authentication password and an endorsement authentication password and no application can use it anymore unless you provide the password.<p>Technically it would still be possible to use it as a very slow cryptographic coprocessor I guess, but that benign and useless. It does still provide access to some platform measurements, but they can&#x27;t be signed by a authenticated (or even safely stored) key, so they are easy to fake.<p>In addition to that the OS of course can be used to completely block access to it if needed.<p>The problem is not that people can&#x27;t stop applications from using it, it is just that in practice people don&#x27;t care.</div><br/><div id="37186609" class="c"><input type="checkbox" id="c-37186609" checked=""/><div class="controls bullet"><span class="by">vladvasiliu</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37184390">parent</a><span>|</span><a href="#37182787">next</a><span>|</span><label class="collapse" for="c-37186609">[-]</label><label class="expand" for="c-37186609">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can&#x27;t you already do that with an existing TPM? You just set an owner authentication password and an endorsement authentication password and no application can use it anymore unless you provide the password.<p>How would one go about doing that?</div><br/></div></div></div></div><div id="37182787" class="c"><input type="checkbox" id="c-37182787" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37181621">parent</a><span>|</span><a href="#37184390">prev</a><span>|</span><a href="#37182814">next</a><span>|</span><label class="collapse" for="c-37182787">[-]</label><label class="expand" for="c-37182787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; to prevent the HSM from being used by anything without my overt permission<p>That sounds quite doable? Basic sandboxing (flatpak&#x2F;snap&#x2F;whatever) and not assigning the tss group to system daemons will do that for you.</div><br/></div></div><div id="37182814" class="c"><input type="checkbox" id="c-37182814" checked=""/><div class="controls bullet"><span class="by">EMIRELADERO</span><span>|</span><a href="#37181621">parent</a><span>|</span><a href="#37182787">prev</a><span>|</span><a href="#37182874">next</a><span>|</span><label class="collapse" for="c-37182814">[-]</label><label class="expand" for="c-37182814">[3 more]</label></div><br/><div class="children"><div class="content">How does that solve the issue, exactly? Apps could simply refuse to run, and platforms refuse to provide you with service, if you don&#x27;t accept their keys in your TPM.</div><br/><div id="37184778" class="c"><input type="checkbox" id="c-37184778" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37182814">parent</a><span>|</span><a href="#37182874">next</a><span>|</span><label class="collapse" for="c-37184778">[-]</label><label class="expand" for="c-37184778">[2 more]</label></div><br/><div class="children"><div class="content">At this point it seems like only regulation could stop this. They should be required to interoperate by law. Refusing service because the user has &quot;unauthorized&quot; software should be literally illegal. Without this, all useful services will exclude us.</div><br/><div id="37186622" class="c"><input type="checkbox" id="c-37186622" checked=""/><div class="controls bullet"><span class="by">A1kmm</span><span>|</span><a href="#37181621">root</a><span>|</span><a href="#37184778">parent</a><span>|</span><a href="#37182874">next</a><span>|</span><label class="collapse" for="c-37186622">[-]</label><label class="expand" for="c-37186622">[1 more]</label></div><br/><div class="children"><div class="content">I think the better regulation would be that it is illegal to sell hardware that includes embedded keys without making the secret key (or the private key if the embedded key is a public key) available to the legitimate owner, with no strings attached.<p>Hardware vendors could chose to, for example, make the keys available in printed form in an envelope with difficult to open without breaking vendor-branded seals that are expensive to manufacture in small quantities, and warn consumers not to open them if they don&#x27;t know what they&#x27;re doing.<p>This would prevent its use to lock consumers out from installing their own software on their own hardware, while still making it useful for legitimate applications. Consumers could chose to securely destroy the key if they wanted (with the caveat they could then not on-sell the device).</div><br/></div></div></div></div></div></div></div></div><div id="37182874" class="c"><input type="checkbox" id="c-37182874" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#37181621">prev</a><span>|</span><a href="#37186273">next</a><span>|</span><label class="collapse" for="c-37182874">[-]</label><label class="expand" for="c-37182874">[5 more]</label></div><br/><div class="children"><div class="content">This reads like &quot;the full TPM spec is too complicated for my use case, so I made my own TPM for my personal use case&quot;. That&#x27;s not fixing TPM, that&#x27;s inventing your own, custom TPM, that only works for a subset of the intended audience of the thing you&#x27;re replacing.<p>It&#x27;s like replacing all private cars by bikes and public transit. This solves the pollution problem, the traffic casualties program, and would solve transportation for the vast majority of people traveling on the road. It doesn&#x27;t solve some niche use cases, like &quot;trucks&quot; or &quot;construction work&quot;, but those are just bloat almost nobody needs in the first place, right?<p>From this description, Tillitis sure seems like a good alternative for TPMs. However, there&#x27;s no Tillitis chip in my laptop or my desktop, but I do have a TPM. Things like SSH and PGP are already implemented. Tillitis isn&#x27;t very interesting to me in its current state as advertised in this article.</div><br/><div id="37182967" class="c"><input type="checkbox" id="c-37182967" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37182874">parent</a><span>|</span><a href="#37186273">next</a><span>|</span><label class="collapse" for="c-37182967">[-]</label><label class="expand" for="c-37182967">[4 more]</label></div><br/><div class="children"><div class="content">Author here. Did you miss the part where users can load arbitrary programs into the &quot;new custom TPM&quot;?  If we can do that, solving all use cases for all users is very easy: just write the appropriate program whenever a new use case pops up.  This is not supporting a subset of current users, this is supporting <i>all</i> users.  Every last one of them.<p>Believe me, given the current complexity of the TPM 2.0 interface, writing a custom program for any single use case is not any harder than wading through the current TPM documentation.  Given suitable crypto libraries I&#x27;m guessing it&#x27;s quite a bit easier in most cases.<p>&gt; <i>However, there&#x27;s no Tillitis chip in my laptop or my desktop</i><p>Yeah, that&#x27;s the thing with new approaches: they&#x27;re new.  Now if someone made an HSM with the same pinout as a discrete TPM, with a DICE-aware approach under the hood, you could plug it on your motherboard <i>today</i>.</div><br/><div id="37186075" class="c"><input type="checkbox" id="c-37186075" checked=""/><div class="controls bullet"><span class="by">Corsome</span><span>|</span><a href="#37182874">root</a><span>|</span><a href="#37182967">parent</a><span>|</span><a href="#37186273">next</a><span>|</span><label class="collapse" for="c-37186075">[-]</label><label class="expand" for="c-37186075">[3 more]</label></div><br/><div class="children"><div class="content">What if the firmware program has a bug that needs to be fixed? Fixing it would change the hash and thus lock it out from key access but leaving it unchanged will mean the keys can be compromised.<p>How does Tillitis handle this case?</div><br/><div id="37186853" class="c"><input type="checkbox" id="c-37186853" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37182874">root</a><span>|</span><a href="#37186075">parent</a><span>|</span><a href="#37186790">next</a><span>|</span><label class="collapse" for="c-37186853">[-]</label><label class="expand" for="c-37186853">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s tedious, but simple: revoke the old key, rotate to the new one.  If you need the old key to revoke it (say you encrypted a disk, or you have wrapped credentials you need to unwrap first), then use the old buggy firmware to do the necessary decryption, then encrypt again with the new one.<p>Writing the migration program that loads the two pieces of firmware (the old, then the new) to the dongle however is a pain in the butt.  Especially if you can&#x27;t restart the device without physically plugging it out and back in again.</div><br/></div></div><div id="37186790" class="c"><input type="checkbox" id="c-37186790" checked=""/><div class="controls bullet"><span class="by">A1kmm</span><span>|</span><a href="#37182874">root</a><span>|</span><a href="#37186075">parent</a><span>|</span><a href="#37186853">prev</a><span>|</span><a href="#37186273">next</a><span>|</span><label class="collapse" for="c-37186790">[-]</label><label class="expand" for="c-37186790">[1 more]</label></div><br/><div class="children"><div class="content">Could you not have a tiny certified kernel program with an embedded public key that reads the main program, hashes it, checks the signature, and executes it (providing the keys to the main program). Obviously, if you change the kernel program, you would change the keys, but you could change the main program. Anyone with the private key then has the power... they could migrate by running a new kernel (while the TKey is under their physical control) and generate a keypair (deterministically from the new secret key) and export the public key. Then the controller of the private key could sign a program to run under the old kernel that will encrypt that old key with the new public key.</div><br/></div></div></div></div></div></div></div></div><div id="37186273" class="c"><input type="checkbox" id="c-37186273" checked=""/><div class="controls bullet"><span class="by">hlandau</span><span>|</span><a href="#37182874">prev</a><span>|</span><a href="#37185528">next</a><span>|</span><label class="collapse" for="c-37186273">[-]</label><label class="expand" for="c-37186273">[2 more]</label></div><br/><div class="children"><div class="content">This article is correct that having a general-purpose owner-controlled programmable secure enclave is highly desirable. The design where each program which runs receives a unique cryptographic identity derived from a fused key is also something I&#x27;ve advocated: <a href="https:&#x2F;&#x2F;www.devever.net&#x2F;~hl&#x2F;secureboot" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.devever.net&#x2F;~hl&#x2F;secureboot</a><p>The TKey is a good design here.<p>TPMs are a red herring here though, as the TKey is not a plausible replacement for a TPM, which exists to measure a platform boot process. There&#x27;s not really any way to use a TKey for this, since a) you&#x27;d have to load firmware at every boot before the first measurement is taken (i.e., before the BIOS even starts running), which no PC is setup to do, b) you would still be vulnerable to classical MitM of the device, as for any discrete TPM, and unlike modern functional TPMs.<p>The lack of controlled storage it should be noted does create vulnerability to rollback attacks. It&#x27;s not really possible to delete data this way.<p>In any case, with regards to the lack of user-programmable secure elements, it&#x27;s the industry attitudes here that are the problem. This kind of technology absolutely exists, but it&#x27;s all under NDA and you can&#x27;t have it. Smartcards are the most obvious example; you can get nice flash-based programmable smartcards now with 32-bit ARM cores, and no you can&#x27;t have one. It&#x27;s ridiculous.<p>So the TKey is built out of a COTS FPGA, one of the few FPGAs with an open source toolchain (painstakingly reverse engineered). This means it doesn&#x27;t have any of the silicon hardening that smartcards and other secure element chips have - but there&#x27;s no choice but to build out of something like this because those chips are all under NDA. The hardware industry doesn&#x27;t seem to believe in Kerchhoff&#x27;s principle.<p>IMO the TKey is basically the best you can do with the publicly available silicon today. In that regard it&#x27;s pretty good. But a TPM is literally the one application it&#x27;s least suitable for as a secure element.</div><br/><div id="37186598" class="c"><input type="checkbox" id="c-37186598" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#37186273">parent</a><span>|</span><a href="#37185528">next</a><span>|</span><label class="collapse" for="c-37186598">[-]</label><label class="expand" for="c-37186598">[1 more]</label></div><br/><div class="children"><div class="content">How about as yubikey replacement ?  What are the good applications?</div><br/></div></div></div></div><div id="37185528" class="c"><input type="checkbox" id="c-37185528" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#37186273">prev</a><span>|</span><a href="#37185299">next</a><span>|</span><label class="collapse" for="c-37185528">[-]</label><label class="expand" for="c-37185528">[1 more]</label></div><br/><div class="children"><div class="content">Yes!  I&#x27;ve been wanting a TPM 2.0 extension that lets users provide something like a bytecoded program that runs like a secure enclave: if its hash matches a secret&#x27;s authz, then the program is authorized to use it via well-defined APIs (e.g., sign data), and the bytecode interpreter would keep the program from doing things it shouldn&#x27;t.</div><br/></div></div><div id="37185299" class="c"><input type="checkbox" id="c-37185299" checked=""/><div class="controls bullet"><span class="by">rzimmerman</span><span>|</span><a href="#37185528">prev</a><span>|</span><a href="#37186775">next</a><span>|</span><label class="collapse" for="c-37185299">[-]</label><label class="expand" for="c-37185299">[1 more]</label></div><br/><div class="children"><div class="content">The TPM spec is a monster and I understand the urge to throw it out and create something simpler. It&#x27;s also true that you&#x27;re trusting proprietary firmware in the TPM to be correct. Errors and bugs in the spec are also near impossible to fix. So the idea of &quot;just run whatever code you want&quot; has appeal. And the reference tpm2_tools and software stack is a hot mess of C code that should definitely not be written in C at this point.<p>A device brewed on a RISC-V SOC in an FPGA is probably very hard to secure against hardware attacks. It&#x27;s fun (in the sense that FPGAs are &quot;fun&quot;) and it&#x27;s definitely a worthy pursuit to have an open hardware + firmware device replace proprietary TPMs. But getting hardware security right is just as important here. A TPM-replacement is not useful if I can solder a JTAG connection to it and read out the memory.<p>Rewrapping keys when there&#x27;s a firmware&#x2F;code update is a real weakness here. There&#x27;s probably a solid solution, like being able to provide a compound&#x2F;asymmetric CDI to wrap between versions. Like &quot;generate an ECDH key pair for the next hash&quot;. It would be a pain if every client application had to implement this themselves. The other hot use case for TPMs is boot chain attestation, where hashes of UEFI firmware, boot loaders, and kernel images are appended to create a verifiable hash. The device attests to the hash being authentic.<p>One major weakness of TPM 2.0 is that it&#x27;s monolithic for the whole system. If you&#x27;re running VMs or even just multiple processes in the OS, it&#x27;s not really easy to use across domains. So lightweight code swapping would be pretty cool.<p>Interesting stuff nonetheless.</div><br/></div></div><div id="37186775" class="c"><input type="checkbox" id="c-37186775" checked=""/><div class="controls bullet"><span class="by">zb3</span><span>|</span><a href="#37185299">prev</a><span>|</span><a href="#37183377">next</a><span>|</span><label class="collapse" for="c-37186775">[-]</label><label class="expand" for="c-37186775">[1 more]</label></div><br/><div class="children"><div class="content">I wish the whole &quot;trusted computing&quot; thing just disappeared.</div><br/></div></div><div id="37183377" class="c"><input type="checkbox" id="c-37183377" checked=""/><div class="controls bullet"><span class="by">Confiks</span><span>|</span><a href="#37186775">prev</a><span>|</span><a href="#37183093">next</a><span>|</span><label class="collapse" for="c-37183377">[-]</label><label class="expand" for="c-37183377">[1 more]</label></div><br/><div class="children"><div class="content">Fixing the TPM is hard because taping out semiconductors at scale is not yet facile [1] and there&#x27;s also still a proprietary PDK in the way of &#x27;traditional&#x27; manufacturing [2]. The article submarines [3], which looks very interesting. I do wonder how the Lattice iCE40 will fare under fault injection and just how many grams of epoxy you&#x27;ll need to stick to it.<p>[1] <a href="https:&#x2F;&#x2F;atomicsemi.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;atomicsemi.com&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;www.bunniestudios.com&#x2F;blog&#x2F;?p=6606" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.bunniestudios.com&#x2F;blog&#x2F;?p=6606</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;tillitis">https:&#x2F;&#x2F;github.com&#x2F;tillitis</a></div><br/></div></div><div id="37183093" class="c"><input type="checkbox" id="c-37183093" checked=""/><div class="controls bullet"><span class="by">jerhewet</span><span>|</span><a href="#37183377">prev</a><span>|</span><a href="#37182257">next</a><span>|</span><label class="collapse" for="c-37183093">[-]</label><label class="expand" for="c-37183093">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m in the minority on this, but I want BIOS to make a comeback. I don&#x27;t want TPM, or any of the rest of this broken garbage. Just let me boot my OS, and get the fuck out of my way...</div><br/><div id="37183294" class="c"><input type="checkbox" id="c-37183294" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37183093">parent</a><span>|</span><a href="#37185083">next</a><span>|</span><label class="collapse" for="c-37183294">[-]</label><label class="expand" for="c-37183294">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you actually.  I do however like the other uses of hardware tokens: two factor authentication, or even replacing password based login.  I would very much like to have a TPM&#x2F;HSM flexible enough to do the same things a YubiKey does, and more.<p>But the powers that be decided that the user is the enemy… Maybe they should be more careful that such a decision may <i>make</i> an enemy out of the user. I for one sure don&#x27;t want to be their ally.</div><br/></div></div><div id="37185083" class="c"><input type="checkbox" id="c-37185083" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#37183093">parent</a><span>|</span><a href="#37183294">prev</a><span>|</span><a href="#37182257">next</a><span>|</span><label class="collapse" for="c-37185083">[-]</label><label class="expand" for="c-37185083">[1 more]</label></div><br/><div class="children"><div class="content">coreboot et al sounds like a better option.</div><br/></div></div></div></div><div id="37182257" class="c"><input type="checkbox" id="c-37182257" checked=""/><div class="controls bullet"><span class="by">motohagiography</span><span>|</span><a href="#37183093">prev</a><span>|</span><a href="#37185689">next</a><span>|</span><label class="collapse" for="c-37182257">[-]</label><label class="expand" for="c-37182257">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an important topic, but the basic tradeoffs with TPMs and HSMs are that either you, a) trust the vendor is generating root secrets with sufficient entropy, whether they are a private key or a symmetric secret, b) you trust the personalization process for replacing the OEM secrets with personalized ones, or c) you trust the firmware to not yield the unique secrets you generate in it.<p>There are issues with all of these, but it&#x27;s a question of in which security context you are generating your root secrets and keys. e.g. at manufacture, at personalization, or whenever the end user wants to. The catastrophic failure mode of TPM&#x27;s depending on shared root secrets may actually be a privacy feature, imo, because in all the digital identity work I have done, this was where every scheme fell over.</div><br/><div id="37182414" class="c"><input type="checkbox" id="c-37182414" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#37182257">parent</a><span>|</span><a href="#37185689">next</a><span>|</span><label class="collapse" for="c-37182414">[-]</label><label class="expand" for="c-37182414">[5 more]</label></div><br/><div class="children"><div class="content">Even if flawed, it can still act as a safety in numbers game. You have to be able to abuse TPM <i>and</i> be in a position to do so, in the context of fde, even a flawed tpm v1 approach stops 90% of potential threat actors capable of abusing an unencrypted device.</div><br/><div id="37182935" class="c"><input type="checkbox" id="c-37182935" checked=""/><div class="controls bullet"><span class="by">motohagiography</span><span>|</span><a href="#37182257">root</a><span>|</span><a href="#37182414">parent</a><span>|</span><a href="#37185689">next</a><span>|</span><label class="collapse" for="c-37182935">[-]</label><label class="expand" for="c-37182935">[4 more]</label></div><br/><div class="children"><div class="content">A solution that was rarely implemented was batch keys, where your secrets installed by the OEM were diversified somehow so when attackers eventually extracted your TPM secrets from one device, it would not compromise all devices. It still has a terrible and unacceptable failure mode when peoples lives depend on it, but for infrastructure, I think the risk is more managable.</div><br/><div id="37183803" class="c"><input type="checkbox" id="c-37183803" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#37182257">root</a><span>|</span><a href="#37182935">parent</a><span>|</span><a href="#37185689">next</a><span>|</span><label class="collapse" for="c-37183803">[-]</label><label class="expand" for="c-37183803">[3 more]</label></div><br/><div class="children"><div class="content">If your threat model involves people sniffing TPM signals in transit, you’re in a different league to me. In most cases I assume physical security (security guards, epoxy the motherboard, etc) become the mitigating factors. I’m just trying to avoid evil maids.</div><br/><div id="37184037" class="c"><input type="checkbox" id="c-37184037" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37182257">root</a><span>|</span><a href="#37183803">parent</a><span>|</span><a href="#37185689">next</a><span>|</span><label class="collapse" for="c-37184037">[-]</label><label class="expand" for="c-37184037">[2 more]</label></div><br/><div class="children"><div class="content">Making an TPM genie isn’t that hard, and once we have that the Evil Maid can fairly easily unplug the discrete TPM, plug the Genie, and plug the TPM into the genie. And voilà, you can now sniff TPM signals in transit.  Only works with discrete TPMs of course, but Man-in-the-Middle is not out of this world.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nccgroup&#x2F;TPMGenie">https:&#x2F;&#x2F;github.com&#x2F;nccgroup&#x2F;TPMGenie</a></div><br/><div id="37185570" class="c"><input type="checkbox" id="c-37185570" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#37182257">root</a><span>|</span><a href="#37184037">parent</a><span>|</span><a href="#37185689">next</a><span>|</span><label class="collapse" for="c-37185570">[-]</label><label class="expand" for="c-37185570">[1 more]</label></div><br/><div class="children"><div class="content">I’m more referring to laptops. If you’re using a desktop, you also have other issues (like key injectors unless you inspect the cable going from your pc to your desk every time, etc).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37185689" class="c"><input type="checkbox" id="c-37185689" checked=""/><div class="controls bullet"><span class="by">StarlightAbove</span><span>|</span><a href="#37182257">prev</a><span>|</span><a href="#37182537">next</a><span>|</span><label class="collapse" for="c-37185689">[-]</label><label class="expand" for="c-37185689">[1 more]</label></div><br/><div class="children"><div class="content">A reprogrammable HSM is a neat idea, but I think the author has not really understood the use cases TPM 2.0 is trying to support. The TPM 2.0 architecture document contemplates three distinct roots of trust, and the TKey can&#x27;t really serve as any of them, at least not while maintaining its operational flexibility and simplicity the author likes about it.<p>The first is the root of trust for measurement which consists of the first immutable boot code run on the application processor, which must be trusted to measure the first mutable code correctly, and the trusted hardware that receives these measurements. This trusted hardware needs to be present and running from the very earliest boot stage, and must keep running until the system is reset. If the application processor can reset the TKey after boot, it could reset the measurements and then imitate the legitimate boot chain, defeating the purpose of measured boot. If it <i>can&#x27;t</i> then the TKey is running fixed firmware that can, at best, be changed by rebooting the system, and needs to be shared by all applications simultaneously. For a general purpose operating system that needs to be able to run arbitrary applications that in turn need to be able to support a wide range of systems, this pushes you inevitably towards something like the TPM 2.0 spec that tries to support all use cases at once.<p>What about just embedding DICE into the application processor and having the system serve as &quot;its own HSM&quot;? That only works for the very simplest boot policy of &quot;these secrets should only be accessible to a device running a single fixed image&quot;. Maybe you&#x27;re fine with reprovisioning your EV charging stations after every software update, but my devices get updated more often than that.<p>The second is the root of trust for storage, which is a container for non-volatile memory with read and&#x2F;or write controls. This is an easy one, to serve in this role you need protected non-volatile storage, the TKey has none, gg.<p>You need this for audit logs, and also for any kind of policy that might change over time. What if I want to change my password? What if I want to revoke access to a secret from an old OS image? Or record all uses of a signing key? All of these require some kind of storage that can&#x27;t be rolled back to an earlier state.<p>I think you could have a scheme where the chip stores the root of a Merkle tree of the NV state for every trusted application and relies on the host to provide the actual state for a specific trusted application + a proof that it&#x27;s in the Merkle tree at boot, which would allow different trusted applications to be run on the same physical chip without interfering with each others data, but that is going to drastically complicate the design of this system and require some kind of runtime OS on the chip to control how the root is updated (otherwise a trusted application could roll the state back for other trusted applications).<p>Finally you have the root of trust for reporting, which can sign trustworthy assertions about the system state. For example, attesting that a key is actually bound to the secure element, or that the system booted is a particular state, or to the audit log. For this you need a key that relying parties <i>already know</i> is bound to the secure element for this purpose. If you have different trusted applications with different secrets, and you want them all to be able to provide remote attestation, then you need to either go through a manual provisioning process for each application (someone needs to connect the device to a trustworthy system and check the attestation key for the application), or you need the firmware to sign something derived from the CDI using something derived from the UDS (which the TKey doesn&#x27;t). It doesn&#x27;t require a trusted runtime OS on the secure element though, so at least it has that going for it.<p>I think the hardest of these is the measured boot use case, because to be useful it needs to be combined with anything that relies on measured boot. There&#x27;s no point in measuring your boot process if you can&#x27;t either remotely attest to it, or bind a secret to it, and it needs to be able to support whatever the host OS needs it to do, so I think attempts at TPM 2.0 style fully general trusted applications are close to unavoidable here.<p>Maybe with some very clever ideas you can make a secure element that can actually replace all these use cases while being reprogrammable at runtime and having only small, purpose-specific trusted applications, but the TKey that exists today isn&#x27;t it.</div><br/></div></div><div id="37182537" class="c"><input type="checkbox" id="c-37182537" checked=""/><div class="controls bullet"><span class="by">dblitt</span><span>|</span><a href="#37185689">prev</a><span>|</span><a href="#37183388">next</a><span>|</span><label class="collapse" for="c-37182537">[-]</label><label class="expand" for="c-37182537">[1 more]</label></div><br/><div class="children"><div class="content">Related from 11 months ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32896580">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32896580</a></div><br/></div></div><div id="37183388" class="c"><input type="checkbox" id="c-37183388" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37182537">prev</a><span>|</span><a href="#37183046">next</a><span>|</span><label class="collapse" for="c-37183388">[-]</label><label class="expand" for="c-37183388">[1 more]</label></div><br/><div class="children"><div class="content">Subvert the manufacture of the UDS...</div><br/></div></div><div id="37183046" class="c"><input type="checkbox" id="c-37183046" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#37183388">prev</a><span>|</span><label class="collapse" for="c-37183046">[-]</label><label class="expand" for="c-37183046">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not an encryption guy so maybe this is a stupid question, but doesn&#x27;t this mean you can&#x27;t update the firmware without losing all your encrypted data?</div><br/><div id="37183370" class="c"><input type="checkbox" id="c-37183370" checked=""/><div class="controls bullet"><span class="by">bluegate010</span><span>|</span><a href="#37183046">parent</a><span>|</span><a href="#37183157">next</a><span>|</span><label class="collapse" for="c-37183370">[-]</label><label class="expand" for="c-37183370">[1 more]</label></div><br/><div class="children"><div class="content">Not a stupid question. CDIs are groovy for minting secrets that are bound to the exact firmware that&#x27;s running, but are a bit less ergonomic out of the box when it comes to keeping long-lived secrets around across a firmware update. Firmware changes --&gt; CDI changes --&gt; anything derived from or sealed to the CDI is gone, by design.<p>A more ergonomic approach for sealing long-lived data is to use something like a hash chain [0], where the chain starts with the equivalent of a DICE UDS, and the chain&#x27;s length is (MAX_VERSION - fw.version). The end of that chain is given to firmware, and the firmware can lengthen the chain to derive older firmware&#x27;s secrets, but cannot shorten it to derive newer firmware&#x27;s secrets.<p>This presumes that the firmware is signed of course, since otherwise there&#x27;d be no way to securely associate the firmware with a version number. If the public key is not baked into the HSM, then the hash of the public key should be used to permute the root of the hash chain.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_chain" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_chain</a></div><br/></div></div><div id="37183157" class="c"><input type="checkbox" id="c-37183157" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#37183046">parent</a><span>|</span><a href="#37183370">prev</a><span>|</span><a href="#37184146">next</a><span>|</span><label class="collapse" for="c-37183157">[-]</label><label class="expand" for="c-37183157">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and no.<p>If you lose the firmware entirely you would indeed lose the derived decryption keys.  But if you <i>keep</i> the firmware somewhere safe (or even fetch it again from wherever you got it first), then loading it again would derive the same keys, and you can decrypt your stuff again.<p>This makes reproducible builds very important by the way: if you rely on a source control system to hold on to old versions of the firmware (just in case someone needs it to decrypt old files), you really really want a way to re-generate the same binary blob from the same source code.</div><br/></div></div><div id="37184146" class="c"><input type="checkbox" id="c-37184146" checked=""/><div class="controls bullet"><span class="by">Hello71</span><span>|</span><a href="#37183046">parent</a><span>|</span><a href="#37183157">prev</a><span>|</span><label class="collapse" for="c-37184146">[-]</label><label class="expand" for="c-37184146">[1 more]</label></div><br/><div class="children"><div class="content">most systems for encrypting large amounts of data (e.g. a whole hard drive) don&#x27;t use the user-derived key directly for encryption; the data is encrypted with a content encryption key (Microsoft) or master key (LUKS), which is then encrypted with the user-derived key and stored in the encryption header. this allows the user passphrase to be changed by reencrypting the CEK&#x2F;MK rather than the whole drive.</div><br/></div></div></div></div></div></div></div></div></div></body></html>