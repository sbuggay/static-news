<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716454870978" as="style"/><link rel="stylesheet" href="styles.css?v=1716454870978"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tryclojure.org/">Try Clojure</a>Â <span class="domain">(<a href="https://tryclojure.org">tryclojure.org</a>)</span></div><div class="subtext"><span>ducktective</span> | <span>200 comments</span></div><br/><div><div id="40445289" class="c"><input type="checkbox" id="c-40445289" checked=""/><div class="controls bullet"><span class="by">jakebasile</span><span>|</span><a href="#40452020">next</a><span>|</span><label class="collapse" for="c-40445289">[-]</label><label class="expand" for="c-40445289">[34 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad this is back. A version of this existed in the ancient past and helped encourage me to try Clojure which ended up being by far the most impactful decision in my professional life. It went away for a while for reasons I&#x27;m unclear on.<p>I use Clojure nearly daily at my job and at home. Sometimes it&#x27;s standard Clojure, sometimes it&#x27;s the excellent Babashka flavor which I use as a make-like task runner and Zsh-like script replacement. It&#x27;s not the only language I use of course, and Go is a strong second place most of the time especially if I need something compiled to a single binary. But Clojure is where I generally feel most at home thanks to the irreplaceable REPL based development flow which is more like a dialogue with my program than your typical write compile run loop.<p>Combine that with it running on the JVM and you have a wonderful set of tools to get things done in a pleasant way.<p>I strongly encourage anyone with even a passing interest in Lisp and functional programming to give it a try. If you&#x27;re using VSCode there is the excellent Calva plugin to help you out.</div><br/><div id="40445500" class="c"><input type="checkbox" id="c-40445500" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40445289">parent</a><span>|</span><a href="#40450936">next</a><span>|</span><label class="collapse" for="c-40445500">[-]</label><label class="expand" for="c-40445500">[31 more]</label></div><br/><div class="children"><div class="content">As a side note, I&#x27;m always amazed by people who can use a highly expressive language (Clojure, Rust, even TS) but switch to Go when they feel like it (especially pre-1.18).<p>To me, switching to a less expressive language is painful and infuriating. I remember having to switch from Python to Java 5, and how everything started to take 3 to 5 times longer code to express.<p>Maybe the key thing is to only write small things in less expressive languages, like shell scripts, or small C functions to help performance or FFI, or, well, tiny Go utilities.</div><br/><div id="40445713" class="c"><input type="checkbox" id="c-40445713" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40451878">next</a><span>|</span><label class="collapse" for="c-40445713">[-]</label><label class="expand" for="c-40445713">[15 more]</label></div><br/><div class="children"><div class="content">Development in Go will always be more painful for some people than in Clojure or TS, because the language is intentionally hostile to abstraction, so you&#x27;re thinking in higher level concepts, but you implement them in more steps than necessary. The program can never reflect the shape of the problem, because it will be riddled with &quot;glue code&quot; that implements the obvious dull steps that you abstract away when reasoning.<p>There&#x27;s a population of people that don&#x27;t like this kind of abstraction, because to understand the code you first need to understand the problem, the data flow and how it&#x27;s expressed. They prefer to look at the issue &quot;bottom up&quot; than &quot;top down&quot;, and for them Go is perfect, because instead of reasoning about what the module does, how the data flows, what the algorithm does, they can focus on the small: this is a loop that iterates through a slice, this is an if condition that depends on this variable.<p>There&#x27;s no better or worse here, just two types of people. Some like to look at the whole bridge, some like to examine the individual nuts and bolts and joints.</div><br/><div id="40445769" class="c"><input type="checkbox" id="c-40445769" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445713">parent</a><span>|</span><a href="#40450824">next</a><span>|</span><label class="collapse" for="c-40445769">[-]</label><label class="expand" for="c-40445769">[5 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s no better or worse here, just two types of people.<p>No, two types of solving a problem. I like writing both (Haskell and Go) - for _myself_ - but the tooling and standard library and ... of Go is orders of magnitudes better.</div><br/><div id="40445898" class="c"><input type="checkbox" id="c-40445898" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445769">parent</a><span>|</span><a href="#40450824">next</a><span>|</span><label class="collapse" for="c-40445898">[-]</label><label class="expand" for="c-40445898">[4 more]</label></div><br/><div class="children"><div class="content">I would refrain from comparing Haskell - a research language intended for academia and created in universities, to Go - a pragmatic industry language intended for production and created in a megacorp. Why would Haskell&#x27;s tooling be better? It&#x27;s not reasonable to expect that.</div><br/><div id="40446113" class="c"><input type="checkbox" id="c-40446113" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445898">parent</a><span>|</span><a href="#40450824">next</a><span>|</span><label class="collapse" for="c-40446113">[-]</label><label class="expand" for="c-40446113">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m actually surprised Go&#x27;s tooling as as good as it is _although_ it is made by Google. But to be fair, GoogleTest is OK too.</div><br/><div id="40446269" class="c"><input type="checkbox" id="c-40446269" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40446113">parent</a><span>|</span><a href="#40450824">next</a><span>|</span><label class="collapse" for="c-40446269">[-]</label><label class="expand" for="c-40446269">[2 more]</label></div><br/><div class="children"><div class="content">Google has produced a number of quite good tools. See also Bazel, for instance.<p>During my time there, I was genuinely impressed by the quality of many of the internal tools. E.g. it took GitHub code review tools a long time to get on par with Google&#x27;s internal code review tools from 2015.</div><br/><div id="40451932" class="c"><input type="checkbox" id="c-40451932" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40446269">parent</a><span>|</span><a href="#40450824">next</a><span>|</span><label class="collapse" for="c-40451932">[-]</label><label class="expand" for="c-40451932">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Google has produced a number of quite good tools.<p>&quot;Quite good&quot; is exactly the wording that I would have used too. But Go&#x27;s tooling is _really_ good; the language itself is, well, &quot;quite good&quot;. And is still supported and actively developed!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40450824" class="c"><input type="checkbox" id="c-40450824" checked=""/><div class="controls bullet"><span class="by">vaylian</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445713">parent</a><span>|</span><a href="#40445769">prev</a><span>|</span><a href="#40447615">next</a><span>|</span><label class="collapse" for="c-40450824">[-]</label><label class="expand" for="c-40450824">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The program can never reflect the shape of the problem, because it will be riddled with &quot;glue code&quot; that implements the obvious dull steps that you abstract away when reasoning.<p>How does this affect readability when one tries to dive into an existing Go project? Is Go code harder to navigate than code in more expressive languages?</div><br/><div id="40452242" class="c"><input type="checkbox" id="c-40452242" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40450824">parent</a><span>|</span><a href="#40452114">next</a><span>|</span><label class="collapse" for="c-40452242">[-]</label><label class="expand" for="c-40452242">[1 more]</label></div><br/><div class="children"><div class="content">Go really is the most &quot;readable&quot; code for anybody who has ever read something C (or Algol ;) like - so just about anybody. The only &quot;strange&quot; stuff is its `iota`, the method syntax and of course channels and goroutines. But that&#x27;s nowhere comparable to some C++ or Haskell, &quot;type heavy&quot; Typescript or some Lisp macro DSL.</div><br/></div></div><div id="40452114" class="c"><input type="checkbox" id="c-40452114" checked=""/><div class="controls bullet"><span class="by">nXqd</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40450824">parent</a><span>|</span><a href="#40452242">prev</a><span>|</span><a href="#40447615">next</a><span>|</span><label class="collapse" for="c-40452114">[-]</label><label class="expand" for="c-40452114">[1 more]</label></div><br/><div class="children"><div class="content">We shouldn&#x27;t overestimtae the complexity of expressive language like Clojrue vs Go. Go is perfectly simple and easy to follow, even compared with Clojure. If you come from background of Computer Science or programming first, Go is easier to follow.</div><br/></div></div></div></div><div id="40447615" class="c"><input type="checkbox" id="c-40447615" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445713">parent</a><span>|</span><a href="#40450824">prev</a><span>|</span><a href="#40451292">next</a><span>|</span><label class="collapse" for="c-40447615">[-]</label><label class="expand" for="c-40447615">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>they can focus on the small: this is a loop that iterates through a slice, this is an if condition that depends on this variable.</i><p>Then a week later, the squinty mole discovers the code is dead; not called at all.  There is no slice and no variable.</div><br/></div></div><div id="40451292" class="c"><input type="checkbox" id="c-40451292" checked=""/><div class="controls bullet"><span class="by">nXqd</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445713">parent</a><span>|</span><a href="#40447615">prev</a><span>|</span><a href="#40445912">next</a><span>|</span><label class="collapse" for="c-40451292">[-]</label><label class="expand" for="c-40451292">[1 more]</label></div><br/><div class="children"><div class="content">I do switch between Clojure and Rust depends on the problems I solve at hands ( prototypes vs building production ). And yes I need go through my checklist of each to switch from connecting data flows at high level to examine nuts and bolts at low level.</div><br/></div></div><div id="40445912" class="c"><input type="checkbox" id="c-40445912" checked=""/><div class="controls bullet"><span class="by">chuckadams</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445713">parent</a><span>|</span><a href="#40451292">prev</a><span>|</span><a href="#40451878">next</a><span>|</span><label class="collapse" for="c-40445912">[-]</label><label class="expand" for="c-40445912">[4 more]</label></div><br/><div class="children"><div class="content">While I share your perspective on go, I do prefer developing in a bottom-up way myself: I just do so with the intent of iterating my way to a higher level abstraction. Sometimes I see the abstraction right away and start with it, but I donât want a language that gets in my way in either direction.</div><br/><div id="40445970" class="c"><input type="checkbox" id="c-40445970" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445912">parent</a><span>|</span><a href="#40446954">next</a><span>|</span><label class="collapse" for="c-40445970">[-]</label><label class="expand" for="c-40445970">[1 more]</label></div><br/><div class="children"><div class="content">The thing is, in Go you can develop bottom-up, but you can&#x27;t always end up with a an appropriate abstraction, because of the lack of tools to achieve that.</div><br/></div></div><div id="40446954" class="c"><input type="checkbox" id="c-40446954" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445912">parent</a><span>|</span><a href="#40445970">prev</a><span>|</span><a href="#40451878">next</a><span>|</span><label class="collapse" for="c-40446954">[-]</label><label class="expand" for="c-40446954">[2 more]</label></div><br/><div class="children"><div class="content">A Lisp (like Clojure), or Haskell are <i>great</i> for playing around with things and developing bottom-up. I did just that for a day job sometimes. Of course, I then had to translate that to Python or TS, but once an idea is understood and tried, it&#x27;s not such a big deal.</div><br/><div id="40452151" class="c"><input type="checkbox" id="c-40452151" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40446954">parent</a><span>|</span><a href="#40451878">next</a><span>|</span><label class="collapse" for="c-40452151">[-]</label><label class="expand" for="c-40452151">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, for me Lisps, Python or TS (or Go) are great for playing around with things and developing bottom-up. And then I translate that to Haskell (or Rust or C++ or Go).</div><br/></div></div></div></div></div></div></div></div><div id="40451878" class="c"><input type="checkbox" id="c-40451878" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40445713">prev</a><span>|</span><a href="#40445871">next</a><span>|</span><label class="collapse" for="c-40451878">[-]</label><label class="expand" for="c-40451878">[1 more]</label></div><br/><div class="children"><div class="content">Writing Go is less fun but the language has far better tooling, dead simple deployment, lower memory usage, generally higher performance, and is easier to onboard new developers. Also I find it way easier to read old projects after time away.<p>You can get incredible mileage out of Go using just the stdlib, built in tools, and the pure go port of SQLite. With Clojure it feels like I have to stitch a million random libraries together to get anywhere. Writing Clojure is delightful but the ecosystem and tooling pale in comparison, and at the end of the day I think thatâs what matters.<p>If Clojure had great built-in tooling, better error messages (and maybe some SBCL-esque type checking features), and if Datomic was open source and less rough around the edges, I think the language would have been far more successful.</div><br/></div></div><div id="40445871" class="c"><input type="checkbox" id="c-40445871" checked=""/><div class="controls bullet"><span class="by">jakebasile</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40451878">prev</a><span>|</span><a href="#40451123">next</a><span>|</span><label class="collapse" for="c-40445871">[-]</label><label class="expand" for="c-40445871">[1 more]</label></div><br/><div class="children"><div class="content">I won&#x27;t tell you there aren&#x27;t stumbling blocks and impedence mismatches but most of them are relatively minor syntactical things. The faux-AST in my head gets typed out in the wrong format and I have to backspace and correct it (think function declaration differences). The biggest workflow difference is undoubtedly the lack of a REPL in Go, but that is somewhat made up for by Go&#x27;s lightning fast compilation and testing tooling (probably its second strongest attribute after the excellent standard library). After a day or two of writing in one or the other my neurons seem to get used to it only to cause the same problem in reverse when I switch back. Overall, it&#x27;s not too bad and a case of just accepting the tools available for what they are. I don&#x27;t try to force Go to be Clojure or Clojure to be Go.</div><br/></div></div><div id="40451123" class="c"><input type="checkbox" id="c-40451123" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40445871">prev</a><span>|</span><a href="#40445732">next</a><span>|</span><label class="collapse" for="c-40451123">[-]</label><label class="expand" for="c-40451123">[1 more]</label></div><br/><div class="children"><div class="content">Python is the new Java 5 here. The lack of multiline lambdas is incredibly awkward, leading to code that bounces you around the file.</div><br/></div></div><div id="40445732" class="c"><input type="checkbox" id="c-40445732" checked=""/><div class="controls bullet"><span class="by">a_wild_dandan</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40451123">prev</a><span>|</span><a href="#40447083">next</a><span>|</span><label class="collapse" for="c-40445732">[-]</label><label class="expand" for="c-40445732">[3 more]</label></div><br/><div class="children"><div class="content">I must use PyTorch for ML, but badly wish I could use TypeScript instead. Its type system demolishes anything else I&#x27;ve used. Writing anything from SPI communications, to server logic, to rich GUIs is a breeze. Then I work in Python and have to fight `Any`s, ambiguous arguments, more verbose code, and bizarrely slow run times. It makes me sad.</div><br/><div id="40446349" class="c"><input type="checkbox" id="c-40446349" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445732">parent</a><span>|</span><a href="#40447083">next</a><span>|</span><label class="collapse" for="c-40446349">[-]</label><label class="expand" for="c-40446349">[2 more]</label></div><br/><div class="children"><div class="content">While I agree with you, Python is getting better in this regard, as is mypy.<p>Making historical interfaces well-typed is another kettle of fish. For instance, Python&#x27;s range() is actually two overrides with incompatible signatures. I bet PyTorch has more of such examples.</div><br/><div id="40451242" class="c"><input type="checkbox" id="c-40451242" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40446349">parent</a><span>|</span><a href="#40447083">next</a><span>|</span><label class="collapse" for="c-40451242">[-]</label><label class="expand" for="c-40451242">[1 more]</label></div><br/><div class="children"><div class="content">If it only had a V8 class JIT in the package as well.</div><br/></div></div></div></div></div></div><div id="40447083" class="c"><input type="checkbox" id="c-40447083" checked=""/><div class="controls bullet"><span class="by">harrison_clarke</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40445732">prev</a><span>|</span><a href="#40445681">next</a><span>|</span><label class="collapse" for="c-40447083">[-]</label><label class="expand" for="c-40447083">[1 more]</label></div><br/><div class="children"><div class="content">i find i flip between different languages when i&#x27;m thinking about the problem in a different way<p>an expressive language (clojure, python, C#, etc.) is good when you&#x27;re iterating &quot;what problem am i even trying to solve?&quot;<p>a less expressive language is typically better when you more or less know a high level solution to your business problem, and you&#x27;re iterating on &quot;how do i make the machine actually do it&quot;. like &quot;how do i reduce my AWS bill&quot; or &quot;how do i render it in 16ms?&quot;<p>for something like gamedev, enough of the problem is in the second category that you might not even reach for the expressive language. (many do, though. with lua, or artisanal lisp dialects)</div><br/></div></div><div id="40445681" class="c"><input type="checkbox" id="c-40445681" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40447083">prev</a><span>|</span><a href="#40445848">next</a><span>|</span><label class="collapse" for="c-40445681">[-]</label><label class="expand" for="c-40445681">[3 more]</label></div><br/><div class="children"><div class="content">I write less boilerplate in Go than in Rust, about as much in Go (but of course different ;) as in Haskell).</div><br/><div id="40446988" class="c"><input type="checkbox" id="c-40446988" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445681">parent</a><span>|</span><a href="#40445848">next</a><span>|</span><label class="collapse" for="c-40446988">[-]</label><label class="expand" for="c-40446988">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool! How do you manage? E.g. the `if err != nil { return err; }` stuff?</div><br/><div id="40452111" class="c"><input type="checkbox" id="c-40452111" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40446988">parent</a><span>|</span><a href="#40445848">next</a><span>|</span><label class="collapse" for="c-40452111">[-]</label><label class="expand" for="c-40452111">[1 more]</label></div><br/><div class="children"><div class="content">Well, in the context of Lisp, `err != nil` is equivalent to Lisp&#x27;s parens: if somebody complains about that, chances are their critique is superficial (and there are enough &quot;real&quot; problems when using Go, especially when using goroutines and channels). The amount of low abstraction Go code I write is compensated by the amount of &quot;abstraction boilerplate&quot; like implementing type classes by myself or letting the compiler derive, implementing newtypes, adding GADTs, adding Pattern Synonyms and Type Families to be able to comfortably use the GADTs without much boilerplate and so on. Rust adds for example the need for associated types and is generally more verbose than Haskell.<p>I do not see a significant difference in the amount of boilerplate needed for catching exceptions, pattern matching or branching on the existence of an error value. Nobody can stop you from implementing `bind` in Go for your error (which I did in some places), but of course Rust &quot;wins&quot; with its `?`.</div><br/></div></div></div></div></div></div><div id="40445848" class="c"><input type="checkbox" id="c-40445848" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40445681">prev</a><span>|</span><a href="#40446324">next</a><span>|</span><label class="collapse" for="c-40445848">[-]</label><label class="expand" for="c-40445848">[4 more]</label></div><br/><div class="children"><div class="content">Java has had lambdas, map&#x2F;filter&#x2F;reduce and other stuff for like ten years or so I think. It&#x27;s a bit chatty for sure, but that&#x27;s what you want sometimes, the verbosity can make it easier for newcomers to make changes and additions.<p>To me it isn&#x27;t more infuriating than learning a new language or practicing one I&#x27;m not very good at. There&#x27;s a bit of friction, but that&#x27;s common when I&#x27;m developing in the languages I&#x27;m most fluent in too. Either that or the problem is trivial and likely to be in most common programming languages.</div><br/><div id="40451944" class="c"><input type="checkbox" id="c-40451944" checked=""/><div class="controls bullet"><span class="by">ErikCorry</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445848">parent</a><span>|</span><a href="#40450532">next</a><span>|</span><label class="collapse" for="c-40451944">[-]</label><label class="expand" for="c-40451944">[1 more]</label></div><br/><div class="children"><div class="content">These Java features are ruined by not allowing mutable variables to be captured. Having to do the 1-element array trick when the compiler could just do it for me is insane.<p>If you are making JavaScript look good you are failing as a language.</div><br/></div></div><div id="40450532" class="c"><input type="checkbox" id="c-40450532" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445848">parent</a><span>|</span><a href="#40451944">prev</a><span>|</span><a href="#40446377">next</a><span>|</span><label class="collapse" for="c-40450532">[-]</label><label class="expand" for="c-40450532">[1 more]</label></div><br/><div class="children"><div class="content">Iâve been writing a lot of Java 11 recently, and I find it to just be a very pleasant environment to work in: the IDEs still are best in class, afaict; the newer APIs avoid a lot of the boilerplate I used to have to write out and there are generally mature libraries to interact with just about any system you might need. Where Clojure really shines is that itâs a really well thought-out layer that can leverage this ecosystem and adds its own well-designed tools on top for my preferred more-interactive development style.</div><br/></div></div><div id="40446377" class="c"><input type="checkbox" id="c-40446377" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445848">parent</a><span>|</span><a href="#40450532">prev</a><span>|</span><a href="#40446324">next</a><span>|</span><label class="collapse" for="c-40446377">[-]</label><label class="expand" for="c-40446377">[1 more]</label></div><br/><div class="children"><div class="content">Java 7 is already pretty pleasant, and it has been improving ever since then.<p>(Say what you want about Oracle Corporation, but as the wardens of Java they&#x27;re doing a pretty good job.)</div><br/></div></div></div></div><div id="40446324" class="c"><input type="checkbox" id="c-40446324" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40445500">parent</a><span>|</span><a href="#40445848">prev</a><span>|</span><a href="#40450936">next</a><span>|</span><label class="collapse" for="c-40446324">[-]</label><label class="expand" for="c-40446324">[1 more]</label></div><br/><div class="children"><div class="content">We get used to being yet another work related chore.</div><br/></div></div></div></div><div id="40450936" class="c"><input type="checkbox" id="c-40450936" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40445289">parent</a><span>|</span><a href="#40445500">prev</a><span>|</span><a href="#40452020">next</a><span>|</span><label class="collapse" for="c-40450936">[-]</label><label class="expand" for="c-40450936">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;j&quot; is always what put me off from learning Clojure. I&#x27;ve had too many bad experiences with JDKs and JVMs that I stay a thousand kilometers away from any thing that has &quot;J&quot; in it unless it&#x27;s referring to JavaScript.</div><br/><div id="40451042" class="c"><input type="checkbox" id="c-40451042" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40445289">root</a><span>|</span><a href="#40450936">parent</a><span>|</span><a href="#40452020">next</a><span>|</span><label class="collapse" for="c-40451042">[-]</label><label class="expand" for="c-40451042">[1 more]</label></div><br/><div class="children"><div class="content">Check out Babashka. It&#x27;s a single binary that runs Clojure without a JVM. It also starts up really fast and has a much lower base memory requirement: <a href="https:&#x2F;&#x2F;github.com&#x2F;babashka&#x2F;babashka">https:&#x2F;&#x2F;github.com&#x2F;babashka&#x2F;babashka</a><p>It&#x27;s pretty easy to switch to writing JVM Clojure if you&#x27;re familiar with Babashka. Most of the libraries written for Babashka are designed to work in either environment.<p>That said, there are reasons you may want to use the Clojure on the JVM later on. It might be interesting to read the replies to another poster with similar concerns about the JVM: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40445415">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40445415</a></div><br/></div></div></div></div></div></div><div id="40452020" class="c"><input type="checkbox" id="c-40452020" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40445289">prev</a><span>|</span><a href="#40445197">next</a><span>|</span><label class="collapse" for="c-40452020">[-]</label><label class="expand" for="c-40452020">[4 more]</label></div><br/><div class="children"><div class="content">I wonder why no functional language has the degree of success imperative or OOP languages have.<p>Is functional programming too weird for majority of computer programmers? Is functional programming not optimal for solving industry problems? Maybe there is no functional programming that that is up to some set of standards? Is functional programming too complicated?<p>I do enjoy functional programming myself, and while I don&#x27;t use a functional programming language at work, I try to use functional programming paradigms when I finds it suits the probem.</div><br/><div id="40452276" class="c"><input type="checkbox" id="c-40452276" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#40452020">parent</a><span>|</span><a href="#40452078">next</a><span>|</span><label class="collapse" for="c-40452276">[-]</label><label class="expand" for="c-40452276">[1 more]</label></div><br/><div class="children"><div class="content">There are degrees and different shades of &quot;success&quot; and &quot;functional programming&quot;.<p>Clojure is successful, stable and well maintained. However it is a niche language compared the big mainstream languages. It takes a functional approach by default, but doesn&#x27;t shy away from other paradigms&#x2F;patterns&#x2F;idioms when appropriate.<p>Functional programming itself has had a huge influence on mainstream languages since about a decade and a half. More and more pragmatic features have been introduced in mainstream languages. Newer languages have adopted functional idioms from the get go. On the macro level as well, ops and architecture have been adopting statelessness, reproducibility and so on.<p>The consensus has shifted towards containing state. The more moving parts you have, the harder it gets to reason about a whole thing. Treating data as data.<p>OOP has also changed and got refined over this time. I think people realized that it has good ideas (generic interfaces, polymorphism etc.) and bad ideas (inheritance, local state etc.). Same thing with FP, there&#x27;s stuff that&#x27;s esoteric and too far from the reality of actual programming and stuff that is pragmatic and simplifying in there.</div><br/></div></div><div id="40452078" class="c"><input type="checkbox" id="c-40452078" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#40452020">parent</a><span>|</span><a href="#40452276">prev</a><span>|</span><a href="#40445197">next</a><span>|</span><label class="collapse" for="c-40452078">[-]</label><label class="expand" for="c-40452078">[2 more]</label></div><br/><div class="children"><div class="content">Functional programming <i>languages</i> haven&#x27;t gone mainstream but functional techniques are very common now.<p>Higher order functions, immutable data structures, declarative UI frameworks, etc are things you&#x27;re quite likely to encounter in a contemporary codebase these days.</div><br/><div id="40452220" class="c"><input type="checkbox" id="c-40452220" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#40452020">root</a><span>|</span><a href="#40452078">parent</a><span>|</span><a href="#40445197">next</a><span>|</span><label class="collapse" for="c-40452220">[-]</label><label class="expand" for="c-40452220">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I said. I do use functional programming techniques, I just wonder why functional programming languages don&#x27;t see a larger following.</div><br/></div></div></div></div></div></div><div id="40445197" class="c"><input type="checkbox" id="c-40445197" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40452020">prev</a><span>|</span><a href="#40450901">next</a><span>|</span><label class="collapse" for="c-40445197">[-]</label><label class="expand" for="c-40445197">[12 more]</label></div><br/><div class="children"><div class="content">If you are new to Clojure and would like to experiment with it in a way that is immediately useful, I highly recommend the Babashka runtime for scripting [0]. It&#x27;s very fun, approachable, and one of the more polished parts of the Clojure ecosystem.<p>It&#x27;s a particularly good entry point because unlike full-JVM Clojure it has a very fast startup time. Newcomers can use any file-watching &#x2F;reloading tools (e.g. nodemon) that they&#x27;re already familiar with to work with it interactively.<p>Hopefully, a enthusiastic user will graduate to using a REPL connection in their editor for a fully interactive setup. But newcomers tend not to do this... its an unfamiliar workflow to most, and can be pretty cumbersome to setup.<p>[0]: <a href="https:&#x2F;&#x2F;babashka.org" rel="nofollow">https:&#x2F;&#x2F;babashka.org</a></div><br/><div id="40445585" class="c"><input type="checkbox" id="c-40445585" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40445197">parent</a><span>|</span><a href="#40446451">next</a><span>|</span><label class="collapse" for="c-40445585">[-]</label><label class="expand" for="c-40445585">[8 more]</label></div><br/><div class="children"><div class="content">And when you&#x27;re ready to take the fun to the web, look no further than Biff: <a href="https:&#x2F;&#x2F;biffweb.com" rel="nofollow">https:&#x2F;&#x2F;biffweb.com</a></div><br/><div id="40445914" class="c"><input type="checkbox" id="c-40445914" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40445585">parent</a><span>|</span><a href="#40447232">next</a><span>|</span><label class="collapse" for="c-40445914">[-]</label><label class="expand" for="c-40445914">[2 more]</label></div><br/><div class="children"><div class="content">I recently went through most of the Biff tutorial but found it seemed to be missing some parts later on that had me scratching my head. It was otherwise a very enjoyable experience and Biff seems like a great way to get a &quot;batteries included&quot; starting point for web (similar to something like Rails or Django, though maybe not as comprehensive as either of those).</div><br/><div id="40446797" class="c"><input type="checkbox" id="c-40446797" checked=""/><div class="controls bullet"><span class="by">jacobobryant</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40445914">parent</a><span>|</span><a href="#40447232">next</a><span>|</span><label class="collapse" for="c-40446797">[-]</label><label class="expand" for="c-40446797">[1 more]</label></div><br/><div class="children"><div class="content">Mind sharing the parts of the tutorial you had trouble with, if you remember?</div><br/></div></div></div></div><div id="40447232" class="c"><input type="checkbox" id="c-40447232" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40445585">parent</a><span>|</span><a href="#40445914">prev</a><span>|</span><a href="#40446314">next</a><span>|</span><label class="collapse" for="c-40447232">[-]</label><label class="expand" for="c-40447232">[3 more]</label></div><br/><div class="children"><div class="content">Ah neat. But darn, I was kinda hoping for supporting tools and packages with names like tannen, delorean, doc, mcfly, and strickland ;)</div><br/><div id="40447242" class="c"><input type="checkbox" id="c-40447242" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40447232">parent</a><span>|</span><a href="#40446314">next</a><span>|</span><label class="collapse" for="c-40447242">[-]</label><label class="expand" for="c-40447242">[2 more]</label></div><br/><div class="children"><div class="content">It features a time-travel database, if that helps!<p><a href="https:&#x2F;&#x2F;biffweb.com&#x2F;p&#x2F;xtdb-compared-to-other-databases&#x2F;" rel="nofollow">https:&#x2F;&#x2F;biffweb.com&#x2F;p&#x2F;xtdb-compared-to-other-databases&#x2F;</a></div><br/><div id="40451776" class="c"><input type="checkbox" id="c-40451776" checked=""/><div class="controls bullet"><span class="by">ungamedplayer</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40447242">parent</a><span>|</span><a href="#40446314">next</a><span>|</span><label class="collapse" for="c-40451776">[-]</label><label class="expand" for="c-40451776">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if op had chance to evaluate because they were outatime.</div><br/></div></div></div></div></div></div><div id="40446314" class="c"><input type="checkbox" id="c-40446314" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40445585">parent</a><span>|</span><a href="#40447232">prev</a><span>|</span><a href="#40446451">next</a><span>|</span><label class="collapse" for="c-40446314">[-]</label><label class="expand" for="c-40446314">[2 more]</label></div><br/><div class="children"><div class="content">I love this so much. The power of being able to connect a repl to your production instance and fix bugs instantly is hard to understate. Itâs actually kind of hard to explain to devs used to deployment cycles measured in <i>weeks</i></div><br/><div id="40451520" class="c"><input type="checkbox" id="c-40451520" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40446314">parent</a><span>|</span><a href="#40446451">next</a><span>|</span><label class="collapse" for="c-40451520">[-]</label><label class="expand" for="c-40451520">[1 more]</label></div><br/><div class="children"><div class="content">How is the fix committed once you are done? Does this run counter to immutable deployments?</div><br/></div></div></div></div></div></div><div id="40446451" class="c"><input type="checkbox" id="c-40446451" checked=""/><div class="controls bullet"><span class="by">yogthos</span><span>|</span><a href="#40445197">parent</a><span>|</span><a href="#40445585">prev</a><span>|</span><a href="#40450901">next</a><span>|</span><label class="collapse" for="c-40446451">[-]</label><label class="expand" for="c-40446451">[3 more]</label></div><br/><div class="children"><div class="content">The best part about Babashka is that it&#x27;s really batteries included nowadays. I had to make a little UI to display some stats about an app at work, and decided to try using it with HTMX. Turned out to be a really good experience. Babashka has pretty much everything you need for a basic web app baked in, and HTMX lets you do dynamic loading on the page without having to bother with a Js frontend.<p>Best part is that bb can start nREPL with `bb --nrepl-server` and then you can connect an editor like Calva to it and develop the script interactively. Definitely recommend checking it out if you need to make a simple web UI. Here&#x27;s an example of a full fledged web app:<p><pre><code>    #!&#x2F;usr&#x2F;bin&#x2F;env bb
    (require
     &#x27;[clojure.string :as str]
     &#x27;[org.httpkit.server :as srv]
     &#x27;[hiccup2.core :as hp]
     &#x27;[cheshire.core :as json]
     &#x27;[babashka.pods :as pods]
     &#x27;[clojure.java.io :as io]
     &#x27;[clojure.edn :as edn])
    (import &#x27;[java.net URLDecoder])

    (pods&#x2F;load-pod &#x27;org.babashka&#x2F;postgresql &quot;0.1.0&quot;)
    (require &#x27;[pod.babashka.postgresql :as pg])

    (defonce server (atom nil))
    (defonce conn (atom nil))

    (def favicon &quot;data:image&#x2F;x-icon;base64,AAABAAEAEBAAAAAAAABoBQAAFgAAACgAAAAQAAAAIAAAAAEACAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP&#x2F;&#x2F;AAD8fwAA&#x2F;H8AAPxjAAD&#x2F;4wAA&#x2F;+MAAMY&#x2F;AADGPwAAxjEAAP&#x2F;xAAD&#x2F;8QAA4x8AAOMfAADjHwAA&#x2F;&#x2F;8AAP&#x2F;&#x2F;AAA=&quot;)

    (defn list-accounts [{:keys [from to]}]
      (pg&#x2F;execute! @conn
                   [&quot;select account_id, created_at
                     from accounts
                     where created_at between to_date(?, &#x27;yyyy-mm-dd&#x27;) and to_date(?, &#x27;yyyy-mm-dd&#x27;)&quot;
                    from to]))

    (defn list-all-accounts [_req]
      (json&#x2F;encode {:accounts (pg&#x2F;execute! @conn [&quot;select account_id, created_at from accounts&quot;])}))

    (defn parse-body [{:keys [body]}]
      (reduce
       (fn [params param]
         (let [[k v] (str&#x2F;split param #&quot;=&quot;)]
           (assoc params (keyword k) (URLDecoder&#x2F;decode v))))
       {}
       (-&gt; body slurp (str&#x2F;split #&quot;&amp;&quot;))))

    (defn render [html]
      (str (hp&#x2F;html html)))

    (defn render-accounts [request]
      (let [params (parse-body request)
            accounts (list-accounts params)]
        [:table.table {:id &quot;accounts&quot;}
         [:thead
          [:tr [:th &quot;account id&quot;] [:th &quot;created at&quot;]]]
         [:tbody
          (for [{:accounts&#x2F;keys [account_id created_at]} accounts]
            [:tr [:td account_id] [:td (str created_at)]])]]))

    (defn date-str [date]
      (let [fmt (java.text.SimpleDateFormat. &quot;yyyy-MM-dd&quot;)]
        (.format fmt date)))

    (defn account-stats []
      [:section.hero
       [:div.hero-body
        [:div.container
         [:div.columns
          [:div.column
           [:form.box
            {:hx-post &quot;&#x2F;accounts-in-range&quot;
             :hx-target &quot;#accounts&quot;
             :hx-swap &quot;outerHTML&quot;}
            [:h1.title &quot;Accounts&quot;]
            [:div.field
             [:label.label {:for &quot;from&quot;} [:b &quot;from &quot;]]
             [:input.control {:type &quot;date&quot; :id &quot;from&quot; :name &quot;from&quot; :value (date-str (java.util.Date.))}]]
    
            [:div.field
             [:label.label {:for &quot;to&quot;} [:b &quot; to &quot;]]
             [:input.control {:type &quot;date&quot; :id &quot;to&quot; :name &quot;to&quot; :value (date-str (java.util.Date.))}]]
    
            [:button.button {:type &quot;submit&quot;} &quot;list accounts&quot;]]
           [:div.box [:table.table {:id &quot;accounts&quot;}]]]]]]])
    
    (defn home-page [_req]
      (render
       [:html
        [:head
         [:link {:href favicon :rel &quot;icon&quot; :type &quot;image&#x2F;x-icon&quot;}]
         [:meta {:charset &quot;UTF-8&quot;}]
         [:title &quot;Account Stats&quot;]
         [:link {:href &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;bulma@1.0.0&#x2F;css&#x2F;bulma.min.css&quot; :rel &quot;stylesheet&quot;}]
         [:link {:href &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;todomvc-app-css@2.4.1&#x2F;index.css&quot; :rel &quot;stylesheet&quot;}]
         [:script {:src &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;htmx.org@1.5.0&#x2F;dist&#x2F;htmx.min.js&quot; :defer true}]
         [:script {:src &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;hyperscript.org@0.8.1&#x2F;dist&#x2F;_hyperscript.min.js&quot; :defer true}]]
        [:body
         (account-stats)]]))

    (defn handler [{:keys [uri request-method] :as req}]
      (condp = [request-method uri]
        [:get &quot;&#x2F;&quot;]
        {:body (home-page req)
         :headers {&quot;Content-Type&quot; &quot;text&#x2F;html charset=utf-8&quot;}
         :status 200}

        [:get &quot;&#x2F;accounts.json&quot;]
        {:body (list-all-accounts req)
         :headers {&quot;Content-Type&quot; &quot;application&#x2F;json; charset=utf-8&quot;}
         :status 200}

        [:post &quot;&#x2F;accounts-in-range&quot;]
        {:body (render (render-accounts req))
         :status 200}

        {:body (str &quot;page &quot; uri &quot; not found&quot;)
         :status 404}))

    (defn read-config []
      (if (.exists (io&#x2F;file &quot;config.edn&quot;))
        (edn&#x2F;read-string (slurp &quot;config.edn&quot;))
        {:port 3001
         :db {:dbtype   &quot;postgresql&quot;
              :host     &quot;localhost&quot;
              :dbname   &quot;postgres&quot;
              :user     &quot;postgres&quot;
              :password &quot;postgres&quot;
              :port     5432}}))
    
    (defn run []
      (let [{:keys [port db]} (read-config)]
        (reset! conn db)
        (when-let [server @server]
          (server))
        (reset! server
                (srv&#x2F;run-server #(handler %) {:port port}))
        (println &quot;started on port:&quot; port)))

    ;; ensures process doesn&#x27;t exit when running from command line
    (when (= &quot;start&quot; (first *command-line-args*))
      (run)
      @(promise))

    (comment
      ;; restart server 
      (do
        (when-let [instance @server] (instance))
        (reset! server nil)
        (run)))</code></pre></div><br/><div id="40446533" class="c"><input type="checkbox" id="c-40446533" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40446451">parent</a><span>|</span><a href="#40450901">next</a><span>|</span><label class="collapse" for="c-40446533">[-]</label><label class="expand" for="c-40446533">[2 more]</label></div><br/><div class="children"><div class="content">I agree. It&#x27;s a breath of fresh air in the Clojure world. I&#x27;m grateful to thoughtful builders like yourself and borkdude for bringing the language to new heights.</div><br/><div id="40447677" class="c"><input type="checkbox" id="c-40447677" checked=""/><div class="controls bullet"><span class="by">yogthos</span><span>|</span><a href="#40445197">root</a><span>|</span><a href="#40446533">parent</a><span>|</span><a href="#40450901">next</a><span>|</span><label class="collapse" for="c-40447677">[-]</label><label class="expand" for="c-40447677">[1 more]</label></div><br/><div class="children"><div class="content">Babashka is definitely the most exciting thing currently happening in Clojure world in my opinion. And thanks, always great to hear my stuff ends up being useful. :)</div><br/></div></div></div></div></div></div></div></div><div id="40450901" class="c"><input type="checkbox" id="c-40450901" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#40445197">prev</a><span>|</span><a href="#40446074">next</a><span>|</span><label class="collapse" for="c-40450901">[-]</label><label class="expand" for="c-40450901">[5 more]</label></div><br/><div class="children"><div class="content">the best reason to learn clojure is reagent[1], by far the best way to use react.<p>shadow-cljs[2] makes using npm libraries easy.<p>iâve settled on go backends and reagent frontends as my default setup[3].<p>1. <a href="https:&#x2F;&#x2F;reagent-project.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reagent-project.github.io&#x2F;</a><p>2. <a href="https:&#x2F;&#x2F;github.com&#x2F;thheller&#x2F;shadow-cljs">https:&#x2F;&#x2F;github.com&#x2F;thheller&#x2F;shadow-cljs</a><p>3. <a href="https:&#x2F;&#x2F;github.com&#x2F;nathants&#x2F;aws-gocljs">https:&#x2F;&#x2F;github.com&#x2F;nathants&#x2F;aws-gocljs</a></div><br/><div id="40450954" class="c"><input type="checkbox" id="c-40450954" checked=""/><div class="controls bullet"><span class="by">jarl-ragnar</span><span>|</span><a href="#40450901">parent</a><span>|</span><a href="#40452131">prev</a><span>|</span><a href="#40451115">next</a><span>|</span><label class="collapse" for="c-40450954">[-]</label><label class="expand" for="c-40450954">[1 more]</label></div><br/><div class="children"><div class="content">Completely agree. Though Iâve also found an Elixir backend works well because of the power of the Beam VM.</div><br/></div></div><div id="40451115" class="c"><input type="checkbox" id="c-40451115" checked=""/><div class="controls bullet"><span class="by">createaccount99</span><span>|</span><a href="#40450901">parent</a><span>|</span><a href="#40450954">prev</a><span>|</span><a href="#40446074">next</a><span>|</span><label class="collapse" for="c-40451115">[-]</label><label class="expand" for="c-40451115">[2 more]</label></div><br/><div class="children"><div class="content">Does your setup do code splitting, SSG? I can&#x27;t really be shipping a blank html file in 2024, destroys SEO. Otherwise am interested in trying.</div><br/><div id="40451158" class="c"><input type="checkbox" id="c-40451158" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#40450901">root</a><span>|</span><a href="#40451115">parent</a><span>|</span><a href="#40446074">next</a><span>|</span><label class="collapse" for="c-40451158">[-]</label><label class="expand" for="c-40451158">[1 more]</label></div><br/><div class="children"><div class="content">no, iâm not interested in seo.<p>this setup is a single go binary that serves a single pre-gzipped html file from a lambda.<p>that html file contains inlined js, that is a reagent app.<p>there is also a favicon. total of 3 files in the lambda zip.<p>you desired setup is certainly possible though. youâd probably want clojure on the backend though, so you could more easily do SSG.</div><br/></div></div></div></div></div></div><div id="40446074" class="c"><input type="checkbox" id="c-40446074" checked=""/><div class="controls bullet"><span class="by">socksy</span><span>|</span><a href="#40450901">prev</a><span>|</span><a href="#40449683">next</a><span>|</span><label class="collapse" for="c-40446074">[-]</label><label class="expand" for="c-40446074">[1 more]</label></div><br/><div class="children"><div class="content">Another website in this vein is <a href="https:&#x2F;&#x2F;www.maria.cloud&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.maria.cloud&#x2F;</a> which is more geared up for teaching complete beginners programming, but I think with the basic paredit style controls and the evaluate-each-form-at-a-time style is I think a lot more realistic to the kind of REPL driven development that you actually use â typing directly into the REPL terminal window is very unergonomic imo. Youâre much more likely to use something like VSCodeâs Calva or emacsâ cider to send the form under the cursor to a REPL process somewhere.</div><br/></div></div><div id="40449683" class="c"><input type="checkbox" id="c-40449683" checked=""/><div class="controls bullet"><span class="by">eliben</span><span>|</span><a href="#40446074">prev</a><span>|</span><a href="#40446717">next</a><span>|</span><label class="collapse" for="c-40449683">[-]</label><label class="expand" for="c-40449683">[1 more]</label></div><br/><div class="children"><div class="content">I loved my stint with Clojure, highly recommend it (<a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2017&#x2F;clojure-the-perfect-language-to-expand-your-brain&#x2F;" rel="nofollow">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2017&#x2F;clojure-the-perfect-langu...</a>)</div><br/></div></div><div id="40446717" class="c"><input type="checkbox" id="c-40446717" checked=""/><div class="controls bullet"><span class="by">tastyminerals2</span><span>|</span><a href="#40449683">prev</a><span>|</span><a href="#40446684">next</a><span>|</span><label class="collapse" for="c-40446717">[-]</label><label class="expand" for="c-40446717">[9 more]</label></div><br/><div class="children"><div class="content">I have to admit, several years ago, a colleague of mine advised me if not to try Clojure but at least to read the &quot;History of Clojure&quot;: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3386321" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3386321</a>, which I never did. But one day I decided to watch Rich Hickey - Greatest Hits <a href="https:&#x2F;&#x2F;changelog.com&#x2F;posts&#x2F;rich-hickeys-greatest-hits" rel="nofollow">https:&#x2F;&#x2F;changelog.com&#x2F;posts&#x2F;rich-hickeys-greatest-hits</a>... I then read the &quot;History of Clojure&quot;, and then jumped into learning it. 
This is probably one of the most fun languages to build with and one of the most beautiful ones. If not syntax-wise, rather in a way it allows you to express your thoughts via good design and composition that so nicely tickles your brain. If you are still searching for that one shiny tool, and none of them clicks, maybe try Clojure. It&#x27;s one of the most concise and yet powerful languages I&#x27;ve seen.</div><br/><div id="40446976" class="c"><input type="checkbox" id="c-40446976" checked=""/><div class="controls bullet"><span class="by">ryan-duve</span><span>|</span><a href="#40446717">parent</a><span>|</span><a href="#40446684">next</a><span>|</span><label class="collapse" for="c-40446976">[-]</label><label class="expand" for="c-40446976">[8 more]</label></div><br/><div class="children"><div class="content">I got what you described by learning Common Lisp just a few months ago.  Do you think learning Clojure would get me something in addition to that or is it roughly the same?</div><br/><div id="40449867" class="c"><input type="checkbox" id="c-40449867" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40450510">next</a><span>|</span><label class="collapse" for="c-40449867">[-]</label><label class="expand" for="c-40449867">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you think learning Clojure would get me something in addition to that<p>For me, the biggest benefit is that it&#x27;s hosted. Learning only Clojure, I can easily today write for JVM, .NET, JavaScript, Flutter, or shell scripts. Even when I need to write Lua, I&#x27;d usually pick Fennel. It&#x27;s not Clojure but feels very similar. There are libs that can give you Python or R interop from Clojure. There are projects to target Golang, Rust or Erlang. Jank is a super interesting, experimental implementation of Clojure that runs on LLVM, I&#x27;m very excited about it. Do you want to become a true polyglot programmer? You only need to learn Clojure.</div><br/></div></div><div id="40450510" class="c"><input type="checkbox" id="c-40450510" checked=""/><div class="controls bullet"><span class="by">didibus</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40449867">prev</a><span>|</span><a href="#40449172">next</a><span>|</span><label class="collapse" for="c-40450510">[-]</label><label class="expand" for="c-40450510">[1 more]</label></div><br/><div class="children"><div class="content">Clojure also teaches you functional programming, where-as CL only teaches you the LISP beauty. Clojure teaches you both Lisp and Fp. So the FP part should still be worth it even though you got the Lisp part from CL.</div><br/></div></div><div id="40449172" class="c"><input type="checkbox" id="c-40449172" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40450510">prev</a><span>|</span><a href="#40447702">next</a><span>|</span><label class="collapse" for="c-40449172">[-]</label><label class="expand" for="c-40449172">[1 more]</label></div><br/><div class="children"><div class="content">I think Clojure leans into immutability a lot, and that leads to more interesting APIs and norms that are valuable. CL has always felt a bit more.... &quot;running on a machine&quot; that I feel has less of a place in an era where everyone and their dog has functional programming essentials built in.<p>Clojure is interesting, but some Clojure APIs (stuff like Spectre) is &quot;I want this everywhere now&quot; stuff.</div><br/></div></div><div id="40447702" class="c"><input type="checkbox" id="c-40447702" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40449172">prev</a><span>|</span><a href="#40449156">next</a><span>|</span><label class="collapse" for="c-40447702">[-]</label><label class="expand" for="c-40447702">[1 more]</label></div><br/><div class="children"><div class="content">IMO, Clojure is superficially&#x2F;syntactically much more elegant and beautiful than Common Lisp or Scheme. I find this really helps you focus on what matters most.</div><br/></div></div><div id="40449156" class="c"><input type="checkbox" id="c-40449156" checked=""/><div class="controls bullet"><span class="by">silcoon</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40447702">prev</a><span>|</span><a href="#40447062">next</a><span>|</span><label class="collapse" for="c-40449156">[-]</label><label class="expand" for="c-40449156">[1 more]</label></div><br/><div class="children"><div class="content">really good talk from Rich Hickey:
Clojure for Lisp Programmers - <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cPNkH-7PRTk&amp;t=3837s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cPNkH-7PRTk&amp;t=3837s</a></div><br/></div></div><div id="40447062" class="c"><input type="checkbox" id="c-40447062" checked=""/><div class="controls bullet"><span class="by">tmountain</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40449156">prev</a><span>|</span><a href="#40448336">next</a><span>|</span><label class="collapse" for="c-40447062">[-]</label><label class="expand" for="c-40447062">[1 more]</label></div><br/><div class="children"><div class="content">Depends on your style of programming CL. Clojure is immutable by default with a heavy emphasis on concurrency and strong ties to the JVM as its host environment. The differences youâll find mostly lie in those areas.</div><br/></div></div><div id="40448336" class="c"><input type="checkbox" id="c-40448336" checked=""/><div class="controls bullet"><span class="by">vindarel</span><span>|</span><a href="#40446717">root</a><span>|</span><a href="#40446976">parent</a><span>|</span><a href="#40447062">prev</a><span>|</span><a href="#40446684">next</a><span>|</span><label class="collapse" for="c-40448336">[-]</label><label class="expand" for="c-40448336">[1 more]</label></div><br/><div class="children"><div class="content">Besides the superficial syntax, those are some differences pointed out by (common) lispers: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;vindarel&#x2F;3484a4bcc944a5be143e74bfae1025e4" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;vindarel&#x2F;3484a4bcc944a5be143e74bfae1...</a></div><br/></div></div></div></div></div></div><div id="40446684" class="c"><input type="checkbox" id="c-40446684" checked=""/><div class="controls bullet"><span class="by">__rito__</span><span>|</span><a href="#40446717">prev</a><span>|</span><a href="#40445478">next</a><span>|</span><label class="collapse" for="c-40446684">[-]</label><label class="expand" for="c-40446684">[4 more]</label></div><br/><div class="children"><div class="content"><i>Clojure for the Brave and True</i> by Daniel Higginbotham is a truly great resource to learn Clojure. I highly recommend it. It is also free online [0].<p>[0]: <a href="https:&#x2F;&#x2F;www.braveclojure.com&#x2F;clojure-for-the-brave-and-true" rel="nofollow">https:&#x2F;&#x2F;www.braveclojure.com&#x2F;clojure-for-the-brave-and-true</a></div><br/><div id="40450939" class="c"><input type="checkbox" id="c-40450939" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40446684">parent</a><span>|</span><a href="#40446802">next</a><span>|</span><label class="collapse" for="c-40450939">[-]</label><label class="expand" for="c-40450939">[1 more]</label></div><br/><div class="children"><div class="content">I think the writing style is too fluffy, but I realize some people like that. The true sin of this book is that it actually starts by teaching the reader <i>Emacs</i>, not Clojure. That&#x27;s a huge distraction for a beginner who is probably coming from VSCode these days.</div><br/></div></div><div id="40446802" class="c"><input type="checkbox" id="c-40446802" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40446684">parent</a><span>|</span><a href="#40450939">prev</a><span>|</span><a href="#40447783">next</a><span>|</span><label class="collapse" for="c-40446802">[-]</label><label class="expand" for="c-40446802">[1 more]</label></div><br/><div class="children"><div class="content">Seconded. I&#x27;m also a big fan of Aphyr&#x27;s &quot;Clojure from the ground up&quot; series:
<a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;301-clojure-from-the-ground-up-welcome" rel="nofollow">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;301-clojure-from-the-ground-up-welco...</a></div><br/></div></div><div id="40447783" class="c"><input type="checkbox" id="c-40447783" checked=""/><div class="controls bullet"><span class="by">stefcoetzee</span><span>|</span><a href="#40446684">parent</a><span>|</span><a href="#40446802">prev</a><span>|</span><a href="#40445478">next</a><span>|</span><label class="collapse" for="c-40447783">[-]</label><label class="expand" for="c-40447783">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Perhaps using VSCode with the Calva plugin if the reader has no previous experience with Emacs.</div><br/></div></div></div></div><div id="40445478" class="c"><input type="checkbox" id="c-40445478" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#40446684">prev</a><span>|</span><a href="#40446278">next</a><span>|</span><label class="collapse" for="c-40445478">[-]</label><label class="expand" for="c-40445478">[8 more]</label></div><br/><div class="children"><div class="content">Is there a version of Clojure that compiles to LLVM or something? Sort of like what Scala-native was supposed to be (but never materialized). I like functional programming but I can&#x27;t abide the Java ecosystem in 2024, it&#x27;s just too archaic for my taste.</div><br/><div id="40447527" class="c"><input type="checkbox" id="c-40447527" checked=""/><div class="controls bullet"><span class="by">jomendoz</span><span>|</span><a href="#40445478">parent</a><span>|</span><a href="#40445714">next</a><span>|</span><label class="collapse" for="c-40447527">[-]</label><label class="expand" for="c-40447527">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an ongoing effort to create a Clang&#x2F;LLVM implementation of Clojure&#x27;s runtime with hot reloading and other very interesting features. You can take a look at it at <a href="https:&#x2F;&#x2F;jank-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jank-lang.org&#x2F;</a>. It still hasn&#x27;t reached feature parity with full blown JVM Clojure but we&#x27;ve paying close attention to its development.</div><br/></div></div><div id="40445714" class="c"><input type="checkbox" id="c-40445714" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40445478">parent</a><span>|</span><a href="#40447527">prev</a><span>|</span><a href="#40446565">next</a><span>|</span><label class="collapse" for="c-40445714">[-]</label><label class="expand" for="c-40445714">[2 more]</label></div><br/><div class="children"><div class="content">the top comment as of writing this reply points to <a href="https:&#x2F;&#x2F;babashka.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;babashka.org&#x2F;</a>, but it&#x27;s GraalVM instead of LLVM (which shouldn&#x27;t really bother you)</div><br/><div id="40446801" class="c"><input type="checkbox" id="c-40446801" checked=""/><div class="controls bullet"><span class="by">kolme</span><span>|</span><a href="#40445478">root</a><span>|</span><a href="#40445714">parent</a><span>|</span><a href="#40446565">next</a><span>|</span><label class="collapse" for="c-40446801">[-]</label><label class="expand" for="c-40446801">[1 more]</label></div><br/><div class="children"><div class="content">Babashka scripts are interpreted, the babashka binary itself is compiled with GraalVM.<p>But: you can also build regular Clojure programs using GraalVM and create a fast-starting binary.</div><br/></div></div></div></div><div id="40446565" class="c"><input type="checkbox" id="c-40446565" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40445478">parent</a><span>|</span><a href="#40445714">prev</a><span>|</span><a href="#40446537">next</a><span>|</span><label class="collapse" for="c-40446565">[-]</label><label class="expand" for="c-40446565">[3 more]</label></div><br/><div class="children"><div class="content">Soon there will be! <a href="https:&#x2F;&#x2F;jank-lang.org" rel="nofollow">https:&#x2F;&#x2F;jank-lang.org</a></div><br/><div id="40446975" class="c"><input type="checkbox" id="c-40446975" checked=""/><div class="controls bullet"><span class="by">lgrapenthin</span><span>|</span><a href="#40445478">root</a><span>|</span><a href="#40446565">parent</a><span>|</span><a href="#40446537">next</a><span>|</span><label class="collapse" for="c-40446975">[-]</label><label class="expand" for="c-40446975">[2 more]</label></div><br/><div class="children"><div class="content">Do they have a realistic shot at implementing immutable datastructures?</div><br/><div id="40449954" class="c"><input type="checkbox" id="c-40449954" checked=""/><div class="controls bullet"><span class="by">Jeaye</span><span>|</span><a href="#40445478">root</a><span>|</span><a href="#40446975">parent</a><span>|</span><a href="#40446537">next</a><span>|</span><label class="collapse" for="c-40449954">[-]</label><label class="expand" for="c-40449954">[1 more]</label></div><br/><div class="children"><div class="content">Oh for sure. That&#x27;s not the tough part. :)<p>jank uses immer for that: <a href="https:&#x2F;&#x2F;github.com&#x2F;arximboldi&#x2F;immer">https:&#x2F;&#x2F;github.com&#x2F;arximboldi&#x2F;immer</a></div><br/></div></div></div></div></div></div><div id="40446537" class="c"><input type="checkbox" id="c-40446537" checked=""/><div class="controls bullet"><span class="by">ojw</span><span>|</span><a href="#40445478">parent</a><span>|</span><a href="#40446565">prev</a><span>|</span><a href="#40446278">next</a><span>|</span><label class="collapse" for="c-40446537">[-]</label><label class="expand" for="c-40446537">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;jank-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jank-lang.org&#x2F;</a></div><br/></div></div></div></div><div id="40446278" class="c"><input type="checkbox" id="c-40446278" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40445478">prev</a><span>|</span><a href="#40447152">next</a><span>|</span><label class="collapse" for="c-40446278">[-]</label><label class="expand" for="c-40446278">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Try Clojure â An interactive tutorial in the browser</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30423856">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30423856</a> - Feb 2022 (93 comments)<p><i>Try Clojure in your browser</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3366526">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=3366526</a> - Dec 2011 (26 comments)<p><i>Try Clojure</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1359682">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=1359682</a> - May 2010 (60 comments)</div><br/></div></div><div id="40447152" class="c"><input type="checkbox" id="c-40447152" checked=""/><div class="controls bullet"><span class="by">jackbravo</span><span>|</span><a href="#40446278">prev</a><span>|</span><a href="#40448091">next</a><span>|</span><label class="collapse" for="c-40447152">[-]</label><label class="expand" for="c-40447152">[2 more]</label></div><br/><div class="children"><div class="content">Clojure is becoming popular in Mexico, and I&#x27;m guessing Brazil may see a similar situation, because of nubank. It is a popular destination to go work there for computer scientists, and they seem to work mostly in Clojure. I seem to remember they even employed some of the core members of the language? I think at some point they also bought the company of Jose Valim (Elixir&#x27;s creator), but I think they are still mostly a Clojure shop.</div><br/><div id="40448430" class="c"><input type="checkbox" id="c-40448430" checked=""/><div class="controls bullet"><span class="by">hlship</span><span>|</span><a href="#40447152">parent</a><span>|</span><a href="#40448091">next</a><span>|</span><label class="collapse" for="c-40448430">[-]</label><label class="expand" for="c-40448430">[1 more]</label></div><br/><div class="children"><div class="content">Nubank purchased Cognitect (the consulting company behind Clojure) in 2020, as well as Platformatec (employers of Jose Valim); the latter was for access to Platformatec&#x27;s project management expertise (see <a href="https:&#x2F;&#x2F;building.nubank.com.br&#x2F;tech-perspectives-behind-nubanks-first-acquisition-deal&#x2F;);" rel="nofollow">https:&#x2F;&#x2F;building.nubank.com.br&#x2F;tech-perspectives-behind-nuba...</a> there is no Elixir code running at Nubank AFAIK.<p>There is Python on the &quot;other side&quot; of the ETL pipeline, but everything user-facing is (again AFAIK) Clojure on the backend and TypeScript in the Android and iOS apps.</div><br/></div></div></div></div><div id="40448091" class="c"><input type="checkbox" id="c-40448091" checked=""/><div class="controls bullet"><span class="by">memothon</span><span>|</span><a href="#40447152">prev</a><span>|</span><a href="#40445634">next</a><span>|</span><label class="collapse" for="c-40448091">[-]</label><label class="expand" for="c-40448091">[1 more]</label></div><br/><div class="children"><div class="content">My favorite part of working in clojure is how easy it is to do common data structure operations.<p>map, filter and reduce are extraordinarily powerful, especially when combined with the other core library functions.</div><br/></div></div><div id="40445634" class="c"><input type="checkbox" id="c-40445634" checked=""/><div class="controls bullet"><span class="by">qnsoaejacniln</span><span>|</span><a href="#40448091">prev</a><span>|</span><a href="#40444995">next</a><span>|</span><label class="collapse" for="c-40445634">[-]</label><label class="expand" for="c-40445634">[3 more]</label></div><br/><div class="children"><div class="content">There is XSS in the (my-name) part :)<p>(my-name &quot;&lt;img src=&#x27;#&#x27; onerror=alert(1) &#x2F;&gt;&quot;)</div><br/><div id="40451439" class="c"><input type="checkbox" id="c-40451439" checked=""/><div class="controls bullet"><span class="by">hpeter</span><span>|</span><a href="#40445634">parent</a><span>|</span><a href="#40450582">next</a><span>|</span><label class="collapse" for="c-40451439">[-]</label><label class="expand" for="c-40451439">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not XSS if it&#x27;s not cross-site.</div><br/></div></div><div id="40450582" class="c"><input type="checkbox" id="c-40450582" checked=""/><div class="controls bullet"><span class="by">didibus</span><span>|</span><a href="#40445634">parent</a><span>|</span><a href="#40451439">prev</a><span>|</span><a href="#40444995">next</a><span>|</span><label class="collapse" for="c-40450582">[-]</label><label class="expand" for="c-40450582">[1 more]</label></div><br/><div class="children"><div class="content">Nice catch. Is it an issue though when the script injection only runs within your own browser session?</div><br/></div></div></div></div><div id="40444995" class="c"><input type="checkbox" id="c-40444995" checked=""/><div class="controls bullet"><span class="by">munirusman</span><span>|</span><a href="#40445634">prev</a><span>|</span><a href="#40444309">next</a><span>|</span><label class="collapse" for="c-40444995">[-]</label><label class="expand" for="c-40444995">[1 more]</label></div><br/><div class="children"><div class="content">Shameless plug: If youâre looking for an online compiler specifically designed for conducting interviews in Clojure, you might find [0] very useful. Itâs designed to streamline coding interviews with real-time collaboration features.<p>[0] <a href="https:&#x2F;&#x2F;codeinterview.io&#x2F;languages&#x2F;clojure" rel="nofollow">https:&#x2F;&#x2F;codeinterview.io&#x2F;languages&#x2F;clojure</a></div><br/></div></div><div id="40444309" class="c"><input type="checkbox" id="c-40444309" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#40444995">prev</a><span>|</span><a href="#40445152">next</a><span>|</span><label class="collapse" for="c-40444309">[-]</label><label class="expand" for="c-40444309">[12 more]</label></div><br/><div class="children"><div class="content">Maybe online &quot;learn lisp&quot; repls should implement paredit keybindings in their editor and have a short section on how to manipulate s-expressions. Because you&#x27;re gonna have to learn it to use the language, but it also helps people understand from the start that &quot;oh, so using the language isn&#x27;t actually complete shit&quot;.<p>Instead, this fact always seems glossed over, and because of it anyone who spends 60 seconds writing lisp by hand into a repl assumes that&#x27;s the lisp experience and nopes out forever. When in fact paredit makes lisps the easiest-to-edit languages in the world.</div><br/><div id="40444915" class="c"><input type="checkbox" id="c-40444915" checked=""/><div class="controls bullet"><span class="by">writeslowly</span><span>|</span><a href="#40444309">parent</a><span>|</span><a href="#40444421">next</a><span>|</span><label class="collapse" for="c-40444915">[-]</label><label class="expand" for="c-40444915">[1 more]</label></div><br/><div class="children"><div class="content">I spent a few months writing a decent sized Clojure program just using my IDE&#x27;s matching bracket highlighting and some sort of rainbow parentheses settings, and never found it very annoying. I&#x27;m not sure there are that many more parentheses than curly-bracket languages, it&#x27;s just that all of the closing parentheses are more likely to cluster together at the end.</div><br/></div></div><div id="40444421" class="c"><input type="checkbox" id="c-40444421" checked=""/><div class="controls bullet"><span class="by">askonomm</span><span>|</span><a href="#40444309">parent</a><span>|</span><a href="#40444915">prev</a><span>|</span><a href="#40446920">next</a><span>|</span><label class="collapse" for="c-40444421">[-]</label><label class="expand" for="c-40444421">[6 more]</label></div><br/><div class="children"><div class="content">Or Parinfer. I personally like Parinfer more than Paredit, mainly because I can&#x27;t be arsed to learn a gazillion keyboard shortcuts.</div><br/><div id="40444463" class="c"><input type="checkbox" id="c-40444463" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#40444309">root</a><span>|</span><a href="#40444421">parent</a><span>|</span><a href="#40446920">next</a><span>|</span><label class="collapse" for="c-40444463">[-]</label><label class="expand" for="c-40444463">[5 more]</label></div><br/><div class="children"><div class="content">Oh, interesting. Yeah, that&#x27;s even better for an onboarding tutorial. I didn&#x27;t know it existed (used Clojure for 6 years a long time ago).<p>Cool: <a href="https:&#x2F;&#x2F;shaunlebron.github.io&#x2F;parinfer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;shaunlebron.github.io&#x2F;parinfer&#x2F;</a><p>I always thought that the surrounding tooling (having to learn how to edit parens productively, using nrepl&#x2F;cider, maybe even emacs... with evil-mode of course) to be both the worst and then eventually the best parts of Clojure.</div><br/><div id="40444517" class="c"><input type="checkbox" id="c-40444517" checked=""/><div class="controls bullet"><span class="by">askonomm</span><span>|</span><a href="#40444309">root</a><span>|</span><a href="#40444463">parent</a><span>|</span><a href="#40446920">next</a><span>|</span><label class="collapse" for="c-40444517">[-]</label><label class="expand" for="c-40444517">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m one of those mainstream devs (who also did Clojure for 6 years, coincidentally) who never got into emacs, and always just used the Cursive IDE plugin for IntelliJ and its Parinfer editing mode. I know I probably didn&#x27;t unlock true god mode of productivity, but it worked fine for me.</div><br/><div id="40444764" class="c"><input type="checkbox" id="c-40444764" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#40444309">root</a><span>|</span><a href="#40444517">parent</a><span>|</span><a href="#40451342">next</a><span>|</span><label class="collapse" for="c-40444764">[-]</label><label class="expand" for="c-40444764">[2 more]</label></div><br/><div class="children"><div class="content">I had already used vim by the time I found clojure during uni (back when I had the energy to learn major new things), but vim support sucked for things like evaluating code blocks in the buffer, so I tried emacs and immediately slapped on evil-mode (vim bindings inside emacs).<p>For those six years I don&#x27;t think I used emacs keybindings during that time except to move between files and execute clojure code. I couldn&#x27;t be arsed to learn it. It was basically a fancier vim, haha.<p>These days I use VSCode for all software. At some point in my 20s I found out there&#x27;s life outside of coding so now I use a less esoteric editor. I&#x27;m sure its clojure &#x2F; nrepl &#x2F; paredit &#x2F; parinfer support is fine. (Seems to be this: <a href="https:&#x2F;&#x2F;calva.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;calva.io&#x2F;</a>) Back in 2010 the options weren&#x27;t as great.</div><br/><div id="40447890" class="c"><input type="checkbox" id="c-40447890" checked=""/><div class="controls bullet"><span class="by">stefcoetzee</span><span>|</span><a href="#40444309">root</a><span>|</span><a href="#40444764">parent</a><span>|</span><a href="#40451342">next</a><span>|</span><label class="collapse" for="c-40447890">[-]</label><label class="expand" for="c-40447890">[1 more]</label></div><br/><div class="children"><div class="content">Yup, Calva&#x27;s pretty great.</div><br/></div></div></div></div><div id="40451342" class="c"><input type="checkbox" id="c-40451342" checked=""/><div class="controls bullet"><span class="by">simongray</span><span>|</span><a href="#40444309">root</a><span>|</span><a href="#40444517">parent</a><span>|</span><a href="#40444764">prev</a><span>|</span><a href="#40446920">next</a><span>|</span><label class="collapse" for="c-40451342">[-]</label><label class="expand" for="c-40451342">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the same, always just used parinfer with IntelliJ, though I do know a few paredit key combos that I use occasionally (paredit isn&#x27;t disabled just because parinfer is enabled).</div><br/></div></div></div></div></div></div></div></div><div id="40446920" class="c"><input type="checkbox" id="c-40446920" checked=""/><div class="controls bullet"><span class="by">silcoon</span><span>|</span><a href="#40444309">parent</a><span>|</span><a href="#40444421">prev</a><span>|</span><a href="#40446222">next</a><span>|</span><label class="collapse" for="c-40446920">[-]</label><label class="expand" for="c-40446920">[1 more]</label></div><br/><div class="children"><div class="content">TryClojure author here. Thanks for the suggestions! Iâll look into adding parinfer soon and maybe add a section on the benefits of integrating Clojure with the editor.</div><br/></div></div><div id="40446222" class="c"><input type="checkbox" id="c-40446222" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#40444309">parent</a><span>|</span><a href="#40446920">prev</a><span>|</span><a href="#40446734">next</a><span>|</span><label class="collapse" for="c-40446222">[-]</label><label class="expand" for="c-40446222">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When in fact paredit makes lisps the easiest-to-edit languages in the world<p>That is true and whenever I switch from Clojure to C, I immediately feel the pain (what do you mean I can&#x27;t just kill or lift this entire expression?).<p>But structured editing has a learning curve, so it&#x27;s a difficult balancing game. Beginners are overwhelmed by all the parentheses, while experienced programmers don&#x27;t even notice them and love the structured editing approach.</div><br/></div></div><div id="40446734" class="c"><input type="checkbox" id="c-40446734" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40444309">parent</a><span>|</span><a href="#40446222">prev</a><span>|</span><a href="#40444457">next</a><span>|</span><label class="collapse" for="c-40446734">[-]</label><label class="expand" for="c-40446734">[1 more]</label></div><br/><div class="children"><div class="content">I use Helix [0] myself, which has tree-sitter based commands for moving + selecting up&#x2F;down&#x2F;forward&#x2F;back by expressions. These are built-in and require no configuration.<p>It&#x27;s surprisingly excellent! Sure, the &quot;language&quot; of paredit features more powerful text manipulation that just simple movement... but combined with the new &quot;jumping&quot; in the latest Helix release [1], it makes for a very impressive keyboard-based navigation system.<p>[0]: <a href="https:&#x2F;&#x2F;helix-editor.com" rel="nofollow">https:&#x2F;&#x2F;helix-editor.com</a>
[1]: <a href="https:&#x2F;&#x2F;helix-editor.com&#x2F;news&#x2F;release-24-03-highlights&#x2F;" rel="nofollow">https:&#x2F;&#x2F;helix-editor.com&#x2F;news&#x2F;release-24-03-highlights&#x2F;</a></div><br/></div></div><div id="40444457" class="c"><input type="checkbox" id="c-40444457" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#40444309">parent</a><span>|</span><a href="#40446734">prev</a><span>|</span><a href="#40445152">next</a><span>|</span><label class="collapse" for="c-40444457">[-]</label><label class="expand" for="c-40444457">[1 more]</label></div><br/><div class="children"><div class="content">At the very least they should have auto-closing and matching parens. I dread to think how many people have been put off Lisp because they think we actually type all those parens (in fact Lisp users have enjoyed IDE features many programmers could only dream of for decades).</div><br/></div></div></div></div><div id="40445152" class="c"><input type="checkbox" id="c-40445152" checked=""/><div class="controls bullet"><span class="by">jollyjerry</span><span>|</span><a href="#40444309">prev</a><span>|</span><a href="#40446961">next</a><span>|</span><label class="collapse" for="c-40445152">[-]</label><label class="expand" for="c-40445152">[2 more]</label></div><br/><div class="children"><div class="content">I still remember Professor Brian Harvey rolling out his terminal on a cart in Berkeley&#x27;s CS61A and typing out commands in a scheme repl. Learning what a y-combinator was with Structure and Interpretation of Computer Programs, and building my own scheme compiler with scheme.</div><br/><div id="40451089" class="c"><input type="checkbox" id="c-40451089" checked=""/><div class="controls bullet"><span class="by">bhasi</span><span>|</span><a href="#40445152">parent</a><span>|</span><a href="#40446961">next</a><span>|</span><label class="collapse" for="c-40451089">[-]</label><label class="expand" for="c-40451089">[1 more]</label></div><br/><div class="children"><div class="content">Oh wow, I didn&#x27;t know that &quot;Y-Combinator&quot; was not just a fancy name but was an actual computer science concept. Thanks!</div><br/></div></div></div></div><div id="40446961" class="c"><input type="checkbox" id="c-40446961" checked=""/><div class="controls bullet"><span class="by">quantisan</span><span>|</span><a href="#40445152">prev</a><span>|</span><a href="#40450668">next</a><span>|</span><label class="collapse" for="c-40446961">[-]</label><label class="expand" for="c-40446961">[1 more]</label></div><br/><div class="children"><div class="content">for some stories on Clojure in production, check out <a href="https:&#x2F;&#x2F;www.juxt.pro&#x2F;clojure-in&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.juxt.pro&#x2F;clojure-in&#x2F;</a></div><br/></div></div><div id="40450668" class="c"><input type="checkbox" id="c-40450668" checked=""/><div class="controls bullet"><span class="by">mariogintili</span><span>|</span><a href="#40446961">prev</a><span>|</span><a href="#40444437">next</a><span>|</span><label class="collapse" for="c-40450668">[-]</label><label class="expand" for="c-40450668">[1 more]</label></div><br/><div class="children"><div class="content">the Scicloj stack <a href="https:&#x2F;&#x2F;scicloj.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;scicloj.github.io&#x2F;</a><p>in my opinion competes with python when it comes to DS&#x2F;ML. I find it a lot more comfortable to use if you use emacs bindings</div><br/></div></div><div id="40444437" class="c"><input type="checkbox" id="c-40444437" checked=""/><div class="controls bullet"><span class="by">drpossum</span><span>|</span><a href="#40450668">prev</a><span>|</span><a href="#40450888">next</a><span>|</span><label class="collapse" for="c-40444437">[-]</label><label class="expand" for="c-40444437">[39 more]</label></div><br/><div class="children"><div class="content">I love clojure, but it&#x27;s really lost a lot of the momentum it had as many imperative languages have adopted parts of functional programming (and much for the better) over the last many years.<p>On the other side I&#x27;ve felt a lot of the ecosystem work that was done has a more &quot;timeless&quot; quality.  Coupled with java interop I haven&#x27;t ever felt wanting when I do reach for it for some hobby projects I keep up with.<p>One thing I will say, since it takes a different tack and philosophy, I think any programmer learning some of it benefits from the different perspective.</div><br/><div id="40444736" class="c"><input type="checkbox" id="c-40444736" checked=""/><div class="controls bullet"><span class="by">d4mi3n</span><span>|</span><a href="#40444437">parent</a><span>|</span><a href="#40446018">next</a><span>|</span><label class="collapse" for="c-40444736">[-]</label><label class="expand" for="c-40444736">[19 more]</label></div><br/><div class="children"><div class="content">In my experience, the subsets of the community around clojure were one of the biggest problem with it. It&#x27;s gotten better over the years, but circa 2016 - 2018 it had a spike in popularity despite being very hostile to newcomers.<p>There was an almost apologist attitude towards rough edges or failure modes folks new to the community would fall into. I managed to work with it for a time despite that, but it left me with a bad taste in my mouth. It&#x27;s really important to make your ecosystem and communities welcome to new users or they&#x27;re destined to fade.</div><br/><div id="40444914" class="c"><input type="checkbox" id="c-40444914" checked=""/><div class="controls bullet"><span class="by">crispyambulance</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444736">parent</a><span>|</span><a href="#40444863">next</a><span>|</span><label class="collapse" for="c-40444914">[-]</label><label class="expand" for="c-40444914">[10 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; ...had a spike in popularity despite being very hostile to newcomers.
</code></pre>
To be fair the community itself, as humans, was very welcoming to newcomers. Really super nice and helpful folks.<p>If anything was &quot;hostile&quot; it was the dominance of emacs and very limited options for other tooling. That, and the horrifically unhelpful leaky abstractions in the stack trace when something went wrong. It&#x27;s a big step, if you don&#x27;t already know emacs to learn emacs (at a fairly advanced level) AND a new very different programming language.<p>I see now there&#x27;s a vscode option with Calva. I haven&#x27;t tried it. Might do that someday. Really wanted to like this language!</div><br/><div id="40446498" class="c"><input type="checkbox" id="c-40446498" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444914">parent</a><span>|</span><a href="#40446530">next</a><span>|</span><label class="collapse" for="c-40446498">[-]</label><label class="expand" for="c-40446498">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll second that the popular tooling, while powerful and reliable, its just not user friendly.<p>The official Clojure CLI, for example, is just plain confusing, and that&#x27;s most people&#x27;s first impression to the entire ecosystem. The config files, while they use the wonderful `.edn` format, are also not intuitive. Newcomers are the most likely people to encounter the most amount of error messages... which are famously difficult to read.<p>And that&#x27;s before you even get into REPL configuration, which involves coordination with your editor process, a client process, and a server process. Even if you have a tool like Calva or CIDER managing it for you, you&#x27;ll still get confused when something goes wrong unless you grok all the moving parts.<p>Even if you figure that all out, you still don&#x27;t have Parinfer or equivalents setup yet in your editor. Also, clojure-lsp tends to require some configuration to get working the way you want. And that&#x27;s before you get started with ClojureScript, which brings the complexity to another level entirely.<p>Despite all this, I love Clojure. It&#x27;s an expert&#x27;s language, even though it shouldn&#x27;t have to  be. Once you learn this stuff, you respect why much of this complexity exists. It&#x27;s inherent to the amount of power the language gives you.<p>But doesn&#x27;t mean we can&#x27;t make it easier to use and get started with.</div><br/><div id="40448706" class="c"><input type="checkbox" id="c-40448706" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446498">parent</a><span>|</span><a href="#40446530">next</a><span>|</span><label class="collapse" for="c-40448706">[-]</label><label class="expand" for="c-40448706">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The official Clojure CLI, for example, is just plain confusing, and that&#x27;s most people&#x27;s first impression to the entire ecosystem. The config files, while they use the wonderful `.edn` format, are also not intuitive.<p>I completely agree; it is unfortunate they don&#x27;t spend more time officially recommending leiningen.org. A beginner attempting to use the built-in CLI is going to lead to a poor first 3 months.</div><br/></div></div></div></div><div id="40446530" class="c"><input type="checkbox" id="c-40446530" checked=""/><div class="controls bullet"><span class="by">astrashe2</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444914">parent</a><span>|</span><a href="#40446498">prev</a><span>|</span><a href="#40445977">next</a><span>|</span><label class="collapse" for="c-40446530">[-]</label><label class="expand" for="c-40446530">[2 more]</label></div><br/><div class="children"><div class="content">This matches my experience as an amateur programmer.  The initial hill was steep, but I don&#x27;t think it was because people weren&#x27;t friendly.<p>There is one cultural thing that might be confused with unfriendliness.  Sometimes people react badly if someone posts incorrect information.  But I think that&#x27;s good.  When you search for information about Python or PHP you have to wade through quite a bit of junk.  Ironically, it&#x27;s sometimes easier to find correct answers for Clojure.<p>Clojure itself is very clean and consistent, it&#x27;s got a lot of polish to it, which makes it comparatively easy to learn.  And there isn&#x27;t that much of it.  But for a long time the tooling was hard.<p>That&#x27;s far less of a problem than it used to be.  deps.edn and shadow-cljs both made things easier, as has Cursive.  People say nice things about Calva, but I don&#x27;t know it.<p>I&#x27;m a big fan. Babashka alone is enough to make learning Clojure worthwhile.  Also, for someone like me, it&#x27;s kind of nice that it feels almost finished.  Once you learn it, you know it, and now that the tooling has settled down a bit you don&#x27;t have to keep running to keep up.</div><br/><div id="40449723" class="c"><input type="checkbox" id="c-40449723" checked=""/><div class="controls bullet"><span class="by">hluska</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446530">parent</a><span>|</span><a href="#40445977">next</a><span>|</span><label class="collapse" for="c-40449723">[-]</label><label class="expand" for="c-40449723">[1 more]</label></div><br/><div class="children"><div class="content">People posting the wrong information is a great opportunity for a community to explain why itâs wrong. We lost that take on community and itâs a major loss for our entire industry. Itâs remarkably hard for people to figure out why theyâre wrong when theyâre wrong.<p>I donât think the solution is the Usenet-esque âyou are wrong and your breeding is suspectâ way. But thereâs a very good place in the middle and Iâd really like to find that place.<p>Business wise, I think weâre using the wrong paradigm in some major places. Maybe we can beat that while Iâm still alive and that would be a net win for our whole craft.</div><br/></div></div></div></div><div id="40445977" class="c"><input type="checkbox" id="c-40445977" checked=""/><div class="controls bullet"><span class="by">yungporko</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444914">parent</a><span>|</span><a href="#40446530">prev</a><span>|</span><a href="#40445167">next</a><span>|</span><label class="collapse" for="c-40445977">[-]</label><label class="expand" for="c-40445977">[1 more]</label></div><br/><div class="children"><div class="content">the tooling is the reason i gave up when i was interested in learning clojure. everywhere pretty much said that emacs was the &quot;correct&quot; editor to use for clojure, i tried it out for a bit but ultimately learning a new language and a new editor at the same time was just too big of an ask.<p>i tried calva with vscode afterwards but it was basically the same thing, calva has paredit which overrides the keyboard navigation and there was no way to disable it. somebody had asked for the option to disable it on the github but the creator said something along the lines of calva without paredit wasn&#x27;t the way he wanted it to be used, so i just picked another language to learn.</div><br/></div></div><div id="40445167" class="c"><input type="checkbox" id="c-40445167" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444914">parent</a><span>|</span><a href="#40445977">prev</a><span>|</span><a href="#40445365">next</a><span>|</span><label class="collapse" for="c-40445167">[-]</label><label class="expand" for="c-40445167">[3 more]</label></div><br/><div class="children"><div class="content">Cursive plugin for IntelliJ is a fantastic option, it&#x27;s not free but it is excellent.</div><br/><div id="40446317" class="c"><input type="checkbox" id="c-40446317" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445167">parent</a><span>|</span><a href="#40445365">next</a><span>|</span><label class="collapse" for="c-40446317">[-]</label><label class="expand" for="c-40446317">[2 more]</label></div><br/><div class="children"><div class="content">it&#x27;s nice, but I used to write Java, and even getting IntelliJ setup on my laptop took a lot of fiddling with JVM versions and getting it to recognize my Clojure install.<p>To this day, I will still have weird issues where Cursive won&#x27;t run a project, and Emacs will.<p>All that being said, I do really like Cursive.</div><br/><div id="40450783" class="c"><input type="checkbox" id="c-40450783" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446317">parent</a><span>|</span><a href="#40445365">next</a><span>|</span><label class="collapse" for="c-40450783">[-]</label><label class="expand" for="c-40450783">[1 more]</label></div><br/><div class="children"><div class="content">I use <a href="https:&#x2F;&#x2F;sdkman.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sdkman.io&#x2F;</a> to manage JVM versions, have you tried that? I haven&#x27;t used Cursive, maybe it does something weird, but in general IntelliJ seems to accept it just fine in my everyday work.</div><br/></div></div></div></div></div></div><div id="40445365" class="c"><input type="checkbox" id="c-40445365" checked=""/><div class="controls bullet"><span class="by">ARandomerDude</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444914">parent</a><span>|</span><a href="#40445167">prev</a><span>|</span><a href="#40444863">next</a><span>|</span><label class="collapse" for="c-40445365">[-]</label><label class="expand" for="c-40445365">[1 more]</label></div><br/><div class="children"><div class="content">clojure-lsp and clj-kondo work with any editor and are both excellent.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;clojure-lsp&#x2F;clojure-lsp">https:&#x2F;&#x2F;github.com&#x2F;clojure-lsp&#x2F;clojure-lsp</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;clj-kondo&#x2F;clj-kondo">https:&#x2F;&#x2F;github.com&#x2F;clj-kondo&#x2F;clj-kondo</a><p>I&#x27;ve always used (Neo)Vim with Clojure.</div><br/></div></div></div></div><div id="40444863" class="c"><input type="checkbox" id="c-40444863" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444736">parent</a><span>|</span><a href="#40444914">prev</a><span>|</span><a href="#40444869">next</a><span>|</span><label class="collapse" for="c-40444863">[-]</label><label class="expand" for="c-40444863">[4 more]</label></div><br/><div class="children"><div class="content">A somewhat similar thing I ran into is that existing Clojure code can be <i>incredibly</i> difficult to grok if you don&#x27;t already know the language very well.<p>Some of this comes from lisp&#x27;s minimalist syntax, which makes it hard to even know what <i>kind</i> of thing you&#x27;re looking at when you&#x27;re encountering a new thing for the first time. But the problem is also compounded by some of Clojure&#x27;s more distinctive (and powerful) features such as ad-hoc polymorphism and using maps to pass function arguments.<p>The closest analogy from imperative languages that I can think of is another language that&#x27;s famous for being incredibly productive in the hands of a skilled user, but whose code tends to feel kind of write-only: Perl.</div><br/><div id="40445187" class="c"><input type="checkbox" id="c-40445187" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444863">parent</a><span>|</span><a href="#40447034">next</a><span>|</span><label class="collapse" for="c-40445187">[-]</label><label class="expand" for="c-40445187">[2 more]</label></div><br/><div class="children"><div class="content">In Perl you have the dynamism, <i>and</i> the syntax.<p>Evidently, 93% paint splatters, when OCRed, are valid Perl programs:<p><a href="https:&#x2F;&#x2F;www.mcmillen.dev&#x2F;sigbovik&#x2F;2019.pdf" rel="nofollow">https:&#x2F;&#x2F;www.mcmillen.dev&#x2F;sigbovik&#x2F;2019.pdf</a><p>I doubt that a similar thing is true for Clojure.<p>Here, the only problem is that you don&#x27;t know what the symbols and some of the notations mean. You can look at the unfamiliar syntax and know what is a child of what. Most operators are words you can search for.</div><br/></div></div><div id="40447034" class="c"><input type="checkbox" id="c-40447034" checked=""/><div class="controls bullet"><span class="by">slifin</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444863">parent</a><span>|</span><a href="#40445187">prev</a><span>|</span><a href="#40444869">next</a><span>|</span><label class="collapse" for="c-40447034">[-]</label><label class="expand" for="c-40447034">[1 more]</label></div><br/><div class="children"><div class="content">If I can get clojure storm running in my project then I find a lot of code incredibly straightforward<p>Because there&#x27;s a preference for just passing immutable data around the time travel debugger really helps me understand complex interactions</div><br/></div></div></div></div><div id="40444869" class="c"><input type="checkbox" id="c-40444869" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444736">parent</a><span>|</span><a href="#40444863">prev</a><span>|</span><a href="#40446635">next</a><span>|</span><label class="collapse" for="c-40444869">[-]</label><label class="expand" for="c-40444869">[3 more]</label></div><br/><div class="children"><div class="content">YMMV. I always found it very welcoming and full of interesting people.</div><br/><div id="40445354" class="c"><input type="checkbox" id="c-40445354" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444869">parent</a><span>|</span><a href="#40446635">next</a><span>|</span><label class="collapse" for="c-40445354">[-]</label><label class="expand" for="c-40445354">[2 more]</label></div><br/><div class="children"><div class="content">I may be wrong, but I think the parent poster was talking more about the language and ecosystem than the community. I, too, have found the community to be amazing. But the language itself used to be quite frustrating to learn. It&#x27;s better now, but I think that by the time it got fixed many companies and teams had already been burned.<p>Clojure is particularly vulnerable to that because it really is an enterprise applications language. That makes it more vulnerable to learning curve problems than a language like Rust whose most direct competitors are other languages with comparably steep learning curves.</div><br/><div id="40451122" class="c"><input type="checkbox" id="c-40451122" checked=""/><div class="controls bullet"><span class="by">kimi</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445354">parent</a><span>|</span><a href="#40446635">next</a><span>|</span><label class="collapse" for="c-40451122">[-]</label><label class="expand" for="c-40451122">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I agree with you, learning is complicated, because it&#x27;s mostly un-learning habits you had for 20+ years. Stack traces suck, but after a while you grok them. The clojure&#x2F;core is full of niceties, but it&#x27;s so big you need a map just to know what&#x27;s in there. And still...</div><br/></div></div></div></div></div></div><div id="40446635" class="c"><input type="checkbox" id="c-40446635" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40444736">parent</a><span>|</span><a href="#40444869">prev</a><span>|</span><a href="#40446018">next</a><span>|</span><label class="collapse" for="c-40446635">[-]</label><label class="expand" for="c-40446635">[1 more]</label></div><br/><div class="children"><div class="content">That is basically every functional programming language in existence.</div><br/></div></div></div></div><div id="40446018" class="c"><input type="checkbox" id="c-40446018" checked=""/><div class="controls bullet"><span class="by">elamje</span><span>|</span><a href="#40444437">parent</a><span>|</span><a href="#40444736">prev</a><span>|</span><a href="#40445195">next</a><span>|</span><label class="collapse" for="c-40446018">[-]</label><label class="expand" for="c-40446018">[3 more]</label></div><br/><div class="children"><div class="content">Should have maintained a python interoperable runtime. Less and less people use JVM languages for things like web apps, data eng, data science, ML, etc.</div><br/><div id="40447277" class="c"><input type="checkbox" id="c-40447277" checked=""/><div class="controls bullet"><span class="by">puredanger</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446018">parent</a><span>|</span><a href="#40446597">next</a><span>|</span><label class="collapse" for="c-40447277">[-]</label><label class="expand" for="c-40447277">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;clj-python&#x2F;libpython-clj">https:&#x2F;&#x2F;github.com&#x2F;clj-python&#x2F;libpython-clj</a> has deep support for leveraging the Python ecosystem and it works great.</div><br/></div></div><div id="40446597" class="c"><input type="checkbox" id="c-40446597" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446018">parent</a><span>|</span><a href="#40447277">prev</a><span>|</span><a href="#40445195">next</a><span>|</span><label class="collapse" for="c-40446597">[-]</label><label class="expand" for="c-40446597">[1 more]</label></div><br/><div class="children"><div class="content">Give <a href="https:&#x2F;&#x2F;github.com&#x2F;basilisp-lang&#x2F;basilisp">https:&#x2F;&#x2F;github.com&#x2F;basilisp-lang&#x2F;basilisp</a> a try</div><br/></div></div></div></div><div id="40445195" class="c"><input type="checkbox" id="c-40445195" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#40444437">parent</a><span>|</span><a href="#40446018">prev</a><span>|</span><a href="#40450888">next</a><span>|</span><label class="collapse" for="c-40445195">[-]</label><label class="expand" for="c-40445195">[16 more]</label></div><br/><div class="children"><div class="content">&gt; many imperative languages have adopted parts of functional programming<p>nailed it. I don&#x27;t know much about functional languages other than a haskell course back in the day, but I don&#x27;t want to do functional all the time. It plays great in some situations and I am happy to use those language subsets in my daily coding, but I don&#x27;t need my entire application to be written in an esoteric language</div><br/><div id="40445371" class="c"><input type="checkbox" id="c-40445371" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445195">parent</a><span>|</span><a href="#40450888">next</a><span>|</span><label class="collapse" for="c-40445371">[-]</label><label class="expand" for="c-40445371">[15 more]</label></div><br/><div class="children"><div class="content">This is of course a popular opinion and pretty much the C++ philosophy. Unfortunately a lot of the benefits of functional programming cannot be fully realised unless you are &quot;all in&quot;. The paper &quot;The Curse of the Excluded Middle&quot; is somewhat blunt but it makes some good points: <a href="https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=2611829" rel="nofollow">https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=2611829</a></div><br/><div id="40445831" class="c"><input type="checkbox" id="c-40445831" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445371">parent</a><span>|</span><a href="#40446675">next</a><span>|</span><label class="collapse" for="c-40445831">[-]</label><label class="expand" for="c-40445831">[12 more]</label></div><br/><div class="children"><div class="content">Programming without immutability is so painful to me, no matter how many functional features a language adds.</div><br/><div id="40446494" class="c"><input type="checkbox" id="c-40446494" checked=""/><div class="controls bullet"><span class="by">throwaway96666</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445831">parent</a><span>|</span><a href="#40446211">next</a><span>|</span><label class="collapse" for="c-40446494">[-]</label><label class="expand" for="c-40446494">[5 more]</label></div><br/><div class="children"><div class="content">In my experience jumping from a Clojure shop to a large Java shop a few years ago, the benefits of persistent data structures are overstated. Mutable collections are just as good for 99% of use cases. And they&#x27;re a lot faster (in single threaded code) and occasionally mutation makes things easier.<p>The selling point of Clojure is that persistent data structures prevent several classes of bugs (unintended mutation, locking, etc.). But in reality -- as long as your team members are good enough programmers -- I don&#x27;t see these kind of bugs happen in practice.<p>That being said I love Clojure and the standard library is the best out of any language. It is a great choice in the small market of &quot;projects that need simple and correct code&quot;.</div><br/><div id="40447099" class="c"><input type="checkbox" id="c-40447099" checked=""/><div class="controls bullet"><span class="by">slifin</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446494">parent</a><span>|</span><a href="#40446773">next</a><span>|</span><label class="collapse" for="c-40447099">[-]</label><label class="expand" for="c-40447099">[2 more]</label></div><br/><div class="children"><div class="content">Looking at an object in my debugger back in my call stack and assume I&#x27;m looking at the value as it was but in reality it was mutated in a subsequent stack gives me trust issues<p>It&#x27;s probably fine most of the time it&#x27;s just when I have to get into the weeds I want to have stability</div><br/><div id="40447958" class="c"><input type="checkbox" id="c-40447958" checked=""/><div class="controls bullet"><span class="by">throwaway96666</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40447099">parent</a><span>|</span><a href="#40446773">next</a><span>|</span><label class="collapse" for="c-40447958">[-]</label><label class="expand" for="c-40447958">[1 more]</label></div><br/><div class="children"><div class="content">That seems like a debugger problem, can&#x27;t the debugger clone&#x2F;maintain history of the object?</div><br/></div></div></div></div><div id="40446773" class="c"><input type="checkbox" id="c-40446773" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446494">parent</a><span>|</span><a href="#40447099">prev</a><span>|</span><a href="#40450319">next</a><span>|</span><label class="collapse" for="c-40446773">[-]</label><label class="expand" for="c-40446773">[1 more]</label></div><br/><div class="children"><div class="content">This is like saying &quot;the benefits of functional programming are overstated&quot;. If you are happy with mutable collections, you&#x27;ve happy with mutable variables, pervasive side effects and essentially the status quo. Many of us are not happy with the level of software quality out there and the status quo, Rich Hickey included.</div><br/></div></div><div id="40450319" class="c"><input type="checkbox" id="c-40450319" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446494">parent</a><span>|</span><a href="#40446773">prev</a><span>|</span><a href="#40446211">next</a><span>|</span><label class="collapse" for="c-40450319">[-]</label><label class="expand" for="c-40450319">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the benefits of persistent data structures are overstated.<p>Well, what else is overstated?<p>- Structural editing? Fine.<p>- REPL-driven development? Okay, let&#x27;s throw that out the window.<p>- Hosted nature and the interop? Gone.<p>- Destructuring? Eh, we kinda have it in Javascript, right?<p>- Concurrency support? Who needs that shit, anyway, right?<p>- Simplicity and elegance? Arguable. Some like verbose Typescript code more.<p>- Functional programming? What the heck is it even?<p>The point I&#x27;m trying to make is that you can&#x27;t just &quot;remove&quot; an essential part of what makes a language. Rich Hickey took a year-long sabbatical (or was it two or even three years? I forgot) and used his savings to get this aspect of the language right. Without the immutable collections, the language would&#x27;ve been an entirely different beast.</div><br/></div></div></div></div><div id="40446211" class="c"><input type="checkbox" id="c-40446211" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445831">parent</a><span>|</span><a href="#40446494">prev</a><span>|</span><a href="#40446675">next</a><span>|</span><label class="collapse" for="c-40446211">[-]</label><label class="expand" for="c-40446211">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s painful for the compiler too, it has to turn the parents imperative code into SSA (essentially A-normal form) so it can optimise it!</div><br/><div id="40446719" class="c"><input type="checkbox" id="c-40446719" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446211">parent</a><span>|</span><a href="#40446675">next</a><span>|</span><label class="collapse" for="c-40446719">[-]</label><label class="expand" for="c-40446719">[5 more]</label></div><br/><div class="children"><div class="content">You guys can make all the baloney claims about this you want.<p>The day that Haskell stops being 10x slower than languages providing mutable data is the day we can start to seriously entertain your claims.</div><br/><div id="40449317" class="c"><input type="checkbox" id="c-40449317" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446719">parent</a><span>|</span><a href="#40446810">next</a><span>|</span><label class="collapse" for="c-40449317">[-]</label><label class="expand" for="c-40449317">[1 more]</label></div><br/><div class="children"><div class="content">I think the persistent collections are generally worth the cost. IIRC, for HAMT maps&#x2F;sets for instance, they&#x27;re about twice as slow for reads and four times as slow for writes. For bulk updates, you can also slip into using transients, and then when you&#x27;re done, &quot;freeze&quot; it back into a persistent data structure.<p>I only wish that the transient collections would support more different kinds of writes, like support all operations on java.util.List&#x2F;Set&#x2F;Map kind of thing. Forget which ones aren&#x27;t present but I remember there being a couple...</div><br/></div></div><div id="40446810" class="c"><input type="checkbox" id="c-40446810" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446719">parent</a><span>|</span><a href="#40449317">prev</a><span>|</span><a href="#40446675">next</a><span>|</span><label class="collapse" for="c-40446810">[-]</label><label class="expand" for="c-40446810">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing baloney about SSA form. I&#x27;m sorry to say it, but C is just not close to the metal any more. Even if you are able to hand optimise something so it works well on one architecture, it likely won&#x27;t be optimal for another.<p>As for Haskell, it does pretty well being 100 times faster than Python with 100 times less the number of people working on it.</div><br/><div id="40447548" class="c"><input type="checkbox" id="c-40447548" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446810">parent</a><span>|</span><a href="#40446675">next</a><span>|</span><label class="collapse" for="c-40447548">[-]</label><label class="expand" for="c-40447548">[2 more]</label></div><br/><div class="children"><div class="content">I believe that your interpretation of whatâs actually happening is whatâs baloney.<p>The fact is that you Haskell people only talk about the optimizations that can sometimes open on immutable data in specific circumstances. What you generally ignore is the optimizations that immutable data permanently locks you out of with no recourse.<p>As with most things programming, immutability should be considered a tool, not a rule.</div><br/><div id="40450767" class="c"><input type="checkbox" id="c-40450767" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40447548">parent</a><span>|</span><a href="#40446675">next</a><span>|</span><label class="collapse" for="c-40450767">[-]</label><label class="expand" for="c-40450767">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I believe that your interpretation of whatâs actually happening is whatâs baloney.<p>I&#x27;m actually quoting Prof Andrew Appel of Princeton: 
<a href="https:&#x2F;&#x2F;www.cs.princeton.edu&#x2F;~appel&#x2F;papers&#x2F;ssafun.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.princeton.edu&#x2F;~appel&#x2F;papers&#x2F;ssafun.pdf</a><p>You seem to think that functional programming and in-place updates are mutually exclusive. This is not the case, e.g. Haskell supports mutation as a tracked and controlled side-effect. It can even give static guarantees that a function is pure even it uses mutation internally.
Recent research even suggests that compilers can add the in-place updates for us: <a href="https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;publication&#x2F;fp2-fully-in-place-functional-programming&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;publication&#x2F;fp2-ful...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40446675" class="c"><input type="checkbox" id="c-40446675" checked=""/><div class="controls bullet"><span class="by">wredue</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40445371">parent</a><span>|</span><a href="#40445831">prev</a><span>|</span><a href="#40450888">next</a><span>|</span><label class="collapse" for="c-40446675">[-]</label><label class="expand" for="c-40446675">[2 more]</label></div><br/><div class="children"><div class="content">&gt;a lot of the benefits cannot be fully realized unless youâre all in<p>That is working under the assumption that âthe benefitsâ are actual benefits.<p>IMO, âthe benefitsâ are measurably drawbacks, and not a technical debt I am willing to accept for no good reason.</div><br/><div id="40447042" class="c"><input type="checkbox" id="c-40447042" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40444437">root</a><span>|</span><a href="#40446675">parent</a><span>|</span><a href="#40450888">next</a><span>|</span><label class="collapse" for="c-40447042">[-]</label><label class="expand" for="c-40447042">[1 more]</label></div><br/><div class="children"><div class="content">Functional programming is basically maths, it solves the problem of how to compose software safely. I struggle to understand why anyone who really cares about their craft would not want this. In fact, many want it so badly they are willing to make sacrifices for it (performance, esoteric languages).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40450888" class="c"><input type="checkbox" id="c-40450888" checked=""/><div class="controls bullet"><span class="by">createaccount99</span><span>|</span><a href="#40444437">prev</a><span>|</span><a href="#40447028">next</a><span>|</span><label class="collapse" for="c-40450888">[-]</label><label class="expand" for="c-40450888">[7 more]</label></div><br/><div class="children"><div class="content">The problem I see with clojure, isn&#x27;t it missing autocompletes? You work with JVM&#x2F;typescript libraries, but your editor isn&#x27;t smart enough to pull types from those into clojure. That slows you down tremendously.</div><br/><div id="40451377" class="c"><input type="checkbox" id="c-40451377" checked=""/><div class="controls bullet"><span class="by">cospaia</span><span>|</span><a href="#40450888">parent</a><span>|</span><a href="#40451311">next</a><span>|</span><label class="collapse" for="c-40451377">[-]</label><label class="expand" for="c-40451377">[1 more]</label></div><br/><div class="children"><div class="content">As a Clojure editor tool smith it pains me that this is the case. Especially for ClojureScript where I spend most of my time. I really want to fix this.<p>For JVM interop, I think Cursive (IntelliJ Clojure plugin) is smart enough to help with autocompleting Java libraries.</div><br/></div></div><div id="40451311" class="c"><input type="checkbox" id="c-40451311" checked=""/><div class="controls bullet"><span class="by">ziftface</span><span>|</span><a href="#40450888">parent</a><span>|</span><a href="#40451377">prev</a><span>|</span><a href="#40451065">next</a><span>|</span><label class="collapse" for="c-40451311">[-]</label><label class="expand" for="c-40451311">[1 more]</label></div><br/><div class="children"><div class="content">Autocomplete works for me with jvm imports</div><br/></div></div><div id="40451065" class="c"><input type="checkbox" id="c-40451065" checked=""/><div class="controls bullet"><span class="by">FredrikMeyer</span><span>|</span><a href="#40450888">parent</a><span>|</span><a href="#40451311">prev</a><span>|</span><a href="#40451005">next</a><span>|</span><label class="collapse" for="c-40451065">[-]</label><label class="expand" for="c-40451065">[1 more]</label></div><br/><div class="children"><div class="content">I use Emacs with Cider+clojure-lsp, and the autocomplete&#x2F;refactoring tools are super good.</div><br/></div></div><div id="40451005" class="c"><input type="checkbox" id="c-40451005" checked=""/><div class="controls bullet"><span class="by">ilikehurdles</span><span>|</span><a href="#40450888">parent</a><span>|</span><a href="#40451065">prev</a><span>|</span><a href="#40447028">next</a><span>|</span><label class="collapse" for="c-40451005">[-]</label><label class="expand" for="c-40451005">[3 more]</label></div><br/><div class="children"><div class="content">No. When working with JVM&#x2F;typescript libraries you have their autocomplete information.<p>If you need method autocomplete scoped to a type you can use the `..` macro for more concise call syntax:<p><pre><code>    (ns my-project.core
      (:import (java.util ArrayList Collections)))

    (defn example []
      (let [list (ArrayList.)]    ; ArrayList constructor can be autocompleted
        (.. list
            (add &quot;Hello&quot;)         ; The .add method on ArrayLists will be autocompleted
            (add &quot;World&quot;)
            (add &quot;Clojure&quot;))
        (Collections&#x2F;sort list)   ; The Collections.sort method will be autocompleted
        list))

</code></pre>
this other form will a also autocomplete everything after the dot (.) to call a method on an object:<p><pre><code>    (.toUpperCase some-str)
</code></pre>
but the trick with this arrangement is to write that variable some-str first, then if you write . in front of it the autocompletes will be relevant to that object. But I gratuitously used threading macros like .. or -&gt; to make it match java-style code (in other words: (-&gt; some-str (.toUpperCase))).</div><br/><div id="40451133" class="c"><input type="checkbox" id="c-40451133" checked=""/><div class="controls bullet"><span class="by">createaccount99</span><span>|</span><a href="#40450888">root</a><span>|</span><a href="#40451005">parent</a><span>|</span><a href="#40447028">next</a><span>|</span><label class="collapse" for="c-40451133">[-]</label><label class="expand" for="c-40451133">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s cool, I had no idea. In clojure itself I suppose you eval code and then get autocompeletes from the repl output? -- I mean for stuff with no types</div><br/><div id="40451330" class="c"><input type="checkbox" id="c-40451330" checked=""/><div class="controls bullet"><span class="by">simongray</span><span>|</span><a href="#40450888">root</a><span>|</span><a href="#40451133">parent</a><span>|</span><a href="#40447028">next</a><span>|</span><label class="collapse" for="c-40451330">[-]</label><label class="expand" for="c-40451330">[1 more]</label></div><br/><div class="children"><div class="content">Autocomplete also works for the functions and vars in the namespaces. You don&#x27;t really use methods in Clojure unless you&#x27;re doing interop with Java or JS.</div><br/></div></div></div></div></div></div></div></div><div id="40447028" class="c"><input type="checkbox" id="c-40447028" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#40450888">prev</a><span>|</span><a href="#40446158">next</a><span>|</span><label class="collapse" for="c-40447028">[-]</label><label class="expand" for="c-40447028">[5 more]</label></div><br/><div class="children"><div class="content">So here&#x27;s something which I, as a Lisper, don&#x27;t understand: Clojure has syntax for hash tables (the curly braces), why doesn&#x27;t it use those for let-bindings, instead choosing to use vector syntax? (Of course I prefer standard Lisp syntax which can easily be extended for multiple-value and destructuring bindings:<p><pre><code>  (let ((a 1)
        ((b c) (list 2 3))
        (d e (values 4 5)))
    `#(,a ,b ,c ,d ,e))
  ;; =&gt; #(1 2 3 4 5)</code></pre></div><br/><div id="40447077" class="c"><input type="checkbox" id="c-40447077" checked=""/><div class="controls bullet"><span class="by">puredanger</span><span>|</span><a href="#40447028">parent</a><span>|</span><a href="#40450639">next</a><span>|</span><label class="collapse" for="c-40447077">[-]</label><label class="expand" for="c-40447077">[2 more]</label></div><br/><div class="children"><div class="content">Maps are unordered, but let bindings are sequential so order matters.</div><br/><div id="40447843" class="c"><input type="checkbox" id="c-40447843" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#40447028">root</a><span>|</span><a href="#40447077">parent</a><span>|</span><a href="#40450639">next</a><span>|</span><label class="collapse" for="c-40447843">[-]</label><label class="expand" for="c-40447843">[1 more]</label></div><br/><div class="children"><div class="content">And also, a variable can be rebound in later bindings!</div><br/></div></div></div></div><div id="40450639" class="c"><input type="checkbox" id="c-40450639" checked=""/><div class="controls bullet"><span class="by">didibus</span><span>|</span><a href="#40447028">parent</a><span>|</span><a href="#40447077">prev</a><span>|</span><a href="#40447180">next</a><span>|</span><label class="collapse" for="c-40450639">[-]</label><label class="expand" for="c-40450639">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s so different to Clojure&#x27;s ?<p><pre><code>    (let [a 1
          [b c] (list 2 3)
          [d e] [4 5]]
      `(~a ~b ~c ~d ~e))
    ;; =&gt; (1 2 3 4 5)</code></pre></div><br/></div></div><div id="40447180" class="c"><input type="checkbox" id="c-40447180" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40447028">parent</a><span>|</span><a href="#40450639">prev</a><span>|</span><a href="#40446158">next</a><span>|</span><label class="collapse" for="c-40447180">[-]</label><label class="expand" for="c-40447180">[1 more]</label></div><br/><div class="children"><div class="content">Clojure has some very expressive destructuring syntax as well:
<a href="https:&#x2F;&#x2F;clojure.org&#x2F;guides&#x2F;destructuring" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;guides&#x2F;destructuring</a></div><br/></div></div></div></div><div id="40446158" class="c"><input type="checkbox" id="c-40446158" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40447028">prev</a><span>|</span><a href="#40444963">next</a><span>|</span><label class="collapse" for="c-40446158">[-]</label><label class="expand" for="c-40446158">[16 more]</label></div><br/><div class="children"><div class="content">Clojure looks productive. What frameworks libraries do people use to build web apps? Like, replacement for Django view layer and ORM (not looking to debate orms thanks)?</div><br/><div id="40446593" class="c"><input type="checkbox" id="c-40446593" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40446158">parent</a><span>|</span><a href="#40446517">next</a><span>|</span><label class="collapse" for="c-40446593">[-]</label><label class="expand" for="c-40446593">[11 more]</label></div><br/><div class="children"><div class="content">This is a good starting point if you want to get a web app going quickly:
<a href="https:&#x2F;&#x2F;biffweb.com" rel="nofollow">https:&#x2F;&#x2F;biffweb.com</a><p>It uses XTDB by default but you can switch to Postgres:
<a href="https:&#x2F;&#x2F;biffweb.com&#x2F;p&#x2F;how-to-use-postgres-with-biff&#x2F;" rel="nofollow">https:&#x2F;&#x2F;biffweb.com&#x2F;p&#x2F;how-to-use-postgres-with-biff&#x2F;</a><p>People don&#x27;t really use ORMs in Clojure, they just write SQL directly and abstract the details from consumers using functions. That said, HoneySQL is a common alternative to writing SQL that makes it a lot less painful (and composable!):
<a href="https:&#x2F;&#x2F;github.com&#x2F;seancorfield&#x2F;honeysql">https:&#x2F;&#x2F;github.com&#x2F;seancorfield&#x2F;honeysql</a></div><br/><div id="40446668" class="c"><input type="checkbox" id="c-40446668" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40446593">parent</a><span>|</span><a href="#40446930">next</a><span>|</span><label class="collapse" for="c-40446668">[-]</label><label class="expand" for="c-40446668">[1 more]</label></div><br/><div class="children"><div class="content">HoneySQL is so, so good. It does for SQL what Hiccup did for HTML. Once you start writing with those, it&#x27;s hard to remember there&#x27;s any other way.</div><br/></div></div><div id="40446930" class="c"><input type="checkbox" id="c-40446930" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40446593">parent</a><span>|</span><a href="#40446668">prev</a><span>|</span><a href="#40446517">next</a><span>|</span><label class="collapse" for="c-40446930">[-]</label><label class="expand" for="c-40446930">[9 more]</label></div><br/><div class="children"><div class="content">Biff looks neat, thanks! I mainly just don&#x27;t want to write raw sql&#x2F;mappers to structures for simple queries. Looks like most sql libraries with clojure can just return maps so that&#x27;s neat.</div><br/><div id="40447317" class="c"><input type="checkbox" id="c-40447317" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40446930">parent</a><span>|</span><a href="#40450661">next</a><span>|</span><label class="collapse" for="c-40447317">[-]</label><label class="expand" for="c-40447317">[6 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a quick example of how DB access generally looks in production:<p><pre><code>    (ns rads.sql-example
      (:require [next.jdbc :as jdbc]
                [honey.sql :as sql]
                [clojure.string :as str]))

    ;; DB Table: posts
    ;; +----+-------+
    ;; | id | title |
    ;; +----+-------+
    ;; |  1 | hello |
    ;; +----+-------+

    (def ds (jdbc&#x2F;get-datasource (System&#x2F;getenv &quot;DATABASE_URL&quot;)))

    (defn row-&gt;post [row]
      ;; This is your optional mapping layer (a plain function that takes a map).
      ;; You can hide DB details here.
      (update row :title str&#x2F;capitalize))

    (defn get-posts [ds]
      ;; Write a SQL query using Clojure data structures.
      (let [query {:select [:*] :from [:posts]}]
        ;; Run the query.
        (-&gt;&gt; (jdbc&#x2F;execute! ds (sql&#x2F;format query))
             ;; Convert each raw DB map to a &quot;post&quot; map
             (map row-&gt;post))))

    (println (get-posts ds))
    ;; =&gt; [{:id 1, :title &quot;Hello&quot;}]</code></pre></div><br/><div id="40447330" class="c"><input type="checkbox" id="c-40447330" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40447317">parent</a><span>|</span><a href="#40450661">next</a><span>|</span><label class="collapse" for="c-40447330">[-]</label><label class="expand" for="c-40447330">[5 more]</label></div><br/><div class="children"><div class="content">You would abstract away the jdbc&#x2F;execute part though, right? otherwise that&#x27;s terribly unproductive compared to django etc.</div><br/><div id="40447352" class="c"><input type="checkbox" id="c-40447352" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40447330">parent</a><span>|</span><a href="#40450661">next</a><span>|</span><label class="collapse" for="c-40447352">[-]</label><label class="expand" for="c-40447352">[4 more]</label></div><br/><div class="children"><div class="content">In practice I do wrap `jdbc&#x2F;execute!` with my own `execute!` function to set some default options. However, there is no ORM layer. What makes you think the code above is terribly unproductive?<p>Edit: Not trying to dismiss your concerns, by the way. In Clojure you can often get away with doing less than you might think so I&#x27;m genuinely curious about the critique.</div><br/><div id="40448072" class="c"><input type="checkbox" id="c-40448072" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40447352">parent</a><span>|</span><a href="#40450661">next</a><span>|</span><label class="collapse" for="c-40448072">[-]</label><label class="expand" for="c-40448072">[3 more]</label></div><br/><div class="children"><div class="content">In Django I would just do Posts.objects.filter(title=x)<p>I don&#x27;t need to define driver boilerplate for every query (or ever have to write it... at all).</div><br/><div id="40451824" class="c"><input type="checkbox" id="c-40451824" checked=""/><div class="controls bullet"><span class="by">didibus</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40448072">parent</a><span>|</span><a href="#40450769">next</a><span>|</span><label class="collapse" for="c-40451824">[-]</label><label class="expand" for="c-40451824">[1 more]</label></div><br/><div class="children"><div class="content">In Clojure you&#x27;ll have to write the queries yourself unfortunately. People always ask, where is the fully fledged web framework in Clojure? There isn&#x27;t one. Why there isn&#x27;t one is hard to answer, but it&#x27;s partially because the people who could write one, don&#x27;t find they need one themselves.<p>There&#x27;s definitely a preference in Clojure for not relying on frameworks, because the current people in the community like to be in control, know what&#x27;s going on, or do it their own way.<p>That said, the whole code still ends up being relatively small. So, you kind of end up with a similar amount of total code, but you&#x27;re much more in control. And if certain things you find too repetitive, you can remove the repetition yourself through many of Clojure&#x27;s facilities, specifically where they annoyed you.<p>See: <a href="https:&#x2F;&#x2F;github.com&#x2F;didibus&#x2F;simple-website-with-posts">https:&#x2F;&#x2F;github.com&#x2F;didibus&#x2F;simple-website-with-posts</a> where I implemented the small website you were talking about, creating posts and seeing them. The whole code is here (minus the CSS): <a href="https:&#x2F;&#x2F;github.com&#x2F;didibus&#x2F;simple-website-with-posts&#x2F;blob&#x2F;main&#x2F;src&#x2F;com&#x2F;github&#x2F;didibus&#x2F;simple_website_with_posts.clj">https:&#x2F;&#x2F;github.com&#x2F;didibus&#x2F;simple-website-with-posts&#x2F;blob&#x2F;ma...</a><p>It&#x27;s 95 loc and that includes the templates. There&#x27;s no framework.</div><br/></div></div><div id="40450769" class="c"><input type="checkbox" id="c-40450769" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40448072">parent</a><span>|</span><a href="#40451824">prev</a><span>|</span><a href="#40450661">next</a><span>|</span><label class="collapse" for="c-40450769">[-]</label><label class="expand" for="c-40450769">[1 more]</label></div><br/><div class="children"><div class="content">The key thing is experienced Clojure programmers often see a lack of ORM as a feature rather than an oversight. There were some more ORM-like libraries years ago (see Korma) but my impression is that people ultimately didn&#x27;t want this and moved on to lower-level JDBC wrappers combined with HoneySQL. I found a more detailed discussion on Reddit about Clojure and ORMs back in 2020 if you want to get more info: <a href="https:&#x2F;&#x2F;reddit.com&#x2F;r&#x2F;Clojure&#x2F;comments&#x2F;g7qyoy&#x2F;why_does_orm_have_omg_complexity&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reddit.com&#x2F;r&#x2F;Clojure&#x2F;comments&#x2F;g7qyoy&#x2F;why_does_orm_ha...</a><p>Note that I&#x27;m not making a value judgement about Python&#x2F;Django or any other library&#x2F;framework combination. It&#x27;s obviously a valid path, but Clojure is a different path. I can assure you there are straightforward solutions to create readable APIs like the Django example with minimal boilerplate, but the approach is fundamentally different from Python&#x2F;Django.<p>If you do decide to build something in Clojure and think, &quot;I already know how to do this in Django, why is it missing?&quot;, don&#x27;t hesitate to join the Clojurians Slack and hop into the #beginners channel. There are plenty of people who can help you there.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40450661" class="c"><input type="checkbox" id="c-40450661" checked=""/><div class="controls bullet"><span class="by">didibus</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40446930">parent</a><span>|</span><a href="#40447317">prev</a><span>|</span><a href="#40450660">next</a><span>|</span><label class="collapse" for="c-40450661">[-]</label><label class="expand" for="c-40450661">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no object in Clojure, so there&#x27;s no need for an Object Relational Mapper. You just work directly of the query result sets, which the SQL library itself can conveniently turn into rows of maps if you prefer (over rows of lists).</div><br/></div></div></div></div></div></div><div id="40446517" class="c"><input type="checkbox" id="c-40446517" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#40446158">parent</a><span>|</span><a href="#40446593">prev</a><span>|</span><a href="#40446580">next</a><span>|</span><label class="collapse" for="c-40446517">[-]</label><label class="expand" for="c-40446517">[1 more]</label></div><br/><div class="children"><div class="content">There is not a batteries included framework a-la Django or Rails for Clojure. I would argue that is one of the biggest pitfalls to the language&#x2F;ecosystem. If you are building a web application, you will need to invent the entire thing yourself. There are micro frameworks and tools that exist standalone to deal with HTTP, DB ORM, etc... but that will be an exercise left to the reader.<p>Some will say this is a good thing (and as a very experienced engineer I will agree) but the barrier to entry for a newbie is quite high in this regard. You have all the rope to hang yourself with - and you will. Especially if you are on a team full of lots of interns and junior folks.</div><br/></div></div><div id="40446580" class="c"><input type="checkbox" id="c-40446580" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40446158">parent</a><span>|</span><a href="#40446517">prev</a><span>|</span><a href="#40446751">next</a><span>|</span><label class="collapse" for="c-40446580">[-]</label><label class="expand" for="c-40446580">[1 more]</label></div><br/><div class="children"><div class="content">Check out Biff, it&#x27;s very thoughtfully made: <a href="https:&#x2F;&#x2F;biffweb.com" rel="nofollow">https:&#x2F;&#x2F;biffweb.com</a></div><br/></div></div><div id="40446751" class="c"><input type="checkbox" id="c-40446751" checked=""/><div class="controls bullet"><span class="by">robto</span><span>|</span><a href="#40446158">parent</a><span>|</span><a href="#40446580">prev</a><span>|</span><a href="#40444963">next</a><span>|</span><label class="collapse" for="c-40446751">[-]</label><label class="expand" for="c-40446751">[2 more]</label></div><br/><div class="children"><div class="content">This is my goto:<p>webserver: ring-jetty9-adapter[0]<p>routing: reitit[1]<p>html templates: hiccup[2]<p>never used an ORM, but happily used HugSQL for making composable queries[3].<p>[0]<a href="https:&#x2F;&#x2F;github.com&#x2F;sunng87&#x2F;ring-jetty9-adapter">https:&#x2F;&#x2F;github.com&#x2F;sunng87&#x2F;ring-jetty9-adapter</a>
[1]<a href="https:&#x2F;&#x2F;github.com&#x2F;metosin&#x2F;reitit">https:&#x2F;&#x2F;github.com&#x2F;metosin&#x2F;reitit</a>
[2]<a href="https:&#x2F;&#x2F;github.com&#x2F;weavejester&#x2F;hiccup">https:&#x2F;&#x2F;github.com&#x2F;weavejester&#x2F;hiccup</a>
[3]<a href="https:&#x2F;&#x2F;www.hugsql.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hugsql.org&#x2F;</a></div><br/><div id="40448098" class="c"><input type="checkbox" id="c-40448098" checked=""/><div class="controls bullet"><span class="by">winrid</span><span>|</span><a href="#40446158">root</a><span>|</span><a href="#40446751">parent</a><span>|</span><a href="#40444963">next</a><span>|</span><label class="collapse" for="c-40448098">[-]</label><label class="expand" for="c-40448098">[1 more]</label></div><br/><div class="children"><div class="content">Those all look great, including HugSQL, thanks!</div><br/></div></div></div></div></div></div><div id="40444963" class="c"><input type="checkbox" id="c-40444963" checked=""/><div class="controls bullet"><span class="by">makach</span><span>|</span><a href="#40446158">prev</a><span>|</span><a href="#40444990">next</a><span>|</span><label class="collapse" for="c-40444963">[-]</label><label class="expand" for="c-40444963">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a great introduction, but... how to do an if statement would&#x27;ve been cool to add in the tutorial.</div><br/><div id="40445161" class="c"><input type="checkbox" id="c-40445161" checked=""/><div class="controls bullet"><span class="by">613style</span><span>|</span><a href="#40444963">parent</a><span>|</span><a href="#40445648">prev</a><span>|</span><a href="#40444990">next</a><span>|</span><label class="collapse" for="c-40445161">[-]</label><label class="expand" for="c-40445161">[1 more]</label></div><br/><div class="children"><div class="content">What is this &quot;statement&quot; you speak of?<p>(if (= 2 2) :OK :nope)</div><br/></div></div></div></div><div id="40444990" class="c"><input type="checkbox" id="c-40444990" checked=""/><div class="controls bullet"><span class="by">masspro</span><span>|</span><a href="#40444963">prev</a><span>|</span><a href="#40446277">next</a><span>|</span><label class="collapse" for="c-40444990">[-]</label><label class="expand" for="c-40444990">[5 more]</label></div><br/><div class="children"><div class="content">&lt;hot-take type=&quot;anecdata&quot;&gt; My Clojure experience was that basic dev experience things were shockingly behind where any other moderately popular lang is at. It&#x27;s been some time though so all I remember clearly is bad error output. Stack traces are hard to read unless you install $random_lib. But worse than stack traces are type errors&#x2F;&quot;Java errors&quot;: if you give the wrong args to a function, the error output is completely inscrutable, generally a very short string like `java.lang.Foo does not implement IBar`, which is only helpful if you kind of know how the Java layer works <i>and</i> all your args are different enough types that you can guess which one it&#x27;s talking about (bonus: anything function-like is just `IFn` so good luck). Ahhh and that made me remember: the doc situation even for stdlib is <i>bad.</i> Everyone around me used a third-party site clojuredocs.org which has broken-formatted auto-ingested versions of the plaintext official doc strings, because it is still the least bad option. No one has decided on a docstring format. No one has decided on code stylistic things either, which has mostly precluded the existence of auto-formatter tools.<p>The lang itself is good and I recommend folks use a LISP sometime. I was just genuinely surprised a 17-year-old lang was lacking in these areas, and I&#x27;d be pretty careful about setting out on a long-term project with it, unless all of those things have radically improved from 6 months ago.<p>(And like other folks said, you genuinely need editor integrations to not be wasting all your time on pren balancing. Not clj&#x27;s fault, just LISPs in general.)</div><br/><div id="40445497" class="c"><input type="checkbox" id="c-40445497" checked=""/><div class="controls bullet"><span class="by">neilyio</span><span>|</span><a href="#40444990">parent</a><span>|</span><a href="#40448012">next</a><span>|</span><label class="collapse" for="c-40445497">[-]</label><label class="expand" for="c-40445497">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m an advocate for Clojure, and while I believe that the usability speed bumps are more than made up for, I completely agree with you. The awkwardness of Clojure&#x27;s errors, REPL experience, and build tooling is a dealbreaker for many.<p>A couple years with Rust has taught me that intuitive errors and tooling will funnel you far enough into language to get you productive, and then you&#x27;re much more likely to stay. There&#x27;s just no way I would have stayed long enough to be a Rust professional if it hadn&#x27;t been for cargo and rust-analyzer.<p>These &quot;non-language&quot; components of Clojure are just not easy enough to use, and its inhibited Clojure&#x27;s growth. If, however, you do put in the time to grok these parts, the joy of using the language itself never fades.</div><br/></div></div><div id="40448012" class="c"><input type="checkbox" id="c-40448012" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#40444990">parent</a><span>|</span><a href="#40445497">prev</a><span>|</span><a href="#40446277">next</a><span>|</span><label class="collapse" for="c-40448012">[-]</label><label class="expand" for="c-40448012">[3 more]</label></div><br/><div class="children"><div class="content">Along the same lines with the docs, I also find it frustrating that a lot of the very most core basic abstractions and interfaces are left totally undefined in terms of documentation. Take `ISeq`&#x27;s definition. Surely, a candidate for the single most core interface.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure&#x2F;blob&#x2F;master&#x2F;src&#x2F;jvm&#x2F;clojure&#x2F;lang&#x2F;ISeq.java">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure&#x2F;blob&#x2F;master&#x2F;src&#x2F;jvm&#x2F;cloju...</a><p>But like, where is the javadoc? What exactly is supposed to be the contract of these methods `first`, `next`, `more`, `cons`? What&#x27;s the difference between `next` and `more`?<p>I really just don&#x27;t like that. Are we just supposed to pick up the core contracts&#x2F;abstractions through oral teachings and slack channel messages?</div><br/><div id="40450147" class="c"><input type="checkbox" id="c-40450147" checked=""/><div class="controls bullet"><span class="by">puredanger</span><span>|</span><a href="#40444990">root</a><span>|</span><a href="#40448012">parent</a><span>|</span><a href="#40446277">next</a><span>|</span><label class="collapse" for="c-40450147">[-]</label><label class="expand" for="c-40450147">[2 more]</label></div><br/><div class="children"><div class="content">You donât use the ISeq interface directly, you use them through the clojure.core API. The seq abstraction is documented at <a href="https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;sequences" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;sequences</a></div><br/><div id="40450970" class="c"><input type="checkbox" id="c-40450970" checked=""/><div class="controls bullet"><span class="by">joshlemer</span><span>|</span><a href="#40444990">root</a><span>|</span><a href="#40450147">parent</a><span>|</span><a href="#40446277">next</a><span>|</span><label class="collapse" for="c-40450970">[-]</label><label class="expand" for="c-40450970">[1 more]</label></div><br/><div class="children"><div class="content">Itâs rare for an application developer to need to use ISeq, but library authors do use of when they want to implement custom seqâs right? For them, and also just for those curious to understand how the core interfaces work, itâs still better to be explicit and write what the contract is I reckon.</div><br/></div></div></div></div></div></div></div></div><div id="40446277" class="c"><input type="checkbox" id="c-40446277" checked=""/><div class="controls bullet"><span class="by">spronket_news</span><span>|</span><a href="#40444990">prev</a><span>|</span><a href="#40449573">next</a><span>|</span><label class="collapse" for="c-40446277">[-]</label><label class="expand" for="c-40446277">[2 more]</label></div><br/><div class="children"><div class="content">this is super neat! how did you set up your fonts folder? what tooling did you use?</div><br/><div id="40448058" class="c"><input type="checkbox" id="c-40448058" checked=""/><div class="controls bullet"><span class="by">stefcoetzee</span><span>|</span><a href="#40446277">parent</a><span>|</span><a href="#40449573">next</a><span>|</span><label class="collapse" for="c-40448058">[-]</label><label class="expand" for="c-40448058">[1 more]</label></div><br/><div class="children"><div class="content">Fonts included in the repo. [0]<p>Tooling is a combo of Shadow CLJS and Clojure CLI.<p>[0] See `resources&#x2F;public&#x2F;fonts` here: 
<a href="https:&#x2F;&#x2F;github.com&#x2F;eliascotto&#x2F;tryclojure&#x2F;tree&#x2F;main&#x2F;resources&#x2F;public&#x2F;fonts">https:&#x2F;&#x2F;github.com&#x2F;eliascotto&#x2F;tryclojure&#x2F;tree&#x2F;main&#x2F;resources...</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;thheller&#x2F;shadow-cljs">https:&#x2F;&#x2F;github.com&#x2F;thheller&#x2F;shadow-cljs</a><p>[2] <a href="https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;clojure_cli" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;reference&#x2F;clojure_cli</a></div><br/></div></div></div></div><div id="40449573" class="c"><input type="checkbox" id="c-40449573" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#40446277">prev</a><span>|</span><a href="#40445003">next</a><span>|</span><label class="collapse" for="c-40449573">[-]</label><label class="expand" for="c-40449573">[2 more]</label></div><br/><div class="children"><div class="content">Clojure is a really interesting and well designed language with bad error messages and bad official tooling. It feels very sloppy.<p>Compared to Go, it has a weak stdlib, is more memory intensive, and generally slower. You get beautifully concise code but it can be very hard to follow (or return to after time away).<p>Go can look completely idiotic or unbelievably focused and practical, depending on the light. It is painful to give up Clojureâs very strong selling points but I find alternatives to be more pragmatic.</div><br/><div id="40452027" class="c"><input type="checkbox" id="c-40452027" checked=""/><div class="controls bullet"><span class="by">hpeter</span><span>|</span><a href="#40449573">parent</a><span>|</span><a href="#40445003">next</a><span>|</span><label class="collapse" for="c-40452027">[-]</label><label class="expand" for="c-40452027">[1 more]</label></div><br/><div class="children"><div class="content">&quot;weak stdlib&quot;: You can use the Java ecosystem, most of the things you need are there<p>&quot;it can be very hard to follow&quot;: I agree, if you are not a lisp developer it&#x27;s really hard, but if you develop clojure everyday, it&#x27;s as easy as anything else.<p>The answer is usually clean code when it comes to clojure. Keep your functions small.<p>&quot;more memory intensive, and generally slower&quot;: yep, the JVM is more memory intensive than Go. No surprise there and Clojure adds up on top of that. Startup times are pretty slow too. But compared to python it&#x27;s still fast. Apples to oranges.<p>I would say Clojure and Go are both great languages that tackle different problems so it&#x27;s not a fair comparison.</div><br/></div></div></div></div><div id="40445003" class="c"><input type="checkbox" id="c-40445003" checked=""/><div class="controls bullet"><span class="by">Anduia</span><span>|</span><a href="#40449573">prev</a><span>|</span><a href="#40447079">next</a><span>|</span><label class="collapse" for="c-40445003">[-]</label><label class="expand" for="c-40445003">[1 more]</label></div><br/><div class="children"><div class="content">I found the red over gray combination a bit hard to read, so I checked it with a color contrast calculator:<p>The contrast ratio here is 3.9:1 (text #DC2626, background #E5E7EB), and the minimum recommended for small text is 4.5:1.<p>Sorry to be that guy :) I am enjoying the tutorial.</div><br/></div></div><div id="40447079" class="c"><input type="checkbox" id="c-40447079" checked=""/><div class="controls bullet"><span class="by">mysore</span><span>|</span><a href="#40445003">prev</a><span>|</span><a href="#40445415">next</a><span>|</span><label class="collapse" for="c-40447079">[-]</label><label class="expand" for="c-40447079">[3 more]</label></div><br/><div class="children"><div class="content">i wish it was easy to make android apps with clojure. not sure if itd be easier with jetpack compose + clojure or react native + clojurescript.</div><br/><div id="40448749" class="c"><input type="checkbox" id="c-40448749" checked=""/><div class="controls bullet"><span class="by">prabhasp</span><span>|</span><a href="#40447079">parent</a><span>|</span><a href="#40447987">next</a><span>|</span><label class="collapse" for="c-40448749">[-]</label><label class="expand" for="c-40448749">[1 more]</label></div><br/><div class="children"><div class="content">Thereâs also clojuredart to do a dart &#x2F; flutter app. Iâve been working on one, and itâs been pretty pleasant to work on.</div><br/></div></div><div id="40447987" class="c"><input type="checkbox" id="c-40447987" checked=""/><div class="controls bullet"><span class="by">stefcoetzee</span><span>|</span><a href="#40447079">parent</a><span>|</span><a href="#40448749">prev</a><span>|</span><a href="#40445415">next</a><span>|</span><label class="collapse" for="c-40447987">[-]</label><label class="expand" for="c-40447987">[1 more]</label></div><br/><div class="children"><div class="content">The CLJS + RN route is doable. [0] Not familiar with the other approach.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;PEZ&#x2F;rn-rf-shadow">https:&#x2F;&#x2F;github.com&#x2F;PEZ&#x2F;rn-rf-shadow</a></div><br/></div></div></div></div><div id="40445415" class="c"><input type="checkbox" id="c-40445415" checked=""/><div class="controls bullet"><span class="by">talkingtab</span><span>|</span><a href="#40447079">prev</a><span>|</span><a href="#40448406">next</a><span>|</span><label class="collapse" for="c-40445415">[-]</label><label class="expand" for="c-40445415">[12 more]</label></div><br/><div class="children"><div class="content">I know many people will have problems with this post, but I am posting as information for clorjure-ophiles. Not reasons, but personal reasons why I don&#x27;t do Clojure and will not try it.<p>1. When I read about Clojure (repeatedly) I like it. I am especially interested in transducers. I even built a half baked transducer engine in JavaScript using generators. There is clearly something here of value here. Any system that can produce transducers is worth learning.<p>2. I spent too many years of my life on Java. It was okay until someone wrote a thing in php (!!) in a day that would be have taken at least a month in Java. Maybe two. I understand the &quot;good&quot; of Java, but for me personally, the cost of that good is just incredible tedium. This is personal and I understand that.<p>3. However, as soon as I get to the part of installing Clojure where you install a JVM, I start hearing voices that say &quot;It ain&#x27;t me babe&quot; and &quot;Just say no to Java&quot;. PTSD?<p>For a while there was Clojure-script and I started working with that, but it seemed to fall off the edge of the world.<p>I will happily try Clojure again if it will compile itself or if it does not require the installation of a JVM. [ And last but not least of irrational reactions- anything associated with Oracle is to be avoided like the plague. sorry]<p>[Edit: then I saw the stuff about Babashka so I will give that a try]</div><br/><div id="40446186" class="c"><input type="checkbox" id="c-40446186" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#40445415">parent</a><span>|</span><a href="#40446109">next</a><span>|</span><label class="collapse" for="c-40446186">[-]</label><label class="expand" for="c-40446186">[4 more]</label></div><br/><div class="children"><div class="content">Running on the JVM is one of the best things about Clojure. The JVM is an impressive piece of engineering where uncounted bajillions of man-hours were invested into making a good and performant VM with modern GC.<p>I&#x27;ve been using Clojure heavily for the last 9 years or so and I can&#x27;t see any reasons to dislike the JVM. Also, I barely ever touch any Java. You don&#x27;t need to.</div><br/><div id="40447594" class="c"><input type="checkbox" id="c-40447594" checked=""/><div class="controls bullet"><span class="by">delegate</span><span>|</span><a href="#40445415">root</a><span>|</span><a href="#40446186">parent</a><span>|</span><a href="#40446998">next</a><span>|</span><label class="collapse" for="c-40447594">[-]</label><label class="expand" for="c-40447594">[1 more]</label></div><br/><div class="children"><div class="content">I can hardly write a correct Hello World in Java. I can read it, I can probably write it, but I&#x27;ve never really used it.
Yet I&#x27;ve been writing Clojure daily for the last 9 years.<p>This means that you really don&#x27;t need Java in order to use Clojure.<p>Coming from a C++ background, I used to dislike the JVM out of principle just like yourself, especially since it needs to run on <i>my</i> local machine and it uses so much memory and is slow to start up.<p>However, once your app is started, you&#x27;re in the REPL and that&#x27;s the only time you need to start your app.. You can keep developing for days without restarting your app once.<p>Once I finished developing my app and I deploy it to a server, I&#x27;m kind of happy it runs on the JVM - that thing is super tuned, very fast and runs on a myriad of hardware platforms.. I don&#x27;t have to spend one minute thinking about those details.<p>So while the JVM is somewhat inconvenient on the dev machine, it helps a lot when you deploy it to production.<p>Things became a lot simpler when I stopped worrying about it and just used the language for its power and beauty.</div><br/></div></div><div id="40446998" class="c"><input type="checkbox" id="c-40446998" checked=""/><div class="controls bullet"><span class="by">owenmarshall</span><span>|</span><a href="#40445415">root</a><span>|</span><a href="#40446186">parent</a><span>|</span><a href="#40447594">prev</a><span>|</span><a href="#40446109">next</a><span>|</span><label class="collapse" for="c-40446998">[-]</label><label class="expand" for="c-40446998">[2 more]</label></div><br/><div class="children"><div class="content">And if you <i>do</i> need to touch Java for reasons Clojure doesnât impose, the interoperability story is really good.<p>Iâve done this with internal libraries - itâs easy to get them pulled into a Clojure code base, wrap them in such a way that the ergonomics of the rest of your code arenât ruined, and still treat them as a first class citizen for stuff like your build system, artifact stores, etc.</div><br/><div id="40447113" class="c"><input type="checkbox" id="c-40447113" checked=""/><div class="controls bullet"><span class="by">puredanger</span><span>|</span><a href="#40445415">root</a><span>|</span><a href="#40446998">parent</a><span>|</span><a href="#40446109">next</a><span>|</span><label class="collapse" for="c-40447113">[-]</label><label class="expand" for="c-40447113">[1 more]</label></div><br/><div class="children"><div class="content">Clojure 1.12 (which is nearly done) is going to add a bunch of interop support - method values, array class syntax, Clojure fn -&gt; Java functional interface conversion, stream support, etc.</div><br/></div></div></div></div></div></div><div id="40446109" class="c"><input type="checkbox" id="c-40446109" checked=""/><div class="controls bullet"><span class="by">fnordsensei</span><span>|</span><a href="#40445415">parent</a><span>|</span><a href="#40446186">prev</a><span>|</span><a href="#40446503">next</a><span>|</span><label class="collapse" for="c-40446109">[-]</label><label class="expand" for="c-40446109">[1 more]</label></div><br/><div class="children"><div class="content">Some dialects at various states of maturity:<p>CLR: <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure-clr">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;clojure-clr</a><p>LLVM: <a href="https:&#x2F;&#x2F;jank-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jank-lang.org&#x2F;</a><p>Erlang: <a href="https:&#x2F;&#x2F;www.clojerl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.clojerl.org&#x2F;</a><p>Python: <a href="http:&#x2F;&#x2F;hylang.org&#x2F;" rel="nofollow">http:&#x2F;&#x2F;hylang.org&#x2F;</a></div><br/></div></div><div id="40446503" class="c"><input type="checkbox" id="c-40446503" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#40445415">parent</a><span>|</span><a href="#40446109">prev</a><span>|</span><a href="#40445520">next</a><span>|</span><label class="collapse" for="c-40446503">[-]</label><label class="expand" for="c-40446503">[1 more]</label></div><br/><div class="children"><div class="content">I also cannot stand Java (not the technology, but everything surrounding it - bean factories, J2EE, Tomcat, war files, maven, insane unhinged class paths etc) but honestly one of the reasons Clojure is amazing is that it allows you to exist inside of the Java ecosystem while also being pretty isolated and walled off from it. It&#x27;s all the good parts of Java without all the bad annoying parts.<p>I would urge you to push thru the PTSD and give it another shot.<p>There is also Clojurescript, which runs on Javascript, and Babashka which is a lighter weight implementation of Clojure for fast startup times that is targeted at things like shell scripts or system programs. <a href="https:&#x2F;&#x2F;babashka.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;babashka.org&#x2F;</a></div><br/></div></div><div id="40445520" class="c"><input type="checkbox" id="c-40445520" checked=""/><div class="controls bullet"><span class="by">default-kramer</span><span>|</span><a href="#40445415">parent</a><span>|</span><a href="#40446503">prev</a><span>|</span><a href="#40449914">next</a><span>|</span><label class="collapse" for="c-40445520">[-]</label><label class="expand" for="c-40445520">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It was okay until someone wrote a thing in php (!!) in a day that would be have taken at least a month in Java. Maybe two. I understand the &quot;good&quot; of Java, but for me personally, the cost of that good is just incredible tedium. This is personal and I understand that.<p>You understand that this has everything to do with Java and nothing to do with the JVM, right?</div><br/><div id="40445872" class="c"><input type="checkbox" id="c-40445872" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#40445415">root</a><span>|</span><a href="#40445520">parent</a><span>|</span><a href="#40445903">next</a><span>|</span><label class="collapse" for="c-40445872">[-]</label><label class="expand" for="c-40445872">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s everything to do with the libraries people pick and not Java the language. Java the language can be extremely concise and expressive. Stop picking Spring and Java becomes fun again.</div><br/></div></div><div id="40445903" class="c"><input type="checkbox" id="c-40445903" checked=""/><div class="controls bullet"><span class="by">collyw</span><span>|</span><a href="#40445415">root</a><span>|</span><a href="#40445520">parent</a><span>|</span><a href="#40445872">prev</a><span>|</span><a href="#40449914">next</a><span>|</span><label class="collapse" for="c-40445903">[-]</label><label class="expand" for="c-40445903">[1 more]</label></div><br/><div class="children"><div class="content">PHP avoids many of the hassles of deployment that pretty much any other language does.</div><br/></div></div></div></div><div id="40449914" class="c"><input type="checkbox" id="c-40449914" checked=""/><div class="controls bullet"><span class="by">iLemming</span><span>|</span><a href="#40445415">parent</a><span>|</span><a href="#40445520">prev</a><span>|</span><a href="#40445863">next</a><span>|</span><label class="collapse" for="c-40449914">[-]</label><label class="expand" for="c-40449914">[1 more]</label></div><br/><div class="children"><div class="content">Slowly repeat after me... &quot;Java and JVM are not the same thing.&quot; Do it ten times every morning.. jk. JVM always gets a bad rap because of Java. Matter of fact, JVM is an incredibly good piece of tech.</div><br/></div></div><div id="40445863" class="c"><input type="checkbox" id="c-40445863" checked=""/><div class="controls bullet"><span class="by">petersellers</span><span>|</span><a href="#40445415">parent</a><span>|</span><a href="#40449914">prev</a><span>|</span><a href="#40448406">next</a><span>|</span><label class="collapse" for="c-40445863">[-]</label><label class="expand" for="c-40445863">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I spent too many years of my life on Java. It was okay until someone wrote a thing in php (!!) in a day that would be have taken at least a month in Java. Maybe two.<p>Really curious to hear what that was, because I&#x27;m having a hard time believing that is true.</div><br/></div></div></div></div><div id="40448406" class="c"><input type="checkbox" id="c-40448406" checked=""/><div class="controls bullet"><span class="by">cageface</span><span>|</span><a href="#40445415">prev</a><span>|</span><label class="collapse" for="c-40448406">[-]</label><label class="expand" for="c-40448406">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the recommended stack for doing front end development with clojure these days?</div><br/><div id="40450849" class="c"><input type="checkbox" id="c-40450849" checked=""/><div class="controls bullet"><span class="by">rads</span><span>|</span><a href="#40448406">parent</a><span>|</span><label class="collapse" for="c-40450849">[-]</label><label class="expand" for="c-40450849">[1 more]</label></div><br/><div class="children"><div class="content">Here is where I&#x27;d start for the path of least resistance while still using the most modern libraries:<p>- Dependency management: <a href="https:&#x2F;&#x2F;clojure.org&#x2F;guides&#x2F;deps_and_cli" rel="nofollow">https:&#x2F;&#x2F;clojure.org&#x2F;guides&#x2F;deps_and_cli</a><p>- Clojure-&gt;JS compiler: <a href="https:&#x2F;&#x2F;github.com&#x2F;thheller&#x2F;shadow-cljs">https:&#x2F;&#x2F;github.com&#x2F;thheller&#x2F;shadow-cljs</a><p>- React integration: <a href="https:&#x2F;&#x2F;github.com&#x2F;reagent-project&#x2F;reagent">https:&#x2F;&#x2F;github.com&#x2F;reagent-project&#x2F;reagent</a><p>- Global state management (optional): <a href="https:&#x2F;&#x2F;github.com&#x2F;day8&#x2F;re-frame">https:&#x2F;&#x2F;github.com&#x2F;day8&#x2F;re-frame</a><p>You might also want a CSS framework. There are some options to write CSS in ClojureScript, but I prefer TailwindCSS which isn&#x27;t a Clojure-specific thing and it works fine out-of-the-box with `.cljs` files.<p>You can swap out Reagent for Helix, which is a lower-level and faster wrapper for React. That said, Reagent does work with React 18 just fine and there&#x27;s tons of docs for it, so jumping to Helix first is a premature optimization IMO, especially if you&#x27;re new to Clojure.</div><br/></div></div></div></div></div></div></div></div></div></body></html>