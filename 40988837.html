<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721293263115" as="style"/><link rel="stylesheet" href="styles.css?v=1721293263115"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pldb.io/blog/brianKernighan.html">A brief interview with Awk creator Dr. Brian Kernighan (2022)</a> <span class="domain">(<a href="https://pldb.io">pldb.io</a>)</span></div><div class="subtext"><span>breck</span> | <span>98 comments</span></div><br/><div><div id="40990147" class="c"><input type="checkbox" id="c-40990147" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#40992042">next</a><span>|</span><label class="collapse" for="c-40990147">[-]</label><label class="expand" for="c-40990147">[5 more]</label></div><br/><div class="children"><div class="content">Little known random Brian Kernighan facts:<p>* He joined Princeton’s CS department in 2000 but taught at least one class there as early as 1993 while still at Bell Labs Research (on sabbatical?)<p>* One of his students regularly brought a 386sx laptop (running pre-1.0 Linux) to class and when Brian was asked more obscure questions about what awk did which he couldn’t remember, the student would run commands in awk and feed Brian the definitive implementation answer. So Brian had some exposure to Linux moderately early on.<p>* Here’s a writeup from him on putting AT&amp;T’s toll free phone directory on the internet back in fall 1994: <a href="https:&#x2F;&#x2F;www.cs.princeton.edu&#x2F;~bwk&#x2F;800.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.princeton.edu&#x2F;~bwk&#x2F;800.html</a></div><br/><div id="40991986" class="c"><input type="checkbox" id="c-40991986" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#40990147">parent</a><span>|</span><a href="#40991653">next</a><span>|</span><label class="collapse" for="c-40991986">[-]</label><label class="expand" for="c-40991986">[3 more]</label></div><br/><div class="children"><div class="content">Is gawk the definitive awk implementation or am I thinking of gsed being the one that’s really different?</div><br/><div id="40992138" class="c"><input type="checkbox" id="c-40992138" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#40990147">root</a><span>|</span><a href="#40991986">parent</a><span>|</span><a href="#40993411">next</a><span>|</span><label class="collapse" for="c-40992138">[-]</label><label class="expand" for="c-40992138">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what you&#x27;re thinking of, but there at least 3 prominent and still-relevant awk implementations:<p>nawk (One True Awk &#x2F; AT&amp;T awk &#x2F; BWK awk): the original awk, still maintained; is used by macOS, FreeBSD, OpenBSD, and NetBSD <a href="https:&#x2F;&#x2F;github.com&#x2F;onetrueawk&#x2F;awk">https:&#x2F;&#x2F;github.com&#x2F;onetrueawk&#x2F;awk</a><p>mawk (Mike&#x27;s awk): the default awk on Debian <a href="https:&#x2F;&#x2F;invisible-island.net&#x2F;mawk&#x2F;" rel="nofollow">https:&#x2F;&#x2F;invisible-island.net&#x2F;mawk&#x2F;</a><p>gawk (GNU awk): the default awk in lots of other places <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gawk&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gawk&#x2F;</a></div><br/></div></div><div id="40993411" class="c"><input type="checkbox" id="c-40993411" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#40990147">root</a><span>|</span><a href="#40991986">parent</a><span>|</span><a href="#40992138">prev</a><span>|</span><a href="#40991653">next</a><span>|</span><label class="collapse" for="c-40993411">[-]</label><label class="expand" for="c-40993411">[1 more]</label></div><br/><div class="children"><div class="content">There were some differences even in the mid 90s between AT&amp;T-style awk which was then considered the original&#x2F;definitive&#x2F;most-backward-compatible and gawk which was new&#x2F;shiny (although not &#x2F;that&#x2F; new).<p>I believe both were available in Linux back then. I believe in the above anecdote both were consulted with the emphasis on AT&amp;T-style awk for obvious reasons.</div><br/></div></div></div></div><div id="40991653" class="c"><input type="checkbox" id="c-40991653" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#40990147">parent</a><span>|</span><a href="#40991986">prev</a><span>|</span><a href="#40992042">next</a><span>|</span><label class="collapse" for="c-40991653">[-]</label><label class="expand" for="c-40991653">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One of his students<p>Smells like the post author, no?</div><br/></div></div></div></div><div id="40992042" class="c"><input type="checkbox" id="c-40992042" checked=""/><div class="controls bullet"><span class="by">rr808</span><span>|</span><a href="#40990147">prev</a><span>|</span><a href="#40989304">next</a><span>|</span><label class="collapse" for="c-40992042">[-]</label><label class="expand" for="c-40992042">[3 more]</label></div><br/><div class="children"><div class="content">Lex Fridman did a good hour and a half interview with BK if you&#x27;re interested. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=O9upVbGSBFo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=O9upVbGSBFo</a></div><br/><div id="40992587" class="c"><input type="checkbox" id="c-40992587" checked=""/><div class="controls bullet"><span class="by">deepspace</span><span>|</span><a href="#40992042">parent</a><span>|</span><a href="#40992841">next</a><span>|</span><label class="collapse" for="c-40992587">[-]</label><label class="expand" for="c-40992587">[1 more]</label></div><br/><div class="children"><div class="content">The Computerphile YouTube channel also did many interviews with BK: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;results?search_query=computerphile+kernighan" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;results?search_query=computerphile+k...</a><p>Sometimes, I feel extremely privileged to be living today.  It&#x27;s like a mathematician being able to interview Euler or a physicist interviewing Newton.</div><br/></div></div><div id="40992841" class="c"><input type="checkbox" id="c-40992841" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40992042">parent</a><span>|</span><a href="#40992587">prev</a><span>|</span><a href="#40989304">next</a><span>|</span><label class="collapse" for="c-40992841">[-]</label><label class="expand" for="c-40992841">[1 more]</label></div><br/><div class="children"><div class="content">checking it out.<p>I didn&#x27;t like his talks earlier (had only seen parts of a few), don&#x27;t know why.<p>but interestingly (to me), this one seems to be good, at least at the start, where I am now.<p>as the real talk starts after the ads, looking at him, for some reason, I thought he looked like a sinister mafia don wearing a tie. :)</div><br/></div></div></div></div><div id="40989304" class="c"><input type="checkbox" id="c-40989304" checked=""/><div class="controls bullet"><span class="by">FelipeCortez</span><span>|</span><a href="#40992042">prev</a><span>|</span><a href="#40992577">next</a><span>|</span><label class="collapse" for="c-40989304">[-]</label><label class="expand" for="c-40989304">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a more comprehensive interview that also includes Aho and Weinberger in the book Masterminds of Programming. Highly recommended</div><br/><div id="40989894" class="c"><input type="checkbox" id="c-40989894" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#40989304">parent</a><span>|</span><a href="#40992577">next</a><span>|</span><label class="collapse" for="c-40989894">[-]</label><label class="expand" for="c-40989894">[1 more]</label></div><br/><div class="children"><div class="content">His wiki lists several interviews, for those inclined:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brian_Kernighan" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brian_Kernighan</a><p><a href="http:&#x2F;&#x2F;www.linuxjournal.com&#x2F;article&#x2F;7035" rel="nofollow">http:&#x2F;&#x2F;www.linuxjournal.com&#x2F;article&#x2F;7035</a><p><a href="http:&#x2F;&#x2F;www-2.cs.cmu.edu&#x2F;~mihaib&#x2F;kernighan-interview&#x2F;index.html" rel="nofollow">http:&#x2F;&#x2F;www-2.cs.cmu.edu&#x2F;~mihaib&#x2F;kernighan-interview&#x2F;index.ht...</a><p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090428163341&#x2F;https:&#x2F;&#x2F;www.princeton.edu&#x2F;~mike&#x2F;unixhistory" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20090428163341&#x2F;https:&#x2F;&#x2F;www.princ...</a><p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20131126220450&#x2F;http:&#x2F;&#x2F;princetonstartuptv.com&#x2F;post&#x2F;49379235060&#x2F;the-legendary-brian-kernighan-on-teaching-writing" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20131126220450&#x2F;http:&#x2F;&#x2F;princetons...</a></div><br/></div></div></div></div><div id="40992577" class="c"><input type="checkbox" id="c-40992577" checked=""/><div class="controls bullet"><span class="by">rswail</span><span>|</span><a href="#40989304">prev</a><span>|</span><a href="#40989740">next</a><span>|</span><label class="collapse" for="c-40992577">[-]</label><label class="expand" for="c-40992577">[1 more]</label></div><br/><div class="children"><div class="content">I own a copy of K&amp;R that is signed by Dr Kernighan from an Australian Unix conference back in the 80s. One of my prized possessions.<p>That book, along with The Practice of Programming by Kernighan&#x2F;Pike and Byte magazine etc were my &quot;Stack Overflow&quot; for the 1980s.</div><br/></div></div><div id="40989740" class="c"><input type="checkbox" id="c-40989740" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40992577">prev</a><span>|</span><a href="#40989213">next</a><span>|</span><label class="collapse" for="c-40989740">[-]</label><label class="expand" for="c-40989740">[33 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve been reading <i>the unix programming environment</i> from 01983 this week (the old testament of kernighan and pike), about 35 years later than i really should have.  awk is really one of the stars of the book, the closest thing in it to currently popular languages like js, lua, python, perl, or tcl.  (what awk calls &#x27;associative arrays&#x27; js just calls &#x27;objects&#x27;.)<p>the 7th edition unix version of awk from 01979 <a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;awk" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;aw...</a> (from <a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;Archive&#x2F;Distributions&#x2F;Research&#x2F;Henry_Spencer_v7&#x2F;v7.tar.gz" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;Archive&#x2F;Distributions&#x2F;Research&#x2F;Henry_Sp...</a>) is only 2680 lines of source code, which is pretty astonishing.  the executable is 46k and ran in the pdp-11&#x27;s 64k address space.  as far as i can tell, that version of awk, and also the one documnted four years later in <i>tupe</i>, didn&#x27;t even have user-defined functions.  neither did the v7 version of the bourne shell, i think<p>bc, however, did</div><br/><div id="40989929" class="c"><input type="checkbox" id="c-40989929" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40989740">parent</a><span>|</span><a href="#40990350">next</a><span>|</span><label class="collapse" for="c-40989929">[-]</label><label class="expand" for="c-40989929">[4 more]</label></div><br/><div class="children"><div class="content">&gt; that version of awk [...] didn&#x27;t even have user-defined functions<p>Also known as “old awk” or (retronymically) “oawk”. Heirloom still carries[1] what should be a descendant of it (alongside the more familliar nawk).<p>Also,<p>&gt; the executable is 46k<p>thus still a bit larger than Turbo Pascal 3.02[2] :) That didn’t have a regex engine, admittedly.<p>[1] <a href="https:&#x2F;&#x2F;heirloom.sourceforge.net&#x2F;man&#x2F;awk.1.html" rel="nofollow">https:&#x2F;&#x2F;heirloom.sourceforge.net&#x2F;man&#x2F;awk.1.html</a><p>[2] <a href="https:&#x2F;&#x2F;prog21.dadgum.com&#x2F;116.html" rel="nofollow">https:&#x2F;&#x2F;prog21.dadgum.com&#x2F;116.html</a></div><br/><div id="40991344" class="c"><input type="checkbox" id="c-40991344" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40989929">parent</a><span>|</span><a href="#40991092">next</a><span>|</span><label class="collapse" for="c-40991344">[-]</label><label class="expand" for="c-40991344">[1 more]</label></div><br/><div class="children"><div class="content">the 39.7-kilobyte turbo pascal executable doesn&#x27;t include the (modest) pascal runtime library, because it is itself written in assembly, not in pascal.  awk, being an interpreter, does have to include the runtime library in the same executable as the parser.  awk is also written in c rather than assembly, and moreover using lex and yacc; lex compiles the lexer into a deterministic automaton written in c for speed, and all of this is compiled with pcc, whose optimizations were relatively weak by today&#x27;s standards<p>i haven&#x27;t compiled version 7 myself so i don&#x27;t have a clear idea of how big it is<p>a slight correction to my above comment!  on running `file *` in bin&#x2F;, i see, among other things<p><pre><code>    at:       PDP-11 pure executable
    awk:      PDP-11 separate I&amp;D executable
    bas:      PDP-11 pure executable
    basename: PDP-11 pure executable
    bc:       PDP-11 pure executable
</code></pre>
if i understand correctly, this means that this awk executable is built with what we used to call the &#x27;small memory model&#x27; on the 8088, using separate instruction and data segments.  that way, awk could have data stored at the same address as executable code, so you had 64 kibibytes available for just the data.  you didn&#x27;t have to squinch your awk program and all its data into the 65-46 = 19 kilobytes left over after the awk executable was loaded<p>this, in effect, allows you 128 kilobytes for the functionality of your program: when you call an awk builtin function (usr&#x2F;src&#x2F;cmd&#x2F;awk&#x2F;proc.c lists seven named functions: substr, sindex, sprintf, printf, print, split, and instat) you&#x27;re invoking code in the instruction segment, while the logic of your interpreted code shares the data segment with the data you&#x27;re manipulating (strings or arrays or whatever)<p>so it&#x27;s at least misleading that i said it &#x27;ran in the pdp-11&#x27;s 64k address space&#x27;<p>not all pdp-11s supported separate instruction and data segments (i think the more expensive pdp-11&#x2F;45 did, but the pdp-11&#x2F;40 and pdp-11&#x2F;20 didn&#x27;t) and most of the 7th edition executables didn&#x27;t require that.  but awk, adb, dcheck, dd, fgrep, icheck, lex, ncheck, refer, restor, sort, tar, tbl, uucp, uulog, uux, and yacc did.  i&#x27;m not sure how you were supposed to run a unix system without dd, icheck, tar, uucp, restor, or adb (sdb and dbx didn&#x27;t exist), so i think maybe at this point they had given up on supporting the smaller models</div><br/></div></div><div id="40991092" class="c"><input type="checkbox" id="c-40991092" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40989929">parent</a><span>|</span><a href="#40991344">prev</a><span>|</span><a href="#40990350">next</a><span>|</span><label class="collapse" for="c-40991092">[-]</label><label class="expand" for="c-40991092">[2 more]</label></div><br/><div class="children"><div class="content">Turbo Pascal was written in asm and highly optimized to reduce its size.</div><br/><div id="40992872" class="c"><input type="checkbox" id="c-40992872" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40991092">parent</a><span>|</span><a href="#40990350">next</a><span>|</span><label class="collapse" for="c-40992872">[-]</label><label class="expand" for="c-40992872">[1 more]</label></div><br/><div class="children"><div class="content">in under 40 KB it had a lightning fast compiler that generated .COM files, and a text based IDE with a WordStar compatible code editor.</div><br/></div></div></div></div></div></div><div id="40990350" class="c"><input type="checkbox" id="c-40990350" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#40989740">parent</a><span>|</span><a href="#40989929">prev</a><span>|</span><a href="#40990633">next</a><span>|</span><label class="collapse" for="c-40990350">[-]</label><label class="expand" for="c-40990350">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>the closest thing [...] to currently popular languages like js</i><p>awk is more than that: having introduced the &quot;function&quot; keyword, for e in a, semicolon-less syntax, stringly-typing, delete x[e], etc, etc, it&#x27;s quite obviously the base for JavaScript, and Brendan Eich said as much [1].<p>[1]: <a href="https:&#x2F;&#x2F;brendaneich.com&#x2F;2010&#x2F;07&#x2F;a-brief-history-of-javascript&#x2F;" rel="nofollow">https:&#x2F;&#x2F;brendaneich.com&#x2F;2010&#x2F;07&#x2F;a-brief-history-of-javascrip...</a></div><br/><div id="40990458" class="c"><input type="checkbox" id="c-40990458" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40990350">parent</a><span>|</span><a href="#40990633">next</a><span>|</span><label class="collapse" for="c-40990458">[-]</label><label class="expand" for="c-40990458">[2 more]</label></div><br/><div class="children"><div class="content">i&#x27;d say perl is closer, but for (e in a) is from awk and not perl<p>semicolonless syntax is in js, tcl, lua, and sh, but not awk or perl; in awk omitted semicolons are interpreted as string concatenation</div><br/></div></div></div></div><div id="40990633" class="c"><input type="checkbox" id="c-40990633" checked=""/><div class="controls bullet"><span class="by">dakiol</span><span>|</span><a href="#40989740">parent</a><span>|</span><a href="#40990350">prev</a><span>|</span><a href="#40991789">next</a><span>|</span><label class="collapse" for="c-40990633">[-]</label><label class="expand" for="c-40990633">[4 more]</label></div><br/><div class="children"><div class="content">I read the same book and got the exact same conclusion. Then I read The UNIX—Haters Handbook and thought that Unix tools (like awk) are sadly not good enough anymore.</div><br/><div id="40990726" class="c"><input type="checkbox" id="c-40990726" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40990633">parent</a><span>|</span><a href="#40991789">next</a><span>|</span><label class="collapse" for="c-40990726">[-]</label><label class="expand" for="c-40990726">[3 more]</label></div><br/><div class="children"><div class="content">yeah, there are a lot of questionable design decisions in there that are only defensible in the context of the pdp-11&#x27;s 64k address space and slow cpu</div><br/><div id="40992462" class="c"><input type="checkbox" id="c-40992462" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40990726">parent</a><span>|</span><a href="#40991789">next</a><span>|</span><label class="collapse" for="c-40992462">[-]</label><label class="expand" for="c-40992462">[2 more]</label></div><br/><div class="children"><div class="content">what are some of those?</div><br/><div id="40992534" class="c"><input type="checkbox" id="c-40992534" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992462">parent</a><span>|</span><a href="#40991789">next</a><span>|</span><label class="collapse" for="c-40992534">[-]</label><label class="expand" for="c-40992534">[1 more]</label></div><br/><div class="children"><div class="content">making everything a string, for example.  representing string length with null termination.  splitting shell variables into words after variable substitution (rather than having a list type).  a zillion shell-script bugs when filenames, directory names, search strings, etc., contain spaces.  not having user-defined subroutines in sh or awk.  no command-line editing.  command names and options that read the same as you type them (thus forcing you to choose between unreadable commands and commands that are too unwieldy to type comfortably).  no tab completion.  more generally, no interactive feedback on what is going to happen when you submit your command.  no job control.  having to retype command output as new input all the time.  table layout that only works with fixed-width fonts.  filenames limited to 14 characters.  no text search through previous output.  hardlinks rather than reflinks.  an inflexible security policy defined in the kernel.  the reification of . and .. in the filesystem.  exposing the layout of filesystem directories to every program that enumerated directory entries.  no way to undo rm or mv.  no screen editors.  arbitrary line-length limits all over the place.  . in the path.  textual macro expansion as the primary form of higher-order programming.  backslashed backquotes.  backslashed backslashes.  total precedence orderings on infix operators.  slightly different regular expression syntaxes for each program.  self-perpetuating at jobs.  etc.<p>a lot of these have been fixed, but some are hard to fix</div><br/></div></div></div></div></div></div></div></div><div id="40991789" class="c"><input type="checkbox" id="c-40991789" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40989740">parent</a><span>|</span><a href="#40990633">prev</a><span>|</span><a href="#40991474">next</a><span>|</span><label class="collapse" for="c-40991789">[-]</label><label class="expand" for="c-40991789">[2 more]</label></div><br/><div class="children"><div class="content">Why do you put zeroes in front of your dates?</div><br/><div id="40991810" class="c"><input type="checkbox" id="c-40991810" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40991789">parent</a><span>|</span><a href="#40991474">next</a><span>|</span><label class="collapse" for="c-40991810">[-]</label><label class="expand" for="c-40991810">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a nod to the Long Now Foundation<p><a href="https:&#x2F;&#x2F;longnow.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;longnow.org&#x2F;</a><p>and can be taken in many ways, either as a sign of a true believer or just to invoke a sense of the scale of time beyond the immediate.</div><br/></div></div></div></div><div id="40991474" class="c"><input type="checkbox" id="c-40991474" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#40989740">parent</a><span>|</span><a href="#40991789">prev</a><span>|</span><a href="#40990734">next</a><span>|</span><label class="collapse" for="c-40991474">[-]</label><label class="expand" for="c-40991474">[18 more]</label></div><br/><div class="children"><div class="content">&gt; 01983<p>&gt; 01979<p>thats not how you write years, or even numbers really.</div><br/><div id="40991491" class="c"><input type="checkbox" id="c-40991491" checked=""/><div class="controls bullet"><span class="by">buzzy_hacker</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40991474">parent</a><span>|</span><a href="#40991801">next</a><span>|</span><label class="collapse" for="c-40991491">[-]</label><label class="expand" for="c-40991491">[14 more]</label></div><br/><div class="children"><div class="content">Guessing it’s from following the style of <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Long_Now_Foundation" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Long_Now_Foundation</a></div><br/><div id="40992128" class="c"><input type="checkbox" id="c-40992128" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40991491">parent</a><span>|</span><a href="#40991801">next</a><span>|</span><label class="collapse" for="c-40992128">[-]</label><label class="expand" for="c-40992128">[13 more]</label></div><br/><div class="children"><div class="content">thats idiotic because thats 7000 years away</div><br/><div id="40993328" class="c"><input type="checkbox" id="c-40993328" checked=""/><div class="controls bullet"><span class="by">gruturo</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992128">parent</a><span>|</span><a href="#40992432">next</a><span>|</span><label class="collapse" for="c-40993328">[-]</label><label class="expand" for="c-40993328">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s also idiotic because we don&#x27;t put a leading zero in front of 1, 2 or 3 digit years, and neither will future historians put one in front of 4-digit ones - it&#x27;s just gratuitously annoying.<p>Charlemagne was crowned in 800 AD, not in 0800 or 00800.<p>Pompeii was destroyed by the Vesuvius in 79 AD, not 079 or 0079 or 00079.<p>The battle of the Teutoburg Forest was in 9 AD, not 09, 009, 0009 or 00009.<p>Also why stop at 5 digits while you&#x27;re being ridiculous?</div><br/><div id="40993340" class="c"><input type="checkbox" id="c-40993340" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40993328">parent</a><span>|</span><a href="#40992432">next</a><span>|</span><label class="collapse" for="c-40993340">[-]</label><label class="expand" for="c-40993340">[5 more]</label></div><br/><div class="children"><div class="content">. . . and now you&#x27;re engaging.<p>Church of the Long Now wins again.</div><br/><div id="40993354" class="c"><input type="checkbox" id="c-40993354" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40993340">parent</a><span>|</span><a href="#40992432">next</a><span>|</span><label class="collapse" for="c-40993354">[-]</label><label class="expand" for="c-40993354">[4 more]</label></div><br/><div class="children"><div class="content">please take this kind of &#x27;engagement&#x27; back to twitter where it belongs</div><br/><div id="40993362" class="c"><input type="checkbox" id="c-40993362" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40993354">parent</a><span>|</span><a href="#40992432">next</a><span>|</span><label class="collapse" for="c-40993362">[-]</label><label class="expand" for="c-40993362">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve replied to the wrong person I suspect.</div><br/><div id="40993388" class="c"><input type="checkbox" id="c-40993388" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40993362">parent</a><span>|</span><a href="#40992432">next</a><span>|</span><label class="collapse" for="c-40993388">[-]</label><label class="expand" for="c-40993388">[2 more]</label></div><br/><div class="children"><div class="content">apologies, yes</div><br/><div id="40993401" class="c"><input type="checkbox" id="c-40993401" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40993388">parent</a><span>|</span><a href="#40992432">next</a><span>|</span><label class="collapse" for="c-40993401">[-]</label><label class="expand" for="c-40993401">[1 more]</label></div><br/><div class="children"><div class="content">No drama, footguns are easy mistakes to make.<p>I&#x27;m happy to expand for others; regardless of my feelings on the matter the Long Now use of a leading zero creates questions and engagement, thus spreading their message under the mantra of &quot;there&#x27;s no such thing as bad press&quot; | &quot;get the public talking&quot;.<p>It&#x27;s an Advertising 101 strategy and not at all idiotic save perhaps at the surface of first exposure.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40992432" class="c"><input type="checkbox" id="c-40992432" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992128">parent</a><span>|</span><a href="#40993328">prev</a><span>|</span><a href="#40991801">next</a><span>|</span><label class="collapse" for="c-40992432">[-]</label><label class="expand" for="c-40992432">[6 more]</label></div><br/><div class="children"><div class="content">some of us post hn comments containing analyses of source code from early versions of unix, results from tracing the execution of uxn &#x27;left&#x27; and other text editors to estimate their power usage <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40842397">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40842397</a>, overviews of the historical development of cpu architecture <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40983675">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40983675</a>, simple explanations of the role that digital signal processing plays in modern mixed-signal systems <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40985558">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40985558</a>, quantitative analyses of the economic and technological impact of the renewable energy transition <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40725765">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40725765</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40724305">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40724305</a>, assembly-language programs to clarify the role of associative arrays in computing <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40990055">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40990055</a>, analyses of mostly forgotten programming languages that python evolved from <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40992191">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40992191</a>, examples of how to use the gnu units program for all kinds of things most people didn&#x27;t know it could do <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36988917">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36988917</a>, comparative benchmarks of different compilers and interpreters <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40960819">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40960819</a>, system call traces to elucidate subtle concurrency bugs in unix <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40955923">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40955923</a>, close readings of federal court rulings placing them in historical context <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40950806">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40950806</a>, gui libraries we wrote ourselves <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40942566">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40942566</a>, simple workarounds for frustrating unix problems <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40911681">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40911681</a>, appreciation for others <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40950084">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40950084</a>, recipes for video streaming from the command line <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40911239">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40911239</a>, admissions of error with reproducible scripts for clearly showing we were wrong <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40912051">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40912051</a>,  helpful tips for everyday command-line usage <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40910845">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40910845</a>, thanks to others for correcting our errors <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40911035">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40911035</a>, quantitative analyses of cutting-edge hardware <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40903708">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40903708</a>, admissions of error in our analyses of chinese export-control regulations <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40885691">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40885691</a>, simple explanations of cutting-edge computer security research <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40885329">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40885329</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40841095">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40841095</a>, simple explanations of cutting-edge software testing tools <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40879952">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40879952</a>, and implementations in three lines of forth of things people think are impossible in forth <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40868981">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40868981</a><p>and some of us say things like &#x27;thats idiotic because thats 7000 years away&#x27;<p>these are two different kinds of discourse, and this website is only for one of them</div><br/><div id="40992569" class="c"><input type="checkbox" id="c-40992569" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992432">parent</a><span>|</span><a href="#40992456">next</a><span>|</span><label class="collapse" for="c-40992569">[-]</label><label class="expand" for="c-40992569">[2 more]</label></div><br/><div class="children"><div class="content">Why not 001982?<p>When are leading zeros in front of numbers particularly useful?  Even in fixed column formats they&#x27;re almost always left blank.</div><br/></div></div><div id="40992456" class="c"><input type="checkbox" id="c-40992456" checked=""/><div class="controls bullet"><span class="by">spencerflem</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992432">parent</a><span>|</span><a href="#40992569">prev</a><span>|</span><a href="#40991801">next</a><span>|</span><label class="collapse" for="c-40992456">[-]</label><label class="expand" for="c-40992456">[3 more]</label></div><br/><div class="children"><div class="content">Dude, they&#x27;ve got a point, your style is annoying and not even right in a &quot;technically correct&quot; sorta way. You don&#x27;t write things that happened 5 AD as 00005 AD.</div><br/><div id="40992483" class="c"><input type="checkbox" id="c-40992483" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992456">parent</a><span>|</span><a href="#40991801">next</a><span>|</span><label class="collapse" for="c-40992483">[-]</label><label class="expand" for="c-40992483">[2 more]</label></div><br/><div class="children"><div class="content">which of these two kinds of discourse are you engaging in right now<p>if you&#x27;re capable of the other one, i suggest you demonstrate that<p>dude</div><br/><div id="40992793" class="c"><input type="checkbox" id="c-40992793" checked=""/><div class="controls bullet"><span class="by">simpaticoder</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992483">parent</a><span>|</span><a href="#40991801">next</a><span>|</span><label class="collapse" for="c-40992793">[-]</label><label class="expand" for="c-40992793">[1 more]</label></div><br/><div class="children"><div class="content">Why not 3 or even 10 leading zeroes? Why so pessimistic?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40991801" class="c"><input type="checkbox" id="c-40991801" checked=""/><div class="controls bullet"><span class="by">bch</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40991474">parent</a><span>|</span><a href="#40991491">prev</a><span>|</span><a href="#40990734">next</a><span>|</span><label class="collapse" for="c-40991801">[-]</label><label class="expand" for="c-40991801">[3 more]</label></div><br/><div class="children"><div class="content">They&#x27;re written in awktal.</div><br/><div id="40992482" class="c"><input type="checkbox" id="c-40992482" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40991801">parent</a><span>|</span><a href="#40990734">next</a><span>|</span><label class="collapse" for="c-40992482">[-]</label><label class="expand" for="c-40992482">[2 more]</label></div><br/><div class="children"><div class="content">are you sure it&#x27;s not hexal or binal?</div><br/><div id="40992539" class="c"><input type="checkbox" id="c-40992539" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989740">root</a><span>|</span><a href="#40992482">parent</a><span>|</span><a href="#40990734">next</a><span>|</span><label class="collapse" for="c-40992539">[-]</label><label class="expand" for="c-40992539">[1 more]</label></div><br/><div class="children"><div class="content">as long as it&#x27;s not intercal</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40989213" class="c"><input type="checkbox" id="c-40989213" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40989740">prev</a><span>|</span><a href="#40989604">next</a><span>|</span><label class="collapse" for="c-40989213">[-]</label><label class="expand" for="c-40989213">[13 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting to me that he refers to association arrays as &quot;newish&quot;, when they showed up in Lisp nearly 20 years earlier.</div><br/><div id="40989507" class="c"><input type="checkbox" id="c-40989507" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40989213">parent</a><span>|</span><a href="#40989334">next</a><span>|</span><label class="collapse" for="c-40989507">[-]</label><label class="expand" for="c-40989507">[6 more]</label></div><br/><div class="children"><div class="content">Two things to keep in mind: Pre-internet, it was quite easy to be skilled and knowledgeable and yet never have been exposed to something another community somewhere would consider basic, or for it to take many many years to percolate across. I remember getting into programming even in the 1990s and I can tell you a lot of the C world would still consider associative data structures like a hash table something to be a bit exotic and only to be pulled out if you had no other choice. It was very easy to not be very up to date on these things.<p>Second, while the programming world fancies itself a very fast mover, it really isn&#x27;t, and it especially wasn&#x27;t back then. 20 years isn&#x27;t necessarily as long as you would think in 2024. We&#x27;re still trying to convince people in 2024 that you really don&#x27;t need a language that will happily index outside of arrays, and how long has <i>that</i> been a staple in existing languages? (You may think that&#x27;s silly, but we&#x27;ve had that fight on HN, yes, yea verily, this very year. Granted, this is winding down, but it&#x27;s still a live argument.)<p>There&#x27;s a lot of things that showed up in some language in the 1960s or 1970s and wasn&#x27;t widely adopted for another few decades.<p>(Though I suspect one problem with Lisp is that back in the day, its performance was pretty awful relative to the other things of the day. It was not always the best advertisement for its features. A bit too ahead of its time sometimes.)</div><br/><div id="40991835" class="c"><input type="checkbox" id="c-40991835" checked=""/><div class="controls bullet"><span class="by">xarope</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40989507">parent</a><span>|</span><a href="#40991373">next</a><span>|</span><label class="collapse" for="c-40991835">[-]</label><label class="expand" for="c-40991835">[2 more]</label></div><br/><div class="children"><div class="content">I remember being taught about associative caches in CPU architecture, and later on programming the same in C.  So I&#x27;m not sure about the 90&#x27;s and hash tables being &quot;exotic&quot;.<p>My first real use of hashes was in perl4; with perl5 released in 1996 (<a href="https:&#x2F;&#x2F;dev.perl.org&#x2F;perl5&#x2F;news&#x2F;" rel="nofollow">https:&#x2F;&#x2F;dev.perl.org&#x2F;perl5&#x2F;news&#x2F;</a>), surely it meant people were also well aware of the usefulness of hash arrays even back then.</div><br/><div id="40992840" class="c"><input type="checkbox" id="c-40992840" checked=""/><div class="controls bullet"><span class="by">cancerhacker</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40991835">parent</a><span>|</span><a href="#40991373">next</a><span>|</span><label class="collapse" for="c-40992840">[-]</label><label class="expand" for="c-40992840">[1 more]</label></div><br/><div class="children"><div class="content">It was a common practical interview question in 1996 to ask a candidate to implement a hash table in C.</div><br/></div></div></div></div><div id="40991373" class="c"><input type="checkbox" id="c-40991373" checked=""/><div class="controls bullet"><span class="by">vram22</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40989507">parent</a><span>|</span><a href="#40991835">prev</a><span>|</span><a href="#40992953">next</a><span>|</span><label class="collapse" for="c-40991373">[-]</label><label class="expand" for="c-40991373">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I remember getting into programming even in the 1990s and I can tell you a lot of the C world would still consider associative data structures like a hash table something to be a bit exotic and only to be pulled out if you had no other choice. It was very easy to not be very up to date on these things.<p>That&#x27;s a little surprising, considering that the classic first  book about C, K&amp;R  was first published in 1978 and again in 1988, the  first and second edition, respectively.<p>One of the editions, maybe the first, had a simple hash table implementation, that just summed up the ASCII values of the characters in the given string, modulo some value, and used that as the key for the string being hashed.<p>.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;The_C_Programming_Language" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;The_C_Programming_Language</a></div><br/></div></div><div id="40992953" class="c"><input type="checkbox" id="c-40992953" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40989507">parent</a><span>|</span><a href="#40991373">prev</a><span>|</span><a href="#40989795">next</a><span>|</span><label class="collapse" for="c-40992953">[-]</label><label class="expand" for="c-40992953">[1 more]</label></div><br/><div class="children"><div class="content">the picture you&#x27;re painting here is absurdly far from reality<p>— kernighan definitely did not think hash tables were &#x27;a bit exotic&#x27; in 01978 —<p>hash tables (or sometimes other associative retrieval structures) were standard fare in computer science degree programs and were a standard feature of compilers, assemblers, and linkers, of which kernighan had written several at that point; associative retrieval structures are also fundamental to databases and filesystems.  in 01979, 7th edition unix (in which kernighan published awk) barely had date formatting but included an on-disk hash table library called &#x27;dbm&#x27;<p>hash tables are the exclusive topic of pp. 506–549 of knuth&#x27;s taocp volume 3, a standard textbook which came out in 01973.  after recommending you some hash functions, on p. 512 (525&#x2F;739) knuth recommends you check out a survey of hash functions published in cacm by lum, yuen, and dodd in 01971, and he cites papers on hashing in cacm as early as 01959 and in an ibm journal as early as 01957.  in the &#x27;history&#x27; section (pp. 540–542 (553–555&#x2F;739)) he traces it back to an internal ibm report by luhn in 01953, and its first report in the open literature to a paper by dumey in 01956.  most of the rest of the 739-page book is about how to implement associative arrays of various kinds, although some parts instead concern the string search problem, and the first half is about sorting, and a sorted table can be used for purposes other than associative retrieval<p>knuth also mentions a &#x27;very influential survey&#x27; of hashing published in cacm in 01968 by robert morris, kernighan&#x27;s coworker at bell labs, and one of the very first users of unix and a major contributor to it<p>there are several papers about hashing every year in cacm throughout the 01970s, as well as alternative associative-array structures such as tries, sorted arrays and binary search trees.  in march 01975 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;the-algorithm-sequential-access-method&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;the-algorithm-sequential-acces...</a>, in april 01975 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;the-quadratic-hash-method-when-the-table-size-is-not-a-prime-number&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;the-quadratic-hash-method-when...</a>, in may 01975 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;analysis-and-performance-of-inverted-data-base-structures&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;analysis-and-performance-of-in...</a>, in july 01975 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-note-on-hash-linking&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-note-on-hash-linking&#x2F;</a>, in september 01975 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;multidimensional-binary-search-trees-used-for-associative-searching&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;multidimensional-binary-search...</a>, in october 01975 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;optimizing-the-performance-of-a-relational-algebra-database-interface&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;optimizing-the-performance-of-...</a> and <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;merging-with-parallel-processors&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;merging-with-parallel-processo...</a>, in january 01976 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;performance-of-height-balanced-trees&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;performance-of-height-balanced...</a>, in february 01976 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;on-self-organizing-sequential-search-heuristics&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;on-self-organizing-sequential-...</a> and <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-stochastic-evaluation-model-for-database-organizations-in-data-retrieval-systems&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-stochastic-evaluation-model-...</a>, in june 01976 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-practitioners-guide-to-addressing-algorithms&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-practitioners-guide-to-addre...</a> (which is about hashing despite the name), in july 01976 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;compressed-tries&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;compressed-tries&#x2F;</a>, and in august 01976 we have <a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;an-insertion-technique-for-one-sided-height-balanced-trees&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;an-insertion-technique-for-one...</a>.  you could not read cacm in the 01960s and 01970s without frequently coming across hashing, as well as other associative-array structures.<p>but perhaps kernighan hadn&#x27;t read cacm?  on the contrary, he and his colleagues regularly published in it; he published in cacm once in 01972, once in 01973, and once in 01975, and his colleagues such as stephen johnson, mike lesk, al aho (his coauthor on awk), and, as i said above, robert morris, published there regularly as well<p>in <i>the practice of programming</i>, kernighan and pike claim that almost all of the time, the only data structures you need are arrays, linked lists, trees, and hash tables (though they wrote this in 01999)<p>what kernighan is talking about here is including them as a basic language construct, a design choice his 01978 tech report on awk likens to that of snobol4, which was a well-known language but not a mainstream one.  in the context of the above cacm articles, you can perhaps see that the daring choice was to offer a single &#x27;good enough&#x27; hash table implementation rather than one optimized for a given purpose—and to use it even in place of conventional arrays<p>— kernighan was not isolated like you were —<p>kernighan was at bell labs, which was probably the most connected place in the software world at the time<p>when awk was released in 01979 the internet was already ten years old, and at&amp;t (the parent company of bell labs) had installed all its long-distance links<p>in 01976 they&#x27;d also developed their own &#x27;internet&#x27; called uucp, which at the time of awk&#x27;s release was interconnecting 80 different unix sites, interchanging software updates on a daily basis, over 300-baud and 1200-baud modems.  they were also in  contact with ken thompson&#x27;s alma mater berkeley; thompson took a sabbatical year to teach there in 01975.  berkeley got a darpa contract to add tcp&#x2F;ip support to the bell labs operating system &#x27;unix&#x27;, which would become the majority of the internet during the 01980s; berkeley participated actively in the uucp network<p>bell labs was also working on the so-called &#x27;advanced communication system&#x27;, its own misconceived version of the internet, where data would be routed using phone numbers, because data communications had become the fastest-growing source of call traffic.  (colin berkshire has written a fantastic overview of this forgotten history.)</div><br/></div></div><div id="40989795" class="c"><input type="checkbox" id="c-40989795" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40989507">parent</a><span>|</span><a href="#40992953">prev</a><span>|</span><a href="#40989334">next</a><span>|</span><label class="collapse" for="c-40989795">[-]</label><label class="expand" for="c-40989795">[1 more]</label></div><br/><div class="children"><div class="content">I totally get the first point, but this comment from Brian was made when the internet had been available for many, many years. It seems more like it felt newish at the time, and that is how he has seen it since then. I guess that&#x27;s more why I find it to be an interesting comment.<p>Regarding the second point, when I hear the term &quot;associative arrays&quot; or &quot;associative lists&quot; I think of them in a pretty high level of abstraction. Like really: a C struct is an association abstraction. A simple array of structs is not often considered an &quot;associative array&quot;, but it can easily be used for the same things.<p>Maybe it would be more accurate to say that the way they were using associative arrays way newish, rather than the construct itself.</div><br/></div></div></div></div><div id="40989334" class="c"><input type="checkbox" id="c-40989334" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#40989213">parent</a><span>|</span><a href="#40989507">prev</a><span>|</span><a href="#40991239">next</a><span>|</span><label class="collapse" for="c-40989334">[-]</label><label class="expand" for="c-40989334">[1 more]</label></div><br/><div class="children"><div class="content">This is from the first edition free PDF online of <i>The AWK Programming Language</i>:<p>&quot;Associative arrays were inspired by SNOBOL4 tables, although they are not 
as general. Awk was born on a slow machine with a small memory, and the 
properties of arrays were a result of that environment. Restricting subscripts to 
be strings is one manifestation, as is the restriction to a single dimension (even 
with syntactic sugar). A more general implementation would 
allow multi-dimensional arrays, or at least allow arrays to be array elements.&quot;<p>Stable release - SNOBOL4 &#x2F; 1967<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SNOBOL" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SNOBOL</a></div><br/></div></div><div id="40991239" class="c"><input type="checkbox" id="c-40991239" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#40989213">parent</a><span>|</span><a href="#40989334">prev</a><span>|</span><a href="#40990055">next</a><span>|</span><label class="collapse" for="c-40991239">[-]</label><label class="expand" for="c-40991239">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp, of course, has built in hash tables. MacLisp doesn&#x27;t seem to - I didn&#x27;t see anything about them in the Pitmanual. ZetaLisp&#x2F;LML and InterLisp have them. So it seems like built in lisp associative arrays (I&#x27;m not counting alists, or property lists, though the latter goes back to the early days and maybe should be) are roughly contemporary to the birth of awk. Maybe a bit newer.</div><br/></div></div><div id="40990055" class="c"><input type="checkbox" id="c-40990055" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989213">parent</a><span>|</span><a href="#40991239">prev</a><span>|</span><a href="#40989604">next</a><span>|</span><label class="collapse" for="c-40990055">[-]</label><label class="expand" for="c-40990055">[4 more]</label></div><br/><div class="children"><div class="content">in a sense lisp alists are &#x27;associative arrays&#x27;, sure.  but, although they were used in the metacircular interpreter that bootstrapped lisp and still inspires us today, they aren&#x27;t a language feature, and the lisp ones aren&#x27;t efficient enough for the things you use them for in awk<p>you can of course build an associative array in any language, especially if you&#x27;re satisfied with the linear search used by lisp alists.  you can hack one together in a few minutes almost without thinking:<p><pre><code>            .intel_syntax noprefix
    lookup: push rbx
            push rbp
            mov rbx, rdi    # pointer to alist node pointer
            mov rbp, rsi    # key
        2:  mov rdi, [rbx]  # load pointer to alist node
            test rdi, rdi   # is it null?
            jnz 3f          # if not null, skip not-found case
            mov rax, rbx    # pointer to null pointer is return value
            xor rdx, rdx    # but associated value is null (sets zero flag)
            jmp 4f          # jump to shared epilogue
        3:  mov rdi, [rdi]  # load pointer from key field of alist node
            mov rsi, rbp    # reload key from callee-saved register
            call comkey     # sets zero flag if rsi and rdi are equal keys
            jne 1f          # skip following return-value case code if !=
            mov rax, rbx    # pointer to node pointer is return value
            mov rdx, [rbx]  # also let’s follow that pointer to the node
            mov rdx, [rdx + 16]    # and return its value field too in rdx
            test rax, rax   # clear zero flag (valid pointer is not null)
        4:  pop rbp
            pop rbx
            ret
        1:  mov rbx, [rbx]  # load pointer to alist node again
            add rbx, 8      # load pointer to next-node pointer field
            jmp 2b
</code></pre>
(untested, let me know if you find bugs)<p>but that&#x27;s very different from having them built in as a language feature, like snobol4, mumps, awk, perl, python, tcl, lua, and js do.  the built-in language feature lisp had for structuring data 20 years earlier was cons, car, and cdr, which is not at all the same thing<p>other programs on unix that contained associative arrays prior to awk included the linker (for symbols), the c compiler, the assembler, the kernel (in the form of directories in the filesystem), and the shell, for shell variables.  none of these had associative arrays as a programming language feature, though.  the bourne shell came closest in that you could concatenate variable names and say things like<p><pre><code>     eval myarray_$key=$val
</code></pre>
here&#x27;s the implementation of binary tree traversal for setting shell variables in the v7 bourne shell from 01979<p><pre><code>    NAMPTR          lookup(nam)
            REG STRING      nam;
    {
            REG NAMPTR      nscan=namep;
            REG NAMPTR      *prev;
            INT             LR;

            IF !chkid(nam)
            THEN    failed(nam,notid);
            FI
            WHILE nscan
            DO      IF (LR=cf(nam,nscan-&gt;namid))==0
                    THEN    return(nscan);
                    ELIF LR&lt;0
                    THEN    prev = &amp;(nscan-&gt;namlft);
                    ELSE    prev = &amp;(nscan-&gt;namrgt);
                    FI
                    nscan = *prev;
            OD

            &#x2F;* add name node *&#x2F;
            nscan=alloc(sizeof *nscan);
            nscan-&gt;namlft=nscan-&gt;namrgt=NIL;
            nscan-&gt;namid=make(nam);
            nscan-&gt;namval=0; nscan-&gt;namflg=N_DEFAULT; nscan-&gt;namenv=0;
            return(*prev = nscan);
    }
</code></pre>
if you&#x27;re not sure, that&#x27;s c (now you know where the ioccc came from)</div><br/><div id="40990506" class="c"><input type="checkbox" id="c-40990506" checked=""/><div class="controls bullet"><span class="by">foobarian</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40990055">parent</a><span>|</span><a href="#40992375">next</a><span>|</span><label class="collapse" for="c-40990506">[-]</label><label class="expand" for="c-40990506">[1 more]</label></div><br/><div class="children"><div class="content">I love that Bourne abused C macros to make sh source look like Algol.  Lots of references to this elsewhere but this is my favorite:<p><a href="https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;sh&#x2F;mac.h" rel="nofollow">https:&#x2F;&#x2F;www.tuhs.org&#x2F;cgi-bin&#x2F;utree.pl?file=V7&#x2F;usr&#x2F;src&#x2F;cmd&#x2F;sh...</a></div><br/></div></div><div id="40992375" class="c"><input type="checkbox" id="c-40992375" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40990055">parent</a><span>|</span><a href="#40990506">prev</a><span>|</span><a href="#40989604">next</a><span>|</span><label class="collapse" for="c-40992375">[-]</label><label class="expand" for="c-40992375">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;killer feature&quot; of alists is that they are persistent data structures; when we extend a shorter alist to make a longer one, the shorter one is unaffected. Moreover, if the program has only a reference to the tail portion of a longer alist, the head portion can be garbage-collected.<p>With this, we can correctly implement lexical closures: we simply take the current environment (head of the alist) ssociate it with the lambda body and arguments, and we are done.</div><br/><div id="40992466" class="c"><input type="checkbox" id="c-40992466" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989213">root</a><span>|</span><a href="#40992375">parent</a><span>|</span><a href="#40989604">next</a><span>|</span><label class="collapse" for="c-40992466">[-]</label><label class="expand" for="c-40992466">[1 more]</label></div><br/><div class="children"><div class="content">yes!  also when you only have two or three things in them, they are faster than hashing, especially on machines without a data cache.  clojure uses hamts for this, thus getting this fp-persistence† as well as efficient lookup in large dictionaries, and chris wellons posted a concise, fast c hamt implementation last year at <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;30&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2023&#x2F;09&#x2F;30&#x2F;</a><p>______<p>† &#x27;persistent&#x27; unfortunately also means &#x27;stored in nonvolatile memory&#x27;, so i feel the need to disambiguate</div><br/></div></div></div></div></div></div></div></div><div id="40989604" class="c"><input type="checkbox" id="c-40989604" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40989213">prev</a><span>|</span><a href="#40991494">next</a><span>|</span><label class="collapse" for="c-40989604">[-]</label><label class="expand" for="c-40989604">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very taken with the regex to lex to yacc to awk sequence of developments. There&#x27;s a very convincing sense of building on prior work to achieve more general results.</div><br/></div></div><div id="40991494" class="c"><input type="checkbox" id="c-40991494" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#40989604">prev</a><span>|</span><a href="#40989040">next</a><span>|</span><label class="collapse" for="c-40991494">[-]</label><label class="expand" for="c-40991494">[4 more]</label></div><br/><div class="children"><div class="content">People will hate me for saying this, but I bet there are many many repos on github written by programmers that are better than all these coding legends. Back then, it was a much smaller pool.</div><br/><div id="40991507" class="c"><input type="checkbox" id="c-40991507" checked=""/><div class="controls bullet"><span class="by">azemetre</span><span>|</span><a href="#40991494">parent</a><span>|</span><a href="#40993080">prev</a><span>|</span><a href="#40991888">next</a><span>|</span><label class="collapse" for="c-40991507">[-]</label><label class="expand" for="c-40991507">[1 more]</label></div><br/><div class="children"><div class="content">Anyone in particular you would you consider great? Always neat to follow the careers or happenings of the new blood.</div><br/></div></div><div id="40991888" class="c"><input type="checkbox" id="c-40991888" checked=""/><div class="controls bullet"><span class="by">funemployd</span><span>|</span><a href="#40991494">parent</a><span>|</span><a href="#40991507">prev</a><span>|</span><a href="#40989040">next</a><span>|</span><label class="collapse" for="c-40991888">[-]</label><label class="expand" for="c-40991888">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anyone ever claimed Brian Kernighan was the best programmer ever.</div><br/></div></div></div></div><div id="40989040" class="c"><input type="checkbox" id="c-40989040" checked=""/><div class="controls bullet"><span class="by">kansai</span><span>|</span><a href="#40991494">prev</a><span>|</span><a href="#40989030">next</a><span>|</span><label class="collapse" for="c-40989040">[-]</label><label class="expand" for="c-40989040">[26 more]</label></div><br/><div class="children"><div class="content">Describing the K of K&amp;R as &quot;Awk creator&quot; is like describing Einstein as a &quot;refrigerator engineer&quot;.</div><br/><div id="40989102" class="c"><input type="checkbox" id="c-40989102" checked=""/><div class="controls bullet"><span class="by">overhead4075</span><span>|</span><a href="#40989040">parent</a><span>|</span><a href="#40990099">next</a><span>|</span><label class="collapse" for="c-40989102">[-]</label><label class="expand" for="c-40989102">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an awk interview. &quot;Awk creator&quot; is relevant.</div><br/><div id="40989803" class="c"><input type="checkbox" id="c-40989803" checked=""/><div class="controls bullet"><span class="by">felideon</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40989102">parent</a><span>|</span><a href="#40989584">next</a><span>|</span><label class="collapse" for="c-40989803">[-]</label><label class="expand" for="c-40989803">[6 more]</label></div><br/><div class="children"><div class="content">Right, the headline gave the appropriate context for the interview in a short sentence. Not everyone knows Kernighan created awk, as opposed to a respected person that happens to have opinions on awk.</div><br/><div id="40989873" class="c"><input type="checkbox" id="c-40989873" checked=""/><div class="controls bullet"><span class="by">Gormo</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40989803">parent</a><span>|</span><a href="#40989584">next</a><span>|</span><label class="collapse" for="c-40989873">[-]</label><label class="expand" for="c-40989873">[5 more]</label></div><br/><div class="children"><div class="content">AWK&#x27;s name is actually an initialism of the last names of its three creators: Aho, Weinberger, and Kernighan.</div><br/><div id="40990284" class="c"><input type="checkbox" id="c-40990284" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40989873">parent</a><span>|</span><a href="#40989584">next</a><span>|</span><label class="collapse" for="c-40990284">[-]</label><label class="expand" for="c-40990284">[4 more]</label></div><br/><div class="children"><div class="content">Aho, one of the authors of the dragon books. When I studied CS 40 years ago it was given standard literature on compiler construction, a mandatory course.<p>No idea whether it is still used today. Well, no idea whether there is anything fundamentally new in compilers such an old book would not cover.</div><br/><div id="40991892" class="c"><input type="checkbox" id="c-40991892" checked=""/><div class="controls bullet"><span class="by">funemployd</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990284">parent</a><span>|</span><a href="#40990470">next</a><span>|</span><label class="collapse" for="c-40991892">[-]</label><label class="expand" for="c-40991892">[2 more]</label></div><br/><div class="children"><div class="content">There are plenty of advanced compiler techniques, but you can&#x27;t understand them until you understand the fundamentals. There will always be a place for the purple dragon book.</div><br/><div id="40993053" class="c"><input type="checkbox" id="c-40993053" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40991892">parent</a><span>|</span><a href="#40990470">next</a><span>|</span><label class="collapse" for="c-40993053">[-]</label><label class="expand" for="c-40993053">[1 more]</label></div><br/><div class="children"><div class="content">Ah, it&#x27;s purple now. It was green when I studied, became red before I graduated. When I search for it now the thumbnails look unfamiliar.</div><br/></div></div></div></div><div id="40990470" class="c"><input type="checkbox" id="c-40990470" checked=""/><div class="controls bullet"><span class="by">ryangs</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990284">parent</a><span>|</span><a href="#40991892">prev</a><span>|</span><a href="#40989584">next</a><span>|</span><label class="collapse" for="c-40990470">[-]</label><label class="expand" for="c-40990470">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, still in use. Also presumably the Aho of the Aho-Corasick string matching algorithm.</div><br/></div></div></div></div></div></div></div></div><div id="40989584" class="c"><input type="checkbox" id="c-40989584" checked=""/><div class="controls bullet"><span class="by">riiii</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40989102">parent</a><span>|</span><a href="#40989803">prev</a><span>|</span><a href="#40989261">next</a><span>|</span><label class="collapse" for="c-40989584">[-]</label><label class="expand" for="c-40989584">[1 more]</label></div><br/><div class="children"><div class="content">He didn&#x27;t say it was irrelevant.</div><br/></div></div><div id="40989261" class="c"><input type="checkbox" id="c-40989261" checked=""/><div class="controls bullet"><span class="by">midiguy</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40989102">parent</a><span>|</span><a href="#40989584">prev</a><span>|</span><a href="#40990099">next</a><span>|</span><label class="collapse" for="c-40989261">[-]</label><label class="expand" for="c-40989261">[1 more]</label></div><br/><div class="children"><div class="content">I agree it was an incredibly awkward interview</div><br/></div></div></div></div><div id="40990099" class="c"><input type="checkbox" id="c-40990099" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#40989040">parent</a><span>|</span><a href="#40989102">prev</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40990099">[-]</label><label class="expand" for="c-40990099">[12 more]</label></div><br/><div class="children"><div class="content">Why do you say that? developing Awk was no less of an accomplishment than C.</div><br/><div id="40990485" class="c"><input type="checkbox" id="c-40990485" checked=""/><div class="controls bullet"><span class="by">alexthehurst</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990099">parent</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40990485">[-]</label><label class="expand" for="c-40990485">[11 more]</label></div><br/><div class="children"><div class="content">This seems like a rather large claim that would benefit from some kind of supporting argument.</div><br/><div id="40990527" class="c"><input type="checkbox" id="c-40990527" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990485">parent</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40990527">[-]</label><label class="expand" for="c-40990527">[10 more]</label></div><br/><div class="children"><div class="content">c-descended languages include c++, java, and c#<p>awk-descended languages include perl, tcl, js, python and lua<p>it&#x27;s a close race but if i had to pick i&#x27;d say the second group is more influential</div><br/><div id="40991268" class="c"><input type="checkbox" id="c-40991268" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990527">parent</a><span>|</span><a href="#40991623">next</a><span>|</span><label class="collapse" for="c-40991268">[-]</label><label class="expand" for="c-40991268">[2 more]</label></div><br/><div class="children"><div class="content">Most implementations of that second group of languages are written in C, and run on operating systems written in C. It&#x27;s really no contest that C has had far more of an influence on computing. So much software would not exist, or not in the forms we recognize, without it.</div><br/><div id="40991458" class="c"><input type="checkbox" id="c-40991458" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40991268">parent</a><span>|</span><a href="#40991623">next</a><span>|</span><label class="collapse" for="c-40991458">[-]</label><label class="expand" for="c-40991458">[1 more]</label></div><br/><div class="children"><div class="content">or at least in c++, c#, or java, sure, smalltalk being the main exception<p>but the layers are somewhat orthogonal.  at the verilog level you can&#x27;t really tell if your hardware is built out of luts, cmos standard cells, hand-laid-out nmos, ttl, or vacuum tubes; at the operating system level you can&#x27;t really tell if your cpu was designed in vhdl, verilog, chisel, or hand-drawn schematics; at the interpreter level you can&#x27;t really tell if your operating system was written in c, pl&#x2F;x, assembly, or lisp; and at the python level you can&#x27;t really tell if you&#x27;re running on cpython (which is written in c) or pypy (which is written in python)<p>i mean there are small clues that make it hard to completely hide, but they&#x27;re subtle<p>so, to my way of thinking, saying &#x27;c has had far more of an influence on computing than awk&#x27;, on the basis that awk was written in c, is similar to saying &#x27;transistors have had far more of an influence on computing than c&#x27;.  it&#x27;s sort of true, but it&#x27;s also sort of false</div><br/></div></div></div></div><div id="40991623" class="c"><input type="checkbox" id="c-40991623" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990527">parent</a><span>|</span><a href="#40991268">prev</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40991623">[-]</label><label class="expand" for="c-40991623">[7 more]</label></div><br/><div class="children"><div class="content">Python influenced by AWK? Never heard that before, and Wikipedia does not list awk among python&#x27;s numerous influences, either. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Python_(programming_language)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Python_(programming_language)</a></div><br/><div id="40991954" class="c"><input type="checkbox" id="c-40991954" checked=""/><div class="controls bullet"><span class="by">Qem</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40991623">parent</a><span>|</span><a href="#40992191">next</a><span>|</span><label class="collapse" for="c-40991954">[-]</label><label class="expand" for="c-40991954">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;x.com&#x2F;gvanrossum&#x2F;status&#x2F;1305529996383928320" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;gvanrossum&#x2F;status&#x2F;1305529996383928320</a></div><br/><div id="40992214" class="c"><input type="checkbox" id="c-40992214" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40991954">parent</a><span>|</span><a href="#40992191">next</a><span>|</span><label class="collapse" for="c-40992214">[-]</label><label class="expand" for="c-40992214">[1 more]</label></div><br/><div class="children"><div class="content">this says &#x27;abc, shell, awk&#x27;, but what is guido responding to?</div><br/></div></div></div></div><div id="40992191" class="c"><input type="checkbox" id="c-40992191" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40991623">parent</a><span>|</span><a href="#40991954">prev</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40992191">[-]</label><label class="expand" for="c-40992191">[4 more]</label></div><br/><div class="children"><div class="content">kernighan said in the interview<p>&gt; <i>The main idea in Awk was associative arrays, which were newish at the time, but which now show up in most languages either as library functions (hashmaps in Java or C++) or directly in the language (dictionaries in Perl and Python). Associative arrays are a very powerful construct, and can be used to simulate lots of other data structures.</i><p>awk was released in 01979, and the authors published this paper in sp&amp;e that year: <a href="https:&#x2F;&#x2F;plan9.io&#x2F;sources&#x2F;contrib&#x2F;steve&#x2F;other-docs&#x2F;awk.pdf" rel="nofollow">https:&#x2F;&#x2F;plan9.io&#x2F;sources&#x2F;contrib&#x2F;steve&#x2F;other-docs&#x2F;awk.pdf</a> but you see this report version is dated september 01978.  but i don&#x27;t think the report was widely circulated until the next year, when it was included in 7th edition unix as &#x2F;usr&#x2F;doc&#x2F;awk (sudo apt install groff; groff -ms -Tutf8 v7&#x2F;usr&#x2F;doc&#x2F;awk | less -r).  it explains:<p>&gt; <i>Array elements may be named by non-numeric
values, which gives awk a capability rather like the
associative memory of Snobol tables. (...) There is an alternate form of the for statement
which is suited for accessing the elements of an associative array:</i><p>this pdf has evidently been retypeset from the troff sources from the open-source 7th edition release, but without the correct bibliographic database, so the references are missing.  a comment in the troff source says:<p>&gt; <i>....It supersedes TM-77-1271-5, dated September 8, 1977.</i><p>but possibly that reference is inaccurate<p>python goes beyond merely having dicts &#x27;directly in the language&#x27;.  python&#x27;s primary data structure is the dict; among other things, it uses dicts for modules, (most) class instances, associating methods with classes, the locals() user interface to the local-variable namespace, and passing keyword arguments to functions and methods.  that is, it uses associative arrays to simulate lots of other data structures, as you are obliged to do in awk, lua, and js.  so where did python get dicts?<p>python got dicts (and tuples) from abc, a teaching language which wikipedia claims was started in 01987, 8 years after awk&#x27;s release, and added conventional arrays (lists) back in.  the five data types in abc <a href="https:&#x2F;&#x2F;homepages.cwi.nl&#x2F;~steven&#x2F;abc&#x2F;language.html" rel="nofollow">https:&#x2F;&#x2F;homepages.cwi.nl&#x2F;~steven&#x2F;abc&#x2F;language.html</a> are numbers, strings, compounds (called tuples in ml), lists (really multisets because they&#x27;re implicitly sorted), and tables (dictionaries), which are awk&#x27;s &#x27;associative arrays&#x27;—and, as in awk, js, lua, and tcl, they&#x27;re used to provide the functionality of conventional arrays as well<p>however, lambert meertens credits the use of tables in abc to jack schwartz&#x27;s setl <a href="https:&#x2F;&#x2F;inference-review.com&#x2F;article&#x2F;the-origins-of-python" rel="nofollow">https:&#x2F;&#x2F;inference-review.com&#x2F;article&#x2F;the-origins-of-python</a> rather than to awk.  he says of the addition of tables to b (the early name for abc, not to be confused with the b that was an earlier version of c)<p>&gt; <i>Having coded a few algorithms in SETL, I had experienced its power firsthand—a power that stemmed entirely from its high-level inbuilt data types. Particularly powerful were sets and maps, also known as “associative arrays,” containing data that can be indexed not only by consecutive integers but by arbitrary values. A programmer could introduce a simple database of quotations named whosaid, in which the value ”Descartes” could be stored in the location whosaid[”cogito ergo sum”]. These high-level types made it possible to express algorithms that required many steps in B1 using just a few steps in SETL. In a clear violation of the Fair-Expectation Rule, B1 allowed only integers as array indices. This design decision had been driven by fear: we had been concerned that aiming too high would make our language unimplementable on the small personal computers that were starting to appear on the market. But Dewar, in particular, convinced me that this meant we were designing for the past, not the future. This led us to redesign the system of data types for our beginners’ language. This time we used only the criteria of ease of learning and ease of use to select candidate systems. The winner turned out to be remarkably similar to the data type system of SETL. The set of possible data type systems to choose from was very large, and to make the process more manageable I had written a program to select the competitive (Pareto-optimal) candidate systems. Interestingly, but quite incidentally, that selection program itself was written in SETL. The winning type system became that of B2, and remained unchanged in the final iteration, released in 1985 under the name “ABC.”</i><p>&#x27;associative arrays&#x27;, of course, is the term used by awk<p>this story of adding associative arrays to abc only for b2 is somewhat complicated by the fact that the version of b (b1?) in meertens&#x27;s 01981 &#x27;draft proposal for the b programming language&#x27; <a href="https:&#x2F;&#x2F;ir.cwi.nl&#x2F;pub&#x2F;16732" rel="nofollow">https:&#x2F;&#x2F;ir.cwi.nl&#x2F;pub&#x2F;16732</a> already includes tables, three years after the release of awk as part of 7th edition; p. 6 (9&#x2F;91) says,<p>&gt; <i>Tables are somewhat like dictionaries.  A short English-Dutch dictionary (not sufficient to maintain a conversation) might be (...) Table entries, like entries in a dictionary, consist of two parts.  The first part is called the</i> key <i>, and the second part is called the</i> associate<i>.  All keys must be the same type of value, and similarly for associates.  A table may be written thus:</i> {[’I’]: 1; [’V’]: 5; [’X’]: 10}.<p>&gt; <i>If this table has been put in a target</i> roman<i>, then</i> roman[’X’] = 10.<p>note that this is also awk&#x27;s <i>syntax</i> for indexing an associative array, though it doesn&#x27;t have a syntax for writing one down.<p>(to be continued; hn says, &#x27;that comment included too many facts&#x27;)</div><br/><div id="40992194" class="c"><input type="checkbox" id="c-40992194" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40992191">parent</a><span>|</span><a href="#40992888">next</a><span>|</span><label class="collapse" for="c-40992194">[-]</label><label class="expand" for="c-40992194">[1 more]</label></div><br/><div class="children"><div class="content">a more recent set of slides on the relation between abc and python is <a href="https:&#x2F;&#x2F;www.cwi.nl&#x2F;documents&#x2F;195216&#x2F;Meertens-20191121.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cwi.nl&#x2F;documents&#x2F;195216&#x2F;Meertens-20191121.pdf</a> which describes again how abc was started in 01975.  this helpfully clarifies the timeline: b0 was 01975; b1 was 01978; b2 was 01979; and b∞ = abc was 01985.  so specifically the point at which setl inspired the replacement of conventional arrays in b1 with associative arrays in b2 was 01979, which was the year 7th edition unix was released and the aho, weinberger, and kernighan paper was published in sp&amp;e<p>a question of some interest to me here is what platform they were developing abc on in 01979.  clearly it couldn&#x27;t have been the ibm pc, which wouldn&#x27;t come out until 01983 (and as far as i know abc on the ibm pc only runs under cygwin or 32-bit microsoft windows), or macos (which came out in 01984) or atari tos, which wouldn&#x27;t come out until 01985.  and so far i haven&#x27;t seen any mention in the history of abc of other operating systems of the time like cp&#x2F;m, vm&#x2F;cms, dg rdos, tenex, or tops-20.  the most likely platform would seem to have been unix, on which awk was one of the relatively few programming languages available.  perhaps at some point i&#x27;ll run across an answer to that question in the abc papers<p>python adopted awk&#x27;s syntax for putting 10 into roman[&#x27;x&#x27;], which was `put 10 in roman[&#x27;x&#x27;]` in abc, but `roman[&#x27;x&#x27;] = 10` in awk and python.  abc&#x27;s syntax is uppercase, presumably case-insensitive, separates words with apostrophes, and departs widely from conventional infix syntax.  python&#x27;s syntax is case-sensitive, mostly lowercase, and conventionally infix, features that have become common through the influence of unix.  python&#x27;s control structures are for, while, and if&#x2F;elif&#x2F;else, as in algol and in abc, and indentation-sensitive as in abc, but uses a conventional ascii syntax rather than abc&#x27;s scratch-like syntax-directed editor<p>abc was statically typed with a hindley-milner type system (&#x27;the type system is similar to that of lcf&#x27;, p. 15 (18&#x2F;91) of the draft proposal), while python is dynamically typed, like smalltalk, lisp, and awk<p>if meertens got his daring notion of storing everything in associative arrays from awk, he certainly doesn&#x27;t mention it.  instead he mentions setl a lot!  the draft proposal doesn&#x27;t cite awk but it also doesn&#x27;t cite setl; it cites the algol-68 report, milner&#x27;s lcf typing paper, a cleaveland and uzgalis paper about grammars, gehani, and three of his own papers, from 01976, 01978, and 01981.  unfortunately i can&#x27;t find any of those earlier meertens papers online<p>the wikipedia page about setl says<p>&gt; <i>SETL provides two basic aggregate data types: (unordered) sets, and tuples.[1][2][5] The elements of sets and tuples can be of any arbitrary type, including sets and tuples themselves, except the undefined value om[1] (sometimes capitalized: OM).[6] Maps are provided as sets of pairs (i.e., tuples of length 2) and can have arbitrary domain and range types.[1][5]</i><p>but it&#x27;s citing papers about setl from 01985 there, well after awk had supposedly popularized the notion of associative arrays<p>however, in meertens&#x27;s essay on python&#x27;s history, he cites a 01975 paper on setl!  <a href="https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;SETL&#x2F;setl&#x2F;doc&#x2F;Schwartz_et_al-On_Programming_SETL_Interim_Report-1975.pdf&#x2F;view" rel="nofollow">https:&#x2F;&#x2F;www.softwarepreservation.org&#x2F;projects&#x2F;SETL&#x2F;setl&#x2F;doc&#x2F;...</a><p>&gt; <i>Jacob T. Schwartz. ON PROGRAMMING: An Interim Report on the SETL Project. Part I: Generalities; Part II: The SETL Language and Examples of Its Use. Computer Science Department, Courant Institute of Mathematical Sciences, New York University, revised June 1975.</i><p>this discusses how setl represented data in memory starting on p. 57 (57&#x2F;689).  it used hash tables to represent sets, including sets of tuples, rather than the ill-advised balanced-tree approach used by abc.  (python, like awk and setl, uses hash tables.)  on pp. 62–63 (62–63&#x2F;689) it explains:<p>&gt; <i>The hash code of a tuple is taken to be the hash code of
its first component, for reasons that will become clear in the
next section. The hash code of a set is the exclusive or of
the hash codes of all its members. (...)</i><p>&gt; <i>— Tuples in Sets —</i><p>&gt; <i>Though expressible in terms of the membership test, &quot;with&quot;, and
&quot;less&quot; operations, functional evaluation plays so important a role
in SETL algorithms that we treat it as a primitive.</i><p>&gt; <i>SETL makes three types of set-related functional evaluation
operators available:</i><p>&gt; - <i>f(x)</i><p>&gt; - <i>f{x}</i><p>&gt; - <i>f[s]</i><p>&gt; <i>The most fundamental of these is f{x}, which invokes a search
over f for all n-tuples that begin with x (n ≥ 2), and which
yields as result the set of all tails of these n-tuples. More
precisely, in SETL:</i><p>&gt; <i>f{x} = if #y eq 2 then y(2) else tℓ y, y ∈ f | type y eq tupl and #y ge 2 and hd y eq x}</i><p>&gt; <i>The operation f(x) has a similar definition but includes a single valuedness check:</i><p>&gt; <i>f(x) = if #f{x} eq 1 then ∋f{x} else Ω</i><p>&gt; <i>The operation f[s] is adequately defined in terms of f{x}:</i><p>&gt; <i>f[s] = [+: x ∈ s] f{x}</i><p>i am fairly confident that the f{x} definition translates into current vernacular python as the set-comprehension {y[2] if len(y) == 2 else y[1:] for y in f if type(y) == tuple and len(y) &gt;= 2 and y[0] == x}.<p>so, it becomes clear that already in 01975 setl treated sets of tuples as maps, which is to say associative arrays, but it didn&#x27;t use the &#x27;associative array&#x27; terminology used by meertens in 01981, or for that matter &#x27;maps&#x27;.  to look up an element in the map, it didn&#x27;t use the f[x] notation used by python, awk, and abc; instead it used f(x).  further explanation on pp. 64–65 (64–65&#x2F;689) clarifies that really it is more accurate to think of &#x27;sets of tuples&#x27; as trees; each item in the tuple entails following an additional level of pointers to a further hash table<p>(in a number of other notational details, python and presumably abc follows setl: start: or start:end for array index ranges, + for string concatenation, * for string repetition, boolean operators spelled out as and, or, and not.  but indexing maps is far from the only difference)<p>abc (including b as described in the 01981 report) also seems to lack the f{x} operation and its possibility of associating an arbitrary-sized set of values with each key.  this is a nontrivial semantic divergence<p>so if abc got its idea of tables from setl, but used awk&#x27;s terminology, notation, and semantics for them (and its own ill-conceived balanced-tree implementation, used by neither), and decided to adopt the table idea in the year when awk was released, probably on the platform that awk was released on, i think it&#x27;s reasonable to assign some share of the credit for abc&#x27;s tables to awk?  even if not all of it<p>but if that&#x27;s so, then why didn&#x27;t meertens credit aho, weinberger, and kernighan?  i don&#x27;t know.  maybe awk&#x27;s loosey-goosey nature was repugnant to him.  maybe weinberger is jewish and meertens is secretely anti-semitic.  maybe meertens thought that awk&#x27;s loosey-goosey nature would be repugnant to the dijkstra-honoring dutch computer science establishment.  maybe aho insulted meertens&#x27;s favorite beer one time when he visited the netherlands.  or maybe he thought it would be unfair for aho, weinberger, and kernighan to steal the thunder of schwartz, who did after all precede them in developing a general-purpose language whose memory was based entirely on hash tables.  from a certain point of view that would be like crediting carl sagan with the theory of relativity because he explained it on nova</div><br/></div></div><div id="40992888" class="c"><input type="checkbox" id="c-40992888" checked=""/><div class="controls bullet"><span class="by">carapace</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40992191">parent</a><span>|</span><a href="#40992194">prev</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40992888">[-]</label><label class="expand" for="c-40992888">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The set of possible data type systems to choose from was very large, and to make the process more manageable I had written a program to select the competitive (Pareto-optimal) candidate systems. Interestingly, but quite incidentally, that selection program itself was written in SETL.<p>Wow, now <i>that</i> I&#x27;d like to see.<p>Awesome and informative comments, cheers!</div><br/><div id="40992956" class="c"><input type="checkbox" id="c-40992956" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40992888">parent</a><span>|</span><a href="#40990105">next</a><span>|</span><label class="collapse" for="c-40992956">[-]</label><label class="expand" for="c-40992956">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;m glad they were helpful!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40990105" class="c"><input type="checkbox" id="c-40990105" checked=""/><div class="controls bullet"><span class="by">1234554321a</span><span>|</span><a href="#40989040">parent</a><span>|</span><a href="#40990099">prev</a><span>|</span><a href="#40990186">next</a><span>|</span><label class="collapse" for="c-40990105">[-]</label><label class="expand" for="c-40990105">[2 more]</label></div><br/><div class="children"><div class="content">He’s the closest man to C still alive. Yet it’s not really “his” accomplishment. C was created by Ritchie alone, Kernighan only wrote the book.</div><br/><div id="40990183" class="c"><input type="checkbox" id="c-40990183" checked=""/><div class="controls bullet"><span class="by">aap_</span><span>|</span><a href="#40989040">root</a><span>|</span><a href="#40990105">parent</a><span>|</span><a href="#40990186">next</a><span>|</span><label class="collapse" for="c-40990183">[-]</label><label class="expand" for="c-40990183">[1 more]</label></div><br/><div class="children"><div class="content">I would say Ken Thompson and Steve Johnson are the closer.</div><br/></div></div></div></div><div id="40990186" class="c"><input type="checkbox" id="c-40990186" checked=""/><div class="controls bullet"><span class="by">audleman</span><span>|</span><a href="#40989040">parent</a><span>|</span><a href="#40990105">prev</a><span>|</span><a href="#40990646">next</a><span>|</span><label class="collapse" for="c-40990186">[-]</label><label class="expand" for="c-40990186">[1 more]</label></div><br/><div class="children"><div class="content">I read this comment in the spirit of &quot;you might not have known that K did much more that write awk, but he&#x27;s a genius.&quot; Which I didn&#x27;t know, so I appreciate the context.</div><br/></div></div></div></div><div id="40989030" class="c"><input type="checkbox" id="c-40989030" checked=""/><div class="controls bullet"><span class="by">fuzzy_biscuit</span><span>|</span><a href="#40989040">prev</a><span>|</span><a href="#40990210">next</a><span>|</span><label class="collapse" for="c-40989030">[-]</label><label class="expand" for="c-40989030">[3 more]</label></div><br/><div class="children"><div class="content">I know the title said brief, but it still took me by surprise that there were only three questions.</div><br/><div id="40990430" class="c"><input type="checkbox" id="c-40990430" checked=""/><div class="controls bullet"><span class="by">phatfish</span><span>|</span><a href="#40989030">parent</a><span>|</span><a href="#40990648">next</a><span>|</span><label class="collapse" for="c-40990430">[-]</label><label class="expand" for="c-40990430">[1 more]</label></div><br/><div class="children"><div class="content">No excuses not to read the whole article before commenting this time!</div><br/></div></div></div></div></div></div></div></div></div></body></html>