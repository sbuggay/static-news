<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736931675383" as="style"/><link rel="stylesheet" href="styles.css?v=1736931675383"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.dgt.is/blog/2025-01-10-nix-death-by-a-thousand-cuts/">Nix – Death by a Thousand Cuts</a> <span class="domain">(<a href="https://www.dgt.is">www.dgt.is</a>)</span></div><div class="subtext"><span>jonotime</span> | <span>188 comments</span></div><br/><div><div id="42708815" class="c"><input type="checkbox" id="c-42708815" checked=""/><div class="controls bullet"><span class="by">choobacker</span><span>|</span><a href="#42703647">next</a><span>|</span><label class="collapse" for="c-42708815">[-]</label><label class="expand" for="c-42708815">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a NixOS user and contributor.<p>This post is fair.<p>Nix is very flexible, and it hasn&#x27;t yet stabilised on a firm set of recommendations for a happy path.<p>Going on a whim:<p>* Use nixos-unstable. It&#x27;s defacto stable, and gets much more attention than nixos-stable.<p>* Use flakes.<p>* Don&#x27;t use multiple versions of nixpkgs. In the rare case a package is failing to build, then raise an issue, or wait, or rollback.<p>* On NixOS, don&#x27;t use user profiles. They won&#x27;t interop in the way OP hopes.<p>* Only use nixpkgs. If you absolutely must use another flake, only use popular ones from <a href="https:&#x2F;&#x2F;github.com&#x2F;nix-community">https:&#x2F;&#x2F;github.com&#x2F;nix-community</a>.<p>But until the community give opinionated suggestions, users will stray towards bad practices.<p>(Also, no need to mix pipewire and jack. Pipewire can emulate jack.)</div><br/></div></div><div id="42703647" class="c"><input type="checkbox" id="c-42703647" checked=""/><div class="controls bullet"><span class="by">Baeocystin</span><span>|</span><a href="#42708815">prev</a><span>|</span><a href="#42702543">next</a><span>|</span><label class="collapse" for="c-42703647">[-]</label><label class="expand" for="c-42703647">[44 more]</label></div><br/><div class="children"><div class="content">The older I get, the more I realize that so much of the divide in the tech field is simply between the two camps of &quot;the tools are the interesting part&quot; vs &quot;getting things done with the tools is the interesting part&quot;.</div><br/><div id="42704575" class="c"><input type="checkbox" id="c-42704575" checked=""/><div class="controls bullet"><span class="by">pkkm</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42703728">next</a><span>|</span><label class="collapse" for="c-42704575">[-]</label><label class="expand" for="c-42704575">[8 more]</label></div><br/><div class="children"><div class="content">Your veiled implication that Nix and NixOS aren&#x27;t about &quot;getting things done&quot; is, I think, more than a little unfair. I&#x27;m using multiple programming languages at work. Each one of them has its own dependency manager that does basically the same job as the other ones. In Python it&#x27;s Poetry, in Ruby it&#x27;s Bundler, in JavaScript it&#x27;s npm&#x2F;yarn, in PHP it&#x27;s Composer, etc. A lot of projects require extra setup steps outside of the dependency manager. It&#x27;s not a good experience that lets you get up and running quickly. And my situation with scripting languages isn&#x27;t the worst case: God help you if you have dependencies between projects in AOT compiled languages that use different dependency managers.<p>Of course, the standard answer is to spin up a ton of Docker containers. Docker works, but it looks to me like a local optimum rather than a truly painless solution. It sucks as a build system, and Dockerfiles not being reproducible is the default outcome that needs significant extra care to avoid (how many times have you seen <i>apt update</i> or some equivalent in one)? Besides, why should I have to worry about a whole another OS inside my main OS, with potentially different tooling and conventions, when what I really want is just specific versions of a couple of tools?<p>I think we&#x27;ve gotten used to development environments being a shitty experience to the point where it seems part and parcel of programming, but when you take step back, it&#x27;s apparent that the situation causes a lot of frustration and wastes a lot of time. To me, Nix&#x27;s combination of package manager and reproducible build system looks like one of the most credible ways out. NixOS&#x27; declarative configuration and rollbacks are nice side benefits too, for server admins and newbies respectively. Nix just needs a lot more polish. I&#x27;m not about to introduce a tool where the most common workflow is still considered experimental. For now, I&#x27;ll keep using Docker, but I watch Nix with interest and can&#x27;t wait until its UX matures.<p>EDIT: Removed claim that Bazel and Buck&#x27;s creation was motivated by multi-language support. Looks like the main motivations were speed and reproducibility.</div><br/><div id="42705534" class="c"><input type="checkbox" id="c-42705534" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704575">parent</a><span>|</span><a href="#42704787">next</a><span>|</span><label class="collapse" for="c-42705534">[-]</label><label class="expand" for="c-42705534">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I think we&#x27;ve gotten used to development environments being a shitty experience to the point where it seems part and parcel of programming…<p>I have staunchly refused to allow this at my current employ, and I’ve been there long enough where I can steer this.<p>This isn’t acceptable and all it does is help introduce inconsistency and regressions.<p>I realize I am fortunate in that I can effect change at my job in this arena.</div><br/><div id="42708346" class="c"><input type="checkbox" id="c-42708346" checked=""/><div class="controls bullet"><span class="by">nbbaier</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705534">parent</a><span>|</span><a href="#42704787">next</a><span>|</span><label class="collapse" for="c-42708346">[-]</label><label class="expand" for="c-42708346">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s been your strategy for doing this</div><br/></div></div></div></div><div id="42704787" class="c"><input type="checkbox" id="c-42704787" checked=""/><div class="controls bullet"><span class="by">eacapeisfutuile</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704575">parent</a><span>|</span><a href="#42705534">prev</a><span>|</span><a href="#42703728">next</a><span>|</span><label class="collapse" for="c-42704787">[-]</label><label class="expand" for="c-42704787">[5 more]</label></div><br/><div class="children"><div class="content">That is not why neither Bazel or Buck was created.</div><br/><div id="42704879" class="c"><input type="checkbox" id="c-42704879" checked=""/><div class="controls bullet"><span class="by">pkkm</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704787">parent</a><span>|</span><a href="#42703728">next</a><span>|</span><label class="collapse" for="c-42704879">[-]</label><label class="expand" for="c-42704879">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not? I recall reading that coping with a variety of languages was one of the main motivations, but do correct me if I&#x27;m wrong and you have a citation.</div><br/><div id="42704946" class="c"><input type="checkbox" id="c-42704946" checked=""/><div class="controls bullet"><span class="by">eacapeisfutuile</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704879">parent</a><span>|</span><a href="#42703728">next</a><span>|</span><label class="collapse" for="c-42704946">[-]</label><label class="expand" for="c-42704946">[3 more]</label></div><br/><div class="children"><div class="content">They do hermetic builds so that it is viable at large scale via granular caching. They were made to make that work at those scales, with pretty much zero consideration for any external package managers or anything like that</div><br/><div id="42705132" class="c"><input type="checkbox" id="c-42705132" checked=""/><div class="controls bullet"><span class="by">pkkm</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704946">parent</a><span>|</span><a href="#42703728">next</a><span>|</span><label class="collapse" for="c-42705132">[-]</label><label class="expand" for="c-42705132">[2 more]</label></div><br/><div class="children"><div class="content">Hm, I did some searching. Bazel&#x27;s FAQ mentions multi-language support prominently, but only suggests speed and reliability as the initial motivations. I&#x27;ll edit my post.</div><br/><div id="42705238" class="c"><input type="checkbox" id="c-42705238" checked=""/><div class="controls bullet"><span class="by">eacapeisfutuile</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705132">parent</a><span>|</span><a href="#42703728">next</a><span>|</span><label class="collapse" for="c-42705238">[-]</label><label class="expand" for="c-42705238">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that is a thing for sure, was just commenting on why it was created :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42703728" class="c"><input type="checkbox" id="c-42703728" checked=""/><div class="controls bullet"><span class="by">azeirah</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42704575">prev</a><span>|</span><a href="#42704419">next</a><span>|</span><label class="collapse" for="c-42703728">[-]</label><label class="expand" for="c-42703728">[23 more]</label></div><br/><div class="children"><div class="content">The more I use nix, the more I understand it&#x27;s both. Nix is genuinely so fucking great, but the ecosystem and docs and language are a mess. It needs to be cleaned up, and things _are_ getting better.<p>The core philosophy of Nix is so damn solid though, and that&#x27;s the real innovation here. As long as its philosophy manage to stick around, then it&#x27;s ok.</div><br/><div id="42703864" class="c"><input type="checkbox" id="c-42703864" checked=""/><div class="controls bullet"><span class="by">rob_c</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703728">parent</a><span>|</span><a href="#42704419">next</a><span>|</span><label class="collapse" for="c-42703864">[-]</label><label class="expand" for="c-42703864">[22 more]</label></div><br/><div class="children"><div class="content">It&#x27;s basically, I refuse to learn how to containerize.<p>Just learn, use, promote best practices and stop forking the ecosystem _even_ further...<p>There, I got that off my chest.</div><br/><div id="42704095" class="c"><input type="checkbox" id="c-42704095" checked=""/><div class="controls bullet"><span class="by">edude03</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42705355">next</a><span>|</span><label class="collapse" for="c-42704095">[-]</label><label class="expand" for="c-42704095">[8 more]</label></div><br/><div class="children"><div class="content">As a heavy container user myself -  I&#x27;ve been using containers since I needed to build my own 3.x kernel to test them - docker doesn&#x27;t solve the reproducibility problem nix solves - IE, I can make a Dockerfile that does `RUN curl foo.com&#x2F;install.sh` and who knows if that&#x27;ll work ever again. Nix on the other hand doesn&#x27;t allow you to do IO during builds[^0] only describe the effect of doing the IO.<p>[0]: Though apparently darwin (mac) doesn&#x27;t support sandboxing by default, so you can bypass that but anyway</div><br/><div id="42705581" class="c"><input type="checkbox" id="c-42705581" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704095">parent</a><span>|</span><a href="#42705355">next</a><span>|</span><label class="collapse" for="c-42705581">[-]</label><label class="expand" for="c-42705581">[7 more]</label></div><br/><div class="children"><div class="content">You can just store the actual container though. Which will reproduce the environment exactly, it&#x27;s just not a guidebook on how it was built.<p>The value of most reproducibility at the Dockerfile is that we&#x27;re actually agnostic to getting a byte-exact reproduction: what we want is the ability to record what was important and effect upgrades.</div><br/><div id="42706349" class="c"><input type="checkbox" id="c-42706349" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705581">parent</a><span>|</span><a href="#42706303">next</a><span>|</span><label class="collapse" for="c-42706349">[-]</label><label class="expand" for="c-42706349">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Which will reproduce the environment exactly, it&#x27;s just not a guidebook on how it was built.<p>By that logic every binary artifact is a &quot;reproducible build&quot;. The point of reproducibility isn&#x27;t just to be able to reproduce the exact same artifact, it&#x27;s to be able to make changes that have predictable effects.<p>&gt; The value of most reproducibility at the Dockerfile is that we&#x27;re actually agnostic to getting a byte-exact reproduction: what we want is the ability to record what was important and effect upgrades.<p>More or less true. But we don&#x27;t have that, because of what grandparent said; if a Dockerfile used to work and now doesn&#x27;t, and there&#x27;s an apt-get update in it, who knows what version it was getting back when it was working, or how to fix the problem?</div><br/><div id="42706881" class="c"><input type="checkbox" id="c-42706881" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42706349">parent</a><span>|</span><a href="#42706303">next</a><span>|</span><label class="collapse" for="c-42706881">[-]</label><label class="expand" for="c-42706881">[3 more]</label></div><br/><div class="children"><div class="content">I do get the theoretical annoyance of how it’s technically not reproducible, but in practice most containers are pulled and not built from scratch.  If you’re really concerned about that apt-get then besides a container registry you’re going to host a private package repository too, or install a versioned tarball from a public URL, but check the hash of whatever you’re downloading and put that hash in the dockerfile.<p>So in practice.. if the build described in the dockerfile breaks, you notice when you’re changing &#x2F; extending the dockerfile.. which is the time and place where you’d expect to need to know.  My guess is that most people complaining about deterministic builds for containers are not using registries for storing images, and are not deploying to platforms like k8s.  If your process is, say, shipping dockerfiles to EC2 and building them in situ with “compose up” or something, then of course it won’t be very deterministic and you’re at the mercy of many more network failures, etc</div><br/><div id="42708206" class="c"><input type="checkbox" id="c-42708206" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42706881">parent</a><span>|</span><a href="#42707081">next</a><span>|</span><label class="collapse" for="c-42708206">[-]</label><label class="expand" for="c-42708206">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you’re really concerned about that apt-get then besides a container registry you’re going to host a private package repository too, or install a versioned tarball from a public URL, but check the hash of whatever you’re downloading and put that hash in the dockerfile.<p>Right, but if you&#x27;re doing that then you probably don&#x27;t need to bother with the docker part at all.<p>&gt; you notice when you’re changing &#x2F; extending the dockerfile.. which is the time and place where you’d expect to need to know<p>You notice, sure, but you can&#x27;t see what it was. Like, sure, it&#x27;s better than it failing when you come to deploy it, but you&#x27;re still in the position of having to do software archaeology to figure out how it ever worked in the first place.<p>Like, for me the main use case for reproducible builds is &quot;I need to make a small change to this component that was made by someone who left the company 3 years ago and has been quietly running since then&quot;, and you want to be able to just run the build and be confident it&#x27;s going to work. You don&#x27;t necessarily need to build something byte-for-byte identical to the thing that&#x27;s currently running, but you do need to build something equivalent. The reproducibility isn&#x27;t important per se but the declarativeness is, and with Docker you don&#x27;t get that.</div><br/></div></div><div id="42707081" class="c"><input type="checkbox" id="c-42707081" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42706881">parent</a><span>|</span><a href="#42708206">prev</a><span>|</span><a href="#42706303">next</a><span>|</span><label class="collapse" for="c-42707081">[-]</label><label class="expand" for="c-42707081">[1 more]</label></div><br/><div class="children"><div class="content">The issue is it&#x27;s <i>why</i> are you trying to be reproducible. The best use case is proving authenticity: that the source code became the binary code as written, but we&#x27;re so far away from that that it&#x27;s not realistic.<p>My dream system would be CI which gives me a gigantic object graph and can sign the source code from the ground up for every single thing including the compiler, so when a change happens you can drill down to what changed, and what the diffs were.</div><br/></div></div></div></div></div></div><div id="42706303" class="c"><input type="checkbox" id="c-42706303" checked=""/><div class="controls bullet"><span class="by">edude03</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705581">parent</a><span>|</span><a href="#42706349">prev</a><span>|</span><a href="#42705355">next</a><span>|</span><label class="collapse" for="c-42706303">[-]</label><label class="expand" for="c-42706303">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about a bit perfect reproduction though, just being able to understand dependencies. Take for example a simple Dockerfile like<p>```
FROM python:latest
ADD . 
RUN pip install foo
```<p>If I run this today, and I run this a year from now, I&#x27;m going to different versions of `python` and `foo` and there is no way (with just the Dockerfile) to know which version of `foo` and `python` were intended.<p>Nix on the other hand, forces me to use a git sha[^0] of my dependency; there is no concept of a mutable input. So to your point it&#x27;s hard to &#x27;upgrade&#x27; from version a -&gt; b in a controlled fashion if you don&#x27;t know what `a` even was.<p>[0]: or the sha256 of the depedency which yes, I understand that&#x27;s not easy for humans to use.</div><br/><div id="42707765" class="c"><input type="checkbox" id="c-42707765" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42706303">parent</a><span>|</span><a href="#42705355">next</a><span>|</span><label class="collapse" for="c-42707765">[-]</label><label class="expand" for="c-42707765">[1 more]</label></div><br/><div class="children"><div class="content">Well, what about &quot;FROM python:3.18&quot; and using requirements.txt or something like that? I mean, running an arbitrary Python version will get you in trouble anyway.</div><br/></div></div></div></div></div></div></div></div><div id="42705355" class="c"><input type="checkbox" id="c-42705355" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42704095">prev</a><span>|</span><a href="#42708314">next</a><span>|</span><label class="collapse" for="c-42705355">[-]</label><label class="expand" for="c-42705355">[3 more]</label></div><br/><div class="children"><div class="content">Nix handles containerization better than Docker does.<p>Here is a flake that builds a Go app and a Docker image for it (based on headless Chrome): <a href="https:&#x2F;&#x2F;github.com&#x2F;aksiksi&#x2F;ncdmv&#x2F;blob&#x2F;aa108a1c1e2c14a13dfbc0407f7f595ca205a4f6&#x2F;flake.nix#L69">https:&#x2F;&#x2F;github.com&#x2F;aksiksi&#x2F;ncdmv&#x2F;blob&#x2F;aa108a1c1e2c14a13dfbc0...</a><p>And here is how the image is built in CI: <a href="https:&#x2F;&#x2F;github.com&#x2F;aksiksi&#x2F;ncdmv&#x2F;blob&#x2F;aa108a1c1e2c14a13dfbc0407f7f595ca205a4f6&#x2F;.github&#x2F;workflows&#x2F;package.yml#L36">https:&#x2F;&#x2F;github.com&#x2F;aksiksi&#x2F;ncdmv&#x2F;blob&#x2F;aa108a1c1e2c14a13dfbc0...</a></div><br/><div id="42705938" class="c"><input type="checkbox" id="c-42705938" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705355">parent</a><span>|</span><a href="#42708314">next</a><span>|</span><label class="collapse" for="c-42705938">[-]</label><label class="expand" for="c-42705938">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re going to need to do more than just link to the flake if you want to show why that&#x27;s <i>better</i> than the Dockerfile equivalent, because the code itself isn&#x27;t selling it.</div><br/><div id="42706008" class="c"><input type="checkbox" id="c-42706008" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705938">parent</a><span>|</span><a href="#42708314">next</a><span>|</span><label class="collapse" for="c-42706008">[-]</label><label class="expand" for="c-42706008">[1 more]</label></div><br/><div class="children"><div class="content">1. Unbelievable layer reuse out of the box. Each Nix build output is placed in its own layer, including your binary (up to a max of 120 or so layers). Rebuilding the image will only result in the final layer changing, which minimizes work on image push.<p>2. Everything is pinned to nixpkgs, including dependencies. Anyone who builds this image will get the exact same versions (vs. apt-get update in a Dockerfile pulling a more recent version). It’s just sqlite in this case, but you can imagine how it would work with more dependencies.<p>3. It is trivial to build a “FROM scratch” image - in fact, that’s the default behavior in Nix, because Nix implicitly includes all runtime dependencies alongside your binary. This is less of a challenge with Go, but YMMV with other languages.<p>4. You can define your entrypoint script - or any other one-off script - in-line. Not a huge advantage, but still quite useful.<p>There is even an alternative pattern that allows you to reap these same benefits directly in your Dockerfile:<p><a href="https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;nix-with-dockerfiles" rel="nofollow">https:&#x2F;&#x2F;mitchellh.com&#x2F;writing&#x2F;nix-with-dockerfiles</a><p>Hope that helps.</div><br/></div></div></div></div></div></div><div id="42708314" class="c"><input type="checkbox" id="c-42708314" checked=""/><div class="controls bullet"><span class="by">turboponyy</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42705355">prev</a><span>|</span><a href="#42704003">next</a><span>|</span><label class="collapse" for="c-42708314">[-]</label><label class="expand" for="c-42708314">[1 more]</label></div><br/><div class="children"><div class="content">Containerizing an application is far easier than packaging an application for Nix - I think most avid Nix users would agree with that.<p>The reason why Nix users &quot;refuse&quot; to containerize is that Nix packages and their associated ecosystem come with a host of benefits that their containerized counterparts do not.</div><br/></div></div><div id="42704003" class="c"><input type="checkbox" id="c-42704003" checked=""/><div class="controls bullet"><span class="by">jvandreae</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42708314">prev</a><span>|</span><a href="#42704523">next</a><span>|</span><label class="collapse" for="c-42704003">[-]</label><label class="expand" for="c-42704003">[1 more]</label></div><br/><div class="children"><div class="content">The problem with docker is less the containerization and more the half-baked build system.</div><br/></div></div><div id="42704523" class="c"><input type="checkbox" id="c-42704523" checked=""/><div class="controls bullet"><span class="by">mazambazz</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42704003">prev</a><span>|</span><a href="#42704040">next</a><span>|</span><label class="collapse" for="c-42704523">[-]</label><label class="expand" for="c-42704523">[1 more]</label></div><br/><div class="children"><div class="content">Nix and containerization aren&#x27;t drop-in replacements for each other.<p>You can use Nix to build containers. Containers on their own don&#x27;t guarantee reproducibility, especially if the build process isn&#x27;t static and pure ( how many times do we `sudo apt update` inside a Dockerfile )?<p>And not everything is going to be containerizable. That only works for most applications. What if we&#x27;re trying to manage our cloud servers? That&#x27;s where Nix really shines.<p>Do you really think that Nix developers don&#x27;t know how to containerize applications? You think people are using Nix because they refuse to learn how to containerize, and therefore opt to learn a _much more_ difficult and arcane build process? The logic doesn&#x27;t track there.</div><br/></div></div><div id="42704040" class="c"><input type="checkbox" id="c-42704040" checked=""/><div class="controls bullet"><span class="by">jjmarr</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42704523">prev</a><span>|</span><a href="#42705771">next</a><span>|</span><label class="collapse" for="c-42704040">[-]</label><label class="expand" for="c-42704040">[3 more]</label></div><br/><div class="children"><div class="content">Well, yeah.<p>Nix is attempting to be better than containerization.<p>Saying &quot;improvements aren&#x27;t necessary because we already have &#x27;good-enough&#x27; technology&quot; is a meaningful argument when the improvements aren&#x27;t significant.<p>In my view, they <i>are</i> significant because Nix can be used to create a fully featured OS instead of just a VM.</div><br/><div id="42704599" class="c"><input type="checkbox" id="c-42704599" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704040">parent</a><span>|</span><a href="#42705771">next</a><span>|</span><label class="collapse" for="c-42704599">[-]</label><label class="expand" for="c-42704599">[2 more]</label></div><br/><div class="children"><div class="content">&gt; they are significant because Nix can be used to create a fully featured OS instead of just a VM<p>Look up Bootable Containers project by RedHat [0]. Fully featured OS built from a Containerfile, bootable on bare metal.<p>I agree that Nix design is much better than Docker, and has a bunch of features that OCI ecosystem doesn&#x27;t (e.g. remote builds[1], partial downloading of the build tree, non-linear build process[2], nix store import&#x2F;export, overlays, I&#x2F;O isolation, much better composability), but &quot;creating OS instead of VM&quot; [did you mean container?] is not one of them.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;bootc">https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;bootc</a><p>[1] You can use DOCKER_HOST, and I&#x27;m happy that this option is there, but Nix does it better.<p>[2] Perhaps with BuildKit it&#x27;s no longer true, I haven&#x27;t checked what happens if you have multi-staged build with one stage depending on multiple previous ones (which  are otherwise unconnected). I think Earthly can parallelize this scenario <a href="https:&#x2F;&#x2F;earthly.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;earthly.dev&#x2F;</a></div><br/><div id="42705667" class="c"><input type="checkbox" id="c-42705667" checked=""/><div class="controls bullet"><span class="by">cpuguy83</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704599">parent</a><span>|</span><a href="#42705771">next</a><span>|</span><label class="collapse" for="c-42705667">[-]</label><label class="expand" for="c-42705667">[1 more]</label></div><br/><div class="children"><div class="content">Yes buildkit can do this.
You can also use buildkit to create a bootable VM, just that nobody is doing it.
You can use estargz to fetch just the pieces you need from a dependency rather than the entire depdency as well.
Really all of the things you mentioned should be possible with buildkit, just that the focus of most things is Dockerfile which has much more limited functionality (though some of the things mentioned above still apply to Dockerfile).</div><br/></div></div></div></div></div></div><div id="42705771" class="c"><input type="checkbox" id="c-42705771" checked=""/><div class="controls bullet"><span class="by">azeirah</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42704040">prev</a><span>|</span><a href="#42704197">next</a><span>|</span><label class="collapse" for="c-42705771">[-]</label><label class="expand" for="c-42705771">[3 more]</label></div><br/><div class="children"><div class="content">Huh? I use Nix to create containers. Nix is a programming language, a build tool, a package manager and an entire ecosystem of extremely powerful tools.<p>The entire reason why I use Nix in the first place is because it allows me to containerize with _better_ reproducibility than docker itself.<p>I do get where you&#x27;re coming from though. It&#x27;s not immediately clear that Nix can do all this stuff. Nix is a lot more than just &quot;glorified weird package manager&quot;.<p>At its core, Nix is a way to specify dependencies in a mathematically sound manner. Once you have that pure dependency graph managed with Nix, you can start doing the _real_ fun stuff.<p>Like, you can containerize it. Or you can create a VM from it, or an ISO, or a NixOS distribution with _only_ that package installed.<p>Nix actually makes containerization _easier_, not harder. But yes, I empathize. Nix is a mess and it is difficult to understand, it will take a few more years before it is fully settled.<p>In the meantime? I&#x27;m going all-in on Nix (the philosophy, not necessarily any particular variant) because I really strongly believe this is the way forward.</div><br/><div id="42707772" class="c"><input type="checkbox" id="c-42707772" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705771">parent</a><span>|</span><a href="#42704197">next</a><span>|</span><label class="collapse" for="c-42707772">[-]</label><label class="expand" for="c-42707772">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Nix is a programming language, a build tool, a package manager and an entire ecosystem of extremely powerful tools<p>You have identified part of the problem.</div><br/><div id="42708352" class="c"><input type="checkbox" id="c-42708352" checked=""/><div class="controls bullet"><span class="by">azeirah</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42707772">parent</a><span>|</span><a href="#42704197">next</a><span>|</span><label class="collapse" for="c-42708352">[-]</label><label class="expand" for="c-42708352">[1 more]</label></div><br/><div class="children"><div class="content">I agree. This _is_ a huge problem.</div><br/></div></div></div></div></div></div><div id="42704197" class="c"><input type="checkbox" id="c-42704197" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42703864">parent</a><span>|</span><a href="#42705771">prev</a><span>|</span><a href="#42704419">next</a><span>|</span><label class="collapse" for="c-42704197">[-]</label><label class="expand" for="c-42704197">[1 more]</label></div><br/><div class="children"><div class="content">eelco thesis: 2003<p>lxc: 2008<p>docker: ~2012</div><br/></div></div></div></div></div></div><div id="42704419" class="c"><input type="checkbox" id="c-42704419" checked=""/><div class="controls bullet"><span class="by">z_mitchell</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42703728">prev</a><span>|</span><a href="#42705863">next</a><span>|</span><label class="collapse" for="c-42704419">[-]</label><label class="expand" for="c-42704419">[2 more]</label></div><br/><div class="children"><div class="content">I think that&#x27;s a bit reductive, but I get the intent. A lot of people see systemic problems in their development and turn to tools to reduce the cognitive load, busywork, or just otherwise automate a solution. For example &quot;we always argue over formatting&quot; -&gt; use an automated formatter. That makes total sense as long as managing&#x2F;interacting with the tool is less work, not just different work.<p>With Nix I still think it&#x27;s a net positive, but the &quot;different kind of work&quot; side of the equation is pretty large. That&#x27;s why we&#x27;re building Flox [1]. The imperative user interface of a package manager (flox install, flox search, etc) that builds out a declaratively-configured, reproducible, cross-platform developer environment. I really think it nails the user experience by keeping that &quot;different work&quot; side of the equation small, and (I hope) just gets out of your way.<p>[1]: <a href="https:&#x2F;&#x2F;flox.dev" rel="nofollow">https:&#x2F;&#x2F;flox.dev</a></div><br/><div id="42708420" class="c"><input type="checkbox" id="c-42708420" checked=""/><div class="controls bullet"><span class="by">strathos</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42704419">parent</a><span>|</span><a href="#42705863">next</a><span>|</span><label class="collapse" for="c-42708420">[-]</label><label class="expand" for="c-42708420">[1 more]</label></div><br/><div class="children"><div class="content">I just started using Flox last weekend and so far it has been quite nice experience. There are two things I don&#x27;t like, though:<p>1) The Homebrew package is a cask that installs also Nix. While I like Flox, I don&#x27;t want my systems to be married to it. Yes, I know about install option with &quot;generic Nix&quot;, but I&#x27;m using Homebrew with Brewfile both in macOS and Linux, and I would like the Homebrew package to be just Flox.<p>2) Documentation is OK for getting started, but not for anything more than that. There are nice manifest.toml examples for many use cases in floxenvs[1] but you need to find those first. Also I&#x27;m not sure how I feel about inline shell scripts in toml. While it works, separate files would be easier to handle, at least for me.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;flox&#x2F;floxenvs">https:&#x2F;&#x2F;github.com&#x2F;flox&#x2F;floxenvs</a></div><br/></div></div></div></div><div id="42705863" class="c"><input type="checkbox" id="c-42705863" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42704419">prev</a><span>|</span><a href="#42705573">next</a><span>|</span><label class="collapse" for="c-42705863">[-]</label><label class="expand" for="c-42705863">[3 more]</label></div><br/><div class="children"><div class="content">I tend to agree. I also think both sides need to learn to better appreciate the other.<p>Without people getting shit done with the tools we’ve built, there would be no demand for better tools and no need to write them.<p>Without better tools, the things we can get done are limited. Better tooling is an exponent to our productivity. The things we can accomplish today would have been nearly unimaginable nearly thirty years ago.</div><br/><div id="42705972" class="c"><input type="checkbox" id="c-42705972" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705863">parent</a><span>|</span><a href="#42707782">next</a><span>|</span><label class="collapse" for="c-42705972">[-]</label><label class="expand" for="c-42705972">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Better tooling is an exponent to our productivity<p>Nix &amp; NixOS have made me <i>much</i> more productive. Maintaining a desktop is effortless. If something breaks, I can simply reboot to a previous installation. I can also try software without installing, and develop parallel projects relying on dependencies that would be mutually incompatible in a regular imperative package manager.<p>But I recognize that if you need to do something slightly unusual, documentation is incomplete and scattered. For simple things, my contrarian view is that Nix is not hard at all. The subset of Nix I use can be learned in a couple of hours. I think the trick is to avoid getting sucked into packaging complex software with messy build systems. If the stack you use is well packaged in NixPkgs, it&#x27;s a joy to use. If it&#x27;s not, it&#x27;s better to stay away.</div><br/></div></div><div id="42707782" class="c"><input type="checkbox" id="c-42707782" checked=""/><div class="controls bullet"><span class="by">ofrzeta</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705863">parent</a><span>|</span><a href="#42705972">prev</a><span>|</span><a href="#42705573">next</a><span>|</span><label class="collapse" for="c-42707782">[-]</label><label class="expand" for="c-42707782">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The things we can accomplish today would have been nearly unimaginable nearly thirty years ago.<p>Like what? Witing an entire operating like Linux or Windows NT from scratch?</div><br/></div></div></div></div><div id="42705573" class="c"><input type="checkbox" id="c-42705573" checked=""/><div class="controls bullet"><span class="by">whazor</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42705863">prev</a><span>|</span><a href="#42705722">next</a><span>|</span><label class="collapse" for="c-42705573">[-]</label><label class="expand" for="c-42705573">[3 more]</label></div><br/><div class="children"><div class="content">Nix currently has the most packages of any distribution, see <a href="https:&#x2F;&#x2F;repology.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;repology.org&#x2F;</a><p>The model of having packages on Github with pull requests scales very well.<p>Therefore, you could argue that people are getting things done with Nix.</div><br/><div id="42707485" class="c"><input type="checkbox" id="c-42707485" checked=""/><div class="controls bullet"><span class="by">dingi</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42705573">parent</a><span>|</span><a href="#42705722">next</a><span>|</span><label class="collapse" for="c-42707485">[-]</label><label class="expand" for="c-42707485">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Nix currently has the most packages of any distribution, see <a href="https:&#x2F;&#x2F;repology.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;repology.org&#x2F;</a><p>This is a meaningless point. Different distros split packages differently.</div><br/><div id="42708013" class="c"><input type="checkbox" id="c-42708013" checked=""/><div class="controls bullet"><span class="by">whazor</span><span>|</span><a href="#42703647">root</a><span>|</span><a href="#42707485">parent</a><span>|</span><a href="#42705722">next</a><span>|</span><label class="collapse" for="c-42708013">[-]</label><label class="expand" for="c-42708013">[1 more]</label></div><br/><div class="children"><div class="content">While I agree that it’s somewhat difficult to compare. Especially as node and python packages are separately packaged in Nix.<p>However it is clear that the Nix folks are quite productive with maintaining packages. So that statement is judgemental, as it implies that all those packages are not ‘the right things to get done’.</div><br/></div></div></div></div></div></div><div id="42705722" class="c"><input type="checkbox" id="c-42705722" checked=""/><div class="controls bullet"><span class="by">foundart</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42705573">prev</a><span>|</span><a href="#42708306">next</a><span>|</span><label class="collapse" for="c-42705722">[-]</label><label class="expand" for="c-42705722">[1 more]</label></div><br/><div class="children"><div class="content">I first heard of Nix a few years ago from someone who fell firmly into the camp of &quot;the tools are the interesting part.&quot; Despite my reservations, perhaps because I didn&#x27;t want my opinion of the person to lead me away from something useful, I started to mess with it. After about 30 minutes I decided it was not for me and have not touched it since.<p>I do keep an eye on Nix-related stories to get a sense of whether or not I should change that stance. So far, nothing has led me to change it.</div><br/></div></div><div id="42708306" class="c"><input type="checkbox" id="c-42708306" checked=""/><div class="controls bullet"><span class="by">endofreach</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42705722">prev</a><span>|</span><a href="#42704935">next</a><span>|</span><label class="collapse" for="c-42708306">[-]</label><label class="expand" for="c-42708306">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m 100% in the third camp.</div><br/></div></div><div id="42704935" class="c"><input type="checkbox" id="c-42704935" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#42703647">parent</a><span>|</span><a href="#42708306">prev</a><span>|</span><a href="#42704360">next</a><span>|</span><label class="collapse" for="c-42704935">[-]</label><label class="expand" for="c-42704935">[1 more]</label></div><br/><div class="children"><div class="content">I enjoy writing tools.<p>How do you feel about Kubernetes?<p>It would be good to have some interesting tasks to do?<p>I think the tools should do also much of the work. I actually prefer batch systems that are a simple execution of a program against a dump which are just process all the data and generate data with the new states than a networked online system that breaks all the time and due to DNS<p>Micro services keep me awake but a simple CSV processing I can fix in my own time.</div><br/></div></div></div></div><div id="42702543" class="c"><input type="checkbox" id="c-42702543" checked=""/><div class="controls bullet"><span class="by">_huayra_</span><span>|</span><a href="#42703647">prev</a><span>|</span><a href="#42703720">next</a><span>|</span><label class="collapse" for="c-42702543">[-]</label><label class="expand" for="c-42702543">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been on the fence about Nix. I&#x27;ve wanted to love it (and do love the concept), but between the Waiting-for-Godot situation for flakes, the weird language, and the occasional political infighting I&#x27;ve seen pop up about the community, I still haven&#x27;t switched.<p>I&#x27;m no language expert, but I genuinely don&#x27;t understand why it wouldn&#x27;t have been better to build some equivalent DSL in Haskell to do this given the similar lazy nature of the language. DSL for most things, then open the hood and do actual Haskell for crazier use cases. I get that Nix started before Haskell became less academic and slightly more usable in the mainstream and has built up momentum, but the lack of tooling for understanding what is going wrong when incrementally building up a config is very confusing.<p>I&#x27;d be curious if anyone has go to or from NixOS compared to declarative distros compared to the atomic distros like ublue [0] and has any thoughts. I&#x27;m a bit split about what to move to next (though my &gt;5 year Tumbleweed install on most of my machines is holding up no problem).<p>[0] <a href="https:&#x2F;&#x2F;universal-blue.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;universal-blue.org&#x2F;</a></div><br/><div id="42703381" class="c"><input type="checkbox" id="c-42703381" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#42702543">parent</a><span>|</span><a href="#42706433">next</a><span>|</span><label class="collapse" for="c-42703381">[-]</label><label class="expand" for="c-42703381">[5 more]</label></div><br/><div class="children"><div class="content">I switched away from Nix OS and eventually landed on GNU Guix, which I have stayed on for about 4 years now. One of the main reasons I switched away from Nix was because of the language, and how underdocumented it all felt. GNU Guix was a breath of fresh air, using a language with decades of academic backing outside of the context of Guix (SICP was awesome for getting into it) and the whole system is very well documented, with a nearly Arch-wiki quality manual built into the OS in the info pages.</div><br/><div id="42705617" class="c"><input type="checkbox" id="c-42705617" checked=""/><div class="controls bullet"><span class="by">jonotime</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42703381">parent</a><span>|</span><a href="#42706233">next</a><span>|</span><label class="collapse" for="c-42705617">[-]</label><label class="expand" for="c-42705617">[2 more]</label></div><br/><div class="children"><div class="content">Oh, I&#x27;m interested. Are you using it on servers, or desktop? My concern is the community is small, while Nix&#x27;s has been booming.</div><br/><div id="42708728" class="c"><input type="checkbox" id="c-42708728" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42705617">parent</a><span>|</span><a href="#42706233">next</a><span>|</span><label class="collapse" for="c-42708728">[-]</label><label class="expand" for="c-42708728">[1 more]</label></div><br/><div class="children"><div class="content">I am using it on my home server that serves my web page and also a lot of things for my home network.<p>It runs some guix containers and some VMs. Nothing fancy.<p>All declared in a couple of files.</div><br/></div></div></div></div><div id="42706233" class="c"><input type="checkbox" id="c-42706233" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42703381">parent</a><span>|</span><a href="#42705617">prev</a><span>|</span><a href="#42706433">next</a><span>|</span><label class="collapse" for="c-42706233">[-]</label><label class="expand" for="c-42706233">[2 more]</label></div><br/><div class="children"><div class="content">Guix has stripped away the biggest plus from NixOS: the module system and replaced it with a half assed system</div><br/><div id="42708711" class="c"><input type="checkbox" id="c-42708711" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42706233">parent</a><span>|</span><a href="#42706433">next</a><span>|</span><label class="collapse" for="c-42708711">[-]</label><label class="expand" for="c-42708711">[1 more]</label></div><br/><div class="children"><div class="content">I mean, modules are just regular guile modules. It feels somewhat clunky, but at the same time you can use guile&#x27;s introspection to do fun stuff.<p>I always found it more flexible, but on the other hand I never liked NixOS modules.</div><br/></div></div></div></div></div></div><div id="42706433" class="c"><input type="checkbox" id="c-42706433" checked=""/><div class="controls bullet"><span class="by">tomn</span><span>|</span><a href="#42702543">parent</a><span>|</span><a href="#42703381">prev</a><span>|</span><a href="#42704811">next</a><span>|</span><label class="collapse" for="c-42706433">[-]</label><label class="expand" for="c-42706433">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m no language expert, but I genuinely don&#x27;t understand why it wouldn&#x27;t have been better to build some equivalent DSL in Haskell to do this given the similar lazy nature of the language.<p>My impression is that you can&#x27;t really build nix as a DSL in haskell, because the core insight of nix is to introduce the &quot;derivation&quot; function into a pure programming language, whose behaviour is pure (the output is determined by only the inputs), but whose implementation is very much not (it builds packages from a specification).<p>There may well be a work-around for that (it&#x27;s been a while since i haskelled), but it&#x27;s likely to end up with a result that&#x27;s less clean than it would ideally be.<p>Personally I find the nix language to be a pretty good match for the tasks it is used for (though some basic static typing would be nice).<p>From the outside, i can see why it looks odd, but from the inside, there&#x27;s not much of a desire to switch to something better, because the language isn&#x27;t the thing that gives people trouble after the initial learning period (which would exist with any host language).</div><br/><div id="42708220" class="c"><input type="checkbox" id="c-42708220" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42706433">parent</a><span>|</span><a href="#42708142">next</a><span>|</span><label class="collapse" for="c-42708220">[-]</label><label class="expand" for="c-42708220">[1 more]</label></div><br/><div class="children"><div class="content"><i>My impression is that you can&#x27;t really build nix as a DSL in haskell, because the core insight of nix is to introduce the &quot;derivation&quot; function into a pure programming language, whose behaviour is pure (the output is determined by only the inputs), but whose implementation is very much not (it builds packages from a specification).</i><p>Evaluation is completely pure (at least with flakes, which disallows querying environment variables, etc.). Evaluation of derivations will result in <i>.drv</i> files in the store, but that does not add impurity to the language itself. Building the <i>.drv</i> is a separate step (instantiation).<p>You could totally write something that generates <i>.drv</i> files in a different language and use Nix for instantiation (building). If I am not mistaken, this is how Guix started - they evaluated derivations defined in scheme to <i>.drv</i> files and then let the Nix daemon build them.<p>Aside from that, as a Nix user, I am happy that Haskell is not the language. Nix is a very small, simple language that is easy to wrap your head around and does not lead to a lot of abstractionitis. A want to say this in a way without painting a caricature, but the Haskell community has a tendency to pile on a lot of abstractions and I would hate to see a Nix with monad transformers, lenses, or whatever is popular these days.</div><br/></div></div><div id="42708142" class="c"><input type="checkbox" id="c-42708142" checked=""/><div class="controls bullet"><span class="by">nothrabannosir</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42706433">parent</a><span>|</span><a href="#42708220">prev</a><span>|</span><a href="#42704811">next</a><span>|</span><label class="collapse" for="c-42708142">[-]</label><label class="expand" for="c-42708142">[1 more]</label></div><br/><div class="children"><div class="content">I don’t understand—the language itself is completely contained and separate from the derivation. Evaluation could be done in any language and the derivation will remain the output. You can absolutely have a better language generate derivations, surely? Hell, you could use Python typescript or go if you wanted to. They’d even be completely compatible with the unholy mess of cursed bash that is stdenv.<p>What you can’t port over to another language as neatly are the modules. Good riddance, id say. Undebuggable spaghetti from hell.<p><i>&gt; from the inside, there&#x27;s not much of a desire to switch to something better, because the language isn&#x27;t the thing that gives people trouble after the initial learning period (which would exist with any host language).</i><p>Unfortunately I have wasted enough of my life to call myself “on the inside” and IMHO the language itself is close to the number one threat to wider adoption of nix.</div><br/></div></div></div></div><div id="42704811" class="c"><input type="checkbox" id="c-42704811" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#42702543">parent</a><span>|</span><a href="#42706433">prev</a><span>|</span><a href="#42703720">next</a><span>|</span><label class="collapse" for="c-42704811">[-]</label><label class="expand" for="c-42704811">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m using Universal Blue now (Aurora, i.e. KDE flavour) and I&#x27;m very happy with it. With its large amount of pre-installed packages and drivers (including proprietary ones), I still didn&#x27;t need to install any custom package (rpm-ostree) or otherwise modify the OS config (except for turning off SELinux in &#x2F;etc&#x2F;sysconfig&#x2F;selinux). It&#x27;s the most pragmatic distro I&#x27;ve used so far.<p>SaveDesktop[0] (saves flatpak apps and DE configs) and mise-en-place[1] (declarative shell environment manager) are making my installation backupable and quite reproducible (not to NixOS standards though).<p>For software that&#x27;s not in flatpak, docker or mise, toolbox[2] and distrobox[3] are available for the rescue. Both work really well (toolbox seems better for CLIs, distrobox for GUIs), but all atomicity&#x2F;declarativity is lost.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;vikdevelop&#x2F;SaveDesktop">https:&#x2F;&#x2F;github.com&#x2F;vikdevelop&#x2F;SaveDesktop</a><p>[1] <a href="https:&#x2F;&#x2F;mise.jdx.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mise.jdx.dev&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;toolbox">https:&#x2F;&#x2F;github.com&#x2F;containers&#x2F;toolbox</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;89luca89&#x2F;distrobox">https:&#x2F;&#x2F;github.com&#x2F;89luca89&#x2F;distrobox</a></div><br/><div id="42706230" class="c"><input type="checkbox" id="c-42706230" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42702543">root</a><span>|</span><a href="#42704811">parent</a><span>|</span><a href="#42703720">next</a><span>|</span><label class="collapse" for="c-42706230">[-]</label><label class="expand" for="c-42706230">[1 more]</label></div><br/><div class="children"><div class="content">Docker and flatpak suck so much if you want to customize anything</div><br/></div></div></div></div></div></div><div id="42703720" class="c"><input type="checkbox" id="c-42703720" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42702543">prev</a><span>|</span><a href="#42705205">next</a><span>|</span><label class="collapse" for="c-42703720">[-]</label><label class="expand" for="c-42703720">[14 more]</label></div><br/><div class="children"><div class="content">I love NixOS, it&#x27;s my daily driver on my personal laptop, but it definitely has given me more than its fair share of headaches.<p>If everything you&#x27;re going to do is in Nixpkgs, great! Nix will mostly &quot;Just Work&quot; and you&#x27;ll get all the nice declarative goodness that you want.  Since Nixpkgs is constantly getting updated, this isn&#x27;t that weird of a thing.<p>The thing that&#x27;s been most annoying to me is when I try and run generic Linux programs, only to be unceremoniously told &quot;You can&#x27;t run generic Linux programs in NixOS because we break dynamic linking&quot;. Suddenly something that would take about ten seconds on Ubuntu involves me, at the very least, making a Flake that has an FHS environment, or me making a package so that no one else has to deal with this crap [1].  I didn&#x27;t really <i>want</i> to know how to make my own Nix package, and I don&#x27;t really <i>want</i> to be stuck maintaining one now, but this is just part of Nix.<p>This means that it&#x27;s still not something I could easily recommend to someone non-technical like my parents, unlike Ubuntu. You have to be willing and able to occasionally hack up some code if you want your system to be consistently useful.<p>To be clear, there&#x27;s a lot of stuff I really like, I don&#x27;t plan on removing it from my laptop, and for something like a server (where the audience is sort of technical by design), I really have no desire to ever use anything but NixOS, but it&#x27;s a little less impressive for desktop.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;366367">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;366367</a></div><br/><div id="42704192" class="c"><input type="checkbox" id="c-42704192" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#42703720">parent</a><span>|</span><a href="#42704900">next</a><span>|</span><label class="collapse" for="c-42704192">[-]</label><label class="expand" for="c-42704192">[6 more]</label></div><br/><div class="children"><div class="content">You can run generic Linux stuff if you install nix-ld¹, the only tricky bit is having to customize the set of libraries given to nix-ld for your use-case. It includes various common libraries by default, but depending on what you want to run you may have to add to it.<p>¹<a href="https:&#x2F;&#x2F;search.nixos.org&#x2F;options?channel=unstable&amp;show=programs.nix-ld.enable&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=nix-ld" rel="nofollow">https:&#x2F;&#x2F;search.nixos.org&#x2F;options?channel=unstable&amp;show=progr...</a></div><br/><div id="42704268" class="c"><input type="checkbox" id="c-42704268" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704192">parent</a><span>|</span><a href="#42704538">next</a><span>|</span><label class="collapse" for="c-42704268">[-]</label><label class="expand" for="c-42704268">[3 more]</label></div><br/><div class="children"><div class="content">Interesting, I didn&#x27;t realize that that was an option.<p>I&#x27;ve been getting by with buildFHSenv and Flakes, which, despite my complaints, really isn&#x27;t <i>that</i> annoying. My goal at this point is to eventually compile all my flakes and take on Lutris.</div><br/><div id="42705291" class="c"><input type="checkbox" id="c-42705291" checked=""/><div class="controls bullet"><span class="by">Chris_Newton</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704268">parent</a><span>|</span><a href="#42706337">next</a><span>|</span><label class="collapse" for="c-42705291">[-]</label><label class="expand" for="c-42705291">[1 more]</label></div><br/><div class="children"><div class="content"><i>Interesting, I didn&#x27;t realize that that was an option.</i><p>As a fellow daily driver of NixOS, you’ve just summed up my biggest problem with it. You <i>can</i> do almost anything, and once you’ve figured out how and why you do it a certain way, that way often makes a lot of sense and the NixOS design can offer significant benefits compared to more traditional distros without much downside. But NixOS <i>is</i> out of the mainstream and its documentation <i>is</i> often less than ideal, so there is a steep learning curve that is relatively difficult to climb compared to a more conventional distro like Ubuntu.<p>The shared object problem in particular comes up so often, particularly if you use applications or programming languages with their own ecosystem and package management, that I feel like having nix-ld installed and activated by default with a selection of the most useful SOs available out of the box would be a significant benefit to new users. Or if including it in a default installation is a step too far, many users would probably benefit from some HOWTO-style documentation so they can learn early on that nix-ld exists, how it helps with software that was built for “typical” Linux distros, why you <i>don’t</i> need or want it when running software that was already built for NixOS such as the contents of nixpkgs, and how to work out which shared objects an application needs and how to find and install them for use with nix-ld.<p>I haven’t yet felt confident enough in my own NixOS knowledge to contribute something like that, but one nice thing about the NixOS community is that there are some genuine experts around who often pop up in these discussions to help the rest of us. I wonder if there’s scope for sponsoring some kind of “Big NixOS Documentation Project™” to fund a few of those experts to close some of those documentation gaps for the benefit of the whole community…</div><br/></div></div><div id="42706337" class="c"><input type="checkbox" id="c-42706337" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704268">parent</a><span>|</span><a href="#42705291">prev</a><span>|</span><a href="#42704538">next</a><span>|</span><label class="collapse" for="c-42706337">[-]</label><label class="expand" for="c-42706337">[1 more]</label></div><br/><div class="children"><div class="content">I would probably still use buildFHSenv if I was trying to package up a third-party binary for installation in my configuration. My usage of nix-ld is actually to solve the problem of using VSCode Remote to connect to my NixOS machine, and in particular to allow it to run binaries it downloads onto the machine for extensions (typically LSP servers).</div><br/></div></div></div></div><div id="42704538" class="c"><input type="checkbox" id="c-42704538" checked=""/><div class="controls bullet"><span class="by">JasonSage</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704192">parent</a><span>|</span><a href="#42704268">prev</a><span>|</span><a href="#42704900">next</a><span>|</span><label class="collapse" for="c-42704538">[-]</label><label class="expand" for="c-42704538">[2 more]</label></div><br/><div class="children"><div class="content">There’s also nix-alien which does this but tries to be more automagical.</div><br/><div id="42706304" class="c"><input type="checkbox" id="c-42706304" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704538">parent</a><span>|</span><a href="#42704900">next</a><span>|</span><label class="collapse" for="c-42706304">[-]</label><label class="expand" for="c-42706304">[1 more]</label></div><br/><div class="children"><div class="content">nix-alien is an older, worse approach that is not that well maintained</div><br/></div></div></div></div></div></div><div id="42704900" class="c"><input type="checkbox" id="c-42704900" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42703720">parent</a><span>|</span><a href="#42704192">prev</a><span>|</span><a href="#42706297">next</a><span>|</span><label class="collapse" for="c-42704900">[-]</label><label class="expand" for="c-42704900">[3 more]</label></div><br/><div class="children"><div class="content">Love NixOS and Nix in general (just not the language). I&#x27;ve started using `steam-run` to run things I&#x27;m too smooth brain to port.</div><br/><div id="42704933" class="c"><input type="checkbox" id="c-42704933" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704900">parent</a><span>|</span><a href="#42706301">next</a><span>|</span><label class="collapse" for="c-42704933">[-]</label><label class="expand" for="c-42704933">[1 more]</label></div><br/><div class="children"><div class="content">I will say that once I found out about Flakes it bothered me a lot less.  I find them a lot easier to test and it&#x27;s nice to be able to easily define a custom little environment for them and then just do `nix run` afterwards.<p>It&#x27;s been especially useful to be able to specify exact versions of wine and winetricks installs on a per-game basis.</div><br/></div></div><div id="42706301" class="c"><input type="checkbox" id="c-42706301" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704900">parent</a><span>|</span><a href="#42704933">prev</a><span>|</span><a href="#42706297">next</a><span>|</span><label class="collapse" for="c-42706301">[-]</label><label class="expand" for="c-42706301">[1 more]</label></div><br/><div class="children"><div class="content">That will likely soon stop working because steam-run is no longer a grab bag for literally every library out there.</div><br/></div></div></div></div><div id="42706297" class="c"><input type="checkbox" id="c-42706297" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42703720">parent</a><span>|</span><a href="#42704900">prev</a><span>|</span><a href="#42704315">next</a><span>|</span><label class="collapse" for="c-42706297">[-]</label><label class="expand" for="c-42706297">[1 more]</label></div><br/><div class="children"><div class="content">You can just use nix-ld to run anything that is somewhat closely resembled.</div><br/></div></div><div id="42704315" class="c"><input type="checkbox" id="c-42704315" checked=""/><div class="controls bullet"><span class="by">kombine</span><span>|</span><a href="#42703720">parent</a><span>|</span><a href="#42706297">prev</a><span>|</span><a href="#42705205">next</a><span>|</span><label class="collapse" for="c-42704315">[-]</label><label class="expand" for="c-42704315">[3 more]</label></div><br/><div class="children"><div class="content">Could you setup distrobox to run regular Linux programs?</div><br/><div id="42705548" class="c"><input type="checkbox" id="c-42705548" checked=""/><div class="controls bullet"><span class="by">worble</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704315">parent</a><span>|</span><a href="#42704436">next</a><span>|</span><label class="collapse" for="c-42705548">[-]</label><label class="expand" for="c-42705548">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s exactly what I did for a while, but really once you get the hang of nix it&#x27;s kind of unnecessary. I keep this bit of nix to hand for anything that I need to run<p><pre><code>   #!&#x2F;usr&#x2F;bin&#x2F;env nix-shell

   { pkgs ? import &lt;nixpkgs&gt; { } }:

  (
    let base = pkgs.appimageTools.defaultFhsEnvArgs; in
    pkgs.buildFHSUserEnv (base &#x2F;&#x2F; {
      name = &quot;FHS&quot;;
      targetPkgs = pkgs: (with pkgs; [
        &#x2F;* add additional packages here e.g *&#x2F;
        pcre
        tzdata
      ]);
      runScript = &quot;bash&quot;;
      extraOutputsToInstall = [ &quot;dev&quot; ];
    })
  ).env
</code></pre>
Running `nix-shell` will drop you into a bash shell that looks just like a normal linux distribution with a lot of common libraries (thanks to `pkgs.appimageTools.defaultFhsEnvArgs`) and after trying to run your application you can shove whatever you need in the extra packages when it complains about a dependency being missing.<p>Obviously it&#x27;s a bit more work than other distros, but once nix gets it&#x27;s claws into you, you&#x27;ll find it hard to go back to old ways.</div><br/></div></div><div id="42704436" class="c"><input type="checkbox" id="c-42704436" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42703720">root</a><span>|</span><a href="#42704315">parent</a><span>|</span><a href="#42705548">prev</a><span>|</span><a href="#42705205">next</a><span>|</span><label class="collapse" for="c-42704436">[-]</label><label class="expand" for="c-42704436">[1 more]</label></div><br/><div class="children"><div class="content">Almost certainly, though I&#x27;ve never tried.<p>I&#x27;m technical enough to where making a Flake doesn&#x27;t really bother me, and it&#x27;s really not as hard as I was making it out if you&#x27;re already familiar with functional programming, I&#x27;m just saying it&#x27;s an annoyance.<p>That said, I might need to play with Distrobox, it looks like it&#x27;s in nixpkgs.</div><br/></div></div></div></div></div></div><div id="42705205" class="c"><input type="checkbox" id="c-42705205" checked=""/><div class="controls bullet"><span class="by">emarthinsen</span><span>|</span><a href="#42703720">prev</a><span>|</span><a href="#42702954">next</a><span>|</span><label class="collapse" for="c-42705205">[-]</label><label class="expand" for="c-42705205">[11 more]</label></div><br/><div class="children"><div class="content">I use NixOS as my daily driver. I concur. I wouldn&#x27;t recommend it for most people (even for me, when I decided to give it a try). I&#x27;d probably just go Arch if I were to do it over again.<p>The concept behind Nix&#x2F;NixOS is amazing, but it needs to be polished. Flakes are the future, but they are languishing in this experimental status. Even simple things like installing packages from stable and unstable channels are too hard to figure out. The documentation is terse and the community answers are often not enlightening.<p>A big complaint of mine is that the builds should be reproducible, but I find I sometimes need to run `nixos-rebuild switch` several times to get a successful build. The error messages mysteriously resolve themselves. For me, this doesn&#x27;t pass the bar for being considered reproducible.<p>Don&#x27;t get me started on using an NVIDIA graphics card also. Granted, part of my difficulties is that I was running Wayland, which doesn&#x27;t have the best NVIDIA support, but I felt like I was just doing an exhaustive search through the potential config settings to see what worked. Ultimately, I found just the right combination of settings to get everything working buttery smooth. I ripped out the NVIDIA card and put an AMD card in.</div><br/><div id="42706288" class="c"><input type="checkbox" id="c-42706288" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42705205">parent</a><span>|</span><a href="#42707286">next</a><span>|</span><label class="collapse" for="c-42706288">[-]</label><label class="expand" for="c-42706288">[1 more]</label></div><br/><div class="children"><div class="content">Installing packages from different channels is still far easier than on any other distro. Try getting a Debian 10 package to work on Debian 13. You can&#x27;t. GUI programs are hard because how GUIs work on Linux. You cannot make them easily pure, they always rely on the booted system through drivers and a bunch of impure things all over the place.<p>If the software you are using has race conditions in its build system then there is only so much you can do to fix that. You could for example run nothing in parallel with only one core but then everything would be painfully slow. Also the occasional network hickup breaks things. Lately also io_uring in combination with nodejs has been a great source for kernel bugs. You can only bang the software so much from the outside.<p>Nvidia is bad because Nvidia is bad but at least switching between different driver versions and variants is possible without leaving a trace of old things behind on your system like on literally any other distro.</div><br/></div></div><div id="42707286" class="c"><input type="checkbox" id="c-42707286" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#42705205">parent</a><span>|</span><a href="#42706288">prev</a><span>|</span><a href="#42705941">next</a><span>|</span><label class="collapse" for="c-42707286">[-]</label><label class="expand" for="c-42707286">[2 more]</label></div><br/><div class="children"><div class="content">After spending some time on NixOS I basically decided to hold off until flakes become official and the docs are written with them in mind. In the mean time I just run Arch with Nix home-manager and I&#x27;m happy.<p>I&#x27;ve developed enough good habits over the years that I don&#x27;t get breakages, and home-manager allows me to easily sync my dotfiles across machines..</div><br/><div id="42708760" class="c"><input type="checkbox" id="c-42708760" checked=""/><div class="controls bullet"><span class="by">wesapien</span><span>|</span><a href="#42705205">root</a><span>|</span><a href="#42707286">parent</a><span>|</span><a href="#42705941">next</a><span>|</span><label class="collapse" for="c-42708760">[-]</label><label class="expand" for="c-42708760">[1 more]</label></div><br/><div class="children"><div class="content">What makes you reluctant from using flakes? I initially thought I&#x27;d never have a need for flakes but after spending an hour on YouTube and Googling, I converted to flakes.</div><br/></div></div></div></div><div id="42705941" class="c"><input type="checkbox" id="c-42705941" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#42705205">parent</a><span>|</span><a href="#42707286">prev</a><span>|</span><a href="#42705259">next</a><span>|</span><label class="collapse" for="c-42705941">[-]</label><label class="expand" for="c-42705941">[6 more]</label></div><br/><div class="children"><div class="content">My experience has been in complete agreement with yours: I love the theory, but the practice is so, so painful.<p>And yes, I also had to settle for your NVIDIA fix. I suspect I would have had a marginally better time on Arch as there are more people beating their heads against it and documenting how they made it work. NixOS documentation is piss-poor in comparison.</div><br/><div id="42706250" class="c"><input type="checkbox" id="c-42706250" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42705205">root</a><span>|</span><a href="#42705941">parent</a><span>|</span><a href="#42705259">next</a><span>|</span><label class="collapse" for="c-42706250">[-]</label><label class="expand" for="c-42706250">[5 more]</label></div><br/><div class="children"><div class="content">Most people don&#x27;t realize that you can read the arch wiki and put the same settings into the nixos options. Where is the point in replicating that all again?</div><br/><div id="42706505" class="c"><input type="checkbox" id="c-42706505" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#42705205">root</a><span>|</span><a href="#42706250">parent</a><span>|</span><a href="#42707165">next</a><span>|</span><label class="collapse" for="c-42706505">[-]</label><label class="expand" for="c-42706505">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how to adapt those settings to the corresponding module - there are often differences in naming and hierarchy conventions - and there are other NixOS-specific considerations with regards to its shared-nothing architecture.<p>While it is technically possible to adapt the information in the Arch wiki to NixOS, you need a strong understanding of the software, how it was packaged for NixOS, and NixOS itself to do it effectively. Once you <i>do</i> figure it out, it&#x27;s pretty straightforward, but that can be hours as opposed to minutes with Arch.</div><br/></div></div><div id="42707165" class="c"><input type="checkbox" id="c-42707165" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#42705205">root</a><span>|</span><a href="#42706250">parent</a><span>|</span><a href="#42706505">prev</a><span>|</span><a href="#42705259">next</a><span>|</span><label class="collapse" for="c-42707165">[-]</label><label class="expand" for="c-42707165">[3 more]</label></div><br/><div class="children"><div class="content">My one big question about nix is how the hell do I find out those options? Like cool, I know I need to set the config to some specific value based on arch wiki, but how do I read the nix package to find out what config &quot;key&quot; to use? I&#x27;ve never been able to work out where these are defined</div><br/><div id="42707484" class="c"><input type="checkbox" id="c-42707484" checked=""/><div class="controls bullet"><span class="by">postcert</span><span>|</span><a href="#42705205">root</a><span>|</span><a href="#42707165">parent</a><span>|</span><a href="#42708190">next</a><span>|</span><label class="collapse" for="c-42707484">[-]</label><label class="expand" for="c-42707484">[1 more]</label></div><br/><div class="children"><div class="content">The key terms don’t change so I usually just grep Nixpkgs in nvim and usually have a lead on where to start. Obviously it’s a bit more work than copy&#x2F;paste from the arch wiki but generally more popular config changes will have an nixos option available.</div><br/></div></div><div id="42708190" class="c"><input type="checkbox" id="c-42708190" checked=""/><div class="controls bullet"><span class="by">theo0833</span><span>|</span><a href="#42705205">root</a><span>|</span><a href="#42707165">parent</a><span>|</span><a href="#42707484">prev</a><span>|</span><a href="#42705259">next</a><span>|</span><label class="collapse" for="c-42708190">[-]</label><label class="expand" for="c-42708190">[1 more]</label></div><br/><div class="children"><div class="content">try <a href="https:&#x2F;&#x2F;search.nixos.org&#x2F;options" rel="nofollow">https:&#x2F;&#x2F;search.nixos.org&#x2F;options</a> .</div><br/></div></div></div></div></div></div></div></div><div id="42705259" class="c"><input type="checkbox" id="c-42705259" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42705205">parent</a><span>|</span><a href="#42705941">prev</a><span>|</span><a href="#42702954">next</a><span>|</span><label class="collapse" for="c-42705259">[-]</label><label class="expand" for="c-42705259">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m on an NVIDIA Jetson, so I guess I&#x27;ll just have to wait before this stuff becomes practically usable for me ...</div><br/></div></div></div></div><div id="42702954" class="c"><input type="checkbox" id="c-42702954" checked=""/><div class="controls bullet"><span class="by">bfrog</span><span>|</span><a href="#42705205">prev</a><span>|</span><a href="#42678365">next</a><span>|</span><label class="collapse" for="c-42702954">[-]</label><label class="expand" for="c-42702954">[2 more]</label></div><br/><div class="children"><div class="content">I love the ideas behind Nix. But as noted here, there&#x27;s a thousand cuts to be found.<p>My biggest issue has been packaging binary distributed programs. These often want files in a particular directory somewhere, often want to find relative path libraries or plugins, want certain configuration options in etc...<p>None of that Just Works, there&#x27;s a whole confusing method to try and monkey patch the software to work but its long list of not being able to find the information you want, not being able to do what you want, or simply limitations around how nix wants to structure things that make it really really frustrating.<p>If something like Nix were to be done again... I&#x27;d really recommend starting with something like a strongly typed flake like language with tooling a lot closer to that of cargo from rust from the get go. Errors should be easy, projects should be easily setup independently, etc. Where every project can simply be built as an independent thing. Sure there&#x27;s downsides, but the upsides are that... you don&#x27;t have the impossible task of managing one of the largest mono repos, if not the largest, on github. With all of the insane issues that entails. It wouldn&#x27;t be that terrible to have a crates.io equivalent to publish, test, and share flakes.<p>Now I think I might&#x27;ve just created flakehub... but flakehub still relies on nix the tool and nix the language which are far from easy to work with.</div><br/><div id="42706345" class="c"><input type="checkbox" id="c-42706345" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42702954">parent</a><span>|</span><a href="#42678365">next</a><span>|</span><label class="collapse" for="c-42706345">[-]</label><label class="expand" for="c-42706345">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just proprietary software assuming you are on something Debian or red hat like. 
The problem is on them being closed and hostile towards improvement.<p>Also for someone not knowing Rust it is also very intimidating and if you start to go into more complex things you are easily out of luck with the tutorials out there.<p>The monorepo is not that big of an issue. More often you are being bitten by badly maintained software that doesn&#x27;t work with a 3 year old compiler or upstream is unwilling to move forward because of LTS support or something.</div><br/></div></div></div></div><div id="42678365" class="c"><input type="checkbox" id="c-42678365" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42702954">prev</a><span>|</span><a href="#42669905">next</a><span>|</span><label class="collapse" for="c-42678365">[-]</label><label class="expand" for="c-42678365">[15 more]</label></div><br/><div class="children"><div class="content">I use NixOS, one of the annoying things to me is the documentation and error reports.<p>I swapped my installation to a Flake managed install a few months ago, and parts of my Nix files that were perfectly fine before started throwing out errors (specifically HomeManager), which no amount of Googling the error message that gone thrown got me any closer to a solution.<p>I looked at documentation recently to try and enable PGO&#x2F;LTO and Zen 3 optimizations (don&#x27;t mind compiling everything) and I think I saw at least 10 ways and none worked (gcc errors, etc).</div><br/><div id="42701889" class="c"><input type="checkbox" id="c-42701889" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42678365">parent</a><span>|</span><a href="#42702268">next</a><span>|</span><label class="collapse" for="c-42701889">[-]</label><label class="expand" for="c-42701889">[10 more]</label></div><br/><div class="children"><div class="content">This is why I haven&#x27;t switched my NixOS to flakes yet. The community discussions always act as though flakes should be the default that everyone should use now, but I figure that the developers know what they&#x27;re doing and haven&#x27;t made them the blessed path yet for a reason. So far so good—my system is far more stable than it was under Debian and I&#x27;ve yet to run into anything that didn&#x27;t have an easy answer.<p>I have a suspicion that because the Nix community is disproportionately likely to contain early adopters, the general mood in the forums is less risk-averse than I am with my primary stacks.</div><br/><div id="42705945" class="c"><input type="checkbox" id="c-42705945" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42701889">parent</a><span>|</span><a href="#42703593">next</a><span>|</span><label class="collapse" for="c-42705945">[-]</label><label class="expand" for="c-42705945">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad I&#x27;m not the only one who&#x27;s grinding their gears with flakes.<p>I decided to migrate to flakes because a lot of the documentation for things I wanted to do with NixOS required flakes. It took me at least a few hours to understand what the purpose of them was though.<p>I just wish the documentation would be improved really, as an example <a href="https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Build_flags#Building_the_whole_system_on_NixOS" rel="nofollow">https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;Build_flags#Building_the_whole_syste...</a> no longer works (gcc complains).</div><br/></div></div><div id="42703593" class="c"><input type="checkbox" id="c-42703593" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42701889">parent</a><span>|</span><a href="#42705945">prev</a><span>|</span><a href="#42702268">next</a><span>|</span><label class="collapse" for="c-42703593">[-]</label><label class="expand" for="c-42703593">[8 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I figure that the developers know what they&#x27;re doing and haven&#x27;t made them the blessed path yet for a reason.</i><p>My take is: flakes don’t align with centralised nixpkgs and ultimately don’t solve any problems that can’t be solved without flakes.<p>They’re just an interface for a decentralised module system. You can use them, they’re feature-complete, and they don’t align with nixpkgs: it doesn’t make sense for individual packages to have their own flakes, nixpkgs can already be loaded as a flake.<p>FlakeHub tries to popularise flakes, but I don’t know if there is a flake discovery problem to solve.<p>Ekala Project is designing a poly-repo alternative to nixpkgs (ekapkgs) and they don’t embrace flakes.<p>So... Flakes have reached full maturity: a decentralised package format that has stalled its adoption status within the main Nix toolchain.</div><br/><div id="42704931" class="c"><input type="checkbox" id="c-42704931" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42703593">parent</a><span>|</span><a href="#42706357">next</a><span>|</span><label class="collapse" for="c-42704931">[-]</label><label class="expand" for="c-42704931">[5 more]</label></div><br/><div class="children"><div class="content">&gt; My take is: flakes don’t align with centralised nixpkgs and ultimately don’t solve any problems that can’t be solved without flakes.<p>I&#x27;ve turned to flakes to specifically solve some problems, and flaked solved them. To this day, flakes are still the only way to solve them.<p>Flakes aren&#x27;t default due to political reasons.</div><br/><div id="42704975" class="c"><input type="checkbox" id="c-42704975" checked=""/><div class="controls bullet"><span class="by">nixosbestos</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42704931">parent</a><span>|</span><a href="#42705021">next</a><span>|</span><label class="collapse" for="c-42704975">[-]</label><label class="expand" for="c-42704975">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I am flabbergasted that anyone can claim flakes don&#x27;t solve problems. And yet, every <i>SINGLE WEEK</i> some newcomer gets tripped up on channels, managing them, realizing the root&#x27;s channels are different than users, realizing their channels are out of sync on their multiple machines, no posting their channel revision when they solicit help. Not to mention pure eval. Not to mention transitive dependency overriding.</div><br/><div id="42707022" class="c"><input type="checkbox" id="c-42707022" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42704975">parent</a><span>|</span><a href="#42705021">next</a><span>|</span><label class="collapse" for="c-42707022">[-]</label><label class="expand" for="c-42707022">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I am flabbergasted that anyone can claim flakes don&#x27;t solve problems</i><p>Yes, that would be an outrageous claim! That is, of course, not what I said.<p>Arguing that channels lead to more problems than flakes is a good argument in favour of adoption of flakes. But you can also abandon channels without adopting flakes.<p>Which is what I said: flakes don’t solve any problems that can’t be solved without flakes.</div><br/></div></div></div></div><div id="42705021" class="c"><input type="checkbox" id="c-42705021" checked=""/><div class="controls bullet"><span class="by">jmholla</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42704931">parent</a><span>|</span><a href="#42704975">prev</a><span>|</span><a href="#42706357">next</a><span>|</span><label class="collapse" for="c-42705021">[-]</label><label class="expand" for="c-42705021">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve turned to flakes to specifically solve some problems, and flaked solved them. To this day, flakes are still the only way to solve them.<p>Can you share some examples of such problems?</div><br/><div id="42707064" class="c"><input type="checkbox" id="c-42707064" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42705021">parent</a><span>|</span><a href="#42706357">next</a><span>|</span><label class="collapse" for="c-42707064">[-]</label><label class="expand" for="c-42707064">[1 more]</label></div><br/><div class="children"><div class="content">I can say what I use flakes for at work:<p>I have a repository with system configurations for some CI infrastructure: a build server, a test runner.<p>The test runner can either be generated as an SD-card image using nixos-generators or live-updated using a remote `nixos-rebuild switch`. The OS configuration contains stuff about purposing specific motherboard GPIO pins.<p>Both systems depend on custom software not in nixpkgs; these are just hosted in private git and have a flake that mainly provide a devShell, but also provide a cross-compiled binary.<p>Flakes handle all of that in a predictable way: OS images, cross-compiled binaries, devShells, cross-repo linking, convenient hash-pinning.</div><br/></div></div></div></div></div></div><div id="42706357" class="c"><input type="checkbox" id="c-42706357" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42703593">parent</a><span>|</span><a href="#42704931">prev</a><span>|</span><a href="#42702268">next</a><span>|</span><label class="collapse" for="c-42706357">[-]</label><label class="expand" for="c-42706357">[2 more]</label></div><br/><div class="children"><div class="content">Flakes bring you one interface to share common dependencies which is kot possible without an interface.</div><br/><div id="42706993" class="c"><input type="checkbox" id="c-42706993" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42706357">parent</a><span>|</span><a href="#42702268">next</a><span>|</span><label class="collapse" for="c-42706993">[-]</label><label class="expand" for="c-42706993">[1 more]</label></div><br/><div class="children"><div class="content">Yes, they bring an interface.<p>And lockfiles that are automatically maintained where digests are extracted into.<p>Unlike if you do builtins.fetch* and pin those, in which case the digests end up in your source code.</div><br/></div></div></div></div></div></div></div></div><div id="42702516" class="c"><input type="checkbox" id="c-42702516" checked=""/><div class="controls bullet"><span class="by">joshcsimmons</span><span>|</span><a href="#42678365">parent</a><span>|</span><a href="#42702268">prev</a><span>|</span><a href="#42669905">next</a><span>|</span><label class="collapse" for="c-42702516">[-]</label><label class="expand" for="c-42702516">[3 more]</label></div><br/><div class="children"><div class="content">Worth noting that ChatGPT et al. Are equally useless for debugging Nix. Frustrating that it’s so far behind. Error messages are often cryptic and misleading.</div><br/><div id="42705886" class="c"><input type="checkbox" id="c-42705886" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42702516">parent</a><span>|</span><a href="#42669905">next</a><span>|</span><label class="collapse" for="c-42705886">[-]</label><label class="expand" for="c-42705886">[2 more]</label></div><br/><div class="children"><div class="content">Yep, I thought ChatGPT was trained on Github but it&#x27;s generated precisely 0 correct .nix files for me to date.</div><br/><div id="42706348" class="c"><input type="checkbox" id="c-42706348" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42678365">root</a><span>|</span><a href="#42705886">parent</a><span>|</span><a href="#42669905">next</a><span>|</span><label class="collapse" for="c-42706348">[-]</label><label class="expand" for="c-42706348">[1 more]</label></div><br/><div class="children"><div class="content">Are you complaining that AI is not the savior of everything?</div><br/></div></div></div></div></div></div></div></div><div id="42669905" class="c"><input type="checkbox" id="c-42669905" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#42678365">prev</a><span>|</span><a href="#42704075">next</a><span>|</span><label class="collapse" for="c-42669905">[-]</label><label class="expand" for="c-42669905">[8 more]</label></div><br/><div class="children"><div class="content">Nix for me has been a great source of stability. I used to run ubuntu and was never happy. Packages randomly broke, the UI lagged a lot, I always had to dig to get things working. One day when I head a uni deadline an automated updated destroyed my wifi funcionality. I had some experience with nix from work so in anger I installed NixOS. Wifi worked and I finished my uni assignment. Haven&#x27;t installed anything else on my computers since, and that was 6 years ago. Sure things can be a pain. But NixOS has never broken in unexpected ways. I know if I update things may go wrong. But I can always go back and try again a newer version a few weeks later.<p>The biggest drawback is really that &quot;random executable from the internet&quot; does not work out of the box. And sometimes you have to spend a lot of time to package something yourself. But all in all It has saved me time and a lot of pain. I dare even say I no longer have a toxic relationship with my OS.</div><br/><div id="42670449" class="c"><input type="checkbox" id="c-42670449" checked=""/><div class="controls bullet"><span class="by">VTimofeenko</span><span>|</span><a href="#42669905">parent</a><span>|</span><a href="#42672189">next</a><span>|</span><label class="collapse" for="c-42670449">[-]</label><label class="expand" for="c-42670449">[5 more]</label></div><br/><div class="children"><div class="content">For those pesky random executables there&#x27;s a couple of escape hatches -- buildFHSenv and nix-ld. This is also predicated on good provenance of the executables in question. One should probably not even ldd sketchy binaries:<p><a href="https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;07&#x2F;ldd-untrusted-binaries.html" rel="nofollow">https:&#x2F;&#x2F;jmmv.dev&#x2F;2023&#x2F;07&#x2F;ldd-untrusted-binaries.html</a></div><br/><div id="42702295" class="c"><input type="checkbox" id="c-42702295" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#42669905">root</a><span>|</span><a href="#42670449">parent</a><span>|</span><a href="#42670863">next</a><span>|</span><label class="collapse" for="c-42702295">[-]</label><label class="expand" for="c-42702295">[3 more]</label></div><br/><div class="children"><div class="content">Even proper packaging is far easier compared to other package managers. Typical distros push users away from packaging their own software, so users end up relying on ad-hoc solutions instead. Nix instead makes packaging easier by having proper tools to abstract away the nitty gritty details.<p>For random binaries, autoPatchelfHook works miracles.</div><br/><div id="42707531" class="c"><input type="checkbox" id="c-42707531" checked=""/><div class="controls bullet"><span class="by">postcert</span><span>|</span><a href="#42669905">root</a><span>|</span><a href="#42702295">parent</a><span>|</span><a href="#42704991">next</a><span>|</span><label class="collapse" for="c-42707531">[-]</label><label class="expand" for="c-42707531">[1 more]</label></div><br/><div class="children"><div class="content">It wasn’t that bad creating some new derivations my first week with Nixos, I was so used to Arch where I had maybe a handful modified pkgbuilds over a decade.<p>For better or worse it was a positive experience, especially when you usually already have a pkgbuild to go off of.</div><br/></div></div><div id="42704991" class="c"><input type="checkbox" id="c-42704991" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42669905">root</a><span>|</span><a href="#42702295">parent</a><span>|</span><a href="#42707531">prev</a><span>|</span><a href="#42670863">next</a><span>|</span><label class="collapse" for="c-42704991">[-]</label><label class="expand" for="c-42704991">[1 more]</label></div><br/><div class="children"><div class="content">Every time I see a linux installation with a mess in &#x2F;opt because it&#x27;s faster than making a package, I get annoyed.</div><br/></div></div></div></div><div id="42670863" class="c"><input type="checkbox" id="c-42670863" checked=""/><div class="controls bullet"><span class="by">micahcc</span><span>|</span><a href="#42669905">root</a><span>|</span><a href="#42670449">parent</a><span>|</span><a href="#42702295">prev</a><span>|</span><a href="#42672189">next</a><span>|</span><label class="collapse" for="c-42670863">[-]</label><label class="expand" for="c-42670863">[1 more]</label></div><br/><div class="children"><div class="content">steam-run seems to be able to run everything. It uses bubble wrap to keep the OS isolated and add &#x2F;usr&#x2F;bin stuff most exes want.</div><br/></div></div></div></div><div id="42672189" class="c"><input type="checkbox" id="c-42672189" checked=""/><div class="controls bullet"><span class="by">aszen</span><span>|</span><a href="#42669905">parent</a><span>|</span><a href="#42670449">prev</a><span>|</span><a href="#42704075">next</a><span>|</span><label class="collapse" for="c-42672189">[-]</label><label class="expand" for="c-42672189">[2 more]</label></div><br/><div class="children"><div class="content">I now use distrobox to run random binaries in a container. It&#x27;s faster and convenient</div><br/><div id="42702487" class="c"><input type="checkbox" id="c-42702487" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#42669905">root</a><span>|</span><a href="#42672189">parent</a><span>|</span><a href="#42704075">next</a><span>|</span><label class="collapse" for="c-42702487">[-]</label><label class="expand" for="c-42702487">[1 more]</label></div><br/><div class="children"><div class="content">&gt; just run random binaries from the internet like it&#x27;s 1998, bro<p>That world was fun but I don&#x27;t want to go back to that place.</div><br/></div></div></div></div></div></div><div id="42704075" class="c"><input type="checkbox" id="c-42704075" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#42669905">prev</a><span>|</span><a href="#42704208">next</a><span>|</span><label class="collapse" for="c-42704075">[-]</label><label class="expand" for="c-42704075">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It seems very cool that you can roll back in the case of a catastrophic upgrade failure, but has that every happened to you? Not me.</i><p>Rollbacks saved me from completely destroying my entire system. I managed to fill up my boot partition in a way that deployed successfully but left the whole system unbootable after reboot, and the only way I managed to save it without having to completely wipe and reinstall from scratch (which means losing all my data) was to load the SD card onto my laptop, fix the boot partition by hand to ensure the kernel from the previous generation was valid, and edit the bootloader config to delete the offending configuration (because accidentally trying to boot it would re-corrupt the boot partition).<p>I&#x27;ve also used rollbacks in other less catastrophic situations, such as when I broke wireless (since I build remotely on a much more powerful machine and deploy over SSH).</div><br/><div id="42706071" class="c"><input type="checkbox" id="c-42706071" checked=""/><div class="controls bullet"><span class="by">bpye</span><span>|</span><a href="#42704075">parent</a><span>|</span><a href="#42704208">next</a><span>|</span><label class="collapse" for="c-42706071">[-]</label><label class="expand" for="c-42706071">[1 more]</label></div><br/><div class="children"><div class="content">I use NixOS on my home router and rollbacks also saved me from a Firewall misconfiguration that broke all network connectivity.</div><br/></div></div></div></div><div id="42704208" class="c"><input type="checkbox" id="c-42704208" checked=""/><div class="controls bullet"><span class="by">edude03</span><span>|</span><a href="#42704075">prev</a><span>|</span><a href="#42703238">next</a><span>|</span><label class="collapse" for="c-42704208">[-]</label><label class="expand" for="c-42704208">[1 more]</label></div><br/><div class="children"><div class="content">Nix has been my daily driver for about 10 years, all 10 on servers, and about 3&#x2F;4 on a laptop.<p>The thing that hits close to home for me, is the inability to use software that doesn&#x27;t support nixes opinions on how to do version management (for example a post of mine from years ago[^0]), software that likes mutable state for its configuration (Gnome for example) and yeah, trying new things that aren&#x27;t packaged for nix means writing a nix derivation.<p>That said, I feel like nix does more good than harm for me so the paper cuts are bearable.<p>[0]: <a href="https:&#x2F;&#x2F;community.roonlabs.com&#x2F;t&#x2F;unable-to-get-roon-to-start-on-nix-linux&#x2F;20923" rel="nofollow">https:&#x2F;&#x2F;community.roonlabs.com&#x2F;t&#x2F;unable-to-get-roon-to-start...</a></div><br/></div></div><div id="42703238" class="c"><input type="checkbox" id="c-42703238" checked=""/><div class="controls bullet"><span class="by">jcmfernandes</span><span>|</span><a href="#42704208">prev</a><span>|</span><a href="#42704272">next</a><span>|</span><label class="collapse" for="c-42703238">[-]</label><label class="expand" for="c-42703238">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m relatively new to nix, and this cut close:<p>&gt; At this point NixOS has been around for 2 decades, but it still feels like it has not settled on good recommended workflows for incoming users.<p>Yes. This was a major pain point when I was getting started. The IRC community has been helpful in this regard. I also really don&#x27;t like that nixpkgs serves as both a lib and a package set. Be one! I don&#x27;t want &quot;special&quot; inputs in my config.</div><br/></div></div><div id="42704272" class="c"><input type="checkbox" id="c-42704272" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#42703238">prev</a><span>|</span><a href="#42671236">next</a><span>|</span><label class="collapse" for="c-42704272">[-]</label><label class="expand" for="c-42704272">[3 more]</label></div><br/><div class="children"><div class="content">I only wish Guix had a more robust nonfree packages I think it could really give Nix a run for its money.</div><br/><div id="42704627" class="c"><input type="checkbox" id="c-42704627" checked=""/><div class="controls bullet"><span class="by">nemoniac</span><span>|</span><a href="#42704272">parent</a><span>|</span><a href="#42706361">next</a><span>|</span><label class="collapse" for="c-42704627">[-]</label><label class="expand" for="c-42704627">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re looking for robust, nonfree packages for Guix, you can find them here:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nonguix&#x2F;nonguix">https:&#x2F;&#x2F;github.com&#x2F;nonguix&#x2F;nonguix</a></div><br/></div></div><div id="42706361" class="c"><input type="checkbox" id="c-42706361" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42704272">parent</a><span>|</span><a href="#42704627">prev</a><span>|</span><a href="#42671236">next</a><span>|</span><label class="collapse" for="c-42706361">[-]</label><label class="expand" for="c-42706361">[1 more]</label></div><br/><div class="children"><div class="content">Just use nix</div><br/></div></div></div></div><div id="42671236" class="c"><input type="checkbox" id="c-42671236" checked=""/><div class="controls bullet"><span class="by">craftkiller</span><span>|</span><a href="#42704272">prev</a><span>|</span><a href="#42702014">next</a><span>|</span><label class="collapse" for="c-42671236">[-]</label><label class="expand" for="c-42671236">[3 more]</label></div><br/><div class="children"><div class="content">&gt; ZFS on Linux [...] The recommended way to do this is to use LUKS, not native ZFS encryption.<p>FWIW I&#x27;ve been using native zfs encryption on nixos and it works great. It lacks neat features like being TPM-backed or having multiple keys, but if all you need is password-based encryption then I think native ZFS encryption is better since you&#x27;ll be able to do encrypted zfs send&#x2F;recv, you&#x27;ll have granular control over which datasets are encrypted (or encrypted with different passwords), you&#x27;d get cross-platform support for the encryption (for example, my FreeBSD home server can receive and decrypt my laptop backups), and you aren&#x27;t adding another layer of complexity.</div><br/><div id="42697469" class="c"><input type="checkbox" id="c-42697469" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42671236">parent</a><span>|</span><a href="#42702014">next</a><span>|</span><label class="collapse" for="c-42697469">[-]</label><label class="expand" for="c-42697469">[2 more]</label></div><br/><div class="children"><div class="content">I think the main reason ZFS&#x27;s native encryption isn&#x27;t recommended is that there&#x27;s known bugs in its implementation, especially around key rotation and send&#x2F;recv.</div><br/><div id="42701987" class="c"><input type="checkbox" id="c-42701987" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42671236">root</a><span>|</span><a href="#42697469">parent</a><span>|</span><a href="#42702014">next</a><span>|</span><label class="collapse" for="c-42701987">[-]</label><label class="expand" for="c-42701987">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think the main reason ZFS&#x27;s native encryption isn&#x27;t recommended is that there&#x27;s known bugs in its implementation, especially around key rotation and send&#x2F;recv.<p>Is that still the case?  I thought the send&#x2F;recv bugs at least were squashed a couple years ago?</div><br/></div></div></div></div></div></div><div id="42702014" class="c"><input type="checkbox" id="c-42702014" checked=""/><div class="controls bullet"><span class="by">sigmonsays</span><span>|</span><a href="#42671236">prev</a><span>|</span><a href="#42669817">next</a><span>|</span><label class="collapse" for="c-42702014">[-]</label><label class="expand" for="c-42702014">[6 more]</label></div><br/><div class="children"><div class="content">i use nixos on VMs, my desktop (Gaming and productivity) and servers. I use flakes for everything.<p>I&#x27;ve painfully learned how to do everything I need. My only big complaint is updating systemd. I have yet to figure out the systemd update bug. Sometimes nixos-rebuild-switch takes my network offline when updating systemd. It&#x27;s incredibly annoying to update a box and have it drop offline. My work around is to do a &#x27;diff&#x27; and when systemd is updated, I reboot manually and only update the boot image.</div><br/><div id="42705628" class="c"><input type="checkbox" id="c-42705628" checked=""/><div class="controls bullet"><span class="by">bdd</span><span>|</span><a href="#42702014">parent</a><span>|</span><a href="#42702257">next</a><span>|</span><label class="collapse" for="c-42705628">[-]</label><label class="expand" for="c-42705628">[1 more]</label></div><br/><div class="children"><div class="content">I believe <a href="https:&#x2F;&#x2F;github.com&#x2F;nixos&#x2F;nixpkgs&#x2F;pull&#x2F;372196">https:&#x2F;&#x2F;github.com&#x2F;nixos&#x2F;nixpkgs&#x2F;pull&#x2F;372196</a> fixes this if you are using systemd-networkd. It was merged to master last week and made it to unstable branches (<a href="https:&#x2F;&#x2F;nixpk.gs&#x2F;pr-tracker.html?pr=372196" rel="nofollow">https:&#x2F;&#x2F;nixpk.gs&#x2F;pr-tracker.html?pr=372196</a>).</div><br/></div></div><div id="42702257" class="c"><input type="checkbox" id="c-42702257" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42702014">parent</a><span>|</span><a href="#42705628">prev</a><span>|</span><a href="#42706368">next</a><span>|</span><label class="collapse" for="c-42702257">[-]</label><label class="expand" for="c-42702257">[1 more]</label></div><br/><div class="children"><div class="content">Does it stay offline?  My network often bounces when updating systemd, but I haven&#x27;t seen it stay down.</div><br/></div></div><div id="42706368" class="c"><input type="checkbox" id="c-42706368" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42702014">parent</a><span>|</span><a href="#42702257">prev</a><span>|</span><a href="#42705725">next</a><span>|</span><label class="collapse" for="c-42706368">[-]</label><label class="expand" for="c-42706368">[1 more]</label></div><br/><div class="children"><div class="content">Probably because it restarts the network service. You can configure the systemd unit to be only reloaded or nothing at all m</div><br/></div></div><div id="42705725" class="c"><input type="checkbox" id="c-42705725" checked=""/><div class="controls bullet"><span class="by">jonotime</span><span>|</span><a href="#42702014">parent</a><span>|</span><a href="#42706368">prev</a><span>|</span><a href="#42703668">next</a><span>|</span><label class="collapse" for="c-42705725">[-]</label><label class="expand" for="c-42705725">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I have had that several times too.</div><br/></div></div><div id="42703668" class="c"><input type="checkbox" id="c-42703668" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42702014">parent</a><span>|</span><a href="#42705725">prev</a><span>|</span><a href="#42669817">next</a><span>|</span><label class="collapse" for="c-42703668">[-]</label><label class="expand" for="c-42703668">[1 more]</label></div><br/><div class="children"><div class="content">Mine does that too, sometimes.</div><br/></div></div></div></div><div id="42669817" class="c"><input type="checkbox" id="c-42669817" checked=""/><div class="controls bullet"><span class="by">RestartKernel</span><span>|</span><a href="#42702014">prev</a><span>|</span><a href="#42708149">next</a><span>|</span><label class="collapse" for="c-42669817">[-]</label><label class="expand" for="c-42669817">[6 more]</label></div><br/><div class="children"><div class="content">Trying to get Eduroam working soured me on NixOS as a desktop&#x2F;laptop OS. If conventional methods fail, you&#x27;re left with a completely non-standard OS designed to prevent quick hacks.<p>But NixOS spoiled my entire mindset around Linux. Going back to anything else feels like a massive downgrade. We would be better off today if declarative operating systems became the standard back when they could.</div><br/><div id="42704630" class="c"><input type="checkbox" id="c-42704630" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42669817">parent</a><span>|</span><a href="#42702135">next</a><span>|</span><label class="collapse" for="c-42704630">[-]</label><label class="expand" for="c-42704630">[1 more]</label></div><br/><div class="children"><div class="content">I ran NixOS while I attended university and don&#x27;t remember any problems with this. Is it a NetworkManager issue?</div><br/></div></div><div id="42702135" class="c"><input type="checkbox" id="c-42702135" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#42669817">parent</a><span>|</span><a href="#42704630">prev</a><span>|</span><a href="#42708149">next</a><span>|</span><label class="collapse" for="c-42702135">[-]</label><label class="expand" for="c-42702135">[4 more]</label></div><br/><div class="children"><div class="content">Wi-Fi should just work like any other Linux distro, assuming you have a desktop environment like GNOME or Plasma installed.</div><br/><div id="42702927" class="c"><input type="checkbox" id="c-42702927" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42669817">root</a><span>|</span><a href="#42702135">parent</a><span>|</span><a href="#42704905">next</a><span>|</span><label class="collapse" for="c-42702927">[-]</label><label class="expand" for="c-42702927">[1 more]</label></div><br/><div class="children"><div class="content">Probably not very helpful telling him that it <i>should</i> work!</div><br/></div></div><div id="42704905" class="c"><input type="checkbox" id="c-42704905" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#42669817">root</a><span>|</span><a href="#42702135">parent</a><span>|</span><a href="#42702927">prev</a><span>|</span><a href="#42708149">next</a><span>|</span><label class="collapse" for="c-42704905">[-]</label><label class="expand" for="c-42704905">[2 more]</label></div><br/><div class="children"><div class="content">eduroam is not your everyday WPA{2,3}-PSK, it&#x27;s WPA2-EAP. There are official shell scripts to provision certificates, but they only seem to work on major distros, and for some reason the eduroam website made different scripts for every university. Also, for most people this is their first (and last) experience with 802.1X, especially setting it up themselves.<p>In my experience few years ago, it was a pain to set it up on everything except macOS and iOS (which come with eduroam certificates preinstalled in their trust stores).</div><br/><div id="42705375" class="c"><input type="checkbox" id="c-42705375" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42669817">root</a><span>|</span><a href="#42704905">parent</a><span>|</span><a href="#42708149">next</a><span>|</span><label class="collapse" for="c-42705375">[-]</label><label class="expand" for="c-42705375">[1 more]</label></div><br/><div class="children"><div class="content">eduroam is less one network standard implemented by universities, more like, individual university networks that are set up similarly enough that they have a chance of talking to each other&#x27;s auth servers and maybe working.</div><br/></div></div></div></div></div></div></div></div><div id="42708149" class="c"><input type="checkbox" id="c-42708149" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#42669817">prev</a><span>|</span><a href="#42704939">next</a><span>|</span><label class="collapse" for="c-42708149">[-]</label><label class="expand" for="c-42708149">[1 more]</label></div><br/><div class="children"><div class="content">Nix has been a godsend at dealing with different dev environments and (cross-)compiling complicated software stacks. When you write a proper nix derivation that runs inside a nix sandbox it does not matter where you run it, you&#x27;ll have high guarantee it replicates the result for you anywhere.</div><br/></div></div><div id="42704939" class="c"><input type="checkbox" id="c-42704939" checked=""/><div class="controls bullet"><span class="by">sunshine-o</span><span>|</span><a href="#42708149">prev</a><span>|</span><a href="#42670589">next</a><span>|</span><label class="collapse" for="c-42704939">[-]</label><label class="expand" for="c-42704939">[3 more]</label></div><br/><div class="children"><div class="content">I really like Nix but recently I ended up in a very tricky situation:<p>If you you are cut from the internet or end up with a very slow connection you can end up totally blocked. As a minor configuration change can require you to download a lot of data.<p>I also found out there is not much you can do to protect you from this.</div><br/><div id="42707118" class="c"><input type="checkbox" id="c-42707118" checked=""/><div class="controls bullet"><span class="by">bsimpson</span><span>|</span><a href="#42704939">parent</a><span>|</span><a href="#42705409">next</a><span>|</span><label class="collapse" for="c-42707118">[-]</label><label class="expand" for="c-42707118">[1 more]</label></div><br/><div class="children"><div class="content">Easy keyboard access is also a baked in assumption.<p>I found my way to Nix because I wanted to try SteamOS on nicer hardware than the Steam Deck. Bazzite is the recommendation in that space now, but at the time, there were a lot of equally unknown options. There&#x27;s a community called Jovian that has replicated the SteamOS setup atop NixOS, using Valve&#x27;s own sources. Using official sources and taking the chance to learn a new functional programming language seemed like as good a place to start as any.<p>When it works, it&#x27;s great; however, +1 to all the gripes.<p>_Everything_ in Nix is set by writing to a text file and calling a CLI to rebuild. If you don&#x27;t have ready access to a keyboard, you might not be able to so much as change the timezone.  You can end up on obsolete versions of evergreen software like Chrome too, because Nix wants to own everything, and nothing changes until you rebuild.</div><br/></div></div><div id="42705409" class="c"><input type="checkbox" id="c-42705409" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#42704939">parent</a><span>|</span><a href="#42707118">prev</a><span>|</span><a href="#42670589">next</a><span>|</span><label class="collapse" for="c-42705409">[-]</label><label class="expand" for="c-42705409">[1 more]</label></div><br/><div class="children"><div class="content">If you’re using flakes, this is minimized, as long as you don’t cleanup (GC) your Nix store and don’t update your lock file.</div><br/></div></div></div></div><div id="42670589" class="c"><input type="checkbox" id="c-42670589" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#42704939">prev</a><span>|</span><a href="#42673017">next</a><span>|</span><label class="collapse" for="c-42670589">[-]</label><label class="expand" for="c-42670589">[3 more]</label></div><br/><div class="children"><div class="content">I found getting started quite easy.<p>But then you discover there are like 4-5 different ways to manage packages and not much consensus in the community on what the correct way is. That was kinda discouraging</div><br/><div id="42704967" class="c"><input type="checkbox" id="c-42704967" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42670589">parent</a><span>|</span><a href="#42702377">next</a><span>|</span><label class="collapse" for="c-42704967">[-]</label><label class="expand" for="c-42704967">[1 more]</label></div><br/><div class="children"><div class="content">A fairly clear hierarchy emerges with enough experience, I think, but I don&#x27;t know if there&#x27;s explicit consensus about it of the kind that could make its way into documentation. Here are the rules of thumb, though (in a kind of priority order):<p>0. If you&#x27;re new and on the fence about using flakes, go ahead. (If you know you don&#x27;t want them, fine.)<p>1. Prefer declarative installation to imperative installation.<p>2. If a module exists, prefer using it to configure a package to just adding that package to a list of installed packages.<p>3. &#x27;Native&#x27; packages are better than &#x27;alien&#x27; packages.<p>3a. Packaged for Nix is better than managed externally. (I.e., prefer that programs live in the Nix store rather than Flatpak or Homebrew.)<p>3b. Prefer packages built from source to packages carved out of foreign binaries.<p>4. Prefer to just rely on Nixpkgs for things that are already in Nixpkgs; only bother with other sources of Nix code (likely distributed as &#x27;flakes&#x27;) if you know you need them.<p>5. Prefer smaller installation scopes to larger installation scopes— when installing a package, go with the first of these that will work: per-session (i.e., ephemeral dev env) -&gt; per-user -&gt; system-wide).<p>6. Prefer Nixlang to not-Nixlang (YAML, JSON, TOML, whatever).<p>7. If you&#x27;re not sure, go for it.<p>If you follow these guidelines you&#x27;ll make reasonable choices and likely have a decent time. The most important rule is #1, so once you know your OS, your task is to make sure you have at least one module system available to you. (On NixOS, that&#x27;s NixOS and optionally Home Manager. On other Linux, that&#x27;s Home Manager. On macOS, that&#x27;s Home Manager and&#x2F;or Nix-Darwin.)<p>After that, everything can find its natural place according to the constraints above. If you need to break or relax a rule, it&#x27;ll be obvious.<p>Inevitably you&#x27;ll end up with things installed in a handful of ways and places, but you&#x27;ll know why each thing belongs where it is, and you can leave yourself a note with a &#x27;#&#x27; character anywhere that you think a reminder might be useful. :)</div><br/></div></div><div id="42702377" class="c"><input type="checkbox" id="c-42702377" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42670589">parent</a><span>|</span><a href="#42704967">prev</a><span>|</span><a href="#42673017">next</a><span>|</span><label class="collapse" for="c-42702377">[-]</label><label class="expand" for="c-42702377">[1 more]</label></div><br/><div class="children"><div class="content">I think there probably actually isn&#x27;t one &quot;correct&quot; way.<p>Anything that is best configured with a nixos module should probably be in your system configuration, but beyond that there are probably a lot more than 5 different ways and they have their advantages and disadvantages.<p>What I settled on was a per-user declarative setup (first with &quot;nix-env -r&quot;, now with &quot;nix profile&quot;).  Then I use nix shells to run software for one-offs.  If I find I am running the same software from a nix shell a lot, I toss it in my declarative file.<p>Plenty of people hate this setup, and do something completely different (e.g. imperative managing of profiles, or using home-manager, or a dozen direnv setups).  I don&#x27;t necessarily think any of them are wrong, but they are not for me for various reasons.</div><br/></div></div></div></div><div id="42673017" class="c"><input type="checkbox" id="c-42673017" checked=""/><div class="controls bullet"><span class="by">ris</span><span>|</span><a href="#42670589">prev</a><span>|</span><a href="#42702274">next</a><span>|</span><label class="collapse" for="c-42673017">[-]</label><label class="expand" for="c-42673017">[14 more]</label></div><br/><div class="children"><div class="content">I think this is quite a fair commentry (although I quite like the Nix language personally) - as a nixpkgs developer even I don&#x27;t use NixOS on the desktop. For me it shines on servers and development environments.</div><br/><div id="42673855" class="c"><input type="checkbox" id="c-42673855" checked=""/><div class="controls bullet"><span class="by">tuananh</span><span>|</span><a href="#42673017">parent</a><span>|</span><a href="#42702126">next</a><span>|</span><label class="collapse" for="c-42673855">[-]</label><label class="expand" for="c-42673855">[12 more]</label></div><br/><div class="children"><div class="content">&gt; as a nixpkgs developer even I don&#x27;t use NixOS on the desktop<p>that&#x27;s not every encouraging :)</div><br/><div id="42697029" class="c"><input type="checkbox" id="c-42697029" checked=""/><div class="controls bullet"><span class="by">autra</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42673855">parent</a><span>|</span><a href="#42704606">next</a><span>|</span><label class="collapse" for="c-42697029">[-]</label><label class="expand" for="c-42697029">[3 more]</label></div><br/><div class="children"><div class="content">To counterpoint this, I&#x27;m an happy nixos desktop user. It&#x27;s not perfect, but still vastly better than a non declarative distro for my taste.</div><br/><div id="42703828" class="c"><input type="checkbox" id="c-42703828" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42697029">parent</a><span>|</span><a href="#42701924">next</a><span>|</span><label class="collapse" for="c-42703828">[-]</label><label class="expand" for="c-42703828">[1 more]</label></div><br/><div class="children"><div class="content">Wholeheartedly agree.<p>NixOS gave me back my desire to customise my Linux again. I’ve run Linux since 1997; I’ve run a lot of distros.<p>Having to reconfigure my Linux on every hardware reset (1-2 years apart) just exhausted me to a point where I ran GNOME on Ubuntu so I wouldn’t waste time on one-off stuff.<p>My .emacs and .vimrc shrunk to 10% so I could reproduce them from memory if I had to.<p>With NixOS, installing a new machine and having it work exactly like all my machines is minutes of work.<p>I’ll never lose my hyper-customised setup again.<p>Running something like Arch or Artix again feels very much like losing my “save” button.</div><br/></div></div><div id="42701924" class="c"><input type="checkbox" id="c-42701924" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42697029">parent</a><span>|</span><a href="#42703828">prev</a><span>|</span><a href="#42704606">next</a><span>|</span><label class="collapse" for="c-42701924">[-]</label><label class="expand" for="c-42701924">[1 more]</label></div><br/><div class="children"><div class="content">Seconded. I switched to NixOS a year ago after an apt install broke my system one too many times, and so far I&#x27;ve been very very happy with it. I&#x27;ve broken things, but being able to roll back to an exact duplicate of the previous state has been a lifesaver. I can&#x27;t imagine wanting to go back to repairing broken apt installs.</div><br/></div></div></div></div><div id="42704606" class="c"><input type="checkbox" id="c-42704606" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42673855">parent</a><span>|</span><a href="#42697029">prev</a><span>|</span><a href="#42674230">next</a><span>|</span><label class="collapse" for="c-42704606">[-]</label><label class="expand" for="c-42704606">[1 more]</label></div><br/><div class="children"><div class="content">It mostly goes the other way, I think. The community surveys haven&#x27;t asked about NixOS desktop usage in particular. Still, I&#x27;m certain that a large majority of contributors are running NixOS on their desktops&#x2F;laptops&#x2F;workstations.<p>That said there are prolific and longstanding contributors who focus on non-NixOS and even non-Linux platforms, and corporate users are likely to be running Nix on macOS or Ubuntu (under WSL). It&#x27;s not surprising that some users who don&#x27;t use NixOS on laptops or desktops have still become Nixpkgs contributors or maintainers, imo.</div><br/></div></div><div id="42674230" class="c"><input type="checkbox" id="c-42674230" checked=""/><div class="controls bullet"><span class="by">ris</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42673855">parent</a><span>|</span><a href="#42704606">prev</a><span>|</span><a href="#42702126">next</a><span>|</span><label class="collapse" for="c-42674230">[-]</label><label class="expand" for="c-42674230">[7 more]</label></div><br/><div class="children"><div class="content">Why? It just isn&#x27;t what draws me to Nix.<p>I&#x27;ve never even really tried NixOS on the desktop TBH.</div><br/><div id="42674377" class="c"><input type="checkbox" id="c-42674377" checked=""/><div class="controls bullet"><span class="by">tuananh</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42674230">parent</a><span>|</span><a href="#42702126">next</a><span>|</span><label class="collapse" for="c-42674377">[-]</label><label class="expand" for="c-42674377">[6 more]</label></div><br/><div class="children"><div class="content">nothing. it&#x27;s just from someone with no experience with nix like me, it feel weird that someone is already deep into Nix but isn&#x27;t tempted to use it daily.</div><br/><div id="42680360" class="c"><input type="checkbox" id="c-42680360" checked=""/><div class="controls bullet"><span class="by">wpm</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42674377">parent</a><span>|</span><a href="#42691394">next</a><span>|</span><label class="collapse" for="c-42680360">[-]</label><label class="expand" for="c-42680360">[2 more]</label></div><br/><div class="children"><div class="content">Maybe it’s everyone else using it on their daily driver that got it wrong?<p>It’s like doubting Kubernetes because one of the maintainers doesn’t run their desktop in KubeVirt.</div><br/><div id="42702190" class="c"><input type="checkbox" id="c-42702190" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42680360">parent</a><span>|</span><a href="#42691394">next</a><span>|</span><label class="collapse" for="c-42702190">[-]</label><label class="expand" for="c-42702190">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more like Microsoft folks running macs; technically valid, but odd optics. Besides, why would you use KubeVirt to run your desktop? Just run it in containers directly.</div><br/></div></div></div></div><div id="42691394" class="c"><input type="checkbox" id="c-42691394" checked=""/><div class="controls bullet"><span class="by">jmartens</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42674377">parent</a><span>|</span><a href="#42680360">prev</a><span>|</span><a href="#42677957">next</a><span>|</span><label class="collapse" for="c-42691394">[-]</label><label class="expand" for="c-42691394">[1 more]</label></div><br/><div class="children"><div class="content">What is so interesting about Nix is that it&#x27;s not one thing. Its not (just) a distro. Its not (just) a package manager. Its not (just) a system manager. Its not (just) a language. Its not (just) a build tool.<p>It is all those things, but specifically, what you want it to be. Yes, that makes it super confusing, but also powerful.</div><br/></div></div><div id="42677957" class="c"><input type="checkbox" id="c-42677957" checked=""/><div class="controls bullet"><span class="by">woile</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42674377">parent</a><span>|</span><a href="#42691394">prev</a><span>|</span><a href="#42674701">next</a><span>|</span><label class="collapse" for="c-42677957">[-]</label><label class="expand" for="c-42677957">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using nix in a Mac for a year now. Recently I got a new Lenovo machine and first thing I did was install nixos, it&#x27;s actually much better than I was expecting. You do notice that nix is designed around nixos</div><br/></div></div><div id="42674701" class="c"><input type="checkbox" id="c-42674701" checked=""/><div class="controls bullet"><span class="by">cbrozefsky</span><span>|</span><a href="#42673017">root</a><span>|</span><a href="#42674377">parent</a><span>|</span><a href="#42677957">prev</a><span>|</span><a href="#42702126">next</a><span>|</span><label class="collapse" for="c-42674701">[-]</label><label class="expand" for="c-42674701">[1 more]</label></div><br/><div class="children"><div class="content">You can use it daily, intimately, without using nixos.  Using it for dev environments on macos for example, and servers.  Did that for years before I installed nixos on my desktop.</div><br/></div></div></div></div></div></div></div></div><div id="42702126" class="c"><input type="checkbox" id="c-42702126" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42673017">parent</a><span>|</span><a href="#42673855">prev</a><span>|</span><a href="#42702274">next</a><span>|</span><label class="collapse" for="c-42702126">[-]</label><label class="expand" for="c-42702126">[1 more]</label></div><br/><div class="children"><div class="content">As a counterpoint, I&#x27;m rather the opposite of you:<p>1. I use Nix primarily on the desktop (2 laptops, 2 workstations), though I also use it on one server.  I don&#x27;t think I could ever go back to any other Linux distro for my daily-driver.  Things &quot;just work&quot; to a degree that they never have for me on e.g. Ubuntu.<p>2. I quite despise the Nix language; this is not to say that I think it&#x27;s particularly bad (or good) as a language, just that nearly every single degree-of-freedom in language design that is largely about personal taste takes the opposite choice to what I would prefer<p>3. I find setting up development environments with it to be very hit-or-miss, to the point where I have in some cases fallen back on what I would do without nix, and used nix-ld to fill in the gaps.</div><br/></div></div></div></div><div id="42702274" class="c"><input type="checkbox" id="c-42702274" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#42673017">prev</a><span>|</span><a href="#42704204">next</a><span>|</span><label class="collapse" for="c-42702274">[-]</label><label class="expand" for="c-42702274">[9 more]</label></div><br/><div class="children"><div class="content">I courted making the switch to NixOS a couple times, but I just don&#x27;t really see the value add to me right now. Yes, if you have a lot of machines then it maybe make sense.<p>At this point I just use Nix home manager for my dotfiles&#x2F;userspace programs on a normal distro and I feel like I get 90% of the benefit without any of the headaches.</div><br/><div id="42703832" class="c"><input type="checkbox" id="c-42703832" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42702274">parent</a><span>|</span><a href="#42702454">next</a><span>|</span><label class="collapse" for="c-42703832">[-]</label><label class="expand" for="c-42703832">[3 more]</label></div><br/><div class="children"><div class="content">The reason I keep it around on my laptop is mostly because of the snapshotting.<p>I generally do know my way around Linux command line nowadays, but with Ubuntu and Arch (especially early in my career when I didn&#x27;t know what I was doing), I would get into states that break the video driver, or break GRUB, or make the machine unstable, and the only thing I could do was reinstall the whole OS.<p>With NixOS, since it&#x27;s all declarative, if I end up really breaking something, I can always reboot and choose a previous generation. It makes things a lot less scary for me, I can experiment with and play with different boot parameters and drivers and I know that I won&#x27;t be stuck spending two hours reinstalling everything. It changes the entire way that I work.<p>For example, on my current laptop (Lenovo Thinkpad, AMD), I was having an issue with my USB ports idling out, so sometimes the first ~4 seconds of my typing wasn&#x27;t registering since the USB port had to wake up.  The solution involved adding a kernel parameter `usbcore.autosuspend=-1`.<p>Had this been something like Ubuntu, I have been burned enough trying to add kernel params that I might honestly have just lived with the annoyance because I didn&#x27;t want to risk everything breaking, but because I knew that there was no actual risk with NixOS, I was able to fix it permanently, and I have the solution committed to Git if I ever have to do this on another computer.</div><br/><div id="42705894" class="c"><input type="checkbox" id="c-42705894" checked=""/><div class="controls bullet"><span class="by">smj-edison</span><span>|</span><a href="#42702274">root</a><span>|</span><a href="#42703832">parent</a><span>|</span><a href="#42702454">next</a><span>|</span><label class="collapse" for="c-42705894">[-]</label><label class="expand" for="c-42705894">[2 more]</label></div><br/><div class="children"><div class="content">Just a side note for those who aren&#x27;t on NixOS, but who would like 90% of snapshotting: use timeshift. Especially if your file system is BTRFS. It&#x27;ll do daily snapshots of all your system files, going back 5 days by default. I&#x27;ve only had to use it once, but it was invaluable. Another nice thing is it&#x27;s very much a set-and-forget program.</div><br/><div id="42706553" class="c"><input type="checkbox" id="c-42706553" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42702274">root</a><span>|</span><a href="#42705894">parent</a><span>|</span><a href="#42702454">next</a><span>|</span><label class="collapse" for="c-42706553">[-]</label><label class="expand" for="c-42706553">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, timeshift is pretty cool too.  I think I prefer NixOS&#x27;s style as it&#x27;s directly integrated into the rebuild system, and the dedicated Nix store allows me to do the snapshots while also being persistent, but if you don&#x27;t want to drink the NixOS Kool-aid, timeshift is definitely a valuable tool.</div><br/></div></div></div></div></div></div><div id="42702454" class="c"><input type="checkbox" id="c-42702454" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#42702274">parent</a><span>|</span><a href="#42703832">prev</a><span>|</span><a href="#42706377">next</a><span>|</span><label class="collapse" for="c-42702454">[-]</label><label class="expand" for="c-42702454">[1 more]</label></div><br/><div class="children"><div class="content">&gt;At this point I just use Nix home manager for my dotfiles&#x2F;userspace programs on a normal distro and I feel like I get 90% of the benefit without any of the headaches.<p>If it works for you, sounds good!<p>I comment because I recently had opposite thoughts - that maybe I should migrate off nix home manager - to keep 90% of benefits (nixos) and avoid all the headaches (home manager quirks). Funny how opposite experience we have.<p>For me I love nixos because how when I configure something it just works, and how when I break something I can just undo that easily. And I like how my system don&#x27;t get more cruft with time and stays lean.</div><br/></div></div><div id="42706377" class="c"><input type="checkbox" id="c-42706377" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42702274">parent</a><span>|</span><a href="#42702454">prev</a><span>|</span><a href="#42704204">next</a><span>|</span><label class="collapse" for="c-42706377">[-]</label><label class="expand" for="c-42706377">[4 more]</label></div><br/><div class="children"><div class="content">I delete your entire system file system right now. How fucked are you?<p>With NixOS: I don&#x27;t care. You can recover from a half deleted root file system.</div><br/><div id="42706596" class="c"><input type="checkbox" id="c-42706596" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#42702274">root</a><span>|</span><a href="#42706377">parent</a><span>|</span><a href="#42707214">next</a><span>|</span><label class="collapse" for="c-42706596">[-]</label><label class="expand" for="c-42706596">[2 more]</label></div><br/><div class="children"><div class="content">My root filesystem is actually just in-memory for NixOS using tmpfs [1].  If you were to trash my root filesystem, I just reboot and it&#x27;s restored. I know of no other operating system that allows something like that.<p>To quote a friend: &quot;A new car smell on every reboot.&quot;<p>[1] <a href="https:&#x2F;&#x2F;elis.nu&#x2F;blog&#x2F;2020&#x2F;05&#x2F;nixos-tmpfs-as-root&#x2F;" rel="nofollow">https:&#x2F;&#x2F;elis.nu&#x2F;blog&#x2F;2020&#x2F;05&#x2F;nixos-tmpfs-as-root&#x2F;</a></div><br/><div id="42707597" class="c"><input type="checkbox" id="c-42707597" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#42702274">root</a><span>|</span><a href="#42706596">parent</a><span>|</span><a href="#42707214">next</a><span>|</span><label class="collapse" for="c-42707597">[-]</label><label class="expand" for="c-42707597">[1 more]</label></div><br/><div class="children"><div class="content">Well OpenWRT does, but probably not what you want on your laptop :-)</div><br/></div></div></div></div><div id="42707214" class="c"><input type="checkbox" id="c-42707214" checked=""/><div class="controls bullet"><span class="by">yoyohello13</span><span>|</span><a href="#42702274">root</a><span>|</span><a href="#42706377">parent</a><span>|</span><a href="#42706596">prev</a><span>|</span><a href="#42704204">next</a><span>|</span><label class="collapse" for="c-42707214">[-]</label><label class="expand" for="c-42707214">[1 more]</label></div><br/><div class="children"><div class="content">Lol, please don&#x27;t. I do take regular snapshots so it probably wouldn&#x27;t be too bad.</div><br/></div></div></div></div></div></div><div id="42704204" class="c"><input type="checkbox" id="c-42704204" checked=""/><div class="controls bullet"><span class="by">captainepoch</span><span>|</span><a href="#42702274">prev</a><span>|</span><a href="#42706255">next</a><span>|</span><label class="collapse" for="c-42704204">[-]</label><label class="expand" for="c-42704204">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems very cool that you can roll back in the case of a catastrophic upgrade failure, but has that every happened to you? Not me.<p>It did, and thanks to that rollback feature, my system was working in a few minutes.</div><br/></div></div><div id="42706255" class="c"><input type="checkbox" id="c-42706255" checked=""/><div class="controls bullet"><span class="by">sweetsocks21</span><span>|</span><a href="#42704204">prev</a><span>|</span><a href="#42706307">next</a><span>|</span><label class="collapse" for="c-42706255">[-]</label><label class="expand" for="c-42706255">[1 more]</label></div><br/><div class="children"><div class="content">I will say I really love the outcome of a Nix development environment. Especially with nix-direnv having a reproducible build environment by doing git clone on any machine is amazing. NixOS has also saved my ass a couple times doing kernel updates on an old laptop, rollbacks are nice. Having consistent commands &quot;nix build&quot;&#x2F;&quot;nix run&quot; is great. It&#x27;s a universal build system that works across different technology stacks. Pain to setup, but bliss when it&#x27;s working.<p>The bad part is the impenetrable errors and obscure configuration. Although, with the rise of LLMs I find it&#x27;s not as bad. Getting a non-trivial flake.nix setup is much easier now. Could never remember the override system before, but can manage with Chat GPT haha.</div><br/></div></div><div id="42706307" class="c"><input type="checkbox" id="c-42706307" checked=""/><div class="controls bullet"><span class="by">davidee</span><span>|</span><a href="#42706255">prev</a><span>|</span><a href="#42705484">next</a><span>|</span><label class="collapse" for="c-42706307">[-]</label><label class="expand" for="c-42706307">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried Nix on a couple of occasions, most recently about two months ago, and ended up coming to the conclusion that it&#x27;s just not for me.<p>I can see the value in a completely declarative configuration for my OS.<p>But the hurdles to get something worthwhile out of that value prop are just too high with my (low) level of skill (in this area) coupled with the limited time I have to build new skills. There are other things I want to invest my time in, but I can totally see this being where someone wants to spend some of their time.<p>I&#x27;ve never found setting up a Linux distro the way I want it particularly hard and once in a while I like to just start from a blank slate to see what&#x27;s new—so yeah, not for me.</div><br/></div></div><div id="42705484" class="c"><input type="checkbox" id="c-42705484" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#42706307">prev</a><span>|</span><a href="#42704885">next</a><span>|</span><label class="collapse" for="c-42705484">[-]</label><label class="expand" for="c-42705484">[1 more]</label></div><br/><div class="children"><div class="content">I generally agree.<p>Nix is an excellent build tool. I use it for all of my projects now. And when building is tricky, e.g. Elixir, I rely on Nix devshells to get my tools setup.<p>NixOS is an amazing <i>server</i> distro. My primary home server VM is running NixOS and it has been rock solid and easy to maintain. I plan to run NixOS exclusively as I add more machines.<p>But I haven’t had a good experience with NixOS on my development VM (as compared to Ubuntu or Debian). You end up spending more work than expected up front just to get something working. One recent frustrating experience was trying to get VS Code Server to run on NixOS so that I could connect to it over SSH. Ultimately I just gave up.</div><br/></div></div><div id="42704885" class="c"><input type="checkbox" id="c-42704885" checked=""/><div class="controls bullet"><span class="by">grep_name</span><span>|</span><a href="#42705484">prev</a><span>|</span><a href="#42706395">next</a><span>|</span><label class="collapse" for="c-42704885">[-]</label><label class="expand" for="c-42704885">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using nixOS on my laptop for over a year now and I still don&#x27;t have an answer for &#x27;my version of firefox&#x2F;darktable has a bug in it, but I can&#x27;t update it without upgrading the entire rest of all the software installed on my machine.&#x27; I keep thinking there has to be a way around this, but it doesn&#x27;t seem like there is one that&#x27;s clean and not hacky &#x2F; brittle. Other than that I love it, but that&#x27;s a pretty huge caveat</div><br/><div id="42705648" class="c"><input type="checkbox" id="c-42705648" checked=""/><div class="controls bullet"><span class="by">Chris_Newton</span><span>|</span><a href="#42704885">parent</a><span>|</span><a href="#42705098">next</a><span>|</span><label class="collapse" for="c-42705648">[-]</label><label class="expand" for="c-42705648">[1 more]</label></div><br/><div class="children"><div class="content">Have you come across Nix Package Versions¹ yet? If you’re looking to work around a recent bug or other unwanted change by installing a slightly older version of some package from nixpkgs, Marcelo Lazaroni built a nice page to help with that and wrote up an explanation² of how it works.<p>This only works for versions of your package that do exist in nixpkgs but aren’t currently the default for your chosen channel, so it doesn’t help if your channel is out of date and you want to install a newer version that hasn’t been packaged yet. But then that’s the case in almost any Linux distro if you rely on installing your software from the distro’s native package repo, and much the same solutions exist in NixOS as in other distros. Although if you’re really determined, you can also start writing your own derivations to automate building the latest versions of your favourite applications before they’re available from nixpkgs…<p>¹ <a href="https:&#x2F;&#x2F;lazamar.co.uk&#x2F;nix-versions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lazamar.co.uk&#x2F;nix-versions&#x2F;</a><p>² <a href="https:&#x2F;&#x2F;lazamar.github.io&#x2F;download-specific-package-version-with-nix&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lazamar.github.io&#x2F;download-specific-package-version-...</a></div><br/></div></div><div id="42705098" class="c"><input type="checkbox" id="c-42705098" checked=""/><div class="controls bullet"><span class="by">thomastjeffery</span><span>|</span><a href="#42704885">parent</a><span>|</span><a href="#42705648">prev</a><span>|</span><a href="#42706395">next</a><span>|</span><label class="collapse" for="c-42705098">[-]</label><label class="expand" for="c-42705098">[1 more]</label></div><br/><div class="children"><div class="content">As with most situations in Nix, there is an elegant and clean solution; but that solution is also hacky and somewhat obfuscated.<p>The problem really stems from how tightly entangled packages are to the nixpkgs source tree. Nix offers the most foundationally modular system possible, and it organizes its packages <i>in a monolithic source tree</i>! This means that despite <i>installed</i> packages being totally isolated in the &#x2F;nix&#x2F;store&#x2F;, the package <i>source</i> (what Nix calls a &quot;derivation&quot;) is semantically tied to whatever specific dependency version was implemented in the contemporary nixpkgs source. If you want to <i>provide</i> users more than one version of a package inside the same source tree, you must put the version in the name, like SDL2 or python3.11.<p>I started this GitHub issue a long time ago: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;issues&#x2F;93327">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;issues&#x2F;93327</a>. Somewhere buried inside may lie the answer to your question. Either way, I have mostly given up on wrapping my head around the current ecosystem of half-baked solutions to this mess; despite still actively using NixOS in ignorance.</div><br/></div></div></div></div><div id="42706395" class="c"><input type="checkbox" id="c-42706395" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42704885">prev</a><span>|</span><a href="#42702682">next</a><span>|</span><label class="collapse" for="c-42706395">[-]</label><label class="expand" for="c-42706395">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used Debian for 3 years and all the problems I had with it and that are now solved with NixOS and replaced with a complete new set of problems I could only dream in my wettest dreams on Debian. Only going back over woodwork to Debian.</div><br/></div></div><div id="42702682" class="c"><input type="checkbox" id="c-42702682" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#42706395">prev</a><span>|</span><a href="#42706386">next</a><span>|</span><label class="collapse" for="c-42702682">[-]</label><label class="expand" for="c-42702682">[9 more]</label></div><br/><div class="children"><div class="content">So a server that&#x27;s dedicated to well-supported(by nixos) services running NixOS is awesome. it&#x27;s easy to upgrade every 6 months and generally very painless. Everything else is a PITA though. Of course if you use an LTS like Debian Stable or Ubuntu, you only have to upgrade every 5-ish years, so unless you always <i>need</i> the latest and greatest release of something, it maybe isn&#x27;t worth the hassle.<p>Trying to hack on other people&#x27;s junk with NixOS is just asking for pain. Just use Ubuntu LTS like everyone else. That&#x27;s generally easy and painless.</div><br/><div id="42702997" class="c"><input type="checkbox" id="c-42702997" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42702682">parent</a><span>|</span><a href="#42706388">next</a><span>|</span><label class="collapse" for="c-42702997">[-]</label><label class="expand" for="c-42702997">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Trying to hack on other people&#x27;s junk with NixOS is just asking for pain.&quot;<p>To me that&#x27;s a large part of the very definition of a useful general purpose OS is that it&#x27;s flexible and enables you to do whatever you need to do today, without the developers having previously somehow planned and provided for exactly that thing.<p>It&#x27;s like the systemd argument all over. The exact thing systemd aims to prevent is the exact thing that made the original unix so powerful and useful that 40 years after architecting it, it still worked because they didn&#x27;t try to think of every possibility, they gave you a toolbox that let you do whatever you might need to do. Where systemd sees a shell script as &quot;unmanaged chaos&quot; I see &quot;unconstrained utiliy&quot;, a useful toolbox including a saw that doesn&#x27;t have it&#x27;s own opinions about me what boards I can cut.<p>If &quot;Trying to hack on other people&#x27;s junk with NixOS is just asking for pain.&quot; that is basically the definition of &quot;this is not a useful operating system that empowers me to get things done&quot;. It&#x27;s useful maybe as a crafted firmware for a static device.<p>(Not saying that nixos inflexibility is driven by the same paternal &quot;we&#x27;ll give you the whitelist of actions Poettering thinks are valid&quot; attitude as systemd. In nixos it&#x27;s merely a natural consequence of indirection and layering. They aren&#x27;t trying to remove any agency from the user&#x2F;admin, it&#x27;s just the simple indirection itself that makes pre-planned and standardized things easier at the expense of anything direct and unplanned becoming harder.<p>Like instead of having an OS that may or may not be driven by ansible, let&#x27;s replace the OS with just ansible, and now there is no way to do anything any other way except by figuring out how to write a playbook to do it.)</div><br/><div id="42703708" class="c"><input type="checkbox" id="c-42703708" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#42702682">root</a><span>|</span><a href="#42702997">parent</a><span>|</span><a href="#42704410">next</a><span>|</span><label class="collapse" for="c-42703708">[-]</label><label class="expand" for="c-42703708">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To me that&#x27;s a large part of the very definition of a useful general purpose OS is that it&#x27;s flexible and enables you to do whatever you need to do today,<p>NixOS gains most of its power from restrictions. These restrictions enable awesome things like starting a shell with all dependencies in seconds versus minutes using alternative technologies (used by great effect by replit). Nix works surprisingly well for most software, but anything with a ton of dynamic dependencies is going to cause issues. Even knowing what the dependencies <i>might be</i> statically can be hard. Sure, providing an OS with no restrictions and complete flexibility is an option, but then you&#x27;ll just end up no better off.<p>Whatever the future of operating systems will be, it certainly will involve more restrictions and less flexibility.</div><br/></div></div><div id="42704410" class="c"><input type="checkbox" id="c-42704410" checked=""/><div class="controls bullet"><span class="by">cb321</span><span>|</span><a href="#42702682">root</a><span>|</span><a href="#42702997">parent</a><span>|</span><a href="#42703708">prev</a><span>|</span><a href="#42706388">next</a><span>|</span><label class="collapse" for="c-42704410">[-]</label><label class="expand" for="c-42704410">[2 more]</label></div><br/><div class="children"><div class="content">Not to be too presumptuous, but you sound like someone would might like Gentoo.  It still works without systemd, though it does install sys-apps&#x2F;systemd-utils (mostly for the &#x2F;dev FS stuff).  I&#x27;d say the focus of Gentoo is on &quot;managing choice&quot;, and it is true that some choices can make your system(s) diverge from the most frequent instances floating around (but those tend to be systemd-based these days).  It&#x27;s still pretty decent, though.  I&#x27;ve been incrementally upgrading the same basic install since Jan, 2007.  Of course, you may already know all about it and have other opinions.</div><br/><div id="42708304" class="c"><input type="checkbox" id="c-42708304" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42702682">root</a><span>|</span><a href="#42704410">parent</a><span>|</span><a href="#42706388">next</a><span>|</span><label class="collapse" for="c-42708304">[-]</label><label class="expand" for="c-42708304">[1 more]</label></div><br/><div class="children"><div class="content">Safe presumtion. I never used it for real but for instance I like freebsd and the ports system, prefer macports to brew etc.</div><br/></div></div></div></div></div></div><div id="42706388" class="c"><input type="checkbox" id="c-42706388" checked=""/><div class="controls bullet"><span class="by">SuperSandro2000</span><span>|</span><a href="#42702682">parent</a><span>|</span><a href="#42702997">prev</a><span>|</span><a href="#42704717">next</a><span>|</span><label class="collapse" for="c-42706388">[-]</label><label class="expand" for="c-42706388">[2 more]</label></div><br/><div class="children"><div class="content">LTS is harming the industry and holding everything back! IMO it is the wrong direction.</div><br/><div id="42706457" class="c"><input type="checkbox" id="c-42706457" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#42702682">root</a><span>|</span><a href="#42706388">parent</a><span>|</span><a href="#42704717">next</a><span>|</span><label class="collapse" for="c-42706457">[-]</label><label class="expand" for="c-42706457">[1 more]</label></div><br/><div class="children"><div class="content">Why do you think that? That seems like a pretty extreme viewpoint to me.<p>Stability is a great thing for busy professionals that want stuff to just work.<p>How many apps have you upgraded that have crashed and burned from the update? Me, a lot. both commercial and OSS.  With OSS at least you get all the pieces so you can figure out how to put it back together again. With Commercial, you rollback, file a bug report and hope someone somewhere in the company will be incentivized enough to fix it for you.</div><br/></div></div></div></div><div id="42704717" class="c"><input type="checkbox" id="c-42704717" checked=""/><div class="controls bullet"><span class="by">mazambazz</span><span>|</span><a href="#42702682">parent</a><span>|</span><a href="#42706388">prev</a><span>|</span><a href="#42706386">next</a><span>|</span><label class="collapse" for="c-42704717">[-]</label><label class="expand" for="c-42704717">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Trying to hack on other people&#x27;s junk with NixOS is just asking for pain.<p>Yeah, but being that Nix is essentially a giant wrapper for the system, that kind of goes without saying. The other side of the coin is that, using other people&#x27;s Nix junk is extremely easy. Far easier than what any other distro could hope to achieve.<p>My favorite example is simple-nixos-mailserver. Try passing someone a dovecot, postfix, and openssh configurations&#x2F;instructions in any other distro and see how long it takes before they mess up, or more likely, give up.<p>Whereas with simple-nixos-mailserver, you&#x27;re guaranteed to get something to work, essentially right out of the box.</div><br/><div id="42705371" class="c"><input type="checkbox" id="c-42705371" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#42702682">root</a><span>|</span><a href="#42704717">parent</a><span>|</span><a href="#42706386">next</a><span>|</span><label class="collapse" for="c-42705371">[-]</label><label class="expand" for="c-42705371">[1 more]</label></div><br/><div class="children"><div class="content">agreed. Like I said, if what you want to do is within NixOS&#x27;s well supported wheelhouse, it&#x27;s great to have a fully declarative OS, that includes application configuration.</div><br/></div></div></div></div></div></div><div id="42706386" class="c"><input type="checkbox" id="c-42706386" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#42702682">prev</a><span>|</span><a href="#42674215">next</a><span>|</span><label class="collapse" for="c-42706386">[-]</label><label class="expand" for="c-42706386">[1 more]</label></div><br/><div class="children"><div class="content">Im temporarily keeping nix on single use machines and lxc. Eg places that are just a docker host etc. for that and cicd uses cases it should be fine.<p>The multitude of ways things can be configured spooked me a bit for desktop use though.</div><br/></div></div><div id="42674215" class="c"><input type="checkbox" id="c-42674215" checked=""/><div class="controls bullet"><span class="by">nunez</span><span>|</span><a href="#42706386">prev</a><span>|</span><a href="#42704125">next</a><span>|</span><label class="collapse" for="c-42674215">[-]</label><label class="expand" for="c-42674215">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like more clarity on this:<p>&gt; The advantage over docker here is that (when using Flakes) Nix builds are completely reproducible. Docker containers may be isolated, but surprisingly they are not deterministic out of the box. With some work you can make docker deterministic, but thats what you need, its much easier to use Nix.<p>as the whole purpose of the Dockerfile is to create a reproducible environment.</div><br/><div id="42704154" class="c"><input type="checkbox" id="c-42704154" checked=""/><div class="controls bullet"><span class="by">thln666</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42702166">next</a><span>|</span><label class="collapse" for="c-42704154">[-]</label><label class="expand" for="c-42704154">[1 more]</label></div><br/><div class="children"><div class="content">The whole purpose of the Dockerfile is not to create a reproducible environment. The purpose of a Dockerfile is to run a bunch of commands inside of a container and save the output. Those commands may or may not produce the same output every time they&#x27;re run.<p>For example, if you have a debian base container that you run `apt install nginx` in, what version you actually get depends on a lot of different things including what the current version of nginx is inside of the remote repositories you&#x27;re installing from _when the docker build command is executed_, not when the Dockerfile is written.<p>So, if you do &quot;docker build .&quot; today, and then the same thing 6 months from now, you will probably not get the same thing. Thus, Dockerfiles are not reproducible without a lot of extra work.<p>Nix flakes are not like that - they tag _exact_ versions of every input in the flake.lock, so a build 6 months from now will give you the _exact same system_ as you have today, given the same input. This is the same as like an npm lock file or a fully-specified python requirements.txt (where you have each package with an ==&lt;version&gt;).<p>So, you definitely can make Dockerfiles reproducible, but again, the Dockerfile itself is not made to do that.<p>Hope that helps your understanding here!</div><br/></div></div><div id="42702166" class="c"><input type="checkbox" id="c-42702166" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42704154">prev</a><span>|</span><a href="#42674560">next</a><span>|</span><label class="collapse" for="c-42702166">[-]</label><label class="expand" for="c-42702166">[1 more]</label></div><br/><div class="children"><div class="content">Do any of your Dockerfiles make e.g. apt calls?  If so, then they will get a different version of software installed when built on different days, because that will depend on the state of the package servers.<p>A more trivial example of non-deterministic would be that you can write a Dockerfile that uses curl to fetch data from random.org; the functions nix provides for fetching from URLs require you to specify the sha-sum of the data you fetch.<p>Nix flakes make it hard for you to inject anything into your dependencies that hasn&#x27;t been hashed to confirm its identity.  It in many cases still isn&#x27;t 100% deterministic (consider e.g. a multithreaded build system where orderings can influence the output), but it&#x27;s a big improvement.</div><br/></div></div><div id="42674560" class="c"><input type="checkbox" id="c-42674560" checked=""/><div class="controls bullet"><span class="by">JamesSwift</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42702166">prev</a><span>|</span><a href="#42674436">next</a><span>|</span><label class="collapse" for="c-42674560">[-]</label><label class="expand" for="c-42674560">[1 more]</label></div><br/><div class="children"><div class="content">Its reproducible at a superficial level. Tags are mutable, so someone can push a different “3.1” between build 1 and 2, which results in a different build. You can also be fuzzy with tags, so if you say “from nginx:3” as your base (or nginx:latest) then build 1 and 2 can change because of a new tagged build upstream.<p>Then theres the million app-level changes that can creep in, eg copying local source is non-deterministic, apt-update, git clone, etc. Nix requires you to be fully explicit about the hash of the content you expect in each of those cases and so if you build it twice it is actually the same build.</div><br/></div></div><div id="42674436" class="c"><input type="checkbox" id="c-42674436" checked=""/><div class="controls bullet"><span class="by">theossuary</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42674560">prev</a><span>|</span><a href="#42675680">next</a><span>|</span><label class="collapse" for="c-42674436">[-]</label><label class="expand" for="c-42674436">[1 more]</label></div><br/><div class="children"><div class="content">I guess you could consider a docker image a &quot;reproducible environment,&quot; but it&#x27;s certainly not a reproducible build; running docker build twice on the same directory isn&#x27;t guaranteed to give you the same image. You could put in the work to make it a reproducible build, but it doesn&#x27;t do anything to help you achieve that. Nix defaults to reproducible builds, and requires flags for &quot;impure&quot; non-reproducible builds. It does this by requiring all dependencies be managed by nix, and all sources be copied into the nix store.</div><br/></div></div><div id="42675680" class="c"><input type="checkbox" id="c-42675680" checked=""/><div class="controls bullet"><span class="by">jonotime</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42674436">prev</a><span>|</span><a href="#42704150">next</a><span>|</span><label class="collapse" for="c-42675680">[-]</label><label class="expand" for="c-42675680">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>The idea with nix flakes is it has a lock file which should guarantee the same build. This is like package-lock.json or pdm.lock which contains dependency checksums for every package.<p>Docker works more like your standard package manager. If you ask for mysql 5, today you may get mysql 5.1, but next week you may get mysql 5.2. So it does not come with a guarantee.</div><br/></div></div><div id="42704150" class="c"><input type="checkbox" id="c-42704150" checked=""/><div class="controls bullet"><span class="by">edude03</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42675680">prev</a><span>|</span><a href="#42702368">next</a><span>|</span><label class="collapse" for="c-42704150">[-]</label><label class="expand" for="c-42704150">[1 more]</label></div><br/><div class="children"><div class="content">Containers are only reproducible at run time not at build time. Once you build a container and pull it down by its sha256, you&#x27;ll get the same environment each time. However if your Dockerfile does any IO (curl, apt get, pip install etc) you&#x27;re quite likely to get different images on different machines.</div><br/></div></div><div id="42702368" class="c"><input type="checkbox" id="c-42702368" checked=""/><div class="controls bullet"><span class="by">soraminazuki</span><span>|</span><a href="#42674215">parent</a><span>|</span><a href="#42704150">prev</a><span>|</span><a href="#42704125">next</a><span>|</span><label class="collapse" for="c-42702368">[-]</label><label class="expand" for="c-42702368">[2 more]</label></div><br/><div class="children"><div class="content">Docker images are just as reproducible as binary blobs, which is essentially what they are.</div><br/><div id="42703901" class="c"><input type="checkbox" id="c-42703901" checked=""/><div class="controls bullet"><span class="by">antonvs</span><span>|</span><a href="#42674215">root</a><span>|</span><a href="#42702368">parent</a><span>|</span><a href="#42704125">next</a><span>|</span><label class="collapse" for="c-42703901">[-]</label><label class="expand" for="c-42703901">[1 more]</label></div><br/><div class="children"><div class="content">Binary blobs can be easily reproducible, depending on how they’re built. By comparison, the “easily” part doesn’t apply to any non-trivial Docker image.<p>The issue is that you have to lock down all your dependencies, including local data, repos, and registries. Most people, and even most companies, don’t have the resources to achieve that, so they simply don’t do it.<p>Further, Docker doesn’t provide any significant mechanisms to help ensure reproducibility in the face of these issues, so you can’t say that Docker <i>supports</i> reproducibility.</div><br/></div></div></div></div></div></div><div id="42704125" class="c"><input type="checkbox" id="c-42704125" checked=""/><div class="controls bullet"><span class="by">ssalka</span><span>|</span><a href="#42674215">prev</a><span>|</span><label class="collapse" for="c-42704125">[-]</label><label class="expand" for="c-42704125">[2 more]</label></div><br/><div class="children"><div class="content">Just want to flag that the first image likening Nix to the Holy Trinity has a spelling error in the text &quot;The Operating Systam&quot;.</div><br/><div id="42706089" class="c"><input type="checkbox" id="c-42706089" checked=""/><div class="controls bullet"><span class="by">antiphase</span><span>|</span><a href="#42704125">parent</a><span>|</span><label class="collapse" for="c-42706089">[-]</label><label class="expand" for="c-42706089">[1 more]</label></div><br/><div class="children"><div class="content">The whole thing is full of speling and grammar errors. The author desperately needs a copy editor.</div><br/></div></div></div></div></div></div></div></div></div></body></html>