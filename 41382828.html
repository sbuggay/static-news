<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724922069026" as="style"/><link rel="stylesheet" href="styles.css?v=1724922069026"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lamport.azurewebsites.net/tla/future.pdf">The Future of TLA+ [pdf]</a> <span class="domain">(<a href="https://lamport.azurewebsites.net">lamport.azurewebsites.net</a>)</span></div><div class="subtext"><span>tkhattra</span> | <span>66 comments</span></div><br/><div><div id="41385480" class="c"><input type="checkbox" id="c-41385480" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#41384788">next</a><span>|</span><label class="collapse" for="c-41385480">[-]</label><label class="expand" for="c-41385480">[4 more]</label></div><br/><div class="children"><div class="content">I may have been spending too much time with Lean recently, but the number one thing I’d like to see for the future of TLA+ is an equivalent of Mathlib (<a href="https:&#x2F;&#x2F;github.com&#x2F;leanprover-community&#x2F;mathlib4">https:&#x2F;&#x2F;github.com&#x2F;leanprover-community&#x2F;mathlib4</a>). What’s so great about the experience of using Lean is that I can pull theorems off the shelf from Mathlib, use them if I want to, or learn from the way their proofs work if I want to do something similar.<p>&gt; The reason for using TLA+ is that it isn’t a programming language; it’s mathematics.<p>I love TLA+, I’ve used it for a decade and reach for it often. I have a huge amount of respect for Leslie Lamport and Chris Newcombe. But I think they’re missing something major here. The sematics of TLA+ are, in my mind, a great set of choices for a whole wide range of systems work. The syntax, on the other hand, is fairly obscure and complex, and makes it harder to learn the language (and, in particular, translate other ways of expressing mathematics into TLA+).<p>I would love to see somebody who thinks deeply about PL syntax to make another language with the same semantics as TLA+, the same goals of looking like mathematics, but more familiar syntax. I don’t know what that would look like, but I’d love to see it.<p>It seems like with the right library (see my mathlib point) and syntax, writing a TLA+ program should be no harder than writing a P program for the same behavior, but that’s not where we are right now.<p>&gt; The errors [types] catch are almost always quickly found by model checking.<p>This hasn’t been my experience, and in fact a lot of the TLA+ programs I see contain partial implementations of arbitrary type checkers. I don’t think TLA+ needs a type system like Coq’s or Lean’s or Haskell’s, but I do think that some level of type enforcement would help avoid whole classes of common specification bugs (or even auto-generation of a type checking specification, which may be the way to go).<p>&gt; [A Coq-like type system] would put TLA+ beyond the ability of so many potential users that no proposal to add them should be taken seriously.<p>I do think this is right, though.<p>&gt; This may turn out to be unnecessary if provers become smarter, which should be possible with the use of AI.<p>Almost definitely will. This just seems like a no-brainer to bet on at this stage. See AlphaProof, moogle.ai, and many other similar examples.<p>&gt; A Unicode representation that can be automatically converted to the ascii version is the best alternative for now.<p>Yes, please! Lean has a unicode representation, along with a nice UI for adding the Unicode operators in VSCode, and it’s awesome. The ASCII encoding is still something I trip over in TLA+, even after a decade of using it.</div><br/><div id="41387905" class="c"><input type="checkbox" id="c-41387905" checked=""/><div class="controls bullet"><span class="by">vanjajaja1</span><span>|</span><a href="#41385480">parent</a><span>|</span><a href="#41386079">next</a><span>|</span><label class="collapse" for="c-41387905">[-]</label><label class="expand" for="c-41387905">[1 more]</label></div><br/><div class="children"><div class="content">I loved the concept of TLA+ and tried to get into it, but as you say<p>&gt; The syntax, on the other hand, is fairly obscure and complex, and makes it harder to learn the language<p>the syntax was very non-standard which was off putting, and the expected dev ux seemed to be of the &#x27;get it right on paper first then just write the text&#x27; variety. This was also off putting and I think you&#x27;re right that there is a space for making a DX focused TLA+ transpiled language</div><br/></div></div><div id="41386079" class="c"><input type="checkbox" id="c-41386079" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#41385480">parent</a><span>|</span><a href="#41387905">prev</a><span>|</span><a href="#41386490">next</a><span>|</span><label class="collapse" for="c-41386079">[-]</label><label class="expand" for="c-41386079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would love to see somebody who thinks deeply about PL syntax to make another language with the same semantics as TLA+<p>Perhaps you would find Quint interesting? <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41111790">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41111790</a><p>There&#x27;s a comment that says Quint uses TLA+ as its base language: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41118162">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41118162</a><p>Disclaimer: I don&#x27;t know anything about TLA+ or Quint, I just remembered seeing Quint here</div><br/></div></div><div id="41386490" class="c"><input type="checkbox" id="c-41386490" checked=""/><div class="controls bullet"><span class="by">pierrefermat1</span><span>|</span><a href="#41385480">parent</a><span>|</span><a href="#41386079">prev</a><span>|</span><a href="#41384788">next</a><span>|</span><label class="collapse" for="c-41386490">[-]</label><label class="expand" for="c-41386490">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only play with TLA+ for a small amount of time but absolutely agree with the maths statement being way off the mark.<p>Building out any real maths with logic operators yourself is just not feasible in a meaningful timescale.</div><br/></div></div></div></div><div id="41384788" class="c"><input type="checkbox" id="c-41384788" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#41385480">prev</a><span>|</span><a href="#41385633">next</a><span>|</span><label class="collapse" for="c-41384788">[-]</label><label class="expand" for="c-41384788">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The [\EE] operator is needed to explain the theory underlying how
TLA+ is used.<p>There&#x27;s another reason to potentially support \EE: it&#x27;s needed to refine specs with auxiliary variables. Currently, if an abstract spec has `aux_hist` to prove a property or something, you <i>need</i> the refinement to have an `aux_hist` equivalent, even if it doesn&#x27;t affect the spec behavior at all. But if checkers could handle `\EE` you could instead leave it out of the refinement and check `\EE aux_hist: Abstract(aux_hist)!Spec`.<p>I think &#x2F;u&#x2F;pron once told me that <i>actually checking</i> a property of that form is 2-EXPTIME complete, though. Which is why it&#x27;s not supported in practice.</div><br/></div></div><div id="41385633" class="c"><input type="checkbox" id="c-41385633" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41384788">prev</a><span>|</span><a href="#41383309">next</a><span>|</span><label class="collapse" for="c-41385633">[-]</label><label class="expand" for="c-41385633">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really not a fan of TLA+&#x27;s tooling, but I do really love the temporal logic. I&#x27;ve always kinda wanted that stuff in other proving languages, but I don&#x27;t know how possible it is.<p>Would it be actually possible to write something like an &quot;a la carte temporal logic library&quot; for other proving languages that could get you some of the confidence you can get from TLA+&#x27;s modeling?<p>(Aside: I have a TLA+ book, but it&#x27;s notably missing really much in terms of exercises or anything. If anyone has any recommendations for a large set of exercises to play around in the space I&#x27;d love to hear about it!)<p>EDIT: turns out just searching for &quot;temporal logic in X language&quot; gets you papers, found this one paper for axiomatizing temporal logic that seems to be a good starting point for anyone looking at this [0]<p>[0]: <a href="https:&#x2F;&#x2F;lim.univ-reunion.fr&#x2F;staff&#x2F;fred&#x2F;Enseignement&#x2F;Verif-M2&#x2F;Articles&#x2F;An%20Axiomatization%20of%20Linear%20Temporal%20Logic%20in%20the%20Calculus%20of%20Inductive%20Constructions-Coupet-Grimal-2002.pdf" rel="nofollow">https:&#x2F;&#x2F;lim.univ-reunion.fr&#x2F;staff&#x2F;fred&#x2F;Enseignement&#x2F;Verif-M2...</a></div><br/><div id="41385888" class="c"><input type="checkbox" id="c-41385888" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#41385633">parent</a><span>|</span><a href="#41383309">next</a><span>|</span><label class="collapse" for="c-41385888">[-]</label><label class="expand" for="c-41385888">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Would it be actually possible to write something like an &quot;a la carte temporal logic library&quot; for other proving languages that could get you some of the confidence you can get from TLA+&#x27;s modeling?<p>Temporal logic is just a specific instance of a modal logic, which can be modeled with reasonable ease using a &quot;possible worlds&quot;-based encoding.  Note that TLA+ combines temporal logic with non-determinism, which is a different modality.</div><br/></div></div></div></div><div id="41383309" class="c"><input type="checkbox" id="c-41383309" checked=""/><div class="controls bullet"><span class="by">bokumo</span><span>|</span><a href="#41385633">prev</a><span>|</span><a href="#41386220">next</a><span>|</span><label class="collapse" for="c-41383309">[-]</label><label class="expand" for="c-41383309">[3 more]</label></div><br/><div class="children"><div class="content">What LaTeX package does one use to get the &quot;back&quot; link at the end of footnotes like the linked PDF exhibits?</div><br/><div id="41383380" class="c"><input type="checkbox" id="c-41383380" checked=""/><div class="controls bullet"><span class="by">gurjeet</span><span>|</span><a href="#41383309">parent</a><span>|</span><a href="#41386532">next</a><span>|</span><label class="collapse" for="c-41383380">[-]</label><label class="expand" for="c-41383380">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s an interesting implementation. I&#x27;m using Firefox, and the jumps to the notes and back to the paragraph are recorded in history, and has the expected effect when clicking the back and forward history arrows&#x2F;buttons.</div><br/></div></div><div id="41386532" class="c"><input type="checkbox" id="c-41386532" checked=""/><div class="controls bullet"><span class="by">evomassiny</span><span>|</span><a href="#41383309">parent</a><span>|</span><a href="#41383380">prev</a><span>|</span><a href="#41386220">next</a><span>|</span><label class="collapse" for="c-41386532">[-]</label><label class="expand" for="c-41386532">[1 more]</label></div><br/><div class="children"><div class="content">hyperref does this with the &quot;\ref{}&quot; command, it can link to any defined \label</div><br/></div></div></div></div><div id="41386220" class="c"><input type="checkbox" id="c-41386220" checked=""/><div class="controls bullet"><span class="by">pnathan</span><span>|</span><a href="#41383309">prev</a><span>|</span><a href="#41384618">next</a><span>|</span><label class="collapse" for="c-41386220">[-]</label><label class="expand" for="c-41386220">[3 more]</label></div><br/><div class="children"><div class="content">I was looking at TLA a few months ago to consider what it would take to prove multiregion fail over worked correctly. Considering I&#x27;d never looked at it before.<p>I did not find it straight forwardly grokkable, which makes me sad. Maybe it needs a library of axioms? I feel there&#x27;s probably a very nice way to work through it without ingesting effectively a graduate school course in proving software.<p>It really is just math and proofs, it shouldn&#x27;t be so hard... to start.<p>Well, that&#x27;s my take. Could be wrong. Might just need to hit the books.</div><br/><div id="41387322" class="c"><input type="checkbox" id="c-41387322" checked=""/><div class="controls bullet"><span class="by">nektro</span><span>|</span><a href="#41386220">parent</a><span>|</span><a href="#41386924">next</a><span>|</span><label class="collapse" for="c-41387322">[-]</label><label class="expand" for="c-41387322">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;video&#x2F;videos.html" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;video&#x2F;videos.html</a> is really excellent</div><br/></div></div><div id="41386924" class="c"><input type="checkbox" id="c-41386924" checked=""/><div class="controls bullet"><span class="by">mjb</span><span>|</span><a href="#41386220">parent</a><span>|</span><a href="#41387322">prev</a><span>|</span><a href="#41384618">next</a><span>|</span><label class="collapse" for="c-41386924">[-]</label><label class="expand" for="c-41386924">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d suggest starting with P (<a href="https:&#x2F;&#x2F;github.com&#x2F;p-org&#x2F;P">https:&#x2F;&#x2F;github.com&#x2F;p-org&#x2F;P</a>), or picking up Hillel Wayne&#x27;s TLA+ book to get started.</div><br/></div></div></div></div><div id="41384618" class="c"><input type="checkbox" id="c-41384618" checked=""/><div class="controls bullet"><span class="by">wizerno</span><span>|</span><a href="#41386220">prev</a><span>|</span><a href="#41383084">next</a><span>|</span><label class="collapse" for="c-41384618">[-]</label><label class="expand" for="c-41384618">[4 more]</label></div><br/><div class="children"><div class="content">As someone who&#x27;s fascinated by formal verification and who&#x27;s early in their career, what advice do senior folks who have been using TLA+ have?<p>TLA+ isn&#x27;t taught in most universities and while I&#x27;ve read about so many interesting applications, I&#x27;m yet to convince myself that someone would hire me for knowing it rather than just teaching it to me on the job. Any tips to get started would also be appreciated!</div><br/><div id="41384732" class="c"><input type="checkbox" id="c-41384732" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#41384618">parent</a><span>|</span><a href="#41385555">next</a><span>|</span><label class="collapse" for="c-41384732">[-]</label><label class="expand" for="c-41384732">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s very little tech that somebody is going to hire you for knowing. It&#x27;s a tool like many others.<p>If nothing else, spending a few days playing with it will give you an idea of what it&#x27;s good for and if you want to continue, or it&#x27;ll make it stick in your mind so you can come back to it if you ever need it.</div><br/><div id="41387778" class="c"><input type="checkbox" id="c-41387778" checked=""/><div class="controls bullet"><span class="by">mnk47</span><span>|</span><a href="#41384618">root</a><span>|</span><a href="#41384732">parent</a><span>|</span><a href="#41385555">next</a><span>|</span><label class="collapse" for="c-41387778">[-]</label><label class="expand" for="c-41387778">[1 more]</label></div><br/><div class="children"><div class="content">&gt;There&#x27;s very little tech that somebody is going to hire you for knowing. It&#x27;s a tool like many others.<p>I guess this must be true on places like SF since I see this so often on HN, but almost every single job listing I&#x27;ve seen strictly requires knowledge of a specific tech stack, with the exception of <i>a few</i> internship programs.</div><br/></div></div></div></div><div id="41385555" class="c"><input type="checkbox" id="c-41385555" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#41384618">parent</a><span>|</span><a href="#41384732">prev</a><span>|</span><a href="#41383084">next</a><span>|</span><label class="collapse" for="c-41385555">[-]</label><label class="expand" for="c-41385555">[1 more]</label></div><br/><div class="children"><div class="content">Someone might hire you for the things you did with it, or for the passion you showed by learning it.</div><br/></div></div></div></div><div id="41383084" class="c"><input type="checkbox" id="c-41383084" checked=""/><div class="controls bullet"><span class="by">threatofrain</span><span>|</span><a href="#41384618">prev</a><span>|</span><a href="#41385584">next</a><span>|</span><label class="collapse" for="c-41383084">[-]</label><label class="expand" for="c-41383084">[17 more]</label></div><br/><div class="children"><div class="content">A TLA+ alternative people might find curious.<p><a href="https:&#x2F;&#x2F;quint-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;quint-lang.org&#x2F;</a></div><br/><div id="41388746" class="c"><input type="checkbox" id="c-41388746" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#41383084">parent</a><span>|</span><a href="#41384432">next</a><span>|</span><label class="collapse" for="c-41388746">[-]</label><label class="expand" for="c-41388746">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kinda raw at this point of development. Could be a promising alternative for pluscal.</div><br/></div></div><div id="41384432" class="c"><input type="checkbox" id="c-41384432" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#41383084">parent</a><span>|</span><a href="#41388746">prev</a><span>|</span><a href="#41386244">next</a><span>|</span><label class="collapse" for="c-41384432">[-]</label><label class="expand" for="c-41384432">[3 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say it&#x27;s a TLA+ alternative because it cannot do the most powerful and useful things TLA+ does (esp. refinement), but it is an alternative for programmers who just want to specify at a level that closer to code and model-check specifications.</div><br/><div id="41384809" class="c"><input type="checkbox" id="c-41384809" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41384432">parent</a><span>|</span><a href="#41386244">next</a><span>|</span><label class="collapse" for="c-41384809">[-]</label><label class="expand" for="c-41384809">[2 more]</label></div><br/><div class="children"><div class="content">Every time I see a new TLA+ replacement my first thought is &quot;Oooh this will be good for the 99% of normal stuff people do with TLA+.&quot;<p>Then I look through some of the specs I&#x27;ve written with clients and find the one <i>absolutely insane</i> thing I did in TLA+ that would be impossible in that replacement.<p>Shoutout to operator labels.</div><br/><div id="41387642" class="c"><input type="checkbox" id="c-41387642" checked=""/><div class="controls bullet"><span class="by">setheron</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41384809">parent</a><span>|</span><a href="#41386244">next</a><span>|</span><label class="collapse" for="c-41387642">[-]</label><label class="expand" for="c-41387642">[1 more]</label></div><br/><div class="children"><div class="content">So for us normies does that mean skip TLA?</div><br/></div></div></div></div></div></div><div id="41386244" class="c"><input type="checkbox" id="c-41386244" checked=""/><div class="controls bullet"><span class="by">pnathan</span><span>|</span><a href="#41383084">parent</a><span>|</span><a href="#41384432">prev</a><span>|</span><a href="#41383945">next</a><span>|</span><label class="collapse" for="c-41386244">[-]</label><label class="expand" for="c-41386244">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see any peer reviews of quint&#x27;s work on their site or GitHub. Am I missing them?</div><br/></div></div><div id="41383945" class="c"><input type="checkbox" id="c-41383945" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41383084">parent</a><span>|</span><a href="#41386244">prev</a><span>|</span><a href="#41383096">next</a><span>|</span><label class="collapse" for="c-41383945">[-]</label><label class="expand" for="c-41383945">[1 more]</label></div><br/><div class="children"><div class="content">Previously discussed: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41111790">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41111790</a></div><br/></div></div><div id="41383096" class="c"><input type="checkbox" id="c-41383096" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41383084">parent</a><span>|</span><a href="#41383945">prev</a><span>|</span><a href="#41385584">next</a><span>|</span><label class="collapse" for="c-41383096">[-]</label><label class="expand" for="c-41383096">[10 more]</label></div><br/><div class="children"><div class="content">What are other limits and opportunities for TLA+ and similar tools?</div><br/><div id="41383360" class="c"><input type="checkbox" id="c-41383360" checked=""/><div class="controls bullet"><span class="by">max_</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383096">parent</a><span>|</span><a href="#41384333">next</a><span>|</span><label class="collapse" for="c-41383360">[-]</label><label class="expand" for="c-41383360">[8 more]</label></div><br/><div class="children"><div class="content">Limits of TLA+<p>- It cannot compile to working code<p>- Steep learning curve<p>Opportunities for TLA+<p>- Helps you understand complex abstractions &amp; systems clearly.<p>- It&#x27;s extremely effective at communicating the components that make up a system with others.<p>Let get give you a real practical example.<p>In the AI models there is this component called a &quot;Transformer&quot;. It under pins ChatGPT (the &quot;T&quot; in ChatGPT).<p>If you are to read the 2018 Transfomer paper &quot;Attention is all you need&quot;.<p>They use human language, diagrams, and mathematics to describe their idea.<p>However if your try to build you own &quot;Transformer&quot; using that paper as your only resource your going to struggle interpreting what they are saying to get working code.<p>Even if you get the code working, how sure are you that what you have created is EXACTLY what the authors are talking about?<p>English is too verbose, diagrams are open to interpretation &amp; mathematics is too ambiguous&#x2F;abstract. And already written code is too dense.<p>TLA+ is a notation that tends to be used to &quot;specify systems&quot;.<p>In TLA+ everything is a defined in terms of a state machine. Hardware, software algorithms, consensus algorithms (paxos, raft etc).<p>So why TLA+?<p>If something is &quot;specified&quot; in TLA+;<p>- You know exactly what it is — just by interpreting the TLA+ spec<p>- If you have an idea to communicate. TLA+ literate people can understand exactly what your talking about.<p>- You can find bugs in an algorithms, hardware, proceseses just by modeling them in TLA+. 
So before building Hardware or software you can check it&#x27;s validity &amp; fix flaws in its design before committing expensive resources only to subsequently find issues in production.</div><br/><div id="41383565" class="c"><input type="checkbox" id="c-41383565" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383360">parent</a><span>|</span><a href="#41384112">next</a><span>|</span><label class="collapse" for="c-41383565">[-]</label><label class="expand" for="c-41383565">[4 more]</label></div><br/><div class="children"><div class="content">Is that a practical example? Has anyone specified a transformer using TLA+? More generally, is TLA+ practical for code that uses a lot of matrix multiplication?</div><br/><div id="41383768" class="c"><input type="checkbox" id="c-41383768" checked=""/><div class="controls bullet"><span class="by">drdrey</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383565">parent</a><span>|</span><a href="#41384058">next</a><span>|</span><label class="collapse" for="c-41383768">[-]</label><label class="expand" for="c-41383768">[1 more]</label></div><br/><div class="children"><div class="content">It’s really not, TLA+ works best for modeling state machines with few discrete states and concurrent systems. It can find interesting interleaving of events that would leave to a violation of your system properties</div><br/></div></div><div id="41384058" class="c"><input type="checkbox" id="c-41384058" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383565">parent</a><span>|</span><a href="#41383768">prev</a><span>|</span><a href="#41384112">next</a><span>|</span><label class="collapse" for="c-41384058">[-]</label><label class="expand" for="c-41384058">[2 more]</label></div><br/><div class="children"><div class="content">The most practical examples
I’m aware of are the usage of TLA+ to specify systems at AWS: <a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;formal-methods-amazon.pdf" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;formal-methods-amazon....</a></div><br/><div id="41385141" class="c"><input type="checkbox" id="c-41385141" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41384058">parent</a><span>|</span><a href="#41384112">next</a><span>|</span><label class="collapse" for="c-41385141">[-]</label><label class="expand" for="c-41385141">[1 more]</label></div><br/><div class="children"><div class="content">From &quot;Use of Formal Methods at Amazon Web Services&quot; (2014) <a href="https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;formal-methods-amazon.pdf" rel="nofollow">https:&#x2F;&#x2F;lamport.azurewebsites.net&#x2F;tla&#x2F;formal-methods-amazon....</a> :<p>&gt; What Formal Specification Is Not Good For: <i>We are concerned with two major classes of problems with large distributed systems: 1) bugs and operator errors that cause a departure from the logical intent of the system, and 2) surprising ‘sustained emergent performance degradation’ of complex systems that inevitably contain feedback loops. We know how to use formal specification to find the first class of problems. However, problems in the second category can cripple a system even though no logic bug is involved. A common example is when a momentary slowdown in a server (perhaps due to Java garbage collection) causes timeouts to be breached on clients, which causes the clients to retry requests, which adds more load to the server, which causes further slowdown. In such scenarios the system will eventually make progress; it is not stuck in a logical deadlock, livelock, or other cycle. But from the customer&#x27;s perspective it is effectively unavailable due to sustained unacceptable response times. TLA+ could be used to specify an upper bound on response time, as a real-time safety property. However, our systems are built on infrastructure (disks, operating systems, network) that do not support hard real-time scheduling or guarantees, so real-time safety properties would not be realistic. We build soft real-time systems in which very short periods of slow responses are not considered errors. However, prolonged severe slowdowns are considered errors. We don’t yet know of a feasible way to model a real system that would enable tools to predict such emergent behavior. We use other techniques to mitigate those risks.</i><p>Delay, cycles, feedback; [complex] [adaptive] nonlinearity<p>Formal methods including TLA+ also can&#x27;t&#x2F;don&#x27;t prevent or can only workaround side channels in hardware and firmware that is not verified. But that&#x27;s a different layer.<p>&gt; <i>This raised a challenge; how to convey the purpose and benefits of formal 
methods to an audience of software engineers? Engineers think in terms of debugging rather than ‘verification’, so we called the presentation “Debugging Designs” [8]
. Continuing that metaphor, we have
 found that software engineers more readily grasp the concept and practical value of TLA+ if we dub it:</i><p><pre><code>  Exhaustively testable pseudo-code
</code></pre>
&gt; <i>We initially avoid the words ‘formal’, ‘verification’, and ‘proof’, due to the widespread view that formal 
methods are impractical. We also initially avoid mentioning what the acronym ‘TLA’ stands for, as doing 
so would give an incorrect impression of complexity.</i><p>Isn&#x27;t there a hello world with vector clocks tutorial? A simple, formally-verified hello world kernel module with each of the potential methods would be demonstrative, but then don&#x27;t you need to model the kernel with abstract distributed concurrency primitives too?<p>From <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40980370">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40980370</a> ;<p>&gt; - [ ] DOC: learnxinyminutes for tlaplus<p>&gt; <i>TLAplus: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TLA%2B" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;TLA%2B</a> </i><p>&gt; <i>awesome-tlaplus &gt; Books, (University) courses teaching (with) TLA+: <a href="https:&#x2F;&#x2F;github.com&#x2F;tlaplus&#x2F;awesome-tlaplus#books">https:&#x2F;&#x2F;github.com&#x2F;tlaplus&#x2F;awesome-tlaplus#books</a> </i><p>FizzBee, Nagini, deal-solver, z3, dafny;  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39904256#39938759">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39904256#39938759</a> ,<p>&quot;Industry forms consortium to drive adoption of Rust in safety-critical systems&quot; (2024) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40680722">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40680722</a><p>awesome-safety-critical:</div><br/></div></div></div></div></div></div><div id="41384112" class="c"><input type="checkbox" id="c-41384112" checked=""/><div class="controls bullet"><span class="by">koolala</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383360">parent</a><span>|</span><a href="#41383565">prev</a><span>|</span><a href="#41383952">next</a><span>|</span><label class="collapse" for="c-41384112">[-]</label><label class="expand" for="c-41384112">[2 more]</label></div><br/><div class="children"><div class="content">Sounds similar to UML: Unified Modeling Language diagrams.<p>I wonder if TLA+ could convert to diagrams instead of Math notation.</div><br/><div id="41384325" class="c"><input type="checkbox" id="c-41384325" checked=""/><div class="controls bullet"><span class="by">hackermeows</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41384112">parent</a><span>|</span><a href="#41383952">next</a><span>|</span><label class="collapse" for="c-41384325">[-]</label><label class="expand" for="c-41384325">[1 more]</label></div><br/><div class="children"><div class="content">you are way off. These is a tool to simulate and validate systems and expose edge&#x2F;race conditions of that system.</div><br/></div></div></div></div><div id="41383952" class="c"><input type="checkbox" id="c-41383952" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383360">parent</a><span>|</span><a href="#41384112">prev</a><span>|</span><a href="#41384333">next</a><span>|</span><label class="collapse" for="c-41383952">[-]</label><label class="expand" for="c-41383952">[1 more]</label></div><br/><div class="children"><div class="content">Are there any RFCs written in TLA+?</div><br/></div></div></div></div><div id="41384333" class="c"><input type="checkbox" id="c-41384333" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41383084">root</a><span>|</span><a href="#41383096">parent</a><span>|</span><a href="#41383360">prev</a><span>|</span><a href="#41385584">next</a><span>|</span><label class="collapse" for="c-41384333">[-]</label><label class="expand" for="c-41384333">[1 more]</label></div><br/><div class="children"><div class="content">Formal specifications benefits are clear and I think well understood at that point. If you want to ensure that your specifications is coherent and doesn’t have unexpected behaviour, having a formal specification is a must. It’s even a legal requirement for some system nowadays in safety critical applications.<p>The issue of TLA+ is that it doesn’t come from the right side of the field. Most formal specifications tools were born out of necessity from the engineering fields requiring them. TLA+ is a computer science tool. It sometimes shows in the vocabulary used and in the way it is structured.</div><br/></div></div></div></div></div></div><div id="41385584" class="c"><input type="checkbox" id="c-41385584" checked=""/><div class="controls bullet"><span class="by">fat_cantor</span><span>|</span><a href="#41383084">prev</a><span>|</span><a href="#41383481">next</a><span>|</span><label class="collapse" for="c-41385584">[-]</label><label class="expand" for="c-41385584">[1 more]</label></div><br/><div class="children"><div class="content">Whoa, I use TLA ironically to joke about Three Letter Acronyms, I had no idea that the Three Letter Acronym (TLA) was in any way related to Temporal Logic Actually. Fascinating!</div><br/></div></div><div id="41383717" class="c"><input type="checkbox" id="c-41383717" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#41383481">prev</a><span>|</span><label class="collapse" for="c-41383717">[-]</label><label class="expand" for="c-41383717">[29 more]</label></div><br/><div class="children"><div class="content">&gt; Simplicity is a major goal of TLA+.<p>Is TLA+ simple? I find this hard to accept.<p>&gt; TLA+ isn’t a programming language; it’s mathematics.<p>Mathematics is not executable, though, whereas TLA+ is.<p>&gt; TLA+ [is better] for its purpose than a programming language.<p>&quot;TLA+ is a formal specification language designed by Leslie Lamport for the specification of system behavior.&quot;<p>&quot;specification of system behavior&quot; sounds like a programming language to me. A systems programming language, even.<p>All this is to say that it seems TLA+ really has no future. If there was a future, like a goal or a roadmap or something, it would be outlined in this document a lot more clearly - whereas, instead, it is more like &quot;nope, everything&#x27;s good, no changes needed&quot;, even as the language appears nowhere on the TIOBE rankings.</div><br/><div id="41383894" class="c"><input type="checkbox" id="c-41383894" checked=""/><div class="controls bullet"><span class="by">Certhas</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41383860">next</a><span>|</span><label class="collapse" for="c-41383894">[-]</label><label class="expand" for="c-41383894">[5 more]</label></div><br/><div class="children"><div class="content">Simple =&#x2F;= easy.<p>It seems to me that TLA+ is executable in the sense that a difference equation can be run forward in time. Plenty of mathematics is executable in that sense.<p>Specification is not the same thing as implementation. A specification language does not tell a machine what operations to perform, a programming language does.<p>System behavior and systems programming are entirely different uses of the word system.</div><br/><div id="41386103" class="c"><input type="checkbox" id="c-41386103" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41383894">parent</a><span>|</span><a href="#41383860">next</a><span>|</span><label class="collapse" for="c-41386103">[-]</label><label class="expand" for="c-41386103">[4 more]</label></div><br/><div class="children"><div class="content">TLA+ is executable in the sense of Prolog: there is an algorithm (the TLA+ implementation) that takes a TLA+ program and produces output. Most mathematics is not executable in this sense, you will have a very difficult time doing anything useful with the PDF&#x27;s of published math papers. Math is a natural language, TLA+ is not.<p>And I would agree, TLA+ as a specification is different from TLA+ as an implementation. I generally disregard specs, I was talking about TLA+ the implementation when I said it had no future. It seems it will be in perpetual maintenance mode with barely any new features.<p>Regarding simple vs. easy, I challenge you to argue that temporal logic is &quot;simple&quot; in any sense of the word.</div><br/><div id="41386436" class="c"><input type="checkbox" id="c-41386436" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41386103">parent</a><span>|</span><a href="#41383860">next</a><span>|</span><label class="collapse" for="c-41386436">[-]</label><label class="expand" for="c-41386436">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Math is a natural language<p>Almost spit out my drink dude, no jokes this early in the day.</div><br/><div id="41388651" class="c"><input type="checkbox" id="c-41388651" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41386436">parent</a><span>|</span><a href="#41387110">next</a><span>|</span><label class="collapse" for="c-41388651">[-]</label><label class="expand" for="c-41388651">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the joke?</div><br/></div></div><div id="41387110" class="c"><input type="checkbox" id="c-41387110" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41386436">parent</a><span>|</span><a href="#41388651">prev</a><span>|</span><a href="#41383860">next</a><span>|</span><label class="collapse" for="c-41387110">[-]</label><label class="expand" for="c-41387110">[1 more]</label></div><br/><div class="children"><div class="content">ChatGPT does just fine with math. I wasn&#x27;t joking...</div><br/></div></div></div></div></div></div></div></div><div id="41383860" class="c"><input type="checkbox" id="c-41383860" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41383894">prev</a><span>|</span><a href="#41383867">next</a><span>|</span><label class="collapse" for="c-41383860">[-]</label><label class="expand" for="c-41383860">[8 more]</label></div><br/><div class="children"><div class="content">TLA+ is only &quot;executable&quot; in the same sense that an algebraic expression is executable. It&#x27;s perfectly possible to write things on TLA+ that can not be simply executed linearly. (These overlap to a great extent with the things which TLC rejects.) As a basic example, it&#x27;s easy to write a statement with \A (unbounded universal quantification) whose truth can only be judged by a proof engine.<p>Specification languages are <i>explicitly not</i> programming languages, for the core reason that programming languages dictate only what <i>must</i> occur; whereas specification languages can dictate what must <i>not</i> occur.  It&#x27;s not possible with a &quot;specification&quot; written using a programming language to determine what of a program is <i>actually</i> the specification, vs. what is an accident of the implementation.</div><br/><div id="41384197" class="c"><input type="checkbox" id="c-41384197" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41383860">parent</a><span>|</span><a href="#41383867">next</a><span>|</span><label class="collapse" for="c-41384197">[-]</label><label class="expand" for="c-41384197">[7 more]</label></div><br/><div class="children"><div class="content">Being able to create systems by writing specifications and having the computer figure out how to execute them was basically the point of fifth generation programming languages.<p>More relevant today, you can execute other &quot;specification&quot; languages like Coq and Idris because they support things outside the narrow feature set of specification usecases.<p>TLA+ isn&#x27;t executable and doesn&#x27;t look like an imperative language because the authors don&#x27;t want it to be, not because there&#x27;s some universal line dividing specification languages from programming languages. It&#x27;s also one of the biggest hurdles to TLA+ usage.</div><br/><div id="41384915" class="c"><input type="checkbox" id="c-41384915" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384197">parent</a><span>|</span><a href="#41384363">next</a><span>|</span><label class="collapse" for="c-41384915">[-]</label><label class="expand" for="c-41384915">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Being able to create systems by writing specifications and having the computer figure out how to execute them was basically the point of fifth generation programming languages.<p>Yeah, but in maths you can specify anything, including things that the computer is unlikely to figure out how to execute if it&#x27;s possible at all. Programming languages of every generation are very useful, as is mathematics, even though they&#x27;re not the same thing.<p>&gt; More relevant today, you can execute other &quot;specification&quot; languages like Coq and Idris because they support things outside the narrow feature set of specification usecases.<p>Coq and Idris are very different in the way they&#x27;re typically used, and I&#x27;d say TLA+ is much closer to Coq than to Idris (and is probably more popular than the two combined), but to &quot;execute&quot; anything the specification needs to be at a certain level that&#x27;s detailed enough to produce a program, and oftentimes that is very much not what you want.<p>It would be extremely useful to have a language that you could describe the various properties of a car and it would compile your specification into the design of a car (you would need to give it sufficient detail as there are choices to be made). But it would also be extremely useful to have a language that could be used to learn certain things about a car -- say, it&#x27;s braking distance -- without specifying it in sufficient detail to actually build one. That is what maths is good for -- describing things at <i>arbitrary</i> levels of detail to answer relevant questions.<p>For example, you may have a 5 MLOC distributed system, and you want to know if a certain kind of failure may lead to data loss. You could use TLA+ to describe just the relevant details to answer the question in, say, 200 lines of formulas. That you cannot compile those formulas into a working 5 MLOC piece of software is not a downside of mathematics, but rather the point.<p>&gt; TLA+ isn&#x27;t executable and doesn&#x27;t look like an imperative language because the authors don&#x27;t want it to be<p>And because it&#x27;s not a language for programming but a language for mathematics, so it looks and feels pretty close to plain mathematics (only it&#x27;s formal), as that&#x27;s the obvious choice for writing mathematics.</div><br/><div id="41386045" class="c"><input type="checkbox" id="c-41386045" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384915">parent</a><span>|</span><a href="#41384363">next</a><span>|</span><label class="collapse" for="c-41386045">[-]</label><label class="expand" for="c-41386045">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  in maths you can specify anything, including things that the computer is unlikely to figure out how to execute if it&#x27;s possible at all.<p>Well, in TLA+ you can write programs that run forever (or at longer than you&#x27;ll live) and don&#x27;t do anything like &quot;model check&quot; or whatever you want to call executing TLA+, even though they are perfectly sound mathematically. This should make it clear that TLA+ is not maths.</div><br/></div></div></div></div><div id="41384363" class="c"><input type="checkbox" id="c-41384363" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384197">parent</a><span>|</span><a href="#41384915">prev</a><span>|</span><a href="#41383867">next</a><span>|</span><label class="collapse" for="c-41384363">[-]</label><label class="expand" for="c-41384363">[4 more]</label></div><br/><div class="children"><div class="content">Coq is not a specification language. It’s an interactive theorem prover. The goal set is completely different.</div><br/><div id="41384528" class="c"><input type="checkbox" id="c-41384528" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384363">parent</a><span>|</span><a href="#41383867">next</a><span>|</span><label class="collapse" for="c-41384528">[-]</label><label class="expand" for="c-41384528">[3 more]</label></div><br/><div class="children"><div class="content">Coq, specifically Gallina, is absolutely a specification tool. It&#x27;s not <i>only</i> that, but it&#x27;s one of the big use cases it&#x27;s explicitly designed to support.</div><br/><div id="41384594" class="c"><input type="checkbox" id="c-41384594" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384528">parent</a><span>|</span><a href="#41383867">next</a><span>|</span><label class="collapse" for="c-41384594">[-]</label><label class="expand" for="c-41384594">[2 more]</label></div><br/><div class="children"><div class="content">No, it’s not. Gallina is not a specification tool in the way TLA+ is (even if coq calls it its specification language). Gallina is a language used to write mathematical statements which you intend to prove. It’s not designed to write specifications.<p>Coq is definitely not a specification tool. You can probably prove a specification with it in the same way you actually can do symbolic manipulation with C if you really want to. It still remains an interactive prover.</div><br/><div id="41388344" class="c"><input type="checkbox" id="c-41388344" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384594">parent</a><span>|</span><a href="#41383867">next</a><span>|</span><label class="collapse" for="c-41388344">[-]</label><label class="expand" for="c-41388344">[1 more]</label></div><br/><div class="children"><div class="content">Of course Coq is also a specification tool. C compilers have been formally verified with Coq. So you have a spec for C in Coq.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41383867" class="c"><input type="checkbox" id="c-41383867" checked=""/><div class="controls bullet"><span class="by">tailrecursion</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41383860">prev</a><span>|</span><a href="#41384409">next</a><span>|</span><label class="collapse" for="c-41383867">[-]</label><label class="expand" for="c-41383867">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;specification of system behavior&quot; sounds like a programming language to me. A systems programming language, even.<p>Lamport has directly and repeatedly addressed the differences between what&#x27;s desirable in a specification language versus what&#x27;s desirable in a programming language.  Understanding the difference is vital to writing specifications.</div><br/><div id="41386535" class="c"><input type="checkbox" id="c-41386535" checked=""/><div class="controls bullet"><span class="by">Mathnerd314</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41383867">parent</a><span>|</span><a href="#41384409">next</a><span>|</span><label class="collapse" for="c-41386535">[-]</label><label class="expand" for="c-41386535">[1 more]</label></div><br/><div class="children"><div class="content">I looked for this &quot;direct address&quot;. All I can tell is that he&#x27;s repeatedly contradicted himself. <a href="http:&#x2F;&#x2F;lambda-the-ultimate.org&#x2F;node&#x2F;4922#comment-79370" rel="nofollow">http:&#x2F;&#x2F;lambda-the-ultimate.org&#x2F;node&#x2F;4922#comment-79370</a></div><br/></div></div></div></div><div id="41384409" class="c"><input type="checkbox" id="c-41384409" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41383867">prev</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41384409">[-]</label><label class="expand" for="c-41384409">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Is TLA+ simple? I find this hard to accept.<p>It is very, <i>very</i> simple, and I would say easier to learn than Python, as long as you remember that it is not programming but maths. For example, suppose you specify this function on the integers:<p><pre><code>    f ≜ CHOOSE f ∈ [Int → Int] : 
       ∀ x ∈ Int : f[x] = -f[x]
</code></pre>
What function is it? Clearly, it&#x27;s the zero function rather than what defining the equivalent &quot;programming function&quot; in, say, Haskell would mean:<p><pre><code>    f :: Integer -&gt; Integer
    f x = -(f x)
</code></pre>
&gt; Mathematics is not executable, though, whereas TLA+ is.<p>It is definitely not executable (i.e. not any more than mathematics is; you can specify executable things in maths and therefore in TLA+, but not everything you specify is executable). You can specify non-computable things (e.g. it is trivial to specify a halting oracle) as well as things involving real numbers. Moreover, when you check a TLA+ specification with a model-checker like TLC, it doesn&#x27;t actually execute the specification, as it can check a specification of uncountable many executions, each of infinite length in a second.<p>However, you can certainly write formulas specifying the behaviour of an executable program and simulate it with TLC. But this is because you can use mathematics to describe physical systems, but not everything you can describe in mathematics can have a physical representation.<p>&gt; &quot;specification of system behavior&quot; sounds like a programming language to me. A systems programming language, even.<p>A program is, indeed, one way of specifying a system, and TLA+ does allow you to specify an algorithm in this way (because maths allows you to specify programs), but it also allows you to specify systems in very useful ways that are very much not programs. For example, you can specify a component that sorts things without ever writing an algorithm for sorting, which is useful when the details of the sorting algorithm are irrelevant to the questions you want to answer. It&#x27;s like how you can write a formula that treats planets as point-masses if you&#x27;re interested in orbital mechanics, yet specify the earth in a much more detailed way if you&#x27;re interested in predicting the weather.<p>&gt; even as the language appears nowhere on the TIOBE rankings.<p>It is not a programming language. While it is true that far more people write programs than use mathematics to reason about physics, biology, or the way software systems behave (especially complicated interactive and distributed systems, which is where TLA+ excels), that doesn&#x27;t mean such disciplines have no future.</div><br/><div id="41388677" class="c"><input type="checkbox" id="c-41388677" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384409">parent</a><span>|</span><a href="#41384617">next</a><span>|</span><label class="collapse" for="c-41388677">[-]</label><label class="expand" for="c-41388677">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes &quot;f triangle equals CHOOSE f member of array of int to int, namely, upside down A x member of int, namely, x&#x27;th element of f equals the negative of x&#x27;th element of f.&quot; Easier than python indeed, where this simple and elegant expression is turned into the much more complicated and ugly form of<p><pre><code>    def f(x):
        return -x</code></pre></div><br/></div></div><div id="41384617" class="c"><input type="checkbox" id="c-41384617" checked=""/><div class="controls bullet"><span class="by">zekrioca</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384409">parent</a><span>|</span><a href="#41388677">prev</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41384617">[-]</label><label class="expand" for="c-41384617">[6 more]</label></div><br/><div class="children"><div class="content">&gt; It is very, very simple, and I would say easier to learn than Python, as long as you remember that it is not programming but maths. For example, suppose you specify this function on the integers:<p>&gt;    f ≜ CHOOSE f ∈ [Int → Int] : 
&gt;       ∀ x ∈ Int : f[x] = -f[x]<p>&gt; What function is it? Clearly, it&#x27;s the zero function<p>Did you mean your example is the constant function [1], rather than a zero function [2] (where c = 0)?<p>[1] <a href="https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;ConstantFunction.html" rel="nofollow">https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;ConstantFunction.html</a><p>[2] <a href="https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;ZeroFunction.html" rel="nofollow">https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;ZeroFunction.html</a></div><br/><div id="41384672" class="c"><input type="checkbox" id="c-41384672" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384617">parent</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41384672">[-]</label><label class="expand" for="c-41384672">[5 more]</label></div><br/><div class="children"><div class="content">I mean the zero function, i.e., the one that is zero everywhere, because if y ∈ ℤ and y = -y, then y = 0.</div><br/><div id="41386464" class="c"><input type="checkbox" id="c-41386464" checked=""/><div class="controls bullet"><span class="by">zekrioca</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384672">parent</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41386464">[-]</label><label class="expand" for="c-41386464">[4 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t ℤ include negative natural numbers?<p>* Nevermind, I just saw you used the &quot;&gt;&quot; sign in the definition. Is it why the definition only applies to positive numbers? In any case, you did not write it in your textual description, which looked confusing to me. I think it would be easier if one could define it as ℤ+ or something like that.</div><br/><div id="41386855" class="c"><input type="checkbox" id="c-41386855" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41386464">parent</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41386855">[-]</label><label class="expand" for="c-41386855">[3 more]</label></div><br/><div class="children"><div class="content">The original from pron:<p><pre><code>    f ≜ CHOOSE f ∈ [Int → Int] : 
       ∀ x ∈ Int : f[x] = -f[x]
</code></pre>
You added the &gt; in your quote of pron, he didn&#x27;t have it in the original. There is no c in ℤ with c != 0 s.t. f(x) = c and f(x) = -f(x), that would imply that c = -c for non-zero integers which is not true. The only function that can satisfy pron&#x27;s constraints is f(x) = 0 since c = 0 is the only time 
c = -c, or 0 = -0.</div><br/><div id="41387305" class="c"><input type="checkbox" id="c-41387305" checked=""/><div class="controls bullet"><span class="by">zekrioca</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41386855">parent</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41387305">[-]</label><label class="expand" for="c-41387305">[2 more]</label></div><br/><div class="children"><div class="content">That’s true, my mistake. Thank you for the clarification! In this case, I have another question.<p>Why is this original definition different than say<p>f ≜ CHOOSE f ∈ [Int → Int]:<p><pre><code>       ∀ x ∈ Int : f[x] = 0
</code></pre>
If you want some function to be 0, just specify it. Why does one need to find this a broader but more complex way of specifying the possible “input” space in TLA+? How does it help is my question, I guess.</div><br/><div id="41388397" class="c"><input type="checkbox" id="c-41388397" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41387305">parent</a><span>|</span><a href="#41384035">next</a><span>|</span><label class="collapse" for="c-41388397">[-]</label><label class="expand" for="c-41388397">[1 more]</label></div><br/><div class="children"><div class="content">This was just an example that TLA+ is not executable.<p>You didn&#x27;t realise that f[x] = -f[x] implies f[x] = 0, and that is how it is often: You have some property, but you don&#x27;t know what it entails exactly. TLA+ allows you to reason about that.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41384035" class="c"><input type="checkbox" id="c-41384035" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41384409">prev</a><span>|</span><a href="#41384648">next</a><span>|</span><label class="collapse" for="c-41384035">[-]</label><label class="expand" for="c-41384035">[2 more]</label></div><br/><div class="children"><div class="content">&gt; even as the language appears nowhere on the TIOBE rankings.<p>TIOBE rankings are widely considered to be useless by those who care about programming languages, but even aside from that your dismissal on those grounds is absurd given that you had just barely criticized TLA+ for trying to duck the label of &quot;programming language&quot; at all. You can&#x27;t criticize it for trying not to be a programming language and then turn around and criticize it for not showing up on a ranking of programming languages.<p>It&#x27;s excluded from the TIOBE index in the same way that HTML, CSS, or Markdown are excluded, and <i>that&#x27;s by choice</i>.</div><br/><div id="41384850" class="c"><input type="checkbox" id="c-41384850" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384035">parent</a><span>|</span><a href="#41384648">next</a><span>|</span><label class="collapse" for="c-41384850">[-]</label><label class="expand" for="c-41384850">[1 more]</label></div><br/><div class="children"><div class="content">Also, being popular is not the same as being useful. Mathematica and Verilog aren&#x27;t on the TIOBE either, and Verilog is a lot more important to society than Logo!</div><br/></div></div></div></div><div id="41384648" class="c"><input type="checkbox" id="c-41384648" checked=""/><div class="controls bullet"><span class="by">foysavas</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41384035">prev</a><span>|</span><a href="#41384196">next</a><span>|</span><label class="collapse" for="c-41384648">[-]</label><label class="expand" for="c-41384648">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;specification of system behavior&quot; sounds like a programming language to me<p>By &quot;specification language&quot; Lamport means one capable of verification via model checking.<p>In contrast, &quot;programming languages&quot; are not capable of such verification.</div><br/></div></div><div id="41384196" class="c"><input type="checkbox" id="c-41384196" checked=""/><div class="controls bullet"><span class="by">klingoff</span><span>|</span><a href="#41383717">parent</a><span>|</span><a href="#41384648">prev</a><span>|</span><label class="collapse" for="c-41384196">[-]</label><label class="expand" for="c-41384196">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If there was a future, like a goal or a roadmap or something, it would be outlined<p>Where is the outline for English? French has a more structured oversight with organizations and goals, so it will beat English?</div><br/><div id="41388034" class="c"><input type="checkbox" id="c-41388034" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#41383717">root</a><span>|</span><a href="#41384196">parent</a><span>|</span><label class="collapse" for="c-41388034">[-]</label><label class="expand" for="c-41388034">[1 more]</label></div><br/><div class="children"><div class="content">It is harder to create&#x2F;merge numerous dialects for a computer language such as TLA+ than English.<p>Even the most popular languages such as Python have just a few viable implementations.<p>Roadmap&#x2F;focus is useful in a collaboration.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>