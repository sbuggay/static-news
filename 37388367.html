<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693904466104" as="style"/><link rel="stylesheet" href="styles.css?v=1693904466104"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.aaronbruce.com/posts/tests-dont-force-good-desgin/">TDD Doesn&#x27;t Force Good Design</a> <span class="domain">(<a href="https://www.aaronbruce.com">www.aaronbruce.com</a>)</span></div><div class="subtext"><span>sh_tomer</span> | <span>35 comments</span></div><br/><div><div id="37389374" class="c"><input type="checkbox" id="c-37389374" checked=""/><div class="controls bullet"><span class="by">m000</span><span>|</span><a href="#37389306">next</a><span>|</span><label class="collapse" for="c-37389374">[-]</label><label class="expand" for="c-37389374">[1 more]</label></div><br/><div class="children"><div class="content">Fairly obvious, but if you do dumb things and expect a general methodology to save you, it won&#x27;t. Or, like it is said in fitness world, &quot;you cannot out-train a bad diet&quot;.<p>Moreover, if you have people in your team that not aligned with the methodology (&quot;I&#x27;d rather be doing X&quot;, &quot;It slows me down as a developer&quot; etc.) the results will be sub-par. Applying a methodology requires a certain level of mindfulness which doesn&#x27;t seem to be common these days.</div><br/></div></div><div id="37389306" class="c"><input type="checkbox" id="c-37389306" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#37389374">prev</a><span>|</span><a href="#37389439">next</a><span>|</span><label class="collapse" for="c-37389306">[-]</label><label class="expand" for="c-37389306">[2 more]</label></div><br/><div class="children"><div class="content">I have absolutely seen high test coverage crystallize bad design. You are less likely to rewrite something tested and proven to work.<p>I have also seen high coverage that didn’t actually test much of anything. Code with side effects, none of which tested, just more or less that the method ran without a runtime exception.<p>Coverage is a good tool but a bad metric.</div><br/><div id="37389444" class="c"><input type="checkbox" id="c-37389444" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#37389306">parent</a><span>|</span><a href="#37389439">next</a><span>|</span><label class="collapse" for="c-37389444">[-]</label><label class="expand" for="c-37389444">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div><div id="37389439" class="c"><input type="checkbox" id="c-37389439" checked=""/><div class="controls bullet"><span class="by">yungporko</span><span>|</span><a href="#37389306">prev</a><span>|</span><a href="#37389218">next</a><span>|</span><label class="collapse" for="c-37389439">[-]</label><label class="expand" for="c-37389439">[1 more]</label></div><br/><div class="children"><div class="content">nothing reliably forces good design, or good code. a shitty team will design a shitty application full of shitty code regardless of testing methodologies or anything else. what else is new?<p>does that mean that literally all development processes are bad and should be dismissed and everybody should just open their editor and start writing, organisation be damned? seems that way if you read comments on literally any post on hackernews.</div><br/></div></div><div id="37389218" class="c"><input type="checkbox" id="c-37389218" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37389439">prev</a><span>|</span><a href="#37389279">next</a><span>|</span><label class="collapse" for="c-37389218">[-]</label><label class="expand" for="c-37389218">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no mechanical process from which blind adherence could produce good design without the author&#x2F;engineer having experience or knowledge (or both).<p>It just stops bad design from setting in too easily - and even then, it&#x27;s &quot;easy&quot; to workaround or apply the process incorrectly or too pedantically.</div><br/></div></div><div id="37389279" class="c"><input type="checkbox" id="c-37389279" checked=""/><div class="controls bullet"><span class="by">frankdejonge</span><span>|</span><a href="#37389218">prev</a><span>|</span><a href="#37389385">next</a><span>|</span><label class="collapse" for="c-37389279">[-]</label><label class="expand" for="c-37389279">[5 more]</label></div><br/><div class="children"><div class="content">Most solutions on their own don&#x27;t improve things a whole lot. Yet, in a system of supporting practices, it can be very powerful. The primary thing is you need a system, not just the individual parts. Testing without changing the design of your code is a horrible experience. Applying techniques like dependency inversion&#x2F;injection has a positive effect on isolating behaviour which makes testing easier. Making code more deterministic makes tests easier. Pushing out side-effect from your core logic makes testing easier. All of those things add up to more than the sum of it&#x27;s part, which is the an indication of dealing with a system.</div><br/><div id="37389360" class="c"><input type="checkbox" id="c-37389360" checked=""/><div class="controls bullet"><span class="by">MoreQARespect</span><span>|</span><a href="#37389279">parent</a><span>|</span><a href="#37389385">next</a><span>|</span><label class="collapse" for="c-37389360">[-]</label><label class="expand" for="c-37389360">[4 more]</label></div><br/><div class="children"><div class="content">Dependency injection is only useful when you&#x27;ve managed to isolate logic&#x2F;math intensive code. Some apps dont have <i>any</i> logic intensive code. Many others have very little.<p>In those cases dependency injection just increases the SLOC with the payoff that you are able a bunch of trivial unit tests that&#x27;ll probably never catch a bug.<p>Integration tests as a default have a the best ROI in those cases.</div><br/><div id="37389421" class="c"><input type="checkbox" id="c-37389421" checked=""/><div class="controls bullet"><span class="by">frankdejonge</span><span>|</span><a href="#37389279">root</a><span>|</span><a href="#37389360">parent</a><span>|</span><a href="#37389365">next</a><span>|</span><label class="collapse" for="c-37389421">[-]</label><label class="expand" for="c-37389421">[1 more]</label></div><br/><div class="children"><div class="content">I look more towards optionality myself. Take for example the encapsulation of randomness. Depending on an abstract notion of randomness (an interface) that decouples you from the implementation is both useful for testing as it is for maintenance of a system. For tests, removing randomness entirely makes it deterministic, allowing you to tests for exact matches instead of approximations. For systems, at a smaller scale get away with a reduced amount of randomness, while systems at scale require more sophisticated code for this. You don&#x27;t want to replace all of that code in all instances, but rather leverage the capability and replace the implementation.<p>Another angle is the encapsulation of storage. Using in-memory storage for tests makes Ci pipelines very quick and production storage might evolve over time to accommodate scaling requirements (sharding and such).</div><br/></div></div><div id="37389365" class="c"><input type="checkbox" id="c-37389365" checked=""/><div class="controls bullet"><span class="by">taberiand</span><span>|</span><a href="#37389279">root</a><span>|</span><a href="#37389360">parent</a><span>|</span><a href="#37389421">prev</a><span>|</span><a href="#37389385">next</a><span>|</span><label class="collapse" for="c-37389365">[-]</label><label class="expand" for="c-37389365">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t really true. For one, dependency injection isn&#x27;t specific to testing or processing logic, it&#x27;s an architectural approach used primarily for managing separation of concerns and modularisation.</div><br/><div id="37389438" class="c"><input type="checkbox" id="c-37389438" checked=""/><div class="controls bullet"><span class="by">MoreQARespect</span><span>|</span><a href="#37389279">root</a><span>|</span><a href="#37389365">parent</a><span>|</span><a href="#37389385">next</a><span>|</span><label class="collapse" for="c-37389438">[-]</label><label class="expand" for="c-37389438">[1 more]</label></div><br/><div class="children"><div class="content">I didnt say it was specific to testing. Nonetheless the pursuit of &quot;unit testability&quot; is probably most often why it&#x27;s done.<p>Call me crazy but I&#x27;m more of the opinion that you should default to adapting your tests to your code and not your code to your tests.</div><br/></div></div></div></div></div></div></div></div><div id="37389385" class="c"><input type="checkbox" id="c-37389385" checked=""/><div class="controls bullet"><span class="by">mrjin</span><span>|</span><a href="#37389279">prev</a><span>|</span><a href="#37389256">next</a><span>|</span><label class="collapse" for="c-37389385">[-]</label><label class="expand" for="c-37389385">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really know where such claim came from. TDD is really about getting features tested. I never heard similar claims before.</div><br/><div id="37389441" class="c"><input type="checkbox" id="c-37389441" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#37389385">parent</a><span>|</span><a href="#37389256">next</a><span>|</span><label class="collapse" for="c-37389441">[-]</label><label class="expand" for="c-37389441">[1 more]</label></div><br/><div class="children"><div class="content">Reusable modules of code involve implementation and the interface.<p>If you just write out an implementation without thought for how others are to use it, there&#x27;s a risk that you&#x27;ll end up with an interface that&#x27;s more complex to use than it needs to be.<p>The idea is that by &#x27;using&#x27; the interface of the module first (e.g. by writing tests first, or by writing documentation first), then the design of the interface isn&#x27;t left to be an afterthought of the implementation.<p>Similarly, it&#x27;s easier to consider edge cases when thinking about unit tests &#x2F; documentation, etc.</div><br/></div></div></div></div><div id="37389256" class="c"><input type="checkbox" id="c-37389256" checked=""/><div class="controls bullet"><span class="by">dopidopHN</span><span>|</span><a href="#37389385">prev</a><span>|</span><a href="#37389281">next</a><span>|</span><label class="collapse" for="c-37389256">[-]</label><label class="expand" for="c-37389256">[7 more]</label></div><br/><div class="children"><div class="content">Could someone elaborate on why “mocking is a smell”?
Is it opposed to running the whole system with real interactions?<p>I find it a nice shortcut, but true as well than the mocking behavior can be non existent in the real code path.<p>Still, I reach out to mocking libraries often. Is that a bad practices and why ?</div><br/><div id="37389348" class="c"><input type="checkbox" id="c-37389348" checked=""/><div class="controls bullet"><span class="by">frankdejonge</span><span>|</span><a href="#37389256">parent</a><span>|</span><a href="#37389425">next</a><span>|</span><label class="collapse" for="c-37389348">[-]</label><label class="expand" for="c-37389348">[2 more]</label></div><br/><div class="children"><div class="content">Mocking, when it is a large part of your test setup, makes your test focus on the blueprint of the implementation rather than the outcome of a unit of behaviour. This causes the tests to break relatively soon when the implementation changes. When a test does not use mocking and rather treats the code as a sealed box, the tests are more stable. Stable tests yield better guarantees for stable outcomes even when the underlying code is (radically) changed&#x2F;refactored. Using mocking frameworks usually makes refactoring harder, as changing the underlying code immediately invalidates the test. Changing the tests and code in unison makes changes less safe.</div><br/><div id="37389366" class="c"><input type="checkbox" id="c-37389366" checked=""/><div class="controls bullet"><span class="by">frankdejonge</span><span>|</span><a href="#37389256">root</a><span>|</span><a href="#37389348">parent</a><span>|</span><a href="#37389425">next</a><span>|</span><label class="collapse" for="c-37389366">[-]</label><label class="expand" for="c-37389366">[1 more]</label></div><br/><div class="children"><div class="content">I must add that it&#x27;s mostly mocking libraries that auto-generate mocks that are the culprit here. They&#x27;re quick to introduce, but once introduced make it harder to change the implementation as the implementation logic is now replicated in N instances of tests. More surface area, more friction for change. Many mocking libraries also allow you to fixate behaviour that is incompatible with the actual implementation, especially in dynamically types languages.</div><br/></div></div></div></div><div id="37389425" class="c"><input type="checkbox" id="c-37389425" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#37389256">parent</a><span>|</span><a href="#37389348">prev</a><span>|</span><a href="#37389377">next</a><span>|</span><label class="collapse" for="c-37389425">[-]</label><label class="expand" for="c-37389425">[1 more]</label></div><br/><div class="children"><div class="content">One issue with mocks is that you have to ensure that the way they are mocked accurately represents the actual behaviour of the thing being mocked, in production.<p>Otherwise your mocks may end up driving the system to a state that is never actually encountered in production, while the unit test still passes. When you run an integration test or a real build of the application, the actual system itself will fail to behave as expected.</div><br/></div></div><div id="37389377" class="c"><input type="checkbox" id="c-37389377" checked=""/><div class="controls bullet"><span class="by">geokon</span><span>|</span><a href="#37389256">parent</a><span>|</span><a href="#37389425">prev</a><span>|</span><a href="#37389402">next</a><span>|</span><label class="collapse" for="c-37389377">[-]</label><label class="expand" for="c-37389377">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t do TDD - so this is my outsider&#x27;s understanding<p>The issue is that if you need to mock then your design is not really properly decoupled. The mock bakes in assumptions about your program state - which may or may not hold up in the real world. This ends up creating a sort of invisible coupling to whatever will be creating&#x2F;updating the state in the real world. Hence you can bake in incorrect assumptions<p>The terminology is a bit fuzzy b&#x2F;c the author describes his unit tests as using mocks - but to me that&#x27;s not a unit test - that&#x27;s an integration test..<p>At the end of the day you do need some coupling and some integration tests are inevitable - but the idea is that TDD pushes you to minimize that<p>Would love to hear anyone&#x27;s corrections :)</div><br/></div></div><div id="37389402" class="c"><input type="checkbox" id="c-37389402" checked=""/><div class="controls bullet"><span class="by">geewee</span><span>|</span><a href="#37389256">parent</a><span>|</span><a href="#37389377">prev</a><span>|</span><a href="#37389335">next</a><span>|</span><label class="collapse" for="c-37389402">[-]</label><label class="expand" for="c-37389402">[1 more]</label></div><br/><div class="children"><div class="content">I think it depends heavily on what you&#x27;re mocking and what the code you&#x27;re testing looks like.<p>I think Martin Fowler has a nice dichotomy where he splits tests up into solitary (generally using mocks for deps) and sociable (generally using real code for dependencies): <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;bliki&#x2F;UnitTest.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;martinfowler.com&#x2F;bliki&#x2F;UnitTest.html</a></div><br/></div></div></div></div><div id="37389281" class="c"><input type="checkbox" id="c-37389281" checked=""/><div class="controls bullet"><span class="by">Dudester230602</span><span>|</span><a href="#37389256">prev</a><span>|</span><a href="#37389395">next</a><span>|</span><label class="collapse" for="c-37389281">[-]</label><label class="expand" for="c-37389281">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not TDD that I don&#x27;t like it&#x27;s the zealously of its proponents.<p>In any case, TDD helped trainers put their kids through college, now the hype is over and we can be productive again.<p>PS: thanks god, mainstream pair programming is dead too.</div><br/></div></div><div id="37389395" class="c"><input type="checkbox" id="c-37389395" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#37389281">prev</a><span>|</span><a href="#37389214">next</a><span>|</span><label class="collapse" for="c-37389395">[-]</label><label class="expand" for="c-37389395">[1 more]</label></div><br/><div class="children"><div class="content">To quote Kent Beck of <i>Extreme Programming</i> fame [1]:<p>--- start quote ---<p>I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence<p>--- end quote ---<p>In my opinion, TDD as proposed by testing zealots is harmful. Instead of testing a <i>unit of work</i> testing frameworks and methodologies all but force you to test <i>units of code</i>, and that is not the same thing.<p>E.g., if your code responds with a list of items from a database, you should test <i>that</i>. Instead, people test the controller in isolation (mocking everything), the transforming function in isolation (mocking everything), the database layer in isolation (mocking everything)...<p>No. You have to test that your code, when called, returns a list of items. If you can&#x27;t have the database, mock that, and only that. Boom, you have 1500% fewer tests, with the same coverage, and an actually increased level of confidence.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;153565" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;153565</a></div><br/></div></div><div id="37389214" class="c"><input type="checkbox" id="c-37389214" checked=""/><div class="controls bullet"><span class="by">ChatGTP</span><span>|</span><a href="#37389395">prev</a><span>|</span><label class="collapse" for="c-37389214">[-]</label><label class="expand" for="c-37389214">[13 more]</label></div><br/><div class="children"><div class="content"><i>I think the simple claim that TDD improves design isn&#x27;t strictly true, and turns some people away from automated testing.</i><p>Never really heard this claim before ?</div><br/><div id="37389400" class="c"><input type="checkbox" id="c-37389400" checked=""/><div class="controls bullet"><span class="by">ryandv</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389319">next</a><span>|</span><label class="collapse" for="c-37389400">[-]</label><label class="expand" for="c-37389400">[1 more]</label></div><br/><div class="children"><div class="content">If tests are written first, (_and_ the dev has a good eye for design, which is not always given) then it is likelier that you will write a more ergonomic interface (e.g. methods having smaller number of parameters&#x2F;dependencies, &quot;intention revealing names&quot;, [0] etc..).<p>In a unit-testing paradigm, this also means that you will need to inject the unit&#x27;s dependencies so that it can be driven into specific states by each test in the suite, encouraging dependency inversion and the open&#x2F;closed principle (as given by Uncle Bob [1]; note that with dependency inversion it becomes possible to vary the behaviour of the unit in test vs. production environments simply by specifying different dependencies without modifying the unit&#x27;s code itself). If the dependencies are too cumbersome or even impossible to set up, then the test reveals something about the design (e.g. high coupling).<p>Of course, it&#x27;s also possible to just grin and bear the pain of tests being too difficult to write, without actually resolving the design problems revealed by the test...<p>[0] <a href="https:&#x2F;&#x2F;wiki.c2.com&#x2F;?IntentionRevealingNames" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.c2.com&#x2F;?IntentionRevealingNames</a><p>[1] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20060822033314&#x2F;http:&#x2F;&#x2F;www.objectmentor.com&#x2F;resources&#x2F;articles&#x2F;ocp.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20060822033314&#x2F;http:&#x2F;&#x2F;www.object...</a></div><br/></div></div><div id="37389319" class="c"><input type="checkbox" id="c-37389319" checked=""/><div class="controls bullet"><span class="by">gumballindie</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389400">prev</a><span>|</span><a href="#37389384">next</a><span>|</span><label class="collapse" for="c-37389319">[-]</label><label class="expand" for="c-37389319">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a common fallacy among some software developers that since TDD forces you to write small units of code (since you have to write small unit tests then naturally the units you test will also be small) then your code will be easy to maintain. It also forces dependency injection in OOP and a couple other design patterns. I&#x27;ve seen code written as if by one&#x27;s feet without unit tests that worked better than code with 90% test coverage. In a few cases tdd was the go to practice for sloppy devs. Somehow they thought that writing tests will account for lack of skill. But guess what? Tests were sloppy too.</div><br/><div id="37389390" class="c"><input type="checkbox" id="c-37389390" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#37389214">root</a><span>|</span><a href="#37389319">parent</a><span>|</span><a href="#37389384">next</a><span>|</span><label class="collapse" for="c-37389390">[-]</label><label class="expand" for="c-37389390">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think anybody could claim TDD will make a sloppy dev write good code.
Though there&#x27;s half an argument for getting more experienced&#x2F;skilled devs to write the tests and the more junior or less capable ones to fill in the actual working implementation (but I&#x27;ll be honest, I&#x27;ve never seen this work in practice over a prolonged period).</div><br/></div></div></div></div><div id="37389384" class="c"><input type="checkbox" id="c-37389384" checked=""/><div class="controls bullet"><span class="by">charlysisto</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389319">prev</a><span>|</span><a href="#37389331">next</a><span>|</span><label class="collapse" for="c-37389384">[-]</label><label class="expand" for="c-37389384">[1 more]</label></div><br/><div class="children"><div class="content">I heard this a few times in the ruby community by some well known figures like Sandy Metz. Simple example : time related tests can be cumbersome to setup, but if you inject time in the method, test becomes easy, incidentally improving your design by not relying on globale objects...<p>But I am sceptical this can work without knowing and practicing good design principles (SOLID) independently from tests !<p>However I believe tests are super important for refactoring, wether the design is good or not. My 2 cents : if the design is bad, (spaghetti and all) tests should be done more at the functional level, when your confident design is getting good then rely more on unit test</div><br/></div></div><div id="37389331" class="c"><input type="checkbox" id="c-37389331" checked=""/><div class="controls bullet"><span class="by">ericdykstra</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389384">prev</a><span>|</span><a href="#37389233">next</a><span>|</span><label class="collapse" for="c-37389331">[-]</label><label class="expand" for="c-37389331">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard it before as something like &quot;code that is easy to test is better code, ergo if you write your tests first your code will be better.&quot;<p>I don&#x27;t use TDD myself, but I&#x27;ve heard this merit pitched more than once.</div><br/></div></div><div id="37389233" class="c"><input type="checkbox" id="c-37389233" checked=""/><div class="controls bullet"><span class="by">beardedwizard</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389331">prev</a><span>|</span><a href="#37389320">next</a><span>|</span><label class="collapse" for="c-37389233">[-]</label><label class="expand" for="c-37389233">[4 more]</label></div><br/><div class="children"><div class="content">Came to say this, never heard this before. I have heard the claim that it improves quality, but even that is debatable. Im sure the most basic claim that can be proven is it often increases test coverage.</div><br/><div id="37389282" class="c"><input type="checkbox" id="c-37389282" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#37389214">root</a><span>|</span><a href="#37389233">parent</a><span>|</span><a href="#37389320">next</a><span>|</span><label class="collapse" for="c-37389282">[-]</label><label class="expand" for="c-37389282">[3 more]</label></div><br/><div class="children"><div class="content">Improvement in quality is improvement in design, since having less bugs is one of the desired properties of good design.</div><br/><div id="37389406" class="c"><input type="checkbox" id="c-37389406" checked=""/><div class="controls bullet"><span class="by">wizofaus</span><span>|</span><a href="#37389214">root</a><span>|</span><a href="#37389282">parent</a><span>|</span><a href="#37389304">next</a><span>|</span><label class="collapse" for="c-37389406">[-]</label><label class="expand" for="c-37389406">[1 more]</label></div><br/><div class="children"><div class="content">Unless the bug fixes are so fragile and&#x2F;or convoluted they make any change in business requirements almost impossible to implement.</div><br/></div></div><div id="37389304" class="c"><input type="checkbox" id="c-37389304" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#37389214">root</a><span>|</span><a href="#37389282">parent</a><span>|</span><a href="#37389406">prev</a><span>|</span><a href="#37389320">next</a><span>|</span><label class="collapse" for="c-37389304">[-]</label><label class="expand" for="c-37389304">[1 more]</label></div><br/><div class="children"><div class="content">A bad design may work equally well when compared to a good design, given it&#x27;s patched enough.</div><br/></div></div></div></div></div></div><div id="37389320" class="c"><input type="checkbox" id="c-37389320" checked=""/><div class="controls bullet"><span class="by">sbergot</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389233">prev</a><span>|</span><a href="#37389273">next</a><span>|</span><label class="collapse" for="c-37389320">[-]</label><label class="expand" for="c-37389320">[1 more]</label></div><br/><div class="children"><div class="content">It is a common claim made by TDD proponent. The reasoning is that it gives you a better perspective of the external facing apis you are developing because you are forced to use them when writing the tests.</div><br/></div></div><div id="37389273" class="c"><input type="checkbox" id="c-37389273" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37389214">parent</a><span>|</span><a href="#37389320">prev</a><span>|</span><label class="collapse" for="c-37389273">[-]</label><label class="expand" for="c-37389273">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Never really heard this claim before ?<p>Neither did I. I guess it really depends on what the code would be like without having the constraints to make it testable. A big ball of mud component hardly qualifies as good design, and TDD definitely dissuades people from that mistake.</div><br/><div id="37389309" class="c"><input type="checkbox" id="c-37389309" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37389214">root</a><span>|</span><a href="#37389273">parent</a><span>|</span><label class="collapse" for="c-37389309">[-]</label><label class="expand" for="c-37389309">[1 more]</label></div><br/><div class="children"><div class="content">A big ball of mocks and ten thousand layers of abstraction is so much better!</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>