<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722934862187" as="style"/><link rel="stylesheet" href="styles.css?v=1722934862187"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://16bpp.net/blog/post/noexcept-can-sometimes-help-or-hurt-performance/">C++&#x27;s `noexcept` can sometimes help or hurt performance</a>Â <span class="domain">(<a href="https://16bpp.net">16bpp.net</a>)</span></div><div class="subtext"><span>def-pri-pub</span> | <span>85 comments</span></div><br/><div><div id="41167036" class="c"><input type="checkbox" id="c-41167036" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41164711">next</a><span>|</span><label class="collapse" for="c-41167036">[-]</label><label class="expand" for="c-41167036">[15 more]</label></div><br/><div class="children"><div class="content">Oh man, don&#x27;t get me started. This was a point in a talk I gave years ago called &quot;Please Please Help the Compiler&quot; (what I thought was a clever cut at the conventional wisdom at the time of &quot;Don&#x27;t Try to Help the Compiler&quot;)<p>I work on MSVC backend. I argued pretty strenuously at the time that noexcept was costly and being marketed incorrectly. Perhaps the costs are worth it, but none the less there is a cost<p>The reason is simple: there is a guarantee here that noexcept functions don&#x27;t throw. std::terminate has to be called. That has to be implemented. There is some cost to that - conceptually every noexcept function (or worse, every call to a noexcept function) is surrounded by a giant try&#x2F;catch(...) block.<p>Yes there are optimizations here. But it&#x27;s still not free<p>Less obvious; how does inlining work? What happens if you inline a noexcept function into a function that allows exceptions? Do we now have &quot;regions&quot; of noexceptness inside that function (answer: yes). How do you implement that? Again, this is implementable, but this is even harder than the whole function case, and a naive&#x2F;early implementation might prohibit inlining across degrees of noexcept-ness to be correct&#x2F;as-if. And guess what, this is what early versions of MSVC did, and this was our biggest problem: a problem which grew release after release as noexcept permeated the standard library.<p>Anyway. My point is, we need more backend compiler engineers on WG21 and not just front end, library, and language lawyer guys.<p>I argued then that if instead noexcept violations were undefined, we could ignore all this, and instead just treat it as the pure optimization it was being marketed as (ie, help prove a region can&#x27;t throw, so we can elide entire try&#x2F;catch blocks etc). The reaction to my suggestion was not positive.</div><br/><div id="41168701" class="c"><input type="checkbox" id="c-41168701" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41167036">parent</a><span>|</span><a href="#41167139">next</a><span>|</span><label class="collapse" for="c-41168701">[-]</label><label class="expand" for="c-41168701">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Anyway. My point is, we need more backend compiler engineers on WG21 and not just front end, library, and language lawyer guys.<p>Even better, the current way of working is broken, WG21 should only discuss papers that come with a preview implementation, just like in other language ecosystems.<p>We have had too many features being approved with &quot;on-paper only&quot; designs, to be proven a bad idea when they finally got implemented, some of which removed&#x2F;changed in later ISO revisions, that already prove the point this isn&#x27;t working.</div><br/></div></div><div id="41167139" class="c"><input type="checkbox" id="c-41167139" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41167036">parent</a><span>|</span><a href="#41168701">prev</a><span>|</span><a href="#41167492">next</a><span>|</span><label class="collapse" for="c-41167139">[-]</label><label class="expand" for="c-41167139">[2 more]</label></div><br/><div class="children"><div class="content">Oh, cool! I googled myself and someone actually archived the slides from the talk I gave. I think it holds up pretty well today<p><a href="https:&#x2F;&#x2F;github.com&#x2F;TriangleCppDevelopersGroup&#x2F;TerryMahaffeyCppTalk&#x2F;blob&#x2F;master&#x2F;compiler.pptm">https:&#x2F;&#x2F;github.com&#x2F;TriangleCppDevelopersGroup&#x2F;TerryMahaffeyC...</a><p>*edit except the stuff about fastlink<p>*edit 2 also I have since added a heuristic bonus for the &quot;inline&quot; keyword because I could no longer stand the irony of &quot;inline&quot; not having anything to do with inlining<p>*edit 3 ok, also statements like &quot;consider doing X if you have no security exposure&quot; haven&#x27;t held up well</div><br/><div id="41167219" class="c"><input type="checkbox" id="c-41167219" checked=""/><div class="controls bullet"><span class="by">jahnu</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167139">parent</a><span>|</span><a href="#41167492">next</a><span>|</span><label class="collapse" for="c-41167219">[-]</label><label class="expand" for="c-41167219">[1 more]</label></div><br/><div class="children"><div class="content">Props for the edits ;)<p>I would be very interested in an updated blog post on this if you felt so inclined!</div><br/></div></div></div></div><div id="41167492" class="c"><input type="checkbox" id="c-41167492" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41167036">parent</a><span>|</span><a href="#41167139">prev</a><span>|</span><a href="#41167094">next</a><span>|</span><label class="collapse" for="c-41167492">[-]</label><label class="expand" for="c-41167492">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I argued then that if instead noexcept violations were undefined, we could ignore all this, and instead just treat it as the pure optimization it was being marketed as (ie, help prove a region can&#x27;t throw, so we can elide entire try&#x2F;catch blocks etc).<p>Do you know if the reasoning for originally switching noexcept violations from UB to calling std::terminate was documented anywhere? The corresponding meeting minutes [0] describes the vote to change the behavior but not the reason(s). There&#x27;s this bit, though:<p>&gt; [Adamczyk] added that there was strong consensus that this approach did not add call overhead in quality exception handling implementations, and did not restrict optimization unnecessarily.<p>Did that view not pan out since that meeting?<p>[0]: <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2010&#x2F;n3081.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2010&#x2F;n30...</a></div><br/><div id="41168778" class="c"><input type="checkbox" id="c-41168778" checked=""/><div class="controls bullet"><span class="by">flamedoge</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167492">parent</a><span>|</span><a href="#41167094">next</a><span>|</span><label class="collapse" for="c-41168778">[-]</label><label class="expand" for="c-41168778">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  did not restrict optimization unnecessarily.<p>well clearly there is a cost</div><br/></div></div></div></div><div id="41167094" class="c"><input type="checkbox" id="c-41167094" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#41167036">parent</a><span>|</span><a href="#41167492">prev</a><span>|</span><a href="#41167301">next</a><span>|</span><label class="collapse" for="c-41167094">[-]</label><label class="expand" for="c-41167094">[4 more]</label></div><br/><div class="children"><div class="content">Added to my list why I compile with -fno-exceptions</div><br/><div id="41167587" class="c"><input type="checkbox" id="c-41167587" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167094">parent</a><span>|</span><a href="#41167301">next</a><span>|</span><label class="collapse" for="c-41167587">[-]</label><label class="expand" for="c-41167587">[3 more]</label></div><br/><div class="children"><div class="content">-fno-exceptions only prevents you from calling throw. If you don&#x27;t want overhead likely you want -fno-asynchronous-unwind-tables + that clang flag that specifies that extern &quot;C&quot; functions don&#x27;t throw</div><br/><div id="41168414" class="c"><input type="checkbox" id="c-41168414" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167587">parent</a><span>|</span><a href="#41168436">next</a><span>|</span><label class="collapse" for="c-41168414">[-]</label><label class="expand" for="c-41168414">[1 more]</label></div><br/><div class="children"><div class="content">Looking how the docs for <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Code-Gen-Options.html#index-fasynchronous-unwind-tables" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Code-Gen-Options.html#ind...</a><p>How does that affect code generation? It reads as only effecting debug information and binary size to my untrained eyes.</div><br/></div></div><div id="41168436" class="c"><input type="checkbox" id="c-41168436" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167587">parent</a><span>|</span><a href="#41168414">prev</a><span>|</span><a href="#41167301">next</a><span>|</span><label class="collapse" for="c-41168436">[-]</label><label class="expand" for="c-41168436">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure I could see a roughly 10% binary size decrease in my C++ projcts just by setting -fno-exceptions, and that was for C++ code that didn&#x27;t use exceptions in the first place, so there must be more to it then just forbidding throw. Last time I tinkered with this stuff was around 2017 though.</div><br/></div></div></div></div></div></div><div id="41167301" class="c"><input type="checkbox" id="c-41167301" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41167036">parent</a><span>|</span><a href="#41167094">prev</a><span>|</span><a href="#41164711">next</a><span>|</span><label class="collapse" for="c-41167301">[-]</label><label class="expand" for="c-41167301">[5 more]</label></div><br/><div class="children"><div class="content">I assume the &#x2F;EHr- flag was introduced to mitigate this, right?</div><br/><div id="41167342" class="c"><input type="checkbox" id="c-41167342" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167301">parent</a><span>|</span><a href="#41164711">next</a><span>|</span><label class="collapse" for="c-41167342">[-]</label><label class="expand" for="c-41167342">[4 more]</label></div><br/><div class="children"><div class="content">Nah that was mostly about extern &quot;C&quot; functions which technically can&#x27;t throw (so the noexcept runtime stuff would be optimized out) but in practice there is a ton of code marked extern &quot;C&quot; which throws</div><br/><div id="41168779" class="c"><input type="checkbox" id="c-41168779" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167342">parent</a><span>|</span><a href="#41167353">next</a><span>|</span><label class="collapse" for="c-41168779">[-]</label><label class="expand" for="c-41168779">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in practice there is a ton of code marked extern &quot;C&quot; which throws<p>Obviously, a random programmer could do any evil things, but does that apply to standard code, such as C standard library used from C++?</div><br/></div></div><div id="41167353" class="c"><input type="checkbox" id="c-41167353" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167342">parent</a><span>|</span><a href="#41168779">prev</a><span>|</span><a href="#41164711">next</a><span>|</span><label class="collapse" for="c-41167353">[-]</label><label class="expand" for="c-41167353">[2 more]</label></div><br/><div class="children"><div class="content">extern &quot;C&quot; seems related to the other flags, not &#x27;r&#x27;?</div><br/><div id="41167446" class="c"><input type="checkbox" id="c-41167446" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41167036">root</a><span>|</span><a href="#41167353">parent</a><span>|</span><a href="#41164711">next</a><span>|</span><label class="collapse" for="c-41167446">[-]</label><label class="expand" for="c-41167446">[1 more]</label></div><br/><div class="children"><div class="content">Well, yeah, things can be related to many things, but throwing extern &quot;C&quot;s was one of the motivations as I recall for &#x27;r&#x27;. r is about a compiler optimization where we elide the runtime terminate check if we can statically &quot;prove&quot; a function can never throw. To prove it statically we depend on things like extern &quot;C&quot; functions not throwing, even though users can (and do) totally write that code.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41164711" class="c"><input type="checkbox" id="c-41164711" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41167036">prev</a><span>|</span><a href="#41164326">next</a><span>|</span><label class="collapse" for="c-41164711">[-]</label><label class="expand" for="c-41164711">[4 more]</label></div><br/><div class="children"><div class="content">The most common place where noexcept improves performance is on move constructors and move assignments when moving is cheaper than copying. If your type is not nothrow moveable std::vector will copy it instead of moving when resizing, as the move constructor throwing would leave the vector in an invalid state (while the copy constructor throwing leaves the vector unchanged).<p>Platforms with setjmp-longjmp based exceptions benefit greatly from noexcept as thereâs setup code required before calling functions which may throw. Those platforms are now mostly gone, though. Modern âzero costâ exceptions donât execute a single instruction related to exception handling if no exceptions are thrown (hence the name), so there just isnât much room for noexcept to be useful to the optimizer.<p>Outside of those two scenarios there isnât any reason to expect noexcept to improve performance.</div><br/><div id="41165344" class="c"><input type="checkbox" id="c-41165344" checked=""/><div class="controls bullet"><span class="by">jzwinck</span><span>|</span><a href="#41164711">parent</a><span>|</span><a href="#41166393">next</a><span>|</span><label class="collapse" for="c-41165344">[-]</label><label class="expand" for="c-41165344">[2 more]</label></div><br/><div class="children"><div class="content">There is another standard library related scenario: hash tables. The std unordered containers will store the hash of each key unless your hash function is noexcept. Analogous to how vector needs noexcept move for fast reserve and resize, unordered containers need noexcept hash to avoid extra memory usage. See <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;libstdc++&#x2F;manual&#x2F;unordered_associative.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;libstdc++&#x2F;manual&#x2F;unordered_as...</a></div><br/><div id="41168437" class="c"><input type="checkbox" id="c-41168437" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#41164711">root</a><span>|</span><a href="#41165344">parent</a><span>|</span><a href="#41166393">next</a><span>|</span><label class="collapse" for="c-41168437">[-]</label><label class="expand" for="c-41168437">[1 more]</label></div><br/><div class="children"><div class="content">For many key types and access patterns, storing the hash is faster anyway. I assume people who care about performance are already not using std::unordered_map though.</div><br/></div></div></div></div><div id="41166393" class="c"><input type="checkbox" id="c-41166393" checked=""/><div class="controls bullet"><span class="by">10tacobytes</span><span>|</span><a href="#41164711">parent</a><span>|</span><a href="#41165344">prev</a><span>|</span><a href="#41164326">next</a><span>|</span><label class="collapse" for="c-41166393">[-]</label><label class="expand" for="c-41166393">[1 more]</label></div><br/><div class="children"><div class="content">This is the correct analysis. The article&#x27;s author could have saved themselves (and the reader) a good amount of blind data diving by learning more about exception processing beforehand.</div><br/></div></div></div></div><div id="41164326" class="c"><input type="checkbox" id="c-41164326" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#41164711">prev</a><span>|</span><a href="#41163900">next</a><span>|</span><label class="collapse" for="c-41164326">[-]</label><label class="expand" for="c-41164326">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s quite interesting and a huge work has been done here, respect for that.<p>Here&#x27;s what has jumped out at me: `noexcept` qualifier is not free in some cases, particularly, when a qualified function could actually throw, but is marked `noexcept`. In that case, a compiler still must set something up to fulfil the main `noexcept` promise - call `std::terminate()` if an exception is thrown. That means, that putting `noexcept` on each and every function blindly without any regard to whether the function could really throw or not (for example, `std::vector::push_back()` could throw on reallocation failure, hence if a `noexcept` qualified function call it, a compiler must take into account) doesn&#x27;t actually test&#x2F;benchmark&#x2F;prove anything, since as the author correctly said, - you won&#x27;t ever do this in a real production project.
It would be really interesting to take a look into a full code of cases that showed very bad performance, however, here we&#x27;re approaching the second issue: if that&#x27;s the core benchmark code: <a href="https:&#x2F;&#x2F;github.com&#x2F;define-private-public&#x2F;PSRayTracing&#x2F;blob&#x2F;acb04979c49ea8adef8c4afc349a96015834835e&#x2F;experiments&#x2F;noexcept_keyword&#x2F;noexcept_list_iteration_test.cpp">https:&#x2F;&#x2F;github.com&#x2F;define-private-public&#x2F;PSRayTracing&#x2F;blob&#x2F;a...</a> then unfortunately it&#x27;s totally invalid since it measures time with the `std::chrono::system_clock` which isn&#x27;t monotonic. Given how long the code required to run, it&#x27;s almost certain that the clock has been adjusted several times...</div><br/><div id="41166375" class="c"><input type="checkbox" id="c-41166375" checked=""/><div class="controls bullet"><span class="by">bodyfour</span><span>|</span><a href="#41164326">parent</a><span>|</span><a href="#41164796">next</a><span>|</span><label class="collapse" for="c-41166375">[-]</label><label class="expand" for="c-41166375">[2 more]</label></div><br/><div class="children"><div class="content">&gt; in that case, a compiler still must set something up to fulfil the main `noexcept` promise - call `std::terminate()`<p>This is actually something that has been more of a problem in clang than gcc due to LLVM IR limitations... but that is being fixed (or maybe is already?)  There was a presentation about it at the 2023 LLVM Developer&#x27;s meeting which was recently published on their youtube channel <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DMUeTaIe1CU" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DMUeTaIe1CU</a><p>The short version (as I understand) is that you don&#x27;t really need to produce any code to call std::terminate, all you need is tell the linker it needs to leave a hole in the table which maps %rip to the required unwind actions.  If the unwinder doesn&#x27;t know what to do, it will call std::terminate per the standard.<p>IR didn&#x27;t have a way of expressing this &quot;hole&quot;, though, so instead clang was forced to emit an explicit &quot;handler&quot; to do the std::terminate call</div><br/><div id="41167093" class="c"><input type="checkbox" id="c-41167093" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41164326">root</a><span>|</span><a href="#41166375">parent</a><span>|</span><a href="#41164796">next</a><span>|</span><label class="collapse" for="c-41167093">[-]</label><label class="expand" for="c-41167093">[1 more]</label></div><br/><div class="children"><div class="content">In MSVC we&#x27;ve also pretty heavily optimized the whole function case such that we no longer have a literal try&#x2F;catch block around it (I think there is a single bit in our per function unwind info that the unwinder checks and kills the program if it encounters while unwinding). One extra branch but no increase in the unwind metadata size<p>The inlining case was always the hard problem to solve though</div><br/></div></div></div></div><div id="41164796" class="c"><input type="checkbox" id="c-41164796" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41164326">parent</a><span>|</span><a href="#41166375">prev</a><span>|</span><a href="#41163900">next</a><span>|</span><label class="collapse" for="c-41164796">[-]</label><label class="expand" for="c-41164796">[2 more]</label></div><br/><div class="children"><div class="content">&gt; then unfortunately it&#x27;s totally invalid since it measures time with the `std::chrono::system_clock` which isn&#x27;t monotonic. Given how long the code required to run, it&#x27;s almost certain that the clock has been adjusted several times<p>monotonic clocks are mostly useful for short measurement periods. for long-term timing wall-time clocks (with their adjustments) are more accurate because they will drift less.</div><br/><div id="41168521" class="c"><input type="checkbox" id="c-41168521" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#41164326">root</a><span>|</span><a href="#41164796">parent</a><span>|</span><a href="#41163900">next</a><span>|</span><label class="collapse" for="c-41168521">[-]</label><label class="expand" for="c-41168521">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that&#x27;s a great correction, thank you!
Yes, indeed, due to a drift, in order to discern second+ (?) differences on different machines (or same machines, but different OSes?), one definitely needs to use a wall-clock time, otherwise it&#x27;s comparing apples to oranges. There&#x27;s a lot of interesting questions related to that, but they out of the scope of the thread. If I&#x27;m not mistaken the author has also timed some individual small functions, which, if correct, still poses a problem to me, but for measuring huge long running tasks like a full suite running 10+ hours, they are probably right in choosing wall-clock timer indeed.<p>However, before researching into results any further (for example, -10% difference for `noexcept` case is extremely interesting to debug up to the root cause), I&#x27;d still like to understand how the code was run and measured exactly. I didn&#x27;t find a plausible looking benchmark runner in their code base.</div><br/></div></div></div></div></div></div><div id="41163900" class="c"><input type="checkbox" id="c-41163900" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#41164326">prev</a><span>|</span><a href="#41164218">next</a><span>|</span><label class="collapse" for="c-41163900">[-]</label><label class="expand" for="c-41163900">[22 more]</label></div><br/><div class="children"><div class="content">&gt; I didn&#x27;t know std::uniform_int_distribution doesn&#x27;t actually produce the same results on different compilers<p>I think this is genuinely my biggest complaint about the C++ standard library. There are countless scenarios where you want deterministic random numbers (for testing if nothing else), so std&#x27;s distributions are unusable. Fortunately you can just plug in Boost&#x27;s implementation.</div><br/><div id="41166408" class="c"><input type="checkbox" id="c-41166408" checked=""/><div class="controls bullet"><span class="by">nwallin</span><span>|</span><a href="#41163900">parent</a><span>|</span><a href="#41164599">next</a><span>|</span><label class="collapse" for="c-41166408">[-]</label><label class="expand" for="c-41166408">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually really important that uniform_int_distribution is implementation defined. The &#x27;right&#x27; way to do it on one architecture is probably not the right way to do it on a different architecture.<p>For instance, Apple&#x27;s new CPUs has very fast division. A convenient and useful tool to implement uniform_int_distribution relies on using modulo. So the implementation that runs on Apple&#x27;s new CPUs ought to use the modulo instructions of the CPU.<p>On other architectures, the ISA might not even have a modulo instruction. In this case, it&#x27;s very important that you don&#x27;t try to emulate modulo in software; it&#x27;s much better to rely other more complicated constructs to give a uniform distribution.<p>C++ is also expected to run on GPUs. NVIDIA&#x27;s CUDA and AMD&#x27;s HIP are both implementations of C++. (these implementations are non-compliant given the nature of GPUs, but both they and the C++ standard&#x27;s committee have a shared goal of narrowing that gap) In general, std::uniform_int_distribution uses loops to eliminate redundancies; the &#x27;happy path&#x27; has relatively easily predicted branches, but they can and do have instances where the branch is not easily predicted and will as often as not have to loop in order to complete. Doing this on a GPU might be multiple orders of magnitude slower than another method that&#x27;s better suited for a GPU.<p>Overzealously dictating an implementation is why C++ ended up with a relatively bad hash table and very bad regex in the standard. It&#x27;s a mistake that shouldn&#x27;t be made again.</div><br/><div id="41168443" class="c"><input type="checkbox" id="c-41168443" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166408">parent</a><span>|</span><a href="#41167955">next</a><span>|</span><label class="collapse" for="c-41168443">[-]</label><label class="expand" for="c-41168443">[1 more]</label></div><br/><div class="children"><div class="content">But reproducibility is as important as performance for the vast majority of use cases, if these implementation-defined bits start to affect the observable outcomes. (That&#x27;s why we define the required <i>time complexity</i> for many container-related functions but do not actually specify the exact algorithm; difference in Big-O time complexity is just large enough to be &quot;observed&quot;.)<p>A common solution is to provide two versions of such features, one for the less reproducible but maximally performant version and another for common middle grounds that can be reproduced reasonably efficiently across many common platforms. In fact I believe `std::chrono` was designed in that way to sidestep many uncertainties in platform clock implementations.</div><br/></div></div><div id="41167955" class="c"><input type="checkbox" id="c-41167955" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166408">parent</a><span>|</span><a href="#41168443">prev</a><span>|</span><a href="#41164599">next</a><span>|</span><label class="collapse" for="c-41167955">[-]</label><label class="expand" for="c-41167955">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Overzealously dictating an implementation is why C++ ended up with a relatively bad hash table and very bad regex in the standard.<p>What parts of the standard dictate a particular regex implementation? IIRC the performance issues are usually blamed on ABI compatibility constraints rather than the standard making a fast(er) implementation impossible.</div><br/></div></div></div></div><div id="41164599" class="c"><input type="checkbox" id="c-41164599" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41163900">parent</a><span>|</span><a href="#41166408">prev</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41164599">[-]</label><label class="expand" for="c-41164599">[17 more]</label></div><br/><div class="children"><div class="content">&gt; There are countless scenarios where you want deterministic random numbers (for testing if nothing else), so std&#x27;s distributions are unusable. Fortunately you can just plug in Boost&#x27;s implementation.<p>I don&#x27;t understand what&#x27;s your complain. If you&#x27;re already plugging in alternative implementations,what stops you from actually stubbing these random number generators with any realization at all?</div><br/><div id="41164763" class="c"><input type="checkbox" id="c-41164763" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41164599">parent</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41164763">[-]</label><label class="expand" for="c-41164763">[16 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a compromised and goofy implementation with lots of warts.  What&#x27;s the point it in having a &#x2F;standard&#x2F; library then?</div><br/><div id="41164985" class="c"><input type="checkbox" id="c-41164985" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41164763">parent</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41164985">[-]</label><label class="expand" for="c-41164985">[15 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a compromised and goofy implementation with lots of warts.<p>I don&#x27;t think this case qualifies as an example. I think the only goofy detail in the story is expecting a random number generator to be non-random and deterministic with the only conceivable usecase being poorly designed and implemented test fxtures.<p>&gt; What&#x27;s the point it in having a &#x2F;standard&#x2F; library then?<p>The point of standardized components is to provide reusable elements that can be used across all platforms and implementations, thus saving on the development effort of upgrading and porting the code across implementations and even platforms. If you cannot design working software, that&#x27;s not a problem you can pin on the tools you don&#x27;t know how to use.</div><br/><div id="41165056" class="c"><input type="checkbox" id="c-41165056" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41164985">parent</a><span>|</span><a href="#41165451">next</a><span>|</span><label class="collapse" for="c-41165056">[-]</label><label class="expand" for="c-41165056">[1 more]</label></div><br/><div class="children"><div class="content">&gt; with the only conceivable usecase being poorly designed and implemented test fxtures.<p>Reproducible pseudo-randomness is a necessity with fuzz testing. It is not a poor design approach when it is actually useful.</div><br/></div></div><div id="41165451" class="c"><input type="checkbox" id="c-41165451" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41164985">parent</a><span>|</span><a href="#41165056">prev</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41165451">[-]</label><label class="expand" for="c-41165451">[13 more]</label></div><br/><div class="children"><div class="content">&gt; The point of standardized components is to provide reusable elements that can be used across all platforms and implementations, thus saving on the development effort of upgrading and porting the code across implementations and even platforms.<p>It&#x27;s a shame that C++&#x27;s &quot;standardized&quot; components ARE COMPLETELY DIFFERENT on different platforms.<p>Some of the C++ standard <i>requires</i> per-platform implementation work. For example std::thread on Linux and Windows obviously must have a different implementation. However a super majority of the standard API is just vanilla C++ code. For example std::vector or std::unordered_map. The fact that the standard defines a spec which is then implemented numerous times is absurd, stupid, and bad. The specs are simultaneously over-constrained and under-constrained. It&#x27;s a disaster.</div><br/><div id="41166046" class="c"><input type="checkbox" id="c-41166046" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41165451">parent</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41166046">[-]</label><label class="expand" for="c-41166046">[12 more]</label></div><br/><div class="children"><div class="content">I consider the current tradeoff to be a feature.<p>It permits implementations to take advantage of target-specific affordances (your thread case is an example) as well as taking different implementation strategies (e.g. the small string optimization is different in libc++ and libstdc++).  Also you may use another, independent standard library because you prefer its implementation decisions.  Meanwhile they remain compatible at the source level.</div><br/><div id="41166790" class="c"><input type="checkbox" id="c-41166790" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166046">parent</a><span>|</span><a href="#41167594">next</a><span>|</span><label class="collapse" for="c-41166790">[-]</label><label class="expand" for="c-41166790">[6 more]</label></div><br/><div class="children"><div class="content">Unlike in C, in C++ it is not possible to use an independent implementation of the standard library.<p>Clang is compatible with GCC&#x27;s standard library&#x2F;libstdc++ and MSVC&#x27;s standard library because the clang compiler explicitly supports them, but it&#x27;s not possible to use clang&#x27;s standard library with GCC in a standard conforming way or interchange GCC&#x27;s with MSVC&#x27;s standard library.<p>There are some hacks that let you use some parts of libc++ with GCC by using the nostdlib flag, but this disables a lot of C++ functionality such as exception handling, RTTI, type traits. These features are in turn used by things like std::vector, std::map, etc... so you won&#x27;t be able to use those classes either, and so on so forth...</div><br/><div id="41168715" class="c"><input type="checkbox" id="c-41168715" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166790">parent</a><span>|</span><a href="#41167145">next</a><span>|</span><label class="collapse" for="c-41168715">[-]</label><label class="expand" for="c-41168715">[1 more]</label></div><br/><div class="children"><div class="content">As proven by musl versus glibc issues, that possibility is mostly theoric, with plenty of gotchas in practice.</div><br/></div></div><div id="41167145" class="c"><input type="checkbox" id="c-41167145" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166790">parent</a><span>|</span><a href="#41168715">prev</a><span>|</span><a href="#41167594">next</a><span>|</span><label class="collapse" for="c-41167145">[-]</label><label class="expand" for="c-41167145">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Unlike in C, in C++ it is not possible to use an independent implementation of the standard library.<p>It sure is, and is pretty easy to do.  I know companies using EASTL, libcu++, and HPX, as well as more who use Folly and Abseil which have alternate implementations to much of the standard library.<p>These days many languages have a single implementation so some people whose experience is only in those environment complain that C++ is âunnecessary complicated to useâ.  But a lot of that flexibility and back compatibility is what <i>allows</i> these multiple implementations to thrive while representing different points in the design&#x2F;feature space.</div><br/><div id="41167261" class="c"><input type="checkbox" id="c-41167261" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41167145">parent</a><span>|</span><a href="#41167594">next</a><span>|</span><label class="collapse" for="c-41167261">[-]</label><label class="expand" for="c-41167261">[3 more]</label></div><br/><div class="children"><div class="content">None of those are implementations of the C++ standard library. None of them even live in the same namespace as the standard library so your claim that they remain compatible at the source level is nonsense. Just a simple Google search would reveal that you are wrong about this and what&#x27;s worse is that you place the burden on me to have to disprove your wrong assertions as opposed to providing references that justify your position:<p>Folly <a href="https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;folly</a>:<p>&quot;It complements (as opposed to competing against) offerings such as Boost and of course std. In fact, we embark on defining our own component only when something we need is either not available, or does not meet the needed performance profile.&quot;<p>libcu++: <a href="https:&#x2F;&#x2F;nvidia.github.io&#x2F;cccl&#x2F;libcudacxx&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nvidia.github.io&#x2F;cccl&#x2F;libcudacxx&#x2F;</a><p>&quot;It does not replace the Standard Library provided by your host compiler (aka anything in std::)<p>Incremental: It does not provide a complete C++ Standard Library implementation.&quot;<p>Abseil: <a href="https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp">https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp</a><p>&quot;Abseil is an open-source collection of C++ library code designed to <i>augment</i> the C++ standard library. Abseil is <i>not meant to be a competitor</i> to the standard library&quot;</div><br/><div id="41167345" class="c"><input type="checkbox" id="c-41167345" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41167261">parent</a><span>|</span><a href="#41167594">next</a><span>|</span><label class="collapse" for="c-41167345">[-]</label><label class="expand" for="c-41167345">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Just a simple Google search would reveal that you are wrong about this and what&#x27;s worse is that you place the burden on me to have to disprove your wrong assertions as opposed to providing references that justify your position:<p>How rude.  Have you used any of those libraries or perhaps relied on Google&#x27;s &quot;AI&quot;-generated answer?<p>&gt; None of those are implementations of the C++ standard library.<p>HPX, EASTL specifically are, the latter being heavily used in (unsurprisingly) the gaming comunity).<p>libcu++ is for your <i>target</i> compilation.<p>As for Folly and Abseil, I wrote &quot;as well as more who use Folly and Abseil which have alternate implementations to <i>much of the standard library</i>&quot; (i.e. not ful drop in replacements).<p>So really I don&#x27;t know what your point is: you made an assertion, then replied not to what I actually wrote but by simply doing a quick google search and using that as your conclusion.<p>I have used all of HPX, Folly and Abseil but I guess the top of a google search result is more authoritative.</div><br/><div id="41167391" class="c"><input type="checkbox" id="c-41167391" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41167345">parent</a><span>|</span><a href="#41167594">next</a><span>|</span><label class="collapse" for="c-41167391">[-]</label><label class="expand" for="c-41167391">[1 more]</label></div><br/><div class="children"><div class="content">My point is simple, you are poorly informed on this topic and should refrain from speaking about it.<p>None of the libraries you listed are independent implementations of the standard library let alone source compatible.<p>EASTL does not claim to be an implementation of the C++ standard library, its claim is that it is an alternative to the C++ standard library. Perhaps the distinction is too subtle for you to have actually understood it but one thing is obvious, you have clearly never used it.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41167594" class="c"><input type="checkbox" id="c-41167594" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166046">parent</a><span>|</span><a href="#41166790">prev</a><span>|</span><a href="#41167132">next</a><span>|</span><label class="collapse" for="c-41167594">[-]</label><label class="expand" for="c-41167594">[2 more]</label></div><br/><div class="children"><div class="content">&gt; as well as taking different implementation strategies (e.g. the small string optimization is different in libc++ and libstdc++<p>As a user this is really not a good thing when the stdlib is tied to the platform. In the end the only sane thing to do if you want any reproducibility across operating systems is to exclusively use libc++ everywhere.</div><br/><div id="41168073" class="c"><input type="checkbox" id="c-41168073" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41167594">parent</a><span>|</span><a href="#41167132">next</a><span>|</span><label class="collapse" for="c-41168073">[-]</label><label class="expand" for="c-41168073">[1 more]</label></div><br/><div class="children"><div class="content">&gt;In the end the only sane thing to do if you want any reproducibility across operating systems is to exclusively use ...<p>no std library code in portable code. FTFY.<p>Ofc there are no absolutes. In gamedev essential type info bits and intrinsics are either allowed back or wrapped. Algorithm library is another bit allowed for the most part ( no unstable sort and such ).<p>I know your approach of &#x27;one ring-libc++ to rule them all&#x27; is much more popular in community but gamedevs needed cross platform code for long time. It always had been working well regardless of the opinions.</div><br/></div></div></div></div><div id="41167132" class="c"><input type="checkbox" id="c-41167132" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41166046">parent</a><span>|</span><a href="#41167594">prev</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41167132">[-]</label><label class="expand" for="c-41167132">[3 more]</label></div><br/><div class="children"><div class="content">Hard, hard disagree.<p>If you want to support different implementation strategies it needs to be far more piecemeal. Not all or nothing. I mean there&#x27;s only 3 meaningful implementation - libstdc++, libc++, and MSVC. And they aren&#x27;t wholly interchangeable!<p>Quite frankly if you value trying different implementation strategies then the C++ model is a complete and total failure. A successful model would have many, many different implementations of different components. The fact there are just 3 is an objective failure.</div><br/><div id="41167151" class="c"><input type="checkbox" id="c-41167151" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41167132">parent</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41167151">[-]</label><label class="expand" for="c-41167151">[2 more]</label></div><br/><div class="children"><div class="content">See my parallel reply: there are much more than just three, and all work with the three&#x2F;four most dominant compilers these days as well as less dominant ones like EDG or Intel.</div><br/><div id="41167465" class="c"><input type="checkbox" id="c-41167465" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41163900">root</a><span>|</span><a href="#41167151">parent</a><span>|</span><a href="#41165673">next</a><span>|</span><label class="collapse" for="c-41167465">[-]</label><label class="expand" for="c-41167465">[1 more]</label></div><br/><div class="children"><div class="content">No, there are just 3 relevant standard implementations. There are numerous independent libraries that perform very similar but non-conformant functionality.<p>My complaint is that the C++ standards committee should, when possible, release code and not a specification. They shouldn&#x27;t release a std::map spec that 3 different vendors implement. The committee should write and release a single std::map implementation. It&#x27;s just vanilla C++ after all.<p>My proposal does not prohibit Abseil, Folly, etc from releasing their own version of map which may, and likely will, choose different constraints and trade-offs.<p>Rust&#x27;s standard library is not a spec, it&#x27;s just code. There are many, many, many crates the implement the same APIs with different implementations and behavior. Sometimes those crates even get promoted and become the standard implementation. This is, imho, a far superior approach than the C++ specification approach.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41165673" class="c"><input type="checkbox" id="c-41165673" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41163900">parent</a><span>|</span><a href="#41164599">prev</a><span>|</span><a href="#41164218">next</a><span>|</span><label class="collapse" for="c-41165673">[-]</label><label class="expand" for="c-41165673">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think this is genuinely my biggest complaint about the C++ standard library<p>What do you think of Abseil hash tables randomizing themselves (piggybacking on ASLR) on each start of your program?</div><br/></div></div></div></div><div id="41164218" class="c"><input type="checkbox" id="c-41164218" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#41163900">prev</a><span>|</span><a href="#41163950">next</a><span>|</span><label class="collapse" for="c-41164218">[-]</label><label class="expand" for="c-41164218">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t feel like this article illuminates anything about how noexcept works. The asm diff at the end suggests _there is no difference_ in the emitted code. I plugged it into godbolt myself and see absolutely no difference. <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;jdro5jdnG" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;jdro5jdnG</a><p>It seems the selected example function may not be exercising noexcept. I suppose the assumption is that operator[] is something that can throw, but ... perhaps the machinery lives outside the function (so should really examine function calls), or is never emitted without a try&#x2F;catch, or operator[] (though not marked noexcept...) doesn&#x27;t throw b&#x2F;c OOB is undefined behavior, or ... ?</div><br/><div id="41167106" class="c"><input type="checkbox" id="c-41167106" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41164218">parent</a><span>|</span><a href="#41165742">next</a><span>|</span><label class="collapse" for="c-41167106">[-]</label><label class="expand" for="c-41167106">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t just look at the codegen of the function itself, you also have to consider the metadata, and the overhead of processing any metadata<p>Specifically here (as I said in other comments) where it goes from complicated&#x2F;quality of implementation issue to &quot;shit this is complicated&quot; is when you consider inlining. If noexcept inhibits inlining in any conceivable circumstances then it&#x27;s having a dramatic (slightly indirect) impact on performance</div><br/></div></div><div id="41165742" class="c"><input type="checkbox" id="c-41165742" checked=""/><div class="controls bullet"><span class="by">quuxplusone</span><span>|</span><a href="#41164218">parent</a><span>|</span><a href="#41167106">prev</a><span>|</span><a href="#41165803">next</a><span>|</span><label class="collapse" for="c-41165742">[-]</label><label class="expand" for="c-41165742">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t feel like this article illuminates anything about how noexcept works. The asm diff at the end suggests _there is no difference_ in the emitted code.<p>You are absolutely correct. The OP is basically testing the hypothesis &quot;Wrapping a function in `noexcept` will magically make it faster,&quot; which is (1) nonsense to anyone who knows how C++ works, and also (2) trivially easy to falsify, because all you have to do is look at the compiled code. Same codegen? Then it&#x27;s not going to be faster (or slower). You needn&#x27;t spend all those CPU cycles to find out what you already know by looking.<p>There <i>has</i> been a fair bit of literature written on the performance of exceptions and noexcept, but OP isn&#x27;t contributing anything with this particular post.<p>Here are two of my own blog posts on the subject. The first one is just an explanation of the &quot;vector pessimization&quot; which was also mentioned (obliquely) in OP&#x27;s post â but with an actual benchmark where you can see why it matters.
<a href="https:&#x2F;&#x2F;quuxplusone.github.io&#x2F;blog&#x2F;2022&#x2F;08&#x2F;26&#x2F;vector-pessimization&#x2F;#conclusion-the-vector-pessimization" rel="nofollow">https:&#x2F;&#x2F;quuxplusone.github.io&#x2F;blog&#x2F;2022&#x2F;08&#x2F;26&#x2F;vector-pessimi...</a>
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;e4jEcdfT9" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;e4jEcdfT9</a><p>The second one is much more interesting, because it shows where `noexcept` can actually have an effect on codegen <i>in the core language</i>. TLDR, it can matter on functions that the compiler can&#x27;t inline, such as when crossing ABI boundaries or when (as in this case) it&#x27;s an indirect call through a function pointer.
<a href="https:&#x2F;&#x2F;quuxplusone.github.io&#x2F;blog&#x2F;2022&#x2F;07&#x2F;30&#x2F;type-erased-inplace-printable&#x2F;#benefits-from-noexcept" rel="nofollow">https:&#x2F;&#x2F;quuxplusone.github.io&#x2F;blog&#x2F;2022&#x2F;07&#x2F;30&#x2F;type-erased-in...</a></div><br/><div id="41166227" class="c"><input type="checkbox" id="c-41166227" checked=""/><div class="controls bullet"><span class="by">hoten</span><span>|</span><a href="#41164218">root</a><span>|</span><a href="#41165742">parent</a><span>|</span><a href="#41165803">next</a><span>|</span><label class="collapse" for="c-41166227">[-]</label><label class="expand" for="c-41166227">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what I&#x27;m talking about! Thanks for sharing, I learned quite a few things about noexcept from your articles.</div><br/></div></div></div></div><div id="41165803" class="c"><input type="checkbox" id="c-41165803" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41164218">parent</a><span>|</span><a href="#41165742">prev</a><span>|</span><a href="#41163950">next</a><span>|</span><label class="collapse" for="c-41165803">[-]</label><label class="expand" for="c-41165803">[1 more]</label></div><br/><div class="children"><div class="content">The example is bad. Maybe this illustrates it better:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1asa7Tjq9" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;1asa7Tjq9</a></div><br/></div></div></div></div><div id="41163950" class="c"><input type="checkbox" id="c-41163950" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#41164218">prev</a><span>|</span><a href="#41168747">next</a><span>|</span><label class="collapse" for="c-41163950">[-]</label><label class="expand" for="c-41163950">[1 more]</label></div><br/><div class="children"><div class="content">Even a speedup of around 1% (if it is consistent and in a carefully controlled experiment) is significant for many workloads, if the workload is big enough.<p>The OP has this as in the fuzz, which it may be for that particular workload. But across a giant distributed system like youtube or Google search, it is a real gain.</div><br/></div></div><div id="41168747" class="c"><input type="checkbox" id="c-41168747" checked=""/><div class="controls bullet"><span class="by">hoseja</span><span>|</span><a href="#41163950">prev</a><span>|</span><a href="#41166642">next</a><span>|</span><label class="collapse" for="c-41168747">[-]</label><label class="expand" for="c-41168747">[1 more]</label></div><br/><div class="children"><div class="content">Apologize less for using completely benign standard macros. They are an okay tool if not abused.</div><br/></div></div><div id="41166642" class="c"><input type="checkbox" id="c-41166642" checked=""/><div class="controls bullet"><span class="by">Squeeeez</span><span>|</span><a href="#41168747">prev</a><span>|</span><a href="#41164404">next</a><span>|</span><label class="collapse" for="c-41166642">[-]</label><label class="expand" for="c-41166642">[1 more]</label></div><br/><div class="children"><div class="content">Is this some kind of new clickbait title? Something &quot;can&quot; &quot;sometimes&quot; do something (already 0 information) - ooor sometimes it also does the opposite. The only possibility not allowed is that it would not make any difference, but this one is actually also possible. Sigh.</div><br/></div></div><div id="41164404" class="c"><input type="checkbox" id="c-41164404" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#41166642">prev</a><span>|</span><a href="#41163981">next</a><span>|</span><label class="collapse" for="c-41164404">[-]</label><label class="expand" for="c-41164404">[1 more]</label></div><br/><div class="children"><div class="content">I thought I saw this post, or a <i>very</i> similar one, a couple years ago. Does anyone else remember that? Yet I don&#x27;t see it in the post history.</div><br/></div></div><div id="41163981" class="c"><input type="checkbox" id="c-41163981" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#41164404">prev</a><span>|</span><a href="#41167375">next</a><span>|</span><label class="collapse" for="c-41163981">[-]</label><label class="expand" for="c-41163981">[23 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t the compiler deduce noexcept for you?</div><br/><div id="41164068" class="c"><input type="checkbox" id="c-41164068" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#41163981">parent</a><span>|</span><a href="#41164053">next</a><span>|</span><label class="collapse" for="c-41164068">[-]</label><label class="expand" for="c-41164068">[9 more]</label></div><br/><div class="children"><div class="content">No, noexcept confusingly doesn&#x27;t mean &quot;does not throw exceptions&quot; in that sense. There is no constraint that says you can only call noexcept code from noexcept code - quite the opposite. Noexcept puts NO constraints on the code.<p>All noexcept does is catch any exception and immediately std::terminate. Confusingly this means that noexcept should really be called deathexcept, since any exception thrown within kills the program.</div><br/><div id="41164561" class="c"><input type="checkbox" id="c-41164561" checked=""/><div class="controls bullet"><span class="by">dgrunwald</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164068">parent</a><span>|</span><a href="#41164856">next</a><span>|</span><label class="collapse" for="c-41164561">[-]</label><label class="expand" for="c-41164561">[2 more]</label></div><br/><div class="children"><div class="content">&gt; All noexcept does is catch any exception and immediately std::terminate.<p>While that&#x27;s a possible implementation; the standard is a bit more relaxed: `noexcept` may also call `std::terminate` immediately when an exception is thrown, without calling destructors in the usual way a catch block would do.<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;YTe84M5vq" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;YTe84M5vq</a>
test1 has a ~S() destructor call if maybe_throw() throws; test2 never calls ~S().<p>MSVC does not appear to support this optimization, so using `noexcept` with MSVC involves overhead similar to the catch-block.</div><br/><div id="41165686" class="c"><input type="checkbox" id="c-41165686" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164561">parent</a><span>|</span><a href="#41164856">next</a><span>|</span><label class="collapse" for="c-41165686">[-]</label><label class="expand" for="c-41165686">[1 more]</label></div><br/><div class="children"><div class="content">More than an optimization is a different exception handling philosophy.<p>AFAIK itanium ABI exception handling requires two phase unwinding: first the stack is traversed looking for a valid landing pad: if it succeeds then the stack is traversed again calling all destructors. If it fails it calls std terminate. This is actually slower as it need to traverse twice, but the big advantage is that if the program would abort, the state of the program is preserved in the core file. This is easily generalized with noexcept functions: no unwind info is generated for those, so unwind always fail.<p>MSVC used to do one pass unwind, but I thought they changed it when they implemented table based unwind for x64.</div><br/></div></div></div></div><div id="41164856" class="c"><input type="checkbox" id="c-41164856" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164068">parent</a><span>|</span><a href="#41164561">prev</a><span>|</span><a href="#41164291">next</a><span>|</span><label class="collapse" for="c-41164856">[-]</label><label class="expand" for="c-41164856">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All noexcept does is catch any exception and immediately std::terminate.<p>I don&#x27;t think this is a decent interpretation of what no except does. It misses the whole point of this feature, and confuses a failsafe with the point of using it.<p>The whole point of noexcept is to tell the compiler that the function does not throw exceptions. This allows the compiler to apply optimizations, such as not needing to track down the necessary info to unwind the call stack when an exception is thrown. Some containers are also designed to only invoke move constructors if they are noexcept and otherwise will copy values around.<p>As the compiler omits the info required to recover from exceptions, if one is indeed thrown and bubbles up to the noexcept function then it&#x27;s not possible to do the necessary janitorial work. Therefore, std::terminate is called instead.</div><br/></div></div><div id="41164291" class="c"><input type="checkbox" id="c-41164291" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164068">parent</a><span>|</span><a href="#41164856">prev</a><span>|</span><a href="#41164053">next</a><span>|</span><label class="collapse" for="c-41164291">[-]</label><label class="expand" for="c-41164291">[5 more]</label></div><br/><div class="children"><div class="content">Oh, so it&#x27;s like Rust&#x27;s panic=abort</div><br/><div id="41164434" class="c"><input type="checkbox" id="c-41164434" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164291">parent</a><span>|</span><a href="#41164053">next</a><span>|</span><label class="collapse" for="c-41164434">[-]</label><label class="expand" for="c-41164434">[4 more]</label></div><br/><div class="children"><div class="content">Panic=abort is more like -fno-exceptions since it applies to all the code being compiled and not just function. Codegen can also take advantage of the fact that it won&#x27;t have to unwind.<p>I don&#x27;t think there is a rust equivalent of noexcept.</div><br/><div id="41164570" class="c"><input type="checkbox" id="c-41164570" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164434">parent</a><span>|</span><a href="#41164053">next</a><span>|</span><label class="collapse" for="c-41164570">[-]</label><label class="expand" for="c-41164570">[3 more]</label></div><br/><div class="children"><div class="content">Does C++ std::terminate unwind the stack and call destructors? Then noexcept would be pretty close to regular Rust panics, wouldn&#x27;t it?<p>Basically an unrecoverable exception?</div><br/><div id="41165263" class="c"><input type="checkbox" id="c-41165263" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164570">parent</a><span>|</span><a href="#41167430">next</a><span>|</span><label class="collapse" for="c-41165263">[-]</label><label class="expand" for="c-41165263">[1 more]</label></div><br/><div class="children"><div class="content">The behavior of `-fno-exceptions` isn&#x27;t standardized, because it&#x27;s a compiler feature, not a part of the C++ standard.  The standard says:<p>&gt; In the situation where no matching [exception] handler is found, it is implementation-defined whether or not the stack is unwound before std::terminate is invoked. In the situation where the search for a handler encounters the outermost block of a function with a non-throwing exception specification, it is implementation-defined whether the stack is unwound, unwound partially, or not unwound at all before the function std::terminate is invoked.<p>So, the whole thing is basically implementation-defined (including `-fno-exceptions`, since that is something that implementing compilers provide).</div><br/></div></div><div id="41167430" class="c"><input type="checkbox" id="c-41167430" checked=""/><div class="controls bullet"><span class="by">g15jv2dp</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164570">parent</a><span>|</span><a href="#41165263">prev</a><span>|</span><a href="#41164053">next</a><span>|</span><label class="collapse" for="c-41167430">[-]</label><label class="expand" for="c-41167430">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does C++ std::terminate unwind the stack and call destructors?<p>No, it doesn&#x27;t. Try this: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;cvG17cYEs" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;cvG17cYEs</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41164053" class="c"><input type="checkbox" id="c-41164053" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#41163981">parent</a><span>|</span><a href="#41164068">prev</a><span>|</span><a href="#41164385">next</a><span>|</span><label class="collapse" for="c-41164053">[-]</label><label class="expand" for="c-41164053">[7 more]</label></div><br/><div class="children"><div class="content">The compiler can tell about the immediate function, but not any functions it calls.<p>If a function marked noexcept calls a function that throws an exception, then the program is terminated with an uncaught exception. A called function can throw through a non-noexcept function to a higher-level exception handler no problem.<p>So in order to avoid changing the semantics of the function, the compiler would have to be able to determine that that transitive closure of called functions dynamically don&#x27;t throw, and that problem is undecidable, even assuming the requirement that &quot;the compiler can see the source of all those functions&quot; is somehow met, which it won&#x27;t be.</div><br/><div id="41167122" class="c"><input type="checkbox" id="c-41167122" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164053">parent</a><span>|</span><a href="#41164385">next</a><span>|</span><label class="collapse" for="c-41167122">[-]</label><label class="expand" for="c-41167122">[6 more]</label></div><br/><div class="children"><div class="content">No, we compile in bottom up order, starting with leaf functions, and collecting information about functions as we go. So &quot;not throwing&quot; sort of trickles up when possible to a certain degree.<p>In LTCG (MSVC)&#x2F;O3 (GCC&#x2F;Clang) there are prepasses over the entire callgraph to collect this order</div><br/><div id="41167439" class="c"><input type="checkbox" id="c-41167439" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41167122">parent</a><span>|</span><a href="#41167379">prev</a><span>|</span><a href="#41167305">next</a><span>|</span><label class="collapse" for="c-41167439">[-]</label><label class="expand" for="c-41167439">[1 more]</label></div><br/><div class="children"><div class="content">Yes of course. Sometimes the compiler can tell. But the original question feels to me more like âShouldn&#x27;t the compiler deduce restrict for you?â</div><br/></div></div></div></div></div></div><div id="41164385" class="c"><input type="checkbox" id="c-41164385" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#41163981">parent</a><span>|</span><a href="#41164053">prev</a><span>|</span><a href="#41167111">next</a><span>|</span><label class="collapse" for="c-41164385">[-]</label><label class="expand" for="c-41164385">[3 more]</label></div><br/><div class="children"><div class="content">No, it can&#x27;t do that. My speculation is that likely it is so because in general case this might be a NP hard problem similar to the halting problem <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Halting_problem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Halting_problem</a>.<p>The best it can do is to say whether a given function is qualified with `noexcept` (see noexcept() operator <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;noexcept" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;noexcept</a>)</div><br/><div id="41167315" class="c"><input type="checkbox" id="c-41167315" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41164385">parent</a><span>|</span><a href="#41167111">next</a><span>|</span><label class="collapse" for="c-41167315">[-]</label><label class="expand" for="c-41167315">[2 more]</label></div><br/><div class="children"><div class="content">Dude I am going to blow your mind</div><br/><div id="41168478" class="c"><input type="checkbox" id="c-41168478" checked=""/><div class="controls bullet"><span class="by">Arech</span><span>|</span><a href="#41163981">root</a><span>|</span><a href="#41167315">parent</a><span>|</span><a href="#41167111">next</a><span>|</span><label class="collapse" for="c-41168478">[-]</label><label class="expand" for="c-41168478">[1 more]</label></div><br/><div class="children"><div class="content">Eeeermm... I haven&#x27;t heard an explosion, but 4+ hours has passed. Are you alive there, dude?<p>Jokes aside - I&#x27;m always happy to be corrected, so please go on if I made a mistake somewhere.</div><br/></div></div></div></div></div></div><div id="41167111" class="c"><input type="checkbox" id="c-41167111" checked=""/><div class="controls bullet"><span class="by">terrymah</span><span>|</span><a href="#41163981">parent</a><span>|</span><a href="#41164385">prev</a><span>|</span><a href="#41163997">next</a><span>|</span><label class="collapse" for="c-41167111">[-]</label><label class="expand" for="c-41167111">[1 more]</label></div><br/><div class="children"><div class="content">It absolutely does, and even better, the compiler deduced &quot;this function doesn&#x27;t throw&quot; doesn&#x27;t come with the overhead of implementing noexcept proper</div><br/></div></div><div id="41163997" class="c"><input type="checkbox" id="c-41163997" checked=""/><div class="controls bullet"><span class="by">Eyas</span><span>|</span><a href="#41163981">parent</a><span>|</span><a href="#41167111">prev</a><span>|</span><a href="#41164601">next</a><span>|</span><label class="collapse" for="c-41163997">[-]</label><label class="expand" for="c-41163997">[1 more]</label></div><br/><div class="children"><div class="content">It probably can in a .cc file but if you&#x27;re importing another library and just have access to the header, it wouldn&#x27;t know how to.</div><br/></div></div><div id="41164601" class="c"><input type="checkbox" id="c-41164601" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41163981">parent</a><span>|</span><a href="#41163997">prev</a><span>|</span><a href="#41167375">next</a><span>|</span><label class="collapse" for="c-41164601">[-]</label><label class="expand" for="c-41164601">[1 more]</label></div><br/><div class="children"><div class="content">A lot of people have answered no, which is likely the correct answer to what you&#x27;re asking, but I wanted to be clear about exactly what that is?<p>Take a hypothetical piece of code<p>some_library_header.h:<p><pre><code>    void library_function();
</code></pre>
some_project_header_1.h:<p><pre><code>    void project_function1();
</code></pre>
some_project_header_2.h:<p><pre><code>    void project_function2();

</code></pre>
some_project_file.cpp:<p><pre><code>    void project_function2() {
        &#x2F;* definition *&#x2F;
        &#x2F;&#x2F; no exception
    }

    void test_function1() {
        library_function();
    }

    void test_function2() {
        project_function1();
    }

    void test_function3() {
        project_function2();
    }

</code></pre>
For your question, where are you wanting to know if the compiler can deduce noexcept?</div><br/></div></div></div></div><div id="41167375" class="c"><input type="checkbox" id="c-41167375" checked=""/><div class="controls bullet"><span class="by">tolmasky</span><span>|</span><a href="#41163981">prev</a><span>|</span><a href="#41164835">next</a><span>|</span><label class="collapse" for="c-41167375">[-]</label><label class="expand" for="c-41167375">[1 more]</label></div><br/><div class="children"><div class="content">Is there any compiler option to have it yell at you if you mark something that can throw as `noexcept`, which seems to be the cause of (at least some of) the slowdowns where the compiler is forced to accommodate with `std::terminate`? I feel like these situations are more commonly <i>mistakes</i>, and not the user wanting to &quot;collapse&quot; exceptions into terminations. So the current approach to dealing with these cases seems to be suboptimal not only from a performance perspective, but a behavior perspective as well.</div><br/></div></div><div id="41164835" class="c"><input type="checkbox" id="c-41164835" checked=""/><div class="controls bullet"><span class="by">olliej</span><span>|</span><a href="#41167375">prev</a><span>|</span><a href="#41165847">next</a><span>|</span><label class="collapse" for="c-41164835">[-]</label><label class="expand" for="c-41164835">[1 more]</label></div><br/><div class="children"><div class="content">I would like to have seen a comparison that actually includes -fno-exceptions, rather than just noexcept. My <i>assumption</i> is that to get a consistent gain from noexcept, you would need every function called to be explicitly noexcept, because a bunch of the cost of exceptions is code size and state required to support unwinding. So if the performance cost exception handling is causing is due to that, then if _anything_ can cause an exception (or I guess more accurately unless every opaque call is explicitly indicated to not cause an exception) then that overhead remains.<p>That said, I&#x27;m still confused by the perf results of the article, especially the perlin noise vs MSVC one. It&#x27;s sufficiently weird outlier that it makes me wonder if something in the compiler has a noexcept path that adds checks that aren&#x27;t usually on (i.e imagine the code has a &quot;debug&quot; mode that did bounds checks or something, but the function resolution you hit in the noexcept path always does the bounds check - I&#x27;m really not sure exactly how you&#x27;d get that to happen, but &quot;non-default path was not benchmarked&quot; is not exactly an uncommon occurrence)</div><br/></div></div><div id="41165847" class="c"><input type="checkbox" id="c-41165847" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#41164835">prev</a><span>|</span><label class="collapse" for="c-41165847">[-]</label><label class="expand" for="c-41165847">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of mysticism and superstition surrounding C++ exceptions. It&#x27;s instructive to sit down with godbolt and examine specific scenarios in which noexcept (or exceptions generally) can affect performance. Read the machine code. Understand <i>why</i> the compiler does what it does. Don&#x27;t want to invest at that level? You probably want to use a higher level language.</div><br/><div id="41166819" class="c"><input type="checkbox" id="c-41166819" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41165847">parent</a><span>|</span><a href="#41166542">next</a><span>|</span><label class="collapse" for="c-41166819">[-]</label><label class="expand" for="c-41166819">[2 more]</label></div><br/><div class="children"><div class="content">You won&#x27;t get a sense of how bad exceptions can be by using Godbolt. A lot of the magic of exceptions is handled behind the scenes by the compiler and&#x2F;or the Itanium ABI. For example one disasterous consequence of using exceptions in GCC is that there is a global application wide lock used to manage stack unwinding.<p>This means that only one single thread can unwind a stack at a time and the lock is held from the start of the exception being thrown until the very last destructor is called. If you have a multicore server with 100 threads, and one of those threads throws an exception, you better hope that no other thread throws an exception because even if those two threads are entirely independent of one another, one of them will block.<p>You won&#x27;t see this by looking at Godbolt.</div><br/><div id="41167994" class="c"><input type="checkbox" id="c-41167994" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#41165847">root</a><span>|</span><a href="#41166819">parent</a><span>|</span><a href="#41166542">next</a><span>|</span><label class="collapse" for="c-41167994">[-]</label><label class="expand" for="c-41167994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example one disasterous consequence of using exceptions in GCC is that there is a global application wide lock used to manage stack unwinding.<p>This might have been (partially?) fixed? GCC Bug 71744 &quot;Concurrently throwing exceptions is not scalable&quot; is marked &quot;RESOLVED FIXED&quot; [0], and commit 6e80a1d164d1 in particular looks interesting:<p>&gt; eliminate mutex in fast path of __register_frame
&gt; 
&gt; &lt;snip&gt;
&gt; 
&gt; This commit eliminates both the mutex and the sorted list from the atomic fast path, and replaces it with a btree that uses optimistic lock coupling during lookup. This allows for fully parallel unwinding and is essential to scale exception handling to large core counts.<p>I&#x27;m not particularly familiar with the unwinding machinery though so I don&#x27;t know if the issue is fully resolved.<p>[0]: <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=71744" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=71744</a></div><br/></div></div></div></div><div id="41166542" class="c"><input type="checkbox" id="c-41166542" checked=""/><div class="controls bullet"><span class="by">r2vcap</span><span>|</span><a href="#41165847">parent</a><span>|</span><a href="#41166819">prev</a><span>|</span><label class="collapse" for="c-41166542">[-]</label><label class="expand" for="c-41166542">[1 more]</label></div><br/><div class="children"><div class="content">Or set the compiler flag -fno-exceptions and ban the use of exceptions. While it isnât standard-compliant, a surprisingly large number of companies and projects follow these practices.</div><br/></div></div></div></div></div></div></div></div></div></body></html>