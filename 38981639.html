<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705222856642" as="style"/><link rel="stylesheet" href="styles.css?v=1705222856642"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/razetime/ngn-k-tutorial/blob/main/12-thinking-in-k.md">Thinking in an array language</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>tosh</span> | <span>110 comments</span></div><br/><div><div id="38982988" class="c"><input type="checkbox" id="c-38982988" checked=""/><div class="controls bullet"><span class="by">gcanyon</span><span>|</span><a href="#38982944">next</a><span>|</span><label class="collapse" for="c-38982988">[-]</label><label class="expand" for="c-38982988">[27 more]</label></div><br/><div class="children"><div class="content">Several people here are questioning the utility and&#x2F;or the comprehensibility of this. I&#x27;m no expert on array languages -- I&#x27;ve played with J and solved maybe a few dozen project Euler problems with it, but here&#x27;s my take:<p><pre><code>   1. Array languages aren&#x27;t well suited to *every* problem.
   2. They *are* ridiculously capable for many types of problem.
   3. The people using array languages are generally insanely smart.
   4. Learning how array languages work is a steep challenge. As shown in the linked article, it&#x27;s possible to write &quot;procedural&quot; code in an array language, and that is a Very Bad Thing. It&#x27;s like using a screwdriver as a hammer.
   5. In particular, understanding how tacit programming works is an awesome mind-expander
   6. Likewise when you internalize verb trains
   7. Likewise when you realize how array-based languages handle *any* dimension array.
   8. Likewise when you comprehend how &quot;under&quot; works
   9. Likewise when you understand how function exponents work
</code></pre>
There are many other awesome aspects of array languages; the above are just a few.</div><br/><div id="38984590" class="c"><input type="checkbox" id="c-38984590" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38986583">next</a><span>|</span><label class="collapse" for="c-38984590">[-]</label><label class="expand" for="c-38984590">[9 more]</label></div><br/><div class="children"><div class="content">Tacit programming is not unique to array languages, many FP and FP-like languages support it.  Generally array programming languages will be a bit terser if you&#x27;re working in problem domains that are idiomatic for the language, but FP languages can be more general and extensible.  The &quot;people using these languages are so smart&quot; attitude is often criticized as it can devolve into gatekeeping, but at least FP communities make somewhat of an attempt to be friendly to outsiders.</div><br/><div id="38984667" class="c"><input type="checkbox" id="c-38984667" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38984590">parent</a><span>|</span><a href="#38985125">next</a><span>|</span><label class="collapse" for="c-38984667">[-]</label><label class="expand" for="c-38984667">[1 more]</label></div><br/><div class="children"><div class="content">Complain about the language or documentation, but array language <i>communities</i> are absolutely friendly to outsiders! This tutorial lists some active forums, give them a try: <a href="https:&#x2F;&#x2F;github.com&#x2F;razetime&#x2F;ngn-k-tutorial&#x2F;tree&#x2F;main?tab=readme-ov-file#how-to-use-this-tutorial">https:&#x2F;&#x2F;github.com&#x2F;razetime&#x2F;ngn-k-tutorial&#x2F;tree&#x2F;main?tab=rea...</a><p>Also, have to shout out the APL Orchard, where Adám will give any visitor a personal tutorial: <a href="https:&#x2F;&#x2F;chat.stackexchange.com&#x2F;rooms&#x2F;52405&#x2F;the-apl-orchard" rel="nofollow">https:&#x2F;&#x2F;chat.stackexchange.com&#x2F;rooms&#x2F;52405&#x2F;the-apl-orchard</a></div><br/></div></div><div id="38985125" class="c"><input type="checkbox" id="c-38985125" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38984590">parent</a><span>|</span><a href="#38984667">prev</a><span>|</span><a href="#38984651">next</a><span>|</span><label class="collapse" for="c-38985125">[-]</label><label class="expand" for="c-38985125">[6 more]</label></div><br/><div class="children"><div class="content">Are there any type systems that work well for the array programming problem domain? Not the kind of ‘everything is an operator’ syntactic sugar, to be clear. More things like supporting the kind of general operators you see in array languages while also expressing the constraints on dimensions, eg for matrix multiplication you need the number of columns on the left to match the number of rows on the right. But the thing written at the end of this post presumably also does things on arrays of higher rank too…</div><br/><div id="38986074" class="c"><input type="checkbox" id="c-38986074" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38985125">parent</a><span>|</span><a href="#38988043">next</a><span>|</span><label class="collapse" for="c-38986074">[-]</label><label class="expand" for="c-38986074">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a fundamental opposition between the functional programming approach to types and array programming principles, as I see it. In functional programming (particularly Haskell), types are used to make fine distinctions for safety. Even if an existing type would work for something, it&#x27;s often recommended to make a new one so two different use cases don&#x27;t get mixed up. But the APL family works to make as few type distinctions as possible: everything is an array, booleans are numbers, and some k features are to unify multi-dimensional arrays with nested ones and sort-of-unify (it&#x27;s complicated) functions, dicts, and arrays.<p>The reason to do this is that it allows one function to do more things. As you guessed, the matmul function from the tutorial works if the right argument has rank 1 or more, which means it also does matrix-vector products. Less code is another form of safety, the theory goes. And handling more things with the same function also lets you draw higher-level connections.<p>Of course you can type the arrays anyway. Remora is one attempt. To me it feels like just a technical exercise and I think this question calls for more high-level investigation of what exactly the goals are before jumping into PL theory details.<p>EDIT: Tali Beynon&#x27;s rainbow arrays don&#x27;t have all the answers, but I think they&#x27;re a good example of the sort of investigation I mean: <a href="https:&#x2F;&#x2F;math.tali.link&#x2F;classical-array-algebra&#x2F;" rel="nofollow">https:&#x2F;&#x2F;math.tali.link&#x2F;classical-array-algebra&#x2F;</a></div><br/></div></div><div id="38988043" class="c"><input type="checkbox" id="c-38988043" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38985125">parent</a><span>|</span><a href="#38986074">prev</a><span>|</span><a href="#38985174">next</a><span>|</span><label class="collapse" for="c-38988043">[-]</label><label class="expand" for="c-38988043">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Are there any type systems that work well for the array programming problem domain?<p>Do a search for &quot;haskell strongly typed tensor programming.&quot;</div><br/><div id="38988537" class="c"><input type="checkbox" id="c-38988537" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38988043">parent</a><span>|</span><a href="#38985174">next</a><span>|</span><label class="collapse" for="c-38988537">[-]</label><label class="expand" for="c-38988537">[1 more]</label></div><br/><div class="children"><div class="content">Or just look at Orthotope: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;orthotope" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;orthotope</a><p>&quot;Multidimensional arrays inspired by APL&quot;</div><br/></div></div></div></div><div id="38985174" class="c"><input type="checkbox" id="c-38985174" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38985125">parent</a><span>|</span><a href="#38988043">prev</a><span>|</span><a href="#38984651">next</a><span>|</span><label class="collapse" for="c-38985174">[-]</label><label class="expand" for="c-38985174">[2 more]</label></div><br/><div class="children"><div class="content">You basically need types that can depend on program constants (like the size of an array) and to be able to do compile-time computation on these constants.  These are emerging features of sorts, but languages like C++ and Rust support them. They&#x27;re also inherent to dependently-typed languages.  (Of course you can alternately pick array sizes at runtime, but then you&#x27;ll be dependent on a runtime check wrt. correctness.)</div><br/><div id="38985491" class="c"><input type="checkbox" id="c-38985491" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38985174">parent</a><span>|</span><a href="#38984651">next</a><span>|</span><label class="collapse" for="c-38985491">[-]</label><label class="expand" for="c-38985491">[1 more]</label></div><br/><div class="children"><div class="content">Surely most of the time you don’t need program constants? You could already implement a slow matrix multiplication that is well typed in a language like Haskell or OCaml. It would have a type something like:<p><pre><code>  val matmul : ((float,&#x27;a) fixed_length, &#x27;b) fixed_length -&gt; ((float,&#x27;c) fixed_length, &#x27;a) fixed_length -&gt; ((float,&#x27;c) fixed_length, &#x27;b) fixed_length
</code></pre>
(And observe the similarity to function composition too:<p><pre><code>  val compose : (&#x27;a -&gt; &#x27;b) -&gt; (&#x27;c -&gt; &#x27;a) -&gt; (&#x27;c -&gt; &#x27;b)
</code></pre>
.) This could work for dimensions that are unknown at runtime for Haskell or OCaml as their polymorphic functions can be implemented by a single machine code function where C++ templates &#x2F; Rust generics must monomorphize (generate different machine code functions for different types). You would probably want existential types (though OCaml and Haskell have them).<p>I think the problems are more things like:<p>- that type only works on matrices, you can’t so easily express that eg * in APL works on two scalars, or two vectors of the same length, or a matrix and a rank-3 array so long as their dimensions line up appropriately.<p>- handling operations that change lengths is hard: concat probably wants you to be able to unify through certain arithmetical expressions, and the filter operation (take an vector and a bitvector the same length, and produce the vector of elements where the bit was set) means you probably want a natural way to handle those kinds of existential types for lengths: you get a vector, and it has a length, but you’re not sure what it is.</div><br/></div></div></div></div></div></div><div id="38984651" class="c"><input type="checkbox" id="c-38984651" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38984590">parent</a><span>|</span><a href="#38985125">prev</a><span>|</span><a href="#38986583">next</a><span>|</span><label class="collapse" for="c-38984651">[-]</label><label class="expand" for="c-38984651">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I think array language communities are generally very friendly and helpful too. Not many programming languages&#x2F;companies employ people to help people in chatrooms.</div><br/></div></div></div></div><div id="38986583" class="c"><input type="checkbox" id="c-38986583" checked=""/><div class="controls bullet"><span class="by">anonu</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38984590">prev</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38986583">[-]</label><label class="expand" for="c-38986583">[9 more]</label></div><br/><div class="children"><div class="content">Learning array languages makes you a better programmer in any other language. The way you think changes. We are taught to approach a problem procedurally. Actually the for loop is your enemy.</div><br/><div id="38987226" class="c"><input type="checkbox" id="c-38987226" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38986583">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38987226">[-]</label><label class="expand" for="c-38987226">[8 more]</label></div><br/><div class="children"><div class="content">yeah, but why mess with K for that?<p>Grab python+numpy or matlab&#x2F;octave - it&#x27;s all the same stuff (likely inspired by K) but with readable syntax, bigger community and so on.</div><br/><div id="38987609" class="c"><input type="checkbox" id="c-38987609" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38987226">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38987609">[-]</label><label class="expand" for="c-38987609">[7 more]</label></div><br/><div class="children"><div class="content">If numpy&#x2F;matlab&#x2F;octave&#x2F;... was &#x27;all the same stuff&#x27; with none of the downsides and all of the benefits, why would k or array languages in general have such a passionate community? Either every arraylang-er is masochistic (only slightly true) or there&#x27;s more to it than you think.</div><br/><div id="38987695" class="c"><input type="checkbox" id="c-38987695" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38987609">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38987695">[-]</label><label class="expand" for="c-38987695">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a weird argument... passion is not always connected to efficiency&#x2F;practicality&#x2F;usefulness, in fact I feel that in a lot of cases it&#x27;s the opposite.<p>As a great example, look at old computers: they are pretty popular (there is one link on HN front page right now about N64!) and people are super passionate about it, and yet you would not recommend &quot;everyone to play at least one Nintendo 64 game&quot;.<p>For non-computer examples, somehow a number of my friends are extremely passionate about super hot (as in spicy) sauces. They bring a new bottle for every meal, and they can talk about the kinds of peppers for hours. It&#x27;s interesting to hear, but I would not want to try them myself, nor would I recommend this to everyone.</div><br/><div id="38987789" class="c"><input type="checkbox" id="c-38987789" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38987695">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38987789">[-]</label><label class="expand" for="c-38987789">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure people who are into retrocomputing or spicy food or any other topic could tell you why they prefer that to something more mainstream. Whether or not you would agree, you could recognise that they had different opinions. The issue I had with your comment was writing off k as simply an inferior version of numpy etc rather than trying to consider why people like it, and what it may even do better than the mainstream alternatives.</div><br/><div id="38987961" class="c"><input type="checkbox" id="c-38987961" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38987789">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38987961">[-]</label><label class="expand" for="c-38987961">[4 more]</label></div><br/><div class="children"><div class="content">well, the very first message in the thread said:<p>&gt; Learning array languages makes you a better programmer in any other language. The way you think changes. We are taught to approach a problem procedurally. Actually the for loop is your enemy.<p>I happen to strongly agree with most of this: learning array-based &quot;operations&quot;, writing the code where &quot;the for loop is your enemy&quot; is a very valuable experience, and if will make you a better programmer in any language. Everyone should try writing some code like this.<p>The problem is K is a mix of three things: array-based operations, point-free style &#x2F; tacit programming, and extreme brevity via punctuation abuse and lack of types. And not all of them are equally useful.<p>It&#x27;s like trying to introduce someone to Chinese cuisine and giving them the spiciest Hunan dish there is. Unless the person already happened to love spicy food, the chances they will just write-off the entire cuisine.<p>I bet there people today who associate &quot;array programming&quot; with obscure character soup of APL&#x2F;J&#x2F;K and ignore it because of that. Who knows, maybe if they knew that numpy&#x2F;octave offers the same thing in more palatable package, there would be more arrays and less &quot;for&quot; loops in the world.</div><br/><div id="38988038" class="c"><input type="checkbox" id="c-38988038" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38987961">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38988038">[-]</label><label class="expand" for="c-38988038">[3 more]</label></div><br/><div class="children"><div class="content">The original comment said learning &quot;array languages&quot;. There&#x27;s some debate about what that means, but generally it means APL&#x2F;J&#x2F;K&#x2F;etc not numpy&#x2F;matlab&#x2F;etc.<p>As far as I can tell (correct me if I&#x27;m wrong) you haven&#x27;t learned an array language, yet you&#x27;re telling someone who has (and anyone else who reads your message) not to bother.<p>To use your food analogy, this is like saying &quot;Don&#x27;t try real Chinese food in a restaurant, just cook some rice at home. Same thing.&quot;<p>It&#x27;s not the same thing. The flavour is completely different.</div><br/><div id="38988229" class="c"><input type="checkbox" id="c-38988229" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38988038">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38988229">[-]</label><label class="expand" for="c-38988229">[2 more]</label></div><br/><div class="children"><div class="content">What would you see as the big benefit of array <i>languages</i> over simply array-based programming in other languages? Or in other words, what sorts of things will I learn from trying out J or APL, that I wouldn&#x27;t learn by playing around with Numpy or Pandas?</div><br/><div id="38988375" class="c"><input type="checkbox" id="c-38988375" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38988229">parent</a><span>|</span><a href="#38984656">next</a><span>|</span><label class="collapse" for="c-38988375">[-]</label><label class="expand" for="c-38988375">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to think of concrete benefits on the spot when the biggest benefit is the somewhat nebulous &quot;feel&quot; of the language. But generally: array languages typically make use of composition of primitives rather than larger, more complicated built in functions. For example in k, there is no &#x27;sort&#x27; primitive. Instead of sort, you have grade (&lt;). In APL this is ⍋. In numpy this is np.argsort<p>This means to sort an array you do x@&lt;x, where @ is apply (indexing - for more info on k&#x27;s indexing read <a href="https:&#x2F;&#x2F;beyondloom.com&#x2F;blog&#x2F;slicedice.html" rel="nofollow">https:&#x2F;&#x2F;beyondloom.com&#x2F;blog&#x2F;slicedice.html</a>)<p>At first this is a bit counterintuitive. But then you realise, x@&lt;x is sort. y@&lt;x is sort by. &lt;&lt;x is &#x27;rank&#x27;. There are all these &#x27;recipes&#x27; that are based on &lt;, and some of them you may not discover using numpy, as there would be another function that did it for you. You don&#x27;t typically solve things by composing simple elements, as that would be far too verbose, instead using complicated built in functions, often with many parameters to describe the desired behaviour.<p>I&#x27;m sure other people will have other opinions on what the benefits are, but that was just one example off the top of my head.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38984656" class="c"><input type="checkbox" id="c-38984656" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38986583">prev</a><span>|</span><a href="#38986846">next</a><span>|</span><label class="collapse" for="c-38984656">[-]</label><label class="expand" for="c-38984656">[1 more]</label></div><br/><div class="children"><div class="content">&gt; function exponents<p>Including negative exponents, namely automated computation of the inverse function!</div><br/></div></div><div id="38986846" class="c"><input type="checkbox" id="c-38986846" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38984656">prev</a><span>|</span><a href="#38985765">next</a><span>|</span><label class="collapse" for="c-38986846">[-]</label><label class="expand" for="c-38986846">[1 more]</label></div><br/><div class="children"><div class="content">&gt;7. Likewise when you realize how array-based languages handle <i>any</i> dimension array.<p>Deserves to be ranked higher, especially for the &quot;blub&quot; programmer.   With specific examples.  I not-so-recently saw an implentation of euler&#x27;s method that replaced the ODE solvers of MATLAB for pegagogical reasons.  I return to it when I want to think about generalizing in that way.</div><br/></div></div><div id="38985765" class="c"><input type="checkbox" id="c-38985765" checked=""/><div class="controls bullet"><span class="by">leephillips</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38986846">prev</a><span>|</span><a href="#38985831">next</a><span>|</span><label class="collapse" for="c-38985765">[-]</label><label class="expand" for="c-38985765">[1 more]</label></div><br/><div class="children"><div class="content">My first (and only) programming course (1976) in college used APL. It was populated by normal undergraduates, most of them in humanities fields. It was fine. You don’t have to be a super genius, but a lack of exposure to boring languages may be an advantage.  I still love APL.</div><br/></div></div><div id="38986520" class="c"><input type="checkbox" id="c-38986520" checked=""/><div class="controls bullet"><span class="by">Bostonian</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38985831">prev</a><span>|</span><a href="#38985879">next</a><span>|</span><label class="collapse" for="c-38986520">[-]</label><label class="expand" for="c-38986520">[1 more]</label></div><br/><div class="children"><div class="content">Regarding #4, an advantage of Modern Fortran is that you have array operations <i>and</i> the ability to write procedural code with loops without a speed penalty if the problem cannot be easily decomposed into array operations.</div><br/></div></div><div id="38985879" class="c"><input type="checkbox" id="c-38985879" checked=""/><div class="controls bullet"><span class="by">WhitneyLand</span><span>|</span><a href="#38982988">parent</a><span>|</span><a href="#38986520">prev</a><span>|</span><a href="#38982944">next</a><span>|</span><label class="collapse" for="c-38985879">[-]</label><label class="expand" for="c-38985879">[3 more]</label></div><br/><div class="children"><div class="content">These arguments could use a little more precision&#x2F;evidence and some concrete examples.<p>&gt;<i>1. Array languages aren&#x27;t well suited to every problem.</i><p>No language is suited to every problem?<p>&gt;<i>2. They are ridiculously capable for many types of problem.</i><p>Irrelevant? It only matters if it is more capable than other languages.<p>&gt;<i>3. The people using array languages are generally insanely smart.</i><p>Folklore. Impossible to quantify. Most of all, there are really smart people using all languages.<p>&gt;<i>4. Learning how array languages work is a steep challenge.</i><p>This is not persuasive.<p>&gt;<i>5. It’s awesomely mind expanding.</i><p>Like philosophy and psychedelics?  People care about GTD.<p>Seriously, I’m listening. What’s the real competitive, objective, case for k?</div><br/><div id="38986087" class="c"><input type="checkbox" id="c-38986087" checked=""/><div class="controls bullet"><span class="by">stealthcat</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38985879">parent</a><span>|</span><a href="#38982944">next</a><span>|</span><label class="collapse" for="c-38986087">[-]</label><label class="expand" for="c-38986087">[2 more]</label></div><br/><div class="children"><div class="content">How do you trust numbers to “quantify extremely smart people”?<p>Interviewers know to hire&#x2F;no-hire within first 10 minutes of talking to candidates.<p>Similarly, the best LLMs nowadays are probed only with some prompts.<p>Just last time I see LLM midwit meme on quantifying best scores on all benchmarks vs idiots&#x2F;geniuses who just prompt something for some while.<p>Do not try to put numbers on everything.</div><br/><div id="38986159" class="c"><input type="checkbox" id="c-38986159" checked=""/><div class="controls bullet"><span class="by">WhitneyLand</span><span>|</span><a href="#38982988">root</a><span>|</span><a href="#38986087">parent</a><span>|</span><a href="#38982944">next</a><span>|</span><label class="collapse" for="c-38986159">[-]</label><label class="expand" for="c-38986159">[1 more]</label></div><br/><div class="children"><div class="content">I’m not sure we’re disagreeing…<p>I said it was impossible to quantify, not that it should be quantified.<p>In general I just don’t think it’s a reason to decide on a programming language.</div><br/></div></div></div></div></div></div></div></div><div id="38982944" class="c"><input type="checkbox" id="c-38982944" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#38982988">prev</a><span>|</span><a href="#38987885">next</a><span>|</span><label class="collapse" for="c-38982944">[-]</label><label class="expand" for="c-38982944">[17 more]</label></div><br/><div class="children"><div class="content">Nothing has ever convinced me about the potential for array languages in practice quite like watching Aaron Hsu describe how he develops his parallel APL compiler [0] using two Notepad.exe windows side-by-side: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=gcUWTa16Jc0&amp;t=860s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=gcUWTa16Jc0&amp;t=860s</a><p>He has also written many comments (arcfide on HN) about this stuff before, e.g. discussing &quot;semantic density&quot; [1]<p>&gt; The compiler is designed so that I can see as much as possible with as little indirection as possible, so that when I see a piece of code I not only know how it works in complete detail, but how it connects to the world around it, and every single dependency related to it in basically one single half screen full of code (usually much less than that) without any jumps, paging, scrolling or any movement. [...] The idea of semantic density is critical to this point. The semantic density of the APL code I&#x27;m using to solve the problem is at a certain rate. I maintain a consistent density rate by choosing my variable names in such a way that they visually align with the expressivity per character of the built in primitive symbols.<p>And<p>&gt; [...] idiomatic programming methods that are so concise, they can begin to be read as we read and chunk English phrases. By doing so, it becomes actually easier to just write out most algorithms, because the normal name for such an algorithm is basically as long as the algorithm itself written out. This means that I start to learn to chunk idioms as phrases and can read code directly, without the cost of name lookup indirection. I can get away with this because I&#x27;ve made reusability and abstraction less important (vastly so) because I can literally see every use case of every idiom on the screen at the same time. It literally would take more time to write the reusable abstraction than it would to just replace the idiomatic code in every place.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;Co-dfns&#x2F;Co-dfns">https:&#x2F;&#x2F;github.com&#x2F;Co-dfns&#x2F;Co-dfns</a><p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13571159">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=13571159</a></div><br/><div id="38983500" class="c"><input type="checkbox" id="c-38983500" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#38982944">parent</a><span>|</span><a href="#38983437">next</a><span>|</span><label class="collapse" for="c-38983500">[-]</label><label class="expand" for="c-38983500">[5 more]</label></div><br/><div class="children"><div class="content">This is like walking into someone&#x27;s office that&#x27;s completely overwhelmed with mess, boxes and binders to the ceiling, but they swear to you they know where absolutely everything is. They don&#x27;t, and certainly nobody else has any chance of ever finding anything. Except in this case he&#x27;s publishing videos and articles about how superior his personal method of just being intimately familiar with his own Giant Mess is.<p>That is not good code, sorry. His average variable name length is about 2.5. He can&#x27;t &quot;literally see every use case of every idiom&quot;. He&#x27;s fooling himself, seemingly convinced by his own brilliance. He:<p>- Brags about using Notepad instead of the fancy IDEs that us weak-minded plebians use<p>- Brags about how easily he understands his giant ball of overly messy code (2- letter variables in the name of &quot;semantic density&quot;)<p>- Uses an obscure (in the modern era) outdated language like some Cinema aficionado who refuses to watch movies in color like all those plebians<p>- Publishes articles in journals that everyone else in our industry would just write as blog posts<p>- Brags about how he can understand <i>his own code</i>. We can all understand our own code. Good code is understandable by <i>others</i>.<p>Any one of these alone wouldn&#x27;t be that weird, but taken together it sure seems like he&#x27;s optimizing for self-promotion and feeling infinitely superior to all us mere mortal programmers.</div><br/><div id="38983794" class="c"><input type="checkbox" id="c-38983794" checked=""/><div class="controls bullet"><span class="by">refset</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983500">parent</a><span>|</span><a href="#38984376">next</a><span>|</span><label class="collapse" for="c-38983794">[-]</label><label class="expand" for="c-38983794">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m far from an expert on such things, but Co-dfns appears to be genuinely cutting edge research that could have utility for many language ecosystems (or do you disagree that this direction of GPU-based compilation holds promise?). If that work has to look like a &quot;mess&quot; to non-APLers in order to get done then so be it.</div><br/><div id="38984808" class="c"><input type="checkbox" id="c-38984808" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983794">parent</a><span>|</span><a href="#38984376">next</a><span>|</span><label class="collapse" for="c-38984808">[-]</label><label class="expand" for="c-38984808">[1 more]</label></div><br/><div class="children"><div class="content">I criticized the approach some in [0], after writing the BQN compiler in a similar style. Pioneering the array-based compiler paradigm is a major accomplishment, and if you did any programming with Aaron, you wouldn&#x27;t question his ability. The Pareas compiler demonstrates that an APL-like language isn&#x27;t required to do it though. And while the research may be applicable to other problems, I have serious doubts that it will be useful for speeding up optimizing compilers, which spend time on very different things than simple ones. Also possibly worth mentioning that Co-dfns still doesn&#x27;t self-host, which I believe means it can&#x27;t run on the GPU. I&#x27;m still unclear on what GPU program was timed in his thesis, a hand-translated version?<p>[0] <a href="https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;codfns.html#is-it-a-good-idea" rel="nofollow">https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;codfns.html#i...</a></div><br/></div></div></div></div><div id="38984376" class="c"><input type="checkbox" id="c-38984376" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983500">parent</a><span>|</span><a href="#38983794">prev</a><span>|</span><a href="#38983437">next</a><span>|</span><label class="collapse" for="c-38984376">[-]</label><label class="expand" for="c-38984376">[2 more]</label></div><br/><div class="children"><div class="content">From memory (not very reliable but I&#x27;m not going to rewatch hours of video to find sources), Aaron said that when he asked around about working on a nano-pass compiler as a PhD thesis, nobody would take him seriously because it was believed to be impossible to do in a performant way. And he has done it, with this style of code. An world first. And it worked out orders of magnitude faster and less memory and less code than a comparable compiler written in Scheme (which Aaron is pretty good with - he used to be involved in the Scheme R5RS and R6RS standards committees).<p>He&#x27;s also built the world&#x27;s first APL compiler which runs on a GPU and outputs GPU code.<p>&gt; - Brags about using Notepad instead of the fancy IDEs that us weak-minded plebians use<p>One of his points is that he&#x27;s convinced programming as an industry went wrong by sidelining array languages, and we shouldn&#x27;t need to be writing so much code to get things done. It&#x27;s not so much bragging about using Notepad, as making a point that a) Notepad is enough for a complex piece of code, b) IDEs can&#x27;t help much with tacit array code because there isn&#x27;t tons of boilerplate to autocomplete, and c) concentrating on the code is easier without a lot of distractions.<p>&gt; - Brags about how he can understand his own code. We can all understand our own code. Good code is understandable by others.<p>Another one of his points is that people who have not learned traditional programming find array-based programming much easier to pick up. And that&#x27;s aside from the usual discussions here where you&#x27;re basically saying &quot;Brags about understanding Chinese. We can all understand our own native language, <i>Good writing</i> is written in English&quot;. Other people have contributed pull requests to co-dfns (apparently).<p>&gt; - Brags about how easily he understands his giant ball of overly messy code<p>Given your previous criticism is that it&#x27;s &quot;not understandable&quot;, emphasising how it not only is understandable it&#x27;s quite easy to understand, seems like a reasonable rebuttal for him to make. Apparently he&#x27;s damned if he does, and damned if he doesn&#x27;t.<p>&gt; - (2- letter variables in the name of &quot;semantic density&quot;)<p>That is the array style; his compiler is tacit (no variables) as much as he can make it, which means the few variables which are left are much easier to keep track of in memory. Regardless of that, there&#x27;s a big gap between languages where people write &#x27;k[i]=m[j]<i>u</i>v&#x27; and languages where people write &#x27;pyramidPointVector[pyramidPointVectorOffset]=adjustedShadowMaskBools[rowAlignmentCounter]...&#x27; or whatever.<p>&gt; - Uses an obscure (in the modern era) outdated language like some Cinema aficionado who refuses to watch movies in color like all those plebians<p>But also like someone who uses any highly specific tool for experts instead of the standard thing an ordinary person might find at Walmart.</div><br/><div id="38984768" class="c"><input type="checkbox" id="c-38984768" checked=""/><div class="controls bullet"><span class="by">fifilura</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38984376">parent</a><span>|</span><a href="#38983437">next</a><span>|</span><label class="collapse" for="c-38984768">[-]</label><label class="expand" for="c-38984768">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Another one of his points is that people who have not learned traditional programming find array-based programming much easier to pick up.<p>I have had the same experience when teaching SQL.<p>I feel like it is difficult for people who have worked with imperative languages to grasp, while people who come from the Excel school (e.g. business people or researchers) actually enjoy it and may even pick it up faster.<p>I believe SQL and array languages have this and probably much more in common. I am probably out of my league here, but I think I&#x27;d call SQL a set language rather than array language. But feels like they are related.</div><br/></div></div></div></div></div></div><div id="38983437" class="c"><input type="checkbox" id="c-38983437" checked=""/><div class="controls bullet"><span class="by">baseball_coach</span><span>|</span><a href="#38982944">parent</a><span>|</span><a href="#38983500">prev</a><span>|</span><a href="#38987885">next</a><span>|</span><label class="collapse" for="c-38983437">[-]</label><label class="expand" for="c-38983437">[11 more]</label></div><br/><div class="children"><div class="content">They have to write the crazy paragraphs because the code is ugly to look at, so  they have to spend 18 hours convincing someone to use it. They could choose symbols that don&#x27;t look so ugly next to each other, then they would not have to spend as much time convincing people the language does not suck.</div><br/><div id="38984473" class="c"><input type="checkbox" id="c-38984473" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983437">parent</a><span>|</span><a href="#38984449">next</a><span>|</span><label class="collapse" for="c-38984473">[-]</label><label class="expand" for="c-38984473">[1 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;d rather have a half page of APL with a page of explanations (given a little time to learn the language better than I do now) than 20 pages of Java that I have to scroll through with comments and unintelligible class paths.<p>Either way it takes time to consume the logic, but it&#x27;s nice to have it all in one place than scattered about all over creation. I think that&#x27;s what he&#x27;s getting at with Aaron&#x27;s more macro based view. He wrote thousands and thousands of loc before being able to whittle it down to such a terse amount. I can&#x27;t read it, but that&#x27;s less to do with APL and a lot more to do with knowing nothing of the domain of compilers.<p>The symbols actually make a lot of sense and can help you remember what they do. I can remember quite a few after only playing around with it a bit and reading a book on it ages ago.</div><br/></div></div><div id="38984449" class="c"><input type="checkbox" id="c-38984449" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983437">parent</a><span>|</span><a href="#38984473">prev</a><span>|</span><a href="#38986038">next</a><span>|</span><label class="collapse" for="c-38984449">[-]</label><label class="expand" for="c-38984449">[5 more]</label></div><br/><div class="children"><div class="content">Your criticism amounts to &quot;if it isn&#x27;t pretty, it isn&#x27;t worth it&quot;. Haven&#x27;t we got past judging worth on surface beauty yet? Didn&#x27;t we hear the story of the ugly duckling as children? Haven&#x27;t we learned that there are tastes which can be developed (like cheeses, beers, spirits, cigars) and worthwhile skills that need time and effort and perseverance to develop?<p>&gt; &quot;<i>They could choose symbols that don&#x27;t look so ugly next to each other,</i>&quot;<p>Not as easily as you might think, given all the Unicode symbols exist because they already have a meaning to someone, and many of those might not render in typical font which computers already have installed.</div><br/><div id="38984545" class="c"><input type="checkbox" id="c-38984545" checked=""/><div class="controls bullet"><span class="by">Analemma_</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38984449">parent</a><span>|</span><a href="#38986038">next</a><span>|</span><label class="collapse" for="c-38984545">[-]</label><label class="expand" for="c-38984545">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very reductive and bad-faith interpretation of the criticism. A much better one would be: &quot;You can write either write a symbol soup with multiple paragraphs explaining what the soup does and why it is good, or you could write an equivalent amount of code in a verbose, readable language. The former option introduces two places for errors: they could be either in the code, or in the mapping from the code to the prose, while the latter only has one.&quot;</div><br/><div id="38984683" class="c"><input type="checkbox" id="c-38984683" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38984545">parent</a><span>|</span><a href="#38985111">next</a><span>|</span><label class="collapse" for="c-38984683">[-]</label><label class="expand" for="c-38984683">[2 more]</label></div><br/><div class="children"><div class="content">Symbol soup is just fine when you&#x27;re working in a highly restricted domain with limited scope for novel abstractions - which may well suit the idiomatic usage of array languages.  Math expressions are symbol soup, but a trained mathematician can read them quite directly.</div><br/><div id="38985497" class="c"><input type="checkbox" id="c-38985497" checked=""/><div class="controls bullet"><span class="by">sudosysgen</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38984683">parent</a><span>|</span><a href="#38985111">next</a><span>|</span><label class="collapse" for="c-38985497">[-]</label><label class="expand" for="c-38985497">[1 more]</label></div><br/><div class="children"><div class="content">Math expressions and notations are far more expressive than APL or J, because they are graphical, highly flexible, and not meant to be compiled. They also tend to be accompanied by text for whatever cannot be efficiently conveyed by the notation.</div><br/></div></div></div></div><div id="38985111" class="c"><input type="checkbox" id="c-38985111" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38984545">parent</a><span>|</span><a href="#38984683">prev</a><span>|</span><a href="#38986038">next</a><span>|</span><label class="collapse" for="c-38985111">[-]</label><label class="expand" for="c-38985111">[1 more]</label></div><br/><div class="children"><div class="content">This is an argument which has been going on for years; &quot;<i>crazy paragraphs because the code is ugly</i>&quot; is a thoughtless low effort criticism and it doesn&#x27;t deserve a steelman fleshed out rebuttal if the person hasn&#x27;t put any effort in.<p>You say &quot;a symbol soup with multiple paragraphs explaining what the soup does and why it is good&quot; - honestly, do you think people write multiple paragraphs explaining the code to beginners who can&#x27;t read APL <i>every single time they write any APL</i>? Of course they don&#x27;t! Your proposal relies on &quot;symbol soup&quot; being a fair and accurate description, which it isn&#x27;t.<p>And, are you suggesting that people <i>don&#x27;t</i> write comments explaining their code in common popular languages? Of course they do! (and should)<p>And, are you suggesting that people don&#x27;t have to <i>learn</i> and practise to be able to read common popular languages when they learn to program? Of course they do, look at posts around the internet on people learning Java and Rust and C# and C++ and Python asking what some code means, what some syntax means, and not only beginners, lots of people ask like &quot;I can code but what is this syntax?&quot; and it&#x27;s a Python generator comprehension, or a ternary operator, or a C# LINQ SQL style or a pattern match or an anonymous function or a compiler hint or a documentation generator template or a generic type or a turbofish or whatever thing they hadn&#x27;t seen before in their previous languages or codebases.<p>And, are you suggesting that comments getting out of sync with code is only a problem in array languages? Of course it isn&#x27;t.<p>Or that nobody ever complains about the readability of Java because it&#x27;s so verbose and has so much abstraction you can&#x27;t see what&#x27;s supposed to be happening? People do. I do.<p>And as always, what about regex? It&#x27;s <i>so</i> useful as a text processing language that it&#x27;s often still shorter and cleaner to write a complex regex and paragraphs of comments explaining it, than to code the equivalent in classic string indexing and slicing and if&#x2F;else branches. You&#x27;d end up writing a Greenspun-esque ad hoc, informally-specified, bug-ridden, slow implementation of half a regex engine.<p>That&#x27;s not to say there is no criticism of APL&#x27;s style possible, but if you want people to take the criticism seriously, have something new to say about it or some solid support and explanation for it. &quot;<i>Whenever you look at a problem somebody’s been working on for a week or a month or maybe years and propose a simple, obvious solution that just happens to be the first thing that comes into your head, then you’re also making it crystal clear to people what you think of them and their work.</i>&quot; - <a href="https:&#x2F;&#x2F;exple.tive.org&#x2F;blarg&#x2F;2019&#x2F;04&#x2F;17&#x2F;why-dont-you-just&#x2F;" rel="nofollow">https:&#x2F;&#x2F;exple.tive.org&#x2F;blarg&#x2F;2019&#x2F;04&#x2F;17&#x2F;why-dont-you-just&#x2F;</a></div><br/></div></div></div></div></div></div><div id="38986038" class="c"><input type="checkbox" id="c-38986038" checked=""/><div class="controls bullet"><span class="by">scrubs</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983437">parent</a><span>|</span><a href="#38984449">prev</a><span>|</span><a href="#38984392">next</a><span>|</span><label class="collapse" for="c-38986038">[-]</label><label class="expand" for="c-38986038">[2 more]</label></div><br/><div class="children"><div class="content">Agree. Plus matrix multiplication is essentially is array oriented by the domain of the problem.<p>Writing a mutex, or any number of distributed search&#x2F;sort algos with disk io approaching dbs isn&#x27;t. Network io isn&#x27;t either is any natural sense</div><br/><div id="38986185" class="c"><input type="checkbox" id="c-38986185" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38986038">parent</a><span>|</span><a href="#38984392">next</a><span>|</span><label class="collapse" for="c-38986185">[-]</label><label class="expand" for="c-38986185">[1 more]</label></div><br/><div class="children"><div class="content">You can do &#x27;regular&#x27; stuff in array languages too. And distributed searching&#x2F;sorting sounds like something array languages would be good at anyway. kdb being the obvious example. The IPC in q for example is very easy to use, and seems better than most languages that aren&#x27;t Erlang.</div><br/></div></div></div></div><div id="38984392" class="c"><input type="checkbox" id="c-38984392" checked=""/><div class="controls bullet"><span class="by">gitonthescene</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983437">parent</a><span>|</span><a href="#38986038">prev</a><span>|</span><a href="#38985844">next</a><span>|</span><label class="collapse" for="c-38984392">[-]</label><label class="expand" for="c-38984392">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the criticism could be a bit more precise than “it sucks”.  Though I am a fan of the animated series The Critic.</div><br/></div></div><div id="38985844" class="c"><input type="checkbox" id="c-38985844" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#38982944">root</a><span>|</span><a href="#38983437">parent</a><span>|</span><a href="#38984392">prev</a><span>|</span><a href="#38987885">next</a><span>|</span><label class="collapse" for="c-38985844">[-]</label><label class="expand" for="c-38985844">[1 more]</label></div><br/><div class="children"><div class="content">The language doesn&#x27;t suck for people who use it. They learn the symbols just fine and are able to understand what&#x27;s going on. Same thing for math, which can also be very terse.<p>Which is better, compact or verbose code? That&#x27;s a style issue and it all depends on who you ask. Verbose code requires you to read more. And more code to maintain.</div><br/></div></div></div></div></div></div><div id="38987885" class="c"><input type="checkbox" id="c-38987885" checked=""/><div class="controls bullet"><span class="by">icsa</span><span>|</span><a href="#38982944">prev</a><span>|</span><a href="#38981963">next</a><span>|</span><label class="collapse" for="c-38987885">[-]</label><label class="expand" for="c-38987885">[1 more]</label></div><br/><div class="children"><div class="content">The most significant Aha! moments that I&#x27;ve had from using array languages (mostly k) were:<p>- Verbs <i>are</i> algorithms. Imperative and object-oriented languages require the implementation of common algorithms (e.g. find, sort, and group).<p>- A sequence of verbs (or adverbs) is the most direct form of composition I&#x27;ve ever used. Composition is easy and fluent.<p>- Programs are the composition of algorithms and not a collection of statements &amp; expressions.<p>- The concept of domain and range treated uniformly across arrays, maps, and functions simplifies my design choices.<p>- Left of right evaluation means that my eyes don&#x27;t have to &quot;jump around&quot; when reading code.<p>- Sending code to data is possible &amp; preferred. Most of my significant k projects fit in a network MTU (i.e. 1540 bytes), not including comments.<p>K bonus:<p>- Views (i.e. dependencies) can implement functional relationships directly.<p>- Hot code (via the interpreter) loading makes &quot;forever&quot; applications possible.</div><br/></div></div><div id="38981963" class="c"><input type="checkbox" id="c-38981963" checked=""/><div class="controls bullet"><span class="by">account-5</span><span>|</span><a href="#38987885">prev</a><span>|</span><a href="#38984655">next</a><span>|</span><label class="collapse" for="c-38981963">[-]</label><label class="expand" for="c-38981963">[11 more]</label></div><br/><div class="children"><div class="content">If you never heard of array programming and are interested in an introduction I recommend:<p>The Array Cast
<a href="https:&#x2F;&#x2F;www.arraycast.com&#x2F;episodes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.arraycast.com&#x2F;episodes&#x2F;</a><p>RSS address: <a href="https:&#x2F;&#x2F;www.arraycast.com&#x2F;episodes?format=rss" rel="nofollow">https:&#x2F;&#x2F;www.arraycast.com&#x2F;episodes?format=rss</a></div><br/><div id="38982772" class="c"><input type="checkbox" id="c-38982772" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#38981963">parent</a><span>|</span><a href="#38982815">next</a><span>|</span><label class="collapse" for="c-38982772">[-]</label><label class="expand" for="c-38982772">[9 more]</label></div><br/><div class="children"><div class="content">I listened to the first ~5 episodes of The Array Cast <i>wanting</i> to be persuaded, but I just couldn&#x27;t buy in.<p>They downplayed the terseness and non-ASCII symbols of the array languages as something you get used to and something that&#x27;s worth it to get the benefits of array languages, but the benefits they listed were mostly ones that I&#x27;m already very familiar with from working with higher-order functions in <i>most</i> mainstream languages today.<p>It felt like the hosts had missed that map&#x2F;filter&#x2F;reduce have gone mainstream and are now available <i>~everywhere</i> without having to learn a whole logographic writing system first.</div><br/><div id="38983462" class="c"><input type="checkbox" id="c-38983462" checked=""/><div class="controls bullet"><span class="by">rak1507</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38982772">parent</a><span>|</span><a href="#38983012">next</a><span>|</span><label class="collapse" for="c-38983462">[-]</label><label class="expand" for="c-38983462">[3 more]</label></div><br/><div class="children"><div class="content">As an array language fan I also feel like a lot of the reasons people give for why array languages are powerful are outdated, and sometimes (not all the time) that&#x27;s because someone tried both APL and C in the 1970s and their opinions haven&#x27;t changed since.<p>However I still find them useful (and fun!) <i>because</i> of the terseness, not in spite of it. Terseness means array languages are very mathematical in nature + can be really ergonomic to write, especially with the repl. If someone said &quot;learn an array language, they&#x27;re easy to write on paper&quot; everyone would think they were insane...  but there is something to it, in certain cases. The idea of &quot;fearless refactoring&quot; is popular in the FP world, but it can also be true in the array language world too.</div><br/><div id="38984229" class="c"><input type="checkbox" id="c-38984229" checked=""/><div class="controls bullet"><span class="by">bear8642</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38983462">parent</a><span>|</span><a href="#38983012">next</a><span>|</span><label class="collapse" for="c-38984229">[-]</label><label class="expand" for="c-38984229">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;learn an array language, they&#x27;re easy to write on paper&quot; everyone would think they were insane... but there is something to it, in certain cases.<p>Indeed, and sometimes not needing a computer to quickly splash out an idea you&#x27;re thinking&#x2F;talking about is extremely useful!<p>Over Christmas, I showed my brother {+⌿⍤2(∘.≤)⍤1⍨⍵} as a small expression to explore attribute to pick playing Top-Trumps admist a discussion. Not something you&#x27;d be able to do in many other languages!</div><br/><div id="38987292" class="c"><input type="checkbox" id="c-38987292" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38984229">parent</a><span>|</span><a href="#38983012">next</a><span>|</span><label class="collapse" for="c-38987292">[-]</label><label class="expand" for="c-38987292">[1 more]</label></div><br/><div class="children"><div class="content">Could you explain the expression to us?</div><br/></div></div></div></div></div></div><div id="38983012" class="c"><input type="checkbox" id="c-38983012" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38982772">parent</a><span>|</span><a href="#38983462">prev</a><span>|</span><a href="#38983610">next</a><span>|</span><label class="collapse" for="c-38983012">[-]</label><label class="expand" for="c-38983012">[3 more]</label></div><br/><div class="children"><div class="content">Array languages come up a lot on HN so I’ve looked into them a few times. I think it’s a hard thing to gauge without trying to use them in anger for a while. One of the core arguments for them that resonates with me is that once you understand the operators, many patterns become so terse and repeat so often, you can refactor large portions of code very rapidly. I use a lot of F#, and can see the beginnings of this where translating from C# to F# often shrinks the code size to the point where I see patterns that weren’t obvious before. I believe APL, K, J, Nial, BQN, etc all have more extreme versions of that happening.<p>It also makes differences stand out so logic bugs are more visually obvious.</div><br/><div id="38983782" class="c"><input type="checkbox" id="c-38983782" checked=""/><div class="controls bullet"><span class="by">steveBK123</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38983012">parent</a><span>|</span><a href="#38983628">next</a><span>|</span><label class="collapse" for="c-38983782">[-]</label><label class="expand" for="c-38983782">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes the benefit of shorter codebases is that you can actually see the code.<p>Understanding that your logic bug is obviously somewhere within a handful of lines of K&#x2F;Q&#x2F;etc that fit neatly on a single screen vs scrolling through 200 lines of logic in Python&#x2F;Java&#x2F;whatever is focussing.<p>Sure each line is more compact and may take more time to digest, but that is a reasonable trade-off in most cases.<p>For me, 10 lines you need to read carefully beats 100 lines of having your eyes glaze over and repeatedly skip over the bug because you are so dulled to all the boilerplate.</div><br/></div></div><div id="38983628" class="c"><input type="checkbox" id="c-38983628" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38983012">parent</a><span>|</span><a href="#38983782">prev</a><span>|</span><a href="#38983610">next</a><span>|</span><label class="collapse" for="c-38983628">[-]</label><label class="expand" for="c-38983628">[1 more]</label></div><br/><div class="children"><div class="content">I can corroborate: That same feeling of as simple and terse code as possible happens in Haskell too.<p>However the most popular professional style of Haskell code is far too verbose for me to be able to &quot;see the essence&quot; in many cases without a round of refactoring.<p>Its far worse and far more grating for Java code that makes you do so much for so little.</div><br/></div></div></div></div><div id="38983610" class="c"><input type="checkbox" id="c-38983610" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38982772">parent</a><span>|</span><a href="#38983012">prev</a><span>|</span><a href="#38984756">next</a><span>|</span><label class="collapse" for="c-38983610">[-]</label><label class="expand" for="c-38983610">[1 more]</label></div><br/><div class="children"><div class="content">Map&#x2F;filter&#x2F;reduce are just primitives. The composability built on top of them and coherent system of using these higher level combinators is where other languages fall short.<p>Other languages support regex for example, but perl takes it to a different level that changes the language experience.</div><br/></div></div><div id="38984756" class="c"><input type="checkbox" id="c-38984756" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#38981963">root</a><span>|</span><a href="#38982772">parent</a><span>|</span><a href="#38983610">prev</a><span>|</span><a href="#38982815">next</a><span>|</span><label class="collapse" for="c-38984756">[-]</label><label class="expand" for="c-38984756">[1 more]</label></div><br/><div class="children"><div class="content">I am often in these threads on HN arguing in defense of the underdog (array languages); I do tend to agree with you here. I think the early days of APL (and Prolog) were that they were high level casually-typed REPL based interpreted languages, in a world of Fortran, PL&#x2F;1, COBOL and C, and the amazing nature of them back then is stuff we take for granted writing items=[1,2,3] and lookup={&#x27;key&#x27;:&#x27;value&#x27;} in Python and not worrying about allocating and freeing memory or pre-declaring the variables and their types, the string length, and compiling, and whatever.<p>Still, there is a fun about a desk calculator on so many steroids that it&#x27;s a Turing-complete programming language. One of the ArrayCast podcast guests said array languages were &quot;like a Domain Specific Language (DSL) with an enormously wide domain&quot;. How many mainstream languages will let you fork and hook and have inverses and over and under and recursively descend into anonymous functions, without ceremony or boilerplate code? You could have that now to play with, without waiting for it to go mainstream, just by learning a two or three dozen unfamiliar glyphs - compare that to the effort of learning a whole new framework for making web applications and it&#x27;s much smaller.</div><br/></div></div></div></div><div id="38982815" class="c"><input type="checkbox" id="c-38982815" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#38981963">parent</a><span>|</span><a href="#38982772">prev</a><span>|</span><a href="#38984655">next</a><span>|</span><label class="collapse" for="c-38982815">[-]</label><label class="expand" for="c-38982815">[1 more]</label></div><br/><div class="children"><div class="content">This is how I found out about BQN. I&#x27;m still not sure I&#x27;d use it in production somewhere. Even though I like it, most array languages seem rather foreign if it&#x27;s not, I don&#x27;t know R, NumPy, Julia maybe.. venturing deeper into APL, J, BQN I&#x27;d just alienate any support I could hope to recruit.</div><br/></div></div></div></div><div id="38984655" class="c"><input type="checkbox" id="c-38984655" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#38981963">prev</a><span>|</span><a href="#38982374">next</a><span>|</span><label class="collapse" for="c-38984655">[-]</label><label class="expand" for="c-38984655">[2 more]</label></div><br/><div class="children"><div class="content">I discovered APL&#x2F;APL2 in the 70&#x27;s (using actual overstrikes on a paper terminal) and fell instantly in love with it.  But when I later discovered functional programming with ML and Haskell, I realized that what I really enjoy about APL had little to do with arrays, but more with its ability to <i>compose</i> functions.<p>Haskell is so much better at this, being completely pure and typed throughout, and is even more fun and powerful than APL; I&#x27;ve used it to write a lot of small and medium-sized projects, prototype LLVM Flang&#x27;s parser to prove the concept of using parser combinators for Fortran, and do Advent of Code each year in a few hundred lines of code total.  If you like APL, try Haskell.<p>Today, I think that the whole &quot;notation as a tool of thought&quot; aspect of APL is a rationalization for excessive brevity -- which can be a good way to demonstrate the power of composition, but which can work against clarity.</div><br/><div id="38988403" class="c"><input type="checkbox" id="c-38988403" checked=""/><div class="controls bullet"><span class="by">jim-jim-jim</span><span>|</span><a href="#38984655">parent</a><span>|</span><a href="#38982374">next</a><span>|</span><label class="collapse" for="c-38988403">[-]</label><label class="expand" for="c-38988403">[1 more]</label></div><br/><div class="children"><div class="content">Yes. I&#x27;m a broken record on this topic, but I largely stopped messing with J and K once I got decent at writing point-free Haskell. Verb trains are even more powerful with functors in the mix. &lt;=&lt; is already available, and once you write an equivalent for fmap, you really start cooking. |||, +++, &amp;&amp;&amp;, and *** are great too. And you can always write UTF-8 operators to make it even shorter and prettier.<p>It&#x27;s unfortunate that the serious Haskell I&#x27;ve seen at work&#x2F;in the wild is rarely friendly to vertical screen realestate in this way.</div><br/></div></div></div></div><div id="38982374" class="c"><input type="checkbox" id="c-38982374" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#38984655">prev</a><span>|</span><a href="#38982563">next</a><span>|</span><label class="collapse" for="c-38982374">[-]</label><label class="expand" for="c-38982374">[17 more]</label></div><br/><div class="children"><div class="content">I have a question about array languages that I&#x27;ve been wondering for a while: lets say you have the task &quot;find all numbers smaller than N where predicate P is true&quot;. You know, like, &quot;find all primes smaller than 1000&quot;, or &quot;find all pythagorean triplets where Z is less than 1,000,000&quot;, something like that. The general pattern for doing this in an imperative language would be to have a for-loop that tests the predicate inside and then does something with the number. In a functional language, you&#x27;d use recursion or map&#x2F;filter on a lazy list, something like that.<p>(to be clear, this is in the general case where you don&#x27;t know exactly what P is. for the specific problem of finding primes smaller than N, you could obviously use sieves and stuff, but i&#x27;m more curious about the general pattern of problems like this)<p>Having only had limited exposure to array languages, my understanding is that in general the way to do that would be to do something like:<p>1. Generate an array from 1 to N<p>2. Test the array against the predicate, getting a new array with 0s and 1s (a mask, essentially)<p>3. Apply that mask to the array to get only elements where the predicate is true<p>Which is all fine, and I imagine that it takes a stupendously small amount of characters to do this. But my question is: what if N is large, and the predicate isn&#x27;t true very often? Like, what if N is a billion or something? This is not an issue in the imperative&#x2F;functional cases, because they don&#x27;t have to generate the array in step 1, they can just loop&#x2F;recurse&#x2F;lazily generate the values (i.e. memory is O(1) for this). But it seems extraordinarily wasteful in array languages both of memory and resources to generate two different billion element arrays (the 1..N array and the mask) just to get out a handful of values.<p>That question is pretty specific, but this is one of my biggest questions about array languages in general. Aren&#x27;t you always generating TONS of temporary arrays for no real reason, that will just pass through the calculation? Isn&#x27;t that really slow? Or does the implementation somehow optimize this stuff away, maybe by using something like lazy evaluation?</div><br/><div id="38982633" class="c"><input type="checkbox" id="c-38982633" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982542">next</a><span>|</span><label class="collapse" for="c-38982633">[-]</label><label class="expand" for="c-38982633">[3 more]</label></div><br/><div class="children"><div class="content">Yes, you waste a lot of memory. Memory&#x27;s cheap. If you need to, you can do the computation in blocks. Well, it&#x27;s pretty rare to actually run out of memory but blocking is useful for staying at a lower cache level.<p>Scalar languages have a different problem: the default is to process one value at a time, which wastes the potential parallelism that array languages take advantage of with SIMD algorithms. Because this is the status quo, it&#x27;s not as easy to see this as a big concern. And the solution is <i>also</i> blocking. That is, the best algorithm for SIMD-friendly stuff is generally a blocked array method.<p>In practice, whether an array language is good or not really depends on the specific problem. Of course, for most practical uses performance doesn&#x27;t matter at all; I believe k&#x27;s reputation mostly comes from kdb being fast as a database rather than k implementations being fast languages. But array languages can be surprisingly fast just by focusing on elegant array algorithms rather than machine-specific considerations. I have comments and benchmarks comparing with C here:<p><a href="https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;versusc.html" rel="nofollow">https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;versusc.html</a></div><br/><div id="38985188" class="c"><input type="checkbox" id="c-38985188" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38982633">parent</a><span>|</span><a href="#38982542">next</a><span>|</span><label class="collapse" for="c-38985188">[-]</label><label class="expand" for="c-38985188">[2 more]</label></div><br/><div class="children"><div class="content">Memory is cheap, but memory bandwidth isn’t.<p>Languages that can stay in L1 cache for the duration of a computation will run circles around a language that explicitly computes and stores all intermediate values in full.<p>Also, array-based languages can easily hit the wall of system memory capacity whereas traditional code tends to be streaming and can handle unbounded input lengths.</div><br/><div id="38985529" class="c"><input type="checkbox" id="c-38985529" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38985188">parent</a><span>|</span><a href="#38982542">next</a><span>|</span><label class="collapse" for="c-38985529">[-]</label><label class="expand" for="c-38985529">[1 more]</label></div><br/><div class="children"><div class="content">Which is exactly why I said you block the computation to stay at a low cache level. With SIMD loads and stores I don&#x27;t think this matters quite as much as you suggest, even without blocking. It&#x27;s pretty much only arithmetic that can saturate L1. I timed the BQN compiler on various files (some old version of itself, repeated). For 18K it runs at 21.4MB&#x2F;s; for 1.7M, 16.5MB&#x2F;s; for 17M, 12.0MB&#x2F;s. So even when the source won&#x27;t fit in L3 (mine&#x27;s 8MB) the degradation is under a factor of 2 (and of course the compiler makes no consideration of cache, who writes a megabyte of BQN?).</div><br/></div></div></div></div></div></div><div id="38982542" class="c"><input type="checkbox" id="c-38982542" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982633">prev</a><span>|</span><a href="#38982878">next</a><span>|</span><label class="collapse" for="c-38982542">[-]</label><label class="expand" for="c-38982542">[1 more]</label></div><br/><div class="children"><div class="content">There are a couple options for working around this. Lazy evaluation is indeed one option (e.g. Kap[0] uses it). Another clear option is loop-fusing the entire body together such that there are no temporary arrays.<p>Then there&#x27;s the slightly simpler option of splitting the operation in chunks of a couple dozen kilobytes of input&#x2F;output arrays such that unnecessary temporary memory usage is bounded; as far as I know no array language does this, but I hope to one day do something like this for CBQN. And this is even a thing that a user can manually do in an array language (and indeed often have to for maximizing perf).<p>[0]: <a href="https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;KAP" rel="nofollow">https:&#x2F;&#x2F;aplwiki.com&#x2F;wiki&#x2F;KAP</a></div><br/></div></div><div id="38982878" class="c"><input type="checkbox" id="c-38982878" checked=""/><div class="controls bullet"><span class="by">DrDroop</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982542">prev</a><span>|</span><a href="#38982520">next</a><span>|</span><label class="collapse" for="c-38982878">[-]</label><label class="expand" for="c-38982878">[1 more]</label></div><br/><div class="children"><div class="content">Your intuition is largely correct, but it is rarely a practical problem. The k language, including the ngn&#x2F;k dialect has some lazy constructions for example !10000000 (iota of 10 million), will not create an array of with 10 million ints but a simple range from 0 to 10 million. Depending on the operator you will of course end up with such an array. There are also certain optimisations (I think they are called colloquialisms) where things like +|x, reverse x and take the first element, is translated into just take the last element.</div><br/></div></div><div id="38982520" class="c"><input type="checkbox" id="c-38982520" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982878">prev</a><span>|</span><a href="#38985856">next</a><span>|</span><label class="collapse" for="c-38982520">[-]</label><label class="expand" for="c-38982520">[1 more]</label></div><br/><div class="children"><div class="content">I think you might think the array instantiation is literal. Nothing prevents an array language from handling it in chunks under the covers. If I ask it to give me an array of 10 billions integers, it may not naively do that. Not an expert , just a thought.</div><br/></div></div><div id="38985856" class="c"><input type="checkbox" id="c-38985856" checked=""/><div class="controls bullet"><span class="by">lokedhs</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982520">prev</a><span>|</span><a href="#38982597">next</a><span>|</span><label class="collapse" for="c-38985856">[-]</label><label class="expand" for="c-38985856">[1 more]</label></div><br/><div class="children"><div class="content">Many array languages do have this issue. To be precise, the issue is that the simple straightforward approach tends to compute a lot more than necessary.<p>It&#x27;s of course possible to do it in a different way to deal with that issues but those solutions can be a bit longer and less pretty.<p>The APL dialect I&#x27;m working on (Kap) solves this problem in many cases by delaying the computation until the result is needed, which means that you can write the code using the straightforward approach but still avoid computing results that will be thrown away.</div><br/></div></div><div id="38982597" class="c"><input type="checkbox" id="c-38982597" checked=""/><div class="controls bullet"><span class="by">max_</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38985856">prev</a><span>|</span><a href="#38982929">next</a><span>|</span><label class="collapse" for="c-38982597">[-]</label><label class="expand" for="c-38982597">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know what a Pythagorean triplet is but for primes you can do it as follows in J.<p>1. The primitive <i>p:</i> generates the nth prime number so, <i>p:0</i> generates the first prime number 2, <i>p:1</i>  generates the 2nd prime number.<p><i>P: 6</i> generates the 6th prime number 17.<p>2. <i>P:</i> supports arrays so <i>p: 0 1 2 3</i> will print the prime numbers at index 0, 1, 2 &amp; 3. Which are 2 3 5 7.<p>3. The primitive&#x2F;verb <i>i.</i> Generates a sequential list. So <i>i. 5</i> will generate 0 1 2 3 4<p>4. <i>p: can consume other verbs like </i>i:*<p>So to print the first 1,000 prime numbers, it is simply <i>p: (i.1000)</i></div><br/><div id="38982712" class="c"><input type="checkbox" id="c-38982712" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38982597">parent</a><span>|</span><a href="#38982929">next</a><span>|</span><label class="collapse" for="c-38982712">[-]</label><label class="expand" for="c-38982712">[4 more]</label></div><br/><div class="children"><div class="content">This is not quite the problem I was asking (i wanted to know how many numbers smaller than N this is true for, not the first N numbers it&#x27;s true for), but it illustrates my point anyway: the i.1000 generates an array of all numbers [0,1000) that is then immediately discarded. In imperative and functional languages, you don&#x27;t need to do that: in an imperative language it&#x27;s just loop counter, and in a functional language with lazy evaluation (e.g. Haskell), it&#x27;s a lazy list that doesn&#x27;t ever store all 1000 numbers.<p>My question is: will J cleverly optimize away the i.1000 array? Is it lazily generated, like in Haskell? Or is this just one of those &quot;we don&#x27;t really care about the memory of the i.1000 array, it&#x27;s usually small in practice&quot;? Like, for high performance stuff, it seems relevant to me that you spend an extra O(n) memory for no real reason.</div><br/><div id="38982986" class="c"><input type="checkbox" id="c-38982986" checked=""/><div class="controls bullet"><span class="by">max_</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38982712">parent</a><span>|</span><a href="#38982929">next</a><span>|</span><label class="collapse" for="c-38982986">[-]</label><label class="expand" for="c-38982986">[3 more]</label></div><br/><div class="children"><div class="content">So basically you already have an arbitrary list of 1000 numbers.<p>That may or may not be prime? And you want to know how many are prime? (Let me know if I am wrong)<p>1. Pick the highest number, H in the arbitrary list of 1000 numbers.<p>2. Generate all prime numbers up to the highest number, H.<p>3. Use  <i>e.</i>, Verb also known as member of to check for prime numbers present in arbitrary list.  <i>+&#x2F;(all prime numbers up to H e. arbitrary list of 1000 numbers)</i> will give you the number of items in the arbitrary list that are prime.<p>&gt; will J cleverly optimize away the i.1000 array?<p>The primitives &amp; verbs in array languages are designed to be as fast and efficient as possible.<p>So even if your code is mediocre, it will perform better that any mediocre imperative code.</div><br/><div id="38983199" class="c"><input type="checkbox" id="c-38983199" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38982986">parent</a><span>|</span><a href="#38982929">next</a><span>|</span><label class="collapse" for="c-38983199">[-]</label><label class="expand" for="c-38983199">[2 more]</label></div><br/><div class="children"><div class="content">I believe J doesn&#x27;t have any optimizations specifically for the problem of large temporary arrays (not to say that such can&#x27;t exist, but I don&#x27;t think anyone&#x27;s written such yet). With multiple temporary operations, each making a temporary array larger than cache, it could in fact end up slower than mediocre imperative scalar code.</div><br/><div id="38983526" class="c"><input type="checkbox" id="c-38983526" checked=""/><div class="controls bullet"><span class="by">max_</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38983199">parent</a><span>|</span><a href="#38982929">next</a><span>|</span><label class="collapse" for="c-38983526">[-]</label><label class="expand" for="c-38983526">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the insight.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38982929" class="c"><input type="checkbox" id="c-38982929" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982597">prev</a><span>|</span><a href="#38983362">next</a><span>|</span><label class="collapse" for="c-38982929">[-]</label><label class="expand" for="c-38982929">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;<i>I imagine that it takes a stupendously small amount of characters to do this.</i>&quot;<p>You&#x27;re right, but it&#x27;s not just codegolf; ideally the few characters are a clean high level way to express intent - and that is in tension with caring how a machine executes the algorithm most quickly.<p>&gt; &quot;<i>This is not an issue in the imperative&#x2F;functional cases, because they don&#x27;t have to generate the array in step 1, they can just loop&#x2F;recurse&#x2F;lazily generate the values (i.e. memory is O(1) for this)</i>&quot;<p>It kind of is the same problem, just pushed down a level or two; writing it casually in Python will not get you the fastest performance, you should be working in C or you&#x27;re wasting a lot of potential running the Python layer, then care about how you can parallelize the computation or you&#x27;re wasting 7&#x2F;8ths of an 8-core processor, then caring how you can make best use of the CPU SIMD instructions or you&#x27;re wasting another half or more of the machine potential, caring about branch predictors, and caches, etc. That a loop written in Python is &quot;not wasteful&quot; but materializing a large array &quot;is wasteful&quot; is where the industry draws a fairly arbitrary line. The ArrayCast podcast episode 52 touches on this[1], me cutting&#x2F;editing some relevant parts from the transcript; [ML] is Marshall Lochbaum who did performance optimizing work on Dyalog APL and designs&#x2F;implements the BQN array language, and [CH] is Conor Hoekstra who hosts the podcast and works in nVidia research:<p>&gt; ML: &quot;using linear memory is just how array languages work. For any problem, pretty much, you&#x27;re going to have to make a bunch of new arrays.&quot;<p>&gt; CH: &quot;there could be an array language that avoids [materializing] arrays when possible.&quot;<p>&gt; ML: &quot;it&#x27;s going very much against the grain of the language to say, &quot;All right, I&#x27;ve specified my answer in these high-level array terms, and now I want you to turn it into a C program for me&quot;.&quot;<p>&gt; ML: &quot;it&#x27;s still nice to specify a problem this way, but this array form for specifying gives you some pretty big advantages. [...] if you try to pack that all into a big iteration, your algorithm is no longer expressed as an array operation - and these array operations are things that we know how to do really quickly. You are giving up some performance information if you tell it, well, yes, I&#x27;m in an array language, but don&#x27;t actually make me any arrays.&quot;<p>&gt; CH: &quot;my dream is that I want to be able to write like the most expressive solutions to problems and then have [the array language implementation] do the most performant thing. Like for Kadane&#x27;s [algorithm], for example, the most performant thing is to hand roll that reduction yourself. It&#x27;s going to be faster than materialize.&quot;<p>&gt; ML: &quot;I&#x27;m not convinced of that&quot;<p>&gt; CH: [where I work we have to optimize for teams working on large problems, recently had a discussion where 2 billion items is a small number]<p>&gt; ML: &quot;2 billion &#x2F;is&#x2F; a small number&quot;<p>&gt; ML: &quot;what you can do, even when you have an array algorithm, you can split it into to smaller arrays. this is often a lot better because you get to use vector operations with these. So for Kadane&#x27;s algorithm in particular, I don&#x27;t know how to express that purely with vector operations, but I think there probably is a way. And in that case, if you write it in C style, where you interleave scan and reduction, then it&#x27;s much harder to go from that to a vectorized algorithm which (if it exists) would almost definitely be the fastest way. The way you would get the array thing to be cache friendly is that you run it blocks. And then within a block, it&#x27;s doing a bunch of vector operations, but what you really want is like, you know, working on two vector registers, say at a time. the array language doesn&#x27;t automatically chunk, but it&#x27;s not that hard&quot;<p>&gt; ML: &quot;Yeah, and I think the way for the implementation to get the best [performance] - maybe not with this particular problem - but definitely for things that are friendlier to arrays where you don&#x27;t have any compound functions inside scans. The way to optimize those is not to immediately break it down into a series of scalar operations, but instead to be more careful and start with your whole array stuff and break that as necessary, and maybe even compile these array operations into operations of individual registers, which is hard. Nobody&#x27;s really done that, but coming from the other side, from C, there have been who knows how many man hours poured into work on auto vectorization. And it&#x27;s still pretty terrible. It would have absolutely no chance of handling something like Kadane&#x27;s algorithm.&quot;<p>&gt; ML: &quot;getting the best implementation of an idea is pretty difficult. But I think actually starting from an array representation, you do have a pretty good chance without going through a C style scalar representation first.&quot;<p>That&#x27;s edited parts from a longer chat; but yes if you want to write X algorithm without wasting machine resources, that&#x27;s a hard problem and takes a lot of low level C&#x2F;SIMD&#x2F;CPU skills and time. Array languages can vector-accelerate the primitives of array symbols much easier than C compilers can identify vector-accelerate arbitrary looping code.<p>You can read more interesting things about the implementing of BQN and comparing with co-dfns and performance here: <a href="https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;codfns.html" rel="nofollow">https:&#x2F;&#x2F;mlochbaum.github.io&#x2F;BQN&#x2F;implementation&#x2F;codfns.html</a><p>[1] <a href="https:&#x2F;&#x2F;www.arraycast.com&#x2F;episode-52-transcript" rel="nofollow">https:&#x2F;&#x2F;www.arraycast.com&#x2F;episode-52-transcript</a> - around 00:39:21*</div><br/><div id="38983364" class="c"><input type="checkbox" id="c-38983364" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982374">root</a><span>|</span><a href="#38982929">parent</a><span>|</span><a href="#38983362">next</a><span>|</span><label class="collapse" for="c-38983364">[-]</label><label class="expand" for="c-38983364">[1 more]</label></div><br/><div class="children"><div class="content">Following this episode, I did find an AVX2 implementation of the maximum subarray sum that&#x27;s about 25% faster than the sequential version, published here: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;mlochbaum&#x2F;b6e9701c6c1c617a2c2a4fb10751e64f" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;mlochbaum&#x2F;b6e9701c6c1c617a2c2a4fb107...</a><p>Troels Henriksen (Futhark developer) pointed out to me that in expanding the state to make the scan associative I&#x27;d reinvented a fairly well-known method. The transformation from a specification as &quot;maximum over the sums of each subarray&quot; to the associative scan is very often used as an example of the power of the Bird-Meertens formalism or Squiggol[0], and some newer papers have demonstrated that it can be derived automatically, although not very quickly. Troels also wrote a simpler ISPC[1] implementation[2] that tested slower than C on an older CPU and faster on a newer one. Then I translated <i>that</i> to BQN and found it was about 4x slower than sequential C.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bird%E2%80%93Meertens_formalism" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bird%E2%80%93Meertens_formalis...</a><p>[1] <a href="https:&#x2F;&#x2F;ispc.github.io&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;ispc.github.io&#x2F;index.html</a><p>[2] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;athas&#x2F;f016084ea749602476b96c05ae415afa" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;athas&#x2F;f016084ea749602476b96c05ae415a...</a></div><br/></div></div></div></div><div id="38983362" class="c"><input type="checkbox" id="c-38983362" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#38982374">parent</a><span>|</span><a href="#38982929">prev</a><span>|</span><a href="#38982487">next</a><span>|</span><label class="collapse" for="c-38983362">[-]</label><label class="expand" for="c-38983362">[1 more]</label></div><br/><div class="children"><div class="content">in general one doesn&#x27;t want to materialize the intermediates. one evaluation strategy is treat the sets as streams. this removes the for loops, and leaves the evaluation strategy intact. for more complicated expressions, also allows you to move the filters first (referential transparency for the win), just like you would if you were compiling a relational query.</div><br/></div></div></div></div><div id="38982563" class="c"><input type="checkbox" id="c-38982563" checked=""/><div class="controls bullet"><span class="by">sega_sai</span><span>|</span><a href="#38982374">prev</a><span>|</span><a href="#38982892">next</a><span>|</span><label class="collapse" for="c-38982563">[-]</label><label class="expand" for="c-38982563">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, my personal&#x2F;biased&#x2F;limited impression from solving K language problems for the job interview is that the language is on purpose obtuse. It&#x27;s a nice language for puzzles and clever solutions.
But IMO, working with numpy arrays in Python -- that&#x27;s what teaches you array language, and how to think in arrays.</div><br/><div id="38984462" class="c"><input type="checkbox" id="c-38984462" checked=""/><div class="controls bullet"><span class="by">gitonthescene</span><span>|</span><a href="#38982563">parent</a><span>|</span><a href="#38982892">next</a><span>|</span><label class="collapse" for="c-38984462">[-]</label><label class="expand" for="c-38984462">[2 more]</label></div><br/><div class="children"><div class="content">Where were you interviewing?</div><br/><div id="38985255" class="c"><input type="checkbox" id="c-38985255" checked=""/><div class="controls bullet"><span class="by">sega_sai</span><span>|</span><a href="#38982563">root</a><span>|</span><a href="#38984462">parent</a><span>|</span><a href="#38982892">next</a><span>|</span><label class="collapse" for="c-38985255">[-]</label><label class="expand" for="c-38985255">[1 more]</label></div><br/><div class="children"><div class="content">DB (10 years ago)</div><br/></div></div></div></div></div></div><div id="38982892" class="c"><input type="checkbox" id="c-38982892" checked=""/><div class="controls bullet"><span class="by">mlochbaum</span><span>|</span><a href="#38982563">prev</a><span>|</span><a href="#38982904">next</a><span>|</span><label class="collapse" for="c-38982892">[-]</label><label class="expand" for="c-38982892">[2 more]</label></div><br/><div class="children"><div class="content">Previous discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31377262">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31377262</a></div><br/><div id="38987017" class="c"><input type="checkbox" id="c-38987017" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38982892">parent</a><span>|</span><a href="#38982904">next</a><span>|</span><label class="collapse" for="c-38987017">[-]</label><label class="expand" for="c-38987017">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>Thinking in an array language</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31377262">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31377262</a> - May 2022 (66 comments)</div><br/></div></div></div></div><div id="38982904" class="c"><input type="checkbox" id="c-38982904" checked=""/><div class="controls bullet"><span class="by">gcanyon</span><span>|</span><a href="#38982892">prev</a><span>|</span><a href="#38982493">next</a><span>|</span><label class="collapse" for="c-38982904">[-]</label><label class="expand" for="c-38982904">[7 more]</label></div><br/><div class="children"><div class="content">This is based on K. Another array language is J <a href="http:&#x2F;&#x2F;jsoftware.com" rel="nofollow">http:&#x2F;&#x2F;jsoftware.com</a> In J this would be:<p><pre><code>   dot =: +&#x2F; . *
   P =: 2 3 4
   Q =: 1 0 2
   P dot Q
</code></pre>
That will return 10, the dot product P and Q.</div><br/><div id="38987087" class="c"><input type="checkbox" id="c-38987087" checked=""/><div class="controls bullet"><span class="by">akavi</span><span>|</span><a href="#38982904">parent</a><span>|</span><a href="#38984367">next</a><span>|</span><label class="collapse" for="c-38987087">[-]</label><label class="expand" for="c-38987087">[3 more]</label></div><br/><div class="children"><div class="content">I guess I still fail to see the advantage of this over Haskell:<p><pre><code>    dot = (sum.) . zipWith (\*)
    p = [2, 3, 4]
    q = [1, 0, 2]
    p `dot` q
</code></pre>
Like, the only difference to my eyes is using names for sum&#x2F;zipWith, and not having the lifts&#x2F;restructuring happen &quot;magically&quot;</div><br/><div id="38987354" class="c"><input type="checkbox" id="c-38987354" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#38982904">root</a><span>|</span><a href="#38987087">parent</a><span>|</span><a href="#38988023">next</a><span>|</span><label class="collapse" for="c-38987354">[-]</label><label class="expand" for="c-38987354">[1 more]</label></div><br/><div class="children"><div class="content">The APL&#x2F;J&#x2F;K&#x2F;Klong versions are more general; they all work for a variety of ranks of input, whereas the Haskell version- which is the longest and most visually noisy- bakes in a single rank&#x27;s mapping explicitly.</div><br/></div></div><div id="38988023" class="c"><input type="checkbox" id="c-38988023" checked=""/><div class="controls bullet"><span class="by">radiator</span><span>|</span><a href="#38982904">root</a><span>|</span><a href="#38987087">parent</a><span>|</span><a href="#38987354">prev</a><span>|</span><a href="#38984367">next</a><span>|</span><label class="collapse" for="c-38988023">[-]</label><label class="expand" for="c-38988023">[1 more]</label></div><br/><div class="children"><div class="content">Well, for one, your Haskell version is obviously much longer.</div><br/></div></div></div></div><div id="38984367" class="c"><input type="checkbox" id="c-38984367" checked=""/><div class="controls bullet"><span class="by">abrudz</span><span>|</span><a href="#38982904">parent</a><span>|</span><a href="#38987087">prev</a><span>|</span><a href="#38983693">next</a><span>|</span><label class="collapse" for="c-38984367">[-]</label><label class="expand" for="c-38984367">[1 more]</label></div><br/><div class="children"><div class="content">The original array lang is APL:<p><pre><code>    dot←+.×
</code></pre>
but why give it a name when spelling it out is as short as the shortest reasonable name for it (and then you  might need to put spaces around the name).</div><br/></div></div><div id="38983693" class="c"><input type="checkbox" id="c-38983693" checked=""/><div class="controls bullet"><span class="by">eismcc</span><span>|</span><a href="#38982904">parent</a><span>|</span><a href="#38984367">prev</a><span>|</span><a href="#38982493">next</a><span>|</span><label class="collapse" for="c-38983693">[-]</label><label class="expand" for="c-38983693">[2 more]</label></div><br/><div class="children"><div class="content">In KlongPy, dot product is: dot::{+&#x2F;x*y}<p><pre><code>    P::[2 3 4]
    Q::[1 0 2]
    dot(P;Q)</code></pre></div><br/><div id="38987036" class="c"><input type="checkbox" id="c-38987036" checked=""/><div class="controls bullet"><span class="by">__marvin_the__</span><span>|</span><a href="#38982904">root</a><span>|</span><a href="#38983693">parent</a><span>|</span><a href="#38982493">next</a><span>|</span><label class="collapse" for="c-38987036">[-]</label><label class="expand" for="c-38987036">[1 more]</label></div><br/><div class="children"><div class="content">TIL of KlongPy (and Klong). Looking at the project page, I think it looks really cool.<p><a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;klongpy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;klongpy&#x2F;</a></div><br/></div></div></div></div></div></div><div id="38982493" class="c"><input type="checkbox" id="c-38982493" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#38982904">prev</a><span>|</span><a href="#38981776">next</a><span>|</span><label class="collapse" for="c-38982493">[-]</label><label class="expand" for="c-38982493">[6 more]</label></div><br/><div class="children"><div class="content">Looking at the example, is there a point to this? Is it more performant in anyway?<p>The syntax for matrix multiplication is shorter, but that’s only because there is a bunch of built in context you have to keep in your head about how the K language works.</div><br/><div id="38982536" class="c"><input type="checkbox" id="c-38982536" checked=""/><div class="controls bullet"><span class="by">maest</span><span>|</span><a href="#38982493">parent</a><span>|</span><a href="#38983181">next</a><span>|</span><label class="collapse" for="c-38982536">[-]</label><label class="expand" for="c-38982536">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more concise, which has value. In particular, think about how maths really consists of packing more and more concepts into higher level definitions. This is similar: higher level concepts become primitives and allow you to think faster and build more complex objects.</div><br/><div id="38984038" class="c"><input type="checkbox" id="c-38984038" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#38982493">root</a><span>|</span><a href="#38982536">parent</a><span>|</span><a href="#38983181">next</a><span>|</span><label class="collapse" for="c-38984038">[-]</label><label class="expand" for="c-38984038">[2 more]</label></div><br/><div class="children"><div class="content">I can see that, though it really depends on what these abstractions are, how complete they are in solving in a variety of problems, or I suppose, how frequent the problems it makes easier in relation to ones it makes harder.<p>I’d have to know a lot more and spend a lot of time before judging.<p>But I am not impressed seeing a single example. I could hypothetically write a language where mergesort is the operator * and reversing an array is the operator + and showcase how in my language 30 lines of code becomes 1. That would be insanely nice if you’re doing something which just requires thinking about sorting and reversing arrays but all together, very poor thing to build a standard language on.</div><br/><div id="38985792" class="c"><input type="checkbox" id="c-38985792" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#38982493">root</a><span>|</span><a href="#38984038">parent</a><span>|</span><a href="#38983181">next</a><span>|</span><label class="collapse" for="c-38985792">[-]</label><label class="expand" for="c-38985792">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what people do on codegolf.stackexchange.com with the dedicated golfing languages. What&#x27;s interesting about APL is that it started out as linear algebra and became array programming, and the primitives are more &quot;things which are useful transforms to do on arrays&quot; rather than &quot;thing people wanted to do in one problem turned into a symbol&quot;, and that&#x27;s enough to be useful in many tasks.<p>&gt; &quot;<i>That would be insanely nice if you’re doing something which just requires thinking about sorting and reversing arrays but all together, very poor thing to build a standard language on.</i>&quot;<p>Prolog has linked lists as its main data structure, which means prepend is more performant than append. In the SWI Prolog documentation for foldl[1] it says &quot;<i>No implementation for a corresponding foldr is given. A foldr implementation would consist in first calling reverse&#x2F;2 on each of the m input lists, then applying the appropriate foldl. This is actually more efficient than using a properly programmed-out recursive algorithm that cannot be tail-call optimized</i>&quot;. i.e. you don&#x27;t have to have a problem which involves reversing arrays, for reverse to be a useful part of a solution.<p>In APL reverse is one character ⌽. In C# to find the first comma in a string you use IndexOf(&#x27;,&#x27;) and to get the last one you use LastIndexOf(&#x27;,&#x27;). In APL you would use the equivalent of indexOf(Reverse(string)) and then you wouldn&#x27;t need the specialised LastIndexOf - and wouldn&#x27;t every other function which works from the left of a string or array to have an equivalent which works from the right. <a href="https:&#x2F;&#x2F;aplcart.info&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aplcart.info&#x2F;</a> is a database of idioms and samples of useful APL and it has 168 pieces of code using ⌽.<p>[1] <a href="https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?predicate=foldl&#x2F;4" rel="nofollow">https:&#x2F;&#x2F;www.swi-prolog.org&#x2F;pldoc&#x2F;man?predicate=foldl&#x2F;4</a></div><br/></div></div></div></div></div></div><div id="38983181" class="c"><input type="checkbox" id="c-38983181" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#38982493">parent</a><span>|</span><a href="#38982536">prev</a><span>|</span><a href="#38983816">next</a><span>|</span><label class="collapse" for="c-38983181">[-]</label><label class="expand" for="c-38983181">[1 more]</label></div><br/><div class="children"><div class="content">It _can_ be more performant because computers are exceedingly fast at cranking through arrays, especially if you can leverage SIMD, but its not just that.<p>It&#x27;s useful to play around with an array language until the paradigm clicks.  Often, imperative code can be better handled in an array style.  Sometimes long, fiddly functions can be greatly simplified if you use array operations instead or in conjunction with other styles.</div><br/></div></div><div id="38983816" class="c"><input type="checkbox" id="c-38983816" checked=""/><div class="controls bullet"><span class="by">ParetoOptimal</span><span>|</span><a href="#38982493">parent</a><span>|</span><a href="#38983181">prev</a><span>|</span><a href="#38981776">next</a><span>|</span><label class="collapse" for="c-38983816">[-]</label><label class="expand" for="c-38983816">[1 more]</label></div><br/><div class="children"><div class="content">If you believe that verbosity has a cost and that only the most complex functions should have the privilege if being verbose, it&#x27;s easy to see a point.<p>Here&#x27;s a Haskell example:<p><pre><code>    (+) &lt;$&gt; Just 1 &lt;*&gt; Just 2
</code></pre>
Versus:<p><pre><code>    do x &lt;- Just 1
       y &lt;- Just 2
       Just (x + y)
</code></pre>
I would always prefer the first for something of this complexity because the latter example implies something more complex is happening to me because it takes more space.<p>If I had something more complex, I&#x27;d prefer to factor that operation into functions small enough that the first variation makes sense over using the second.<p>This does trade &quot;beginner+ can read this quickly&quot; for &quot;some beginners can read this&quot;.<p>I&#x27;m of the opinion you shouldn&#x27;t optimize for &quot;some beginners can read this&quot; because of very diminishing returns.<p>Instead I aim for &quot;beginner+ can read this&quot; or in some cases &quot;intermediate+ can read this&quot;.</div><br/></div></div></div></div><div id="38981776" class="c"><input type="checkbox" id="c-38981776" checked=""/><div class="controls bullet"><span class="by">rekttrader</span><span>|</span><a href="#38982493">prev</a><span>|</span><a href="#38982514">next</a><span>|</span><label class="collapse" for="c-38981776">[-]</label><label class="expand" for="c-38981776">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for posting this, I just this week tried to explain array programming.</div><br/></div></div><div id="38982514" class="c"><input type="checkbox" id="c-38982514" checked=""/><div class="controls bullet"><span class="by">p1esk</span><span>|</span><a href="#38981776">prev</a><span>|</span><a href="#38982190">next</a><span>|</span><label class="collapse" for="c-38982514">[-]</label><label class="expand" for="c-38982514">[3 more]</label></div><br/><div class="children"><div class="content">Is Numpy or Pytorch an array language? With things like einsum and elaborate slicing&#x2F;indexing mechanisms.</div><br/><div id="38982794" class="c"><input type="checkbox" id="c-38982794" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#38982514">parent</a><span>|</span><a href="#38983027">next</a><span>|</span><label class="collapse" for="c-38982794">[-]</label><label class="expand" for="c-38982794">[1 more]</label></div><br/><div class="children"><div class="content">More like an array framework&#x2F;library on top of a general purpose Object Oriented language.</div><br/></div></div><div id="38983027" class="c"><input type="checkbox" id="c-38983027" checked=""/><div class="controls bullet"><span class="by">Qem</span><span>|</span><a href="#38982514">parent</a><span>|</span><a href="#38982794">prev</a><span>|</span><a href="#38982190">next</a><span>|</span><label class="collapse" for="c-38983027">[-]</label><label class="expand" for="c-38983027">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;analyzethedatanotthedrivel.org&#x2F;2018&#x2F;03&#x2F;31&#x2F;numpy-another-iverson-ghost&#x2F;" rel="nofollow">https:&#x2F;&#x2F;analyzethedatanotthedrivel.org&#x2F;2018&#x2F;03&#x2F;31&#x2F;numpy-anot...</a></div><br/></div></div></div></div><div id="38982190" class="c"><input type="checkbox" id="c-38982190" checked=""/><div class="controls bullet"><span class="by">theusus</span><span>|</span><a href="#38982514">prev</a><span>|</span><a href="#38982500">next</a><span>|</span><label class="collapse" for="c-38982190">[-]</label><label class="expand" for="c-38982190">[8 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t lisp a list language? Isn&#x27;t easy to index but gives similar functionality</div><br/><div id="38988223" class="c"><input type="checkbox" id="c-38988223" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38982190">parent</a><span>|</span><a href="#38985016">next</a><span>|</span><label class="collapse" for="c-38988223">[-]</label><label class="expand" for="c-38988223">[1 more]</label></div><br/><div class="children"><div class="content">In a word, no. Lisp is the name of a language family, not a specific language.<p>Major dialects in the Lisp family are languages with built-in support for more than one kind of data type, not only lists.</div><br/></div></div><div id="38985016" class="c"><input type="checkbox" id="c-38985016" checked=""/><div class="controls bullet"><span class="by">account-5</span><span>|</span><a href="#38982190">parent</a><span>|</span><a href="#38988223">prev</a><span>|</span><a href="#38982314">next</a><span>|</span><label class="collapse" for="c-38985016">[-]</label><label class="expand" for="c-38985016">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an array programming language implemented in lisp called april: <a href="https:&#x2F;&#x2F;github.com&#x2F;phantomics&#x2F;april">https:&#x2F;&#x2F;github.com&#x2F;phantomics&#x2F;april</a><p>EDIT: someone beat me to it in a comment further down or up the thread...</div><br/></div></div><div id="38982314" class="c"><input type="checkbox" id="c-38982314" checked=""/><div class="controls bullet"><span class="by">RodgerTheGreat</span><span>|</span><a href="#38982190">parent</a><span>|</span><a href="#38985016">prev</a><span>|</span><a href="#38982301">next</a><span>|</span><label class="collapse" for="c-38982314">[-]</label><label class="expand" for="c-38982314">[3 more]</label></div><br/><div class="children"><div class="content">It does not.<p>Array-oriented languages (or Vector-oriented languages, if you like) are generally distinguished by features like concise syntax, implicit conforming&#x2F;mapping over homogenous collections, and a strong de-emphasis on explicit looping or recursion in favor of abstract (and often parallel) iteration.<p>Some of these features could be implemented- to an extent- in a Lisp, but they do not reflect normal Lisp programming style.</div><br/><div id="38982409" class="c"><input type="checkbox" id="c-38982409" checked=""/><div class="controls bullet"><span class="by">aeonik</span><span>|</span><a href="#38982190">root</a><span>|</span><a href="#38982314">parent</a><span>|</span><a href="#38982301">next</a><span>|</span><label class="collapse" for="c-38982409">[-]</label><label class="expand" for="c-38982409">[2 more]</label></div><br/><div class="children"><div class="content">Clojure actually has a fair amount in common with Array Languages, at least the mapping and conformation.<p>That being said, I really really like Array Languages for certain subsets of problems over anything else.<p>I kinda think every language and have an embedded Array Language engine, kinda like how Regex works so well for text processing.</div><br/><div id="38982474" class="c"><input type="checkbox" id="c-38982474" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38982190">root</a><span>|</span><a href="#38982409">parent</a><span>|</span><a href="#38982301">next</a><span>|</span><label class="collapse" for="c-38982474">[-]</label><label class="expand" for="c-38982474">[1 more]</label></div><br/><div class="children"><div class="content">The key thing is that lisp type (and most functional) languages, including Clojure, emphasize function application and (often) recursion.<p>Array languages try to get you to formulate your problem in terms of batch applications across whole vectors at a time, rather than piece by piece.<p>Which is actually potentially insanely faster on modern hardware where branches are expensive and we have special SIMD and&#x2F;or vector hardware support.</div><br/></div></div></div></div></div></div><div id="38982301" class="c"><input type="checkbox" id="c-38982301" checked=""/><div class="controls bullet"><span class="by">ginsider_oaks</span><span>|</span><a href="#38982190">parent</a><span>|</span><a href="#38982314">prev</a><span>|</span><a href="#38982500">next</a><span>|</span><label class="collapse" for="c-38982301">[-]</label><label class="expand" for="c-38982301">[2 more]</label></div><br/><div class="children"><div class="content">list languages and array languages are quite different.
in LISP, the lists are heterogeneous i.e. each element can contain different types, which is also how you can e.g. make a tree out of lists in LISP.
typically in array languages all elements are the same, and you use operations that apply to the whole array e.g. one operation for summing the array rather than a loop.</div><br/><div id="38984222" class="c"><input type="checkbox" id="c-38984222" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#38982190">root</a><span>|</span><a href="#38982301">parent</a><span>|</span><a href="#38982500">next</a><span>|</span><label class="collapse" for="c-38984222">[-]</label><label class="expand" for="c-38984222">[1 more]</label></div><br/><div class="children"><div class="content">There are attempts to combine those...<p>a cool example is April (Array Programming Re-Imagined in Lisp), which runs on top of Common Lisp...<p><a href="https:&#x2F;&#x2F;github.com&#x2F;phantomics&#x2F;april">https:&#x2F;&#x2F;github.com&#x2F;phantomics&#x2F;april</a><p>One can see that the Lisp macro APRIL-F compiles APL-like code to Lisp.<p><pre><code>  APRIL&gt; (macroexpand &#x27;(april-f &quot;3r4J9r5×⍳4&quot;))
  (LET ((OUTPUT-STREAM *STANDARD-OUTPUT*))
    (DECLARE (IGNORABLE OUTPUT-STREAM))
    (SYMBOL-MACROLET ((INDEX-ORIGIN APRIL-WORKSPACE-COMMON::*INDEX-ORIGIN*)
                      (PRINT-PRECISION APRIL-WORKSPACE-COMMON::*PRINT-PRECISION*)
                      (COMPARISON-TOLERANCE
                       APRIL-WORKSPACE-COMMON::*COMPARISON-TOLERANCE*)
                      (DIVISION-METHOD APRIL-WORKSPACE-COMMON::*DIVISION-METHOD*)
                      (RNGS APRIL-WORKSPACE-COMMON::*RNGS*))
      (A-OUT (A-CALL (APL-FN-S ×) (A-CALL (APL-FN ⍳ INDEX-ORIGIN) 4) #C(3&#x2F;4 9&#x2F;5))
             :PRINT-PRECISION PRINT-PRECISION :PRINT-TO OUTPUT-STREAM)))
  T
</code></pre>
we can run that:<p><pre><code>  APRIL&gt; (april-f &quot;3r4J9r5×⍳4&quot;)
  3r4J9r5 3r2J18r5 9r4J27r5 3J36r5
  #(#C(3&#x2F;4 9&#x2F;5) #C(3&#x2F;2 18&#x2F;5) #C(9&#x2F;4 27&#x2F;5) #C(3 36&#x2F;5))
</code></pre>
It has created a Lisp vector of complex numbers.<p><pre><code>  APRIL&gt; (describe *)
  #(#C(3&#x2F;4 9&#x2F;5) #C(3&#x2F;2 18&#x2F;5) #C(9&#x2F;4 27&#x2F;5) #C(3 36&#x2F;5))
    [simple-vector]

  Element-type: T
  Length: 4
  ; No value</code></pre></div><br/></div></div></div></div></div></div><div id="38982500" class="c"><input type="checkbox" id="c-38982500" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38982190">prev</a><span>|</span><a href="#38982753">next</a><span>|</span><label class="collapse" for="c-38982500">[-]</label><label class="expand" for="c-38982500">[2 more]</label></div><br/><div class="children"><div class="content">Should be interesting to see what people will do the the RISC-V (V)ector extension with array languages. I would think there is a pretty straight 1:1 conceptual correspondence there, and one could write a pretty nifty compiler to go from an APL-ish thingy to those instructions, and get some serious oomph.</div><br/><div id="38982837" class="c"><input type="checkbox" id="c-38982837" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#38982500">parent</a><span>|</span><a href="#38982753">next</a><span>|</span><label class="collapse" for="c-38982837">[-]</label><label class="expand" for="c-38982837">[1 more]</label></div><br/><div class="children"><div class="content">While RVV still makes for a good target for arraylang implementations, RVV isn&#x27;t really much closer to arraylangs than AVX-512, or really any SIMD if you squint hard enough (the scalability of RVV&#x2F;SVE is unrelated as you still need to have loops; and the existence of VL, while nice, doesn&#x27;t give any new fundamental possibilities).<p>Basic list operations might have a roughly-1:1 mapping to simple RVV loops, but many others still require a decent bit of extra code (all search functions (hash- or lookup tables), narrow matrix ops (processing multiple rows at a time); even compress operations get questionable when there&#x27;s multiple of them due to their variable-length nature).</div><br/></div></div></div></div><div id="38982753" class="c"><input type="checkbox" id="c-38982753" checked=""/><div class="controls bullet"><span class="by">Bostonian</span><span>|</span><a href="#38982500">prev</a><span>|</span><label class="collapse" for="c-38982753">[-]</label><label class="expand" for="c-38982753">[2 more]</label></div><br/><div class="children"><div class="content">Fortran has the matmul intrinsic function, and you can define an operator .x. so that a .x. b is equivalent to matmul(a,b). APL, J, and K are not unique in being able to express linear algebra operations concisely.</div><br/><div id="38983356" class="c"><input type="checkbox" id="c-38983356" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#38982753">parent</a><span>|</span><label class="collapse" for="c-38983356">[-]</label><label class="expand" for="c-38983356">[1 more]</label></div><br/><div class="children"><div class="content">You can’t define a generic interface in terms of another generic interface in Fortran.  To do what you suggest in actual Fortran, you would have to write specific functions for all the combinations of data types and ranks supported by MATMUL (hundreds).</div><br/></div></div></div></div></div></div></div></div></div></body></html>