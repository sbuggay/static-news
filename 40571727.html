<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717578075940" as="style"/><link rel="stylesheet" href="styles.css?v=1717578075940"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://emildziewanowski.com/flat-planets/">Sphere Rendering: Flat Planets</a> <span class="domain">(<a href="https://emildziewanowski.com">emildziewanowski.com</a>)</span></div><div class="subtext"><span>skilled</span> | <span>35 comments</span></div><br/><div><div id="40577993" class="c"><input type="checkbox" id="c-40577993" checked=""/><div class="controls bullet"><span class="by">mrsharpoblunto</span><span>|</span><a href="#40577101">next</a><span>|</span><label class="collapse" for="c-40577993">[-]</label><label class="expand" for="c-40577993">[7 more]</label></div><br/><div class="children"><div class="content">The author dismisses cubemaps pretty quickly, but imo it’s the simplest solution &amp; it’s what I did when rendering dynamic gas giants on my own personal project a number of years back* . Using a cubemap doesn’t result in a 6x increase in memory usage, you’re just splitting the texture size from one large rectangular face into 6 smaller rectangular faces, but the total texture detail is the same. The nice part about a cubemap is you don’t have to worry about pole pinching at all + you can use a 3 or 4 dimensional noise function to easily create a seamless flow field for texture animation&#x2F;distortion.<p>* <a href="https:&#x2F;&#x2F;www.junkship.net&#x2F;News&#x2F;2016&#x2F;06&#x2F;09&#x2F;jupiter-jazz" rel="nofollow">https:&#x2F;&#x2F;www.junkship.net&#x2F;News&#x2F;2016&#x2F;06&#x2F;09&#x2F;jupiter-jazz</a></div><br/><div id="40580220" class="c"><input type="checkbox" id="c-40580220" checked=""/><div class="controls bullet"><span class="by">jacobolus</span><span>|</span><a href="#40577993">parent</a><span>|</span><a href="#40579858">next</a><span>|</span><label class="collapse" for="c-40580220">[-]</label><label class="expand" for="c-40580220">[1 more]</label></div><br/><div class="children"><div class="content">If you want to avoid weird seam artifacts, using 2 hemispheres of stereographic projection is probably better still. Each hemisphere projects to a disk but you can just fill out the texture to the boundaries of a square, duplicating a bit of each hemisphere into the corners of the other&#x27;s texture (or you could leave those parts blank if you want). There&#x27;s a 1:2 difference in scale from the center to the edge of each disk, so you could argue this is slightly wasteful of pixels for a given minimum required level of detail, but the projection is conformal so it&#x27;s considerably less tricky to figure out how to sample it to decide the color for destination pixels drawn at steep perspective, and the stereographic projection is very cheap to compute in both directions (1 division + some additions and multiplications per projected point), even cheaper than the gnomonic projection used for a cubemap.<p>If you want something conformal that has less scale variation and wastes fewer corner pixels than a pair of stereographically projected hemispheres and is still not too conceptually tricky, you can use a pair of slightly overlapping Mercator projections, at right angles to each-other, covering the sphere like the two pieces of leather covering a baseball. Each one can have a rectangular texture. There are some NOAA papers suggesting this approach for the grids for solving differential equations needed in weather simulation of the Earth.<p>The most pixel-efficient projection I know starts by breaking the sphere into an octahedron, then taking each octant to be covered in a grid of hexagonal pixels, using &quot;spherical area coordinates&quot; in each octant to determine the grid. Each octant can then be represented in an ordinary square-pixel image by a half square (&quot;45–45–90 right triangle&quot;), so the result is something like this &lt;<a href="https:&#x2F;&#x2F;observablehq.com&#x2F;@jrus&#x2F;sac-quincuncial" rel="nofollow">https:&#x2F;&#x2F;observablehq.com&#x2F;@jrus&#x2F;sac-quincuncial</a>&gt; with a hexagon grid like &lt;<a href="https:&#x2F;&#x2F;observablehq.com&#x2F;@jrus&#x2F;sphere-resample" rel="nofollow">https:&#x2F;&#x2F;observablehq.com&#x2F;@jrus&#x2F;sphere-resample</a>&gt; (scroll a few examples down from the top of the page). But figuring out the details about how to sample the texture when you need to cross edge boundaries, etc., makes using this quite a bit more fiddly than the 2 stereographic projection version. And there will be some seam artifacts.</div><br/></div></div><div id="40579858" class="c"><input type="checkbox" id="c-40579858" checked=""/><div class="controls bullet"><span class="by">jeffparsons</span><span>|</span><a href="#40577993">parent</a><span>|</span><a href="#40580220">prev</a><span>|</span><a href="#40580079">next</a><span>|</span><label class="collapse" for="c-40579858">[-]</label><label class="expand" for="c-40579858">[1 more]</label></div><br/><div class="children"><div class="content">And if you want to further minimise distortion, you could group the triangular faces of an icosahedron into 10 rhombuses, each covered by one square texture.<p>It&#x27;s more math, though, and usually not worth it unless you&#x27;re already planning to subdivide the surface further for some other reason.</div><br/></div></div><div id="40580079" class="c"><input type="checkbox" id="c-40580079" checked=""/><div class="controls bullet"><span class="by">robertsdionne</span><span>|</span><a href="#40577993">parent</a><span>|</span><a href="#40579858">prev</a><span>|</span><a href="#40578701">next</a><span>|</span><label class="collapse" for="c-40580079">[-]</label><label class="expand" for="c-40580079">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Peirce_quincuncial_projection" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Peirce_quincuncial_projection</a></div><br/></div></div><div id="40578701" class="c"><input type="checkbox" id="c-40578701" checked=""/><div class="controls bullet"><span class="by">bun_terminator</span><span>|</span><a href="#40577993">parent</a><span>|</span><a href="#40580079">prev</a><span>|</span><a href="#40577101">next</a><span>|</span><label class="collapse" for="c-40578701">[-]</label><label class="expand" for="c-40578701">[3 more]</label></div><br/><div class="children"><div class="content">Thank you for posting that. I might use that curl-noise to generate clouds on a planetary-scale game I&#x27;m working on right now.</div><br/><div id="40580936" class="c"><input type="checkbox" id="c-40580936" checked=""/><div class="controls bullet"><span class="by">mrsharpoblunto</span><span>|</span><a href="#40577993">root</a><span>|</span><a href="#40578701">parent</a><span>|</span><a href="#40578854">next</a><span>|</span><label class="collapse" for="c-40580936">[-]</label><label class="expand" for="c-40580936">[1 more]</label></div><br/><div class="children"><div class="content">I’ve since done a bunch more on planetary cloud rendering, need to do a proper write up, but it’s a combination of volumetric noise, flow fields &amp; atmospheric scattering.<p><a href="https:&#x2F;&#x2F;x.com&#x2F;mr_sharpoblunto&#x2F;status&#x2F;1653986502106570757" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;mr_sharpoblunto&#x2F;status&#x2F;1653986502106570757</a></div><br/></div></div><div id="40578854" class="c"><input type="checkbox" id="c-40578854" checked=""/><div class="controls bullet"><span class="by">lainga</span><span>|</span><a href="#40577993">root</a><span>|</span><a href="#40578701">parent</a><span>|</span><a href="#40580936">prev</a><span>|</span><a href="#40577101">next</a><span>|</span><label class="collapse" for="c-40578854">[-]</label><label class="expand" for="c-40578854">[1 more]</label></div><br/><div class="children"><div class="content">unrelated: if you want to talk about that particular type of game shoot me an email (see profile)</div><br/></div></div></div></div></div></div><div id="40577101" class="c"><input type="checkbox" id="c-40577101" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#40577993">prev</a><span>|</span><a href="#40578111">next</a><span>|</span><label class="collapse" for="c-40577101">[-]</label><label class="expand" for="c-40577101">[8 more]</label></div><br/><div class="children"><div class="content">Texture pinching at the poles is an extreme version of a form of distortion that is actually present on the whole surface. The distortion is usually only obvious at the poles but it can also become visible elsewhere if you use adaptive subdivision of the sphere into triangles because the distortion will change as the subdivision changes.<p>The problem is the sphere is divided into quads which are represented by two triangles, which each have equal area in UV space, but one of the triangles is smaller than the other in 3D space (the one with its horizontal edge closer to the pole). Despite this difference, the UVs are interpolated linearly across the triangle, which means half of the texture is shrunk and half is stretched. At the pole this becomes extreme because one of the triangles actually has zero area in 3D space, so only half of the texture is actually rendered, which causes obvious seams between the triangles.<p>The right solution is to calculate the UV coordinates per pixel in the pixel shader, instead of per vertex with linear interpretation. If done properly the poles will be seamless.</div><br/><div id="40577220" class="c"><input type="checkbox" id="c-40577220" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#40577101">parent</a><span>|</span><a href="#40579972">next</a><span>|</span><label class="collapse" for="c-40577220">[-]</label><label class="expand" for="c-40577220">[3 more]</label></div><br/><div class="children"><div class="content">Hi! Could you provide some more information please (either in hints&#x2F;keywords to help search, or links if you have them handy)? I&#x27;ve recently started dabbling a bit rendering, shaders and game dev. So I&#x27;d love to know more!</div><br/><div id="40579874" class="c"><input type="checkbox" id="c-40579874" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40577101">root</a><span>|</span><a href="#40577220">parent</a><span>|</span><a href="#40579972">next</a><span>|</span><label class="collapse" for="c-40579874">[-]</label><label class="expand" for="c-40579874">[2 more]</label></div><br/><div class="children"><div class="content">See the <i>Rasterisation algorithms</i>[1] section of Wikipedia&#x27;s <i>Texture mapping</i> article.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Texture_mapping#Rasterisation_algorithms" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Texture_mapping#Rasterisation_...</a></div><br/><div id="40581898" class="c"><input type="checkbox" id="c-40581898" checked=""/><div class="controls bullet"><span class="by">spoiler</span><span>|</span><a href="#40577101">root</a><span>|</span><a href="#40579874">parent</a><span>|</span><a href="#40579972">next</a><span>|</span><label class="collapse" for="c-40581898">[-]</label><label class="expand" for="c-40581898">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div></div></div><div id="40579972" class="c"><input type="checkbox" id="c-40579972" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40577101">parent</a><span>|</span><a href="#40577220">prev</a><span>|</span><a href="#40577348">next</a><span>|</span><label class="collapse" for="c-40579972">[-]</label><label class="expand" for="c-40579972">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t scaling W (instead of leaving it as 1 in the XYZ entries) fix this?</div><br/><div id="40581040" class="c"><input type="checkbox" id="c-40581040" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#40577101">root</a><span>|</span><a href="#40579972">parent</a><span>|</span><a href="#40577348">next</a><span>|</span><label class="collapse" for="c-40581040">[-]</label><label class="expand" for="c-40581040">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I think it could probably be fixed this way, if you calculate the W coordinates appropriately.</div><br/></div></div></div></div><div id="40577348" class="c"><input type="checkbox" id="c-40577348" checked=""/><div class="controls bullet"><span class="by">adolph</span><span>|</span><a href="#40577101">parent</a><span>|</span><a href="#40579972">prev</a><span>|</span><a href="#40578111">next</a><span>|</span><label class="collapse" for="c-40577348">[-]</label><label class="expand" for="c-40577348">[2 more]</label></div><br/><div class="children"><div class="content">Are spheres ever rendered with multiple rendering poles to decrease the pinching you describe?<p>As an example a sphere with a “true north” pole that is rendered with one rendering pole at “true north” and another at 0&#x27;,0’. When the user is looking at the sphere sidelong the former is used and if the user looks at it from closer to the “true north” pole, the equatorial render is used.</div><br/><div id="40577411" class="c"><input type="checkbox" id="c-40577411" checked=""/><div class="controls bullet"><span class="by">lainga</span><span>|</span><a href="#40577101">root</a><span>|</span><a href="#40577348">parent</a><span>|</span><a href="#40578111">next</a><span>|</span><label class="collapse" for="c-40577411">[-]</label><label class="expand" for="c-40577411">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cube_mapping" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cube_mapping</a></div><br/></div></div></div></div></div></div><div id="40578111" class="c"><input type="checkbox" id="c-40578111" checked=""/><div class="controls bullet"><span class="by">JKCalhoun</span><span>|</span><a href="#40577101">prev</a><span>|</span><a href="#40580914">next</a><span>|</span><label class="collapse" for="c-40578111">[-]</label><label class="expand" for="c-40578111">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me to revisit displacement mapping — probably not going to be a replacement for the problem that author is trying to solve but simpler and kind of fun.<p>I wrote a kind of cool music visualizer for SoundJam perhaps 25 years ago I called &quot;Eclipse&quot;. Input data was an array of levels (probably integers) across some range of audible frequencies — a left and right channel.<p>Think of the eclipsed sun with corona ejections — that was what I was going for. The music data was the &quot;ejections&quot;. The frequency of the data determined where around the disc of the sun it would appear.<p>Over time the ejecta moved away from the sun and soon disappeared as they &quot;cooled&quot; to black — the initial color of the ejecta being white for the strongest signals — yellow, orange, red, brown when weaker. (Think of the black body curve.)<p>I had to keep a circular buffer of the sound data values (an array of arrays) large enough to represent how much time the ejecta would &quot;live&quot; before disappearing to black.<p>In any event, the whole display of the &quot;eclipse&quot;, ejecta, was just a displacement map. I had pre-calculated a bitmap where the value for each &quot;pixel&quot; was an offset into the buffer of sound level values. &quot;pixels&quot; close to the surface of the sun would have offsets to the new data coming in, pixels further out would have offsets into the tail of the buffer that was about to expire. With the circular, radial aspect of the ejecta, there was some math involved in generating the displacement values in order to map from essentially a radial space to a cartesian one.<p>With that established as described, the main loop simply pulled in new sound values, over-wrote the oldest values in the circular buffer with the new and then iterated row and column-wise over the displacement map, grabbing the corresponding sound data value, mapped it to a color in a fixed palette and pushed that color into display buffer.<p>Although not as &quot;flashy&quot; as other visualizers, there was I thought a calm beauty to it. And it very much represented the music data (you know, as opposed to later visualizers where, even when presented with silence, they seemed to be unable to settle down).</div><br/></div></div><div id="40580914" class="c"><input type="checkbox" id="c-40580914" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#40578111">prev</a><span>|</span><a href="#40577342">next</a><span>|</span><label class="collapse" for="c-40580914">[-]</label><label class="expand" for="c-40580914">[5 more]</label></div><br/><div class="children"><div class="content">Do no GPUs or 3D libraries include a function to do this by just horizontally walking each line of a circle and mapping the X,Y from the texture to the &quot;3D&quot; position on the sphere?<p>It seems like a magnificent waste of resources to rotate and project a million vertices for the triangles of this thing when a sphere is a circle, the algorithm for drawing a circle is simple, and you only need to walk horizontally and then drop down a line and keep going until you&#x27;ve drawn every line.<p>I remember doing stuff like this in the late 80s to precompute magnifying lenses, like the one in Second Reality.</div><br/><div id="40581901" class="c"><input type="checkbox" id="c-40581901" checked=""/><div class="controls bullet"><span class="by">azornathogron</span><span>|</span><a href="#40580914">parent</a><span>|</span><a href="#40581853">next</a><span>|</span><label class="collapse" for="c-40581901">[-]</label><label class="expand" for="c-40581901">[1 more]</label></div><br/><div class="children"><div class="content">GPUs don&#x27;t rasterise line-by-line like old software renderers, and they basically only know how to rasterise triangles. If you&#x27;re rendering on GPU then I think the approach in the article is pretty good, despite its apparent complexity.<p>This is a great series of blog posts about how GPU based rendering is structured (long but excellent if you&#x27;re interested):<p><a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-graphics-pipeline-2011-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2011&#x2F;07&#x2F;09&#x2F;a-trip-through-the-...</a><p>Part 6 is about rasterisation.</div><br/></div></div><div id="40581853" class="c"><input type="checkbox" id="c-40581853" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#40580914">parent</a><span>|</span><a href="#40581901">prev</a><span>|</span><a href="#40580979">next</a><span>|</span><label class="collapse" for="c-40581853">[-]</label><label class="expand" for="c-40581853">[1 more]</label></div><br/><div class="children"><div class="content">GPT gave me this, which seems to work when I ran it:<p><pre><code>    public void DrawSphere(int centerX, int centerY, int radius, double angle)
    {
     for (int y = -radius; y &lt;= radius; y++)
     {
      for (int x = -radius; x &lt;= radius; x++)
      {
       if (x * x + y * y &lt;= radius * radius)
       {
        double z = Math.Sqrt(radius * radius - x * x - y * y);
  
        double xRot = x * Math.Cos(angle) - z * Math.Sin(angle);
        double zRot = x * Math.Sin(angle) + z * Math.Cos(angle);
  
        double u = 0.5 + (Math.Atan2(zRot, xRot) &#x2F; (2 * Math.PI));
        double v = 0.5 - (Math.Asin(y &#x2F; (double)radius) &#x2F; Math.PI);
        int textureX = (int)(u * _textureWidth) % _textureWidth;
        int textureY = (int)(v * _textureHeight) % _textureHeight;
  
        Rgba32 color = _texture[textureX, textureY];
        SetPixel(centerX + x, centerY + y, color);
       }
      }
     }
    }</code></pre></div><br/></div></div><div id="40580979" class="c"><input type="checkbox" id="c-40580979" checked=""/><div class="controls bullet"><span class="by">gloggy</span><span>|</span><a href="#40580914">parent</a><span>|</span><a href="#40581853">prev</a><span>|</span><a href="#40577342">next</a><span>|</span><label class="collapse" for="c-40580979">[-]</label><label class="expand" for="c-40580979">[2 more]</label></div><br/><div class="children"><div class="content">Probably due to the fact that spherical linear interpolation would be slower and more specialised than linear interpolation; which the entire render pipeline is already constructed to handle. You can draw a perfect, anti-aliased sphere using a single shader program and 1 triangle.</div><br/><div id="40581177" class="c"><input type="checkbox" id="c-40581177" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#40580914">root</a><span>|</span><a href="#40580979">parent</a><span>|</span><a href="#40577342">next</a><span>|</span><label class="collapse" for="c-40581177">[-]</label><label class="expand" for="c-40581177">[1 more]</label></div><br/><div class="children"><div class="content">I only found this so far:<p><a href="https:&#x2F;&#x2F;computergraphics.stackexchange.com&#x2F;questions&#x2F;5090&#x2F;fast-approximation-of-spherical-texture-coordinates" rel="nofollow">https:&#x2F;&#x2F;computergraphics.stackexchange.com&#x2F;questions&#x2F;5090&#x2F;fa...</a></div><br/></div></div></div></div></div></div><div id="40577342" class="c"><input type="checkbox" id="c-40577342" checked=""/><div class="controls bullet"><span class="by">ygra</span><span>|</span><a href="#40580914">prev</a><span>|</span><a href="#40580149">next</a><span>|</span><label class="collapse" for="c-40577342">[-]</label><label class="expand" for="c-40577342">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of this article on a similar approach: <a href="https:&#x2F;&#x2F;bgolus.medium.com&#x2F;rendering-a-sphere-on-a-quad-13c92025570c" rel="nofollow">https:&#x2F;&#x2F;bgolus.medium.com&#x2F;rendering-a-sphere-on-a-quad-13c92...</a></div><br/></div></div><div id="40580149" class="c"><input type="checkbox" id="c-40580149" checked=""/><div class="controls bullet"><span class="by">robertsdionne</span><span>|</span><a href="#40577342">prev</a><span>|</span><a href="#40581841">next</a><span>|</span><label class="collapse" for="c-40580149">[-]</label><label class="expand" for="c-40580149">[1 more]</label></div><br/><div class="children"><div class="content">Love the gas giant and the corresponding page: <a href="https:&#x2F;&#x2F;emildziewanowski.com&#x2F;flowfields&#x2F;" rel="nofollow">https:&#x2F;&#x2F;emildziewanowski.com&#x2F;flowfields&#x2F;</a></div><br/></div></div><div id="40581841" class="c"><input type="checkbox" id="c-40581841" checked=""/><div class="controls bullet"><span class="by">ToJans</span><span>|</span><a href="#40580149">prev</a><span>|</span><a href="#40580041">next</a><span>|</span><label class="collapse" for="c-40581841">[-]</label><label class="expand" for="c-40581841">[1 more]</label></div><br/><div class="children"><div class="content">This feels very complicated and a lot like yak shaving. I would have just created a programmed shader with some n-D perlin noise on top.<p>Effects like swirl etc are easy, and you can use a range of parameters for the noise input: polar angle, azimut, time, 3d coordinates, ...
Configuration could be easy by adding things like hue etc</div><br/></div></div><div id="40580041" class="c"><input type="checkbox" id="c-40580041" checked=""/><div class="controls bullet"><span class="by">fyrn_</span><span>|</span><a href="#40581841">prev</a><span>|</span><a href="#40577383">next</a><span>|</span><label class="collapse" for="c-40580041">[-]</label><label class="expand" for="c-40580041">[1 more]</label></div><br/><div class="children"><div class="content">Icosphere would unwrap a lot more smoothly, and has regular vertex positons and element sizes.
Not trival to unwrap, but doable</div><br/></div></div><div id="40577383" class="c"><input type="checkbox" id="c-40577383" checked=""/><div class="controls bullet"><span class="by">RIMR</span><span>|</span><a href="#40580041">prev</a><span>|</span><a href="#40576566">next</a><span>|</span><label class="collapse" for="c-40577383">[-]</label><label class="expand" for="c-40577383">[2 more]</label></div><br/><div class="children"><div class="content">Wow, this article is cool, but it loads a lot of shaders the more you scroll down the page, and unless you are on a very powerful computer, your browser might slow to a crawl.</div><br/><div id="40578078" class="c"><input type="checkbox" id="c-40578078" checked=""/><div class="controls bullet"><span class="by">karolist</span><span>|</span><a href="#40577383">parent</a><span>|</span><a href="#40576566">next</a><span>|</span><label class="collapse" for="c-40578078">[-]</label><label class="expand" for="c-40578078">[1 more]</label></div><br/><div class="children"><div class="content">What is a very powerful computer? Would any laptop no older than 10 years with integrated graphics have trouble rendering these?</div><br/></div></div></div></div><div id="40576566" class="c"><input type="checkbox" id="c-40576566" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40577383">prev</a><span>|</span><a href="#40578619">next</a><span>|</span><label class="collapse" for="c-40576566">[-]</label><label class="expand" for="c-40576566">[5 more]</label></div><br/><div class="children"><div class="content">Most of the images of moons in this post resemble false-color imagery, and don’t reflect how these moons would actually appear to human eyes. Just fyi.</div><br/><div id="40578662" class="c"><input type="checkbox" id="c-40578662" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#40576566">parent</a><span>|</span><a href="#40579631">next</a><span>|</span><label class="collapse" for="c-40578662">[-]</label><label class="expand" for="c-40578662">[2 more]</label></div><br/><div class="children"><div class="content">Man, HNers have an expert opinion on everything. This person appears to be weighing in on the color accuracy of fictional artwork moons.</div><br/><div id="40580148" class="c"><input type="checkbox" id="c-40580148" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40576566">root</a><span>|</span><a href="#40578662">parent</a><span>|</span><a href="#40579631">next</a><span>|</span><label class="collapse" for="c-40580148">[-]</label><label class="expand" for="c-40580148">[1 more]</label></div><br/><div class="children"><div class="content">From TFA:<p>&gt; I’m taking a similar approach in my project. The skybox I’m working on will feature an animated moon and a gas giant, adding some extra visual flair. Both planets will spin, and in addition, the gas giant will feature moving atmospheric currents. Normally, these motions are too subtle to be seen, but I’ll accelerate them for greater visual impact.<p>Sounds like they&#x27;re attempting to create background imagery for a video game or movie or something. Maybe they&#x27;re fine adjusting the colors just like they adjusted the wind speeds. But they should know that they&#x27;re trading off accuracy.</div><br/></div></div></div></div><div id="40579631" class="c"><input type="checkbox" id="c-40579631" checked=""/><div class="controls bullet"><span class="by">ncallaway</span><span>|</span><a href="#40576566">parent</a><span>|</span><a href="#40578662">prev</a><span>|</span><a href="#40578647">next</a><span>|</span><label class="collapse" for="c-40579631">[-]</label><label class="expand" for="c-40579631">[1 more]</label></div><br/><div class="children"><div class="content">Yea! And Picasso&#x27;s paintings don&#x27;t use an accurate perspective projection and don&#x27;t reflect how his subjects would actually appear to human eyes, either!</div><br/></div></div></div></div><div id="40578619" class="c"><input type="checkbox" id="c-40578619" checked=""/><div class="controls bullet"><span class="by">antiquark</span><span>|</span><a href="#40576566">prev</a><span>|</span><label class="collapse" for="c-40578619">[-]</label><label class="expand" for="c-40578619">[2 more]</label></div><br/><div class="children"><div class="content">That page literally hung my Win10 PC. I had to power cycle to recover!</div><br/><div id="40578704" class="c"><input type="checkbox" id="c-40578704" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#40578619">parent</a><span>|</span><label class="collapse" for="c-40578704">[-]</label><label class="expand" for="c-40578704">[1 more]</label></div><br/><div class="children"><div class="content">That’s definitely not an issue with the page.</div><br/></div></div></div></div></div></div></div></div></div></body></html>