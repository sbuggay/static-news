<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719306050237" as="style"/><link rel="stylesheet" href="styles.css?v=1719306050237"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://letsencrypt.org/2024/06/24/ntpd-rs-deployment.html">More Memory Safety for Let&#x27;s Encrypt: Deploying ntpd-rs</a> <span class="domain">(<a href="https://letsencrypt.org">letsencrypt.org</a>)</span></div><div class="subtext"><span>Dunedan</span> | <span>133 comments</span></div><br/><div><div id="40780813" class="c"><input type="checkbox" id="c-40780813" checked=""/><div class="controls bullet"><span class="by">NelsonMinar</span><span>|</span><a href="#40781167">next</a><span>|</span><label class="collapse" for="c-40780813">[-]</label><label class="expand" for="c-40780813">[2 more]</label></div><br/><div class="children"><div class="content">I like the idea of NTPD in Rust. Is there anything to read about how well ntpd-rs performs? Would love a new column for chrony&#x27;s comparison: <a href="https:&#x2F;&#x2F;chrony-project.org&#x2F;comparison.html" rel="nofollow">https:&#x2F;&#x2F;chrony-project.org&#x2F;comparison.html</a><p>Particularly interested in the performance stats, how well the daemon keeps time in the face of various network problems. Chrony is very good at this. Some of the other NTP implementations (not on that chart) are so bad they shouldn&#x27;t be used in production.</div><br/><div id="40785066" class="c"><input type="checkbox" id="c-40785066" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40780813">parent</a><span>|</span><a href="#40781167">next</a><span>|</span><label class="collapse" for="c-40785066">[-]</label><label class="expand" for="c-40785066">[1 more]</label></div><br/><div class="children"><div class="content">In our internal testing we are very close to Chrony with our synchronization performance, some of our testing data and an explanation of our algorithm is published in our repository: <a href="https:&#x2F;&#x2F;github.com&#x2F;pendulum-project&#x2F;ntpd-rs&#x2F;tree&#x2F;main&#x2F;docs&#x2F;algorithm">https:&#x2F;&#x2F;github.com&#x2F;pendulum-project&#x2F;ntpd-rs&#x2F;tree&#x2F;main&#x2F;docs&#x2F;a...</a><p>Given the amount of testing we (and other parties) have done, and given the strong theoretical foundation of our algorithm I’m pretty confident we’d do well in many production environments. If you do find any performance issues though, we’d love to hear about them!</div><br/></div></div></div></div><div id="40781167" class="c"><input type="checkbox" id="c-40781167" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#40780813">prev</a><span>|</span><a href="#40781555">next</a><span>|</span><label class="collapse" for="c-40781167">[-]</label><label class="expand" for="c-40781167">[12 more]</label></div><br/><div class="children"><div class="content">Unlike say, coreutils, ntp is something very far from being a solved problem and the memory safety of the solution is unfortunately going to play second fiddle to its efficacy.<p>For example, we only use chrony because it’s so much better than whatever came with your system (especially on virtual machines). ntpd-rs would have to come at least within spitting distance of chrony’s time keeping abilities to even be up for consideration.<p>(And I say this as a massive rust aficionado using it for both work and pleasure.)</div><br/><div id="40785328" class="c"><input type="checkbox" id="c-40785328" checked=""/><div class="controls bullet"><span class="by">hi-v-rocknroll</span><span>|</span><a href="#40781167">parent</a><span>|</span><a href="#40781355">next</a><span>|</span><label class="collapse" for="c-40785328">[-]</label><label class="expand" for="c-40785328">[2 more]</label></div><br/><div class="children"><div class="content">You might be doing too much work at the wrong level of abstraction. VMs should use host clock synchronization. It requires some work and coordination, but it eliminates the need for ntp in VMs entirely.<p>Hosts should then be synced using PTP or a proper NTP local stratum (just get a proper GNSS source for each DC if you have then funds).<p><a href="https:&#x2F;&#x2F;tsn.readthedocs.io&#x2F;timesync.html" rel="nofollow">https:&#x2F;&#x2F;tsn.readthedocs.io&#x2F;timesync.html</a><p>Deploy chrony to bare metal servers wherever possible.</div><br/><div id="40785612" class="c"><input type="checkbox" id="c-40785612" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40785328">parent</a><span>|</span><a href="#40781355">next</a><span>|</span><label class="collapse" for="c-40785612">[-]</label><label class="expand" for="c-40785612">[1 more]</label></div><br/><div class="children"><div class="content">Our project also includes a PTP implementation, statime (<a href="https:&#x2F;&#x2F;github.com&#x2F;pendulum-project&#x2F;statime&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;pendulum-project&#x2F;statime&#x2F;</a>), that includes a Linux daemon. Our implementation should work as well or even better than what linuxptp does, but it&#x27;s still early days. One thing to note though is that NTP can be made to be just as precise (if not more precise), given the right access to hardware (unfortunately most hardware that does timestamping only does so for PTP packets). The reason for this precision is simple: NTP can use multiple sources of time, whereas PTP by design only uses a single source. This gives NTP more information about the current time and thus allows it to more precisely estimate what the current time is. The thing with relying purely on GNSS is that those signals can be (and are in practice) disrupted relatively easily. This is why time synchronization over the internet makes sense, even for large data centers. And doing secure time synchronization over the internet is only practically possible using NTP&#x2F;NTS at this time. But there is no one size fits all solution for time synchonization in general.</div><br/></div></div></div></div><div id="40781355" class="c"><input type="checkbox" id="c-40781355" checked=""/><div class="controls bullet"><span class="by">syncsynchalt</span><span>|</span><a href="#40781167">parent</a><span>|</span><a href="#40785328">prev</a><span>|</span><a href="#40785088">next</a><span>|</span><label class="collapse" for="c-40781355">[-]</label><label class="expand" for="c-40781355">[8 more]</label></div><br/><div class="children"><div class="content">The biggest danger in NTP isn&#x27;t memory safety (though good on this project for tackling it), it&#x27;s<p>(a) the inherent risks in implementing a protocol based on trivially spoofable UDP that can be used to do amplification and reflection<p>and<p>(b) emergent resonant behavior from your implementation that will inadvertently DDOS critical infrastructure when all 100m installed copies of your daemon decide to send a packet to NIST in the same microsecond.<p>I&#x27;m happy to see more ntpd implementations but always a little worried.</div><br/><div id="40785438" class="c"><input type="checkbox" id="c-40785438" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40781355">parent</a><span>|</span><a href="#40781951">next</a><span>|</span><label class="collapse" for="c-40785438">[-]</label><label class="expand" for="c-40785438">[1 more]</label></div><br/><div class="children"><div class="content">I agree that amplification and reflection definitely are worries, which is why we are working towards NTS becoming a default on the internet. NTS would prevent responses by a server from a spoofed packet and at the same time would make sure that NTP clients can finally start trusting their time instead of hoping that there are no malicious actors anywhere near them. You can read about it on our blog as well: <a href="https:&#x2F;&#x2F;tweedegolf.nl&#x2F;en&#x2F;blog&#x2F;122&#x2F;a-safe-internet-requires-secure-time" rel="nofollow">https:&#x2F;&#x2F;tweedegolf.nl&#x2F;en&#x2F;blog&#x2F;122&#x2F;a-safe-internet-requires-s...</a><p>One thing to note about amplification: amplification has always been something that NTP developers have been especially sensitive to. I would say though that protocols like QUIC and DNS have far greater amplification risks. Meanwhile, our server implementation forces that responses can never be bigger than the requests that initiated them, meaning that no amplification is possible at all. Even if we would have allowed bigger responses, I cannot imagine NTP responses being much bigger than two or three times their related request. Meanwhile I&#x27;ve seen numbers for DNS all the way up to 180 times the request payload.<p>As for your worries: I think being a little cautious keeps you alert and can prevent mistakes, but I also feel that we&#x27;ve gone out of our way to not do anything crazy and hopefully we will be a net positive in the end. I hope you do give us a try and let us know if you find anything suspicious. If you have any feedback we&#x27;d love to hear it!</div><br/></div></div><div id="40781951" class="c"><input type="checkbox" id="c-40781951" checked=""/><div class="controls bullet"><span class="by">timmytokyo</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40781355">parent</a><span>|</span><a href="#40785438">prev</a><span>|</span><a href="#40785088">next</a><span>|</span><label class="collapse" for="c-40781951">[-]</label><label class="expand" for="c-40781951">[6 more]</label></div><br/><div class="children"><div class="content">I really wish more internet infrastructure would switch to using NTS. It addresses these kinds of issues.</div><br/><div id="40782057" class="c"><input type="checkbox" id="c-40782057" checked=""/><div class="controls bullet"><span class="by">jaas</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40781951">parent</a><span>|</span><a href="#40783533">next</a><span>|</span><label class="collapse" for="c-40782057">[-]</label><label class="expand" for="c-40782057">[1 more]</label></div><br/><div class="children"><div class="content">ntpd-rs support NTS, I agree it would be great if more people used it!</div><br/></div></div><div id="40783533" class="c"><input type="checkbox" id="c-40783533" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40781951">parent</a><span>|</span><a href="#40782057">prev</a><span>|</span><a href="#40785088">next</a><span>|</span><label class="collapse" for="c-40783533">[-]</label><label class="expand" for="c-40783533">[4 more]</label></div><br/><div class="children"><div class="content">Never heard of it. Shockingly little on wikipedia for example.</div><br/><div id="40785655" class="c"><input type="checkbox" id="c-40785655" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40783533">parent</a><span>|</span><a href="#40784730">next</a><span>|</span><label class="collapse" for="c-40785655">[-]</label><label class="expand" for="c-40785655">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m afraid this is a pretty common sentiment. NTS has been out for several years already and is implemented in several implementations (including our ntpd-rs implementation, and others like chrony and ntpsec). Yet its usage is low and meanwhile the fully unsecured and easily spoofable NTP remains the default, in effect allowing anyone to manipulate your clock almost trivially (see our blog post about this: <a href="https:&#x2F;&#x2F;tweedegolf.nl&#x2F;en&#x2F;blog&#x2F;121&#x2F;hacking-time" rel="nofollow">https:&#x2F;&#x2F;tweedegolf.nl&#x2F;en&#x2F;blog&#x2F;121&#x2F;hacking-time</a>). Hopefully we can get NTS to the masses more quickly in the coming years and slowly start to decrease our dependency on unsigned NTP traffic, just as we did with unencrypted HTTP traffic.</div><br/></div></div><div id="40784730" class="c"><input type="checkbox" id="c-40784730" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40783533">parent</a><span>|</span><a href="#40785655">prev</a><span>|</span><a href="#40785088">next</a><span>|</span><label class="collapse" for="c-40784730">[-]</label><label class="expand" for="c-40784730">[2 more]</label></div><br/><div class="children"><div class="content">Yeah. Seems it doesn’t even have its own article there.<p>Only a short mention in the main article about NTP itself:<p>&gt; Network Time Security (NTS) is a secure version of NTPv4 with TLS and AEAD. The main improvement over previous attempts is that a separate &quot;key establishment&quot; server handles the heavy asymmetric cryptography, which needs to be done only once. If the server goes down, previous users would still be able to fetch time without fear of MITM. NTS is currently supported by several time servers, including Cloudflare. It is supported by NTPSec and chrony.</div><br/><div id="40785484" class="c"><input type="checkbox" id="c-40785484" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40781167">root</a><span>|</span><a href="#40784730">parent</a><span>|</span><a href="#40785088">next</a><span>|</span><label class="collapse" for="c-40785484">[-]</label><label class="expand" for="c-40785484">[1 more]</label></div><br/><div class="children"><div class="content">&quot;RFC 8915: Network Time Security for the Network Time Protocol&quot; (2020) <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8915.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8915.html</a><p>&quot;NTS RFC Published: New Standard to Ensure Secure Time on the Internet&quot; (2020) <a href="https:&#x2F;&#x2F;www.internetsociety.org&#x2F;blog&#x2F;2020&#x2F;10&#x2F;nts-rfc-published-new-standard-to-ensure-secure-time-on-the-internet&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.internetsociety.org&#x2F;blog&#x2F;2020&#x2F;10&#x2F;nts-rfc-publish...</a> :<p>&gt; <i>NTS is basically two loosely coupled sub-protocols that together add security to NTP. NTS Key Exchange (NTS-KE) is based on TLS 1.3 and performs the initial authentication of the server and exchanges security tokens with the client. The NTP client then uses these tokens in NTP extension fields for authentication and integrity checking of the NTP protocol messages that exchange time information.</i><p>From &quot;Simple Precision Time Protocol at Meta&quot; <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39306209">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39306209</a> :<p>&gt; <i>How does SPTP compare to CERN&#x27;s WhiteRabbit, which is built on PTP</i> [and NTP NTS]<i>?</i><p>White Rabbit Project: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;White_Rabbit_Project" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;White_Rabbit_Project</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40785088" class="c"><input type="checkbox" id="c-40785088" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40781167">parent</a><span>|</span><a href="#40781355">prev</a><span>|</span><a href="#40781555">next</a><span>|</span><label class="collapse" for="c-40785088">[-]</label><label class="expand" for="c-40785088">[1 more]</label></div><br/><div class="children"><div class="content">I would encourage you to take a look at some of our testing data and an explanation of our algorithm in our repository (<a href="https:&#x2F;&#x2F;github.com&#x2F;pendulum-project&#x2F;ntpd-rs&#x2F;tree&#x2F;main&#x2F;docs&#x2F;algorithm">https:&#x2F;&#x2F;github.com&#x2F;pendulum-project&#x2F;ntpd-rs&#x2F;tree&#x2F;main&#x2F;docs&#x2F;a...</a>). I think we are very much in spitting distance of Chrony in terms of synchronization performance, sometimes even beating Chrony. But we’d love for more people to try our algorithm in their infrastructure and report back. The more data the better.</div><br/></div></div></div></div><div id="40781555" class="c"><input type="checkbox" id="c-40781555" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40781167">prev</a><span>|</span><a href="#40780759">next</a><span>|</span><label class="collapse" for="c-40781555">[-]</label><label class="expand" for="c-40781555">[56 more]</label></div><br/><div class="children"><div class="content">This seems like a weird place to be touting memory safety.<p>It&#x27;s ntpd, it doesn&#x27;t seem like a place for any sort of attack vector and it&#x27;s been running on many VMs without exploding memory for a while now.<p>I&#x27;d think there are far more critical components to rewrite in a memory safe language than the clock synchronizer.</div><br/><div id="40781863" class="c"><input type="checkbox" id="c-40781863" checked=""/><div class="controls bullet"><span class="by">jaas</span><span>|</span><a href="#40781555">parent</a><span>|</span><a href="#40781767">next</a><span>|</span><label class="collapse" for="c-40781863">[-]</label><label class="expand" for="c-40781863">[40 more]</label></div><br/><div class="children"><div class="content">I&#x27;m the person driving this.<p>NTP is worth moving to a memory safe language but of course it&#x27;s not the single most critical thing in our entire stack to make memory safe. I don&#x27;t think anyone is claiming that. It&#x27;s simply the first component that got to production status, a good place to start.<p>NTP is a component worth moving to a memory safe language because it&#x27;s a widely used critical service on a network boundary. A quick Google for NTP vulnerabilities will show you that there are plenty of memory safety vulnerabilities lurking in C NTP implementations:<p><a href="https:&#x2F;&#x2F;www.cvedetails.com&#x2F;vulnerability-list&#x2F;vendor_id-2153&#x2F;NTP.html" rel="nofollow">https:&#x2F;&#x2F;www.cvedetails.com&#x2F;vulnerability-list&#x2F;vendor_id-2153...</a><p>Some of these are severe, some aren&#x27;t. It&#x27;s only a matter of time though until another severe one pops up.<p>I don&#x27;t think any critical service on a network boundary should be written in C&#x2F;C++, we know too much at this point to think that&#x27;s a good idea. It will take a while to change that across the board though.<p>If I had to pick the most important thing in the context of Let&#x27;s Encrypt to move to a memory safe language it would be DNS. We have been investing heavily in Hickory DNS but it&#x27;s not ready for production at Let&#x27;s Encrypt yet (our usage of DNS is a bit more complex than the average use case).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hickory-dns&#x2F;hickory-dns">https:&#x2F;&#x2F;github.com&#x2F;hickory-dns&#x2F;hickory-dns</a><p>Work is proceeding at a rapid pace and I expect Hickory DNS to be deployed at Let&#x27;s Encrypt in 2025.</div><br/><div id="40782125" class="c"><input type="checkbox" id="c-40782125" checked=""/><div class="controls bullet"><span class="by">twothreeone</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781863">parent</a><span>|</span><a href="#40781961">next</a><span>|</span><label class="collapse" for="c-40782125">[-]</label><label class="expand" for="c-40782125">[2 more]</label></div><br/><div class="children"><div class="content">It continues to astonish me how little people care (i.e., it triggers the $%&amp;@ out of me). I really appreciate the professionalism and cool rationale when faced with absolute ignorance of how shaky a foundation our &quot;modern&quot; software stack is built upon. This is a huge service to the community, kudos to you and many others slowly grinding out progress!</div><br/><div id="40786111" class="c"><input type="checkbox" id="c-40786111" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782125">parent</a><span>|</span><a href="#40781961">next</a><span>|</span><label class="collapse" for="c-40786111">[-]</label><label class="expand" for="c-40786111">[1 more]</label></div><br/><div class="children"><div class="content">Lol, shaky indeed.  A business person once said, &quot;can you imagine if machine engineer (like auto makers) behave like software engineering?&quot;.<p>Seems no digital system is truly secure. Moving foundational code to memory safe seems like a good first step.</div><br/></div></div></div></div><div id="40782479" class="c"><input type="checkbox" id="c-40782479" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781863">parent</a><span>|</span><a href="#40781961">prev</a><span>|</span><a href="#40781767">next</a><span>|</span><label class="collapse" for="c-40782479">[-]</label><label class="expand" for="c-40782479">[23 more]</label></div><br/><div class="children"><div class="content">Why are C and C++ all of a sudden unsafe? Did I miss something?<p>What is safe now? JavaScript? PyTorch?</div><br/><div id="40785462" class="c"><input type="checkbox" id="c-40785462" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782479">parent</a><span>|</span><a href="#40782615">next</a><span>|</span><label class="collapse" for="c-40785462">[-]</label><label class="expand" for="c-40785462">[1 more]</label></div><br/><div class="children"><div class="content">They have been unsafe from their very early days, Multics got a higher security score than UNIX thanks to PL&#x2F;I, and C.A.R Hoare has addressed C&#x27;s existence on his Turing Award in 1980, while Fran Allen has also made similar remarks back in the day.</div><br/></div></div><div id="40782615" class="c"><input type="checkbox" id="c-40782615" checked=""/><div class="controls bullet"><span class="by">ghshephard</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782479">parent</a><span>|</span><a href="#40785462">prev</a><span>|</span><a href="#40782495">next</a><span>|</span><label class="collapse" for="c-40782615">[-]</label><label class="expand" for="c-40782615">[18 more]</label></div><br/><div class="children"><div class="content">One of the major drivers (if not <i>the</i> driver) for the creation of Rust the fact that C is not a memory-safe language.<p>This has been known for decades, but it wasn&#x27;t until 2010 that a serious attempt at writing a new system-language that was memory safe was attempted and got traction - Rust.<p><a href="https:&#x2F;&#x2F;kruschecompany.com&#x2F;rust-language-concise-overview&#x2F;#:~:text=Rust%20was%20released%20in%202010,did%20and%20Rust%20was%20born" rel="nofollow">https:&#x2F;&#x2F;kruschecompany.com&#x2F;rust-language-concise-overview&#x2F;#:...</a>.</div><br/><div id="40785474" class="c"><input type="checkbox" id="c-40785474" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782615">parent</a><span>|</span><a href="#40782652">next</a><span>|</span><label class="collapse" for="c-40785474">[-]</label><label class="expand" for="c-40785474">[1 more]</label></div><br/><div class="children"><div class="content">I would consider that serious attempts have been made since 1961, however all of them failed in the presence of a free beer OS, with free beer unsafe compilers.<p>The getting traction part is the relevance part.</div><br/></div></div><div id="40782652" class="c"><input type="checkbox" id="c-40782652" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782615">parent</a><span>|</span><a href="#40785474">prev</a><span>|</span><a href="#40782495">next</a><span>|</span><label class="collapse" for="c-40782652">[-]</label><label class="expand" for="c-40782652">[16 more]</label></div><br/><div class="children"><div class="content">How is C not memory safe? If I access memory I didn&#x27;t allocate the OS shuts the program down. Is that not memory safety?<p>(Unless you&#x27;re running it on bare metal ...)</div><br/><div id="40782806" class="c"><input type="checkbox" id="c-40782806" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40782717">next</a><span>|</span><label class="collapse" for="c-40782806">[-]</label><label class="expand" for="c-40782806">[4 more]</label></div><br/><div class="children"><div class="content">This is not a question for HN at this point. It’s like asking why SQL query forming via string concatenation of user inputs is unsafe.<p>Google it, C memory boundary issues have been a problem for security forever.</div><br/><div id="40784727" class="c"><input type="checkbox" id="c-40784727" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782806">parent</a><span>|</span><a href="#40782717">next</a><span>|</span><label class="collapse" for="c-40784727">[-]</label><label class="expand" for="c-40784727">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It’s like asking why SQL query forming via string concatenation of user inputs is unsafe.</i><p>To be honest, that&#x27;s a surprisingly deep question, and the answer is something I&#x27;m yet to see <i>any</i> developer I worked with understand. For example, did you know that SQL injection and XSS are really the same problem? And so is using template systems[0] like Mustache?<p>In my experience, very few people appreciate that the issue with &quot;SQL query forming via string concatenation&quot; isn&#x27;t in the &quot;SQL&quot; part, but in the &quot;string concatenation&quot; part.<p>--<p>[0] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Template_processor" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Template_processor</a></div><br/><div id="40785436" class="c"><input type="checkbox" id="c-40785436" checked=""/><div class="controls bullet"><span class="by">cowsandmilk</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40784727">parent</a><span>|</span><a href="#40784759">next</a><span>|</span><label class="collapse" for="c-40785436">[-]</label><label class="expand" for="c-40785436">[1 more]</label></div><br/><div class="children"><div class="content">Really, the problem is in combining tainted input strings with string concatenation. If you have certain guarantees on the input strings, concatenation can be safe. That said, I still wouldn’t use it since there are few guarantees that future code wouldn’t introduce tainted strings.</div><br/></div></div><div id="40784759" class="c"><input type="checkbox" id="c-40784759" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40784727">parent</a><span>|</span><a href="#40785436">prev</a><span>|</span><a href="#40782717">next</a><span>|</span><label class="collapse" for="c-40784759">[-]</label><label class="expand" for="c-40784759">[1 more]</label></div><br/><div class="children"><div class="content">The problem that causes it is in photo cases that a flat string representation kind of mixes code and data. And therefore escaping (such as not allowing quotes in the user input to terminate quotes in your query, or not allowing html tags to be opened or closed by user input, nor allowing html attributes to be opened or closed by the user input, etc) is needed.</div><br/></div></div></div></div></div></div><div id="40782717" class="c"><input type="checkbox" id="c-40782717" checked=""/><div class="controls bullet"><span class="by">rictic</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40782806">prev</a><span>|</span><a href="#40783326">next</a><span>|</span><label class="collapse" for="c-40782717">[-]</label><label class="expand" for="c-40782717">[1 more]</label></div><br/><div class="children"><div class="content">Memory errors can be exploited by a clever adversary to control your process in a variety of unpleasant ways, see: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety#Types_of_memory_errors" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety#Types_of_memory_...</a></div><br/></div></div><div id="40783326" class="c"><input type="checkbox" id="c-40783326" checked=""/><div class="controls bullet"><span class="by">patmorgan23</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40782717">prev</a><span>|</span><a href="#40785418">next</a><span>|</span><label class="collapse" for="c-40783326">[-]</label><label class="expand" for="c-40783326">[1 more]</label></div><br/><div class="children"><div class="content">I think you have a missunderstanding on what memory safety is.<p>Memory safety means that your program is free of memory corruption bugs (such as buff overflow or under flow bugs) that could be used to retrieve data the user isn&#x27;t supposed to have, or can be used to inject code&#x2F;commands that then get run in the programs process. These don&#x27;t get shut down by the OS because the program is interacting with its own memory.</div><br/></div></div><div id="40785418" class="c"><input type="checkbox" id="c-40785418" checked=""/><div class="controls bullet"><span class="by">dataking</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40783326">prev</a><span>|</span><a href="#40782732">next</a><span>|</span><label class="collapse" for="c-40785418">[-]</label><label class="expand" for="c-40785418">[1 more]</label></div><br/><div class="children"><div class="content">Highly recommend Alex Gaynor&#x27;s intro to memory unsafety <a href="https:&#x2F;&#x2F;alexgaynor.net&#x2F;2019&#x2F;aug&#x2F;12&#x2F;introduction-to-memory-unsafety-for-vps-of-engineering&#x2F;" rel="nofollow">https:&#x2F;&#x2F;alexgaynor.net&#x2F;2019&#x2F;aug&#x2F;12&#x2F;introduction-to-memory-un...</a></div><br/></div></div><div id="40782732" class="c"><input type="checkbox" id="c-40782732" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40785418">prev</a><span>|</span><a href="#40783162">next</a><span>|</span><label class="collapse" for="c-40782732">[-]</label><label class="expand" for="c-40782732">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what memory safety refers to.</div><br/></div></div><div id="40783162" class="c"><input type="checkbox" id="c-40783162" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40782732">prev</a><span>|</span><a href="#40782721">next</a><span>|</span><label class="collapse" for="c-40783162">[-]</label><label class="expand" for="c-40783162">[5 more]</label></div><br/><div class="children"><div class="content">&gt;  If I access memory I didn&#x27;t allocate the OS shuts the program down.<p>The real problem is when you access memory that <i>did</i> allocate.</div><br/><div id="40783640" class="c"><input type="checkbox" id="c-40783640" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40783162">parent</a><span>|</span><a href="#40782721">next</a><span>|</span><label class="collapse" for="c-40783640">[-]</label><label class="expand" for="c-40783640">[4 more]</label></div><br/><div class="children"><div class="content">So we need a new flag for gcc that writes zeros to any block of allocated memory before malloc returns, not a new language.</div><br/><div id="40784102" class="c"><input type="checkbox" id="c-40784102" checked=""/><div class="controls bullet"><span class="by">KMag</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40783640">parent</a><span>|</span><a href="#40785911">next</a><span>|</span><label class="collapse" for="c-40784102">[-]</label><label class="expand" for="c-40784102">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d probably want an alternative libc implementation rather than a compiler flag.<p>However, calloc everywhere won&#x27;t save you from smashing the stack or pointer type confusion (a common source of JavaScript exploits).  Very rarely is leftover data from freed memory the source of an exploit.</div><br/></div></div><div id="40785911" class="c"><input type="checkbox" id="c-40785911" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40783640">parent</a><span>|</span><a href="#40784102">prev</a><span>|</span><a href="#40784124">next</a><span>|</span><label class="collapse" for="c-40785911">[-]</label><label class="expand" for="c-40785911">[1 more]</label></div><br/><div class="children"><div class="content">We have that already. There are still other problems that exist.</div><br/></div></div><div id="40784124" class="c"><input type="checkbox" id="c-40784124" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40783640">parent</a><span>|</span><a href="#40785911">prev</a><span>|</span><a href="#40782721">next</a><span>|</span><label class="collapse" for="c-40784124">[-]</label><label class="expand" for="c-40784124">[1 more]</label></div><br/><div class="children"><div class="content">That wouldn&#x27;t make it safe.  It would just make it crash in a different way, and still be vulnerable to exploitation by an attacker.</div><br/></div></div></div></div></div></div><div id="40784114" class="c"><input type="checkbox" id="c-40784114" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782652">parent</a><span>|</span><a href="#40782721">prev</a><span>|</span><a href="#40782495">next</a><span>|</span><label class="collapse" for="c-40784114">[-]</label><label class="expand" for="c-40784114">[1 more]</label></div><br/><div class="children"><div class="content">No, that&#x27;s a security vulnerability waiting for someone to exploit.</div><br/></div></div></div></div></div></div><div id="40782495" class="c"><input type="checkbox" id="c-40782495" checked=""/><div class="controls bullet"><span class="by">dequan</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782479">parent</a><span>|</span><a href="#40782615">prev</a><span>|</span><a href="#40785046">next</a><span>|</span><label class="collapse" for="c-40782495">[-]</label><label class="expand" for="c-40782495">[1 more]</label></div><br/><div class="children"><div class="content">All of a sudden? They&#x27;ve been unsafe for decades, it&#x27;s just that you had less of a choice then.</div><br/></div></div><div id="40785046" class="c"><input type="checkbox" id="c-40785046" checked=""/><div class="controls bullet"><span class="by">runiq</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782479">parent</a><span>|</span><a href="#40782495">prev</a><span>|</span><a href="#40784617">next</a><span>|</span><label class="collapse" for="c-40785046">[-]</label><label class="expand" for="c-40785046">[1 more]</label></div><br/><div class="children"><div class="content">Tcl</div><br/></div></div></div></div></div></div><div id="40781767" class="c"><input type="checkbox" id="c-40781767" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#40781555">parent</a><span>|</span><a href="#40781863">prev</a><span>|</span><a href="#40781598">next</a><span>|</span><label class="collapse" for="c-40781767">[-]</label><label class="expand" for="c-40781767">[7 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s been running on many VMs without exploding memory for a while now<p>Most of the security bugs we hear about don&#x27;t cause random crashes on otherwise healthy machines, because that tends to get them noticed and fixed. It&#x27;s the ones that require complicated steps to trigger that are really scary. When I look at NTP, I see a service that:<p>- runs as root<p>- talks to the network<p>- doesn&#x27;t usually authenticate its traffic<p>- uses a bespoke binary packet format<p>- almost all network security depends on (for checking cert expiration)<p>That looks to me like an <i>excellent</i> candidate for a memory-safe reimplementation.</div><br/><div id="40781837" class="c"><input type="checkbox" id="c-40781837" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781767">parent</a><span>|</span><a href="#40781598">next</a><span>|</span><label class="collapse" for="c-40781837">[-]</label><label class="expand" for="c-40781837">[6 more]</label></div><br/><div class="children"><div class="content">&gt; runs as root<p>ntpd can (and should) run as a user<p>&gt; talks to the network<p>Makes outbound requests to the network.  For it to be compromised, the network itself or a downstream server needs to be compromised.  That&#x27;s very different from something like hosting an http server.<p>&gt; doesn&#x27;t usually authenticate its traffic<p>Yes it does. ntp uses TLS to communicate with it&#x27;s well known locations.<p>&gt; uses a bespoke binary packet format<p>Not great but also see above where it&#x27;s talking to well known locations authenticated and running as a user.<p>It&#x27;s a service that to be compromised requires state level interference.</div><br/><div id="40782473" class="c"><input type="checkbox" id="c-40782473" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781837">parent</a><span>|</span><a href="#40782830">next</a><span>|</span><label class="collapse" for="c-40782473">[-]</label><label class="expand" for="c-40782473">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think NTP uses TLS by default. The closest equivalent I can find online is NTS, which was only standardized in 2020 (and for which I can’t find clear adoption numbers).<p>(But regardless: “the transport layer is secure” is not a good reason to leave memory unsafe code on the network boundary. Conventional wisdom in these settings is to do the “defense in depth” thing and assume that transport security can be circumvented.)</div><br/><div id="40782525" class="c"><input type="checkbox" id="c-40782525" checked=""/><div class="controls bullet"><span class="by">mcpherrinm</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40782473">parent</a><span>|</span><a href="#40782830">next</a><span>|</span><label class="collapse" for="c-40782525">[-]</label><label class="expand" for="c-40782525">[1 more]</label></div><br/><div class="children"><div class="content">ntpd-rs supports NTS and we (Let’s Encrypt) are using it a little bit. But it is far from having any wide adoption yet.<p>There aren’t many public NTS servers: <a href="https:&#x2F;&#x2F;netfuture.ch&#x2F;public-nts-server-list&#x2F;" rel="nofollow">https:&#x2F;&#x2F;netfuture.ch&#x2F;public-nts-server-list&#x2F;</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;jauderho&#x2F;nts-servers">https:&#x2F;&#x2F;github.com&#x2F;jauderho&#x2F;nts-servers</a> have some listed.</div><br/></div></div></div></div><div id="40782830" class="c"><input type="checkbox" id="c-40782830" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781837">parent</a><span>|</span><a href="#40782473">prev</a><span>|</span><a href="#40782147">next</a><span>|</span><label class="collapse" for="c-40782830">[-]</label><label class="expand" for="c-40782830">[1 more]</label></div><br/><div class="children"><div class="content">Ntp does not use TLS widely. It’s also a UDP protocol which makes it subject to spoofing attacks without a compromised network (no protection from kernel network stack verifying TCP sequence numbers).</div><br/></div></div><div id="40782147" class="c"><input type="checkbox" id="c-40782147" checked=""/><div class="controls bullet"><span class="by">franga2000</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781837">parent</a><span>|</span><a href="#40782830">prev</a><span>|</span><a href="#40784606">next</a><span>|</span><label class="collapse" for="c-40782147">[-]</label><label class="expand" for="c-40782147">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a service that to be compromised requires state level interference<p>For servers it&#x27;s definitely harder, although definitely not only state-level, but another big issue could be client-side. NTP servers can be set by DHCP, so the admin of any network you connect to could exploit such a bug against you. And once you have code execution on a desktop OS, all bets are off, even if you&#x27;re not under the primary UID.<p>It&#x27;s not the most important threat vector, but it also doesn&#x27;t seem as difficult as some of the other system services to rewrite, so I&#x27;d say it was a good first step for the memory-safe-everything project.</div><br/></div></div><div id="40784606" class="c"><input type="checkbox" id="c-40784606" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781837">parent</a><span>|</span><a href="#40782147">prev</a><span>|</span><a href="#40781598">next</a><span>|</span><label class="collapse" for="c-40784606">[-]</label><label class="expand" for="c-40784606">[1 more]</label></div><br/><div class="children"><div class="content">The network is just a bunch of strangers in a meet me room.</div><br/></div></div></div></div></div></div><div id="40781598" class="c"><input type="checkbox" id="c-40781598" checked=""/><div class="controls bullet"><span class="by">luma</span><span>|</span><a href="#40781555">parent</a><span>|</span><a href="#40781767">prev</a><span>|</span><a href="#40782119">next</a><span>|</span><label class="collapse" for="c-40781598">[-]</label><label class="expand" for="c-40781598">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s present on loads of systems, it&#x27;s a very common service to offer, it&#x27;s a reasonably well-constrained use case, and the fact that nobody thinks about it might be a good reason to think about it. They can&#x27;t boil the ocean but one service at a time is a reasonable approach.<p>I&#x27;ll flip the question around, why not start at ntpd?</div><br/><div id="40781780" class="c"><input type="checkbox" id="c-40781780" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781598">parent</a><span>|</span><a href="#40782119">next</a><span>|</span><label class="collapse" for="c-40781780">[-]</label><label class="expand" for="c-40781780">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ll flip the question around, why not start at ntpd?<p>Easy, because there are loads of critical infrastructure written in C++ that is commonly executed on pretty much every VM and exposed in such a way that vulnerabilities are disasterous.<p>For example, JEMalloc is used by nearly every app compiled in *nix.<p>Perhaps systemd which is just about everywhere running everything.<p>Maybe sshd, heaven knows it&#x27;s been the root of many attacks.</div><br/><div id="40784139" class="c"><input type="checkbox" id="c-40784139" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781780">parent</a><span>|</span><a href="#40783622">next</a><span>|</span><label class="collapse" for="c-40784139">[-]</label><label class="expand" for="c-40784139">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>For example, JEMalloc is used by nearly every app compiled in </i>nix.*<p>JEmalloc is used by very very very few apps compiled for *nix.  That&#x27;s a conscious decision that an app developer needs to make (and few would bother without specialized needs) or a distro packager needs to shoehorn into their package builds (which most&#x2F;all would not do).</div><br/></div></div><div id="40783622" class="c"><input type="checkbox" id="c-40783622" checked=""/><div class="controls bullet"><span class="by">hedora</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40781780">parent</a><span>|</span><a href="#40784139">prev</a><span>|</span><a href="#40782119">next</a><span>|</span><label class="collapse" for="c-40783622">[-]</label><label class="expand" for="c-40783622">[3 more]</label></div><br/><div class="children"><div class="content">There’s a nice pure-rust ssh client&#x2F;server already.<p>Systemd should just be scrapped.  This week’s wtf “systemd-tmpfile  —-purge” intentionally changed its behavior to “rm -rf &#x2F;home”.  Confirmed not-a-bug.  There are dozens of other comparable screwups in that stack, even ignoring the long list of CVEs (including dns and ntp, I think).  Rust can’t fix that.<p>I haven’t heard of any issues with jemalloc, though that seems reasonable (assuming calling rust from C doesn’t break compiler inlining, etc).</div><br/><div id="40783780" class="c"><input type="checkbox" id="c-40783780" checked=""/><div class="controls bullet"><span class="by">forbiddenlake</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40783622">parent</a><span>|</span><a href="#40784247">next</a><span>|</span><label class="collapse" for="c-40783780">[-]</label><label class="expand" for="c-40783780">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Confirmed not-a-bug.<p>Initially closed not a bug, but then Poettering overruled that decision and implemented a fix which is already released.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;commit&#x2F;e76015738942246db70f444b3567afd1b132f824">https:&#x2F;&#x2F;github.com&#x2F;systemd&#x2F;systemd&#x2F;commit&#x2F;e76015738942246db7...</a></div><br/></div></div><div id="40784247" class="c"><input type="checkbox" id="c-40784247" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40781555">root</a><span>|</span><a href="#40783622">parent</a><span>|</span><a href="#40783780">prev</a><span>|</span><a href="#40782119">next</a><span>|</span><label class="collapse" for="c-40784247">[-]</label><label class="expand" for="c-40784247">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There’s a nice pure-rust ssh client&#x2F;server already.<p>Prod ready, audited, non-buggy in actual use? And if so, do you have a link so I can start test-deploying it?</div><br/></div></div></div></div></div></div></div></div><div id="40782119" class="c"><input type="checkbox" id="c-40782119" checked=""/><div class="controls bullet"><span class="by">lambdaone</span><span>|</span><a href="#40781555">parent</a><span>|</span><a href="#40781598">prev</a><span>|</span><a href="#40785549">next</a><span>|</span><label class="collapse" for="c-40782119">[-]</label><label class="expand" for="c-40782119">[1 more]</label></div><br/><div class="children"><div class="content">NTP is a ubiquitous network service that runs directly exposed to the Internet, and that seems to me like a good thing to harden. Making NTP more secure does not stop anyone else from working on any other project.</div><br/></div></div><div id="40785549" class="c"><input type="checkbox" id="c-40785549" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40781555">parent</a><span>|</span><a href="#40782119">prev</a><span>|</span><a href="#40780759">next</a><span>|</span><label class="collapse" for="c-40785549">[-]</label><label class="expand" for="c-40785549">[1 more]</label></div><br/><div class="children"><div class="content">I do think that memory safety is important for any network service. The probability of something going horribly wrong when a network packet is parsed in a wrong way is just too high. NTP typically does have more access to the host OS than other daemons, with it needing to adjust the system clock.<p>Of course, there are many other services that could be made memory safe, and maybe there is some sort of right or smart order in which we should make our core network infrastructure memory safe. But everyone has their own priorities here, and I feel like this could end up being an endless debate of whatabout-ism. There is no right place to start, other than to just start.<p>Aside from memory safety though, I feel like our implementation has a strong focus on security in general. We try and make choices that make our implementation more robust than what was out there previously. Aside from that, I think the NTP space has had an under supply of implementations, with there only being a few major open source implementations (like ntpd, ntpsec and chrony). Meanwhile, NTP is one of those pieces of technology at the core of many of the things we do on the modern internet. Knowing the current time is one of these things you just need in order to trust many of the things we take for granted (without knowledge of the current time, your TLS connection could never be trusted). I think NTP definitely deserves this attention and could use a bunch more attention.</div><br/></div></div></div></div><div id="40780759" class="c"><input type="checkbox" id="c-40780759" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40781555">prev</a><span>|</span><a href="#40785354">next</a><span>|</span><label class="collapse" for="c-40780759">[-]</label><label class="expand" for="c-40780759">[28 more]</label></div><br/><div class="children"><div class="content">Why does your ntpd have a json dependency?</div><br/><div id="40780845" class="c"><input type="checkbox" id="c-40780845" checked=""/><div class="controls bullet"><span class="by">danudey</span><span>|</span><a href="#40780759">parent</a><span>|</span><a href="#40785191">next</a><span>|</span><label class="collapse" for="c-40780845">[-]</label><label class="expand" for="c-40780845">[13 more]</label></div><br/><div class="children"><div class="content">This is a good question to ask, especially in the age of everything pulling in every possible dependency just to get one library function or an `isNumeric()` convenience function.<p>The answer is that there is observability functionality which provides its results as JSON output via a UNIX socket[0]. As far as I can see, there&#x27;s no other JSON functionality anywhere else in the code, so this is just to allow for easily querying (and parsing) the daemon&#x27;s internal state.<p>(I&#x27;m not convinced that JSON is the way to go here, but that&#x27;s the answer to the question)<p>[0] <a href="https:&#x2F;&#x2F;docs.ntpd-rs.pendulum-project.org&#x2F;development&#x2F;code-structure&#x2F;#observability-task" rel="nofollow">https:&#x2F;&#x2F;docs.ntpd-rs.pendulum-project.org&#x2F;development&#x2F;code-s...</a></div><br/><div id="40781101" class="c"><input type="checkbox" id="c-40781101" checked=""/><div class="controls bullet"><span class="by">motrm</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780845">parent</a><span>|</span><a href="#40783155">next</a><span>|</span><label class="collapse" for="c-40781101">[-]</label><label class="expand" for="c-40781101">[11 more]</label></div><br/><div class="children"><div class="content">If the pieces of state are all well known at build time - and trusted in terms of their content - it may be feasible to print out JSON &#x27;manually&#x27; as it were, instead of needing to use a JSON library,<p><pre><code>  print &quot;{&quot;
  print &quot;\&quot;some_state\&quot;: \&quot;&quot;;
  print GlobalState.Something.to_text();
  print &quot;\&quot;, &quot;;
  print &quot;\&quot;count_of_frobs\&quot;: &quot;;
  print GlobalState.FrobsCounter;
  print &quot;}&quot;;
</code></pre>
Whether it&#x27;s worth doing this just to rid yourself of a dependency... who knows.</div><br/><div id="40783950" class="c"><input type="checkbox" id="c-40783950" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781101">parent</a><span>|</span><a href="#40781248">next</a><span>|</span><label class="collapse" for="c-40783950">[-]</label><label class="expand" for="c-40783950">[3 more]</label></div><br/><div class="children"><div class="content">This looks like the exact kind of thing that results in unexpected exploits.</div><br/><div id="40784331" class="c"><input type="checkbox" id="c-40784331" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40783950">parent</a><span>|</span><a href="#40781248">next</a><span>|</span><label class="collapse" for="c-40784331">[-]</label><label class="expand" for="c-40784331">[2 more]</label></div><br/><div class="children"><div class="content">Hand rolled JSON input processing, yes. Hand rolled JSON output, no.<p>You&#x27;re gonna have a hard time exploiting a text file output that happens to be JSON.</div><br/><div id="40785101" class="c"><input type="checkbox" id="c-40785101" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40784331">parent</a><span>|</span><a href="#40781248">next</a><span>|</span><label class="collapse" for="c-40785101">[-]</label><label class="expand" for="c-40785101">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re gonna have a hard time exploiting a text file output that happens to be JSON.<p>If you’re not escaping double quotes in strings in your hand-rolled JSON output, and some string you’re outputting happens to be something an attacker can control, then the attacker can inject arbitrary JSON.  Which probably won’t compromise the program doing the outputting, but it could cause whatever <i>reads</i> the JSON to do something unexpected, which might be a vulnerability, depending on the design of the system.<p>If you are escaping double quotes, then you avoid most problems, but you also need to escape control characters to ensure the JSON isn’t invalid.  And also check for invalid UTF-8, if you’re using a language where strings aren’t guaranteed to be valid UTF-8.  If an attacker can make the output invalid JSON, then they can cause a denial of service, which is typically not considered a severe vulnerability but is still a problem.  Realistically, this is more likely to happen by accident than because of an attacker, but then it’s still an annoying bug.<p>Oh, and if you happen to be using C and writing the JSON to a fixed-size buffer with snprintf (I’ve seen this specific pattern more than once), then the output can be silently truncated, which could also potentially allow JSON injection.<p>Handling all that correctly doesn’t require <i>that</i> much code, but it’s not completely trivial either.  In practice, when I see code hand-roll JSON output, it usually doesn’t even bother escaping anything.  Which is usually fine, because the data being written is usually not attacker-controlled at all.  For now.  But code has a tendency to get adapted and reused in unexpected ways.</div><br/></div></div></div></div></div></div><div id="40781248" class="c"><input type="checkbox" id="c-40781248" checked=""/><div class="controls bullet"><span class="by">syncsynchalt</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781101">parent</a><span>|</span><a href="#40783950">prev</a><span>|</span><a href="#40781306">next</a><span>|</span><label class="collapse" for="c-40781248">[-]</label><label class="expand" for="c-40781248">[4 more]</label></div><br/><div class="children"><div class="content">Even better to just use TSV.  Hand-rolling XML or JSON is always a smell to me, even if it&#x27;s visibly safe.</div><br/><div id="40785435" class="c"><input type="checkbox" id="c-40785435" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781248">parent</a><span>|</span><a href="#40781623">next</a><span>|</span><label class="collapse" for="c-40785435">[-]</label><label class="expand" for="c-40785435">[1 more]</label></div><br/><div class="children"><div class="content">Hand-rolling TSV is no better. The average TSV generator does not pay any mind to data cleaning, and quoting &#x2F; escaping is non-standard, so what the other wide will do with it is basically playing russian roulette.<p>Using C0 codes is likely safer at least in the sense that you will <i>probably</i> think to check for those and there is no reason whatsoever for them to be found in user data.</div><br/></div></div><div id="40781623" class="c"><input type="checkbox" id="c-40781623" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781248">parent</a><span>|</span><a href="#40785435">prev</a><span>|</span><a href="#40781306">next</a><span>|</span><label class="collapse" for="c-40781623">[-]</label><label class="expand" for="c-40781623">[2 more]</label></div><br/><div class="children"><div class="content">Do you mean TLV (tag-length-value)? I can&#x27;t figure out what TSV is.</div><br/><div id="40781670" class="c"><input type="checkbox" id="c-40781670" checked=""/><div class="controls bullet"><span class="by">FredFS456</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781623">parent</a><span>|</span><a href="#40781306">next</a><span>|</span><label class="collapse" for="c-40781670">[-]</label><label class="expand" for="c-40781670">[1 more]</label></div><br/><div class="children"><div class="content">Tab Separated Values, like CSV but tabs instead of commas.</div><br/></div></div></div></div></div></div><div id="40781306" class="c"><input type="checkbox" id="c-40781306" checked=""/><div class="controls bullet"><span class="by">fiedzia</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781101">parent</a><span>|</span><a href="#40781248">prev</a><span>|</span><a href="#40781428">next</a><span>|</span><label class="collapse" for="c-40781306">[-]</label><label class="expand" for="c-40781306">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the pieces of state are all well known at build time - and trusted in terms of their content<p>.. than use library, because you should not rely on the assumption that next developer adding one more piece to this code will magically remember to validate it with json spec.</div><br/><div id="40781887" class="c"><input type="checkbox" id="c-40781887" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781306">parent</a><span>|</span><a href="#40781428">next</a><span>|</span><label class="collapse" for="c-40781887">[-]</label><label class="expand" for="c-40781887">[1 more]</label></div><br/><div class="children"><div class="content">No magic necessary. Factor your hand-rolling into a function that returns a string (instead of printing as in the example), and write a test that parses it&#x27;s return with a proper JSON library. Assert that the parsing was successful and that the extracted values are correct. Ideally you&#x27;d use a property test.</div><br/></div></div></div></div><div id="40781428" class="c"><input type="checkbox" id="c-40781428" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781101">parent</a><span>|</span><a href="#40781306">prev</a><span>|</span><a href="#40783155">next</a><span>|</span><label class="collapse" for="c-40781428">[-]</label><label class="expand" for="c-40781428">[1 more]</label></div><br/><div class="children"><div class="content">That’s somewhat better than assembling, say, HTML or SQL out of text fragments, but it’s still not fantastic. A JSON output DSL would be better still—it wouldn’t have to be particularly complicated. (Shame those usually only come paired with parsers, libxo excepted.)</div><br/></div></div></div></div></div></div><div id="40785191" class="c"><input type="checkbox" id="c-40785191" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40780759">parent</a><span>|</span><a href="#40780845">prev</a><span>|</span><a href="#40780953">next</a><span>|</span><label class="collapse" for="c-40785191">[-]</label><label class="expand" for="c-40785191">[3 more]</label></div><br/><div class="children"><div class="content">I don’t think our dependency tree is perfect, but I think our dependencies are reasonable overall. We use JSON for transferring metrics data from our NTP daemon to our prometheus metrics daemon. We’ve made this split for security reasons, why have all the attack surface of a HTTP server in your NTP daemon? That didn’t make sense to us. Which is why we added a readonly unix socket to our NTP daemon that on connecting dumps a JSON blob and then closes the connection (i.e. doing as little as possible), which is then usable by our client tool and by our prometheus metrics daemon. That data transfer uses json, but could have used any data format. We’d be happy to accept pull requests to replace this data format with something else, but given budget and time constraints, I think what we came up with is pretty reasonable.</div><br/><div id="40785523" class="c"><input type="checkbox" id="c-40785523" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40785191">parent</a><span>|</span><a href="#40780953">next</a><span>|</span><label class="collapse" for="c-40785523">[-]</label><label class="expand" for="c-40785523">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re only dumping a string, couldn&#x27;t you replace this dependency with some string concatenation?</div><br/><div id="40785961" class="c"><input type="checkbox" id="c-40785961" checked=""/><div class="controls bullet"><span class="by">rnijveld</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40785523">parent</a><span>|</span><a href="#40780953">next</a><span>|</span><label class="collapse" for="c-40785961">[-]</label><label class="expand" for="c-40785961">[1 more]</label></div><br/><div class="children"><div class="content">Probably, but we still need to parse that string on the client side as well. If you’re willing to do the work I’m sure we would accept a pull request for it! There’s just so many things to do in so little time unfortunately. I think reducing our dependencies is a good thing, but our dependencies for JSON parsing&#x2F;writing are used so commonly in Rust and the way we use it hopefully prevents any major security issues that I don’t think this should be a high priority for us right now compared to the many things we could be doing.</div><br/></div></div></div></div></div></div><div id="40780953" class="c"><input type="checkbox" id="c-40780953" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#40780759">parent</a><span>|</span><a href="#40785191">prev</a><span>|</span><a href="#40785354">next</a><span>|</span><label class="collapse" for="c-40780953">[-]</label><label class="expand" for="c-40780953">[11 more]</label></div><br/><div class="children"><div class="content">Would you rather it had a JSON dependency to parse a config file, or yet another poorly thought out, ad-hoc homegrown config file format?</div><br/><div id="40783732" class="c"><input type="checkbox" id="c-40783732" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780953">parent</a><span>|</span><a href="#40781298">next</a><span>|</span><label class="collapse" for="c-40783732">[-]</label><label class="expand" for="c-40783732">[1 more]</label></div><br/><div class="children"><div class="content">JSON is a terrible configuration format since it doesn&#x27;t support comments.</div><br/></div></div><div id="40781298" class="c"><input type="checkbox" id="c-40781298" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780953">parent</a><span>|</span><a href="#40783732">prev</a><span>|</span><a href="#40780999">next</a><span>|</span><label class="collapse" for="c-40781298">[-]</label><label class="expand" for="c-40781298">[1 more]</label></div><br/><div class="children"><div class="content">&gt; yet another poorly thought out, ad-hoc homegrown config file format<p>OpenBSD style ntpd.conf:<p><pre><code>    servers 0.gentoo.pool.ntp.org
    servers 1.gentoo.pool.ntp.org
    servers 2.gentoo.pool.ntp.org
    servers 3.gentoo.pool.ntp.org

    constraints from &quot;https:&#x2F;&#x2F;www.google.com&quot;

    listen on *
</code></pre>
I mean,  there&#x27;s always the possibility that they used a common,  well known and pretty decent config file format.  In this particular case,  this shouldn&#x27;t be the thing that differentiates your ntpd implementation anyways.</div><br/></div></div><div id="40780999" class="c"><input type="checkbox" id="c-40780999" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780953">parent</a><span>|</span><a href="#40781298">prev</a><span>|</span><a href="#40781305">next</a><span>|</span><label class="collapse" for="c-40780999">[-]</label><label class="expand" for="c-40780999">[2 more]</label></div><br/><div class="children"><div class="content">It uses TOML for configuration.</div><br/><div id="40782798" class="c"><input type="checkbox" id="c-40782798" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780999">parent</a><span>|</span><a href="#40781305">next</a><span>|</span><label class="collapse" for="c-40782798">[-]</label><label class="expand" for="c-40782798">[1 more]</label></div><br/><div class="children"><div class="content">Cool, thats why this is a hypothetical question</div><br/></div></div></div></div><div id="40781305" class="c"><input type="checkbox" id="c-40781305" checked=""/><div class="controls bullet"><span class="by">amiga386</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780953">parent</a><span>|</span><a href="#40780999">prev</a><span>|</span><a href="#40783464">next</a><span>|</span><label class="collapse" for="c-40781305">[-]</label><label class="expand" for="c-40781305">[4 more]</label></div><br/><div class="children"><div class="content">Poorly thought out, ad-hoc homegrown config file format, please. Every time.<p>1. Code doesn&#x27;t change at the whims of others.<p>2. The <i>entire</i> parser for an INI-style config can be in about 20 lines of C<p>3. Attacker doesn&#x27;t also get to exploit code you&#x27;ve never read in the third party dependency (and its dependencies! The JSON dependency now wants to pull in the ICU library... I guess you&#x27;re linking to that, too)<p>4. Complexity of config file formats are usually format-independent, the feature-set of the format itself only <i>adds</i> complexity, rather than takes it away. To put it another way, is <i>this</i> any saner...<p><pre><code>    {&quot;user&quot;:&quot;ams&quot;,&quot;host&quot;:&quot;ALL&quot;,&quot;runas&quot;:[&quot;&#x2F;bin&#x2F;ls&quot;,&quot;&#x2F;bin&#x2F;df -h &#x2F;&quot;,&quot;&#x2F;bin&#x2F;date \&quot;\&quot;&quot;,&quot;&#x2F;usr&#x2F;bin&#x2F;&quot;,&quot;sudoedit &#x2F;etc&#x2F;hosts&quot;,&quot;OTHER_COMMANDS&quot;}
</code></pre>
... than ...<p><pre><code>    # I may be crazy mad but at least I can have comments!
    ams ALL=&#x2F;bin&#x2F;ls, &#x2F;bin&#x2F;df -h &#x2F;, &#x2F;bin&#x2F;date &quot;&quot;, &#x2F;usr&#x2F;bin&#x2F;, sudoedit &#x2F;etc&#x2F;hosts, OTHER_COMMANDS

</code></pre>
All the magic in the example is in what those values <i>are</i> and what they <i>imply</i>, the format doesn&#x27;t improve if you naively transpose it to JSON.<p>An example of an NTP server&#x27;s config:<p><pre><code>    # I can have comments too
    [Time]
    NTP=ntp.ubuntu.com
    RootDistanceMaxSec=5
    PollIntervalMinSec=32
    PollIntervalMaxSec=2048

</code></pre>
If you <i>just</i> want key-value pairs of strings&#x2F;ints, nothing more complex is needed. Using JSON is overdoing it.</div><br/><div id="40783027" class="c"><input type="checkbox" id="c-40783027" checked=""/><div class="controls bullet"><span class="by">vlakreeh</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781305">parent</a><span>|</span><a href="#40785000">next</a><span>|</span><label class="collapse" for="c-40783027">[-]</label><label class="expand" for="c-40783027">[1 more]</label></div><br/><div class="children"><div class="content">1. I can pin my json parser dependency and literally never update it again<p>2. And how many times have we seen 20 lines of C backfire with some sort of memory safety issue.<p>3. First off, i&#x27;d go out on a limb and say the number of attacks from a well-established (or even a naive one) rust json parsing library is dwarfed by the number of attacks from adhoc config parsers written in C with some overlooked memory safety issue.<p>4. Usually being the key word, tons of adhoc config formats have weird shit in them. With json (or yaml&#x2F;toml) you know what you&#x27;re getting into and you immediately know what you&#x27;re able and unable to do.</div><br/></div></div><div id="40785000" class="c"><input type="checkbox" id="c-40785000" checked=""/><div class="controls bullet"><span class="by">whytevuhuni</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781305">parent</a><span>|</span><a href="#40783027">prev</a><span>|</span><a href="#40784647">next</a><span>|</span><label class="collapse" for="c-40785000">[-]</label><label class="expand" for="c-40785000">[1 more]</label></div><br/><div class="children"><div class="content">I once saw an .ini for a log parser:<p><pre><code>    [Alarm]
    Name=Nginx Errors
    Pattern=&quot;[error] &lt;pid&gt;#&lt;tid&gt;: &lt;message&gt;&quot;
</code></pre>
The thing worked. Without any errors. And yet it took:<p><pre><code>    Pattern=&quot;[error] &lt;pid&gt;
</code></pre>
..and then considered the rest of the line a comment. It didn&#x27;t even error on the fact that the quotes were not closed.<p>Hand-rolling config formats is <i>hard</i>.</div><br/></div></div><div id="40784647" class="c"><input type="checkbox" id="c-40784647" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40781305">parent</a><span>|</span><a href="#40785000">prev</a><span>|</span><a href="#40783464">next</a><span>|</span><label class="collapse" for="c-40784647">[-]</label><label class="expand" for="c-40784647">[1 more]</label></div><br/><div class="children"><div class="content">I feel like using the incomprehensibly error-prone and inscrutable sudoers format as an example kinda argues against your point.<p>(I do agree that JSON is a terrible configuration file format, though.)</div><br/></div></div></div></div><div id="40783464" class="c"><input type="checkbox" id="c-40783464" checked=""/><div class="controls bullet"><span class="by">patmorgan23</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40780953">parent</a><span>|</span><a href="#40781305">prev</a><span>|</span><a href="#40785354">next</a><span>|</span><label class="collapse" for="c-40783464">[-]</label><label class="expand" for="c-40783464">[2 more]</label></div><br/><div class="children"><div class="content">Why isn&#x27;t there a decent parser in the standard library? More than 50% of programs will probably touch json at this point.</div><br/><div id="40785751" class="c"><input type="checkbox" id="c-40785751" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40780759">root</a><span>|</span><a href="#40783464">parent</a><span>|</span><a href="#40785354">next</a><span>|</span><label class="collapse" for="c-40785751">[-]</label><label class="expand" for="c-40785751">[1 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s stdlib is (at least notionally) forever. Things in the standard library (including core and alloc) get deprecated but must be maintained forever, which means that &quot;at this point&quot; isn&#x27;t enough.<p>In 2003 those programs would have used XML, in 1993 probably .INI files. Are you sure that despite all its shortcomings JSON is the end of history? I don&#x27;t believe you.<p>If you want &quot;at this point&quot; you can, as software does today, just use a crate. Unlike the stdlib, if next week Fonzie files are huge and by 2026 &quot;nobody&quot; is using JSON because Fonzie is cool, the JSON config crate merely becomes less popular.</div><br/></div></div></div></div></div></div></div></div><div id="40785354" class="c"><input type="checkbox" id="c-40785354" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#40780759">prev</a><span>|</span><a href="#40781564">next</a><span>|</span><label class="collapse" for="c-40785354">[-]</label><label class="expand" for="c-40785354">[1 more]</label></div><br/><div class="children"><div class="content">BGP probably should be the next.</div><br/></div></div><div id="40781564" class="c"><input type="checkbox" id="c-40781564" checked=""/><div class="controls bullet"><span class="by">_joel</span><span>|</span><a href="#40785354">prev</a><span>|</span><a href="#40781718">next</a><span>|</span><label class="collapse" for="c-40781564">[-]</label><label class="expand" for="c-40781564">[2 more]</label></div><br/><div class="children"><div class="content">Reading this reminded me of ntpsec, anyone actually use that?</div><br/><div id="40783119" class="c"><input type="checkbox" id="c-40783119" checked=""/><div class="controls bullet"><span class="by">move-on-by</span><span>|</span><a href="#40781564">parent</a><span>|</span><a href="#40781718">next</a><span>|</span><label class="collapse" for="c-40783119">[-]</label><label class="expand" for="c-40783119">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Debian transitioned to NTPSec with bookworm. The NTP package is just a dummy transitional package to that installs NTPsec.<p><a href="https:&#x2F;&#x2F;packages.debian.org&#x2F;bookworm&#x2F;net&#x2F;ntp" rel="nofollow">https:&#x2F;&#x2F;packages.debian.org&#x2F;bookworm&#x2F;net&#x2F;ntp</a></div><br/></div></div></div></div><div id="40781718" class="c"><input type="checkbox" id="c-40781718" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40781564">prev</a><span>|</span><a href="#40780829">next</a><span>|</span><label class="collapse" for="c-40781718">[-]</label><label class="expand" for="c-40781718">[4 more]</label></div><br/><div class="children"><div class="content">The problem with ntp isn&#x27;t the client, it&#x27;s the servers having to deal with forged UDP packets.  Will ntpd ever become TCP-only?  Sadly I&#x27;m not holding my breath.  I stopped running a public stratum 3 server ~10 years ago.</div><br/><div id="40781881" class="c"><input type="checkbox" id="c-40781881" checked=""/><div class="controls bullet"><span class="by">brohee</span><span>|</span><a href="#40781718">parent</a><span>|</span><a href="#40781775">next</a><span>|</span><label class="collapse" for="c-40781881">[-]</label><label class="expand" for="c-40781881">[2 more]</label></div><br/><div class="children"><div class="content">When one can make a stratum 1 server for $100, there is very little reason for the continuous existence of public NTP servers. ISP can offer the service to their customers, and any company with a semblance of IT dept can have its own stratum 1.</div><br/><div id="40785886" class="c"><input type="checkbox" id="c-40785886" checked=""/><div class="controls bullet"><span class="by">ssl-3</span><span>|</span><a href="#40781718">root</a><span>|</span><a href="#40781881">parent</a><span>|</span><a href="#40781775">next</a><span>|</span><label class="collapse" for="c-40785886">[-]</label><label class="expand" for="c-40785886">[1 more]</label></div><br/><div class="children"><div class="content">One can build a GPS-backed stratum 1 server for a lot less than $100 in hardware (and I have done so in the past).  It was a fun little project for me, but it involved a confluence of skillsets that many [especially smaller] companies may not collectively possess.  And even then, it needs to be documented so someone else can work on it, and that maintenance has to actually-happen, and it needs a view of the sky in order for it to chooch, and it also needs redundancy.  This takes time.  (And if this IT department doesn&#x27;t work for free, then the cost is very quickly a lot more than $100.)<p>And going full-assed with one or more actually-outside antennas can also be problematic, since it&#x27;s a Bad Day when (eg) grounding is done improperly and lightning comes by to fuck their shit up.<p>And ISPs can (and certainly should!) provide decent NTP servers.  That&#x27;s the logical place for shared servers, network-wise.  But the one&#x27;s choice of ISP is often limited by geography, and the most-viable ISP here stopped publishing what their NTP servers are -- if they still exist in a form that customers can use, they don&#x27;t publish this information.  (It wasn&#x27;t always this way and I remember using them years ago when they were more forthcoming.  They were shitty NTP servers with high jitter.  Good enough for some things, I suppose, but not as good as the members of the public NTP pool tend to be.)<p>I mean:  Many ISPs can&#x27;t even manage to handle DNS queries quickly.  When public servers like 8.8.8.8 and 1.1.1.1 (or the semi-public ones like 4.2.2.1) are faster than the ISP&#x27;s own servers, then that&#x27;s a problem.  And it&#x27;s a stupid problem, and it should not happen.  But it does happen.<p>So thus, public NTP servers are useful for many -- including those who have a tinkered-together NTP server with a GPS antenna in a window somewhere, where public servers can be used as backup.<p>It&#x27;s good to have options, and it&#x27;s nice that some organizations provide some options for the greater network.</div><br/></div></div></div></div><div id="40781775" class="c"><input type="checkbox" id="c-40781775" checked=""/><div class="controls bullet"><span class="by">Faaak</span><span>|</span><a href="#40781718">parent</a><span>|</span><a href="#40781881">prev</a><span>|</span><a href="#40780829">next</a><span>|</span><label class="collapse" for="c-40781775">[-]</label><label class="expand" for="c-40781775">[1 more]</label></div><br/><div class="children"><div class="content">On the contrary, I&#x27;m hosting a stratum 1 and 2 stratum 2s (at my previous company we offered 3 stratum 1s) on the ntp pool. It&#x27;s useful, used, and still needed :-)</div><br/></div></div></div></div></div></div></div></div></div></body></html>