<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706950856991" as="style"/><link rel="stylesheet" href="styles.css?v=1706950856991"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/n7space/aerugo">Aerugo – RTOS for aerospace uses written in Rust</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>38 comments</span></div><br/><div><div id="39235743" class="c"><input type="checkbox" id="c-39235743" checked=""/><div class="controls bullet"><span class="by">foundry27</span><span>|</span><a href="#39233375">next</a><span>|</span><label class="collapse" for="c-39235743">[-]</label><label class="expand" for="c-39235743">[5 more]</label></div><br/><div class="children"><div class="content">(n.b. The project looks awesome, and it’s awesome that it’s written in Rust and working well. Great job folks!)<p>I’ve been the managing functional safety engineer for several safety-critical real-time embedded systems and safety-related components&#x2F;SEooCs (including a RTOS), and something stood out to me after reading through the repository: This is not a safety-critical operating system, despite the project’s claim.<p>There was clearly requirements engineering and verification work done, and the authors are under absolutely no obligation to publish the requirements and methodologies. But there’s no safety manual &#x2F; integrator’s guide provided, no evidence of any qualitative or quantitative safety analysis or modelling at any abstraction level having been performed, no evidence of a safety concept, and no evidence of a safety case. I recognize that this is likely intended as a PoC from the description of it being exploratory to produce a “Lessons Learned” report, but the website for the ESA initiative that’s driving this development claims that “The design of the system will be guided to support potential future qualification activities”. If that was done, there should be evidence of some of all of those work products, because that’s how you support future qualification. You cannot retroactively sprinkle safety on top of a system that hasn’t been designed with safety in mind.</div><br/><div id="39236261" class="c"><input type="checkbox" id="c-39236261" checked=""/><div class="controls bullet"><span class="by">aknfffn</span><span>|</span><a href="#39235743">parent</a><span>|</span><a href="#39233375">next</a><span>|</span><label class="collapse" for="c-39236261">[-]</label><label class="expand" for="c-39236261">[4 more]</label></div><br/><div class="children"><div class="content">I’d love to learn more about this — can you recommended any resources for building something from the ground up with the relevant safety-critical considerations? Appreciate any pointers</div><br/><div id="39236767" class="c"><input type="checkbox" id="c-39236767" checked=""/><div class="controls bullet"><span class="by">kejaed</span><span>|</span><a href="#39235743">root</a><span>|</span><a href="#39236261">parent</a><span>|</span><a href="#39233375">next</a><span>|</span><label class="collapse" for="c-39236767">[-]</label><label class="expand" for="c-39236767">[3 more]</label></div><br/><div class="children"><div class="content">Here’s a decent textbook that covers the software side in aerospace (DO-178):<p><a href="https:&#x2F;&#x2F;www.amazon.ca&#x2F;Developing-Safety-Critical-Software-Practical-Compliance&#x2F;dp&#x2F;143981368X" rel="nofollow">https:&#x2F;&#x2F;www.amazon.ca&#x2F;Developing-Safety-Critical-Software-Pr...</a><p>You can read up on the system safety side in documents like ARP5754 and ARP4761 and hardware side in DO-254.</div><br/><div id="39236972" class="c"><input type="checkbox" id="c-39236972" checked=""/><div class="controls bullet"><span class="by">fallingmeat</span><span>|</span><a href="#39235743">root</a><span>|</span><a href="#39236767">parent</a><span>|</span><a href="#39233375">next</a><span>|</span><label class="collapse" for="c-39236972">[-]</label><label class="expand" for="c-39236972">[2 more]</label></div><br/><div class="children"><div class="content">Someone who spent that much time at CMC would know!<p>I also love her book.</div><br/><div id="39237078" class="c"><input type="checkbox" id="c-39237078" checked=""/><div class="controls bullet"><span class="by">kejaed</span><span>|</span><a href="#39235743">root</a><span>|</span><a href="#39236972">parent</a><span>|</span><a href="#39233375">next</a><span>|</span><label class="collapse" for="c-39237078">[-]</label><label class="expand" for="c-39237078">[1 more]</label></div><br/><div class="children"><div class="content">I learned lots, worked with some great people, and even certified a thing or two!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39233375" class="c"><input type="checkbox" id="c-39233375" checked=""/><div class="controls bullet"><span class="by">jiehong</span><span>|</span><a href="#39235743">prev</a><span>|</span><a href="#39236534">next</a><span>|</span><label class="collapse" for="c-39233375">[-]</label><label class="expand" for="c-39233375">[18 more]</label></div><br/><div class="children"><div class="content">Can someone clarify this part like I’m 5:<p>&gt; Its design is inspired by purely functional programming paradigm and transputers architecture.<p>&gt; RTOS is implemented in a form of an executor instead of classic scheduler and doesn&#x27;t support preemption. Executor runs tasklets, which are fine-grained units of computation, that execute a processing step in a finite amount of time.<p>Transputers seem to be a leftover technology from the 80s, and lack of preemption seems hard to reconcile with real time guarantees?</div><br/><div id="39234137" class="c"><input type="checkbox" id="c-39234137" checked=""/><div class="controls bullet"><span class="by">qayxc</span><span>|</span><a href="#39233375">parent</a><span>|</span><a href="#39236574">next</a><span>|</span><label class="collapse" for="c-39234137">[-]</label><label class="expand" for="c-39234137">[1 more]</label></div><br/><div class="children"><div class="content">As far as my very limited understanding goes, the transputer reference is simply referring to a highly parallel message-passing system based on message queues, not actual hardware implementations.<p>As for lack of preemption, that&#x27;s explained by the system not implementing a scheduler. The system &quot;just&quot; implements an executor.<p>An Executor is a component that handles subscriptions (e.g. to interrupts or events&#x2F;messages), services (both clients and servers), timers, and QoS events (deadline missed, invalid QoS request, task died&#x2F;unresponsive, etc.), which are  implemented as tasks (Aerugo calls them &quot;tasklets&quot;) and registered with the executor.<p>• Subscriptions are tasks that subscribe to a topic (of a message).<p>• Service servers are tasks that are invoked when a request from a client is received.<p>• Service clients are tasks that are invoked whenever a response from a server is received.<p>• Timers trigger when a timer expired.<p>• QoS events are fired when a deadline has been missed, a task died&#x2F;became unresponsive, and other stuff like a QoS request couldn&#x27;t be met, etc.<p>Aerugo supports a subset of these capabilities, namely message queues (for subscribers&#x2F;clients and producers&#x2F;servers), events (IRQs, h&#x2F;w signals, etc.), and cyclic execution (execute the task n-times or forever).<p>Scheduling - i.e. the priority of things - is handled by the user or built into the Executor itself. For Aerugo the former is the case, so if you need control over priorities and order of task execution, you&#x27;d have to implement it on top of it.<p>Now the realtime-part isn&#x27;t really affected by any of this. It still allows for weaker RT systems. RT just means there&#x27;s a time constraint on executed tasks. Weaker systems have average runtime guarantees (e.g. a tasks have to finish within a limit <i>on average</i>, i.e. outliers are allowed). Stronger systems are stricter in the sense that tasks <i>always</i> have to finish within the limit. The strongest systems even enforce an exact limit (that is, tasks aren&#x27;t even allowed to finish sooner - they have to take <i>exactly</i> a given amount of time).<p>Preemption is required if tasks have to be scheduled w.r.t. to different priorities, especiallyy in multi-threaded scenarios. Lack of it means that the executor will never interrupt a running task to execute tasks that take priority - at least from what I understand, which might be wrong.</div><br/></div></div><div id="39236574" class="c"><input type="checkbox" id="c-39236574" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#39233375">parent</a><span>|</span><a href="#39234137">prev</a><span>|</span><a href="#39237797">next</a><span>|</span><label class="collapse" for="c-39236574">[-]</label><label class="expand" for="c-39236574">[1 more]</label></div><br/><div class="children"><div class="content">A couple of things of note:<p>Run-to-completion scheduling is a thing in the real-time world. See for example Miro Samek&#x27;s book Practical UML Statecharts in C++.<p>XMOS makes real-time embedded CPUs supporting task-per-core architecture and hardware message passing. Commonly used in consumer real-time audio hardware, to pick one example. I believe some of the original Transputer people are involved.</div><br/></div></div><div id="39237797" class="c"><input type="checkbox" id="c-39237797" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#39233375">parent</a><span>|</span><a href="#39236574">prev</a><span>|</span><a href="#39233951">next</a><span>|</span><label class="collapse" for="c-39237797">[-]</label><label class="expand" for="c-39237797">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Executor runs tasklets, [...] that execute a processing step in a finite amount of time.<p>&gt; lack of preemption seems hard to reconcile with real time guarantees?<p>Depends on the requirements and the bounds of the finite time allowed and the enforcement of it. For example, Erlang claims to be soft real-time; it doesn&#x27;t have preemption, but any function call can result in yielding, and as a functional language there are no loops without calling functions.</div><br/></div></div><div id="39233951" class="c"><input type="checkbox" id="c-39233951" checked=""/><div class="controls bullet"><span class="by">flyinglizard</span><span>|</span><a href="#39233375">parent</a><span>|</span><a href="#39237797">prev</a><span>|</span><a href="#39236534">next</a><span>|</span><label class="collapse" for="c-39233951">[-]</label><label class="expand" for="c-39233951">[14 more]</label></div><br/><div class="children"><div class="content">No preemption makes this an organizer more than an RTOS.</div><br/><div id="39233993" class="c"><input type="checkbox" id="c-39233993" checked=""/><div class="controls bullet"><span class="by">csdreamer7</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39233951">parent</a><span>|</span><a href="#39236534">next</a><span>|</span><label class="collapse" for="c-39233993">[-]</label><label class="expand" for="c-39233993">[13 more]</label></div><br/><div class="children"><div class="content">Would you please explain more?</div><br/><div id="39234086" class="c"><input type="checkbox" id="c-39234086" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39233993">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39234086">[-]</label><label class="expand" for="c-39234086">[9 more]</label></div><br/><div class="children"><div class="content">No preemption means that any realtime guarantees are handled by user space, as the kernel relies on that yielding to hit time guarantees. It means it doesn&#x27;t have to do much of the &quot;difficult&quot; work for a realtime system.</div><br/><div id="39234586" class="c"><input type="checkbox" id="c-39234586" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39234086">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39234586">[-]</label><label class="expand" for="c-39234586">[8 more]</label></div><br/><div class="children"><div class="content">On a preemptive OS, all multitasking with (non-CPU) contended resources is, to a certain extent, cooperative.  If one task acquires a mutex and then never releases it, no amount of priority-inheritance, highest-locker semantics &amp;c. will fix that.  Making everything cooperative increases the analysis needed because the CPU becomes a manually managed contended resource.<p>In addition, while not being preemptive, it sounds like executors are expected to run in bounded time, and the system triggers an event when the time is exceeded.<p>Complete systems, not operating-systems, are realtime.  Operating systems can be non-realtime (most general purpose schedulers are completely unsuited for hard realtime systems), but at their best only make the design of realtime systems tractable.</div><br/><div id="39234814" class="c"><input type="checkbox" id="c-39234814" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39234586">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39234814">[-]</label><label class="expand" for="c-39234814">[7 more]</label></div><br/><div class="children"><div class="content">You are confusing deadlock with scheduling. Sure, deadlock can happen in the absence of &quot;cooperation&quot;. And lack of on-time scheduling can happen in a cooperatively scheduled system in the absence of the appropriate cooperation.<p>But scheduling has been considered by most kernel designers to be the responsible of the kernel, not the participants (i.e. preemptively scheduled threads not cooperatively).<p>Even if a thread is going to deadlock as soon as it starts running (again), there is a huge difference between that thread being scheduled at the right time and it not being scheduled. You can fix the former (deadlock) with better coding. You cannot fix the latter without fixing the kernel.</div><br/><div id="39235365" class="c"><input type="checkbox" id="c-39235365" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39234814">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39235365">[-]</label><label class="expand" for="c-39235365">[6 more]</label></div><br/><div class="children"><div class="content">&gt; You are confusing deadlock with scheduling. Sure, deadlock can happen in the absence of &quot;cooperation&quot;. And lack of on-time scheduling can happen in a cooperatively scheduled system in the absence of the appropriate cooperation.<p>I was describing situations much broader than deadlock.  The following pseudocode is not deadlock, but nevertheless a failure of cooperation:<p><pre><code>  WaitForMutex(m)
  DoSomeReallyLongComputation()
</code></pre>
My point was that the above code in a preemptively scheduled system is as damaging to all tasks that will contend for &quot;m&quot; as this code is in a cooperatively scheduled system:<p><pre><code>  DoSomeReallyLongComputation()
</code></pre>
&gt; But scheduling has been considered by most kernel designers to be the responsible of the kernel, not the participants (i.e. preemptively scheduled threads not cooperatively).<p>Yes and no.  Schedulers tend to have parameters.  Realtime systems will rely heavily on those parameters.  Those parameters will sometimes even include promises for thread T to not run for more than X amount of time in a period of Y time.<p>&gt; Even if a thread is going to deadlock as soon as it starts running (again), there is a huge difference between that thread being scheduled at the right time and it not being scheduled. You can fix the former (deadlock) with better coding. You cannot fix the latter without fixing the kernel.<p>This is true in a <i>preemptively</i> scheduled kernel.  It&#x27;s kind of tautological that fixing issues with resource X needs to fix the kernel IFF X is managed by the kernel.  See also my above paragraph about kernel scheduler parameters.<p>[edit]<p>Just saw who I was replying to.  I suspect that you and I have different visions of what a &quot;Real Time System&quot; is, given that I&#x27;m thinking industrial control and you&#x27;re probably thinking audio.  There&#x27;s definitely overlap in theory and discipline, but the hardware and software stacks are rather different.</div><br/><div id="39235458" class="c"><input type="checkbox" id="c-39235458" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39235365">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39235458">[-]</label><label class="expand" for="c-39235458">[5 more]</label></div><br/><div class="children"><div class="content">A kernel (because that&#x27;s where interrupt handlers are located) can ensure that a thread is scheduled with N usecs of when it &quot;ought to be&quot; (which could be based on some sort of time allocation algorithm, or simple priorities or whatever other scheme may be in use. The kernel can say &quot;oh look, it&#x27;s been N usecs, let&#x27;s check who is running and who is ready to run ... hey, time for Thread 2 to run&quot;. This is preemptive scheduling.<p>No cooperative scheduling system can ensure this.<p>Your example involves poorly designed code, which is not the responsibility of the scheduler. Its job is just to make sure that threads run when they &quot;ought to&quot; - it cannot protect against priority inversions in user space <i>and</i> ensure that RT guarantees are met (pick 1, and even then, you lose).</div><br/><div id="39235848" class="c"><input type="checkbox" id="c-39235848" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39235458">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39235848">[-]</label><label class="expand" for="c-39235848">[4 more]</label></div><br/><div class="children"><div class="content">You two are talking past each other.<p>They are saying that a real time application requires a transitive closure analysis of all cooperating partners to verify if service can be guaranteed.<p>A cooperative scheduler requires you to extend the transitive closure to all code in the system.<p>For a critical appliance where the appliance as a whole needs to guarantee service, this means your transitive closure already encompasses all code in the system, so you are not losing too much.<p>The advantage of preemptive scheduling is that it allows you to subdivide your applications so that you do not need to analyze everything in the system. You can restrict yourself to only considering direct and intentional interaction. This provides modularity advantages and allows you to provide guarantees to sub-components even in the presence of errors or malicious behavior in other components.<p>However, if you are doing whole system analysis anyways and the systems are simple enough to be tractable to analyze without decomposition, then a cooperative scheduler is adequate to ensure real time performance.</div><br/><div id="39236040" class="c"><input type="checkbox" id="c-39236040" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39235848">parent</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39236040">[-]</label><label class="expand" for="c-39236040">[3 more]</label></div><br/><div class="children"><div class="content">The original claim was:<p>&gt; On a preemptive OS, all multitasking with (non-CPU) contended resources is, to a certain extent, cooperative<p>This just isn&#x27;t correct.</div><br/><div id="39236125" class="c"><input type="checkbox" id="c-39236125" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39236040">parent</a><span>|</span><a href="#39236211">next</a><span>|</span><label class="collapse" for="c-39236125">[-]</label><label class="expand" for="c-39236125">[1 more]</label></div><br/><div class="children"><div class="content">“with contended resources” is the part you are misinterpreting. They are saying that two applications that contend on a resource must cooperate to operate properly.<p>As they clearly state later: “Making everything cooperative increases the analysis needed because the CPU becomes a manually managed contended resource.”<p>i.e. a cooperative scheduler makes all code contend on the CPU, thus requiring global cooperation.<p>Given that they are providing that case as establishing a new requirement (the CPU becomes a contended resource) they are clearly stating in the preemptive scheduler case that the CPU is not a contended resource and thus no global cooperation is required. Only if they contend on a resource do they need cooperation amongst the contending partys.<p>But again, if you are already doing a whole system analysis anyways, then the benefits are less pronounced.</div><br/></div></div><div id="39236211" class="c"><input type="checkbox" id="c-39236211" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39236040">parent</a><span>|</span><a href="#39236125">prev</a><span>|</span><a href="#39234078">next</a><span>|</span><label class="collapse" for="c-39236211">[-]</label><label class="expand" for="c-39236211">[1 more]</label></div><br/><div class="children"><div class="content">Veserv has correctly restated what I meant by my original comment (which I still stand by).  In my first reply, I used a mutex as an example for a contended resource.  A cooperative multitasking system just extends &quot;contended resource&quot; to include the CPU.<p>Just like you need to make sure you don&#x27;t hold a critical lock for too long in a preemptive multitasking system, you need to make sure you don&#x27;t run on the CPU for too long in a cooperative multitasking system.<p>[replying to GP so as to not fork this thread too much]<p>&gt; A kernel (because that&#x27;s where interrupt handlers are located) can ensure that a thread is scheduled with N usecs of when it &quot;ought to be&quot; (which could be based on some sort of time allocation algorithm, or simple priorities or whatever other scheme may be in use. The kernel can say &quot;oh look, it&#x27;s been N usecs, let&#x27;s check who is running and who is ready to run ... hey, time for Thread 2 to run&quot;. This is preemptive scheduling.<p>&gt; No cooperative scheduling system can ensure this.<p>Sure it can: just poll for preemption every N usecs.  You can even statically analyze the assembly code to calculate the maximum number of clock cycles between two points where you poll for preemption (in the event that your microcontroller has caches, you will want to use writethrough caching to help with this analysis).<p>&gt; Your example involves poorly designed code, which is not the responsibility of the scheduler. Its job is just to make sure that threads run when they &quot;ought to&quot; - it cannot protect against priority inversions in user space and ensure that RT guarantees are met (pick 1, and even then, you lose).<p>This was the whole point of that example.  A realtime scheduler only guarantees that a thread gets the CPU time it is promised.  CPI time is one of (potentially many) contended resources in a multitasking system.  It is so helpful because all tasks will be contending for CPU time and there are few other resources for which this is true (memory bandwidth, particularly on SMP systems immediately comes to mind).<p>To be clear: I like realtime schedulers.  The are great and simplify many things; the analyses of tasks that only contend for CPU are greatly simplified by them.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39234078" class="c"><input type="checkbox" id="c-39234078" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39233993">parent</a><span>|</span><a href="#39234086">prev</a><span>|</span><a href="#39236534">next</a><span>|</span><label class="collapse" for="c-39234078">[-]</label><label class="expand" for="c-39234078">[3 more]</label></div><br/><div class="children"><div class="content">What happens when a tasklet take too long?</div><br/><div id="39234897" class="c"><input type="checkbox" id="c-39234897" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39234078">parent</a><span>|</span><a href="#39234168">next</a><span>|</span><label class="collapse" for="c-39234897">[-]</label><label class="expand" for="c-39234897">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What happens when a tasklet take too long?<p>The same thing that happens when 1+1 == 3, or when a task tries to write to memory that it doesn&#x27;t have permissions for. The static analysis that your system relies on for correct behavior is no longer valid, so a hardware belt-and-suspender mechanism (a schedule overrun timer interrupt, a lockstep core check failure, or an MPU fault, respectively) resets or otherwise safe-states the failed ECU and safety is assured higher up in the system analysis.</div><br/></div></div><div id="39234168" class="c"><input type="checkbox" id="c-39234168" checked=""/><div class="controls bullet"><span class="by">qayxc</span><span>|</span><a href="#39233375">root</a><span>|</span><a href="#39234078">parent</a><span>|</span><a href="#39234897">prev</a><span>|</span><a href="#39236534">next</a><span>|</span><label class="collapse" for="c-39234168">[-]</label><label class="expand" for="c-39234168">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t poked into the source code, but usually a QoS event is fired, e.g. &quot;deadline missed&quot;. What happens exactly in that case is very application specific.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39236534" class="c"><input type="checkbox" id="c-39236534" checked=""/><div class="controls bullet"><span class="by">pitherpather</span><span>|</span><a href="#39233375">prev</a><span>|</span><a href="#39233642">next</a><span>|</span><label class="collapse" for="c-39236534">[-]</label><label class="expand" for="c-39236534">[1 more]</label></div><br/><div class="children"><div class="content">I have not read the ESA document, but in their defense one possibly applicable principle is this:<p>If you get too far from understanding&#x2F;practicing implementation, soon enough you will not be competent enough to produce a specification.</div><br/></div></div><div id="39233642" class="c"><input type="checkbox" id="c-39233642" checked=""/><div class="controls bullet"><span class="by">hlandau</span><span>|</span><a href="#39236534">prev</a><span>|</span><a href="#39234468">next</a><span>|</span><label class="collapse" for="c-39233642">[-]</label><label class="expand" for="c-39233642">[6 more]</label></div><br/><div class="children"><div class="content">A bit surprised to see a common MCU used here rather than one designed for safety applications (e.g. TMS570). Is there any rationale to this?</div><br/><div id="39234064" class="c"><input type="checkbox" id="c-39234064" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39233642">parent</a><span>|</span><a href="#39235337">next</a><span>|</span><label class="collapse" for="c-39234064">[-]</label><label class="expand" for="c-39234064">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see a super explicit one, but: <a href="https:&#x2F;&#x2F;activities.esa.int&#x2F;4000140241" rel="nofollow">https:&#x2F;&#x2F;activities.esa.int&#x2F;4000140241</a><p>&gt; The proposed activity is to evaluate the usage of Rust programming language in space applications,<p>&gt; The design of the system will be guided to support potential future qualification activities.<p>&gt; This application will showcase the viability of the developed RTOS and provide input to a Lessons Learned report, describing the encountered issues, potential problem and improvement areas, usage recommendations and proposed way forward.<p>Looks like it&#x27;s not intended for real applications, but instead to gain some experience. What better way to ensure that you don&#x27;t ship the prototype than by doing it on hardware that is similar but different enough to ensure that it won&#x27;t be used in production.<p>Just a guess though!</div><br/><div id="39234276" class="c"><input type="checkbox" id="c-39234276" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#39233642">root</a><span>|</span><a href="#39234064">parent</a><span>|</span><a href="#39235337">next</a><span>|</span><label class="collapse" for="c-39234276">[-]</label><label class="expand" for="c-39234276">[1 more]</label></div><br/><div class="children"><div class="content">I hope they also publish the Lessons Learned report mentioned above, would be an interesting read.</div><br/></div></div></div></div><div id="39235337" class="c"><input type="checkbox" id="c-39235337" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#39233642">parent</a><span>|</span><a href="#39234064">prev</a><span>|</span><a href="#39234468">next</a><span>|</span><label class="collapse" for="c-39235337">[-]</label><label class="expand" for="c-39235337">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Is there any rationale to this?<p>It&#x27;s all ARM Cortex?  The RTOS doesn&#x27;t care.</div><br/><div id="39235943" class="c"><input type="checkbox" id="c-39235943" checked=""/><div class="controls bullet"><span class="by">xyx0826</span><span>|</span><a href="#39233642">root</a><span>|</span><a href="#39235337">parent</a><span>|</span><a href="#39234468">next</a><span>|</span><label class="collapse" for="c-39235943">[-]</label><label class="expand" for="c-39235943">[2 more]</label></div><br/><div class="children"><div class="content">The choice of microcontroller matters. Functional safety qualified MCUs might have the same CPU core but is built in a way that minimizes interference or common cause of failures between peripherals. The software needs to be written closely following the safety manual of such a MCU to make maximum use of those safety guarantees.</div><br/><div id="39236135" class="c"><input type="checkbox" id="c-39236135" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#39233642">root</a><span>|</span><a href="#39235943">parent</a><span>|</span><a href="#39234468">next</a><span>|</span><label class="collapse" for="c-39236135">[-]</label><label class="expand" for="c-39236135">[1 more]</label></div><br/><div class="children"><div class="content">There are several safety critical Cortex implementations around, with features like multi-core lock-step operation that is largely transparent to the RTOS (or whatever) beyond fault handling.  There isn&#x27;t some vast gulf between the ATSAMV71Q21 they&#x27;ve piloted this on and whatever space rated device and requirements you imagine.</div><br/></div></div></div></div></div></div></div></div><div id="39234468" class="c"><input type="checkbox" id="c-39234468" checked=""/><div class="controls bullet"><span class="by">matt3210</span><span>|</span><a href="#39233642">prev</a><span>|</span><a href="#39233397">next</a><span>|</span><label class="collapse" for="c-39234468">[-]</label><label class="expand" for="c-39234468">[4 more]</label></div><br/><div class="children"><div class="content">The program cannot be verified against the standard to be correct. There is no standard, how can it be verified.</div><br/><div id="39234724" class="c"><input type="checkbox" id="c-39234724" checked=""/><div class="controls bullet"><span class="by">Xylakant</span><span>|</span><a href="#39234468">parent</a><span>|</span><a href="#39234630">next</a><span>|</span><label class="collapse" for="c-39234724">[-]</label><label class="expand" for="c-39234724">[1 more]</label></div><br/><div class="children"><div class="content">If by &quot;no standard&quot; you mean that there is no language specification for rust, then there is no standard. However, a language specification is not sufficient to verify program correctness, nor is it required.<p>A standard may (and the C standard for example does) leave parts of the behavior as &quot;implementation specific&quot; and there&#x27;s quite a few edge cases - and that&#x27;s not even talking about &quot;undefined behavior&quot;, of which there is plenty. An even in the behavior that is neither implementation specific nor undefined you&#x27;ll find enough rope to hang yourself (all the beautiful pointers). There&#x27;s a reason things such as MISRA C exist - effectively a standard on top of a standard.<p>On the other hand, the rust language - while having no formal spec - is fairly well described, in the form of its RFCs and testsuite. We (the ferrocene team) were able to derive a descriptive specification from the existing description fairly easily. So while there is no ISO standard, and no spec that would be sufficient to write a competing implementation, there is a description of what the language behaves like. You can read up on it at <a href="https:&#x2F;&#x2F;spec.ferrocene.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;spec.ferrocene.dev&#x2F;</a><p>As for verification of correct behavior of such a program, you can employ a host of different techniques depending on what your requirements are - down to verification of the produced bytecode by means of blackbox testing or other.</div><br/></div></div><div id="39234630" class="c"><input type="checkbox" id="c-39234630" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39234468">parent</a><span>|</span><a href="#39234724">prev</a><span>|</span><a href="#39234933">next</a><span>|</span><label class="collapse" for="c-39234630">[-]</label><label class="expand" for="c-39234630">[1 more]</label></div><br/><div class="children"><div class="content">Because verification does not require a standard. rustc has already been qualified (though not for any aerospace-specific things yet that I&#x27;m aware of, but in my understanding the shape is the same) (via Ferrocene[1]), even though there is no Rust Standard. No issues here.<p>1: <a href="https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;qualifying-rust-without-forking&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;qualifying-rust-without-for...</a><p>Also, I don&#x27;t see where this project claims to be verified.</div><br/></div></div><div id="39234933" class="c"><input type="checkbox" id="c-39234933" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#39234468">parent</a><span>|</span><a href="#39234630">prev</a><span>|</span><a href="#39233397">next</a><span>|</span><label class="collapse" for="c-39234933">[-]</label><label class="expand" for="c-39234933">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is no standard, how can it be verified.<p>The behavior of the generated binary can be verified against the requirements. Yeah, the most common way to do this is to verify certain properties at the source code level, and then rely on various ways to show equivalence between the source code and the generated assembly, the generated assembly and the generated binary, and the formal semantics of the generated binary and the as-executed semantics on the chosen hardware; but it&#x27;s perfectly reasonable, and not even particularly unusual, to skip the first equivalence and verify the assembly against the requirements directly.</div><br/></div></div></div></div><div id="39233397" class="c"><input type="checkbox" id="c-39233397" checked=""/><div class="controls bullet"><span class="by">sigmonsays</span><span>|</span><a href="#39234468">prev</a><span>|</span><a href="#39233958">next</a><span>|</span><label class="collapse" for="c-39233397">[-]</label><label class="expand" for="c-39233397">[2 more]</label></div><br/><div class="children"><div class="content">can someone please make an ode to &quot;write in C&quot; (1) entitled &quot;Write in Rust&quot;<p>(1) <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wJ81MZUlrDo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=wJ81MZUlrDo</a></div><br/><div id="39234364" class="c"><input type="checkbox" id="c-39234364" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39233397">parent</a><span>|</span><a href="#39233958">next</a><span>|</span><label class="collapse" for="c-39234364">[-]</label><label class="expand" for="c-39234364">[1 more]</label></div><br/><div class="children"><div class="content">Was this song written in like 1990 and recorded&#x2F;posted in 2013, or something?</div><br/></div></div></div></div></div></div></div></div></div></body></html>