<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692781262601" as="style"/><link rel="stylesheet" href="styles.css?v=1692781262601"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.demofox.org/2023/08/22/permutation-iteration-and-random-access/">Permutation iteration and random access</a> <span class="domain">(<a href="https://blog.demofox.org">blog.demofox.org</a>)</span></div><div class="subtext"><span>ingve</span> | <span>7 comments</span></div><br/><div><div id="37232950" class="c"><input type="checkbox" id="c-37232950" checked=""/><div class="controls bullet"><span class="by">tromp</span><span>|</span><a href="#37232819">next</a><span>|</span><label class="collapse" for="c-37232950">[-]</label><label class="expand" for="c-37232950">[1 more]</label></div><br/><div class="children"><div class="content">The permutation ranking algorithm described in the article can be generalized to a so-called multinomial ranking, one of several rankings implemented in Haskell [1]. E.g.<p><pre><code>   &gt; let r = multinomialRanking (zip &quot;abc&quot; [1..3])
   &gt; size r
   60
   &gt; unrank r 42
   &quot;cbcabc&quot;
   &gt; rank r &quot;cbcabc&quot;
   42
</code></pre>
Multinomial rankings can be combined with a dozen others to rank a subset of all chess positions that includes all legal ones [2]:<p><pre><code>    &gt; let cpr = sideToMoveRanking `composeURI` (caseRanking `composeRI` wArmyStatRanking `composeURI` bArmyStatRanking `composeRI` guardRanking `composeRI` enPassantRanking `composeURI` epOppRanking `composeURI` sandwichRanking `composeRI` opposeRanking `composeURI` pawnRanking `composeURI` castleRanking `composeURI` wArmyRanking `composeURI` bArmyRanking `composeURI` pieceRanking) $ emptyURPosition
    &gt; size cpr
    8726713169886222032347729969256422370854716254
    &gt; writeFEN . toPosition . unrank cpr $ 2389124290426577024216048831051262280148947032
    &quot;1r6&#x2F;1qrRPk2&#x2F;1rn1Rn1n&#x2F;1RQRR2R&#x2F;3P4&#x2F;3b2BN&#x2F;1Knn1b1b&#x2F;1BR5 w - - 0 1&quot;
    &gt; rank cpr . fromPosition . readFEN $ &quot;1r6&#x2F;1qrRPk2&#x2F;1rn1Rn1n&#x2F;1RQRR2R&#x2F;3P4&#x2F;3b2BN&#x2F;1Knn1b1b&#x2F;1BR5 w - - 0 1&quot;
    2389124290426577024216048831051262280148947032
</code></pre>
in which pieceRanking and pawnRanking are built upon multinomialRanking. Position data includes side to move, castling status, and en-passant status.<p>This allows one to sample millions of random such positions, determine how many are legal, and thus obtain an accurate estimate of 4.8 * 10^44 legal chess positions.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;tromp&#x2F;ChessPositionRanking&#x2F;blob&#x2F;main&#x2F;src&#x2F;Data&#x2F;Ranking.hs">https:&#x2F;&#x2F;github.com&#x2F;tromp&#x2F;ChessPositionRanking&#x2F;blob&#x2F;main&#x2F;src&#x2F;...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;tromp&#x2F;ChessPositionRanking">https:&#x2F;&#x2F;github.com&#x2F;tromp&#x2F;ChessPositionRanking</a></div><br/></div></div><div id="37232819" class="c"><input type="checkbox" id="c-37232819" checked=""/><div class="controls bullet"><span class="by">legerdemain</span><span>|</span><a href="#37232950">prev</a><span>|</span><a href="#37232695">next</a><span>|</span><label class="collapse" for="c-37232819">[-]</label><label class="expand" for="c-37232819">[1 more]</label></div><br/><div class="children"><div class="content">Given a permutation of a collection of elements, it&#x27;s trivially possible to find the next permutation (in lexicographic order) without ranking and unranking. Sedgewick 77 [1] calls it the Fischer-Krause algorithm.<p>The traditional (and still readable) reference for generating combinatorial objects such as permutations is Nijenhuis &amp; Wilf&#x27;s <i>Combinatorial Algorithms</i>.<p>The author of the article ubiquitously misspells &quot;lexicographic&quot; as &quot;lexographic.&quot; That might make it harder to Google the term.<p>[1] <a href="https:&#x2F;&#x2F;www.princeton.edu&#x2F;~rblee&#x2F;ELE572Papers&#x2F;p137-sedgewick.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.princeton.edu&#x2F;~rblee&#x2F;ELE572Papers&#x2F;p137-sedgewick...</a></div><br/></div></div><div id="37232695" class="c"><input type="checkbox" id="c-37232695" checked=""/><div class="controls bullet"><span class="by">reikonomusha</span><span>|</span><a href="#37232819">prev</a><span>|</span><a href="#37233302">next</a><span>|</span><label class="collapse" for="c-37232695">[-]</label><label class="expand" for="c-37232695">[2 more]</label></div><br/><div class="children"><div class="content">Here is Lisp code [1] that maps all sorts of combinatorial objects—permutations, combinations, radix-R integers, multi-set arrangements, etc.—perfectly into the smallest set of integers [0, n-1] and back. (In a sense, they are perfect hash functions.) This is used to help efficiently solve combinatorial puzzles.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;stylewarning&#x2F;cl-permutation&#x2F;blob&#x2F;master&#x2F;src&#x2F;combinatorial-ranking.lisp">https:&#x2F;&#x2F;github.com&#x2F;stylewarning&#x2F;cl-permutation&#x2F;blob&#x2F;master&#x2F;s...</a></div><br/><div id="37233077" class="c"><input type="checkbox" id="c-37233077" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#37232695">parent</a><span>|</span><a href="#37233302">next</a><span>|</span><label class="collapse" for="c-37233077">[-]</label><label class="expand" for="c-37233077">[1 more]</label></div><br/><div class="children"><div class="content">see also <a href="http:&#x2F;&#x2F;www.sudleyplace.com&#x2F;APL&#x2F;A%20Combinatorial%20Operator%20in%20APL.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.sudleyplace.com&#x2F;APL&#x2F;A%20Combinatorial%20Operator%...</a><p>&gt; <i>The goal of this document is to describe a single APL primitive to both count and generate various Combinatorial Arrays: permutations, combinations, compositions, partitions, etc. The unifying (and very APL-like) principle for such a primitive is Gian-Carlo Rota&#x27;s Twelvefold Way as described in Richard Stanley&#x27;s &quot;Enumerative Combinatorics&quot;, Knuth’s TAoCP, Vol. 4A, and Wikipedia among other references.</i></div><br/></div></div></div></div><div id="37233302" class="c"><input type="checkbox" id="c-37233302" checked=""/><div class="controls bullet"><span class="by">bobmaxup</span><span>|</span><a href="#37232695">prev</a><span>|</span><a href="#37232835">next</a><span>|</span><label class="collapse" for="c-37233302">[-]</label><label class="expand" for="c-37233302">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Lexographic<p>I also have made this spelling (speech?) error</div><br/></div></div><div id="37232835" class="c"><input type="checkbox" id="c-37232835" checked=""/><div class="controls bullet"><span class="by">pipo234</span><span>|</span><a href="#37233302">prev</a><span>|</span><label class="collapse" for="c-37232835">[-]</label><label class="expand" for="c-37232835">[1 more]</label></div><br/><div class="children"><div class="content">Nice demonstration, though the C++ is a bit cheesy. (C-style cast, integer signedness, modernize beyond C++98, ... :-)</div><br/></div></div></div></div></div></div></div></body></html>