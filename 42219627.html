<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732438848763" as="style"/><link rel="stylesheet" href="styles.css?v=1732438848763"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://tratt.net/laurie/blog/2023/rusts_two_kinds_of_assert_make_for_better_code.html">Rust&#x27;s Two Kinds of &#x27;Assert&#x27; Make for Better Code</a>Â <span class="domain">(<a href="https://tratt.net">tratt.net</a>)</span></div><div class="subtext"><span>untilted</span> | <span>33 comments</span></div><br/><div><div id="42226481" class="c"><input type="checkbox" id="c-42226481" checked=""/><div class="controls bullet"><span class="by">sfink</span><span>|</span><a href="#42226788">next</a><span>|</span><label class="collapse" for="c-42226481">[-]</label><label class="expand" for="c-42226481">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; These days I thus view asserts as falling into two categories:
    &gt;    1. Checking problem domain assumptions.
    &gt;    2. Checking internal assumptions.
</code></pre>
(1) is the category of assert that <i>should not be an assert</i>. That is an error to be handled, not asserted.<p>Ok, to be fair, (1) is really a combination of two categories: (1a) assumptions about uncontrolled external input, and (1b) assumptions about supposedly controlled or known input. Both should be handled with error checking most of the time, but it&#x27;s forgivable for (1b) to be asserted if it&#x27;s too inconvenient to do proper error handling. (1b) and (2) are problems that you need to fix, and the sooner and clearer the issue is announced, the more likely and easier it is to be fixed.<p>One thing I didn&#x27;t see mentioned is that asserts, especially category (2), enable fuzz testing to be vastly more effective. A fuzz test doesn&#x27;t have to stumble across something that causes a crash or a recognizably bad output; it just needs to trigger an assert. Which is another reason to not use asserts for unexpected input; fuzzers are <i>supposed</i> to give unexpected input, and your program is supposed to handle it reasonably gracefully. If you over-constrain the input, then first you&#x27;ll be wrong because weirdness will sneak in anyway, and second the fuzzer is harder to implement correctly and is less powerful. The fuzzer is supposed to be a chaos monkey, and it works best if you allow it to be one.</div><br/><div id="42226749" class="c"><input type="checkbox" id="c-42226749" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#42226481">parent</a><span>|</span><a href="#42226738">next</a><span>|</span><label class="collapse" for="c-42226749">[-]</label><label class="expand" for="c-42226749">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree with you. Though I would add that it a little depends on the type of program. A CLI program&#x27;s lazy, but often sufficient way of handling erroneous input are asserts (that are still enabled in release). In GUI app it shouldn&#x27;t happen.</div><br/></div></div><div id="42226738" class="c"><input type="checkbox" id="c-42226738" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#42226481">parent</a><span>|</span><a href="#42226749">prev</a><span>|</span><a href="#42226788">next</a><span>|</span><label class="collapse" for="c-42226738">[-]</label><label class="expand" for="c-42226738">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I do this kind of fuzz testing all the time. Its an incredible way to test code.<p>For fuzz testing I go even further with asserts. I usually also write a function called dbg_check(), which actively goes through all internal data and checks that all the internal invariants hold. Eg, in a b-tree, the depth should be the same for all children, children should be in order, width of all nodes is between n&#x2F;2-n, and so on.<p>If anything breaks during fuzz testing (which is almost guaranteed), you want the program to crash as soon as possible - since that makes it much easier to debug. I&#x27;ll wrap a lot of methods which modify the data structure in calls to dbg_check, calling it both before and after making changes. If dbg_check passes before a function runs, but fails afterwards - then I have a surefire way to narrow in on the buggy behaviour so I can fix it.</div><br/></div></div></div></div><div id="42226788" class="c"><input type="checkbox" id="c-42226788" checked=""/><div class="controls bullet"><span class="by">sagacity</span><span>|</span><a href="#42226481">prev</a><span>|</span><a href="#42226359">next</a><span>|</span><label class="collapse" for="c-42226788">[-]</label><label class="expand" for="c-42226788">[2 more]</label></div><br/><div class="children"><div class="content">One point I didn&#x27;t see mentioned that asserts can be used by the compiler to enable certain optimisations.<p>For instance, if you assert that an incoming index into a function is within the bounds of a vector, then during the rest of the function the compiler can elide any bounds checking.</div><br/><div id="42226813" class="c"><input type="checkbox" id="c-42226813" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42226788">parent</a><span>|</span><a href="#42226359">next</a><span>|</span><label class="collapse" for="c-42226813">[-]</label><label class="expand" for="c-42226813">[1 more]</label></div><br/><div class="children"><div class="content">What C compiler would add bounds checks?</div><br/></div></div></div></div><div id="42226359" class="c"><input type="checkbox" id="c-42226359" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#42226788">prev</a><span>|</span><a href="#42226710">next</a><span>|</span><label class="collapse" for="c-42226359">[-]</label><label class="expand" for="c-42226359">[6 more]</label></div><br/><div class="children"><div class="content">Asserts are convenient, but every time I encounter them I ask &quot;Can the compiler prove this can&#x27;t happen?&quot;<p>In the example of &quot;min(ages) &gt; 0&quot;, making age a NonZero type renders the assert unnecessary. Rust even has some fancy perf optimizations it can do with that information. It&#x27;s a win all around.</div><br/><div id="42226373" class="c"><input type="checkbox" id="c-42226373" checked=""/><div class="controls bullet"><span class="by">winter_blue</span><span>|</span><a href="#42226359">parent</a><span>|</span><a href="#42226710">next</a><span>|</span><label class="collapse" for="c-42226373">[-]</label><label class="expand" for="c-42226373">[5 more]</label></div><br/><div class="children"><div class="content">If you created a custom NonZero type, how would the Rust compiler figure out how to optimize that?<p>How would one communicate properties&#x2F;traits of a custom type (like a non-zero unit) that a compiler can leverage to optimize (<i>in general, for any programming language</i>)?</div><br/><div id="42226386" class="c"><input type="checkbox" id="c-42226386" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42226359">root</a><span>|</span><a href="#42226373">parent</a><span>|</span><a href="#42226694">next</a><span>|</span><label class="collapse" for="c-42226386">[-]</label><label class="expand" for="c-42226386">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the mechanics of being able to convey a niche are stable&#x2F;developer-accessible, but NonZero is a type provided by the standard library: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;num&#x2F;struct.NonZero.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;num&#x2F;struct.NonZero.html</a><p>An example of the niche optimisations is in that link; if a 32bit number is NonZero, you can put that in an Option, and your Option&lt;NonZero&lt;u32&gt;&gt; will be the same size as a normal u32.</div><br/></div></div><div id="42226694" class="c"><input type="checkbox" id="c-42226694" checked=""/><div class="controls bullet"><span class="by">Timshel</span><span>|</span><a href="#42226359">root</a><span>|</span><a href="#42226373">parent</a><span>|</span><a href="#42226386">prev</a><span>|</span><a href="#42226557">next</a><span>|</span><label class="collapse" for="c-42226694">[-]</label><label class="expand" for="c-42226694">[1 more]</label></div><br/><div class="children"><div class="content">In general such a thing is written with a wrapper type which disappear at compilation (a kind of stricter type alias).<p>In rust might be a NewType: <a href="https:&#x2F;&#x2F;www.howtocodeit.com&#x2F;articles&#x2F;ultimate-guide-rust-newtypes" rel="nofollow">https:&#x2F;&#x2F;www.howtocodeit.com&#x2F;articles&#x2F;ultimate-guide-rust-new...</a></div><br/></div></div><div id="42226557" class="c"><input type="checkbox" id="c-42226557" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42226359">root</a><span>|</span><a href="#42226373">parent</a><span>|</span><a href="#42226694">prev</a><span>|</span><a href="#42226710">next</a><span>|</span><label class="collapse" for="c-42226557">[-]</label><label class="expand" for="c-42226557">[2 more]</label></div><br/><div class="children"><div class="content">In general, you need a type system that supports sets of integer values, e.g. range(2, 7) or set(3, 5, 7). Rust doesn&#x27;t support that unfortunately so it has a special annotation instead to make NonZero work.</div><br/><div id="42226814" class="c"><input type="checkbox" id="c-42226814" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42226359">root</a><span>|</span><a href="#42226557">parent</a><span>|</span><a href="#42226710">next</a><span>|</span><label class="collapse" for="c-42226814">[-]</label><label class="expand" for="c-42226814">[1 more]</label></div><br/><div class="children"><div class="content">In terms of category theory, what we would need is subtraction and division types on top of product and sum types.<p>So a 32-bit integer is the product of 32 two-state bit types. Something akin to NonZero could be defined as that type <i>minus</i> one state, such that there are now 4294967296 - 1 representable values.<p>Similarly, pointer types on some machines always have some bits set to 0 due to hardware constraints. These can be represented in the type system as 2^64 &#x2F; 2^n where &#x27;n&#x27; is the number of bits that are not usable, resulting in something like 2^46 for typical CPUs. This would allow extra bits of state to be &quot;packed in there&quot;.<p>This concept is more generally useful, not just for bit-packing.<p>For example, a database table row might be represented by a struct that contains a field for every column. But then, how to represent the result of a SELECT query!? Either you code-gen this into a new type, create that type manually, or use compiler-generated &quot;unspeakable&quot; type names. (Linq in C# does this.)<p>Or... the language could natively support type division, so you could use one struct type for &quot;all columns&quot; and then use division on the type to delete columns you don&#x27;t need for a particular query or REST response.<p>There&#x27;s a whole ecosystem of tools that work around the problem of not having this as a built-in feature in typical languages: AutoMapper, automap, Mapster, etc...</div><br/></div></div></div></div></div></div></div></div><div id="42226710" class="c"><input type="checkbox" id="c-42226710" checked=""/><div class="controls bullet"><span class="by">darkr</span><span>|</span><a href="#42226359">prev</a><span>|</span><a href="#42226200">next</a><span>|</span><label class="collapse" for="c-42226710">[-]</label><label class="expand" for="c-42226710">[1 more]</label></div><br/><div class="children"><div class="content">Similarly python in optimised mode with -O or -OO flags will disable asserts.<p>I see asserts as a less temporary version of print() based debugging. Sometimes very useful as a quick and dirty fix, but 9 times out of 10 youâre better off with some combination of a real debugger, unit tests, tracing&#x2F;logging, and better typing or validation.</div><br/></div></div><div id="42226200" class="c"><input type="checkbox" id="c-42226200" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#42226710">prev</a><span>|</span><a href="#42226317">next</a><span>|</span><label class="collapse" for="c-42226200">[-]</label><label class="expand" for="c-42226200">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The problem that Iâve just expressed ultimately occurs because languages like C force us to encode both kinds of assumption with a single assert statement: either all asserts are compiled in or none are.<p>Itâs trivial to write a debug_assert macro in C, so no, youâre not forced to do that.</div><br/><div id="42226233" class="c"><input type="checkbox" id="c-42226233" checked=""/><div class="controls bullet"><span class="by">delaaxe</span><span>|</span><a href="#42226200">parent</a><span>|</span><a href="#42226317">next</a><span>|</span><label class="collapse" for="c-42226233">[-]</label><label class="expand" for="c-42226233">[2 more]</label></div><br/><div class="children"><div class="content">It says so in the last paragraph</div><br/><div id="42226541" class="c"><input type="checkbox" id="c-42226541" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#42226200">root</a><span>|</span><a href="#42226233">parent</a><span>|</span><a href="#42226317">next</a><span>|</span><label class="collapse" for="c-42226541">[-]</label><label class="expand" for="c-42226541">[1 more]</label></div><br/><div class="children"><div class="content">Right, this whole debug_assert thing is just a tiny bit of syntactic sugar. Everyone starts their C&#x2F;C++ programs with a dozen lines of #define that wouldn&#x27;t be necessary if only the authors in the 1980s had the foresight to design programming languages to fit the taste of 2020s programmers. This eliminates one of those lines.<p>Rust provides some remarkably rich features to help you reason about the assumptions, preconditions and postconditions your code has, but debug_assert isn&#x27;t one of them.</div><br/></div></div></div></div></div></div><div id="42226317" class="c"><input type="checkbox" id="c-42226317" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#42226200">prev</a><span>|</span><a href="#42226380">next</a><span>|</span><label class="collapse" for="c-42226317">[-]</label><label class="expand" for="c-42226317">[1 more]</label></div><br/><div class="children"><div class="content">I remember someone arguing that disabling assertions in prod is like wearing a life jacket in the harbor but throwing it overboard going to sea. And Moore&#x27;s Law paid for them years ago.</div><br/></div></div><div id="42226380" class="c"><input type="checkbox" id="c-42226380" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#42226317">prev</a><span>|</span><a href="#42226464">next</a><span>|</span><label class="collapse" for="c-42226380">[-]</label><label class="expand" for="c-42226380">[9 more]</label></div><br/><div class="children"><div class="content">Common Lisp does assertions right: you can let `<i>assert</i>&#x27; provide a restart which allows the user to fix a problem when it crops up. For example:<p><pre><code>  (assert (&lt; index (length some-vector))
    (index)
    &quot;Can&#x27;t change the element at index ~D, index must be smaller than ~D.&quot;
    index
    (length some-vector))
</code></pre>
That will print a message when the index is too large and give you the option of providing another index.</div><br/><div id="42226421" class="c"><input type="checkbox" id="c-42226421" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42226380">parent</a><span>|</span><a href="#42226447">next</a><span>|</span><label class="collapse" for="c-42226421">[-]</label><label class="expand" for="c-42226421">[2 more]</label></div><br/><div class="children"><div class="content">Wat&#x27;s up with calling the variable &quot;index&quot; in the second parameter to assert? What happens when you try to call what&#x27;s presumably an integer..?</div><br/><div id="42226442" class="c"><input type="checkbox" id="c-42226442" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42226380">root</a><span>|</span><a href="#42226421">parent</a><span>|</span><a href="#42226447">next</a><span>|</span><label class="collapse" for="c-42226442">[-]</label><label class="expand" for="c-42226442">[1 more]</label></div><br/><div class="children"><div class="content">There is no call. assert is a macro, the second parameter is a list of places which the restart can update.</div><br/></div></div></div></div><div id="42226447" class="c"><input type="checkbox" id="c-42226447" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42226380">parent</a><span>|</span><a href="#42226421">prev</a><span>|</span><a href="#42226464">next</a><span>|</span><label class="collapse" for="c-42226447">[-]</label><label class="expand" for="c-42226447">[6 more]</label></div><br/><div class="children"><div class="content">It would be interesting if a language allowed control flow to jump between catches and exceptions with named sort of exceptions.<p>E.g., imagine in this example that the code code throw an invalid index exception, some calling code could catch that, and supply a new index, and control flow would resume from the throw expression.<p>This would be a complete mess, but it would be interesting nonetheless :)</div><br/><div id="42226545" class="c"><input type="checkbox" id="c-42226545" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42226380">root</a><span>|</span><a href="#42226447">parent</a><span>|</span><a href="#42226722">next</a><span>|</span><label class="collapse" for="c-42226545">[-]</label><label class="expand" for="c-42226545">[2 more]</label></div><br/><div class="children"><div class="content">That is literally what Common Lisp has and GP describesâ¦<p><a href="https:&#x2F;&#x2F;en.m.wikibooks.org&#x2F;wiki&#x2F;Common_Lisp&#x2F;Advanced_topics&#x2F;Condition_System" rel="nofollow">https:&#x2F;&#x2F;en.m.wikibooks.org&#x2F;wiki&#x2F;Common_Lisp&#x2F;Advanced_topics&#x2F;...</a></div><br/><div id="42226748" class="c"><input type="checkbox" id="c-42226748" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42226380">root</a><span>|</span><a href="#42226545">parent</a><span>|</span><a href="#42226722">next</a><span>|</span><label class="collapse" for="c-42226748">[-]</label><label class="expand" for="c-42226748">[1 more]</label></div><br/><div class="children"><div class="content">It is always fun when people learn some of the things that common lisp has done for a long time.</div><br/></div></div></div></div><div id="42226722" class="c"><input type="checkbox" id="c-42226722" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#42226380">root</a><span>|</span><a href="#42226447">parent</a><span>|</span><a href="#42226545">prev</a><span>|</span><a href="#42226470">next</a><span>|</span><label class="collapse" for="c-42226722">[-]</label><label class="expand" for="c-42226722">[2 more]</label></div><br/><div class="children"><div class="content">You can do it easily in any language with coroutines, for example Lua.</div><br/><div id="42226829" class="c"><input type="checkbox" id="c-42226829" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42226380">root</a><span>|</span><a href="#42226722">parent</a><span>|</span><a href="#42226470">next</a><span>|</span><label class="collapse" for="c-42226829">[-]</label><label class="expand" for="c-42226829">[1 more]</label></div><br/><div class="children"><div class="content">You can do it easily in any language with functions and flow control. Restarts and coroutines are just if-errs and CPS-natured code in disguise. The difference is only syntactic, and there are ways to reduce the noise to manageable levels.</div><br/></div></div></div></div><div id="42226470" class="c"><input type="checkbox" id="c-42226470" checked=""/><div class="controls bullet"><span class="by">skavi</span><span>|</span><a href="#42226380">root</a><span>|</span><a href="#42226447">parent</a><span>|</span><a href="#42226722">prev</a><span>|</span><a href="#42226464">next</a><span>|</span><label class="collapse" for="c-42226470">[-]</label><label class="expand" for="c-42226470">[1 more]</label></div><br/><div class="children"><div class="content">Exceptions are a special case of general effect systems which do include the capability you describe.</div><br/></div></div></div></div></div></div><div id="42226464" class="c"><input type="checkbox" id="c-42226464" checked=""/><div class="controls bullet"><span class="by">archargelod</span><span>|</span><a href="#42226380">prev</a><span>|</span><a href="#42226364">next</a><span>|</span><label class="collapse" for="c-42226464">[-]</label><label class="expand" for="c-42226464">[2 more]</label></div><br/><div class="children"><div class="content">Nim has this too:<p><pre><code>  - `assert` is disabled in unsafe `danger` mode or can be disabled with a flag for performance
  - `doAssert` cannot be disabled
</code></pre>
While I&#x27;ve never come across an argument for why there are two types of assert, over time Iâve naturally started using them in the same way as the author.</div><br/><div id="42226538" class="c"><input type="checkbox" id="c-42226538" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42226464">parent</a><span>|</span><a href="#42226364">next</a><span>|</span><label class="collapse" for="c-42226538">[-]</label><label class="expand" for="c-42226538">[1 more]</label></div><br/><div class="children"><div class="content">How are people <i>still</i> making the classic `foo`&#x2F;`foo_safe_version` mistake? In a supposedly modern language. And they didn&#x27;t even name the safe version clearly! If the rest of Nim is designed on this level then I hope it never succeeds.<p>Note that Rust got this exactly right. assert, debug_assert. Clear and fail-safe.</div><br/></div></div></div></div><div id="42226364" class="c"><input type="checkbox" id="c-42226364" checked=""/><div class="controls bullet"><span class="by">EE84M3i</span><span>|</span><a href="#42226464">prev</a><span>|</span><a href="#42226341">next</a><span>|</span><label class="collapse" for="c-42226364">[-]</label><label class="expand" for="c-42226364">[2 more]</label></div><br/><div class="children"><div class="content">Is it common to use parenthesis for python assert statements?</div><br/><div id="42226560" class="c"><input type="checkbox" id="c-42226560" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42226364">parent</a><span>|</span><a href="#42226341">next</a><span>|</span><label class="collapse" for="c-42226560">[-]</label><label class="expand" for="c-42226560">[1 more]</label></div><br/><div class="children"><div class="content">I would say no. In fact it is risky, because if you try to add an assertion message inside the parens youâre now asserting a non-empty tuple which is always truthy. Though obviously you might know enough to not make this error, and want the parens for consistency when asserts need to be multiline.<p>tratt might also be doing that more for consistency with the desugaring than as a routine behaviour.</div><br/></div></div></div></div><div id="42226341" class="c"><input type="checkbox" id="c-42226341" checked=""/><div class="controls bullet"><span class="by">davelee</span><span>|</span><a href="#42226364">prev</a><span>|</span><a href="#42226747">next</a><span>|</span><label class="collapse" for="c-42226341">[-]</label><label class="expand" for="c-42226341">[1 more]</label></div><br/><div class="children"><div class="content">Swift calls these precondition() and assert(). Preconditions are enabled in release (and debug) builds, and asserts are enabled in debug builds only.</div><br/></div></div><div id="42226747" class="c"><input type="checkbox" id="c-42226747" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42226341">prev</a><span>|</span><a href="#42226504">next</a><span>|</span><label class="collapse" for="c-42226747">[-]</label><label class="expand" for="c-42226747">[1 more]</label></div><br/><div class="children"><div class="content">The distinction between debug and release mode wrt my code (assertions, debug logging) was always confusing to me. The experience told me uncountable times that âreleaseâ (iow âprodâ) is where you <i>want</i> debug information to be produced, cause thatâs where your code meets full-blown reality. Otherwise your system silently breaks in production after few weeks, and two weeks later someone will ask you why and to repair it asap. Good luck investigating it without megabytes of the debug info. And donât expect that youâll get only definitive questions. In âwhoâs rightâ and disputes the question you receive will often have a great share of uncertainty.<p>Assertions are basically opposite to that. Useless in development because you watch&#x2F;test closely anyway and useless in âreleaseâ because they vanish.<p>As I rarely write #CLK-level performance-required code - like most developers I believe - and mostly create systems that just do things rather than doing things in really tight loops many times a second, I always leave as much debug info and explicit failure modes as it is reasonable in my production code, so that the few-weeks failure would be immediate and explained in the logs (âreasonableâ being readable without holding pgdn and not filling the ssd just after a week). It doesnât mean that the system must crash hard as in sigsegv, ofc. It means it reports and logs all(!) steps and errors as they occur in a form that is obviously greppable by all important params (client id, task id, module tag, etc), and it stops a logical process in which an inconsistency occurred from advancing it further. If someone asks you later why it happened or what happened at the specific time with a specific process, you always have the answer almost immediately.<p>Tldr. Unless you write performance-first systems, i.e. you have performance requirements document in any form to follow, donât turn off assertions and do log everything. Youâll thank yourself later.</div><br/></div></div><div id="42226504" class="c"><input type="checkbox" id="c-42226504" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42226747">prev</a><span>|</span><label class="collapse" for="c-42226504">[-]</label><label class="expand" for="c-42226504">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Using runtime assert() in a tight performance loop can impact performance?&quot;  Um, like ... duh?<p>Run time checks should simply be enabled.  Normally, you&#x27;re checking some context on entry or exit from a function.  99% of the time it simply won&#x27;t matter to performance.  And, when it does, it will pop out at you and you can remove it.<p>The bigger issue as alluded to is assert() in libraries.  As a user, you can&#x27;t add an assert() to a library.  And also, as a user, you can&#x27;t remove an assert() that is getting in your way.</div><br/></div></div></div></div></div></div></div></body></html>