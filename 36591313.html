<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688547651855" as="style"/><link rel="stylesheet" href="styles.css?v=1688547651855"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://elixir-lang.org/blog/2023/06/22/type-system-updates-research-dev/">Type system updates: moving from research into development</a> <span class="domain">(<a href="https://elixir-lang.org">elixir-lang.org</a>)</span></div><div class="subtext"><span>weatherlight</span> | <span>67 comments</span></div><br/><div><div id="36597359" class="c"><input type="checkbox" id="c-36597359" checked=""/><div class="controls bullet"><span class="by">phtrivier</span><span>|</span><a href="#36593305">next</a><span>|</span><label class="collapse" for="c-36597359">[-]</label><label class="expand" for="c-36597359">[1 more]</label></div><br/><div class="children"><div class="content">As a very frequent nagger about the lack of type system of Elixir, this made my day:<p>&gt; The type system will extract type information from patterns and guards to find the most obvious mistakes, such as typos in field names or type mismatches from attempting to add an integer to a string, without introducing any user-facing changes to the language.<p>&gt; By propagating types from structs and their fields throughout the program, we will increase the type system’s ability to find errors while further straining our type system implementation.<p>Congrats to them.<p>I still wish it had been implemented 10 years ago, but, hey, that train has sailed a long while ago. (I know, trains dont sail. Or, as we say in Elixir-land, &quot;** (MatchError) ...&quot;)</div><br/></div></div><div id="36593305" class="c"><input type="checkbox" id="c-36593305" checked=""/><div class="controls bullet"><span class="by">losvedir</span><span>|</span><a href="#36597359">prev</a><span>|</span><a href="#36591855">next</a><span>|</span><label class="collapse" for="c-36593305">[-]</label><label class="expand" for="c-36593305">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used Elixir professionally for 6 years and have been very impressed with how it&#x27;s been managed. All additions seem very careful and deliberate. I can&#x27;t think of any regression or issue I&#x27;ve had as the language and tooling and standard library have improved.<p>Given that, I&#x27;m excited to see how this works out. Adding static types has the potential to be very disruptive but I trust the team to do it in a way that will work very well with existing Elixir apps and the BEAM VM.</div><br/><div id="36594450" class="c"><input type="checkbox" id="c-36594450" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#36593305">parent</a><span>|</span><a href="#36591855">next</a><span>|</span><label class="collapse" for="c-36594450">[-]</label><label class="expand" for="c-36594450">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested to see how this affects Gleam.</div><br/><div id="36595319" class="c"><input type="checkbox" id="c-36595319" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36593305">root</a><span>|</span><a href="#36594450">parent</a><span>|</span><a href="#36591855">next</a><span>|</span><label class="collapse" for="c-36595319">[-]</label><label class="expand" for="c-36595319">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it will. Elixir, if everything pans out, will be gradually typed. the new type system will be sound, but will be very different than other type systems.<p>Gleam from Day 1 is going to be statically typed using a Hindley-Milner type system&#x2F;Algorithm W. It&#x27;s battle tested. If you come from a lang like Rust, OCaml, Standard ML, etc its type system is going to be very familiar to you.</div><br/><div id="36595522" class="c"><input type="checkbox" id="c-36595522" checked=""/><div class="controls bullet"><span class="by">Ndymium</span><span>|</span><a href="#36593305">root</a><span>|</span><a href="#36595319">parent</a><span>|</span><a href="#36591855">next</a><span>|</span><label class="collapse" for="c-36595522">[-]</label><label class="expand" for="c-36595522">[1 more]</label></div><br/><div class="children"><div class="content">Additionally, Gleam is very different as a language. Erlang is only one of its targets, another one is JavaScript (and I see many people just using it for that alone). I&#x27;m personally writing a static blog generator for myself that&#x27;ll run on the Node target.<p>So I don&#x27;t think this will have too much effect on Gleam.</div><br/></div></div></div></div></div></div></div></div><div id="36591855" class="c"><input type="checkbox" id="c-36591855" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36593305">prev</a><span>|</span><a href="#36593590">next</a><span>|</span><label class="collapse" for="c-36591855">[-]</label><label class="expand" for="c-36591855">[3 more]</label></div><br/><div class="children"><div class="content">Proposed type system described in more detail here.
<a href="https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf</a></div><br/><div id="36595358" class="c"><input type="checkbox" id="c-36595358" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36591855">parent</a><span>|</span><a href="#36592085">next</a><span>|</span><label class="collapse" for="c-36595358">[-]</label><label class="expand" for="c-36595358">[1 more]</label></div><br/><div class="children"><div class="content">I seemed to remember one of the authors from some previous work on formalizing multimethod dispatch, so I looked him up again..<p>He seems to have written <i>a ton</i> of interesting stuff on PL theory!<p><a href="https:&#x2F;&#x2F;www.irif.fr&#x2F;~gc&#x2F;papers.en.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.irif.fr&#x2F;~gc&#x2F;papers.en.html</a></div><br/></div></div><div id="36592085" class="c"><input type="checkbox" id="c-36592085" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#36591855">parent</a><span>|</span><a href="#36595358">prev</a><span>|</span><a href="#36593590">next</a><span>|</span><label class="collapse" for="c-36592085">[-]</label><label class="expand" for="c-36592085">[1 more]</label></div><br/><div class="children"><div class="content">Ah, thanks for that, I was wondering where the details were! Adding this to my pile...</div><br/></div></div></div></div><div id="36593590" class="c"><input type="checkbox" id="c-36593590" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#36591855">prev</a><span>|</span><a href="#36591605">next</a><span>|</span><label class="collapse" for="c-36593590">[-]</label><label class="expand" for="c-36593590">[20 more]</label></div><br/><div class="children"><div class="content">Is set theory more useful than category theory for dynamic types? Seems like set theory is less constrained, like a set can be part of itself by nature, whereas category theory generally doesn&#x27;t allow mixing containers and elements like that out of the box IIUC. Seems like category theory best suits Haskell and such where types are more precisely defined (something that could be an int or a bool needs an ADT wrapper), whereas set theory might make sense for completely dynamic types, where something could be an int or a bool or whatever else by nature.<p>But I&#x27;m entirely unsure. Maybe it is completely unrelated to why set theory is used as a basis here. Just wondering.</div><br/><div id="36595601" class="c"><input type="checkbox" id="c-36595601" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36593590">parent</a><span>|</span><a href="#36594784">next</a><span>|</span><label class="collapse" for="c-36595601">[-]</label><label class="expand" for="c-36595601">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.irif.fr&#x2F;~gc&#x2F;papers&#x2F;set-theoretic-types-2022.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.irif.fr&#x2F;~gc&#x2F;papers&#x2F;set-theoretic-types-2022.pdf</a><p>This research paper by Giuseppe Castagna presents an in-depth exploration of programming with set-theoretic types, which include union, intersection, and negation type connectives. The author argues that these types are not just useful, but necessary for typing some common programming patterns, and they play a crucial role in precisely typing various language constructs, from branching and pattern matching to function overloading and type-cases.<p>What sets this work apart is the extension of the theory of types known as semantic subtyping to include polymorphic types. This is a significant step forward as it allows for a more expressive and precise type system. The paper also discusses the design of languages that use these types and presents a theoretical framework that covers all the examples given in the presentation.<p>one of the key takeaways from this paper is that current programming languages are unable to infer intersection types for functions without explicit annotations. This is a limitation that could impact the development and efficiency of certain programs. The author presents three effective restrictions of this system, each with its own trade-offs, which could potentially guide the design of future programming languages.<p>The paper concludes with an overview of other aspects of these languages, such as pattern matching, gradual typing, and denotational semantics. These insights could have far-reaching implications for the development of more expressive and precise programming languages.<p>this paper pushes the boundaries of what we understand about type systems in programming languages, Elixir is going to be the first general purpose language to implement such a type system.</div><br/></div></div><div id="36594784" class="c"><input type="checkbox" id="c-36594784" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#36593590">parent</a><span>|</span><a href="#36595601">prev</a><span>|</span><a href="#36593770">next</a><span>|</span><label class="collapse" for="c-36594784">[-]</label><label class="expand" for="c-36594784">[4 more]</label></div><br/><div class="children"><div class="content">A set being a member if itself (or not) is the source of the famous paradox that destroyed the naive set theory %)<p>In practice, you usually need either a definite sum.type (int | str | null), or the all-encompassing type, like Any. I think both cases should be adequately representable in a categorial language — am I wrong?<p>You may need to represent a sum type that includes Any (or a similar type) if you.allow type-based signature overloads for functions. I wonder if this may represent any obstacle to a caregorial approach.</div><br/><div id="36596829" class="c"><input type="checkbox" id="c-36596829" checked=""/><div class="controls bullet"><span class="by">eric-hu</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36594784">parent</a><span>|</span><a href="#36595442">next</a><span>|</span><label class="collapse" for="c-36596829">[-]</label><label class="expand" for="c-36596829">[1 more]</label></div><br/><div class="children"><div class="content">That would be Russell’s paradox<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Russell%27s_paradox" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Russell%27s_paradox</a></div><br/></div></div><div id="36595442" class="c"><input type="checkbox" id="c-36595442" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36594784">parent</a><span>|</span><a href="#36596829">prev</a><span>|</span><a href="#36593770">next</a><span>|</span><label class="collapse" for="c-36595442">[-]</label><label class="expand" for="c-36595442">[2 more]</label></div><br/><div class="children"><div class="content">I thought the principle of the excluded middle was the ultimate source of that paradox, not set theory itself?</div><br/><div id="36597587" class="c"><input type="checkbox" id="c-36597587" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36595442">parent</a><span>|</span><a href="#36593770">next</a><span>|</span><label class="collapse" for="c-36597587">[-]</label><label class="expand" for="c-36597587">[1 more]</label></div><br/><div class="children"><div class="content">No, Russel&#x27;s paradox and the Law of the Excluded Middle have not much to do with each other. (It is not easy to <i>prove</i> such a negative statement, but I googled them together, and found absolutely nothing.)</div><br/></div></div></div></div></div></div><div id="36593770" class="c"><input type="checkbox" id="c-36593770" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#36593590">parent</a><span>|</span><a href="#36594784">prev</a><span>|</span><a href="#36595397">next</a><span>|</span><label class="collapse" for="c-36593770">[-]</label><label class="expand" for="c-36593770">[8 more]</label></div><br/><div class="children"><div class="content">&gt; <i>A set has the least structure. It&#x27;s a discrete category, with no morphisms other than identities. Conversely, the category of sets has the most structure, since its morphisms don&#x27;t have to preserve any structure.</i><p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;BartoszMilewski&#x2F;status&#x2F;1674357272498110467" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;BartoszMilewski&#x2F;status&#x2F;16743572724981104...</a></div><br/><div id="36597686" class="c"><input type="checkbox" id="c-36597686" checked=""/><div class="controls bullet"><span class="by">kmill</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593770">parent</a><span>|</span><a href="#36593798">next</a><span>|</span><label class="collapse" for="c-36597686">[-]</label><label class="expand" for="c-36597686">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Set-theoretic type theory&quot; is working with the lattice of all subsets of possible values, where a &quot;type&quot; is one of these subsets. This lattice has plenty of structure, but sure individual subsets do not.<p>The category of sets is different from this lattice, since it allows arbitrary functions between sets for its morphisms rather than just inclusions.<p>&quot;Set-theoretic types&quot; have a meaningful notion of overlap. Usually types in other type system tend to be practically disjoint, like objects in a concrete category might be sets but the category itself doesn&#x27;t give language to check whether the objects are disjoint sets.</div><br/></div></div><div id="36593798" class="c"><input type="checkbox" id="c-36593798" checked=""/><div class="controls bullet"><span class="by">climatologist</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593770">parent</a><span>|</span><a href="#36597686">prev</a><span>|</span><a href="#36593889">next</a><span>|</span><label class="collapse" for="c-36593798">[-]</label><label class="expand" for="c-36593798">[4 more]</label></div><br/><div class="children"><div class="content">This is incorrect. The number of morphisms is not what makes mathematical objects more or less structured. What is correct is that the category of sets does not have constraints for morphisms between its objects. Bartosz is equating morphisms and &quot;structure&quot; which is not how most mathematicians think of what it means for a category or an object to be structured.</div><br/><div id="36597622" class="c"><input type="checkbox" id="c-36597622" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593798">parent</a><span>|</span><a href="#36596282">next</a><span>|</span><label class="collapse" for="c-36597622">[-]</label><label class="expand" for="c-36597622">[1 more]</label></div><br/><div class="children"><div class="content">It is correct, in the best possible way.<p>Having <i>least structure</i> is a soft&#x2F;aesthetical statement, and there is right after it what they mean of it, and it is true (a correct definition).<p>I wish all the math looked like this, first a soft&#x2F;aesthetical statement, then right after the correct math.</div><br/></div></div><div id="36596282" class="c"><input type="checkbox" id="c-36596282" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593798">parent</a><span>|</span><a href="#36597622">prev</a><span>|</span><a href="#36594555">next</a><span>|</span><label class="collapse" for="c-36596282">[-]</label><label class="expand" for="c-36596282">[1 more]</label></div><br/><div class="children"><div class="content">He prefaces the statement with &quot;my intuition tells me&quot;, so perhaps he is much less categorical (pun intended) about the claim than you interpret it.</div><br/></div></div><div id="36594555" class="c"><input type="checkbox" id="c-36594555" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593798">parent</a><span>|</span><a href="#36596282">prev</a><span>|</span><a href="#36593889">next</a><span>|</span><label class="collapse" for="c-36594555">[-]</label><label class="expand" for="c-36594555">[1 more]</label></div><br/><div class="children"><div class="content">It seems incorrect to state that his perspective is categorically incorrect. The term “structure” lacks a precise definition and his interpretation isn’t completely invalid.</div><br/></div></div></div></div><div id="36593889" class="c"><input type="checkbox" id="c-36593889" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593770">parent</a><span>|</span><a href="#36593798">prev</a><span>|</span><a href="#36594550">next</a><span>|</span><label class="collapse" for="c-36593889">[-]</label><label class="expand" for="c-36593889">[1 more]</label></div><br/><div class="children"><div class="content">Better thread on Mastodon [1]<p>[1] <a href="https:&#x2F;&#x2F;mathstodon.xyz&#x2F;@johncarlosbaez&#x2F;110631013611448277" rel="nofollow noreferrer">https:&#x2F;&#x2F;mathstodon.xyz&#x2F;@johncarlosbaez&#x2F;110631013611448277</a></div><br/></div></div><div id="36594550" class="c"><input type="checkbox" id="c-36594550" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36593770">parent</a><span>|</span><a href="#36593889">prev</a><span>|</span><a href="#36595397">next</a><span>|</span><label class="collapse" for="c-36594550">[-]</label><label class="expand" for="c-36594550">[1 more]</label></div><br/><div class="children"><div class="content">Interesting definition of most structure</div><br/></div></div></div></div><div id="36595397" class="c"><input type="checkbox" id="c-36595397" checked=""/><div class="controls bullet"><span class="by">ughitsaaron</span><span>|</span><a href="#36593590">parent</a><span>|</span><a href="#36593770">prev</a><span>|</span><a href="#36594657">next</a><span>|</span><label class="collapse" for="c-36595397">[-]</label><label class="expand" for="c-36595397">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, but could anyone share some background (reading, links, etc.) on set vs. category theory as applied type systems?</div><br/><div id="36595435" class="c"><input type="checkbox" id="c-36595435" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36595397">parent</a><span>|</span><a href="#36594657">next</a><span>|</span><label class="collapse" for="c-36595435">[-]</label><label class="expand" for="c-36595435">[1 more]</label></div><br/><div class="children"><div class="content">Mostly about proof assistants, but type systems are fundamentally related <a href="https:&#x2F;&#x2F;mathoverflow.net&#x2F;questions&#x2F;376839&#x2F;what-makes-dependent-type-theory-more-suitable-than-set-theory-for-proof-assista" rel="nofollow noreferrer">https:&#x2F;&#x2F;mathoverflow.net&#x2F;questions&#x2F;376839&#x2F;what-makes-depende...</a></div><br/></div></div></div></div><div id="36594657" class="c"><input type="checkbox" id="c-36594657" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#36593590">parent</a><span>|</span><a href="#36595397">prev</a><span>|</span><a href="#36591605">next</a><span>|</span><label class="collapse" for="c-36594657">[-]</label><label class="expand" for="c-36594657">[4 more]</label></div><br/><div class="children"><div class="content">&gt; a set can be part of itself<p>A set cannot be part of itself in an axiomatic formulation of set theory. Naïve set theory, one that allows an unrestricted general comprehension, has been thoroughly rejected.</div><br/><div id="36594866" class="c"><input type="checkbox" id="c-36594866" checked=""/><div class="controls bullet"><span class="by">dkbrk</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36594657">parent</a><span>|</span><a href="#36591605">next</a><span>|</span><label class="collapse" for="c-36594866">[-]</label><label class="expand" for="c-36594866">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A set cannot be part of itself in an axiomatic formulation of set theory.<p>This isn&#x27;t quite true. In practice, you&#x27;re correct: &quot;set theory&quot;, generally referring to ZF (or some closely related derivative thereof) with the Von Neumann Universe, doesn&#x27;t allow sets to contain themselves. But it <i>is</i> possible to axiomatize set theory where sets can contain themselves [0].<p>This replaces the axiom of foundation with the axiom of anti-foundation [1], so it&#x27;s not naive set theory but it is an axiomatized non-well-founded set theory.<p>[0]: <a href="https:&#x2F;&#x2F;plato.stanford.edu&#x2F;entries&#x2F;nonwellfounded-set-theory&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;plato.stanford.edu&#x2F;entries&#x2F;nonwellfounded-set-theory...</a><p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aczel%27s_anti-foundation_axiom" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Aczel%27s_anti-foundation_axio...</a></div><br/><div id="36595154" class="c"><input type="checkbox" id="c-36595154" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36594866">parent</a><span>|</span><a href="#36591605">next</a><span>|</span><label class="collapse" for="c-36595154">[-]</label><label class="expand" for="c-36595154">[2 more]</label></div><br/><div class="children"><div class="content">My understanding was that you just had to get rid of the law of the excluded middle. Then things like Russell&#x27;s Paradox can be stated, but evaluate to neither true nor false, and be fine. Is that not correct?</div><br/><div id="36595944" class="c"><input type="checkbox" id="c-36595944" checked=""/><div class="controls bullet"><span class="by">climatologist</span><span>|</span><a href="#36593590">root</a><span>|</span><a href="#36595154">parent</a><span>|</span><a href="#36591605">next</a><span>|</span><label class="collapse" for="c-36595944">[-]</label><label class="expand" for="c-36595944">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more to do with unrestricted circular self-reference than excluded middle but what you&#x27;re saying makes sense. Without excluded middle there is no contradiction. There is something called Curry&#x27;s paradox which is similar. Excluded middle is not involved in Curry&#x27;s paradox but circular self-refernece is still the culprit for the paradoxical conclusion.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36591605" class="c"><input type="checkbox" id="c-36591605" checked=""/><div class="controls bullet"><span class="by">rocketbop</span><span>|</span><a href="#36593590">prev</a><span>|</span><a href="#36591594">next</a><span>|</span><label class="collapse" for="c-36591605">[-]</label><label class="expand" for="c-36591605">[1 more]</label></div><br/><div class="children"><div class="content">Discussed yesterday also.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36576352">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36576352</a></div><br/></div></div><div id="36591594" class="c"><input type="checkbox" id="c-36591594" checked=""/><div class="controls bullet"><span class="by">ccday</span><span>|</span><a href="#36591605">prev</a><span>|</span><a href="#36596962">next</a><span>|</span><label class="collapse" for="c-36591594">[-]</label><label class="expand" for="c-36591594">[19 more]</label></div><br/><div class="children"><div class="content">Very excited to hear about this. Elixir is a fantastic language but tooling lags behind some other options, a type system should help with that.</div><br/><div id="36591634" class="c"><input type="checkbox" id="c-36591634" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36591594">parent</a><span>|</span><a href="#36596962">next</a><span>|</span><label class="collapse" for="c-36591634">[-]</label><label class="expand" for="c-36591634">[18 more]</label></div><br/><div class="children"><div class="content">&gt;  tooling lags behind some other options.<p>Just out of curiosity. What other options?</div><br/><div id="36591681" class="c"><input type="checkbox" id="c-36591681" checked=""/><div class="controls bullet"><span class="by">ccday</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591634">parent</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36591681">[-]</label><label class="expand" for="c-36591681">[8 more]</label></div><br/><div class="children"><div class="content">I use IDEA and most typed languages I write (eg Java, Go, Python with annotations) have better support for things like automated refactoring, bug detection via static analysis, etc</div><br/><div id="36591760" class="c"><input type="checkbox" id="c-36591760" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591681">parent</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36591760">[-]</label><label class="expand" for="c-36591760">[7 more]</label></div><br/><div class="children"><div class="content">Dialyzer gets you pretty far, Especially since Elixir is dynamically typed.</div><br/><div id="36592092" class="c"><input type="checkbox" id="c-36592092" checked=""/><div class="controls bullet"><span class="by">wofo</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591760">parent</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36592092">[-]</label><label class="expand" for="c-36592092">[6 more]</label></div><br/><div class="children"><div class="content">After spending 6 months working on an Elixir codebase, and spoiled by languages with proper IDE support, I&#x27;d say Dialyzer is nice... But doesn&#x27;t get even close to what I&#x27;m used to. Sometimes the benefits of the BEAM and the OTP outweight these drawbacks, of course, but to me it sucked the joy out of programming (I&#x27;m very type oriented when writing and, more importantly, reading code).</div><br/><div id="36592796" class="c"><input type="checkbox" id="c-36592796" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592092">parent</a><span>|</span><a href="#36592453">next</a><span>|</span><label class="collapse" for="c-36592796">[-]</label><label class="expand" for="c-36592796">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (I&#x27;m very type oriented when writing and, more importantly, reading code).<p>Me too!<p>Have you learned any tricks for getting up to speed on large code bases with very limited static typing?<p>In recent years I&#x27;ve mostly worked on large, complex Python systems.  The consequences of (undisciplined) dynamic typing not only sapped my joy in programming, it really burned me out.<p>Some people are really good at living with code bases like that.  I&#x27;m not one of them, but I&#x27;m still hoping to find some way to bridge the mental gap.</div><br/></div></div><div id="36592453" class="c"><input type="checkbox" id="c-36592453" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592092">parent</a><span>|</span><a href="#36592796">prev</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36592453">[-]</label><label class="expand" for="c-36592453">[4 more]</label></div><br/><div class="children"><div class="content">Personally I am most affected by language features that didn’t exist before September, 2021.</div><br/><div id="36592876" class="c"><input type="checkbox" id="c-36592876" checked=""/><div class="controls bullet"><span class="by">ljlolel</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592453">parent</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36592876">[-]</label><label class="expand" for="c-36592876">[3 more]</label></div><br/><div class="children"><div class="content">Are you an AI?</div><br/><div id="36593615" class="c"><input type="checkbox" id="c-36593615" checked=""/><div class="controls bullet"><span class="by">reilly3000</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592876">parent</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36593615">[-]</label><label class="expand" for="c-36593615">[2 more]</label></div><br/><div class="children"><div class="content">Are you?</div><br/><div id="36595056" class="c"><input type="checkbox" id="c-36595056" checked=""/><div class="controls bullet"><span class="by">justinjlynn</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36593615">parent</a><span>|</span><a href="#36591673">next</a><span>|</span><label class="collapse" for="c-36595056">[-]</label><label class="expand" for="c-36595056">[1 more]</label></div><br/><div class="children"><div class="content">That face when you realise that it&#x27;s all Actual Intelligence and it&#x27;s just some of it has extra steps.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36591673" class="c"><input type="checkbox" id="c-36591673" checked=""/><div class="controls bullet"><span class="by">totallywrong</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591634">parent</a><span>|</span><a href="#36591681">prev</a><span>|</span><a href="#36596962">next</a><span>|</span><label class="collapse" for="c-36591673">[-]</label><label class="expand" for="c-36591673">[9 more]</label></div><br/><div class="children"><div class="content">Elixir leverages Erlang&#x2F;OTP and the BEAM which is basically a whole platform for applications. Probably only the Java &#x2F; JVM ecosystem is on par.</div><br/><div id="36591689" class="c"><input type="checkbox" id="c-36591689" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591673">parent</a><span>|</span><a href="#36596962">next</a><span>|</span><label class="collapse" for="c-36591689">[-]</label><label class="expand" for="c-36591689">[8 more]</label></div><br/><div class="children"><div class="content">The tooling in the elixir ecosystem is excelent. The only lang&#x2F;ecosystem that I think does a better job is maybe Rust.</div><br/><div id="36592265" class="c"><input type="checkbox" id="c-36592265" checked=""/><div class="controls bullet"><span class="by">dns_snek</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591689">parent</a><span>|</span><a href="#36592456">next</a><span>|</span><label class="collapse" for="c-36592265">[-]</label><label class="expand" for="c-36592265">[5 more]</label></div><br/><div class="children"><div class="content">I love Elixir, I use it daily, but I have to disagree. Elixir tooling is in my opinion one of the only sore spots of the ecosystem and its quality is seriously lagging behind the vast majority of other languages. When I say &quot;tooling&quot;, I&#x27;m talking about language servers and overall editor support.<p>As much as I appreciate the work the team has done, I think we have to be honest about the good and bad parts. ElixirLS has never worked quite right for me, or most other Elixir developers I know. It&#x27;s often painfully slow to respond even in small project, it often gets stuck in obscure failures that require an editor reload to get it fully working again. If you run into any kind of issue with it, the boilerplate response it always: Try running `rm -rf .elixir_ls _build` which sometimes works, but usually not.<p>Javascript, Typescript have immaculate tooling in this regard, same goes for Java, C#, Go, even Python (on IDE side, the package management situation is of course a dumpster fire). I&#x27;d go as far as to say that any language supported by Jetbrains has better tooling than Elixir does.</div><br/><div id="36592484" class="c"><input type="checkbox" id="c-36592484" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592265">parent</a><span>|</span><a href="#36593263">next</a><span>|</span><label class="collapse" for="c-36592484">[-]</label><label class="expand" for="c-36592484">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;elixir-tools">https:&#x2F;&#x2F;github.com&#x2F;elixir-tools</a><p>Check out next-ls aims to replace ElixirLS.<p><a href="https:&#x2F;&#x2F;www.elixir-tools.dev&#x2F;next-ls&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.elixir-tools.dev&#x2F;next-ls&#x2F;</a><p>There&#x27;s a podcast&#x2F;interview from its creator below.<p><a href="https:&#x2F;&#x2F;podcast.thinkingelixir.com&#x2F;153" rel="nofollow noreferrer">https:&#x2F;&#x2F;podcast.thinkingelixir.com&#x2F;153</a></div><br/></div></div><div id="36593263" class="c"><input type="checkbox" id="c-36593263" checked=""/><div class="controls bullet"><span class="by">losvedir</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592265">parent</a><span>|</span><a href="#36592484">prev</a><span>|</span><a href="#36593764">next</a><span>|</span><label class="collapse" for="c-36593263">[-]</label><label class="expand" for="c-36593263">[2 more]</label></div><br/><div class="children"><div class="content">I use VSCode at work on our Elixir codebases so I feel your pain trying to get ElixirLS working, though when it does work it&#x27;s pretty good. However, on my personal laptop I&#x27;ve been trying out the Zed editor which has Elixir language server capabilities out of the box (not a user installed plugin) and haven&#x27;t had any issues at all.</div><br/><div id="36594286" class="c"><input type="checkbox" id="c-36594286" checked=""/><div class="controls bullet"><span class="by">sk0g</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36593263">parent</a><span>|</span><a href="#36593764">next</a><span>|</span><label class="collapse" for="c-36594286">[-]</label><label class="expand" for="c-36594286">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t heard of Zed before, feels pretty snappy! Will try it out some more on other projects, though I can&#x27;t tell how to set it up with PyEnv packages off the bat.</div><br/></div></div></div></div><div id="36593764" class="c"><input type="checkbox" id="c-36593764" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36592265">parent</a><span>|</span><a href="#36593263">prev</a><span>|</span><a href="#36592456">next</a><span>|</span><label class="collapse" for="c-36593764">[-]</label><label class="expand" for="c-36593764">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It&#x27;s often painfully slow to respond even in small project</i><p>I had that problem with NeoVim&#x27;s Mason plugin that manages language servers, then I just cloned `elixir-ls` and made a super small script to update it daily from GitHub and recompile it. I use that in NeoVim instead and it works near-instantly. Give it a try.<p>I don&#x27;t disagree that IDE support can look subpar but I&#x27;d also venture a guess that proper IDE support is very first-world problem. You won&#x27;t find yourself working on projects with millions of lines in Elixir ever, and thus not having e.g. full-blown IDE refactoring has never been a problem for me or any other Elixir dev I know.<p>All that being said, literally nothing I have ever saw was able to beat Golang&#x27;s and OCaml&#x27;s language servers. <i>They just work</i> and are amazingly fast to boot. It&#x27;s simply a joy coding in those languages with their LS. Rust is trailing closely behind but it&#x27;s also a fact that its LS is objectively slower -- still, they seem to have made a lot of strides on that front lately and it&#x27;s much better compared to even one year ago.</div><br/></div></div></div></div><div id="36592456" class="c"><input type="checkbox" id="c-36592456" checked=""/><div class="controls bullet"><span class="by">answiftydev</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591689">parent</a><span>|</span><a href="#36592265">prev</a><span>|</span><a href="#36594718">next</a><span>|</span><label class="collapse" for="c-36592456">[-]</label><label class="expand" for="c-36592456">[1 more]</label></div><br/><div class="children"><div class="content">The command line tooling is pretty good, the elixirls&#x2F;ide integration is pretty poor compared to other languages I have worked with.  Some trivial examples while learning live view.  Using : in pattern matching brings up erlang modules, instead of the atom I used elsewhere in the file. html.heex and the ~H sigil can’t seem to support both html and elixir syntax intellsense at the same time.  I also somehow got def in intellsense to not make a new function but instead autocomplete to def(). Finally, after hearing how great Ecto was I was hoping it could provide some sort of hints based on the names of tables&#x2F;rows I had provided in the migrations.</div><br/></div></div><div id="36594718" class="c"><input type="checkbox" id="c-36594718" checked=""/><div class="controls bullet"><span class="by">jcpst</span><span>|</span><a href="#36591594">root</a><span>|</span><a href="#36591689">parent</a><span>|</span><a href="#36592456">prev</a><span>|</span><a href="#36596962">next</a><span>|</span><label class="collapse" for="c-36594718">[-]</label><label class="expand" for="c-36594718">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, can’t agree on that one. I like to play with elixir in my spare time, love the language. There is a ton of great tooling. But I use C# and Rider at work, and the IDE experience is light-years better.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36596962" class="c"><input type="checkbox" id="c-36596962" checked=""/><div class="controls bullet"><span class="by">querulous</span><span>|</span><a href="#36591594">prev</a><span>|</span><a href="#36591662">next</a><span>|</span><label class="collapse" for="c-36596962">[-]</label><label class="expand" for="c-36596962">[1 more]</label></div><br/><div class="children"><div class="content">how does the type system handle `receive` in erlang&#x2F;elixir? does it just require every `receive` clause have a catchall case (meaning every `receive` is any -&gt; T) or does it only guarantee type checking in the absence of external messages?</div><br/></div></div><div id="36591662" class="c"><input type="checkbox" id="c-36591662" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#36596962">prev</a><span>|</span><a href="#36592212">next</a><span>|</span><label class="collapse" for="c-36591662">[-]</label><label class="expand" for="c-36591662">[11 more]</label></div><br/><div class="children"><div class="content">There seems to be a pattern of introducing static types into previously weakly typed or dynamically typed languages. I think this is because people have written many large projects in them, and without types, it&#x27;s quite hard to enforce an API or document what to pass into it if there are no types.<p>The drawbacks to statically typed languages have become way less significant since most of them have &quot;var&quot; or an equivalent which saves on typing.</div><br/><div id="36591841" class="c"><input type="checkbox" id="c-36591841" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36591662">parent</a><span>|</span><a href="#36593110">next</a><span>|</span><label class="collapse" for="c-36591841">[-]</label><label class="expand" for="c-36591841">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also not your &quot;standard static&quot; type system. It&#x27;s a new type system that novel using Set Theoretical Types. Which is kind of interesting. because if Elixir can get this working properly, it would also probably work for other Strong Dynamically Typed languages.<p>Imagine if Typescript&#x27;s type system if it were actually sound.<p>The research paper is here if anyone wants to read it.
<a href="https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.irif.fr&#x2F;_media&#x2F;users&#x2F;gduboc&#x2F;elixir-types.pdf</a></div><br/></div></div><div id="36593110" class="c"><input type="checkbox" id="c-36593110" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#36591662">parent</a><span>|</span><a href="#36591841">prev</a><span>|</span><a href="#36591720">next</a><span>|</span><label class="collapse" for="c-36593110">[-]</label><label class="expand" for="c-36593110">[4 more]</label></div><br/><div class="children"><div class="content">&quot;var&quot; does not &quot;save on typing&quot;, at least not in C#. A variable declared with var is still statically typed. Its type is just inferred from context. The compiler will assign it the most specific type possible from that context. That&#x27;s the important point - this occurs at compile time, not runtime.</div><br/><div id="36593535" class="c"><input type="checkbox" id="c-36593535" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#36591662">root</a><span>|</span><a href="#36593110">parent</a><span>|</span><a href="#36591720">next</a><span>|</span><label class="collapse" for="c-36593535">[-]</label><label class="expand" for="c-36593535">[3 more]</label></div><br/><div class="children"><div class="content">You have perhaps misconstrued what your parent was saying.<p>Typing has two meanings, the one intended here wasn&#x27;t about types - it was about keyboards. The var keyword and similar syntax in modern languages is less typing where &quot;typing&quot; means pushing the little buttons on the keyboard, and the associated squiggles appearing on a display.</div><br/><div id="36594470" class="c"><input type="checkbox" id="c-36594470" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#36591662">root</a><span>|</span><a href="#36593535">parent</a><span>|</span><a href="#36591720">next</a><span>|</span><label class="collapse" for="c-36594470">[-]</label><label class="expand" for="c-36594470">[2 more]</label></div><br/><div class="children"><div class="content">Hah yeah you might be right lol - var definitely does save on keystrokes.</div><br/><div id="36596528" class="c"><input type="checkbox" id="c-36596528" checked=""/><div class="controls bullet"><span class="by">Pannoniae</span><span>|</span><a href="#36591662">root</a><span>|</span><a href="#36594470">parent</a><span>|</span><a href="#36591720">next</a><span>|</span><label class="collapse" for="c-36596528">[-]</label><label class="expand" for="c-36596528">[1 more]</label></div><br/><div class="children"><div class="content">Sorry for the ambiguous usage:)</div><br/></div></div></div></div></div></div></div></div><div id="36591720" class="c"><input type="checkbox" id="c-36591720" checked=""/><div class="controls bullet"><span class="by">slondr</span><span>|</span><a href="#36591662">parent</a><span>|</span><a href="#36593110">prev</a><span>|</span><a href="#36594626">next</a><span>|</span><label class="collapse" for="c-36591720">[-]</label><label class="expand" for="c-36591720">[1 more]</label></div><br/><div class="children"><div class="content">Elixir never really didn’t have a static type system, this is just improving it.</div><br/></div></div><div id="36594626" class="c"><input type="checkbox" id="c-36594626" checked=""/><div class="controls bullet"><span class="by">fabianhjr</span><span>|</span><a href="#36591662">parent</a><span>|</span><a href="#36591720">prev</a><span>|</span><a href="#36592627">next</a><span>|</span><label class="collapse" for="c-36594626">[-]</label><label class="expand" for="c-36594626">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  most of them have &quot;var&quot; or an equivalent which saves on typing<p>Do you mean type inference? Most typed-languages have that, even Haskell&#x2F;Scala.<p>It gets iffy on dependent type systems like Agda&#x2F;Idris.</div><br/><div id="36594650" class="c"><input type="checkbox" id="c-36594650" checked=""/><div class="controls bullet"><span class="by">seanmcdirmid</span><span>|</span><a href="#36591662">root</a><span>|</span><a href="#36594626">parent</a><span>|</span><a href="#36592627">next</a><span>|</span><label class="collapse" for="c-36594650">[-]</label><label class="expand" for="c-36594650">[1 more]</label></div><br/><div class="children"><div class="content">Scala type inference isn&#x27;t as powerful as Haskell&#x27;s primarily due to nominal subtyping. Dependent type systems are so power that they defy type inference (in general, the more expressive your types, the harder it is to infer subtyping relationships, which is the primary complexity of type inference).</div><br/></div></div></div></div><div id="36592627" class="c"><input type="checkbox" id="c-36592627" checked=""/><div class="controls bullet"><span class="by">srgpqt</span><span>|</span><a href="#36591662">parent</a><span>|</span><a href="#36594626">prev</a><span>|</span><a href="#36592212">next</a><span>|</span><label class="collapse" for="c-36592627">[-]</label><label class="expand" for="c-36592627">[2 more]</label></div><br/><div class="children"><div class="content">Indeed, even C has caught up!<p>#define let __auto_type</div><br/><div id="36594411" class="c"><input type="checkbox" id="c-36594411" checked=""/><div class="controls bullet"><span class="by">dlisboa</span><span>|</span><a href="#36591662">root</a><span>|</span><a href="#36592627">parent</a><span>|</span><a href="#36592212">next</a><span>|</span><label class="collapse" for="c-36594411">[-]</label><label class="expand" for="c-36594411">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I learn something new every day!<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Typeof.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Typeof.html</a><p>Having learned (old) C in college and taking a closer look at it lately, I was surprised how much you can make it look “modern”, what with _Generic, wchar_t, booleans and even this __auto_type.<p>It seems like with a couple #define macros and some discipline you can make it look and behave more ergonomic.</div><br/></div></div></div></div></div></div><div id="36592212" class="c"><input type="checkbox" id="c-36592212" checked=""/><div class="controls bullet"><span class="by">yewenjie</span><span>|</span><a href="#36591662">prev</a><span>|</span><label class="collapse" for="c-36592212">[-]</label><label class="expand" for="c-36592212">[6 more]</label></div><br/><div class="children"><div class="content">Is this type-system guaranteed to be sound? (Does type checking ensure no runtime type bugs?). Also, can it infer all the types if none of the types are actually annotated?<p>Also, what is the novelty about this new type system?</div><br/><div id="36592339" class="c"><input type="checkbox" id="c-36592339" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#36592212">parent</a><span>|</span><a href="#36593385">next</a><span>|</span><label class="collapse" for="c-36592339">[-]</label><label class="expand" for="c-36592339">[4 more]</label></div><br/><div class="children"><div class="content">Yes. it&#x27;s guaranteed to be sound.
As per what makes it unique, from the paper:<p><pre><code>    We present a gradual type system for Elixir, based on the framework of semantic subtyping [10, 19]. This framework, developed for and implemented by the CDuce programming language [3, 15], provides a type system centered on the use of settheoretic types (unions, intersections, negations) that satisfy the commutativity and distributivity properties of the corresponding set-theoretic operations [19]. The system is a polymorphic type system with local type inference, that is, functions are explicitly annotated with types that may contain type variables, but their applications do not require explicit instantiations: the system deduces the right instantiations of every type variable. It also features precise typing of pattern matching combined with type narrowing: the types of the capture variables of the pattern and of some variables of the matched expression are refined in the branches to take into account the results of pattern matching
</code></pre>
CDuce programming language: <a href="https:&#x2F;&#x2F;www.cduce.org" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cduce.org</a></div><br/><div id="36593463" class="c"><input type="checkbox" id="c-36593463" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#36592212">root</a><span>|</span><a href="#36592339">parent</a><span>|</span><a href="#36593385">next</a><span>|</span><label class="collapse" for="c-36593463">[-]</label><label class="expand" for="c-36593463">[3 more]</label></div><br/><div class="children"><div class="content">I had to double-check that, knowing CDuce as an XML-oriented language from when XML was hip around almost twenty years ago - and indeed it&#x27;s that language for manipulating XML. It&#x27;s been a while but I thought the point was to experiment with static typing of XML transformations, but ultimately type inference complexity results hit a wall and weren&#x27;t convincing from a practical PoV. But what do I know - after all, adding types on top of a language that isn&#x27;t statically typed seems like a pointless exercise to me when there are plenty statically typed languages. I guess it might make sense for a Python code base that&#x27;s gotten out of control maybe?</div><br/><div id="36593584" class="c"><input type="checkbox" id="c-36593584" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#36592212">root</a><span>|</span><a href="#36593463">parent</a><span>|</span><a href="#36596137">next</a><span>|</span><label class="collapse" for="c-36593584">[-]</label><label class="expand" for="c-36593584">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t make sense for certain kinds of languages.  But Elixir and Erlang unique in a way that languages like Python, Ruby, etc. are not.<p>A semi-mainstream BEAM language with static typing would be a huge boon.  For those of us who have problems that BEAM fits really well, it&#x27;s like saying Typescript doesn&#x27;t matter because other statically typed languages exist.  Which is <i>really</i> missing the point.</div><br/></div></div><div id="36596137" class="c"><input type="checkbox" id="c-36596137" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#36592212">root</a><span>|</span><a href="#36593463">parent</a><span>|</span><a href="#36593584">prev</a><span>|</span><a href="#36593385">next</a><span>|</span><label class="collapse" for="c-36596137">[-]</label><label class="expand" for="c-36596137">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s been a while but I thought the point was to experiment with static typing of XML transformations, but ultimately type inference complexity results hit a wall<p>Type inference for set theoretic type systems is expensive and that has not changed. It is not surprising either: inference is harder or undecidable in more expressive type systems.<p>We address this by providing reconstruction based only on patterns, guards, and return types. Other than that, inference is not a major limitation to us, given you don’t need to declare types today anyway.</div><br/></div></div></div></div></div></div><div id="36593385" class="c"><input type="checkbox" id="c-36593385" checked=""/><div class="controls bullet"><span class="by">daxfohl</span><span>|</span><a href="#36592212">parent</a><span>|</span><a href="#36592339">prev</a><span>|</span><label class="collapse" for="c-36593385">[-]</label><label class="expand" for="c-36593385">[1 more]</label></div><br/><div class="children"><div class="content">Nothing can infer _all_ types. Or even much of a subset. I was surprised to learn that Hindley Milner can&#x27;t infer &quot;id&quot; as a function argument, and attempting to extend it to do so results in undecidability: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;74869648&#x2F;171121" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;74869648&#x2F;171121</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>