<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737795674365" as="style"/><link rel="stylesheet" href="styles.css?v=1737795674365"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://composehq.com/blog/scaling-websockets-1-23-25">The hidden complexity of scaling WebSockets</a> <span class="domain">(<a href="https://composehq.com">composehq.com</a>)</span></div><div class="subtext"><span>atul-jalan</span> | <span>34 comments</span></div><br/><div><div id="42816958" class="c"><input type="checkbox" id="c-42816958" checked=""/><div class="controls bullet"><span class="by">peteforde</span><span>|</span><a href="#42817724">next</a><span>|</span><label class="collapse" for="c-42816958">[-]</label><label class="expand" for="c-42816958">[15 more]</label></div><br/><div class="children"><div class="content">This is all true, but it also serves to remind us that Rails gives developers so much out of the box, even if you&#x27;re not aware of it.<p>ActionCable is Rails&#x27; WebSockets wrapper library, and it addresses basically every pain point in the post. However, it does so in a way that all Rails developers are using the same battle-tested solution. There&#x27;s no need for every project to hack together its own proprietary approach.<p>Thundering herds, heartbeat monitoring are both covered.<p>If you need a messaging schema, I strongly recommend that you check out CableReady. It&#x27;s a powerful library for triggering outcomes on the client. It ships with a large set of operations, but adding custom operations is trivial.<p><a href="https:&#x2F;&#x2F;cableready.stimulusreflex.com&#x2F;hello-world&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cableready.stimulusreflex.com&#x2F;hello-world&#x2F;</a><p>While both ActionCable and CableReady are Rails libraries, other frameworks would score huge wins if they adopted their client libraries.</div><br/><div id="42817175" class="c"><input type="checkbox" id="c-42817175" checked=""/><div class="controls bullet"><span class="by">atul-jalan</span><span>|</span><a href="#42816958">parent</a><span>|</span><a href="#42818122">next</a><span>|</span><label class="collapse" for="c-42817175">[-]</label><label class="expand" for="c-42817175">[10 more]</label></div><br/><div class="children"><div class="content">Node has similar libraries like Socket.IO too, but it over-abstracts it a bit in my opinion.</div><br/><div id="42817348" class="c"><input type="checkbox" id="c-42817348" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817175">parent</a><span>|</span><a href="#42818122">next</a><span>|</span><label class="collapse" for="c-42817348">[-]</label><label class="expand" for="c-42817348">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done my share of building websocket servers from scratch, but when you don&#x27;t use libraries like ActiveCable or socket.io, you have to build your own MessageID reconciliation so that you can have request&#x2F;response cycles. Which is generally what you want (or eventually want) in a websocket-heavy application.<p><pre><code>    send(payload).then(reply =&gt; ...)</code></pre></div><br/><div id="42817361" class="c"><input type="checkbox" id="c-42817361" checked=""/><div class="controls bullet"><span class="by">atul-jalan</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817348">parent</a><span>|</span><a href="#42819643">next</a><span>|</span><label class="collapse" for="c-42817361">[-]</label><label class="expand" for="c-42817361">[2 more]</label></div><br/><div class="children"><div class="content">Yep, for our application, we have an `executionId` that is sent in essentially every single WebSocket message.<p>But client and server use it to maintain a record of events.</div><br/><div id="42818547" class="c"><input type="checkbox" id="c-42818547" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817361">parent</a><span>|</span><a href="#42819643">next</a><span>|</span><label class="collapse" for="c-42818547">[-]</label><label class="expand" for="c-42818547">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this JSON-RPC&#x27;s approach?</div><br/></div></div></div></div><div id="42819643" class="c"><input type="checkbox" id="c-42819643" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817348">parent</a><span>|</span><a href="#42817361">prev</a><span>|</span><a href="#42817757">next</a><span>|</span><label class="collapse" for="c-42819643">[-]</label><label class="expand" for="c-42819643">[1 more]</label></div><br/><div class="children"><div class="content">At this point why even use a websocket vs a normal request&#x2F;reply technology like grpc or json-rpc?</div><br/></div></div><div id="42817757" class="c"><input type="checkbox" id="c-42817757" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817348">parent</a><span>|</span><a href="#42819643">prev</a><span>|</span><a href="#42818897">next</a><span>|</span><label class="collapse" for="c-42817757">[-]</label><label class="expand" for="c-42817757">[4 more]</label></div><br/><div class="children"><div class="content">Or just use jsonrpc.</div><br/><div id="42818471" class="c"><input type="checkbox" id="c-42818471" checked=""/><div class="controls bullet"><span class="by">moralestapia</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817757">parent</a><span>|</span><a href="#42818897">next</a><span>|</span><label class="collapse" for="c-42818471">[-]</label><label class="expand" for="c-42818471">[3 more]</label></div><br/><div class="children"><div class="content">???<p>That solves none of the issues outlined in the post or the comments.</div><br/><div id="42819193" class="c"><input type="checkbox" id="c-42819193" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42818471">parent</a><span>|</span><a href="#42818897">next</a><span>|</span><label class="collapse" for="c-42819193">[-]</label><label class="expand" for="c-42819193">[2 more]</label></div><br/><div class="children"><div class="content">It solves the very limited problem of bike-shedding envelope shapes for request&#x2F;reply protocols, which I think was all they meant to say.<p>At its core, JSON-RPC boils down to &quot;use `id` and `method` and work the rest out&quot;, which is acceptably minimal but does leave you with a lot of other issues to deal with.</div><br/><div id="42820255" class="c"><input type="checkbox" id="c-42820255" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42819193">parent</a><span>|</span><a href="#42818897">next</a><span>|</span><label class="collapse" for="c-42820255">[-]</label><label class="expand" for="c-42820255">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit misnomer because it defines rpcs _and_ notifications.<p>What people seem to be often missing for some reason is that those two map naturally to existing semantics of the programming language they&#x27;re already using.<p>What it means in practice is that you are exposing and consuming functions (ie. on classes) – just like you do in ordinary libraries.<p>In js&#x2F;ts context it usually means async functions on classes annotated with decorators (to register method as rpc and perform runtime assertions) that are event emitters – all concepts already familiar to developers.<p>To summarize you have system that is easy to inspect, reason about and easy to use - almost like any other package in your dependency.<p>Introducing backward compatible&#x2F;incompatible changes also becomes straight forward for everybody ie. following semver on api surface just like in any ordinary package you depend on.<p>Those straight forward facts are often missed and largely underappriciated.<p>ps. in our systems we&#x27;re introducing two deviations – error code can also be strings, not just numbers (trivial); and we support async generators (emitting individual objects for array results) – which helps with head of line blocking issues for large resultsets (still compatible with jsonrpc at protocol level, although it would be nice if they supported it upstream as dedicated semantic in jsonrpc 2.1 or something). They could also specify registering and unregistering notification listeners at the spec level so everybody is using the same scheme.</div><br/></div></div></div></div></div></div></div></div><div id="42818897" class="c"><input type="checkbox" id="c-42818897" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42817348">parent</a><span>|</span><a href="#42817757">prev</a><span>|</span><a href="#42818122">next</a><span>|</span><label class="collapse" for="c-42818897">[-]</label><label class="expand" for="c-42818897">[1 more]</label></div><br/><div class="children"><div class="content">If you add Content-Negotiation it will have ALL the OSI layers! &#x2F;s<p>Honestly, I&#x27;m a little surprised and more than a bit depressed how we effectively reinvent the OSI stack so often...</div><br/></div></div></div></div></div></div><div id="42818122" class="c"><input type="checkbox" id="c-42818122" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42816958">parent</a><span>|</span><a href="#42817175">prev</a><span>|</span><a href="#42817724">next</a><span>|</span><label class="collapse" for="c-42818122">[-]</label><label class="expand" for="c-42818122">[4 more]</label></div><br/><div class="children"><div class="content">Elixir’s lightweight processes are also a good fit. Though I’ve seen some benchmarks that claim that goroutines can hit even lower overhead per connection.</div><br/><div id="42819102" class="c"><input type="checkbox" id="c-42819102" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42818122">parent</a><span>|</span><a href="#42817724">next</a><span>|</span><label class="collapse" for="c-42819102">[-]</label><label class="expand" for="c-42819102">[3 more]</label></div><br/><div class="children"><div class="content">That makes sense, Erlang&#x2F;Elixir processes are a much higher-level construct than goroutines, and they trade off performance for fault tolerance and observability.<p>As an example, with a goroutine you have to be careful to handle all errors, because a panic would take down the whole service. In Elixir a websocket handler can crash anywhere without impacting the application. This comes at a cost, because to make this safe Elixir has to isolate the processes so they don&#x27;t share memory, so each process has its own individual heap, and data gets copied around more often than in Go.</div><br/><div id="42819408" class="c"><input type="checkbox" id="c-42819408" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42819102">parent</a><span>|</span><a href="#42817724">next</a><span>|</span><label class="collapse" for="c-42819408">[-]</label><label class="expand" for="c-42819408">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As an example, with a goroutine you have to be careful to handle all errors, because a panic would take down the whole service.<p>Unless you&#x27;re the default `net&#x2F;http` library and simply recover from the panic: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;http&#x2F;server.go#L1944-L1949">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;master&#x2F;src&#x2F;net&#x2F;http&#x2F;server...</a></div><br/><div id="42820358" class="c"><input type="checkbox" id="c-42820358" checked=""/><div class="controls bullet"><span class="by">neillyons</span><span>|</span><a href="#42816958">root</a><span>|</span><a href="#42819408">parent</a><span>|</span><a href="#42817724">next</a><span>|</span><label class="collapse" for="c-42820358">[-]</label><label class="expand" for="c-42820358">[1 more]</label></div><br/><div class="children"><div class="content">You still need to be careful, as this won&#x27;t catch panics from go routines launched from your http handler.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42817724" class="c"><input type="checkbox" id="c-42817724" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#42816958">prev</a><span>|</span><a href="#42820172">next</a><span>|</span><label class="collapse" for="c-42817724">[-]</label><label class="expand" for="c-42817724">[3 more]</label></div><br/><div class="children"><div class="content">The key to managing this complexity is to avoid mixing transport-level state with application-level state. The same approach for scaling HTTP requests also works for scaling WebSocket connections:<p>* Read, write and track all application-level state in a persistent data store.<p>* Identify sessions with a session token so that application-level sessions can span multiple WebSocket connections.<p>It&#x27;s a lot easier to do this if your application-level protocol consists of a single discrete request and response (a la RPC). But you can also handle unidirectional&#x2F;bidirectional streaming, as long as the stream states are tracked in your data store and on the client side.</div><br/><div id="42818143" class="c"><input type="checkbox" id="c-42818143" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42817724">parent</a><span>|</span><a href="#42818059">next</a><span>|</span><label class="collapse" for="c-42818143">[-]</label><label class="expand" for="c-42818143">[1 more]</label></div><br/><div class="children"><div class="content">Functional core, imperative shell makes testing and this fast iteration a lot easier. It’s best if your business logic knows very little about transport mechanisms.<p>I think part of the problem is that early systems wanted to eagerly process requests while they are still coming in. But in a system getting 100s of requests per second you get better concurrency if you wait for entire payloads before you waste cache lines on attempting to make forward progress on incomplete data. Which means you can divorce the concept of a payload entirely from how you acquired it.</div><br/></div></div><div id="42818059" class="c"><input type="checkbox" id="c-42818059" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#42817724">parent</a><span>|</span><a href="#42818143">prev</a><span>|</span><a href="#42820172">next</a><span>|</span><label class="collapse" for="c-42818059">[-]</label><label class="expand" for="c-42818059">[1 more]</label></div><br/><div class="children"><div class="content">Currently another thread is going[1] which advocates very similar things, in order to reduce complexity when dealing with distributed systems.<p>Then again, the frontend and backend are a distributed system, so not that weird one comes to similar conclusions.<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42813049">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42813049</a> <i>Every System is a Log: Avoiding coordination in distributed applications</i></div><br/></div></div></div></div><div id="42820172" class="c"><input type="checkbox" id="c-42820172" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#42817724">prev</a><span>|</span><a href="#42819768">next</a><span>|</span><label class="collapse" for="c-42820172">[-]</label><label class="expand" for="c-42820172">[1 more]</label></div><br/><div class="children"><div class="content">The only complexity I have found with regards to scaling WebSockets is knowing the minimum delay between flush event completion and actual message completion to destination. It takes longer to process a message, even on IPC routing, than it does to kill a socket. That has upstream consequences with consideration of redirection and message pipes between multiple sockets. If you kill a socket too early after a message is flushed from the socket there is a good chance the destination sees the socket collapse before it has processed the final message off the socket and that processing delay is not something a remote location is easily aware of.<p>I have found for safety you need to allow an arbitrary delay of 100ms before killing sockets to ensure message completion which is likely why the protocol imposes a round trip of control frame opcode 8 before closing the connection the right way.</div><br/></div></div><div id="42819768" class="c"><input type="checkbox" id="c-42819768" checked=""/><div class="controls bullet"><span class="by">notatoad</span><span>|</span><a href="#42820172">prev</a><span>|</span><a href="#42818255">next</a><span>|</span><label class="collapse" for="c-42819768">[-]</label><label class="expand" for="c-42819768">[1 more]</label></div><br/><div class="children"><div class="content">for me, the most important lesson i&#x27;ve learned when using websockets is to <i>not</i> use them whenever possible.<p>i don&#x27;t hate them, they&#x27;re great for what they are, but they&#x27;re for realtime push of small messages only.  trying to use them for the rest of your API as well just throws out all the great things about http - like caching and load balancing, and just normal request&#x2F;response architecture. while you can use websockets for that it&#x27;s only going to cause you headaches that are already solved by simply using a normal http api for the vast majority of your api.</div><br/></div></div><div id="42818255" class="c"><input type="checkbox" id="c-42818255" checked=""/><div class="controls bullet"><span class="by">SerCe</span><span>|</span><a href="#42819768">prev</a><span>|</span><a href="#42816996">next</a><span>|</span><label class="collapse" for="c-42818255">[-]</label><label class="expand" for="c-42818255">[2 more]</label></div><br/><div class="children"><div class="content">I wrote about the way we handle WebSocket connections at Canva a while ago [1]. Even though some small things have changed here and there since the post was published, the overall approach has held up pretty well handling many millions of concurrent connections.<p>That said, even with great framework-level support, it&#x27;s much, much harder to build a streaming functionality compared to plain request&#x2F;response if you&#x27;ve got some notion of a &quot;session&quot;.<p>[1]: <a href="https:&#x2F;&#x2F;www.canva.dev&#x2F;blog&#x2F;engineering&#x2F;enabling-real-time-collaboration-with-rsocket&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.canva.dev&#x2F;blog&#x2F;engineering&#x2F;enabling-real-time-co...</a></div><br/><div id="42820010" class="c"><input type="checkbox" id="c-42820010" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42818255">parent</a><span>|</span><a href="#42816996">next</a><span>|</span><label class="collapse" for="c-42820010">[-]</label><label class="expand" for="c-42820010">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s much, much harder to build a streaming functionality compared to plain request&#x2F;response if you&#x27;ve got some notion of a &quot;session&quot;<p>This touches something that I think is starting to become understood- the concept of a &quot;session backend&quot; to address this kind of use case.<p>See the complexity of disaggregation a live session backend on AWS versus CloudFlare: <a href="https:&#x2F;&#x2F;digest.browsertech.com&#x2F;archive&#x2F;browsertech-digest-cloudflares-durable&#x2F;" rel="nofollow">https:&#x2F;&#x2F;digest.browsertech.com&#x2F;archive&#x2F;browsertech-digest-cl...</a><p>I wrote about session backends as distinct from durable execution: <a href="https:&#x2F;&#x2F;crabmusket.net&#x2F;2024&#x2F;durable-execution-versus-session-backends&#x2F;" rel="nofollow">https:&#x2F;&#x2F;crabmusket.net&#x2F;2024&#x2F;durable-execution-versus-session...</a></div><br/></div></div></div></div><div id="42816996" class="c"><input type="checkbox" id="c-42816996" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#42818255">prev</a><span>|</span><a href="#42817367">next</a><span>|</span><label class="collapse" for="c-42816996">[-]</label><label class="expand" for="c-42816996">[5 more]</label></div><br/><div class="children"><div class="content">I recall another complication with websockets: IIRC it&#x27;s with proxy load balancers, like binding a connection to a single connection server, even if the backend connection is using HTTP&#x2F;2. I probably have the details wrong. I&#x27;m sure someone will correct my statement.</div><br/><div id="42817187" class="c"><input type="checkbox" id="c-42817187" checked=""/><div class="controls bullet"><span class="by">atul-jalan</span><span>|</span><a href="#42816996">parent</a><span>|</span><a href="#42817029">next</a><span>|</span><label class="collapse" for="c-42817187">[-]</label><label class="expand" for="c-42817187">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a way to do it, but it likely involves custom headers on the initial connection that the load balancer can read to route to the correct origin server.<p>I imagine the way it might go is that the client would first send an HTTP request to an endpoint that returns routing instructions, and then use that in the custom headers it sends when initiating the WebSocket connection.<p>Haven&#x27;t tried this myself though.</div><br/></div></div><div id="42817029" class="c"><input type="checkbox" id="c-42817029" checked=""/><div class="controls bullet"><span class="by">hpx7</span><span>|</span><a href="#42816996">parent</a><span>|</span><a href="#42817187">prev</a><span>|</span><a href="#42817460">next</a><span>|</span><label class="collapse" for="c-42817029">[-]</label><label class="expand" for="c-42817029">[1 more]</label></div><br/><div class="children"><div class="content">Horizontal scaling is certainly a challenge. With traditional load balancers, you don&#x27;t control which instance your clients get routed to, so you end up needing to use message brokers or stateful routing to ensure message broadcasts work correctly with multiple websocket server instances.</div><br/></div></div><div id="42817460" class="c"><input type="checkbox" id="c-42817460" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42816996">parent</a><span>|</span><a href="#42817029">prev</a><span>|</span><a href="#42817367">next</a><span>|</span><label class="collapse" for="c-42817460">[-]</label><label class="expand" for="c-42817460">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s more that WebSockets are held open for a long time, so if you&#x27;re not careful, you can get &quot;hot&quot; backends with a lot of connections that you can&#x27;t shift to a different instance.
It can also be harder to rotate backends since you know you are disrupting a large number of active clients.</div><br/><div id="42817998" class="c"><input type="checkbox" id="c-42817998" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42816996">root</a><span>|</span><a href="#42817460">parent</a><span>|</span><a href="#42817367">next</a><span>|</span><label class="collapse" for="c-42817998">[-]</label><label class="expand" for="c-42817998">[1 more]</label></div><br/><div class="children"><div class="content">The trick to doing this efficiently is to arrange for the live session state to be available (through replication or some data bus) at the alternative back end before cut over.</div><br/></div></div></div></div></div></div><div id="42819601" class="c"><input type="checkbox" id="c-42819601" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42817367">prev</a><span>|</span><label class="collapse" for="c-42819601">[-]</label><label class="expand" for="c-42819601">[5 more]</label></div><br/><div class="children"><div class="content">&gt; WebSocket connections can be unexpectedly blocked, especially on restrictive public networks.<p>What? How would public network even know you’re running a websocket if you’re using TLS?   I dont think it’s really possible in general case<p>&gt; Since SSE is HTTP-based, it&#x27;s much less likely to be blocked, providing a reliable alternative in restricted environments.<p>And websockets are not http-based?<p>What article describes as challenges seems like very pedestrian things that any rpc-based backend needs to solve.<p>The real reason websockets are hard to scale is because they pin state to a particular backend replica so if the whole bunch of them disconnect <i>at scale</i> the system might run out of resources trying to re-load all that state</div><br/><div id="42820414" class="c"><input type="checkbox" id="c-42820414" checked=""/><div class="controls bullet"><span class="by">pk-protect-ai</span><span>|</span><a href="#42819601">parent</a><span>|</span><a href="#42819642">next</a><span>|</span><label class="collapse" for="c-42820414">[-]</label><label class="expand" for="c-42820414">[1 more]</label></div><br/><div class="children"><div class="content">I agree here. I have had an experience of scaling WebSockets server to 20M connections on a single server (with this one <a href="https:&#x2F;&#x2F;github.com&#x2F;ITpC&#x2F;LAppS.git">https:&#x2F;&#x2F;github.com&#x2F;ITpC&#x2F;LAppS.git</a>). However there are several issues with scaling WebSockets, on the backends as well: mutex locking, non-parallel XOR of input stream, utf8 validation. 
I do not know the state of the above repository code, it seems that it was never updated for at least 5 years. There were bugs in HTTP parsing in the client part for some cases. Though vertical scalability was excellent. Sad this thing never reached production state.</div><br/></div></div><div id="42819642" class="c"><input type="checkbox" id="c-42819642" checked=""/><div class="controls bullet"><span class="by">atul-jalan</span><span>|</span><a href="#42819601">parent</a><span>|</span><a href="#42820414">prev</a><span>|</span><label class="collapse" for="c-42819642">[-]</label><label class="expand" for="c-42819642">[3 more]</label></div><br/><div class="children"><div class="content">The initial handshake will usually include an `Upgrade: websocket` header, which can be inspected by networks.</div><br/><div id="42819658" class="c"><input type="checkbox" id="c-42819658" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#42819601">root</a><span>|</span><a href="#42819642">parent</a><span>|</span><label class="collapse" for="c-42819658">[-]</label><label class="expand" for="c-42819658">[2 more]</label></div><br/><div class="children"><div class="content">No, it literally can not be because by the time Upgrade header appears the connection is already encrypted.</div><br/><div id="42820312" class="c"><input type="checkbox" id="c-42820312" checked=""/><div class="controls bullet"><span class="by">jauco</span><span>|</span><a href="#42819601">root</a><span>|</span><a href="#42819658">parent</a><span>|</span><label class="collapse" for="c-42820312">[-]</label><label class="expand" for="c-42820312">[1 more]</label></div><br/><div class="children"><div class="content">Restricted environments in larger corporations can do a full mitm proxy</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>