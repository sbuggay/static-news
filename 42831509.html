<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737968469769" as="style"/><link rel="stylesheet" href="styles.css?v=1737968469769"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mort.coffee/home/wayland-input-latency/">Hard numbers in the Wayland vs. X11 input latency discussion</a> <span class="domain">(<a href="https://mort.coffee">mort.coffee</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>243 comments</span></div><br/><div><div id="42832550" class="c"><input type="checkbox" id="c-42832550" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#42832090">next</a><span>|</span><label class="collapse" for="c-42832550">[-]</label><label class="expand" for="c-42832550">[89 more]</label></div><br/><div class="children"><div class="content">This is excellent. Too often people guess at things when they could be more empirical about them. Ever since I learned the scientific method (I think 3rd or 4th grade) I was all about the &#x27;let&#x27;s design an experiment&#x27; :-).<p>Let me state up front that I have no idea why Wayland would have this additional latency. That said, having been active in the computer community at the &#x27;birth&#x27; of X11 (yes I&#x27;m that old) I can tell you that there was, especially early on, a constant whine about screen latency. Whether it was cursor response or xterm scrolling. When &quot;workstations&quot; became a thing, they sometimes had explicit display hardware for just the mouse because that would cut out the latency of rendering the mouse in the frame. (not to mention the infamous XOR patent[1])<p>As a result of all this whinging, the code paths that were between keyboard&#x2F;mouse input and their effect on the screen, were <i>constantly</i> being evaluated for ways to &quot;speed them up and reduce latency.&quot; Wayland, being something relatively &quot;new&quot; compared to X11, has not had this level of scrutiny for as long. I&#x27;m looking forward to folks fixing it though.<p>[1] <a href="https:&#x2F;&#x2F;patents.google.com&#x2F;patent&#x2F;US4197590" rel="nofollow">https:&#x2F;&#x2F;patents.google.com&#x2F;patent&#x2F;US4197590</a></div><br/><div id="42833313" class="c"><input type="checkbox" id="c-42833313" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42832618">next</a><span>|</span><label class="collapse" for="c-42833313">[-]</label><label class="expand" for="c-42833313">[26 more]</label></div><br/><div class="children"><div class="content">Display devices (usually part of your GPU) still have &quot;explicit display hardware just for the mouse&quot; in form of cursor planes. Later this has been generalized as overlay planes.<p>Planes can be updated and repositioned without redrawing the rest of the screen (the regular screen image is on the primary plane), so moving the cursor is just a case of committing the new plane position.<p>The input latency introduced by GNOME&#x27;s Mutter (the Wayland server used here) is likely simply a matter of their input sampling and commit timing strategy. Different servers have different strategies and priorities there, which can be good and bad.<p>Wayland, which is a protocol, is not involved in the process of positioning regular cursors, so this is entirely display server internals and optimization. What happens on the protocol level is allowing clients to set the cursor image, and telling clients where the cursor is.</div><br/><div id="42833943" class="c"><input type="checkbox" id="c-42833943" checked=""/><div class="controls bullet"><span class="by">smallmancontrov</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833313">parent</a><span>|</span><a href="#42835251">next</a><span>|</span><label class="collapse" for="c-42833943">[-]</label><label class="expand" for="c-42833943">[9 more]</label></div><br/><div class="children"><div class="content">Protocols can bake in unfortunate performance implications simply by virtue of defining an interface that doesn&#x27;t fit the shape needed for good performance. Furthermore, this tends to happen &quot;by default&quot; unless there is a strong voice for performance in the design process.<p>Hopefully this general concern doesn&#x27;t apply to Wayland and the &quot;shape&quot; you have described doesn&#x27;t sound bad, but the devil is in the details.</div><br/><div id="42834451" class="c"><input type="checkbox" id="c-42834451" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833943">parent</a><span>|</span><a href="#42834416">next</a><span>|</span><label class="collapse" for="c-42834451">[-]</label><label class="expand" for="c-42834451">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the Wayland protocol is actually involved in this. Wayland describes how clients communicate with the compositor. Neither the cursor, nor the mouse are a client, so no where in the path between moving the mouse and the cursor moving on screen is Wayland actually involved.<p>The story is different for applications like games that hide the system cursor to display their own. In those cases, the client needs to receive mouse events from the compositor, then redraw the surface appropriately, all of which does go through Wayland.</div><br/><div id="42838787" class="c"><input type="checkbox" id="c-42838787" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834451">parent</a><span>|</span><a href="#42835064">next</a><span>|</span><label class="collapse" for="c-42838787">[-]</label><label class="expand" for="c-42838787">[1 more]</label></div><br/><div class="children"><div class="content">Well there are opportunities to do the wrong thing though, like sending an event to the client every time it get an update. Which means that high poll rate mice would DDOS less efficient clients. This used to be a problem in Mutter, but that particular issue was fixed.</div><br/></div></div><div id="42835064" class="c"><input type="checkbox" id="c-42835064" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834451">parent</a><span>|</span><a href="#42838787">prev</a><span>|</span><a href="#42834416">next</a><span>|</span><label class="collapse" for="c-42835064">[-]</label><label class="expand" for="c-42835064">[5 more]</label></div><br/><div class="children"><div class="content">According to Asahi Lina, X does async ioctl that can update the cursor even during the scanout of the current frame, while Wayland does atomic, synced updates on everything, cursor involved, which has the benefit of no tearing and the cursor&#x27;s state is always in sync with the content, but it does add an average of 1 more frame latency (either updates just in time for the next frame), or it <i>will</i> go to the next frame.</div><br/><div id="42835745" class="c"><input type="checkbox" id="c-42835745" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835064">parent</a><span>|</span><a href="#42837104">next</a><span>|</span><label class="collapse" for="c-42835745">[-]</label><label class="expand" for="c-42835745">[2 more]</label></div><br/><div class="children"><div class="content">This is not what <i>Wayland</i> does, it is what a particular display server with Wayland support decided to do.<p>Second, just to be clear, this only discusses mouse cursors on the desktop - not the content of windows, and in particular not games even if they have cursors. Just the white cursor you browse the Web with.<p>Anyway, what you refer to is the legacy drm interface that was replaced by the atomic one. The legacy interface is very broken  and does not expose new hardware features, but it did indeed handle cursors as its own magical entity.<p>The atomic API does support tearing updates, but cursor updates are currently rejected in that path as drivers are not ready for that, and at the same time, current consensus is that tearing is toggled on when a particular fullscreen game demands it, and games composite any cursors in their own render pass so they&#x27;re unaffected. Drivers will probably support this eventually, but it&#x27;s not meant to be a general solution.<p>The legacy API <i>could</i> let some hardware swap the cursor position mid-scanout, possibly tearing the cursor, but just because the call is made mid-scanout does not mean that the driver or hardware would do it.<p>&gt; but it does add an average of 1 more frame latency<p>If you commit just in time (display servers aim to commit as late as possible), then the delay between the commit and a tearing update made just before the pixels were pushed is dependent on the cursor position - if the cursor is at the first line shown, it makes no difference, if on the last shown, it&#x27;ll be almost a frame newer.<p>Averaging cursor positions mean half a frame of extra latency, but with a steady sampling rate instead of rolling shutter.<p>Proper commit timing is usually the proper solution, and more importantly helps every other aspect of content delivery as well.</div><br/><div id="42838311" class="c"><input type="checkbox" id="c-42838311" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835745">parent</a><span>|</span><a href="#42837104">next</a><span>|</span><label class="collapse" for="c-42838311">[-]</label><label class="expand" for="c-42838311">[1 more]</label></div><br/><div class="children"><div class="content">Sure, it&#x27;s what Gnome Wayland does, but the Wayland protocol does sort of mandate that every frame should be perfect, and the cursor has to match the underlying content, e.g. if it moves over a text it has to change to denote that it is selectable.<p>I do believe it is a useful tradeoff, though.</div><br/></div></div></div></div><div id="42837104" class="c"><input type="checkbox" id="c-42837104" checked=""/><div class="controls bullet"><span class="by">TapamN</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835064">parent</a><span>|</span><a href="#42835745">prev</a><span>|</span><a href="#42834416">next</a><span>|</span><label class="collapse" for="c-42837104">[-]</label><label class="expand" for="c-42837104">[2 more]</label></div><br/><div class="children"><div class="content">It seems like it should be possible to do the X async method without tearing.<p>When updating the cursor position, check if line being output overlaps with the cursor. If it isn&#x27;t, it&#x27;s safe to update the hardware cursor immediately, without tearing. Otherwise, defer updating the cursor until later (vblank would work) to avoid tearing.<p>Of course, this assumes it&#x27;s possible to read what row of the frame buffer is being displayed. I think most hardware would support it, but I could see driver support being poorly tested, or possibly even missing entirely from Linux&#x27;s video APIs.</div><br/><div id="42838559" class="c"><input type="checkbox" id="c-42838559" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42837104">parent</a><span>|</span><a href="#42834416">next</a><span>|</span><label class="collapse" for="c-42838559">[-]</label><label class="expand" for="c-42838559">[1 more]</label></div><br/><div class="children"><div class="content">This would have to be done by the kernel driver for you GPU. I kind of doubt that it&#x27;s possible (you&#x27;re not really scanning out lines anymore with things like Display Stream Compression, partial panel self refresh and weird buffer formats), and doubt even more that kernel devs would consider it worth the maintenance burden...</div><br/></div></div></div></div></div></div></div></div><div id="42834416" class="c"><input type="checkbox" id="c-42834416" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833943">parent</a><span>|</span><a href="#42834451">prev</a><span>|</span><a href="#42835251">next</a><span>|</span><label class="collapse" for="c-42834416">[-]</label><label class="expand" for="c-42834416">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, Wayland isn&#x27;t designed in such a way that would require any additional latency on cursor updates. The Wayland protocols almost entirely regard how applications talk to the compositor, and don&#x27;t really specify how the compositor handles input or output directly. So the pipeline from mouse input coming from evdev devices and then eventually going to DRM planes doesn&#x27;t <i>actually</i> involve Wayland.</div><br/></div></div></div></div><div id="42835251" class="c"><input type="checkbox" id="c-42835251" checked=""/><div class="controls bullet"><span class="by">wmanley</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833313">parent</a><span>|</span><a href="#42833943">prev</a><span>|</span><a href="#42838285">next</a><span>|</span><label class="collapse" for="c-42835251">[-]</label><label class="expand" for="c-42835251">[14 more]</label></div><br/><div class="children"><div class="content">Software works best when the developers take responsibility for solving user&#x27;s problems.<p>&gt; Wayland, which is a protocol<p>This is wayland&#x27;s biggest weakness.  The effect is diffusion of responsibility.</div><br/><div id="42838062" class="c"><input type="checkbox" id="c-42838062" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835251">parent</a><span>|</span><a href="#42835526">next</a><span>|</span><label class="collapse" for="c-42838062">[-]</label><label class="expand" for="c-42838062">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the biggest strength!<p>Every time someone complains about wayland there&#x27;s someone informing you how it achtually it isn&#x27;t.</div><br/><div id="42838431" class="c"><input type="checkbox" id="c-42838431" checked=""/><div class="controls bullet"><span class="by">tankenmate</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42838062">parent</a><span>|</span><a href="#42838333">next</a><span>|</span><label class="collapse" for="c-42838431">[-]</label><label class="expand" for="c-42838431">[1 more]</label></div><br/><div class="children"><div class="content">Your biggest strength is also your biggest weakness.<p>The organisation of Wayland sounds great, but it is very hard to share optimised code between compositors since key parts that affect performance (in this case latency) are largely developed outside of any shared library code.<p>The &quot;organisation&quot; of Wayland reminds me of the UNIX wars; this is going to get worse before it gets better.<p>SVR4 Wayland anyone?<p>xref the time it has taken the Rust rewrite of the GNU coreutils and arguably coreutils is a much easier problem.</div><br/></div></div><div id="42838333" class="c"><input type="checkbox" id="c-42838333" checked=""/><div class="controls bullet"><span class="by">genewitch</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42838062">parent</a><span>|</span><a href="#42838431">prev</a><span>|</span><a href="#42835526">next</a><span>|</span><label class="collapse" for="c-42838333">[-]</label><label class="expand" for="c-42838333">[1 more]</label></div><br/><div class="children"><div class="content">See also AI discussions and holding a telephone incorrectly, also do we not own phones</div><br/></div></div></div></div><div id="42835526" class="c"><input type="checkbox" id="c-42835526" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835251">parent</a><span>|</span><a href="#42838062">prev</a><span>|</span><a href="#42838589">next</a><span>|</span><label class="collapse" for="c-42835526">[-]</label><label class="expand" for="c-42835526">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;re kind of getting tripped up on terminology. The OP didn&#x27;t measure Wayland; they measured GNOME Shell which does take responsibility for its performance. Also, I&#x27;m not aware of any latency-related mistakes in Wayland&#x2F;Weston (given its goal of tear-free compositing).</div><br/><div id="42836347" class="c"><input type="checkbox" id="c-42836347" checked=""/><div class="controls bullet"><span class="by">wmanley</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835526">parent</a><span>|</span><a href="#42838589">next</a><span>|</span><label class="collapse" for="c-42836347">[-]</label><label class="expand" for="c-42836347">[5 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;re kind of getting tripped up on terminology.<p>I&#x27;m not.  My comment doesn&#x27;t address the latency of gnome shell.  I understand the boring technical distinctions between wayland and wayland client libraries and wayland display servers and gnome shell and mutter and sway, blah blah blah.  Much like I understand that Linux is a kernel.  That it is inspired by UNIX, but it is technically not a UNIX.  I also understand that if someone describes themselves as a Linux user they probably don&#x27;t just mean that they have a Android phone or that the display controller in their dishwasher or wireless access point happens to include Linux the kernel.<p>The &quot;well acksually wayland is just the name of the protocol&quot; that emerges whenever a problem is brought up is a symptom of the underlying problem with <i>wayland the system</i>.  The confusion that gives rise to these deflections is also a symptom of that problem.<p>By Conway&#x27;s law systems end up resembling the organisations that produce them.  In this way the design of wayland the system seems to be designed by people who don&#x27;t want to work together.  I can see a parallel with microservice architecture.</div><br/><div id="42837362" class="c"><input type="checkbox" id="c-42837362" checked=""/><div class="controls bullet"><span class="by">WhyNotHugo</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42836347">parent</a><span>|</span><a href="#42838589">next</a><span>|</span><label class="collapse" for="c-42837362">[-]</label><label class="expand" for="c-42837362">[4 more]</label></div><br/><div class="children"><div class="content">The distinction between protocol and implementation IS significant here.<p>Imagine comparing HTTP1.1 vs HTTP3. These are protocols, but in practice one compares implementations. I can pick curl for http1.1, but Python for http3, and http3 would very likely measures as slower.<p>Is that the protocols fault?</div><br/><div id="42837689" class="c"><input type="checkbox" id="c-42837689" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42837362">parent</a><span>|</span><a href="#42837650">next</a><span>|</span><label class="collapse" for="c-42837689">[-]</label><label class="expand" for="c-42837689">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; <i>”well acksually wayland is just the name of the protocol&quot; […] is a symptom of the underlying problem</i><p>&gt; <i>well acksually</i><p>It’s not the protocol’s fault, but the system and organisation that brought it.</div><br/></div></div><div id="42837650" class="c"><input type="checkbox" id="c-42837650" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42837362">parent</a><span>|</span><a href="#42837689">prev</a><span>|</span><a href="#42838589">next</a><span>|</span><label class="collapse" for="c-42837650">[-]</label><label class="expand" for="c-42837650">[2 more]</label></div><br/><div class="children"><div class="content">All this proves is that it&#x27;s possible for a protocol to not be the determining factor; which says nothing about whether it&#x27;s possible that it _is_ a determining factor.</div><br/><div id="42837846" class="c"><input type="checkbox" id="c-42837846" checked=""/><div class="controls bullet"><span class="by">WhyNotHugo</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42837650">parent</a><span>|</span><a href="#42838589">next</a><span>|</span><label class="collapse" for="c-42837846">[-]</label><label class="expand" for="c-42837846">[1 more]</label></div><br/><div class="children"><div class="content">You’re quite right. We’d need similar benchmarks done with other compositors.<p>I very much doubt that Wayland makes a difference for this test; Wayland is for IPC between the client and server. Moving the cursor around is done by the server, without needing to talk to the client.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42838589" class="c"><input type="checkbox" id="c-42838589" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835251">parent</a><span>|</span><a href="#42835526">prev</a><span>|</span><a href="#42836902">next</a><span>|</span><label class="collapse" for="c-42838589">[-]</label><label class="expand" for="c-42838589">[1 more]</label></div><br/><div class="children"><div class="content">Is it a weakness of the web that HTTP is just a protocol specification?<p>The &quot;problem&quot; with this in Wayland is that before people &#x27;ran Xorg with GNOME on top&quot;, now they just run GNOME the same way they run Chrome or Firefox to use HTTP - it will take time for people to get used to this.</div><br/></div></div><div id="42836902" class="c"><input type="checkbox" id="c-42836902" checked=""/><div class="controls bullet"><span class="by">sho_hn</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835251">parent</a><span>|</span><a href="#42838589">prev</a><span>|</span><a href="#42838285">next</a><span>|</span><label class="collapse" for="c-42836902">[-]</label><label class="expand" for="c-42836902">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s no different from X11, which is also a protocol&#x2F;spec with many implementations.</div><br/><div id="42838255" class="c"><input type="checkbox" id="c-42838255" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42836902">parent</a><span>|</span><a href="#42838418">prev</a><span>|</span><a href="#42838285">next</a><span>|</span><label class="collapse" for="c-42838255">[-]</label><label class="expand" for="c-42838255">[1 more]</label></div><br/><div class="children"><div class="content">If there is no difference then how does the official reference implementation of Wayland, that nearly everyone uses daily, handle it? &#x2F;s</div><br/></div></div></div></div></div></div><div id="42838285" class="c"><input type="checkbox" id="c-42838285" checked=""/><div class="controls bullet"><span class="by">redmajor12</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833313">parent</a><span>|</span><a href="#42835251">prev</a><span>|</span><a href="#42832618">next</a><span>|</span><label class="collapse" for="c-42838285">[-]</label><label class="expand" for="c-42838285">[2 more]</label></div><br/><div class="children"><div class="content">Wayland as a just protocol... Isn&#x27;t that the same argument they used when it shipped without copy&#x2F;paste or a screensaver?</div><br/><div id="42838397" class="c"><input type="checkbox" id="c-42838397" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42838285">parent</a><span>|</span><a href="#42832618">next</a><span>|</span><label class="collapse" for="c-42838397">[-]</label><label class="expand" for="c-42838397">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an &quot;argument&quot;, it&#x27;s just a description of what Wayland is. But no, the correct protocol has had copy-paste since day one, and I dont remember there being issues with screensavers.<p>In the metaphor of a web server and a web browser, Wayland would be the HTTP specification. What you&#x27;re <i>usually</i> interested in is what server you&#x27;re running, e.g. GNOME&#x27;s Mutter, KDE&#x27;s Kwin, sway, niri, or what client you&#x27;re running, e.g. Gtk4, Qt6, etc.</div><br/></div></div></div></div></div></div><div id="42832618" class="c"><input type="checkbox" id="c-42832618" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42833313">prev</a><span>|</span><a href="#42838029">next</a><span>|</span><label class="collapse" for="c-42832618">[-]</label><label class="expand" for="c-42832618">[2 more]</label></div><br/><div class="children"><div class="content">GNOME has unredirection support, so I don&#x27;t think this test is applicable to actual in-game performance.<p>A fullscreen app ought to be taking a fast path through &#x2F; around the compositor.</div><br/></div></div><div id="42838029" class="c"><input type="checkbox" id="c-42838029" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42832618">prev</a><span>|</span><a href="#42833916">next</a><span>|</span><label class="collapse" for="c-42838029">[-]</label><label class="expand" for="c-42838029">[1 more]</label></div><br/><div class="children"><div class="content">Once upon a time XFree86 and Xorg updated the pointer directly in a SIGIO handler.  But that&#x27;s ancient history at this point, and nowadays I wouldn&#x27;t expect Wayland and Xorg to have a hugely different situation in this area.<p>IIRC it all started going downhill in Xorg when glamour appeared.  After the cursor rendering path wasn&#x27;t async-safe for execution from the signal handler (which something opengl-backed certainly wouldn&#x27;t be), the latency was worse.<p>I remember when even if your Linux box was thrashing your mouse pointer would stay responsive, and that was a reliable indicator of if the kernel was hung or not.  If the pointer prematurely became unresponsive, it was because you were on an IDE&#x2F;PATA host and needed to enable unmask irq w&#x2F;hdparm.  An unresponsive pointer in XFree86 was <i>that</i> useful of a signal that something was wrong or misconfigured...  ah, the good old days.</div><br/></div></div><div id="42833916" class="c"><input type="checkbox" id="c-42833916" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42838029">prev</a><span>|</span><a href="#42835019">next</a><span>|</span><label class="collapse" for="c-42833916">[-]</label><label class="expand" for="c-42833916">[2 more]</label></div><br/><div class="children"><div class="content">Hardware cursor is still a thing to this day on pretty much all platforms.</div><br/><div id="42835909" class="c"><input type="checkbox" id="c-42835909" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833916">parent</a><span>|</span><a href="#42835019">next</a><span>|</span><label class="collapse" for="c-42835909">[-]</label><label class="expand" for="c-42835909">[1 more]</label></div><br/><div class="children"><div class="content">On sway, if you use the proprietary Nvidia drivers, it is often necessary to disable hardware cursors. I wonder if there is something similar happening here. Maybe wayland gnome doesn&#x27;t use hardware cursors?</div><br/></div></div></div></div><div id="42835019" class="c"><input type="checkbox" id="c-42835019" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42833916">prev</a><span>|</span><a href="#42837381">next</a><span>|</span><label class="collapse" for="c-42835019">[-]</label><label class="expand" for="c-42835019">[3 more]</label></div><br/><div class="children"><div class="content">Asahi Lina&#x27;s comment on the topic: <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;oxtwre&#x2F;hard_numbers_wayland_vs_x11_input_latency#c_edq7tn" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;oxtwre&#x2F;hard_numbers_wayland_vs_x11_input...</a></div><br/><div id="42835609" class="c"><input type="checkbox" id="c-42835609" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835019">parent</a><span>|</span><a href="#42838309">next</a><span>|</span><label class="collapse" for="c-42835609">[-]</label><label class="expand" for="c-42835609">[1 more]</label></div><br/><div class="children"><div class="content">That is a great comment and everyone should read it. It also demonstrates a common truism that system goals dictate performance.</div><br/></div></div><div id="42838309" class="c"><input type="checkbox" id="c-42838309" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835019">parent</a><span>|</span><a href="#42835609">prev</a><span>|</span><a href="#42837381">next</a><span>|</span><label class="collapse" for="c-42838309">[-]</label><label class="expand" for="c-42838309">[1 more]</label></div><br/><div class="children"><div class="content">Tl;dr: X bad and tears but Wayland with 1.5 frame latency (or more) good. Now, if you have a monitor (or TV) with 30i refresh rate, you&#x27;re screwed.</div><br/></div></div></div></div><div id="42837381" class="c"><input type="checkbox" id="c-42837381" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42835019">prev</a><span>|</span><a href="#42833073">next</a><span>|</span><label class="collapse" for="c-42837381">[-]</label><label class="expand" for="c-42837381">[2 more]</label></div><br/><div class="children"><div class="content">Reminds me of how we used &#x27;dir&#x27; command to test computer speed by watching how fast it would scroll by.</div><br/><div id="42838307" class="c"><input type="checkbox" id="c-42838307" checked=""/><div class="controls bullet"><span class="by">redmajor12</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42837381">parent</a><span>|</span><a href="#42833073">next</a><span>|</span><label class="collapse" for="c-42838307">[-]</label><label class="expand" for="c-42838307">[1 more]</label></div><br/><div class="children"><div class="content">Or later, seeing how long it took to load &#x2F;usr&#x2F;bin in a filemanager.</div><br/></div></div></div></div><div id="42833073" class="c"><input type="checkbox" id="c-42833073" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42837381">prev</a><span>|</span><a href="#42834660">next</a><span>|</span><label class="collapse" for="c-42833073">[-]</label><label class="expand" for="c-42833073">[48 more]</label></div><br/><div class="children"><div class="content">How old is Wayland?<p>I&#x27;ll be reading a dream of spring in my grave at this rate.<p>I understand I&#x27;m complaining about free things, but this is a forced change for the worse for so long. Wayland adoption should have been predicated on a near universal superiority in all input and display requirements.<p>Intel and AMD and Nvidia and Arm makers should be all in on a viable desktop Linux as a consortium. Governments should be doing the same because a secure Linux desktop is actually possible. It is the fastest path to showcasing their CPUs and 3d bling, advanced vector &#x2F;computer hardware.<p>Wayland simply came at a time to further the delay of the Linux desktop, at a time when Windows was attempting to kill Windows with its horrid tiles and Apple staunchly refused a half billion in extra market cap by offering osx on general x86.</div><br/><div id="42833145" class="c"><input type="checkbox" id="c-42833145" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42833319">next</a><span>|</span><label class="collapse" for="c-42833145">[-]</label><label class="expand" for="c-42833145">[31 more]</label></div><br/><div class="children"><div class="content">Wayland is a protocol.  The problems people complain about are generally implementation details specific to GNOME or KDE or (in general) one particular implementation.<p>There&#x27;s rarely any such thing as &quot;universal superiority&quot;, usually you&#x27;re making a tradeoff.  In the case of X vs Wayland it&#x27;s usually latency vs. tearing. Personally I&#x27;m happy with Wayland because there was a time when watching certain videos with certain media players on Linux was incredibly painful because of how blatant and obtrusive the tearing was. Watching the same video under Wayland worked fine.<p>Early automobiles didn&#x27;t have &quot;universal superiority&quot; to horses, but that wasn&#x27;t an inhibitor to adoption.</div><br/><div id="42833625" class="c"><input type="checkbox" id="c-42833625" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833145">parent</a><span>|</span><a href="#42833469">next</a><span>|</span><label class="collapse" for="c-42833625">[-]</label><label class="expand" for="c-42833625">[11 more]</label></div><br/><div class="children"><div class="content">&quot;Wayland is a protocol&quot; is exactly the problem. Protocols suck; they just mean multiplying the possibility of bugs. A standard <i>implementation</i> is far more valuable any day.<p>With X11, it was simple: everybody used Xfree86 (or eventually the Xorg fork, but forks are not reimplementations) and libX11 (later libxcb was shimmed underneath with careful planning). The WM was bespoke, but it was small, nonintrusive, and out of the critical path, so bugs in it were neither numerous nor disastrous.<p>But today, with Wayland, there is no plan. And there is no limit to the bugs, which must get patched time and time again every time they are implemented.</div><br/><div id="42833918" class="c"><input type="checkbox" id="c-42833918" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833625">parent</a><span>|</span><a href="#42834035">next</a><span>|</span><label class="collapse" for="c-42833918">[-]</label><label class="expand" for="c-42833918">[9 more]</label></div><br/><div class="children"><div class="content">X had garbage handling of multiple monitors and especially multiple monitors with different DPIs, and there was &quot;no plan&quot; to deal with that either.  Nobody wanted to work on the X codebase anymore.  The architecture bore no resemblance to the way any other part of the desktop stack (or hardware) works.</div><br/><div id="42833994" class="c"><input type="checkbox" id="c-42833994" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833918">parent</a><span>|</span><a href="#42838620">next</a><span>|</span><label class="collapse" for="c-42833994">[-]</label><label class="expand" for="c-42833994">[7 more]</label></div><br/><div class="children"><div class="content">Most of the garbage aspect is because toolkits refuse to support multiple monitors on DPI with X11 with the argument that &quot;Wayland is just around the corner&quot;, for decades now.<p>For example Qt does per-monitor DPI just fine on X11; it&#x27;s just that the way to specify&#x2F;override the DPI values just sucks (an environment variable).<p>This stupid decision is going to chase us until the end of times since Xwayland will have no standardized way to tell its clients about per-display DPI.</div><br/><div id="42835412" class="c"><input type="checkbox" id="c-42835412" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833994">parent</a><span>|</span><a href="#42838620">next</a><span>|</span><label class="collapse" for="c-42835412">[-]</label><label class="expand" for="c-42835412">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not useful if you have to specify a scaling factor before the application has started, when the application can move monitors.<p>This is something feasible on Wayland, X draws one large wide screen display.</div><br/><div id="42836741" class="c"><input type="checkbox" id="c-42836741" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835412">parent</a><span>|</span><a href="#42836635">next</a><span>|</span><label class="collapse" for="c-42836741">[-]</label><label class="expand" for="c-42836741">[1 more]</label></div><br/><div class="children"><div class="content">X could do seveal different screens  I did have this working once. However then moving an application to a different display was impossible (an app could do it but it was a lot of work so nobody bothered). I few cad programs supported two streens but they were seperate and the two didn&#x27;t meet.<p>Most people want to drag windown between screens and sometimes even split down the middle. One large display supports that much easier so that is what everyone switched to in the late 1990</div><br/></div></div><div id="42836635" class="c"><input type="checkbox" id="c-42836635" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835412">parent</a><span>|</span><a href="#42836741">prev</a><span>|</span><a href="#42836480">next</a><span>|</span><label class="collapse" for="c-42836635">[-]</label><label class="expand" for="c-42836635">[2 more]</label></div><br/><div class="children"><div class="content">X11 used to provide separate displays, but at some point due to hardware changes (and quite probably due to prominence of intel hardware, actually) it was changed to merged framebuffer with virtual cut out displays.<p>In a way, Wayland in this case developed a solution for issue its creators brought into this world first</div><br/><div id="42836797" class="c"><input type="checkbox" id="c-42836797" checked=""/><div class="controls bullet"><span class="by">goosedragons</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42836635">parent</a><span>|</span><a href="#42836480">next</a><span>|</span><label class="collapse" for="c-42836797">[-]</label><label class="expand" for="c-42836797">[1 more]</label></div><br/><div class="children"><div class="content">It can still provide seperate displays. The problem is you couldn&#x27;t do something like drag a window from display 1 to 2°. IIRC it&#x27;s also annoying to launch two instances of a program on both displays. The hacky merged framebuffer thing is a workaround to these problems. But you can have independent DPIs on each display.<p>° For most programs.</div><br/></div></div></div></div><div id="42836480" class="c"><input type="checkbox" id="c-42836480" checked=""/><div class="controls bullet"><span class="by">AshamedCaptain</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835412">parent</a><span>|</span><a href="#42836635">prev</a><span>|</span><a href="#42838655">next</a><span>|</span><label class="collapse" for="c-42836480">[-]</label><label class="expand" for="c-42836480">[1 more]</label></div><br/><div class="children"><div class="content">Yes. It just proves that all you needed is a better way to specify the per-monitor DPI, one that can be updated afterwards, or even set by the WM on windows.</div><br/></div></div><div id="42838655" class="c"><input type="checkbox" id="c-42838655" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835412">parent</a><span>|</span><a href="#42836480">prev</a><span>|</span><a href="#42838620">next</a><span>|</span><label class="collapse" for="c-42838655">[-]</label><label class="expand" for="c-42838655">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not useful if you have to specify a scaling factor before the application has started, when the application can move monitors.<p>Windows does this. Try to use in Windows 2 monitors with 2 different scalling factors. It is hit or miss. 100 and 150 works. 100 and 125 doesn&#x27;t.</div><br/></div></div></div></div></div></div><div id="42838620" class="c"><input type="checkbox" id="c-42838620" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833918">parent</a><span>|</span><a href="#42833994">prev</a><span>|</span><a href="#42834035">next</a><span>|</span><label class="collapse" for="c-42838620">[-]</label><label class="expand" for="c-42838620">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Nobody wanted to work on the X codebase anymore.<p>That, i think, is the main issue. Nobody wants to work with GTK1, or GTK2, or GTK3 anymore. Nobody wants to work with QT1, or QT2, or QT3 or QT4 anymore. Everybody wants the new shiny toy. Over and over again.<p>It is CADT all over. 
Earlier X was developed by an industry consortium. Now Wayland is a monopoly pushed by RedHat.</div><br/></div></div></div></div><div id="42834035" class="c"><input type="checkbox" id="c-42834035" checked=""/><div class="controls bullet"><span class="by">sweeter</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833625">parent</a><span>|</span><a href="#42833918">prev</a><span>|</span><a href="#42833469">next</a><span>|</span><label class="collapse" for="c-42834035">[-]</label><label class="expand" for="c-42834035">[1 more]</label></div><br/><div class="children"><div class="content">Software has bugs and water is wet. Wait til you hear about HTTP, TCP, UDP, IP torrents, etc... and &quot;simple&quot; is not really a term I would designate to X11. I mean, its fine, but even just the ecosystem surrounding X is convoluted, outdated and absurd. Things like xinit, startx, .Xauthority, xresources, xhost etc... are all a mess.</div><br/></div></div></div></div><div id="42833469" class="c"><input type="checkbox" id="c-42833469" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833145">parent</a><span>|</span><a href="#42833625">prev</a><span>|</span><a href="#42833272">next</a><span>|</span><label class="collapse" for="c-42833469">[-]</label><label class="expand" for="c-42833469">[8 more]</label></div><br/><div class="children"><div class="content">&gt; Wayland is a protocol. The problems people complain about are generally implementation details specific to GNOME or KDE or (in general) one particular implementation.<p>I feel like at some point this is a cop-out. Wayland is a protocol but its also a &quot;system&quot; involving many components. If the product as a whole doesn&#x27;t work well then its still a failure regardless of which component&#x27;s fault it is.<p>Its a little like responding to someone saying we haven&#x27;t reached the year of linux on the desktop by saying: well actually linux is just the kernel and its been ready for the desktop for ages. Technically true but also missing the point.</div><br/><div id="42833596" class="c"><input type="checkbox" id="c-42833596" checked=""/><div class="controls bullet"><span class="by">washadjeffmad</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833469">parent</a><span>|</span><a href="#42837387">next</a><span>|</span><label class="collapse" for="c-42833596">[-]</label><label class="expand" for="c-42833596">[3 more]</label></div><br/><div class="children"><div class="content">Wayland. Solving yesterday&#x27;s problems, tomorrow.</div><br/><div id="42836697" class="c"><input type="checkbox" id="c-42836697" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833596">parent</a><span>|</span><a href="#42837387">next</a><span>|</span><label class="collapse" for="c-42836697">[-]</label><label class="expand" for="c-42836697">[2 more]</label></div><br/><div class="children"><div class="content">unlike x which couldn&#x27;t solve yesterdays problems.</div><br/><div id="42836813" class="c"><input type="checkbox" id="c-42836813" checked=""/><div class="controls bullet"><span class="by">Qwertious</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42836697">parent</a><span>|</span><a href="#42837387">next</a><span>|</span><label class="collapse" for="c-42836813">[-]</label><label class="expand" for="c-42836813">[1 more]</label></div><br/><div class="children"><div class="content">X is fine, most of the problems people bring up are niche and minor. Meanwhile, Wayland induces problems of its own, like breaking all sorts of accessibility systems and multi-window X applications with no solution in sight.</div><br/></div></div></div></div></div></div><div id="42837387" class="c"><input type="checkbox" id="c-42837387" checked=""/><div class="controls bullet"><span class="by">WhyNotHugo</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833469">parent</a><span>|</span><a href="#42833596">prev</a><span>|</span><a href="#42834139">next</a><span>|</span><label class="collapse" for="c-42837387">[-]</label><label class="expand" for="c-42837387">[1 more]</label></div><br/><div class="children"><div class="content">The key detail in the “Wayland is a protocol” is that there are several other implementations, some of them extremely mature. The implementation being tested here isn’t exactly know to be a good one.<p>If there were a single Wayland implementation in existence, I’d agree with your sentiment.</div><br/></div></div><div id="42834139" class="c"><input type="checkbox" id="c-42834139" checked=""/><div class="controls bullet"><span class="by">sweeter</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833469">parent</a><span>|</span><a href="#42837387">prev</a><span>|</span><a href="#42833272">next</a><span>|</span><label class="collapse" for="c-42834139">[-]</label><label class="expand" for="c-42834139">[3 more]</label></div><br/><div class="children"><div class="content">What components? Wayland is literally an XML protocol that turns an XML file into a method of communication. libwayland-server and libwayland-client only handle communication and the internal event loop. Its completely up to the developer to write the implementations of these functions and register them in the server.<p>Then a client is going to query the server and ask request to do stuff via a unix socket. In fact, you don&#x27;t even need libwayland, you can raw dog it over sockets manually. The idea is that there are standard protocols that can be queried and used,and you can implement this in any environment you want to. You could write the &quot;frontend&quot; in html and JS and run a wayland compositor on the web (which has been done [1]), you could do it with text or anything really, most people use some graphics stack.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;udevbe&#x2F;greenfield">https:&#x2F;&#x2F;github.com&#x2F;udevbe&#x2F;greenfield</a></div><br/><div id="42836132" class="c"><input type="checkbox" id="c-42836132" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834139">parent</a><span>|</span><a href="#42834442">next</a><span>|</span><label class="collapse" for="c-42836132">[-]</label><label class="expand" for="c-42836132">[1 more]</label></div><br/><div class="children"><div class="content">The components are:<p>- the compositor, of which there are multiple implementations (gnome, kde, all the wlroots compositors)<p>- the client, which often uses one of several toolkits (gtk, qt, several smaller frameworks, or even directly using the protocol)<p>- the wayland protocol (or rather protocols, because there are several extensions) itself<p>- other specifications and side channels for communication, in particular dbus.<p>Many issues (although I don&#x27;t think the one in OP) are due to the protocol being underspecified, and so the client and compositor disagree about some semantics, or doesn&#x27;t even have a standard way to accomplish something across all compositors.</div><br/></div></div><div id="42834442" class="c"><input type="checkbox" id="c-42834442" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834139">parent</a><span>|</span><a href="#42836132">prev</a><span>|</span><a href="#42833272">next</a><span>|</span><label class="collapse" for="c-42834442">[-]</label><label class="expand" for="c-42834442">[1 more]</label></div><br/><div class="children"><div class="content">Nit: Wayland isn&#x27;t an XML protocol. The &quot;calls&quot; and their arguments are described in XML, but the data is transmitted in a fairly simple binary encoding.</div><br/></div></div></div></div></div></div><div id="42833272" class="c"><input type="checkbox" id="c-42833272" checked=""/><div class="controls bullet"><span class="by">bpfrh</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833145">parent</a><span>|</span><a href="#42833469">prev</a><span>|</span><a href="#42838400">next</a><span>|</span><label class="collapse" for="c-42833272">[-]</label><label class="expand" for="c-42833272">[10 more]</label></div><br/><div class="children"><div class="content">I mean most of the things are the fault of a badly  designed or non existent protocols:<p>-Problems with non western input systems<p>-Accessibility<p>-Remote control(took around 2 years to be stable I think?)<p>-Bad color management<p>Then there&#x27;s the things that did work in x11 but not in wayland:<p>-Bad support for keymapping(the input library says keymapping should be implemented by the compositor, gnome says not in scope, so we have a regression)<p>-bad nvidia support for the first two years? three years?<p>While these things are compositor&#x2F;hw vendor faults, the rush to use wayland and nearly every distro making it as default, forced major regressions and wayland kinda promised to improve the x11 based experience.</div><br/><div id="42833508" class="c"><input type="checkbox" id="c-42833508" checked=""/><div class="controls bullet"><span class="by">tuna74</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833272">parent</a><span>|</span><a href="#42834316">next</a><span>|</span><label class="collapse" for="c-42833508">[-]</label><label class="expand" for="c-42833508">[5 more]</label></div><br/><div class="children"><div class="content">I have run Wayland since it was available for testing on Fedora Workstation and I have had zero problems inputting Japanese and Chinese.<p>With regards to accessibility, what problems have you had exactly?</div><br/><div id="42838276" class="c"><input type="checkbox" id="c-42838276" checked=""/><div class="controls bullet"><span class="by">bashkiddie</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833508">parent</a><span>|</span><a href="#42835418">next</a><span>|</span><label class="collapse" for="c-42838276">[-]</label><label class="expand" for="c-42838276">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have had zero problems inputting Japanese and Chinese.<p>That may be fine.<p>Neo2 does not work. Neo has 3 modifier keys, Gnome&#x2F;Mutter&#x2F;Wayland&#x2F;Whatever does only support two.
Neo2 has a compose key, Wayland does not honor it.<p><a href="https:&#x2F;&#x2F;neo-layout.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;neo-layout.org&#x2F;</a><p>I use mod4 for navigation (arrow keys, site up) and compose for Slavish (read Polish) input (źżąę)</div><br/></div></div><div id="42835418" class="c"><input type="checkbox" id="c-42835418" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833508">parent</a><span>|</span><a href="#42838276">prev</a><span>|</span><a href="#42836354">next</a><span>|</span><label class="collapse" for="c-42835418">[-]</label><label class="expand" for="c-42835418">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With regards to accessibility, what problems have you had exactly?<p>Fedora shipped a broken screen reader for 8 years.</div><br/></div></div><div id="42836354" class="c"><input type="checkbox" id="c-42836354" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833508">parent</a><span>|</span><a href="#42835418">prev</a><span>|</span><a href="#42838116">next</a><span>|</span><label class="collapse" for="c-42836354">[-]</label><label class="expand" for="c-42836354">[1 more]</label></div><br/><div class="children"><div class="content">I think that gnome has had built-in IME, but at least for a long time, it wasn&#x27;t possible to use a third party system with gnome, or use gnome&#x27;s with other compositors. And I&#x27;m pretty sure the situation was the same for sreen readers and on-screen keyboards. The wlroots project created their own protocols to support external applications to provide such features, since that is out of scope for a compositor like sway, but there are still missing pieces.</div><br/></div></div><div id="42838116" class="c"><input type="checkbox" id="c-42838116" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833508">parent</a><span>|</span><a href="#42836354">prev</a><span>|</span><a href="#42834316">next</a><span>|</span><label class="collapse" for="c-42838116">[-]</label><label class="expand" for="c-42838116">[1 more]</label></div><br/><div class="children"><div class="content">2 finger scroll doesn&#x27;t work on my thinkpad model.<p>Not a bug, apparently. <a href="https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;libinput&#x2F;libinput&#x2F;-&#x2F;issues&#x2F;1059" rel="nofollow">https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;libinput&#x2F;libinput&#x2F;-&#x2F;issues&#x2F;10...</a></div><br/></div></div></div></div><div id="42834316" class="c"><input type="checkbox" id="c-42834316" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833272">parent</a><span>|</span><a href="#42833508">prev</a><span>|</span><a href="#42833325">next</a><span>|</span><label class="collapse" for="c-42834316">[-]</label><label class="expand" for="c-42834316">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  the rush to use wayland and nearly every distro making it as default,<p>Which rush? It has been done by only a small fraction of distros like Fedora, after years of development of the first wayland compositors. Fedora main purpose has always been to implement bleeding edge tech stuff early so that bugs get found and fixed before people using more stable distros have to suffer from it.<p>Nobody has been forced in any regression and x11 has continued to be available until now and there is no sign that the most conservative distros will drop x11 support anytime soon.</div><br/></div></div><div id="42833325" class="c"><input type="checkbox" id="c-42833325" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833272">parent</a><span>|</span><a href="#42834316">prev</a><span>|</span><a href="#42838400">next</a><span>|</span><label class="collapse" for="c-42833325">[-]</label><label class="expand" for="c-42833325">[3 more]</label></div><br/><div class="children"><div class="content">Yes, and to the parents point it was a CHANGE in protocol.<p>I get there was cruft in x. But the moment selected was a barrier to Linux desktop adoption precisely when the greatest opportunity in decades was present.<p>And the desktop was reimplemented.<p>Now in this period kde and gnome both decided to do rewrites,  Ubuntu did their own desktop, got it up to snuff, and abandoned it. The lunacy wasn&#x27;t just Wayland.<p>If we are complaining the gnome compositor sucks... I mean , should that be the goddamn reference implementation? What percent of desktops are gnome, 80% at least?  If the gnome composting ready for primetime, then Wayland isn&#x27;t ready for primetime.</div><br/><div id="42833445" class="c"><input type="checkbox" id="c-42833445" checked=""/><div class="controls bullet"><span class="by">vincent-manis</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833325">parent</a><span>|</span><a href="#42838400">next</a><span>|</span><label class="collapse" for="c-42833445">[-]</label><label class="expand" for="c-42833445">[2 more]</label></div><br/><div class="children"><div class="content">&gt;If the gnome composting ready for primetime, then Wayland isn&#x27;t ready for primetime.<p>I use Sway, which uses a different compos[i]tor than Gnome. I would like to see similar results for wlroots, Sway&#x27;s compositor, though I&#x27;m not actually interested enough to do the experiment (I guess that would be comparing Sway with i3). Cursor lag in Sway is not enough to bother me. I have on occasion used Gnome on the same machine(s), and never been bothered by lag.<p>As others have pointed out, Wayland is a protocol, not a compositor.</div><br/><div id="42838484" class="c"><input type="checkbox" id="c-42838484" checked=""/><div class="controls bullet"><span class="by">tankenmate</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833445">parent</a><span>|</span><a href="#42838400">next</a><span>|</span><label class="collapse" for="c-42838484">[-]</label><label class="expand" for="c-42838484">[1 more]</label></div><br/><div class="children"><div class="content">&quot;As others have pointed out, Wayland is a protocol, not a compositor.&quot;<p>But the Wayland protocol requires a compositor, so here we are.</div><br/></div></div></div></div></div></div></div></div><div id="42838400" class="c"><input type="checkbox" id="c-42838400" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833145">parent</a><span>|</span><a href="#42833272">prev</a><span>|</span><a href="#42833319">next</a><span>|</span><label class="collapse" for="c-42838400">[-]</label><label class="expand" for="c-42838400">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there was a time when watching certain videos with certain media players on Linux was incredibly painful because of how blatant and obtrusive the tearing was<p>It was because of the crap LCD monitors (5 to 20 ms GtG) and how they are driven. The problem persists today. The (Wayland) solution was to render and display a complete frame at a time without taking into account the timings involved in hardware (you always have a good static image, but you have to wait).<p>I tried Tails (comes with some Wayland compositor) on a laptop. The GUI performance was terrible with only a Tor browser open and one tab.<p>If you do not care about hardware, you will, sooner or later, run into problems. Not everybody has your shiny 240 Hz monitor.</div><br/></div></div></div></div><div id="42833319" class="c"><input type="checkbox" id="c-42833319" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42833145">prev</a><span>|</span><a href="#42835640">next</a><span>|</span><label class="collapse" for="c-42833319">[-]</label><label class="expand" for="c-42833319">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How old is Wayland?<p>About 16 years old, for comparison, X is 40.</div><br/><div id="42838892" class="c"><input type="checkbox" id="c-42838892" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833319">parent</a><span>|</span><a href="#42835640">next</a><span>|</span><label class="collapse" for="c-42838892">[-]</label><label class="expand" for="c-42838892">[1 more]</label></div><br/><div class="children"><div class="content">Hm, X works fine since 20 years. Wayland is still a protocol after 16. &#x2F;s</div><br/></div></div></div></div><div id="42835640" class="c"><input type="checkbox" id="c-42835640" checked=""/><div class="controls bullet"><span class="by">BrenBarn</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42833319">prev</a><span>|</span><a href="#42834251">next</a><span>|</span><label class="collapse" for="c-42835640">[-]</label><label class="expand" for="c-42835640">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Wayland adoption should have been predicated on a near universal superiority in all input and display requirements.<p>Totally agree.  The people saying &quot;Wayland is a protocol&quot; miss the point.  Wayland is a protocol, but Wayland <i>adoption</i> means implementing stuff that uses that protocol, and then pushing it onto users.<p>Measure twice, cut once.  Look before you leap.  All that kind of thing.  Get it working FIRST, then release it.</div><br/><div id="42836790" class="c"><input type="checkbox" id="c-42836790" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835640">parent</a><span>|</span><a href="#42834251">next</a><span>|</span><label class="collapse" for="c-42836790">[-]</label><label class="expand" for="c-42836790">[2 more]</label></div><br/><div class="children"><div class="content">You have to releaseethings like this in parts because it needs too many external people to do things to make it useful. Managing those parts is something nobody has figured out and so people live you end up using it before it is ready for your use and then complaining.</div><br/><div id="42838004" class="c"><input type="checkbox" id="c-42838004" checked=""/><div class="controls bullet"><span class="by">BrenBarn</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42836790">parent</a><span>|</span><a href="#42834251">next</a><span>|</span><label class="collapse" for="c-42838004">[-]</label><label class="expand" for="c-42838004">[1 more]</label></div><br/><div class="children"><div class="content">When I say &quot;release&quot; I mean &quot;release to users&quot;.  You can release stuff to other developers, no problem.  But it should all come with large warnings saying &quot;This is not for daily use&quot;.  The failure is when distros like Fedora start not only shipping it, but then saying they&#x27;re going to drop the working alternative before Wayland is actually ready to do <i>everything</i> that X does.<p>(Also, I don&#x27;t use Wayland.  I mean I tried it out but don&#x27;t see any real benefit so I don&#x27;t use it regularly.)</div><br/></div></div></div></div></div></div><div id="42834251" class="c"><input type="checkbox" id="c-42834251" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42835640">prev</a><span>|</span><a href="#42833296">next</a><span>|</span><label class="collapse" for="c-42834251">[-]</label><label class="expand" for="c-42834251">[2 more]</label></div><br/><div class="children"><div class="content">&gt;but this is a forced change for the worse for so long<p>Can you explain who is forced to do what in that context?</div><br/><div id="42838329" class="c"><input type="checkbox" id="c-42838329" checked=""/><div class="controls bullet"><span class="by">bashkiddie</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834251">parent</a><span>|</span><a href="#42833296">next</a><span>|</span><label class="collapse" for="c-42838329">[-]</label><label class="expand" for="c-42838329">[1 more]</label></div><br/><div class="children"><div class="content">AMD states that bugs only get fixed for Wayland.<p>Coincidentally I have got a graphics driver that likes crashing on OpenGL (AMD Ryzen 7 7840U w&#x2F; Radeon  780M Graphics)</div><br/></div></div></div></div><div id="42833296" class="c"><input type="checkbox" id="c-42833296" checked=""/><div class="controls bullet"><span class="by">n144q</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42834251">prev</a><span>|</span><a href="#42837149">next</a><span>|</span><label class="collapse" for="c-42833296">[-]</label><label class="expand" for="c-42833296">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Wayland simply came at a time to further the delay of the Linux desktop<p>I can&#x27;t tell if you are serious or not.</div><br/><div id="42834135" class="c"><input type="checkbox" id="c-42834135" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833296">parent</a><span>|</span><a href="#42837149">next</a><span>|</span><label class="collapse" for="c-42834135">[-]</label><label class="expand" for="c-42834135">[1 more]</label></div><br/><div class="children"><div class="content">Serious</div><br/></div></div></div></div><div id="42837149" class="c"><input type="checkbox" id="c-42837149" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42833296">prev</a><span>|</span><a href="#42833903">next</a><span>|</span><label class="collapse" for="c-42837149">[-]</label><label class="expand" for="c-42837149">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I understand I&#x27;m complaining about free things, but this is a forced change for the worse for so long.<p>Then write code.<p>Asahi Lina has demonstrated that a single person can write the appropriate shims to make things work.<p>Vulkan being effectively universally available on all the Linux graphics cards means that you have the hardest layer of abstraction to the GPU taken care of.<p>A single or small number of people could write a layer that sits above Wayland and X11 and does it right.  However, no one has.</div><br/></div></div><div id="42833903" class="c"><input type="checkbox" id="c-42833903" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833073">parent</a><span>|</span><a href="#42837149">prev</a><span>|</span><a href="#42834660">next</a><span>|</span><label class="collapse" for="c-42833903">[-]</label><label class="expand" for="c-42833903">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;re arguing against Wayland, but for a more secure Linux desktop? I recommend you spend more time getting to know the X11 protocol then, because it has plenty of design decisions that simply cannot be secured. The same people who used to develop XFree86 designed Wayland to fix things that could not be fixed in the scope of X11.</div><br/><div id="42835117" class="c"><input type="checkbox" id="c-42835117" checked=""/><div class="controls bullet"><span class="by">wmanley</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42833903">parent</a><span>|</span><a href="#42834660">next</a><span>|</span><label class="collapse" for="c-42835117">[-]</label><label class="expand" for="c-42835117">[5 more]</label></div><br/><div class="children"><div class="content">&gt; the X11 protocol [...] has plenty of design decisions that simply cannot be secured.<p>I&#x27;ve been hearing this for over a decade now.  I don&#x27;t get it.  Just because xorg currently makes different clients aware of each other and broadcasts keypresses and mouse movements to all clients and allows screen capturing doesn&#x27;t mean it has to.  You could essentially give every application the impression that they are the only thing running.<p>It might seem difficult to implement, but compare it to the effort that has gone into wayland across the whole ecosystem.  Maybe that was the point - motivating people to work on X was too difficult, and the wayland approach manages to diffuse the work out to more people.<p>I was really bullish on Wayland 10 years ago.  Not so much any more.  In retrospect it seems like a failure in technical leadership.</div><br/><div id="42835299" class="c"><input type="checkbox" id="c-42835299" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835117">parent</a><span>|</span><a href="#42835449">next</a><span>|</span><label class="collapse" for="c-42835299">[-]</label><label class="expand" for="c-42835299">[1 more]</label></div><br/><div class="children"><div class="content">X always had the capability to isolate clients, but it is not used it would need some work which nobody does because of Wayland.</div><br/></div></div><div id="42835449" class="c"><input type="checkbox" id="c-42835449" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835117">parent</a><span>|</span><a href="#42835299">prev</a><span>|</span><a href="#42834660">next</a><span>|</span><label class="collapse" for="c-42835449">[-]</label><label class="expand" for="c-42835449">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll be challenging to even figure out which one of the things connecting to $DISPLAY is the <i>real</i> window manager. Good luck on your lonely[1] journey!<p>[1]: The people who actually developed Xorg are now working on various Wayland-related things.</div><br/><div id="42836138" class="c"><input type="checkbox" id="c-42836138" checked=""/><div class="controls bullet"><span class="by">wmanley</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42835449">parent</a><span>|</span><a href="#42834660">next</a><span>|</span><label class="collapse" for="c-42836138">[-]</label><label class="expand" for="c-42836138">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;ll be challenging to even figure out which one of the things connecting to $DISPLAY is the real window manager.<p>I suspect it would be less challenging than writing a whole new wayland server.<p>Off the top of my head, I&#x27;d use a separate abstract domain socket for the window manager including some UUID, and then pass that to the window manager when launching it.<p>You could create these sockets on demand - one for each security context.  On linux typically a different security contexts will either have different UIDs - in which case filesystem permissions would be sufficient - or they have different mount namespaces - in which case you make different sockets visible in different namespaces.<p>For SSH forwarding you could have SSH ask the X server for a new socket for forwarding purposes - so remote clients can&#x27;t snoop on local clients.<p>&gt; Good luck on your lonely[1] journey!
&gt;
&gt; [1]: The people who actually developed Xorg are now working on various Wayland-related things.<p>This is what I mean by a failure of technical leadership.</div><br/><div id="42838543" class="c"><input type="checkbox" id="c-42838543" checked=""/><div class="controls bullet"><span class="by">tankenmate</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42836138">parent</a><span>|</span><a href="#42834660">next</a><span>|</span><label class="collapse" for="c-42838543">[-]</label><label class="expand" for="c-42838543">[1 more]</label></div><br/><div class="children"><div class="content">&quot;You could create these sockets on demand - one for each security context. On linux typically a different security contexts will either have different UIDs - in which case filesystem permissions would be sufficient - or they have different mount namespaces - in which case you make different sockets visible in different namespaces.&quot;<p>This is reminiscent of how Trusted Solaris[0] implements Mandatory Access Control (MAC) a la Orange Book[1].<p>[0] <a href="https:&#x2F;&#x2F;www.oracle.com&#x2F;technetwork&#x2F;server-storage&#x2F;solaris10&#x2F;overview&#x2F;ds-ts8-150124.pdf" rel="nofollow">https:&#x2F;&#x2F;www.oracle.com&#x2F;technetwork&#x2F;server-storage&#x2F;solaris10&#x2F;...</a>
[1] <a href="https:&#x2F;&#x2F;public.milcyber.org&#x2F;activities&#x2F;magazine&#x2F;articles&#x2F;2021&#x2F;renda-the-orange-book" rel="nofollow">https:&#x2F;&#x2F;public.milcyber.org&#x2F;activities&#x2F;magazine&#x2F;articles&#x2F;202...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42834660" class="c"><input type="checkbox" id="c-42834660" checked=""/><div class="controls bullet"><span class="by">giantrobot</span><span>|</span><a href="#42832550">parent</a><span>|</span><a href="#42833073">prev</a><span>|</span><a href="#42832090">next</a><span>|</span><label class="collapse" for="c-42834660">[-]</label><label class="expand" for="c-42834660">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Wayland, being something relatively &quot;new&quot; compared to X11, has not had this level of scrutiny for as long. I&#x27;m looking forward to folks fixing it though.<p>Part of the problem will doubtless be the USB (and Bluetooth) stacks including the device hardware and firmware. When keyboards and mice were serial devices with their own interrupt making the code path fast was achievable. I&#x27;m not so confident that modern peripheral stacks can be made to run with the same priority. It becomes even more challenging for devices sitting on a bus with multiple device classes or multiple protocols between the device and driver (USB -&gt; Bluetooth -&gt; Mouse).<p>I hope devices can be sped up but we&#x27;re a long way from a keypress triggering an interrupt and being handled in tens of milliseconds[0].<p>[0] <a href="https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;input-lag&#x2F;</a></div><br/><div id="42835647" class="c"><input type="checkbox" id="c-42835647" checked=""/><div class="controls bullet"><span class="by">ndiddy</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834660">parent</a><span>|</span><a href="#42834806">next</a><span>|</span><label class="collapse" for="c-42835647">[-]</label><label class="expand" for="c-42835647">[1 more]</label></div><br/><div class="children"><div class="content">The article you&#x27;re commenting on is about someone running X11 and Wayland on the same computer with the same mouse and experiencing higher input latency on Wayland. I don&#x27;t think differences between serial and USB mice are relevant here.</div><br/></div></div><div id="42834806" class="c"><input type="checkbox" id="c-42834806" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834660">parent</a><span>|</span><a href="#42835647">prev</a><span>|</span><a href="#42836657">next</a><span>|</span><label class="collapse" for="c-42834806">[-]</label><label class="expand" for="c-42834806">[1 more]</label></div><br/><div class="children"><div class="content">As a systems I guy I completely agree with this. One of the things that was interesting about X11 is that it draws an API &quot;wall&quot; around the stuff involved in presentation. Many folks don&#x27;t remember this but we had X &quot;terminals&quot; which was a computer system that did <i>nothing else</i> except render the screen and handle the input.<p>In that compartmentalization there was nothing <i>else</i> competing for attention. You didn&#x27;t get USB bus contention because there was just the one mouse, ever, on the line between the user and the X11 server in the X terminal.</div><br/></div></div><div id="42836657" class="c"><input type="checkbox" id="c-42836657" checked=""/><div class="controls bullet"><span class="by">Permik</span><span>|</span><a href="#42832550">root</a><span>|</span><a href="#42834660">parent</a><span>|</span><a href="#42834806">prev</a><span>|</span><a href="#42832090">next</a><span>|</span><label class="collapse" for="c-42836657">[-]</label><label class="expand" for="c-42836657">[1 more]</label></div><br/><div class="children"><div class="content">USB devices today are dummy fast, USB 3.1 signals at 10 GHz. You just need to check the USB queue more often :D<p>Alternatively you move straight up to USB 4, where we get pci-e interrupts again! :)</div><br/></div></div></div></div></div></div><div id="42832090" class="c"><input type="checkbox" id="c-42832090" checked=""/><div class="controls bullet"><span class="by">sxp</span><span>|</span><a href="#42832550">prev</a><span>|</span><a href="#42831822">next</a><span>|</span><label class="collapse" for="c-42832090">[-]</label><label class="expand" for="c-42832090">[11 more]</label></div><br/><div class="children"><div class="content">For anyone who uses ffmpeg for this type of per frame analysis, `ffmpeg -skip_frame nokey -i file -vsync 0 -frame_pts true out%d.png` will get the &quot;presentation time&quot; of each frame in the video. That&#x27;s more precise than just dumping frames and calculating timestamps. You can also do something similar in a web browser by playing a &lt;video&gt; and using `requestVideoFrameCallback()`. Though, you might need to set `.playbackRate` to a low value if the computer can&#x27;t decode all the frames fast enough.<p>&gt; With my 144Hz screen,....Wayland, on average, has roughly 6.5ms more cursor latency than X11 on my system...Interestingly, the difference is very close to 1 full screen refresh. I don&#x27;t know whether or not that&#x27;s a coincidence.<p>The fact that the latency is almost 1&#x2F;144th of a second means that it might become 1&#x2F;60th of a second on standard 60Hz monitors. This is hard to notice consciously without training, but most people can &quot;feel&quot; the difference even if they can&#x27;t explain it.</div><br/><div id="42832536" class="c"><input type="checkbox" id="c-42832536" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#42832090">parent</a><span>|</span><a href="#42832387">next</a><span>|</span><label class="collapse" for="c-42832536">[-]</label><label class="expand" for="c-42832536">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The fact that the latency is almost 1&#x2F;144th of a second means that it might become 1&#x2F;60th of a second on standard 60Hz monitors.<p>My guess: the &quot;true&quot; numbers are close to 2.5 (half a frame of random phase of when the mouse is touched vs. refresh, plus 2 frames to move cursor) and 3.5.  If you throw out the low outlier from each set you get pretty close to that.<p>(of course, the 125Hz mouse poll rate is another confound for many users, but this guy used a 1KHz mouse).<p>&gt; This is hard to notice consciously without training, but most people can &quot;feel&quot; the difference even if they can&#x27;t explain it.<p>Yah.  7ms difference is not bad vs 16.6ms is starting to be a lot.<p>IMO, we should be putting in effort on computers to reach 1.6 frames of latency -- half a frame of random phase, plus one frame, plus a little bit of processing time.</div><br/><div id="42833027" class="c"><input type="checkbox" id="c-42833027" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42832536">parent</a><span>|</span><a href="#42832387">next</a><span>|</span><label class="collapse" for="c-42833027">[-]</label><label class="expand" for="c-42833027">[2 more]</label></div><br/><div class="children"><div class="content">To have a compositor not introduce a frame of latency more or less requires it to race the beam, which has definitely been suggested[1], but you can see how it’d be difficult, and so far no operating systems have tried as far as I know. And as for good frame pacing support in UI toolkits (and not just game engines), well, one can dream. Until both of these are in place, 2.5±0.5 seems to be the hard limit, the question here is more where the Mutter is losing another frame (which even the greats tell us[2] is not hard to do by accident).<p>[1] <a href="https:&#x2F;&#x2F;raphlinus.github.io&#x2F;ui&#x2F;graphics&#x2F;2020&#x2F;09&#x2F;13&#x2F;compositor-is-evil.html" rel="nofollow">https:&#x2F;&#x2F;raphlinus.github.io&#x2F;ui&#x2F;graphics&#x2F;2020&#x2F;09&#x2F;13&#x2F;composito...</a><p>[2] <a href="http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;john_carmack_on_inlined_code.html" rel="nofollow">http:&#x2F;&#x2F;number-none.com&#x2F;blow&#x2F;john_carmack_on_inlined_code.htm...</a></div><br/><div id="42834259" class="c"><input type="checkbox" id="c-42834259" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42833027">parent</a><span>|</span><a href="#42832387">next</a><span>|</span><label class="collapse" for="c-42834259">[-]</label><label class="expand" for="c-42834259">[1 more]</label></div><br/><div class="children"><div class="content">I’ve read these arguments quite a few times and always found them a bit questionable. Sure, if everything is driven by the vblank time (or any other clock that counts in frames), it makes sense. But that’s a silly approach!  There is nothing whatsoever special about allocating one full frame interval to the compositor to composite a frame — if it takes 16ms to composite reliably, it will take 16ms to composite reliably at 30Hz or 60Hz or 144Hz.  So shouldn’t the system clock itself on a <i>time</i> basis, not a frame basis?<p>Put another way, a system fast enough to composite at 144Hz should be able to composite at 60Hz while only allocating 1&#x2F;144 seconds to the compositor, which would require offsetting the presentation times as seen by the compositor’s clients by some fraction of a frame time, which doesn’t actually seem that bad.<p>It gets even better if variable refresh rate &#x2F; frame timing works well, because then frames don’t drop even if some fraction of compositing operations are a bit too slow.<p>I assume I’m missing some reason why this isn’t done.</div><br/></div></div></div></div></div></div><div id="42832387" class="c"><input type="checkbox" id="c-42832387" checked=""/><div class="controls bullet"><span class="by">goalieca</span><span>|</span><a href="#42832090">parent</a><span>|</span><a href="#42832536">prev</a><span>|</span><a href="#42832529">next</a><span>|</span><label class="collapse" for="c-42832387">[-]</label><label class="expand" for="c-42832387">[6 more]</label></div><br/><div class="children"><div class="content">I found low latency terminals make a big improvement to even simple tasks like typing.</div><br/><div id="42834640" class="c"><input type="checkbox" id="c-42834640" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42832387">parent</a><span>|</span><a href="#42832469">next</a><span>|</span><label class="collapse" for="c-42834640">[-]</label><label class="expand" for="c-42834640">[1 more]</label></div><br/><div class="children"><div class="content">I was pretty shocked by the eyestrain difference I felt going from 30hz to 60hz with a 4K monitor while only doing coding tasks (i.e. text and mouse, no real graphics or animations).</div><br/></div></div><div id="42832469" class="c"><input type="checkbox" id="c-42832469" checked=""/><div class="controls bullet"><span class="by">daef</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42832387">parent</a><span>|</span><a href="#42834640">prev</a><span>|</span><a href="#42832529">next</a><span>|</span><label class="collapse" for="c-42832469">[-]</label><label class="expand" for="c-42832469">[4 more]</label></div><br/><div class="children"><div class="content">what would you count as low latency terminal?</div><br/><div id="42832842" class="c"><input type="checkbox" id="c-42832842" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42832469">parent</a><span>|</span><a href="#42832529">next</a><span>|</span><label class="collapse" for="c-42832842">[-]</label><label class="expand" for="c-42832842">[3 more]</label></div><br/><div class="children"><div class="content">See <a href="https:&#x2F;&#x2F;beuke.org&#x2F;terminal-latency&#x2F;" rel="nofollow">https:&#x2F;&#x2F;beuke.org&#x2F;terminal-latency&#x2F;</a>. Single-digit milliseconds I’d say. These numbers are minus the keyboard and display latency.</div><br/><div id="42833511" class="c"><input type="checkbox" id="c-42833511" checked=""/><div class="controls bullet"><span class="by">rustc</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42832842">parent</a><span>|</span><a href="#42832529">next</a><span>|</span><label class="collapse" for="c-42833511">[-]</label><label class="expand" for="c-42833511">[2 more]</label></div><br/><div class="children"><div class="content">Has anyone run this test on Ghostty?</div><br/><div id="42835885" class="c"><input type="checkbox" id="c-42835885" checked=""/><div class="controls bullet"><span class="by">_emacsomancer_</span><span>|</span><a href="#42832090">root</a><span>|</span><a href="#42833511">parent</a><span>|</span><a href="#42832529">next</a><span>|</span><label class="collapse" for="c-42835885">[-]</label><label class="expand" for="c-42835885">[1 more]</label></div><br/><div class="children"><div class="content">I get a &quot;Cannot detect the reference pattern&quot; error when I try with Ghostty with Typometer.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42832529" class="c"><input type="checkbox" id="c-42832529" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42832090">parent</a><span>|</span><a href="#42832387">prev</a><span>|</span><a href="#42831822">next</a><span>|</span><label class="collapse" for="c-42832529">[-]</label><label class="expand" for="c-42832529">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s almost certainly because of one extra frame of buffering between the mouse move and the screen. Vsync can cause this, but it should be possible to get vsync with just double buffering.</div><br/></div></div></div></div><div id="42831822" class="c"><input type="checkbox" id="c-42831822" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#42832090">prev</a><span>|</span><a href="#42833314">next</a><span>|</span><label class="collapse" for="c-42831822">[-]</label><label class="expand" for="c-42831822">[1 more]</label></div><br/><div class="children"><div class="content">Note that the results will differ between compositors, different GPUs, and different configurations. This is somewhat less the case with X11 since there is only one X server implementation (that Linux desktop systems use, anyhow.)<p>I think there may still be the issue that many compositor&#x2F;GPU combinations don&#x27;t get hardware cursor planes, which would definitely cause a latency discrepancy like this.</div><br/></div></div><div id="42833314" class="c"><input type="checkbox" id="c-42833314" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#42831822">prev</a><span>|</span><a href="#42837617">next</a><span>|</span><label class="collapse" for="c-42833314">[-]</label><label class="expand" for="c-42833314">[25 more]</label></div><br/><div class="children"><div class="content">TIL Wayland is 16 years old already; in a few years (I can&#x27;t math) it&#x27;ll be as old as X was when Wayland came out, but it seems it&#x27;s still considered mediocre or not as good as X was.</div><br/><div id="42834974" class="c"><input type="checkbox" id="c-42834974" checked=""/><div class="controls bullet"><span class="by">jzb</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42833758">next</a><span>|</span><label class="collapse" for="c-42834974">[-]</label><label class="expand" for="c-42834974">[12 more]</label></div><br/><div class="children"><div class="content">Initial release of X was June 1984, and Wayland was first released in 2008 -- so it won&#x27;t be until 2032 that Wayland is the same age. When people complain about Wayland being mediocre or &quot;as good as X was&quot; what they often mean is &quot;Wayland doesn&#x27;t support $very_specific_feature&quot; or &quot;my video card vendor&#x27;s proprietary drivers aren&#x27;t well-tested with Wayland and it makes me sad&quot;.<p>Approximately 99.999% of those complaints are uttered by people who 1) are not doing the work, 2) are not interested or capable of doing the work, and 3) do not understand or refuse to acknowledge that the Wayland and X developers are _mostly the same folks_ and they _do not want to work on X11 anymore_.<p>I don&#x27;t really have a stake in this argument, except I&#x27;m bone-tired of seeing people whine about Wayland when they&#x27;re using software somebody else gave them for free. There are enough Wayland whiners that, by now, they could&#x27;ve banded together and started maintaining &#x2F; improving X and (if their complaints and theories were correct) left Wayland behind.<p>Strangely -- even though X is open source and eminently forkable (we know this, because XFree86 -&gt; X.org) it gathers dust and none of its proponents are doing anything towards its upkeep.<p>When someone shows up with &quot;Wayland isn&#x27;t as good as X, so here is my modernized fork of X anyone can use&quot; -- I&#x27;ll be quite interested.</div><br/><div id="42836602" class="c"><input type="checkbox" id="c-42836602" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42834974">parent</a><span>|</span><a href="#42835435">next</a><span>|</span><label class="collapse" for="c-42836602">[-]</label><label class="expand" for="c-42836602">[5 more]</label></div><br/><div class="children"><div class="content">&gt; When people complain about Wayland being mediocre or &quot;as good as X was&quot; what they often mean is &quot;Wayland doesn&#x27;t support $very_specific_feature&quot; or &quot;my video card vendor&#x27;s proprietary drivers aren&#x27;t well-tested with Wayland and it makes me sad&quot;.<p>...Yes? Wayland being a regression in terms of features and bugginess <i>is</i> kinda a sticking point.<p>&gt; Approximately 99.999% of those complaints are uttered by people who 1) are not doing the work, 2) are not interested or capable of doing the work, and 3) do not understand or refuse to acknowledge that the Wayland and X developers are _mostly the same folks_ and they _do not want to work on X11 anymore_.<p>If X works for someone and Wayland doesn&#x27;t, none of that matters. It doesn&#x27;t matter how much you insult X users, it won&#x27;t make their usecases invalid or make Wayland good enough.<p>&gt; I don&#x27;t really have a stake in this argument, except I&#x27;m bone-tired of seeing people whine about Wayland when they&#x27;re using software somebody else gave them for free.<p>It cuts both ways: Users aren&#x27;t entitled to free work, and developers aren&#x27;t entitled to their work being well-regarded. Giving software away for free has never meant that people can&#x27;t point out its problems.</div><br/><div id="42836821" class="c"><input type="checkbox" id="c-42836821" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836602">parent</a><span>|</span><a href="#42835435">next</a><span>|</span><label class="collapse" for="c-42836821">[-]</label><label class="expand" for="c-42836821">[4 more]</label></div><br/><div class="children"><div class="content">X also isn&#x27;t wrking for some. If you care about tearing for instance x doesn&#x27;t work.</div><br/><div id="42837849" class="c"><input type="checkbox" id="c-42837849" checked=""/><div class="controls bullet"><span class="by">Ballas</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836821">parent</a><span>|</span><a href="#42837000">next</a><span>|</span><label class="collapse" for="c-42837849">[-]</label><label class="expand" for="c-42837849">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen any tearing in X in at least 5 years - with nvidia, nouveau and intel drivers. I don&#x27;t think I&#x27;m doing anything special to achieve this, so your comment seems like a strange assertion to me?<p>I agree that X11 has some faults, and I really want Wayland to work, but everytime I try it, something ends up being broken.</div><br/><div id="42838336" class="c"><input type="checkbox" id="c-42838336" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42837849">parent</a><span>|</span><a href="#42837000">next</a><span>|</span><label class="collapse" for="c-42838336">[-]</label><label class="expand" for="c-42838336">[1 more]</label></div><br/><div class="children"><div class="content">I do see heavy tearing when watching videos under i3 on Ubuntu LTS and a 60 Hz monitor. So what? I just don&#x27;t care. Tearing in videos does not hinder me from getting my work done. Watching videos is just wasting time most of the cases anyway.</div><br/></div></div></div></div><div id="42837000" class="c"><input type="checkbox" id="c-42837000" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836821">parent</a><span>|</span><a href="#42837849">prev</a><span>|</span><a href="#42835435">next</a><span>|</span><label class="collapse" for="c-42837000">[-]</label><label class="expand" for="c-42837000">[1 more]</label></div><br/><div class="children"><div class="content">True; also various scaling problems, and its security situation. We&#x27;re in an unfortunate situation where no option has everything. If you want to say &quot;Wayland is better for what I need&quot;, or &quot;Xorg is better for what I need&quot;, or even &quot;Arcan is better for what I need&quot;, then that is 100% legitimate. I&#x27;m also cool with &quot;the current problems with (X|Wayland|Arcan) are...&quot; because that&#x27;s constructive and useful for trying to improve them. It&#x27;s only pretending that one doesn&#x27;t have faults or insulting its users&#x2F;proponents that I mind.</div><br/></div></div></div></div></div></div><div id="42835435" class="c"><input type="checkbox" id="c-42835435" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42834974">parent</a><span>|</span><a href="#42836602">prev</a><span>|</span><a href="#42836431">next</a><span>|</span><label class="collapse" for="c-42835435">[-]</label><label class="expand" for="c-42835435">[2 more]</label></div><br/><div class="children"><div class="content">The core Wayland and X.org don&#x27;t exist in a vacuum. I have written a lot of code over the years that works only on X, as have many others. I have not directly contributed to the X.org server, but have to the &quot;wider X ecosystem&quot;. I will have to rewrite some of that. This is the case for many people.</div><br/><div id="42837247" class="c"><input type="checkbox" id="c-42837247" checked=""/><div class="controls bullet"><span class="by">jzb</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42835435">parent</a><span>|</span><a href="#42836431">next</a><span>|</span><label class="collapse" for="c-42837247">[-]</label><label class="expand" for="c-42837247">[1 more]</label></div><br/><div class="children"><div class="content">&quot;I have not directly contributed to the X.org server, but have to the &quot;wider X ecosystem&quot;. I will have to rewrite some of that. This is the case for many people.&quot;<p>This is a fair point, but the quality of Wayland isn&#x27;t really at issue for this -- Wayland could be much better than X by all accounts and it would still require you to rewrite software for it. (Assuming XWayland doesn&#x27;t suit your needs, anyway.)</div><br/></div></div></div></div><div id="42836431" class="c"><input type="checkbox" id="c-42836431" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42834974">parent</a><span>|</span><a href="#42835435">prev</a><span>|</span><a href="#42833758">next</a><span>|</span><label class="collapse" for="c-42836431">[-]</label><label class="expand" for="c-42836431">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There are enough Wayland whiners that, by now, they could&#x27;ve banded together and started maintaining &#x2F; improving X and (if their complaints and theories were correct) left Wayland behind.<p>They already have. X is already more full-featured and stable than Wayland (yes it is missing certain niche features that Wayland has). Sometimes the most important thing you can do with a piece of software is not screw around with it.</div><br/><div id="42836583" class="c"><input type="checkbox" id="c-42836583" checked=""/><div class="controls bullet"><span class="by">braiamp</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836431">parent</a><span>|</span><a href="#42833758">next</a><span>|</span><label class="collapse" for="c-42836583">[-]</label><label class="expand" for="c-42836583">[3 more]</label></div><br/><div class="children"><div class="content">And yet, X is as flawed as it can be. There&#x27;s a problem with global shortcuts, that Xorg only fires an event on keyup&#x2F;key release, rather than on first match on keypress. That is a protocol limitation, and fixing it means breaking a bunch of stuff. The complains about wayland are of that nature, but at least they are fixable.</div><br/><div id="42836851" class="c"><input type="checkbox" id="c-42836851" checked=""/><div class="controls bullet"><span class="by">goosedragons</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836583">parent</a><span>|</span><a href="#42838103">next</a><span>|</span><label class="collapse" for="c-42836851">[-]</label><label class="expand" for="c-42836851">[1 more]</label></div><br/><div class="children"><div class="content">Are they fixable? One of my beefs with Wayland is that every compositor handles things differently. How GNOME&#x27;s does some setting is different from how KDE&#x27;s is different from Sway&#x27;s. There&#x27;s no guarantee they&#x27;ve even implemented the setting either. In X11 you can always globally configure something for any WM the same way. Wayland by design you can&#x27;t. It&#x27;s not fixable. I think it was a really poor decision to do a protocol and just made an OS where things are often too fragmented even more fragmented.</div><br/></div></div><div id="42838103" class="c"><input type="checkbox" id="c-42838103" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836583">parent</a><span>|</span><a href="#42836851">prev</a><span>|</span><a href="#42833758">next</a><span>|</span><label class="collapse" for="c-42838103">[-]</label><label class="expand" for="c-42838103">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The complains about wayland are of that nature, but at least they are fixable.<p>Eh maybe. Ultimately you can never be sure something is possible without doing it.<p>I&#x27;m pragmatic here, if and when Wayland offers me a better experience than X then I&#x27;ll use it. I just resent distros etc. pushing me towards it when it&#x27;s currently a downgrade.</div><br/></div></div></div></div></div></div></div></div><div id="42833758" class="c"><input type="checkbox" id="c-42833758" checked=""/><div class="controls bullet"><span class="by">craftkiller</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42834974">prev</a><span>|</span><a href="#42833746">next</a><span>|</span><label class="collapse" for="c-42833758">[-]</label><label class="expand" for="c-42833758">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 16 years old [...] in a few years [...] it&#x27;ll be as old as X was when Wayland came out<p>Lol no. X is from 1984: <a href="https:&#x2F;&#x2F;www.talisman.org&#x2F;x-debut.shtml" rel="nofollow">https:&#x2F;&#x2F;www.talisman.org&#x2F;x-debut.shtml</a><p>That means Wayland is only 66% the age of X when Wayland came out, or you&#x27;d need 50% more of Wayland&#x27;s life before its as old as X was.</div><br/></div></div><div id="42833746" class="c"><input type="checkbox" id="c-42833746" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42833758">prev</a><span>|</span><a href="#42834713">next</a><span>|</span><label class="collapse" for="c-42833746">[-]</label><label class="expand" for="c-42833746">[4 more]</label></div><br/><div class="children"><div class="content">If X is 40 and Wayland is 16,that means a difference of 24 years. Hence Wayland compositors have 8 years to work out the kinks. I am currently using Wayland via Plasma 6 and it works well enough but I don&#x27;t have special needs, so I don&#x27;t know how well... say... screen readers work.</div><br/><div id="42834737" class="c"><input type="checkbox" id="c-42834737" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42833746">parent</a><span>|</span><a href="#42834713">next</a><span>|</span><label class="collapse" for="c-42834737">[-]</label><label class="expand" for="c-42834737">[3 more]</label></div><br/><div class="children"><div class="content">That means in two more years it will be legal for X11 and Wayland to have a baby!</div><br/><div id="42838478" class="c"><input type="checkbox" id="c-42838478" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42834737">parent</a><span>|</span><a href="#42838212">next</a><span>|</span><label class="collapse" for="c-42838478">[-]</label><label class="expand" for="c-42838478">[1 more]</label></div><br/><div class="children"><div class="content">We can call it V to signify another step backwards and make it the default, people can just use the terminal until the first implementation crops up.</div><br/></div></div><div id="42838212" class="c"><input type="checkbox" id="c-42838212" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42834737">parent</a><span>|</span><a href="#42838478">prev</a><span>|</span><a href="#42834713">next</a><span>|</span><label class="collapse" for="c-42838212">[-]</label><label class="expand" for="c-42838212">[1 more]</label></div><br/><div class="children"><div class="content">Maybe like we did we pulseaudio (throw it away and make pipewire) needs to be done with wayland.</div><br/></div></div></div></div></div></div><div id="42834713" class="c"><input type="checkbox" id="c-42834713" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42833746">prev</a><span>|</span><a href="#42838678">next</a><span>|</span><label class="collapse" for="c-42834713">[-]</label><label class="expand" for="c-42834713">[1 more]</label></div><br/><div class="children"><div class="content">Another way to look at these figures is that in a few years a Wayland successor is due, born out of the same motivation as Wayland ie. lack of people with a desire to maintain legacy software. My expectation is that browser frontend stacks will eat the desktop completely at that point; it&#x27;s not like there weren&#x27;t many new desktop apps on Linux anyway.</div><br/></div></div><div id="42838678" class="c"><input type="checkbox" id="c-42838678" checked=""/><div class="controls bullet"><span class="by">ein0p</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42834713">prev</a><span>|</span><a href="#42835558">next</a><span>|</span><label class="collapse" for="c-42838678">[-]</label><label class="expand" for="c-42838678">[1 more]</label></div><br/><div class="children"><div class="content">16 years old and there&#x27;s still video tearing in the browsers. I try it with every Ubuntu LTS release, and then switch back to X in a few days. It solves problems I just don&#x27;t have.</div><br/></div></div><div id="42835558" class="c"><input type="checkbox" id="c-42835558" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42838678">prev</a><span>|</span><a href="#42834850">next</a><span>|</span><label class="collapse" for="c-42835558">[-]</label><label class="expand" for="c-42835558">[3 more]</label></div><br/><div class="children"><div class="content">&gt; but it seems it&#x27;s still considered mediocre or not as good as X was.<p>Because there was a big fracture and doubt in the community support for Wayland, not to mention alternatives like mir popping up and diverting resources.</div><br/><div id="42836862" class="c"><input type="checkbox" id="c-42836862" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42835558">parent</a><span>|</span><a href="#42834850">next</a><span>|</span><label class="collapse" for="c-42836862">[-]</label><label class="expand" for="c-42836862">[2 more]</label></div><br/><div class="children"><div class="content">A lot of things liked mir happened over the years and didn&#x27;t go anywhere. Most tried to fix problems with x that the x developers said were not the real problems. When wayland came it was supported by people who knew the real problems with x. They have also proven to keep working - no surprise at they had a history of working on x.</div><br/><div id="42838218" class="c"><input type="checkbox" id="c-42838218" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42833314">root</a><span>|</span><a href="#42836862">parent</a><span>|</span><a href="#42834850">next</a><span>|</span><label class="collapse" for="c-42838218">[-]</label><label class="expand" for="c-42838218">[1 more]</label></div><br/><div class="children"><div class="content">They &quot;claimed&quot; to know the real problems with X. But the fact that wayland is still lacking features shows otherwise.</div><br/></div></div></div></div></div></div><div id="42834850" class="c"><input type="checkbox" id="c-42834850" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42835558">prev</a><span>|</span><a href="#42835136">next</a><span>|</span><label class="collapse" for="c-42834850">[-]</label><label class="expand" for="c-42834850">[1 more]</label></div><br/><div class="children"><div class="content">Wayland came out at the same time as the Windows compositor in Vista. Let&#x27;s be generous and consider the next Windows version, 7, as having a &quot;good&#x2F;stable&quot; compositor. So Wayland is 13 years behind Windows.</div><br/></div></div><div id="42835136" class="c"><input type="checkbox" id="c-42835136" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42833314">parent</a><span>|</span><a href="#42834850">prev</a><span>|</span><a href="#42837617">next</a><span>|</span><label class="collapse" for="c-42835136">[-]</label><label class="expand" for="c-42835136">[1 more]</label></div><br/><div class="children"><div class="content">Based on what exactly? On a single frame difference, which is easily explained by the fundamental point of Wayland: no tearing? It&#x27;s simply that X puts the cursor asynchronously, potentially tearing it, while Wayland always renders a correct frame, but the mouse movements&#x27; result has to wait for the very next frame.<p>That&#x27;s literally it.</div><br/></div></div></div></div><div id="42837617" class="c"><input type="checkbox" id="c-42837617" checked=""/><div class="controls bullet"><span class="by">adeon</span><span>|</span><a href="#42833314">prev</a><span>|</span><a href="#42833081">next</a><span>|</span><label class="collapse" for="c-42837617">[-]</label><label class="expand" for="c-42837617">[2 more]</label></div><br/><div class="children"><div class="content">I used to be a NetHack speedrunner. Pressing the keys real fast. All of it in terminals. I had the fastest run for almost 10 years. Input lag was a thing I thought sometimes. Everything below is based on pure gut feelings because I never measured any of it.<p>I&#x27;ve long wondered why some terminals and operating systems felt like they were pretty laggy. In the sense that if I press my character to move, how long until they actually move?<p>iTerm2 on MacOS is worst offender. But I can&#x27;t tell if it&#x27;s iTerm2 or MacOS itself. I remember trying other terminals on Mac, and it was mostly the same. iTerm2 itself also had bunch of rendering options, but I couldn&#x27;t get them to do anything I could actually feel affected input lag. One thought I had was: maybe iTerm2 added 1 frame lateness, and MacOS itself added another? But that would be ~30ms on a 60fps monitor which I can easily already tell on a server-connection NetHack.<p>I also have no idea if measuring &quot;N frames late&quot; is actually a sensible way to think about this. I assume computers know when a key is pressed at a higher frequency?<p>Linux xterm and rxvt were the fastest that I remember, on X11 (I&#x27;ve never used Wayland like in the article, well not for NetHack anyway).<p>I have no idea how compositors work on any of these operating systems or X11&#x2F;Wayland to say anything smart about them or why they would be slower or faster.<p>Reading the article...I realized I have that same iPhone 15 Pro with 240fps recording. I could replicate that experiment, but testing out terminals on various operating systems instead I used to play on. So I could now test if my gut feeling was right all along or not. <i>or maybe it lied to me all these years</i>.<p>I wrote the idea in the article down on my notes, maybe when I&#x27;m bored enough I&#x27;ll try it :) and I can stop saying propaganda about iTerm2 being slow if it turns out I was completely wrong. Maybe I have easier time because all my NetHack days were 60fps, so I have more leeway in measurements.<p>I&#x27;m not active in NetHack playing anymore, although I sometimes play it as a comfort game.</div><br/><div id="42838144" class="c"><input type="checkbox" id="c-42838144" checked=""/><div class="controls bullet"><span class="by">patal</span><span>|</span><a href="#42837617">parent</a><span>|</span><a href="#42833081">next</a><span>|</span><label class="collapse" for="c-42838144">[-]</label><label class="expand" for="c-42838144">[1 more]</label></div><br/><div class="children"><div class="content">iTerm2 is on 45ms and more in this measuring: <a href="https:&#x2F;&#x2F;danluu.com&#x2F;term-latency&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;term-latency&#x2F;</a><p>There, it&#x27;s distinct in that other terminals have lower latency on the same system.</div><br/></div></div></div></div><div id="42833081" class="c"><input type="checkbox" id="c-42833081" checked=""/><div class="controls bullet"><span class="by">SaintSeiya</span><span>|</span><a href="#42837617">prev</a><span>|</span><a href="#42831907">next</a><span>|</span><label class="collapse" for="c-42833081">[-]</label><label class="expand" for="c-42833081">[13 more]</label></div><br/><div class="children"><div class="content">Why this does not surprise me? every attempt to rewrite a working solution to make it more &quot;modern, easy to maintain and future proof&quot; rarely do so. It always end up slower, with more latency and lifted by faster hardware, not by faster software. 
Every 20 years a new generation comes weaker, pampered with the  abtsractions of the previous generations who did the grunt work for them. After 3 generations of software developers all we have is library&#x2F;framework callers and nobody really knows about performance and optimization.</div><br/><div id="42833425" class="c"><input type="checkbox" id="c-42833425" checked=""/><div class="controls bullet"><span class="by">kombine</span><span>|</span><a href="#42833081">parent</a><span>|</span><a href="#42834368">next</a><span>|</span><label class="collapse" for="c-42833425">[-]</label><label class="expand" for="c-42833425">[10 more]</label></div><br/><div class="children"><div class="content">This is not my experience. When I upgraded several of my computers to KDE 6 switching to Wayland, overall responsiveness and snappiness of the system increased very visibly. There are still features that Wayland lacks compared to X11, but I am willing to compromise in favor of its other benefits.</div><br/><div id="42834347" class="c"><input type="checkbox" id="c-42834347" checked=""/><div class="controls bullet"><span class="by">dvdkon</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42833425">parent</a><span>|</span><a href="#42838233">next</a><span>|</span><label class="collapse" for="c-42834347">[-]</label><label class="expand" for="c-42834347">[2 more]</label></div><br/><div class="children"><div class="content">Same here, switching from i3 to sway resulted in a noticeably more responsive experience on my aging hardware. Of course, this is just an anecdote, and I could probably get the same results on X with some fiddling, but I do think the value of simpler and more modern systems is demonstrated here.</div><br/><div id="42837444" class="c"><input type="checkbox" id="c-42837444" checked=""/><div class="controls bullet"><span class="by">WhyNotHugo</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42834347">parent</a><span>|</span><a href="#42838233">next</a><span>|</span><label class="collapse" for="c-42837444">[-]</label><label class="expand" for="c-42837444">[1 more]</label></div><br/><div class="children"><div class="content">I’d be interested in seeing similar benchmarks done on x11+i3 vs sway.<p>There’s nothing Wayland-specific that would introduce this latency, so I wonder if wlroots&#x2F;sway have any additions lag.</div><br/></div></div></div></div><div id="42838233" class="c"><input type="checkbox" id="c-42838233" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42833425">parent</a><span>|</span><a href="#42834347">prev</a><span>|</span><a href="#42834142">next</a><span>|</span><label class="collapse" for="c-42838233">[-]</label><label class="expand" for="c-42838233">[1 more]</label></div><br/><div class="children"><div class="content">????<p>After upgrading to plasma6 from 5, all the desktop animations have started stuttering. Probably your hardware is too new.</div><br/></div></div><div id="42834142" class="c"><input type="checkbox" id="c-42834142" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42833425">parent</a><span>|</span><a href="#42838233">prev</a><span>|</span><a href="#42834368">next</a><span>|</span><label class="collapse" for="c-42834142">[-]</label><label class="expand" for="c-42834142">[6 more]</label></div><br/><div class="children"><div class="content">On the other hand, I just did a fresh install of Artix Linux. Installed KDE just to have something functional while I get my tiling setup working. Boot into Plasma(Wayland) and it utterly shits itself, turning my main monitor on and off repeatedly until it finally crashes. So I pick Plasma(X11) instead and that just works.<p>In fact, in almost 2 decades of using Linux every day, I can&#x27;t remember X doing anything similar. It&#x27;s always just worked.</div><br/><div id="42835178" class="c"><input type="checkbox" id="c-42835178" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42834142">parent</a><span>|</span><a href="#42834368">next</a><span>|</span><label class="collapse" for="c-42835178">[-]</label><label class="expand" for="c-42835178">[5 more]</label></div><br/><div class="children"><div class="content">&gt; In fact, in almost 2 decades of using Linux every day, I can&#x27;t remember X doing anything similar. It&#x27;s always just worked.<p>Well, we have <i>very</i> different memories then. Sure, X worked reliably once configured. But configuring it was a marathon in hell, as per by my memory, and all the litany of forum posts crying out for help all across the internet. Like, I have at one point had to rescue an install by changing back the config file without a screen at all!</div><br/><div id="42838793" class="c"><input type="checkbox" id="c-42838793" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42835178">parent</a><span>|</span><a href="#42835325">next</a><span>|</span><label class="collapse" for="c-42838793">[-]</label><label class="expand" for="c-42838793">[1 more]</label></div><br/><div class="children"><div class="content">I mean, I&#x27;ve certainly had issues with X before, back when you had to configure it. But they were usually initial issues while figuring out the right configuration. And if you had a GPU where the choice was between shitty proprietary blob drivers and woefully incomplete open ones, you might have a bad experience regardless of what you put in the config. But that&#x27;s not really Xorg&#x27;s fault. It can&#x27;t magically make shitty drivers good. With decent drivers, once configured, it was rock solid, and has been for as long as I&#x27;ve been using Linux. And for a long time the configuration has been addressed; it now figures that stuff out on its own the vast majority of the time, unless you have really specific needs, in which case I bet Wayland compositors don&#x27;t fare any better.<p>I also fundamentally disagree with the idea that X &quot;does too much&quot;, which is often cited in favour of Wayland. The fact that X encompasses everything about how I interact with my computer is one of the things I love about it. I might switch WMs and DEs, but my xmodmap, xresources etc remain the same.</div><br/></div></div><div id="42835325" class="c"><input type="checkbox" id="c-42835325" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42835178">parent</a><span>|</span><a href="#42838793">prev</a><span>|</span><a href="#42838236">next</a><span>|</span><label class="collapse" for="c-42835325">[-]</label><label class="expand" for="c-42835325">[1 more]</label></div><br/><div class="children"><div class="content">I remember this too, but it was a really long time ago.</div><br/></div></div><div id="42838236" class="c"><input type="checkbox" id="c-42838236" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42835178">parent</a><span>|</span><a href="#42835325">prev</a><span>|</span><a href="#42834368">next</a><span>|</span><label class="collapse" for="c-42838236">[-]</label><label class="expand" for="c-42838236">[2 more]</label></div><br/><div class="children"><div class="content">That was like over 10 years ago… It has been a long time since Xorg required configuring.</div><br/><div id="42838412" class="c"><input type="checkbox" id="c-42838412" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42838236">parent</a><span>|</span><a href="#42834368">next</a><span>|</span><label class="collapse" for="c-42838412">[-]</label><label class="expand" for="c-42838412">[1 more]</label></div><br/><div class="children"><div class="content">Yes. Grandparent talked about 20 years ago. 15 years ago Ubuntu required no configuration at all if you had a graphics card that worked (most newer ones did, Nvidia was a nightmare).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42834368" class="c"><input type="checkbox" id="c-42834368" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#42833081">parent</a><span>|</span><a href="#42833425">prev</a><span>|</span><a href="#42831907">next</a><span>|</span><label class="collapse" for="c-42834368">[-]</label><label class="expand" for="c-42834368">[2 more]</label></div><br/><div class="children"><div class="content">Old computers had less latency, but otoh on many OSes a single app crashing meant the whole OS was irresponsive and you had to reboot the whole system.</div><br/><div id="42834810" class="c"><input type="checkbox" id="c-42834810" checked=""/><div class="controls bullet"><span class="by">Avamander</span><span>|</span><a href="#42833081">root</a><span>|</span><a href="#42834368">parent</a><span>|</span><a href="#42831907">next</a><span>|</span><label class="collapse" for="c-42834810">[-]</label><label class="expand" for="c-42834810">[1 more]</label></div><br/><div class="children"><div class="content">Less latency matters little if it&#x27;s just to wait behind some other operation like disk IO or network.</div><br/></div></div></div></div></div></div><div id="42831907" class="c"><input type="checkbox" id="c-42831907" checked=""/><div class="controls bullet"><span class="by">mikenew</span><span>|</span><a href="#42833081">prev</a><span>|</span><a href="#42831848">next</a><span>|</span><label class="collapse" for="c-42831907">[-]</label><label class="expand" for="c-42831907">[3 more]</label></div><br/><div class="children"><div class="content">I get major lag spikes when the gpu is under heavy load (like doing Stable Diffusion inference or something). TBF I haven&#x27;t A&#x2F;B tested with X11, but I don&#x27;t ever remember it being like that. An extra frame of latency isn&#x27;t great on it&#x27;s own, but the occasional spikes in lag are really irritating.</div><br/><div id="42832439" class="c"><input type="checkbox" id="c-42832439" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#42831907">parent</a><span>|</span><a href="#42831848">next</a><span>|</span><label class="collapse" for="c-42832439">[-]</label><label class="expand" for="c-42832439">[2 more]</label></div><br/><div class="children"><div class="content">May still happen especially if it is thrashing vram in and out of system memory or something, but have you tried lowering priority of the stable diffusion process?</div><br/><div id="42836950" class="c"><input type="checkbox" id="c-42836950" checked=""/><div class="controls bullet"><span class="by">cloudwalk9</span><span>|</span><a href="#42831907">root</a><span>|</span><a href="#42832439">parent</a><span>|</span><a href="#42831848">next</a><span>|</span><label class="collapse" for="c-42836950">[-]</label><label class="expand" for="c-42836950">[1 more]</label></div><br/><div class="children"><div class="content">I can also attest to horrific lagspikes on an Optimus laptop even if Intel is driving the desktop. Memory pressure is definitely the problem here. Lagspikes actually <i>lessened</i> when I switched to Wayland Gnome. I think they lessened further with PREEMPT_RT on kernel 6.12. Nvidia requires an environment variable to build on real time kernels but it plays surprisingly nice as of driver 570. But if you have this config, you need at least 11th gen Intel iGPU or AMD APU, because i915 does not build for real-time kernels. Only the Xe driver works and only if you force_probe the ID if it&#x27;s Tiger Lake.<p>...Which I don&#x27;t get because the Xe driver is said to explicitly support, at minimum, Tiger Lake. I played Minecraft on the iGPU with Xe and it was perfectly fine. It... drew 3D graphics at expected framerates.</div><br/></div></div></div></div></div></div><div id="42831848" class="c"><input type="checkbox" id="c-42831848" checked=""/><div class="controls bullet"><span class="by">sapiogram</span><span>|</span><a href="#42831907">prev</a><span>|</span><a href="#42831823">next</a><span>|</span><label class="collapse" for="c-42831848">[-]</label><label class="expand" for="c-42831848">[1 more]</label></div><br/><div class="children"><div class="content">Beautiful work. Could it be worth repeating the experiment with the monitor running at a very low refresh rate, i.e. 30hz? If Wayland is always a frame slower than X11, it should be much easier to observe.</div><br/></div></div><div id="42831823" class="c"><input type="checkbox" id="c-42831823" checked=""/><div class="controls bullet"><span class="by">tapoxi</span><span>|</span><a href="#42831848">prev</a><span>|</span><a href="#42832301">next</a><span>|</span><label class="collapse" for="c-42831823">[-]</label><label class="expand" for="c-42831823">[2 more]</label></div><br/><div class="children"><div class="content">This is probably compositor specific, so I wonder if this is a mutter issue or if it can be replicated in kwin.</div><br/><div id="42835434" class="c"><input type="checkbox" id="c-42835434" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42831823">parent</a><span>|</span><a href="#42832301">next</a><span>|</span><label class="collapse" for="c-42835434">[-]</label><label class="expand" for="c-42835434">[1 more]</label></div><br/><div class="children"><div class="content">Mutter has one of the laggiest Wayland implementations imho.</div><br/></div></div></div></div><div id="42832301" class="c"><input type="checkbox" id="c-42832301" checked=""/><div class="controls bullet"><span class="by">kelseyfrog</span><span>|</span><a href="#42831823">prev</a><span>|</span><a href="#42834032">next</a><span>|</span><label class="collapse" for="c-42832301">[-]</label><label class="expand" for="c-42832301">[9 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t have the statistics expertise necessary to properly analyze whether this difference is statistically significant or not,<p>The two sample t-test statistic is -4.74 with a p-value of 4.20e-05.</div><br/><div id="42832350" class="c"><input type="checkbox" id="c-42832350" checked=""/><div class="controls bullet"><span class="by">pwr22</span><span>|</span><a href="#42832301">parent</a><span>|</span><a href="#42834032">next</a><span>|</span><label class="collapse" for="c-42832350">[-]</label><label class="expand" for="c-42832350">[8 more]</label></div><br/><div class="children"><div class="content">and that means?</div><br/><div id="42832546" class="c"><input type="checkbox" id="c-42832546" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42832350">parent</a><span>|</span><a href="#42837637">next</a><span>|</span><label class="collapse" for="c-42832546">[-]</label><label class="expand" for="c-42832546">[3 more]</label></div><br/><div class="children"><div class="content">That there&#x27;s a probability of 4.20e-05 that the observed difference of that large would happen by chance due to observation noise if there would be no real difference (given your assumptions about the data generating process holds).</div><br/><div id="42838196" class="c"><input type="checkbox" id="c-42838196" checked=""/><div class="controls bullet"><span class="by">tstenner</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42832546">parent</a><span>|</span><a href="#42837637">next</a><span>|</span><label class="collapse" for="c-42838196">[-]</label><label class="expand" for="c-42838196">[2 more]</label></div><br/><div class="children"><div class="content">The normality assumption is a large stretch, especially since there an absolute lower limit near the observation and a somewhat discrete distribution, so a t-test isn&#x27;t appropriate. But then again it looks significant, so there&#x27;s no real need for a test</div><br/><div id="42838252" class="c"><input type="checkbox" id="c-42838252" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42838196">parent</a><span>|</span><a href="#42837637">next</a><span>|</span><label class="collapse" for="c-42838252">[-]</label><label class="expand" for="c-42838252">[1 more]</label></div><br/><div class="children"><div class="content">Something like Mann-Whitney U would be safer. But it&#x27;s indeed quite obvious from the samples that the difference is robust.</div><br/></div></div></div></div></div></div><div id="42837637" class="c"><input type="checkbox" id="c-42837637" checked=""/><div class="controls bullet"><span class="by">pjdesno</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42832350">parent</a><span>|</span><a href="#42832546">prev</a><span>|</span><a href="#42836456">next</a><span>|</span><label class="collapse" for="c-42837637">[-]</label><label class="expand" for="c-42837637">[1 more]</label></div><br/><div class="children"><div class="content">In a lot of fields, p=0.05 is good enough to publish. p=0.0001 means it&#x27;s really f*ing unlikely that the difference in means is due to random chance.</div><br/></div></div><div id="42836456" class="c"><input type="checkbox" id="c-42836456" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42832350">parent</a><span>|</span><a href="#42837637">prev</a><span>|</span><a href="#42832389">next</a><span>|</span><label class="collapse" for="c-42836456">[-]</label><label class="expand" for="c-42836456">[1 more]</label></div><br/><div class="children"><div class="content">Evidence more than strong enough to be published in most fields. Not quite strong enough to qualify as &quot;discovery&quot; in high-energy physics.</div><br/></div></div><div id="42832389" class="c"><input type="checkbox" id="c-42832389" checked=""/><div class="controls bullet"><span class="by">kelseyfrog</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42832350">parent</a><span>|</span><a href="#42836456">prev</a><span>|</span><a href="#42834032">next</a><span>|</span><label class="collapse" for="c-42832389">[-]</label><label class="expand" for="c-42832389">[2 more]</label></div><br/><div class="children"><div class="content">Depends on your alpha ;) . But it&#x27;s significant.</div><br/><div id="42833606" class="c"><input type="checkbox" id="c-42833606" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#42832301">root</a><span>|</span><a href="#42832389">parent</a><span>|</span><a href="#42834032">next</a><span>|</span><label class="collapse" for="c-42833606">[-]</label><label class="expand" for="c-42833606">[1 more]</label></div><br/><div class="children"><div class="content">That <i>really</i> does not answer the question.</div><br/></div></div></div></div></div></div></div></div><div id="42834032" class="c"><input type="checkbox" id="c-42834032" checked=""/><div class="controls bullet"><span class="by">mattbee</span><span>|</span><a href="#42832301">prev</a><span>|</span><a href="#42838208">next</a><span>|</span><label class="collapse" for="c-42834032">[-]</label><label class="expand" for="c-42834032">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve used <a href="https:&#x2F;&#x2F;isitsnappy.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;isitsnappy.com&#x2F;</a> on the iPhone to do these kinds of measurements pretty quickly, to substantiate why I sucked at Steam Deck rhythm games when connected to a TV.<p>(I do not suck, my setup had 100ms lag)</div><br/><div id="42834143" class="c"><input type="checkbox" id="c-42834143" checked=""/><div class="controls bullet"><span class="by">abhinavk</span><span>|</span><a href="#42834032">parent</a><span>|</span><a href="#42834173">next</a><span>|</span><label class="collapse" for="c-42834143">[-]</label><label class="expand" for="c-42834143">[1 more]</label></div><br/><div class="children"><div class="content">Great app. I hope next iPhones have improved slow-motion camera modes. 1000fps will be a long shot but maybe 480&#x2F;500fps.</div><br/></div></div><div id="42834173" class="c"><input type="checkbox" id="c-42834173" checked=""/><div class="controls bullet"><span class="by">davet91</span><span>|</span><a href="#42834032">parent</a><span>|</span><a href="#42834143">prev</a><span>|</span><a href="#42838208">next</a><span>|</span><label class="collapse" for="c-42834173">[-]</label><label class="expand" for="c-42834173">[2 more]</label></div><br/><div class="children"><div class="content">What was the issue with your setup? TV not in game mode?</div><br/><div id="42834242" class="c"><input type="checkbox" id="c-42834242" checked=""/><div class="controls bullet"><span class="by">mattbee</span><span>|</span><a href="#42834032">root</a><span>|</span><a href="#42834173">parent</a><span>|</span><a href="#42838208">next</a><span>|</span><label class="collapse" for="c-42834242">[-]</label><label class="expand" for="c-42834242">[1 more]</label></div><br/><div class="children"><div class="content">Never got to the bottom of it.  TV was set to game mode, I tried various scaler settings on the deck itself, couldn&#x27;t get it below about 90-100ms. I&#x27;ve tried on two TVs.<p>You can learn to play Space Channel 5 by tapping 100ms ahead of the beat. But I worried that if I succeeded too much, I&#x27;d end up doing everything that way: jumping red lights, taking espresso shots while they were still being poured etc.</div><br/></div></div></div></div></div></div><div id="42838208" class="c"><input type="checkbox" id="c-42838208" checked=""/><div class="controls bullet"><span class="by">chme</span><span>|</span><a href="#42834032">prev</a><span>|</span><a href="#42838188">next</a><span>|</span><label class="collapse" for="c-42838208">[-]</label><label class="expand" for="c-42838208">[1 more]</label></div><br/><div class="children"><div class="content">If you just want to measure user space software input lag, shouldn&#x27;t it be more accurate if you print out the time when the event arrives in the kernel, and again when the mouse moves within a application window?</div><br/></div></div><div id="42838188" class="c"><input type="checkbox" id="c-42838188" checked=""/><div class="controls bullet"><span class="by">oskenso</span><span>|</span><a href="#42838208">prev</a><span>|</span><a href="#42836896">next</a><span>|</span><label class="collapse" for="c-42838188">[-]</label><label class="expand" for="c-42838188">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad more people are looking into this. Maybe one day we&#x27;ll discover the cause of the Laggy Mouse bug which has been a problem since 2015<p><a href="https:&#x2F;&#x2F;bugzilla.gnome.org&#x2F;show_bug.cgi?id=745032" rel="nofollow">https:&#x2F;&#x2F;bugzilla.gnome.org&#x2F;show_bug.cgi?id=745032</a>
<a href="https:&#x2F;&#x2F;gitlab.gnome.org&#x2F;GNOME&#x2F;gnome-shell&#x2F;-&#x2F;issues&#x2F;749" rel="nofollow">https:&#x2F;&#x2F;gitlab.gnome.org&#x2F;GNOME&#x2F;gnome-shell&#x2F;-&#x2F;issues&#x2F;749</a></div><br/></div></div><div id="42836896" class="c"><input type="checkbox" id="c-42836896" checked=""/><div class="controls bullet"><span class="by">sho_hn</span><span>|</span><a href="#42838188">prev</a><span>|</span><a href="#42836069">next</a><span>|</span><label class="collapse" for="c-42836896">[-]</label><label class="expand" for="c-42836896">[1 more]</label></div><br/><div class="children"><div class="content">Note that Wayland is a protocol, not an implementation. This testing was done with Gnome&#x27;s implementation of Wayland, which doesn&#x27;t mean much for any other Wayland desktop.</div><br/></div></div><div id="42836069" class="c"><input type="checkbox" id="c-42836069" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#42836896">prev</a><span>|</span><a href="#42833843">next</a><span>|</span><label class="collapse" for="c-42836069">[-]</label><label class="expand" for="c-42836069">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like the design of Wayland at all, so it&#x27;ll take a lot more than performance analytics to get me to switch. I think that one of the core issues in Linux is nothing is ever consolidated, only moved toward more fragmentation. Wayland had the opportunity to consolidate, but instead to not fix fragmentation (each app is responsible for drawing its own window borders) and introduce more (multiple compositors each with their own quirks and non-standard APIs)</div><br/></div></div><div id="42833843" class="c"><input type="checkbox" id="c-42833843" checked=""/><div class="controls bullet"><span class="by">perihelions</span><span>|</span><a href="#42836069">prev</a><span>|</span><a href="#42832150">next</a><span>|</span><label class="collapse" for="c-42833843">[-]</label><label class="expand" for="c-42833843">[3 more]</label></div><br/><div class="children"><div class="content">For those of you who are application developers on Linux&#x2F;Wayland, do you use any other methods for benchmarking true latencies between input events and screen? Less heroic than the high-speed camera method. I&#x27;m embarrassed I&#x27;ve still never figured this out properly.</div><br/><div id="42834572" class="c"><input type="checkbox" id="c-42834572" checked=""/><div class="controls bullet"><span class="by">freehorse</span><span>|</span><a href="#42833843">parent</a><span>|</span><a href="#42836638">next</a><span>|</span><label class="collapse" for="c-42834572">[-]</label><label class="expand" for="c-42834572">[1 more]</label></div><br/><div class="children"><div class="content">A photocell is I think the standard (or at least &quot;the standard&quot; in psychophysics applications I have also used). You need, though, to make sure your event causes a change that a simple photocell would detect (eg you have a corner of your screen or application window having a small square that turns from black to white and vice versa). You can connect that to an arduino or whatever you can use to get both signals in some low latency way (one from user interaction or whatever causes the event, and one from the event itself with that light intensity change). There are also photocells with a higher granularity for luminosity changes than just light&#x2F;dark, so maybe you do not need to have the black&#x2F;white square thing, just something that causes enough luminosity change to be detected. This should, in principle, give you very accurate timings if you can also get the event initiator somehow with low latency (or you can do stuff like simulate an event periodically and look for skipped frames&#x2F;variance in the screen presentation rather than latency).</div><br/></div></div><div id="42836638" class="c"><input type="checkbox" id="c-42836638" checked=""/><div class="controls bullet"><span class="by">dsissitka</span><span>|</span><a href="#42833843">parent</a><span>|</span><a href="#42834572">prev</a><span>|</span><a href="#42832150">next</a><span>|</span><label class="collapse" for="c-42836638">[-]</label><label class="expand" for="c-42836638">[1 more]</label></div><br/><div class="children"><div class="content">You might like Typometer. I believe it was created by a JetBrains developer to improve input latency in IDEA.<p>&gt; Typometer works by generating OS input events and using screen capture to measure the delay between a keystroke and a corresponding screen update. Hence, the measurement encompasses all the constituents of processing latency (i. e. OS queue, VM, editor, GPU pipeline, buffering, window manager and possible V-Sync).<p><a href="https:&#x2F;&#x2F;pavelfatin.com&#x2F;typing-with-pleasure&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pavelfatin.com&#x2F;typing-with-pleasure&#x2F;</a></div><br/></div></div></div></div><div id="42832150" class="c"><input type="checkbox" id="c-42832150" checked=""/><div class="controls bullet"><span class="by">hirako2000</span><span>|</span><a href="#42833843">prev</a><span>|</span><a href="#42833205">next</a><span>|</span><label class="collapse" for="c-42832150">[-]</label><label class="expand" for="c-42832150">[17 more]</label></div><br/><div class="children"><div class="content">Was Wayland not architected to fix latency issues?<p>I also find Wayland more laggy and more buggy without concrete evidence of course.<p>It has significantly improved lately though, far more stable than it used to be.</div><br/><div id="42833007" class="c"><input type="checkbox" id="c-42833007" checked=""/><div class="controls bullet"><span class="by">itvision</span><span>|</span><a href="#42832150">parent</a><span>|</span><a href="#42832253">next</a><span>|</span><label class="collapse" for="c-42833007">[-]</label><label class="expand" for="c-42833007">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Was Wayland not architected to fix latency issues?<p>It was designed to fix tearing issues, not latency issues.<p>But then the Wayland designers found out that players often prefer tearing to minimize latency, so the tearing protocol was implemented.<p>When a committee of perfectionists, rather than real people or companies, design something, you often get something that is completely unusable by anyone but that committee.<p>And that&#x27;s exactly how it&#x27;s played out so far. Wayland is still largely incomplete, not to mention it doesn&#x27;t even have a reference implementation [1], and still doesn&#x27;t include&#x2F;describe several essential desktop APIs and features, which results in this protocol not having a ton of universal tools and applications that work across all of its implementations, including but not limited to:<p><pre><code>    * Keyboard layout switching and input management
    * Display configuration
    * Clipboard management
    * Tools to manage windows&#x2F;automate tasks
    * Lots more
</code></pre>
It&#x27;s a damn ugly mess that has led to a lot of fragmentation with no obvious benefit. Currently, only KDE and Gnome have somewhat usable Wayland implementations. If you use anything else? You&#x27;re SoL.<p>1. <a href="https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;wayland&#x2F;wayland&#x2F;-&#x2F;issues&#x2F;233" rel="nofollow">https:&#x2F;&#x2F;gitlab.freedesktop.org&#x2F;wayland&#x2F;wayland&#x2F;-&#x2F;issues&#x2F;233</a></div><br/><div id="42835199" class="c"><input type="checkbox" id="c-42835199" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42833007">parent</a><span>|</span><a href="#42833556">next</a><span>|</span><label class="collapse" for="c-42835199">[-]</label><label class="expand" for="c-42835199">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s almost like you don&#x27;t want tearing when browsing the web and your documents, but games can take over the precise control of rendering.. because they are games that want to do so?<p>How is that bad design?</div><br/><div id="42835744" class="c"><input type="checkbox" id="c-42835744" checked=""/><div class="controls bullet"><span class="by">ndiddy</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42835199">parent</a><span>|</span><a href="#42833556">next</a><span>|</span><label class="collapse" for="c-42835744">[-]</label><label class="expand" for="c-42835744">[1 more]</label></div><br/><div class="children"><div class="content">The numbers presented in the article (~1 additional frame of latency on Wayland) are from someone using GNOME with the Mutter compositor. This means that neither the X11 or Wayland session has screen tearing. I imagine the X11 input latency numbers would go down by around half a frame on average if the author was using a different window manager without a compositor.</div><br/></div></div></div></div><div id="42833556" class="c"><input type="checkbox" id="c-42833556" checked=""/><div class="controls bullet"><span class="by">tuna74</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42833007">parent</a><span>|</span><a href="#42835199">prev</a><span>|</span><a href="#42836077">next</a><span>|</span><label class="collapse" for="c-42833556">[-]</label><label class="expand" for="c-42833556">[2 more]</label></div><br/><div class="children"><div class="content">Of the things you list, IMO, maybe the display configuration should be part of the Wayland protocol.<p>It might be a better technical design to have the other stuff outside of the display protocol. Just because Xorg implemented something does not mean you have to put it in the Wayland protocol.</div><br/><div id="42835068" class="c"><input type="checkbox" id="c-42835068" checked=""/><div class="controls bullet"><span class="by">eschaton</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42833556">parent</a><span>|</span><a href="#42836077">next</a><span>|</span><label class="collapse" for="c-42835068">[-]</label><label class="expand" for="c-42835068">[1 more]</label></div><br/><div class="children"><div class="content">Routing of input events to windows has turned out to also be extremely important for a display subsystem in practice. It wasn’t just X11 that did this, it was also the NeXT window server, and Sun’s NeWS, and SGI’s pre-X window system, and the original VAXstation window system on VMS, as well as how both modern macOS and modern iOS and iOS-derived platforms work.<p>In any of these cases there may be one or more daemons behind the scenes handling the “raw” input—possibly even in cooperation with kernel-level pre-processing code, to ensure low latencey—but most event delivery to applications is associated with windows, with options to get lower-level access if needed.<p>One of the things that helps many of the systems described above with latency is kernel participation, whether by pushing much of the preprocessing of events down to the drivers so there’s little for userspace to do, or by implementing kernel-level zero-copy IPC (e.g. use of Mach messages by NeXT and Apple).<p>If human interface IPC happens entirely in userspace and requires multiple context switches to get an event from device to a display change, you’ll wind up with hitches and delays unless there’s some sort of scheduler hinting that ensures each stage in the pipeline runs immediately after the last.<p>This is, of course, why there was a lot of desire by Wayland advocates for kernel dbus support, but they went at the problem backwards: “Let’s take DBus, and make it fast by putting it in-kernel,” *without* first trying to make it as fast as possible without kernel support, *and* without trying to figure out the minimal feature set for kernel-level IPC that would be needed to support it (which may not look like DBus).</div><br/></div></div></div></div><div id="42836077" class="c"><input type="checkbox" id="c-42836077" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42833007">parent</a><span>|</span><a href="#42833556">prev</a><span>|</span><a href="#42832253">next</a><span>|</span><label class="collapse" for="c-42836077">[-]</label><label class="expand" for="c-42836077">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It was designed to fix tearing issues, not latency issues.<p>Actually is was designed because the X11 codebase was bad and nobody wanted to work on it.</div><br/></div></div></div></div><div id="42832253" class="c"><input type="checkbox" id="c-42832253" checked=""/><div class="controls bullet"><span class="by">vander_elst</span><span>|</span><a href="#42832150">parent</a><span>|</span><a href="#42833007">prev</a><span>|</span><a href="#42832980">next</a><span>|</span><label class="collapse" for="c-42832253">[-]</label><label class="expand" for="c-42832253">[9 more]</label></div><br/><div class="children"><div class="content">Wayland is just a protocol that is probably implemented over and over and each implementation might have issues. It&#x27;s mostly likely the different implementations having issues.</div><br/><div id="42832399" class="c"><input type="checkbox" id="c-42832399" checked=""/><div class="controls bullet"><span class="by">hirako2000</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42832253">parent</a><span>|</span><a href="#42832980">next</a><span>|</span><label class="collapse" for="c-42832399">[-]</label><label class="expand" for="c-42832399">[8 more]</label></div><br/><div class="children"><div class="content">Was Wayland not architected to be simpler to implement than the (antique) X11 protocol?<p>Not arguing though, you are right it is just issues: Drivers, the Wayland implementations, how some plethora of apps and libraries have been battle tested then  optimized, years over years, for X11. Not as much for Wayland display yet.</div><br/><div id="42834484" class="c"><input type="checkbox" id="c-42834484" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42832399">parent</a><span>|</span><a href="#42832869">next</a><span>|</span><label class="collapse" for="c-42834484">[-]</label><label class="expand" for="c-42834484">[2 more]</label></div><br/><div class="children"><div class="content">Wayland is simpler because it does less. And among the things Wayland doesn&#x27;t do and X does are things that people need. It means these things have to be implemented elsewhere.<p>It is a common problem with these &quot;simple&quot; things. The problem is complex, and if you simplify one part, you are just pushing complexity elsewhere, you are not making it disappear. It is sometimes a good thing, but in the case of Wayland, it didn&#x27;t go well.</div><br/><div id="42834907" class="c"><input type="checkbox" id="c-42834907" checked=""/><div class="controls bullet"><span class="by">freehorse</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42834484">parent</a><span>|</span><a href="#42832869">next</a><span>|</span><label class="collapse" for="c-42834907">[-]</label><label class="expand" for="c-42834907">[1 more]</label></div><br/><div class="children"><div class="content">There is also the option to make complexity disappear by just convincing people that they should not want to do what they want to do. This was the kind of response to what I needed to do. Then I had to switch back to x11.<p>In any case wayland is not bad if you only have pretty basic needs I guess, some basic things look easier to me there from a user perspective, and troubleshooting x11-related issues for a non-technical person is no fun either.</div><br/></div></div></div></div><div id="42832869" class="c"><input type="checkbox" id="c-42832869" checked=""/><div class="controls bullet"><span class="by">mrweasel</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42832399">parent</a><span>|</span><a href="#42834484">prev</a><span>|</span><a href="#42832631">next</a><span>|</span><label class="collapse" for="c-42832869">[-]</label><label class="expand" for="c-42832869">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Was Wayland not architected to be simpler to implement than the (antique) X11 protocol?<p>I think it&#x27;s safe to assume that it is actually simpler, given that we already have multiple Wayland implementations, but still basically just the one X11 server implementation. Can one or more of those implementations shave off one or two milliseconds overs the next 40 years... Probably yes.</div><br/><div id="42833434" class="c"><input type="checkbox" id="c-42833434" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42832869">parent</a><span>|</span><a href="#42832631">next</a><span>|</span><label class="collapse" for="c-42833434">[-]</label><label class="expand" for="c-42833434">[2 more]</label></div><br/><div class="children"><div class="content">Sure, on linux all you really have is xorg, what used to be xfree86, but I have used xsgi, and there are X servers for windows, heck, I have even seen this amazing demo Xserver that ran on the web.<p>footnote: there is something wrong with the commonly used web search engines and I am unable to find that X11 web demo, I think they are prioritizing recent content over good content. you would think with how interesting that web demo was it was it would show up right away. but I got nothing, so no links. Anyway it was a deep dive into the intricacies of X11 window painting and the author had ported a limited subset of an X server to javascript in order to provide a live demonstration of the topic. I will keep looking.<p>Found it. <a href="https:&#x2F;&#x2F;magcius.github.io&#x2F;xplain&#x2F;article&#x2F;x-basics.html" rel="nofollow">https:&#x2F;&#x2F;magcius.github.io&#x2F;xplain&#x2F;article&#x2F;x-basics.html</a></div><br/><div id="42836843" class="c"><input type="checkbox" id="c-42836843" checked=""/><div class="controls bullet"><span class="by">hirako2000</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42833434">parent</a><span>|</span><a href="#42832631">next</a><span>|</span><label class="collapse" for="c-42836843">[-]</label><label class="expand" for="c-42836843">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s called a SEO driven content vs quality drive content. Unfortunately the engine has has poor sense of taste.</div><br/></div></div></div></div></div></div><div id="42832631" class="c"><input type="checkbox" id="c-42832631" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42832399">parent</a><span>|</span><a href="#42832869">prev</a><span>|</span><a href="#42835842">next</a><span>|</span><label class="collapse" for="c-42832631">[-]</label><label class="expand" for="c-42832631">[1 more]</label></div><br/><div class="children"><div class="content">Architecture contributes, but all it takes to blow input latency is some inefficient code almost anywhere in the input or rendering pipeline. The Apple IIe didn’t really have very many layers between the keyboard and the CRT. Wayland might have an optimal architecture in theory for latency — I don’t know — and latency could still be ruined by not fully optimizing the other components in the stack.</div><br/></div></div><div id="42835842" class="c"><input type="checkbox" id="c-42835842" checked=""/><div class="controls bullet"><span class="by">dsp_person</span><span>|</span><a href="#42832150">root</a><span>|</span><a href="#42832399">parent</a><span>|</span><a href="#42832631">prev</a><span>|</span><a href="#42832980">next</a><span>|</span><label class="collapse" for="c-42835842">[-]</label><label class="expand" for="c-42835842">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m impressed how wlroots compiles in under 3 seconds for me</div><br/></div></div></div></div></div></div><div id="42832980" class="c"><input type="checkbox" id="c-42832980" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#42832150">parent</a><span>|</span><a href="#42832253">prev</a><span>|</span><a href="#42833205">next</a><span>|</span><label class="collapse" for="c-42832980">[-]</label><label class="expand" for="c-42832980">[1 more]</label></div><br/><div class="children"><div class="content">Gnome was fixed a few years ago to remove significant latency it was adding.  May have been a factor if you used that as well, but it wasn&#x27;t wayland specific to my knowledge.</div><br/></div></div></div></div><div id="42833205" class="c"><input type="checkbox" id="c-42833205" checked=""/><div class="controls bullet"><span class="by">cakealert</span><span>|</span><a href="#42832150">prev</a><span>|</span><a href="#42836438">next</a><span>|</span><label class="collapse" for="c-42833205">[-]</label><label class="expand" for="c-42833205">[1 more]</label></div><br/><div class="children"><div class="content">Would have been nice to see if the issue is present on wlroots compositors, GNOME rolled their own.</div><br/></div></div><div id="42836438" class="c"><input type="checkbox" id="c-42836438" checked=""/><div class="controls bullet"><span class="by">a-dub</span><span>|</span><a href="#42833205">prev</a><span>|</span><a href="#42832091">next</a><span>|</span><label class="collapse" for="c-42836438">[-]</label><label class="expand" for="c-42836438">[1 more]</label></div><br/><div class="children"><div class="content">i run nvidia&#x2F;intel&#x2F;optimus&#x2F;wayland in optimus&#x2F;integrated mode on my laptop.  i have anecdotally noticed perceptually salient increased response times when:<p>1) dpi scaling is in use
2) external displays are used via usb-c&#x2F;displayport
3) the nvidia memory clock has been scaled down by power management<p>that said there have been fantastic improvements overall to both stability and response times since kde6 and nvidia-open have stabilized and i haven&#x27;t noticed any of it in a long time now. it really is pretty great these days.</div><br/></div></div><div id="42832091" class="c"><input type="checkbox" id="c-42832091" checked=""/><div class="controls bullet"><span class="by">sheepdestroyer</span><span>|</span><a href="#42836438">prev</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832091">[-]</label><label class="expand" for="c-42832091">[16 more]</label></div><br/><div class="children"><div class="content">It would be interesting to have numbers under gamescope instead, Gnome doesn&#x27;t care much about gamers &amp; power users that mesure latencies.</div><br/><div id="42832144" class="c"><input type="checkbox" id="c-42832144" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42832091">parent</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832144">[-]</label><label class="expand" for="c-42832144">[15 more]</label></div><br/><div class="children"><div class="content">Games don’t depend on a compositor for anything, they draw direct to the framebuffer.<p>Anything related to the compositor won’t affect the game, unless it’s in windowed mode, then there can be some strange interactions.</div><br/><div id="42832625" class="c"><input type="checkbox" id="c-42832625" checked=""/><div class="controls bullet"><span class="by">sheepdestroyer</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832144">parent</a><span>|</span><a href="#42832162">next</a><span>|</span><label class="collapse" for="c-42832625">[-]</label><label class="expand" for="c-42832625">[2 more]</label></div><br/><div class="children"><div class="content">Valve&#x27;s gamescope addresses something that you don&#x27;t seem to believe exist :<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;gamescope">https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;gamescope</a></div><br/><div id="42832652" class="c"><input type="checkbox" id="c-42832652" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832625">parent</a><span>|</span><a href="#42832162">next</a><span>|</span><label class="collapse" for="c-42832652">[-]</label><label class="expand" for="c-42832652">[1 more]</label></div><br/><div class="children"><div class="content">That will indeed help with Windowed mode</div><br/></div></div></div></div><div id="42832162" class="c"><input type="checkbox" id="c-42832162" checked=""/><div class="controls bullet"><span class="by">talldayo</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832144">parent</a><span>|</span><a href="#42832625">prev</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832162">[-]</label><label class="expand" for="c-42832162">[12 more]</label></div><br/><div class="children"><div class="content">Games don&#x27;t, but xWayland does.</div><br/><div id="42832217" class="c"><input type="checkbox" id="c-42832217" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832162">parent</a><span>|</span><a href="#42832183">prev</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832217">[-]</label><label class="expand" for="c-42832217">[10 more]</label></div><br/><div class="children"><div class="content">I thought we were talking about gamers, xWayland doesn’t affect gamers at all either.</div><br/><div id="42832331" class="c"><input type="checkbox" id="c-42832331" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832217">parent</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832331">[-]</label><label class="expand" for="c-42832331">[9 more]</label></div><br/><div class="children"><div class="content">What do you mean? Most games run on XWayland when you&#x27;re in a Wayland session, wouldn&#x27;t input latency caused by XWayland therefore affect gamers who use Wayland?</div><br/><div id="42832388" class="c"><input type="checkbox" id="c-42832388" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832331">parent</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832388">[-]</label><label class="expand" for="c-42832388">[8 more]</label></div><br/><div class="children"><div class="content">Games don’t run via X11, they write direct to the framebuffer using a framework like Vulkan.<p>In windowed mode they can be captured, then things get tricky, but in full screen they draw direct to the gpu, vulkan itself is completely headless.</div><br/><div id="42832894" class="c"><input type="checkbox" id="c-42832894" checked=""/><div class="controls bullet"><span class="by">sheepdestroyer</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832388">parent</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42832894">[-]</label><label class="expand" for="c-42832894">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s true on modern platforms where the compositor (Mutter in the case of Gnome) is always responsible for presenting the frame.<p>Gamescope&#x27;s direct scanout bypasses this.</div><br/><div id="42832939" class="c"><input type="checkbox" id="c-42832939" checked=""/><div class="controls bullet"><span class="by">dijit</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832894">parent</a><span>|</span><a href="#42835318">next</a><span>|</span><label class="collapse" for="c-42832939">[-]</label><label class="expand" for="c-42832939">[5 more]</label></div><br/><div class="children"><div class="content">I’ll look into it, but it used to be a choice in the game settings that bypassed the drawing display server entirely, and caused that full screen flicker you might recall when tabbing back to your desktop (and the switchover of rendering control, and subsequent huge performance loss of the running game).<p>I wasn’t aware that this changed, but you could be right. Its definitely the same on Windows as it always was, which is the platform I most developed games for.</div><br/><div id="42834061" class="c"><input type="checkbox" id="c-42834061" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832939">parent</a><span>|</span><a href="#42836687">next</a><span>|</span><label class="collapse" for="c-42834061">[-]</label><label class="expand" for="c-42834061">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Its definitely the same on Windows as it always was, which is the platform I most developed games for.<p>Not really. Most games use &quot;borderless windowed&quot; mode instead of fullscreen exclusive, and even FSE is not true exclusive mode anymore in most cases.<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;directx&#x2F;demystifying-full-screen-optimizations&#x2F;" rel="nofollow">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;directx&#x2F;demystifying-full-scr...</a><p>&gt; When using Fullscreen Optimizations, your game believes that it is running in Fullscreen Exclusive, but behind the scenes, Windows has the game running in borderless windowed mode. When a game is run in borderless windowed mode, the game does not have full control of the display– that overarching control is given back to the Desktop Window Manager (DWM).<p>see also <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;direct3ddxgi&#x2F;for-best-performance--use-dxgi-flip-model" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;direct3ddxgi...</a></div><br/><div id="42835457" class="c"><input type="checkbox" id="c-42835457" checked=""/><div class="controls bullet"><span class="by">ChocolateGod</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42834061">parent</a><span>|</span><a href="#42836687">next</a><span>|</span><label class="collapse" for="c-42835457">[-]</label><label class="expand" for="c-42835457">[1 more]</label></div><br/><div class="children"><div class="content">I think Windows now also supports hardware overlays, so games running in fullscreen Windows can skip the compositor, which reduces the latency in no longer allowing games to directly write to the FB.</div><br/></div></div></div></div><div id="42836687" class="c"><input type="checkbox" id="c-42836687" checked=""/><div class="controls bullet"><span class="by">hackernudes</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832939">parent</a><span>|</span><a href="#42834061">prev</a><span>|</span><a href="#42834378">next</a><span>|</span><label class="collapse" for="c-42836687">[-]</label><label class="expand" for="c-42836687">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t really work like that in Wayland.<p>If an application framebuffer is full screen and in a compatible pixel format the compositor can do &quot;direct scan out&quot; where the compositor sends the framebuffer directly to the crtc instead of compositing first. I know that wlroots supports that. I&#x27;m not sure how much performance it saves to be honest.<p>And I&#x27;ll second that most commercial games do go through XWayland, though it depends on what games you like!</div><br/></div></div><div id="42834378" class="c"><input type="checkbox" id="c-42834378" checked=""/><div class="controls bullet"><span class="by">BearOso</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832939">parent</a><span>|</span><a href="#42836687">prev</a><span>|</span><a href="#42835318">next</a><span>|</span><label class="collapse" for="c-42834378">[-]</label><label class="expand" for="c-42834378">[1 more]</label></div><br/><div class="children"><div class="content">Most compositors can do direct scanout when they detect a full screen surface. (This is broken right now with Gnome on X11 because of the way window frames are drawn: <a href="https:&#x2F;&#x2F;gitlab.gnome.org&#x2F;GNOME&#x2F;mutter&#x2F;-&#x2F;issues&#x2F;2794" rel="nofollow">https:&#x2F;&#x2F;gitlab.gnome.org&#x2F;GNOME&#x2F;mutter&#x2F;-&#x2F;issues&#x2F;2794</a> ) If the game uses the platform cursor then that will reflect the additional latency, but the actual input signals won&#x27;t be delayed.</div><br/></div></div></div></div><div id="42835318" class="c"><input type="checkbox" id="c-42835318" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42832091">root</a><span>|</span><a href="#42832894">parent</a><span>|</span><a href="#42832939">prev</a><span>|</span><a href="#42838773">next</a><span>|</span><label class="collapse" for="c-42835318">[-]</label><label class="expand" for="c-42835318">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;wayland.app&#x2F;protocols&#x2F;fullscreen-shell-unstable-v1" rel="nofollow">https:&#x2F;&#x2F;wayland.app&#x2F;protocols&#x2F;fullscreen-shell-unstable-v1</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42838773" class="c"><input type="checkbox" id="c-42838773" checked=""/><div class="controls bullet"><span class="by">BitPirate</span><span>|</span><a href="#42832091">prev</a><span>|</span><a href="#42833297">next</a><span>|</span><label class="collapse" for="c-42838773">[-]</label><label class="expand" for="c-42838773">[1 more]</label></div><br/><div class="children"><div class="content">Asahi Linas explanation:<p><a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;oxtwre&#x2F;hard_numbers_wayland_vs_x11_input_latency#c_edq7tn" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;oxtwre&#x2F;hard_numbers_wayland_vs_x11_input...</a></div><br/></div></div><div id="42833297" class="c"><input type="checkbox" id="c-42833297" checked=""/><div class="controls bullet"><span class="by">goodburb</span><span>|</span><a href="#42838773">prev</a><span>|</span><a href="#42834500">next</a><span>|</span><label class="collapse" for="c-42833297">[-]</label><label class="expand" for="c-42833297">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s much worse with Nvidia 30+ series on Wayland, feels worse than a Bluetooth mouse, using Nouveau eliminates lag for the most part.</div><br/></div></div><div id="42834500" class="c"><input type="checkbox" id="c-42834500" checked=""/><div class="controls bullet"><span class="by">colonial</span><span>|</span><a href="#42833297">prev</a><span>|</span><a href="#42838199">next</a><span>|</span><label class="collapse" for="c-42834500">[-]</label><label class="expand" for="c-42834500">[1 more]</label></div><br/><div class="children"><div class="content">Funny, I didn&#x27;t even know this was a debate. I didn&#x27;t even notice when Fedora switched from X to Wayland by default - maybe because I&#x27;m still a 60hz plebian?<p>I <i>have</i> experienced issues with my mouse input locking up&#x2F;jumping - especially noticeable when I&#x27;m playing a shooter - but I&#x27;m pretty sure that&#x27;s just my poor ancient mouse giving out.</div><br/></div></div><div id="42838199" class="c"><input type="checkbox" id="c-42838199" checked=""/><div class="controls bullet"><span class="by">Grieverheart</span><span>|</span><a href="#42834500">prev</a><span>|</span><a href="#42832931">next</a><span>|</span><label class="collapse" for="c-42838199">[-]</label><label class="expand" for="c-42838199">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t 3 frames of latency already way too much? I would say they are both too slow!</div><br/></div></div><div id="42832931" class="c"><input type="checkbox" id="c-42832931" checked=""/><div class="controls bullet"><span class="by">ray023</span><span>|</span><a href="#42838199">prev</a><span>|</span><a href="#42836219">next</a><span>|</span><label class="collapse" for="c-42832931">[-]</label><label class="expand" for="c-42832931">[5 more]</label></div><br/><div class="children"><div class="content">I also have no ideas how it works, but my guess would be that is actually translates exactly like that into games. Why would the mouse on the desktop have a latency that games do not have. Linux does not have a real fullscreen mode like Windows has (that I do not use anymore anyway for faster alt-tabbing). So my guess is, the cursor or mouse input gets into games very much the same way as it gets in the desktop.</div><br/><div id="42833324" class="c"><input type="checkbox" id="c-42833324" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42832931">parent</a><span>|</span><a href="#42833078">next</a><span>|</span><label class="collapse" for="c-42833324">[-]</label><label class="expand" for="c-42833324">[3 more]</label></div><br/><div class="children"><div class="content">Wayland has support for games completely taking over the GPU; notoriously critical for VR support. This is basically the same as Windows exclusive full screen.<p>Wine&#x2F;proton would need to support it, XWayland would need to support it (Wine&#x2F;Proton are one major step away from native Wayland support: Vulkan), and finally the compositor would need to support it. Gnome is about the worst compositor that you could be testing any of this stuff on, they are comically hostile towards ideas not their own. The chances of this ever working on Gnome are near zero. KDE is pretty good for support, Hyprland seems to be trying to support every under the sun.</div><br/><div id="42835576" class="c"><input type="checkbox" id="c-42835576" checked=""/><div class="controls bullet"><span class="by">NekkoDroid</span><span>|</span><a href="#42832931">root</a><span>|</span><a href="#42833324">parent</a><span>|</span><a href="#42834930">next</a><span>|</span><label class="collapse" for="c-42835576">[-]</label><label class="expand" for="c-42835576">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Gnome is about the worst compositor that you could be testing any of this stuff on, they are comically hostile towards ideas not their own. The chances of this ever working on Gnome are near zero.<p>GNOME has supported direct scanout for fullscreen apps for a while and drm-lease was implemented not too long ago either.</div><br/></div></div><div id="42834930" class="c"><input type="checkbox" id="c-42834930" checked=""/><div class="controls bullet"><span class="by">debugnik</span><span>|</span><a href="#42832931">root</a><span>|</span><a href="#42833324">parent</a><span>|</span><a href="#42835576">prev</a><span>|</span><a href="#42833078">next</a><span>|</span><label class="collapse" for="c-42834930">[-]</label><label class="expand" for="c-42834930">[1 more]</label></div><br/><div class="children"><div class="content">&gt; notoriously critical for VR support. This is basically the same as Windows exclusive full screen.<p>D3D12 dropped support for exclusive fullscreen, and I don&#x27;t think headsets even go through DXGI but their own swap chain APIs. Why do VR games on Linux need the equivalent from the Wayland compositor?</div><br/></div></div></div></div><div id="42833078" class="c"><input type="checkbox" id="c-42833078" checked=""/><div class="controls bullet"><span class="by">gsich</span><span>|</span><a href="#42832931">parent</a><span>|</span><a href="#42833324">prev</a><span>|</span><a href="#42836219">next</a><span>|</span><label class="collapse" for="c-42833078">[-]</label><label class="expand" for="c-42833078">[1 more]</label></div><br/><div class="children"><div class="content">Hardware cursor might be used in games. You notice the difference on Windows if a GPU does not support it, even on the desktop.</div><br/></div></div></div></div><div id="42836219" class="c"><input type="checkbox" id="c-42836219" checked=""/><div class="controls bullet"><span class="by">FrostKiwi</span><span>|</span><a href="#42832931">prev</a><span>|</span><a href="#42835453">next</a><span>|</span><label class="collapse" for="c-42836219">[-]</label><label class="expand" for="c-42836219">[1 more]</label></div><br/><div class="children"><div class="content">Somebody should point LDAT at that [1] or the custom setup with LED triggered by the mouseclick + a high FPS camera that Battlenonsense used [2] before LDAT released.<p>[1] <a href="https:&#x2F;&#x2F;developer.nvidia.com&#x2F;nvidia-latency-display-analysis-tool" rel="nofollow">https:&#x2F;&#x2F;developer.nvidia.com&#x2F;nvidia-latency-display-analysis...</a><p>[2] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_MaeJbd1xaM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_MaeJbd1xaM</a></div><br/></div></div><div id="42835453" class="c"><input type="checkbox" id="c-42835453" checked=""/><div class="controls bullet"><span class="by">okr</span><span>|</span><a href="#42836219">prev</a><span>|</span><a href="#42833138">next</a><span>|</span><label class="collapse" for="c-42835453">[-]</label><label class="expand" for="c-42835453">[3 more]</label></div><br/><div class="children"><div class="content">Hm. I am currently using Ubuntu 24.10 and it also has Wayland and gnome as a default, with the nvidia 565 driver. And it is really, really bad. For example, i use chrome and the tabs, man, it takes ages to switch from one tab to another and to get focus in the location bar again.<p>So much for the whining. I do not know what to do. I could record this behaviour, but it somehow needs to show the timestamp of when i intend a behaviour and the time, that behaviour becomes actualized.<p>I used to be quick with all the hotkeys but i do make so many mistakes now, because the system is simply not responsive and all my instincts await instant action.</div><br/><div id="42835478" class="c"><input type="checkbox" id="c-42835478" checked=""/><div class="controls bullet"><span class="by">hinoki</span><span>|</span><a href="#42835453">parent</a><span>|</span><a href="#42833138">next</a><span>|</span><label class="collapse" for="c-42835478">[-]</label><label class="expand" for="c-42835478">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;ui.perfetto.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ui.perfetto.dev&#x2F;</a><p>Won’t get you end to end latency, but should be able to trace the input events through chrome, and show the context swaps of all the Wayland&#x2F;dbus stuff.<p>EDIT: looks like Linux system tracking is more work, but possible <a href="https:&#x2F;&#x2F;perfetto.dev&#x2F;docs&#x2F;quickstart&#x2F;linux-tracing" rel="nofollow">https:&#x2F;&#x2F;perfetto.dev&#x2F;docs&#x2F;quickstart&#x2F;linux-tracing</a></div><br/><div id="42835518" class="c"><input type="checkbox" id="c-42835518" checked=""/><div class="controls bullet"><span class="by">okr</span><span>|</span><a href="#42835453">root</a><span>|</span><a href="#42835478">parent</a><span>|</span><a href="#42833138">next</a><span>|</span><label class="collapse" for="c-42835518">[-]</label><label class="expand" for="c-42835518">[1 more]</label></div><br/><div class="children"><div class="content">Thank you!</div><br/></div></div></div></div></div></div><div id="42833138" class="c"><input type="checkbox" id="c-42833138" checked=""/><div class="controls bullet"><span class="by">haunter</span><span>|</span><a href="#42835453">prev</a><span>|</span><a href="#42831986">next</a><span>|</span><label class="collapse" for="c-42833138">[-]</label><label class="expand" for="c-42833138">[1 more]</label></div><br/><div class="children"><div class="content">Does the Nvidia FrameView app works under Linux (or more like under X11 and Wayland)? You can measure general system latency with that <a href="https:&#x2F;&#x2F;www.nvidia.com&#x2F;en-us&#x2F;geforce&#x2F;technologies&#x2F;frameview&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.nvidia.com&#x2F;en-us&#x2F;geforce&#x2F;technologies&#x2F;frameview&#x2F;</a></div><br/></div></div><div id="42831986" class="c"><input type="checkbox" id="c-42831986" checked=""/><div class="controls bullet"><span class="by">bigbones</span><span>|</span><a href="#42833138">prev</a><span>|</span><a href="#42831866">next</a><span>|</span><label class="collapse" for="c-42831986">[-]</label><label class="expand" for="c-42831986">[1 more]</label></div><br/><div class="children"><div class="content">would love to see this test repeated with a non-compositing WM on X11</div><br/></div></div><div id="42831866" class="c"><input type="checkbox" id="c-42831866" checked=""/><div class="controls bullet"><span class="by">henry700</span><span>|</span><a href="#42831986">prev</a><span>|</span><label class="collapse" for="c-42831866">[-]</label><label class="expand" for="c-42831866">[25 more]</label></div><br/><div class="children"><div class="content">Has implications for competitive FPS gaming on modern Linux — one more problem to fix. For example &quot;The Finals&quot; allows Linux players, but imagine having this much input delay and having to revert to classic x11 to play games, lol.</div><br/><div id="42831926" class="c"><input type="checkbox" id="c-42831926" checked=""/><div class="controls bullet"><span class="by">riskable</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42832492">next</a><span>|</span><label class="collapse" for="c-42831926">[-]</label><label class="expand" for="c-42831926">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s actually just cursor latency <i>specific to the windowed environment you&#x27;re running</i>. From what I&#x27;ve experienced (with a 4060 Ti) it doesn&#x27;t seem to impact FPS games at all.<p>I haven&#x27;t tried any games that use a cursor with Wayland yet so I don&#x27;t know if it would have an impact there.<p>I think it has to do with whether or not the game in question is reading the mouse device directly (e.g. through SSL) or via the compositor. If it&#x27;s reading the device directly it stands to reason that there would be less latency.</div><br/></div></div><div id="42832492" class="c"><input type="checkbox" id="c-42832492" checked=""/><div class="controls bullet"><span class="by">janice1999</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42831926">prev</a><span>|</span><a href="#42832653">next</a><span>|</span><label class="collapse" for="c-42832492">[-]</label><label class="expand" for="c-42832492">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Has implications for competitive FPS gaming<p>That has not been proven in the article. Input handling follows different paths for full screen games.</div><br/></div></div><div id="42832653" class="c"><input type="checkbox" id="c-42832653" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42832492">prev</a><span>|</span><a href="#42831998">next</a><span>|</span><label class="collapse" for="c-42832653">[-]</label><label class="expand" for="c-42832653">[2 more]</label></div><br/><div class="children"><div class="content">&gt; having to revert to classic x11 to play games, lol.<p>It would be more of a problem the other way around, if we had to resort to Wayland to get low latency. I think most of us using Linux for gaming and casual stuff are happy to stick to X11 for now and the foreseeable future. It has good support in software, its failure modes are well-documented, and it doesn&#x27;t add one more layer to the pile of complexity that desktop linux already is; at least, not one us users have to consciously keep in mind as a common source of issues.</div><br/><div id="42835373" class="c"><input type="checkbox" id="c-42835373" checked=""/><div class="controls bullet"><span class="by">gf000</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42832653">parent</a><span>|</span><a href="#42831998">next</a><span>|</span><label class="collapse" for="c-42835373">[-]</label><label class="expand" for="c-42835373">[1 more]</label></div><br/><div class="children"><div class="content">If anything, Wayland removes a layer. Replaces the insanely huge monolith with binary blobs with bog-standard Linux kernel APIs.</div><br/></div></div></div></div><div id="42831998" class="c"><input type="checkbox" id="c-42831998" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42832653">prev</a><span>|</span><a href="#42835044">next</a><span>|</span><label class="collapse" for="c-42831998">[-]</label><label class="expand" for="c-42831998">[1 more]</label></div><br/><div class="children"><div class="content">As I type this, I&#x27;m playing &quot;the finals&quot; on Linux via Proton on Wayland.  I won&#x27;t pretend I&#x27;m any kind of competitive gamer type, but it&#x27;s perfectly fine and I don&#x27;t feel like I&#x27;m being held back by input lag.  So this is very much a niche issue to have.</div><br/></div></div><div id="42835044" class="c"><input type="checkbox" id="c-42835044" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42831998">prev</a><span>|</span><a href="#42835482">next</a><span>|</span><label class="collapse" for="c-42835044">[-]</label><label class="expand" for="c-42835044">[1 more]</label></div><br/><div class="children"><div class="content">On CS2 Wayland gave a major performance boost, but it&#x27;s being held back by a regression since a change in device input layer.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;csgo-osx-linux&#x2F;issues&#x2F;3856">https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;csgo-osx-linux&#x2F;issues&#x2F;3856</a><p>From outside it&#x27;s hard to tell if it&#x27;s truly protocol differences or just the age of the implementations on X11, but when Wayland came out every project has claimed improvements over the old X11 stack. Also, from the early Wayland days presentations bashed the protocol as something that couldn&#x27;t be fixed without a rework that was not going to happen due to the dead weight of backwards compatibility and awful older hardware.<p>As a user applications running on Wayland have consistently improved on how nice things feel if you don&#x27;t miss your latency deadlines. It&#x27;s easy to perceive on apps, and straight out obvious in games.</div><br/></div></div><div id="42835482" class="c"><input type="checkbox" id="c-42835482" checked=""/><div class="controls bullet"><span class="by">Novosell</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42835044">prev</a><span>|</span><a href="#42832037">next</a><span>|</span><label class="collapse" for="c-42835482">[-]</label><label class="expand" for="c-42835482">[1 more]</label></div><br/><div class="children"><div class="content">I got to diamond in Apex Legends on Linux using Wayland on KDE Plasma. Didn&#x27;t feel any noticeable difference between wayland, x and windows in my Apex playing.</div><br/></div></div><div id="42832037" class="c"><input type="checkbox" id="c-42832037" checked=""/><div class="controls bullet"><span class="by">talldayo</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42835482">prev</a><span>|</span><a href="#42831972">next</a><span>|</span><label class="collapse" for="c-42832037">[-]</label><label class="expand" for="c-42832037">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Competitive FPS gaming&quot; stops allowing anything besides fresh Windows installs after a certain point. It&#x27;s a diminutive distinction, like pointing out that emulating GameCube games won&#x27;t let Smash Melee players fight competitively; nobody playing on either side actually cares.</div><br/></div></div><div id="42831972" class="c"><input type="checkbox" id="c-42831972" checked=""/><div class="controls bullet"><span class="by">rez9x</span><span>|</span><a href="#42831866">parent</a><span>|</span><a href="#42832037">prev</a><span>|</span><label class="collapse" for="c-42831972">[-]</label><label class="expand" for="c-42831972">[16 more]</label></div><br/><div class="children"><div class="content">I have trouble believing that 6.5ms in increased latency would be perceptible to any more than a fraction of a percent of the most elite gamers. Most the people claiming that this level of difference is impacting their gameplay are victims of confirmation bias.</div><br/><div id="42832862" class="c"><input type="checkbox" id="c-42832862" checked=""/><div class="controls bullet"><span class="by">tolciho</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42832155">next</a><span>|</span><label class="collapse" for="c-42832862">[-]</label><label class="expand" for="c-42832862">[1 more]</label></div><br/><div class="children"><div class="content">David Eagleman has done some work with drummers. Granted the audio system might be a bit more accurate than the visual, or maybe drummers are just weird. On the other hand, vim taking 30 milliseconds to start (ugh) and having sluggish cursor motions is why I&#x27;m on vi now. Haven&#x27;t tried Wayland. Maybe in some number of years once it&#x27;s more portable and more developed? (And how many years has it already been out?)<p>&gt; “I was working with Larry Mullen, Jr., on one of the U2 albums,” Eno told me. “ ‘All That You Don’t Leave Behind,’ or whatever it’s called.” Mullen was playing drums over a recording of the band and a click track—a computer-generated beat that was meant to keep all the overdubbed parts in synch. In this case, however, Mullen thought that the click track was slightly off: it was a fraction of a beat behind the rest of the band. “I said, ‘No, that can’t be so, Larry,’ ” Eno recalled. “ ‘We’ve all worked to that track, so it must be right.’ But he said, ‘Sorry, I just can’t play to it.’ ”<p>&gt; Eno eventually adjusted the click to Mullen’s satisfaction, but he was just humoring him. It was only later, after the drummer had left, that Eno checked the original track again and realized that Mullen was right: the click was off by six milliseconds. “The thing is,” Eno told me, “when we were adjusting it I once had it two milliseconds to the wrong side of the beat, and he said, ‘No, you’ve got to come back a bit.’ Which I think is absolutely staggering.”</div><br/></div></div><div id="42832155" class="c"><input type="checkbox" id="c-42832155" checked=""/><div class="controls bullet"><span class="by">Strilanc</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42832862">prev</a><span>|</span><a href="#42832095">next</a><span>|</span><label class="collapse" for="c-42832155">[-]</label><label class="expand" for="c-42832155">[4 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t need to be perceptible to cause a difference in a game.<p>Suppose two players notice each other at the same time (e.g. as would naturally happen when walking around a corner in a shooter), first to shoot wins, and their total latencies are identical Gaussians with a standard deviation of 100ms. Then a 6.5ms reduction in latency is worth an additional 2.5% chance of winning the trade. Maybe you won&#x27;t notice this on a moment by moment basis, but take statistics and its impact should be measurable.<p>In ELO terms a 2.5% gain in win rate is around a 10 point increase (simplifying by assuming that single Gaussian is the entire game). That&#x27;s small, but if you were a hardcore player and all it took to raise your ELO by 10 points was using a better monitor&#x2F;mouse&#x2F;OS... why not? Doing that is cheap compared to the time investment required to improve your ELO another 10 points with practice (unless you&#x27;re just starting).<p>Also, I think you&#x27;d be surprised what people can perceive in a context where they are practiced. Speed runners hit frame perfect tricks in 60FPS games. That&#x27;s not <i>reaction time</i> but it does intimately involve consistent control latency between practice and execution.</div><br/><div id="42832984" class="c"><input type="checkbox" id="c-42832984" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42832155">parent</a><span>|</span><a href="#42833233">next</a><span>|</span><label class="collapse" for="c-42832984">[-]</label><label class="expand" for="c-42832984">[2 more]</label></div><br/><div class="children"><div class="content">Slightly off topic…<p>&gt; Suppose two players notice each other at the same time (e.g. as would naturally happen when walking around a corner in a shooter)<p>This is not true for third person games. Depending on a left sided or right sided peek and your angle or approach, players see asymmetrically.<p>For example, Fortnite is a right side peek game. Peeking right is safer than peeking left as less of your body is exposed before your camera turns the corner.<p>I believe distance also plays a part in the angles.</div><br/><div id="42833239" class="c"><input type="checkbox" id="c-42833239" checked=""/><div class="controls bullet"><span class="by">Strilanc</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42832984">parent</a><span>|</span><a href="#42833233">next</a><span>|</span><label class="collapse" for="c-42833239">[-]</label><label class="expand" for="c-42833239">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, network latency and client side prediction and accuracy will also play huge roles. The actual distributions will be very complex, but in general reacting faster is going to be better.</div><br/></div></div></div></div><div id="42833233" class="c"><input type="checkbox" id="c-42833233" checked=""/><div class="controls bullet"><span class="by">wink</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42832155">parent</a><span>|</span><a href="#42832984">prev</a><span>|</span><a href="#42832095">next</a><span>|</span><label class="collapse" for="c-42833233">[-]</label><label class="expand" for="c-42833233">[1 more]</label></div><br/><div class="children"><div class="content">Do people not play deathmatches on LAN parties anymore these days? 2.5 is huge if the game lasts long enough that someone would be leading with 200. ;)</div><br/></div></div></div></div><div id="42832095" class="c"><input type="checkbox" id="c-42832095" checked=""/><div class="controls bullet"><span class="by">sapiogram</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42832155">prev</a><span>|</span><a href="#42833650">next</a><span>|</span><label class="collapse" for="c-42832095">[-]</label><label class="expand" for="c-42832095">[1 more]</label></div><br/><div class="children"><div class="content">I would postulate that 100% of professional (i.e. elite) competitive gamers would be able to tell the difference. See this old touchscreen demonstration: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vOvQCPLkPt4" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vOvQCPLkPt4</a></div><br/></div></div><div id="42833650" class="c"><input type="checkbox" id="c-42833650" checked=""/><div class="controls bullet"><span class="by">AnthonBerg</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42832095">prev</a><span>|</span><a href="#42832505">next</a><span>|</span><label class="collapse" for="c-42833650">[-]</label><label class="expand" for="c-42833650">[1 more]</label></div><br/><div class="children"><div class="content">Those sorts of latencies actually are noticeable! As an example, 6.5ms latency between a virtual instrument and its UI is <i>definitely</i> noticeable.<p>I didn’t think it was. But it is. I promise!<p>It’s not necessarily a reaction-time game-winning thing. It’s a feel.<p>With virtual instruments, my experience is that when you get down to ~3ms you don’t notice the latency anymore… but!, when you go below 3ms, it starts feeling more physically <i>real</i>.</div><br/></div></div><div id="42832505" class="c"><input type="checkbox" id="c-42832505" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42833650">prev</a><span>|</span><a href="#42832088">next</a><span>|</span><label class="collapse" for="c-42832505">[-]</label><label class="expand" for="c-42832505">[6 more]</label></div><br/><div class="children"><div class="content">About the difference between 60hz and 120hz monitor, instantly noticeable just by moving the mouse in windows (just by looking 
at the distance cursor updates as it moves). Would you argue that all gaming monitors are placebo?</div><br/><div id="42832875" class="c"><input type="checkbox" id="c-42832875" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42832505">parent</a><span>|</span><a href="#42833134">next</a><span>|</span><label class="collapse" for="c-42832875">[-]</label><label class="expand" for="c-42832875">[1 more]</label></div><br/><div class="children"><div class="content">Just to nitpick, that difference is still above 6.5 ms.</div><br/></div></div><div id="42833134" class="c"><input type="checkbox" id="c-42833134" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42832505">parent</a><span>|</span><a href="#42832875">prev</a><span>|</span><a href="#42832088">next</a><span>|</span><label class="collapse" for="c-42833134">[-]</label><label class="expand" for="c-42833134">[4 more]</label></div><br/><div class="children"><div class="content">I actually would. Gaming monitors are the equivalent of fancy audiophile gear. It&#x27;s a way to fleece people by making them think they can perceive a difference that isn&#x27;t really there.</div><br/><div id="42833407" class="c"><input type="checkbox" id="c-42833407" checked=""/><div class="controls bullet"><span class="by">sapiogram</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42833134">parent</a><span>|</span><a href="#42833599">next</a><span>|</span><label class="collapse" for="c-42833407">[-]</label><label class="expand" for="c-42833407">[1 more]</label></div><br/><div class="children"><div class="content">But the difference between 60hz and 120hz is <i>instantly</i> noticeable in a blind test, without even opening a game. That&#x27;s by definition not placebo.</div><br/></div></div><div id="42833599" class="c"><input type="checkbox" id="c-42833599" checked=""/><div class="controls bullet"><span class="by">tuna74</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42833134">parent</a><span>|</span><a href="#42833407">prev</a><span>|</span><a href="#42833671">next</a><span>|</span><label class="collapse" for="c-42833599">[-]</label><label class="expand" for="c-42833599">[1 more]</label></div><br/><div class="children"><div class="content">There have been actual tests showing players have better accuracy up to 360 fps displays.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=OX31kZbAXsA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=OX31kZbAXsA</a></div><br/></div></div><div id="42833671" class="c"><input type="checkbox" id="c-42833671" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42833134">parent</a><span>|</span><a href="#42833599">prev</a><span>|</span><a href="#42832088">next</a><span>|</span><label class="collapse" for="c-42833671">[-]</label><label class="expand" for="c-42833671">[1 more]</label></div><br/><div class="children"><div class="content">Guess you think all speakers are the same.</div><br/></div></div></div></div></div></div><div id="42832088" class="c"><input type="checkbox" id="c-42832088" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42832505">prev</a><span>|</span><a href="#42832493">next</a><span>|</span><label class="collapse" for="c-42832088">[-]</label><label class="expand" for="c-42832088">[1 more]</label></div><br/><div class="children"><div class="content">You may think 6.5 ms of input latency is imperceptible. But combine it with the rest of the stack (monitor refresh rate, local network latency, RTT between client and server, time for server to register input from client and calculate “winner”), and it becomes the diff between an L and W. In the case of pros, the diff between a multimillion dollar cash prize and nil.</div><br/></div></div><div id="42832493" class="c"><input type="checkbox" id="c-42832493" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#42831866">root</a><span>|</span><a href="#42831972">parent</a><span>|</span><a href="#42832088">prev</a><span>|</span><label class="collapse" for="c-42832493">[-]</label><label class="expand" for="c-42832493">[1 more]</label></div><br/><div class="children"><div class="content">There are noticability thresholds where this could push it over. For fighting games if you have the reactions to whiff punish N frame recovery moves this may push you to only being able to punish N+1 recovery moves and really impact your ranking.  This is a little over 1&#x2F;3rd of a 60hz frame.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>