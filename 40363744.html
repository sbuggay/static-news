<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715763670889" as="style"/><link rel="stylesheet" href="styles.css?v=1715763670889"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://formal.land/blog/2024/04/26/translation-core-alloc-crates">Translation of the Rust&#x27;s core and alloc crates to Coq for formal verification</a> <span class="domain">(<a href="https://formal.land">formal.land</a>)</span></div><div class="subtext"><span>p4bl0</span> | <span>41 comments</span></div><br/><div><div id="40364105" class="c"><input type="checkbox" id="c-40364105" checked=""/><div class="controls bullet"><span class="by">thaliaarchi</span><span>|</span><a href="#40364599">next</a><span>|</span><label class="collapse" for="c-40364105">[-]</label><label class="expand" for="c-40364105">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s really impressive.<p>Automatic translation like this shifts the trust to the tool. coq-of-rust itself is written in Rust, not in Coq. The recursive nature is somewhat boggling, but I think a proof of its correctness is possible in a similar process to David A. Wheeler&#x27;s “Countering Trusting Trust through Diverse Double-Compiling” (2009) [0] (which circumvents Ken Thompson&#x27;s Trusting Trusting attack by using a second compiler), but with a mix of a CompCert approach.<p>To verify it, you&#x27;d use coq-of-rust to convert the coq-of-rust translator from Rust to Coq. That translation is not trusted, because it was performed in Rust, but it doesn&#x27;t matter. Once in Coq, you prove the desired correctness properties—crucially, that it preserves the semantics of the Rust program when it translates a program to Coq.<p>As in the article, it is likely easier to work with more functional definitions in proofs instead of generated ones, so you&#x27;d undertake the same process as they do with the stdlib of proving equivalence between definitions. Since the current line count for the coq-of-rust translator (specifically, lib&#x2F; [1]) is 6350 lines of Rust, it even seems feasible to write a full translator in Coq and prove its equivalence to the generated one.<p>Then, you execute the proven-correct Coq coq-of-rust translator on the Rust source of the coq-of-rust translator. The Coq definitions it outputs should match the output of the Rust coq-of-rust translator that you started with.<p>As an aside, it&#x27;s nice to see industry funding for work like this. I&#x27;m often cynical of cryptocurrency, but its correctness constraints really push for improvements in areas I like (Rust, Coq, funding for masters students I know, etc.).<p>[0]: <a href="https:&#x2F;&#x2F;dwheeler.com&#x2F;trusting-trust&#x2F;wheelerd-trust.pdf" rel="nofollow">https:&#x2F;&#x2F;dwheeler.com&#x2F;trusting-trust&#x2F;wheelerd-trust.pdf</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;formal-land&#x2F;coq-of-rust&#x2F;tree&#x2F;main&#x2F;lib">https:&#x2F;&#x2F;github.com&#x2F;formal-land&#x2F;coq-of-rust&#x2F;tree&#x2F;main&#x2F;lib</a></div><br/><div id="40364215" class="c"><input type="checkbox" id="c-40364215" checked=""/><div class="controls bullet"><span class="by">clarus</span><span>|</span><a href="#40364105">parent</a><span>|</span><a href="#40364352">next</a><span>|</span><label class="collapse" for="c-40364215">[-]</label><label class="expand" for="c-40364215">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the comment! One of the authors here.<p>Indeed this would be a nice process to verify coq-of-rust. Also, although the code is rather short, we depend on the Rust compiler to parse and type-check the input Rust code. So that would need to be also verified, or at least formally specified without doing the proofs, and the API of rustc is rather large and unstable. It could still be a way to get more insurance.</div><br/><div id="40364516" class="c"><input type="checkbox" id="c-40364516" checked=""/><div class="controls bullet"><span class="by">thaliaarchi</span><span>|</span><a href="#40364105">root</a><span>|</span><a href="#40364215">parent</a><span>|</span><a href="#40364506">next</a><span>|</span><label class="collapse" for="c-40364516">[-]</label><label class="expand" for="c-40364516">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t touch on that, but I did assume trust of the Rust toolchain, verifying starting at THIR. Verifying rustc would be a monumental undertaking, though I think some people are working on it.<p>Since we don&#x27;t have a verified rustc (a la CompCert [0]), I wonder if an approach like the translation validation of seL4 [1] would work. They prove that the artifact (ARM machine code) produced by an existing compiler (gcc) for a chosen program (seL4) matches the source semantics (C). Thus you could circumvent trusting rustc, but it only works to verify a specific output of a chosen program. If the chosen program was coq-of-rust, I don&#x27;t think this would be easier than the approach I detailed above. The seL4 kernel is 9,500 lines of C, while their Isabel&#x2F;HOL specification is over 200,000 lines, so the technique doesn&#x27;t seem to scale to a large chosen source like rustc.<p>Isn&#x27;t bootstrapping fun?<p>[0]: Xavier Leroy. 2008. “Formal verification of a realistic compiler”. <a href="https:&#x2F;&#x2F;xavierleroy.org&#x2F;publi&#x2F;compcert-CACM.pdf" rel="nofollow">https:&#x2F;&#x2F;xavierleroy.org&#x2F;publi&#x2F;compcert-CACM.pdf</a><p>[1]: Thomas Sewell, Magnus Myreen, and Gerwin Klein. PLDI 2013. “Translation Validation for a Verified OS Kernel”. <a href="https:&#x2F;&#x2F;sci-hub.st&#x2F;10.1145&#x2F;2491956.2462183" rel="nofollow">https:&#x2F;&#x2F;sci-hub.st&#x2F;10.1145&#x2F;2491956.2462183</a></div><br/></div></div><div id="40364506" class="c"><input type="checkbox" id="c-40364506" checked=""/><div class="controls bullet"><span class="by">deredede</span><span>|</span><a href="#40364105">root</a><span>|</span><a href="#40364215">parent</a><span>|</span><a href="#40364516">prev</a><span>|</span><a href="#40364352">next</a><span>|</span><label class="collapse" for="c-40364506">[-]</label><label class="expand" for="c-40364506">[1 more]</label></div><br/><div class="children"><div class="content">Is there a Coq formalisation for enough of Rust that would be usable here? I thought people were still figuring that out.</div><br/></div></div></div></div><div id="40364352" class="c"><input type="checkbox" id="c-40364352" checked=""/><div class="controls bullet"><span class="by">noneeeed</span><span>|</span><a href="#40364105">parent</a><span>|</span><a href="#40364215">prev</a><span>|</span><a href="#40364599">next</a><span>|</span><label class="collapse" for="c-40364352">[-]</label><label class="expand" for="c-40364352">[1 more]</label></div><br/><div class="children"><div class="content">It reminds me of when I used to work in SPARK Ada. On a number of projects where there was no supported Ada target (especially very small devices), it would be converted to C and then compiled for the target. That allowed us to perform the various forms of static analysis in the SPARK land.<p>It obviously introduced issues around verifying the output or the transpiler, but I think the resulting C code was quite readable and limited in style for verification purposes, and the tools had a high degree of trust.<p>The SPARK static analysis was only ever a part of the whole verification and validation process and there was plenty of testing and other activities that provides additional levels of trust.<p>The whole approach seemed to work pretty well.</div><br/></div></div></div></div><div id="40364599" class="c"><input type="checkbox" id="c-40364599" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#40364105">prev</a><span>|</span><a href="#40364399">next</a><span>|</span><label class="collapse" for="c-40364599">[-]</label><label class="expand" for="c-40364599">[1 more]</label></div><br/><div class="children"><div class="content">Note to interested readers: I submitted this blog post because it is less directly versed in cryptocurrency-related stuff than other posts from the same blog, but there are many more technically interesting posts there, especially the last two discussing the same approach but for Python instead of Rust.</div><br/></div></div><div id="40364399" class="c"><input type="checkbox" id="c-40364399" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#40364599">prev</a><span>|</span><a href="#40364273">next</a><span>|</span><label class="collapse" for="c-40364399">[-]</label><label class="expand" for="c-40364399">[6 more]</label></div><br/><div class="children"><div class="content">What I don&#x27;t quite understand with these efforts is this: If we have to translate the code to Coq manually or semi-manually, isn&#x27;t the likelihood that we make mistakes there much higher than what we ultimately gain with the formal verification.
In other words, how do we know that what we proof is still valid for the original code?</div><br/><div id="40364532" class="c"><input type="checkbox" id="c-40364532" checked=""/><div class="controls bullet"><span class="by">muldvarp</span><span>|</span><a href="#40364399">parent</a><span>|</span><a href="#40364512">next</a><span>|</span><label class="collapse" for="c-40364532">[-]</label><label class="expand" for="c-40364532">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In other words, how do we know that what we proof is still valid for the original code?<p>We don&#x27;t. We will always have to trust _something_ (the hardware, the compiler, the specification, Coq&#x27;s trusted kernel, ...). Formal verification is sadly often discussed as removing the possibility of bugs in their entirety. In practice, formal verification only makes bugs much less likey.<p>That said, yes, automatic translation between Rust and Coq massively reduces the complexity of the things you have to trust and should therefore be preferred over manual translation.</div><br/></div></div><div id="40364512" class="c"><input type="checkbox" id="c-40364512" checked=""/><div class="controls bullet"><span class="by">bennofs</span><span>|</span><a href="#40364399">parent</a><span>|</span><a href="#40364532">prev</a><span>|</span><a href="#40364446">next</a><span>|</span><label class="collapse" for="c-40364512">[-]</label><label class="expand" for="c-40364512">[2 more]</label></div><br/><div class="children"><div class="content">Yes, that is a limitation. But this limitation is not too bad.<p>In many cases, a bug in the translation simply makes the proof impossible. Somebody then investigates why the proof does not go through and finds the bug in the translation.<p>We only have a problem if the bug in the translation specificially cancels a bug in the original code. If there is no systematic risk, it is quite unlikely that two bugs cancel each other in this way.</div><br/><div id="40364634" class="c"><input type="checkbox" id="c-40364634" checked=""/><div class="controls bullet"><span class="by">user2342</span><span>|</span><a href="#40364399">root</a><span>|</span><a href="#40364512">parent</a><span>|</span><a href="#40364446">next</a><span>|</span><label class="collapse" for="c-40364634">[-]</label><label class="expand" for="c-40364634">[1 more]</label></div><br/><div class="children"><div class="content">In case of coq-to-ocaml: is it feasible to do an extraction to OCaml on the translated code and compare it with the original?</div><br/></div></div></div></div><div id="40364446" class="c"><input type="checkbox" id="c-40364446" checked=""/><div class="controls bullet"><span class="by">clarus</span><span>|</span><a href="#40364399">parent</a><span>|</span><a href="#40364512">prev</a><span>|</span><a href="#40364273">next</a><span>|</span><label class="collapse" for="c-40364446">[-]</label><label class="expand" for="c-40364446">[2 more]</label></div><br/><div class="children"><div class="content">The code is translated automatically with coq-of-rust! When issues are found in the translation they can be fixed once in the coq-of-rust tool, and all the translations are updated.</div><br/><div id="40364631" class="c"><input type="checkbox" id="c-40364631" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#40364399">root</a><span>|</span><a href="#40364446">parent</a><span>|</span><a href="#40364273">next</a><span>|</span><label class="collapse" for="c-40364631">[-]</label><label class="expand" for="c-40364631">[1 more]</label></div><br/><div class="children"><div class="content">Ok, what I think I do not understand is what they mean by <i>&quot;tedious and error prone&quot;</i>? Is it tedious to write the automated translation (aka the coq-of-rust tool in this case) or does the translation of a concrete piece of code (e.g. the core crate) still involve manual work?</div><br/></div></div></div></div></div></div><div id="40364273" class="c"><input type="checkbox" id="c-40364273" checked=""/><div class="controls bullet"><span class="by">Havoc</span><span>|</span><a href="#40364399">prev</a><span>|</span><a href="#40363847">next</a><span>|</span><label class="collapse" for="c-40364273">[-]</label><label class="expand" for="c-40364273">[1 more]</label></div><br/><div class="children"><div class="content">Didn’t know that is even feasible.<p>I wonder if efforts like this could speed up rust in key parts of kernel adoption</div><br/></div></div></div></div></div></div></div></body></html>