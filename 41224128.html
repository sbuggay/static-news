<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1723712457157" as="style"/><link rel="stylesheet" href="styles.css?v=1723712457157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.yossarian.net/2024/08/12/Approximating-sum-types-in-Python-with-Pydantic">Approximating sum types in Python with Pydantic</a> <span class="domain">(<a href="https://blog.yossarian.net">blog.yossarian.net</a>)</span></div><div class="subtext"><span>woodruffw</span> | <span>84 comments</span></div><br/><div><div id="41244890" class="c"><input type="checkbox" id="c-41244890" checked=""/><div class="controls bullet"><span class="by">carderne</span><span>|</span><a href="#41247172">next</a><span>|</span><label class="collapse" for="c-41244890">[-]</label><label class="expand" for="c-41244890">[11 more]</label></div><br/><div class="children"><div class="content">I think it would be useful to differentiate more clearly between what is offered by Python&#x27;s type system, and what is offered by Pydantic.<p>That is, you can approximate Rusts&#x27;s enum (sum type) with pure Python using whatever combination of Literal, Enum, Union and dataclasses. For example (more here[1]):<p><pre><code>  @dataclass
  class Foo: ...
  @dataclass
  class Bar: ...
  
  Frobulated = Foo | Bar
</code></pre>
Pydantic adds de&#x2F;ser, but if you&#x27;re not doing that then you can get very far without it. (And even if you are, there are lighter-weight options that play with dataclasses like cattrs, pyserde, dataclasses-json).<p>[1] <a href="https:&#x2F;&#x2F;threeofwands.com&#x2F;algebraic-data-types-in-python&#x2F;" rel="nofollow">https:&#x2F;&#x2F;threeofwands.com&#x2F;algebraic-data-types-in-python&#x2F;</a></div><br/><div id="41254022" class="c"><input type="checkbox" id="c-41254022" checked=""/><div class="controls bullet"><span class="by">binarycoffee</span><span>|</span><a href="#41244890">parent</a><span>|</span><a href="#41246079">next</a><span>|</span><label class="collapse" for="c-41254022">[-]</label><label class="expand" for="c-41254022">[1 more]</label></div><br/><div class="children"><div class="content">I needed to reflect Rust enums and went a bit further with that approach. All variants are wrapped in a decorated class, where the decorator automatically computes the union type and adds de&#x2F;serialization hooks for `cattrs`.<p><pre><code>    @enumclass
    class MyEnum:
        class UnitLikeVariant(Variant0Arg): ...
    
        class TupleLikeVariant(Variant2Arg[int, str]): ...
    
        @dataclass
        class StructLikeVariant:
            foo: float
            bar: int

        # The following class variable is automatically generated:
        #
        # type = UnitLikeVariant | TupleLikeVariant | StructLikeVariant
</code></pre>
where the `VariantXArg` classes are predefined.</div><br/></div></div><div id="41246079" class="c"><input type="checkbox" id="c-41246079" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41244890">parent</a><span>|</span><a href="#41254022">prev</a><span>|</span><a href="#41246047">next</a><span>|</span><label class="collapse" for="c-41246079">[-]</label><label class="expand" for="c-41246079">[3 more]</label></div><br/><div class="children"><div class="content">Yep, someone brought this up on another discussion forum. The post was intended to be explicitly about accomplishing the ser&#x2F;de half as well, hence the emphasis on Pydantic :-)<p>(Python’s annotated types are very powerful, and you can do this and more with them if you don’t immediately need ser&#x2F;de! But they also have limitations, e.g. I believe Union wasn’t allowed in isinstance checks or matching until a recent version.)</div><br/><div id="41250505" class="c"><input type="checkbox" id="c-41250505" checked=""/><div class="controls bullet"><span class="by">nsagent</span><span>|</span><a href="#41244890">root</a><span>|</span><a href="#41246079">parent</a><span>|</span><a href="#41249840">next</a><span>|</span><label class="collapse" for="c-41250505">[-]</label><label class="expand" for="c-41250505">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re looking for serialization&#x2F;deserialization, you might consider confactory [1]. I created to be a factory for objects defined in configs. It actually builds the Python objects without much effort on the user. It simply makes use of type annotations (though you can define your own serializers and deserializers).<p>It also supports complex structures like union types, lists, etc. I used it to create cresset [2], a package that allows building Pytorch models directly from config files.<p>[1]: <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;confactory&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;confactory&#x2F;</a>
[2]: <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;cresset&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;cresset&#x2F;</a></div><br/></div></div><div id="41249840" class="c"><input type="checkbox" id="c-41249840" checked=""/><div class="controls bullet"><span class="by">carderne</span><span>|</span><a href="#41244890">root</a><span>|</span><a href="#41246079">parent</a><span>|</span><a href="#41250505">prev</a><span>|</span><a href="#41246047">next</a><span>|</span><label class="collapse" for="c-41249840">[-]</label><label class="expand" for="c-41249840">[1 more]</label></div><br/><div class="children"><div class="content">Yeah and in practise most people will probably be using Pydantic anyway. Just wanted to point out it&#x27;s not strictly necessary. :)</div><br/></div></div></div></div><div id="41246047" class="c"><input type="checkbox" id="c-41246047" checked=""/><div class="controls bullet"><span class="by">intalentive</span><span>|</span><a href="#41244890">parent</a><span>|</span><a href="#41246079">prev</a><span>|</span><a href="#41253164">next</a><span>|</span><label class="collapse" for="c-41246047">[-]</label><label class="expand" for="c-41246047">[4 more]</label></div><br/><div class="children"><div class="content">Pydantic offers runtime checks.<p>Also I’d add msgspec to your list at the end. Lightweight and fast, handles validation during decoding.</div><br/><div id="41249826" class="c"><input type="checkbox" id="c-41249826" checked=""/><div class="controls bullet"><span class="by">carderne</span><span>|</span><a href="#41244890">root</a><span>|</span><a href="#41246047">parent</a><span>|</span><a href="#41249254">next</a><span>|</span><label class="collapse" for="c-41249826">[-]</label><label class="expand" for="c-41249826">[2 more]</label></div><br/><div class="children"><div class="content">Good point, but that&#x27;s not always desirable. If you have strict type-checking and _aren&#x27;t_ doing ser&#x2F;de, it&#x27;s likely not necessary (eg Rust doesn&#x27;t do runtime checks).</div><br/><div id="41254144" class="c"><input type="checkbox" id="c-41254144" checked=""/><div class="controls bullet"><span class="by">nsteel</span><span>|</span><a href="#41244890">root</a><span>|</span><a href="#41249826">parent</a><span>|</span><a href="#41249254">next</a><span>|</span><label class="collapse" for="c-41254144">[-]</label><label class="expand" for="c-41254144">[1 more]</label></div><br/><div class="children"><div class="content">The situation we found where it&#x27;s still useful is if your app supports extension-type functionality. The 3rd parties writing extensions would ideally be type-checking during development... but they might not bother. Runtime validation becomes useful at the interfaces.</div><br/></div></div></div></div><div id="41249254" class="c"><input type="checkbox" id="c-41249254" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#41244890">root</a><span>|</span><a href="#41246047">parent</a><span>|</span><a href="#41249826">prev</a><span>|</span><a href="#41253164">next</a><span>|</span><label class="collapse" for="c-41249254">[-]</label><label class="expand" for="c-41249254">[1 more]</label></div><br/><div class="children"><div class="content">Typeguard too. The @typechecked annotation on any function or method will blow up with an error at runtime if types do not match</div><br/></div></div></div></div><div id="41253164" class="c"><input type="checkbox" id="c-41253164" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#41244890">parent</a><span>|</span><a href="#41246047">prev</a><span>|</span><a href="#41253361">next</a><span>|</span><label class="collapse" for="c-41253164">[-]</label><label class="expand" for="c-41253164">[1 more]</label></div><br/><div class="children"><div class="content">There is also <a href="https:&#x2F;&#x2F;github.com&#x2F;zifeo&#x2F;dataconf">https:&#x2F;&#x2F;github.com&#x2F;zifeo&#x2F;dataconf</a> that relies heavily on dataclasses to represent configs.</div><br/></div></div><div id="41253361" class="c"><input type="checkbox" id="c-41253361" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#41244890">parent</a><span>|</span><a href="#41253164">prev</a><span>|</span><a href="#41247172">next</a><span>|</span><label class="collapse" for="c-41253361">[-]</label><label class="expand" for="c-41253361">[1 more]</label></div><br/><div class="children"><div class="content">Last time I tried dataclasses-json it had no type safety whatsoever and relied on the data being correct without checking it.<p>It was also an order of magnitude slower than other libraries, and at the time all these libraries were much slower.</div><br/></div></div></div></div><div id="41247172" class="c"><input type="checkbox" id="c-41247172" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#41244890">prev</a><span>|</span><a href="#41244823">next</a><span>|</span><label class="collapse" for="c-41247172">[-]</label><label class="expand" for="c-41247172">[19 more]</label></div><br/><div class="children"><div class="content">The problem I see with it is this: Now, instead of understanding Python, which is straightforward, you have to understand a bunch about Pydantic and type unions. In a large shop of Python programmers, I would expect many would not follow most of this.<p>Essentially, if this is a feature you must have, Python seems like the wrong language. Maybe if you only need it in spots this makes sense...</div><br/><div id="41247613" class="c"><input type="checkbox" id="c-41247613" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41247365">next</a><span>|</span><label class="collapse" for="c-41247613">[-]</label><label class="expand" for="c-41247613">[1 more]</label></div><br/><div class="children"><div class="content">I think an important piece of context here is that this is <i>not</i> useful for non-ser&#x2F;de patterns in Python: if all you have is pure Python types that don&#x27;t need to cross serialization boundaries, then you can do all of this in pure Python (and refine it with Python&#x27;s very mature type annotations).<p>In practice, however, Pydantic is one of the most popular packages&#x2F;frameworks in Python because people <i>do</i> in fact need this kind of complexity. In particular, it makes wrangling complicated object hierarchies that come from REST APIs much easier&#x2F;error prone.</div><br/></div></div><div id="41247365" class="c"><input type="checkbox" id="c-41247365" checked=""/><div class="controls bullet"><span class="by">hnthrowaway6543</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41247613">prev</a><span>|</span><a href="#41249301">next</a><span>|</span><label class="collapse" for="c-41247365">[-]</label><label class="expand" for="c-41247365">[9 more]</label></div><br/><div class="children"><div class="content">&gt; instead of understanding Python, which is straightforward, you have to understand a bunch about Pydantic and type unions.<p>This like saying &quot;instead of understanding Python, you have to understand a bunch about SQLAlchemy and ORMs&quot; or &quot;instead of understanding Python, you need to understand GRPC and data streaming.&quot;<p>Ultimately every library you add to a project is cognitive overhead. Major frameworks or tools like sqlalchemy, Flask&#x2F;Django, Pandas, etc. have a <i>lot</i> of cognitive overhead. The engineering decision is whether that cognitive overhead is worth what the library provides.<p>The measurement of worth is really dependent on your use case. If your use for Python is data scientists doing iterative, interactive work in Jupyter notebooks, Pydantic is probably not worth it. If you&#x27;re building a robust data pipeline or backend web app with high availability requirements but dealing with suspect data parsing, Pydantic might be worth it.</div><br/><div id="41247815" class="c"><input type="checkbox" id="c-41247815" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41247365">parent</a><span>|</span><a href="#41252778">next</a><span>|</span><label class="collapse" for="c-41247815">[-]</label><label class="expand" for="c-41247815">[7 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not wrong, but the distinction here that I was responding to was the idea of needing to use Pydantic routinely for typechecking. Libraries that you <i>have</i> to know might as well be language features.<p>The phrasing of &quot;The engineering decision&quot; in your reply is telling -- you are coming from it as an engineer. But I&#x27;m looking at the population of Python programmers, which extends far beyond software engineers. The more such people have to learn, the more problematic the language becomes. Python succeeded despite <i>not</i> being a statically compiled language with clear typechecking because there is an audience for which those aren&#x27;t the critical factors.<p>As I said in another response, it reminds me of what happened to Java. Maybe that&#x27;s just my own quirk, but none of these changes are free.</div><br/><div id="41249347" class="c"><input type="checkbox" id="c-41249347" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41247815">parent</a><span>|</span><a href="#41248111">next</a><span>|</span><label class="collapse" for="c-41249347">[-]</label><label class="expand" for="c-41249347">[3 more]</label></div><br/><div class="children"><div class="content">I think you are underestimating python developers. When python became popular popular languages did not have such expressive type systems. Java and perl were popular then.<p>Also, here it is claimed the library should be part of the language, and at the same time it us assumed it is too complicated for the users to understand. It seems like the feature being a library solves this, if we let go of the self-imposed requirement of it being part of the language.</div><br/><div id="41253689" class="c"><input type="checkbox" id="c-41253689" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41249347">parent</a><span>|</span><a href="#41251148">next</a><span>|</span><label class="collapse" for="c-41253689">[-]</label><label class="expand" for="c-41253689">[1 more]</label></div><br/><div class="children"><div class="content">When Python started to become popular as Perl alternative, and Zope became a thing to be aware of, I already learned about Caml Light, Objective Caml, Miranda, Standard ML, and the new kind in town Haskell.<p>Also, even within the constrains of C++98 type system, expressivness wasn&#x27;t something C++ was lacking.</div><br/></div></div><div id="41251148" class="c"><input type="checkbox" id="c-41251148" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41249347">parent</a><span>|</span><a href="#41253689">prev</a><span>|</span><a href="#41248111">next</a><span>|</span><label class="collapse" for="c-41251148">[-]</label><label class="expand" for="c-41251148">[1 more]</label></div><br/><div class="children"><div class="content">Usually syntax makes things easier, certainly for types. That&#x27;s why we have syntax.<p>I don&#x27;t claim Python developers cannot understand it. But every additional thing adds to the cognitive burden.</div><br/></div></div></div></div><div id="41248111" class="c"><input type="checkbox" id="c-41248111" checked=""/><div class="controls bullet"><span class="by">hnthrowaway6543</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41247815">parent</a><span>|</span><a href="#41249347">prev</a><span>|</span><a href="#41252778">next</a><span>|</span><label class="collapse" for="c-41248111">[-]</label><label class="expand" for="c-41248111">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Libraries that you have to know might as well be language features.<p>What you <i>have</i> to know depends on where you&#x27;re working and what you&#x27;re doing. You don&#x27;t <i>have</i> to know GRPC Python libraries, unless it&#x27;s a company that uses GRPC for internal communication. You don&#x27;t <i>have</i> to know Flask unless you&#x27;re building a REST API using Flask. You don&#x27;t <i>have</i> to know beautifulsoup unless you&#x27;re building a web scraper. You don&#x27;t <i>have</i> to know Pydantic unless you&#x27;re working on a project that uses Pydantic for data validation.<p>&gt; The phrasing of &quot;The engineering decision&quot; in your reply is telling -- you are coming from it as an engineer. But I&#x27;m looking at the population of Python programmers, which extends far beyond software engineers.<p>You don&#x27;t have to <i>be</i> a software engineer to make an engineering decision. When a data scientist uses conda because they don&#x27;t want to manage their Python environment manually, but runs into performance issues on production because their Docker containers are multiple gigabytes larger than they should be -- that&#x27;s the result of an engineering decision. When a business analyst writes a Python script and manually installs packages without a requirements file, then tries to get it running on a new computer 8 months later but can&#x27;t because they forget which package versions they used -- that&#x27;s the result of an engineering decision. So when you deploy your code without any data validation that runs fine now, but breaks in unexpected ways next week because the result of an external REST API you&#x27;re calling changed unexpectedly...<p>&gt; The more such people have to learn, the more problematic the language becomes. Python succeeded despite not being a statically compiled language with clear typechecking because there is an audience for which those aren&#x27;t the critical factors. ... none of these changes are free.<p>I agree with all this, which is why I said that the engineering decision is deciding whether or not the cost is worth it. Different projects, companies, and people will have different needs.<p>Your original assertion was that &quot;if this is a feature you must have, Python seems like the wrong language&quot; -- but this contradicts what you&#x27;re saying. The overhead of learning a single Python library is far, far less than, say, introducing Rust into a company that only uses Python for everything else.</div><br/><div id="41248756" class="c"><input type="checkbox" id="c-41248756" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41248111">parent</a><span>|</span><a href="#41252778">next</a><span>|</span><label class="collapse" for="c-41248756">[-]</label><label class="expand" for="c-41248756">[2 more]</label></div><br/><div class="children"><div class="content">Yes, at that point in time you wouldn&#x27;t switch from Python. Hence the comments about Java, as an example of where escalating complexity can take you.<p>I think my assertion, less pithily, was &quot;if having the best type-checking system was critical to you, probably you wouldn&#x27;t pick Python&quot;. And I think that&#x27;s correct. People pick it for other features.<p>I didn&#x27;t say I hated having the option. I expressed reservations, which I still have.</div><br/><div id="41249454" class="c"><input type="checkbox" id="c-41249454" checked=""/><div class="controls bullet"><span class="by">hnthrowaway6543</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41248756">parent</a><span>|</span><a href="#41252778">next</a><span>|</span><label class="collapse" for="c-41249454">[-]</label><label class="expand" for="c-41249454">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if having the best type-checking system was critical to you, probably you wouldn&#x27;t pick Python<p>Agree, but the only situation where as a developer you can pick a language&#x2F;ecosystem on its own merits, independently of anything else, is on personal projects. Even if you&#x27;re a startup CTO building a greenfield app, you have account for hiring and train developers. It&#x27;s perfectly sensible that you would want to use Python + mypy&#x2F;pyright&#x2F;pydantic&#x2F;etc for extra robustness since it&#x27;s easy to find Python devs, with a relatively small learning curve if they haven&#x27;t use those tools, vs going full-on Rust or Haskell, which would require much more rare + expensive people and&#x2F;or a much longer training period.</div><br/></div></div></div></div></div></div></div></div><div id="41252778" class="c"><input type="checkbox" id="c-41252778" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41247365">parent</a><span>|</span><a href="#41247815">prev</a><span>|</span><a href="#41249301">next</a><span>|</span><label class="collapse" for="c-41252778">[-]</label><label class="expand" for="c-41252778">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Ultimately every library you add to a project is cognitive overhead. Major frameworks or tools like sqlalchemy, Flask&#x2F;Django, Pandas, etc. have a lot of cognitive overhead. The engineering decision is whether that cognitive overhead is worth what the library provides.<p>IMO a library that provides regular functions and values that follow the rules of the language adds zero cognitive overhead. Frameworks that change&#x2F;break the rules, that let you do things that you can&#x27;t normally do with regular values, or don&#x27;t let you do things that you normally could do, are the ones that add overhead, and it sounds like Pydantic is more in that category.</div><br/></div></div></div></div><div id="41249301" class="c"><input type="checkbox" id="c-41249301" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41247365">prev</a><span>|</span><a href="#41249045">next</a><span>|</span><label class="collapse" for="c-41249301">[-]</label><label class="expand" for="c-41249301">[1 more]</label></div><br/><div class="children"><div class="content">I think it is normal to know popular libraries of a language. For python, django, drf, fastapi, pydantic or jinja are very common.<p>There are some people resisting type checks in python but I think fewer and fewer. I dont think people refusing to learn basic concepts and libraries are a reason to not use something.<p>Also, I am not a big fan of not doing something useful because we need to do a bit of learning. It seems like a variant of &quot;we have always done it this way&quot;. Plus it is a strawman attributed to python developers, IMO.</div><br/></div></div><div id="41249045" class="c"><input type="checkbox" id="c-41249045" checked=""/><div class="controls bullet"><span class="by">rocgf</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41249301">prev</a><span>|</span><a href="#41252399">next</a><span>|</span><label class="collapse" for="c-41249045">[-]</label><label class="expand" for="c-41249045">[1 more]</label></div><br/><div class="children"><div class="content">As it just so happens, I was struggling with this in Python recently and this post describes a better solution than what I came up with.<p>&gt; Essentially, if this is a feature you must have, Python seems like the wrong language.<p>While I don&#x27;t disgree in the absolute sense, there are constraints. You can&#x27;t just switch language or change the problem you&#x27;re solving. If you have the need for more type safety, then this is a price worth paying.</div><br/></div></div><div id="41252399" class="c"><input type="checkbox" id="c-41252399" checked=""/><div class="controls bullet"><span class="by">thenwho</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41249045">prev</a><span>|</span><a href="#41247331">next</a><span>|</span><label class="collapse" for="c-41252399">[-]</label><label class="expand" for="c-41252399">[2 more]</label></div><br/><div class="children"><div class="content">Okay? Programmers have to understand lots of things that aren&#x27;t just the bare basics of the language they&#x27;re using. When did we decide that all software developers are helpless? When can we get back to expecting experts to know things?</div><br/><div id="41253789" class="c"><input type="checkbox" id="c-41253789" checked=""/><div class="controls bullet"><span class="by">73kl4453dz</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41252399">parent</a><span>|</span><a href="#41247331">next</a><span>|</span><label class="collapse" for="c-41253789">[-]</label><label class="expand" for="c-41253789">[1 more]</label></div><br/><div class="children"><div class="content">When? Probably around the time when the people hoping they don&#x27;t need to know anything because ai will write what they want discover desire without knowledge doesn&#x27;t work so well?</div><br/></div></div></div></div><div id="41247331" class="c"><input type="checkbox" id="c-41247331" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41252399">prev</a><span>|</span><a href="#41249222">next</a><span>|</span><label class="collapse" for="c-41247331">[-]</label><label class="expand" for="c-41247331">[3 more]</label></div><br/><div class="children"><div class="content">Pydantic is truly a godsend to the Python ecosystem. It is a full implementation of &quot;parse don&#x27;t validate&quot; and does so using Python&#x27;s existing type declarations. It uses the same forms as dataclasses, SQLAlchemy, and Django that have been part of Python forever so most Python programmers are familiar with it. And the reason you reach for it is that it eliminates whole classes of errors when the boundary between your program and the outside world is only via .model_validate() and .model_dump(). The outside world including 3rd-party API calls. The data either comes back to you <i>exactly</i> like you expect it to, or it errs. It&#x27;s hundreds of tests that you simply don&#x27;t have to write.<p>In the same way that SQLite bills itself as the better alternative to fopen(), Pydantic is the better alternative to json.loads()&#x2F;json.dumps().</div><br/><div id="41247713" class="c"><input type="checkbox" id="c-41247713" checked=""/><div class="controls bullet"><span class="by">adamc</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41247331">parent</a><span>|</span><a href="#41249222">next</a><span>|</span><label class="collapse" for="c-41247713">[-]</label><label class="expand" for="c-41247713">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think you are wrong and I have at times missed having such an option. But... I saw Java go down this path of cool features that you needed to learn, on top of the basic language, and eventually it took Java to an environment where learning the toolset and environment was complex, and vastly changed the calculus of how approachable the language was. In my mind, anyway, it went from being a useful if incomplete tool to being a more complete language that was not really worth messing with unless you were going to make a big commitment.<p>Every step that takes Python in that direction is a mistake, because if we need to make a huge commitment, Python probably isn&#x27;t the right language. A large part of the appeal of Python is that it is easy to learn, easy to bring devs up to speed on if they don&#x27;t know it, easy to debug and understand. That&#x27;s why people use it despite its performance shortcomings, despite its concurrency issues, etc. (That and the benefit of a large and fairly high quality library.)</div><br/><div id="41248464" class="c"><input type="checkbox" id="c-41248464" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41247172">root</a><span>|</span><a href="#41247713">parent</a><span>|</span><a href="#41249222">next</a><span>|</span><label class="collapse" for="c-41248464">[-]</label><label class="expand" for="c-41248464">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re right but I take a different view of it and think it&#x27;s great. Python is changing so that the language you switch to when you need more performance or type safety is... Python. At some level you have to meet users where they are and large complex applications are already written in Python. And it&#x27;s those kinds of developers are more invested in the future direction of the language.<p>I think Python&#x27;s journey is very similar to Go in this regard where as the language matures and more people start using it for large applications you start having to compromise on the ease of on-boarding in favor of the users who are trying to get work done. Both Python and Go added generics around the same time.</div><br/></div></div></div></div></div></div><div id="41249222" class="c"><input type="checkbox" id="c-41249222" checked=""/><div class="controls bullet"><span class="by">jfyusldfwjasdf</span><span>|</span><a href="#41247172">parent</a><span>|</span><a href="#41247331">prev</a><span>|</span><a href="#41244823">next</a><span>|</span><label class="collapse" for="c-41249222">[-]</label><label class="expand" for="c-41249222">[1 more]</label></div><br/><div class="children"><div class="content">Completely disagree. Pydantic, FastAPI, Type Hints, mypy, pyright have all made python much more enjoyable to use and less error prone.</div><br/></div></div></div></div><div id="41244823" class="c"><input type="checkbox" id="c-41244823" checked=""/><div class="controls bullet"><span class="by">reubenmorais</span><span>|</span><a href="#41247172">prev</a><span>|</span><a href="#41245895">next</a><span>|</span><label class="collapse" for="c-41244823">[-]</label><label class="expand" for="c-41244823">[5 more]</label></div><br/><div class="children"><div class="content">One caveat of the tip in the &quot;Deduplicating shared variant state&quot; section about including an underspecified discriminator field in the base class, is that it doesn&#x27;t play well if you&#x27;re using Literals instead of Enums as the discriminator type. Python does not allow you to narrow a literal type of a field in a subclass, so the following doesn&#x27;t type check:<p><pre><code>  from typing import Literal
  
  class _FrobulatedBase:
      kind: Literal[&#x27;foo&#x27;, &#x27;bar&#x27;]
      value: str
  
  class Foo(_FrobulatedBase):
      kind: Literal[&#x27;foo&#x27;] = &#x27;foo&#x27;
      foo_specific: int
  
  class Bar(_FrobulatedBase):
      kind: Literal[&#x27;bar&#x27;] = &#x27;bar&#x27;
      bar_specific: bool


  &quot;kind&quot; overrides symbol of same name in class &quot;_FrobulatedBase&quot;
    Variable is mutable so its type is invariant
      Override type &quot;Literal[&#x27;foo&#x27;]&quot; is not the same as base type &quot;Literal[&#x27;foo&#x27;, &#x27;bar&#x27;]&quot;
</code></pre>
<a href="https:&#x2F;&#x2F;pyright-play.net&#x2F;?code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAySMApiAIYA2AUNQMaXkDOTUA%2BgGLgBGAro6QAmAIWYkAXNSjSoAa1SDxhYmSoBtAOTAwYDQBooG7uRAaAulJkA3KrwlQmMELXqMWUDjoAUnHv3JCokwkAJSSMnIKSkSkFJSa2rpmUAC8hokaltKJbEwIJHRIwEh0SqgwLgzMrKIgPlxgfAIkImJhWZEoisqx6kYm5qmGxqYdI7n5hcWlUNw6NEA" rel="nofollow">https:&#x2F;&#x2F;pyright-play.net&#x2F;?code=GYJw9gtgBALgngBwJYDsDmUkQWEMo...</a></div><br/><div id="41247272" class="c"><input type="checkbox" id="c-41247272" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41244823">parent</a><span>|</span><a href="#41253576">prev</a><span>|</span><a href="#41245472">next</a><span>|</span><label class="collapse" for="c-41247272">[-]</label><label class="expand" for="c-41247272">[2 more]</label></div><br/><div class="children"><div class="content">mypy typechecks that just fine[1].<p>However, I think that&#x27;s possibly a bug :-) -- I agree that narrowing a literal via subclassing is unsound. That&#x27;s why the example in the blog used `str` for the superclass, not the closure of all `Literal` variants.<p>(I use this pattern pretty extensively in Python codebases that are typechecked with mypy, and I haven&#x27;t run into many issues with mypy failing to understand the variant shapes -- the exception to this so far has been with `RootModel`, where mypy has needed Pydantic&#x27;s mypy plugin[2] to understand the relationship between the &quot;root&quot; type and its underlying union. But it&#x27;s possible that this is essentially unsound as well.)<p>[1]: <a href="https:&#x2F;&#x2F;mypy-play.net&#x2F;?mypy=latest&amp;python=3.12&amp;gist=f35da62ec4ac59f06360a758ca5f58f6" rel="nofollow">https:&#x2F;&#x2F;mypy-play.net&#x2F;?mypy=latest&amp;python=3.12&amp;gist=f35da62e...</a><p>[2]: <a href="https:&#x2F;&#x2F;docs.pydantic.dev&#x2F;latest&#x2F;integrations&#x2F;mypy&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.pydantic.dev&#x2F;latest&#x2F;integrations&#x2F;mypy&#x2F;</a></div><br/><div id="41250188" class="c"><input type="checkbox" id="c-41250188" checked=""/><div class="controls bullet"><span class="by">reubenmorais</span><span>|</span><a href="#41244823">root</a><span>|</span><a href="#41247272">parent</a><span>|</span><a href="#41245472">next</a><span>|</span><label class="collapse" for="c-41250188">[-]</label><label class="expand" for="c-41250188">[1 more]</label></div><br/><div class="children"><div class="content">Using str in the superclass equally unsound and also doesn&#x27;t type check. There&#x27;s no good way to do it, as the discriminator type is by definition disjoint between all kinds.</div><br/></div></div></div></div><div id="41245472" class="c"><input type="checkbox" id="c-41245472" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#41244823">parent</a><span>|</span><a href="#41247272">prev</a><span>|</span><a href="#41245895">next</a><span>|</span><label class="collapse" for="c-41245472">[-]</label><label class="expand" for="c-41245472">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it doesn&#x27;t play well if you&#x27;re using Literals instead of Enums as the discriminator type<p>The original example code with Enums doesn&#x27;t type-check either, and for the same reason:<p>If the type checker allowed that, someone could take an object of type Foo, assign it to a variable of type _FrobulatedBase, then use that variable to modify the kind field to &#x27;bar&#x27; and now you have an illegal Foo with kind &#x27;bar&#x27;.</div><br/></div></div></div></div><div id="41245895" class="c"><input type="checkbox" id="c-41245895" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41244823">prev</a><span>|</span><a href="#41253279">next</a><span>|</span><label class="collapse" for="c-41245895">[-]</label><label class="expand" for="c-41245895">[27 more]</label></div><br/><div class="children"><div class="content">Meta comment.<p>Something I&#x27;ve wondered of late. I keep seeing these articles pop up and they&#x27;re trying to recreate ADTs for Python in the manner of Rust. But there&#x27;s a long history of ADTs in other languages. For instance we don&#x27;t see threads on recreating Haskell&#x27;s ADT structures in Python.<p>Is this an artifact of Rust is hype right now, especially on HN? As in the typical reader is more familiar with Rust than Haskell, and thus &quot;I want to do what I&#x27;m used to in Rust in Python&quot; is more likely to resonate than &quot;I want to do what I&#x27;m used to in Haskell in Python&quot;?<p>At the end of the day it doesn&#x27;t *really* matter  as the underlying construct being modeled is the same. It&#x27;s the translation layer that I&#x27;m wondering about.</div><br/><div id="41245996" class="c"><input type="checkbox" id="c-41245996" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">parent</a><span>|</span><a href="#41245946">next</a><span>|</span><label class="collapse" for="c-41245996">[-]</label><label class="expand" for="c-41245996">[6 more]</label></div><br/><div class="children"><div class="content">(Author of the post.)<p>I think so, in the sense that Rust has successfully translated ADTs and other PLT-laden concepts from SML&#x2F;Haskell into syntax that a large base of engineers finds intuitive. Whether or not that’s hype is a value judgement, but that <i>is</i> the reason I picked it for the example snippet: I figured more people would “get” it with less explanation required :-)</div><br/><div id="41254038" class="c"><input type="checkbox" id="c-41254038" checked=""/><div class="controls bullet"><span class="by">pwm</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41245996">parent</a><span>|</span><a href="#41246230">next</a><span>|</span><label class="collapse" for="c-41254038">[-]</label><label class="expand" for="c-41254038">[1 more]</label></div><br/><div class="children"><div class="content">Apologies for my meta-meta-comment :) I&#x27;ve been writing code for ~30 years in various languages, and today my brain can&#x27;t compute how people find any syntax other than this more intuitive:<p><pre><code>  data Thing
    = ThingA Int
    | ThingB String Bool
    | ThingC
</code></pre>
To me, the above syntax takes away all the noise and just states what needs to be stated.</div><br/></div></div><div id="41246230" class="c"><input type="checkbox" id="c-41246230" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41245996">parent</a><span>|</span><a href="#41254038">prev</a><span>|</span><a href="#41245946">next</a><span>|</span><label class="collapse" for="c-41246230">[-]</label><label class="expand" for="c-41246230">[4 more]</label></div><br/><div class="children"><div class="content">Got it. It makes sense and was what I figured is the case. I find it interesting as it&#x27;s a sign of the times watching the evolution of what the &quot;base language&quot; is in threads like this over time. I mentioned in another comment that several years ago it&#x27;d have been Haskell or Scala. If one went back further (before my time!) it&#x27;d probably have been in OCaml or something.</div><br/><div id="41247239" class="c"><input type="checkbox" id="c-41247239" checked=""/><div class="controls bullet"><span class="by">mattarm</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41246230">parent</a><span>|</span><a href="#41245946">next</a><span>|</span><label class="collapse" for="c-41247239">[-]</label><label class="expand" for="c-41247239">[3 more]</label></div><br/><div class="children"><div class="content">In my experience learning a bit of OCaml after Rust, and then looking at Haskell, the three aren&#x27;t all that different in terms of the basics of how ADTs are declared and used, especially for the simpler cases.</div><br/><div id="41247376" class="c"><input type="checkbox" id="c-41247376" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247239">parent</a><span>|</span><a href="#41245946">next</a><span>|</span><label class="collapse" for="c-41247376">[-]</label><label class="expand" for="c-41247376">[2 more]</label></div><br/><div class="children"><div class="content">Agreed. As a concept they&#x27;re all the same thing.<p>Another way of phrasing my query is that given these are all basically ML-style constructs, why would the examples not be ML? And I was assuming the answer to that is &quot;the sorts of people reading these blogs in 2024 are more familiar with Rust&quot;</div><br/><div id="41247765" class="c"><input type="checkbox" id="c-41247765" checked=""/><div class="controls bullet"><span class="by">runeblaze</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247376">parent</a><span>|</span><a href="#41245946">next</a><span>|</span><label class="collapse" for="c-41247765">[-]</label><label class="expand" for="c-41247765">[1 more]</label></div><br/><div class="children"><div class="content">I think a second reason might be that translating OCaml&#x2F;Haskell concepts to Python has that academic connotation to it. Rust also (thanks to PyO3) has more affinity to Python than the ML languages. I guess it isn&#x27;t a surprise that this post has Python, C++, and Rust, all &quot;commonly&quot; used for Python libraries.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41245946" class="c"><input type="checkbox" id="c-41245946" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41245895">parent</a><span>|</span><a href="#41245996">prev</a><span>|</span><a href="#41246317">next</a><span>|</span><label class="collapse" for="c-41245946">[-]</label><label class="expand" for="c-41245946">[2 more]</label></div><br/><div class="children"><div class="content">I think &quot;hype&quot; has some connotations that I wouldn&#x27;t necessarily agree with, and I don&#x27;t think it&#x27;s as much &quot;on HN&quot; as &quot;people who write Python,&quot; but I would agree that I would expect at this point more Python folks to be familiar with Rust than Haskell, and so that to be the reason, yes.</div><br/><div id="41246194" class="c"><input type="checkbox" id="c-41246194" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41245946">parent</a><span>|</span><a href="#41246317">next</a><span>|</span><label class="collapse" for="c-41246194">[-]</label><label class="expand" for="c-41246194">[1 more]</label></div><br/><div class="children"><div class="content">The reason I said hype is that it&#x27;s a cycle here. If you go back 10 years every example *would* have been in Haskell. Or perhaps Scala. They were the cool languages of the era. And the topics here painted a picture that their use in the broader world was more common than they really were. And I say that as someone who used both Haskell &amp; Scala in my day job at the time. HN would have you believe that I was the norm, but I very much was not.<p>That&#x27;s not to say it&#x27;s bad, or a problem. If it gets more people into these concepts that&#x27;s great.</div><br/></div></div></div></div><div id="41246317" class="c"><input type="checkbox" id="c-41246317" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41245895">parent</a><span>|</span><a href="#41245946">prev</a><span>|</span><a href="#41246165">next</a><span>|</span><label class="collapse" for="c-41246317">[-]</label><label class="expand" for="c-41246317">[13 more]</label></div><br/><div class="children"><div class="content">It is quite common to see people in Rust circles mentioning Rust being innovative for feature XYZ, that was initially in a ML variant, Ada, Eiffel, ....<p>I would say familarity, and lack of exposure to programming languages in general.</div><br/><div id="41246516" class="c"><input type="checkbox" id="c-41246516" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41246317">parent</a><span>|</span><a href="#41246165">next</a><span>|</span><label class="collapse" for="c-41246516">[-]</label><label class="expand" for="c-41246516">[12 more]</label></div><br/><div class="children"><div class="content">Nowhere in this post or in any Rust community post I&#x27;m aware of does anybody claim that sum types (or product types, or affine&#x2F;linear types, etc.) are a Rust novelty.<p>As a stretch, I&#x27;ve seen Rust content where people claim that Rust has successfully <i>popularized</i> a handful of relatively obscure PLT concepts. But this is a much, much weaker claim than Rust innovating or inventing them outright, and it&#x27;s one that&#x27;s largely supported by the size of the Rust community versus the size of Haskell or even the largest ML variant communities.<p>(I say this as someone who wrote OCaml for a handful of years before I touched Rust.)</div><br/><div id="41247561" class="c"><input type="checkbox" id="c-41247561" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41246516">parent</a><span>|</span><a href="#41246165">next</a><span>|</span><label class="collapse" for="c-41247561">[-]</label><label class="expand" for="c-41247561">[11 more]</label></div><br/><div class="children"><div class="content">Where did I specially mentioned it was this post, and not in general?<p>Here is another common one, <i>&quot;It would be great a Rust like but with GC&quot;</i>.</div><br/><div id="41247726" class="c"><input type="checkbox" id="c-41247726" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247561">parent</a><span>|</span><a href="#41246165">next</a><span>|</span><label class="collapse" for="c-41247726">[-]</label><label class="expand" for="c-41247726">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Here is another common one, &quot;It would be great a Rust like but with GC&quot;.<p>What in this phrase suggests or implies that Rust has innovated something that an earlier FP language actually did? Something that resembles Go&#x27;s managed runtime but with Rust&#x27;s sum types seems like a very reasonable thing to want, and doesn&#x27;t exist <i>per se</i> without buying either into a very foreign syntax and thus a much smaller community and library ecosystem.<p>(Or as another phrasing: what is <i>actually</i> wrong with someone saying this? Insufficient credit given to other languages? Do people apply this standard to C with BCPL and ALGOL? I haven&#x27;t seen them do so.)</div><br/><div id="41248459" class="c"><input type="checkbox" id="c-41248459" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247726">parent</a><span>|</span><a href="#41250404">next</a><span>|</span><label class="collapse" for="c-41248459">[-]</label><label class="expand" for="c-41248459">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Something that resembles Go&#x27;s managed runtime but with Rust&#x27;s sum types  ..... Or as another phrasing: what is actually wrong with someone saying this?<p>I don&#x27;t think there&#x27;s anything wrong per se. Although I do think it contributes to the sentiment that people may be ascribing things as being novel to Rust, even when not intended as in this case. To be fair, that&#x27;s what sent me down the mental path earlier that prompted this subthread. And that&#x27;s when I figured it was more a matter of being the implementation most likely to resonate with the audience.<p>And I don&#x27;t think it&#x27;s a matter of needing to give credit to other languages. But phrasing it like &quot;Something with a managed runtime, but with sum types&quot; is generic enough, unless there&#x27;s something specific about either of those. For instance the phrasing I gave does exist in plenty of places, but perhaps &quot;Something that resembles Go&#x27;s managed runtime with sum types&quot; perhaps does not. I don&#x27;t know enough about Go to say that.<p>In other words, is there something specific about *Rust*&#x27;s sum types that one is after in this example? Or just the concept of sum types.</div><br/><div id="41248786" class="c"><input type="checkbox" id="c-41248786" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41248459">parent</a><span>|</span><a href="#41250404">next</a><span>|</span><label class="collapse" for="c-41248786">[-]</label><label class="expand" for="c-41248786">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In other words, is there something specific about <i>Rust</i>&#x27;s sum types that one is after in this example? Or just the concept of sum types.<p>I think, concretely, it&#x27;s the fact that Rust&#x27;s syntax is more intuitive to the average engineer than ML or Haskell. Maybe that&#x27;s a failure of SWE education! But generally speaking, it&#x27;s easier to explain what Rust does to someone who has taken a year or two of Java, C, or C++ than to explain ML to them.</div><br/><div id="41249159" class="c"><input type="checkbox" id="c-41249159" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41248786">parent</a><span>|</span><a href="#41250404">next</a><span>|</span><label class="collapse" for="c-41249159">[-]</label><label class="expand" for="c-41249159">[2 more]</label></div><br/><div class="children"><div class="content">I agree and think you&#x27;re right, to a point. But I would posit that a much higher percentage of devs than the typical HNer would expect would find the Rust syntax to be pretty arcane. Although I grant that they&#x27;d find Haskell to be *more* arcane for sure.<p>And that stopping point I think is where the perception of Rust&#x27;s popularity on sites like HN is much higher than in the general public. And by that I mean people who at least grok, if not use, Rust and not people who like the idea of Rust.<p>For instance, keep in mind that even during the heyday of Scala here on HN the rest of the JVM world was complaining that Scala syntax was too arcane.</div><br/><div id="41249442" class="c"><input type="checkbox" id="c-41249442" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41249159">parent</a><span>|</span><a href="#41250404">next</a><span>|</span><label class="collapse" for="c-41249442">[-]</label><label class="expand" for="c-41249442">[1 more]</label></div><br/><div class="children"><div class="content">No particular disagreement there!</div><br/></div></div></div></div></div></div></div></div><div id="41250404" class="c"><input type="checkbox" id="c-41250404" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247726">parent</a><span>|</span><a href="#41248459">prev</a><span>|</span><a href="#41252443">next</a><span>|</span><label class="collapse" for="c-41250404">[-]</label><label class="expand" for="c-41250404">[3 more]</label></div><br/><div class="children"><div class="content">It implies completely lack of knowledge that something like that already exists, predating Rust by a few decades.<p>The contexts where it pops up, it is as if it would be yet to come, such language.<p>Speaking of C and BCPL, indeed we do, because many wrongly believe in this urban myth, that without them there was nothing else as high level systems programming languages, even though JOVIAL came to be in 1958, followed by ALGOL and PL dialects, Bootstrap CPL was never planned to be used beyond that purpose, and there was a rich research outside Bell Labs in systems programming in high level languages.<p>Instead we got stuck with something that 50 years later are still trying to fix, with Rust being part of the solution.</div><br/><div id="41250895" class="c"><input type="checkbox" id="c-41250895" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41250404">parent</a><span>|</span><a href="#41252430">next</a><span>|</span><label class="collapse" for="c-41250895">[-]</label><label class="expand" for="c-41250895">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It implies completely lack of knowledge that something like that already exists, predating Rust by a few decades.<p>I don&#x27;t understand why you think this: we explain things all the time without presuming that the particular choice of explanation implies ignorance of a preceding concept. In high school physics, for example, you wouldn&#x27;t assume that your teacher doesn&#x27;t know who Ptolemy is because they start with Newton.<p>The value of an explanation is in its effectiveness, not a pedantic lineage of the underlying concept. The latter is interesting, at least to me, but I&#x27;m not going to bore my readers by walking them through 65 years of language evolution just to get back to the same basic concept that they&#x27;re able to intuit immediately from a ~6 line code snippet.<p>(It&#x27;s also condescending to do so: there&#x27;s no evidence whatsoever that Rust&#x27;s creators, maintainers, community, etc. <i>aren&#x27;t</i> familiar with the history of PL development.)</div><br/></div></div><div id="41252430" class="c"><input type="checkbox" id="c-41252430" checked=""/><div class="controls bullet"><span class="by">thenwho</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41250404">parent</a><span>|</span><a href="#41250895">prev</a><span>|</span><a href="#41252443">next</a><span>|</span><label class="collapse" for="c-41252430">[-]</label><label class="expand" for="c-41252430">[1 more]</label></div><br/><div class="children"><div class="content">For what it&#x27;s worth, you&#x27;re right. I saw the same thing happen with Go: everyone seems to think that Go invented static linking and <i>gasp</i> compiling executables, seemingly ignorant of the fact that we actually used to do that all the time, before bloated dynamic runtimes and massive virtual machines even existed. I don&#x27;t trust software &quot;experts&quot; who don&#x27;t know their history, because they usually don&#x27;t know a lot of other important things, either.</div><br/></div></div></div></div><div id="41252443" class="c"><input type="checkbox" id="c-41252443" checked=""/><div class="controls bullet"><span class="by">thenwho</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247726">parent</a><span>|</span><a href="#41250404">prev</a><span>|</span><a href="#41246165">next</a><span>|</span><label class="collapse" for="c-41252443">[-]</label><label class="expand" for="c-41252443">[2 more]</label></div><br/><div class="children"><div class="content">It always has to be some moral thing with you people. What&#x27;s &quot;wrong&quot; is that software practitioners who don&#x27;t know their history are doomed to repeat it. It implies a lack of exposure to different parts of the field, and especially a lack of exposure to the theory. Someone who thinks Rust is an entirely new idea in computing probably has other massive gaps in their knowledge, and it follows the irrational pop culture this industry has cultivated where anything older than 18 months is bad, and anything newer than 18 months has never existed before and is the greatest thing since sliced bread.<p>Some of us are tired of cleaning up after the inevitable messes these developers leave behind.</div><br/><div id="41252675" class="c"><input type="checkbox" id="c-41252675" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41252443">parent</a><span>|</span><a href="#41246165">next</a><span>|</span><label class="collapse" for="c-41252675">[-]</label><label class="expand" for="c-41252675">[1 more]</label></div><br/><div class="children"><div class="content">What are you talking about? The “wrong” above is factual i.e. positive, not normative.<p>Please be a little bit more charitable with how you read comments. The core observation here is that “Rust is completely novel” is not actually something that Rust practitioners, including junior engineers, actually say. Nobody has said it in this thread, and nobody has even provided a single example of somebody saying it.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41246165" class="c"><input type="checkbox" id="c-41246165" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#41245895">parent</a><span>|</span><a href="#41246317">prev</a><span>|</span><a href="#41247225">next</a><span>|</span><label class="collapse" for="c-41246165">[-]</label><label class="expand" for="c-41246165">[3 more]</label></div><br/><div class="children"><div class="content">Is there any reason why you&#x27;ve singled out Rust as particularly notable here and not any of the many other languages with them? OCaml, Elm, F#, Scala, I think more recent versions of Java, Kotlin, Nim, TypeScript, and Swift all support ADTs. Python <i>already</i> supports them, albeit with very little runtime support. Rust doesn&#x27;t particularly stand out in such a broad field of languages. They&#x27;re so useful a language needs a good reason these days to <i>not</i> support them.</div><br/><div id="41246212" class="c"><input type="checkbox" id="c-41246212" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41246165">parent</a><span>|</span><a href="#41247225">next</a><span>|</span><label class="collapse" for="c-41246212">[-]</label><label class="expand" for="c-41246212">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re making the exact point that I was raising.</div><br/><div id="41250002" class="c"><input type="checkbox" id="c-41250002" checked=""/><div class="controls bullet"><span class="by">darby_nine</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41246212">parent</a><span>|</span><a href="#41247225">next</a><span>|</span><label class="collapse" for="c-41250002">[-]</label><label class="expand" for="c-41250002">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry, I&#x27;m still completely confused where rust came from or what particular relevance it has to the conversation beyond the short segment in the article?<p>My point being—you see articles about ADTs involving non-rust languages all the time. Why single rust out?</div><br/></div></div></div></div></div></div><div id="41247225" class="c"><input type="checkbox" id="c-41247225" checked=""/><div class="controls bullet"><span class="by">myvoiceismypass</span><span>|</span><a href="#41245895">parent</a><span>|</span><a href="#41246165">prev</a><span>|</span><a href="#41253279">next</a><span>|</span><label class="collapse" for="c-41247225">[-]</label><label class="expand" for="c-41247225">[2 more]</label></div><br/><div class="children"><div class="content">FWIW I seem to often find myself reaching for Haskell-isms when writing Typscript or Scala. And I’ve never actually written production Haskell code! But so many concepts like this just map nicely. “Parse don’t validate”, “make illegal states unreprsentable”, etc - all those patterns.</div><br/><div id="41253702" class="c"><input type="checkbox" id="c-41253702" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41245895">root</a><span>|</span><a href="#41247225">parent</a><span>|</span><a href="#41253279">next</a><span>|</span><label class="collapse" for="c-41253702">[-]</label><label class="expand" for="c-41253702">[1 more]</label></div><br/><div class="children"><div class="content">Also known as Type Driven Development, a much better approach than the other TDD abbreviation.</div><br/></div></div></div></div></div></div><div id="41253279" class="c"><input type="checkbox" id="c-41253279" checked=""/><div class="controls bullet"><span class="by">adsharma</span><span>|</span><a href="#41245895">prev</a><span>|</span><a href="#41250130">next</a><span>|</span><label class="collapse" for="c-41253279">[-]</label><label class="expand" for="c-41253279">[1 more]</label></div><br/><div class="children"><div class="content">python has been about expressing ideas. Even if the language doesn&#x27;t support some of the concepts natively, it&#x27;s useful to express it in python so it could be effectively transpiled into a language that does. This is what py2many needs from a curated subset of python with some enhancements as opposed to inventing a new language.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;adsharma&#x2F;adt">https:&#x2F;&#x2F;github.com&#x2F;adsharma&#x2F;adt</a> contains a small enhancement for @sealed decorator from the excellent upstream repo.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;py2many&#x2F;py2many&#x2F;blob&#x2F;main&#x2F;tests&#x2F;cases&#x2F;sealed.py">https:&#x2F;&#x2F;github.com&#x2F;py2many&#x2F;py2many&#x2F;blob&#x2F;main&#x2F;tests&#x2F;cases&#x2F;sea...</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;py2many&#x2F;py2many&#x2F;blob&#x2F;main&#x2F;tests&#x2F;expected&#x2F;sealed.rs">https:&#x2F;&#x2F;github.com&#x2F;py2many&#x2F;py2many&#x2F;blob&#x2F;main&#x2F;tests&#x2F;expected&#x2F;...</a></div><br/></div></div><div id="41250130" class="c"><input type="checkbox" id="c-41250130" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#41253279">prev</a><span>|</span><a href="#41251052">next</a><span>|</span><label class="collapse" for="c-41250130">[-]</label><label class="expand" for="c-41250130">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a shame there&#x27;s so many different names for a set of very related (or identical?) concepts.  For example wikipedia says &quot;tagged union&quot; is also known as &quot;variant, variant record, choice type, discriminated union, disjoint union, sum type, or coproduct&quot;. [<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tagged_union" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tagged_union</a>]</div><br/></div></div><div id="41253199" class="c"><input type="checkbox" id="c-41253199" checked=""/><div class="controls bullet"><span class="by">gnulinux996</span><span>|</span><a href="#41251052">prev</a><span>|</span><a href="#41246401">next</a><span>|</span><label class="collapse" for="c-41253199">[-]</label><label class="expand" for="c-41253199">[7 more]</label></div><br/><div class="children"><div class="content">I feel like with typescript and pydantic taking center stage it seems that the dynamic vs static typing debate finally comes to a close.<p>More and more Java seems to be not that bad after all.</div><br/><div id="41253634" class="c"><input type="checkbox" id="c-41253634" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41253199">parent</a><span>|</span><a href="#41253278">next</a><span>|</span><label class="collapse" for="c-41253634">[-]</label><label class="expand" for="c-41253634">[3 more]</label></div><br/><div class="children"><div class="content">Maybe it has gotten less bad but Java was the main counter-argument and foe to static typing: a poor and inexpressive type system coupled with significant verbosity, Java required a lot of buck and provided very little bang for it. And that is just the langage, ignoring the horrendous best practices.<p>I very much credit Java for having turned a generation away from static typing, dynamic typing did get buoyed by a combination of moore’s law and good press but could never have done it without Java having smothered the other side and being dreck.</div><br/><div id="41253708" class="c"><input type="checkbox" id="c-41253708" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41253199">root</a><span>|</span><a href="#41253634">parent</a><span>|</span><a href="#41253278">next</a><span>|</span><label class="collapse" for="c-41253708">[-]</label><label class="expand" for="c-41253708">[2 more]</label></div><br/><div class="children"><div class="content">Something went very wrong then, given Go&#x27;s existence, making Java feel like a PhD level language.</div><br/><div id="41254148" class="c"><input type="checkbox" id="c-41254148" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41253199">root</a><span>|</span><a href="#41253708">parent</a><span>|</span><a href="#41253278">next</a><span>|</span><label class="collapse" for="c-41254148">[-]</label><label class="expand" for="c-41254148">[1 more]</label></div><br/><div class="children"><div class="content">Java never felt like phd level language except for a phd in sucking.<p>Go does have a poor type system, but it has nowhere near the verbosity of early aught Java: local type inference, free functions, any number of (public) types in the same file, closures, type definitions (terse and easy newtyping), iteration (if only for builtin types until 1.23), etc...<p>And that&#x27;s without considering the cultural side of requiring two different implementations of every type (one interface and one impl) or XML-oriented programming for bindings &quot;improved&quot; by unreliable parsers going through method comments.</div><br/></div></div></div></div></div></div><div id="41253278" class="c"><input type="checkbox" id="c-41253278" checked=""/><div class="controls bullet"><span class="by">lolive</span><span>|</span><a href="#41253199">parent</a><span>|</span><a href="#41253634">prev</a><span>|</span><a href="#41253933">next</a><span>|</span><label class="collapse" for="c-41253278">[-]</label><label class="expand" for="c-41253278">[1 more]</label></div><br/><div class="children"><div class="content">Next steps: immutable data structures and functional programming.
#haskell #hereWeCome</div><br/></div></div><div id="41253933" class="c"><input type="checkbox" id="c-41253933" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41253199">parent</a><span>|</span><a href="#41253278">prev</a><span>|</span><a href="#41246401">next</a><span>|</span><label class="collapse" for="c-41253933">[-]</label><label class="expand" for="c-41253933">[2 more]</label></div><br/><div class="children"><div class="content">It is now bad even as a typed language</div><br/><div id="41254156" class="c"><input type="checkbox" id="c-41254156" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#41253199">root</a><span>|</span><a href="#41253933">parent</a><span>|</span><a href="#41246401">next</a><span>|</span><label class="collapse" for="c-41254156">[-]</label><label class="expand" for="c-41254156">[1 more]</label></div><br/><div class="children"><div class="content">It was always bad as a statically typed language, and it was a lot worse back then.</div><br/></div></div></div></div></div></div><div id="41246401" class="c"><input type="checkbox" id="c-41246401" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#41253199">prev</a><span>|</span><a href="#41244572">next</a><span>|</span><label class="collapse" for="c-41246401">[-]</label><label class="expand" for="c-41246401">[4 more]</label></div><br/><div class="children"><div class="content">A pretty good article. Would be a great article if they used real world examples instead of made up &quot;formulated&quot; ones.</div><br/><div id="41252173" class="c"><input type="checkbox" id="c-41252173" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41246401">parent</a><span>|</span><a href="#41250390">next</a><span>|</span><label class="collapse" for="c-41252173">[-]</label><label class="expand" for="c-41252173">[1 more]</label></div><br/><div class="children"><div class="content">Something I&#x27;ve learned is that in general, people find it easier to follow concrete examples than abstract ones.<p>I agree with you that the article would have been improved if they&#x27;d used real-world examples, e.g. a ContactMethod type that has Address or PhoneNumber or something like that.</div><br/></div></div><div id="41250390" class="c"><input type="checkbox" id="c-41250390" checked=""/><div class="controls bullet"><span class="by">jamincan</span><span>|</span><a href="#41246401">parent</a><span>|</span><a href="#41252173">prev</a><span>|</span><a href="#41252782">next</a><span>|</span><label class="collapse" for="c-41250390">[-]</label><label class="expand" for="c-41250390">[1 more]</label></div><br/><div class="children"><div class="content">I know that Foo and Frobulator and so on have history in code examples, but I personally find examples with them require more careful reading than examples built on real concepts.</div><br/></div></div><div id="41252782" class="c"><input type="checkbox" id="c-41252782" checked=""/><div class="controls bullet"><span class="by">__mharrison__</span><span>|</span><a href="#41246401">parent</a><span>|</span><a href="#41250390">prev</a><span>|</span><a href="#41244572">next</a><span>|</span><label class="collapse" for="c-41252782">[-]</label><label class="expand" for="c-41252782">[1 more]</label></div><br/><div class="children"><div class="content">I teach for a living. Simple examples are fine for introducing a concept but students really grok it when they can see it in practice.</div><br/></div></div></div></div><div id="41244572" class="c"><input type="checkbox" id="c-41244572" checked=""/><div class="controls bullet"><span class="by">blorenz</span><span>|</span><a href="#41246401">prev</a><span>|</span><a href="#41247449">next</a><span>|</span><label class="collapse" for="c-41244572">[-]</label><label class="expand" for="c-41244572">[3 more]</label></div><br/><div class="children"><div class="content">Discriminated unions are also a wonderful part of the zod library. I use them to overload endpoints for multiple relevant operations.</div><br/><div id="41244856" class="c"><input type="checkbox" id="c-41244856" checked=""/><div class="controls bullet"><span class="by">roshankhan28</span><span>|</span><a href="#41244572">parent</a><span>|</span><a href="#41247288">next</a><span>|</span><label class="collapse" for="c-41244856">[-]</label><label class="expand" for="c-41244856">[1 more]</label></div><br/><div class="children"><div class="content">+1 for the discriminated unions</div><br/></div></div><div id="41247288" class="c"><input type="checkbox" id="c-41247288" checked=""/><div class="controls bullet"><span class="by">myvoiceismypass</span><span>|</span><a href="#41244572">parent</a><span>|</span><a href="#41244856">prev</a><span>|</span><a href="#41247449">next</a><span>|</span><label class="collapse" for="c-41247288">[-]</label><label class="expand" for="c-41247288">[1 more]</label></div><br/><div class="children"><div class="content">I used to use io-ts heavily but zod is my go to now - and it’s so ergonomic and easy for typescript newbies to pick up and grasp.</div><br/></div></div></div></div><div id="41244720" class="c"><input type="checkbox" id="c-41244720" checked=""/><div class="controls bullet"><span class="by">wizerno</span><span>|</span><a href="#41247449">prev</a><span>|</span><a href="#41252836">next</a><span>|</span><label class="collapse" for="c-41244720">[-]</label><label class="expand" for="c-41244720">[1 more]</label></div><br/><div class="children"><div class="content">A slightly related discussion on Type Unions in C# from a week ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41183240">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41183240</a></div><br/></div></div><div id="41252836" class="c"><input type="checkbox" id="c-41252836" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#41244720">prev</a><span>|</span><a href="#41253347">next</a><span>|</span><label class="collapse" for="c-41252836">[-]</label><label class="expand" for="c-41252836">[1 more]</label></div><br/><div class="children"><div class="content">And people complain that typescript is crazy. I think we just need to acknowledge that typing is hard, especially with what mainstream languages give us.</div><br/></div></div><div id="41253347" class="c"><input type="checkbox" id="c-41253347" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#41252836">prev</a><span>|</span><label class="collapse" for="c-41253347">[-]</label><label class="expand" for="c-41253347">[1 more]</label></div><br/><div class="children"><div class="content">Author of typedload here.<p>typedload does this without need to pass a &quot;discriminator&quot; parameter.<p>Just having the types with the same field defined as a literal of different things will suffice.<p>I&#x27;ve also implemented an algorithm to inspect the data and find out the type directly from the literal field, to avoid having to try multiple types when loading a union. Pydantic has also implemented the same strategy afterwards.<p>typedload is faster than pydantic to load tagged unions. It is written in pure python.<p>edit: Also, typedload just uses completely regular dataclasses or attrs. No need for all those different BaseModel, RootModel and understanding when to use them.</div><br/></div></div></div></div></div></div></div></body></html>