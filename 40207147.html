<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714467680628" as="style"/><link rel="stylesheet" href="styles.css?v=1714467680628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://rachelbythebay.com/w/2024/04/29/pb/">Hitting every branch on the way down</a>Â <span class="domain">(<a href="http://rachelbythebay.com">rachelbythebay.com</a>)</span></div><div class="subtext"><span>zdw</span> | <span>53 comments</span></div><br/><div><div id="40207744" class="c"><input type="checkbox" id="c-40207744" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#40208372">next</a><span>|</span><label class="collapse" for="c-40207744">[-]</label><label class="expand" for="c-40207744">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  I told it to install &quot;protobuf&quot; since I use that library in my build tool. That actually installed &quot;protobuf-24.4,1&quot; which is some insane version number I&#x27;d never seen before. All of my other systems are all running 3.x.x type versions.<p>I was curious about this, so I took a look at the list of protobuf releases[0] and they&#x27;re...confusing, to say the least. Chronologically, the most recent tags at the time I write this comment are:<p>v5.27.0-rc1
v3.27.0-rc1
v27.0-rc1
v27-dev
v26.1
v5.26.1
v3.26.1
v26.1
v26.0
v5.26.0
v3.26.0<p>Does anyone here happen to know what&#x27;s going on here? As best I can tell, they&#x27;re simultaneously supporting 3 major versions while keeping their minor and patch versions in lockstep, and then having one major version be implicit?<p>I can almost imagine a scenario where they started out with just major and minor version and then realized they wanted to make breaking changes, which led them down the path of adding a third separate number to the versions, but if they already were going down the path of assuming &quot;wider&quot; versions are newer , why not just stop using version numbers with only major-minor and instead just add a 0 or 1 to the front of all of the continuations of that branch? Also, why synchronize every single minor and patch version between all three major versions? I can understand why it might be useful to continue providing support for multiple major versions at the same time, but I&#x27;d expect that _sometimes_ there might be a bug or something in only one of them, and pushing out a release of the other two that don&#x27;t contain any changes would be pretty strange.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tags">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;tags</a></div><br/><div id="40208601" class="c"><input type="checkbox" id="c-40208601" checked=""/><div class="controls bullet"><span class="by">maeln</span><span>|</span><a href="#40207744">parent</a><span>|</span><a href="#40208372">next</a><span>|</span><label class="collapse" for="c-40208601">[-]</label><label class="expand" for="c-40208601">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s because they changed the versioning format: <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;releases?page=5">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;releases?page=5</a> &#x2F; <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;news&#x2F;2022-05-06&#x2F;" rel="nofollow">https:&#x2F;&#x2F;protobuf.dev&#x2F;news&#x2F;2022-05-06&#x2F;</a><p>But I suppose old version still receive bugfixes.</div><br/></div></div></div></div><div id="40208372" class="c"><input type="checkbox" id="c-40208372" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#40207744">prev</a><span>|</span><a href="#40207460">next</a><span>|</span><label class="collapse" for="c-40208372">[-]</label><label class="expand" for="c-40208372">[1 more]</label></div><br/><div class="children"><div class="content">So, <i>someone</i> at some point in some commit that we will never see because it got squashed with other commits thought it would be cooler to use absl::StrCat() instead of the &quot;+&quot; operator, and in the process of doing that, they went &quot;what&#x27;s this useless code using angled brackets instead of quotes?! It works with quotes too, let&#x27;s delete it!&quot;. Or maybe that part was difficult to test, so they simply deleted it to increase test coverage? Guess we will never know, but still, open source is now a bit shittier because of it. Thanks, anonymous clueless developer!<p><pre><code>    --  std::string left = &quot;\&quot;&quot;;
    --  std::string right = &quot;\&quot;&quot;;
    --  if (use_system_include) {
    --    left = &quot;&lt;&quot;;
    --    right = &quot;&gt;&quot;;
    --  }
    --  return left + name + right;
    ++  return absl::StrCat(&quot;\&quot;&quot;, basename, &quot;\&quot;&quot;);</code></pre></div><br/></div></div><div id="40207460" class="c"><input type="checkbox" id="c-40207460" checked=""/><div class="controls bullet"><span class="by">bananskalhalk</span><span>|</span><a href="#40208372">prev</a><span>|</span><a href="#40207286">next</a><span>|</span><label class="collapse" for="c-40207460">[-]</label><label class="expand" for="c-40207460">[5 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    $ git show  d85c9944c55fb38f4eae149979a0f680ea125ecb  | wc -l
    11067
    $
</code></pre>
From `man git-log`: &quot;Note that unless one of --diff-merges variants (including short -m, -c, and --cc options) is explicitly given, merge commits will not show a diff, even if a diff format like --patch is selected, nor will they match search options like -S. The exception is when --first-parent is in use, in which case first-parent is the default format.&quot;<p>Presumably the author would have been happier using the -m-flag in addition to -p.</div><br/><div id="40208137" class="c"><input type="checkbox" id="c-40208137" checked=""/><div class="controls bullet"><span class="by">thriftwy</span><span>|</span><a href="#40207460">parent</a><span>|</span><a href="#40207286">next</a><span>|</span><label class="collapse" for="c-40208137">[-]</label><label class="expand" for="c-40208137">[4 more]</label></div><br/><div class="children"><div class="content">And that&#x27;s one of the reasons why I advocate against merges in the codebase on every project I work for and in every HN thread where the topic of merges is mentioned.</div><br/><div id="40208393" class="c"><input type="checkbox" id="c-40208393" checked=""/><div class="controls bullet"><span class="by">baud147258</span><span>|</span><a href="#40207460">root</a><span>|</span><a href="#40208137">parent</a><span>|</span><a href="#40207286">next</a><span>|</span><label class="collapse" for="c-40208393">[-]</label><label class="expand" for="c-40208393">[3 more]</label></div><br/><div class="children"><div class="content">That might reveal the depths of my ignorance of Git, but how do you manage moving changes from one branch to the other if you don&#x27;t use merge? Edit: continuing to read the discussion, it seems it&#x27;s rebase? I have some reading to do</div><br/><div id="40208534" class="c"><input type="checkbox" id="c-40208534" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#40207460">root</a><span>|</span><a href="#40208393">parent</a><span>|</span><a href="#40208461">next</a><span>|</span><label class="collapse" for="c-40208534">[-]</label><label class="expand" for="c-40208534">[1 more]</label></div><br/><div class="children"><div class="content">When people talk about avoiding merges, I think they mean this: <a href="https:&#x2F;&#x2F;trunkbaseddevelopment.com" rel="nofollow">https:&#x2F;&#x2F;trunkbaseddevelopment.com</a><p>The approach described on that site doesn&#x27;t strictly rule out &quot;git merge&quot;, but it emphasises short-lived branches and unidirectional commit flow. If you do things that way you find you just don&#x27;t really need merges. The next step is to think &quot;merges are rarely useful and sometimes dangerous, so let&#x27;s just avoid them completely&quot;.</div><br/></div></div><div id="40208461" class="c"><input type="checkbox" id="c-40208461" checked=""/><div class="controls bullet"><span class="by">BHSPitMonkey</span><span>|</span><a href="#40207460">root</a><span>|</span><a href="#40208393">parent</a><span>|</span><a href="#40208534">prev</a><span>|</span><a href="#40207286">next</a><span>|</span><label class="collapse" for="c-40208461">[-]</label><label class="expand" for="c-40208461">[1 more]</label></div><br/><div class="children"><div class="content">Or use squash merges.</div><br/></div></div></div></div></div></div></div></div><div id="40207286" class="c"><input type="checkbox" id="c-40207286" checked=""/><div class="controls bullet"><span class="by">datascienced</span><span>|</span><a href="#40207460">prev</a><span>|</span><a href="#40208543">next</a><span>|</span><label class="collapse" for="c-40207286">[-]</label><label class="expand" for="c-40207286">[38 more]</label></div><br/><div class="children"><div class="content">I wont claim to understand C and the reason why &lt;&gt; is better than ââ. I assume it is.<p>But the fact that a merge can have arbitrary changes in it always bothers me!<p>This is a case for rebase over merge if there are conflicts.<p>You could have a merge of 2 empty repo parents where the result is the complete source of the latest version of Kubernetes!</div><br/><div id="40207323" class="c"><input type="checkbox" id="c-40207323" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207372">next</a><span>|</span><label class="collapse" for="c-40207323">[-]</label><label class="expand" for="c-40207323">[4 more]</label></div><br/><div class="children"><div class="content">Yep. Stuff like this is part of why I&#x27;m a rebaser.<p>Rebase is <i>simple</i>. <i>Always</i>. The end result is obvious and clear and can only be interpreted in one way.<p>Merge has lots of little sharp edges and surprises if you don&#x27;t know every single tiniest detail.<p>Almost nobody knows it in that level of detail, so it&#x27;s a terrible choice for interacting with anyone else.  If you&#x27;re on your own, sure, do whatever - many things are not built solo though.</div><br/><div id="40208170" class="c"><input type="checkbox" id="c-40208170" checked=""/><div class="controls bullet"><span class="by">zilti</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207323">parent</a><span>|</span><a href="#40207372">next</a><span>|</span><label class="collapse" for="c-40208170">[-]</label><label class="expand" for="c-40208170">[3 more]</label></div><br/><div class="children"><div class="content">&quot;But it is littering the commit history with useless commits!&quot; is what I always hear</div><br/><div id="40208281" class="c"><input type="checkbox" id="c-40208281" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40208170">parent</a><span>|</span><a href="#40208554">next</a><span>|</span><label class="collapse" for="c-40208281">[-]</label><label class="expand" for="c-40208281">[1 more]</label></div><br/><div class="children"><div class="content">And the best answer is: &quot;Why do you do useless commits?&quot;.<p>With `git amend` and `git fixup` you can arrange your commits to be clean, properly documented and self explanatory (and maybe atomic but that&#x27;s a little harder). It takes a little time but it is hugely beneficial to code reviews and bug investigation.</div><br/></div></div><div id="40208554" class="c"><input type="checkbox" id="c-40208554" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40208170">parent</a><span>|</span><a href="#40208281">prev</a><span>|</span><a href="#40207372">next</a><span>|</span><label class="collapse" for="c-40208554">[-]</label><label class="expand" for="c-40208554">[1 more]</label></div><br/><div class="children"><div class="content">Merge does that, yes, hence the preference for rebase flows.</div><br/></div></div></div></div></div></div><div id="40207372" class="c"><input type="checkbox" id="c-40207372" checked=""/><div class="controls bullet"><span class="by">prerok</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207323">prev</a><span>|</span><a href="#40207816">next</a><span>|</span><label class="collapse" for="c-40207372">[-]</label><label class="expand" for="c-40207372">[2 more]</label></div><br/><div class="children"><div class="content">What I find strange is that &lt;&gt; traditionally included system header files and &quot;&quot; included local files. They used different include paths, so you could have a header file in your sources with the same name as the system header file and then could control whether you are including one or the other based on using &lt;&gt; or &quot;&quot;.<p>Anyway, I thought the distinction was lost in later compilers in favor of a single include path and then just taking the first file found when looking at potential matches through include path.<p>It seems the author of that merge thought the same thing. So, the distinction is actually still used by compilers?</div><br/><div id="40207594" class="c"><input type="checkbox" id="c-40207594" checked=""/><div class="controls bullet"><span class="by">pavon</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207372">parent</a><span>|</span><a href="#40207816">next</a><span>|</span><label class="collapse" for="c-40207594">[-]</label><label class="expand" for="c-40207594">[1 more]</label></div><br/><div class="children"><div class="content">With both GCC and Visual C++, the ââ form first searches local paths and then system paths, while the &lt;&gt; form only searches system paths. Guess some BSDs are stricter about local paths.</div><br/></div></div></div></div><div id="40207816" class="c"><input type="checkbox" id="c-40207816" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207372">prev</a><span>|</span><a href="#40208205">next</a><span>|</span><label class="collapse" for="c-40207816">[-]</label><label class="expand" for="c-40207816">[2 more]</label></div><br/><div class="children"><div class="content">All but the first commit has parents. All commits point to the state of the file tree at that point.<p>A &quot;merge commit&quot; is nothing more than a commit claiming any number of parents greater than one. It is still its own file tree reference that decides how the tree looks, and nothing dictates that it should be related to the parents.</div><br/><div id="40207984" class="c"><input type="checkbox" id="c-40207984" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207816">parent</a><span>|</span><a href="#40208205">next</a><span>|</span><label class="collapse" for="c-40207984">[-]</label><label class="expand" for="c-40207984">[1 more]</label></div><br/><div class="children"><div class="content">You are right that conceptually this is okay. But it is a UI problem that commands the author tried didn&#x27;t manage to show the difference between the merge commit against any of its parents.</div><br/></div></div></div></div><div id="40208205" class="c"><input type="checkbox" id="c-40208205" checked=""/><div class="controls bullet"><span class="by">red_admiral</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207816">prev</a><span>|</span><a href="#40207513">next</a><span>|</span><label class="collapse" for="c-40208205">[-]</label><label class="expand" for="c-40208205">[1 more]</label></div><br/><div class="children"><div class="content">The &lt;&gt; version searches the library path (usually &#x2F;usr&#x2F;include&#x2F;* but can be modified with flags) whereas the &quot;&quot; searches the current working directory.</div><br/></div></div><div id="40207513" class="c"><input type="checkbox" id="c-40207513" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40208205">prev</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207513">[-]</label><label class="expand" for="c-40207513">[18 more]</label></div><br/><div class="children"><div class="content">One idiot with rebase destroys history with no trace. I worked with such an idiot in a parallel team. I can&#x27;t say how many weeks of work randomly got destroyed by said idiot.<p>I hate rebase on shared code  I don&#x27;t care how clean jt looks. Don&#x27;t mess with history.</div><br/><div id="40207646" class="c"><input type="checkbox" id="c-40207646" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207513">parent</a><span>|</span><a href="#40207837">next</a><span>|</span><label class="collapse" for="c-40207646">[-]</label><label class="expand" for="c-40207646">[6 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t understand how you can lose weeks of work. The person that would have done the force push would have the original commit in their reflog. ORIG_HEAD would be set.<p>Everyone else that had a copy of the repo would have had a copy of the &quot;lost&quot; commits.<p>I really cannot imagine how many things would have to go wrong for weeks of work to be lost.</div><br/><div id="40207811" class="c"><input type="checkbox" id="c-40207811" checked=""/><div class="controls bullet"><span class="by">chaorace</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207646">parent</a><span>|</span><a href="#40207837">next</a><span>|</span><label class="collapse" for="c-40207811">[-]</label><label class="expand" for="c-40207811">[5 more]</label></div><br/><div class="children"><div class="content">There is a hierarchy to these things:<p>- Person who destroys git history<p>- Person who hates destroying git history<p>- Person who knows how to recover &quot;destroyed&quot; history<p>- Person who knows how to truly destroy git history</div><br/><div id="40207956" class="c"><input type="checkbox" id="c-40207956" checked=""/><div class="controls bullet"><span class="by">pvdoom</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207811">parent</a><span>|</span><a href="#40207905">next</a><span>|</span><label class="collapse" for="c-40207956">[-]</label><label class="expand" for="c-40207956">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Person who knows how to truly destroy git history<p>The Gitsatz Haderach</div><br/></div></div><div id="40207905" class="c"><input type="checkbox" id="c-40207905" checked=""/><div class="controls bullet"><span class="by">pcl</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207811">parent</a><span>|</span><a href="#40207956">prev</a><span>|</span><a href="#40207837">next</a><span>|</span><label class="collapse" for="c-40207905">[-]</label><label class="expand" for="c-40207905">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; - Person who knows how to truly destroy git history</i><p>â¦ tell me more!</div><br/><div id="40208024" class="c"><input type="checkbox" id="c-40208024" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207905">parent</a><span>|</span><a href="#40208005">next</a><span>|</span><label class="collapse" for="c-40208024">[-]</label><label class="expand" for="c-40208024">[1 more]</label></div><br/><div class="children"><div class="content">A rebase can be undone, because the old commits keep hanging around in the repo. Rebase doesn&#x27;t delete or rewrite anything, it just creates new commits and adjusts branch pointers, so the old stuff is still there just hard to get at because nothing points at it anymore.<p>You just need to find an old commit ID somewhere, normally the reflog.<p>The old stuff will go away on its own eventually due to git&#x27;s self-maintenance procedures removing unreachable commits, or it can be done forcefully by adjusting the gc parameters to get rid of it.</div><br/></div></div><div id="40208005" class="c"><input type="checkbox" id="c-40208005" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207905">parent</a><span>|</span><a href="#40208024">prev</a><span>|</span><a href="#40207837">next</a><span>|</span><label class="collapse" for="c-40208005">[-]</label><label class="expand" for="c-40208005">[1 more]</label></div><br/><div class="children"><div class="content">I cannot imagine how one could _truly_ destroy git history. You could destroy it locally, sure no problem. You _might_ be able to destroy it on your remote, but if you&#x27;re using something like Github&#x2F;Gitlab&#x2F;Bitbucket I&#x27;m sure they&#x27;ll have a cache that isn&#x27;t trivial to remove from. But even if you remove it locally and from remote, there&#x27;s no way you&#x27;re removing it from other peoples clones. And other people could have pushed to other remotes.<p>Stuff &quot;leaks&quot; so much in git, that it&#x27;s really hard to lose work. The only way I could see someone losing work is if they never commit or if they never push. But even if you don&#x27;t push and just rebase, you&#x27;re not losing work. You would have to go out of your way to delete git history locally.</div><br/></div></div></div></div></div></div></div></div><div id="40207837" class="c"><input type="checkbox" id="c-40207837" checked=""/><div class="controls bullet"><span class="by">arghwhat</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207513">parent</a><span>|</span><a href="#40207646">prev</a><span>|</span><a href="#40207593">next</a><span>|</span><label class="collapse" for="c-40207837">[-]</label><label class="expand" for="c-40207837">[1 more]</label></div><br/><div class="children"><div class="content">One never rebases shared code. They rebase their own work branch. Messing with history of master&#x2F;main&#x2F;integration branches should be blocked.<p>Rebase is a necessary part of a workflow even if you like merge commits. You&#x27;re severely missing out if interactive rebases are not part of your toolbox.</div><br/></div></div><div id="40207593" class="c"><input type="checkbox" id="c-40207593" checked=""/><div class="controls bullet"><span class="by">Feathercrown</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207513">parent</a><span>|</span><a href="#40207837">prev</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207593">[-]</label><label class="expand" for="c-40207593">[10 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t consider rebasing your own local commits on top of a more recent remote master to be messing with history in any meaningful way, and that&#x27;s the most useful method of rebasing.</div><br/><div id="40207615" class="c"><input type="checkbox" id="c-40207615" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207593">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207615">[-]</label><label class="expand" for="c-40207615">[9 more]</label></div><br/><div class="children"><div class="content">Rebasing unpushed commits is ok. But I have yet to see a workflow that provides good enough guardrails to make it something you can do safely.</div><br/><div id="40207687" class="c"><input type="checkbox" id="c-40207687" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207615">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207687">[-]</label><label class="expand" for="c-40207687">[8 more]</label></div><br/><div class="children"><div class="content">Protect your main branch?</div><br/><div id="40207747" class="c"><input type="checkbox" id="c-40207747" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207687">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207747">[-]</label><label class="expand" for="c-40207747">[7 more]</label></div><br/><div class="children"><div class="content">One of the great advantages of git is being able to pull from other people&#x27;s feature branches, not just master. So protecting just master isn&#x27;t good enough.</div><br/><div id="40207791" class="c"><input type="checkbox" id="c-40207791" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207747">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207791">[-]</label><label class="expand" for="c-40207791">[6 more]</label></div><br/><div class="children"><div class="content">Yeah so you have them go through the workflow that doesnât ruin things, like pull requests?</div><br/><div id="40207855" class="c"><input type="checkbox" id="c-40207855" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207791">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207855">[-]</label><label class="expand" for="c-40207855">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to have to go back and forth with someone to pull their branch. I want to just be able to pull anything they&#x27;ve pushed.</div><br/><div id="40208613" class="c"><input type="checkbox" id="c-40208613" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207855">parent</a><span>|</span><a href="#40207928">next</a><span>|</span><label class="collapse" for="c-40208613">[-]</label><label class="expand" for="c-40208613">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t &quot;protect your main branch&quot; still the answer to this?<p>Your two feature branches would be unprotected so you can merge away if you like. When one of you wants to commit something to master, that&#x27;s when you&#x27;d check for dodgy merges.<p>Also, &quot;git cherry-pick&quot; is a good alternative to merging for this use case.</div><br/></div></div><div id="40207928" class="c"><input type="checkbox" id="c-40207928" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207855">parent</a><span>|</span><a href="#40208613">prev</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207928">[-]</label><label class="expand" for="c-40207928">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll often just do a<p><pre><code>   git reset --hard origin&#x2F;branch-name</code></pre></div><br/><div id="40207989" class="c"><input type="checkbox" id="c-40207989" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207928">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40207989">[-]</label><label class="expand" for="c-40207989">[2 more]</label></div><br/><div class="children"><div class="content">Right but that doesn&#x27;t help if you&#x27;ve done your own work on top of their changes.</div><br/><div id="40208624" class="c"><input type="checkbox" id="c-40208624" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207989">parent</a><span>|</span><a href="#40207790">next</a><span>|</span><label class="collapse" for="c-40208624">[-]</label><label class="expand" for="c-40208624">[1 more]</label></div><br/><div class="children"><div class="content">I think rebase is generally the correct approach here. If you&#x27;ve done your own work on top of their old changes, rebase your work on top of their new changes.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40207790" class="c"><input type="checkbox" id="c-40207790" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207513">prev</a><span>|</span><a href="#40207338">next</a><span>|</span><label class="collapse" for="c-40207790">[-]</label><label class="expand" for="c-40207790">[2 more]</label></div><br/><div class="children"><div class="content">Wouldnât you have the same amount of merge conflicts with rebase? Especially if you donât do it often, which you frankly also should with merge?<p>I have to admit that I never really understood the advantages of rebase, and what I mean by this is they I actually donât understand how the dangers of rebase out-weighs any form of advantages. Especially because on of the major advantages of merge is that you can squash your local commit history when you submit it to your main branch.<p>What we do is that we tie every pull request to a relatively small feature task, and because we do this, we genuinely donât care about the individual commits developers do. Which means they can commit really silly messages if they are heading to a meeting or if they are just tired at the end of the day. It also helps with them merging main into their branch often, because it doesnât taint the history.<p>The biggest advantage weâve seen, that maybe we didnât expect, is that nobody ever fucks up our tree in a way that needs someone who actually understands git to solve. Weâve also locked down the use of force push so that is not available to anyone unless itâs absolutely needed. Part of the reason I set this up initially was to protect myself from me, but itâs been a good thing since.<p>But Iâm actually curious if itâs wrong.</div><br/><div id="40208061" class="c"><input type="checkbox" id="c-40208061" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207790">parent</a><span>|</span><a href="#40207338">next</a><span>|</span><label class="collapse" for="c-40208061">[-]</label><label class="expand" for="c-40208061">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Especially because on of the major advantages of merge is that you can squash your local commit history when you submit it to your main branch.<p>Squashing is in no-way limited to merging and is actually done by doing an interactive rebase. Nothing is stopping you from squashing without creating a merge commit. It&#x27;s entirely separate.<p>If you&#x27;re squashing everything anyway, what does merging even give you? Is your main branch just:<p>* merge B<p>* squashed commit B<p>* merge A<p>* squashed commit A<p>If you didn&#x27;t merge, you&#x27;d have:<p>* squashed commit B<p>* squashed commit A<p>&gt; What we do is that we tie every pull request to a relatively small feature task, and because we do this, we genuinely donât care about the individual commits developers do.<p>Except eventually there is a large feature task and then you end up with a giant commit that is annoying when git-bisecting.<p>But at the end of the day, these things only matter if you are spelunking through git history and&#x2F;or using things like git bisect. If your git history is &quot;write-only &amp; rollback&quot;, then none of this stuff matters.</div><br/></div></div></div></div><div id="40207338" class="c"><input type="checkbox" id="c-40207338" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207790">prev</a><span>|</span><a href="#40208320">next</a><span>|</span><label class="collapse" for="c-40207338">[-]</label><label class="expand" for="c-40207338">[2 more]</label></div><br/><div class="children"><div class="content">I believe that the semantics of &lt; &gt; vs &quot;&quot; is actually compiler-dependent but on every compiler that matters, #including with angle brackets is the semantic for &quot;the system header&quot; whereas using quotes gives preference to files in your local source tree.<p>So for example if you #include &lt;foo&gt; then the compiler (actually the preprocessor, but whatever) looks in the system&#x27;s standard location, whereas if you #include &quot;foo&quot; then it looks in the local tree.</div><br/><div id="40207561" class="c"><input type="checkbox" id="c-40207561" checked=""/><div class="controls bullet"><span class="by">ephimetheus</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207338">parent</a><span>|</span><a href="#40208320">next</a><span>|</span><label class="collapse" for="c-40207561">[-]</label><label class="expand" for="c-40207561">[1 more]</label></div><br/><div class="children"><div class="content">I think thatâs just the ordering though. ââ will also end up searching the system paths, it will just check the local paths first.</div><br/></div></div></div></div><div id="40208320" class="c"><input type="checkbox" id="c-40208320" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207338">prev</a><span>|</span><a href="#40207428">next</a><span>|</span><label class="collapse" for="c-40208320">[-]</label><label class="expand" for="c-40208320">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But the fact that a merge can have arbitrary changes in it always bothers me!<p>After that xy thing where they were trying to install a back door having changes that are hidden like this is a big red flag.<p>In fact changing include &lt;something.h&gt; to include &quot;something.h&quot; with a hidden commit like this isn&#x27;t a red flag it&#x27;s a big rotating alarm with a siren. Someones trying set things up to include malicious code via a faked system lib.</div><br/><div id="40208384" class="c"><input type="checkbox" id="c-40208384" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40208320">parent</a><span>|</span><a href="#40207428">next</a><span>|</span><label class="collapse" for="c-40208384">[-]</label><label class="expand" for="c-40208384">[1 more]</label></div><br/><div class="children"><div class="content">Sadly, not all of us can live in the tech equivalent of Bond films. There is only so many xz backdoors to go around.</div><br/></div></div></div></div><div id="40207428" class="c"><input type="checkbox" id="c-40207428" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40208320">prev</a><span>|</span><a href="#40207536">next</a><span>|</span><label class="collapse" for="c-40207428">[-]</label><label class="expand" for="c-40207428">[3 more]</label></div><br/><div class="children"><div class="content">But a rebased commit can also have arbitrary changes!<p>---<p>P.S. Any commit can have any change. Or no change.<p>A &quot;commit&quot; is a version...a message, a tree, some metadata, and 0 or more parents. In fact it&#x27;s not even a change&#x2F;diff&#x2F;patchset per se. Though will often compare it against its assigned parents. If it has multiple parents, you&#x27;d have to choose which to compare. If it has zero parents, you can&#x27;t compare against any parents.</div><br/><div id="40207471" class="c"><input type="checkbox" id="c-40207471" checked=""/><div class="controls bullet"><span class="by">ptsneves</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207428">parent</a><span>|</span><a href="#40207536">next</a><span>|</span><label class="collapse" for="c-40207471">[-]</label><label class="expand" for="c-40207471">[2 more]</label></div><br/><div class="children"><div class="content">Yes, except git log will show all the commits that got into the branch, while with merge you need git log -m otherwise there are invisible commits(and diffs) in a pretty  common workflow. I donât know why this is the default behaviour.<p>Git log only shows one tree not parallel trees from the merge.</div><br/><div id="40207493" class="c"><input type="checkbox" id="c-40207493" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#40207286">root</a><span>|</span><a href="#40207471">parent</a><span>|</span><a href="#40207536">next</a><span>|</span><label class="collapse" for="c-40207493">[-]</label><label class="expand" for="c-40207493">[1 more]</label></div><br/><div class="children"><div class="content">? Not sure what you mean.<p>git log will show all ancestors.<p>And git diff shows any difference between two refs.<p>Nothing invisible unless you deliberately make it so.</div><br/></div></div></div></div></div></div><div id="40207536" class="c"><input type="checkbox" id="c-40207536" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#40207286">parent</a><span>|</span><a href="#40207428">prev</a><span>|</span><a href="#40208543">next</a><span>|</span><label class="collapse" for="c-40207536">[-]</label><label class="expand" for="c-40207536">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wont claim to understand C and the reason why &lt;&gt; is better than ââ. I assume it is.<p>That one&#x27;s obvious, you can type &lt;&gt; and you can&#x27;t type ââ.</div><br/></div></div></div></div><div id="40208543" class="c"><input type="checkbox" id="c-40208543" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#40207286">prev</a><span>|</span><a href="#40208290">next</a><span>|</span><label class="collapse" for="c-40208543">[-]</label><label class="expand" for="c-40208543">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of <a href="https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;issues&#x2F;1491">https:&#x2F;&#x2F;github.com&#x2F;protocolbuffers&#x2F;protobuf&#x2F;issues&#x2F;1491</a> , which has effectively been WONTFIX (why does github not have this useful distinction?) because Google are happy with how it works and it&#x27;s really difficult to make this particular thing work with the (also broken) Python module import system.</div><br/></div></div><div id="40208290" class="c"><input type="checkbox" id="c-40208290" checked=""/><div class="controls bullet"><span class="by">microtherion</span><span>|</span><a href="#40208543">prev</a><span>|</span><a href="#40207491">next</a><span>|</span><label class="collapse" for="c-40208290">[-]</label><label class="expand" for="c-40208290">[1 more]</label></div><br/><div class="children"><div class="content">Rather than the sed post-processing, the author could also have used -iquote for the place where protobuf is installed, which makes it findable by quoted includes.</div><br/></div></div><div id="40208347" class="c"><input type="checkbox" id="c-40208347" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#40207491">prev</a><span>|</span><a href="#40207702">next</a><span>|</span><label class="collapse" for="c-40208347">[-]</label><label class="expand" for="c-40208347">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t want to victim blame too much, but this line stood out to me<p>&gt; There&#x27;s no &quot;body&quot; to this commit. It&#x27;s just a &quot;Merge:&quot; and two other commits<p>Commits are snapshots of repository state, and merges &quot;obviously&quot; have differences from its parents. So not having &quot;body&quot; for a commit is bit nonsensical in git (yes, technically you can make empty commits but that&#x27;s a special case). These sort of things are where having good mental model of git is useful.<p>As I have my share of hairy merges, it is pretty intuitive that merge commits can, and in many cases need to, have changes that are not part of either parent.<p>Maybe something like pijul (&#x2F;darcs) would handle things differently here, but I believe that merges are fundamentally difficult problem.</div><br/></div></div><div id="40207702" class="c"><input type="checkbox" id="c-40207702" checked=""/><div class="controls bullet"><span class="by">jeffrallen</span><span>|</span><a href="#40208347">prev</a><span>|</span><label class="collapse" for="c-40207702">[-]</label><label class="expand" for="c-40207702">[2 more]</label></div><br/><div class="children"><div class="content">This reminds me of a comment my new boss made, &quot;you like learning on hard mode&quot;. He meant that instead of following doc to learn, I want to go find out how it works from first principles and then follow the docs, maybe improving them, based on what I saw from &quot;beneath them&quot; looking up.</div><br/><div id="40208641" class="c"><input type="checkbox" id="c-40208641" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#40207702">parent</a><span>|</span><label class="collapse" for="c-40208641">[-]</label><label class="expand" for="c-40208641">[1 more]</label></div><br/><div class="children"><div class="content">I like to think of that as &quot;actually learning&quot;</div><br/></div></div></div></div></div></div></div></div></div></body></html>