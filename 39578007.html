<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709456456555" as="style"/><link rel="stylesheet" href="styles.css?v=1709456456555"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nostarch.com/algorithmic-thinking-2nd-edition">Algorithmic Thinking (2nd Edition)</a> <span class="domain">(<a href="https://nostarch.com">nostarch.com</a>)</span></div><div class="subtext"><span>teleforce</span> | <span>20 comments</span></div><br/><div><div id="39578124" class="c"><input type="checkbox" id="c-39578124" checked=""/><div class="controls bullet"><span class="by">npalli</span><span>|</span><a href="#39578100">next</a><span>|</span><label class="collapse" for="c-39578124">[-]</label><label class="expand" for="c-39578124">[5 more]</label></div><br/><div class="children"><div class="content">One interesting part of this book is the language chosen is C. Now, we all know the downsides but the good part is it allows the student to understand the runtime efficiency, memory usage and complexity of various algorithms closer to what you can expect in the ideal case. I see a lot of books nowadays using Python, it is not clear with such a high level language you understand the tradeoffs. How much of the slowness is due to the algorithms vs the data structures you chose from Python.<p>Of course, no GC, segfaults and OOM are some of the downsides of C but this is not production code. You can use this knowledge to understand how various algorithms are implemented in other languages and predict behavior or chose a better one.</div><br/><div id="39579454" class="c"><input type="checkbox" id="c-39579454" checked=""/><div class="controls bullet"><span class="by">Affric</span><span>|</span><a href="#39578124">parent</a><span>|</span><a href="#39578726">next</a><span>|</span><label class="collapse" for="c-39579454">[-]</label><label class="expand" for="c-39579454">[1 more]</label></div><br/><div class="children"><div class="content">When we teach students we have to balance employability, pedagogical utility, interest, and learning curve.<p>The majority of students won’t need to know C to be employable. Teaching an Algos course in JS helps web dev. In Python helps data science. Java is still pretty popular for enterprise.<p>The majority of students will find it quite difficult compared to most languages they use.<p>C does not reflect a truly low level machine. You might be able to teach them the same thing with an assembly language.<p>The kids who want to know C will teach themselves.</div><br/></div></div><div id="39578726" class="c"><input type="checkbox" id="c-39578726" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#39578124">parent</a><span>|</span><a href="#39579454">prev</a><span>|</span><a href="#39578100">next</a><span>|</span><label class="collapse" for="c-39578726">[-]</label><label class="expand" for="c-39578726">[3 more]</label></div><br/><div class="children"><div class="content">see also MMIX (and its predecessor, MIX)</div><br/><div id="39579273" class="c"><input type="checkbox" id="c-39579273" checked=""/><div class="controls bullet"><span class="by">Arainach</span><span>|</span><a href="#39578124">root</a><span>|</span><a href="#39578726">parent</a><span>|</span><a href="#39578100">next</a><span>|</span><label class="collapse" for="c-39579273">[-]</label><label class="expand" for="c-39579273">[2 more]</label></div><br/><div class="children"><div class="content">C is a much more appropriate choice in my opinion.  It expresses 99.9% of the same concepts while being orders of magnitude faster to read.  Most people I know who have tried to read (some of) Knuth cited MMIX among their reasons for eventually growing tired and abandoning the effort.</div><br/><div id="39579482" class="c"><input type="checkbox" id="c-39579482" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39578124">root</a><span>|</span><a href="#39579273">parent</a><span>|</span><a href="#39578100">next</a><span>|</span><label class="collapse" for="c-39579482">[-]</label><label class="expand" for="c-39579482">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It expresses 99.9% of the same concepts while being orders of magnitude faster to read.</i><p>Knuth thinks so, or did at some point.<p>&quot;I think C has a lot of features that are very important. The way C handles pointers, for example, was a brilliant innovation; it solved a lot of problems that we had before in data structuring and made the programs look good afterwards. C isn&#x27;t the perfect language, no language is, but I think it has a lot of virtues, and you can avoid the parts you don&#x27;t like. I do like C as a language, especially because it blends in with the operating system (if you&#x27;re using UNIX, for example).<p>All through my life, I&#x27;ve always used the programming language that blended best with the debugging system and operating system that I&#x27;m using. If I had a better debugger for language X, and if X went well with the operating system, I would be using that.&quot;<p>Dec 7, 1993, Computer Literacy Bookshops Interview.</div><br/></div></div></div></div></div></div></div></div><div id="39578261" class="c"><input type="checkbox" id="c-39578261" checked=""/><div class="controls bullet"><span class="by">avinassh</span><span>|</span><a href="#39578100">prev</a><span>|</span><a href="#39578665">next</a><span>|</span><label class="collapse" for="c-39578261">[-]</label><label class="expand" for="c-39578261">[3 more]</label></div><br/><div class="children"><div class="content">Has anyone read this and also, Algorithm Design Manual by Skiena, I am wondering how do they compare.</div><br/><div id="39579059" class="c"><input type="checkbox" id="c-39579059" checked=""/><div class="controls bullet"><span class="by">spit2wind</span><span>|</span><a href="#39578261">parent</a><span>|</span><a href="#39578458">next</a><span>|</span><label class="collapse" for="c-39579059">[-]</label><label class="expand" for="c-39579059">[1 more]</label></div><br/><div class="children"><div class="content">I have read Skienas book, both the second and third edition. Love the idea. There is an errata nearly every other page for the second edition. Third edition appears better...for now. Someone needs to get this man a proper editor!<p>- <a href="https:&#x2F;&#x2F;www3.cs.stonybrook.edu&#x2F;~skiena&#x2F;algorist&#x2F;book&#x2F;errata" rel="nofollow">https:&#x2F;&#x2F;www3.cs.stonybrook.edu&#x2F;~skiena&#x2F;algorist&#x2F;book&#x2F;errata</a>
- <a href="https:&#x2F;&#x2F;www3.cs.stonybrook.edu&#x2F;~skiena&#x2F;algorist&#x2F;book&#x2F;errata-adm3" rel="nofollow">https:&#x2F;&#x2F;www3.cs.stonybrook.edu&#x2F;~skiena&#x2F;algorist&#x2F;book&#x2F;errata-...</a></div><br/></div></div><div id="39578458" class="c"><input type="checkbox" id="c-39578458" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#39578261">parent</a><span>|</span><a href="#39579059">prev</a><span>|</span><a href="#39578665">next</a><span>|</span><label class="collapse" for="c-39578458">[-]</label><label class="expand" for="c-39578458">[1 more]</label></div><br/><div class="children"><div class="content">I wrote a short rant about it a while ago [1].<p>--<p>1: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38855014">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38855014</a></div><br/></div></div></div></div><div id="39578665" class="c"><input type="checkbox" id="c-39578665" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#39578261">prev</a><span>|</span><label class="collapse" for="c-39578665">[-]</label><label class="expand" for="c-39578665">[10 more]</label></div><br/><div class="children"><div class="content">Honestly speaking most of these books just show&#x2F;illustrate how an existing algorithm works, not how to make an algorithm.<p>I don&#x27;t have a CS education but what I learned about algorithm thinking is this.<p>1. Trees- Use this if the solution to your problem involves searching a large search space. Trees comes in two types. Binary(Every node has only two child nodes) and K-ary(a node has many children). Building a tree involves putting data in the tree based on some logic(e.g- right node is less than the parent node, and left is greater than the parent node). Using this sort of logic every time one decides to left&#x2F;right, they are deciding not to traverse an entire sub-tree. Decreasing search space. These trees can be used to represent physical space. Like say representing a district&#x2F;county and its sub-areas as subtrees. Or words- Like imagine the words &#x27;application&#x27; and &#x27;apple&#x27; have first 4 common letters. So you can put this in a tree and decide to left&#x2F;right to check if a word exists in a tree(this is helpful in building spell checkers). Another example is a file system. Basically think of a tree anytime you have to a) Reduce search space. b) Makes less decisions. In fact tree is a way of making expensive computations in advance and putting them in a way accessing them is easy. There are efficient ways of traversing trees. Inorder, Preorder, Postorder traversals. Once you know these its easy as there are just 3 ways. Use these if your solution demands going &#x27;breadth first&#x27; or &#x27;depth first&#x27;.<p>2. Graphs- These are interconnected trees. Many use cases in everyday life involve Graphs. Roads, Weblinks, Family trees, Organisation hierarchies. These structures are used to represent data of similar nature. There are many common problems that have solutions that can use this.<p>3. Linked Lists- These are just plain lists. For eg- your file is represented as a LL. Things like a Twitter stream, or a shopping cart. Hence simple searching, sorting operations are done here.<p>Notice how these things are just lists or lists of lists. There are also many such structures which can help with efficient representation of data. Eg- A stack- Solutions where last come, first serve methods are needed. Queues- Solutions where first come, first serve methods are needed. Sets are another useful structure. They are helpful when finding, common elements and grouping needs between two groups. Another useful structure is a HashMap which allows fast look up. etc.<p>Algorithms-<p>1. Dynamic programming- If you are doing repeated computations often, you are better of doing it one, and looking up the result, instead of doing it over and over again.<p>2. Recursion- Solution builds from a base case, and can extended by using recently&#x2F;already computed values.<p>3. Bit Shifting- Its often a mistake to assume that common methods used for simple operations like addition, and multiplication are the fastest. There are other methods and these can save time.<p>4. Searching, and Sorting- Since most common use cases involved pre computing the data and accessing it, you need efficient means of storing them. Hence these algorithms come handy. There are only a handful of them, and once learned can be used to solve those category of problems.<p>5. Backtracking- Since the computer is not an oracle, and the only way of looking in the future we have is a for loop, some times we have to look ahead to realise it was a wrong move, take a step back and walk into a different branch of a tree. So chess, checkers, route planning etc are efficiently solved with these approaches.</div><br/><div id="39578932" class="c"><input type="checkbox" id="c-39578932" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39578665">parent</a><span>|</span><a href="#39578919">next</a><span>|</span><label class="collapse" for="c-39578932">[-]</label><label class="expand" for="c-39578932">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;d amend the definition of a graph to be something like, a graph is a set of nodes and a set of their relationships called edges. A tree is a special case of a graph where every node has exactly one relationship with its parent. Essentially, now that we know about N-aray trees where any node can have N many children, what about a datastructure where any node can have N many parents?<p>This avoids confusion with some non-optimal representations, like a list of trees and a list of edges between those trees. While that&#x27;s useful for some algorithms (for example, what&#x27;s called a least-single-common-ancestor (LSCA) tree and auxiliary list of edges, which can be used for efficiently finding the least common ancestor of two or more nodes), it&#x27;s really bad for most.<p>The logical build up from linked lists to trees to graphs is useful for practical applications.<p>It&#x27;s also useful to know that this is an abstraction and you can store everything in faster data structures like hashmaps and arrays to efficiently lookup tree or graph relationships.</div><br/><div id="39578948" class="c"><input type="checkbox" id="c-39578948" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#39578665">root</a><span>|</span><a href="#39578932">parent</a><span>|</span><a href="#39578919">next</a><span>|</span><label class="collapse" for="c-39578948">[-]</label><label class="expand" for="c-39578948">[4 more]</label></div><br/><div class="children"><div class="content">&gt;  A tree is a special case of a graph where every node has exactly one relationship with its parent.<p>Is a triangle a tree, a graph where every node has one parent and one child then?</div><br/><div id="39579020" class="c"><input type="checkbox" id="c-39579020" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39578665">root</a><span>|</span><a href="#39578948">parent</a><span>|</span><a href="#39578919">next</a><span>|</span><label class="collapse" for="c-39579020">[-]</label><label class="expand" for="c-39579020">[3 more]</label></div><br/><div class="children"><div class="content">No, since it&#x27;s undirected every node has two parents</div><br/><div id="39579037" class="c"><input type="checkbox" id="c-39579037" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#39578665">root</a><span>|</span><a href="#39579020">parent</a><span>|</span><a href="#39578919">next</a><span>|</span><label class="collapse" for="c-39579037">[-]</label><label class="expand" for="c-39579037">[2 more]</label></div><br/><div class="children"><div class="content">perhaps you should amend your amendment to make <i>directed</i> graph clear ?<p>Does that solve your problem?</div><br/><div id="39579046" class="c"><input type="checkbox" id="c-39579046" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39578665">root</a><span>|</span><a href="#39579037">parent</a><span>|</span><a href="#39578919">next</a><span>|</span><label class="collapse" for="c-39579046">[-]</label><label class="expand" for="c-39579046">[1 more]</label></div><br/><div class="children"><div class="content">I intentionally omitted direction from the description to avoid pedantry, because the problem I was highlighting was that &quot;interconnected trees&quot; is very wrong.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39578919" class="c"><input type="checkbox" id="c-39578919" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#39578665">parent</a><span>|</span><a href="#39578932">prev</a><span>|</span><a href="#39578721">next</a><span>|</span><label class="collapse" for="c-39578919">[-]</label><label class="expand" for="c-39578919">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if books try to present tree structures as in abstract space partitionning, instead of describing the final result first.</div><br/></div></div><div id="39578721" class="c"><input type="checkbox" id="c-39578721" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#39578665">parent</a><span>|</span><a href="#39578919">prev</a><span>|</span><a href="#39578765">next</a><span>|</span><label class="collapse" for="c-39578721">[-]</label><label class="expand" for="c-39578721">[1 more]</label></div><br/><div class="children"><div class="content">How to think about Big-O<p>Big-O has nothing to do with running things fast. Although its a welcome and a nice side effect. Big-O optimisation is basically a way of finding means to reduce <i>effort</i> required to do anything. It just happens when you take fewer steps to do a thing, you also in most cases make it run faster. Though making it run faster was never the goal. Hence you must stop thinking it terms of making a program run faster. This causes confusion given you are not thinking about the problem from first principles. For example writing a vim macro is going from many steps to one command. Hence writing a vim macro is a O(1) operations. There are many such everyday things where you are doing N steps, which can be automated to doing it in 1 step.<p>In programming parlance there is only one way big work is done. Its either done with a for loop, or nested for loops. That is <i>for(i=0;i&lt;SomethingBig;i++){&#x2F;&#x2F;do something with at speed of tick of i}</i> or <i>for(i=0;i&lt;SomethingBig;i++){for(j=0;j&lt;SomethingBig1;j++){&#x2F;&#x2F;do all of tick of j repeatedly, at the tick of i}}</i> Of course we can have as many sub loops, which in case the count of operations are i<i>j</i>...<p>Now here is how you think about making it efficient. Notice the i++ part of the for loop conditions to take the for loop forward? Most peoples minds are hard trained to think only in terms of i++, and nothing else. Hence it looks very hard to think anything else could work there. i++ moves the loop forward one element forward at a time. If you have a huge &#x27;SomethingBig&#x27; it can take an eternity to get there. How else can we make the counter run fast. Increase i++ to i+2 for eg, is one way. But there are other ways like multiplication for eg i * 2, would mean you are going way faster now, and saving computations. Basically finding how to do that is algorithmic optimisation.<p>Notice as mentioned above using a tree achieves many such tasks.</div><br/></div></div><div id="39578765" class="c"><input type="checkbox" id="c-39578765" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#39578665">parent</a><span>|</span><a href="#39578721">prev</a><span>|</span><a href="#39578771">next</a><span>|</span><label class="collapse" for="c-39578765">[-]</label><label class="expand" for="c-39578765">[1 more]</label></div><br/><div class="children"><div class="content">How to think about implementation of such things.<p>Since everything is a list, and then a list of lists. You must begin with learning atomic list operations. Them being-<p>1. Accessing the first element of a list.<p>2. Accessing the remainder of a list.<p>3. Using 1. and 2. You can iterate a list.<p>4. Once you can iterate a list, you can iterate two lists. To find common elements, or element common to lists based on a criteria.<p>5. Swap elements, store elements etc.<p>Ideally all operations can be built from learning list operations.</div><br/></div></div><div id="39578771" class="c"><input type="checkbox" id="c-39578771" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#39578665">parent</a><span>|</span><a href="#39578765">prev</a><span>|</span><label class="collapse" for="c-39578771">[-]</label><label class="expand" for="c-39578771">[1 more]</label></div><br/><div class="children"><div class="content">How to think about recursion<p>Finally the most easiest answer of all. Just don&#x27;t use for loops to do anything. Begin by imagining your programming language doesn&#x27;t have a for loop. Now write code. This is how you write recursive code.</div><br/></div></div></div></div></div></div></div></div></div></body></html>