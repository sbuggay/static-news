<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726045273281" as="style"/><link rel="stylesheet" href="styles.css?v=1726045273281"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gist.github.com/thoughtpolice/9c45287550a56b2047c6311fbadebed2">Some of us like &quot;interdiff&quot; code review</a> <span class="domain">(<a href="https://gist.github.com">gist.github.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>76 comments</span></div><br/><div><div id="41507798" class="c"><input type="checkbox" id="c-41507798" checked=""/><div class="controls bullet"><span class="by">mstachowiak</span><span>|</span><a href="#41506335">next</a><span>|</span><label class="collapse" for="c-41507798">[-]</label><label class="expand" for="c-41507798">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always exciting to see new approaches to code reviews - GitHub has its strengths, but it’s far from perfect.<p>For the scenario you’ve outlined, have you thought about splitting the 3 patches into separate, dependent pull requests? While GitHub doesn’t natively support this, the right code review tool (shameless plug - I’m part of a team building one called GitContext) should allow you to keep pull requests small while maintaining dependencies between them. For example, patch 3 can depend on patch 2, which in turn depends on patch 1. The dependency tracking between them - provided by the code review tool - can ensure everything is released in unison if that&#x27;s required.<p>Each patch can then be reviewed on its own, making feedback more targeted and easier to respond to. You can even squash commits within a pull request, ensuring a clean commit history with messages that accurately reflect the individual changes. Better still, with the right tool, you can use AI to summarize your pull request and review, streamlining the creation of accurate commit messages without all the manual effort.<p>A good code review tool also won’t get bogged down by git operations like rebases, merges, or force pushes. Reviewers should always see only the changes since their last review, no matter how many crazy git operations happen behind the scenes. That way, you avoid having to re-review large diffs and can focus on what’s new. The review history stays clean, separate from the commit history.<p>I&#x27;d be curious if this approach to splitting up pull requests and tracking their inter-dependencies would address your needs?</div><br/><div id="41509010" class="c"><input type="checkbox" id="c-41509010" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#41507798">parent</a><span>|</span><a href="#41508696">next</a><span>|</span><label class="collapse" for="c-41509010">[-]</label><label class="expand" for="c-41509010">[1 more]</label></div><br/><div class="children"><div class="content">As mentioned elsewhere in this thread, this is also the approach that Sapling follows.<p>As for GitContext, how do you keep track of commits across fixups, rebases, reordering, etc.?</div><br/></div></div><div id="41508696" class="c"><input type="checkbox" id="c-41508696" checked=""/><div class="controls bullet"><span class="by">fHr</span><span>|</span><a href="#41507798">parent</a><span>|</span><a href="#41509010">prev</a><span>|</span><a href="#41506335">next</a><span>|</span><label class="collapse" for="c-41508696">[-]</label><label class="expand" for="c-41508696">[1 more]</label></div><br/><div class="children"><div class="content">Why not just do good old mergetrains with pullrequest A points to branch B amd then B points to master, merge B into master and thereafter point A back to master or am I missing the point?</div><br/></div></div></div></div><div id="41506335" class="c"><input type="checkbox" id="c-41506335" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#41507798">prev</a><span>|</span><a href="#41506732">next</a><span>|</span><label class="collapse" for="c-41506335">[-]</label><label class="expand" for="c-41506335">[4 more]</label></div><br/><div class="children"><div class="content">100% agree that this is ideal, the way Github does it is completely godawful and it&#x27;s a tragedy that so many people have it normalized for them.<p>We did this with Phabricator, although it was a somewhat-manual process, helped along by having some command line macros for updating all the reviews at once. But better still would be an explicit UI for it.</div><br/><div id="41506500" class="c"><input type="checkbox" id="c-41506500" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506335">parent</a><span>|</span><a href="#41506732">next</a><span>|</span><label class="collapse" for="c-41506500">[-]</label><label class="expand" for="c-41506500">[3 more]</label></div><br/><div class="children"><div class="content">I am the author and used the phrase &quot;Code review is a pretty good idea, in general&quot; in the opening very specifically, because it used be one of the selling points listed on the Phabricator homepage. :) I miss it.</div><br/><div id="41506697" class="c"><input type="checkbox" id="c-41506697" checked=""/><div class="controls bullet"><span class="by">taspeotis</span><span>|</span><a href="#41506335">root</a><span>|</span><a href="#41506500">parent</a><span>|</span><a href="#41506732">next</a><span>|</span><label class="collapse" for="c-41506697">[-]</label><label class="expand" for="c-41506697">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Grab ahold of tasks, literally. Place them in confusing, new orders. Make a column just for interns! Ignore the backlog forever.<p>I swear the Herald selling points also had keeping tabs on the pesky interns, or something to that effect.</div><br/><div id="41506755" class="c"><input type="checkbox" id="c-41506755" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506335">root</a><span>|</span><a href="#41506697">parent</a><span>|</span><a href="#41506732">next</a><span>|</span><label class="collapse" for="c-41506755">[-]</label><label class="expand" for="c-41506755">[1 more]</label></div><br/><div class="children"><div class="content">One of my favorites was something like:<p>&gt; Phabricator is well received, and has raging reviews from users inside Facebook, such as &quot;Mandatory&quot; and &quot;OK&quot;<p>Also, Evan Priestley still uses the <a href="https:&#x2F;&#x2F;secure.phabricator.com" rel="nofollow">https:&#x2F;&#x2F;secure.phabricator.com</a> instance to occasionally post life updates, so I check in on it.<p>Last I checked he was learning about PCB design and printing. I think he wanted to learn how to actually physically manufacture his own boards (e.g. etching your own conductive copper layers) and then he posted some update like &quot;I&#x27;m not sure I&#x27;ll go down this route, because it turns out you can send your design to PCBWay, and it will come back within 5 days, because there is a magical PCB Faucet somewhere in Shenzen apparently.&quot;<p>What a guy.</div><br/></div></div></div></div></div></div></div></div><div id="41506732" class="c"><input type="checkbox" id="c-41506732" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41506335">prev</a><span>|</span><a href="#41506477">next</a><span>|</span><label class="collapse" for="c-41506732">[-]</label><label class="expand" for="c-41506732">[5 more]</label></div><br/><div class="children"><div class="content">Yes! This is what I imagine in my head as a real code review style, not the stuff Github does. Glad to have a name for it.<p>I&#x27;d add I&#x27;d also like my review system to be able to kick patches &quot;out&quot; of the review once they&#x27;re ready. E.g., the small bugfixes that you make while working on that bigger feature should hopefully be small, isolated patches, ones that are going to find consensus with a reviewer quite quickly. Once that happens … I want to just eject that patch from the entire series &amp; cherry-pick it to main, and rebase the review on the new HEAD. (Or, differently, rebase the latest version of the patch series on main, reordered such that the agreed patch is fist, and then FF main onto that agreed upon patch.)<p>Essentially, narrow the scope of the review to &quot;the part we&#x27;re still talking about&quot;, but let bug fixes see merging as soon as they&#x27;re ready.<p>The argument I&#x27;d have against this is &quot;just make that a separate review&#x2F;PR&quot;. But then you get into the hairiness of patchset A depends on patchset B, until B is merged, then it just depends on main.</div><br/><div id="41506787" class="c"><input type="checkbox" id="c-41506787" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506732">parent</a><span>|</span><a href="#41506767">next</a><span>|</span><label class="collapse" for="c-41506787">[-]</label><label class="expand" for="c-41506787">[3 more]</label></div><br/><div class="children"><div class="content">I keep saying this over and over but, Gerrit basically does that. :) You can see the relationships between any two patches on Gerrit, and more importantly, Gerrit shows you <i>each patch individually</i>. So you can see in a series A -&gt; B -&gt; C that yeah, B is small, let&#x27;s go ahead and get that in.<p>Part of this is that UX has some really smart ideas like the &quot;Attention Set&quot;. The attention set is basically &quot;Which people need to take the next step?&quot; Like a turn-based game. So, if you just did a review, you&#x27;re not in the attention set for that patch anymore -- the <i>author</i> is.<p>That means Gerrit puts it down at the bottom of your queue in the UX. And what&#x27;s at the top of the queue? Things where <i>you</i> are in the attention set! So it naturally groups things this way.<p>I didn&#x27;t get into all the other really annoying papercuts with GitHub&#x27;s UX, but even the pull request listing is worse than the alternatives. How do you know what state <i>anything</i> is in? You don&#x27;t, you have to go read the whole thing.</div><br/><div id="41507022" class="c"><input type="checkbox" id="c-41507022" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#41506732">root</a><span>|</span><a href="#41506787">parent</a><span>|</span><a href="#41506936">next</a><span>|</span><label class="collapse" for="c-41507022">[-]</label><label class="expand" for="c-41507022">[1 more]</label></div><br/><div class="children"><div class="content">I guess I missed it in your article, and I&#x27;ve never had the opportunity otherwise to use Gerrit. (Since Github is essentially so pervasive. I&#x27;ve only used that, Gitlab, and an internal review system that didn&#x27;t do interdiff.)</div><br/></div></div><div id="41506936" class="c"><input type="checkbox" id="c-41506936" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41506732">root</a><span>|</span><a href="#41506787">parent</a><span>|</span><a href="#41507022">prev</a><span>|</span><a href="#41506767">next</a><span>|</span><label class="collapse" for="c-41506936">[-]</label><label class="expand" for="c-41506936">[1 more]</label></div><br/><div class="children"><div class="content">Attention Set &lt;3 - that alone is worth another post. Gerrit really is one of the best kept dev secrets, and if you never had the luck of seeing it in person at a company where you worked at, well...<p>Makes me wonder what other git or dev-in-general blindspots I have.</div><br/></div></div></div></div><div id="41506767" class="c"><input type="checkbox" id="c-41506767" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41506732">parent</a><span>|</span><a href="#41506787">prev</a><span>|</span><a href="#41506477">next</a><span>|</span><label class="collapse" for="c-41506767">[-]</label><label class="expand" for="c-41506767">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what Gerrit can do. When you push an x-b-c-d-e chain, these show up stacked in the UI, but you can easily cherry-pick b onto main (see that the CI passes, and the usual review), and rebase everything on top of that. If it is x, the bottom one, you can directly submit it and continue with the others.</div><br/></div></div></div></div><div id="41506477" class="c"><input type="checkbox" id="c-41506477" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506732">prev</a><span>|</span><a href="#41506525">next</a><span>|</span><label class="collapse" for="c-41506477">[-]</label><label class="expand" for="c-41506477">[7 more]</label></div><br/><div class="children"><div class="content">I am the person who wrote this. AMA<p>EDIT: Also, I&#x27;m not sure if this is against the rules, but I also need a new job as of recently. I like working on dev tools and other hard problems. If you liked reading this, want me to make your dev team more productive, or just want to experience and enjoy my excellent (and occasionally <i>eclectic</i>) taste, the email is in my profile.</div><br/><div id="41506652" class="c"><input type="checkbox" id="c-41506652" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41506477">parent</a><span>|</span><a href="#41506528">next</a><span>|</span><label class="collapse" for="c-41506652">[-]</label><label class="expand" for="c-41506652">[4 more]</label></div><br/><div class="children"><div class="content">From my interaction with the free part of GitHub, &quot;diff soup&quot; describes it very well. Does the paid version do anything better? What about GitLab, can this get near Gerrit? And then there are the external services which try to make GitHub less painful (and quite pricey, especially compared to a selfhosted Gerrit), by providing stacked diff support, did you look at these?</div><br/><div id="41506677" class="c"><input type="checkbox" id="c-41506677" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506477">root</a><span>|</span><a href="#41506652">parent</a><span>|</span><a href="#41506528">next</a><span>|</span><label class="collapse" for="c-41506677">[-]</label><label class="expand" for="c-41506677">[3 more]</label></div><br/><div class="children"><div class="content">No, paying for GH doesn&#x27;t make the code review experience any better. It&#x27;s identical across public&#x2F;cloud&#x2F;enterprise GH.<p>I do not know if GitLab does anything different; I&#x27;ve never used it in anger. I&#x27;d bet $10 the answer is &quot;no, it&#x27;s basically just the same as GitHub&quot;, though.<p>If you want a service that adds stacking on top of GitHub, my conclusion after some research is that <a href="https:&#x2F;&#x2F;graphite.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;graphite.dev&#x2F;</a> is the best option. We did consider it, but it couldn&#x27;t work in my last job for &quot;reasons&quot; (see my other replies in this thread) but if you&#x27;ve got a shop of Git users and just want to throw money at the problem, I think it&#x27;s the best choice.<p>GerritHub is also a possibility, they employ many of the Gerrit devs and know what they&#x27;re doing, but holy shit the corporate options are expensive out of the gate. It&#x27;s like $20k&#x2F;yr minimum regardless of size or number of users.<p>Honestly, Graphite is cheap as hell considering how much more productive your engineers can be with a good review tool. Gerrit was basically night and day for us. It&#x27;s not &quot;oh, it pays for itself really quickly in a few days!&quot; You&#x27;d probably pay off the monthly cost in less than an <i>hour</i> of actual code review. And you don&#x27;t even have to opt most of your engineers in; you can trial it where 90% of them use GH and only a subset use graphite and pay.</div><br/><div id="41506743" class="c"><input type="checkbox" id="c-41506743" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41506477">root</a><span>|</span><a href="#41506677">parent</a><span>|</span><a href="#41508732">next</a><span>|</span><label class="collapse" for="c-41506743">[-]</label><label class="expand" for="c-41506743">[1 more]</label></div><br/><div class="children"><div class="content">Right, for Graphite $20&#x2F;dev&#x2F;month is nothing (I wonder if Enterprise is less or more more than that...), considering an ounce of review (prevention) is worth a pound of bugfixes (cure).<p>And when you can not get corporate to switch away from GH, then that is it. In hindsight an obvious way to (almost) print money, congratulations, but also a sad state of affairs.<p>But I imagine the $20k&#x2F;yr is something you can easily spend on a 1&#x2F;5 of a dev doing Gerrit maintenance.</div><br/></div></div><div id="41508732" class="c"><input type="checkbox" id="c-41508732" checked=""/><div class="controls bullet"><span class="by">fHr</span><span>|</span><a href="#41506477">root</a><span>|</span><a href="#41506677">parent</a><span>|</span><a href="#41506743">prev</a><span>|</span><a href="#41506528">next</a><span>|</span><label class="collapse" for="c-41508732">[-]</label><label class="expand" for="c-41508732">[1 more]</label></div><br/><div class="children"><div class="content">Never going to understand those finance teams who think like 20k&#x2F;yr for any enterprise deal is a good deal to onboard more customers and increase reach.</div><br/></div></div></div></div></div></div><div id="41506528" class="c"><input type="checkbox" id="c-41506528" checked=""/><div class="controls bullet"><span class="by">rosmax_1337</span><span>|</span><a href="#41506477">parent</a><span>|</span><a href="#41506652">prev</a><span>|</span><a href="#41506525">next</a><span>|</span><label class="collapse" for="c-41506528">[-]</label><label class="expand" for="c-41506528">[2 more]</label></div><br/><div class="children"><div class="content">What is the meaning of life?</div><br/><div id="41506717" class="c"><input type="checkbox" id="c-41506717" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506477">root</a><span>|</span><a href="#41506528">parent</a><span>|</span><a href="#41506525">next</a><span>|</span><label class="collapse" for="c-41506717">[-]</label><label class="expand" for="c-41506717">[1 more]</label></div><br/><div class="children"><div class="content">I know this is in jest, but I&#x27;ll just take the opportunity to respond by posting my favorite poem. The relationship between it and your question -- well, that&#x27;s for you to decide.<p><pre><code>    The birds have vanished down the sky.
    Now the last cloud drains away.
    We sit together, the mountain and me,
    until only the mountain remains.
</code></pre>
-- Zazen on Ching-t’ing Mountain</div><br/></div></div></div></div></div></div><div id="41506525" class="c"><input type="checkbox" id="c-41506525" checked=""/><div class="controls bullet"><span class="by">chipx86</span><span>|</span><a href="#41506477">prev</a><span>|</span><a href="#41506080">next</a><span>|</span><label class="collapse" for="c-41506525">[-]</label><label class="expand" for="c-41506525">[3 more]</label></div><br/><div class="children"><div class="content">We first built interdiffs in Review Board [<a href="https:&#x2F;&#x2F;www.reviewboard.org" rel="nofollow">https:&#x2F;&#x2F;www.reviewboard.org</a>] way back in 2006 (in fact I think I may have coined the term, or arrived at it independently). It&#x27;s still my favorite part of the product and my process when doing code reviews. And it&#x27;s one of the things we hear the most nostalgia for when people move to something like GitHub.<p>I&#x27;ve never felt that fix-it commits are really a proper alternative, since:<p>1) They don&#x27;t tell you what upstream changes have been incorporated into a series of commits.<p>2) They tend to mess up the commit graph, even if temporarily, and make it more difficult to review. If you&#x27;ve been following along with a review, you may have already read the code being fixed in fix-it commits, but if you&#x27;re coming in fresh, you may start off with a bad sense of what that code&#x27;s trying to do or how it&#x27;s structured.<p>3) Not everyone uses Git or other multi-commit-capable SCMs. Plenty of people are on Perforce (such as in gamedev) or on specialized SCMs like Keysight SOS (such as chip manufacturers). So fix-it commits aren&#x27;t even an option there.<p>A proper interdiff-capable code review systems means one reviewer can start off from the first published review request and follow along with every update, seeing only what&#x27;s changed, while another can jump in to the latest full change and not have to worry about the series of fix-its that led up to it. And it can do this regardless of the SCM.<p>If done right, it can also exist alongside multi-commit changes.<p>Let&#x27;s say I have a small project I&#x27;ve broken up into multiple commits to help with the review process (say, an API handler, front-end UI, and documentation), and have decided this is suitable for posting as one review request (since the commits are largely interrelated and having these as one change helps lend context to the reviewers — if they aren&#x27;t, multiple review requests in a dependency chain are probably ideal).<p>Based on review feedback, I may end up making a series of changes to one or all of those commits. When people go to review my updates, it&#x27;s nice to be able to see how each piece evolved, without trying to do the mental arithmetic of mapping fix-it commits and their changes to their corresponding changes.<p>So yes, interdiffs are fantastic! More people should use them, whether they&#x27;re working with lots of small commits or large commits, single-commit review requests or multi-commit.</div><br/><div id="41506618" class="c"><input type="checkbox" id="c-41506618" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506525">parent</a><span>|</span><a href="#41506080">next</a><span>|</span><label class="collapse" for="c-41506618">[-]</label><label class="expand" for="c-41506618">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s sick as hell, friend. Actually, I have a second part to this article discussing some of the history and politics of what brought me to these tools.<p>In about 2013, I migrated the Glasgow Haskell Compiler from &quot;read .patch files on bug reporter&quot; that I joked about, to using Phabricator. For a couple reasons, but at the time one of them was <i>not</i> stacked diffs. It was because GitHub was so bad for review it didn&#x27;t even have <i>side-by-side diffs</i>! It was a total non-starter for me for those reasons among others.<p>But that actually wasn&#x27;t the first time I migrated a team to a code review tool. My first job in 2009 was a very small tight knit team of engineers in a single room in Houston, and I remember thinking it would be really good to get reviews of my code from other people, and to read the things they wrote so I could better understand the codebase. So, the first thing I did in the first few months was pester my manager to set up... ReviewBoard! And we all really liked it.<p>So I guess this is a way of saying thanks for RB! I still think of it fondly from time to time. And because of it, Code Review has always just been a huge part of my career, almost since day one (and I could still do more of it.)</div><br/><div id="41506722" class="c"><input type="checkbox" id="c-41506722" checked=""/><div class="controls bullet"><span class="by">chipx86</span><span>|</span><a href="#41506525">root</a><span>|</span><a href="#41506618">parent</a><span>|</span><a href="#41506080">next</a><span>|</span><label class="collapse" for="c-41506722">[-]</label><label class="expand" for="c-41506722">[1 more]</label></div><br/><div class="children"><div class="content">I love that! Thanks for sharing that with me :) It made my day. Looking forward to the second part! If you&#x27;re on really any of the current social platforms, I&#x27;d love to connect. I&#x27;m chipx86 everywhere.<p>I still develop Review Board full-time with a small team :) The development world has changed a lot, and much of the world has converged on GitHub (it&#x27;s a hard market to be in right now), so we still look for opportunities to build review capabilities that target problems people have that aren&#x27;t being addressed elsewhere.<p>Just as an example, we launched PDF Review and diffing a while back, which we see companies use for things like industrial designs and schematics. It&#x27;s neat, we actually diff two rendered PDFs without just converting them into text files first, like you usually see. Following that up with full Office Document Review soon.<p>Dark mode <i>finally</i> shipped earlier this year (I should write about that endeavor sometime). And there&#x27;s a couple of super-neat code review capabilities we&#x27;ve come up with that nobody&#x27;s doing, which I&#x27;m keeping under wraps for next year. I think they&#x27;re going to be pretty awesome.</div><br/></div></div></div></div></div></div><div id="41506080" class="c"><input type="checkbox" id="c-41506080" checked=""/><div class="controls bullet"><span class="by">zdw</span><span>|</span><a href="#41506525">prev</a><span>|</span><a href="#41509301">next</a><span>|</span><label class="collapse" for="c-41506080">[-]</label><label class="expand" for="c-41506080">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve generally found that code review first, and rebase-centric systems like Gerrit tend to be much easier to review code in.  One of the best parts of this is native support for stacking multiple patches, so people make smaller patches that are easier to review.<p>Code review in Github feels like a bad afterthought - the space-wasting interface that looks more like a forum thread, the inability to track over rebases, etc.</div><br/><div id="41506789" class="c"><input type="checkbox" id="c-41506789" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41506080">parent</a><span>|</span><a href="#41509301">next</a><span>|</span><label class="collapse" for="c-41506789">[-]</label><label class="expand" for="c-41506789">[1 more]</label></div><br/><div class="children"><div class="content">There is one thing I miss on Gerrit when you push a stack of commits: A central place to talk about the whole of the stack, not just individual commits. This &quot;big picture&quot;, but still technical stuff, too often happens in the issue tracker. But where to place it, I have no idea. This stack is just too ephemeral and and can be completely different on the next push.</div><br/></div></div></div></div><div id="41509301" class="c"><input type="checkbox" id="c-41509301" checked=""/><div class="controls bullet"><span class="by">snatchpiesinger</span><span>|</span><a href="#41506080">prev</a><span>|</span><a href="#41506210">next</a><span>|</span><label class="collapse" for="c-41509301">[-]</label><label class="expand" for="c-41509301">[3 more]</label></div><br/><div class="children"><div class="content">Another way to look at this that this is 3 linearly dependent PRs masquerading as one. Make each a distinct PR and the problem goes away, especially if you can mark the PR to depend on another one (on Gitlab you can, not sure about Github). If you want to see each change as a single logical unit, then they will each be a distinct merge commit on your master branch, use `git log --first-parent-only master` to only see these kind of changes.</div><br/><div id="41509438" class="c"><input type="checkbox" id="c-41509438" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41509301">parent</a><span>|</span><a href="#41509319">next</a><span>|</span><label class="collapse" for="c-41509438">[-]</label><label class="expand" for="c-41509438">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [GitLab] you can mark the PR to depend on another<p>How much user interaction does that require, and how is this visualized in the review UI? Gerrit creates this dependency with a single `git push`.</div><br/></div></div></div></div><div id="41506210" class="c"><input type="checkbox" id="c-41506210" checked=""/><div class="controls bullet"><span class="by">ams92</span><span>|</span><a href="#41509301">prev</a><span>|</span><a href="#41508989">next</a><span>|</span><label class="collapse" for="c-41506210">[-]</label><label class="expand" for="c-41506210">[21 more]</label></div><br/><div class="children"><div class="content">Most of the complaints here could be solved by having smaller pull requests and then squashing commits when it’s time to merge.</div><br/><div id="41506261" class="c"><input type="checkbox" id="c-41506261" checked=""/><div class="controls bullet"><span class="by">eximius</span><span>|</span><a href="#41506210">parent</a><span>|</span><a href="#41506401">next</a><span>|</span><label class="collapse" for="c-41506261">[-]</label><label class="expand" for="c-41506261">[1 more]</label></div><br/><div class="children"><div class="content">Well, yes. Or by having stacked branches and rebasing your branches, etc.<p>The point is that GitHub&#x2F;git&#x27;s default experience makes this harder to do than a system that bakes it in.</div><br/></div></div><div id="41506401" class="c"><input type="checkbox" id="c-41506401" checked=""/><div class="controls bullet"><span class="by">lozenge</span><span>|</span><a href="#41506210">parent</a><span>|</span><a href="#41506261">prev</a><span>|</span><a href="#41508815">next</a><span>|</span><label class="collapse" for="c-41506401">[-]</label><label class="expand" for="c-41506401">[6 more]</label></div><br/><div class="children"><div class="content">Not really. The idea is to split work into separate stages which are reviewed separately, but as a whole.<p>In the example: &quot;small refactor 25LOC -&gt; new API 500LOC -&gt; migrate API users 50LOC&quot;<p>Making a PR of the small refactor will probably garner comments about &quot;why is this necessary&quot;.<p>Opening two PRs at the same time is clutter as GitHub presents them as separate.<p>As well, sometimes CI won&#x27;t pass on one of the stages meaning it can&#x27;t be a separate PR, but it would still be useful in the code review to see it as a separate stage.</div><br/><div id="41506816" class="c"><input type="checkbox" id="c-41506816" checked=""/><div class="controls bullet"><span class="by">danparsonson</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506401">parent</a><span>|</span><a href="#41506601">next</a><span>|</span><label class="collapse" for="c-41506816">[-]</label><label class="expand" for="c-41506816">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be quite happy with seeing the three jobs in the article as three separate PRs. Fixing a bug and adding a feature are two jobs that, as I think we all agree, need to be tracked individually - so work on them individually.<p>&gt; As well, sometimes CI won&#x27;t pass on one of the stages meaning it can&#x27;t be a separate PR<p>Could you give an example of this? Not sure what you mean.</div><br/><div id="41506977" class="c"><input type="checkbox" id="c-41506977" checked=""/><div class="controls bullet"><span class="by">Forge36</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506816">parent</a><span>|</span><a href="#41506601">next</a><span>|</span><label class="collapse" for="c-41506977">[-]</label><label class="expand" for="c-41506977">[3 more]</label></div><br/><div class="children"><div class="content">Commits aren&#x27;t always perfect.<p>Sometimes I&#x27;ll make the unit test first, which fails CI and the next set of commits implements the behavior.</div><br/><div id="41509190" class="c"><input type="checkbox" id="c-41509190" checked=""/><div class="controls bullet"><span class="by">trashburger</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506977">parent</a><span>|</span><a href="#41506601">next</a><span>|</span><label class="collapse" for="c-41509190">[-]</label><label class="expand" for="c-41509190">[2 more]</label></div><br/><div class="children"><div class="content">By doing this, you break commit atomicity and make bisects hell. Please don’t do this. Commits aren’t perfect at first for sure, but they should be by the time you make them reviewable.</div><br/><div id="41509332" class="c"><input type="checkbox" id="c-41509332" checked=""/><div class="controls bullet"><span class="by">snatchpiesinger</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41509190">parent</a><span>|</span><a href="#41506601">next</a><span>|</span><label class="collapse" for="c-41509332">[-]</label><label class="expand" for="c-41509332">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fine to break commit atomicity on feature branches. You can use git bisect --first-parent on you development&#x2F;master branch.</div><br/></div></div></div></div></div></div></div></div><div id="41506601" class="c"><input type="checkbox" id="c-41506601" checked=""/><div class="controls bullet"><span class="by">john_the_writer</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506401">parent</a><span>|</span><a href="#41506816">prev</a><span>|</span><a href="#41508815">next</a><span>|</span><label class="collapse" for="c-41506601">[-]</label><label class="expand" for="c-41506601">[1 more]</label></div><br/><div class="children"><div class="content">the comments about &quot;why is this necessary&quot; can be handled with a decent PR template, and a comment.<p>What I tend to do is make the changes locally with different commits and then cherry pick the refactor into a PR branch and wait for that to be accepted. Then I rebase the FULL branch with &quot;master&quot; after the merge and create the PR.</div><br/></div></div></div></div><div id="41508815" class="c"><input type="checkbox" id="c-41508815" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41506210">parent</a><span>|</span><a href="#41506401">prev</a><span>|</span><a href="#41506340">next</a><span>|</span><label class="collapse" for="c-41508815">[-]</label><label class="expand" for="c-41508815">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s like a caveman approach to the problem. Imagine the extra overhead required to submit the &quot;refactor&quot; commit. The result world be either nobody refactors or refactors are just bundled into the feature commit so it&#x27;s never clear what you&#x27;re actually reviewing.</div><br/></div></div><div id="41506340" class="c"><input type="checkbox" id="c-41506340" checked=""/><div class="controls bullet"><span class="by">gloryjulio</span><span>|</span><a href="#41506210">parent</a><span>|</span><a href="#41508815">prev</a><span>|</span><a href="#41508737">next</a><span>|</span><label class="collapse" for="c-41506340">[-]</label><label class="expand" for="c-41506340">[11 more]</label></div><br/><div class="children"><div class="content">We use stacked commits + rebase only in our company. The commit history is linear and it&#x27;s very easy to revert changes. I don&#x27;t see any advantage of using merging instead of rebase<p>I am not sure why we need to squash commits. We encourage the opposite where you should commit small and often. So if we need to revert any commit, it&#x27;s less painful to do so.</div><br/><div id="41506431" class="c"><input type="checkbox" id="c-41506431" checked=""/><div class="controls bullet"><span class="by">majormajor</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506340">parent</a><span>|</span><a href="#41506603">next</a><span>|</span><label class="collapse" for="c-41506431">[-]</label><label class="expand" for="c-41506431">[5 more]</label></div><br/><div class="children"><div class="content">Without squashing it&#x27;s hard for me to commit as small and often as I would like.<p>Some things I want out of the final series of commits:<p>1) everything builds. If I need to revert something or roll back a commit, the resulting point of the codebase is valid and functional and has all passing tests.<p>2) features are logically grouped and consistent - kinda similar to the first, but it&#x27;s not just that I want the build to pass, I don&#x27;t want, say, module A to be not yet ready for feature flag X but module B to expect the feature flag to work. In the original article, this is to say that I want the three commits listed, but not one halfway through the &quot;migrate API users&quot; step.<p>But when I&#x27;m developing I <i>do</i> want to commit halfway through steps. I might commit 50 lines of changes that I&#x27;m confident in and then try the next 50 lines and decide I want to throw them away and try a different way. I might just want to push a central copy of what I&#x27;ve got at the end of the day in case my laptop breaks overnight (it&#x27;s rare, but happens!). I might want to push something WIP for a coworker to take an initial look at with no intent of it being ready to land.<p>But I don&#x27;t want any of those inconsistent&#x2F;not-buildable&#x2F;not-runnable states to be in the permanent history. It fucks with things like git bisect and git blame.</div><br/><div id="41509051" class="c"><input type="checkbox" id="c-41509051" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506431">parent</a><span>|</span><a href="#41506505">next</a><span>|</span><label class="collapse" for="c-41509051">[-]</label><label class="expand" for="c-41509051">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s an ambiguity here between squashing every commit in the PR into a single one, and squashing fixup commits made as responses to review into the commits that originated them.<p>For example, if the original commit series was<p><pre><code>    Do a small refactor before I can start adding the test
    Add the test for the feature
    Do a small refactor before I can start adding the feature
    Work in progress
    Complete sub-feature 1
    Work in progress
    lint
    lint
    Complete sub-feature 2
    Respond to reviewer 1 comments
    Respond to reviewer 2 comments
</code></pre>
Then you can either squash the entire PR down to<p><pre><code>    Implement feature
</code></pre>
or you can, using interactive rebase, squash (or more precisely fixup) individual WIP, lint, and response commits into where they belong to obtain<p><pre><code>    Do a small refactor before I can start adding the test
    Do a small refactor before I can start adding the feature
    Complete sub-feature 1
    Complete sub-feature 2
</code></pre>
where each commit individually builds and passes tests.  I <i>far</i> prefecr the latter!</div><br/></div></div><div id="41506505" class="c"><input type="checkbox" id="c-41506505" checked=""/><div class="controls bullet"><span class="by">gloryjulio</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506431">parent</a><span>|</span><a href="#41509051">prev</a><span>|</span><a href="#41506603">next</a><span>|</span><label class="collapse" for="c-41506505">[-]</label><label class="expand" for="c-41506505">[3 more]</label></div><br/><div class="children"><div class="content">When we publish a stack of commits, our ci ensures that every commit is build and tested individually. There is no consistency issue<p>Squash and merge actually makes the above goal harder. With rebase + small commits, all we need to make sure is that every commit pass all the build signals and tests during ci</div><br/><div id="41506647" class="c"><input type="checkbox" id="c-41506647" checked=""/><div class="controls bullet"><span class="by">john_the_writer</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506505">parent</a><span>|</span><a href="#41506603">next</a><span>|</span><label class="collapse" for="c-41506647">[-]</label><label class="expand" for="c-41506647">[2 more]</label></div><br/><div class="children"><div class="content">This only works if your commit in a green state.  Sometimes we have to change when things are still &quot;Yellow&quot;..<p>I tend to add all my tests in one go and commit the RED.  &quot;tests are written&quot; Then as I pass each test, I commit that.<p>This pattern works really well for me because if I mess up, then rolling back to the last yellow is easy. I can also WIP commit if I have to fix an urgent bug, and then get back to the WIP later.</div><br/><div id="41506669" class="c"><input type="checkbox" id="c-41506669" checked=""/><div class="controls bullet"><span class="by">gloryjulio</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506647">parent</a><span>|</span><a href="#41506603">next</a><span>|</span><label class="collapse" for="c-41506669">[-]</label><label class="expand" for="c-41506669">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what you mean... When we ship a stack of commits, every commit has to pass everything in CI. You are not suppose to ship a commit that&#x27;s not passing the ci bar. There is a escape hatch that you can bypass but it&#x27;s rarely used.<p>You can make changes before you ship however you wanted as long as they pass ci. If you already shipped the code and want to make changes later, that means making new commit or reverting a bad commit. It&#x27;s simple as that</div><br/></div></div></div></div></div></div></div></div><div id="41506603" class="c"><input type="checkbox" id="c-41506603" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506340">parent</a><span>|</span><a href="#41506431">prev</a><span>|</span><a href="#41508737">next</a><span>|</span><label class="collapse" for="c-41506603">[-]</label><label class="expand" for="c-41506603">[5 more]</label></div><br/><div class="children"><div class="content">My experience is that systemically squashing PRs enables a &quot;fire and forget&quot; style where you can add a bunch of small commits to your PR to address reviews and CI failures without worrying about making them fit a narrative of &quot;these are the commits my PR is made of&quot;.<p>On a more concrete level, squashing PRs means every single commit is guaranteed to pass CI (assuming you also use merge queues) which is helpful when bisecting.</div><br/><div id="41506627" class="c"><input type="checkbox" id="c-41506627" checked=""/><div class="controls bullet"><span class="by">gloryjulio</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506603">parent</a><span>|</span><a href="#41508737">next</a><span>|</span><label class="collapse" for="c-41506627">[-]</label><label class="expand" for="c-41506627">[4 more]</label></div><br/><div class="children"><div class="content">With stacked commits, every commit is already passing CI though.<p>To us the mental model is minimum. All you need to do is to make sure each commit pass CI. You can ship any number of stacked commits together<p>----------------------------------------------------------------------------------------------------<p>Not sure why I can&#x27;t reply in a technical discussion. I have to edit to answer your question @danparsonson<p>&gt; if I&#x27;m working on a long series of changes across multiple days, and halfway through it the code doesn&#x27;t build yet?<p>That&#x27;s why you break them down into small commits. The early you push it to CI, the earlier you will know whether each commit builds. For example, push commit 1 2 3 to the CI when they are ready. When the CI is running, you are working on commit 4 5 6<p>&gt; The code won&#x27;t pass CI because I&#x27;m not finished, but I want to commit my progress<p>If your commit 1,2,3 are ready, just ship them. It doesn&#x27;t stop you have a few commits in reviews and a few WIP commits. There is no down time</div><br/><div id="41506773" class="c"><input type="checkbox" id="c-41506773" checked=""/><div class="controls bullet"><span class="by">danparsonson</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506627">parent</a><span>|</span><a href="#41508737">next</a><span>|</span><label class="collapse" for="c-41506773">[-]</label><label class="expand" for="c-41506773">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps I misunderstand you but what if I&#x27;m working on a long series of changes across multiple days, and halfway through it the code doesn&#x27;t build yet? The code won&#x27;t pass CI because I&#x27;m not finished, but I want to commit my progress so I don&#x27;t lose it if something goes wrong, and I can roll back if make mistakes.</div><br/><div id="41509057" class="c"><input type="checkbox" id="c-41509057" checked=""/><div class="controls bullet"><span class="by">tome</span><span>|</span><a href="#41506210">root</a><span>|</span><a href="#41506773">parent</a><span>|</span><a href="#41506966">next</a><span>|</span><label class="collapse" for="c-41509057">[-]</label><label class="expand" for="c-41509057">[1 more]</label></div><br/><div class="children"><div class="content">Then fix up the commit history at the end, for example like this:  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41509051">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41509051</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41508737" class="c"><input type="checkbox" id="c-41508737" checked=""/><div class="controls bullet"><span class="by">fHr</span><span>|</span><a href="#41506210">parent</a><span>|</span><a href="#41506340">prev</a><span>|</span><a href="#41508989">next</a><span>|</span><label class="collapse" for="c-41508737">[-]</label><label class="expand" for="c-41508737">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I don&#x27;t see the point, why not just use mergetrains?</div><br/></div></div></div></div><div id="41508989" class="c"><input type="checkbox" id="c-41508989" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#41506210">prev</a><span>|</span><a href="#41506898">next</a><span>|</span><label class="collapse" for="c-41508989">[-]</label><label class="expand" for="c-41508989">[1 more]</label></div><br/><div class="children"><div class="content">Nice article, it captures the issues I&#x27;ve had with code reviews very well. I&#x27;m just not sure the &quot;pairwise diff&quot; would work well in practice. Sometimes you do forget a change which should be separate commit (in between the existing commits), etc.<p>I recently got introduced to Sapling, specifically to the approach of never merging more than a single commit and also doing code reviews commit by commit. I like that idea even better!<p>Of course with existing tools like git &amp; GitHub this seems rather difficult to implement, but Sapling automatically keeps track of how commits change across fixups &amp; rebases, and it also handles entire &quot;stacks&quot; of merge requests &#x2F; commits.</div><br/></div></div><div id="41506898" class="c"><input type="checkbox" id="c-41506898" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41508989">prev</a><span>|</span><a href="#41506292">next</a><span>|</span><label class="collapse" for="c-41506898">[-]</label><label class="expand" for="c-41506898">[1 more]</label></div><br/><div class="children"><div class="content">This is interesting. At work we use PRs like the author uses commits, and in fact we squash-and-merge them at the end, but our approach requires rebasing the later PRs whenever we make a change to the earlier PRs. This can be quite laborious, falls afoul of the &quot;don&#x27;t force-push&quot; rule, takes a long time for engineers to learn, and tends to break existing code review comments in the GitHub interface, but works out okay for two or three PRs. In our workflow a commit is less a unit of work and more a savepoint.<p>I also use heavily use stashes, as well as undo-tree-mode in Emacs. This means we have four different ways of tracking the history of source code, which sounds redundant but works out okay in practice.<p>The ergonomics of doing this in Git are pretty bad. I found Phabicator better but still unnecessarily difficult. Perhaps a new source control management tool could have first class support for higher level concepts than just commits and branches, or perhaps that would be even worse to use.</div><br/></div></div><div id="41506292" class="c"><input type="checkbox" id="c-41506292" checked=""/><div class="controls bullet"><span class="by">enasterosophes</span><span>|</span><a href="#41506898">prev</a><span>|</span><a href="#41508774">next</a><span>|</span><label class="collapse" for="c-41506292">[-]</label><label class="expand" for="c-41506292">[2 more]</label></div><br/><div class="children"><div class="content">Nice, this taught me about `git range-diff` which wasn&#x27;t on my radar before.<p>Is the conclusion likely to be that the author thinks Gerrit is good, or is there some nuance I didn&#x27;t pick up? I&#x27;ve used Gerrit before and in hindsight I much prefer it to other ways of doing code review.</div><br/><div id="41506569" class="c"><input type="checkbox" id="c-41506569" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506292">parent</a><span>|</span><a href="#41508774">next</a><span>|</span><label class="collapse" for="c-41506569">[-]</label><label class="expand" for="c-41506569">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Gerrit is fucking great. If you actually want to do <i>code review</i> and not just rubber stamp shit on GitHub because your eyes are going to bleed after reading the same thing for the 15th time, just use Gerrit.<p>The thing is, I just never got around to finishing this article because what&#x27;s there right now is &quot;good enough&quot; to get the ideas across.</div><br/></div></div></div></div><div id="41508774" class="c"><input type="checkbox" id="c-41508774" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#41506292">prev</a><span>|</span><a href="#41507542">next</a><span>|</span><label class="collapse" for="c-41508774">[-]</label><label class="expand" for="c-41508774">[4 more]</label></div><br/><div class="children"><div class="content">When doing code reviews, I think it is annoying that every time I comment on a line, PR author gets a notification.<p>This is not a simultaneous, real-time thing.<p>I&#x27;m in the middle of doing my review, and my comments are not ready to be read. Maybe I&#x27;ll change my mind on my comment on line 8 when I reach line 80.</div><br/><div id="41508786" class="c"><input type="checkbox" id="c-41508786" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41508774">parent</a><span>|</span><a href="#41507542">next</a><span>|</span><label class="collapse" for="c-41508786">[-]</label><label class="expand" for="c-41508786">[3 more]</label></div><br/><div class="children"><div class="content">GitLab lets you compose the entire review before submitting it so the author won&#x27;t see anything until you&#x27;re done.</div><br/><div id="41508805" class="c"><input type="checkbox" id="c-41508805" checked=""/><div class="controls bullet"><span class="by">djur</span><span>|</span><a href="#41508774">root</a><span>|</span><a href="#41508786">parent</a><span>|</span><a href="#41508830">next</a><span>|</span><label class="collapse" for="c-41508805">[-]</label><label class="expand" for="c-41508805">[1 more]</label></div><br/><div class="children"><div class="content">Github does, too. You just click &quot;Start a review&quot; when filling out your first comment.</div><br/></div></div><div id="41508830" class="c"><input type="checkbox" id="c-41508830" checked=""/><div class="controls bullet"><span class="by">senko</span><span>|</span><a href="#41508774">root</a><span>|</span><a href="#41508786">parent</a><span>|</span><a href="#41508805">prev</a><span>|</span><a href="#41507542">next</a><span>|</span><label class="collapse" for="c-41508830">[-]</label><label class="expand" for="c-41508830">[1 more]</label></div><br/><div class="children"><div class="content">GitHub as well.</div><br/></div></div></div></div></div></div><div id="41507542" class="c"><input type="checkbox" id="c-41507542" checked=""/><div class="controls bullet"><span class="by">codeapprove</span><span>|</span><a href="#41508774">prev</a><span>|</span><a href="#41506277">next</a><span>|</span><label class="collapse" for="c-41507542">[-]</label><label class="expand" for="c-41507542">[1 more]</label></div><br/><div class="children"><div class="content">Love the blog post, it&#x27;s great to see people actually thinking about how code review should work!<p>I&#x27;ve used four different code review systems extensively, all with different strengths and weaknesses: Critique (Google internal), Gerrit (at Google, but same as external), GitHub (duh), and CodeApprove (the one I built).<p>Critique was far and away the best, but it only works because it&#x27;s perfectly fit to Google&#x27;s monorepo and the custom VCS they&#x27;ve built as well as all of their custom lint&#x2F;test tooling. I designed CodeApprove to bring as much of that as I could to GitHub, but it will never really be close.<p>Gerrit was the second best in terms of the reviewer experience ... but as an author I always hated it. It just seemed to be so author-hostile. There were more wrong ways to do something than right ways. And the UI is not exactly beautiful.<p>GitHub is extremely author friendly, it works how we think. You write code, you get feedback, you write more code, etc. If you squash and merge at the end of a PR you don&#x27;t have the history problems the author mentioned. It&#x27;s not very reviewer or team friendly though. Incremental diffs are not highlighted. Diffs and conversation are in different tabs. Force pushes and rebases destroy history. Comments are lost as &quot;outdated&quot;. You can&#x27;t comment on files outside the diff window. Large files are hidden by default, etc etc. They clearly don&#x27;t care about this too much and maybe they know something I don&#x27;t.<p>In the end, the thing I find most frustrating is how many teams just accept whatever code review tool is built in to their VCS platform. That would be like using whatever IDE shipped with your laptop! There are so many better options out there today. My favorites (besides CodeApprove) are GitContext, Reviewable, and Graphite but I can name half a dozen other excellent choices. Don&#x27;t accept the defaults!</div><br/></div></div><div id="41506277" class="c"><input type="checkbox" id="c-41506277" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#41507542">prev</a><span>|</span><a href="#41508869">next</a><span>|</span><label class="collapse" for="c-41506277">[-]</label><label class="expand" for="c-41506277">[1 more]</label></div><br/><div class="children"><div class="content">I create my GitHub PRs like a reviewer&#x27;s going to look at the commits if it&#x27;s too large overall. I&#x27;m also fairly sure they don&#x27;t, because it&#x27;s basically never worth doing so in their PRs (&#x27;fix the test&#x27;, &#x27;merge origin&#x2F;master&#x27;, &#x27;address review comment&#x27;, etc. commits).<p>I suppose I agree GitHub doesn&#x27;t help with this &#x2F; implicitly opposes it (I don&#x27;t see the &#x27;explicitly and&#x27; claim justified though?) but there&#x27;s nothing about a PR that isn&#x27;t a &#x27;series&#x27; of &#x27;patches&#x27;. Maybe GitHub&#x27;s just responding to the way most people use it, and making that easier&#x2F;better instead of being principled? Doesn&#x27;t mean we can&#x27;t be.</div><br/></div></div><div id="41508869" class="c"><input type="checkbox" id="c-41508869" checked=""/><div class="controls bullet"><span class="by">senko</span><span>|</span><a href="#41506277">prev</a><span>|</span><a href="#41506836">next</a><span>|</span><label class="collapse" for="c-41508869">[-]</label><label class="expand" for="c-41508869">[1 more]</label></div><br/><div class="children"><div class="content">I usually deal with “isolated patch series followed by a bunch of fixups” by letting them pile on top, then rebasing just before merging (the setting is usually feature branches all branched from main so that’s fine).<p>It is extra work and not everyone appreciates the benefits, so it’s hard to convince coworkers to do the same.</div><br/></div></div><div id="41506836" class="c"><input type="checkbox" id="c-41506836" checked=""/><div class="controls bullet"><span class="by">pronoiac</span><span>|</span><a href="#41508869">prev</a><span>|</span><a href="#41506376">next</a><span>|</span><label class="collapse" for="c-41506836">[-]</label><label class="expand" for="c-41506836">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m midway through, but a nitpick:<p>&gt; You&#x27;re on your own figuring out the Commit IDs and punching them into the URL bar if you want something more granular.<p>There&#x27;s a &quot;commits&quot; tab at the top, like:
  Conversation | [Commits] | Checks | Files changed<p>Example: <a href="https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;linux&#x2F;pull&#x2F;6330&#x2F;commits">https:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;linux&#x2F;pull&#x2F;6330&#x2F;commits</a></div><br/><div id="41506906" class="c"><input type="checkbox" id="c-41506906" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506836">parent</a><span>|</span><a href="#41506376">next</a><span>|</span><label class="collapse" for="c-41506906">[-]</label><label class="expand" for="c-41506906">[1 more]</label></div><br/><div class="children"><div class="content">I more meant that it&#x27;s hard to diff between <i>arbitrary</i> commits without using the URL bar. The results are also... Weird. For example, let&#x27;s say you have the base B, and commit X:<p><pre><code>    B  ---&gt; X
</code></pre>
Now someone pushed to main, so you rebase on B&#x27;<p><pre><code>    B&#x27; ---&gt; X
</code></pre>
Now, you modify X to address something (maybe just a spelling error)<p><pre><code>    B&#x27; ---&gt; X&#x27;
</code></pre>
Now you push the new rebased branch. Question: how do you view the difference between X&#x27; and X?<p>Well, you have to use that little &quot;Compare&quot; button, but there&#x27;s a really big problem with it: it shows you the diff from X to X&#x27; <i>and</i> the diff from B to B&#x27; at the EXACT same time. Which is really bad! Imagine if the difference between B and B&#x27; is 500 lines; it will completely dwarf the 1 line typofix from X to X&#x27;, making it impossible to read.<p>Now, this is kind of a problem in Gerrit too. But they use a UX technique to make it manageable, which is very smart: they color-code the lines of the diff, depending on if the diff comes from B..B&#x27; or from X..X&#x27; -- so you can see <i>at a glance</i> if the hunk is relevant.<p>More broadly, interdiffing between commit X and commit Y can be tricky, because what you <i>really</i> want to do is something like &quot;Rebase Y onto the parent of X, then diff X and Y&quot;, because otherwise you get the included differences between their baselines. (We do &quot;Rebase Y on X&#x27;s parent&quot; for Jujutsu&#x27;s &quot;interdiff&quot; command IIRC?) But sometimes you DO want to include the base diff, because the changes from B..B&#x27; can be VERY relevant to your patch.<p>So, you need all these options, really. But once you go off this beaten path where you want to compare X to Y... yeah, you have to start typing into the URL bar, I think.<p>But I will say, the commits tab and the little n&#x2F;p keyboard shortcuts to &quot;flip through the commits&quot; like book pages is at least a HUGE improvement over the basic UX though. I use that all the time on GH projects these days, even if I have tons of other problems.</div><br/></div></div></div></div><div id="41506376" class="c"><input type="checkbox" id="c-41506376" checked=""/><div class="controls bullet"><span class="by">fosterfriends</span><span>|</span><a href="#41506836">prev</a><span>|</span><a href="#41508792">next</a><span>|</span><label class="collapse" for="c-41506376">[-]</label><label class="expand" for="c-41506376">[4 more]</label></div><br/><div class="children"><div class="content">I agree with the argument laid out here. Series of small diffs with versions is a fantastic clean model.<p>When creating Graphite on top of GitHub, we chose to only support rebase model (despite the chaos that creates in GitHub timeline events). We also added “versions” support, which wasn’t too hard because GitHub holds on to old commits even if you force push over them.<p>A lot of what we try to build is the exact ideas this author is championing, in a way that’s compatible on top of GitHub. My dream is us and others help usher Eng back towards the patterns Phabricator and Gerrit helped start :)</div><br/><div id="41506560" class="c"><input type="checkbox" id="c-41506560" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41506376">parent</a><span>|</span><a href="#41506524">next</a><span>|</span><label class="collapse" for="c-41506560">[-]</label><label class="expand" for="c-41506560">[2 more]</label></div><br/><div class="children"><div class="content">We strongly considered Graphite as an alternative to Gerrit at my job that I mentioned at the start of this post (which I am no longer at, actually) because it does look like an absolutely excellent product, I will admit. You should all be proud of a smart design and smart set of tools.<p>But there&#x27;s a really really really really really really big problem. Me and the other main engineer on our team used a custom frontend to Git called Jujutsu[1] for all development. Jujutsu is about 1000x better than Git. So that&#x27;s nice. (I&#x27;m also one of the developers, so I&#x27;m not going to abandon it anytime soon.)<p>But gt, the graphite client, is not open source. I have no idea how to make them work together. I have no idea how to extend Jujutsu to handle Graphite stacks, because I don&#x27;t even think there&#x27;s an API to handle any of this.<p>I even wrote a Gerrit integration for Jujutsu because JJ works so well at stacking, and Gerrit + Jujutsu is absolutely a force to be reckoned with IMO, even if the UX isn&#x27;t as nice as Graphite&#x27;s. (I&#x27;m happy to show the people at Graphite why that is, too, if anyone has time or is interested, but I suspect you could all grasp Jujutsu quite easily :)<p>Please! Make gt open source and make it possible for third parties to make and update stacks. This isn&#x27;t just useful for jj but all kinds of automation that wants to contribute patches -- imagine tools like Google&#x27;s internal &quot;Code Review ML models&quot; for Critique that might recommend you rename a variable based on context. They will suggest the fix for you or even apply it! You can get around <i>some</i> of those workflows with &quot;Incorporate suggested edits&quot; which is great on Gerrit (and Graphite?), but not all of them.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj">https:&#x2F;&#x2F;github.com&#x2F;martinvonz&#x2F;jj</a></div><br/><div id="41507132" class="c"><input type="checkbox" id="c-41507132" checked=""/><div class="controls bullet"><span class="by">jacobegold</span><span>|</span><a href="#41506376">root</a><span>|</span><a href="#41506560">parent</a><span>|</span><a href="#41506524">next</a><span>|</span><label class="collapse" for="c-41507132">[-]</label><label class="expand" for="c-41507132">[1 more]</label></div><br/><div class="children"><div class="content">We (Graphite) love Jujutsu – comes up in conversation all the time here.<p>A prior version of the CLI is open source, the core data model (using git refs to store some extra data about what a branch&#x27;s parent is) is still the same. <a href="https:&#x2F;&#x2F;github.com&#x2F;withgraphite&#x2F;graphite-cli">https:&#x2F;&#x2F;github.com&#x2F;withgraphite&#x2F;graphite-cli</a><p>We&#x27;ve talked about supporting other clients, but don&#x27;t currently have the bandwidth to build something like that – definitely something I am personally passionate about making sure happens at some point.</div><br/></div></div></div></div></div></div><div id="41508792" class="c"><input type="checkbox" id="c-41508792" checked=""/><div class="controls bullet"><span class="by">cryptonector</span><span>|</span><a href="#41506376">prev</a><span>|</span><a href="#41508851">next</a><span>|</span><label class="collapse" for="c-41508792">[-]</label><label class="expand" for="c-41508792">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Interlude: Can you please just tell me if git rebase is evil or not so that we can derail the entire discussion over it?<p>Ha, that&#x27;s funny.  But yes, please we need interdiffs in GitHub and GitLab.  I want to have my PRs&#x2F;MRs always rebased and I don&#x27;t want &quot;fix code review comments&quot; commits.</div><br/></div></div><div id="41508851" class="c"><input type="checkbox" id="c-41508851" checked=""/><div class="controls bullet"><span class="by">lynguist</span><span>|</span><a href="#41508792">prev</a><span>|</span><a href="#41508103">next</a><span>|</span><label class="collapse" for="c-41508851">[-]</label><label class="expand" for="c-41508851">[1 more]</label></div><br/><div class="children"><div class="content">I did code reviews on Azure devops and on Bitbucket. I noticed that Azure devops shows exactly this diff soup, and Bitbucket shows interdiffs, and comments do point to previous points in time etc. It is much better from both points of view.</div><br/></div></div><div id="41508103" class="c"><input type="checkbox" id="c-41508103" checked=""/><div class="controls bullet"><span class="by">EPWN3D</span><span>|</span><a href="#41508851">prev</a><span>|</span><a href="#41506593">next</a><span>|</span><label class="collapse" for="c-41508103">[-]</label><label class="expand" for="c-41508103">[1 more]</label></div><br/><div class="children"><div class="content">Is it just me or is the author just arguing for fixup commits and squashing them, something GitHub and Stash&#x2F;Bitbucket handle just fine? I don&#x27;t see how the idea of &quot;publish a new version of the three commits&quot; is new with or exclusive to Gerritt.</div><br/></div></div><div id="41506593" class="c"><input type="checkbox" id="c-41506593" checked=""/><div class="controls bullet"><span class="by">sesuximo</span><span>|</span><a href="#41508103">prev</a><span>|</span><a href="#41508781">next</a><span>|</span><label class="collapse" for="c-41506593">[-]</label><label class="expand" for="c-41506593">[2 more]</label></div><br/><div class="children"><div class="content">If someone brought back phabricator i think they’d make easy $</div><br/><div id="41507418" class="c"><input type="checkbox" id="c-41507418" checked=""/><div class="controls bullet"><span class="by">roryokane</span><span>|</span><a href="#41506593">parent</a><span>|</span><a href="#41508781">next</a><span>|</span><label class="collapse" for="c-41507418">[-]</label><label class="expand" for="c-41507418">[1 more]</label></div><br/><div class="children"><div class="content">Phorge (<a href="https:&#x2F;&#x2F;phorge.it&#x2F;" rel="nofollow">https:&#x2F;&#x2F;phorge.it&#x2F;</a>) already exists. It’s a still-maintained fork of Phabricator.</div><br/></div></div></div></div><div id="41508781" class="c"><input type="checkbox" id="c-41508781" checked=""/><div class="controls bullet"><span class="by">globular-toast</span><span>|</span><a href="#41506593">prev</a><span>|</span><a href="#41506128">next</a><span>|</span><label class="collapse" for="c-41508781">[-]</label><label class="expand" for="c-41508781">[1 more]</label></div><br/><div class="children"><div class="content">GitLab supports this. Every time someone pushes <i>or force pushes</i> it tags that as a version which you can diff. If your developers know how to generate new commits then you can do it right away with GitLab.<p>The problem is generating the new commits. Developers just aren&#x27;t very good at doing this. They can modify a single commit just fine, but modify a commit that isn&#x27;t the latest commit involves a rebase.<p>Magit has the &quot;instant fixup&quot; option which is basically like amending an arbitrary commit instead of just the latest. What is actually doing is doing a commit with `--fixup` then `rebase --autosquash`. This technique can be used manually. Fixup&#x2F;squash commits should be part of all developers&#x27; toolkits.</div><br/></div></div><div id="41506128" class="c"><input type="checkbox" id="c-41506128" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41508781">prev</a><span>|</span><label class="collapse" for="c-41506128">[-]</label><label class="expand" for="c-41506128">[4 more]</label></div><br/><div class="children"><div class="content">Someone should do a deep dive into developer productivity after LLVM switched from Phabricator to GitHub. How many other major projects have done a switch like that?</div><br/><div id="41506341" class="c"><input type="checkbox" id="c-41506341" checked=""/><div class="controls bullet"><span class="by">ajkjk</span><span>|</span><a href="#41506128">parent</a><span>|</span><label class="collapse" for="c-41506341">[-]</label><label class="expand" for="c-41506341">[3 more]</label></div><br/><div class="children"><div class="content">Better it be a deep dive into developer sanity, a more important but comparatively under-valued metric.</div><br/><div id="41506475" class="c"><input type="checkbox" id="c-41506475" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41506128">root</a><span>|</span><a href="#41506341">parent</a><span>|</span><label class="collapse" for="c-41506475">[-]</label><label class="expand" for="c-41506475">[2 more]</label></div><br/><div class="children"><div class="content">For me, GitHub PR review drives me crazy. It&#x27;s good for exactly one round of exchange. After that nobody can tell what the heck is going on. So my self-reported mental health would be worse.<p>But on non-subjective metrics it seems like LLVM PRs on GitHub are gathering noticeably less discussion than they used to enjoy as Phabricator diffs.</div><br/><div id="41506824" class="c"><input type="checkbox" id="c-41506824" checked=""/><div class="controls bullet"><span class="by">zeotroph</span><span>|</span><a href="#41506128">root</a><span>|</span><a href="#41506475">parent</a><span>|</span><label class="collapse" for="c-41506824">[-]</label><label class="expand" for="c-41506824">[1 more]</label></div><br/><div class="children"><div class="content">And just visually, GitHub wastes so much vertical space, so even trying to place what belong to which patchset becomes hard.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>