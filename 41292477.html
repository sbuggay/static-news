<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724317256078" as="style"/><link rel="stylesheet" href="styles.css?v=1724317256078"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://redis.io/docs/latest/develop/use/patterns/distributed-locks/">Distributed Locks with Redis (2014)</a> <span class="domain">(<a href="https://redis.io">redis.io</a>)</span></div><div class="subtext"><span>thenewwazoo</span> | <span>36 comments</span></div><br/><div><div id="41315621" class="c"><input type="checkbox" id="c-41315621" checked=""/><div class="controls bullet"><span class="by">zinodaur</span><span>|</span><a href="#41316989">next</a><span>|</span><label class="collapse" for="c-41315621">[-]</label><label class="expand" for="c-41315621">[17 more]</label></div><br/><div class="children"><div class="content">Martin Kleppmann has some interesting thoughts on Redlock:<p>&gt; I think the Redlock algorithm is a poor choice because it is “neither fish nor fowl”: it is unnecessarily heavyweight and expensive for efficiency-optimization locks, but it is not sufficiently safe for situations in which correctness depends on the lock.<p><a href="https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2016&#x2F;02&#x2F;08&#x2F;how-to-do-distributed-locking.html" rel="nofollow">https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2016&#x2F;02&#x2F;08&#x2F;how-to-do-distribute...</a></div><br/><div id="41316537" class="c"><input type="checkbox" id="c-41316537" checked=""/><div class="controls bullet"><span class="by">pram</span><span>|</span><a href="#41315621">parent</a><span>|</span><a href="#41315756">next</a><span>|</span><label class="collapse" for="c-41316537">[-]</label><label class="expand" for="c-41316537">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve personally used Redis locks in my personal projects. The real motivation isn&#x27;t because it&#x27;s good or correct but because: Redis is already there in my env.</div><br/><div id="41316608" class="c"><input type="checkbox" id="c-41316608" checked=""/><div class="controls bullet"><span class="by">gabetax</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41316537">parent</a><span>|</span><a href="#41316542">next</a><span>|</span><label class="collapse" for="c-41316608">[-]</label><label class="expand" for="c-41316608">[1 more]</label></div><br/><div class="children"><div class="content">For basic SETNX single instance redis instances, sure.<p>But for the Redlock algorithm, I&#x27;ve never encountered anyone that was already running 5 redis masters to use out of convenience.<p>You&#x27;re much more likely to have an etcd, consul, Zookeeper, etc cluster that you could use for coarse-grained distributed locking.</div><br/></div></div><div id="41316542" class="c"><input type="checkbox" id="c-41316542" checked=""/><div class="controls bullet"><span class="by">pookybear223</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41316537">parent</a><span>|</span><a href="#41316608">prev</a><span>|</span><a href="#41315756">next</a><span>|</span><label class="collapse" for="c-41316542">[-]</label><label class="expand" for="c-41316542">[1 more]</label></div><br/><div class="children"><div class="content">i think this type of ‘just tacking on’ to projects, since it is so low friction to do so, is part of how we got to where we are today</div><br/></div></div></div></div><div id="41315756" class="c"><input type="checkbox" id="c-41315756" checked=""/><div class="controls bullet"><span class="by">cjk</span><span>|</span><a href="#41315621">parent</a><span>|</span><a href="#41316537">prev</a><span>|</span><a href="#41317296">next</a><span>|</span><label class="collapse" for="c-41315756">[-]</label><label class="expand" for="c-41315756">[10 more]</label></div><br/><div class="children"><div class="content">Salvatore Sanfilippo (author of Redis and Redlock) wrote a response to Martin Kleppmann&#x27;s analysis that is worth a read (though it is a bit dense and hard to follow at times): <a href="http:&#x2F;&#x2F;antirez.com&#x2F;news&#x2F;101" rel="nofollow">http:&#x2F;&#x2F;antirez.com&#x2F;news&#x2F;101</a><p>I think I agree with Kleppmann&#x27;s analysis, though.</div><br/><div id="41317221" class="c"><input type="checkbox" id="c-41317221" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41315756">parent</a><span>|</span><a href="#41317290">next</a><span>|</span><label class="collapse" for="c-41317221">[-]</label><label class="expand" for="c-41317221">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time:<p><i>Is Redlock Safe? Reply to Redlock Analysis</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11065933">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=11065933</a> - Feb 2016 (135 comments)</div><br/></div></div><div id="41317290" class="c"><input type="checkbox" id="c-41317290" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41315756">parent</a><span>|</span><a href="#41317221">prev</a><span>|</span><a href="#41315851">next</a><span>|</span><label class="collapse" for="c-41317290">[-]</label><label class="expand" for="c-41317290">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a good read, but not so much a rebuttal. He never really addresses the following scenario:<p>1. Get the current time.<p>2. … All the steps needed to acquire the lock …<p>3. Get the current time, again.<p>4. Check if we are already out of time, or if we acquired the lock fast enough.<p>4.5. client pauses for whatever reason (the example Kleppmann gives is a GC pause), long enough for the lock to expire<p>4.75. another client acquires the lock<p>5. Two clients simultaneously hold the lock<p>Which is the core of Kleppmann&#x27;s argument against Redlock&#x27;s correctness. I think the conclusion Sanfilippo can arrive at is that the algorithm is safer than the single node locking algorithm.</div><br/></div></div><div id="41315851" class="c"><input type="checkbox" id="c-41315851" checked=""/><div class="controls bullet"><span class="by">zinodaur</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41315756">parent</a><span>|</span><a href="#41317290">prev</a><span>|</span><a href="#41317296">next</a><span>|</span><label class="collapse" for="c-41315851">[-]</label><label class="expand" for="c-41315851">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The algorithm&#x27;s goal was to move away people that were using a single Redis instance, or a master-slave setup with failover, in order to implement distributed locks, to something much more reliable and safe, but having a very low complexity and good performance.<p>I think this is good perspective. More reliable + more safe + good performance - Fine, its not perfect, but I bet if you are currently using a single node redis lock and keep running into problems when it goes down, these improvements sound nice.<p>Some of antirez&#x27;s comments surprise me a bit though<p>&gt; A distributed lock without an auto release mechanism, where the lock owner will hold it indefinitely, is basically useless.<p>I have found durable locks very practical and useful</div><br/><div id="41316045" class="c"><input type="checkbox" id="c-41316045" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41315851">parent</a><span>|</span><a href="#41317296">next</a><span>|</span><label class="collapse" for="c-41316045">[-]</label><label class="expand" for="c-41316045">[6 more]</label></div><br/><div class="children"><div class="content">Durable locks have a partitioning problem. If the lock holder gets hit by a tornado or catches on fire then there is no recovery method short of manual intervention.<p>I took a formal class on distributed systems back when dinosaurs roamed the earth and the implementation of Ethernet was still considered interesting. And even back then we talked about leases for locks.</div><br/><div id="41316663" class="c"><input type="checkbox" id="c-41316663" checked=""/><div class="controls bullet"><span class="by">zinodaur</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41316045">parent</a><span>|</span><a href="#41317028">next</a><span>|</span><label class="collapse" for="c-41316663">[-]</label><label class="expand" for="c-41316663">[3 more]</label></div><br/><div class="children"><div class="content">We have things we call &quot;durable locks&quot; (but it sounds like thats a loaded term that I don&#x27;t know the meaning of) that work by recording lock holders in persistent storage + use a corresponding volatile lock when the lock holders need to assert ownership (e.g. to perform a write).<p>in our system, the only programs that are allowed to take &quot;durable locks&quot; are ones that are guaranteed to complete (ie, their existence is also recorded in persistent storage, and they are retried until completion). The &quot;durable&quot; part means that even if they restart or die, other writers cant jump in and screw things up. The &quot;volatile&quot; part guarantees that only one of them will be writing at the same time.<p>I wonder what Martin would have to say about our weird little locks</div><br/><div id="41316961" class="c"><input type="checkbox" id="c-41316961" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41316663">parent</a><span>|</span><a href="#41317028">next</a><span>|</span><label class="collapse" for="c-41316961">[-]</label><label class="expand" for="c-41316961">[2 more]</label></div><br/><div class="children"><div class="content">The thing about most modern web backends is that virtually nothing is guaranteed to complete.<p>The processes that use locks are often short-lived. They live in short-lived containers with no state, or maybe they&#x27;re just lambdas executing under a strict resource limit. Either way, there&#x27;s nobody to clean up after them or restart them once they&#x27;re killed. When they begin a database transaction and then disappear for any reason, the best practice is to roll back and pretend they never did anything.<p>In this brave new world of YOLO lock holders, antirez&#x27;s position makes a lot of sense. There&#x27;s definitely still room for old-fashioned durable locks, but these are different use cases.</div><br/><div id="41317279" class="c"><input type="checkbox" id="c-41317279" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41316961">parent</a><span>|</span><a href="#41317028">next</a><span>|</span><label class="collapse" for="c-41317279">[-]</label><label class="expand" for="c-41317279">[1 more]</label></div><br/><div class="children"><div class="content">Autoscaling might mean there isn’t even a machine that corresponds to that dead server for days, weeks, or months.<p>What GP said sounds like it has leases of a fashion. Maybe not the jargon I’d choose to describe them but the industry is full of misleading names for things.</div><br/></div></div></div></div></div></div><div id="41316628" class="c"><input type="checkbox" id="c-41316628" checked=""/><div class="controls bullet"><span class="by">pookybear223</span><span>|</span><a href="#41315621">root</a><span>|</span><a href="#41316045">parent</a><span>|</span><a href="#41317028">prev</a><span>|</span><a href="#41317296">next</a><span>|</span><label class="collapse" for="c-41316628">[-]</label><label class="expand" for="c-41316628">[1 more]</label></div><br/><div class="children"><div class="content">time have changed though. there are better implementations of these, and many companies have built successful startups based around these ideas. look around, it’s the age of distributed locking!</div><br/></div></div></div></div></div></div></div></div><div id="41317296" class="c"><input type="checkbox" id="c-41317296" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#41315621">parent</a><span>|</span><a href="#41315756">prev</a><span>|</span><a href="#41316693">next</a><span>|</span><label class="collapse" for="c-41317296">[-]</label><label class="expand" for="c-41317296">[1 more]</label></div><br/><div class="children"><div class="content">This is a very nice read, as Kleppmann always is. Thanks for the recommendation!</div><br/></div></div><div id="41316693" class="c"><input type="checkbox" id="c-41316693" checked=""/><div class="controls bullet"><span class="by">Axsuul</span><span>|</span><a href="#41315621">parent</a><span>|</span><a href="#41317296">prev</a><span>|</span><a href="#41316073">next</a><span>|</span><label class="collapse" for="c-41316693">[-]</label><label class="expand" for="c-41316693">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s a good alternative?</div><br/></div></div><div id="41316073" class="c"><input type="checkbox" id="c-41316073" checked=""/><div class="controls bullet"><span class="by">HideousKojima</span><span>|</span><a href="#41315621">parent</a><span>|</span><a href="#41316693">prev</a><span>|</span><a href="#41316989">next</a><span>|</span><label class="collapse" for="c-41316073">[-]</label><label class="expand" for="c-41316073">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Those who don&#x27;t understand ACID are doomed to reimplement it... poorly&quot;</div><br/></div></div></div></div><div id="41316989" class="c"><input type="checkbox" id="c-41316989" checked=""/><div class="controls bullet"><span class="by">eurleif</span><span>|</span><a href="#41315621">prev</a><span>|</span><a href="#41315940">next</a><span>|</span><label class="collapse" for="c-41316989">[-]</label><label class="expand" for="c-41316989">[1 more]</label></div><br/><div class="children"><div class="content">I helped! :) (A little.)<p><a href="http:&#x2F;&#x2F;antirez.com&#x2F;news&#x2F;77" rel="nofollow">http:&#x2F;&#x2F;antirez.com&#x2F;news&#x2F;77</a><p>&gt;The Hacker News user eurleif noticed how it is possible to reacquire the lock as a strategy if the client notices it is taking too much time in order to complete the operation. This can be done by just extending an existing lock, sending a script that extends the expire of the value stored at the key is the expected one. If there are no new partitions, and we try to extend the lock enough in advance so that the keys will not expire, there is the guarantee that the lock will be extended.</div><br/></div></div><div id="41315940" class="c"><input type="checkbox" id="c-41315940" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#41316989">prev</a><span>|</span><a href="#41315847">next</a><span>|</span><label class="collapse" for="c-41315940">[-]</label><label class="expand" for="c-41315940">[7 more]</label></div><br/><div class="children"><div class="content">Something I don&#x27;t enjoy about remote&#x2F;distributed locks is that unlike distributed transactions they&#x27;re usually unable to provide any strict guarantees about things they protect.<p>E.g. if you algorithm is:<p>1) Hold the distributed lock<p>2) Do the thing<p>3) Release the lock<p>And the node goes dark for a while between steps 1 and 2 (e.g. 100% CPU load), by the time it reaches 2 the lock may have already expired and another node is holding it, resulting in a race. Adding steps like &quot;1.1 double&#x2F;triple check the lock is still held&quot; obviously doesn&#x27;t help because the node can go dark right after these and resume operation at 2. The probability of these is not too high, but still: no guarantees. Furthermore at a certain scale you do actually start seeing rogue nodes deemed dead hours ago suddenly coming back to life and doing unpleasant things.<p>The rule of thumb usually is &quot;keep locks within the same transaction space as the thing they protect&quot;, and often you don&#x27;t even needs locks in that case, just transactions can be enough by themselves. If you&#x27;re trying to protect something that inherently un-transactional then, well, good luck because these efforts are always probabilistic in nature.<p>A good use-case for a remote lock would be when it&#x27;s not actually used to guarantee consistency or avoid races, but merely tries to prevent duplicate calculations for cost&#x2F;performance considerations. For all other cases I outright recommend avoiding them.</div><br/><div id="41318131" class="c"><input type="checkbox" id="c-41318131" checked=""/><div class="controls bullet"><span class="by">rand_r</span><span>|</span><a href="#41315940">parent</a><span>|</span><a href="#41317242">next</a><span>|</span><label class="collapse" for="c-41318131">[-]</label><label class="expand" for="c-41318131">[1 more]</label></div><br/><div class="children"><div class="content">Yes, exactly! We found out the hard way just how unreliable Redis-based locks are, and switched to Postgres locks. It works reliably since our code is already in a Postgres transaction.<p>Created a “lock” table with a single string key column, so you can “select key for update” on an arbitrary string key (similar UX to redis lock). I looked at advisory locks, but they don’t work when the lock key needs to be dynamically generated.</div><br/></div></div><div id="41317242" class="c"><input type="checkbox" id="c-41317242" checked=""/><div class="controls bullet"><span class="by">imor80</span><span>|</span><a href="#41315940">parent</a><span>|</span><a href="#41318131">prev</a><span>|</span><a href="#41316088">next</a><span>|</span><label class="collapse" for="c-41317242">[-]</label><label class="expand" for="c-41317242">[1 more]</label></div><br/><div class="children"><div class="content">A lot of what you say is explained in detail in Martin Kleppmann&#x27;s article[0]. As you said, there&#x27;s no guarantee about when the lock will expire. The proper solution for this is a fencing token. The idea is similar to how people have used optimistic locking when updating data in a db to avoid two users overwriting other&#x27;s work.<p>[0]: <a href="https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2016&#x2F;02&#x2F;08&#x2F;how-to-do-distributed-locking.html" rel="nofollow">https:&#x2F;&#x2F;martin.kleppmann.com&#x2F;2016&#x2F;02&#x2F;08&#x2F;how-to-do-distribute...</a></div><br/></div></div><div id="41316088" class="c"><input type="checkbox" id="c-41316088" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41315940">parent</a><span>|</span><a href="#41317242">prev</a><span>|</span><a href="#41315847">next</a><span>|</span><label class="collapse" for="c-41316088">[-]</label><label class="expand" for="c-41316088">[4 more]</label></div><br/><div class="children"><div class="content">If it goes dark a microsecond after #3 you might have an ambiguous success. Transaction processed but you didn&#x27;t get a confirmation.<p>A lot of robust systems end up implementing their own bespoke WAL semantics on top of the system of record. It&#x27;s like we should have a formal solution for doing that by now.</div><br/><div id="41317149" class="c"><input type="checkbox" id="c-41317149" checked=""/><div class="controls bullet"><span class="by">qaq</span><span>|</span><a href="#41315940">root</a><span>|</span><a href="#41316088">parent</a><span>|</span><a href="#41316682">next</a><span>|</span><label class="collapse" for="c-41317149">[-]</label><label class="expand" for="c-41317149">[1 more]</label></div><br/><div class="children"><div class="content">We do we have globally distributed ACID DBs like Spanner, CockroachDB, FoundationDB etc.</div><br/></div></div><div id="41316682" class="c"><input type="checkbox" id="c-41316682" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#41315940">root</a><span>|</span><a href="#41316088">parent</a><span>|</span><a href="#41317149">prev</a><span>|</span><a href="#41315847">next</a><span>|</span><label class="collapse" for="c-41316682">[-]</label><label class="expand" for="c-41316682">[2 more]</label></div><br/><div class="children"><div class="content">True. Even simple scenarios like &quot;save a file in s3 IFF the s3 link is saved in postgres&quot; which are seen in virtually any application are rarely handled well.</div><br/><div id="41316863" class="c"><input type="checkbox" id="c-41316863" checked=""/><div class="controls bullet"><span class="by">physicles</span><span>|</span><a href="#41315940">root</a><span>|</span><a href="#41316682">parent</a><span>|</span><a href="#41315847">next</a><span>|</span><label class="collapse" for="c-41316863">[-]</label><label class="expand" for="c-41316863">[1 more]</label></div><br/><div class="children"><div class="content">Uggh, I was cornered into writing a couple of these over the years. The way I handled it was:<p>1. make sure both operations will be retried if they don&#x27;t run to completion, and<p>2. think through how the rest of the system would react to one of them being present without the other<p>Then I use whichever of the two orderings is less bad from the perspective of #2. Obviously this depends on the exact use case -- I was simply lucky that the rest of the system was designed in such a way that it could tolerate that bad intermediate state.</div><br/></div></div></div></div></div></div></div></div><div id="41315847" class="c"><input type="checkbox" id="c-41315847" checked=""/><div class="controls bullet"><span class="by">jetru</span><span>|</span><a href="#41315940">prev</a><span>|</span><a href="#41317220">next</a><span>|</span><label class="collapse" for="c-41315847">[-]</label><label class="expand" for="c-41315847">[1 more]</label></div><br/><div class="children"><div class="content">Famously broken badly for anything mission critical.</div><br/></div></div><div id="41317220" class="c"><input type="checkbox" id="c-41317220" checked=""/><div class="controls bullet"><span class="by">Bogdanp</span><span>|</span><a href="#41315847">prev</a><span>|</span><a href="#41316524">next</a><span>|</span><label class="collapse" for="c-41317220">[-]</label><label class="expand" for="c-41317220">[1 more]</label></div><br/><div class="children"><div class="content">To counter some of the hate in this thread: I have used this to great success as an &quot;opportunistic&quot; locking mechanism to, for example, reduce load on a Postgres database. The winner of the race to acquire the lock would run the (expensive) query then cache the result. On lock release, the nodes waiting on the lock would then try to read the cache before trying to acquire the lock again.</div><br/></div></div><div id="41316524" class="c"><input type="checkbox" id="c-41316524" checked=""/><div class="controls bullet"><span class="by">awinter-py</span><span>|</span><a href="#41317220">prev</a><span>|</span><a href="#41315634">next</a><span>|</span><label class="collapse" for="c-41316524">[-]</label><label class="expand" for="c-41316524">[3 more]</label></div><br/><div class="children"><div class="content">redis is the easiest-to-host lock server and that&#x27;s worth the risk in some applications (depending on consequence of errors obv)<p>inspiring + slightly terrifying that rather than a single server-side implementation, every client is responsible for its own implementation<p>if postgres provided fast kv cache and a lock primitive it would own</div><br/><div id="41316827" class="c"><input type="checkbox" id="c-41316827" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#41316524">parent</a><span>|</span><a href="#41315634">next</a><span>|</span><label class="collapse" for="c-41316827">[-]</label><label class="expand" for="c-41316827">[2 more]</label></div><br/><div class="children"><div class="content">Redis is a very bad store for a distributed lock but Postgres is only slightly better.<p>What you truly need is something like ZooKeeper and etcd that are designed to achieve distributed consensus using algorithms like Paxos or Raft.<p>This ensures strong consistency and reliability in a distributed system, making them ideal for tasks like leader election, configuration management, and lease management where consistency across nodes is critical.</div><br/><div id="41316842" class="c"><input type="checkbox" id="c-41316842" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#41316524">root</a><span>|</span><a href="#41316827">parent</a><span>|</span><a href="#41315634">next</a><span>|</span><label class="collapse" for="c-41316842">[-]</label><label class="expand" for="c-41316842">[1 more]</label></div><br/><div class="children"><div class="content">Paxos and Raft are consensus algorithms that provide certain guarantees and capabilities that a master-slave system with synchronous replication, such as PostgreSQL, cannot offer.<p>These algorithms ensure that a majority of nodes (a quorum) must agree on any proposed chAnge. This agreement guarantees that once a decision is made (e.g., to commit a transaction), it is final and consistent across all nodes. This strong consistency is critical in distributed systems to avoid split-brain scenarios.<p>This is easily caused by :<p>1-network partition<p>2-latency issues.<p>3-Async failover (2 nodes think they are the master)<p>4-replica lag (some but not all replica acknowledged the write) while master send confirmation to client</div><br/></div></div></div></div></div></div><div id="41315634" class="c"><input type="checkbox" id="c-41315634" checked=""/><div class="controls bullet"><span class="by">AtlasBarfed</span><span>|</span><a href="#41316524">prev</a><span>|</span><a href="#41316404">next</a><span>|</span><label class="collapse" for="c-41315634">[-]</label><label class="expand" for="c-41315634">[3 more]</label></div><br/><div class="children"><div class="content">Where&#x27;s the Jepsen suite tests?<p>Without it this is alphaware at best</div><br/><div id="41316801" class="c"><input type="checkbox" id="c-41316801" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41315634">parent</a><span>|</span><a href="#41316080">next</a><span>|</span><label class="collapse" for="c-41316801">[-]</label><label class="expand" for="c-41316801">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an out-of-band locking mechanism.  In particular, one which mentions &quot;you should consider fencing tokens&quot; merely in passing instead of baking them in from the start.<p>The only reasonable correctness-oriented view of that is &quot;lol&quot;.  It&#x27;s not worth throwing a Jepsen-like test at it, the fundamentals aren&#x27;t even slightly sound, merely &quot;usually good enough&quot;.  Whether that&#x27;s <i>worth it</i> for [use X] depends on that use - often yes!</div><br/></div></div><div id="41316080" class="c"><input type="checkbox" id="c-41316080" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41315634">parent</a><span>|</span><a href="#41316801">prev</a><span>|</span><a href="#41316404">next</a><span>|</span><label class="collapse" for="c-41316080">[-]</label><label class="expand" for="c-41316080">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like a 50&#x27;s ad slogan. If it doesn&#x27;t _____, then I won&#x27;t _____.</div><br/></div></div></div></div><div id="41316404" class="c"><input type="checkbox" id="c-41316404" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41315634">prev</a><span>|</span><label class="collapse" for="c-41316404">[-]</label><label class="expand" for="c-41316404">[2 more]</label></div><br/><div class="children"><div class="content">I have seen (ad hoc) implementations go quite bad many times. I encounter them quite a bit as a distributed replacement for some type of db transaction where the db is something like rds; someone thought to be smart and write &#x27;things at scale&#x27; (they read on reddit etc) while a db transaction would&#x27;ve been the correct solution and they didn&#x27;t need scale anyway (or underestimated the current db capabilities for mysql&#x2F;postgres).</div><br/></div></div></div></div></div></div></div></body></html>