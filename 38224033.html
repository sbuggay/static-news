<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699693265330" as="style"/><link rel="stylesheet" href="styles.css?v=1699693265330"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://re.factorcode.org/2023/11/factor-is-faster-than-zig.html">Hashmaps in Factor are faster than in Zig</a> <span class="domain">(<a href="https://re.factorcode.org">re.factorcode.org</a>)</span></div><div class="subtext"><span>kencausey</span> | <span>24 comments</span></div><br/><div><div id="38227693" class="c"><input type="checkbox" id="c-38227693" checked=""/><div class="controls bullet"><span class="by">senderista</span><span>|</span><a href="#38227559">next</a><span>|</span><label class="collapse" for="c-38227693">[-]</label><label class="expand" for="c-38227693">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see a compelling reason to use tombstones in linear probing except in a concurrent context (where you can&#x27;t move entries around). The tombstone-free deletion algorithm is quite simple: <a href="https:&#x2F;&#x2F;github.com&#x2F;senderista&#x2F;hashtable-benchmarks&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;set&#x2F;int64&#x2F;LPLongHashSet.java#L184">https:&#x2F;&#x2F;github.com&#x2F;senderista&#x2F;hashtable-benchmarks&#x2F;blob&#x2F;mast...</a>. No rehashing is necessary.</div><br/><div id="38227802" class="c"><input type="checkbox" id="c-38227802" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#38227693">parent</a><span>|</span><a href="#38227813">next</a><span>|</span><label class="collapse" for="c-38227802">[-]</label><label class="expand" for="c-38227802">[1 more]</label></div><br/><div class="children"><div class="content">imo a pretty good approach is tombstones where you delete trailing tombstones. that way the tombstones can&#x27;t overly clog the dictionary but never have to move live objects</div><br/></div></div><div id="38227813" class="c"><input type="checkbox" id="c-38227813" checked=""/><div class="controls bullet"><span class="by">celeritascelery</span><span>|</span><a href="#38227693">parent</a><span>|</span><a href="#38227802">prev</a><span>|</span><a href="#38227559">next</a><span>|</span><label class="collapse" for="c-38227813">[-]</label><label class="expand" for="c-38227813">[2 more]</label></div><br/><div class="children"><div class="content">This is a really cool approach! But if it so obvious, why doesn&#x27;t every hashmap use it? It seems like there are some trade-offs here that I must be missing.</div><br/><div id="38227955" class="c"><input type="checkbox" id="c-38227955" checked=""/><div class="controls bullet"><span class="by">Leszek</span><span>|</span><a href="#38227693">root</a><span>|</span><a href="#38227813">parent</a><span>|</span><a href="#38227559">next</a><span>|</span><label class="collapse" for="c-38227955">[-]</label><label class="expand" for="c-38227955">[1 more]</label></div><br/><div class="children"><div class="content">If you do any kind of probing other than linear probing (e.g. quadratic probing) this approach doesn&#x27;t work anymore, because your collisions are no longer densely grouped together.</div><br/></div></div></div></div></div></div><div id="38227559" class="c"><input type="checkbox" id="c-38227559" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#38227693">prev</a><span>|</span><a href="#38227752">next</a><span>|</span><label class="collapse" for="c-38227559">[-]</label><label class="expand" for="c-38227559">[7 more]</label></div><br/><div class="children"><div class="content">Hash maps are such a fundamentally important data structure that it comes as a surprise that the Zig implementation is so broken. Good to see it’s getting fixed, but surprising that this wasn’t detected before.</div><br/><div id="38228361" class="c"><input type="checkbox" id="c-38228361" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#38227559">parent</a><span>|</span><a href="#38228058">next</a><span>|</span><label class="collapse" for="c-38228361">[-]</label><label class="expand" for="c-38228361">[1 more]</label></div><br/><div class="children"><div class="content">My impression from the article is that Zig provides several <i>different</i> hashtables and not all of them are broken in this way.<p>This reminds me of Aria&#x27;s comment in her Rust tutorial <a href="https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;</a> about failing to kill LinkedList. One philosophy (and the one Rust chose) for a stdlib is that this is only where things should live when they&#x27;re so commonly needed that essentially everybody needs them either directly or to talk about. So, HashTable is needed by so much otherwise unrelated software that qualifies, BloomFilter, while it&#x27;s real useful for some people, not so much. Aria cleaned out Rust&#x27;s set of standard library containers before Rust 1.0, trying to keep only those most people would need. LinkedList isn&#x27;t a good general purpose data structure, but, it was too popular and Aria was not able to remove it.<p>Having multiple hash tables feels like a win (they&#x27;re optimized for different purposes) but may cost too much in terms of the necessary testing to ensure they all hit the quality you want.</div><br/></div></div><div id="38228058" class="c"><input type="checkbox" id="c-38228058" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#38227559">parent</a><span>|</span><a href="#38228361">prev</a><span>|</span><a href="#38227752">next</a><span>|</span><label class="collapse" for="c-38228058">[-]</label><label class="expand" for="c-38228058">[5 more]</label></div><br/><div class="children"><div class="content">Not that many hashmaps see hundreds of millions of entries in their lifetime. Given that Zig isn’t widely used, it’s probable that noone has really stumbled upon this behaviour in a non-benchmark setting.</div><br/><div id="38228308" class="c"><input type="checkbox" id="c-38228308" checked=""/><div class="controls bullet"><span class="by">shemii</span><span>|</span><a href="#38227559">root</a><span>|</span><a href="#38228058">parent</a><span>|</span><a href="#38227752">next</a><span>|</span><label class="collapse" for="c-38228308">[-]</label><label class="expand" for="c-38228308">[4 more]</label></div><br/><div class="children"><div class="content">Actually it seems according to the issue that TigerBeetle (one of the bigger zig projects out there) noticed this issue [1]. It&#x27;s also on their issue tracker [2].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;17851">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;17851</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;tigerbeetle&#x2F;tigerbeetle&#x2F;issues&#x2F;1191">https:&#x2F;&#x2F;github.com&#x2F;tigerbeetle&#x2F;tigerbeetle&#x2F;issues&#x2F;1191</a></div><br/><div id="38228392" class="c"><input type="checkbox" id="c-38228392" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#38227559">root</a><span>|</span><a href="#38228308">parent</a><span>|</span><a href="#38227752">next</a><span>|</span><label class="collapse" for="c-38228392">[-]</label><label class="expand" for="c-38228392">[3 more]</label></div><br/><div class="children"><div class="content">When you use a language that&#x27;s in alpha- (maybe beta- now?) stage, this kind of thing should be expected.
Even with the latest version of Zig, perfectly correct programs can segfault due to miscompilation, so performance issues are not even the biggest worry you should have.</div><br/><div id="38228426" class="c"><input type="checkbox" id="c-38228426" checked=""/><div class="controls bullet"><span class="by">shemii</span><span>|</span><a href="#38227559">root</a><span>|</span><a href="#38228392">parent</a><span>|</span><a href="#38227752">next</a><span>|</span><label class="collapse" for="c-38228426">[-]</label><label class="expand" for="c-38228426">[2 more]</label></div><br/><div class="children"><div class="content">One thing I really don&#x27;t unserstand is how bun already reached stability with it&#x27;s 1.0 release (<a href="https:&#x2F;&#x2F;bun.sh&#x2F;blog&#x2F;bun-v1.0" rel="nofollow noreferrer">https:&#x2F;&#x2F;bun.sh&#x2F;blog&#x2F;bun-v1.0</a>) while being written in Zig, which still hasn&#x27;t reached it&#x27;s 1.0 release.</div><br/><div id="38228463" class="c"><input type="checkbox" id="c-38228463" checked=""/><div class="controls bullet"><span class="by">fastball</span><span>|</span><a href="#38227559">root</a><span>|</span><a href="#38228426">parent</a><span>|</span><a href="#38227752">next</a><span>|</span><label class="collapse" for="c-38228463">[-]</label><label class="expand" for="c-38228463">[1 more]</label></div><br/><div class="children"><div class="content">Bun is compiled to a binary, so not sure it matters how stable the underlying language is if Bun itself has a stable API?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38227752" class="c"><input type="checkbox" id="c-38227752" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#38227559">prev</a><span>|</span><a href="#38228140">next</a><span>|</span><label class="collapse" for="c-38227752">[-]</label><label class="expand" for="c-38227752">[1 more]</label></div><br/><div class="children"><div class="content">So in other words, bug in Zig library causes linear execution time on something that isn&#x27;t supposed to be linear.</div><br/></div></div><div id="38228140" class="c"><input type="checkbox" id="c-38228140" checked=""/><div class="controls bullet"><span class="by">chmod600</span><span>|</span><a href="#38227752">prev</a><span>|</span><a href="#38224052">next</a><span>|</span><label class="collapse" for="c-38228140">[-]</label><label class="expand" for="c-38228140">[2 more]</label></div><br/><div class="children"><div class="content">Factor looks cool, but what&#x27;s it really about? Can someone who loves the language explain why?</div><br/><div id="38228183" class="c"><input type="checkbox" id="c-38228183" checked=""/><div class="controls bullet"><span class="by">m031</span><span>|</span><a href="#38228140">parent</a><span>|</span><a href="#38224052">next</a><span>|</span><label class="collapse" for="c-38228183">[-]</label><label class="expand" for="c-38228183">[1 more]</label></div><br/><div class="children"><div class="content">Found this page on that subject: <a href="https:&#x2F;&#x2F;concatenative.org&#x2F;wiki&#x2F;view&#x2F;Factor&#x2F;FAQ&#x2F;Why%3F" rel="nofollow noreferrer">https:&#x2F;&#x2F;concatenative.org&#x2F;wiki&#x2F;view&#x2F;Factor&#x2F;FAQ&#x2F;Why%3F</a></div><br/></div></div></div></div><div id="38224052" class="c"><input type="checkbox" id="c-38224052" checked=""/><div class="controls bullet"><span class="by">kencausey</span><span>|</span><a href="#38228140">prev</a><span>|</span><a href="#38227706">next</a><span>|</span><label class="collapse" for="c-38224052">[-]</label><label class="expand" for="c-38224052">[4 more]</label></div><br/><div class="children"><div class="content">Title is a bit clickbait.  This is regarding Hashmaps specifically.  Read or at least scan through it where the author will submit a fix for the Zig implementation resulting in Zig&#x27;s Hashmap being 50% faster than the Factor implementation.</div><br/><div id="38226071" class="c"><input type="checkbox" id="c-38226071" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38224052">parent</a><span>|</span><a href="#38227706">next</a><span>|</span><label class="collapse" for="c-38226071">[-]</label><label class="expand" for="c-38226071">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve edited the title to make that clearer. Thanks!</div><br/><div id="38227904" class="c"><input type="checkbox" id="c-38227904" checked=""/><div class="controls bullet"><span class="by">sirmike_</span><span>|</span><a href="#38224052">root</a><span>|</span><a href="#38226071">parent</a><span>|</span><a href="#38227706">next</a><span>|</span><label class="collapse" for="c-38227904">[-]</label><label class="expand" for="c-38227904">[2 more]</label></div><br/><div class="children"><div class="content">** ** ** ***. ** **. ** ** ****</div><br/><div id="38228031" class="c"><input type="checkbox" id="c-38228031" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#38224052">root</a><span>|</span><a href="#38227904">parent</a><span>|</span><a href="#38227706">next</a><span>|</span><label class="collapse" for="c-38228031">[-]</label><label class="expand" for="c-38228031">[1 more]</label></div><br/><div class="children"><div class="content">whut?</div><br/></div></div></div></div></div></div></div></div><div id="38227706" class="c"><input type="checkbox" id="c-38227706" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#38224052">prev</a><span>|</span><label class="collapse" for="c-38227706">[-]</label><label class="expand" for="c-38227706">[5 more]</label></div><br/><div class="children"><div class="content">Why hashmaps? Python has named tuples.<p>Oh - this puts a lot of keys into one hashmap, not a ton of objects with the same keys. :)</div><br/><div id="38227806" class="c"><input type="checkbox" id="c-38227806" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#38227706">parent</a><span>|</span><label class="collapse" for="c-38227806">[-]</label><label class="expand" for="c-38227806">[4 more]</label></div><br/><div class="children"><div class="content">Python also has dicts.</div><br/><div id="38227869" class="c"><input type="checkbox" id="c-38227869" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#38227706">root</a><span>|</span><a href="#38227806">parent</a><span>|</span><label class="collapse" for="c-38227869">[-]</label><label class="expand" for="c-38227869">[3 more]</label></div><br/><div class="children"><div class="content">Of course.<p>I was just saying that a lot of the time hashmaps don&#x27;t get very many entries.<p>There is serialization and deserialization where Cap&#x27;n Proto, Flatbuffers, and Protocol Buffers have a savings over JSON by not repeating key names of a list of maps.</div><br/><div id="38228052" class="c"><input type="checkbox" id="c-38228052" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#38227706">root</a><span>|</span><a href="#38227869">parent</a><span>|</span><a href="#38228057">next</a><span>|</span><label class="collapse" for="c-38228052">[-]</label><label class="expand" for="c-38228052">[1 more]</label></div><br/><div class="children"><div class="content">I fail to see how is this relevant to the article. HashMap&#x2F;dict can as well store a mapping from an integer to an integer. Or from a token to an integer, or whatever, and it has nothing to do with serialization, JSON inefficiency or lists of maps.</div><br/></div></div><div id="38228057" class="c"><input type="checkbox" id="c-38228057" checked=""/><div class="controls bullet"><span class="by">asplake</span><span>|</span><a href="#38227706">root</a><span>|</span><a href="#38227869">parent</a><span>|</span><a href="#38228052">prev</a><span>|</span><label class="collapse" for="c-38228057">[-]</label><label class="expand" for="c-38228057">[1 more]</label></div><br/><div class="children"><div class="content">Use the structure that best fits the problem. The saving to which you refer applies only to serialisation, not to the use of the structure by an algorithm.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>