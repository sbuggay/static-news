<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729242071367" as="style"/><link rel="stylesheet" href="styles.css?v=1729242071367"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3477r0.html">C++ proposal: There are exactly 8 bits in a byte</a> <span class="domain">(<a href="https://www.open-std.org">www.open-std.org</a>)</span></div><div class="subtext"><span>Twirrim</span> | <span>212 comments</span></div><br/><div><div id="41875023" class="c"><input type="checkbox" id="c-41875023" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41874875">next</a><span>|</span><label class="collapse" for="c-41875023">[-]</label><label class="expand" for="c-41875023">[28 more]</label></div><br/><div class="children"><div class="content">Previously, in JF&#x27;s &quot;Can we acknowledge that every real computer works this way?&quot; series: &quot;Signed Integers are Two’s Complement&quot; &lt;<a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p0907r0.html" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p09...</a>&gt;</div><br/><div id="41875200" class="c"><input type="checkbox" id="c-41875200" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#41875023">parent</a><span>|</span><a href="#41874875">next</a><span>|</span><label class="collapse" for="c-41875200">[-]</label><label class="expand" for="c-41875200">[27 more]</label></div><br/><div class="children"><div class="content">Maybe specifying that floats are always IEEE floats should be next? Though that would obsolete this Linux kernel classic so maybe not.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;include&#x2F;math-emu&#x2F;double.h#L29">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;include&#x2F;math-e...</a></div><br/><div id="41876461" class="c"><input type="checkbox" id="c-41876461" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41875859">next</a><span>|</span><label class="collapse" for="c-41876461">[-]</label><label class="expand" for="c-41876461">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m literally giving a talk next week who&#x27;s first slide is essentially &quot;Why IEEE 754 is not a sufficient description of floating-point semantics&quot; and I&#x27;m sitting here trying to figure out what needs to be thrown out of the talk to make it fit the time slot.<p>One of the most surprising things about floating-point is that very little is actually IEEE 754; most things are merely IEEE 754-ish, and there&#x27;s a long tail of fiddly things that are different that make it only -ish.</div><br/><div id="41876547" class="c"><input type="checkbox" id="c-41876547" checked=""/><div class="controls bullet"><span class="by">chungy</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876461">parent</a><span>|</span><a href="#41876497">next</a><span>|</span><label class="collapse" for="c-41876547">[-]</label><label class="expand" for="c-41876547">[1 more]</label></div><br/><div class="children"><div class="content">The IEEE 754 standard has been updated several times, often by relaxing previous mandates in order to make various hardware implementations become compliant retroactively (eg, adding Intel&#x27;s 80-bit floats as a standard floating point size).<p>It&#x27;ll be interesting if the &quot;-ish&quot; bits are still &quot;-ish&quot; with the current standard.</div><br/></div></div><div id="41876497" class="c"><input type="checkbox" id="c-41876497" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876461">parent</a><span>|</span><a href="#41876547">prev</a><span>|</span><a href="#41876510">next</a><span>|</span><label class="collapse" for="c-41876497">[-]</label><label class="expand" for="c-41876497">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there&#x27;s a long tail of fiddly things that are different that make it only -ish.<p>Perhaps a way to fill some time would be gradually revealing parts of a convoluted Venn diagram or mind-map of the fiddling things. (That is, assuming there&#x27;s any sane categorization.)</div><br/></div></div><div id="41876510" class="c"><input type="checkbox" id="c-41876510" checked=""/><div class="controls bullet"><span class="by">speedgoose</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876461">parent</a><span>|</span><a href="#41876497">prev</a><span>|</span><a href="#41875859">next</a><span>|</span><label class="collapse" for="c-41876510">[-]</label><label class="expand" for="c-41876510">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested by your future talk, do you plan to publish a video or a transcript?</div><br/></div></div></div></div><div id="41875859" class="c"><input type="checkbox" id="c-41875859" checked=""/><div class="controls bullet"><span class="by">jfbastien</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41876461">prev</a><span>|</span><a href="#41877394">next</a><span>|</span><label class="collapse" for="c-41875859">[-]</label><label class="expand" for="c-41875859">[1 more]</label></div><br/><div class="children"><div class="content">Hi! I&#x27;m JF. I half-jokingly threatened to do IEEE float in 2018 <a href="https:&#x2F;&#x2F;youtu.be&#x2F;JhUxIVf1qok?si=QxZN_fIU2Th8vhxv&amp;t=3250" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;JhUxIVf1qok?si=QxZN_fIU2Th8vhxv&amp;t=3250</a><p>I wouldn&#x27;t want to lose the Linux humor tho!</div><br/></div></div><div id="41877394" class="c"><input type="checkbox" id="c-41877394" checked=""/><div class="controls bullet"><span class="by">seoulbigchris</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41875859">prev</a><span>|</span><a href="#41876173">next</a><span>|</span><label class="collapse" for="c-41877394">[-]</label><label class="expand" for="c-41877394">[1 more]</label></div><br/><div class="children"><div class="content">Which one? Remember the decimal IEEE 754 floating point formats exist too. Do folks in banking use IEEE decimal formats? I remember we used to have different math libs to link against depending, but this was like 40 years ago.</div><br/></div></div><div id="41876173" class="c"><input type="checkbox" id="c-41876173" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41877394">prev</a><span>|</span><a href="#41875351">next</a><span>|</span><label class="collapse" for="c-41876173">[-]</label><label class="expand" for="c-41876173">[1 more]</label></div><br/><div class="children"><div class="content">I was curious about float16, and TIL that the 2008 revision of the standard includes it as an interchange format:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IEEE_754-2008_revision" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IEEE_754-2008_revision</a></div><br/></div></div><div id="41875351" class="c"><input type="checkbox" id="c-41875351" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41876173">prev</a><span>|</span><a href="#41876831">next</a><span>|</span><label class="collapse" for="c-41875351">[-]</label><label class="expand" for="c-41875351">[2 more]</label></div><br/><div class="children"><div class="content">That line is actually from a famous Dilbert cartoon.<p>I found this snapshot of it, though it&#x27;s not on the real Dilbert site:  <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;linux&#x2F;comments&#x2F;73in9&#x2F;computer_holy_wars_png&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;linux&#x2F;comments&#x2F;73in9&#x2F;computer_holy_...</a></div><br/><div id="41875688" class="c"><input type="checkbox" id="c-41875688" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875351">parent</a><span>|</span><a href="#41876831">next</a><span>|</span><label class="collapse" for="c-41875688">[-]</label><label class="expand" for="c-41875688">[1 more]</label></div><br/><div class="children"><div class="content">This is the epitome, the climax, the crux, the ultimate, the holy grail, the crème de la crème of nerd sniping.<p>fuckin bravo</div><br/></div></div></div></div><div id="41876831" class="c"><input type="checkbox" id="c-41876831" checked=""/><div class="controls bullet"><span class="by">Silphendio</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41875351">prev</a><span>|</span><a href="#41875749">next</a><span>|</span><label class="collapse" for="c-41876831">[-]</label><label class="expand" for="c-41876831">[1 more]</label></div><br/><div class="children"><div class="content">At the very least, division by zero should not be undefined for floats.</div><br/></div></div><div id="41875749" class="c"><input type="checkbox" id="c-41875749" checked=""/><div class="controls bullet"><span class="by">FooBarBizBazz</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41876831">prev</a><span>|</span><a href="#41875213">next</a><span>|</span><label class="collapse" for="c-41875749">[-]</label><label class="expand" for="c-41875749">[15 more]</label></div><br/><div class="children"><div class="content">Whether double floats can silently have 80 bit accumulators is a controversial thing. Numerical analysis people like it. Computer science types seem not to because it&#x27;s unpredictable. I lean towards, &quot;we should have it, but it should be explicit&quot;, but this is not the most considered opinion. I think there&#x27;s a legitimate reason why Intel included it in x87, and why DSPs include it.</div><br/><div id="41876023" class="c"><input type="checkbox" id="c-41876023" checked=""/><div class="controls bullet"><span class="by">stephencanon</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875749">parent</a><span>|</span><a href="#41875950">next</a><span>|</span><label class="collapse" for="c-41876023">[-]</label><label class="expand" for="c-41876023">[13 more]</label></div><br/><div class="children"><div class="content">Numerical analysis people do not like it. Having _explicitly controlled_ wider accumulation available is great. Having compilers deciding to do it for you or not in unpredictable ways is anathema.</div><br/><div id="41876108" class="c"><input type="checkbox" id="c-41876108" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876023">parent</a><span>|</span><a href="#41875950">next</a><span>|</span><label class="collapse" for="c-41876108">[-]</label><label class="expand" for="c-41876108">[12 more]</label></div><br/><div class="children"><div class="content">It isn’t harmful, right? Just like getting a little accuracy from a fused multiply add. It just isn’t useful if you can’t depend on it.</div><br/><div id="41876269" class="c"><input type="checkbox" id="c-41876269" checked=""/><div class="controls bullet"><span class="by">Negitivefrags</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876108">parent</a><span>|</span><a href="#41876218">next</a><span>|</span><label class="collapse" for="c-41876269">[-]</label><label class="expand" for="c-41876269">[9 more]</label></div><br/><div class="children"><div class="content">It can be harmful. In GCC while compiling a 32 bit executable, making an std::map&lt; float, T &gt; can cause infinite loops or crashes in your program.<p>This is because when you insert a value into the map, it has 80 bit precision, and that number of bits is used when comparing the value you are inserting during the traversal of the tree.<p>After the float is stored in the tree, it&#x27;s clamped to 32 bits.<p>This can cause the element to be inserted into into the wrong order in the tree, and this breaks the assumptions of the algorithm leaidng to the crash or infinite loop.<p>Compiling for 64 bits or explicitly disabling x87 float math makes this problem go away.<p>I have actually had this bug in production and it was very hard to track down.</div><br/><div id="41876406" class="c"><input type="checkbox" id="c-41876406" checked=""/><div class="controls bullet"><span class="by">jfbastien</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876269">parent</a><span>|</span><a href="#41876590">next</a><span>|</span><label class="collapse" for="c-41876406">[-]</label><label class="expand" for="c-41876406">[2 more]</label></div><br/><div class="children"><div class="content">10 years ago, a coworker had a really hard time root-causing a bug. I shoulder-debugged it by noticing the bit patterns: it was a miscompile of LLVM itself by GCC, where GCC was using an x87 fldl&#x2F;fstpl move for a union { double; int64; }. The active member was actually the int64, and GCC chose FP moved based on what was the first member of the union... but the int64 happened to be the representation of SNaN, so the instructions transformed it quietly to a qNaN as part of moving. The &quot;fix&quot; was to change the order of the union&#x27;s members in LLVM. The bug is still open, though it&#x27;s had recent activity: <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=58416" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;bugzilla&#x2F;show_bug.cgi?id=58416</a></div><br/><div id="41877021" class="c"><input type="checkbox" id="c-41877021" checked=""/><div class="controls bullet"><span class="by">ptsneves</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876406">parent</a><span>|</span><a href="#41876590">next</a><span>|</span><label class="collapse" for="c-41877021">[-]</label><label class="expand" for="c-41877021">[1 more]</label></div><br/><div class="children"><div class="content">It also affected eMacs compilation and the fix is in the trunk now.<p>Wow 11 years for such a banal minimal code trigger. I really don’t quiet understand how we can have the scale of infrastructure in operation when this kind of infrastructure software bugs exist. This is not just gcc. All the working castle of cards is an achievement by itself and also a reminder that good enough is all that is needed.<p>I also highly doubt you could get a 1 in 1000 developers to successfully debug this issue were it happening in the wild, and much smaller to actually fix it.</div><br/></div></div></div></div><div id="41876590" class="c"><input type="checkbox" id="c-41876590" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876269">parent</a><span>|</span><a href="#41876406">prev</a><span>|</span><a href="#41876377">next</a><span>|</span><label class="collapse" for="c-41876590">[-]</label><label class="expand" for="c-41876590">[3 more]</label></div><br/><div class="children"><div class="content">What use case do you have that requires indexing a hashmap by a floating point value? Keep in mind, even with a compliant implementation that isn&#x27;t widening your types behind your back, you still have to deal with NaN.<p>In fact, Rust has the Eq trait <i>specifically</i> to keep f32&#x2F;f64s out of hash tables, because NaN breaks them really bad.</div><br/><div id="41877086" class="c"><input type="checkbox" id="c-41877086" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876590">parent</a><span>|</span><a href="#41877111">next</a><span>|</span><label class="collapse" for="c-41877086">[-]</label><label class="expand" for="c-41877086">[1 more]</label></div><br/><div class="children"><div class="content">std::map is not a hash map. It&#x27;s a tree map. It supports range queries, upper and lower bound queries. Quite useful for geometric algorithms.</div><br/></div></div><div id="41877111" class="c"><input type="checkbox" id="c-41877111" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876590">parent</a><span>|</span><a href="#41877086">prev</a><span>|</span><a href="#41876377">next</a><span>|</span><label class="collapse" for="c-41877111">[-]</label><label class="expand" for="c-41877111">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you still have to deal with NaN.<p>Detecting and filtering out NaNs is both trivial and reliable as long as nobody instructs the compiler to break basic floating point operations (so no ffast-math). Dealing with a compiler that randomly changes the values of your variables is much harder.</div><br/></div></div></div></div><div id="41876377" class="c"><input type="checkbox" id="c-41876377" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876269">parent</a><span>|</span><a href="#41876590">prev</a><span>|</span><a href="#41876310">next</a><span>|</span><label class="collapse" for="c-41876377">[-]</label><label class="expand" for="c-41876377">[2 more]</label></div><br/><div class="children"><div class="content">Are you mixing up long double with float?</div><br/><div id="41877176" class="c"><input type="checkbox" id="c-41877176" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876377">parent</a><span>|</span><a href="#41876310">next</a><span>|</span><label class="collapse" for="c-41877176">[-]</label><label class="expand" for="c-41877176">[1 more]</label></div><br/><div class="children"><div class="content">Old Intel CPUs only had long double, 32 bit and 64 bit floats were a compiler hack on top of the 80 bit floating point stack.</div><br/></div></div></div></div><div id="41876310" class="c"><input type="checkbox" id="c-41876310" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876269">parent</a><span>|</span><a href="#41876377">prev</a><span>|</span><a href="#41876218">next</a><span>|</span><label class="collapse" for="c-41876310">[-]</label><label class="expand" for="c-41876310">[1 more]</label></div><br/><div class="children"><div class="content">dang that&#x27;s a good war story.</div><br/></div></div></div></div><div id="41876218" class="c"><input type="checkbox" id="c-41876218" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876108">parent</a><span>|</span><a href="#41876269">prev</a><span>|</span><a href="#41876272">next</a><span>|</span><label class="collapse" for="c-41876218">[-]</label><label class="expand" for="c-41876218">[1 more]</label></div><br/><div class="children"><div class="content">I suppose it could be harmful if you write code that depends on it without realizing it, and then something changes so it stops doing that.</div><br/></div></div><div id="41876272" class="c"><input type="checkbox" id="c-41876272" checked=""/><div class="controls bullet"><span class="by">lf37300</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41876108">parent</a><span>|</span><a href="#41876218">prev</a><span>|</span><a href="#41875950">next</a><span>|</span><label class="collapse" for="c-41876272">[-]</label><label class="expand" for="c-41876272">[1 more]</label></div><br/><div class="children"><div class="content">If not done properly, double rounding (round to extended precision then rounding to working precision) can actually introduce larger approximation error than round to nearest working precision directly. So it can actually make some numerical algorithms perform worse.</div><br/></div></div></div></div></div></div></div></div><div id="41875213" class="c"><input type="checkbox" id="c-41875213" checked=""/><div class="controls bullet"><span class="by">NL807</span><span>|</span><a href="#41875023">root</a><span>|</span><a href="#41875200">parent</a><span>|</span><a href="#41875749">prev</a><span>|</span><a href="#41874875">next</a><span>|</span><label class="collapse" for="c-41875213">[-]</label><label class="expand" for="c-41875213">[1 more]</label></div><br/><div class="children"><div class="content">Love it</div><br/></div></div></div></div></div></div><div id="41874875" class="c"><input type="checkbox" id="c-41874875" checked=""/><div class="controls bullet"><span class="by">pjdesno</span><span>|</span><a href="#41875023">prev</a><span>|</span><a href="#41875254">next</a><span>|</span><label class="collapse" for="c-41874875">[-]</label><label class="expand" for="c-41874875">[15 more]</label></div><br/><div class="children"><div class="content">During an internship in 1986 I wrote C code for a machine with 10-bit bytes, the BBN C&#x2F;70. It was a horrible experience, and the existence of the machine in the first place was due to a cosmic accident of the negative kind.</div><br/><div id="41876076" class="c"><input type="checkbox" id="c-41876076" checked=""/><div class="controls bullet"><span class="by">Isamu</span><span>|</span><a href="#41874875">parent</a><span>|</span><a href="#41875234">next</a><span>|</span><label class="collapse" for="c-41876076">[-]</label><label class="expand" for="c-41876076">[4 more]</label></div><br/><div class="children"><div class="content">I wrote code on a DECSYSTEM-20, the C compiler was not officially supported. It had a 36-bit word and a 7-bit byte. Yep, when you packed bytes into a word there were bits left over.<p>And I was tasked with reading a tape with binary data in 8-bit format. Hilarity ensued.</div><br/><div id="41876915" class="c"><input type="checkbox" id="c-41876915" checked=""/><div class="controls bullet"><span class="by">Ballas</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41876076">parent</a><span>|</span><a href="#41876112">next</a><span>|</span><label class="collapse" for="c-41876915">[-]</label><label class="expand" for="c-41876915">[1 more]</label></div><br/><div class="children"><div class="content">That is so strange. If it were 9-bit bytes, that would make sense: 8bits+parity. Then a word is just 32bits+4 parity.</div><br/></div></div><div id="41876112" class="c"><input type="checkbox" id="c-41876112" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41876076">parent</a><span>|</span><a href="#41876915">prev</a><span>|</span><a href="#41875234">next</a><span>|</span><label class="collapse" for="c-41876112">[-]</label><label class="expand" for="c-41876112">[2 more]</label></div><br/><div class="children"><div class="content">Hah. Why did they do that?</div><br/><div id="41877442" class="c"><input type="checkbox" id="c-41877442" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41876112">parent</a><span>|</span><a href="#41875234">next</a><span>|</span><label class="collapse" for="c-41877442">[-]</label><label class="expand" for="c-41877442">[1 more]</label></div><br/><div class="children"><div class="content">Which part of it?<p>8 bit tape?  Probably the format the hardware worked in... not actually sure I haven&#x27;t used real tapes but it&#x27;s plausible.<p>36 bit per word computer?  Sometimes 0..~4Billion isn&#x27;t enough.  4 more bits would get someone to 64 billion, or +&#x2F;- 32 billion.<p>As it turns out, my guess was ALMOST correct<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;36-bit_computing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;36-bit_computing</a><p>Paraphrasing, legacy keying systems were based on records of up to 10 printed decimal digits of accuracy for input.  35 bits would be required to match the +&#x2F;- input but 36 works better as a machine word and operations on 6 x 6 bit (yuck?) characters; or some &#x27;smaller&#x27; machines which used a 36 bit larger word and 12 or 18 bit small words.  Why the yuck?  That&#x27;s only 64 characters total, so these systems only supported UPPERCASE ALWAYS numeric digits and some other characters.</div><br/></div></div></div></div></div></div><div id="41875234" class="c"><input type="checkbox" id="c-41875234" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41874875">parent</a><span>|</span><a href="#41876076">prev</a><span>|</span><a href="#41874970">next</a><span>|</span><label class="collapse" for="c-41875234">[-]</label><label class="expand" for="c-41875234">[1 more]</label></div><br/><div class="children"><div class="content">I programmed the Intel Intellivision cpu which had a 10 bit &quot;decl&quot;. A wacky machine. It wasn&#x27;t powerful enough for C.</div><br/></div></div><div id="41874970" class="c"><input type="checkbox" id="c-41874970" checked=""/><div class="controls bullet"><span class="by">csours</span><span>|</span><a href="#41874875">parent</a><span>|</span><a href="#41875234">prev</a><span>|</span><a href="#41875248">next</a><span>|</span><label class="collapse" for="c-41874970">[-]</label><label class="expand" for="c-41874970">[1 more]</label></div><br/><div class="children"><div class="content">Somehow this machine found its way onto The Heart of Gold in a highly improbable chain of events.</div><br/></div></div><div id="41875248" class="c"><input type="checkbox" id="c-41875248" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#41874875">parent</a><span>|</span><a href="#41874970">prev</a><span>|</span><a href="#41875733">next</a><span>|</span><label class="collapse" for="c-41875248">[-]</label><label class="expand" for="c-41875248">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked on a machine with 9-bit bytes (and 81-bit instructions) and others with 6-bit ones - nether has a C compiler</div><br/><div id="41875983" class="c"><input type="checkbox" id="c-41875983" checked=""/><div class="controls bullet"><span class="by">corysama</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41875248">parent</a><span>|</span><a href="#41875661">next</a><span>|</span><label class="collapse" for="c-41875983">[-]</label><label class="expand" for="c-41875983">[1 more]</label></div><br/><div class="children"><div class="content">The Nintendo64 had 9-bit RAM. But, C viewed it as 8 bit. The 9th bit was only there for the RSP (GPU).</div><br/></div></div><div id="41875661" class="c"><input type="checkbox" id="c-41875661" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41875248">parent</a><span>|</span><a href="#41875983">prev</a><span>|</span><a href="#41875733">next</a><span>|</span><label class="collapse" for="c-41875661">[-]</label><label class="expand" for="c-41875661">[2 more]</label></div><br/><div class="children"><div class="content">I think the pdp-10 could have 9 bit bytes, depending on decisions you made in the compiler. I notice it&#x27;s hard to Google information about this though. People say lots of confusing, conflicting things. When I google pdp-10 byte size it says a c++ compiler chose to represent char as 36 bits.</div><br/><div id="41876849" class="c"><input type="checkbox" id="c-41876849" checked=""/><div class="controls bullet"><span class="by">larsbrinkhoff</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41875661">parent</a><span>|</span><a href="#41875733">next</a><span>|</span><label class="collapse" for="c-41876849">[-]</label><label class="expand" for="c-41876849">[1 more]</label></div><br/><div class="children"><div class="content">PDP-10 byte size is not fixed.  Bytes can be 0 to 36 bits wide.  (Sure, 0 is not very useful; still legal.)<p>I don&#x27;t think there is a C++ compiler for the PDP-10.  One of the C compiler does have a 36-bit char type.</div><br/></div></div></div></div></div></div><div id="41875733" class="c"><input type="checkbox" id="c-41875733" checked=""/><div class="controls bullet"><span class="by">aldanor</span><span>|</span><a href="#41874875">parent</a><span>|</span><a href="#41875248">prev</a><span>|</span><a href="#41875834">next</a><span>|</span><label class="collapse" for="c-41875733">[-]</label><label class="expand" for="c-41875733">[2 more]</label></div><br/><div class="children"><div class="content">10-bit arithmetics are actually not uncommon on fpgas these days and are used in production in relatively modern applications.<p>10-bit C, however, ..........</div><br/><div id="41875796" class="c"><input type="checkbox" id="c-41875796" checked=""/><div class="controls bullet"><span class="by">eulgro</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41875733">parent</a><span>|</span><a href="#41875834">next</a><span>|</span><label class="collapse" for="c-41875796">[-]</label><label class="expand" for="c-41875796">[1 more]</label></div><br/><div class="children"><div class="content">How so? Arithmetic on FPGA usually use the minimum size that works, because any size over that will use more resources than needed.<p>9-bit bytes are pretty common in block RAM though, with the extra bit being used for either for ECC or user storage.</div><br/></div></div></div></div><div id="41875834" class="c"><input type="checkbox" id="c-41875834" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41874875">parent</a><span>|</span><a href="#41875733">prev</a><span>|</span><a href="#41875254">next</a><span>|</span><label class="collapse" for="c-41875834">[-]</label><label class="expand" for="c-41875834">[2 more]</label></div><br/><div class="children"><div class="content">C itself was developed on machines that had 18 bit ints.</div><br/><div id="41876858" class="c"><input type="checkbox" id="c-41876858" checked=""/><div class="controls bullet"><span class="by">larsbrinkhoff</span><span>|</span><a href="#41874875">root</a><span>|</span><a href="#41875834">parent</a><span>|</span><a href="#41875254">next</a><span>|</span><label class="collapse" for="c-41876858">[-]</label><label class="expand" for="c-41876858">[1 more]</label></div><br/><div class="children"><div class="content">B was developed on the PDP-7.  C was developed on the PDP-11.</div><br/></div></div></div></div></div></div><div id="41875254" class="c"><input type="checkbox" id="c-41875254" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41874875">prev</a><span>|</span><a href="#41877523">next</a><span>|</span><label class="collapse" for="c-41875254">[-]</label><label class="expand" for="c-41875254">[48 more]</label></div><br/><div class="children"><div class="content">D made a great leap forward with the following:<p>1. bytes are 8 bits<p>2. shorts are 16 bits<p>3. ints are 32 bits<p>4. longs are 64 bits<p>5. arithmetic is 2&#x27;s complement<p>6. IEEE floating point<p>and a big chunk of wasted time trying to abstract these away and getting it wrong anyway was saved. Millions of people cried out in relief!<p>Oh, and Unicode was the character set. Not EBCDIC, RADIX-50, etc.</div><br/><div id="41875878" class="c"><input type="checkbox" id="c-41875878" checked=""/><div class="controls bullet"><span class="by">Laremere</span><span>|</span><a href="#41875254">parent</a><span>|</span><a href="#41875486">next</a><span>|</span><label class="collapse" for="c-41875878">[-]</label><label class="expand" for="c-41875878">[9 more]</label></div><br/><div class="children"><div class="content">Zig is even better:<p>1. u8 and i8 are 8 bits.<p>2. u16 and i16 are 16 bits.<p>3. u32 and i32 are 32 bits.<p>4. u64 and i64 are 64 bits.<p>5. Arithmetic is an explicit choice. &#x27;+&#x27; overflowing is illegal behavior (will crash in debug and releasesafe), &#x27;+%&#x27; is 2&#x27;s compliment wrapping, and &#x27;+|&#x27; is saturating arithmetic.  Edit: forgot to mention @addWithOverflow(), which provides a tuple of the original type and a u1; there&#x27;s also std.math.add(), which returns an error on overflow.<p>6. f16, f32, f64, f80, and f128 are the respective but length IEEE floating point types.<p>The question of the length of a byte doesn&#x27;t even matter.  If someone wants to compile to machine whose bytes are 12 bits, just use u12 and i12.</div><br/><div id="41877281" class="c"><input type="checkbox" id="c-41877281" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875878">parent</a><span>|</span><a href="#41876011">next</a><span>|</span><label class="collapse" for="c-41877281">[-]</label><label class="expand" for="c-41877281">[1 more]</label></div><br/><div class="children"><div class="content">Zig allows any uX and iX in the range of 1 - 65,535, as well as u0</div><br/></div></div><div id="41876011" class="c"><input type="checkbox" id="c-41876011" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875878">parent</a><span>|</span><a href="#41877281">prev</a><span>|</span><a href="#41876480">next</a><span>|</span><label class="collapse" for="c-41876011">[-]</label><label class="expand" for="c-41876011">[1 more]</label></div><br/><div class="children"><div class="content">This is the way.</div><br/></div></div><div id="41876480" class="c"><input type="checkbox" id="c-41876480" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875878">parent</a><span>|</span><a href="#41876011">prev</a><span>|</span><a href="#41876942">next</a><span>|</span><label class="collapse" for="c-41876480">[-]</label><label class="expand" for="c-41876480">[1 more]</label></div><br/><div class="children"><div class="content">Same deal with Rust.</div><br/></div></div><div id="41876942" class="c"><input type="checkbox" id="c-41876942" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875878">parent</a><span>|</span><a href="#41876480">prev</a><span>|</span><a href="#41876015">next</a><span>|</span><label class="collapse" for="c-41876942">[-]</label><label class="expand" for="c-41876942">[1 more]</label></div><br/><div class="children"><div class="content">Eh I like the nice names. Byte=8, short=16, int=32, long=64 is my preferred scheme when implementing languages. But either is better than C and C++.</div><br/></div></div><div id="41876015" class="c"><input type="checkbox" id="c-41876015" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875878">parent</a><span>|</span><a href="#41876942">prev</a><span>|</span><a href="#41875486">next</a><span>|</span><label class="collapse" for="c-41876015">[-]</label><label class="expand" for="c-41876015">[4 more]</label></div><br/><div class="children"><div class="content">How does 5 work in practice? Surely no one is actually checking if their arithmetic overflows, especially from user-supplied or otherwise external values. Is there any use for the normal +?</div><br/><div id="41876229" class="c"><input type="checkbox" id="c-41876229" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876015">parent</a><span>|</span><a href="#41875486">next</a><span>|</span><label class="collapse" for="c-41876229">[-]</label><label class="expand" for="c-41876229">[3 more]</label></div><br/><div class="children"><div class="content">You think no one checks if their arithmetic overflows?</div><br/><div id="41876357" class="c"><input type="checkbox" id="c-41876357" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876229">parent</a><span>|</span><a href="#41875486">next</a><span>|</span><label class="collapse" for="c-41876357">[-]</label><label class="expand" for="c-41876357">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure it&#x27;s not literally no one but I bet the percent of additions that have explicit checks for overflow is for all practical purposes indistinguishable from 0.</div><br/><div id="41876729" class="c"><input type="checkbox" id="c-41876729" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876357">parent</a><span>|</span><a href="#41875486">next</a><span>|</span><label class="collapse" for="c-41876729">[-]</label><label class="expand" for="c-41876729">[1 more]</label></div><br/><div class="children"><div class="content">Lots of secure code checks for overflow<p><pre><code>    fillBufferWithData(buffer, data, offset, size)
</code></pre>
You want to know that offset + size don&#x27;t wrap past 32bits (or 64) and end up with nonsense and a security vulnerability.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41875486" class="c"><input type="checkbox" id="c-41875486" checked=""/><div class="controls bullet"><span class="by">gerdesj</span><span>|</span><a href="#41875254">parent</a><span>|</span><a href="#41875878">prev</a><span>|</span><a href="#41876632">next</a><span>|</span><label class="collapse" for="c-41875486">[-]</label><label class="expand" for="c-41875486">[16 more]</label></div><br/><div class="children"><div class="content">&quot;1. bytes are 8 bits&quot;<p>How big is a bit?</div><br/><div id="41875768" class="c"><input type="checkbox" id="c-41875768" checked=""/><div class="controls bullet"><span class="by">thamer</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41876149">next</a><span>|</span><label class="collapse" for="c-41875768">[-]</label><label class="expand" for="c-41875768">[2 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t feel like a serious question, but in case this is still a mystery to you… the name <i>bit</i> is a portmanteau of <i>binary digit</i>, and as indicated by the word &quot;binary&quot;, there are only two possible digits that can be used as values for a bit: 0 and 1.</div><br/><div id="41877360" class="c"><input type="checkbox" id="c-41877360" checked=""/><div class="controls bullet"><span class="by">seoulbigchris</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875768">parent</a><span>|</span><a href="#41876149">next</a><span>|</span><label class="collapse" for="c-41877360">[-]</label><label class="expand" for="c-41877360">[1 more]</label></div><br/><div class="children"><div class="content">So trinary and quaternary digits are trits and quits?</div><br/></div></div></div></div><div id="41876149" class="c"><input type="checkbox" id="c-41876149" checked=""/><div class="controls bullet"><span class="by">basementcat</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41875768">prev</a><span>|</span><a href="#41877432">next</a><span>|</span><label class="collapse" for="c-41876149">[-]</label><label class="expand" for="c-41876149">[3 more]</label></div><br/><div class="children"><div class="content">A bit is a measure of information theoretical entropy. Specifically, one bit has been defined as the uncertainty of the outcome of a single fair coin flip. A single less than fair coin would have less than one bit of entropy; a coin that always lands heads up has zero bits, n fair coins have n bits of entropy and so on.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Information_theory" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Information_theory</a><p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Entropy_(information_theory)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Entropy_(information_theory)</a></div><br/><div id="41876245" class="c"><input type="checkbox" id="c-41876245" checked=""/><div class="controls bullet"><span class="by">fourier54</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876149">parent</a><span>|</span><a href="#41877432">next</a><span>|</span><label class="collapse" for="c-41876245">[-]</label><label class="expand" for="c-41876245">[2 more]</label></div><br/><div class="children"><div class="content">That is a bit in information theory. It has nothing to do with the computer&#x2F;digital engineering term being discussed here.</div><br/><div id="41876484" class="c"><input type="checkbox" id="c-41876484" checked=""/><div class="controls bullet"><span class="by">sirsinsalot</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876245">parent</a><span>|</span><a href="#41877432">next</a><span>|</span><label class="collapse" for="c-41876484">[-]</label><label class="expand" for="c-41876484">[1 more]</label></div><br/><div class="children"><div class="content">This comment I feel sure would repulse Shannon in the deepest way. A (digital, stored) bit, abstractly seeks to encode and make useful through computation the properties of information theory.<p>Your comment must be sarcasm or satire, surely.</div><br/></div></div></div></div></div></div><div id="41877432" class="c"><input type="checkbox" id="c-41877432" checked=""/><div class="controls bullet"><span class="by">zombot</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41876149">prev</a><span>|</span><a href="#41875701">next</a><span>|</span><label class="collapse" for="c-41877432">[-]</label><label class="expand" for="c-41877432">[1 more]</label></div><br/><div class="children"><div class="content">If your detector is sensitive enough, it could be just a single electron that&#x27;s either present or absent.</div><br/></div></div><div id="41875701" class="c"><input type="checkbox" id="c-41875701" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41877432">prev</a><span>|</span><a href="#41876238">next</a><span>|</span><label class="collapse" for="c-41875701">[-]</label><label class="expand" for="c-41875701">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How big is a bit?<p>A quarter nybble.</div><br/></div></div><div id="41876238" class="c"><input type="checkbox" id="c-41876238" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41875701">prev</a><span>|</span><a href="#41876060">next</a><span>|</span><label class="collapse" for="c-41876238">[-]</label><label class="expand" for="c-41876238">[1 more]</label></div><br/><div class="children"><div class="content">At least 2 or 3</div><br/></div></div><div id="41876060" class="c"><input type="checkbox" id="c-41876060" checked=""/><div class="controls bullet"><span class="by">nonameiguess</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41876238">prev</a><span>|</span><a href="#41875621">next</a><span>|</span><label class="collapse" for="c-41876060">[-]</label><label class="expand" for="c-41876060">[1 more]</label></div><br/><div class="children"><div class="content">How philosophical do you want to get? Technically, voltage is a continuous signal, but we sample only at clock cycle intervals, and if the sample at some cycle is below a threshold, we call that 0. Above, we call it 1. Our ability to measure whether a signal is above or below a threshold is uncertain, though, so for values where the actual difference is less than our ability to measure, we have to conclude that a bit can actually take three values: 0, 1, and we can&#x27;t tell but we have no choice but to pick one.<p>The latter value is clearly less common than 0 and 1, but how much less? I don&#x27;t know, but we have to conclude that the true size of a bit is probably something more like 1.00000000000000001 bits rather than 1 bit.</div><br/></div></div><div id="41875621" class="c"><input type="checkbox" id="c-41875621" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875486">parent</a><span>|</span><a href="#41876060">prev</a><span>|</span><a href="#41876632">next</a><span>|</span><label class="collapse" for="c-41875621">[-]</label><label class="expand" for="c-41875621">[6 more]</label></div><br/><div class="children"><div class="content">A bit is either a 0 or 1. A byte is the smallest addressable piece of memory in your architecture.</div><br/><div id="41875706" class="c"><input type="checkbox" id="c-41875706" checked=""/><div class="controls bullet"><span class="by">elromulous</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875621">parent</a><span>|</span><a href="#41875737">next</a><span>|</span><label class="collapse" for="c-41875706">[-]</label><label class="expand" for="c-41875706">[4 more]</label></div><br/><div class="children"><div class="content">Technically the smallest addressable piece of memory is a word.</div><br/><div id="41876056" class="c"><input type="checkbox" id="c-41876056" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875706">parent</a><span>|</span><a href="#41876953">next</a><span>|</span><label class="collapse" for="c-41876056">[-]</label><label class="expand" for="c-41876056">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the term word has any consistent meaning. Certainly x86 doesn&#x27;t use the term word to mean smallest addressable unit of memory. The x86 documentation defines a word as 16 bits, but x86 is byte addressable.<p>ARM is similar, ARM processors define a word as 32-bits, even on 64-bit ARM processors, but they are also byte addressable.<p>As best as I can tell, it seems like a word is whatever the size of the arithmetic or general purpose register is at the time that the processor was introduced, and even if later a new processor is introduced with larger registers, for backwards compatibility the size of a word remains the same.</div><br/></div></div><div id="41876953" class="c"><input type="checkbox" id="c-41876953" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875706">parent</a><span>|</span><a href="#41876056">prev</a><span>|</span><a href="#41876026">next</a><span>|</span><label class="collapse" for="c-41876953">[-]</label><label class="expand" for="c-41876953">[1 more]</label></div><br/><div class="children"><div class="content">Every ISA I&#x27;ve ever used has used the term &quot;word&quot; to describe a 16- or 32-bit quantity, while having instructions to load and store individual bytes (8 bit quantities). I&#x27;m pretty sure you&#x27;re straight up wrong here.</div><br/></div></div><div id="41876026" class="c"><input type="checkbox" id="c-41876026" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875706">parent</a><span>|</span><a href="#41876953">prev</a><span>|</span><a href="#41875737">next</a><span>|</span><label class="collapse" for="c-41876026">[-]</label><label class="expand" for="c-41876026">[1 more]</label></div><br/><div class="children"><div class="content">Depends on your definition of addressable.<p>Lots of CISC architectures allow memory accesses in various units even if they call general-purpose-register-sized quantities &quot;word&quot;.<p>Iirc the C standard specifies that all memory can be accessed via char*.</div><br/></div></div></div></div><div id="41875737" class="c"><input type="checkbox" id="c-41875737" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875621">parent</a><span>|</span><a href="#41875706">prev</a><span>|</span><a href="#41876632">next</a><span>|</span><label class="collapse" for="c-41875737">[-]</label><label class="expand" for="c-41875737">[1 more]</label></div><br/><div class="children"><div class="content">Which … if your heap always returns N bit aligned values, for some N … is there a name for that? The smallest heap addressable segment?</div><br/></div></div></div></div></div></div><div id="41876632" class="c"><input type="checkbox" id="c-41876632" checked=""/><div class="controls bullet"><span class="by">stkdump</span><span>|</span><a href="#41875254">parent</a><span>|</span><a href="#41875486">prev</a><span>|</span><a href="#41875539">next</a><span>|</span><label class="collapse" for="c-41876632">[-]</label><label class="expand" for="c-41876632">[2 more]</label></div><br/><div class="children"><div class="content">I mean practically speaking in C++ we have (it just hasn&#x27;t made it to the standard):<p>1. char 8 bit<p>2. short 16 bit<p>3. int 32 bit<p>4. long long 64 bit<p>5. arithmetic is 2s complement<p>6. IEEE floating point (float is 32, double is 64 bit)<p>Along with other stuff like little endian, etc.<p>Some people just mistakenly think they can&#x27;t rely on such stuff, because it isn&#x27;t in the standard. But they forget that having an ISO standard comes on top of what most other languages have, which rely solely on the documentation.</div><br/><div id="41876956" class="c"><input type="checkbox" id="c-41876956" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876632">parent</a><span>|</span><a href="#41875539">next</a><span>|</span><label class="collapse" for="c-41876956">[-]</label><label class="expand" for="c-41876956">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (it just hasn&#x27;t made it to the standard)<p>That&#x27;s the problem</div><br/></div></div></div></div><div id="41875539" class="c"><input type="checkbox" id="c-41875539" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41875254">parent</a><span>|</span><a href="#41876632">prev</a><span>|</span><a href="#41877523">next</a><span>|</span><label class="collapse" for="c-41875539">[-]</label><label class="expand" for="c-41875539">[20 more]</label></div><br/><div class="children"><div class="content">Yeah, this is something Java got right as well.  It got &quot;unsigned&quot; wrong, but it got standardizing primitive bits correct<p>byte = 8 bits<p>short = 16<p>int = 32<p>long = 64<p>float = 32 bit IEEE<p>double = 64 bit IEEE</div><br/><div id="41877440" class="c"><input type="checkbox" id="c-41877440" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875539">parent</a><span>|</span><a href="#41875597">next</a><span>|</span><label class="collapse" for="c-41877440">[-]</label><label class="expand" for="c-41877440">[1 more]</label></div><br/><div class="children"><div class="content">While I don&#x27;t agree with not having unsigned as part of the primitive times, and look forward to Valhala fixing that, it was based on the experience most devs don&#x27;t get unsigned arithmetic right.<p>&quot;For me as a language designer, which I don&#x27;t really count myself as these days, what &quot;simple&quot; really ended up meaning was could I expect J. Random Developer to hold the spec in his head. That definition says that, for instance, Java isn&#x27;t -- and in fact a lot of these languages end up with a lot of corner cases, things that nobody really understands. Quiz any C developer about unsigned, and pretty soon you discover that almost no C developers actually understand what goes on with unsigned, what unsigned arithmetic is. Things like that made C complex. The language part of Java is, I think, pretty simple. The libraries you have to look up.&quot;<p><a href="http:&#x2F;&#x2F;www.gotw.ca&#x2F;publications&#x2F;c_family_interview.htm" rel="nofollow">http:&#x2F;&#x2F;www.gotw.ca&#x2F;publications&#x2F;c_family_interview.htm</a></div><br/></div></div><div id="41875597" class="c"><input type="checkbox" id="c-41875597" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875539">parent</a><span>|</span><a href="#41877440">prev</a><span>|</span><a href="#41875634">next</a><span>|</span><label class="collapse" for="c-41875597">[-]</label><label class="expand" for="c-41875597">[11 more]</label></div><br/><div class="children"><div class="content">I like the Rust approach more: usize&#x2F;isize are the native integer types, and with every other numeric type, you have to mention the size explicitly.<p>On the C++ side, I sometimes use an alias that contains the word &quot;short&quot; for 32-bit integers. When I use them, I&#x27;m explicitly assuming that the numbers are small enough to fit in a smaller than usual integer type, and that it&#x27;s critical enough to performance that the assumption is worth making.</div><br/><div id="41875827" class="c"><input type="checkbox" id="c-41875827" checked=""/><div class="controls bullet"><span class="by">jonstewart</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875597">parent</a><span>|</span><a href="#41875695">next</a><span>|</span><label class="collapse" for="c-41875827">[-]</label><label class="expand" for="c-41875827">[1 more]</label></div><br/><div class="children"><div class="content">&lt;cstdint&gt; has int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, and uint64_t. I still go back and forth between uint64_t, size_t, and unsigned int, but am defaulting to uint64_t more and more, even if it doesn&#x27;t matter.</div><br/></div></div><div id="41875695" class="c"><input type="checkbox" id="c-41875695" checked=""/><div class="controls bullet"><span class="by">Jerrrrrrry</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875597">parent</a><span>|</span><a href="#41875827">prev</a><span>|</span><a href="#41875847">next</a><span>|</span><label class="collapse" for="c-41875695">[-]</label><label class="expand" for="c-41875695">[1 more]</label></div><br/><div class="children"><div class="content">hindsight has its advantages</div><br/></div></div><div id="41875847" class="c"><input type="checkbox" id="c-41875847" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875597">parent</a><span>|</span><a href="#41875695">prev</a><span>|</span><a href="#41875634">next</a><span>|</span><label class="collapse" for="c-41875847">[-]</label><label class="expand" for="c-41875847">[8 more]</label></div><br/><div class="children"><div class="content">&gt; <i>you have to mention the size explicitly</i><p>It&#x27;s unbelievably ugly. Every piece of code working with any kind of integer screams &quot;I am hardware dependent in some way&quot;.<p>E.g. in a structure representing an automobile, the number of wheels has to be some i8 or i16, which looks ridiculous.<p>Why would you take a language in which you can write functional pipelines over collections of objects, and make it look like assembler.</div><br/><div id="41875953" class="c"><input type="checkbox" id="c-41875953" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875847">parent</a><span>|</span><a href="#41876035">next</a><span>|</span><label class="collapse" for="c-41875953">[-]</label><label class="expand" for="c-41875953">[6 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t care about the size of your number, just use isize or usize.<p>If you do care, then isn&#x27;t it better to specify it explicitly than trying to guess it and having different compilers disagreeing on the size?</div><br/><div id="41875968" class="c"><input type="checkbox" id="c-41875968" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875953">parent</a><span>|</span><a href="#41876035">next</a><span>|</span><label class="collapse" for="c-41875968">[-]</label><label class="expand" for="c-41875968">[5 more]</label></div><br/><div class="children"><div class="content">A type called <i>isize</i> is some kind of size. It looks wrong for something that isn&#x27;t a size.</div><br/><div id="41876423" class="c"><input type="checkbox" id="c-41876423" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875968">parent</a><span>|</span><a href="#41876035">next</a><span>|</span><label class="collapse" for="c-41876423">[-]</label><label class="expand" for="c-41876423">[4 more]</label></div><br/><div class="children"><div class="content">Then just define a type alias, which is good practice if you want your types to be more descriptive: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;type-aliases.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;type-aliases.html</a></div><br/><div id="41876975" class="c"><input type="checkbox" id="c-41876975" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876423">parent</a><span>|</span><a href="#41876035">next</a><span>|</span><label class="collapse" for="c-41876975">[-]</label><label class="expand" for="c-41876975">[3 more]</label></div><br/><div class="children"><div class="content">Nope! Because then you will also define an alias, and Suzy will define an alias, and Bob will define an alias, ...<p>We should all agree on <i>int</i> and <i>uint</i>; not some <i>isize</i> nonsense, and not <i>bobint</i> or <i>suzyint</i>.</div><br/><div id="41877189" class="c"><input type="checkbox" id="c-41877189" checked=""/><div class="controls bullet"><span class="by">pezezin</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876975">parent</a><span>|</span><a href="#41877079">next</a><span>|</span><label class="collapse" for="c-41877189">[-]</label><label class="expand" for="c-41877189">[1 more]</label></div><br/><div class="children"><div class="content">Ok, it is obvious that you are looking for something to complaint about and don&#x27;t want to find a solution. That is not a productive attitude in life, but whatever floats your boat. Have a good day.</div><br/></div></div><div id="41877079" class="c"><input type="checkbox" id="c-41877079" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41876975">parent</a><span>|</span><a href="#41877189">prev</a><span>|</span><a href="#41876035">next</a><span>|</span><label class="collapse" for="c-41877079">[-]</label><label class="expand" for="c-41877079">[1 more]</label></div><br/><div class="children"><div class="content">Alas, it&#x27;s pretty clear that we <i>won&#x27;t!</i></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41876035" class="c"><input type="checkbox" id="c-41876035" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875847">parent</a><span>|</span><a href="#41875953">prev</a><span>|</span><a href="#41875634">next</a><span>|</span><label class="collapse" for="c-41876035">[-]</label><label class="expand" for="c-41876035">[1 more]</label></div><br/><div class="children"><div class="content">Is it any better calling it an int where it&#x27;s assumed to be an i32 and 30 of the bits are wasted.</div><br/></div></div></div></div></div></div><div id="41875634" class="c"><input type="checkbox" id="c-41875634" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875539">parent</a><span>|</span><a href="#41875597">prev</a><span>|</span><a href="#41877523">next</a><span>|</span><label class="collapse" for="c-41875634">[-]</label><label class="expand" for="c-41875634">[7 more]</label></div><br/><div class="children"><div class="content">Yep. Pity about getting chars &#x2F; string encoding wrong though. (Java chars are 16 bits).<p>But it’s not alone in that mistake. All the languages invented in that era made the same mistake. (C#, JavaScript, etc).</div><br/><div id="41876445" class="c"><input type="checkbox" id="c-41876445" checked=""/><div class="controls bullet"><span class="by">davidgay</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875634">parent</a><span>|</span><a href="#41876204">next</a><span>|</span><label class="collapse" for="c-41876445">[-]</label><label class="expand" for="c-41876445">[1 more]</label></div><br/><div class="children"><div class="content">Java was just unlucky, it standardised it&#x27;s strings at the wrong time (when Unicode was 16-bit code points):
  Java was announced in May 1995, and the following comment from the Unicode history wiki page makes it clear what happened: &quot;In 1996, a surrogate character mechanism was implemented in Unicode 2.0, so that Unicode was no longer restricted to 16 bits.  ...&quot;</div><br/></div></div><div id="41876204" class="c"><input type="checkbox" id="c-41876204" checked=""/><div class="controls bullet"><span class="by">jeberle</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875634">parent</a><span>|</span><a href="#41876445">prev</a><span>|</span><a href="#41875696">next</a><span>|</span><label class="collapse" for="c-41876204">[-]</label><label class="expand" for="c-41876204">[1 more]</label></div><br/><div class="children"><div class="content">Java strings are byte[]&#x27;s if their contents contain only Latin-1 values (the first 256 codepoints of Unicode). This shipped in Java 9.<p>JEP 254: Compact Strings<p><a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;254" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;254</a></div><br/></div></div><div id="41875696" class="c"><input type="checkbox" id="c-41875696" checked=""/><div class="controls bullet"><span class="by">paragraft</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875634">parent</a><span>|</span><a href="#41876204">prev</a><span>|</span><a href="#41877523">next</a><span>|</span><label class="collapse" for="c-41875696">[-]</label><label class="expand" for="c-41875696">[4 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the right way?</div><br/><div id="41875771" class="c"><input type="checkbox" id="c-41875771" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875696">parent</a><span>|</span><a href="#41875782">next</a><span>|</span><label class="collapse" for="c-41875771">[-]</label><label class="expand" for="c-41875771">[1 more]</label></div><br/><div class="children"><div class="content">UTF-8<p>When D was first implemented, circa 2000, it wasn&#x27;t clear whether UTF-8, UTF-16, or UTF-32 was going to be the winner. So D supported all three.</div><br/></div></div><div id="41875782" class="c"><input type="checkbox" id="c-41875782" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875696">parent</a><span>|</span><a href="#41875771">prev</a><span>|</span><a href="#41877523">next</a><span>|</span><label class="collapse" for="c-41875782">[-]</label><label class="expand" for="c-41875782">[2 more]</label></div><br/><div class="children"><div class="content">utf8, for essentially the reasons mentioned in this manifesto: <a href="https:&#x2F;&#x2F;utf8everywhere.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;utf8everywhere.org&#x2F;</a></div><br/><div id="41875952" class="c"><input type="checkbox" id="c-41875952" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41875254">root</a><span>|</span><a href="#41875782">parent</a><span>|</span><a href="#41877523">next</a><span>|</span><label class="collapse" for="c-41875952">[-]</label><label class="expand" for="c-41875952">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Notably supported by go, python3, rust and swift. And probably all new programming languages created from here on.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41877523" class="c"><input type="checkbox" id="c-41877523" checked=""/><div class="controls bullet"><span class="by">RJIb8RBYxzAMX9u</span><span>|</span><a href="#41875254">prev</a><span>|</span><a href="#41874997">next</a><span>|</span><label class="collapse" for="c-41877523">[-]</label><label class="expand" for="c-41877523">[1 more]</label></div><br/><div class="children"><div class="content">While we&#x27;re at it, perhaps we should also presume little-endian byte order. As much as I prefer big-endian, little-endian had <i>won</i>.<p>As consolation, big-endian will likely live on forever as the network byte order.</div><br/></div></div><div id="41874997" class="c"><input type="checkbox" id="c-41874997" checked=""/><div class="controls bullet"><span class="by">MaulingMonkey</span><span>|</span><a href="#41877523">prev</a><span>|</span><a href="#41874909">next</a><span>|</span><label class="collapse" for="c-41874997">[-]</label><label class="expand" for="c-41874997">[7 more]</label></div><br/><div class="children"><div class="content">Some people are still dealing with DSPs.<p><a href="https:&#x2F;&#x2F;thephd.dev&#x2F;conformance-should-mean-something-fputc-and-freestanding#we-cannot-program-on--vibes-" rel="nofollow">https:&#x2F;&#x2F;thephd.dev&#x2F;conformance-should-mean-something-fputc-a...</a><p>Me?  I just dabble with documenting an unimplemented &quot;50% more bits per byte than the competition!&quot; 12-bit fantasy console of my own invention - replete with inventions such as &quot;UTF-12&quot; - for shits and giggles.</div><br/><div id="41875875" class="c"><input type="checkbox" id="c-41875875" checked=""/><div class="controls bullet"><span class="by">jfbastien</span><span>|</span><a href="#41874997">parent</a><span>|</span><a href="#41875020">next</a><span>|</span><label class="collapse" for="c-41875875">[-]</label><label class="expand" for="c-41875875">[3 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;m trying to figure out which are still relevant and whether they target a modern C++, or intend to. I&#x27;ve been asking for a few years and haven&#x27;t gotten positive answers. The only one that been brought up is TI, I added info in the updated draft: <a href="https:&#x2F;&#x2F;isocpp.org&#x2F;files&#x2F;papers&#x2F;D3477R1.html" rel="nofollow">https:&#x2F;&#x2F;isocpp.org&#x2F;files&#x2F;papers&#x2F;D3477R1.html</a></div><br/><div id="41876413" class="c"><input type="checkbox" id="c-41876413" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#41874997">root</a><span>|</span><a href="#41875875">parent</a><span>|</span><a href="#41875020">next</a><span>|</span><label class="collapse" for="c-41876413">[-]</label><label class="expand" for="c-41876413">[2 more]</label></div><br/><div class="children"><div class="content">&gt; and would benefit from C23’s _BigInt<p>s&#x2F;_BigInt&#x2F;_BitInt&#x2F;</div><br/><div id="41876489" class="c"><input type="checkbox" id="c-41876489" checked=""/><div class="controls bullet"><span class="by">jfbastien</span><span>|</span><a href="#41874997">root</a><span>|</span><a href="#41876413">parent</a><span>|</span><a href="#41875020">next</a><span>|</span><label class="collapse" for="c-41876489">[-]</label><label class="expand" for="c-41876489">[1 more]</label></div><br/><div class="children"><div class="content">Dang, will fix when I get home! Thanks Nick, and hi!</div><br/></div></div></div></div></div></div><div id="41875020" class="c"><input type="checkbox" id="c-41875020" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41874997">parent</a><span>|</span><a href="#41875875">prev</a><span>|</span><a href="#41875142">next</a><span>|</span><label class="collapse" for="c-41875020">[-]</label><label class="expand" for="c-41875020">[1 more]</label></div><br/><div class="children"><div class="content">They can just target C++23 or earlier, right? I have a small collection of SHARCs but I am not going to go crying to the committee if they make C++30 (or whatever) not support CHAR_BIT=32</div><br/></div></div><div id="41875142" class="c"><input type="checkbox" id="c-41875142" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41874997">parent</a><span>|</span><a href="#41875020">prev</a><span>|</span><a href="#41874909">next</a><span>|</span><label class="collapse" for="c-41875142">[-]</label><label class="expand" for="c-41875142">[2 more]</label></div><br/><div class="children"><div class="content">no doubt you&#x27;ve got your brainfuck compiler hard at work on this ...</div><br/><div id="41875767" class="c"><input type="checkbox" id="c-41875767" checked=""/><div class="controls bullet"><span class="by">defrost</span><span>|</span><a href="#41874997">root</a><span>|</span><a href="#41875142">parent</a><span>|</span><a href="#41874909">next</a><span>|</span><label class="collapse" for="c-41875767">[-]</label><label class="expand" for="c-41875767">[1 more]</label></div><br/><div class="children"><div class="content">TI DSP Assembler is pretty high level, it&#x27;s &quot;almost C&quot; already.<p>Writing geophysical | military signal and image processing applications on custom DSP clusters is suprisingly straightforward and doesn&#x27;t need C++.<p>It&#x27;s a RISC architecture optimised for DSP | FFT | Array processing with the basic simplification that char text is for hosts, integers and floats are at least 32 bit and 32 bits (or 64) is the smallest addressable unit.<p>Fantastic architecture to work with for numerics, deep computational pipelines, once &quot;primed&quot; you push in raw aquisition samples in chunks <i>every clock cycle</i> and extract processed moving window data chunks <i>every clock cycle</i>.<p>A single ASM instruction in a cycle can accumulate totals from vector  multiplication and modulo update indexes on three vectors (two inputs and and out).<p>Not your mama&#x27;s brainfuck.</div><br/></div></div></div></div></div></div><div id="41874909" class="c"><input type="checkbox" id="c-41874909" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#41874997">prev</a><span>|</span><a href="#41876138">next</a><span>|</span><label class="collapse" for="c-41874909">[-]</label><label class="expand" for="c-41874909">[20 more]</label></div><br/><div class="children"><div class="content">Is C++ capable of deprecating or simplifying anything?<p>Honest question, haven&#x27;t followed closely. rand() is broken,I;m told unfixable and last I heard still wasn&#x27;t deprecated.<p>Is this proposal a test? &quot;Can we even drop support for a solution to a problem literally nobody has?&quot;</div><br/><div id="41877466" class="c"><input type="checkbox" id="c-41877466" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41876970">next</a><span>|</span><label class="collapse" for="c-41877466">[-]</label><label class="expand" for="c-41877466">[1 more]</label></div><br/><div class="children"><div class="content">GC API from C++11 was removed in C++23, understandibly so, given that it wasn&#x27;t designed taking into account the needs of Unreal C++ and C++&#x2F;CLI, the only two major variants that have GC support.<p>Exception specifications have been removed, although some want them back for value type exceptions, if that ever happens.<p>auto_ptr has been removed, given its broken design.<p>Now on the simplying side, not really, as the old ways still need to be understood.</div><br/></div></div><div id="41876970" class="c"><input type="checkbox" id="c-41876970" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41877466">prev</a><span>|</span><a href="#41875009">next</a><span>|</span><label class="collapse" for="c-41876970">[-]</label><label class="expand" for="c-41876970">[1 more]</label></div><br/><div class="children"><div class="content">How is rand() broken? It seems to produce random-ish values, which is what it&#x27;s for. It obviously doesn&#x27;t produce cryptographically secure random values, but that&#x27;s expected (and reflects other languages&#x27; equivalent functions). For a decently random integer that&#x27;s quick to compute, rand() works just fine.</div><br/></div></div><div id="41875009" class="c"><input type="checkbox" id="c-41875009" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41876970">prev</a><span>|</span><a href="#41875887">next</a><span>|</span><label class="collapse" for="c-41875009">[-]</label><label class="expand" for="c-41875009">[1 more]</label></div><br/><div class="children"><div class="content">Signed integers did not have to be 2’s complement, there were 3 valid representations: signed mag, 1s and  2s complement. Modern C and C++ dropped this and mandate 2s complement (“as if” but that distinction is moot here, you can do the same for CHAR_BIT). So there is certainly precedence for this sort of thing.</div><br/></div></div><div id="41875887" class="c"><input type="checkbox" id="c-41875887" checked=""/><div class="controls bullet"><span class="by">jfbastien</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41875009">prev</a><span>|</span><a href="#41875757">next</a><span>|</span><label class="collapse" for="c-41875887">[-]</label><label class="expand" for="c-41875887">[1 more]</label></div><br/><div class="children"><div class="content">As mentioned by others, we&#x27;ve dropped trigraph and deprecated rand (and offer an alternative). I also have:<p>* p2809 Trivial infinite loops are not Undefined Behavior
* p1152 Deprecating volatile
* p0907 Signed Integers are Two&#x27;s Complement
* p2723 Zero-initialize objects of automatic storage duration
* p2186 Removing Garbage Collection Support<p>So it is possible to change things!</div><br/></div></div><div id="41875757" class="c"><input type="checkbox" id="c-41875757" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41875887">prev</a><span>|</span><a href="#41875407">next</a><span>|</span><label class="collapse" for="c-41875757">[-]</label><label class="expand" for="c-41875757">[2 more]</label></div><br/><div class="children"><div class="content">I think you are right. Absolutely.<p>Don’t break perfection!! Just accumulate more perfection.<p>What we need is a new C++ symbol that reliably references eight bit bytes, without breaking compatibility, or wasting annnnnny opportunity to expand the kitchen sink once again.<p>I propose “unsigned byte8” and (2’s complement) “signed byte8”. And “byte8” with undefined sign behavior because we can always use some more spice.<p>“unsigned decimal byte8” and “signed decimal byte8”, would limit legal values to 0 to 10 and -10 to +10.<p>For the damn accountants.<p>“unsigned centimal byte8” and “signed centimal byte8”, would limit legal values to 0 to 100 and -100 to +100.<p>For the damn accountants who care about the cost of bytes.<p>Also for a statistically almost valid, good enough for your customer’s alpha, data type for “age” fields in databases.<p>And “float byte8” obviously.</div><br/><div id="41876095" class="c"><input type="checkbox" id="c-41876095" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875757">parent</a><span>|</span><a href="#41875407">next</a><span>|</span><label class="collapse" for="c-41876095">[-]</label><label class="expand" for="c-41876095">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For the damn accountants who care about the cost of bytes.<p>Finally! A language that can calculate my S3 bill</div><br/></div></div></div></div><div id="41875407" class="c"><input type="checkbox" id="c-41875407" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41875757">prev</a><span>|</span><a href="#41875528">next</a><span>|</span><label class="collapse" for="c-41875407">[-]</label><label class="expand" for="c-41875407">[2 more]</label></div><br/><div class="children"><div class="content">C++ long ago crossed the line where making any change is more work than any benefit it could ever create.</div><br/><div id="41877472" class="c"><input type="checkbox" id="c-41877472" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875407">parent</a><span>|</span><a href="#41875528">next</a><span>|</span><label class="collapse" for="c-41877472">[-]</label><label class="expand" for="c-41877472">[1 more]</label></div><br/><div class="children"><div class="content">It is one of my favourite languages, but I think it has already crossed over the complexity threshold PL&#x2F;I was known for.</div><br/></div></div></div></div><div id="41875528" class="c"><input type="checkbox" id="c-41875528" checked=""/><div class="controls bullet"><span class="by">mrpippy</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41875407">prev</a><span>|</span><a href="#41875032">next</a><span>|</span><label class="collapse" for="c-41875528">[-]</label><label class="expand" for="c-41875528">[2 more]</label></div><br/><div class="children"><div class="content">C++17 removed trigraphs</div><br/><div id="41875630" class="c"><input type="checkbox" id="c-41875630" checked=""/><div class="controls bullet"><span class="by">poincaredisk</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875528">parent</a><span>|</span><a href="#41875032">next</a><span>|</span><label class="collapse" for="c-41875630">[-]</label><label class="expand" for="c-41875630">[1 more]</label></div><br/><div class="children"><div class="content">Which was quite controversial. Imagine that.</div><br/></div></div></div></div><div id="41875032" class="c"><input type="checkbox" id="c-41875032" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#41874909">parent</a><span>|</span><a href="#41875528">prev</a><span>|</span><a href="#41876138">next</a><span>|</span><label class="collapse" for="c-41875032">[-]</label><label class="expand" for="c-41875032">[9 more]</label></div><br/><div class="children"><div class="content">well they managed to get two&#x27;s complement requirement into C++20. there is always hope.</div><br/><div id="41875491" class="c"><input type="checkbox" id="c-41875491" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875032">parent</a><span>|</span><a href="#41876138">next</a><span>|</span><label class="collapse" for="c-41875491">[-]</label><label class="expand" for="c-41875491">[8 more]</label></div><br/><div class="children"><div class="content">Well then someone somewhere with some mainframe got so angry they decided to write a manifesto to condemn kids these days and announced a fork of Qt because Qt committed the cardinal sin of adopting C++20. So don’t say “a problem literally nobody has”, someone always has a use case; although at some point it’s okay to make a decision to ignore them.<p><a href="https:&#x2F;&#x2F;lscs-software.com&#x2F;LsCs-Manifesto.html" rel="nofollow">https:&#x2F;&#x2F;lscs-software.com&#x2F;LsCs-Manifesto.html</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41614949">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41614949</a><p>Edit: Fixed typo pointed out by child.</div><br/><div id="41875583" class="c"><input type="checkbox" id="c-41875583" checked=""/><div class="controls bullet"><span class="by">ripe</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875491">parent</a><span>|</span><a href="#41876055">next</a><span>|</span><label class="collapse" for="c-41875583">[-]</label><label class="expand" for="c-41875583">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because Qt committed the carnal sin of adopting C++20<p>I do believe you meant to write &quot;cardinal sin,&quot; good sir. Unless Qt has not only become sentient but also corporeal when I wasn&#x27;t looking and gotten close and personal with the C++ standard...</div><br/></div></div><div id="41876055" class="c"><input type="checkbox" id="c-41876055" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875491">parent</a><span>|</span><a href="#41875583">prev</a><span>|</span><a href="#41875873">next</a><span>|</span><label class="collapse" for="c-41876055">[-]</label><label class="expand" for="c-41876055">[3 more]</label></div><br/><div class="children"><div class="content">This person is unhinged.<p>&gt; It&#x27;s a desktop on a Linux distro meant to create devices to better&#x2F;save lives.<p>If you are creating life critical medical devices you should not be using linux.</div><br/><div id="41876446" class="c"><input type="checkbox" id="c-41876446" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41876055">parent</a><span>|</span><a href="#41875873">next</a><span>|</span><label class="collapse" for="c-41876446">[-]</label><label class="expand" for="c-41876446">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If you are creating life critical medical devices you should not be using linux.<p>Hmm, what do you mean?<p>Like, no you should not adopt some buggy or untested distro, instead choose each component carefully and disable all un-needed updates...<p>But that beats working on an unstable, randomly and capriciously deprecated and broken OS (windows&#x2F;mac over the years), that you can perform zero practical review, casual or otherwise, legal or otherwise, and that insists upon updating and further breaking itself at regular intervals...<p>Unless you mean to talk maybe about some microkernel with a very simple graphical UI, which, sure yes, much less complexity...</div><br/><div id="41876522" class="c"><input type="checkbox" id="c-41876522" checked=""/><div class="controls bullet"><span class="by">__turbobrew__</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41876446">parent</a><span>|</span><a href="#41875873">next</a><span>|</span><label class="collapse" for="c-41876522">[-]</label><label class="expand" for="c-41876522">[1 more]</label></div><br/><div class="children"><div class="content">I mean you should be building life critical medical devices on top of an operating system like QNX or vxworks which are much more stable and simpler.</div><br/></div></div></div></div></div></div><div id="41875873" class="c"><input type="checkbox" id="c-41875873" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875491">parent</a><span>|</span><a href="#41876055">prev</a><span>|</span><a href="#41876138">next</a><span>|</span><label class="collapse" for="c-41875873">[-]</label><label class="expand" for="c-41875873">[3 more]</label></div><br/><div class="children"><div class="content">Wow.<p><a href="https:&#x2F;&#x2F;theminimumyouneedtoknow.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;theminimumyouneedtoknow.com&#x2F;</a><p><a href="https:&#x2F;&#x2F;lscs-software.com&#x2F;LsCs-Roadmap.html" rel="nofollow">https:&#x2F;&#x2F;lscs-software.com&#x2F;LsCs-Roadmap.html</a><p>&quot;Many of us got our first exposure to Qt on OS&#x2F;2 in or around 1987.&quot;<p>Uh huh.<p>&gt; someone always has a use case;<p>No he doesn&#x27;t. He&#x27;s just unhinged. The machines this dude bitches about don&#x27;t even have a modern C++ compiler nor do they support any kind of display system relevant to Qt. They&#x27;re never going to be a target for Qt.
Further irony is this dude proudly proclaims this fork will support nothing but Wayland and Vulkan on Linux.<p>&quot;the smaller processors like those in sensors, are 1&#x27;s complement for a reason.&quot;<p>The &quot;reason&quot; is never explained.<p>&quot;Why? Because nothing is faster when it comes to straight addition and subtraction of financial values in scaled integers. (Possibly packed decimal too, but uncertain on that.)&quot;<p>Is this a justification for using Unisys mainframes, or is the implication that they are fastest because of 1&#x27;s complement? (not that this is even close to being true - as any dinosaurs are decomissioned they&#x27;re fucking replaced with capable but not TOL commodity Xeon CPU based hardware running emulation, I don&#x27;t think Unisys makes any non x86 hardware anymore)  Anyway, may need to refresh that CS education.<p>There&#x27;s some rambling about the justification being data conversion, but what serialization protocols mandate 1&#x27;s complement anyway, and if those exist someone has already implemented 2&#x27;s complement supporting libraries for the past 50 years since that has been the overwhelming status quo. We somehow manage to deal with endianness and decimal conversions as well.<p>&quot;Passing 2&#x27;s complement data to backend systems or front end sensors expecting 1&#x27;s complement causes catastrophes.&quot;<p>99.999% of every system MIPS, ARM, x86, Power, etc for the last 40 years uses 2&#x27;s complement, so this has been the normal state of the world since forever.<p>Also the enterpriseist of languages, Java somehow has survived mandating 2&#x27;s complement.<p>This is all very unhinged.<p>I&#x27;m not holding my breath to see this ancient Qt fork fully converted to &quot;modified&quot; Barr spec but that will be a hoot.</div><br/><div id="41876530" class="c"><input type="checkbox" id="c-41876530" checked=""/><div class="controls bullet"><span class="by">smaudet</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41875873">parent</a><span>|</span><a href="#41876138">next</a><span>|</span><label class="collapse" for="c-41876530">[-]</label><label class="expand" for="c-41876530">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, I think many of their arguments are not quite up to snuff. I would be quite interested how 1s compliment is faster, it is simpler and thus the hardware could be faster, iff you figure out how to deal with the drawbacks like -0 vs +0 (you could do it in hardware pretty easily...)<p>Buuuut then the Unisys thing. Like you say they dont make processors (for the market) and themselves just use Intel now...and even if they make some special secret processors I don&#x27;t think the IRS is using top secret processors to crunch our taxes, even in the hundreds of millions of record realm with average hundreds of items per record, modern CPUs run at billions of ops per second...so I suspect we are talking some tens of seconds, and some modest amount of RAM (for a server).<p>The one point he does have is interoperability, which if a lot of (especially medical) equipment uses 1s compliment because its cheaper (in terms of silicon), using &quot;modern&quot; tools is likely to be a bad fit.<p>Compatability is King, and where medical devices are concerned I would be inclined to agree that not changing things is better than &quot;upgrading&quot; - its all well and good to have two systems until a crisis hits and some doctor plus the wrong sensor into the wrong device...</div><br/><div id="41876811" class="c"><input type="checkbox" id="c-41876811" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41874909">root</a><span>|</span><a href="#41876530">parent</a><span>|</span><a href="#41876138">next</a><span>|</span><label class="collapse" for="c-41876811">[-]</label><label class="expand" for="c-41876811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The one point he does have is interoperability, which if a lot of (especially medical) equipment uses 1s compliment<p>No it’s completely loony. Note that even the devices he claims to work with for medical devices are off the shelf ARM processors (ie what everybody uses). No commonly used commodity processors for embedded have used 1’s complement in the last 50 years.<p>&gt; equipment uses 1s compliment because its cheaper (in terms of silicon)<p>Yeah that makes no sense. 
If you need an ALU at all, 2s complement requires no more silicon and is <i>simpler</i> to work with. That’s why it was recommended by von Neumann in 1945.
1s complement is only simpler if you don’t have an adder of any kind, which is then not a CPU, certainly not a C&#x2F;C++ target.<p>Even the shittiest low end PIC microcontroller from the 70s uses 2s complement.<p>It is possible that a sensing device with no microprocessor or computation of any kind (ie a bare ADC) may generate values in sign-mag or 1s complement (and it’s usually the former, again how stupid this is) - but this has nothing to do with the C implementation of whatever host connects to it which is certainly 2s. I guarantee you no embedded processor this dude ever worked with in the medical industry used anything other than 2s complement - you would have <i>always</i> needed to do a conversion.<p>This truly is one of the most absurd issues to get wrapped up on. It might be dementia, sadly.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;RolandHughes&#x2F;ls-cs&#x2F;blob&#x2F;master&#x2F;README.md">https:&#x2F;&#x2F;github.com&#x2F;RolandHughes&#x2F;ls-cs&#x2F;blob&#x2F;master&#x2F;README.md</a><p>Maintaining a fork of a large C++ framework (well of another obscure fork) where the top most selling point is a fixation on avoiding C++20 all because they dropped support for integer representations that have no extant hardware with recent C++ compilers - and any theoretical hardware wouldn’t run this framework anyway, that doesn’t seem well attached to reality.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41876138" class="c"><input type="checkbox" id="c-41876138" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#41874909">prev</a><span>|</span><a href="#41876974">next</a><span>|</span><label class="collapse" for="c-41876138">[-]</label><label class="expand" for="c-41876138">[4 more]</label></div><br/><div class="children"><div class="content">I have mixed feelings about this. On the one hand, it&#x27;s obviously correct--there is no meaningful use for CHAR_BIT to be anything other than 8.<p>On the other hand, it seems like some sort of <i>concession</i> to the idea that you are entitled to some sort of just world where things make sense and can be reasoned out given your own personal, deeply oversimplified model of what&#x27;s going on inside the computer. This approach can take you pretty far, but it&#x27;s a garden path that goes nowhere--eventually you must admit that you know nothing and the best you can do is a formal argument that conditional on the documentation being correct you have constructed a correct program.<p>This is a huge intellectual leap, and in my personal experience the further you go without being forced to acknowledge it the harder it will be to make the jump.<p>That said, there seems to be an increasing popularity of physical electronics projects among the novice set these days... hopefully read the damn spec sheet will become the new read the documentation</div><br/><div id="41876249" class="c"><input type="checkbox" id="c-41876249" checked=""/><div class="controls bullet"><span class="by">joelignaatius</span><span>|</span><a href="#41876138">parent</a><span>|</span><a href="#41877226">next</a><span>|</span><label class="collapse" for="c-41876249">[-]</label><label class="expand" for="c-41876249">[2 more]</label></div><br/><div class="children"><div class="content">As with any highly used language you end up running into what I call the COBOL problem. It will work for the vast majority of cases except where there&#x27;s a system that forces an update and all of a sudden a traffic control system doesn&#x27;t work or a plane falls out of the sky.<p>You&#x27;d have to have some way of testing all previous code in the compilation (pardon my ignorance if this is somehow obvious) to make sure this macro isn&#x27;t already used. You also risk forking the language with any kind of breaking changes like this. How difficult it would be to test if a previous code base uses a charbit macro and whether it can be updated to the new compiler sounds non obvious. What libraries would then be considered breaking? Would interacting with other compiled code (possibly stupid question) that used charbit also cause problems? Just off the top of my head.<p>I agree that it sounds nonintuitive. I&#x27;d suggest creating a conversion tool first and demonstrating it was safe to use even in extreme cases and then make the conversion. But that&#x27;s just my unenlightened opinion.</div><br/><div id="41876505" class="c"><input type="checkbox" id="c-41876505" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#41876138">root</a><span>|</span><a href="#41876249">parent</a><span>|</span><a href="#41877226">next</a><span>|</span><label class="collapse" for="c-41876505">[-]</label><label class="expand" for="c-41876505">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not really the problem here--CHAR_BIT is already 8 everywhere in practice, and all real existing code[1] handles CHAR_BIT being 8.<p>The question is &quot;does any code need to care about CHAR_BIT &gt; 8 platforms&quot; and the answer of course is no, its just should we  perform the occult standards ceremony to acknowledge this, or continue to ritually pretend to standards compliant 16 bit DSPs are a thing.<p>[1] I&#x27;m sure artifacts of 7, 9, 16, 32, etc[2] bit code &amp; platforms exist, but they aren&#x27;t targeting  or implementing anything resembling modern ISO C++ and can continue to exist without anyone&#x27;s permission.<p>[2] if we&#x27;re going for unconventional bitness my money&#x27;s on 53, which at least has practical uses in 2024</div><br/></div></div></div></div><div id="41877226" class="c"><input type="checkbox" id="c-41877226" checked=""/><div class="controls bullet"><span class="by">technion</span><span>|</span><a href="#41876138">parent</a><span>|</span><a href="#41876249">prev</a><span>|</span><a href="#41876974">next</a><span>|</span><label class="collapse" for="c-41877226">[-]</label><label class="expand" for="c-41877226">[1 more]</label></div><br/><div class="children"><div class="content">And yet every time I run an autoconf script I watch as it checks the bits in a byte and saves the output in config.h as though anyone planned to act on it.</div><br/></div></div></div></div><div id="41876974" class="c"><input type="checkbox" id="c-41876974" checked=""/><div class="controls bullet"><span class="by">js8</span><span>|</span><a href="#41876138">prev</a><span>|</span><a href="#41875864">next</a><span>|</span><label class="collapse" for="c-41876974">[-]</label><label class="expand" for="c-41876974">[2 more]</label></div><br/><div class="children"><div class="content">Nothing to do with C++, but:<p>I kinda like the idea of 6-bit byte retro-microcomputer (resp. 24-bit, that would be a word). Because microcomputers typically deal with small number of objects (and prefer arrays to pointers), it would save memory.<p>VGA was 6-bit per color, you can have a readable alphabet in 6x4 bit matrix, you can stuff basic LISP or Forth language into 6-bit alphabet, and the original System&#x2F;360 only had 24-bit addresses.<p>What&#x27;s there not to love? 12MiB of memory, with independently addressable 6-bits, should be enough for anyone. And if it&#x27;s not enough, you can naturally extend FAT-12 to FAT-24 for external storage. Or you can use 48-bit pointers, which are pretty much as useful as 64-bit pointers.</div><br/><div id="41877036" class="c"><input type="checkbox" id="c-41877036" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#41876974">parent</a><span>|</span><a href="#41875864">next</a><span>|</span><label class="collapse" for="c-41877036">[-]</label><label class="expand" for="c-41877036">[1 more]</label></div><br/><div class="children"><div class="content">Or you can have 8 bit bytes, and 3 byte words.  That’s still 24 bits.</div><br/></div></div></div></div><div id="41875864" class="c"><input type="checkbox" id="c-41875864" checked=""/><div class="controls bullet"><span class="by">jfbastien</span><span>|</span><a href="#41876974">prev</a><span>|</span><a href="#41874745">next</a><span>|</span><label class="collapse" for="c-41875864">[-]</label><label class="expand" for="c-41875864">[1 more]</label></div><br/><div class="children"><div class="content">Hi! Thanks for the interest on my proposal.
I have an updated draft based on feedback I&#x27;ve received so far:
<a href="https:&#x2F;&#x2F;isocpp.org&#x2F;files&#x2F;papers&#x2F;D3477R1.html" rel="nofollow">https:&#x2F;&#x2F;isocpp.org&#x2F;files&#x2F;papers&#x2F;D3477R1.html</a></div><br/></div></div><div id="41874745" class="c"><input type="checkbox" id="c-41874745" checked=""/><div class="controls bullet"><span class="by">TrueDuality</span><span>|</span><a href="#41875864">prev</a><span>|</span><a href="#41874966">next</a><span>|</span><label class="collapse" for="c-41874745">[-]</label><label class="expand" for="c-41874745">[1 more]</label></div><br/><div class="children"><div class="content">This is both uncontroversial and incredibly spicy. I love it.</div><br/></div></div><div id="41874966" class="c"><input type="checkbox" id="c-41874966" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#41874745">prev</a><span>|</span><a href="#41875832">next</a><span>|</span><label class="collapse" for="c-41874966">[-]</label><label class="expand" for="c-41874966">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m totally fine with enforcing that int8_t == char == 8-bits, however I&#x27;m not sure about spreading the misconception that a byte <i>is</i> 8-bits. A byte with 8-bits is called an octet.<p>At the same time, a `byte` is already an &quot;alias&quot; for `char` since C++17 anyway[1].<p>[1] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;types&#x2F;byte" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;types&#x2F;byte</a></div><br/><div id="41876119" class="c"><input type="checkbox" id="c-41876119" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41874966">parent</a><span>|</span><a href="#41876985">next</a><span>|</span><label class="collapse" for="c-41876119">[-]</label><label class="expand" for="c-41876119">[3 more]</label></div><br/><div class="children"><div class="content">My first experience with computers was 45 years ago, and a &quot;byte&quot; back then was defined as an 8-bit quantity.  And in the intervening 45 years, I&#x27;ve never come across a different meaning for &quot;byte&quot;.  I&#x27;ll ask for a citation for a definition of &quot;byte&quot; that isn&#x27;t 8-bits.</div><br/><div id="41877397" class="c"><input type="checkbox" id="c-41877397" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#41874966">root</a><span>|</span><a href="#41876119">parent</a><span>|</span><a href="#41876924">next</a><span>|</span><label class="collapse" for="c-41877397">[-]</label><label class="expand" for="c-41877397">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting because maybe a byte will not be 8-bit in 45 years from now on.<p>I&#x27;m mostly discussing from the sake of it because I don&#x27;t really mind as a C&#x2F;C++ user. We could just use &quot;octet&quot; and call it a day, but now there is an ambiguity with the past definition and potential in the future definition (in which case I hope the term &quot;byte&quot; will just disappear).</div><br/></div></div><div id="41876924" class="c"><input type="checkbox" id="c-41876924" checked=""/><div class="controls bullet"><span class="by">larsbrinkhoff</span><span>|</span><a href="#41874966">root</a><span>|</span><a href="#41876119">parent</a><span>|</span><a href="#41877397">prev</a><span>|</span><a href="#41876985">next</a><span>|</span><label class="collapse" for="c-41876924">[-]</label><label class="expand" for="c-41876924">[1 more]</label></div><br/><div class="children"><div class="content">1979 is quite recent as computer history goes, and many conventions had settled by then.  The Wikipedia article discusses the etymology of &quot;byte&quot; and how the definition evolved from loosely &quot;a group of bits less than a word&quot; to &quot;precisely 8 bits&quot;.  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Byte" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Byte</a></div><br/></div></div></div></div><div id="41876985" class="c"><input type="checkbox" id="c-41876985" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#41874966">parent</a><span>|</span><a href="#41876119">prev</a><span>|</span><a href="#41874974">next</a><span>|</span><label class="collapse" for="c-41876985">[-]</label><label class="expand" for="c-41876985">[1 more]</label></div><br/><div class="children"><div class="content">Nah, a byte is 8 bits.<p>This is a normative statement, not a descriptive statement.</div><br/></div></div><div id="41874974" class="c"><input type="checkbox" id="c-41874974" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41874966">parent</a><span>|</span><a href="#41876985">prev</a><span>|</span><a href="#41875832">next</a><span>|</span><label class="collapse" for="c-41874974">[-]</label><label class="expand" for="c-41874974">[3 more]</label></div><br/><div class="children"><div class="content">I, for one, hate that int8 == signed char.<p>std::cout &lt;&lt; (int8_t)32 &lt;&lt; std::endl; &#x2F;&#x2F;should print 32 dang it</div><br/><div id="41875004" class="c"><input type="checkbox" id="c-41875004" checked=""/><div class="controls bullet"><span class="by">kreco</span><span>|</span><a href="#41874966">root</a><span>|</span><a href="#41874974">parent</a><span>|</span><a href="#41875832">next</a><span>|</span><label class="collapse" for="c-41875004">[-]</label><label class="expand" for="c-41875004">[2 more]</label></div><br/><div class="children"><div class="content">Now you can also enjoy the fact that you can&#x27;t even compile:<p><pre><code>  std::cout &lt;&lt; (std::byte)32 &lt;&lt; std::endl;
</code></pre>
because there is no default operator&lt;&lt; defined.</div><br/><div id="41875133" class="c"><input type="checkbox" id="c-41875133" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41874966">root</a><span>|</span><a href="#41875004">parent</a><span>|</span><a href="#41875832">next</a><span>|</span><label class="collapse" for="c-41875133">[-]</label><label class="expand" for="c-41875133">[1 more]</label></div><br/><div class="children"><div class="content">Very enjoyable. It will a constant reminder that I need to decide how I want std::byte to print - character or integer ...</div><br/></div></div></div></div></div></div></div></div><div id="41875832" class="c"><input type="checkbox" id="c-41875832" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41874966">prev</a><span>|</span><a href="#41877018">next</a><span>|</span><label class="collapse" for="c-41875832">[-]</label><label class="expand" for="c-41875832">[1 more]</label></div><br/><div class="children"><div class="content">What will be the benefit?<p>- CHAR_BIT cannot go away; reams of code references it.<p>- You still need the constant 8.  It&#x27;s better if it has a name.<p>- Neither the C nor C++ standard will be simplified if CHAR_BIT is declared to be 8. Only a few passages will change. Just, certain possible implementations will be rendered nonconforming.<p>- There are specialized platforms with C compilers, such as DSP chips, that are not byte addressable machines. They are in current use; they are not museum pieces.</div><br/></div></div><div id="41877018" class="c"><input type="checkbox" id="c-41877018" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41875832">prev</a><span>|</span><a href="#41875881">next</a><span>|</span><label class="collapse" for="c-41877018">[-]</label><label class="expand" for="c-41877018">[1 more]</label></div><br/><div class="children"><div class="content">This is an egoistical viewpoint, but if I want 8 bits in a byte I have plenty of choices anyway - Zig, Rust, D, you name it.
Should the need for another byte width come up, either for past or future architectures C and C++ are my only practical choice.<p>Sure, it is selfish to expect C and C++ do the dirty work, while more modern languages get away skimping on it. On the other hand I think especially C++ is doing itself a disservice trying to become a kind of half-baked Rust.</div><br/></div></div><div id="41875881" class="c"><input type="checkbox" id="c-41875881" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#41877018">prev</a><span>|</span><a href="#41876038">next</a><span>|</span><label class="collapse" for="c-41875881">[-]</label><label class="expand" for="c-41875881">[1 more]</label></div><br/><div class="children"><div class="content">There are DSP chips that have C compilers, and do not have 8 bit bytes; smallest addressable unit is 16 (or larger).<p>Less than a decade ago I worked with something like that: the TeakLite III DSP from CEVA.</div><br/></div></div><div id="41876038" class="c"><input type="checkbox" id="c-41876038" checked=""/><div class="controls bullet"><span class="by">boulos</span><span>|</span><a href="#41875881">prev</a><span>|</span><a href="#41875027">next</a><span>|</span><label class="collapse" for="c-41876038">[-]</label><label class="expand" for="c-41876038">[1 more]</label></div><br/><div class="children"><div class="content">The current proposal says:<p>&gt; A byte is 8 bits, which is at least large enough to contain the ordinary literal encoding of any element of the basic character set literal character set and the eight-bit code units of the Unicode UTF-8 encoding form and is composed of a contiguous sequence of bits, the number of which is bits in a byte.<p>But instead of the &quot;and is composed&quot; ending, it feels like you&#x27;d change the intro to say that &quot;A byte is 8 contiguous bits, which is&quot;.<p>We can also remove the &quot;at least&quot;, since that was there  to imply a requirement on the number of bits being large enough for UTF-8.<p>Personally, I&#x27;d make a &quot;A byte is 8 contiguous bits.&quot; a standalone sentence. Then explain as follow up that &quot;A byte is large enough to contain...&quot;.</div><br/></div></div><div id="41875027" class="c"><input type="checkbox" id="c-41875027" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41876038">prev</a><span>|</span><a href="#41874737">next</a><span>|</span><label class="collapse" for="c-41875027">[-]</label><label class="expand" for="c-41875027">[1 more]</label></div><br/><div class="children"><div class="content">I just put static_assert(CHAR_BITS==8); in one place and move on. Haven&#x27;t had it fire since it was #if equivalent</div><br/></div></div><div id="41874737" class="c"><input type="checkbox" id="c-41874737" checked=""/><div class="controls bullet"><span class="by">JamesStuff</span><span>|</span><a href="#41875027">prev</a><span>|</span><a href="#41875419">next</a><span>|</span><label class="collapse" for="c-41874737">[-]</label><label class="expand" for="c-41874737">[10 more]</label></div><br/><div class="children"><div class="content">Not sure about that, seems pretty controversial to me. Are we forgetting about the UNIVACs?</div><br/><div id="41874803" class="c"><input type="checkbox" id="c-41874803" checked=""/><div class="controls bullet"><span class="by">trebligdivad</span><span>|</span><a href="#41874737">parent</a><span>|</span><a href="#41875416">next</a><span>|</span><label class="collapse" for="c-41874803">[-]</label><label class="expand" for="c-41874803">[2 more]</label></div><br/><div class="children"><div class="content">Hopefully we are; it&#x27;s been a long time, but as I remember indexing in strings on them is a disaster.</div><br/><div id="41874905" class="c"><input type="checkbox" id="c-41874905" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41874737">root</a><span>|</span><a href="#41874803">parent</a><span>|</span><a href="#41875416">next</a><span>|</span><label class="collapse" for="c-41874905">[-]</label><label class="expand" for="c-41874905">[1 more]</label></div><br/><div class="children"><div class="content">They still exist. You can still run OS 2200 on a Clearpath Dorado.[1] Although it&#x27;s actually Intel Xeon processors doing an emulation.<p>Yes, indexing strings of 6-bit FIELDATA characters was a huge headache. UNIVAC had the unfortunate problem of having to settle on a character code in the early 1960s, before ASCII was standardized. At the time, a military 6-bit character set looked like the next big thing. It was better than IBM&#x27;s code, which mapped to punch card holes and the letters weren&#x27;t all in one block.<p>[1] <a href="https:&#x2F;&#x2F;www.unisys.com&#x2F;siteassets&#x2F;collateral&#x2F;info-sheets&#x2F;info-clearpath-forward-dorado-8690.pdf" rel="nofollow">https:&#x2F;&#x2F;www.unisys.com&#x2F;siteassets&#x2F;collateral&#x2F;info-sheets&#x2F;inf...</a></div><br/></div></div></div></div><div id="41875416" class="c"><input type="checkbox" id="c-41875416" checked=""/><div class="controls bullet"><span class="by">omoikane</span><span>|</span><a href="#41874737">parent</a><span>|</span><a href="#41874803">prev</a><span>|</span><a href="#41874887">next</a><span>|</span><label class="collapse" for="c-41875416">[-]</label><label class="expand" for="c-41875416">[1 more]</label></div><br/><div class="children"><div class="content">This would be a great setup for a time travelling science fiction where there is some legacy UNIVAC software that needs to be debugged, and John Titor, instead of looking for an IBM 5100, came back to the year 2024 to find a pre-P3477R0 compiler.</div><br/></div></div><div id="41874887" class="c"><input type="checkbox" id="c-41874887" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#41874737">parent</a><span>|</span><a href="#41875416">prev</a><span>|</span><a href="#41874920">next</a><span>|</span><label class="collapse" for="c-41874887">[-]</label><label class="expand" for="c-41874887">[2 more]</label></div><br/><div class="children"><div class="content">idk. by today most software already assumes 8 bit == byte in subtle ways all over the place to a point you kinda have to use a fully custom or at least fully self reviewed and patched stack of C libraries<p>so delegating such by now very very edge cases to non standard C seems fine, i.e. seems to IMHO not change much at all in practice<p>and C&#x2F;C++ compilers are anyway full of non standard extensions and it&#x27;s not that CHAR_BIT go away or you as a non-standard extension assume it might not be 8</div><br/><div id="41875219" class="c"><input type="checkbox" id="c-41875219" checked=""/><div class="controls bullet"><span class="by">II2II</span><span>|</span><a href="#41874737">root</a><span>|</span><a href="#41874887">parent</a><span>|</span><a href="#41874920">next</a><span>|</span><label class="collapse" for="c-41875219">[-]</label><label class="expand" for="c-41875219">[1 more]</label></div><br/><div class="children"><div class="content">&gt; most software already assumes 8 bit == byte in subtle ways all over the place<p>Which is the real reason why 8-bits should be adopted as the standard byte size.<p>I didn&#x27;t even realize that the byte was defined as anything other than 8-bits until recently. I have known, for decades, that there were non-8-bit character encodings (including ASCII) and word sizes were all over the map (including some where <i>word size % 8 != 0</i>). Enough thought about that last point should have helped me realize that there were machines where the byte was not 8-bits, yet the rarity of encountering such systems left me with the incorrect notion that a byte was defined as 8-bits.<p>Now if someone with enough background to figure it out doesn&#x27;t figure it out, how can someone without that background figure it out? Someone who has only experienced systems with 8-bit bytes. Someone who has only read books that make the explicit assumption of 8-bit bytes (which virtually every book does). Anything they write has the potential of breaking on systems with a different byte size. The idea of writing portable code because the compiler itself is &quot;standards compliant&quot; breaks down. You probably should modify the standard to ensure the code remains portable by either forcing the compiler for non-8-bit systems to handle the exceptions, or simply admitting that compiler does not portable code for non-8-bit systems.</div><br/></div></div></div></div><div id="41874920" class="c"><input type="checkbox" id="c-41874920" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41874737">parent</a><span>|</span><a href="#41874887">prev</a><span>|</span><a href="#41875419">next</a><span>|</span><label class="collapse" for="c-41874920">[-]</label><label class="expand" for="c-41874920">[4 more]</label></div><br/><div class="children"><div class="content">Do UNIVACs care about modern C++ compilers? Do modern C++ compilers care about UNIVACs?<p>Given that Wikipedia says UNIVAC was discontinued in 1986 I’m pretty sure the answer is no and no!</div><br/><div id="41875217" class="c"><input type="checkbox" id="c-41875217" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#41874737">root</a><span>|</span><a href="#41874920">parent</a><span>|</span><a href="#41875419">next</a><span>|</span><label class="collapse" for="c-41875217">[-]</label><label class="expand" for="c-41875217">[3 more]</label></div><br/><div class="children"><div class="content">The UNIVAC 1108 (and descendants) mainframe architecture was not discontinued in 1986. The company that owned it (Sperry) merged with Burroughs in that year to form Unisys. The platform still exists, but now runs as a software emulator under x86-64. The OS is still maintained and had a new release just last year. Around the time of the merger the old school name “UNIVAC” was retired in a rebranding, but the platform survived.<p>Its OS, OS 2200, does have a C compiler. Not sure if there ever was a C++ compiler, if there once was it is no longer around. But that C compiler is not being kept up to date with the latest standards, it only officially supports C89&#x2F;C90 - this is a deeply legacy system, most application software is written in COBOL and the OS itself itself is mainly written in assembler and a proprietary Pascal-like language called “PLUS”. They <i>might</i> add some features from newer standards if particularly valuable, but formal compliance with C99&#x2F;C11&#x2F;C17&#x2F;C23&#x2F;etc is not a goal.<p>The OS does contain components written in C++, most notably the HotSpot JVM. However, from what I understand, the JVM actually runs in x86-64 Linux processes on the host system, outside of the emulated mainframe environment, but the mainframe emulator is integrated with those Linux processes so they can access mainframe files&#x2F;data&#x2F;apps.</div><br/><div id="41877501" class="c"><input type="checkbox" id="c-41877501" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41874737">root</a><span>|</span><a href="#41875217">parent</a><span>|</span><a href="#41876419">next</a><span>|</span><label class="collapse" for="c-41877501">[-]</label><label class="expand" for="c-41877501">[1 more]</label></div><br/><div class="children"><div class="content">I got curious, there is a Wikipedia page describing what languages are currently available,<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unisys_OS_2200_programming_languages" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unisys_OS_2200_programming_lan...</a></div><br/></div></div><div id="41876419" class="c"><input type="checkbox" id="c-41876419" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41874737">root</a><span>|</span><a href="#41875217">parent</a><span>|</span><a href="#41877501">prev</a><span>|</span><a href="#41875419">next</a><span>|</span><label class="collapse" for="c-41876419">[-]</label><label class="expand" for="c-41876419">[1 more]</label></div><br/><div class="children"><div class="content">That would be a resounding no then. Nice. So why are we talking about an obscure and irrelevant-to-the-discussion platform? Internet comments I swear.</div><br/></div></div></div></div></div></div></div></div><div id="41875419" class="c"><input type="checkbox" id="c-41875419" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#41874737">prev</a><span>|</span><a href="#41875647">next</a><span>|</span><label class="collapse" for="c-41875419">[-]</label><label class="expand" for="c-41875419">[3 more]</label></div><br/><div class="children"><div class="content">Hmm, I wonder if any modern languages can work on computers that use trits instead of bits.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ternary_computer" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ternary_computer</a></div><br/><div id="41875664" class="c"><input type="checkbox" id="c-41875664" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#41875419">parent</a><span>|</span><a href="#41875556">next</a><span>|</span><label class="collapse" for="c-41875664">[-]</label><label class="expand" for="c-41875664">[1 more]</label></div><br/><div class="children"><div class="content">Possible, but likely slow. There&#x27;s nothing in the &quot;C abstract machine&quot; that mandates specific hardware. But, the bitshift is only a fast operation when you have bits. Similarly with bitwise boolean operations.</div><br/></div></div><div id="41875556" class="c"><input type="checkbox" id="c-41875556" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41875419">parent</a><span>|</span><a href="#41875664">prev</a><span>|</span><a href="#41875647">next</a><span>|</span><label class="collapse" for="c-41875556">[-]</label><label class="expand" for="c-41875556">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;d just be a translation&#x2F;compiler problem.  Most languages don&#x27;t really have a &quot;bit&quot;, instead it&#x27;s usually a byte with the upper bits ignored.</div><br/></div></div></div></div><div id="41875647" class="c"><input type="checkbox" id="c-41875647" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41875419">prev</a><span>|</span><a href="#41875031">next</a><span>|</span><label class="collapse" for="c-41875647">[-]</label><label class="expand" for="c-41875647">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We can find vestigial support, for example GCC dropped dsp16xx in 2004, and 1750a in 2002.<p>Honestly kind of surprised it was relavent as late as 2004. I thought the era of non 8-bit bytes was like 1970s or earlier.</div><br/></div></div><div id="41875031" class="c"><input type="checkbox" id="c-41875031" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#41875647">prev</a><span>|</span><a href="#41874794">next</a><span>|</span><label class="collapse" for="c-41875031">[-]</label><label class="expand" for="c-41875031">[20 more]</label></div><br/><div class="children"><div class="content">So please do excuse my ignorance, but is there a &quot;logic&quot; related reason other than hardware cost limitations ala &quot;8 was cheaper than 10 for the same number of memory addresses&quot; that bytes are 8 bits instead of 10? Genuinely curious, as a high-level dev of twenty years, I don&#x27;t know why 8 was selected.<p>To my naive eye, It seems like moving to 10 bits per byte would be both logical and make learning the trade just a little bit easier?</div><br/><div id="41875211" class="c"><input type="checkbox" id="c-41875211" checked=""/><div class="controls bullet"><span class="by">morio</span><span>|</span><a href="#41875031">parent</a><span>|</span><a href="#41875147">next</a><span>|</span><label class="collapse" for="c-41875211">[-]</label><label class="expand" for="c-41875211">[1 more]</label></div><br/><div class="children"><div class="content">One example from the software side: A common thing to do in data processing is to obtain bit offsets (compression, video decoding etc.). If a byte would be 10 bits you would need mod%10 operations everywhere which is slow and&#x2F;or complex. In contrast mod%(2^N) is one logic processor instruction.</div><br/></div></div><div id="41875147" class="c"><input type="checkbox" id="c-41875147" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#41875031">parent</a><span>|</span><a href="#41875211">prev</a><span>|</span><a href="#41875041">next</a><span>|</span><label class="collapse" for="c-41875147">[-]</label><label class="expand" for="c-41875147">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re ignoring what&#x27;s efficient to use then just use a decimal data type and let the hardware figure out how to calculate that for you best. If what&#x27;s efficient matters then address management, hardware operation implementations, and data packing are all simplest when the group size is a power of the base.</div><br/></div></div><div id="41875041" class="c"><input type="checkbox" id="c-41875041" checked=""/><div class="controls bullet"><span class="by">dplavery92</span><span>|</span><a href="#41875031">parent</a><span>|</span><a href="#41875147">prev</a><span>|</span><a href="#41875110">next</a><span>|</span><label class="collapse" for="c-41875041">[-]</label><label class="expand" for="c-41875041">[10 more]</label></div><br/><div class="children"><div class="content">Eight is a nice power of two.</div><br/><div id="41875063" class="c"><input type="checkbox" id="c-41875063" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875041">parent</a><span>|</span><a href="#41875110">next</a><span>|</span><label class="collapse" for="c-41875063">[-]</label><label class="expand" for="c-41875063">[9 more]</label></div><br/><div class="children"><div class="content">Can you explain how that&#x27;s helpful? I&#x27;m not being obtuse, I just don&#x27;t follow</div><br/><div id="41875101" class="c"><input type="checkbox" id="c-41875101" checked=""/><div class="controls bullet"><span class="by">spongebobstoes</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875063">parent</a><span>|</span><a href="#41875462">next</a><span>|</span><label class="collapse" for="c-41875101">[-]</label><label class="expand" for="c-41875101">[3 more]</label></div><br/><div class="children"><div class="content">One thought is that it&#x27;s always a whole number of bits (3) to bit-address within a byte. It&#x27;s 3.5 bits to bit address a 10 bit byte. Sorta just works out nicer in general to have powers of 2 when working on base 2.</div><br/><div id="41875607" class="c"><input type="checkbox" id="c-41875607" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875101">parent</a><span>|</span><a href="#41875462">next</a><span>|</span><label class="collapse" for="c-41875607">[-]</label><label class="expand" for="c-41875607">[2 more]</label></div><br/><div class="children"><div class="content">This is basically the reason.<p>Another part of it is the fact that it&#x27;s a lot easier to represent stuff with hex if the bytes line up.<p>I can represent &quot;255&quot; with &quot;0xFF&quot; which fits nice and neat in 1 byte.  However, now if a byte is 10bits that hex no longer really works.  You have 1024 values to represent.  The max value would be 0x3FF which just looks funky.<p>Coming up with an alphanumeric system to represent 2^10 cleanly just ends up weird and unintuitive.</div><br/><div id="41876097" class="c"><input type="checkbox" id="c-41876097" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875607">parent</a><span>|</span><a href="#41875462">next</a><span>|</span><label class="collapse" for="c-41876097">[-]</label><label class="expand" for="c-41876097">[1 more]</label></div><br/><div class="children"><div class="content">We probably wouldn&#x27;t have chosen hex in a theoretical world where bytes were 10 bits, right? It would probably be two groups of 5 like 02:21 == 85 (like an ip address) or five groups of two 0x01111 == 85. It just has to be one of its divisors.</div><br/></div></div></div></div></div></div><div id="41875462" class="c"><input type="checkbox" id="c-41875462" checked=""/><div class="controls bullet"><span class="by">davemp</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875063">parent</a><span>|</span><a href="#41875101">prev</a><span>|</span><a href="#41875100">next</a><span>|</span><label class="collapse" for="c-41875462">[-]</label><label class="expand" for="c-41875462">[1 more]</label></div><br/><div class="children"><div class="content">Many circuits have ceil(log_2(N_bits)) scaling wrt to propagation delay&#x2F;other dimensions so you’re just leaving efficiency on the table if you aren’t using a power of 2 for your bit size.</div><br/></div></div><div id="41875100" class="c"><input type="checkbox" id="c-41875100" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875063">parent</a><span>|</span><a href="#41875462">prev</a><span>|</span><a href="#41875319">next</a><span>|</span><label class="collapse" for="c-41875100">[-]</label><label class="expand" for="c-41875100">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easier to go from a bit number to (byte, bit) if you don&#x27;t have to divide by 10.</div><br/></div></div><div id="41875319" class="c"><input type="checkbox" id="c-41875319" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875063">parent</a><span>|</span><a href="#41875100">prev</a><span>|</span><a href="#41875110">next</a><span>|</span><label class="collapse" for="c-41875319">[-]</label><label class="expand" for="c-41875319">[3 more]</label></div><br/><div class="children"><div class="content">Because modern computing has settled on the Boolean (binary) logic (0&#x2F;1 or true&#x2F;false) in the chip design, which has given us 8 bit bytes (a power of two). It is the easiest and most reliable to design and implement in the hardware.<p>On the other hand, if computing settled on a three-valued logic (e.g. 0&#x2F;1&#x2F;«something» where «something» has been proposed as -1, «undefined»&#x2F;«unknown»&#x2F;«undecided» or a «shade of grey»), we would have had 9 bit bytes (a power of three).<p>10 was tried numerous times at the dawn of computing and… it was found too unwieldy in the circuit design.</div><br/><div id="41875536" class="c"><input type="checkbox" id="c-41875536" checked=""/><div class="controls bullet"><span class="by">davemp</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875319">parent</a><span>|</span><a href="#41875110">next</a><span>|</span><label class="collapse" for="c-41875536">[-]</label><label class="expand" for="c-41875536">[2 more]</label></div><br/><div class="children"><div class="content">&gt; On the other hand, if computing settled on a three-valued logic (e.g. 0&#x2F;1&#x2F;«something» where «something» has been proposed as -1, «undefined»&#x2F;«unknown&#x2F;undecided» or a «shade of grey»), we would have had 9 bit bytes (a power of three).<p>Is this true? 4 ternary bits give you really convenient base 12 which has a lot of desirable properties for things like multiplication and fixed point. Though I have no idea what ternary building blocks would look like so it’s hard to visualize potential hardware.</div><br/><div id="41875705" class="c"><input type="checkbox" id="c-41875705" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875536">parent</a><span>|</span><a href="#41875110">next</a><span>|</span><label class="collapse" for="c-41875705">[-]</label><label class="expand" for="c-41875705">[1 more]</label></div><br/><div class="children"><div class="content">It is hard to say whether it would have been 9 or 12, now that people have stopped experimenting with alternative hardware designs. 9-bit byte designs certainly did exist (and maybe even the 12-bit designs), too, although they were still based on the Boolean logic.<p>I have certainly heard an argument that ternary logic would have been a better choice, if it won over, but it is history now, and we are left with the vestiges of the ternary logic in SQL (NULL values which are semantically «no value» &#x2F; «undefined» values).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41875110" class="c"><input type="checkbox" id="c-41875110" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#41875031">parent</a><span>|</span><a href="#41875041">prev</a><span>|</span><a href="#41875204">next</a><span>|</span><label class="collapse" for="c-41875110">[-]</label><label class="expand" for="c-41875110">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m fairly sure it&#x27;s because the English character set fits nicely into a byte.   7 bits would have have worked as well, but 7 is a very odd width for something in a binary computer.</div><br/></div></div><div id="41875204" class="c"><input type="checkbox" id="c-41875204" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#41875031">parent</a><span>|</span><a href="#41875110">prev</a><span>|</span><a href="#41875052">next</a><span>|</span><label class="collapse" for="c-41875204">[-]</label><label class="expand" for="c-41875204">[1 more]</label></div><br/><div class="children"><div class="content">likely mostly as a concession to ASCII in the end. you used a typewriter to write into and receive terminal output from machines back in the day. terminals would use ASCII. there were machines with all sorts of smallest-addressable-sizes, but eight bit bytes align nicely with ASCII. makes strings easier. making strings easier makes programming easier. easier programming makes a machine more popular. once machines started standardizing on eight bit bytes, others followed. when they went to add more data, they kept the byte since code was written for bytes, and made their new registeres two bytes. then two of those. then two of those. so we&#x27;re sitting at 64 bit registers on the backs of all that that came before.</div><br/></div></div><div id="41875052" class="c"><input type="checkbox" id="c-41875052" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41875031">parent</a><span>|</span><a href="#41875204">prev</a><span>|</span><a href="#41874794">next</a><span>|</span><label class="collapse" for="c-41875052">[-]</label><label class="expand" for="c-41875052">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure why you think being able to store values from -512 to +511 is more logical than -128 to +127?</div><br/><div id="41875059" class="c"><input type="checkbox" id="c-41875059" checked=""/><div class="controls bullet"><span class="by">donatj</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875052">parent</a><span>|</span><a href="#41874794">next</a><span>|</span><label class="collapse" for="c-41875059">[-]</label><label class="expand" for="c-41875059">[4 more]</label></div><br/><div class="children"><div class="content">Buckets of 10 seem more regular to beings with 10 fingers that can be up or down?</div><br/><div id="41876677" class="c"><input type="checkbox" id="c-41876677" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875059">parent</a><span>|</span><a href="#41875079">next</a><span>|</span><label class="collapse" for="c-41876677">[-]</label><label class="expand" for="c-41876677">[1 more]</label></div><br/><div class="children"><div class="content">Computers are not beings with 10 fingers that can be up or down.<p>Powers of two are more natural in a binary computer. Then add the fact that 8 is the smallest power of two that allows you to fit the Latin alphabet plus most common symbols as a character encoding.<p>We&#x27;re all about building towers of abstractions. It does make sense to aim for designs that are natural for humans when you&#x27;re closer to the top of the stack. Bytes are fairly low down the stack, so it makes more sense for them to be natural to computers.</div><br/></div></div><div id="41875079" class="c"><input type="checkbox" id="c-41875079" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875059">parent</a><span>|</span><a href="#41876677">prev</a><span>|</span><a href="#41877245">next</a><span>|</span><label class="collapse" for="c-41875079">[-]</label><label class="expand" for="c-41875079">[1 more]</label></div><br/><div class="children"><div class="content">I think 8bits (really 7 bits) was chosen because it holds a value closest to +&#x2F;- 100.  What is regular just depends on how you look at it.</div><br/></div></div><div id="41877245" class="c"><input type="checkbox" id="c-41877245" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#41875031">root</a><span>|</span><a href="#41875059">parent</a><span>|</span><a href="#41875079">prev</a><span>|</span><a href="#41874794">next</a><span>|</span><label class="collapse" for="c-41877245">[-]</label><label class="expand" for="c-41877245">[1 more]</label></div><br/><div class="children"><div class="content">Unless they are Addams who have 10 fingers and 11 toes as it is known abundantly well.</div><br/></div></div></div></div></div></div></div></div><div id="41874794" class="c"><input type="checkbox" id="c-41874794" checked=""/><div class="controls bullet"><span class="by">throwaway889900</span><span>|</span><a href="#41875031">prev</a><span>|</span><a href="#41875162">next</a><span>|</span><label class="collapse" for="c-41874794">[-]</label><label class="expand" for="c-41874794">[24 more]</label></div><br/><div class="children"><div class="content">But how many bytes are there in a word?</div><br/><div id="41874796" class="c"><input type="checkbox" id="c-41874796" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41874794">parent</a><span>|</span><a href="#41874838">next</a><span>|</span><label class="collapse" for="c-41874796">[-]</label><label class="expand" for="c-41874796">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re on x86, the answer can be simultaneously 16, 32, and 64.</div><br/><div id="41876081" class="c"><input type="checkbox" id="c-41876081" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874796">parent</a><span>|</span><a href="#41874838">next</a><span>|</span><label class="collapse" for="c-41876081">[-]</label><label class="expand" for="c-41876081">[2 more]</label></div><br/><div class="children"><div class="content">Don’t you mean 2,4, and 8?</div><br/><div id="41876883" class="c"><input type="checkbox" id="c-41876883" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41876081">parent</a><span>|</span><a href="#41874838">next</a><span>|</span><label class="collapse" for="c-41876883">[-]</label><label class="expand" for="c-41876883">[1 more]</label></div><br/><div class="children"><div class="content">Bits, bytes, whatever.</div><br/></div></div></div></div></div></div><div id="41874838" class="c"><input type="checkbox" id="c-41874838" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41874794">parent</a><span>|</span><a href="#41874796">prev</a><span>|</span><a href="#41875413">next</a><span>|</span><label class="collapse" for="c-41874838">[-]</label><label class="expand" for="c-41874838">[18 more]</label></div><br/><div class="children"><div class="content">&quot;Word&quot; is an outdated concept we should try to get rid of.</div><br/><div id="41874892" class="c"><input type="checkbox" id="c-41874892" checked=""/><div class="controls bullet"><span class="by">anigbrowl</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874838">parent</a><span>|</span><a href="#41875850">next</a><span>|</span><label class="collapse" for="c-41874892">[-]</label><label class="expand" for="c-41874892">[7 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right. To be consistent with bytes we should call it a <i>snack</i>.</div><br/><div id="41874949" class="c"><input type="checkbox" id="c-41874949" checked=""/><div class="controls bullet"><span class="by">SCUSKU</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874892">parent</a><span>|</span><a href="#41875850">next</a><span>|</span><label class="collapse" for="c-41874949">[-]</label><label class="expand" for="c-41874949">[6 more]</label></div><br/><div class="children"><div class="content">Henceforth, it follows that a doublesnack is called a lunch. And a quadruplesnack a fourthmeal.</div><br/><div id="41875163" class="c"><input type="checkbox" id="c-41875163" checked=""/><div class="controls bullet"><span class="by">tetron</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874949">parent</a><span>|</span><a href="#41874984">next</a><span>|</span><label class="collapse" for="c-41875163">[-]</label><label class="expand" for="c-41875163">[4 more]</label></div><br/><div class="children"><div class="content">There&#x27;s only one right answer:<p>Nybble - 4 bits<p>Byte   - 8 bits<p>Snyack - 16 bits<p>Lyunch - 32 bits<p>Dynner - 64 bits</div><br/><div id="41876019" class="c"><input type="checkbox" id="c-41876019" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41875163">parent</a><span>|</span><a href="#41875680">next</a><span>|</span><label class="collapse" for="c-41876019">[-]</label><label class="expand" for="c-41876019">[2 more]</label></div><br/><div class="children"><div class="content">In the spirit of redefining the kilobyte, we should define byte as having a nice, metric 10 bits. An 8 bit thing is obviously a bibyte. Then power of 2 multiples of them can include kibibibytes, mebibibytes, gibibibytes, and so on for clarity.</div><br/><div id="41876085" class="c"><input type="checkbox" id="c-41876085" checked=""/><div class="controls bullet"><span class="by">jaysonvantuyl</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41876019">parent</a><span>|</span><a href="#41875680">next</a><span>|</span><label class="collapse" for="c-41876085">[-]</label><label class="expand" for="c-41876085">[1 more]</label></div><br/><div class="children"><div class="content">ಠ_ಠ</div><br/></div></div></div></div><div id="41875680" class="c"><input type="checkbox" id="c-41875680" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41875163">parent</a><span>|</span><a href="#41876019">prev</a><span>|</span><a href="#41874984">next</a><span>|</span><label class="collapse" for="c-41875680">[-]</label><label class="expand" for="c-41875680">[1 more]</label></div><br/><div class="children"><div class="content">And what about elevensies?<p>(Ok,. I guess there&#x27;s a difference between bits and hob-bits)</div><br/></div></div></div></div><div id="41874984" class="c"><input type="checkbox" id="c-41874984" checked=""/><div class="controls bullet"><span class="by">iwaztomack</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874949">parent</a><span>|</span><a href="#41875163">prev</a><span>|</span><a href="#41875850">next</a><span>|</span><label class="collapse" for="c-41874984">[-]</label><label class="expand" for="c-41874984">[1 more]</label></div><br/><div class="children"><div class="content">or an f-word</div><br/></div></div></div></div></div></div><div id="41875850" class="c"><input type="checkbox" id="c-41875850" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874838">parent</a><span>|</span><a href="#41874892">prev</a><span>|</span><a href="#41874888">next</a><span>|</span><label class="collapse" for="c-41875850">[-]</label><label class="expand" for="c-41875850">[1 more]</label></div><br/><div class="children"><div class="content">Appeasing that attitude is what prevented Microsoft from migrating to LP64. Would have been an easier task if their 32-bit LONG type never existed, they stuck with DWORD, and told the RISC platforms to live with it.</div><br/></div></div><div id="41874888" class="c"><input type="checkbox" id="c-41874888" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874838">parent</a><span>|</span><a href="#41875850">prev</a><span>|</span><a href="#41874933">next</a><span>|</span><label class="collapse" for="c-41874888">[-]</label><label class="expand" for="c-41874888">[7 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very useful on hardware that is not an x86 CPU.</div><br/><div id="41874937" class="c"><input type="checkbox" id="c-41874937" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874888">parent</a><span>|</span><a href="#41874988">next</a><span>|</span><label class="collapse" for="c-41874937">[-]</label><label class="expand" for="c-41874937">[5 more]</label></div><br/><div class="children"><div class="content">As an abstraction on the size of a CPU register, it really turned out to be more confusing than useful.</div><br/><div id="41875078" class="c"><input type="checkbox" id="c-41875078" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874937">parent</a><span>|</span><a href="#41875003">next</a><span>|</span><label class="collapse" for="c-41875078">[-]</label><label class="expand" for="c-41875078">[1 more]</label></div><br/><div class="children"><div class="content">On RISC machines, it can be very useful to have the concept of &quot;words,&quot; because that indicates things about how the computer loads and stores data, as well as the native instruction size. In DSPs and custom hardware, it can indicate the only available datatype.<p>The land of x86 goes to great pains to eliminate the concept of a word at a silicon cost.</div><br/></div></div><div id="41875003" class="c"><input type="checkbox" id="c-41875003" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874937">parent</a><span>|</span><a href="#41875078">prev</a><span>|</span><a href="#41874993">next</a><span>|</span><label class="collapse" for="c-41875003">[-]</label><label class="expand" for="c-41875003">[1 more]</label></div><br/><div class="children"><div class="content">Fortunately we have `register_t` these days.</div><br/></div></div><div id="41874993" class="c"><input type="checkbox" id="c-41874993" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874937">parent</a><span>|</span><a href="#41875003">prev</a><span>|</span><a href="#41874988">next</a><span>|</span><label class="collapse" for="c-41874993">[-]</label><label class="expand" for="c-41874993">[2 more]</label></div><br/><div class="children"><div class="content">Is it 32 or 64 bits on ARM64? Why not both?</div><br/><div id="41876643" class="c"><input type="checkbox" id="c-41876643" checked=""/><div class="controls bullet"><span class="by">billti</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874993">parent</a><span>|</span><a href="#41874988">next</a><span>|</span><label class="collapse" for="c-41876643">[-]</label><label class="expand" for="c-41876643">[1 more]</label></div><br/><div class="children"><div class="content">ARM64 has a 32-bit word, even though the native pointer size and general register size is 64 bits. To access just the lower 32 bits of a register Xn you refer to it as Wn.</div><br/></div></div></div></div></div></div><div id="41874988" class="c"><input type="checkbox" id="c-41874988" checked=""/><div class="controls bullet"><span class="by">iwaztomack</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874888">parent</a><span>|</span><a href="#41874937">prev</a><span>|</span><a href="#41874933">next</a><span>|</span><label class="collapse" for="c-41874988">[-]</label><label class="expand" for="c-41874988">[1 more]</label></div><br/><div class="children"><div class="content">such as...?</div><br/></div></div></div></div><div id="41874933" class="c"><input type="checkbox" id="c-41874933" checked=""/><div class="controls bullet"><span class="by">BlueTemplar</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874838">parent</a><span>|</span><a href="#41874888">prev</a><span>|</span><a href="#41875413">next</a><span>|</span><label class="collapse" for="c-41874933">[-]</label><label class="expand" for="c-41874933">[2 more]</label></div><br/><div class="children"><div class="content">How exactly ? How else do you suggest CPUs do addressing ?<p>Or are you suggesting to increase the size of a byte until it&#x27;s the same size as a word, and merge both concepts ?</div><br/><div id="41874963" class="c"><input type="checkbox" id="c-41874963" checked=""/><div class="controls bullet"><span class="by">wvenable</span><span>|</span><a href="#41874794">root</a><span>|</span><a href="#41874933">parent</a><span>|</span><a href="#41875413">next</a><span>|</span><label class="collapse" for="c-41874963">[-]</label><label class="expand" for="c-41874963">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m saying the term &quot;Word&quot; abstracting the number of bytes a CPU can process in a single operation is an outdated concept.  We don&#x27;t really talk about word-sized values anymore.  Instead we mostly explicit on the size of value in bits.  Even the idea of a CPU having just one relevant word size is a bit outdated.</div><br/></div></div></div></div></div></div><div id="41875413" class="c"><input type="checkbox" id="c-41875413" checked=""/><div class="controls bullet"><span class="by">elteto</span><span>|</span><a href="#41874794">parent</a><span>|</span><a href="#41874838">prev</a><span>|</span><a href="#41875260">next</a><span>|</span><label class="collapse" for="c-41875413">[-]</label><label class="expand" for="c-41875413">[1 more]</label></div><br/><div class="children"><div class="content">There are 4 bytes in word:<p><pre><code>  const char word[] = {‘w’, ‘o’, ‘r’, ‘d’};
  assert(sizeof word == 4);</code></pre></div><br/></div></div><div id="41875260" class="c"><input type="checkbox" id="c-41875260" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#41874794">parent</a><span>|</span><a href="#41875413">prev</a><span>|</span><a href="#41875162">next</a><span>|</span><label class="collapse" for="c-41875260">[-]</label><label class="expand" for="c-41875260">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen 6 8-bit characters&#x2F;word (Burroughs large systems, they also support 8 6-bit characters&#x2F;word)</div><br/></div></div></div></div><div id="41875162" class="c"><input type="checkbox" id="c-41875162" checked=""/><div class="controls bullet"><span class="by">DowsingSpoon</span><span>|</span><a href="#41874794">prev</a><span>|</span><a href="#41876113">next</a><span>|</span><label class="collapse" for="c-41875162">[-]</label><label class="expand" for="c-41875162">[1 more]</label></div><br/><div class="children"><div class="content">As a person who designed and built a hobby CPU with a sixteen-bit byte, I’m not sure how I feel about this proposal.</div><br/></div></div><div id="41876113" class="c"><input type="checkbox" id="c-41876113" checked=""/><div class="controls bullet"><span class="by">vitiral</span><span>|</span><a href="#41875162">prev</a><span>|</span><a href="#41874934">next</a><span>|</span><label class="collapse" for="c-41876113">[-]</label><label class="expand" for="c-41876113">[1 more]</label></div><br/><div class="children"><div class="content">I wish the types were all in bytes instead of bits too. u1 is unsigned 1 byte and u8 is 8 bytes.<p>That&#x27;s probably not going to fly anymore though</div><br/></div></div><div id="41874934" class="c"><input type="checkbox" id="c-41874934" checked=""/><div class="controls bullet"><span class="by">aj7</span><span>|</span><a href="#41876113">prev</a><span>|</span><a href="#41875136">next</a><span>|</span><label class="collapse" for="c-41874934">[-]</label><label class="expand" for="c-41874934">[1 more]</label></div><br/><div class="children"><div class="content">And then we lose communication with Europa Clipper.</div><br/></div></div><div id="41875136" class="c"><input type="checkbox" id="c-41875136" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#41874934">prev</a><span>|</span><a href="#41875813">next</a><span>|</span><label class="collapse" for="c-41875136">[-]</label><label class="expand" for="c-41875136">[3 more]</label></div><br/><div class="children"><div class="content">This is entertaining and probably a good idea but the justification is very abstract.<p>Specifically, has there even been a C++ compiler on a system where bytes weren&#x27;t 8 bits?  If so, when was it last updated?</div><br/><div id="41875179" class="c"><input type="checkbox" id="c-41875179" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#41875136">parent</a><span>|</span><a href="#41875156">next</a><span>|</span><label class="collapse" for="c-41875179">[-]</label><label class="expand" for="c-41875179">[1 more]</label></div><br/><div class="children"><div class="content">There were&#x2F;are C++ compilers for PDP-10 (9 bit byte).   Those haven&#x27;t been maintained AFAICT, but there are C++ compilers for various DSP&#x27;s where the smallest unit of access is 16 or 32 bits that are still being sold.</div><br/></div></div><div id="41875156" class="c"><input type="checkbox" id="c-41875156" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41875136">parent</a><span>|</span><a href="#41875179">prev</a><span>|</span><a href="#41875813">next</a><span>|</span><label class="collapse" for="c-41875156">[-]</label><label class="expand" for="c-41875156">[1 more]</label></div><br/><div class="children"><div class="content">I know some DSPs have 24-bit &quot;bytes&quot;, and there are C compilers available for them.</div><br/></div></div></div></div><div id="41875813" class="c"><input type="checkbox" id="c-41875813" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#41875136">prev</a><span>|</span><a href="#41875386">next</a><span>|</span><label class="collapse" for="c-41875813">[-]</label><label class="expand" for="c-41875813">[1 more]</label></div><br/><div class="children"><div class="content">I like the diversity of hardware and strange machines. So this saddens me. But I&#x27;m in the minority I think.</div><br/></div></div><div id="41875386" class="c"><input type="checkbox" id="c-41875386" checked=""/><div class="controls bullet"><span class="by">whatsakandr</span><span>|</span><a href="#41875813">prev</a><span>|</span><a href="#41874989">next</a><span>|</span><label class="collapse" for="c-41875386">[-]</label><label class="expand" for="c-41875386">[1 more]</label></div><br/><div class="children"><div class="content">Hoesntly at thought this might be an onion headline. But then I stopped to think about it.</div><br/></div></div><div id="41874989" class="c"><input type="checkbox" id="c-41874989" checked=""/><div class="controls bullet"><span class="by">hexo</span><span>|</span><a href="#41875386">prev</a><span>|</span><a href="#41875072">next</a><span>|</span><label class="collapse" for="c-41874989">[-]</label><label class="expand" for="c-41874989">[3 more]</label></div><br/><div class="children"><div class="content">Why? Pls no. We&#x27;ve been told (in school!) that byte is byte. Its only sometimes 8bits long (ok, most of the time these days). Do not destroy the last bits of fun.
Is network order little endian too?</div><br/><div id="41875209" class="c"><input type="checkbox" id="c-41875209" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#41874989">parent</a><span>|</span><a href="#41875671">next</a><span>|</span><label class="collapse" for="c-41875209">[-]</label><label class="expand" for="c-41875209">[1 more]</label></div><br/><div class="children"><div class="content">I think there&#x27;s plenty of fun left in the standard if they remove this :)</div><br/></div></div><div id="41875671" class="c"><input type="checkbox" id="c-41875671" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#41874989">parent</a><span>|</span><a href="#41875209">prev</a><span>|</span><a href="#41875072">next</a><span>|</span><label class="collapse" for="c-41875671">[-]</label><label class="expand" for="c-41875671">[1 more]</label></div><br/><div class="children"><div class="content">Heretic, do not defile the last remnants of true order!</div><br/></div></div></div></div><div id="41875072" class="c"><input type="checkbox" id="c-41875072" checked=""/><div class="controls bullet"><span class="by">gafferongames</span><span>|</span><a href="#41874989">prev</a><span>|</span><a href="#41874940">next</a><span>|</span><label class="collapse" for="c-41875072">[-]</label><label class="expand" for="c-41875072">[1 more]</label></div><br/><div class="children"><div class="content">Amazing stuff guys. Bravo.</div><br/></div></div><div id="41874940" class="c"><input type="checkbox" id="c-41874940" checked=""/><div class="controls bullet"><span class="by">starik36</span><span>|</span><a href="#41875072">prev</a><span>|</span><label class="collapse" for="c-41874940">[-]</label><label class="expand" for="c-41874940">[1 more]</label></div><br/><div class="children"><div class="content">There are FOUR bits.<p>Jean-Luc Picard</div><br/></div></div></div></div></div></div></div></body></html>