<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733475653505" as="style"/><link rel="stylesheet" href="styles.css?v=1733475653505"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bit.kevinslin.com/p/lossless-log-aggregation">Lossless Log Aggregation - Reduce Log Volume by 99% Without Dropping Data</a> <span class="domain">(<a href="https://bit.kevinslin.com">bit.kevinslin.com</a>)</span></div><div class="subtext"><span>benshumaker</span> | <span>35 comments</span></div><br/><div><div id="42335887" class="c"><input type="checkbox" id="c-42335887" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#42337653">next</a><span>|</span><label class="collapse" for="c-42335887">[-]</label><label class="expand" for="c-42335887">[2 more]</label></div><br/><div class="children"><div class="content">But… this does drop data? Only the start and end timestamp are preserved; the middle ones have no time. How can this be called lossless?<p>Genuinely lossless compression algorithms like gzip work pretty well.</div><br/><div id="42335976" class="c"><input type="checkbox" id="c-42335976" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#42335887">parent</a><span>|</span><a href="#42337653">next</a><span>|</span><label class="collapse" for="c-42335976">[-]</label><label class="expand" for="c-42335976">[1 more]</label></div><br/><div class="children"><div class="content">Was going to point out the same thing - the original article&#x27;s solution is losing timestamps and possibly ordering. They also are losing some compressibility by converting to a structured format (JSON).  And if they actually include a lot of UUIDs (their diagram is vague on what transaction IDs look like), then good luck - those don&#x27;t compress very well.<p>I worked at a magnificent 7 company that compressed a lot of logs; we found that zstd actually did the best all-around job back in 2021 after a lot of testing.</div><br/></div></div></div></div><div id="42337653" class="c"><input type="checkbox" id="c-42337653" checked=""/><div class="controls bullet"><span class="by">KaiserPro</span><span>|</span><a href="#42335887">prev</a><span>|</span><a href="#42335631">next</a><span>|</span><label class="collapse" for="c-42337653">[-]</label><label class="expand" for="c-42337653">[1 more]</label></div><br/><div class="children"><div class="content">Shipping and diving logs is a bad idea for anything other than last line debug defence.<p>If you&#x27;re going to agregate your logs, you&#x27;re much better off converting them to metrics _on device_. it makes comparison much easier, and storage and pensioning trivial.</div><br/></div></div><div id="42335631" class="c"><input type="checkbox" id="c-42335631" checked=""/><div class="controls bullet"><span class="by">aaaronic</span><span>|</span><a href="#42337653">prev</a><span>|</span><a href="#42336835">next</a><span>|</span><label class="collapse" for="c-42335631">[-]</label><label class="expand" for="c-42335631">[1 more]</label></div><br/><div class="children"><div class="content">The multi-line case can usually be fixed with simple configuration changes to a structured log format.<p>The other cases are more interesting, and pre-aggregation of all logs related to a correlation ID can be really helpful when debugging a specific incident, but it does seem like this proposal is the same basic trade-off around size and performance as with virtually any form of compression.</div><br/></div></div><div id="42336835" class="c"><input type="checkbox" id="c-42336835" checked=""/><div class="controls bullet"><span class="by">eastern</span><span>|</span><a href="#42335631">prev</a><span>|</span><a href="#42335722">next</a><span>|</span><label class="collapse" for="c-42336835">[-]</label><label class="expand" for="c-42336835">[2 more]</label></div><br/><div class="children"><div class="content">The obvious answer is a relational structure. In the given example, host, status, path and target should be separate relations. They&#x27;ll all be tiny ones, a few rows each.<p>Of course, performance etc are a separate story but as far as the shape of the data goes, that&#x27;s what the solution is</div><br/><div id="42337038" class="c"><input type="checkbox" id="c-42337038" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#42336835">parent</a><span>|</span><a href="#42335722">next</a><span>|</span><label class="collapse" for="c-42337038">[-]</label><label class="expand" for="c-42337038">[1 more]</label></div><br/><div class="children"><div class="content">Then you&#x27;re locking your data into a relational model.<p>A log is universal, and can be projected to relational, document etc. Which is why most relational databases are built on top of them.</div><br/></div></div></div></div><div id="42335722" class="c"><input type="checkbox" id="c-42335722" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#42336835">prev</a><span>|</span><a href="#42335840">next</a><span>|</span><label class="collapse" for="c-42335722">[-]</label><label class="expand" for="c-42335722">[21 more]</label></div><br/><div class="children"><div class="content">I have a persistent mental nag that the way we do logging always seems so inefficient: that theoretically no application should ever be outputting actual text messages, because logs are basically fixed strings + formatting data.<p>So in theory we could uniquely identify all logs as a much more compact binary representation + a lookup table we ship with the executable.</div><br/><div id="42337795" class="c"><input type="checkbox" id="c-42337795" checked=""/><div class="controls bullet"><span class="by">jpalomaki</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42337515">next</a><span>|</span><label class="collapse" for="c-42337795">[-]</label><label class="expand" for="c-42337795">[1 more]</label></div><br/><div class="children"><div class="content">Side benefit is that you don&#x27;t need to parse the arbitrary strings to extract information from the logs.</div><br/></div></div><div id="42337515" class="c"><input type="checkbox" id="c-42337515" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42337795">prev</a><span>|</span><a href="#42335758">next</a><span>|</span><label class="collapse" for="c-42337515">[-]</label><label class="expand" for="c-42337515">[1 more]</label></div><br/><div class="children"><div class="content">Yep, every actually efficient logging system does it that way. It is the only way you can log fast enough to saturate memory bandwidth or output billions of logs per core-second.<p>You can see a fairly general explanation of the concept here: <a href="https:&#x2F;&#x2F;messagetemplates.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;messagetemplates.org&#x2F;</a></div><br/></div></div><div id="42335758" class="c"><input type="checkbox" id="c-42335758" checked=""/><div class="controls bullet"><span class="by">drivebyhooting</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42337515">prev</a><span>|</span><a href="#42336032">next</a><span>|</span><label class="collapse" for="c-42335758">[-]</label><label class="expand" for="c-42335758">[2 more]</label></div><br/><div class="children"><div class="content">Compression will basically achieve that kind of encoding without tightly coupling your logging with an external enum or schema.</div><br/><div id="42337479" class="c"><input type="checkbox" id="c-42337479" checked=""/><div class="controls bullet"><span class="by">vouwfietsman</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42335758">parent</a><span>|</span><a href="#42336032">next</a><span>|</span><label class="collapse" for="c-42337479">[-]</label><label class="expand" for="c-42337479">[1 more]</label></div><br/><div class="children"><div class="content">Compression is only ever as good as the information it is given, if given text, it can do an OK job using general entropy encoding. However, most data is not text, even log data is not text. Log data is timestamps, numbers, enums, indices, guids, text, etc. Each of those categories, combined with how they are layed out, can be compressed in different optimal ways, resulting in different optimal compression ratios based on your specific log format. As a simple example, compressing 3D meshes as meshes is an order of magnitude better than compressing 3D meshes as text.<p>Sure, zipping your logs gives you a LOT, and you should do it, but if the result disappoints it is not the end of the road, at all.</div><br/></div></div></div></div><div id="42336032" class="c"><input type="checkbox" id="c-42336032" checked=""/><div class="controls bullet"><span class="by">muststopmyths</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42335758">prev</a><span>|</span><a href="#42336150">next</a><span>|</span><label class="collapse" for="c-42336032">[-]</label><label class="expand" for="c-42336032">[4 more]</label></div><br/><div class="children"><div class="content">Microsoft had a poorly documented tool called tracewpp that did this. Blindingly fast logging with very little runtime overhead.<p>It was hard to figure out how to use it without documentation so it wasn’t very popular. No idea if they still ship it in the DDK.<p>It was a preprocessor that converted logging macros into string table references so there was no runtime formatting. You decoded the binary logs with another tool after the fact.<p>Vaguely remember some open source cross platform tool that did something similar but the name escapes me now.</div><br/><div id="42336864" class="c"><input type="checkbox" id="c-42336864" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42336032">parent</a><span>|</span><a href="#42336286">next</a><span>|</span><label class="collapse" for="c-42336864">[-]</label><label class="expand" for="c-42336864">[1 more]</label></div><br/><div class="children"><div class="content">I think the Windows event log works like this. Sadly it&#x27;s very opaque and difficult to use for non admin apps (you need admin rights to install your logs for the first time. Afterwards you can run with less privileges.)</div><br/></div></div><div id="42336286" class="c"><input type="checkbox" id="c-42336286" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42336032">parent</a><span>|</span><a href="#42336864">prev</a><span>|</span><a href="#42336044">next</a><span>|</span><label class="collapse" for="c-42336286">[-]</label><label class="expand" for="c-42336286">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It was a preprocessor that converted logging macros into string table references so there was no runtime formatting. You decoded the binary logs with another tool after the fact.<p>Is be curious how that stacks up against something like zstd with a predefined dictionary.</div><br/></div></div><div id="42336044" class="c"><input type="checkbox" id="c-42336044" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42336032">parent</a><span>|</span><a href="#42336286">prev</a><span>|</span><a href="#42336150">next</a><span>|</span><label class="collapse" for="c-42336044">[-]</label><label class="expand" for="c-42336044">[1 more]</label></div><br/><div class="children"><div class="content">Apple’s os_log API also works this way.</div><br/></div></div></div></div><div id="42336150" class="c"><input type="checkbox" id="c-42336150" checked=""/><div class="controls bullet"><span class="by">dietr1ch</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42336032">prev</a><span>|</span><a href="#42335752">next</a><span>|</span><label class="collapse" for="c-42336150">[-]</label><label class="expand" for="c-42336150">[1 more]</label></div><br/><div class="children"><div class="content">Besides space, you can also save CPU when writing logs.<p>This is a logging library that does lazy formatting,
  - <a href="https:&#x2F;&#x2F;defmt.ferrous-systems.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;defmt.ferrous-systems.com&#x2F;</a></div><br/></div></div><div id="42335752" class="c"><input type="checkbox" id="c-42335752" checked=""/><div class="controls bullet"><span class="by">RHSeeger</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42336150">prev</a><span>|</span><a href="#42337456">next</a><span>|</span><label class="collapse" for="c-42335752">[-]</label><label class="expand" for="c-42335752">[1 more]</label></div><br/><div class="children"><div class="content">It depends on your use case. If you&#x27;re looking to have a set of data that you can search through, sure. If you&#x27;re looking to tail the log while working on things, having it output in plain text is very handy.</div><br/></div></div><div id="42337456" class="c"><input type="checkbox" id="c-42337456" checked=""/><div class="controls bullet"><span class="by">david38</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42335752">prev</a><span>|</span><a href="#42336318">next</a><span>|</span><label class="collapse" for="c-42337456">[-]</label><label class="expand" for="c-42337456">[1 more]</label></div><br/><div class="children"><div class="content">This is what metrics are for</div><br/></div></div><div id="42336318" class="c"><input type="checkbox" id="c-42336318" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42337456">prev</a><span>|</span><a href="#42335812">next</a><span>|</span><label class="collapse" for="c-42336318">[-]</label><label class="expand" for="c-42336318">[6 more]</label></div><br/><div class="children"><div class="content">Your feelings are spot on.<p>In most modern distributed tracing, &quot;observability&quot;, or similar systems the <i>write amplification</i> is typically 100:1 because of these overheads.<p>For example, in Azure, every log entry includes a bunch of highly repetitive fields in full, such as the resource ID, &quot;Azure&quot; as the source system, the log entry Type, the source system, tenant, etc...<p>A single &quot;line&quot; is typically over a kilobyte, but often the interesting part is maybe 4 to 20 bytes of actual payload data. Sending this involves HTTP overheads as well such as the headers, authentication, etc...<p>Most vendors in this space <i>charge by the gigabyte</i>, so as you can imagine they have zero incentive to improve on this.<p>Even for efficient binary logs such as the Windows performance counters, I noticed that second-to-second they&#x27;re very highly redundant.<p>I once experimented with a metric monitor that could collect 10,000-15,000 metrics <i>per server per second</i> and use only about 100MB of storage per host... <i>per year</i>.<p>The trick was to simply binary-diff the collected metrics with some light &quot;alignment&quot; so that groups of related metrics would be at the same offsets. Almost all numbers become zero, and compress very well.</div><br/><div id="42336504" class="c"><input type="checkbox" id="c-42336504" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42336318">parent</a><span>|</span><a href="#42337474">next</a><span>|</span><label class="collapse" for="c-42336504">[-]</label><label class="expand" for="c-42336504">[3 more]</label></div><br/><div class="children"><div class="content">You never send a single individual log event per HTTP request, you always batch them up. Assuming some reasonable batch size per request (minimum ~1MiB or so) there is rarely any meaningful difference in payload size between gzipped&#x2F;zstd&#x2F;whatever JSON bytes, and any particular binary encoding format you might prefer.</div><br/><div id="42337022" class="c"><input type="checkbox" id="c-42337022" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42336504">parent</a><span>|</span><a href="#42337474">next</a><span>|</span><label class="collapse" for="c-42337022">[-]</label><label class="expand" for="c-42337022">[2 more]</label></div><br/><div class="children"><div class="content">Most log collection systems do not compress logs as they send them, because again, why would they? This would instantly turn their firehose of revenue cash down to a trickle. Any engineer suggesting such a feature would be disciplined at best, fired at worst. Even if their boss is naive to the business realities and approves the idea, it turns out that it&#x27;s weirdly difficult in HTTP to send compressed <i>requests</i>. See: <a href="https:&#x2F;&#x2F;medium.com&#x2F;@abhinav.ittekot&#x2F;why-http-request-compression-is-almost-never-supported-5de68067b245" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@abhinav.ittekot&#x2F;why-http-request-compres...</a><p>HTTP&#x2F;2 would also improve efficiency because of its built-in header compression feature, but again, I&#x27;ve not seen this used much.<p>The ideal would be to have some sort of &quot;session&quot; cookie associated with a bag of constants, slowly changing values, and the schema for the source tables. Send this once a day or so, and then send only the cookie followed by columnar data compressed with RLE and then zstd. Ideally in a format where the server doesn&#x27;t have to apply any processing to store the data apart from some light verification and appending onto existing blobs. I.e.: make the whole thing compatible with Parquet, Avro, or <i>something</i> other than just sending uncompressed JSON like a savage.</div><br/><div id="42337584" class="c"><input type="checkbox" id="c-42337584" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42337022">parent</a><span>|</span><a href="#42337474">next</a><span>|</span><label class="collapse" for="c-42337584">[-]</label><label class="expand" for="c-42337584">[1 more]</label></div><br/><div class="children"><div class="content">Most systems _do_ compress request payloads on the wire, because the cost-per-byte in transit over those wires is almost always frictional and externalized.<p>Weird perspective, yours.</div><br/></div></div></div></div></div></div><div id="42337474" class="c"><input type="checkbox" id="c-42337474" checked=""/><div class="controls bullet"><span class="by">david38</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42336318">parent</a><span>|</span><a href="#42336504">prev</a><span>|</span><a href="#42335812">next</a><span>|</span><label class="collapse" for="c-42337474">[-]</label><label class="expand" for="c-42337474">[2 more]</label></div><br/><div class="children"><div class="content">This is why metrics rule and logging in production need only be turned on to debug specific problems and even then have a short TTL</div><br/><div id="42337522" class="c"><input type="checkbox" id="c-42337522" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42337474">parent</a><span>|</span><a href="#42335812">next</a><span>|</span><label class="collapse" for="c-42337522">[-]</label><label class="expand" for="c-42337522">[1 more]</label></div><br/><div class="children"><div class="content">You got... entirely the wrong message.<p>The answer to &quot;this thing is horrendously inefficient because of misaligned incentives&quot; isn&#x27;t to be frugal with the thing, but to <i>make it efficient</i>, ideally by aligning incentives.<p>Open source monitoring software will eventually blow the proprietary products out of the water because when you&#x27;re running something yourself, the cost per gigabyte is now just your own cost and not a <i>profit centre line item</i> for someone else.</div><br/></div></div></div></div></div></div><div id="42335812" class="c"><input type="checkbox" id="c-42335812" checked=""/><div class="controls bullet"><span class="by">floren</span><span>|</span><a href="#42335722">parent</a><span>|</span><a href="#42336318">prev</a><span>|</span><a href="#42335840">next</a><span>|</span><label class="collapse" for="c-42335812">[-]</label><label class="expand" for="c-42335812">[3 more]</label></div><br/><div class="children"><div class="content">How big of a lookup table will you use for logging IPv6 addresses?</div><br/><div id="42335930" class="c"><input type="checkbox" id="c-42335930" checked=""/><div class="controls bullet"><span class="by">do_not_redeem</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42335812">parent</a><span>|</span><a href="#42335840">next</a><span>|</span><label class="collapse" for="c-42335930">[-]</label><label class="expand" for="c-42335930">[2 more]</label></div><br/><div class="children"><div class="content">&gt; fixed strings + formatting data<p>IP addresses are obviously part of the formatting data, not the fixed strings.</div><br/><div id="42336054" class="c"><input type="checkbox" id="c-42336054" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#42335722">root</a><span>|</span><a href="#42335930">parent</a><span>|</span><a href="#42335840">next</a><span>|</span><label class="collapse" for="c-42336054">[-]</label><label class="expand" for="c-42336054">[1 more]</label></div><br/><div class="children"><div class="content">Why wouldn&#x27;t IPv6 compress well?<p>IPv6 is used internally a lot more than externally, so I would expect to see a LOT of commonality in the network ID fraction of the addresses- essentially all the bits of representing your IPv6 network ID get reduced to the number of bits in a compression token, in the worst case.  In the moderate case, you get a few chatty machines (DNS servers and the like) where the whole address is converted to a single compression token.  In the best case, you get that AND a lot of repetition in the rest of the message, and you reduce most of each message to a single compression token.<p>It&#x27;s hard to explain if you haven&#x27;t actually experimented with it, but modern variants of LZ compression are miraculous.  It&#x27;s like compilers- your intuition tells you hand tuned assembly is better, but compilers know crazy tricks and that intuition is almost always wrong.  Same with compressors- they don&#x27;t look at data the same way you do, and they work way better than your intuition thinks they would.</div><br/></div></div></div></div></div></div></div></div><div id="42335840" class="c"><input type="checkbox" id="c-42335840" checked=""/><div class="controls bullet"><span class="by">iampims</span><span>|</span><a href="#42335722">prev</a><span>|</span><a href="#42335755">next</a><span>|</span><label class="collapse" for="c-42335840">[-]</label><label class="expand" for="c-42335840">[4 more]</label></div><br/><div class="children"><div class="content">Or sampling :)</div><br/><div id="42335865" class="c"><input type="checkbox" id="c-42335865" checked=""/><div class="controls bullet"><span class="by">craigching</span><span>|</span><a href="#42335840">parent</a><span>|</span><a href="#42335755">next</a><span>|</span><label class="collapse" for="c-42335865">[-]</label><label class="expand" for="c-42335865">[3 more]</label></div><br/><div class="children"><div class="content">Sampling is lossy though</div><br/><div id="42336065" class="c"><input type="checkbox" id="c-42336065" checked=""/><div class="controls bullet"><span class="by">iampims</span><span>|</span><a href="#42335840">root</a><span>|</span><a href="#42335865">parent</a><span>|</span><a href="#42335755">next</a><span>|</span><label class="collapse" for="c-42336065">[-]</label><label class="expand" for="c-42336065">[2 more]</label></div><br/><div class="children"><div class="content">lossy and simpler.<p>IME, I&#x27;ve found sampling simpler to reason about, and with the sampling rate part of the message, deriving metrics from logs works pretty well.<p>The example in the article is a little contrived. Healthchecks often originate from multiple hosts and&#x2F;or logs contain the remote address+port, leading to each log message being effectively unique. So sure, one could parse the remote address into remote_address=192.168.12.23 remote_port=64780 and then decide to drop the port in the aggregation, but is it worth the squeeze?</div><br/><div id="42336940" class="c"><input type="checkbox" id="c-42336940" checked=""/><div class="controls bullet"><span class="by">kiitos</span><span>|</span><a href="#42335840">root</a><span>|</span><a href="#42336065">parent</a><span>|</span><a href="#42335755">next</a><span>|</span><label class="collapse" for="c-42336940">[-]</label><label class="expand" for="c-42336940">[1 more]</label></div><br/><div class="children"><div class="content">If a service emits a log event, then that log event should be visible in your logging system. Basic stuff. Sampling fails this table-stakes requirement.</div><br/></div></div></div></div></div></div></div></div><div id="42335755" class="c"><input type="checkbox" id="c-42335755" checked=""/><div class="controls bullet"><span class="by">ThrowawayTestr</span><span>|</span><a href="#42335840">prev</a><span>|</span><a href="#42335847">next</a><span>|</span><label class="collapse" for="c-42335755">[-]</label><label class="expand" for="c-42335755">[2 more]</label></div><br/><div class="children"><div class="content">Logs seem like they&#x27;d be easily compressible, no?</div><br/><div id="42336005" class="c"><input type="checkbox" id="c-42336005" checked=""/><div class="controls bullet"><span class="by">efitz</span><span>|</span><a href="#42335755">parent</a><span>|</span><a href="#42335847">next</a><span>|</span><label class="collapse" for="c-42336005">[-]</label><label class="expand" for="c-42336005">[1 more]</label></div><br/><div class="children"><div class="content">All the LZ variants work well on logs, but I had the best luck so far with zstd.  YMMV.</div><br/></div></div></div></div><div id="42335847" class="c"><input type="checkbox" id="c-42335847" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#42335755">prev</a><span>|</span><label class="collapse" for="c-42335847">[-]</label><label class="expand" for="c-42335847">[1 more]</label></div><br/><div class="children"><div class="content">always assumed this was a given on all the log aggregators SaaS of the last decade.</div><br/></div></div></div></div></div></div></div></body></html>