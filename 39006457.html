<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705482060084" as="style"/><link rel="stylesheet" href="styles.css?v=1705482060084"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://azeemba.com/posts/pids-creating-stable-control-in-games.html">PIDs: Creating Stable Control in Games</a> <span class="domain">(<a href="https://azeemba.com">azeemba.com</a>)</span></div><div class="subtext"><span>azeemba</span> | <span>31 comments</span></div><br/><div><div id="39025163" class="c"><input type="checkbox" id="c-39025163" checked=""/><div class="controls bullet"><span class="by">DoingIsLearning</span><span>|</span><a href="#39024530">next</a><span>|</span><label class="collapse" for="c-39025163">[-]</label><label class="expand" for="c-39025163">[1 more]</label></div><br/><div class="children"><div class="content">For every PID write up that reviews the theory we need an equally length follow up on the practical aspects of PID tuning and problem modelling.</div><br/></div></div><div id="39024530" class="c"><input type="checkbox" id="c-39024530" checked=""/><div class="controls bullet"><span class="by">alanir</span><span>|</span><a href="#39025163">prev</a><span>|</span><a href="#39023017">next</a><span>|</span><label class="collapse" for="c-39024530">[-]</label><label class="expand" for="c-39024530">[1 more]</label></div><br/><div class="children"><div class="content">There is a cool sandbox game on steam called “Plasma” that offers a graphical programming environment which includes a basic PID controller. I was really impressed with how easily I was able to make a cube float almost perfectly in 3D space within that game by only using 3 of these controllers (mainly the P and D portions) and some thrusters by monitoring the pitch and roll angles, and how high above the ground the cube was. I was even more impressed when adding some weight to one side of the cube and seeing the system compensate for it automatically.<p>The process of tuning the gains on the different inputs of the controllers, then seeing how the system responded made me think about how this is a similar yet much simpler process to training ML models.<p>I’ve always been a bit skeptical of how easily one would be able to make changes to something as complex as a large ML model, but looking at it like tuning a very complex PID controller kind of made it seem less like black magic to me for some reason</div><br/></div></div><div id="39023017" class="c"><input type="checkbox" id="c-39023017" checked=""/><div class="controls bullet"><span class="by">zubspace</span><span>|</span><a href="#39024530">prev</a><span>|</span><a href="#39023261">next</a><span>|</span><label class="collapse" for="c-39023017">[-]</label><label class="expand" for="c-39023017">[11 more]</label></div><br/><div class="children"><div class="content">The site explains the three parts of PID&#x27;s very well.<p>On one hand I like PID controllers. It&#x27;s a reusable concept which you can apply to a loot of stuff. On the other hand, in my experience it can be very tricky and cumbersome to tweak them.<p>In the given example, a PID makes perfect sense. There&#x27;s a single, static target location you need to approach. Adjust velocity with a PID and you&#x27;re done.<p>But what if the target location is not static? Imagine that the character needs to move to your mouse pointer? Do PID&#x27;s still hold up? How do you handle the I and D term then?<p>It gets even trickier if you move to 3D. You maybe say, hmm, let&#x27;s use a rigidbody this time instead of a kinematic body for the player character and use PID&#x27;s to adjust forces to steer velocity and rotation.<p>But I never found a good way to do that, because in those other cases the error depends on the goal you need to reach, and if the goal constantly changes, I and D are kinda useless...</div><br/><div id="39023937" class="c"><input type="checkbox" id="c-39023937" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#39023017">parent</a><span>|</span><a href="#39024962">next</a><span>|</span><label class="collapse" for="c-39023937">[-]</label><label class="expand" for="c-39023937">[1 more]</label></div><br/><div class="children"><div class="content">Your example is really a classical real world PID where a motion system tracks a motion profile.  The short answer is yes, PIDs work just as well when the target changes.  The stability of a PID depends on the open loop response which command or error are not part of.<p>The theory isn&#x27;t that simple (you can take a course in Control Theory which would cover that) but I think many&#x2F;most people that use&#x2F;tune PIDs in the real world just use rules of thumb and standard approaches to tune the different components of the loop.  Somewhat more advanced, but still non-theoretical tools, are actually measuring the open loop response which lets you pretty much see the margins you have.  Optimizing PIDs is really trying to get the loop to respond quickly without becoming unstable.<p>Another interesting thing that&#x27;s used in the real world is feed-forward.  That is if you have some estimate of how to perform the function of the PID directly you can just feed that to the output and add the PID in parallel.  The motion control analogy of this is called acceleration feed forward.  If you know the target acceleration you can basically multiply that by some constant and feed it directly to the output (which is generally current to the motor which is more or less linear to acceleration given a constant load).  This dramatically improves the performance of your control system because the PID now just corrects the much smaller residual error.</div><br/></div></div><div id="39024962" class="c"><input type="checkbox" id="c-39024962" checked=""/><div class="controls bullet"><span class="by">ilayn</span><span>|</span><a href="#39023017">parent</a><span>|</span><a href="#39023937">prev</a><span>|</span><a href="#39023818">next</a><span>|</span><label class="collapse" for="c-39024962">[-]</label><label class="expand" for="c-39024962">[1 more]</label></div><br/><div class="children"><div class="content">&gt; the error depends on the goal you need to reach, and if the goal constantly changes, I and D are kinda useless...<p>Why do you think that? the error is the difference between actual and desired at every instant. If you move the desired then you enlarge the error term and PID reacts to close that gap, it might never reach if you are changing the goal too fast but that&#x27;s something related to the concept of &quot;bandwidth&quot;. OTherwise you are quite right and all is OK.<p>If you have multiple axes then the typical solution is to have n PID loops for n axes. This assumes that the dynamics of the system is decoupled. In english, if I do something in one axis it will not affect the other axes. Then you can tune the PID loops independently. Otherwise, dry math.</div><br/></div></div><div id="39023818" class="c"><input type="checkbox" id="c-39023818" checked=""/><div class="controls bullet"><span class="by">amatic</span><span>|</span><a href="#39023017">parent</a><span>|</span><a href="#39024962">prev</a><span>|</span><a href="#39023236">next</a><span>|</span><label class="collapse" for="c-39023818">[-]</label><label class="expand" for="c-39023818">[1 more]</label></div><br/><div class="children"><div class="content">A tuned PID loop should follow a moving target with no issues and no advanced control theory. Here is a similar example from a Lego robot with a pixi camera [1]. The pixi camera recognizes the ball location in 2D, sends to arduino. There are two independent loops, one keeping the ball in the center of the horizontal visual field, by rotating the camera left-right, and the other is keeping the ball in the center vertically, by tilting the camera via two levers. 
One thing you might notice is that the ball sometimes goes too fast for the robot to follow - this is due to the limitations of the power of the motors, and the rate of sampling in the loop. Games usually don&#x27;t have the limitation of the power, but I suppose the rate of sampling and updating the loop could be limited by the game loop. In that case, it might be useful to update the PID multiple times per loop.<p>Other than that, there are some tricks to make the loops more stable. Limiting the error can be useful. Limiting the action of the actuator. Smoothing the action of the actuator is very useful. I tend to think of PD loops as damped springs. The P term is like the spring constant, and the D term is like friction or viscosity. The first one determines the speed of reaching the goal, and the second one reduces the oscillations when reaching the goal. I rarely use the I term.<p>[1]<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7_IZb0RJN_U" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7_IZb0RJN_U</a></div><br/></div></div><div id="39023236" class="c"><input type="checkbox" id="c-39023236" checked=""/><div class="controls bullet"><span class="by">x86x87</span><span>|</span><a href="#39023017">parent</a><span>|</span><a href="#39023818">prev</a><span>|</span><a href="#39023299">next</a><span>|</span><label class="collapse" for="c-39023236">[-]</label><label class="expand" for="c-39023236">[4 more]</label></div><br/><div class="children"><div class="content">Lol. There is an entire field dedicated to this question. It&#x27;s called Automatic Control. Yes, you can do all of the above. You need to model it with a multivariable system. Google control systems and systems theory.<p>Usually in a physical control system (that is driven by a PID controller) your limiting factors are the execution element (how fast can you change the input) and your sensors (the resolution of the transducers&#x2F;sensors dictate the resolution of what you can achieve). A lot of times the PID controller will have a way that it can autotune itself as it&#x27;s extremely rare to be able to measure the properties of the physical system precisely and for those properties to not vary with temperature and with wear and tear.</div><br/><div id="39023453" class="c"><input type="checkbox" id="c-39023453" checked=""/><div class="controls bullet"><span class="by">zubspace</span><span>|</span><a href="#39023017">root</a><span>|</span><a href="#39023236">parent</a><span>|</span><a href="#39023299">next</a><span>|</span><label class="collapse" for="c-39023453">[-]</label><label class="expand" for="c-39023453">[3 more]</label></div><br/><div class="children"><div class="content">Well, you kind of prove my point, because you made me jump from a 5 minute lecture about PIDs to a study about control systems.<p>Yes, probably there are all kinds of systems to control and autotune a PID. But that&#x27;s the problem. In gamedev, PID&#x27;s get constantly recommended for so many things, but when you play around with them you soon realize, that they are quite hard to get right. So then there&#x27;s two ways: you dive into control systems or you just lerp the value and call it a day.</div><br/><div id="39023618" class="c"><input type="checkbox" id="c-39023618" checked=""/><div class="controls bullet"><span class="by">x86x87</span><span>|</span><a href="#39023017">root</a><span>|</span><a href="#39023453">parent</a><span>|</span><a href="#39023299">next</a><span>|</span><label class="collapse" for="c-39023618">[-]</label><label class="expand" for="c-39023618">[2 more]</label></div><br/><div class="children"><div class="content">yup. i get it. it&#x27;s a steep learning curve. and it&#x27;s hard to grok if you don&#x27;t understand what the theory behind them is.<p>My bigger point is that the articles like the one linked here just barely scratch the surface and you cannot really jump into it and get an intuitive understanding by just looking at it. that being said, if you want to learn more you can and they can be applied to a large range of problems.</div><br/><div id="39024910" class="c"><input type="checkbox" id="c-39024910" checked=""/><div class="controls bullet"><span class="by">ilayn</span><span>|</span><a href="#39023017">root</a><span>|</span><a href="#39023618">parent</a><span>|</span><a href="#39023299">next</a><span>|</span><label class="collapse" for="c-39024910">[-]</label><label class="expand" for="c-39024910">[1 more]</label></div><br/><div class="children"><div class="content">Control theorist here. The articles are pretty good. There is nothing wrong with them.<p>What you are insinuating is not always correct that if you model stuff you&#x27;ll get a better result. Sometimes PID is more then enough and in fact better since your model can get arbitrarily complex and you don&#x27;t have any tools to deal with that behavior. It&#x27;s a bit snobbish that you need to have math and all the shenanigans. The rest of the manufacturing world disagrees with your premise that is very common in academic circles.</div><br/></div></div></div></div></div></div></div></div><div id="39023299" class="c"><input type="checkbox" id="c-39023299" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#39023017">parent</a><span>|</span><a href="#39023236">prev</a><span>|</span><a href="#39023261">next</a><span>|</span><label class="collapse" for="c-39023299">[-]</label><label class="expand" for="c-39023299">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done character controllers and AI with rigid bodies and I just tune damping values and naive functions until it&#x27;s good enough and I achieve great results. Ie: players doing backflips with torque, AI steering and slowing to a stop within a small radius of a destination.<p>It&#x27;s just a game!</div><br/><div id="39023498" class="c"><input type="checkbox" id="c-39023498" checked=""/><div class="controls bullet"><span class="by">zubspace</span><span>|</span><a href="#39023017">root</a><span>|</span><a href="#39023299">parent</a><span>|</span><a href="#39023261">next</a><span>|</span><label class="collapse" for="c-39023498">[-]</label><label class="expand" for="c-39023498">[2 more]</label></div><br/><div class="children"><div class="content">Simple example: You want to control torque with a PID to reach a target angular velocity. What if the player suddenly negates the target angular velocity (by going from left arrow key press to right arrow key press for example).<p>How do you handle the I and D term then?<p>What if the player can also use a gamepad and go from left to right gradually?<p>The fundamental problem is that the error accumulates while you try to reach the target. But then the target suddenly changes. Do you just drop the previous error? Do you create an upper bound on the error? Or something else? This is the question no PID post ever answers.<p>I don&#x27;t say, that this is impossible, but just that PID&#x27;s in this context are harder to use than they first appear.</div><br/><div id="39024204" class="c"><input type="checkbox" id="c-39024204" checked=""/><div class="controls bullet"><span class="by">applied_heat</span><span>|</span><a href="#39023017">root</a><span>|</span><a href="#39023498">parent</a><span>|</span><a href="#39023261">next</a><span>|</span><label class="collapse" for="c-39024204">[-]</label><label class="expand" for="c-39024204">[1 more]</label></div><br/><div class="children"><div class="content">Yes drop the “previous error” by setting the integral to zero when the setpoint changes such that the sign of the error changes.<p>If the derivative is on the error when the setpoint is changed all of the sudden the error is increasing instead of decreasing so it works as desired.<p>There are many books on control systems that cover different forms of the PID algorithm and what applications they suit.<p>I prefer the velocity form or double derivative form for the simplicity of managing the integrator and applying real world limits on maximum and minimum outputs and rate of change of output. I basically never need such a fast response that it is worth bothering with D.<p>A mathematics professor solved the differential equations governing my processes so now I can calculate the exact correct gains for critical damping and simulate the response for different limitations such as input sensor resolution and measurement delays. It is wonderful.</div><br/></div></div></div></div></div></div></div></div><div id="39023261" class="c"><input type="checkbox" id="c-39023261" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#39023017">prev</a><span>|</span><a href="#39022990">next</a><span>|</span><label class="collapse" for="c-39023261">[-]</label><label class="expand" for="c-39023261">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re learning about PID controllers, do yourself a favor and watch Brian Douglas&#x27;s video series on the topic:<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;wkfEZmsQqiA?si=50WWz4kuber56JIU" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;wkfEZmsQqiA?si=50WWz4kuber56JIU</a><p>Brian has great videos on other control theory topics as well.</div><br/></div></div><div id="39022990" class="c"><input type="checkbox" id="c-39022990" checked=""/><div class="controls bullet"><span class="by">wombatpm</span><span>|</span><a href="#39023261">prev</a><span>|</span><a href="#39022293">next</a><span>|</span><label class="collapse" for="c-39022990">[-]</label><label class="expand" for="c-39022990">[2 more]</label></div><br/><div class="children"><div class="content">PID get real fun when you model physical systems, like say filling a tank while trying to maintain liquid depth and temperature or maintaining a constant reaction rate. You get to start taking laplace transforms. I had a ChemE professor who’d tell stories from the 30’s when chemical engineering was forming as a discipline. Common practice back in the day (before the theory) was to manually adjust parameters until things went unstable, then back off 5%. Turns out the optimum point is the inflection between stable and unstable behavior.</div><br/><div id="39023791" class="c"><input type="checkbox" id="c-39023791" checked=""/><div class="controls bullet"><span class="by">i_am_a_peasant</span><span>|</span><a href="#39022990">parent</a><span>|</span><a href="#39022293">next</a><span>|</span><label class="collapse" for="c-39023791">[-]</label><label class="expand" for="c-39023791">[1 more]</label></div><br/><div class="children"><div class="content">My whole BSc degree was in systems engineering and automatic control. You make me nostalgic about all those classes that at the time I hated. What a weird feeling.</div><br/></div></div></div></div><div id="39022293" class="c"><input type="checkbox" id="c-39022293" checked=""/><div class="controls bullet"><span class="by">bruce343434</span><span>|</span><a href="#39022990">prev</a><span>|</span><a href="#39022654">next</a><span>|</span><label class="collapse" for="c-39022293">[-]</label><label class="expand" for="c-39022293">[5 more]</label></div><br/><div class="children"><div class="content">Feels like PIDs are the wrong tool for this problem. Stuff to do with matching animations up to physics is usually better solved with inverse kinematics.</div><br/><div id="39022903" class="c"><input type="checkbox" id="c-39022903" checked=""/><div class="controls bullet"><span class="by">oreally</span><span>|</span><a href="#39022293">parent</a><span>|</span><a href="#39022472">next</a><span>|</span><label class="collapse" for="c-39022903">[-]</label><label class="expand" for="c-39022903">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is PIDs are vastly preferred in situations where very often real world measurements have a degree of error in them. Like having the wheels of your car slip extra distance when you put your foot on the paddle for a specific amount of time. It&#x27;s a feedback system of sorts.<p>If there&#x27;s no error in measurements, sure, a mix of IK and blending seems to be a lot easier to implement.</div><br/></div></div><div id="39022472" class="c"><input type="checkbox" id="c-39022472" checked=""/><div class="controls bullet"><span class="by">azeemba</span><span>|</span><a href="#39022293">parent</a><span>|</span><a href="#39022903">prev</a><span>|</span><a href="#39022654">next</a><span>|</span><label class="collapse" for="c-39022472">[-]</label><label class="expand" for="c-39022472">[3 more]</label></div><br/><div class="children"><div class="content">What are you imagining in this situation? How would one use IK with a running animation?<p>You could remove the root motion of the animation and control the position of runner in code. This would allow controlling the position&#x2F;speed easily but to look natural you still have to tweak the animation speed dynamically. Just changing the foot position via IK would not be enough to make the animation look natural. So feels like you are still left with the original problem of tweaking the animation speed.</div><br/><div id="39022549" class="c"><input type="checkbox" id="c-39022549" checked=""/><div class="controls bullet"><span class="by">turtledragonfly</span><span>|</span><a href="#39022293">root</a><span>|</span><a href="#39022472">parent</a><span>|</span><a href="#39022654">next</a><span>|</span><label class="collapse" for="c-39022549">[-]</label><label class="expand" for="c-39022549">[2 more]</label></div><br/><div class="children"><div class="content">Not the person you asked, but here&#x27;s a video you might like: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=LNidsMesxSE&amp;t=268s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=LNidsMesxSE&amp;t=268s</a><p>In that example, they do the character&#x27;s physics first (just a ball), then match the animation to it. The animation speed is controlled by a &quot;surveyor wheel&quot; approach — go to  to 336s in the video for that part.<p>So, the animation speed is derived from the physics, rather than the physics speed being derived from the animation.<p>I wouldn&#x27;t call that &quot;IK&quot; exactly, which would be more for things like matching the foot to individual stair steps as the character walks up them, or such. But I suppose in a broader sense it is, since you&#x27;re deciding on a physical goal a-priori, then forcing the animation to match that goal.</div><br/><div id="39022626" class="c"><input type="checkbox" id="c-39022626" checked=""/><div class="controls bullet"><span class="by">azeemba</span><span>|</span><a href="#39022293">root</a><span>|</span><a href="#39022549">parent</a><span>|</span><a href="#39022654">next</a><span>|</span><label class="collapse" for="c-39022626">[-]</label><label class="expand" for="c-39022626">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the link! The ideas are presented so well. Really a cool approach too</div><br/></div></div></div></div></div></div></div></div><div id="39022654" class="c"><input type="checkbox" id="c-39022654" checked=""/><div class="controls bullet"><span class="by">cgg1</span><span>|</span><a href="#39022293">prev</a><span>|</span><a href="#39023491">next</a><span>|</span><label class="collapse" for="c-39022654">[-]</label><label class="expand" for="c-39022654">[8 more]</label></div><br/><div class="children"><div class="content">Using only PD (no I) when tracking also works well. Might be worth adding a short section about that to compare against the full PID.</div><br/><div id="39022777" class="c"><input type="checkbox" id="c-39022777" checked=""/><div class="controls bullet"><span class="by">azeemba</span><span>|</span><a href="#39022654">parent</a><span>|</span><a href="#39023491">next</a><span>|</span><label class="collapse" for="c-39022777">[-]</label><label class="expand" for="c-39022777">[7 more]</label></div><br/><div class="children"><div class="content">Interestingly, there was another PID post earlier today and someone specifically commented on using a PID for camera tracking: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39011630#39016836">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39011630#39016836</a><p>I am surprised to hear about a PD controller though. In my testing, a PI controller seemed to behave much better than a PD controller. In my research, it seemed a common strategy to drop the D-component completely but I did not see the suggestion to drop the I-component.</div><br/><div id="39023440" class="c"><input type="checkbox" id="c-39023440" checked=""/><div class="controls bullet"><span class="by">claytonwramsey</span><span>|</span><a href="#39022654">root</a><span>|</span><a href="#39022777">parent</a><span>|</span><a href="#39022966">next</a><span>|</span><label class="collapse" for="c-39023440">[-]</label><label class="expand" for="c-39023440">[3 more]</label></div><br/><div class="children"><div class="content">In terms of the theoretical guarantees, a PD controller is (nearly) always stable and pretty easy to critically damp. However, if the set point is moving with a nonzero velocity or there is some load, then the PD controller will not converge. A PI and a PID controller can converge even if the target is moving.<p>Practically speaking, I would recommend encoding as much model information as possible before pulling out the I term: for instance, if you know the velocity of your tracked object and assume an intertidal model, you can just include some of that data in your feed forward rather than the controller, which simplifies things greatly.</div><br/><div id="39023674" class="c"><input type="checkbox" id="c-39023674" checked=""/><div class="controls bullet"><span class="by">fho</span><span>|</span><a href="#39022654">root</a><span>|</span><a href="#39023440">parent</a><span>|</span><a href="#39022966">next</a><span>|</span><label class="collapse" for="c-39023674">[-]</label><label class="expand" for="c-39023674">[2 more]</label></div><br/><div class="children"><div class="content">Do you have some resources on that?</div><br/><div id="39024012" class="c"><input type="checkbox" id="c-39024012" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#39022654">root</a><span>|</span><a href="#39023674">parent</a><span>|</span><a href="#39022966">next</a><span>|</span><label class="collapse" for="c-39024012">[-]</label><label class="expand" for="c-39024012">[1 more]</label></div><br/><div class="children"><div class="content">You can use your intuition in the sense that if what you measure just has a constant error without an integrator in the loop that error will never be closed.  Think about a motion control system with a proportional gain where you are pushing the actuator with your hand away from the current position.  The proportional gain will apply a force against your push but generally that will leave some residual error in steady state.  This is where the integrator comes in.  And I agree with the parent that I&#x27;ve mostly seen the D term dropped from controllers, definitely with motion control, though sometimes there are other weird components or multiple loops which may end up having a similar effect.<p>One thing that I think is often confused the matter is that P, I, and D all relate to what you measure and what you&#x27;re controlling.  E.g. you might measure velocity or position in a motion control system, and generally your output is going to be current.  In a temperature control system your measurement would be temperature and your output is likely going to be current (which influences acceleration, not position or velocity).  Ofcourse velocity being the derivative of position means that the meaning of &quot;P&quot; is different.  I haven&#x27;t done PID in a long while but I&#x27;ve always used to ground myself in motion control systems to get a sense what I want to put the loop over.<p>EDIT: E.g. IIRC it&#x27;s common in motion control to have a PI loop over the position error and an additional proportional controller over the velocity (and then filters, feed-forward and a bunch of other components ;) ).</div><br/></div></div></div></div></div></div><div id="39022966" class="c"><input type="checkbox" id="c-39022966" checked=""/><div class="controls bullet"><span class="by">ok_dad</span><span>|</span><a href="#39022654">root</a><span>|</span><a href="#39022777">parent</a><span>|</span><a href="#39023440">prev</a><span>|</span><a href="#39022781">next</a><span>|</span><label class="collapse" for="c-39022966">[-]</label><label class="expand" for="c-39022966">[2 more]</label></div><br/><div class="children"><div class="content">I used a PD controller for a specific application where we were trying to maintain a specific temperature in the future, and cared more about the trajectory of the temperature over time to reach the goal. We didn’t much care for the integration of that temperature since that wasn’t important in this particular case. An integration factor would actually wind up the rate of temperature change too much!</div><br/><div id="39023445" class="c"><input type="checkbox" id="c-39023445" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#39022654">root</a><span>|</span><a href="#39022966">parent</a><span>|</span><a href="#39022781">next</a><span>|</span><label class="collapse" for="c-39023445">[-]</label><label class="expand" for="c-39023445">[1 more]</label></div><br/><div class="children"><div class="content">Integral windup is the term for this issue, there&#x27;s a few ways to deal with the windup if you need to keep the integral component (e.g. for tracking a moving set point, or to overcome a stable error).
<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Integral_windup" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Integral_windup</a></div><br/></div></div></div></div><div id="39022781" class="c"><input type="checkbox" id="c-39022781" checked=""/><div class="controls bullet"><span class="by">cgg1</span><span>|</span><a href="#39022654">root</a><span>|</span><a href="#39022777">parent</a><span>|</span><a href="#39022966">prev</a><span>|</span><a href="#39023491">next</a><span>|</span><label class="collapse" for="c-39022781">[-]</label><label class="expand" for="c-39022781">[1 more]</label></div><br/><div class="children"><div class="content">YMMV I guess :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>