<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687597258424" as="style"/><link rel="stylesheet" href="styles.css?v=1687597258424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.bleepingcomputer.com/news/security/millions-of-github-repos-likely-vulnerable-to-repojacking-researchers-say/">Millions of GitHub repos likely vulnerable to RepoJacking, researchers say</a>Â <span class="domain">(<a href="https://www.bleepingcomputer.com">www.bleepingcomputer.com</a>)</span></div><div class="subtext"><span>pyeri</span> | <span>41 comments</span></div><br/><div><div id="36453988" class="c"><input type="checkbox" id="c-36453988" checked=""/><div class="controls bullet"><span class="by">lol768</span><span>|</span><a href="#36453896">next</a><span>|</span><label class="collapse" for="c-36453988">[-]</label><label class="expand" for="c-36453988">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure GitHub warns you every single time you pull from or push to a repository where the organisation or repository has been renamed and you&#x27;re relying on an alias that is not permanent.<p>Why is this news, and why does it need a name of &quot;RepoJacking&quot; assigned to it when the behaviour is working exactly as designed?<p>This isn&#x27;t a novel vulnerability, and I wouldn&#x27;t say any novel vulnerability research has been conducted here. Sure, there&#x27;s some value in doing a code search and finding instances where people have automated scripts etc relying on aliases, but the vulnerability lies within these scripts.</div><br/><div id="36454219" class="c"><input type="checkbox" id="c-36454219" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#36453988">parent</a><span>|</span><a href="#36456615">next</a><span>|</span><label class="collapse" for="c-36454219">[-]</label><label class="expand" for="c-36454219">[5 more]</label></div><br/><div class="children"><div class="content">All mutable global namespaces have the same problems.<p>I didn&#x27;t know you could get street cred pointing this out one by one.<p>Let&#x27;s try! If someone buys an expired domain and installs an SSL cert on it then old scripts will think it&#x27;s legit. Let&#x27;s call it phantomain, a combination of phantom and domain.</div><br/><div id="36455002" class="c"><input type="checkbox" id="c-36455002" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#36453988">root</a><span>|</span><a href="#36454219">parent</a><span>|</span><a href="#36454616">next</a><span>|</span><label class="collapse" for="c-36455002">[-]</label><label class="expand" for="c-36455002">[2 more]</label></div><br/><div class="children"><div class="content">First thing I thought of too. If you&#x27;ve acquired a company, you&#x27;ll need to plan on keeping the old domain names for a long time, if not indefinitely. Anyone who can later re-register that domain will now own any email sent there and any other network traffic as well.</div><br/><div id="36456787" class="c"><input type="checkbox" id="c-36456787" checked=""/><div class="controls bullet"><span class="by">adrianmsmith</span><span>|</span><a href="#36453988">root</a><span>|</span><a href="#36455002">parent</a><span>|</span><a href="#36454616">next</a><span>|</span><label class="collapse" for="c-36456787">[-]</label><label class="expand" for="c-36456787">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. For example NeXT was bought by Apple in 1997 yet next.com is still owned by Apple all this time later.</div><br/></div></div></div></div><div id="36454616" class="c"><input type="checkbox" id="c-36454616" checked=""/><div class="controls bullet"><span class="by">topato</span><span>|</span><a href="#36453988">root</a><span>|</span><a href="#36454219">parent</a><span>|</span><a href="#36455002">prev</a><span>|</span><a href="#36456615">next</a><span>|</span><label class="collapse" for="c-36454616">[-]</label><label class="expand" for="c-36454616">[2 more]</label></div><br/><div class="children"><div class="content">No no! That&#x27;s gotta be  Ghomainjacking, two buzzwords in one AND ghosts are waaay spookier! Phantoms evoke too much imagery of incels in masks, singing on boats.</div><br/><div id="36454834" class="c"><input type="checkbox" id="c-36454834" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#36453988">root</a><span>|</span><a href="#36454616">parent</a><span>|</span><a href="#36456615">next</a><span>|</span><label class="collapse" for="c-36454834">[-]</label><label class="expand" for="c-36454834">[1 more]</label></div><br/><div class="children"><div class="content">I was also trying to allude to Saint-Domingue, the French colony which France woke up one day to realize it no longer had and &quot;sans domain&quot;, which are way too nerdy. Let&#x27;s go with yours<p>Ghomainjacking but it&#x27;s pronounced fimainjacking using the gho from ghoti because it&#x27;s in the class of phishing attacks using a collision you didn&#x27;t realize was possible</div><br/></div></div></div></div></div></div><div id="36456615" class="c"><input type="checkbox" id="c-36456615" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36453988">parent</a><span>|</span><a href="#36454219">prev</a><span>|</span><a href="#36456602">next</a><span>|</span><label class="collapse" for="c-36456615">[-]</label><label class="expand" for="c-36456615">[1 more]</label></div><br/><div class="children"><div class="content">So would I see this message if it was pulled in a script, by npm, go install, cargo or another such tool?<p>But this article describes RepoJacking as reclaiming the original repo. The alias is removed, and the warning you mention too.</div><br/></div></div><div id="36456602" class="c"><input type="checkbox" id="c-36456602" checked=""/><div class="controls bullet"><span class="by">kdmccormick</span><span>|</span><a href="#36453988">parent</a><span>|</span><a href="#36456615">prev</a><span>|</span><a href="#36454700">next</a><span>|</span><label class="collapse" for="c-36456602">[-]</label><label class="expand" for="c-36456602">[1 more]</label></div><br/><div class="children"><div class="content">Nope. The project I work on went through a governance restructuring and we moved half the repos to a new org. I haven&#x27;t updated most of my remotes, but they redirect seamlessly, no CLI warnings whatsoever.</div><br/></div></div><div id="36454700" class="c"><input type="checkbox" id="c-36454700" checked=""/><div class="controls bullet"><span class="by">warent</span><span>|</span><a href="#36453988">parent</a><span>|</span><a href="#36456602">prev</a><span>|</span><a href="#36454056">next</a><span>|</span><label class="collapse" for="c-36454700">[-]</label><label class="expand" for="c-36454700">[2 more]</label></div><br/><div class="children"><div class="content">Hmm did you read the article? One specific attack vector they show has nothing to with Git or pushing&#x2F;pulling to repositories. It shows an install.sh which curl downloads a master.zip from a public github repo and executes files within it.</div><br/><div id="36456060" class="c"><input type="checkbox" id="c-36456060" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#36453988">root</a><span>|</span><a href="#36454700">parent</a><span>|</span><a href="#36454056">next</a><span>|</span><label class="collapse" for="c-36456060">[-]</label><label class="expand" for="c-36456060">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It shows an install.sh which curl downloads a master.zip from a public github repo<p>A repo that is an alias to another one. Someone can create this repo breaking the alias and thus being able to serve whatever they want. This is the so-called &quot;repojacking&quot; and what GP is also talking about.</div><br/></div></div></div></div></div></div><div id="36453896" class="c"><input type="checkbox" id="c-36453896" checked=""/><div class="controls bullet"><span class="by">runlevel1</span><span>|</span><a href="#36453988">prev</a><span>|</span><a href="#36454533">next</a><span>|</span><label class="collapse" for="c-36453896">[-]</label><label class="expand" for="c-36453896">[2 more]</label></div><br/><div class="children"><div class="content">The redirect behavior gives users the false impression that the old organization name is still permanently associated with them. Making that the actual behavior seems like the easy solution here.<p>If GitHub is concerned with people burning through names, they could either limit the number of changes before you have to reach out to support or limit the redirect behavior to just the last two org names.</div><br/><div id="36454170" class="c"><input type="checkbox" id="c-36454170" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#36453896">parent</a><span>|</span><a href="#36454533">next</a><span>|</span><label class="collapse" for="c-36454170">[-]</label><label class="expand" for="c-36454170">[1 more]</label></div><br/><div class="children"><div class="content">Or just return a 410 and force folk to deal with the situation when their dependency breaks. I&#x27;m not convinced the convenience outweighs the risk.  Especially given how many folk are just out here git-cloning random stuff from unvetted &quot;vendors&quot;.</div><br/></div></div></div></div><div id="36454533" class="c"><input type="checkbox" id="c-36454533" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#36453896">prev</a><span>|</span><a href="#36454612">next</a><span>|</span><label class="collapse" for="c-36454533">[-]</label><label class="expand" for="c-36454533">[2 more]</label></div><br/><div class="children"><div class="content">There are, currently, millions of exploits that are just ready to be taken advantage of, and we have no idea where they are, no way to detect them (because they could all be way upstream), and no way to stop them. That&#x27;s kind of a big deal. Like an existential, massive, unsolvable, imminent disaster kind of deal.<p>It&#x27;s such a big deal that I don&#x27;t think anyone&#x27;s going to take it seriously until the compromises start coming in waves. Just <i>one</i> of these compromises could affect thousands of projects. If there are millions of potential exploits? We&#x27;re talking, like, the majority of the modern software landscape now has a giant hole in it. Not a <i>potential</i> hole, but, actively, right now, is exploitable.</div><br/><div id="36455953" class="c"><input type="checkbox" id="c-36455953" checked=""/><div class="controls bullet"><span class="by">flangola7</span><span>|</span><a href="#36454533">parent</a><span>|</span><a href="#36454612">next</a><span>|</span><label class="collapse" for="c-36455953">[-]</label><label class="expand" for="c-36455953">[1 more]</label></div><br/><div class="children"><div class="content">Fine-tuned LLMs will make this nice and scalable. I look forward to the coming hacknado.</div><br/></div></div></div></div><div id="36454612" class="c"><input type="checkbox" id="c-36454612" checked=""/><div class="controls bullet"><span class="by">1lint</span><span>|</span><a href="#36454533">prev</a><span>|</span><a href="#36454590">next</a><span>|</span><label class="collapse" for="c-36454612">[-]</label><label class="expand" for="c-36454612">[7 more]</label></div><br/><div class="children"><div class="content">Another reason to include commit ids in the url when fetching files from external repos. I think you should do this anyways in case the external repo maintainer makes a change that silently breaks your build script</div><br/><div id="36455410" class="c"><input type="checkbox" id="c-36455410" checked=""/><div class="controls bullet"><span class="by">ewhauser421</span><span>|</span><a href="#36454612">parent</a><span>|</span><a href="#36454643">next</a><span>|</span><label class="collapse" for="c-36455410">[-]</label><label class="expand" for="c-36455410">[1 more]</label></div><br/><div class="children"><div class="content">Just verify the SHA of the tarball a la Bazel?</div><br/></div></div><div id="36454643" class="c"><input type="checkbox" id="c-36454643" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#36454612">parent</a><span>|</span><a href="#36455410">prev</a><span>|</span><a href="#36454590">next</a><span>|</span><label class="collapse" for="c-36454643">[-]</label><label class="expand" for="c-36454643">[5 more]</label></div><br/><div class="children"><div class="content">That won&#x27;t help you very much. There&#x27;s no guarantee the commit belongs to the named repository with e.g. raw links[0].<p>[0] <a href="https:&#x2F;&#x2F;twitter.com&#x2F;slimsag&#x2F;status&#x2F;1672421999698903043" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;slimsag&#x2F;status&#x2F;1672421999698903043</a></div><br/><div id="36454948" class="c"><input type="checkbox" id="c-36454948" checked=""/><div class="controls bullet"><span class="by">faangsticle</span><span>|</span><a href="#36454612">root</a><span>|</span><a href="#36454643">parent</a><span>|</span><a href="#36454590">next</a><span>|</span><label class="collapse" for="c-36454948">[-]</label><label class="expand" for="c-36454948">[4 more]</label></div><br/><div class="children"><div class="content">Of course it will, since you&#x27;ll either get the commit you wanted at the time you wrote the script, or an error.</div><br/><div id="36455232" class="c"><input type="checkbox" id="c-36455232" checked=""/><div class="controls bullet"><span class="by">bqmjjx0kac</span><span>|</span><a href="#36454612">root</a><span>|</span><a href="#36454948">parent</a><span>|</span><a href="#36454590">next</a><span>|</span><label class="collapse" for="c-36455232">[-]</label><label class="expand" for="c-36455232">[3 more]</label></div><br/><div class="children"><div class="content">Unless someone is very good at finding SHA1 collisions.</div><br/><div id="36455304" class="c"><input type="checkbox" id="c-36455304" checked=""/><div class="controls bullet"><span class="by">NhanH</span><span>|</span><a href="#36454612">root</a><span>|</span><a href="#36455232">parent</a><span>|</span><a href="#36455309">next</a><span>|</span><label class="collapse" for="c-36455304">[-]</label><label class="expand" for="c-36455304">[1 more]</label></div><br/><div class="children"><div class="content">The collisions need to deliver malicious payload as well, making it extra hard</div><br/></div></div><div id="36455309" class="c"><input type="checkbox" id="c-36455309" checked=""/><div class="controls bullet"><span class="by">manwe150</span><span>|</span><a href="#36454612">root</a><span>|</span><a href="#36455232">parent</a><span>|</span><a href="#36455304">prev</a><span>|</span><a href="#36454590">next</a><span>|</span><label class="collapse" for="c-36455309">[-]</label><label class="expand" for="c-36455309">[1 more]</label></div><br/><div class="children"><div class="content">Those are still very hard to get for a random hash, and GitHub I think warns (or blocks?) you if you try to push a hash with a known vulnerability.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36454590" class="c"><input type="checkbox" id="c-36454590" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#36454612">prev</a><span>|</span><a href="#36453951">next</a><span>|</span><label class="collapse" for="c-36454590">[-]</label><label class="expand" for="c-36454590">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve thought about this a lot when building GitHub integrations. It&#x27;s so so so easy to use a GitHub username or an email as the link to the GitHub account. In fact, I don&#x27;t even know how you connect an account to GitHub in a persistent manner. Email is slightly better because the odds that someone takes a specific email is pretty unlikely, but hey, domains expire too. Does GitHub give you a unique, guaranteed to never change id that corresponds to an account? They should.</div><br/><div id="36454899" class="c"><input type="checkbox" id="c-36454899" checked=""/><div class="controls bullet"><span class="by">eslaught</span><span>|</span><a href="#36454590">parent</a><span>|</span><a href="#36453951">next</a><span>|</span><label class="collapse" for="c-36454899">[-]</label><label class="expand" for="c-36454899">[3 more]</label></div><br/><div class="children"><div class="content">Yes:<p><a href="https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;&lt;userhandle&gt;" rel="nofollow noreferrer">https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;&lt;userhandle&gt;</a><p>From:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;maintainers&#x2F;maintainer-list.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;maintainers&#x2F;mai...</a></div><br/><div id="36455167" class="c"><input type="checkbox" id="c-36455167" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#36454590">root</a><span>|</span><a href="#36454899">parent</a><span>|</span><a href="#36453951">next</a><span>|</span><label class="collapse" for="c-36455167">[-]</label><label class="expand" for="c-36455167">[2 more]</label></div><br/><div class="children"><div class="content">Is it guaranteed to not change?</div><br/><div id="36455886" class="c"><input type="checkbox" id="c-36455886" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#36454590">root</a><span>|</span><a href="#36455167">parent</a><span>|</span><a href="#36453951">next</a><span>|</span><label class="collapse" for="c-36455886">[-]</label><label class="expand" for="c-36455886">[1 more]</label></div><br/><div class="children"><div class="content">GitHub user IDs look like &quot;4723091&quot; (there&#x27;s mine).<p>If you look at the IDs for multiple accounts, you&#x27;ll very quickly notice that they seem to have been assigned sequentially at registration time.<p>Fairly sure this is a permanent deal.</div><br/></div></div></div></div></div></div></div></div><div id="36453951" class="c"><input type="checkbox" id="c-36453951" checked=""/><div class="controls bullet"><span class="by">ashishbijlani</span><span>|</span><a href="#36454590">prev</a><span>|</span><a href="#36453904">next</a><span>|</span><label class="collapse" for="c-36453951">[-]</label><label class="expand" for="c-36453951">[1 more]</label></div><br/><div class="children"><div class="content">We carried out a similar analysis using Packj tool [1] and found that a large number of repos are vulnerable to supply-chain attacks. We received a bunch of bounties for reporting vulnerabilities. Hopefully, these findings will bolster open-source security.<p>1. <a href="http:&#x2F;&#x2F;github.com&#x2F;ossillate-inc&#x2F;packj">http:&#x2F;&#x2F;github.com&#x2F;ossillate-inc&#x2F;packj</a> flags vulnerable&#x2F;malicious NPM&#x2F;PyPI&#x2F;Rubygems&#x2F;Cargo&#x2F;Packagist packages. I&#x27;m the lead dev.</div><br/></div></div><div id="36453904" class="c"><input type="checkbox" id="c-36453904" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#36453951">prev</a><span>|</span><a href="#36456000">next</a><span>|</span><label class="collapse" for="c-36453904">[-]</label><label class="expand" for="c-36453904">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Also, because the instructions included an &quot;npm install&quot; command for the dependency, the attacker&#x27;s code would achieve arbitrary code execution on the devices of unsuspecting users.<p>This is debatable. If the owner unpublishes their old releases, then the npm install would simply fail and the package reference string is burned forever. I don&#x27;t like the implication this post makes that other package managers don&#x27;t require code execution to install, or that npm is somehow more vulnerable.<p>&gt; Registry data is immutable, meaning once published, a package cannot change. We do this for reasons of security and stability of the users who depend on those packages. So if you&#x27;ve ever published a package called &quot;bob&quot; at version 1.1.0, no other package can ever be published with that name at that version. This is true even if that package is unpublished.<p><a href="https:&#x2F;&#x2F;docs.npmjs.com&#x2F;policies&#x2F;unpublish" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.npmjs.com&#x2F;policies&#x2F;unpublish</a><p><a href="https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v9&#x2F;commands&#x2F;npm-unpublish" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v9&#x2F;commands&#x2F;npm-unpublish</a><p>To hijack an npm package is to exploit sloppy code review somewhere in the dependency tree. The registry has nothing to do with this.<p>Being aware of this policy, requiring maintainers to review all changes to &quot;package-lock.json&quot;, and keeping this lock file in your repo (&quot;npm-shrinkwrap.json&quot; for releases) entirely mitigates this.<p><a href="https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v9&#x2F;configuring-npm&#x2F;package-lock-json" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v9&#x2F;configuring-npm&#x2F;package-lock-j...</a><p>It&#x27;s also important to regularly run npm audit on all releases and unpublish if vulnerabilities are found in the dependency tree of that lock file. It&#x27;s better to break someone&#x27;s build and leave a note that they need to upgrade than be part of the problem. Even further, npm audit reports are shown to the end user after an npm install so they can decide for themselves in the event the maintainers haven&#x27;t unpublished yet (or ever).<p><a href="https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v9&#x2F;commands&#x2F;npm-audit" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v9&#x2F;commands&#x2F;npm-audit</a></div><br/><div id="36455802" class="c"><input type="checkbox" id="c-36455802" checked=""/><div class="controls bullet"><span class="by">EdwardDiego</span><span>|</span><a href="#36453904">parent</a><span>|</span><a href="#36456000">next</a><span>|</span><label class="collapse" for="c-36455802">[-]</label><label class="expand" for="c-36455802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that other package managers don&#x27;t require code execution to install<p>But that&#x27;s more or less true. Arbitrary code execution isn&#x27;t a feature needed when installing packages for other languages that don&#x27;t use C bindings so heavily.<p>You&#x27;re spot on that Node.js isn&#x27;t alone, Python packages are very much the same in that packages can require code execution to install.<p>But not all packaging systems require the ability to execute package provided code in order to install some packages.<p>But then, in those languages, binding to C libs is far far less common.</div><br/></div></div></div></div><div id="36456000" class="c"><input type="checkbox" id="c-36456000" checked=""/><div class="controls bullet"><span class="by">jeffkeen</span><span>|</span><a href="#36453904">prev</a><span>|</span><a href="#36453813">next</a><span>|</span><label class="collapse" for="c-36456000">[-]</label><label class="expand" for="c-36456000">[1 more]</label></div><br/><div class="children"><div class="content">Iâd love to clickjack some repos to merge some PRs.</div><br/></div></div><div id="36453813" class="c"><input type="checkbox" id="c-36453813" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36456000">prev</a><span>|</span><a href="#36454713">next</a><span>|</span><label class="collapse" for="c-36453813">[-]</label><label class="expand" for="c-36453813">[6 more]</label></div><br/><div class="children"><div class="content">What if there were some way to specify a difficult to forge checksum for your dependencies?</div><br/><div id="36455356" class="c"><input type="checkbox" id="c-36455356" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#36453813">parent</a><span>|</span><a href="#36453917">next</a><span>|</span><label class="collapse" for="c-36455356">[-]</label><label class="expand" for="c-36455356">[1 more]</label></div><br/><div class="children"><div class="content">Like a commit hash?</div><br/></div></div><div id="36453917" class="c"><input type="checkbox" id="c-36453917" checked=""/><div class="controls bullet"><span class="by">rrdharan</span><span>|</span><a href="#36453813">parent</a><span>|</span><a href="#36455356">prev</a><span>|</span><a href="#36454713">next</a><span>|</span><label class="collapse" for="c-36453917">[-]</label><label class="expand" for="c-36453917">[4 more]</label></div><br/><div class="children"><div class="content">They could call it an SBOM...</div><br/><div id="36453939" class="c"><input type="checkbox" id="c-36453939" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#36453813">root</a><span>|</span><a href="#36453917">parent</a><span>|</span><a href="#36454713">next</a><span>|</span><label class="collapse" for="c-36453939">[-]</label><label class="expand" for="c-36453939">[3 more]</label></div><br/><div class="children"><div class="content">I think tedunangst is referring to <a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;signify.1" rel="nofollow noreferrer">https:&#x2F;&#x2F;man.openbsd.org&#x2F;signify.1</a></div><br/><div id="36454461" class="c"><input type="checkbox" id="c-36454461" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#36453813">root</a><span>|</span><a href="#36453939">parent</a><span>|</span><a href="#36454713">next</a><span>|</span><label class="collapse" for="c-36454461">[-]</label><label class="expand" for="c-36454461">[2 more]</label></div><br/><div class="children"><div class="content">Even simpler than that, something like bsd ports distfiles checksums, or go.sum, or whatever. If you depend on something, you should know what that something is, and you should have some measure of it in your code&#x2F;project.</div><br/><div id="36454591" class="c"><input type="checkbox" id="c-36454591" checked=""/><div class="controls bullet"><span class="by">throwaway892238</span><span>|</span><a href="#36453813">root</a><span>|</span><a href="#36454461">parent</a><span>|</span><a href="#36454713">next</a><span>|</span><label class="collapse" for="c-36454591">[-]</label><label class="expand" for="c-36454591">[1 more]</label></div><br/><div class="children"><div class="content">Like a SBOM</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36454713" class="c"><input type="checkbox" id="c-36454713" checked=""/><div class="controls bullet"><span class="by">AHOHA</span><span>|</span><a href="#36453813">prev</a><span>|</span><a href="#36453796">next</a><span>|</span><label class="collapse" for="c-36454713">[-]</label><label class="expand" for="c-36454713">[2 more]</label></div><br/><div class="children"><div class="content">Another reason not use github.</div><br/><div id="36454842" class="c"><input type="checkbox" id="c-36454842" checked=""/><div class="controls bullet"><span class="by">taftster</span><span>|</span><a href="#36454713">parent</a><span>|</span><a href="#36453796">next</a><span>|</span><label class="collapse" for="c-36454842">[-]</label><label class="expand" for="c-36454842">[1 more]</label></div><br/><div class="children"><div class="content">What would you suggest as an alternative? Do you have a list of github problems that tips you over to said alternative(s)?</div><br/></div></div></div></div></div></div></div></div></div></body></html>