<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716109254797" as="style"/><link rel="stylesheet" href="styles.css?v=1716109254797"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lupyuen.codeberg.page/articles/sg2000.html">Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S SBC)</a> <span class="domain">(<a href="https://lupyuen.codeberg.page">lupyuen.codeberg.page</a>)</span></div><div class="subtext"><span>lupyuen</span> | <span>8 comments</span></div><br/><div><div id="40403538" class="c"><input type="checkbox" id="c-40403538" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><label class="collapse" for="c-40403538">[-]</label><label class="expand" for="c-40403538">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Soon we’ll see many new 64-bit RISC-V SBCs based on the Sophgo SG2000 RISC-V SoC.<p>This is an extremely unusual SoC with three main CPU cores with heterogenous ISA; 1 GHz C906 RISC-V, 1 GHz ARM Cortex-A53, and an extra 700 MHz C906 RISC-V core. You can choose only one of the 1GHz C906 or A53 cores to be active, and the 700 MHz core is additionally active. It also has an MCU, an NPU, and boards are $8.<p>The Xuantie C906 has been incredibly popular core for years now, it&#x27;s not clear when a successor will appear and the RVV 0.7 debacle still has no end in sight.<p>The A53 has also been surprisingly longevious despite having official successors - either the A55&#x2F;A510&#x2F;etc license for a lot more, or the A53 RTL is just floating on GitHub somewhere.</div><br/><div id="40404057" class="c"><input type="checkbox" id="c-40404057" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#40403538">parent</a><span>|</span><label class="collapse" for="c-40404057">[-]</label><label class="expand" for="c-40404057">[6 more]</label></div><br/><div class="children"><div class="content">&gt; You can choose only one of the 1GHz C906 or A53 cores to be active<p>I know a guy who is reverse-engineering the boot ROM and is writing replacement code in Rust (blergh) that already enables either C906 or A53 to be booted (the A53 was only a theoretical possibility with official software released so far). He says it&#x27;s not obvious that both can&#x27;t run at the same time. I expect we&#x27;ll know in a week or two if he is successful.<p>&gt; the RVV 0.7 debacle still has no end in sight.<p>What debacle?<p>The C906 and C910 vector units implement what was the official draft RVV at the time they were designed. Krste wrote at the time &quot;We think we&#x27;re very near to the final spec&quot;. That turned out to be 2.5 years premature, but all the same 0.7.1 and 1.0 are very very similar (much more so than they are to 0.6 or 0.5 or other SIMD&#x2F;Vector ISAs such as AVX or SVE), much useful code is binary compatible between them (e.g. all the C library string functions, memcpy etc), and anything at all you write for 0.7.1 can be trivially updated to 1.0 compatibility.<p>Even better, the recently released GCC 14 supports both (0.7.1 under the name &quot;XTHeadVector&quot;) and if you write code using the C vector intrinsic functions then GCC can generate code for either version from the exact same source code with only makefile &#x2F; compiler flag changes.<p>We have two different RVV 1.0 implementations in the market now (I mean boards &#x2F; chips you can buy and regular customers already have), with more coming this year.<p>BUT, there will continue to be new C906 and maybe C910 boards for probably the next five years.<p>And that is really not the problem some people seem to think it is. They are far more compatible than say, AVX and AVX-512, or AVX and SSE.</div><br/><div id="40404216" class="c"><input type="checkbox" id="c-40404216" checked=""/><div class="controls bullet"><span class="by">mappu</span><span>|</span><a href="#40403538">root</a><span>|</span><a href="#40404057">parent</a><span>|</span><a href="#40404269">next</a><span>|</span><label class="collapse" for="c-40404216">[-]</label><label class="expand" for="c-40404216">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the update -<p>IMO the debacle ranges over the last 4 years or so, where GCC refused to upstream support for RVV 0.7 until now (14.1) and that only living in out-of-tree vendor toolchains, and so all the most popular boards (all with C906&#x2F;C910) were unable to run RVV binaries compiled with standard distro-packaged GCC. Thus making the vector unit largely useless without a custom toolchain or (more likely) whole BSP&#x2F;rootfs.<p>My ideal would be if the ordinary Debian binary port could make something useful out of either RVV version if present, without needing a special board rootfs or custom glibc build.<p>&gt; much useful code is binary compatible between them (e.g. all the C library string functions, memcpy etc)<p>I didn&#x27;t realize common libc functions could be made binary compatible between RVV 0.7 and 1.0, that sounds extremely promising for glibc.<p>I had a quick glance at the glibc source code and didn&#x27;t find anything other than a C implementation - do you know if that&#x27;s a recent innovation or what version of glibc supports that? Or is any V implementation in glibc&#x27;s string functions just relying on the compiler autovectorization (does that exist for RVV)? Or is this not upstream yet?<p>The x86_64 version of this logic is in sysdeps&#x2F;x86_64&#x2F;stpcpy.S , it automatically switches to a sse2&#x2F;avx2&#x2F;evex implementation if those ISA extensions are present.<p>It looks like the Linux kernel&#x27;s memcpy does not attempt to use V at all neither (as of 6.9 arch&#x2F;riscv&#x2F;lib&#x2F;memcpy.S),</div><br/><div id="40404890" class="c"><input type="checkbox" id="c-40404890" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40403538">root</a><span>|</span><a href="#40404216">parent</a><span>|</span><a href="#40405147">next</a><span>|</span><label class="collapse" for="c-40404890">[-]</label><label class="expand" for="c-40404890">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I had a quick glance at the glibc source code and didn&#x27;t find anything other than a C implementation - do you know if that&#x27;s a recent innovation or what version of glibc supports that? Or is any V implementation in glibc&#x27;s string functions just relying on the compiler autovectorization (does that exist for RVV)? Or is this not upstream yet?</i><p>Last I heard the glibc developers are waiting for a decent hardware platform to target.  You need something that supports V1.0, is widely available, and performs something like we expect future hardware to perform so you don&#x27;t end up optimizing for the wrong things.  (Qemu is no use because the performance of emulated V is very different from the real thing since every V instruction goes through a TCG helper function.)</div><br/></div></div><div id="40405147" class="c"><input type="checkbox" id="c-40405147" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#40403538">root</a><span>|</span><a href="#40404216">parent</a><span>|</span><a href="#40404890">prev</a><span>|</span><a href="#40404269">next</a><span>|</span><label class="collapse" for="c-40405147">[-]</label><label class="expand" for="c-40405147">[1 more]</label></div><br/><div class="children"><div class="content">&gt; GCC refused to upstream support for RVV 0.7 until now<p>IMHO the GCC people were being dumb. They don&#x27;t want to upstream support for &quot;draft&quot; specs. That&#x27;s fundamentally because it will be obsolete as soon as there&#x27;s a new draft. But that should go out the window as soon as someone makes commercial hardware using that spec -- at that point it&#x27;s frozen and those real-world users have a right to expect hardware they paid for to be supported.<p>There was also the qustion of who will do the work, and THead and Allwinner and other interested parties in China were not quick to step up to do it.<p>&gt; I didn&#x27;t realize common libc functions could be made binary compatible between RVV 0.7 and 1.0<p>Sure. For example here is something I posted in April 2021, tested on a prototype AWOL Nezha D1 board I got ssh access to in China a few months before customers started to receive them in late June &#x2F; early July.<p><a href="https:&#x2F;&#x2F;hoult.org&#x2F;d1_memcpy.txt" rel="nofollow">https:&#x2F;&#x2F;hoult.org&#x2F;d1_memcpy.txt</a><p>Of course RVV 1.0 was not final then. But it turns out that if you change the `vlb.v` instruction to `vlbu.v` (which doesn&#x27;t change the functionality as it&#x27;s loading bytes in RAM to bytes in a vector register) then that maps to `vle8.v` in RVV 1.0. All the other instructions used are binary compatible with the equivalent RVV 1.0 instruction.</div><br/></div></div></div></div><div id="40404269" class="c"><input type="checkbox" id="c-40404269" checked=""/><div class="controls bullet"><span class="by">timschmidt</span><span>|</span><a href="#40403538">root</a><span>|</span><a href="#40404057">parent</a><span>|</span><a href="#40404216">prev</a><span>|</span><label class="collapse" for="c-40404269">[-]</label><label class="expand" for="c-40404269">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I know a guy who is reverse-engineering the boot ROM and is writing replacement code in Rust<p>Have a link to the work?</div><br/><div id="40405179" class="c"><input type="checkbox" id="c-40405179" checked=""/><div class="controls bullet"><span class="by">brucehoult</span><span>|</span><a href="#40403538">root</a><span>|</span><a href="#40404269">parent</a><span>|</span><label class="collapse" for="c-40405179">[-]</label><label class="expand" for="c-40405179">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the WIP is published. There&#x27;s an occasional update on X e.g. ...<p><a href="https:&#x2F;&#x2F;twitter.com&#x2F;OrangeCMS&#x2F;status&#x2F;1784872873951125770" rel="nofollow">https:&#x2F;&#x2F;twitter.com&#x2F;OrangeCMS&#x2F;status&#x2F;1784872873951125770</a><p>... but day to day updates are more on the RISC-V Telegram  &#x2F; Matrix channels.<p>There is also stuff here, but nothing on SG2000 there yet:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;@CyReVolt&#x2F;playlists" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;@CyReVolt&#x2F;playlists</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>