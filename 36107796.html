<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1685350863662" as="style"/><link rel="stylesheet" href="styles.css?v=1685350863662"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://leanprover.github.io/functional_programming_in_lean/">Functional Programming in Lean</a>Â <span class="domain">(<a href="https://leanprover.github.io">leanprover.github.io</a>)</span></div><div class="subtext"><span>d_christiansen</span> | <span>18 comments</span></div><br/><div><div id="36107798" class="c"><input type="checkbox" id="c-36107798" checked=""/><div class="controls bullet"><span class="by">d_christiansen</span><span>|</span><a href="#36111470">next</a><span>|</span><label class="collapse" for="c-36107798">[-]</label><label class="expand" for="c-36107798">[7 more]</label></div><br/><div class="children"><div class="content">Lean 4 is an interactive theorem prover. It&#x27;s also a programming language with a self-hosting compiler. This is a free book on using Lean 4 as a programming language, written without assuming any background in functional programming. It&#x27;s intended to be accessible to Python, C#, Rust, Kotlin, Java, TypeScript, and Scala developers. Today marks the final release, after more than a year of writing.</div><br/><div id="36109309" class="c"><input type="checkbox" id="c-36109309" checked=""/><div class="controls bullet"><span class="by">mdm12</span><span>|</span><a href="#36107798">parent</a><span>|</span><a href="#36109318">next</a><span>|</span><label class="collapse" for="c-36109309">[-]</label><label class="expand" for="c-36109309">[2 more]</label></div><br/><div class="children"><div class="content">Congratulations on the publication! As a dabbler in strictly typed functional programming languages like Scala and F#, I have always been curious about proof-oriented languages such as Coq or Agda, but found it difficult to justify the time investment. Lean seems to position itself as a theorem proving language that also supports general-purpose programs. Looking forward to digging into your book!</div><br/><div id="36110182" class="c"><input type="checkbox" id="c-36110182" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#36107798">root</a><span>|</span><a href="#36109309">parent</a><span>|</span><a href="#36109318">next</a><span>|</span><label class="collapse" for="c-36110182">[-]</label><label class="expand" for="c-36110182">[1 more]</label></div><br/><div class="children"><div class="content">Agda and Idris both also position themselves similarly.</div><br/></div></div></div></div><div id="36109318" class="c"><input type="checkbox" id="c-36109318" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#36107798">parent</a><span>|</span><a href="#36109309">prev</a><span>|</span><a href="#36110543">next</a><span>|</span><label class="collapse" for="c-36109318">[-]</label><label class="expand" for="c-36109318">[1 more]</label></div><br/><div class="children"><div class="content">Thank you very much for this book.  It has been invaluable for my introduction to Lean and a joy to study from.  I still have not read the last chapter, looking forward to it!  Kudos for your effort, and I hope you will write some more stuff about Lean in the future.</div><br/></div></div><div id="36111204" class="c"><input type="checkbox" id="c-36111204" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36107798">parent</a><span>|</span><a href="#36110543">prev</a><span>|</span><a href="#36110741">next</a><span>|</span><label class="collapse" for="c-36111204">[-]</label><label class="expand" for="c-36111204">[1 more]</label></div><br/><div class="children"><div class="content">Congratulations on releasing it.<p>Looking forward to read it during Summer time.</div><br/></div></div><div id="36110741" class="c"><input type="checkbox" id="c-36110741" checked=""/><div class="controls bullet"><span class="by">Reitet00</span><span>|</span><a href="#36107798">parent</a><span>|</span><a href="#36111204">prev</a><span>|</span><a href="#36111470">next</a><span>|</span><label class="collapse" for="c-36110741">[-]</label><label class="expand" for="c-36110741">[1 more]</label></div><br/><div class="children"><div class="content">This looks very nice! Is epub version planned?</div><br/></div></div></div></div><div id="36111470" class="c"><input type="checkbox" id="c-36111470" checked=""/><div class="controls bullet"><span class="by">theresistor</span><span>|</span><a href="#36107798">prev</a><span>|</span><a href="#36110526">next</a><span>|</span><label class="collapse" for="c-36111470">[-]</label><label class="expand" for="c-36111470">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested to know why I would want to learn Lean if I&#x27;m already familiar with Idris.</div><br/></div></div><div id="36110526" class="c"><input type="checkbox" id="c-36110526" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36111470">prev</a><span>|</span><a href="#36111326">next</a><span>|</span><label class="collapse" for="c-36110526">[-]</label><label class="expand" for="c-36110526">[6 more]</label></div><br/><div class="children"><div class="content">Minor thing. Purely as a side:<p><i>in C and C++, the conditional statement is written using if and else, while the conditional expression is written with a ternary operator ? and :.</i><p>ending a sentence with . is a must. Including a period directly after a syntactic construct about ? and : is .. jarring because it is possible to attempt to read this as :. as an atomic construct in the language. Or even worse, the three-dots pyramid in some mathematical proof notations.</div><br/><div id="36112011" class="c"><input type="checkbox" id="c-36112011" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#36110526">parent</a><span>|</span><a href="#36110601">next</a><span>|</span><label class="collapse" for="c-36112011">[-]</label><label class="expand" for="c-36112011">[1 more]</label></div><br/><div class="children"><div class="content">In the book, the &quot;:&quot; is typeset in monospace and the &quot;.&quot; in proportional font, making their meaning clear.</div><br/></div></div><div id="36110601" class="c"><input type="checkbox" id="c-36110601" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#36110526">parent</a><span>|</span><a href="#36112011">prev</a><span>|</span><a href="#36111326">next</a><span>|</span><label class="collapse" for="c-36110601">[-]</label><label class="expand" for="c-36110601">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Also, I always find it interesting the ternary operation is constructed in statements&#x2F;expressions in ? ... : notation but actually has &quot;two&quot; operators there. the ? is the conditional, the : is the binary-choice. It&#x27;s a language syntax choice which &quot;side&quot; is true or false and it is also true that you can&#x27;t construct statements in : without a prior ? but .. its hardly a single operator in syntax terms if it has two disjoint components. := is an unambiguous single operation. condition ? x : y is ... not. It&#x27;s definedly ambiguous!<p>In C++, the lexical construct you describe is an atomic operator[0] and neither an expression nor a statement:<p><pre><code>  The first operand of the conditional operator is
  evaluated and contextually converted to bool.
  After both the value evaluation and all side effects
  of the first operand are completed, if the result
  was true, the second operand is evaluated. If the
  result was false, the third operand is evaluated. 
</code></pre>
0 - <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_other" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_other</a></div><br/><div id="36110767" class="c"><input type="checkbox" id="c-36110767" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36110526">root</a><span>|</span><a href="#36110601">parent</a><span>|</span><a href="#36110687">next</a><span>|</span><label class="collapse" for="c-36110767">[-]</label><label class="expand" for="c-36110767">[2 more]</label></div><br/><div class="children"><div class="content">&gt; its hardly a single operator in syntax terms if it has two disjoint components<p>I don&#x27;t think &quot;operator in syntax terms&quot; is nearly as well-defined as OP thinks. Why couldn&#x27;t `?` be parsed as half an operator and `:` as the other half? There&#x27;s no rule that says a parser has to call each distinct symbol token its own &quot;operator&quot;. In fact, I&#x27;d argue that the only reason this might seem seem like a rule is that almost all of the other operators in common use are either unary or binary, making it easy to use a single token for the operator itself. That&#x27;s why it&#x27;s called the &quot;ternary operator&quot;; it&#x27;s the only one that operates on three things! The only alternative to spreading it out across separate tokens with an operand in between is to put multiple operands in a row on one side of it; as confusing as `foo ? bar : baz` might be, I have strong doubts that `foo ?: bar baz` would be less confusing in most real-world cases.</div><br/><div id="36110794" class="c"><input type="checkbox" id="c-36110794" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36110526">root</a><span>|</span><a href="#36110767">parent</a><span>|</span><a href="#36110687">next</a><span>|</span><label class="collapse" for="c-36110794">[-]</label><label class="expand" for="c-36110794">[1 more]</label></div><br/><div class="children"><div class="content">The other thing I took out is &quot;I get called a fool over beer about this&quot; because nobody seems to find my confusion very compelling. I think my own interpretation of operator in the context of syntax as a single atom is provably false. The problem is, it&#x27;s burnt into my personal mental lexer over textual representation of code.</div><br/></div></div></div></div><div id="36110687" class="c"><input type="checkbox" id="c-36110687" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36110526">root</a><span>|</span><a href="#36110601">parent</a><span>|</span><a href="#36110767">prev</a><span>|</span><a href="#36111326">next</a><span>|</span><label class="collapse" for="c-36110687">[-]</label><label class="expand" for="c-36110687">[1 more]</label></div><br/><div class="children"><div class="content">I took my comments about ?...: notation out. Basically, at a syntactic level its tempting to regard ? as &quot;the operator&quot; and : as some other operator but really the ternary operation only exists as some hypothetical function in 3 arguments:<p><pre><code>  ternary(condition, true-path, false-path)
</code></pre>
which executes either true-path or false-path depending on condition. But in notational terms, how &quot;big&quot; condition and true and false parts are is rather unconstrained, so you wind up with the ? and the : widely separated. They aren&#x27;t operators in the higher sense: they&#x27;re the syntax which forms the ternary operation as a whole over the expression and it&#x27;s condition.<p>Lexing bleeds into syntax and syntax bleeds into semantics.<p>:. is a possible faux-pas in lexing the sentence around the ?...: construct because of :. being unfortunate.</div><br/></div></div></div></div></div></div><div id="36111326" class="c"><input type="checkbox" id="c-36111326" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#36110526">prev</a><span>|</span><a href="#36111306">next</a><span>|</span><label class="collapse" for="c-36111326">[-]</label><label class="expand" for="c-36111326">[1 more]</label></div><br/><div class="children"><div class="content">Is this production ready ? How about performance (comparison with Rust)</div><br/></div></div><div id="36111306" class="c"><input type="checkbox" id="c-36111306" checked=""/><div class="controls bullet"><span class="by">foderking</span><span>|</span><a href="#36111326">prev</a><span>|</span><a href="#36109070">next</a><span>|</span><label class="collapse" for="c-36111306">[-]</label><label class="expand" for="c-36111306">[1 more]</label></div><br/><div class="children"><div class="content">this is actually a good read</div><br/></div></div></div></div></div></div></div></body></html>