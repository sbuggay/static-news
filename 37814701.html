<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1696842083411" as="style"/><link rel="stylesheet" href="styles.css?v=1696842083411"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/">Speeding up the JavaScript ecosystem – The barrel file debacle</a> <span class="domain">(<a href="https://marvinh.dev">marvinh.dev</a>)</span></div><div class="subtext"><span>cdme</span> | <span>23 comments</span></div><br/><div><div id="37818419" class="c"><input type="checkbox" id="c-37818419" checked=""/><div class="controls bullet"><span class="by">silverwind</span><span>|</span><a href="#37816920">next</a><span>|</span><label class="collapse" for="c-37818419">[-]</label><label class="expand" for="c-37818419">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s the next step for package manager to bundle npm dependencies on installation and therefor optimize the import speed. With fast bundlers like esbuild, it&#x27;s feasible.</div><br/></div></div><div id="37816920" class="c"><input type="checkbox" id="c-37816920" checked=""/><div class="controls bullet"><span class="by">Jarred</span><span>|</span><a href="#37818419">prev</a><span>|</span><a href="#37818034">next</a><span>|</span><label class="collapse" for="c-37816920">[-]</label><label class="expand" for="c-37816920">[1 more]</label></div><br/><div class="children"><div class="content">One of the optimizations we do in Bun.build() is to automatically rewrite imports&#x2F;requires of CommonJS modules shaped like this<p><pre><code>    if (process.env.NODE_ENV === &quot;development&quot;) {
      module.exports = require(&quot;.&#x2F;another-file.dev.js&quot;)
    } else {
      module.exports = require(&quot;.&#x2F;another-file.js&quot;)  
    }
</code></pre>
Into the destination path, removing this module entirely<p>I tried to make this work for ESM too, but there were too many edgecases due to module namespace objects being observable (`import * as `)<p>A similar thing could be done for barrel files with `&quot;sideEffects&quot;: false`. We don&#x27;t currently follow nested default exports which makes this harder to do as effectively (we do support &quot;sideEffects&quot;: false)</div><br/></div></div><div id="37818034" class="c"><input type="checkbox" id="c-37818034" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#37816920">prev</a><span>|</span><a href="#37816964">next</a><span>|</span><label class="collapse" for="c-37818034">[-]</label><label class="expand" for="c-37818034">[1 more]</label></div><br/><div class="children"><div class="content">The “cost of loading modules” diagram shows non-linear behaviour (though you should largely ignore the curve visible in the <i>diagram</i> because the x axis is way off linear):<p>• 0.15s ÷ 500 = 0.3ms<p>• 0.31s ÷ 1000 = 0.31ms<p>• 3.12s ÷ 10000 = 0.312ms<p>• 16.81s ÷ 25000 = 0.6724ms<p>• 48.44s ÷ 50000 = 0.9688ms<p>My own observation on a Surface Book six years ago was that in Node.js under Windows, each module had about 1ms of overhead when there was warm file system cache—that is, simply bundling with Rollup saved 1ms per file. If this sort of thing interests you, quite a lot of useful stuff came out of <a href="https:&#x2F;&#x2F;github.com&#x2F;stylelint&#x2F;stylelint&#x2F;issues&#x2F;2454">https:&#x2F;&#x2F;github.com&#x2F;stylelint&#x2F;stylelint&#x2F;issues&#x2F;2454</a> which I filed because I was unhappy with stylelint taking over a second to import. And that must have been only in the order of one or two thousand modules, when the behaviour is still close enough to linear.</div><br/></div></div><div id="37816964" class="c"><input type="checkbox" id="c-37816964" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#37818034">prev</a><span>|</span><a href="#37818266">next</a><span>|</span><label class="collapse" for="c-37816964">[-]</label><label class="expand" for="c-37816964">[3 more]</label></div><br/><div class="children"><div class="content">I really like this article series, but this entry seems quite light on the usual rigorous approach.<p>Instead of detailed analysis of the barrel files in a specific project+dependencies, there are vague exaggerated comparisons like &quot;What&#x27;s quicker? Having to load 30k files or just 10? Probably only loading 10 files is faster.&quot; Of course 10 modules is faster. But are there 29,990 barrel modules in Webpack?<p>Also, why is running esbuild+node faster than just node? Does that suggest the problem is not just lots of dusk reads, but something inefficient in the way node processes the module graph? Could that be improved?<p>Anyway this is an interesting direction of inquiry, and definitely worth considering!</div><br/><div id="37817321" class="c"><input type="checkbox" id="c-37817321" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37816964">parent</a><span>|</span><a href="#37818266">next</a><span>|</span><label class="collapse" for="c-37817321">[-]</label><label class="expand" for="c-37817321">[2 more]</label></div><br/><div class="children"><div class="content">Author here.<p>That&#x27;s fair criticism. Whilst the setup shown in the article is synthetic, the experience is from working on real world projects. I&#x27;ve worked on a bunch of projects which had about 3000-6000 barrel files easily, and these then lead to every file in the project always being included. The total amount of files being loaded was somewhat around 30-60k, depending on the project.<p>I did the exact same thing as described in the article and wrote a custom test runner for jest that bundled the test files with esbuild before executing them. Even though bundling introduces a costly overhead on its own, it was still about 60% faster to bundle + run the bundled code vs not doing it. Bundling can also be amortized because it only needs to be done once per test run vs once per file. That&#x27;s where the real gains came from, because in jest every single test file constructs the whole module graph from scratch.<p>I haven&#x27;t checked myself, but there is likely improvements to be made in node (or other runtimes) to address this. Hopefully, some folks get inspired by this article to look at that.</div><br/><div id="37817685" class="c"><input type="checkbox" id="c-37817685" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#37816964">root</a><span>|</span><a href="#37817321">parent</a><span>|</span><a href="#37818266">next</a><span>|</span><label class="collapse" for="c-37817685">[-]</label><label class="expand" for="c-37817685">[1 more]</label></div><br/><div class="children"><div class="content">Thank you so much for this article series! It&#x27;s much needed and I love reading each installment.</div><br/></div></div></div></div></div></div><div id="37818266" class="c"><input type="checkbox" id="c-37818266" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#37816964">prev</a><span>|</span><a href="#37816376">next</a><span>|</span><label class="collapse" for="c-37818266">[-]</label><label class="expand" for="c-37818266">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the popular jest test runner, each test file is executed in its own child process.<p>Is that confirmed?<p>I&#x27;ve been following this issue:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jestjs&#x2F;jest&#x2F;issues&#x2F;6957">https:&#x2F;&#x2F;github.com&#x2F;jestjs&#x2F;jest&#x2F;issues&#x2F;6957</a><p>And what Jest actually does is still kind of muddy.<p>In contrast to that, other test runners like AVA have a clear description what happens when:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;avajs&#x2F;ava&#x2F;blob&#x2F;main&#x2F;docs&#x2F;01-writing-tests.md#process-isolation">https:&#x2F;&#x2F;github.com&#x2F;avajs&#x2F;ava&#x2F;blob&#x2F;main&#x2F;docs&#x2F;01-writing-tests...</a></div><br/></div></div><div id="37816376" class="c"><input type="checkbox" id="c-37816376" checked=""/><div class="controls bullet"><span class="by">Sophistifunk</span><span>|</span><a href="#37818266">prev</a><span>|</span><a href="#37816382">next</a><span>|</span><label class="collapse" for="c-37816376">[-]</label><label class="expand" for="c-37816376">[1 more]</label></div><br/><div class="children"><div class="content">This is the kind of thing that should be fixed by improving tooling, rather than making your source less clear. Given the opportunity that was mjs, bun, deno, etc it&#x27;s clear that file-based and url-based, and relative imports are things people don&#x27;t want to move away from in the current JS ecosystem, which means &quot;barrel files&quot; (the name makes no sense to me either) are going to remain a useful part of trying to cut down on the noise.</div><br/></div></div><div id="37816382" class="c"><input type="checkbox" id="c-37816382" checked=""/><div class="controls bullet"><span class="by">corbezzoli</span><span>|</span><a href="#37816376">prev</a><span>|</span><a href="#37817819">next</a><span>|</span><label class="collapse" for="c-37816382">[-]</label><label class="expand" for="c-37816382">[2 more]</label></div><br/><div class="children"><div class="content">Locally, never ever use barrel files. If you manage the entire project, just import the specific file you need.<p>However when exporting a public&#x2F;published module it can become onerous to ask the user to import 7 files instead of 7 items from one module.<p>In a perfect world, this would not be much of an issue because tools would cache these resolutions&#x2F;imports and their treeshaken code. In the current world, you could prepackage your project even on Node, so that there’s only one file to load, and no extra unused code.</div><br/><div id="37817230" class="c"><input type="checkbox" id="c-37817230" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#37816382">parent</a><span>|</span><a href="#37817819">next</a><span>|</span><label class="collapse" for="c-37817230">[-]</label><label class="expand" for="c-37817230">[1 more]</label></div><br/><div class="children"><div class="content">&gt; However when exporting a public&#x2F;published module it can become onerous to ask the user to import 7 files instead of 7 items from one module.<p>Plenty of large single units in almost any language are _developed_ this way,  but is there any particular reason they are _deployed_ that way?  It really seems like a distribution packaging issue.</div><br/></div></div></div></div><div id="37817819" class="c"><input type="checkbox" id="c-37817819" checked=""/><div class="controls bullet"><span class="by">can3p</span><span>|</span><a href="#37816382">prev</a><span>|</span><a href="#37818063">next</a><span>|</span><label class="collapse" for="c-37817819">[-]</label><label class="expand" for="c-37817819">[1 more]</label></div><br/><div class="children"><div class="content">I think a fair question to explore is why is it not a problem in other languages (maybe it is)<p>Direct paths also make file structure a part of api and that may not be the desired effect. In addition the bigger problem is not barrel files in your project but rather those in all third-party dependencies</div><br/></div></div><div id="37818063" class="c"><input type="checkbox" id="c-37818063" checked=""/><div class="controls bullet"><span class="by">TheFragenTaken</span><span>|</span><a href="#37817819">prev</a><span>|</span><a href="#37817875">next</a><span>|</span><label class="collapse" for="c-37818063">[-]</label><label class="expand" for="c-37818063">[2 more]</label></div><br/><div class="children"><div class="content">There are typically useful ways (tools) in most bundlers to tree shake barrel files. Libraries also differ in how tree shakable they are.<p>Personally I think the readability of having few import lines from shared barrels, compared to a forest of lines, are very useful.</div><br/><div id="37818179" class="c"><input type="checkbox" id="c-37818179" checked=""/><div class="controls bullet"><span class="by">padjo</span><span>|</span><a href="#37818063">parent</a><span>|</span><a href="#37817875">next</a><span>|</span><label class="collapse" for="c-37818179">[-]</label><label class="expand" for="c-37818179">[1 more]</label></div><br/><div class="children"><div class="content">I find that I essentially never look at the imports anymore, it’s all handled automatically for me. So there could be one line or a hundred lines I don’t care and just scroll past. I’m sure I could get an editor plugin to auto fold imports too</div><br/></div></div></div></div><div id="37817875" class="c"><input type="checkbox" id="c-37817875" checked=""/><div class="controls bullet"><span class="by">Kiro</span><span>|</span><a href="#37818063">prev</a><span>|</span><a href="#37816738">next</a><span>|</span><label class="collapse" for="c-37817875">[-]</label><label class="expand" for="c-37817875">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Excited about finishing your feature, you run the code and realize that it takes an awfully long time to complete.<p>How do you run your project where this happens? I thought everyone complied it separately and then ran it, not both at the same time. Shouldn&#x27;t your tooling tell you immediately that it&#x27;s the compilation being slow and not the code?</div><br/><div id="37818042" class="c"><input type="checkbox" id="c-37818042" checked=""/><div class="controls bullet"><span class="by">mhagemeister</span><span>|</span><a href="#37817875">parent</a><span>|</span><a href="#37816738">next</a><span>|</span><label class="collapse" for="c-37818042">[-]</label><label class="expand" for="c-37818042">[1 more]</label></div><br/><div class="children"><div class="content">Author here.<p>Compilation isn&#x27;t the problem, loading and instantiating the module graph is. The timings for that are currently not exposed in any runtime afaik.</div><br/></div></div></div></div><div id="37816738" class="c"><input type="checkbox" id="c-37816738" checked=""/><div class="controls bullet"><span class="by">TheSisb2</span><span>|</span><a href="#37817875">prev</a><span>|</span><a href="#37816494">next</a><span>|</span><label class="collapse" for="c-37816738">[-]</label><label class="expand" for="c-37816738">[1 more]</label></div><br/><div class="children"><div class="content">In between barrel files and no barrel files, are unbarrelled files. This is where you have one installable package (i.e.: @cool-lib&#x2F;core) and create imports from sub-paths like this:<p>import Button from &quot;@cool-lib&#x2F;core&#x2F;button&quot;;<p>import Link from &quot;@cool-lib&#x2F;core&#x2F;link&quot;;<p>import Widget from &quot;@cool-lib&#x2F;core&#x2F;widget&quot;;<p>This is similar to what lodash does too. Still have more imports, but only one package.json dependency! And the same perf gains.</div><br/></div></div><div id="37816494" class="c"><input type="checkbox" id="c-37816494" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#37816738">prev</a><span>|</span><a href="#37815600">next</a><span>|</span><label class="collapse" for="c-37816494">[-]</label><label class="expand" for="c-37816494">[3 more]</label></div><br/><div class="children"><div class="content">Jesus...50000 modules creates 40 seconds in overhead!!!</div><br/><div id="37816592" class="c"><input type="checkbox" id="c-37816592" checked=""/><div class="controls bullet"><span class="by">daliusd</span><span>|</span><a href="#37816494">parent</a><span>|</span><a href="#37815600">next</a><span>|</span><label class="collapse" for="c-37816592">[-]</label><label class="expand" for="c-37816592">[2 more]</label></div><br/><div class="children"><div class="content">According to article 20 minutes</div><br/><div id="37818040" class="c"><input type="checkbox" id="c-37818040" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#37816494">root</a><span>|</span><a href="#37816592">parent</a><span>|</span><a href="#37815600">next</a><span>|</span><label class="collapse" for="c-37818040">[-]</label><label class="expand" for="c-37818040">[1 more]</label></div><br/><div class="children"><div class="content">That’s for running it 100 times, spread across four cores, i.e. multiplied by 25. About 48 seconds is the actual claimed figure.</div><br/></div></div></div></div></div></div><div id="37815600" class="c"><input type="checkbox" id="c-37815600" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#37816494">prev</a><span>|</span><a href="#37817672">next</a><span>|</span><label class="collapse" for="c-37815600">[-]</label><label class="expand" for="c-37815600">[2 more]</label></div><br/><div class="children"><div class="content">Good write-up. Interesting to me that the author doesn&#x27;t recommend minifying and packing the code as a solution though; even if you get rid of barrel files, not every imported symbol is always used and a pack-and-minify will leave unused code behind.</div><br/><div id="37816355" class="c"><input type="checkbox" id="c-37816355" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#37815600">parent</a><span>|</span><a href="#37817672">next</a><span>|</span><label class="collapse" for="c-37816355">[-]</label><label class="expand" for="c-37816355">[1 more]</label></div><br/><div class="children"><div class="content">Minifying and getting rid of unused code improve runtime performance, but it&#x27;s work at compile time &#x2F; during development. IIUC the author is mostly speaking about tooling performance (tooling that&#x27;s used during development &#x2F; compilation). I don&#x27;t think minifying and dead code removal improve the issue the author writes about.</div><br/></div></div></div></div></div></div></div></div></div></body></html>