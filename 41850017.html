<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729069267399" as="style"/><link rel="stylesheet" href="styles.css?v=1729069267399"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gustedt.wordpress.com/2024/10/15/the-c23-edition-of-modern-c/">The C23 edition of Modern C</a> <span class="domain">(<a href="https://gustedt.wordpress.com">gustedt.wordpress.com</a>)</span></div><div class="subtext"><span>bwidlar</span> | <span>232 comments</span></div><br/><div><div id="41850897" class="c"><input type="checkbox" id="c-41850897" checked=""/><div class="controls bullet"><span class="by">belter</span><span>|</span><a href="#41854897">next</a><span>|</span><label class="collapse" for="c-41850897">[-]</label><label class="expand" for="c-41850897">[121 more]</label></div><br/><div class="children"><div class="content">Important reminder just in the Preface :-)<p>Takeaway #1: &quot;C and C++ are different: don’t mix them, and don’t mix them up&quot;</div><br/><div id="41857019" class="c"><input type="checkbox" id="c-41857019" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41851693">next</a><span>|</span><label class="collapse" for="c-41857019">[-]</label><label class="expand" for="c-41857019">[1 more]</label></div><br/><div class="children"><div class="content">can&#x27;t believe so many people are arguing against this honestly. you don&#x27;t mix them in the sense the author means. I take it these people didn&#x27;t read the paragraphs this was the &#x27;takeaway&#x27; from.<p>For example, the primary reason for the sentence seems to be from the text:
&quot;Many code examples in this book won&#x27;t even compile on a c++ compiler, So we should not mix sources of both languages&quot;.<p>It&#x27;s not at all about the ability to use c libraries in c++ projects or vice versa :S.... c&#x27;mon guys!</div><br/></div></div><div id="41851693" class="c"><input type="checkbox" id="c-41851693" checked=""/><div class="controls bullet"><span class="by">jasode</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41857019">prev</a><span>|</span><a href="#41853183">next</a><span>|</span><label class="collapse" for="c-41851693">[-]</label><label class="expand" for="c-41851693">[44 more]</label></div><br/><div class="children"><div class="content"><i>&gt;Takeaway #1: &quot;C and C++ are different: don’t mix them, and don’t mix them up&quot;</i><p>Where &quot;mixing C&#x2F;C++&quot; is helpful:<p>- I &quot;mix C in with my C++&quot; projects because &quot;sqlite3.c&quot; and ffmpeg source code is written C.  <i>C++ was designed to interoperate with C code.</i>  C++ code can seamlessly add <i>#include &quot;sqlite3.h&quot;</i> unchanged.<p>- For my own code, I take advantage of &quot;C++ being _mostly_ a superset of C&quot; such as using old-style C printf in C++ instead of newer C++ cout.<p>Where the <i>&quot;C is a totally different language from C++&quot;</i> perspective is helpful:<p>- knowing that compilers can compile code in &quot;C&quot; or &quot;C++&quot; mode which has ramifications for name mangling which leads to &quot;LINK unresolved symbol&quot; errors.<p>- knowing that C99 C23 has many exceptions to &quot;C++ is a superset of C&quot; :  <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Compatibility_of_C_and_C%2B%2B#Constructs_valid_in_C_but_not_in_C++" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Compatibility_of_C_and_C%2B%2B...</a></div><br/><div id="41852165" class="c"><input type="checkbox" id="c-41852165" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851693">parent</a><span>|</span><a href="#41851853">next</a><span>|</span><label class="collapse" for="c-41852165">[-]</label><label class="expand" for="c-41852165">[31 more]</label></div><br/><div class="children"><div class="content">The entire I&#x2F;O streams (where std::cout comes from) feature is garbage, if this was an independent development there is no way that WG21 would have taken it, the reason it&#x27;s in C++ 98 and thus still here today is that it&#x27;s Bjarne&#x27;s baby. The reason not to take it is that it&#x27;s contradictory to the &quot;Don&#x27;t use operator overloading for unrelated operations&quot; core idea. Bjarne will insist that &quot;actually&quot; these operators somehow always meant streaming I&#x2F;O but his evidence is basically the same library feature he&#x27;s trying to justify. No other language does this, and it&#x27;s not because they can&#x27;t it&#x27;s because it was a bad idea when it was created, it was still a bad idea in 1998, the only difference today is that C++ has a replacement.<p>The modern fmt-inspired std::print and std::println etc. are much nicer, preserving all the type checking but losing terrible ideas like stored format state, and localisation by default. The biggest problem is that today C++ doesn&#x27;t have a way to implement this for your own types easily, Barry illustrates a comfortable way this could work in C++ 26 via reflection which on that issue closes the gap with Rust&#x27;s #[derive(Debug)].</div><br/><div id="41854396" class="c"><input type="checkbox" id="c-41854396" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41853207">next</a><span>|</span><label class="collapse" for="c-41854396">[-]</label><label class="expand" for="c-41854396">[1 more]</label></div><br/><div class="children"><div class="content">Remember that C++ originally didn&#x27;t have variadic templates, so something like std::format would have been impossible back in the day. Back in the day, std::iostream was a very neat solution for <i>type safe</i> string formatting. As you conceded, it also makes it very easy to integrate your own types. It was a <i>big</i> improvement over printf(). Historic perspective is everything.</div><br/></div></div><div id="41853207" class="c"><input type="checkbox" id="c-41853207" checked=""/><div class="controls bullet"><span class="by">dieortin</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41854396">prev</a><span>|</span><a href="#41855859">next</a><span>|</span><label class="collapse" for="c-41853207">[-]</label><label class="expand" for="c-41853207">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The biggest problem is that today C++ doesn&#x27;t have a way to implement this for your own types easily<p>I’m not sure about the stdlib version, but with fmtlib you can easily implement formatters for your own types. <a href="https:&#x2F;&#x2F;fmt.dev&#x2F;11.0&#x2F;api&#x2F;#formatting-user-defined-types" rel="nofollow">https:&#x2F;&#x2F;fmt.dev&#x2F;11.0&#x2F;api&#x2F;#formatting-user-defined-types</a></div><br/><div id="41853483" class="c"><input type="checkbox" id="c-41853483" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853207">parent</a><span>|</span><a href="#41855859">next</a><span>|</span><label class="collapse" for="c-41853483">[-]</label><label class="expand" for="c-41853483">[1 more]</label></div><br/><div class="children"><div class="content">I think the problem is that your idea of &quot;easy&quot; is &quot;Here&#x27;s a whole bunch of C++ you could write by hand for each type&quot; while the comparison was very literally #[derive(Debug)]. I wasn&#x27;t abbreviating or referring to something else, that&#x27;s literally what Rust programmers type to indicate that their type should have the obvious boilerplate implementation for this feature, in most types you&#x27;re deriving other traits already, so the extra work is literally typing out the word Debug.</div><br/></div></div></div></div><div id="41855859" class="c"><input type="checkbox" id="c-41855859" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41853207">prev</a><span>|</span><a href="#41852524">next</a><span>|</span><label class="collapse" for="c-41855859">[-]</label><label class="expand" for="c-41855859">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Don&#x27;t use operator overloading for unrelated operations<p>This disn&#x27;t stop with &lt;iostream&gt;, they keep doing it - the latest example I can think of is std::ranges operations being &quot;piped&quot; with |.</div><br/></div></div><div id="41852524" class="c"><input type="checkbox" id="c-41852524" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41855859">prev</a><span>|</span><a href="#41855139">next</a><span>|</span><label class="collapse" for="c-41852524">[-]</label><label class="expand" for="c-41852524">[20 more]</label></div><br/><div class="children"><div class="content">Perfectly iostreams happy user since 1993.</div><br/><div id="41853058" class="c"><input type="checkbox" id="c-41853058" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852524">parent</a><span>|</span><a href="#41852904">next</a><span>|</span><label class="collapse" for="c-41853058">[-]</label><label class="expand" for="c-41853058">[7 more]</label></div><br/><div class="children"><div class="content">int a;<p>cin &gt;&gt; a;<p>Then the program goes berserk as soon as the first non-number is read out of standard input.  All the other &quot;cin &gt;&gt; integer&quot; lines are immediately skipped.<p>Yes, I know about error checking, clearing error condition, discarding characters.  But it&#x27;s a whole lot of stuff you need to do after every single &quot;cin&gt;&gt;&quot; line.  It makes the simplicity of cin not worth it.</div><br/><div id="41855407" class="c"><input type="checkbox" id="c-41855407" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853058">parent</a><span>|</span><a href="#41853403">next</a><span>|</span><label class="collapse" for="c-41855407">[-]</label><label class="expand" for="c-41855407">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   fscanf (STDIN, &quot;%d&quot;, &amp;a);
</code></pre>
the program goes beserk as soon as the first non-number is read out of standard input.<p>in both cases, you need error checking (which you &quot;know about&quot;).</div><br/><div id="41856642" class="c"><input type="checkbox" id="c-41856642" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855407">parent</a><span>|</span><a href="#41853403">next</a><span>|</span><label class="collapse" for="c-41856642">[-]</label><label class="expand" for="c-41856642">[1 more]</label></div><br/><div class="children"><div class="content">No actual C programmer who has been around the block more than halfway should do that. The mantra is: &quot;read into a character buffer, then parse that&quot;.<p>It&#x27;s more code, sure, but it buys you a lot of good things. I&#x2F;O is hard.</div><br/></div></div></div></div><div id="41853403" class="c"><input type="checkbox" id="c-41853403" checked=""/><div class="controls bullet"><span class="by">eMSF</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853058">parent</a><span>|</span><a href="#41855407">prev</a><span>|</span><a href="#41853339">next</a><span>|</span><label class="collapse" for="c-41853403">[-]</label><label class="expand" for="c-41853403">[3 more]</label></div><br/><div class="children"><div class="content">How could you ever continue after the second statement without checking if you actually read an integer or not? How would you know what you can do with a?</div><br/><div id="41854295" class="c"><input type="checkbox" id="c-41854295" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853403">parent</a><span>|</span><a href="#41855723">next</a><span>|</span><label class="collapse" for="c-41854295">[-]</label><label class="expand" for="c-41854295">[1 more]</label></div><br/><div class="children"><div class="content">You couldn&#x27;t or wouldn&#x27;t. but why have a read statement like cin&gt;&gt; which looks so nice and clean when you then have to go and check everything with flags and boolean casts on stateful objects.<p>I agree. It&#x27;s lunacy. just be explicit and use functions or equivalent like literally every other language.</div><br/></div></div><div id="41855723" class="c"><input type="checkbox" id="c-41855723" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853403">parent</a><span>|</span><a href="#41854295">prev</a><span>|</span><a href="#41853339">next</a><span>|</span><label class="collapse" for="c-41855723">[-]</label><label class="expand" for="c-41855723">[1 more]</label></div><br/><div class="children"><div class="content">Well in a language like Haskell you could solve this with monads and do-notation. The general idiom in Haskell is to use a Maybe or Either monad to capture success&#x2F;failure and you assume you’re on the happy path. Then you put the error handling at the consumer end of the pipeline when you unwrap the Maybe or Either.<p>I believe Rust has adopted similar idioms. I’ve heard the overall idea referred to as Railway-oriented programming.<p>In C++ you could implement it with exceptions, though they bring in a bunch of their own baggage that you don’t have to deal with when using monads.</div><br/></div></div></div></div><div id="41853339" class="c"><input type="checkbox" id="c-41853339" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853058">parent</a><span>|</span><a href="#41853403">prev</a><span>|</span><a href="#41852904">next</a><span>|</span><label class="collapse" for="c-41853339">[-]</label><label class="expand" for="c-41853339">[1 more]</label></div><br/><div class="children"><div class="content">You’re holding it wrong. Like nan, the point is you don’t have to error check every operation.<p>You check error for the whole batch.</div><br/></div></div></div></div><div id="41852904" class="c"><input type="checkbox" id="c-41852904" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852524">parent</a><span>|</span><a href="#41853058">prev</a><span>|</span><a href="#41854676">next</a><span>|</span><label class="collapse" for="c-41852904">[-]</label><label class="expand" for="c-41852904">[1 more]</label></div><br/><div class="children"><div class="content">Same, as long as I stay the hell away from locales&#x2F;facets.<p>Type safe input&#x2F;output stream types and memory backed streams served on a silver plate is a pretty decent improvement over C.</div><br/></div></div><div id="41854676" class="c"><input type="checkbox" id="c-41854676" checked=""/><div class="controls bullet"><span class="by">fra</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852524">parent</a><span>|</span><a href="#41852904">prev</a><span>|</span><a href="#41853427">next</a><span>|</span><label class="collapse" for="c-41854676">[-]</label><label class="expand" for="c-41854676">[1 more]</label></div><br/><div class="children"><div class="content">This was a tip my hatn excellent to you</div><br/></div></div><div id="41853427" class="c"><input type="checkbox" id="c-41853427" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852524">parent</a><span>|</span><a href="#41854676">prev</a><span>|</span><a href="#41854939">next</a><span>|</span><label class="collapse" for="c-41853427">[-]</label><label class="expand" for="c-41853427">[8 more]</label></div><br/><div class="children"><div class="content">Then I suppose you don&#x27;t care about:<p>* Performance<p>* Support for localization (as the format string and positions of values to format differ between languages).<p>* Code reuse &amp; dogfooding - the data structures used in iostreams are not used elsewhere, and vice-versa<p>* C and OS interoperability - as you can&#x27;t wrap a stream around a FILE* &#x2F; file descritor<p>* bunch of other stuff...<p>iostreams work, but are rather crappy.</div><br/><div id="41853587" class="c"><input type="checkbox" id="c-41853587" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853427">parent</a><span>|</span><a href="#41854939">next</a><span>|</span><label class="collapse" for="c-41853587">[-]</label><label class="expand" for="c-41853587">[7 more]</label></div><br/><div class="children"><div class="content">I care about performance, when it actually matters to acceptance testing.<p>The less C the merrier.<p>If you care about correct use of localisation, standard C and C++ libraries aren&#x27;t really what you&#x27;re looking for, or even C and C++ to start with.</div><br/><div id="41855144" class="c"><input type="checkbox" id="c-41855144" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853587">parent</a><span>|</span><a href="#41854253">next</a><span>|</span><label class="collapse" for="c-41855144">[-]</label><label class="expand" for="c-41855144">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; If you care about correct use of localisation, standard C and C++ libraries aren&#x27;t really what you&#x27;re looking for, or even C and C++ to start with.
</code></pre>
What do you recommend instead?</div><br/><div id="41856784" class="c"><input type="checkbox" id="c-41856784" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855144">parent</a><span>|</span><a href="#41855414">next</a><span>|</span><label class="collapse" for="c-41856784">[-]</label><label class="expand" for="c-41856784">[2 more]</label></div><br/><div class="children"><div class="content">QT, unfortunately.</div><br/><div id="41856862" class="c"><input type="checkbox" id="c-41856862" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41856784">parent</a><span>|</span><a href="#41855414">next</a><span>|</span><label class="collapse" for="c-41856862">[-]</label><label class="expand" for="c-41856862">[1 more]</label></div><br/><div class="children"><div class="content">Why do you &quot;unfortunately&quot;?</div><br/></div></div></div></div><div id="41855414" class="c"><input type="checkbox" id="c-41855414" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855144">parent</a><span>|</span><a href="#41856784">prev</a><span>|</span><a href="#41854253">next</a><span>|</span><label class="collapse" for="c-41855414">[-]</label><label class="expand" for="c-41855414">[1 more]</label></div><br/><div class="children"><div class="content">_(&quot;some text&quot;) ... aka gettext and friends.</div><br/></div></div></div></div><div id="41854253" class="c"><input type="checkbox" id="c-41854253" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853587">parent</a><span>|</span><a href="#41855144">prev</a><span>|</span><a href="#41854939">next</a><span>|</span><label class="collapse" for="c-41854253">[-]</label><label class="expand" for="c-41854253">[2 more]</label></div><br/><div class="children"><div class="content">C and C++ are the bedrock of operating systems with the best performance and extensive support for all languages.<p>The only reason why iostreams are slow is because of its incompatible buffering scheme, and the fact that C and C++ need to stay in sync when linked together. And that brand of slow is still faster than other languages, except sometimes those that delegate i&#x2F;o to pure C implementations.</div><br/><div id="41856448" class="c"><input type="checkbox" id="c-41856448" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41854253">parent</a><span>|</span><a href="#41854939">next</a><span>|</span><label class="collapse" for="c-41856448">[-]</label><label class="expand" for="c-41856448">[1 more]</label></div><br/><div class="children"><div class="content">Historical baggage, they weren&#x27;t the first system programming languages, got lucky with UNIX&#x27;s license allowing for widespread adoption, and won&#x27;t be the last one standing either.</div><br/></div></div></div></div></div></div></div></div><div id="41854939" class="c"><input type="checkbox" id="c-41854939" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852524">parent</a><span>|</span><a href="#41853427">prev</a><span>|</span><a href="#41853344">next</a><span>|</span><label class="collapse" for="c-41854939">[-]</label><label class="expand" for="c-41854939">[1 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/></div></div><div id="41853344" class="c"><input type="checkbox" id="c-41853344" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852524">parent</a><span>|</span><a href="#41854939">prev</a><span>|</span><a href="#41855139">next</a><span>|</span><label class="collapse" for="c-41853344">[-]</label><label class="expand" for="c-41853344">[1 more]</label></div><br/><div class="children"><div class="content">Yep, it’s very clean once you get the hang of it.</div><br/></div></div></div></div><div id="41855139" class="c"><input type="checkbox" id="c-41855139" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41852524">prev</a><span>|</span><a href="#41854242">next</a><span>|</span><label class="collapse" for="c-41855139">[-]</label><label class="expand" for="c-41855139">[1 more]</label></div><br/><div class="children"><div class="content">Over the years, I have heard numerous complaints about C++ I&#x2F;O streams.  Is there a better open source replacement?  Or do you recommend to use C functions for I&#x2F;O?</div><br/></div></div><div id="41854242" class="c"><input type="checkbox" id="c-41854242" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41855139">prev</a><span>|</span><a href="#41853365">next</a><span>|</span><label class="collapse" for="c-41854242">[-]</label><label class="expand" for="c-41854242">[3 more]</label></div><br/><div class="children"><div class="content">&gt;No other language does this, and it&#x27;s not because they can&#x27;t it&#x27;s because it was a bad idea when it was created, it was still a bad idea in 1998, the only difference today is that C++ has a replacement.<p>Hindsight is 20&#x2F;20, remember that. Streams are not that bad of an idea and have been working fine for decades. You haven&#x27;t named a problem with it other than the fact the operators are used for other stuff in other contexts. But operator overloading is a feature of C++ so most operators, even the comma operator, can be something other than what you expect.<p>&gt;The biggest problem is that today C++ doesn&#x27;t have a way to implement this for your own types easily, Barry illustrates a comfortable way this could work in C++ 26 via reflection which on that issue closes the gap with Rust&#x27;s #[derive(Debug)].<p>You can trivially implement input and output for your own types with streams.<p>You appear to be a Rust guy whose motive is to throw shade on C++ for things that are utterly banal and subjective issues.</div><br/><div id="41855426" class="c"><input type="checkbox" id="c-41855426" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41854242">parent</a><span>|</span><a href="#41853365">next</a><span>|</span><label class="collapse" for="c-41855426">[-]</label><label class="expand" for="c-41855426">[2 more]</label></div><br/><div class="children"><div class="content">What they mean is this:<p><pre><code>     struct Foo {
       int a;
       float b;
       std::string c;
     };


     Foo foo;
     std::cout &lt;&lt; foo;
</code></pre>
with no extra code. It&#x27;s called reflection, where the compiler can generate good-enough code to generate a character-stream serialization of an object without any human intervention.</div><br/><div id="41856808" class="c"><input type="checkbox" id="c-41856808" checked=""/><div class="controls bullet"><span class="by">wakawaka28</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855426">parent</a><span>|</span><a href="#41853365">next</a><span>|</span><label class="collapse" for="c-41856808">[-]</label><label class="expand" for="c-41856808">[1 more]</label></div><br/><div class="children"><div class="content">I know what reflection is of course. C++ makes it easy to implement IO. If you&#x27;re asking for a reflection-based solution with less effort, you are practically asking for zero extra code. Anyway, C++ does not yet have reflection but who&#x27;s to say how anyone wants any particular data to be dumped? A default implementation is nice but less useful than you make it sound. In any case, there are libraries approximating what you described (usually with macros and stuff) and reflection is totally coming at some point.</div><br/></div></div></div></div></div></div><div id="41853365" class="c"><input type="checkbox" id="c-41853365" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41854242">prev</a><span>|</span><a href="#41852543">next</a><span>|</span><label class="collapse" for="c-41853365">[-]</label><label class="expand" for="c-41853365">[1 more]</label></div><br/><div class="children"><div class="content">What’s wrong with it?</div><br/></div></div><div id="41852543" class="c"><input type="checkbox" id="c-41852543" checked=""/><div class="controls bullet"><span class="by">lugu</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852165">parent</a><span>|</span><a href="#41853365">prev</a><span>|</span><a href="#41851853">next</a><span>|</span><label class="collapse" for="c-41852543">[-]</label><label class="expand" for="c-41852543">[1 more]</label></div><br/><div class="children"><div class="content">Thank you.</div><br/></div></div></div></div><div id="41851853" class="c"><input type="checkbox" id="c-41851853" checked=""/><div class="controls bullet"><span class="by">accelbred</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851693">parent</a><span>|</span><a href="#41852165">prev</a><span>|</span><a href="#41852449">next</a><span>|</span><label class="collapse" for="c-41851853">[-]</label><label class="expand" for="c-41851853">[7 more]</label></div><br/><div class="children"><div class="content">C++ can seamlessly include C89 headers.<p>The C library headers for libraries I write often include C11&#x2F;C99 stuff that is invalid in C++.<p>Even when they are in C89, they are often incorrect to include without the include being in an `extern &quot;C&quot;`.</div><br/><div id="41851979" class="c"><input type="checkbox" id="c-41851979" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851853">parent</a><span>|</span><a href="#41852136">next</a><span>|</span><label class="collapse" for="c-41851979">[-]</label><label class="expand" for="c-41851979">[1 more]</label></div><br/><div class="children"><div class="content">Extern &quot;C&quot; around the prototypes is mandatory, otherwise your linker will search for C++ symbols, which cannot be found in the C libraries you pass it.</div><br/></div></div><div id="41852136" class="c"><input type="checkbox" id="c-41852136" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851853">parent</a><span>|</span><a href="#41851979">prev</a><span>|</span><a href="#41852251">next</a><span>|</span><label class="collapse" for="c-41852136">[-]</label><label class="expand" for="c-41852136">[3 more]</label></div><br/><div class="children"><div class="content">Clang supports C11 - 23 in C++, as well as some future C features like fixed-point integers. The main pain points with Clang are just the fundamental differences like void* and char, which don&#x27;t typically matter much at an interoperability layer.</div><br/><div id="41856217" class="c"><input type="checkbox" id="c-41856217" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852136">parent</a><span>|</span><a href="#41852251">next</a><span>|</span><label class="collapse" for="c-41856217">[-]</label><label class="expand" for="c-41856217">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of subtle differences between &#x27;proper&#x27; C and the C subset of C++, since C++ uses C++ semantics everywhere, even for its C subset.<p>Many C++ coders are oblivious to those differences (myself included before I switched from &#x27;mainly C++&#x27; to &#x27;mainly C&#x27;) because they think that the C subset of C++ is compatible with &#x27;proper&#x27; C, but any C code that compiles both in a C++ and C compiler is actually also a (heavily outdated) subset of the C language (so for a C coder it takes extra effort to write C++ compatible C code, and it&#x27;s not great because it&#x27;s a throwback to the mid-90s, C++ compatible C is potentially less safe and harder to maintain).<p>For instance in C++ it&#x27;s illegal to take the address of an &#x27;adhoc-constructed&#x27; function argument, like:<p><pre><code>    sum(&amp;(bla_t){ .a = 1, .b = 2, .c = 3, .d = 4 });
</code></pre>
(godbolt: <a href="https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;r7r5rPc6K" rel="nofollow">https:&#x2F;&#x2F;www.godbolt.org&#x2F;z&#x2F;r7r5rPc6K</a>)<p>Interestingly, Objective-C leaves its C subset alone, so it is always automatically compatible with the latest C features without requiring a new &#x27;ObjC standard&#x27;.</div><br/><div id="41856478" class="c"><input type="checkbox" id="c-41856478" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41856217">parent</a><span>|</span><a href="#41852251">next</a><span>|</span><label class="collapse" for="c-41856478">[-]</label><label class="expand" for="c-41856478">[1 more]</label></div><br/><div class="children"><div class="content">Because Objective-C initial proposal is that everything that isn&#x27;t touched by Smalltalk like code, clearly in brackets or @annotarions, is plain C.<p>The pre-processor original compiler, before the GCC fork, would leave everything else alone, blindly copying into the generated C file.</div><br/></div></div></div></div></div></div><div id="41852251" class="c"><input type="checkbox" id="c-41852251" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851853">parent</a><span>|</span><a href="#41852136">prev</a><span>|</span><a href="#41852449">next</a><span>|</span><label class="collapse" for="c-41852251">[-]</label><label class="expand" for="c-41852251">[2 more]</label></div><br/><div class="children"><div class="content">Yeah plenty of headers first have `#ifdef __cplusplus` and then they add `extern &quot;C&quot;`. And of course even then they have to avoid doing things unacceptable in C++ such as using &quot;new&quot; as the name of a variable.<p>It takes a little bit of an effort to make a header work on C and C++. A lot less effort than making a single Python file work with Python 2 and 3.</div><br/><div id="41856228" class="c"><input type="checkbox" id="c-41856228" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852251">parent</a><span>|</span><a href="#41852449">next</a><span>|</span><label class="collapse" for="c-41856228">[-]</label><label class="expand" for="c-41856228">[1 more]</label></div><br/><div class="children"><div class="content">The &#x27;#ifdef __cplusplus extern &quot;C&quot; { }&#x27; thing only removes C++ name mangling from exported symbols, it doesn&#x27;t switch the C++ language into &quot;C mode&quot; (unfortunately).</div><br/></div></div></div></div></div></div><div id="41852449" class="c"><input type="checkbox" id="c-41852449" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851693">parent</a><span>|</span><a href="#41851853">prev</a><span>|</span><a href="#41856015">next</a><span>|</span><label class="collapse" for="c-41852449">[-]</label><label class="expand" for="c-41852449">[3 more]</label></div><br/><div class="children"><div class="content">&gt; C++ code can seamlessly add #include &quot;sqlite3.h&quot; unchanged.<p>Almost seamlessly. You have to do<p><pre><code>  extern “C” {
    #include &quot;sqlite3.h&quot;
  }
</code></pre>
(<a href="https:&#x2F;&#x2F;isocpp.org&#x2F;wiki&#x2F;faq&#x2F;mixing-c-and-cpp#include-c-hdrs-nonsystem" rel="nofollow">https:&#x2F;&#x2F;isocpp.org&#x2F;wiki&#x2F;faq&#x2F;mixing-c-and-cpp#include-c-hdrs-...</a>)</div><br/><div id="41853127" class="c"><input type="checkbox" id="c-41853127" checked=""/><div class="controls bullet"><span class="by">cornstalks</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852449">parent</a><span>|</span><a href="#41852651">next</a><span>|</span><label class="collapse" for="c-41853127">[-]</label><label class="expand" for="c-41853127">[1 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re nitpicking then sqlite3.h already has `#ifdef __cplusplus` and `extern &quot;C&quot; {`. So yes, from the user&#x27;s perspective it is seamless. They do not need to play the `extern &quot;C&quot; {` game.</div><br/></div></div></div></div><div id="41856015" class="c"><input type="checkbox" id="c-41856015" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851693">parent</a><span>|</span><a href="#41852449">prev</a><span>|</span><a href="#41853183">next</a><span>|</span><label class="collapse" for="c-41856015">[-]</label><label class="expand" for="c-41856015">[2 more]</label></div><br/><div class="children"><div class="content">Yep; I think of it as &quot;C&#x2F;C++&quot; and not &quot;C&quot; and&#x2F;or &quot;C++&quot; i.e. one &quot;multi-paradigm&quot; language with different sets of mix-and-match.</div><br/><div id="41856842" class="c"><input type="checkbox" id="c-41856842" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41856015">parent</a><span>|</span><a href="#41853183">next</a><span>|</span><label class="collapse" for="c-41856842">[-]</label><label class="expand" for="c-41856842">[1 more]</label></div><br/><div class="children"><div class="content">kinda like python and ruby</div><br/></div></div></div></div></div></div><div id="41853183" class="c"><input type="checkbox" id="c-41853183" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41851693">prev</a><span>|</span><a href="#41850960">next</a><span>|</span><label class="collapse" for="c-41853183">[-]</label><label class="expand" for="c-41853183">[2 more]</label></div><br/><div class="children"><div class="content">My brief foray into microcontroller land has taught me that C and C++ are very much mixed.<p>It&#x27;s telling that every compiler toolchain that compiles C++ also compiles C (for some definition of &quot;C&quot;). With compiler flags, GCC extensions, and libraries that are kinda-sorta compatible with both languages, there&#x27;s no being strict about it.<p>_My_ code might be strict about it, but what about tinyusb? Eventually you&#x27;ll have to work with a library that chokes on `--pedantic`, because much (most?) code is not written to a strict C or C++ standard, but is &quot;C&#x2F;C++&quot; and various extensions.</div><br/><div id="41856074" class="c"><input type="checkbox" id="c-41856074" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853183">parent</a><span>|</span><a href="#41850960">next</a><span>|</span><label class="collapse" for="c-41856074">[-]</label><label class="expand" for="c-41856074">[1 more]</label></div><br/><div class="children"><div class="content">&gt; because much (most?) code is not written to a strict C or C++ standard, but is &quot;C&#x2F;C++&quot; and various extensions.<p>Absolutely true. I generally insist on folks learning C and C++ interoperability before diving in to all the &quot;Modern C or C++&quot; goodness. It helps them in understanding what actually is going on &quot;under the hood&quot; and makes them a better programmer&#x2F;debugger.<p>See also the book <i>Advanced C and C++ Compiling by Milan Stevanovic.</i></div><br/></div></div></div></div><div id="41850960" class="c"><input type="checkbox" id="c-41850960" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41853183">prev</a><span>|</span><a href="#41851166">next</a><span>|</span><label class="collapse" for="c-41850960">[-]</label><label class="expand" for="c-41850960">[43 more]</label></div><br/><div class="children"><div class="content">Specially relevant to all those folks that insist on &quot;Coding C with a C++ compiler&quot;, instead of safer language constructs, and standard library alternatives provided by C++ during the last decades.</div><br/><div id="41851268" class="c"><input type="checkbox" id="c-41851268" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41850960">parent</a><span>|</span><a href="#41851082">next</a><span>|</span><label class="collapse" for="c-41851268">[-]</label><label class="expand" for="c-41851268">[11 more]</label></div><br/><div class="children"><div class="content">Funny because for a long time the Microsoft MSVC team explicitly recommended compiling C code with a C++ compiler because they couldn&#x27;t be arsed to update their C frontend for over two decades (which thankfully has changed now) ;)<p><a href="https:&#x2F;&#x2F;herbsutter.com&#x2F;2012&#x2F;05&#x2F;03&#x2F;reader-qa-what-about-vc-and-c99&#x2F;" rel="nofollow">https:&#x2F;&#x2F;herbsutter.com&#x2F;2012&#x2F;05&#x2F;03&#x2F;reader-qa-what-about-vc-an...</a></div><br/><div id="41851659" class="c"><input type="checkbox" id="c-41851659" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851268">parent</a><span>|</span><a href="#41852439">next</a><span>|</span><label class="collapse" for="c-41851659">[-]</label><label class="expand" for="c-41851659">[9 more]</label></div><br/><div class="children"><div class="content">That thing always baffled me, this huge company building a professional IDE couldn&#x27;t figure out how to ship updates to the C compiler.<p>&gt; it is hard to say no to you, and I’m sorry to say it. But we have to choose a focus, and our focus is to implement (the standard) and innovate (with extensions like everyone but which we also contribute for potential standardization) in C++.<p>I mean, yeah if it came from a two member team at a startup, sure focus on C++, understandably. But Microsoft, what happened to &quot;Developers! Developers! Developers!&quot;?</div><br/><div id="41851811" class="c"><input type="checkbox" id="c-41851811" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851659">parent</a><span>|</span><a href="#41852459">next</a><span>|</span><label class="collapse" for="c-41851811">[-]</label><label class="expand" for="c-41851811">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not baffling, it&#x27;s remarkably consistent. They implemented Java as J++ and made their version incompatible in various ways with the standard so it was harder to port your code away from J++ (and later J#). They implemented things in the CSS spec almost exactly opposite the specification to lock people into IE (the dominant browser, if you have to make your site work with 2+ incompatible systems which will you focus on?). Not supporting C effectively with their tools pushed developers towards their C++ implementation, creating more lock-in opportunities.</div><br/></div></div><div id="41852459" class="c"><input type="checkbox" id="c-41852459" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851659">parent</a><span>|</span><a href="#41851811">prev</a><span>|</span><a href="#41851984">next</a><span>|</span><label class="collapse" for="c-41852459">[-]</label><label class="expand" for="c-41852459">[6 more]</label></div><br/><div class="children"><div class="content">It was on purpose, Microsoft was done with C, the official message was to move on to C++.<p>The change of heart was the new management, and the whole Microsoft &lt;3 FOSS.</div><br/><div id="41852886" class="c"><input type="checkbox" id="c-41852886" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852459">parent</a><span>|</span><a href="#41851984">next</a><span>|</span><label class="collapse" for="c-41852886">[-]</label><label class="expand" for="c-41852886">[5 more]</label></div><br/><div class="children"><div class="content">&gt; It was on purpose, Microsoft was done with C<p>Indeed, and yet here we are with C23<p>&gt; The change of heart was the new management, and the whole Microsoft &lt;3 FOSS.<p>Yeah, agree. To me the turning point was when they created WSL.</div><br/><div id="41855699" class="c"><input type="checkbox" id="c-41855699" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852886">parent</a><span>|</span><a href="#41856495">next</a><span>|</span><label class="collapse" for="c-41855699">[-]</label><label class="expand" for="c-41855699">[3 more]</label></div><br/><div class="children"><div class="content">Microsoft didn&#x27;t create C23 and they don&#x27;t &lt;3 FOSS.  They&#x27;re accepting that they have to deal with FOSS, but installing Windows will still make your Linux system unbootable until you fix it with a rescue disk, among numerous other unfriendly things they do.</div><br/><div id="41855935" class="c"><input type="checkbox" id="c-41855935" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855699">parent</a><span>|</span><a href="#41856495">next</a><span>|</span><label class="collapse" for="c-41855935">[-]</label><label class="expand" for="c-41855935">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen Windows fuck up the EFI partition or delete the other entries in a while now. After installing it the machine will usually boot directly into it, but it should be just a toggle in the firmware to switch back to GRUB.</div><br/><div id="41856064" class="c"><input type="checkbox" id="c-41856064" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855935">parent</a><span>|</span><a href="#41856495">next</a><span>|</span><label class="collapse" for="c-41856064">[-]</label><label class="expand" for="c-41856064">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an improvement!  When did they fix that?</div><br/></div></div></div></div></div></div><div id="41856495" class="c"><input type="checkbox" id="c-41856495" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852886">parent</a><span>|</span><a href="#41855699">prev</a><span>|</span><a href="#41851984">next</a><span>|</span><label class="collapse" for="c-41856495">[-]</label><label class="expand" for="c-41856495">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft doesn&#x27;t take part on WG14, and MSVC only does up to C17 nowadays.</div><br/></div></div></div></div></div></div><div id="41851984" class="c"><input type="checkbox" id="c-41851984" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851659">parent</a><span>|</span><a href="#41852459">prev</a><span>|</span><a href="#41852439">next</a><span>|</span><label class="collapse" for="c-41851984">[-]</label><label class="expand" for="c-41851984">[1 more]</label></div><br/><div class="children"><div class="content">Funnily enough, the intellisense parser <i>does</i> support C syntax because it&#x27;s using a commercial frontend by edison under the hood. MSVC&#x27;s frontend doesn&#x27;t.</div><br/></div></div></div></div><div id="41852439" class="c"><input type="checkbox" id="c-41852439" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851268">parent</a><span>|</span><a href="#41851659">prev</a><span>|</span><a href="#41851082">next</a><span>|</span><label class="collapse" for="c-41852439">[-]</label><label class="expand" for="c-41852439">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, 12 years ago, when governments couldn&#x27;t care less about nation state cyberattacks, and Microsoft was yet to be called by the Congress to testify on their failures.</div><br/></div></div></div></div><div id="41851082" class="c"><input type="checkbox" id="c-41851082" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41850960">parent</a><span>|</span><a href="#41851268">prev</a><span>|</span><a href="#41851031">next</a><span>|</span><label class="collapse" for="c-41851082">[-]</label><label class="expand" for="c-41851082">[30 more]</label></div><br/><div class="children"><div class="content">Perfectly valid to do if you need to interface with a large C code base and you just want to do some simple OO here and there. Especially if you cannot have runtime exceptions and the like.<p>This is how I managed to sneak C++ into an embedded C codebase. We even created some templates for data structures that supported static allocation at compile time.</div><br/><div id="41851140" class="c"><input type="checkbox" id="c-41851140" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851082">parent</a><span>|</span><a href="#41852515">next</a><span>|</span><label class="collapse" for="c-41851140">[-]</label><label class="expand" for="c-41851140">[28 more]</label></div><br/><div class="children"><div class="content">What would be an example of &quot;simple OO here and there&quot; that cannot be done cleanly in plain C?</div><br/><div id="41851407" class="c"><input type="checkbox" id="c-41851407" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851140">parent</a><span>|</span><a href="#41854294">next</a><span>|</span><label class="collapse" for="c-41851407">[-]</label><label class="expand" for="c-41851407">[1 more]</label></div><br/><div class="children"><div class="content">Templating on pixel classes so that a blitter builds all supported pixel paths separately and inlines them.<p>Yes you can do it less cleanly with macros or inline functions. But you can&#x27;t do it  performantly with struct and function pointers.</div><br/></div></div><div id="41854294" class="c"><input type="checkbox" id="c-41854294" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851140">parent</a><span>|</span><a href="#41851407">prev</a><span>|</span><a href="#41851799">next</a><span>|</span><label class="collapse" for="c-41854294">[-]</label><label class="expand" for="c-41854294">[3 more]</label></div><br/><div class="children"><div class="content">You can do anything in C that you want to. Of course one can make v-tables and all of that, and even do inheritance.<p>But having the &quot;class&quot; keyword is nice. Having built in support for member functions is nice.<p>Sometimes a person just wants the simplicity of C++ 2003.<p>(In reality I was working on a project where our compiler only supported C++ 2003 and we had a UI library written in C++ 2003 and honestly pure C UI libraries kind of suck compared to just sprinkling in a bit of C++ sugar.)</div><br/><div id="41855255" class="c"><input type="checkbox" id="c-41855255" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41854294">parent</a><span>|</span><a href="#41851799">next</a><span>|</span><label class="collapse" for="c-41855255">[-]</label><label class="expand" for="c-41855255">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; You can do anything in C that you want to.
</code></pre>
How about destructors?</div><br/><div id="41856788" class="c"><input type="checkbox" id="c-41856788" checked=""/><div class="controls bullet"><span class="by">com2kid</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855255">parent</a><span>|</span><a href="#41851799">next</a><span>|</span><label class="collapse" for="c-41856788">[-]</label><label class="expand" for="c-41856788">[1 more]</label></div><br/><div class="children"><div class="content">You can obviously build any runtime system you desire in C, including one that parses and executes C code with additional features added in. The wisdom of doing this is questionable.<p>Though I&#x27;ve actually seen macro systems that do things akin to destructors, although less automatically.</div><br/></div></div></div></div></div></div><div id="41851225" class="c"><input type="checkbox" id="c-41851225" checked=""/><div class="controls bullet"><span class="by">raluk</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851140">parent</a><span>|</span><a href="#41851799">prev</a><span>|</span><a href="#41851244">next</a><span>|</span><label class="collapse" for="c-41851225">[-]</label><label class="expand" for="c-41851225">[10 more]</label></div><br/><div class="children"><div class="content">RAII</div><br/><div id="41851243" class="c"><input type="checkbox" id="c-41851243" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851225">parent</a><span>|</span><a href="#41851451">next</a><span>|</span><label class="collapse" for="c-41851243">[-]</label><label class="expand" for="c-41851243">[2 more]</label></div><br/><div class="children"><div class="content">Is RAII Object orientation? I thought it was an idiom of C++ by Stroustrup.</div><br/><div id="41851991" class="c"><input type="checkbox" id="c-41851991" checked=""/><div class="controls bullet"><span class="by">runevault</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851243">parent</a><span>|</span><a href="#41851451">next</a><span>|</span><label class="collapse" for="c-41851991">[-]</label><label class="expand" for="c-41851991">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t necessarily have to be OO no. Rust uses RAII and it uses traits instead of traditional OO style inheritance etc. You do need something like destructors&#x2F;drop trait for it to work as far as I know though.</div><br/></div></div></div></div><div id="41851451" class="c"><input type="checkbox" id="c-41851451" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851225">parent</a><span>|</span><a href="#41851243">prev</a><span>|</span><a href="#41851244">next</a><span>|</span><label class="collapse" for="c-41851451">[-]</label><label class="expand" for="c-41851451">[7 more]</label></div><br/><div class="children"><div class="content">The killer feature of RAII is when combined with exceptions. But sneaking in exceptions in an embedded C project isn&#x27;t something I&#x27;d encourage or recommend.<p>C++ imo doesn&#x27;t offer anything compelling for the embedded usecase. Especially not considering all the footguns and politics it brings.<p>You can of course be strict and diligent about it but if you are you are pretty much just writing C anyway. Better to do it explicitly.<p>Allowing the use of the C++ standard library has been one of my biggest regrets (not that it was my decision to make, I fought it).</div><br/><div id="41852332" class="c"><input type="checkbox" id="c-41852332" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851451">parent</a><span>|</span><a href="#41852178">next</a><span>|</span><label class="collapse" for="c-41852332">[-]</label><label class="expand" for="c-41852332">[2 more]</label></div><br/><div class="children"><div class="content">There are a lot of large C++ shops that purposefully disable exceptions and yet still use RAII usefully. It&#x27;s so useful that in many C codebases you see people using RAII. For example Gtk has g_autoptr and g_autofree.<p>One of the most compelling things C++ offers to embedded use case is moving runtime initialization to compile-time initialization by liberally using constexpr functions. You literally ask the compiler to do work that would otherwise be done at runtime.</div><br/><div id="41853043" class="c"><input type="checkbox" id="c-41853043" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852332">parent</a><span>|</span><a href="#41852178">next</a><span>|</span><label class="collapse" for="c-41853043">[-]</label><label class="expand" for="c-41853043">[1 more]</label></div><br/><div class="children"><div class="content">RAII is useful without exceptions yes. I guess it is the other way around. Exceptions are not useful without RAII (sorry not sorry most garbage collected languages ;)).<p>But without exceptions it is mostly syntactic sugar anyway.<p>If compile time initialization is the most compelling usecase I&#x27;ll rest my case. Good feature, yes! Hardly worth switching language for.</div><br/></div></div></div></div><div id="41852178" class="c"><input type="checkbox" id="c-41852178" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851451">parent</a><span>|</span><a href="#41852332">prev</a><span>|</span><a href="#41851244">next</a><span>|</span><label class="collapse" for="c-41852178">[-]</label><label class="expand" for="c-41852178">[4 more]</label></div><br/><div class="children"><div class="content">C++ offers lots of compelling things for embedded use cases, like enum classes (finally fixed in C23), constexpr, std::optional, namespaces, and atomics&#x2F;generics that are much smaller dumpster fires.<p>There&#x27;s an effort to extract the good parts and make it work for embedded use cases or even bring them into C. Khalil Estelle on WG21 has been working on an experimental, deterministic runtime for exception handling, to give one example. Constexpr is an example of the latter that&#x27;s now showing up in C23.</div><br/><div id="41852427" class="c"><input type="checkbox" id="c-41852427" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852178">parent</a><span>|</span><a href="#41851244">next</a><span>|</span><label class="collapse" for="c-41852427">[-]</label><label class="expand" for="c-41852427">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, but these are in the ~2% convenience at most. With the huge baggage of including C++ in a project. The cost of learning C++ easily outweighs all those benefits. If you happen to have a proficient C++ team (that actually know embedded), go for it!</div><br/><div id="41852592" class="c"><input type="checkbox" id="c-41852592" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852427">parent</a><span>|</span><a href="#41851244">next</a><span>|</span><label class="collapse" for="c-41852592">[-]</label><label class="expand" for="c-41852592">[2 more]</label></div><br/><div class="children"><div class="content">Speaking more broadly than just the std implementation, but result types like optional shouldn&#x27;t be a 2% convenience, they should be used in most function calls that return errors. Rust is the obvious example here.</div><br/><div id="41853150" class="c"><input type="checkbox" id="c-41853150" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852592">parent</a><span>|</span><a href="#41851244">next</a><span>|</span><label class="collapse" for="c-41853150">[-]</label><label class="expand" for="c-41853150">[1 more]</label></div><br/><div class="children"><div class="content">If you argue for Rust I&#x27;m all for it, arguably much less of a learning curve than C++ too.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41851244" class="c"><input type="checkbox" id="c-41851244" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851140">parent</a><span>|</span><a href="#41851225">prev</a><span>|</span><a href="#41851998">next</a><span>|</span><label class="collapse" for="c-41851244">[-]</label><label class="expand" for="c-41851244">[11 more]</label></div><br/><div class="children"><div class="content">Namespaces, methods.</div><br/><div id="41851261" class="c"><input type="checkbox" id="c-41851261" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851244">parent</a><span>|</span><a href="#41851998">next</a><span>|</span><label class="collapse" for="c-41851261">[-]</label><label class="expand" for="c-41851261">[10 more]</label></div><br/><div class="children"><div class="content">Namespaces is not object orientation, is it? Am I missing something?
You can place functions (methods) inside of structs in C23, can&#x27;t you?</div><br/><div id="41851481" class="c"><input type="checkbox" id="c-41851481" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851261">parent</a><span>|</span><a href="#41851286">next</a><span>|</span><label class="collapse" for="c-41851481">[-]</label><label class="expand" for="c-41851481">[2 more]</label></div><br/><div class="children"><div class="content">You can handcode vtables in C, just as you can handcode loops in assembly (i.e. it works but it&#x27;s verbose, not particularly readable, and brings more footguns).<p>But why would you do that if you have an instrument that lets you work at the same level as C, but with methods provided as a proper abstraction that maps exactly to what you&#x27;d have written yourself anyway?</div><br/><div id="41852301" class="c"><input type="checkbox" id="c-41852301" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851481">parent</a><span>|</span><a href="#41851286">next</a><span>|</span><label class="collapse" for="c-41852301">[-]</label><label class="expand" for="c-41852301">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, I never found the &quot;proper abstraction&quot; be more than irrelevant syntactic sugar. And the cost of C++ is that you end up putting everything in the header (IMHO the biggest design flaw of the language) and then compile time start to get long....</div><br/></div></div></div></div><div id="41851286" class="c"><input type="checkbox" id="c-41851286" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851261">parent</a><span>|</span><a href="#41851481">prev</a><span>|</span><a href="#41851339">next</a><span>|</span><label class="collapse" for="c-41851286">[-]</label><label class="expand" for="c-41851286">[4 more]</label></div><br/><div class="children"><div class="content">On a high level, &quot;object orientation&quot; means you think of your code as representing the state and interactions of objects. You can equally well do this in assembly. If you think of some namespace as a &quot;singleton object&quot; then that&#x27;s what it is.<p>I guess what you&#x27;re really asking is what are the best or most common ways to do OO in C?</div><br/><div id="41851403" class="c"><input type="checkbox" id="c-41851403" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851286">parent</a><span>|</span><a href="#41851339">next</a><span>|</span><label class="collapse" for="c-41851403">[-]</label><label class="expand" for="c-41851403">[3 more]</label></div><br/><div class="children"><div class="content">Oh. I learned that object orientation is primarily a way to structure data and code, such that the data is encapsulated with the code that works on it, in so called objects. So an Object is the Data, plus the functions that work on the data, an ensure that some invariants are kept. In OO parlance, that code gets executed by sending messages (calling methods).<p>Where can I find something about objects being &quot;think of your code as representing the state and interactions of objects&quot; honesty totally new to me.<p>So no, certainly I&#x27;m not asking ways to do OO in C. But it seems to be more definitions of object orientation as I thought...</div><br/><div id="41851523" class="c"><input type="checkbox" id="c-41851523" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851403">parent</a><span>|</span><a href="#41851677">next</a><span>|</span><label class="collapse" for="c-41851523">[-]</label><label class="expand" for="c-41851523">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no clear definition of what OO is, so the best you can do pragmatically is look at mainstream languages that are broadly recognized as OO and try to deduce the commonalities.<p>If you do that, you&#x27;ll notice that, for example, encapsulation is <i>not</i> a part of that de facto definition, because languages like Python and (until recently) JavaScript lack it, despite being considered OO.<p>Indeed, the only two things that appear to be consistently present in all OO languages are: 1) some notion of object identity as distinct from object state, and 2) runtime polymorphic dispatch.</div><br/></div></div><div id="41851677" class="c"><input type="checkbox" id="c-41851677" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851403">parent</a><span>|</span><a href="#41851523">prev</a><span>|</span><a href="#41851339">next</a><span>|</span><label class="collapse" for="c-41851677">[-]</label><label class="expand" for="c-41851677">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Where can I find something about objects being &quot;think of your code as representing the state and interactions of objects&quot; honesty totally new to me.<p>I’m scratching my head how you think this is materially different than what you described in your first para. s&#x2F;state&#x2F;data and s&#x2F;interactions&#x2F;methods.<p>If anything though I would say the GP is more aligned with the classic definition as it highlights the focus is more on the messages (interactions) themselves rather than the implementation.</div><br/></div></div></div></div></div></div><div id="41851339" class="c"><input type="checkbox" id="c-41851339" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851261">parent</a><span>|</span><a href="#41851286">prev</a><span>|</span><a href="#41851998">next</a><span>|</span><label class="collapse" for="c-41851339">[-]</label><label class="expand" for="c-41851339">[3 more]</label></div><br/><div class="children"><div class="content">Correct, and you did ask specifically for OO things, but I thought I&#x27;d list namespaces too as far as “C++ things you might use when writing C-like C++ code”.<p>Another big one that I always forget C still doesn&#x27;t support is function overloading.</div><br/><div id="41852319" class="c"><input type="checkbox" id="c-41852319" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851339">parent</a><span>|</span><a href="#41851998">next</a><span>|</span><label class="collapse" for="c-41852319">[-]</label><label class="expand" for="c-41852319">[2 more]</label></div><br/><div class="children"><div class="content">Function overloading is a feature that makes code less self-documenting without providing any meaningful value.   Operator overloading is more interesting, because you can build you domain language with nice syntax.  But I also tend to think that this is not really worth it.</div><br/><div id="41853276" class="c"><input type="checkbox" id="c-41853276" checked=""/><div class="controls bullet"><span class="by">adamrezich</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852319">parent</a><span>|</span><a href="#41851998">next</a><span>|</span><label class="collapse" for="c-41853276">[-]</label><label class="expand" for="c-41853276">[1 more]</label></div><br/><div class="children"><div class="content">In C++ where you have methods? Sure. It would be nice to have in C, though. But, alas, ABI compatibility.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41851998" class="c"><input type="checkbox" id="c-41851998" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851140">parent</a><span>|</span><a href="#41851244">prev</a><span>|</span><a href="#41852515">next</a><span>|</span><label class="collapse" for="c-41851998">[-]</label><label class="expand" for="c-41851998">[1 more]</label></div><br/><div class="children"><div class="content">CRTP?</div><br/></div></div></div></div><div id="41852515" class="c"><input type="checkbox" id="c-41852515" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851082">parent</a><span>|</span><a href="#41851140">prev</a><span>|</span><a href="#41851031">next</a><span>|</span><label class="collapse" for="c-41852515">[-]</label><label class="expand" for="c-41852515">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but one should provide C++ type safe abstractions on top.<p>Just like one doesn&#x27;t use Typescript to keep writing plain old JavaScript, then why bother.</div><br/></div></div></div></div><div id="41851031" class="c"><input type="checkbox" id="c-41851031" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41850960">parent</a><span>|</span><a href="#41851082">prev</a><span>|</span><a href="#41851166">next</a><span>|</span><label class="collapse" for="c-41851031">[-]</label><label class="expand" for="c-41851031">[1 more]</label></div><br/><div class="children"><div class="content">I mean as long as your goal is specifically to do that I think it&#x27;s fine. Using a C++ compiler to compile a C program isn&#x27;t that rare.</div><br/></div></div></div></div><div id="41851166" class="c"><input type="checkbox" id="c-41851166" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41850960">prev</a><span>|</span><a href="#41855660">next</a><span>|</span><label class="collapse" for="c-41851166">[-]</label><label class="expand" for="c-41851166">[5 more]</label></div><br/><div class="children"><div class="content">A couple of months ago, in the company I work, there was a talk from HR, where they explained how to make a good CV (the company is firing lots of people). She say: &quot;if you have experience in programming C, you can writing just that, or, if you have lots of experience in C, is customary to write ``C++ Experience&#x27;&#x27; &quot;<p>Sooo... yeah... I should definitely change company!</div><br/><div id="41851294" class="c"><input type="checkbox" id="c-41851294" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851166">parent</a><span>|</span><a href="#41853090">next</a><span>|</span><label class="collapse" for="c-41851294">[-]</label><label class="expand" for="c-41851294">[1 more]</label></div><br/><div class="children"><div class="content">That literally made me do a spit take, and it was fizzy water and it burned.<p>My god. That&#x27;s amazing.</div><br/></div></div><div id="41853090" class="c"><input type="checkbox" id="c-41853090" checked=""/><div class="controls bullet"><span class="by">thenipper</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851166">parent</a><span>|</span><a href="#41851294">prev</a><span>|</span><a href="#41852598">next</a><span>|</span><label class="collapse" for="c-41853090">[-]</label><label class="expand" for="c-41853090">[2 more]</label></div><br/><div class="children"><div class="content">How many pluses until you should just say you have D experience?</div><br/><div id="41856899" class="c"><input type="checkbox" id="c-41856899" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853090">parent</a><span>|</span><a href="#41852598">next</a><span>|</span><label class="collapse" for="c-41856899">[-]</label><label class="expand" for="c-41856899">[1 more]</label></div><br/><div class="children"><div class="content">Possibly three. Four pluses is naturally C#.</div><br/></div></div></div></div></div></div><div id="41855660" class="c"><input type="checkbox" id="c-41855660" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41851166">prev</a><span>|</span><a href="#41851047">next</a><span>|</span><label class="collapse" for="c-41855660">[-]</label><label class="expand" for="c-41855660">[1 more]</label></div><br/><div class="children"><div class="content">If you want a language with a great C FFI, C++ is hard to beat!</div><br/></div></div><div id="41851047" class="c"><input type="checkbox" id="c-41851047" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#41850897">parent</a><span>|</span><a href="#41855660">prev</a><span>|</span><a href="#41854897">next</a><span>|</span><label class="collapse" for="c-41851047">[-]</label><label class="expand" for="c-41851047">[24 more]</label></div><br/><div class="children"><div class="content">Bjarne should have called it ++C.</div><br/><div id="41854437" class="c"><input type="checkbox" id="c-41854437" checked=""/><div class="controls bullet"><span class="by">wnoise</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851047">parent</a><span>|</span><a href="#41851328">next</a><span>|</span><label class="collapse" for="c-41854437">[-]</label><label class="expand" for="c-41854437">[1 more]</label></div><br/><div class="children"><div class="content">Nah.  It&#x27;s just the natural semantics -- he added stuff to C, but returned something that wasn&#x27;t actually more advanced...</div><br/></div></div><div id="41851328" class="c"><input type="checkbox" id="c-41851328" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851047">parent</a><span>|</span><a href="#41854437">prev</a><span>|</span><a href="#41854897">next</a><span>|</span><label class="collapse" for="c-41851328">[-]</label><label class="expand" for="c-41851328">[22 more]</label></div><br/><div class="children"><div class="content">Because people choose to use pre-increment by default instead of post-increment?<p>Why is that?</div><br/><div id="41851650" class="c"><input type="checkbox" id="c-41851650" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851328">parent</a><span>|</span><a href="#41853498">next</a><span>|</span><label class="collapse" for="c-41851650">[-]</label><label class="expand" for="c-41851650">[3 more]</label></div><br/><div class="children"><div class="content">It should be ++C because with C++ the value you get from the expression is the old one.<p>If you&#x27;re asking why people use pre-increment by default instead of post-increment, it&#x27;s mostly historical. The early C compilers on resource-constrained platforms such as early DOS were not good at optimization; on those, pre-increment would be reliably translated to a simple ADD or INC, whereas code for post-increment might generate an extra copy even if it wasn&#x27;t actually used.<p>For C++ this was even worse with iterators, because now it depended on the compiler&#x27;s ability to inline its implementation of postfix ++, and then prove that all the copies produced by that implementation have no side effects to optimize it to the same degree as prefix ++ could. Depending on the type of the underlying value, this may not even be possible in general.<p>The other reason is that all other unary operators in C are prefix rather than postfix, and mixing unary prefix with unary postfix in a single expression produces code that is easy to misunderstand. E.g. *p++ is *(p++), not (*p)++, even though the latter feels more natural, reading it left-to-right as usual. OTOH *++p vs ++*p is unambiguous.</div><br/><div id="41851765" class="c"><input type="checkbox" id="c-41851765" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851650">parent</a><span>|</span><a href="#41854531">next</a><span>|</span><label class="collapse" for="c-41851765">[-]</label><label class="expand" for="c-41851765">[1 more]</label></div><br/><div class="children"><div class="content">K&amp;R seems to use pre-increment early on, then post-increment consistently (or a lot, anyway, I haven&#x27;t done a thorough check) after chapter 3, in situations where either would do. In fact, after introducing post-increment at 2.8.</div><br/></div></div><div id="41854531" class="c"><input type="checkbox" id="c-41854531" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851650">parent</a><span>|</span><a href="#41851765">prev</a><span>|</span><a href="#41853498">next</a><span>|</span><label class="collapse" for="c-41854531">[-]</label><label class="expand" for="c-41854531">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It should be ++C because with C++ the value you get from the expression is the old one.<p>You get it!</div><br/></div></div></div></div><div id="41853498" class="c"><input type="checkbox" id="c-41853498" checked=""/><div class="controls bullet"><span class="by">wpollock</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851328">parent</a><span>|</span><a href="#41851650">prev</a><span>|</span><a href="#41851427">next</a><span>|</span><label class="collapse" for="c-41853498">[-]</label><label class="expand" for="c-41853498">[3 more]</label></div><br/><div class="children"><div class="content">The PDP-11 that C originally targeted had address modes to support the stack.  Pre-increment and post-decrement therefore did not require a separate instruction; they were free.  After  the PDP-11 went the way of the dodo, both forms took a machine cycle so it (mostly) became a stylistic issue. (The two operators have different semantics,  but the trend to avoid side-effects in expressions means that both are most often used in a single expression statement like &quot;++x;&quot; or &quot;x++;&quot;, so it comes down to your preferred style.)</div><br/><div id="41855124" class="c"><input type="checkbox" id="c-41855124" checked=""/><div class="controls bullet"><span class="by">zabzonk</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41853498">parent</a><span>|</span><a href="#41851427">next</a><span>|</span><label class="collapse" for="c-41855124">[-]</label><label class="expand" for="c-41855124">[2 more]</label></div><br/><div class="children"><div class="content">Please explain what you mean by &quot;a separate instruction&quot;.</div><br/><div id="41855741" class="c"><input type="checkbox" id="c-41855741" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41855124">parent</a><span>|</span><a href="#41851427">next</a><span>|</span><label class="collapse" for="c-41855741">[-]</label><label class="expand" for="c-41855741">[1 more]</label></div><br/><div class="children"><div class="content">Some idiomatic C code to copy a string (I&#x27;m not saying this is good C code, but it&#x27;s just an example):<p><pre><code>    while(*d++ = *s++)
      ;
 </code></pre>
On the Motorola 68000 (based somewhat on the PDP-11) the code would look like:<p><pre><code>    loop:       move.b  (a0)+,d0
                move.b  d0,(a1)+
                bne     loop
 </code></pre>
while on the x86 line, it would be:<p><pre><code>    loop:       mov     al,[rsi]
                mov     [rdi],al
                inc     rsi     ; extra instruction!
                inc     rdi     ; extra instruction!
                cmp     al,0
                jne     loop
 </code></pre>
Yes, there are better ways to write that code for both the 68K and x86, but I hope this gets the point across.</div><br/></div></div></div></div></div></div><div id="41851427" class="c"><input type="checkbox" id="c-41851427" checked=""/><div class="controls bullet"><span class="by">jejdjdbd</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851328">parent</a><span>|</span><a href="#41853498">prev</a><span>|</span><a href="#41851557">next</a><span>|</span><label class="collapse" for="c-41851427">[-]</label><label class="expand" for="c-41851427">[9 more]</label></div><br/><div class="children"><div class="content">Why would you use post increment by default? The semantics are very particular.<p>Only on very rare occasions I need post increment semantics.<p>And in those cases I prefer to use a temporary to make the intent more clear</div><br/><div id="41856255" class="c"><input type="checkbox" id="c-41856255" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851427">parent</a><span>|</span><a href="#41851532">next</a><span>|</span><label class="collapse" for="c-41856255">[-]</label><label class="expand" for="c-41856255">[1 more]</label></div><br/><div class="children"><div class="content">I rarely use pre-increment tbh, but post-increment all the time for array indices (since typically the array should be indexed with the value before the increment happens).<p>If the pre- or post-increment behaviour isn&#x27;t actually needed, I prefer `x += 1` though.</div><br/></div></div><div id="41851532" class="c"><input type="checkbox" id="c-41851532" checked=""/><div class="controls bullet"><span class="by">card_zero</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851427">parent</a><span>|</span><a href="#41856255">prev</a><span>|</span><a href="#41852965">next</a><span>|</span><label class="collapse" for="c-41851532">[-]</label><label class="expand" for="c-41851532">[6 more]</label></div><br/><div class="children"><div class="content">People seem to mostly write a typical for loop ending with ; ++i){<p>But I write ; i++){ and seeing it the other way round throws me off for a minute, because I think, as you put it, why would you use those very particular semantics?<p>But I guess this is only a semantic argument.</div><br/><div id="41852277" class="c"><input type="checkbox" id="c-41852277" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851532">parent</a><span>|</span><a href="#41851721">next</a><span>|</span><label class="collapse" for="c-41852277">[-]</label><label class="expand" for="c-41852277">[1 more]</label></div><br/><div class="children"><div class="content">In C++ the semantics can differ, in that copying an object for post-increment might require a memory allocation internally (for example in the case of a BigInt class), which may fail and throw an exception. For consistency, using pre-increment by default and unless you <i>really</i> need post-increment, is a good habit.</div><br/></div></div><div id="41851721" class="c"><input type="checkbox" id="c-41851721" checked=""/><div class="controls bullet"><span class="by">johannes1234321</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851532">parent</a><span>|</span><a href="#41852277">prev</a><span>|</span><a href="#41852595">next</a><span>|</span><label class="collapse" for="c-41851721">[-]</label><label class="expand" for="c-41851721">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why would you use those very particular semantics?<p>The difference is that i++ has to keep a copy to the original around as the return value is the pre-increment value, while with ++i that isn&#x27;t needed as the resulting value is being returned.<p>In the for loop that shouldn&#x27;t matter as a) for an integer it is essentially for free (it is just reordering when the relevant register is set) and b) that value is hopefully optimized out anyways by the compiler, however as there are cases where it matters some people prefer the ++i style, some just think it looks better.</div><br/></div></div><div id="41852595" class="c"><input type="checkbox" id="c-41852595" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851532">parent</a><span>|</span><a href="#41851721">prev</a><span>|</span><a href="#41852443">next</a><span>|</span><label class="collapse" for="c-41852595">[-]</label><label class="expand" for="c-41852595">[1 more]</label></div><br/><div class="children"><div class="content">It makes no difference if the increment is done on an int, but it can make a different if your `i` is some object with its own ++ operator.</div><br/></div></div><div id="41852443" class="c"><input type="checkbox" id="c-41852443" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851532">parent</a><span>|</span><a href="#41852595">prev</a><span>|</span><a href="#41852965">next</a><span>|</span><label class="collapse" for="c-41852443">[-]</label><label class="expand" for="c-41852443">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen either style, but it the argument about which is proper is pointless. Any modern compiler will optimize either equally well, unless you&#x27;re doing something that actually depends on the order of the increment.</div><br/><div id="41852642" class="c"><input type="checkbox" id="c-41852642" checked=""/><div class="controls bullet"><span class="by">kanbankaren</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852443">parent</a><span>|</span><a href="#41852965">next</a><span>|</span><label class="collapse" for="c-41852642">[-]</label><label class="expand" for="c-41852642">[1 more]</label></div><br/><div class="children"><div class="content">No, for fundamental datatypes pre&#x2F;post-increment doesn&#x27;t matter, but for classes that overload those operators, the postfix form creates a temporary object hence people write<p>for(auto it = begin(v); it != end(v); ++it)</div><br/></div></div></div></div></div></div><div id="41852965" class="c"><input type="checkbox" id="c-41852965" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851427">parent</a><span>|</span><a href="#41851532">prev</a><span>|</span><a href="#41851557">next</a><span>|</span><label class="collapse" for="c-41852965">[-]</label><label class="expand" for="c-41852965">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re used to the idiom, the intent couldn&#x27;t be clearer.<p>I miss it when switching between C&#x2F;++ and other languages.</div><br/></div></div></div></div><div id="41851557" class="c"><input type="checkbox" id="c-41851557" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851328">parent</a><span>|</span><a href="#41851427">prev</a><span>|</span><a href="#41854897">next</a><span>|</span><label class="collapse" for="c-41851557">[-]</label><label class="expand" for="c-41851557">[6 more]</label></div><br/><div class="children"><div class="content">Why use this operator? Like most C and C++ features the main reason tends to be showing off, you learned a thing (in this case that there are four extra operators here) and so you show off by using it even if it doesn&#x27;t make the software easier to understand.<p>This is not one of those beginner -&gt; journeyman -&gt; expert cycles where coincidentally the way you wrote it as a beginner is identical to how an expert writes it but for a very different reason. I&#x27;d expect experts are very comfortable writing either { x = k; k += 1; } or { k += 1; x = k; } depending on which they meant and don&#x27;t feel an itch to re-write these as { x = k++; } and { x = ++k; } respectively.<p>I&#x27;m slightly surprised none of the joke languages add equally frivolous operators. a%% to set a to the remainder after dividing a by 10, or b** to set b as two to the power b or some other silliness.</div><br/><div id="41854621" class="c"><input type="checkbox" id="c-41854621" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851557">parent</a><span>|</span><a href="#41852158">next</a><span>|</span><label class="collapse" for="c-41854621">[-]</label><label class="expand" for="c-41854621">[2 more]</label></div><br/><div class="children"><div class="content">They can be useful when adding things to an array in a loop. A trivial example which removes a character from a null terminated string:<p><pre><code>  void remove_char(char *s, char c) {
    size_t i, j;

    for (i = j = 0; s[i] != &#x27;\0&#x27;; i++)
      if (s[i] != c)
        s[j++] = c;
    s[j] = &#x27;\0&#x27;;
  }

</code></pre>
This might be better expressed with a higher order filter function, but C is too low level for things like that.<p>There are also idioms for stack manipulation using them: &quot;stack[sp++] = pushed&quot; and &quot;popped = stack[--sp]&quot;.<p>C code does a lot of incrementing and decrementing by one, and so having dedicated syntax for it is convenient.</div><br/><div id="41855882" class="c"><input type="checkbox" id="c-41855882" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41854621">parent</a><span>|</span><a href="#41852158">next</a><span>|</span><label class="collapse" for="c-41855882">[-]</label><label class="expand" for="c-41855882">[1 more]</label></div><br/><div class="children"><div class="content">Note that in your example there appear to be three distinct meanings:<p>1. prefix incr&#x2F;decr precedence: &quot;stack[--sp]&quot;<p>2. postfix incr&#x2F;decr precedence: &quot;s[j++]&quot;<p>3. i have no particular preference for the precedence and am just using a shorthand I inherited from my ancestors whose use cases are no longer relevant to me: &quot;i++&quot; in your for loop<p>My rank speculation is that C programmers get in a habit of #3 and then forget to consider precedence in an expression where it matters.<p>In any case, it would be interesting to do a scan of github to see how often prefix and suffix incr&#x2F;decr had to get switched up in a bugfix patch.</div><br/></div></div></div></div><div id="41852158" class="c"><input type="checkbox" id="c-41852158" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851557">parent</a><span>|</span><a href="#41854621">prev</a><span>|</span><a href="#41851920">next</a><span>|</span><label class="collapse" for="c-41852158">[-]</label><label class="expand" for="c-41852158">[2 more]</label></div><br/><div class="children"><div class="content">The idiomatic<p><pre><code>    void strcpy(char *s, char *t)
    {
        while (*s++ = *t++)
            ;
    }
</code></pre>
(straight from K&amp;R) wouldn’t work without it.</div><br/><div id="41853132" class="c"><input type="checkbox" id="c-41853132" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41852158">parent</a><span>|</span><a href="#41851920">next</a><span>|</span><label class="collapse" for="c-41853132">[-]</label><label class="expand" for="c-41853132">[1 more]</label></div><br/><div class="children"><div class="content">Which many people find unreadable compared to other versions.</div><br/></div></div></div></div><div id="41851920" class="c"><input type="checkbox" id="c-41851920" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#41850897">root</a><span>|</span><a href="#41851557">parent</a><span>|</span><a href="#41852158">prev</a><span>|</span><a href="#41854897">next</a><span>|</span><label class="collapse" for="c-41851920">[-]</label><label class="expand" for="c-41851920">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more useful for pointers than for values, IMO</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41854897" class="c"><input type="checkbox" id="c-41854897" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#41850897">prev</a><span>|</span><a href="#41855381">next</a><span>|</span><label class="collapse" for="c-41854897">[-]</label><label class="expand" for="c-41854897">[11 more]</label></div><br/><div class="children"><div class="content">Personally this[1] just makes C much more complicated for me, and I choose C when I want simplicity. If I want complicated, I would just pick C++ which I typically would never want. I would just pick Go (or Elixir if I want a server).<p>&quot;_BitInt(N)&quot; is also ugly, reminds me of &quot;_Bool&quot; which is thankfully &quot;bool&quot; now.<p>[1] guard, defer, auto, constexpr, nullptr (what is wrong with NULL?), etc. On top of that &quot;constexpr&quot; and &quot;nullptr&quot; just reeks of C++.<p>That said, Modern C is an incredible book, I have been using it for C99 (which I intend to continue sticking to).</div><br/><div id="41856362" class="c"><input type="checkbox" id="c-41856362" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41854897">parent</a><span>|</span><a href="#41855553">next</a><span>|</span><label class="collapse" for="c-41856362">[-]</label><label class="expand" for="c-41856362">[1 more]</label></div><br/><div class="children"><div class="content">auto is mostly useful when tinkering with type-generic macros, but shouldn&#x27;t be used in regular code (e.g. please no &#x27;almost always auto&#x27; madness like it was popular in the C++ world for a little while). Unfortunately there are also slight differences between compilers (IIRC Clang implements a C++ style auto, while GCC implements a C style auto, which has subtle differences for &#x27;auto pointers&#x27; - not sure if those differences have been fixed in the meantime).<p>_BitInt(N) isn&#x27;t typically used directly but typedef&#x27;ed to the width you need, e.g.<p><pre><code>    typedef _BitInt(2) u2;
</code></pre>
The &#x27;ugly&#x27; _B syntax is needed because the combination of underscore followed by a capital letter is reserved in the C standard to avoid collisions with existing code for every little thing added to the language (same reason why it was called _Bool).<p>AFAIK defer didn&#x27;t actually make it into C23?<p>I&#x27;m also more on the conservative side when it comes to adding features to the C standard, but IMHO each of the C23 additions makes sense.</div><br/></div></div><div id="41855553" class="c"><input type="checkbox" id="c-41855553" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#41854897">parent</a><span>|</span><a href="#41856362">prev</a><span>|</span><a href="#41855182">next</a><span>|</span><label class="collapse" for="c-41855553">[-]</label><label class="expand" for="c-41855553">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what is wrong with NULL?<p>One of the few advantages of ISO standardization is you can just read the associated papers to answer questions like this: <a href="https:&#x2F;&#x2F;wg21.link&#x2F;p2312" rel="nofollow">https:&#x2F;&#x2F;wg21.link&#x2F;p2312</a><p>The quick bullet points:<p>* Surprises when invoking a type-generic macro with a NULL argument.<p>* Conditional expressions such as (1 ? 0 : NULL) and (1 ? 1 : NULL) have different status depending how NULL is defined<p>* A NULL argument that is passed to a va_arg function that expects a pointer can have severe consequences. On many architectures nowadays int and void* have different size, and so if NULL is just 0, a wrongly sized argument is passed to the function.</div><br/></div></div><div id="41855214" class="c"><input type="checkbox" id="c-41855214" checked=""/><div class="controls bullet"><span class="by">mmphosis</span><span>|</span><a href="#41854897">parent</a><span>|</span><a href="#41855182">prev</a><span>|</span><a href="#41854987">next</a><span>|</span><label class="collapse" for="c-41855214">[-]</label><label class="expand" for="c-41855214">[2 more]</label></div><br/><div class="children"><div class="content">NULL is not wrong. The things that I will do with NULL are</div><br/></div></div><div id="41854987" class="c"><input type="checkbox" id="c-41854987" checked=""/><div class="controls bullet"><span class="by">cornstalks</span><span>|</span><a href="#41854897">parent</a><span>|</span><a href="#41855214">prev</a><span>|</span><a href="#41855526">next</a><span>|</span><label class="collapse" for="c-41854987">[-]</label><label class="expand" for="c-41854987">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>what is wrong with NULL?</i><p>For starters, you have to #include a header to use it.</div><br/><div id="41855143" class="c"><input type="checkbox" id="c-41855143" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#41854897">root</a><span>|</span><a href="#41854987">parent</a><span>|</span><a href="#41855812">next</a><span>|</span><label class="collapse" for="c-41855143">[-]</label><label class="expand" for="c-41855143">[1 more]</label></div><br/><div class="children"><div class="content">And it avoids the NULL == 0 ambiguity, allowing for better type checking.</div><br/></div></div><div id="41855812" class="c"><input type="checkbox" id="c-41855812" checked=""/><div class="controls bullet"><span class="by">johnisgood</span><span>|</span><a href="#41854897">root</a><span>|</span><a href="#41854987">parent</a><span>|</span><a href="#41855143">prev</a><span>|</span><a href="#41855526">next</a><span>|</span><label class="collapse" for="c-41855812">[-]</label><label class="expand" for="c-41855812">[2 more]</label></div><br/><div class="children"><div class="content">Well, I always include stdio.h which includes stddef.h that defines NULL as (void *)0.</div><br/><div id="41855960" class="c"><input type="checkbox" id="c-41855960" checked=""/><div class="controls bullet"><span class="by">dhhfss</span><span>|</span><a href="#41854897">root</a><span>|</span><a href="#41855812">parent</a><span>|</span><a href="#41855526">next</a><span>|</span><label class="collapse" for="c-41855960">[-]</label><label class="expand" for="c-41855960">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, hardly any source files require studio.h<p>stddef.h on the other hand is required by most to get size_t</div><br/></div></div></div></div></div></div></div></div><div id="41855381" class="c"><input type="checkbox" id="c-41855381" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#41854897">prev</a><span>|</span><a href="#41855279">next</a><span>|</span><label class="collapse" for="c-41855381">[-]</label><label class="expand" for="c-41855381">[1 more]</label></div><br/><div class="children"><div class="content">I kind of like some of Metaware&#x27;s high C extensions.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41647843">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41647843</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38938402">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38938402</a></div><br/></div></div><div id="41855279" class="c"><input type="checkbox" id="c-41855279" checked=""/><div class="controls bullet"><span class="by">israrkhan</span><span>|</span><a href="#41855381">prev</a><span>|</span><a href="#41851383">next</a><span>|</span><label class="collapse" for="c-41855279">[-]</label><label class="expand" for="c-41855279">[11 more]</label></div><br/><div class="children"><div class="content">Most important aspect of C is its portability. From small microcontrollers to almost any computing platform. I doubt that any new version of C will see that much adoption.<p>If I want to live on cutting edge  I would rather use C++2x or Rust rather than C.<p>Am I missing something? What benefit this supposedly modern C offers?</div><br/><div id="41855595" class="c"><input type="checkbox" id="c-41855595" checked=""/><div class="controls bullet"><span class="by">doe_eyes</span><span>|</span><a href="#41855279">parent</a><span>|</span><a href="#41856401">next</a><span>|</span><label class="collapse" for="c-41855595">[-]</label><label class="expand" for="c-41855595">[1 more]</label></div><br/><div class="children"><div class="content">Of course they will, just like they did in the past with C11, GNU extensions, or some of the individual features that are now rolled into C23. For example, the 0b notation for binary numbers is widely used in the MCU world.<p>The microcontroller toolchains are generally built on top of GCC, so they get the features for free. There are some proprietary C compilers that are chronically lagging behind, but they are not nearly as important as they used to be two decades ago.</div><br/></div></div><div id="41856401" class="c"><input type="checkbox" id="c-41856401" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41855279">parent</a><span>|</span><a href="#41855595">prev</a><span>|</span><a href="#41855343">next</a><span>|</span><label class="collapse" for="c-41856401">[-]</label><label class="expand" for="c-41856401">[2 more]</label></div><br/><div class="children"><div class="content">One advantage of writing C code is that you don&#x27;t have annoying discussions about what idiomatic code is supposed to look like, and what language subset is the right one ;)<p>For the cutting edge I would recommend Zig btw, much less language complexity than both modern C++ and Rust.<p>One good but less visible side effect of C23 is that it harmonizes more syntax with C++ (like ... = {} vs {0}) which makes it a bit less annoying for us C library maintainers to support the people how want to compile their C code with a C++ compiler.</div><br/><div id="41856506" class="c"><input type="checkbox" id="c-41856506" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41855279">root</a><span>|</span><a href="#41856401">parent</a><span>|</span><a href="#41855343">next</a><span>|</span><label class="collapse" for="c-41856506">[-]</label><label class="expand" for="c-41856506">[1 more]</label></div><br/><div class="children"><div class="content">There is enough material in C, and related compiler extensions, to have similar discussions, starting from where to place brackets.</div><br/></div></div></div></div><div id="41855343" class="c"><input type="checkbox" id="c-41855343" checked=""/><div class="controls bullet"><span class="by">vitaminka</span><span>|</span><a href="#41855279">parent</a><span>|</span><a href="#41856401">prev</a><span>|</span><a href="#41855410">next</a><span>|</span><label class="collapse" for="c-41855343">[-]</label><label class="expand" for="c-41855343">[5 more]</label></div><br/><div class="children"><div class="content">these features will eventually trickle down into the mainstream, kind of like C11 is doing at the moment<p>also, unless you&#x27;re targeting embedded or a very wide set of architectures, there&#x27;s no reason why you couldn&#x27;t start using C23 today</div><br/><div id="41855853" class="c"><input type="checkbox" id="c-41855853" checked=""/><div class="controls bullet"><span class="by">bboygravity</span><span>|</span><a href="#41855279">root</a><span>|</span><a href="#41855343">parent</a><span>|</span><a href="#41855410">next</a><span>|</span><label class="collapse" for="c-41855853">[-]</label><label class="expand" for="c-41855853">[4 more]</label></div><br/><div class="children"><div class="content">Or in other words, for embedded and existing code: most use c99, some use c11 and nobody uses c23 until at least 10 years from now.</div><br/><div id="41855978" class="c"><input type="checkbox" id="c-41855978" checked=""/><div class="controls bullet"><span class="by">dhhfss</span><span>|</span><a href="#41855279">root</a><span>|</span><a href="#41855853">parent</a><span>|</span><a href="#41855982">next</a><span>|</span><label class="collapse" for="c-41855978">[-]</label><label class="expand" for="c-41855978">[2 more]</label></div><br/><div class="children"><div class="content">This depends on the platform. Many embedded systems are based on arm these days and have modern toolchains available.<p>I cannot remember the last time I saw C99 used. C codebases generally use C11 or C17, and C++ code bases use C++20</div><br/><div id="41856523" class="c"><input type="checkbox" id="c-41856523" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41855279">root</a><span>|</span><a href="#41855978">parent</a><span>|</span><a href="#41855982">next</a><span>|</span><label class="collapse" for="c-41856523">[-]</label><label class="expand" for="c-41856523">[1 more]</label></div><br/><div class="children"><div class="content">Unless you can vouch for the C++ compiler, the best C++ portable code can offer today is C++17.<p>Also 8 and 16 bit embedded toolchains are certainly not on C11 &#x2F; C17, they can hardly afford full C89.</div><br/></div></div></div></div><div id="41855982" class="c"><input type="checkbox" id="c-41855982" checked=""/><div class="controls bullet"><span class="by">vitaminka</span><span>|</span><a href="#41855279">root</a><span>|</span><a href="#41855853">parent</a><span>|</span><a href="#41855978">prev</a><span>|</span><a href="#41855410">next</a><span>|</span><label class="collapse" for="c-41855982">[-]</label><label class="expand" for="c-41855982">[1 more]</label></div><br/><div class="children"><div class="content">most non-embedded and non-legacy codebases could use c23, that&#x27;s not an insignificant set</div><br/></div></div></div></div></div></div><div id="41855880" class="c"><input type="checkbox" id="c-41855880" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#41855279">parent</a><span>|</span><a href="#41855410">prev</a><span>|</span><a href="#41851383">next</a><span>|</span><label class="collapse" for="c-41855880">[-]</label><label class="expand" for="c-41855880">[1 more]</label></div><br/><div class="children"><div class="content">The `thread_local` specifier is used on a few microcontroller platforms already, but would be absolutely illegal in C11 and before to use. However, it vastly simplifies memory management in a threaded context.<p>Why would I rather step into the world of C++ just to deal with that?</div><br/></div></div></div></div><div id="41851383" class="c"><input type="checkbox" id="c-41851383" checked=""/><div class="controls bullet"><span class="by">zkirill</span><span>|</span><a href="#41855279">prev</a><span>|</span><a href="#41851044">next</a><span>|</span><label class="collapse" for="c-41851383">[-]</label><label class="expand" for="c-41851383">[3 more]</label></div><br/><div class="children"><div class="content">I was going to ask if there is a good list of C books and then answered my own question. It categorizes _Modern C_ as Intermediate level.<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;562303&#x2F;the-definitive-c-book-guide-and-list" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;562303&#x2F;the-definitive-c-...</a></div><br/><div id="41853777" class="c"><input type="checkbox" id="c-41853777" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#41851383">parent</a><span>|</span><a href="#41856208">next</a><span>|</span><label class="collapse" for="c-41853777">[-]</label><label class="expand" for="c-41853777">[1 more]</label></div><br/><div class="children"><div class="content">Note that this is not a complete list, fwiw. For example, I doesn&#x27;t include &quot;Effective C.&quot; [1].<p>I like &quot;Effective C&quot; over &quot;Modern C&quot; because it&#x27;s more engaging ... &quot;Modern C&quot; is super rigorous and feels a bit like reading an annotated spec of the language, which is what an expert may need, but makes for a dull read for a casual C user like me.<p>--<p>1: <a href="https:&#x2F;&#x2F;nostarch.com&#x2F;effective-c-2nd-edition" rel="nofollow">https:&#x2F;&#x2F;nostarch.com&#x2F;effective-c-2nd-edition</a></div><br/></div></div><div id="41856208" class="c"><input type="checkbox" id="c-41856208" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#41851383">parent</a><span>|</span><a href="#41853777">prev</a><span>|</span><a href="#41851044">next</a><span>|</span><label class="collapse" for="c-41856208">[-]</label><label class="expand" for="c-41856208">[1 more]</label></div><br/><div class="children"><div class="content">Also see <i>Fluent C: Principles, Practices and Patterns</i> by Christopher Preschern.</div><br/></div></div></div></div><div id="41851044" class="c"><input type="checkbox" id="c-41851044" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#41851383">prev</a><span>|</span><a href="#41850998">next</a><span>|</span><label class="collapse" for="c-41851044">[-]</label><label class="expand" for="c-41851044">[6 more]</label></div><br/><div class="children"><div class="content">Table of contents in the sidebar doesn&#x27;t work properly for me when I click on an entry (in macOS Preview).</div><br/><div id="41851101" class="c"><input type="checkbox" id="c-41851101" checked=""/><div class="controls bullet"><span class="by">bwidlar</span><span>|</span><a href="#41851044">parent</a><span>|</span><a href="#41851177">next</a><span>|</span><label class="collapse" for="c-41851101">[-]</label><label class="expand" for="c-41851101">[2 more]</label></div><br/><div class="children"><div class="content">I just test some links in the table of content, works fine for me. Using zathura pdf reader.</div><br/><div id="41851491" class="c"><input type="checkbox" id="c-41851491" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#41851044">root</a><span>|</span><a href="#41851101">parent</a><span>|</span><a href="#41851177">next</a><span>|</span><label class="collapse" for="c-41851491">[-]</label><label class="expand" for="c-41851491">[1 more]</label></div><br/><div class="children"><div class="content">Also works in Adobe and Firefox, but doesn&#x27;t work in Chrome and Edge.</div><br/></div></div></div></div><div id="41851177" class="c"><input type="checkbox" id="c-41851177" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41851044">parent</a><span>|</span><a href="#41851101">prev</a><span>|</span><a href="#41851448">next</a><span>|</span><label class="collapse" for="c-41851177">[-]</label><label class="expand" for="c-41851177">[1 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t work for me either... but I will not dismiss the book because of that.</div><br/></div></div><div id="41851448" class="c"><input type="checkbox" id="c-41851448" checked=""/><div class="controls bullet"><span class="by">channel_t</span><span>|</span><a href="#41851044">parent</a><span>|</span><a href="#41851177">prev</a><span>|</span><a href="#41851429">next</a><span>|</span><label class="collapse" for="c-41851448">[-]</label><label class="expand" for="c-41851448">[1 more]</label></div><br/><div class="children"><div class="content">Table of contents is definitely broken right now.</div><br/></div></div><div id="41851429" class="c"><input type="checkbox" id="c-41851429" checked=""/><div class="controls bullet"><span class="by">soegaard</span><span>|</span><a href="#41851044">parent</a><span>|</span><a href="#41851448">prev</a><span>|</span><a href="#41850998">next</a><span>|</span><label class="collapse" for="c-41851429">[-]</label><label class="expand" for="c-41851429">[1 more]</label></div><br/><div class="children"><div class="content">Same here.</div><br/></div></div></div></div><div id="41850998" class="c"><input type="checkbox" id="c-41850998" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#41851044">prev</a><span>|</span><a href="#41856509">next</a><span>|</span><label class="collapse" for="c-41850998">[-]</label><label class="expand" for="c-41850998">[1 more]</label></div><br/><div class="children"><div class="content">So happy that we still get the dinosaur mascots!  This is a good book.</div><br/></div></div><div id="41856509" class="c"><input type="checkbox" id="c-41856509" checked=""/><div class="controls bullet"><span class="by">tenderfault</span><span>|</span><a href="#41850998">prev</a><span>|</span><a href="#41852979">next</a><span>|</span><label class="collapse" for="c-41856509">[-]</label><label class="expand" for="c-41856509">[2 more]</label></div><br/><div class="children"><div class="content">any chance of getting a responsive TOC in any pdf reader whatsoever?</div><br/><div id="41856542" class="c"><input type="checkbox" id="c-41856542" checked=""/><div class="controls bullet"><span class="by">kamaal</span><span>|</span><a href="#41856509">parent</a><span>|</span><a href="#41852979">next</a><span>|</span><label class="collapse" for="c-41856542">[-]</label><label class="expand" for="c-41856542">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.manning.com&#x2F;books&#x2F;modern-c-third-edition" rel="nofollow">https:&#x2F;&#x2F;www.manning.com&#x2F;books&#x2F;modern-c-third-edition</a></div><br/></div></div></div></div><div id="41852979" class="c"><input type="checkbox" id="c-41852979" checked=""/><div class="controls bullet"><span class="by">nimish</span><span>|</span><a href="#41856509">prev</a><span>|</span><a href="#41852928">next</a><span>|</span><label class="collapse" for="c-41852979">[-]</label><label class="expand" for="c-41852979">[1 more]</label></div><br/><div class="children"><div class="content">My kingdom for fully specified, well defined portable bitfields.</div><br/></div></div><div id="41852928" class="c"><input type="checkbox" id="c-41852928" checked=""/><div class="controls bullet"><span class="by">russellbeattie</span><span>|</span><a href="#41852979">prev</a><span>|</span><a href="#41853042">next</a><span>|</span><label class="collapse" for="c-41852928">[-]</label><label class="expand" for="c-41852928">[2 more]</label></div><br/><div class="children"><div class="content">Wow, the use of attributes like [[__unsequenced__]], [[maybe_unused]] and [[noreturn]] throughout the book is really awful. It seems pretty pedantic of the author to litter all the code examples with something that is mostly optional. For a second I wondered if C23 <i>required</i> them.</div><br/><div id="41854373" class="c"><input type="checkbox" id="c-41854373" checked=""/><div class="controls bullet"><span class="by">amomchilov</span><span>|</span><a href="#41852928">parent</a><span>|</span><a href="#41853042">next</a><span>|</span><label class="collapse" for="c-41854373">[-]</label><label class="expand" for="c-41854373">[1 more]</label></div><br/><div class="children"><div class="content">Such is the issue with bad defaults. Opting into the sensible thing makes most of your code ugly, instead of just the exceptions.</div><br/></div></div></div></div><div id="41853042" class="c"><input type="checkbox" id="c-41853042" checked=""/><div class="controls bullet"><span class="by">leonheld</span><span>|</span><a href="#41852928">prev</a><span>|</span><a href="#41850914">next</a><span>|</span><label class="collapse" for="c-41853042">[-]</label><label class="expand" for="c-41853042">[1 more]</label></div><br/><div class="children"><div class="content">One of my favorite books ever.</div><br/></div></div><div id="41850914" class="c"><input type="checkbox" id="c-41850914" checked=""/><div class="controls bullet"><span class="by">bitbasher</span><span>|</span><a href="#41853042">prev</a><span>|</span><a href="#41851601">next</a><span>|</span><label class="collapse" for="c-41850914">[-]</label><label class="expand" for="c-41850914">[13 more]</label></div><br/><div class="children"><div class="content">Really looking forward to #embed, once the compilers catch up. Until then, Golang.</div><br/><div id="41851074" class="c"><input type="checkbox" id="c-41851074" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#41850914">parent</a><span>|</span><a href="#41851215">next</a><span>|</span><label class="collapse" for="c-41851074">[-]</label><label class="expand" for="c-41851074">[5 more]</label></div><br/><div class="children"><div class="content">This is not how C standards work.  If it appears in the standard, it means that it is already implemented in some compilers (in that case, at least in gcc and clang).</div><br/><div id="41852554" class="c"><input type="checkbox" id="c-41852554" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41851074">parent</a><span>|</span><a href="#41851215">next</a><span>|</span><label class="collapse" for="c-41852554">[-]</label><label class="expand" for="c-41852554">[4 more]</label></div><br/><div class="children"><div class="content">That isn&#x27;t really how it goes, that is how it used to be up to C99.</div><br/><div id="41852590" class="c"><input type="checkbox" id="c-41852590" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41852554">parent</a><span>|</span><a href="#41851215">next</a><span>|</span><label class="collapse" for="c-41852590">[-]</label><label class="expand" for="c-41852590">[3 more]</label></div><br/><div class="children"><div class="content">Thanks for the correction!  Do you know if there is a document from the standards body explaining the change in philosophy?</div><br/><div id="41853692" class="c"><input type="checkbox" id="c-41853692" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41852590">parent</a><span>|</span><a href="#41853226">next</a><span>|</span><label class="collapse" for="c-41853692">[-]</label><label class="expand" for="c-41853692">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a nuisance to implement the thing you want to add to the standard yourself. It&#x27;s easier to ship it in the language and then complain at compiler devs that they&#x27;re running behind the edge of progress.<p>This interacts in the obvious way with refusing to correct mistakes after the fact for fear of breaking user code.<p>I don&#x27;t believe anyone has written a paper along the lines of &quot;let&#x27;s not bother with the existing practice part anymore&quot;, it&#x27;s more an emergent feature of people following local incentive structures.</div><br/></div></div><div id="41853226" class="c"><input type="checkbox" id="c-41853226" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41852590">parent</a><span>|</span><a href="#41853692">prev</a><span>|</span><a href="#41851215">next</a><span>|</span><label class="collapse" for="c-41853226">[-]</label><label class="expand" for="c-41853226">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard something along the lines of &quot;the standard is to define facilities that will be used in most programs, and to codify widespread existing practice.&quot;   That was in the context of &quot;I don&#x27;t like this proposed feature,&quot; though. This was for C++, not C.<p>A lot of stuff in the C++11 standard library was based on widespread use of Boost. Since then, I don&#x27;t know. Also, were things like templates and lambdas implemented as compiler extensions before standardization? I don&#x27;t know, but I doubt it. Maybe &quot;we&#x27;re a committee of people who will decide on a thing and we hope you like it&quot; was always the norm in many ways.</div><br/></div></div></div></div></div></div></div></div><div id="41851215" class="c"><input type="checkbox" id="c-41851215" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#41850914">parent</a><span>|</span><a href="#41851074">prev</a><span>|</span><a href="#41851110">next</a><span>|</span><label class="collapse" for="c-41851215">[-]</label><label class="expand" for="c-41851215">[1 more]</label></div><br/><div class="children"><div class="content">I do that with ld and objcopy:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;58815959&#x2F;include-binary-data-files-into-compiled-binary-without-converting-to-hex-arrays" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;58815959&#x2F;include-binary-...</a></div><br/></div></div><div id="41851110" class="c"><input type="checkbox" id="c-41851110" checked=""/><div class="controls bullet"><span class="by">jpcfl</span><span>|</span><a href="#41850914">parent</a><span>|</span><a href="#41851215">prev</a><span>|</span><a href="#41851080">next</a><span>|</span><label class="collapse" for="c-41851110">[-]</label><label class="expand" for="c-41851110">[2 more]</label></div><br/><div class="children"><div class="content">Or<p><pre><code>    xxd --include &lt;file&gt;
</code></pre>
:)</div><br/><div id="41852569" class="c"><input type="checkbox" id="c-41852569" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41851110">parent</a><span>|</span><a href="#41851080">next</a><span>|</span><label class="collapse" for="c-41852569">[-]</label><label class="expand" for="c-41852569">[1 more]</label></div><br/><div class="children"><div class="content">The anti-Rust approach!</div><br/></div></div></div></div><div id="41851080" class="c"><input type="checkbox" id="c-41851080" checked=""/><div class="controls bullet"><span class="by">rfl890</span><span>|</span><a href="#41850914">parent</a><span>|</span><a href="#41851110">prev</a><span>|</span><a href="#41851883">next</a><span>|</span><label class="collapse" for="c-41851080">[-]</label><label class="expand" for="c-41851080">[1 more]</label></div><br/><div class="children"><div class="content">Clang 19 has it.</div><br/></div></div><div id="41851883" class="c"><input type="checkbox" id="c-41851883" checked=""/><div class="controls bullet"><span class="by">accelbred</span><span>|</span><a href="#41850914">parent</a><span>|</span><a href="#41851080">prev</a><span>|</span><a href="#41851601">next</a><span>|</span><label class="collapse" for="c-41851883">[-]</label><label class="expand" for="c-41851883">[3 more]</label></div><br/><div class="children"><div class="content">I end up using a .S asm file with .incbin directives to embed files.<p>#embed would be much nicer</div><br/><div id="41853705" class="c"><input type="checkbox" id="c-41853705" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41851883">parent</a><span>|</span><a href="#41851601">next</a><span>|</span><label class="collapse" for="c-41853705">[-]</label><label class="expand" for="c-41853705">[2 more]</label></div><br/><div class="children"><div class="content">Incbin works just fine from inline asm fwiw</div><br/><div id="41856465" class="c"><input type="checkbox" id="c-41856465" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#41850914">root</a><span>|</span><a href="#41853705">parent</a><span>|</span><a href="#41851601">next</a><span>|</span><label class="collapse" for="c-41856465">[-]</label><label class="expand" for="c-41856465">[1 more]</label></div><br/><div class="children"><div class="content">Inline assembly isn&#x27;t supported for x86-64 and ARM on MSVC which unfortunately also means the incbin trick can&#x27;t be used there anymore.</div><br/></div></div></div></div></div></div></div></div><div id="41851601" class="c"><input type="checkbox" id="c-41851601" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#41850914">prev</a><span>|</span><a href="#41854389">next</a><span>|</span><label class="collapse" for="c-41851601">[-]</label><label class="expand" for="c-41851601">[36 more]</label></div><br/><div class="children"><div class="content">How does &quot;Modern&quot; C compare safety-wise to Rust or Zig?</div><br/><div id="41856856" class="c"><input type="checkbox" id="c-41856856" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41851601">parent</a><span>|</span><a href="#41852113">next</a><span>|</span><label class="collapse" for="c-41856856">[-]</label><label class="expand" for="c-41856856">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s finally a way to safely add two signed numbers, without tricky overflow checks that may trigger UB themselves!</div><br/></div></div><div id="41852113" class="c"><input type="checkbox" id="c-41852113" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41851601">parent</a><span>|</span><a href="#41856856">prev</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41852113">[-]</label><label class="expand" for="c-41852113">[16 more]</label></div><br/><div class="children"><div class="content">Modern C still promptly decays an array to a pointer, so no array bounds checking is possible.<p>D does not decay arrays, so D has array bounds checking.<p>Note that array overflow bugs are consistently the #1 problem with shipped C code, by a wide margin.</div><br/><div id="41852316" class="c"><input type="checkbox" id="c-41852316" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852113">parent</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41852316">[-]</label><label class="expand" for="c-41852316">[15 more]</label></div><br/><div class="children"><div class="content">&gt; no array bounds checking is possible.<p>This isn’t strictly true, a C implementation is allowed to associate memory-range (or more generally, pointer provenance) metadata with a pointer.<p>The DeathStation 9000 features a conforming C implementation which is known to catch all array bounds violations. ;)</div><br/><div id="41852348" class="c"><input type="checkbox" id="c-41852348" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852316">parent</a><span>|</span><a href="#41854734">next</a><span>|</span><label class="collapse" for="c-41852348">[-]</label><label class="expand" for="c-41852348">[6 more]</label></div><br/><div class="children"><div class="content">Right. Also it might it sound like array-to-pointer decay is forced onto the programmer. Instead, you can take the address of an array just fine without letting it decay. The type then preserves the length.</div><br/><div id="41854211" class="c"><input type="checkbox" id="c-41854211" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852348">parent</a><span>|</span><a href="#41853029">next</a><span>|</span><label class="collapse" for="c-41854211">[-]</label><label class="expand" for="c-41854211">[2 more]</label></div><br/><div class="children"><div class="content">C:
    int foo(int a[]) { return a[5]; }<p><pre><code>    int main() {
        int a[3];
        return foo(a);
    }

    &gt; gcc test.c
    &gt; .&#x2F;a.out</code></pre>
Oops.<p>D:
    int foo(int[] a) { return a[5]; }<p><pre><code>    int main() {
        int[3] a;
        return foo(a);
    }

    &gt; .&#x2F;cc array.d
    &gt; .&#x2F;array
    core.exception.ArrayIndexError@array.d(1): index [5] is out of bounds for array of length 3
</code></pre>
Ah, Nirvana!<p>How to fix it for C:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a></div><br/><div id="41856518" class="c"><input type="checkbox" id="c-41856518" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41854211">parent</a><span>|</span><a href="#41853029">next</a><span>|</span><label class="collapse" for="c-41856518">[-]</label><label class="expand" for="c-41856518">[1 more]</label></div><br/><div class="children"><div class="content">You need to take the address of the array instead of letting it decay and then size is encoded in the type:<p><pre><code>  int foo(int (*a)[6]) { return a[5]; }
  int main() {
  int a[3];
    return foo(&amp;a);
  }
</code></pre>
Or for run-time length:<p><pre><code>  int foo(int n, int (*a)[n]) { return (\*a)[5]; }
  int main() {
    int a[3];
    return foo(ARRAY_SIZE(a), &amp;a);
  }
  &#x2F;app&#x2F;example.c:4:38: runtime error: index 5 out of bounds for 
 type &#x27;int[n]&#x27;
</code></pre>
<a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;dxx7TsKbK\" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;dxx7TsKbK\</a>*</div><br/></div></div></div></div><div id="41853029" class="c"><input type="checkbox" id="c-41853029" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852348">parent</a><span>|</span><a href="#41854211">prev</a><span>|</span><a href="#41854734">next</a><span>|</span><label class="collapse" for="c-41853029">[-]</label><label class="expand" for="c-41853029">[3 more]</label></div><br/><div class="children"><div class="content">Nice, when you know the length at compile time, which is rarely from my experience.<p>The holy grail is runtime access to the length, which means an array would have to be backed by something more elaborate.</div><br/><div id="41856489" class="c"><input type="checkbox" id="c-41856489" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41853029">parent</a><span>|</span><a href="#41854734">next</a><span>|</span><label class="collapse" for="c-41856489">[-]</label><label class="expand" for="c-41856489">[2 more]</label></div><br/><div class="children"><div class="content">Oh, it also work for runtime length:<p><a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;PnaWWcK9o" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;PnaWWcK9o</a></div><br/><div id="41856543" class="c"><input type="checkbox" id="c-41856543" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41856489">parent</a><span>|</span><a href="#41854734">next</a><span>|</span><label class="collapse" for="c-41856543">[-]</label><label class="expand" for="c-41856543">[1 more]</label></div><br/><div class="children"><div class="content">Now try that on a compiler without -fsanitize=bounds, yet full ISO C compliant.</div><br/></div></div></div></div></div></div></div></div><div id="41854734" class="c"><input type="checkbox" id="c-41854734" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852316">parent</a><span>|</span><a href="#41852348">prev</a><span>|</span><a href="#41855111">next</a><span>|</span><label class="collapse" for="c-41854734">[-]</label><label class="expand" for="c-41854734">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The DeathStation 9000 features a conforming C implementation which is known to catch all array bounds violations. ;)<p>That actually really does exist already with CHERI CPUs, whose pointers are tagged with &quot;capabilities,&quot; which catch buffer overruns at runtime.<p><a href="https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;blog&#x2F;2023&#x2F;two_stories_for_what_is_cheri.html" rel="nofollow">https:&#x2F;&#x2F;tratt.net&#x2F;laurie&#x2F;blog&#x2F;2023&#x2F;two_stories_for_what_is_c...</a><p><a href="https:&#x2F;&#x2F;msrc.microsoft.com&#x2F;blog&#x2F;2022&#x2F;01&#x2F;an_armful_of_cheris&#x2F;" rel="nofollow">https:&#x2F;&#x2F;msrc.microsoft.com&#x2F;blog&#x2F;2022&#x2F;01&#x2F;an_armful_of_cheris&#x2F;</a></div><br/></div></div><div id="41855111" class="c"><input type="checkbox" id="c-41855111" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852316">parent</a><span>|</span><a href="#41854734">prev</a><span>|</span><a href="#41852932">next</a><span>|</span><label class="collapse" for="c-41855111">[-]</label><label class="expand" for="c-41855111">[1 more]</label></div><br/><div class="children"><div class="content">A worked example: <a href="https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;deluge&#x2F;Manifesto.md">https:&#x2F;&#x2F;github.com&#x2F;pizlonator&#x2F;llvm-project-deluge&#x2F;blob&#x2F;delug...</a></div><br/></div></div><div id="41852932" class="c"><input type="checkbox" id="c-41852932" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852316">parent</a><span>|</span><a href="#41855111">prev</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41852932">[-]</label><label class="expand" for="c-41852932">[6 more]</label></div><br/><div class="children"><div class="content">&quot;The DeathStation 9000&quot;<p>The what now?</div><br/><div id="41853918" class="c"><input type="checkbox" id="c-41853918" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852932">parent</a><span>|</span><a href="#41853018">next</a><span>|</span><label class="collapse" for="c-41853918">[-]</label><label class="expand" for="c-41853918">[1 more]</label></div><br/><div class="children"><div class="content">Nasal daemons for those of us of a slightly older vintage ...</div><br/></div></div><div id="41853018" class="c"><input type="checkbox" id="c-41853018" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852932">parent</a><span>|</span><a href="#41853918">prev</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41853018">[-]</label><label class="expand" for="c-41853018">[4 more]</label></div><br/><div class="children"><div class="content">Google it.</div><br/><div id="41854150" class="c"><input type="checkbox" id="c-41854150" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41853018">parent</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41854150">[-]</label><label class="expand" for="c-41854150">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, why have any type of human interaction in a forum when you can just refer your fellow brethren to the automaton.</div><br/><div id="41854271" class="c"><input type="checkbox" id="c-41854271" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41854150">parent</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41854271">[-]</label><label class="expand" for="c-41854271">[2 more]</label></div><br/><div class="children"><div class="content">I’m saying this because any explanation I could offer would provide less insight than the Google results.</div><br/><div id="41854957" class="c"><input type="checkbox" id="c-41854957" checked=""/><div class="controls bullet"><span class="by">TZubiri</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41854271">parent</a><span>|</span><a href="#41852048">next</a><span>|</span><label class="collapse" for="c-41854957">[-]</label><label class="expand" for="c-41854957">[1 more]</label></div><br/><div class="children"><div class="content">Less insight, perhaps, but of higher quality, which is subjective.<p>I personally find that googling stuff provides not much connection to the subject of study, very impersonal and try to avoid it.<p>For example I did google the concept, and found this <a href="https:&#x2F;&#x2F;github.com&#x2F;cousteaulecommandant&#x2F;ds9k">https:&#x2F;&#x2F;github.com&#x2F;cousteaulecommandant&#x2F;ds9k</a>.<p>Which is not trivial to parse, bing posited the answer as authoritative, and if you look at the code it is really nothing, it seems to be a folklore concept, and as such, it is much more aptly transmitted by speaking to a human and getting a live version than by googling an authoratitative static answer.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41852048" class="c"><input type="checkbox" id="c-41852048" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41851601">parent</a><span>|</span><a href="#41852113">prev</a><span>|</span><a href="#41852498">next</a><span>|</span><label class="collapse" for="c-41852048">[-]</label><label class="expand" for="c-41852048">[17 more]</label></div><br/><div class="children"><div class="content">You&#x27;d be surprised: Zig has one UB (Undefined Behaviour) that C doesn&#x27;t have!<p>In release fast mode, unsigned overflow&#x2F;underflow is undefined in Zig whereas in C it wraps.<p>:-)<p>Of course C has many UBs that Zig doesn&#x27;t have, so C is far less safe than Zig, especially since you can use ReleaseSafe in Zig..</div><br/><div id="41852363" class="c"><input type="checkbox" id="c-41852363" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852048">parent</a><span>|</span><a href="#41852615">next</a><span>|</span><label class="collapse" for="c-41852363">[-]</label><label class="expand" for="c-41852363">[9 more]</label></div><br/><div class="children"><div class="content">UB is does not automatically make things unsafe. You can have a compiler that implements safe defaults for most UB, and then it is not unsafe.</div><br/><div id="41853004" class="c"><input type="checkbox" id="c-41853004" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852363">parent</a><span>|</span><a href="#41853762">next</a><span>|</span><label class="collapse" for="c-41853004">[-]</label><label class="expand" for="c-41853004">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s implementation defined behavior, not undefined behavior. Undefined behavior explicitly refers to something the compiler does not provide a definition for, including &quot;safe defaults.&quot;</div><br/><div id="41854616" class="c"><input type="checkbox" id="c-41854616" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41853004">parent</a><span>|</span><a href="#41853169">next</a><span>|</span><label class="collapse" for="c-41854616">[-]</label><label class="expand" for="c-41854616">[1 more]</label></div><br/><div class="children"><div class="content">The C standard says, and I quote:<p>&gt;Possible undefined behavior ranges from ignoring the situation completely with unpredictable results ... or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message)<p>So a compiler is absolutely welcome to make undefined behavior safe. In fact every compiler I know of, such as GCC, clang, MSVC has flags to make various undefined behavior safe, such as signed integer overflow, type punning, casting function pointers to void pointers.<p>The Linux kernel is notorious for leveraging undefined behavior in C for which GCC guarantees specific and well defined behavior.<p>It looks like there is also the notion of unspecified behavior, which gives compilers a choice about the behavior and does not require compilers to document that choice or even choose consistently.<p>And finally there is what you bring up, which is implementation defined behavior which is defined as a subset of unspecified behavior in which compilers must document the choice.</div><br/></div></div><div id="41853169" class="c"><input type="checkbox" id="c-41853169" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41853004">parent</a><span>|</span><a href="#41854616">prev</a><span>|</span><a href="#41853762">next</a><span>|</span><label class="collapse" for="c-41853169">[-]</label><label class="expand" for="c-41853169">[1 more]</label></div><br/><div class="children"><div class="content">Compilers are not prohibited to provide their own definition for UB, that&#x27;s how UBsan exists.</div><br/></div></div></div></div><div id="41853762" class="c"><input type="checkbox" id="c-41853762" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852363">parent</a><span>|</span><a href="#41853004">prev</a><span>|</span><a href="#41853083">next</a><span>|</span><label class="collapse" for="c-41853762">[-]</label><label class="expand" for="c-41853762">[1 more]</label></div><br/><div class="children"><div class="content">Well Zig has ReleaseSafe for this.. ReleaseFast is for using these UBs to generate the fastest code.</div><br/></div></div><div id="41852548" class="c"><input type="checkbox" id="c-41852548" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852363">parent</a><span>|</span><a href="#41853083">prev</a><span>|</span><a href="#41852615">next</a><span>|</span><label class="collapse" for="c-41852548">[-]</label><label class="expand" for="c-41852548">[3 more]</label></div><br/><div class="children"><div class="content">By definition UB cannot be safe.</div><br/><div id="41854910" class="c"><input type="checkbox" id="c-41854910" checked=""/><div class="controls bullet"><span class="by">Maxatar</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852548">parent</a><span>|</span><a href="#41853174">next</a><span>|</span><label class="collapse" for="c-41854910">[-]</label><label class="expand" for="c-41854910">[1 more]</label></div><br/><div class="children"><div class="content">The definition given by the C standard allows for safe undefined behavior.</div><br/></div></div><div id="41853174" class="c"><input type="checkbox" id="c-41853174" checked=""/><div class="controls bullet"><span class="by">marssaxman</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852548">parent</a><span>|</span><a href="#41854910">prev</a><span>|</span><a href="#41852615">next</a><span>|</span><label class="collapse" for="c-41853174">[-]</label><label class="expand" for="c-41853174">[1 more]</label></div><br/><div class="children"><div class="content">this depends on your choice of definition for &quot;safe&quot;</div><br/></div></div></div></div></div></div><div id="41852615" class="c"><input type="checkbox" id="c-41852615" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852048">parent</a><span>|</span><a href="#41852363">prev</a><span>|</span><a href="#41852498">next</a><span>|</span><label class="collapse" for="c-41852615">[-]</label><label class="expand" for="c-41852615">[7 more]</label></div><br/><div class="children"><div class="content">Does C automatically wrap? I thought you need to pass `-fwrapv` to the compiler to ensure that.</div><br/><div id="41852833" class="c"><input type="checkbox" id="c-41852833" checked=""/><div class="controls bullet"><span class="by">greyw</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852615">parent</a><span>|</span><a href="#41852848">next</a><span>|</span><label class="collapse" for="c-41852833">[-]</label><label class="expand" for="c-41852833">[3 more]</label></div><br/><div class="children"><div class="content">Unsigned overflow wraps. Signed overflow is undefined behavior.</div><br/><div id="41852909" class="c"><input type="checkbox" id="c-41852909" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852833">parent</a><span>|</span><a href="#41852848">next</a><span>|</span><label class="collapse" for="c-41852909">[-]</label><label class="expand" for="c-41852909">[2 more]</label></div><br/><div class="children"><div class="content">This distinction does not exist in K&amp;R 2&#x2F;e which documents ANSI C aka C89, but maybe it was added in a later version of the language (or didn&#x27;t make it into the book)? According to K&amp;R, all overflow is undefined.</div><br/><div id="41853245" class="c"><input type="checkbox" id="c-41853245" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852909">parent</a><span>|</span><a href="#41852848">next</a><span>|</span><label class="collapse" for="c-41853245">[-]</label><label class="expand" for="c-41853245">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have my copy of K&amp;R handy, but this distinction has existed since the initial codification. From C89:<p><pre><code>  3.1.2.5 Types

  [...] A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.
</code></pre>
Source: C89 (draft) at <a href="https:&#x2F;&#x2F;port70.net&#x2F;~nsz&#x2F;c&#x2F;c89&#x2F;c89-draft.txt" rel="nofollow">https:&#x2F;&#x2F;port70.net&#x2F;~nsz&#x2F;c&#x2F;c89&#x2F;c89-draft.txt</a></div><br/></div></div></div></div></div></div><div id="41852848" class="c"><input type="checkbox" id="c-41852848" checked=""/><div class="controls bullet"><span class="by">renox</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852615">parent</a><span>|</span><a href="#41852833">prev</a><span>|</span><a href="#41852877">next</a><span>|</span><label class="collapse" for="c-41852848">[-]</label><label class="expand" for="c-41852848">[2 more]</label></div><br/><div class="children"><div class="content">-fwrapv is for <i>signed</i> integer overflow not <i>unsigned</i>.</div><br/><div id="41853085" class="c"><input type="checkbox" id="c-41853085" checked=""/><div class="controls bullet"><span class="by">sp1rit</span><span>|</span><a href="#41851601">root</a><span>|</span><a href="#41852848">parent</a><span>|</span><a href="#41852877">next</a><span>|</span><label class="collapse" for="c-41853085">[-]</label><label class="expand" for="c-41853085">[1 more]</label></div><br/><div class="children"><div class="content">Yes, as unsigned overflow is fine by default. AFAIK the issue was originally that there were still machines that used ones complement for describing negative integers instead of the now customary twos complement.</div><br/></div></div></div></div></div></div></div></div><div id="41852498" class="c"><input type="checkbox" id="c-41852498" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#41851601">parent</a><span>|</span><a href="#41852048">prev</a><span>|</span><a href="#41854389">next</a><span>|</span><label class="collapse" for="c-41852498">[-]</label><label class="expand" for="c-41852498">[1 more]</label></div><br/><div class="children"><div class="content">Modern C is barely any different than older C.  The language committee for C is extremely conservative, changes tend to happen only around the edges.</div><br/></div></div></div></div><div id="41854389" class="c"><input type="checkbox" id="c-41854389" checked=""/><div class="controls bullet"><span class="by">jhatemyjob</span><span>|</span><a href="#41851601">prev</a><span>|</span><a href="#41853486">next</a><span>|</span><label class="collapse" for="c-41854389">[-]</label><label class="expand" for="c-41854389">[4 more]</label></div><br/><div class="children"><div class="content">Can someone link me to an article that explains why C is basically frozen at C99 for all practical purposes? Few projects worth talking about leverage features from C11 and newer</div><br/><div id="41855054" class="c"><input type="checkbox" id="c-41855054" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41854389">parent</a><span>|</span><a href="#41853486">next</a><span>|</span><label class="collapse" for="c-41855054">[-]</label><label class="expand" for="c-41855054">[3 more]</label></div><br/><div class="children"><div class="content">C99 is still <i>new</i>! Microsoft tried to kill C by refusing to implement anything that wasn&#x27;t also in C++. MSVC was 16 years late implementing C99, and implemented only the bare minimum. Their C11 implementation is only 11 years late.<p>I suspect that decades of C being effectively frozen have caused the userbase to self-select to people who like C exactly the way it is (was), and don&#x27;t mind supporting ancient junk compilers.<p>Everyone who lost patience, or wanted a 21st century language, has left for C++&#x2F;Rust&#x2F;Zig or something else.</div><br/><div id="41856469" class="c"><input type="checkbox" id="c-41856469" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41854389">root</a><span>|</span><a href="#41855054">parent</a><span>|</span><a href="#41853486">next</a><span>|</span><label class="collapse" for="c-41856469">[-]</label><label class="expand" for="c-41856469">[2 more]</label></div><br/><div class="children"><div class="content">Most of us liking a good language just did not use MSVC.  I do not think many people who appreciate C&#x27;s simplicity and stability would be happy with C++ &#x2F; Rust.  Zig is beautiful, but still limited in many ways and I would not use it outside of fun projects.</div><br/><div id="41856805" class="c"><input type="checkbox" id="c-41856805" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41854389">root</a><span>|</span><a href="#41856469">parent</a><span>|</span><a href="#41853486">next</a><span>|</span><label class="collapse" for="c-41856805">[-]</label><label class="expand" for="c-41856805">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even use Windows, but I need to write portable libraries. Unfortunately, MSVC does strongly influence the baseline, and it&#x27;s not my decision if I want to be interoperable with other projects.<p>In my experience, Windows devs don&#x27;t like being told to use a different toolchain. They may have projects tied to Visual Studio, dependencies that are MSVC-only or code written for quirks of MSVC&#x27;s libc&#x2F;CRT, or want unique MSVC build features.<p>I found it hard to convince people that C isn&#x27;t just C (probably because C89 has been around forever, and many serious projects still target it). I look like an asshole when I demand them to switch to whole another toolchain, instead of me adding a few #ifdefs and macro hacks for some rare nice thing in C.<p>Honestly, paradoxically it&#x27;s been easier to tell people to build Rust code instead (it has MSVC-compatible output with almost zero setup needed).</div><br/></div></div></div></div></div></div></div></div><div id="41853486" class="c"><input type="checkbox" id="c-41853486" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#41854389">prev</a><span>|</span><a href="#41851186">next</a><span>|</span><label class="collapse" for="c-41853486">[-]</label><label class="expand" for="c-41853486">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s only been a few years since I&#x27;ve come to feel I can  rely on C compilers all supporting C99, for a library I&#x27;m maintaing [1]. And after a couple of years, sure enough - I get an issue opened asking for C89 compatibility because of some arcane embedded toolchain or what-not.<p>So, C23? ... that&#x27;s nice and all, but, let&#x27;s talk about it in 20 years or so T_T<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;eyalroz&#x2F;printf">https:&#x2F;&#x2F;github.com&#x2F;eyalroz&#x2F;printf</a></div><br/></div></div><div id="41851186" class="c"><input type="checkbox" id="c-41851186" checked=""/><div class="controls bullet"><span class="by">jumpman_miya</span><span>|</span><a href="#41853486">prev</a><span>|</span><a href="#41854443">next</a><span>|</span><label class="collapse" for="c-41851186">[-]</label><label class="expand" for="c-41851186">[2 more]</label></div><br/><div class="children"><div class="content">in example 1.1 i read that as &#x27;tits_square&#x27; until i saw the output</div><br/><div id="41851281" class="c"><input type="checkbox" id="c-41851281" checked=""/><div class="controls bullet"><span class="by">glass-z13</span><span>|</span><a href="#41851186">parent</a><span>|</span><a href="#41854443">next</a><span>|</span><label class="collapse" for="c-41851281">[-]</label><label class="expand" for="c-41851281">[1 more]</label></div><br/><div class="children"><div class="content">that&#x27;s by design</div><br/></div></div></div></div><div id="41854443" class="c"><input type="checkbox" id="c-41854443" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41851186">prev</a><span>|</span><a href="#41851781">next</a><span>|</span><label class="collapse" for="c-41854443">[-]</label><label class="expand" for="c-41854443">[2 more]</label></div><br/><div class="children"><div class="content">GCC support has been around since gcc 11 apparently.  See table at (1).  This is available in ubuntu 22.04.  The page below also shows support for C26!<p>1) <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;projects&#x2F;cxx-status.html#:~:text=C%2B%2B23%20Support" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;projects&#x2F;cxx-status.html#:~:text=C%2B%2B...</a></div><br/><div id="41856669" class="c"><input type="checkbox" id="c-41856669" checked=""/><div class="controls bullet"><span class="by">bondant</span><span>|</span><a href="#41854443">parent</a><span>|</span><a href="#41851781">next</a><span>|</span><label class="collapse" for="c-41856669">[-]</label><label class="expand" for="c-41856669">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s for C++ not C</div><br/></div></div></div></div><div id="41851781" class="c"><input type="checkbox" id="c-41851781" checked=""/><div class="controls bullet"><span class="by">zerr</span><span>|</span><a href="#41854443">prev</a><span>|</span><a href="#41855777">next</a><span>|</span><label class="collapse" for="c-41851781">[-]</label><label class="expand" for="c-41851781">[7 more]</label></div><br/><div class="children"><div class="content">Do they still use 0-terminated strings&#x2F;char* as the main string type?<p>Is the usage of single linked lists still prevalent as the main container type?</div><br/><div id="41851903" class="c"><input type="checkbox" id="c-41851903" checked=""/><div class="controls bullet"><span class="by">racingmars</span><span>|</span><a href="#41851781">parent</a><span>|</span><a href="#41854343">next</a><span>|</span><label class="collapse" for="c-41851903">[-]</label><label class="expand" for="c-41851903">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Do they still use 0-terminated strings&#x2F;char* as the main string type?<p>Of course, it&#x27;s still C.<p>&gt; Is the usage of single linked lists still prevalent as the main container type?<p>As far as I can remember, the C standard library has never had any functions that used linked lists. Nor are there any container types, linked lists or otherwise, provided by C. So I&#x27;d say this is a question about how people teach and use C, not related to the language -- or language spec version -- itself.</div><br/><div id="41856764" class="c"><input type="checkbox" id="c-41856764" checked=""/><div class="controls bullet"><span class="by">zerr</span><span>|</span><a href="#41851781">root</a><span>|</span><a href="#41851903">parent</a><span>|</span><a href="#41853057">next</a><span>|</span><label class="collapse" for="c-41856764">[-]</label><label class="expand" for="c-41856764">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t mean the language spec but what is commonly used in the wild.</div><br/></div></div><div id="41853057" class="c"><input type="checkbox" id="c-41853057" checked=""/><div class="controls bullet"><span class="by">eps</span><span>|</span><a href="#41851781">root</a><span>|</span><a href="#41851903">parent</a><span>|</span><a href="#41856764">prev</a><span>|</span><a href="#41854343">next</a><span>|</span><label class="collapse" for="c-41853057">[-]</label><label class="expand" for="c-41853057">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t feed the trolls.</div><br/></div></div></div></div><div id="41854343" class="c"><input type="checkbox" id="c-41854343" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41851781">parent</a><span>|</span><a href="#41851903">prev</a><span>|</span><a href="#41853099">next</a><span>|</span><label class="collapse" for="c-41854343">[-]</label><label class="expand" for="c-41854343">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think that will ever change. Will the possibly introduce a more modern string2 type? Maybe but it will probably be unlikely before 2050</div><br/></div></div><div id="41853099" class="c"><input type="checkbox" id="c-41853099" checked=""/><div class="controls bullet"><span class="by">codr7</span><span>|</span><a href="#41851781">parent</a><span>|</span><a href="#41854343">prev</a><span>|</span><a href="#41853013">next</a><span>|</span><label class="collapse" for="c-41853099">[-]</label><label class="expand" for="c-41853099">[1 more]</label></div><br/><div class="children"><div class="content">Embedded linked lists are pretty cool though.</div><br/></div></div><div id="41853013" class="c"><input type="checkbox" id="c-41853013" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#41851781">parent</a><span>|</span><a href="#41853099">prev</a><span>|</span><a href="#41855777">next</a><span>|</span><label class="collapse" for="c-41853013">[-]</label><label class="expand" for="c-41853013">[1 more]</label></div><br/><div class="children"><div class="content">The C standard library provides no recognizable container types, so there&#x27;s no &quot;main&quot; anything.</div><br/></div></div></div></div><div id="41855777" class="c"><input type="checkbox" id="c-41855777" checked=""/><div class="controls bullet"><span class="by">survivedurcode</span><span>|</span><a href="#41851781">prev</a><span>|</span><a href="#41856600">next</a><span>|</span><label class="collapse" for="c-41855777">[-]</label><label class="expand" for="c-41855777">[5 more]</label></div><br/><div class="children"><div class="content">Continuing to use a memory-unsafe language that has no recourse for safety and is full of footguns and is frankly irresponsible for the software profession. God help us all.<p>By the way, the US government did the profession no favors by including C++ as a memory-unsafe language. It is possible to write memory-safe C++, safe array dereferencing C++. But it’s not obvious how to do it. Herb Sutter is working on it with CppFront. The point stands that C++ can be memory-safe code. If you make a mistake, you might write some unsafe code in C++. But you can fix that mistake and learn to avoid it.<p>When you write C, you are in the bad luck shitter. You have no choice. You will write memory—unsafe code and hope you don’t fuck it up. You will hope that a refactor of your code doesn’t fuck it up.<p>Ah, C, so simple! You, only you, are responsible for handling memory safely. Don’t fuck it up, cadet. (Don’t leave it all to computers like a C++ developer would.)<p>Put C in the bin, where it belongs.</div><br/><div id="41856591" class="c"><input type="checkbox" id="c-41856591" checked=""/><div class="controls bullet"><span class="by">dxuh</span><span>|</span><a href="#41855777">parent</a><span>|</span><a href="#41856045">next</a><span>|</span><label class="collapse" for="c-41856591">[-]</label><label class="expand" for="c-41856591">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t just put a language in the bin that has been used for 50 years and that a huge percentage the present day software infrastructure is built on.<p>I see comments like yours everywhere all the time and I seriously think you have a very unhealthy emotional relationship with this topic. You should not have that much hate in your heart for a programming language that has served us very well for many decades and still continues to do so. Even if C was literally all bad (which imho isn&#x27;t even possible), you shouldn&#x27;t be that angry at it.</div><br/></div></div><div id="41856045" class="c"><input type="checkbox" id="c-41856045" checked=""/><div class="controls bullet"><span class="by">fjfaase</span><span>|</span><a href="#41855777">parent</a><span>|</span><a href="#41856591">prev</a><span>|</span><a href="#41855946">next</a><span>|</span><label class="collapse" for="c-41856045">[-]</label><label class="expand" for="c-41856045">[1 more]</label></div><br/><div class="children"><div class="content">There are still applications (especially with embedded devices) where you do not dynamically allocate memory or might not even use pointers at all.</div><br/></div></div><div id="41855946" class="c"><input type="checkbox" id="c-41855946" checked=""/><div class="controls bullet"><span class="by">purple-leafy</span><span>|</span><a href="#41855777">parent</a><span>|</span><a href="#41856045">prev</a><span>|</span><a href="#41856600">next</a><span>|</span><label class="collapse" for="c-41855946">[-]</label><label class="expand" for="c-41855946">[2 more]</label></div><br/><div class="children"><div class="content">Skill issue</div><br/><div id="41856860" class="c"><input type="checkbox" id="c-41856860" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41855777">root</a><span>|</span><a href="#41855946">parent</a><span>|</span><a href="#41856600">next</a><span>|</span><label class="collapse" for="c-41856860">[-]</label><label class="expand" for="c-41856860">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a skill issue for 40 years. How long are we going to continue searching for those programmers who don&#x27;t make mistakes?</div><br/></div></div></div></div></div></div><div id="41856600" class="c"><input type="checkbox" id="c-41856600" checked=""/><div class="controls bullet"><span class="by">johanvts</span><span>|</span><a href="#41855777">prev</a><span>|</span><label class="collapse" for="c-41856600">[-]</label><label class="expand" for="c-41856600">[1 more]</label></div><br/><div class="children"><div class="content">I payed for this on manning and they didn’t even release the final version yet. I guess   I didn’t understand what I was buying, but I can’t help feel a bit cheated.</div><br/></div></div></div></div></div></div></div></body></html>