<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702371683181" as="style"/><link rel="stylesheet" href="styles.css?v=1702371683181"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://00f.net/2023/12/11/webassembly-compilation-to-c/">The best WebAssembly runtime may be no runtime</a>Â <span class="domain">(<a href="https://00f.net">00f.net</a>)</span></div><div class="subtext"><span>jedisct1</span> | <span>124 comments</span></div><br/><div><div id="38604477" class="c"><input type="checkbox" id="c-38604477" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38602928">next</a><span>|</span><label class="collapse" for="c-38604477">[-]</label><label class="expand" for="c-38604477">[1 more]</label></div><br/><div class="children"><div class="content">Firefox actually uses this technique to harden some components:<p><a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2021&#x2F;12&#x2F;webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2021&#x2F;12&#x2F;webassembly-and-back-again...</a></div><br/></div></div><div id="38602928" class="c"><input type="checkbox" id="c-38602928" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#38604477">prev</a><span>|</span><a href="#38605789">next</a><span>|</span><label class="collapse" for="c-38602928">[-]</label><label class="expand" for="c-38602928">[32 more]</label></div><br/><div class="children"><div class="content">&quot;Take existing C code, compile it to WebAssembly, transpile it back to C, and you get the same code, but sandboxed.&quot; Nice!</div><br/><div id="38603307" class="c"><input type="checkbox" id="c-38603307" checked=""/><div class="controls bullet"><span class="by">turbolent</span><span>|</span><a href="#38602928">parent</a><span>|</span><a href="#38607773">next</a><span>|</span><label class="collapse" for="c-38603307">[-]</label><label class="expand" for="c-38603307">[2 more]</label></div><br/><div class="children"><div class="content">Just to clarify: Compared to wasm2c, w2c2 does not (yet) have sandboxing capabilities, so assumes the translated WebAssembly module is trustworthy. 
The main &quot;goal&quot; of w2c2 so far has been allowing to port applications and libraries to as many systems as possible.</div><br/><div id="38609105" class="c"><input type="checkbox" id="c-38609105" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603307">parent</a><span>|</span><a href="#38607773">next</a><span>|</span><label class="collapse" for="c-38609105">[-]</label><label class="expand" for="c-38609105">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;gvisor.dev&#x2F;docs&#x2F;architecture_guide&#x2F;platforms&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;gvisor.dev&#x2F;docs&#x2F;architecture_guide&#x2F;platforms&#x2F;</a> :<p>&gt; <i>gVisor requires a platform to implement interception of syscalls, basic context switching, and memory mapping functionality. Internally, gVisor uses an abstraction sensibly called Platform.</i><p>Chrome sandbox: <a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;src&#x2F;+&#x2F;refs&#x2F;heads&#x2F;main&#x2F;docs&#x2F;design&#x2F;sandbox.md" rel="nofollow noreferrer">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromium&#x2F;src&#x2F;+&#x2F;refs&#x2F;heads&#x2F;...</a><p>Firefox sandbox: <a href="https:&#x2F;&#x2F;wiki.mozilla.org&#x2F;Security&#x2F;Sandbox" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.mozilla.org&#x2F;Security&#x2F;Sandbox</a><p>Chromium sandbox types summary: <a href="https:&#x2F;&#x2F;github.com&#x2F;chromium&#x2F;chromium&#x2F;blob&#x2F;main&#x2F;docs&#x2F;linux&#x2F;sandboxing.md#sandbox-types-summary">https:&#x2F;&#x2F;github.com&#x2F;chromium&#x2F;chromium&#x2F;blob&#x2F;main&#x2F;docs&#x2F;linux&#x2F;sa...</a><p>Minijail: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;minijail">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;minijail</a> :<p>&gt; <i>Minijail is a sandboxing and containment tool used in ChromeOS and Android. It provides an executable that can be used to launch and sandbox other programs, and a library that can be used by code to sandbox itself.</i><p>Chrome vulnerability reward amounts: <a href="https:&#x2F;&#x2F;bughunters.google.com&#x2F;about&#x2F;rules&#x2F;5745167867576320&#x2F;chrome-vulnerability-reward-program-rules#reward-amounts" rel="nofollow noreferrer">https:&#x2F;&#x2F;bughunters.google.com&#x2F;about&#x2F;rules&#x2F;5745167867576320&#x2F;c...</a><p>Systemd has SystemCallFilter= to limit processes to certain syscall: 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36693366">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36693366</a><p>Nerdctl:
<a href="https:&#x2F;&#x2F;github.com&#x2F;containerd&#x2F;nerdctl">https:&#x2F;&#x2F;github.com&#x2F;containerd&#x2F;nerdctl</a><p>Nerdctl, podman, and podman-remote do <i>rootless</i> containers.</div><br/></div></div></div></div><div id="38607773" class="c"><input type="checkbox" id="c-38607773" checked=""/><div class="controls bullet"><span class="by">mattsan</span><span>|</span><a href="#38602928">parent</a><span>|</span><a href="#38603307">prev</a><span>|</span><a href="#38603459">next</a><span>|</span><label class="collapse" for="c-38607773">[-]</label><label class="expand" for="c-38607773">[1 more]</label></div><br/><div class="children"><div class="content">Oh dude imagine using cosmocc on the final C code and have a single binary that runs on 6 different OS&#x27;s</div><br/></div></div><div id="38603459" class="c"><input type="checkbox" id="c-38603459" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#38602928">parent</a><span>|</span><a href="#38607773">prev</a><span>|</span><a href="#38603158">next</a><span>|</span><label class="collapse" for="c-38603459">[-]</label><label class="expand" for="c-38603459">[23 more]</label></div><br/><div class="children"><div class="content">This feels like a really roundabout way to implement something that the compiler should be responsible for. All the pain and effort of C -&gt; WASM -&gt; C could be avoided if GCC or clang had some option to add bounds checking instrumentation for each memory access in the compiled output.</div><br/><div id="38604358" class="c"><input type="checkbox" id="c-38604358" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603459">parent</a><span>|</span><a href="#38603825">next</a><span>|</span><label class="collapse" for="c-38604358">[-]</label><label class="expand" for="c-38604358">[5 more]</label></div><br/><div class="children"><div class="content">Maybe, but don&#x27;t underestimate network effects. What&#x27;s important about wasm is its universality - both where it can run and what can target it - which is already making for a powerful ecosystem of tools and compatibility<p>GCC and clang could implement their own bounds checking rules, but C -&gt; WASM -&gt; C is actually &lt;C | anything&gt; -&gt; WASM -&gt; &lt;C | anything&gt;</div><br/><div id="38604540" class="c"><input type="checkbox" id="c-38604540" checked=""/><div class="controls bullet"><span class="by">gwervc</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604358">parent</a><span>|</span><a href="#38603825">next</a><span>|</span><label class="collapse" for="c-38604540">[-]</label><label class="expand" for="c-38604540">[4 more]</label></div><br/><div class="children"><div class="content">The &quot;universality&quot; exists only for now because wasm is at the toy-language level. The more it will evolve towards being helpful for production, the more opinionated and complex it&#x27;ll become which will reduce the number of languages supported and platforms it runs one.<p>Source: every language vm under the sun (CLR, JVM, Neko, etc.)</div><br/><div id="38605509" class="c"><input type="checkbox" id="c-38605509" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604540">parent</a><span>|</span><a href="#38604697">next</a><span>|</span><label class="collapse" for="c-38605509">[-]</label><label class="expand" for="c-38605509">[2 more]</label></div><br/><div class="children"><div class="content">JVM supports more languages than ever.</div><br/><div id="38610439" class="c"><input type="checkbox" id="c-38610439" checked=""/><div class="controls bullet"><span class="by">broken-kebab</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38605509">parent</a><span>|</span><a href="#38604697">next</a><span>|</span><label class="collapse" for="c-38610439">[-]</label><label class="expand" for="c-38610439">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s however not because JVM is not opinionated. It just offers enough market&#x2F;libs&#x2F;tools&#x2F;stability to make it worth the pain.</div><br/></div></div></div></div><div id="38604697" class="c"><input type="checkbox" id="c-38604697" checked=""/><div class="controls bullet"><span class="by">fluoridation</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604540">parent</a><span>|</span><a href="#38605509">prev</a><span>|</span><a href="#38603825">next</a><span>|</span><label class="collapse" for="c-38604697">[-]</label><label class="expand" for="c-38604697">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s so sad, and so true. Even now I&#x27;d argue there&#x27;s only like a handful of languages that have complete WASM support.</div><br/></div></div></div></div></div></div><div id="38603825" class="c"><input type="checkbox" id="c-38603825" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603459">parent</a><span>|</span><a href="#38604358">prev</a><span>|</span><a href="#38607871">next</a><span>|</span><label class="collapse" for="c-38603825">[-]</label><label class="expand" for="c-38603825">[8 more]</label></div><br/><div class="children"><div class="content">NaCl solved that long time ago</div><br/><div id="38604759" class="c"><input type="checkbox" id="c-38604759" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603825">parent</a><span>|</span><a href="#38604578">next</a><span>|</span><label class="collapse" for="c-38604759">[-]</label><label class="expand" for="c-38604759">[1 more]</label></div><br/><div class="children"><div class="content">NaCl was CPU specific, and the way they solved this problem with PNaCl (by using a subset of the LLVM IR) was more or less a hack which most likely involved at least as much machinery in the browser as a WASM runtime (and it compiled slower and also performance wasn&#x27;t any better than even the first WASM runtimes, the only thing that PNaCl had going for it was straightforward multithreading support, which took far too long to materialize in WASM - on the other hand, Spectre&#x2F;Meltdown would also have affected PNaCl hard).<p>Having worked with asm.js, NaCl, PNaCl (plus a couple other long forgotten competitors like Adobe&#x27;s Alchemy&#x2F;Flascc) and finally WASM: WASM is the natural result of an evolutionary process, and considering what all could have gone wrong if business decisions would have overruled technology decisions, what we got out of the whole endeavour is really pretty damn good. It&#x27;s really not surprising that Google abandondend PNaCl and went full in on WASM.</div><br/></div></div><div id="38604578" class="c"><input type="checkbox" id="c-38604578" checked=""/><div class="controls bullet"><span class="by">lambda</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603825">parent</a><span>|</span><a href="#38604759">prev</a><span>|</span><a href="#38604194">next</a><span>|</span><label class="collapse" for="c-38604578">[-]</label><label class="expand" for="c-38604578">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, WASM was the result of taking a look at NaCl, realizing it could never be specified and independently implemented, and writing a spec for something better that could.<p>WASM is superior in pretty much all ways to NaCl other than being a bit more time to go through the whole specification and implementation process. NaCl was a great prototype, and WASM is a much more polished result because of it.</div><br/><div id="38605297" class="c"><input type="checkbox" id="c-38605297" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604578">parent</a><span>|</span><a href="#38604194">next</a><span>|</span><label class="collapse" for="c-38605297">[-]</label><label class="expand" for="c-38605297">[3 more]</label></div><br/><div class="children"><div class="content">Ooh, I&#x27;d love to know a few more details about both.<p>What kept NaCl from being independently implemented? And what did WASM learn from NaCl?<p>Edit: ah, someone already mentioned NaCl being CPU-specific.</div><br/><div id="38606080" class="c"><input type="checkbox" id="c-38606080" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38605297">parent</a><span>|</span><a href="#38604194">next</a><span>|</span><label class="collapse" for="c-38606080">[-]</label><label class="expand" for="c-38606080">[2 more]</label></div><br/><div class="children"><div class="content">(P)NaCl was just too close to the past, roo many memories of activeX, flash and other crap still loomed heavy in people&#x27;s hearts and they wanted a clean cut with the past, an open web, free from the dictat of corporations etc.<p>I do understand why people wanted something different and rejected (p)NaCl. But the reason is not technical, it&#x27;s political (in the broad sense). Any technical issues could have been solved by fixing and extending (p)NaCl, but everybody involved understood it was not going to work</div><br/><div id="38610659" class="c"><input type="checkbox" id="c-38610659" checked=""/><div class="controls bullet"><span class="by">krasin</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38606080">parent</a><span>|</span><a href="#38604194">next</a><span>|</span><label class="collapse" for="c-38610659">[-]</label><label class="expand" for="c-38610659">[1 more]</label></div><br/><div class="children"><div class="content">I used to work in the Native Client team at Google, both on regular NaCl and pNaCl. It failed for technical reasons too. And maybe, mostly for technical reasons.<p>pNaCl&#x27;s biggest mistake was using LLVM bitcode as a wire format (see, for example, [1]). Another problem was trying to use glibc, instead of newlib. That resulted in a lot of low-level incompatibilities, as glibc itself is too target-specific. And implementing shared objects between portable and native world was really messy.<p>asm.js appeared as a simpler alternative to NaCl, and then it was quickly replaced by wasm, developed mutually by Mozilla, Google and others.<p>1. <a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;native-client-discuss&#x2F;c&#x2F;h6GJ8nQd23E&#x2F;m&#x2F;V0-6C6d4QcwJ" rel="nofollow noreferrer">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;native-client-discuss&#x2F;c&#x2F;h6GJ8nQd...</a></div><br/></div></div></div></div></div></div></div></div><div id="38604194" class="c"><input type="checkbox" id="c-38604194" checked=""/><div class="controls bullet"><span class="by">phickey</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603825">parent</a><span>|</span><a href="#38604578">prev</a><span>|</span><a href="#38607871">next</a><span>|</span><label class="collapse" for="c-38604194">[-]</label><label class="expand" for="c-38604194">[2 more]</label></div><br/><div class="children"><div class="content">it solved it so well that nobody outside of chrome ever implemented nacl, and chrome&#x27;s nacl team became their webassembly team</div><br/><div id="38606138" class="c"><input type="checkbox" id="c-38606138" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604194">parent</a><span>|</span><a href="#38607871">next</a><span>|</span><label class="collapse" for="c-38606138">[-]</label><label class="expand" for="c-38606138">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s perfectly compatible with the claim that from a technical pov pnacl solved the issue.<p>There were other good reasons why that wasn&#x27;t ultimately the road taken, but they largely were know technical reasons.</div><br/></div></div></div></div></div></div><div id="38604813" class="c"><input type="checkbox" id="c-38604813" checked=""/><div class="controls bullet"><span class="by">russellbeattie</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603459">parent</a><span>|</span><a href="#38607871">prev</a><span>|</span><a href="#38603158">next</a><span>|</span><label class="collapse" for="c-38604813">[-]</label><label class="expand" for="c-38604813">[8 more]</label></div><br/><div class="children"><div class="content">Totally aree. This is such a an obvious thing to do, I&#x27;m amazed that I had never considered it a possibility until now. I guess I thought of sandboxing as something only VM-based programming languages were capable of. For decades we&#x27;ve been dealing with buffer overflow exploits in C apps - you really have to wonder why this hasn&#x27;t already been an option in GCC and other compilers, or simply another pass in OS make compilation steps.<p>I&#x27;m sure it&#x27;s not a cure all, adds overhead and not applicable in all cases, but every small addition to security wouldn&#x27;t be a bad thing. I don&#x27;t see any reason why every command line utility in Unix based OSes, for example, couldn&#x27;t be sandboxed. Think like wget or curl for example.</div><br/><div id="38605387" class="c"><input type="checkbox" id="c-38605387" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604813">parent</a><span>|</span><a href="#38607439">next</a><span>|</span><label class="collapse" for="c-38605387">[-]</label><label class="expand" for="c-38605387">[5 more]</label></div><br/><div class="children"><div class="content">C programs are already sandboxed in the WASM sense at the process level by the MMU machinery.</div><br/><div id="38608314" class="c"><input type="checkbox" id="c-38608314" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38605387">parent</a><span>|</span><a href="#38607689">next</a><span>|</span><label class="collapse" for="c-38608314">[-]</label><label class="expand" for="c-38608314">[3 more]</label></div><br/><div class="children"><div class="content">Sure and containers give you syscall restrictions and OS protections, but you donât see people embedding containers inside of other applications. People generally sont like sidecars, so embedding wasm makes a lot of sense to have in process</div><br/><div id="38609894" class="c"><input type="checkbox" id="c-38609894" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38608314">parent</a><span>|</span><a href="#38610135">next</a><span>|</span><label class="collapse" for="c-38609894">[-]</label><label class="expand" for="c-38609894">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sure and containers give you syscall restrictions and OS protections, but you donât see people embedding containers inside of other applications.<p>It sounds like you&#x27;re implying that C coders will opt out of the sandboxing provided by the OS, but that&#x27;s not possible without coding kernel level code. For userland processes, the sandboxing isn&#x27;t optional, and your process will be sent a SEGV signal if it tries to access memory it&#x27;s not allowed to access.</div><br/></div></div><div id="38610135" class="c"><input type="checkbox" id="c-38610135" checked=""/><div class="controls bullet"><span class="by">wahern</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38608314">parent</a><span>|</span><a href="#38609894">prev</a><span>|</span><a href="#38607689">next</a><span>|</span><label class="collapse" for="c-38610135">[-]</label><label class="expand" for="c-38610135">[1 more]</label></div><br/><div class="children"><div class="content">On Linux seccomp is what provides syscall restrictions, and seccomp was originally added to Linux to support untrusted app sandboxing--CPUShare and later Chrome Native Client (NaCl). See <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;332974&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;332974&#x2F;</a>. This is why classic seccomp, as opposed to BPF seccomp, only permitted a small, fixed set of syscalls--read, write, and _exit.<p>A seccomp classic sandboxed process will be at least as secure as any WASM runtime, no matter the engine. Even though the former is running untrusted native code, the attack surface is much more narrow and transparent.</div><br/></div></div></div></div><div id="38607689" class="c"><input type="checkbox" id="c-38607689" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38605387">parent</a><span>|</span><a href="#38608314">prev</a><span>|</span><a href="#38607439">next</a><span>|</span><label class="collapse" for="c-38607689">[-]</label><label class="expand" for="c-38607689">[1 more]</label></div><br/><div class="children"><div class="content">How am I going to sell wasm shovelware if people know The Truth?</div><br/></div></div></div></div><div id="38607439" class="c"><input type="checkbox" id="c-38607439" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604813">parent</a><span>|</span><a href="#38605387">prev</a><span>|</span><a href="#38607702">next</a><span>|</span><label class="collapse" for="c-38607439">[-]</label><label class="expand" for="c-38607439">[1 more]</label></div><br/><div class="children"><div class="content">If those utilities cared about that sort of thing they&#x27;d already have been rewritten in OCaml 20 years ago. The reasons unix utilities are written in C and C compilers don&#x27;t do bounds checking are political, not technical.</div><br/></div></div><div id="38607702" class="c"><input type="checkbox" id="c-38607702" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38604813">parent</a><span>|</span><a href="#38607439">prev</a><span>|</span><a href="#38603158">next</a><span>|</span><label class="collapse" for="c-38607702">[-]</label><label class="expand" for="c-38607702">[1 more]</label></div><br/><div class="children"><div class="content">Because this breaks the C ABI, so you can only do it with programs that were designed to be sandboxed anyways.</div><br/></div></div></div></div></div></div><div id="38603158" class="c"><input type="checkbox" id="c-38603158" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#38602928">parent</a><span>|</span><a href="#38603459">prev</a><span>|</span><a href="#38603228">next</a><span>|</span><label class="collapse" for="c-38603158">[-]</label><label class="expand" for="c-38603158">[2 more]</label></div><br/><div class="children"><div class="content">It helps so much that the WebAssembly &quot;virtual machine&quot; promises so little (compared to, say, Java.)</div><br/><div id="38604024" class="c"><input type="checkbox" id="c-38604024" checked=""/><div class="controls bullet"><span class="by">Lerc</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603158">parent</a><span>|</span><a href="#38603228">next</a><span>|</span><label class="collapse" for="c-38604024">[-]</label><label class="expand" for="c-38604024">[1 more]</label></div><br/><div class="children"><div class="content">That really epitomizes the proverb,<p>Either make something so simple that it obviously has no flaws or make something so complex that no flaws are obvious.</div><br/></div></div></div></div><div id="38603228" class="c"><input type="checkbox" id="c-38603228" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38602928">parent</a><span>|</span><a href="#38603158">prev</a><span>|</span><a href="#38604787">next</a><span>|</span><label class="collapse" for="c-38603228">[-]</label><label class="expand" for="c-38603228">[2 more]</label></div><br/><div class="children"><div class="content">This is already in Firefox: <a href="https:&#x2F;&#x2F;rlbox.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;rlbox.dev&#x2F;</a></div><br/><div id="38603528" class="c"><input type="checkbox" id="c-38603528" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#38602928">root</a><span>|</span><a href="#38603228">parent</a><span>|</span><a href="#38604787">next</a><span>|</span><label class="collapse" for="c-38603528">[-]</label><label class="expand" for="c-38603528">[1 more]</label></div><br/><div class="children"><div class="content">I strongly recommend reading through this site if this topic interests you at all (which it probably does if youâre reading this comments thread!). Lot of explanation and detail about how it works, what it does, and how to use it yourself. Itâs good stuff. And yeah, itâs been in Firefox for two years now: <a href="https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2021&#x2F;12&#x2F;webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2021&#x2F;12&#x2F;webassembly-and-back-again...</a>.</div><br/></div></div></div></div></div></div><div id="38605789" class="c"><input type="checkbox" id="c-38605789" checked=""/><div class="controls bullet"><span class="by">apatheticonion</span><span>|</span><a href="#38602928">prev</a><span>|</span><a href="#38604403">next</a><span>|</span><label class="collapse" for="c-38605789">[-]</label><label class="expand" for="c-38605789">[4 more]</label></div><br/><div class="children"><div class="content">Huuury up. I need WebAssembly in my life. My two use cases are:<p>1) Web UIs with DOM access from wasm&#x2F;threads and all that goodness. I want to write my entire web application as a Rust wasm application without thunking through JS.<p>2) A native application with dynamic plugins as WASI libraries. Writing CLI tools and desktop applications in Rust with a practical method of loading plugins dynamically is .</div><br/><div id="38606260" class="c"><input type="checkbox" id="c-38606260" checked=""/><div class="controls bullet"><span class="by">maxflowrn</span><span>|</span><a href="#38605789">parent</a><span>|</span><a href="#38604403">next</a><span>|</span><label class="collapse" for="c-38606260">[-]</label><label class="expand" for="c-38606260">[3 more]</label></div><br/><div class="children"><div class="content">for 1) there is <a href="https:&#x2F;&#x2F;yew.rs" rel="nofollow noreferrer">https:&#x2F;&#x2F;yew.rs</a></div><br/><div id="38609668" class="c"><input type="checkbox" id="c-38609668" checked=""/><div class="controls bullet"><span class="by">galdosdi</span><span>|</span><a href="#38605789">root</a><span>|</span><a href="#38606260">parent</a><span>|</span><a href="#38609031">next</a><span>|</span><label class="collapse" for="c-38609668">[-]</label><label class="expand" for="c-38609668">[1 more]</label></div><br/><div class="children"><div class="content">No, yew.rs does not address this problem (WASM can&#x27;t directly touch the DOM or other browser APIs such as WebGPU, only JS can) It just wraps around calls to JS.<p>Everytime you use yew.rs or some other &quot;pure rust&quot; or whatever framework, it&#x27;s making tons of JS calls under the hood.<p>This is OK for some purposes, but if you&#x27;re trying for performance on a workload that isn&#x27;t CPU-bound, it sucks. And it&#x27;s another abstraction layer that&#x27;s bound to leak, I imagine.<p>This is a significant issue with WASM that a lot of us are waiting with bated breath to be fixed. We want to really be able to target the web browser with NO javascript involved.</div><br/></div></div><div id="38609031" class="c"><input type="checkbox" id="c-38609031" checked=""/><div class="controls bullet"><span class="by">triyambakam</span><span>|</span><a href="#38605789">root</a><span>|</span><a href="#38606260">parent</a><span>|</span><a href="#38609668">prev</a><span>|</span><a href="#38604403">next</a><span>|</span><label class="collapse" for="c-38609031">[-]</label><label class="expand" for="c-38609031">[1 more]</label></div><br/><div class="children"><div class="content">Does Yew provide any kind of assurances on runtime errors?</div><br/></div></div></div></div></div></div><div id="38604403" class="c"><input type="checkbox" id="c-38604403" checked=""/><div class="controls bullet"><span class="by">VikingCoder</span><span>|</span><a href="#38605789">prev</a><span>|</span><a href="#38604027">next</a><span>|</span><label class="collapse" for="c-38604403">[-]</label><label class="expand" for="c-38604403">[6 more]</label></div><br/><div class="children"><div class="content">Some language -&gt; WASM -&gt; C -&gt; Cosmopolitan C Compiler -&gt; Actually Portable Executable that runs on just about anything...?</div><br/><div id="38604497" class="c"><input type="checkbox" id="c-38604497" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#38604403">parent</a><span>|</span><a href="#38607919">next</a><span>|</span><label class="collapse" for="c-38604497">[-]</label><label class="expand" for="c-38604497">[2 more]</label></div><br/><div class="children"><div class="content">Why not just Some Language -&gt; C -&gt; CCC -&gt; executable? What is WASM bringing to the table?<p>Or better yet Some Language -&gt; MLIR.</div><br/><div id="38604819" class="c"><input type="checkbox" id="c-38604819" checked=""/><div class="controls bullet"><span class="by">turbolent</span><span>|</span><a href="#38604403">root</a><span>|</span><a href="#38604497">parent</a><span>|</span><a href="#38607919">next</a><span>|</span><label class="collapse" for="c-38604819">[-]</label><label class="expand" for="c-38604819">[1 more]</label></div><br/><div class="children"><div class="content">Very few languages have &quot;Some Language -&gt; C&quot; or &quot;Some Language -&gt; non-common OS &#x2F; arch combo&quot;. The &quot;just&quot; part is a whole new backend, which is a massive amount of work for common languages.<p>But it turns out many languages do have &quot;Some Language -&gt; WASM&quot; now. 
WebAssembly brings portability to the table.</div><br/></div></div></div></div><div id="38607919" class="c"><input type="checkbox" id="c-38607919" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#38604403">parent</a><span>|</span><a href="#38604497">prev</a><span>|</span><a href="#38604771">next</a><span>|</span><label class="collapse" for="c-38607919">[-]</label><label class="expand" for="c-38607919">[2 more]</label></div><br/><div class="children"><div class="content">No more than &quot;Some language -&gt; its native toolchain&quot; already is or isn&#x27;t.</div><br/><div id="38610310" class="c"><input type="checkbox" id="c-38610310" checked=""/><div class="controls bullet"><span class="by">VikingCoder</span><span>|</span><a href="#38604403">root</a><span>|</span><a href="#38607919">parent</a><span>|</span><a href="#38604771">next</a><span>|</span><label class="collapse" for="c-38610310">[-]</label><label class="expand" for="c-38610310">[1 more]</label></div><br/><div class="children"><div class="content">Did you read up on Cosmopolitan C Compiler when it was discussed here?<p>No, it&#x27;s not exactly the same amount of portability as some language and its native toolchain.  If you give me source code in some language that I can transpile to C or C++, or into WASM (and then into C), then I can give you a single file which can be executed on Linux, BSD, Mac, or Windows.<p>That&#x27;s not remotely the same thing as &quot;its native toolchain.&quot;<p>You, a developer or tech savvy person, might not see any difference.<p>But if I hand a non-tech-savvy person a file and they can just run it, no matter what OS they&#x27;re using - with no pre-requisites - that&#x27;s kind of magic.</div><br/></div></div></div></div><div id="38604771" class="c"><input type="checkbox" id="c-38604771" checked=""/><div class="controls bullet"><span class="by">turbolent</span><span>|</span><a href="#38604403">parent</a><span>|</span><a href="#38607919">prev</a><span>|</span><a href="#38604027">next</a><span>|</span><label class="collapse" for="c-38604771">[-]</label><label class="expand" for="c-38604771">[1 more]</label></div><br/><div class="children"><div class="content">Exactly!</div><br/></div></div></div></div><div id="38604027" class="c"><input type="checkbox" id="c-38604027" checked=""/><div class="controls bullet"><span class="by">pjs_</span><span>|</span><a href="#38604403">prev</a><span>|</span><a href="#38604469">next</a><span>|</span><label class="collapse" for="c-38604027">[-]</label><label class="expand" for="c-38604027">[5 more]</label></div><br/><div class="children"><div class="content">Back to the good old days of downloading and running .exes from the public internet :)</div><br/><div id="38604366" class="c"><input type="checkbox" id="c-38604366" checked=""/><div class="controls bullet"><span class="by">theonething</span><span>|</span><a href="#38604027">parent</a><span>|</span><a href="#38604395">next</a><span>|</span><label class="collapse" for="c-38604366">[-]</label><label class="expand" for="c-38604366">[3 more]</label></div><br/><div class="children"><div class="content">The first time I did that was at an internship when I needed a music player to listen to my music CDs on my work PC&#x27;s CD-ROM drive while working.<p>Searched for it (probably on Lycos), found one, downloaded the .exe, launched it, popped a CD in.  When I pressed play and heard the music start in my headphones, I had the feeling I just performed magic.  Big smile on my face as I went back to work.<p>Viruses, etc. weren&#x27;t in our reality in those naive and heady days.</div><br/><div id="38605060" class="c"><input type="checkbox" id="c-38605060" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38604027">root</a><span>|</span><a href="#38604366">parent</a><span>|</span><a href="#38604395">next</a><span>|</span><label class="collapse" for="c-38605060">[-]</label><label class="expand" for="c-38605060">[2 more]</label></div><br/><div class="children"><div class="content">I remember people being worried about viruses pre-Internet.  You had to be careful about borrowing software from friends and things like that.</div><br/><div id="38607354" class="c"><input type="checkbox" id="c-38607354" checked=""/><div class="controls bullet"><span class="by">thenickdude</span><span>|</span><a href="#38604027">root</a><span>|</span><a href="#38605060">parent</a><span>|</span><a href="#38604395">next</a><span>|</span><label class="collapse" for="c-38607354">[-]</label><label class="expand" for="c-38607354">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, my DOS machine got infected by a Jazz Jackrabbit disk borrowed from a friend.<p>I had a text-mode launcher menu for running programs, and that had an &quot;anti-virus&quot; feature built-in that checksummed programs, and alerted you if their checksum ever changed (since these viruses spread by infecting .exes), which is how I found out about it!</div><br/></div></div></div></div></div></div><div id="38604395" class="c"><input type="checkbox" id="c-38604395" checked=""/><div class="controls bullet"><span class="by">afandian</span><span>|</span><a href="#38604027">parent</a><span>|</span><a href="#38604366">prev</a><span>|</span><a href="#38604469">next</a><span>|</span><label class="collapse" for="c-38604395">[-]</label><label class="expand" for="c-38604395">[1 more]</label></div><br/><div class="children"><div class="content">Be fair, itâs .ocx files.</div><br/></div></div></div></div><div id="38604469" class="c"><input type="checkbox" id="c-38604469" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#38604027">prev</a><span>|</span><a href="#38604116">next</a><span>|</span><label class="collapse" for="c-38604469">[-]</label><label class="expand" for="c-38604469">[11 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t really buy the security argument if: âsome traditional WebAssembly compilers can decorate memory accesses with bound-checking code. w2c2 currently canât, but it totally could.â<p>Also, in my experience, naive bounds checking will eat up a lot of cycles. But maybe the C compiler can eliminate a bunch of them.</div><br/><div id="38604628" class="c"><input type="checkbox" id="c-38604628" checked=""/><div class="controls bullet"><span class="by">keithwinstein</span><span>|</span><a href="#38604469">parent</a><span>|</span><a href="#38604571">next</a><span>|</span><label class="collapse" for="c-38604628">[-]</label><label class="expand" for="c-38604628">[8 more]</label></div><br/><div class="children"><div class="content">wasm2c (part of WABT) does this transpilation in a spec-conforming way; it passes all* the WebAssembly tests and enforces the memory-safety and determinism requirements and the rest of the spec. The memory bounds-checking itself doesn&#x27;t have a runtime performance impact because it&#x27;s all done with mprotect() and a segfault handler. (There are some other differences between w2c2 and wasm2c that also have to do with spec-conformance and safety; e.g., enforcing type-safety of indirect function calls. This costs &lt;4 cycles but it&#x27;s not zero.)<p>Re: bounds checks, the thing that consumes cycles isn&#x27;t the bounds check itself, it&#x27;s Wasm&#x27;s requirement that OOB accesses produce a <i>deterministic</i> trap, even if the result of an OOB load is never observed and could be optimized out. wasm2c has to prevent the compiler from optimizing out an unobserved OOB load, and that forced liveness defeats some compiler optimizations (probably more than it needs to). But even with all that, we&#x27;re talking like a &lt;30% slowdown compared with native compilation across the SPECcpu benchmarks.<p>If you want to transpile arbitrary Wasm to native code in a spec-conforming way, you&#x27;re probably better-off using wasm2c (which, disclosure, I work on). If you trust the Wasm module, or you&#x27;re good with the isolation you get from your operating system and don&#x27;t need Wasm&#x27;s determinism, w2c2 seems great. Both of these are far less battle-hardened than V8 or wasmtime, especially when you include the fact that now you need an optimizing C compiler in the TCB.<p>---<p>* The Wasm testsuite repo has recently merged in the &quot;v4&quot; version of the exception-handling proposal, and WABT is still on &quot;v3&quot;. But it does pass all the core tests (including tail calls) at least until GC is merged.</div><br/><div id="38605533" class="c"><input type="checkbox" id="c-38605533" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38604628">parent</a><span>|</span><a href="#38605155">next</a><span>|</span><label class="collapse" for="c-38605533">[-]</label><label class="expand" for="c-38605533">[6 more]</label></div><br/><div class="children"><div class="content">So how is it any different than just adding bound checkings for normal C code?</div><br/><div id="38605943" class="c"><input type="checkbox" id="c-38605943" checked=""/><div class="controls bullet"><span class="by">keithwinstein</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38605533">parent</a><span>|</span><a href="#38605155">next</a><span>|</span><label class="collapse" for="c-38605943">[-]</label><label class="expand" for="c-38605943">[5 more]</label></div><br/><div class="children"><div class="content">Well, a bunch of ways.<p>It&#x27;s much faster to execute than adding a software bounds-check on every load. (Because the module declares its memories explicitly, it&#x27;s very easy for a runtime to use a zero-cost strategy to enforce that memory loads&#x2F;stores are all in-bounds.)<p>But Wasm&#x27;s safety is more than bounds-checking memory loads&#x2F;stores. E.g., Wasm indirect function calls are safe, including cross-module function calls for modules compiled separately, because there&#x27;s a runtime type check (which wasm2c does very efficiently, but not zero-cost).<p>And, Wasm modules are provably isolated (their only access outside the module is via explicit imports). Whereas if you wanted that from &quot;normal C code,&quot; it&#x27;s a lot harder -- at some point you&#x27;ll have to scan something (the source? the object file?) to enforce isolation and make sure it&#x27;s not, e.g., jumping to an arbitrary address or making a random syscall. There&#x27;s obviously a huge amount of good work on SFI but it&#x27;s not easy to do either on &quot;normal C code&quot; or on arbitrary x86-64 machine code.</div><br/><div id="38608302" class="c"><input type="checkbox" id="c-38608302" checked=""/><div class="controls bullet"><span class="by">stefanha</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38605943">parent</a><span>|</span><a href="#38606083">next</a><span>|</span><label class="collapse" for="c-38608302">[-]</label><label class="expand" for="c-38608302">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  it&#x27;s very easy for a runtime to use a zero-cost strategy to enforce that memory loads&#x2F;stores are all in-bounds<p>I believe your statement is only true for wasm32 on a 64-bit host where guard pages can be placed around the memory.<p>Has anyone come up with a zero-cost strategy for wasm64?<p>This is something that CPU vendors could help with. x86 used to have segment registers but the limit checks were removed in x86_64 so FS&#x2F;GS cannot be used for this purpose anymore.</div><br/></div></div><div id="38606083" class="c"><input type="checkbox" id="c-38606083" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38605943">parent</a><span>|</span><a href="#38608302">prev</a><span>|</span><a href="#38605155">next</a><span>|</span><label class="collapse" for="c-38606083">[-]</label><label class="expand" for="c-38606083">[3 more]</label></div><br/><div class="children"><div class="content">If a c code can automatically be compiled to wasm that is compiled to a safer c and machine code, then the same c code can also be transformed the same way without that extra step to that output. Itâs either that the original c code that can be compiled to wasm is a subset of all c codes (partially true), or that compilers trade off safety for performance (wasm has more rigid control flow, for example).</div><br/><div id="38606967" class="c"><input type="checkbox" id="c-38606967" checked=""/><div class="controls bullet"><span class="by">keithwinstein</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38606083">parent</a><span>|</span><a href="#38605155">next</a><span>|</span><label class="collapse" for="c-38606967">[-]</label><label class="expand" for="c-38606967">[2 more]</label></div><br/><div class="children"><div class="content">The goal usually isn&#x27;t for <i>one</i> party to take a C program and transform it into &quot;safe&quot; machine code. The goal is for a possible adversary to take a C program and produce an IR, and then for somebody else (maybe you) to validate that IR and produce safe machine code. Wasm is a vastly better interchange format between distrustful parties than C would be!<p>(There are probably even better interchange formats coming on the horizon; Zachary Yedidia has some cutting-edge work on &quot;lightweight fault isolation&quot; that will be presented at the upcoming ASPLOS. Earlier talk here: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;AM5fdd6ULF0" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;AM5fdd6ULF0</a> . But outside of the research world, it&#x27;s hard to beat Wasm for this.)<p>Less important: I don&#x27;t think going through Wasm has to be viewed as an &quot;extra step&quot; -- every compiler uses an IR, and if you want that IR to easily admit a &quot;safe&quot; lowering (especially one that enforces safety across independently compiled translation units), it will probably look at least a little like Wasm, which is quite minimal in its design. Remember that Wasm evolved from things like PNaCl which is basically LLVM IR, and RLBox&#x2F;Firefox considered a bunch of other SFI techniques before wasm2c.</div><br/><div id="38610215" class="c"><input type="checkbox" id="c-38610215" checked=""/><div class="controls bullet"><span class="by">zyedidia</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38606967">parent</a><span>|</span><a href="#38605155">next</a><span>|</span><label class="collapse" for="c-38610215">[-]</label><label class="expand" for="c-38610215">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the shout-out -- in case someone wants to check it out, the code for Lightweight Fault Isolation is available here: <a href="https:&#x2F;&#x2F;github.com&#x2F;zyedidia&#x2F;lfi">https:&#x2F;&#x2F;github.com&#x2F;zyedidia&#x2F;lfi</a>.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38605155" class="c"><input type="checkbox" id="c-38605155" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38604628">parent</a><span>|</span><a href="#38605533">prev</a><span>|</span><a href="#38604571">next</a><span>|</span><label class="collapse" for="c-38605155">[-]</label><label class="expand" for="c-38605155">[1 more]</label></div><br/><div class="children"><div class="content">30% is in the ballpark of what I&#x27;m expecting, actually.</div><br/></div></div></div></div><div id="38604571" class="c"><input type="checkbox" id="c-38604571" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38604469">parent</a><span>|</span><a href="#38604628">prev</a><span>|</span><a href="#38604116">next</a><span>|</span><label class="collapse" for="c-38604571">[-]</label><label class="expand" for="c-38604571">[2 more]</label></div><br/><div class="children"><div class="content">AFAIK the (software) bounds checking isn&#x27;t necessary if the WASM heap has large enough &quot;guard bands&quot; at the top and bottom to trap memory accesses (because the WASM bounds checking isn&#x27;t fine-grained, but only against the WASM heap boundaries).<p>E.g. see here:<p><a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M&#x2F;edit#heading=h.tbi7hpbheoai" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;17y4kxuHFrVxAiuCP_FFtFA2H...</a><p>(I&#x27;m not 100% sure but I think that at least V8 has implemented this in the meantime)</div><br/><div id="38605448" class="c"><input type="checkbox" id="c-38605448" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#38604469">root</a><span>|</span><a href="#38604571">parent</a><span>|</span><a href="#38604116">next</a><span>|</span><label class="collapse" for="c-38605448">[-]</label><label class="expand" for="c-38605448">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that is exactly how production Wasm VMs optimize heap accesses. Bounds checks cause no overhead as a result. That&#x27;s the case in all modern browsers, as well as in wasm2c.</div><br/></div></div></div></div></div></div><div id="38604116" class="c"><input type="checkbox" id="c-38604116" checked=""/><div class="controls bullet"><span class="by">prmph</span><span>|</span><a href="#38604469">prev</a><span>|</span><a href="#38605393">next</a><span>|</span><label class="collapse" for="c-38604116">[-]</label><label class="expand" for="c-38604116">[23 more]</label></div><br/><div class="children"><div class="content">This whole webassembly thing does not seems like it will solve real problems, The more I learn about it, the more it seems like another kludge built on top of the kludges we have now.<p>Why doesn&#x27;t HTML get an overhaul, with a massive set of new and actually useful and styleable components (e.g., data table with sorting&#x2F;paging&#x2F;filtering capabilities built right into the browser), ability to scope CSS, and things like that? That&#x27;s how the shittiness of web dev can actually be solved so that reliance of client side code can be drastically reduced</div><br/><div id="38604608" class="c"><input type="checkbox" id="c-38604608" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38604319">next</a><span>|</span><label class="collapse" for="c-38604608">[-]</label><label class="expand" for="c-38604608">[3 more]</label></div><br/><div class="children"><div class="content">WebAssembly is &quot;just another ISA&quot; for a &quot;software CPU&quot; that happens to work well for traditional compiled languages, it doesn&#x27;t really have to do much with high level web development centered around HTML+CSS.<p>For instance, personally I really appreciate that I can bundle an assembler written in C89 in the mid-90&#x27;s and last updated in 2008, and a home computer emulator written in C and C++ into a VSCode extension without having to worry about platform compatibility or security issues (<a href="https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=floooh.vscode-kcide" rel="nofollow noreferrer">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=floooh.v...</a>). Stuff like this wasn&#x27;t really possible until asm.js and then WebAssembly.</div><br/><div id="38608028" class="c"><input type="checkbox" id="c-38608028" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604608">parent</a><span>|</span><a href="#38604319">next</a><span>|</span><label class="collapse" for="c-38608028">[-]</label><label class="expand" for="c-38608028">[2 more]</label></div><br/><div class="children"><div class="content">&gt; that happens to work well for traditional compiled languages,<p>It doesn&#x27;t, though, which is a big problem. WASM starts the heap at 0x0 which breaks the null handling of 99% of traditional AOT languages _and also_ breaks the null handling of optimized higher level runtimes that rely on page faults to identify that a null deref happened before backtracking and converting that into an exception.<p>The MVP priority for WASM was to protect the host and make it simple to be the host. The guest features, security, and general sanity is <i>very</i> poor as a result.</div><br/><div id="38609692" class="c"><input type="checkbox" id="c-38609692" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38608028">parent</a><span>|</span><a href="#38604319">next</a><span>|</span><label class="collapse" for="c-38609692">[-]</label><label class="expand" for="c-38609692">[1 more]</label></div><br/><div class="children"><div class="content">Traditional AOT languages don&#x27;t make promises about what happens if you try to dereference null.  And they don&#x27;t depend on a page fault happening.<p>For higher level runtimes, can you name some common ones that use page faults that way?  I&#x27;ve never heard of that technique.</div><br/></div></div></div></div></div></div><div id="38604319" class="c"><input type="checkbox" id="c-38604319" checked=""/><div class="controls bullet"><span class="by">Matheus28</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38604608">prev</a><span>|</span><a href="#38610319">next</a><span>|</span><label class="collapse" for="c-38604319">[-]</label><label class="expand" for="c-38604319">[11 more]</label></div><br/><div class="children"><div class="content">It doesnât look like you know what webassembly is supposed to solve. It has nothing to do with styling. Itâs about deploying native code in a safe sandboxed way. Itâs not just about web pages. My use of wasm is web games that perform a lot better than anyone could achieve with JavaScript.</div><br/><div id="38606169" class="c"><input type="checkbox" id="c-38606169" checked=""/><div class="controls bullet"><span class="by">prmph</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604319">parent</a><span>|</span><a href="#38604397">next</a><span>|</span><label class="collapse" for="c-38606169">[-]</label><label class="expand" for="c-38606169">[3 more]</label></div><br/><div class="children"><div class="content">I know what webassembly is. In addition to whatever else it is used for, I hear a lot about it allowing devs to avoid JS and just write browsers apps in whatever language they want to use. That there is a clamor for that is borne out of the massive pain that is the current HTML&#x2F;CSS&#x2F;JS based web dev.<p>So what I&#x27;m saying is, instead of wasting innovation effort focusing on the use of to improve the experience of writing web apps, let&#x27;s use that to solve the actual problems with web dev.</div><br/><div id="38607387" class="c"><input type="checkbox" id="c-38607387" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38606169">parent</a><span>|</span><a href="#38609431">next</a><span>|</span><label class="collapse" for="c-38607387">[-]</label><label class="expand" for="c-38607387">[1 more]</label></div><br/><div class="children"><div class="content">&quot;In addition to whatever else it&#x27;s used for&quot; is pulling a lot of weight there. People excited about it just for not writing JavaScript just aren&#x27;t aware of what&#x27;s out there. There&#x27;s so many ways to avoid using JS these days. The value add of web assembly has always been portability and sandboxing. This is a big deal for software preservation.</div><br/></div></div><div id="38609431" class="c"><input type="checkbox" id="c-38609431" checked=""/><div class="controls bullet"><span class="by">brokenbyclouds</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38606169">parent</a><span>|</span><a href="#38607387">prev</a><span>|</span><a href="#38604397">next</a><span>|</span><label class="collapse" for="c-38609431">[-]</label><label class="expand" for="c-38609431">[1 more]</label></div><br/><div class="children"><div class="content">making web apps is the least exciting thing wasm could be used for. plugin systems, embedded, serverless use cases are much more interesting off the top of my head.<p>i think we live in a world where we can do both: we can do wasm and we can continue making improvements to the big three webdev tools.</div><br/></div></div></div></div><div id="38604397" class="c"><input type="checkbox" id="c-38604397" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604319">parent</a><span>|</span><a href="#38606169">prev</a><span>|</span><a href="#38608553">next</a><span>|</span><label class="collapse" for="c-38604397">[-]</label><label class="expand" for="c-38604397">[6 more]</label></div><br/><div class="children"><div class="content">What are you writing the games in?</div><br/><div id="38604525" class="c"><input type="checkbox" id="c-38604525" checked=""/><div class="controls bullet"><span class="by">Matheus28</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604397">parent</a><span>|</span><a href="#38608553">next</a><span>|</span><label class="collapse" for="c-38604525">[-]</label><label class="expand" for="c-38604525">[5 more]</label></div><br/><div class="children"><div class="content">C++ with a little bit of JS glue to interact with web APIs, <a href="https:&#x2F;&#x2F;florr.io" rel="nofollow noreferrer">https:&#x2F;&#x2F;florr.io</a></div><br/><div id="38604889" class="c"><input type="checkbox" id="c-38604889" checked=""/><div class="controls bullet"><span class="by">beebeepka</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604525">parent</a><span>|</span><a href="#38608553">next</a><span>|</span><label class="collapse" for="c-38604889">[-]</label><label class="expand" for="c-38604889">[4 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t code written in JS be just as fast after being turned into wasm?</div><br/><div id="38604988" class="c"><input type="checkbox" id="c-38604988" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604889">parent</a><span>|</span><a href="#38605270">next</a><span>|</span><label class="collapse" for="c-38604988">[-]</label><label class="expand" for="c-38604988">[2 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t really turn Javascript into WASM without also compiling the whole Javascript runtime to WASM because of Javascript&#x27;s highly dynamic nature.<p>You could use a more restrictive Typescript subset like <a href="https:&#x2F;&#x2F;www.assemblyscript.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.assemblyscript.org&#x2F;</a> though.<p>Also languages like C, C++ or Rust let you exactly define the layout of data on the heap, which is crucial for performance (look up data-oriented-design), and WASM preserves this in-memory layout (since it uses a simple linear heap, like C, C++, Rust, etc... but unlike Javascript, C# or Java). Achieving something similar in a high level language like Javascript would involve mapping  all application data into a single ArrayBuffer &quot;pseudo heap&quot;, and at that point, it&#x27;s easier and more maintainable to do the same thing in C (or C++ or Rust).<p>Having said all that: modern Javascript engines can perform surprisingly well (in general I&#x27;m seeing that Javascript performance is underrated, and WASM performance is often overrated - sane Javascript, WASM and native code can all be in the same performance ballpark, but native code usually has the most &quot;optimization potential&quot;).</div><br/><div id="38610761" class="c"><input type="checkbox" id="c-38610761" checked=""/><div class="controls bullet"><span class="by">hutzlibu</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604988">parent</a><span>|</span><a href="#38605270">next</a><span>|</span><label class="collapse" for="c-38610761">[-]</label><label class="expand" for="c-38610761">[1 more]</label></div><br/><div class="children"><div class="content">Assemblyscript is unfortunately not that fast (yet?), same as javascript in most cases, also because it uses a garbage collector.<p>&quot;in general I&#x27;m seeing that Javascript performance is underrated, and WASM performance is often overrated - sane Javascript, WASM and native code can all be in the same performance ballpark, but native code usually has the most &quot;optimization potential&quot;&quot;<p>And strong disagree. Javascript is indeed quite fast, but if you use a native compiled wasm libary in the right way (avoiding too many calls to wasm and back) - you will get a worlds difference in performance.</div><br/></div></div></div></div><div id="38605270" class="c"><input type="checkbox" id="c-38605270" checked=""/><div class="controls bullet"><span class="by">TheCoelacanth</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604889">parent</a><span>|</span><a href="#38604988">prev</a><span>|</span><a href="#38608553">next</a><span>|</span><label class="collapse" for="c-38605270">[-]</label><label class="expand" for="c-38605270">[1 more]</label></div><br/><div class="children"><div class="content">No, because the semantics of JS aren&#x27;t amenable to producing fast wasm.</div><br/></div></div></div></div></div></div></div></div><div id="38608553" class="c"><input type="checkbox" id="c-38608553" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604319">parent</a><span>|</span><a href="#38604397">prev</a><span>|</span><a href="#38610319">next</a><span>|</span><label class="collapse" for="c-38608553">[-]</label><label class="expand" for="c-38608553">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I don&#x27;t get why so much software gets access to the entire filesystem just by running it. They should have made it so an .exe can only modify its own directory, a temp directory, and any file or directory passed to it by the user through the system&#x27;s file picker or command line. That would solve 99% of the use cases.<p>Every time I program something that deletes files I get worried about accidentally deleting the entire filesystem by mistyping something. I shouldn&#x27;t have to worry about that.<p>One of the reasons that webapps get as much trust as they do is simply because they don&#x27;t have unrestricted file access. I wish there was an application format that promised the same on the desktop.</div><br/></div></div></div></div><div id="38610319" class="c"><input type="checkbox" id="c-38610319" checked=""/><div class="controls bullet"><span class="by">gnulinux</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38604319">prev</a><span>|</span><a href="#38604586">next</a><span>|</span><label class="collapse" for="c-38610319">[-]</label><label class="expand" for="c-38610319">[1 more]</label></div><br/><div class="children"><div class="content">WebAssembly is like an openly designed Java virtual machine that&#x27;s intended to run on all systems. You&#x27;re completely confused. WebAssembly is extremely exciting and I believe it&#x27;ll soon be <i>the</i> thing in the tech industry. With Wasm you can write one app and run it in the following platforms TODAY:<p>1. Desktop: Linux + Windows + OSX<p>2. Browsers: Chrome + Firefox<p>3. Phone: Android (no iOS)<p>4. Embedded<p>it&#x27;s absolutely amazing. The biggest problem nowadays is packaging and various runtime things, but what I listed above 100% works, you just need to do the work to package it in N different platforms. How is this not appealing?<p>Imagine you write Google Sheets, it works on your browser, on OSX, on Linux, on Windows and on Android. It&#x27;s the same binary.</div><br/></div></div><div id="38604586" class="c"><input type="checkbox" id="c-38604586" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38610319">prev</a><span>|</span><a href="#38604310">next</a><span>|</span><label class="collapse" for="c-38604586">[-]</label><label class="expand" for="c-38604586">[1 more]</label></div><br/><div class="children"><div class="content">WebAssembly is solving a completing different problem than better webpage UI.</div><br/></div></div><div id="38604310" class="c"><input type="checkbox" id="c-38604310" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38604586">prev</a><span>|</span><a href="#38604249">next</a><span>|</span><label class="collapse" for="c-38604310">[-]</label><label class="expand" for="c-38604310">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about much more than web browsers at this point, in fact I think its biggest impact will end up being outside of them</div><br/></div></div><div id="38604249" class="c"><input type="checkbox" id="c-38604249" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38604310">prev</a><span>|</span><a href="#38604422">next</a><span>|</span><label class="collapse" for="c-38604249">[-]</label><label class="expand" for="c-38604249">[2 more]</label></div><br/><div class="children"><div class="content">Webassembly doesn&#x27;t solve the same problems as styleable components, scoped CSS, and things like that though.  Webassembly solves the problem of &quot;how do I deploy this software that isn&#x27;t written in Javascript to the browser client?&quot;.<p>Sure, it also is sorta about performance, but JS interpreters are actually shockingly fast in the modern world.  Mostly wasm is about moving your existing C++ code (or whatever) for your existing formats or algorithms or tools into a web&#x2F;mobile client without having to hire someone to recode it all in TypeScript or whatever.  That&#x27;s not sexy, but it&#x27;s valuable.</div><br/><div id="38604327" class="c"><input type="checkbox" id="c-38604327" checked=""/><div class="controls bullet"><span class="by">dudus</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604249">parent</a><span>|</span><a href="#38604422">next</a><span>|</span><label class="collapse" for="c-38604327">[-]</label><label class="expand" for="c-38604327">[1 more]</label></div><br/><div class="children"><div class="content">I think webassembly actually acts as a reliable target when building software. Every platform will have a fast web assembly runtime. So you just build for it and you can deploy for any platform mobile or desktop.</div><br/></div></div></div></div><div id="38604422" class="c"><input type="checkbox" id="c-38604422" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#38604116">parent</a><span>|</span><a href="#38604249">prev</a><span>|</span><a href="#38605393">next</a><span>|</span><label class="collapse" for="c-38604422">[-]</label><label class="expand" for="c-38604422">[3 more]</label></div><br/><div class="children"><div class="content">I mean, just because it&#x27;s not solving problems relevant to what you&#x27;re working on, doesn&#x27;t mean it&#x27;s not solving problems. The implications of a relatively fast universal runtime that can safely sandbox untrusted code are quite far-reaching, and it will probably take a while to see the end-game. Docker and containers have been around for a fairly long time, and while the uptake of containers to solve problems has gradually increased over time, it&#x27;s still nowhere near the peak. I think this is likewise true for WebAssembly, which has more potential than we currently know what to do with.<p>Personally I think the focus for web technologies should be deprecating old things and being very judicial about adding new things. New things that get added have to be maintained by all browser engines effectively forever, and this is part of why every browser engine is a huge multi-million dollar per year endeavor just to maintain. Meanwhile, a lot of features being added to browsers don&#x27;t necessarily justify all of this cost. Layout engines are unmanageably complex already. CSS is unmanageably complex already. I think adding even more stuff is hardly the solution, but rather, we need to figure out how to actually utilize what&#x27;s here better before we can actually come up with successors. Rather than adding more scoped CSS and CSS modules junk, I&#x27;d rather just have improvements to CSS-in-JS. Maybe some targeted new APIs that make it easier to implement these features in the browser, not entire new paradigms that require implementing hundreds of thousands of new lines of code that will have to be maintained indefinitely. Likewise for web components: the concept is fine, but <i>every browser has to maintain all of this forever</i>, and all of the edge cases that come from it; will it yield so much benefit from what exists today? Will it actually stop people from shipping megabytes of Javascript, or could they have already stopped doing that if they really wanted to, and all this will do is mop it around a bit? A large node_modules folder disappears when a web app disappears. A large Chromium source code checkout only continues to grow larger effectively forever.<p>WebAssembly though, gets a pass from me, because it&#x27;s far more than &quot;Web&quot;, but the Web part adds a lot to the overall package. It&#x27;s just a win all around.</div><br/><div id="38606202" class="c"><input type="checkbox" id="c-38606202" checked=""/><div class="controls bullet"><span class="by">prmph</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38604422">parent</a><span>|</span><a href="#38605393">next</a><span>|</span><label class="collapse" for="c-38606202">[-]</label><label class="expand" for="c-38606202">[2 more]</label></div><br/><div class="children"><div class="content">The unmanageable complexity is exactly the result of the current architecture of browsers. My proposal is to rip off all that cruft and actually address the pain points of web dev in a modern way.<p>For example, CSS is a disaster. That browsers need to be very complex to implement it correctly is the more reason why it should be replaced.</div><br/><div id="38607062" class="c"><input type="checkbox" id="c-38607062" checked=""/><div class="controls bullet"><span class="by">Already__Taken</span><span>|</span><a href="#38604116">root</a><span>|</span><a href="#38606202">parent</a><span>|</span><a href="#38605393">next</a><span>|</span><label class="collapse" for="c-38607062">[-]</label><label class="expand" for="c-38607062">[1 more]</label></div><br/><div class="children"><div class="content">you&#x27;d break the web and that is worse overall</div><br/></div></div></div></div></div></div></div></div><div id="38605393" class="c"><input type="checkbox" id="c-38605393" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#38604116">prev</a><span>|</span><a href="#38603630">next</a><span>|</span><label class="collapse" for="c-38605393">[-]</label><label class="expand" for="c-38605393">[1 more]</label></div><br/><div class="children"><div class="content">I like the term &quot;VMless&quot; (or &quot;VM-less&quot;) for this. (Inspired by &quot;serverless&quot; I guess)</div><br/></div></div><div id="38603630" class="c"><input type="checkbox" id="c-38603630" checked=""/><div class="controls bullet"><span class="by">spankalee</span><span>|</span><a href="#38605393">prev</a><span>|</span><a href="#38605996">next</a><span>|</span><label class="collapse" for="c-38603630">[-]</label><label class="expand" for="c-38603630">[4 more]</label></div><br/><div class="children"><div class="content">I love the idea of AOT WASM compilers, but they will definitely be complicated by WASM GC. I wonder if compiling to another GC language, like Go, might help, or if they can just use a GC library like tgc or Oilpan.</div><br/><div id="38603769" class="c"><input type="checkbox" id="c-38603769" checked=""/><div class="controls bullet"><span class="by">csjh</span><span>|</span><a href="#38603630">parent</a><span>|</span><a href="#38605996">next</a><span>|</span><label class="collapse" for="c-38603769">[-]</label><label class="expand" for="c-38603769">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d imagine the majority won&#x27;t support GC, at least not for some time</div><br/><div id="38609932" class="c"><input type="checkbox" id="c-38609932" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#38603630">root</a><span>|</span><a href="#38603769">parent</a><span>|</span><a href="#38608333">next</a><span>|</span><label class="collapse" for="c-38609932">[-]</label><label class="expand" for="c-38609932">[1 more]</label></div><br/><div class="children"><div class="content">I think WASM has a problem which isn&#x27;t really noticed&#x2F;worked on yet (at least, that&#x27;s my perspective)<p>The WASM GC will be good, not because it&#x27;s a GC, but because it would allow languages compiled to WASM to interoperate with e.g. the DOM using the same memory manager so you&#x27;re not e.g. manually managing the memory of DOM objects while JS may hold references to them according to the terms of the GC.<p>But this also means the DOM API will be tied to the GC, right? I don&#x27;t know this for fact, but logically that seems correct. So languages that do NOT have good use of the GC are going to be at a disadvantage when it comes to interacting with the DOM, presumably.<p>Meanwhile, the runtimes of languages like Go and modern Java (after Java gets goroutine-like behavior from project loom) rely on small ~8kb stacks and the ability to swap the stack to a new goroutine using setjmp&#x2F;longjmp - but WASM isn&#x27;t a traditional register machine like x86 ASM, instead it&#x27;s more of a stack machine.. with no setjmp&#x2F;longjmp.<p>So not only do languages like Go and Java need to &#x27;decouple&#x27; their runtimes for goroutine-like behavior from their GC and make use of the WASM GC instead (which is not tailored to the usage patterns of such languages), but they also need to emulate their own register machine &#x27;on top of&#x27; the WASM stack machine so that their goroutine-like behavior works in WASM. Back in 2017 my coworker did this for Go, and so far as I know the implementation has not moved on from that approach since because there is no alternative.<p>So for Go and Java, you&#x27;d be working with a GC that isn&#x27;t designed for the language and presumably that has performance implications.. and you&#x27;d be working with an emulated register machine on top of a sandboxed stack machine (WASM)... that all starts to seem quite a bit far from &#x27;low level like native code&#x27; that WASM aims to promise.<p>I hope I&#x27;m wrong, but I fear Go&#x2F;Java do not have a bright, performant, future when it comes to WASM.<p>Zig, C++, Rust - all probably have a bright future here. But the challenges for higher level languages are stark<p>[0] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32078190">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=32078190</a></div><br/></div></div><div id="38608333" class="c"><input type="checkbox" id="c-38608333" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#38603630">root</a><span>|</span><a href="#38603769">parent</a><span>|</span><a href="#38609932">prev</a><span>|</span><a href="#38605996">next</a><span>|</span><label class="collapse" for="c-38608333">[-]</label><label class="expand" for="c-38608333">[1 more]</label></div><br/><div class="children"><div class="content">I mean Kotlin already does, I believe Java will too, but youâre right that python, js, ruby, golang, rust and c&#x2F;c++ donât use Wasm GC</div><br/></div></div></div></div></div></div><div id="38605996" class="c"><input type="checkbox" id="c-38605996" checked=""/><div class="controls bullet"><span class="by">AndrewDucker</span><span>|</span><a href="#38603630">prev</a><span>|</span><a href="#38603514">next</a><span>|</span><label class="collapse" for="c-38605996">[-]</label><label class="expand" for="c-38605996">[2 more]</label></div><br/><div class="children"><div class="content">How much does this limit the code you can write?
Presumably WASM is made safe by limiting the ability of the code in some way. Otherwise the checks that occur as part of the C -&gt; WASM -&gt; C pipeline could be built into your standard C compiler.<p>So what do we lose as part of this round trip?<p>Just speed? Nothing else?</div><br/><div id="38607856" class="c"><input type="checkbox" id="c-38607856" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#38605996">parent</a><span>|</span><a href="#38603514">next</a><span>|</span><label class="collapse" for="c-38607856">[-]</label><label class="expand" for="c-38607856">[1 more]</label></div><br/><div class="children"><div class="content">You could build Software Fault Isolation into an existing compiler toolchain, and people have done it, but WebAssembly comes with an existing constraint which is why it&#x27;s designed the way it is: a WASM file may be generated by an unknown or untrustworthy participant and needs to be consumed in a trustworthy context, i.e. served from a random HTTP server into a users browser. Therefore the WASM file format has stringent requirements and a strict validation algorithm placed on it before you should execute it.<p>So, you&#x27;re doing a classic thing in verification, which is just writing a &quot;checker&quot; that implements some (known good) algorithm in the smallest and most correct way possible, and then using that to check whether much bigger &quot;unknown&quot; things are safe. The goal is that the checker is much easier to implement correctly than auditing everything by hand.<p>For example, you might have a media player with extensions (like foobar2000); traditionally extensions would be delivered as .dlls, because developers did not release the source. This would be a use case similar to the browser, where WebAssembly would be a good choice instead of random .dll files. They may not want to release the code, but you don&#x27;t want to trust a random blob of binary code. If you trust your WASM implementation, you don&#x27;t need to trust that the binary blob is harmless (it will just be rejected or forbidden from doing bad things.)<p>If you&#x27;re not dealing with &quot;random binary blob from potentially untrusted source&quot;, i.e. you are running the compiler yourself on some code you downloaded, and then running that code, then you don&#x27;t really need WASM for this, because you could reasonably trust the compiler to uphold the security guarantees using SFI techniques. For example, if you wanted to make sure zlib was safe from buffer overflows in your main process, to reduce blast radius, a pure SFI toolchain would be fine. You can trust it works and then just compile zlib yourself.<p>But there&#x27;s generally a lot more mindset and movement around WASM than anything else, so people use it for all of these cases, even cases where they control both the compiler generating code, and where the code is being run.</div><br/></div></div></div></div><div id="38603514" class="c"><input type="checkbox" id="c-38603514" checked=""/><div class="controls bullet"><span class="by">legulere</span><span>|</span><a href="#38605996">prev</a><span>|</span><a href="#38608569">next</a><span>|</span><label class="collapse" for="c-38603514">[-]</label><label class="expand" for="c-38603514">[1 more]</label></div><br/><div class="children"><div class="content">The difficulty of sandboxes is to offer a usable, useful API to the outside world that is still secure. Operating system processes would perfectly fine sandboxes except for the huge hole current syscalls and other out of process APIs rip.</div><br/></div></div><div id="38608569" class="c"><input type="checkbox" id="c-38608569" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#38603514">prev</a><span>|</span><a href="#38603243">next</a><span>|</span><label class="collapse" for="c-38608569">[-]</label><label class="expand" for="c-38608569">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no &quot;best&quot; approach here. If you have RAM and enough cores, you can use JIT to achieve better performance over time for hot loops. Much better.<p>But if you need statically compiled code, no runtime is much simpler to handle, with a lot less to go wrong. But also expect performance that&#x27;s just &quot;ok&quot;. Nothing to call home about.</div><br/></div></div><div id="38603243" class="c"><input type="checkbox" id="c-38603243" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38608569">prev</a><span>|</span><a href="#38603838">next</a><span>|</span><label class="collapse" for="c-38603243">[-]</label><label class="expand" for="c-38603243">[12 more]</label></div><br/><div class="children"><div class="content">I think it would be more interesting to compile to LLVM IR, so you don&#x27;t have to deal with C. Part of the appeal of Wasm is that it&#x27;s a modern system that doesn&#x27;t have to deal with 70s nonsense.</div><br/><div id="38603381" class="c"><input type="checkbox" id="c-38603381" checked=""/><div class="controls bullet"><span class="by">turbolent</span><span>|</span><a href="#38603243">parent</a><span>|</span><a href="#38604214">next</a><span>|</span><label class="collapse" for="c-38603381">[-]</label><label class="expand" for="c-38603381">[2 more]</label></div><br/><div class="children"><div class="content">You do not have to deal with the generated C, simply consider it the IR.<p>The main benefit of generating C over LLVM IR is portability: C is supported by far more systems than LLVM can target.<p>For example, it enables porting Rust applications to Mac OS 9 (<a href="https:&#x2F;&#x2F;twitter.com&#x2F;turbolent&#x2F;status&#x2F;1617231570573873152" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;turbolent&#x2F;status&#x2F;1617231570573873152</a>), or porting Python to  all sorts of operating systems and CPUs (<a href="https:&#x2F;&#x2F;twitter.com&#x2F;turbolent&#x2F;status&#x2F;1621992945745547264" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;turbolent&#x2F;status&#x2F;1621992945745547264</a>).<p>The main &quot;goal&quot; of w2c2 so far has been allowing to port applications and libraries to as many systems as possible.
For more information, see the README of w2c2.</div><br/><div id="38606753" class="c"><input type="checkbox" id="c-38606753" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38603243">root</a><span>|</span><a href="#38603381">parent</a><span>|</span><a href="#38604214">next</a><span>|</span><label class="collapse" for="c-38606753">[-]</label><label class="expand" for="c-38606753">[1 more]</label></div><br/><div class="children"><div class="content">You do have to deal with the generated C though. Unless you just generate it and throw it away?</div><br/></div></div></div></div><div id="38604214" class="c"><input type="checkbox" id="c-38604214" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#38603243">parent</a><span>|</span><a href="#38603381">prev</a><span>|</span><a href="#38603438">next</a><span>|</span><label class="collapse" for="c-38604214">[-]</label><label class="expand" for="c-38604214">[3 more]</label></div><br/><div class="children"><div class="content">&gt;I think it would be more interesting to compile to LLVM IR<p>C is a stable format that&#x27;s backwards compatible for decades; LLVM IR changes with every LLM release. Unnecessarily tying stuff to a LLVM version is a nightmare waiting to happen.</div><br/><div id="38605560" class="c"><input type="checkbox" id="c-38605560" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38603243">root</a><span>|</span><a href="#38604214">parent</a><span>|</span><a href="#38603438">next</a><span>|</span><label class="collapse" for="c-38605560">[-]</label><label class="expand" for="c-38605560">[2 more]</label></div><br/><div class="children"><div class="content">Obligatory âC is not a low-level languageâ blog post.<p>Standard C doesnât specify any specifically low-level detail, no cache, no vector instructions, nothing.</div><br/><div id="38608944" class="c"><input type="checkbox" id="c-38608944" checked=""/><div class="controls bullet"><span class="by">remexre</span><span>|</span><a href="#38603243">root</a><span>|</span><a href="#38605560">parent</a><span>|</span><a href="#38603438">next</a><span>|</span><label class="collapse" for="c-38608944">[-]</label><label class="expand" for="c-38608944">[1 more]</label></div><br/><div class="children"><div class="content">But we&#x27;re not expecting that the produced C (or LLVM IR) has already had target-specific optimization applied, so as long as the C compiler is an optimizing compiler, that&#x27;s not a problem?</div><br/></div></div></div></div></div></div><div id="38603438" class="c"><input type="checkbox" id="c-38603438" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38603243">parent</a><span>|</span><a href="#38604214">prev</a><span>|</span><a href="#38605128">next</a><span>|</span><label class="collapse" for="c-38603438">[-]</label><label class="expand" for="c-38603438">[3 more]</label></div><br/><div class="children"><div class="content">That would<p>1. Put more onus for optimization on the converter<p>2. Mean you can&#x27;t target as many platforms</div><br/><div id="38605010" class="c"><input type="checkbox" id="c-38605010" checked=""/><div class="controls bullet"><span class="by">connicpu</span><span>|</span><a href="#38603243">root</a><span>|</span><a href="#38603438">parent</a><span>|</span><a href="#38605128">next</a><span>|</span><label class="collapse" for="c-38605010">[-]</label><label class="expand" for="c-38605010">[2 more]</label></div><br/><div class="children"><div class="content">To be fair for point 1, if you have LLVM IR you can just run the full LLVM optimizer suite over it. But overall LLVM IR is a poor target because it constantly changes with every LLVM release.</div><br/><div id="38605711" class="c"><input type="checkbox" id="c-38605711" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#38603243">root</a><span>|</span><a href="#38605010">parent</a><span>|</span><a href="#38605128">next</a><span>|</span><label class="collapse" for="c-38605711">[-]</label><label class="expand" for="c-38605711">[1 more]</label></div><br/><div class="children"><div class="content">LLVM does some optimizations, but compilers that target it normally do their own optimizations before generating the IR, because they know more than LLVM does about the higher-level source language and what can be done with it<p>So eg, you may generate LLVM IR directly and only get LLVM&#x27;s optimizations, or you may generate C and compile it with Clang and get Clang&#x27;s optimizations + LLVM&#x27;s optimizations<p>You could always implement your own pre-LLVM optimizations in your LLVM IR generator, but as I think we all know, that&#x27;s a huge amount of extra work (which is the OP&#x27;s point)</div><br/></div></div></div></div></div></div><div id="38605128" class="c"><input type="checkbox" id="c-38605128" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#38603243">parent</a><span>|</span><a href="#38603438">prev</a><span>|</span><a href="#38603345">next</a><span>|</span><label class="collapse" for="c-38605128">[-]</label><label class="expand" for="c-38605128">[1 more]</label></div><br/><div class="children"><div class="content">LLVM IR is a moving target, and AFAIK actually also target platform specific because of things like different per-CPU&#x2F;per-platform ABIs.<p>C on the other hand is standardized, stable, ABI agnostic and compiles on pretty much anything that has a CPU.</div><br/></div></div><div id="38603345" class="c"><input type="checkbox" id="c-38603345" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#38603243">parent</a><span>|</span><a href="#38605128">prev</a><span>|</span><a href="#38603838">next</a><span>|</span><label class="collapse" for="c-38603345">[-]</label><label class="expand" for="c-38603345">[2 more]</label></div><br/><div class="children"><div class="content">C is not a large language, and a transpiler can choose to generate code that only uses a subset of the features of the language, and can choose to be consistent about safety mechanisms that the underlying language doesn&#x27;t guarantee.<p>When you say &quot;70s nonsense&quot; are there specific C features you are concerned about?  I would think that transpilation can just avoid bad practices like passing around void * pointers and then casting them optimistically, or even the use of char * for strings in favor of a bounds-checked alternative.</div><br/><div id="38607532" class="c"><input type="checkbox" id="c-38607532" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38603243">root</a><span>|</span><a href="#38603345">parent</a><span>|</span><a href="#38603838">next</a><span>|</span><label class="collapse" for="c-38607532">[-]</label><label class="expand" for="c-38607532">[1 more]</label></div><br/><div class="children"><div class="content">C can&#x27;t represent lots of information that would be useful, e.g. while C99 has a limited &quot;restrict&quot; function, you can&#x27;t express any more complex detail of &quot;these things can only alias under these circumstances&quot;. If the hardware supports doing anything useful with sum types (e.g. atomic operations), there is no way to expose that in the C model. C specifies a concept of trap representations but anything you would actually do with them is undefined behaviour, so you can&#x27;t write code that e.g. safely errors out when someone tries to use an uninitialized pointer. Even for arithmetic on standard hardware, the ability to fully express even quite basic things is limited - you can&#x27;t write code that e.g. permits signed overflow to occur and handles it if it does. You effectively can&#x27;t use any floating point rounding modes except the most broken one, at least not if your code ever uses threads. I&#x27;m sure there&#x27;s more.</div><br/></div></div></div></div></div></div><div id="38603838" class="c"><input type="checkbox" id="c-38603838" checked=""/><div class="controls bullet"><span class="by">nbittich</span><span>|</span><a href="#38603243">prev</a><span>|</span><a href="#38604081">next</a><span>|</span><label class="collapse" for="c-38603838">[-]</label><label class="expand" for="c-38603838">[1 more]</label></div><br/><div class="children"><div class="content">So you take a language that compiles to wasm, then you take your wasm output and transpile it to c? Welcome to the frontend world I guess</div><br/></div></div><div id="38604081" class="c"><input type="checkbox" id="c-38604081" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38603838">prev</a><span>|</span><label class="collapse" for="c-38604081">[-]</label><label class="expand" for="c-38604081">[19 more]</label></div><br/><div class="children"><div class="content">All the stuff trying to use WebAssembly outside the browser, without looking into all bytecode formats that have trailled the same path for decades since early 1960&#x27;s is getting tiresome.</div><br/><div id="38604382" class="c"><input type="checkbox" id="c-38604382" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38604081">parent</a><span>|</span><a href="#38604398">next</a><span>|</span><label class="collapse" for="c-38604382">[-]</label><label class="expand" for="c-38604382">[11 more]</label></div><br/><div class="children"><div class="content">Do you have any actual interesting critiques of the wasm bytecode format and what it has failed to learn from Java bytecode or CLR bytecode or whatever? Because that would be interesting, and I&#x27;m sure there are design choices to analyze and criticise. Empty references to the potential existence of problems isn&#x27;t very interesting though.</div><br/><div id="38609809" class="c"><input type="checkbox" id="c-38609809" checked=""/><div class="controls bullet"><span class="by">kouteiheika</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604382">parent</a><span>|</span><a href="#38604999">next</a><span>|</span><label class="collapse" for="c-38609809">[-]</label><label class="expand" for="c-38609809">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Do you have any actual interesting critiques of the wasm bytecode format and what it has failed to learn from Java bytecode or CLR bytecode or whatever?<p>I&#x27;m not OP, and I don&#x27;t know if you could have figured this out by just looking at the bytecode formats that came before it, but I think the biggest design mistake of WASM is most likely it being a stack machine. It gives very little (if any?) practical benefits and it just massively complicates everything, both the compilers <i>and</i> the VMs.<p>I&#x27;m not speculating here. I have a pet VM that I&#x27;m developing for a register-based IR which achieves roughly the same execution performance of guest programs as wasmtime, but compiles them into native code 160 times faster, doesn&#x27;t compromise on security, has a bytecode format which takes roughly as much space as WASM, and with an implementation that is vastly less complex (wasmtime&#x27;s Cranelift is ~150k lines of code; my codegen is, maybe, ~2k lines of code, depending on how you count).</div><br/></div></div><div id="38604999" class="c"><input type="checkbox" id="c-38604999" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604382">parent</a><span>|</span><a href="#38609809">prev</a><span>|</span><a href="#38604398">next</a><span>|</span><label class="collapse" for="c-38604999">[-]</label><label class="expand" for="c-38604999">[9 more]</label></div><br/><div class="children"><div class="content">Start with Burroughs Large Machines from 1961, do a stop at Xerox PARC, visit ETHZ, Bell Labs,  Amsterdam University, Caltech, Tao Group, UCSD, IBM and Unisys mainframes, Microsoft R&amp;D, and already there are several bytecodes to look into.<p>The hype around WebAssembly is also not very interesting for those of us that have read hundreds of papers on those bytecodes, but hey there is VC money to burn.</div><br/><div id="38605190" class="c"><input type="checkbox" id="c-38605190" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604999">parent</a><span>|</span><a href="#38606164">next</a><span>|</span><label class="collapse" for="c-38605190">[-]</label><label class="expand" for="c-38605190">[3 more]</label></div><br/><div class="children"><div class="content">I think that network effects win over technical merit every time, and this time WebAssembly has the momentum.  I think it&#x27;s pretty neat that you can take a web server written in C++, implement some new compression algorithm in Go, and then have that web server compress pages with your Go code without having to recompile the webserver or touch any of its code.  That&#x27;s what WebAssembly outside of the browser offers; you can just write stuff in your language of choosing for other products.  All the VC hype just means that everyone picked the same backend so there is some possibility of traction.<p>In reality, some flaws are preventing adoption.  C and Rust are pretty much the only viable languages with WebAssembly support, and since those are also the chosen implementation languages for runtime, nobody is really deriving this benefit.  (Anything with a runtime seems to fail for programs beyond &quot;hello world&quot;.)<p>(I tried a &quot;real program&quot; and WebAssembly once, but it ran out of memory when compiled with either gc or tinygo.  We had to write the browser side of things in Javascript, which was a shame. The code in question was: <a href="https:&#x2F;&#x2F;github.com&#x2F;pachyderm&#x2F;pachyderm&#x2F;blob&#x2F;master&#x2F;src&#x2F;internal&#x2F;archiveserver&#x2F;encode.go#L22">https:&#x2F;&#x2F;github.com&#x2F;pachyderm&#x2F;pachyderm&#x2F;blob&#x2F;master&#x2F;src&#x2F;inter...</a>.  Somewhat complex, but not so complex you can&#x27;t do it in Javascript.  So a bit of a shame that WebAssembly didn&#x27;t work out.)<p>The other thing that I think WebAssembly should fix (but people seem to want to kill me when I mention this) is that the Typescript compiler should just output WebAssembly and we can forget about node_modules and Webpack and that whole nightmare.  There is AssemblyScript, but it doesn&#x27;t run React, so doesn&#x27;t matter for this use case.<p>Someday I will go insane and just compile node or deno to WebAssembly and just ship the whole VM with my app embedded in it.  Then you&#x27;ll have a real reason to want to kill me!  Muahahaha.</div><br/><div id="38610754" class="c"><input type="checkbox" id="c-38610754" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38605190">parent</a><span>|</span><a href="#38606206">next</a><span>|</span><label class="collapse" for="c-38610754">[-]</label><label class="expand" for="c-38610754">[1 more]</label></div><br/><div class="children"><div class="content">Some of those bytecodes were already polyglot, this idea is as old as UNCOL, from 1958.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;UNCOL" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;UNCOL</a></div><br/></div></div><div id="38606206" class="c"><input type="checkbox" id="c-38606206" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38605190">parent</a><span>|</span><a href="#38610754">prev</a><span>|</span><a href="#38606164">next</a><span>|</span><label class="collapse" for="c-38606206">[-]</label><label class="expand" for="c-38606206">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some cool stuff going on with GC in WebAssembly, which should really help bring higher level languages efficiently to WASM: <a href="https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;wasm-gc-porting" rel="nofollow noreferrer">https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;wasm-gc-porting</a>.</div><br/></div></div></div></div><div id="38606164" class="c"><input type="checkbox" id="c-38606164" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604999">parent</a><span>|</span><a href="#38605190">prev</a><span>|</span><a href="#38605288">next</a><span>|</span><label class="collapse" for="c-38606164">[-]</label><label class="expand" for="c-38606164">[2 more]</label></div><br/><div class="children"><div class="content">I know that there are existing bytecodes. I&#x27;m asking what you think WebAssembly should have learned from them but didn&#x27;t. But based on your response I&#x27;m guessing you don&#x27;t really have that kind of thoughtful critique of WebAssembly?</div><br/><div id="38610731" class="c"><input type="checkbox" id="c-38610731" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38606164">parent</a><span>|</span><a href="#38605288">next</a><span>|</span><label class="collapse" for="c-38610731">[-]</label><label class="expand" for="c-38610731">[1 more]</label></div><br/><div class="children"><div class="content">Here is one, despite all the security marketing, programs inside the sandbox can still be tricked into internal memory corruption, as there is no way to prevent bounds checking inside the same linear memory segment.<p>So they are bound to black box attacks, where a clever sequence of function calls can eventually result in something being allowed that wasn&#x27;t before, as the internal memory state of the WASM module is now corrupt.</div><br/></div></div></div></div><div id="38605288" class="c"><input type="checkbox" id="c-38605288" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604999">parent</a><span>|</span><a href="#38606164">prev</a><span>|</span><a href="#38607392">next</a><span>|</span><label class="collapse" for="c-38605288">[-]</label><label class="expand" for="c-38605288">[1 more]</label></div><br/><div class="children"><div class="content">&gt; hey there is VC money to burn.<p>given the absolute idiocy some of them finance WASM is a paragon of sensibility and should be injected money via IV. special mentions go out to softbank, tiger global and a16z.</div><br/></div></div><div id="38607392" class="c"><input type="checkbox" id="c-38607392" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604999">parent</a><span>|</span><a href="#38605288">prev</a><span>|</span><a href="#38604398">next</a><span>|</span><label class="collapse" for="c-38607392">[-]</label><label class="expand" for="c-38607392">[2 more]</label></div><br/><div class="children"><div class="content">What is your actual technical criticism?</div><br/><div id="38610741" class="c"><input type="checkbox" id="c-38610741" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38607392">parent</a><span>|</span><a href="#38604398">next</a><span>|</span><label class="collapse" for="c-38610741">[-]</label><label class="expand" for="c-38610741">[1 more]</label></div><br/><div class="children"><div class="content">Selling WASM as the solution of all problems in the world, and being the first at anything.</div><br/></div></div></div></div></div></div></div></div><div id="38604398" class="c"><input type="checkbox" id="c-38604398" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38604081">parent</a><span>|</span><a href="#38604382">prev</a><span>|</span><a href="#38604125">next</a><span>|</span><label class="collapse" for="c-38604398">[-]</label><label class="expand" for="c-38604398">[5 more]</label></div><br/><div class="children"><div class="content">Not just that, but which device today doesn&#x27;t have hardware virtualization where you are literally in a sandbox, running on the actual CPU with all the advanced instruction set extensions available to you?<p>Some of these WASM run-times are literally hundreds of thousands of lines of code running just-in-time compilation. Inferno-level safety hazard.</div><br/><div id="38604770" class="c"><input type="checkbox" id="c-38604770" checked=""/><div class="controls bullet"><span class="by">keithwinstein</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604398">parent</a><span>|</span><a href="#38604125">next</a><span>|</span><label class="collapse" for="c-38604770">[-]</label><label class="expand" for="c-38604770">[4 more]</label></div><br/><div class="children"><div class="content">It takes tens or hundreds of microseconds to launch a new thread on Linux, and tens or hundreds of milliseconds (or more) to launch a new VM.<p>It takes tens of <i>cycles</i> to instantiate a Wasm module and call one of its exported functions.<p>There are some serious benefits to OS-mediated hardware isolation, but there are also some real benefits to the &quot;ahead-of-time&quot; isolation you can get from something like Wasm (e.g. via wasm2c-&gt;a C compiler-&gt;machine code, but also with more mainstream tools like wasmtime).</div><br/><div id="38605431" class="c"><input type="checkbox" id="c-38605431" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38604770">parent</a><span>|</span><a href="#38604125">next</a><span>|</span><label class="collapse" for="c-38605431">[-]</label><label class="expand" for="c-38605431">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an impressive feat if true, but I wonder when you would need it outside of a seriously threaded architecture. That is, the server you are embedded in has one thread per client or backend. In a modern server architecture I suspect you could still use KVM if you put your mind to it. For example, switching between internal processes doesn&#x27;t have to be done according to Linux scheduling. KVM is just a hypervisor architecture, and even though it requires you to call it from the current thread, you can still build fast process isolation on it. Source: I have done it.<p>Launching a new VM is not something that should be done outside of a restart or reconfiguration.<p>I think for me, what WASM brings to the table is perhaps reduced Linux-isms. Everything has become a little bit Linux-or-nothing, and if WASM presents a unified API towards all operating systems that is a good thing. I&#x27;m still not happy that Browsers are de-facto operating systems now, and with WASM even more so.</div><br/><div id="38608380" class="c"><input type="checkbox" id="c-38608380" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38605431">parent</a><span>|</span><a href="#38604125">next</a><span>|</span><label class="collapse" for="c-38608380">[-]</label><label class="expand" for="c-38608380">[2 more]</label></div><br/><div class="children"><div class="content">I gave a talk at Cloud Native wasm day talking about some of the stuff you can do with a WasmVM. Redpanda (where I work) is a storage engine whoâs performance is predicated on kernel bypass (Direct IO, thread per core, locked memory). You can use stack switching to context switch between the VM and host application in a handful of cycles. Also having good upstream tooling for a lot of popular languages is big for adoption.<p>Link to the talk if interested: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;t4-Al2FoU0k" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;t4-Al2FoU0k</a></div><br/><div id="38609771" class="c"><input type="checkbox" id="c-38609771" checked=""/><div class="controls bullet"><span class="by">fwsgonzo</span><span>|</span><a href="#38604081">root</a><span>|</span><a href="#38608380">parent</a><span>|</span><a href="#38604125">next</a><span>|</span><label class="collapse" for="c-38609771">[-]</label><label class="expand" for="c-38609771">[1 more]</label></div><br/><div class="children"><div class="content">Cool. I watched it twice! I thought you meant the stack switching done by wasmtime, which is not &quot;a handful of cycles,&quot; but I stand corrected: It&#x27;s fiber&#x2F;coro switching. Alfred, a friend of mine, gave a talk on using those on a bare metal unikernel we were creating back in the day! :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38604125" class="c"><input type="checkbox" id="c-38604125" checked=""/><div class="controls bullet"><span class="by">alex_suzuki</span><span>|</span><a href="#38604081">parent</a><span>|</span><a href="#38604398">prev</a><span>|</span><a href="#38604205">next</a><span>|</span><label class="collapse" for="c-38604125">[-]</label><label class="expand" for="c-38604125">[1 more]</label></div><br/><div class="children"><div class="content">Butâ¦ itâs new!</div><br/></div></div></div></div></div></div></div></div></div></body></html>