<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699520478082" as="style"/><link rel="stylesheet" href="styles.css?v=1699520478082"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://eslint.org/blog/2022/07/interesting-bugs-caught-by-no-constant-binary-expression/">Interesting Bugs Caught by ESLint&#x27;s no-constant-binary-expression</a> <span class="domain">(<a href="https://eslint.org">eslint.org</a>)</span></div><div class="subtext"><span>CharlesW</span> | <span>114 comments</span></div><br/><div><div id="38199028" class="c"><input type="checkbox" id="c-38199028" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#38198067">next</a><span>|</span><label class="collapse" for="c-38199028">[-]</label><label class="expand" for="c-38199028">[9 more]</label></div><br/><div class="children"><div class="content">This is pretty compelling. Why isn&#x27;t it in the &quot;recommended&quot; preset of lints?<p>In general, I find it frustrating that the eslint recommended presets don&#x27;t document <i>why</i> they are recommended. I disable several of the rules in all my projects because they seem to be arbitrary stylistic choices (e.g. [0], [1], [2]).<p>[0] <a href="https:&#x2F;&#x2F;typescript-eslint.io&#x2F;rules&#x2F;no-empty-function&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;typescript-eslint.io&#x2F;rules&#x2F;no-empty-function&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;blob&#x2F;master&#x2F;docs&#x2F;rules&#x2F;no-children-prop.md">https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;blob&#x2F;maste...</a><p>[2] Specifically checkLoops of <a href="https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;no-constant-condition" rel="nofollow noreferrer">https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;no-constant-condition</a><p>[edit] In looking up no-empty-function, I saw a stack overflow post that provides a compelling alternative of using `() =&gt; undefined` instead of `() =&gt; {}`, which suppresses the error. That should be shown as an example on the eslint page!</div><br/><div id="38199651" class="c"><input type="checkbox" id="c-38199651" checked=""/><div class="controls bullet"><span class="by">btmills</span><span>|</span><a href="#38199028">parent</a><span>|</span><a href="#38200719">next</a><span>|</span><label class="collapse" for="c-38199651">[-]</label><label class="expand" for="c-38199651">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I find it frustrating that the eslint recommended presets don&#x27;t document why they are recommended.<p>That’s a good point. While this doesn’t address the root problem, I can share some context here as a former maintainer: browsing the core rules [1], you should see that  recommended rules flag cases that are highly likely to be bugs or unnecessary constructs. Recommended rules should have false positives only in exceptional cases and be objective or near-universal consensus opinions.<p>Plugins, of course, are free to choose their own threshold for their recommended configs.<p>&gt; Why isn&#x27;t it in the &quot;recommended&quot; preset of lints?<p>It will be added to recommended in v9! [2] The rule was written during one of the v8 minor versions, and adding to the recommended config is always a breaking change.<p>[1]: <a href="https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;latest&#x2F;rules&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;eslint&#x2F;eslint&#x2F;issues&#x2F;17596">https:&#x2F;&#x2F;github.com&#x2F;eslint&#x2F;eslint&#x2F;issues&#x2F;17596</a></div><br/></div></div><div id="38200719" class="c"><input type="checkbox" id="c-38200719" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#38199028">parent</a><span>|</span><a href="#38199651">prev</a><span>|</span><a href="#38201197">next</a><span>|</span><label class="collapse" for="c-38200719">[-]</label><label class="expand" for="c-38200719">[2 more]</label></div><br/><div class="children"><div class="content">Regarding the recommendations:<p>0 is to prevent mistakes where you declare a function, but forget to implement it. If that&#x27;s really intended I like to put a comment &quot;do nothing&quot; in empty functions, even in projects without the ESLint rule, so future readers know what&#x27;s going on.<p>1 is for consistency &amp; readability. Imagine you read someone else&#x27;s code like &lt;div children=&quot;foo&quot; &#x2F;&gt;, and you see that it&#x27;s self-closing, so you expect it&#x27;s an empty div. Even more confusing when you have more than just one attribute. Or say you want to modify the code to add a new child, so you remove the self-closing and add the child, breaking the old children in the process. What is the reason for doing children=&quot;foo&quot; in the first place anyways?<p>2 is to prevent infinite loops, it&#x27;s good practice to keep an upper bound (in a single-threaded world like JS, infinite loops can be very deadly and hard to diagnose). I like NASA&#x27;s ten coding commandments (this is #2): <a href="https:&#x2F;&#x2F;devm.io&#x2F;careers&#x2F;power-ten-nasas-coding-commandments-114124" rel="nofollow noreferrer">https:&#x2F;&#x2F;devm.io&#x2F;careers&#x2F;power-ten-nasas-coding-commandments-...</a></div><br/><div id="38200807" class="c"><input type="checkbox" id="c-38200807" checked=""/><div class="controls bullet"><span class="by">FranksTV</span><span>|</span><a href="#38199028">root</a><span>|</span><a href="#38200719">parent</a><span>|</span><a href="#38201197">next</a><span>|</span><label class="collapse" for="c-38200807">[-]</label><label class="expand" for="c-38200807">[1 more]</label></div><br/><div class="children"><div class="content">I find throwing an error that says &quot;not implemented&quot; to be a good solution. Or at least logging a warning.</div><br/></div></div></div></div><div id="38201197" class="c"><input type="checkbox" id="c-38201197" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38199028">parent</a><span>|</span><a href="#38200719">prev</a><span>|</span><a href="#38199543">next</a><span>|</span><label class="collapse" for="c-38201197">[-]</label><label class="expand" for="c-38201197">[1 more]</label></div><br/><div class="children"><div class="content">Author of the rule&#x2F;post here. It&#x27;s planned to be included in the set of recommend  rules in version 9. <a href="https:&#x2F;&#x2F;eslint.org&#x2F;blog&#x2F;2023&#x2F;11&#x2F;whats-coming-in-eslint-9.0.0&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;eslint.org&#x2F;blog&#x2F;2023&#x2F;11&#x2F;whats-coming-in-eslint-9.0.0...</a></div><br/></div></div><div id="38199543" class="c"><input type="checkbox" id="c-38199543" checked=""/><div class="controls bullet"><span class="by">gwern</span><span>|</span><a href="#38199028">parent</a><span>|</span><a href="#38201197">prev</a><span>|</span><a href="#38201455">next</a><span>|</span><label class="collapse" for="c-38199543">[-]</label><label class="expand" for="c-38199543">[2 more]</label></div><br/><div class="children"><div class="content">Presumably it&#x27;s not yet default because it&#x27;s so new, and that&#x27;s why he ends the post by asking for tester to opt-in and report any issues.</div><br/><div id="38201814" class="c"><input type="checkbox" id="c-38201814" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38199028">root</a><span>|</span><a href="#38199543">parent</a><span>|</span><a href="#38201455">next</a><span>|</span><label class="collapse" for="c-38201814">[-]</label><label class="expand" for="c-38201814">[1 more]</label></div><br/><div class="children"><div class="content">This is correct. The post is from 2022. New default rules are a breaking change and version 9, the first major relates since it was added, is coming soon and will include it by default.</div><br/></div></div></div></div><div id="38201455" class="c"><input type="checkbox" id="c-38201455" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#38199028">parent</a><span>|</span><a href="#38199543">prev</a><span>|</span><a href="#38198067">next</a><span>|</span><label class="collapse" for="c-38201455">[-]</label><label class="expand" for="c-38201455">[2 more]</label></div><br/><div class="children"><div class="content">&gt; [1] <a href="https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;blob&#x2F;master&#x2F;docs&#x2F;rules&#x2F;no-children-prop.md">https:&#x2F;&#x2F;github.com&#x2F;jsx-eslint&#x2F;eslint-plugin-react&#x2F;blob&#x2F;maste...</a><p>From what I remember, being able to pass children as a prop is considered a side-effect of an implementation detail, that breaks the expected abstraction.  There really isn&#x27;t any reason to use it, and I think there&#x27;s a chance it may even limit what the virtual dom diffing can manage?<p>Also this would prevent you from accidentally doing both at once:<p><pre><code>  &lt;MyComponent children={&lt;div&gt;Is it me?&lt;&#x2F;div&gt;}&gt;
    &lt;div&gt;Or is it me?&lt;&#x2F;div&gt;
  &lt;&#x2F;MyComponent&gt;
</code></pre>
(I don&#x27;t remember what React does in this situation)</div><br/><div id="38201830" class="c"><input type="checkbox" id="c-38201830" checked=""/><div class="controls bullet"><span class="by">MrJohz</span><span>|</span><a href="#38199028">root</a><span>|</span><a href="#38201455">parent</a><span>|</span><a href="#38198067">next</a><span>|</span><label class="collapse" for="c-38201830">[-]</label><label class="expand" for="c-38201830">[1 more]</label></div><br/><div class="children"><div class="content">I use it fairly extensively whenever I have code like &lt;Cpt&gt;{props.children}&lt;&#x2F;Cpt&gt; (i.e. whenever the only thing I&#x27;m doing with the children prop is passing it to another component. This comes up pretty often with context providers, where I&#x27;ll write a provider wrapper that handles some stuff by itself, and then passes the value and children to a React context.<p>I like using the &quot;children&quot; prop explicitly because it&#x27;s a lot more concise (with prettier, I can often go from five lines to one line with this style), and because it&#x27;s more explicit. I&#x27;m not creating my own children, I&#x27;m not adding anything to the markup myself, I&#x27;m just passing the input children directly to another component.<p>This isn&#x27;t really anything unusual, it&#x27;s exactly what JSX compiles to under the hood. And passing JSX elements in props rather than as children is useful in other contexts as well - for example, a button that allows &lt;Btn icon={&lt;MyIcon &#x2F;&gt;} ...&gt;<p>You&#x27;re right that this can cause odd situations where children are specified in two ways, but I&#x27;d rather have a lint rule explicitly handle this case than disallow using the &quot;children&quot; prop altogether. (In fact, I think Typescript does validate this case already? But I might be wrong there.)<p>I can see why this rule might be useful to have in general, but I agree with the previous poster that it&#x27;s a semi-opinionated rule, and one of the sort of rules where I end up having to disable it and fiddle around with configs whenever it comes up, which in turn puts me off using ESLint in general because I know to get it to be useful I&#x27;m going to need to spend some time changing everything up.</div><br/></div></div></div></div></div></div><div id="38198067" class="c"><input type="checkbox" id="c-38198067" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38199028">prev</a><span>|</span><a href="#38201038">next</a><span>|</span><label class="collapse" for="c-38198067">[-]</label><label class="expand" for="c-38198067">[12 more]</label></div><br/><div class="children"><div class="content">&gt; Eventually it clicked for me: developers don’t intend to write useless code, and code that does not match the developer’s intent is by definition a bug. Therefore, any useless code you can detect is a bug.<p>I&#x27;m not completely sure I would take it all the way to calling it a bug, but I do appreciate a rigorous way to simplify code, because the worst case is that you&#x27;ve made it easier to reason about and that&#x27;s a win all by itself.<p>(EDIT: This post also makes me feel better about my personal coding style being paranoid and doing things like using parens to force order of operations and avoiding &quot;advanced&quot; constructs like ?? because I don&#x27;t trust myself to not shoot myself in the foot. I&#x27;m not a professional dev, so I&#x27;m happy to write verbose, inelegant code in exchange for it being so simple that I&#x27;m less likely to screw it up)</div><br/><div id="38198869" class="c"><input type="checkbox" id="c-38198869" checked=""/><div class="controls bullet"><span class="by">zeta0134</span><span>|</span><a href="#38198067">parent</a><span>|</span><a href="#38201258">next</a><span>|</span><label class="collapse" for="c-38198869">[-]</label><label class="expand" for="c-38198869">[7 more]</label></div><br/><div class="children"><div class="content">I am a professional developer, and I&#x27;ll take the verbose, ugly, but readable code every time. Clever code that makes me work harder to understand what it does has a greater chance of being missed, blindly trusted, or just misunderstood, and that causes us untold numbers of headaches.<p>Writing clear, concise code is *hard.* Writing just clear code, conciseness be damned, is a perfectly fine middle ground.</div><br/><div id="38199174" class="c"><input type="checkbox" id="c-38199174" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38198869">parent</a><span>|</span><a href="#38199307">next</a><span>|</span><label class="collapse" for="c-38199174">[-]</label><label class="expand" for="c-38199174">[3 more]</label></div><br/><div class="children"><div class="content">OK but if you have large amounts of unused code throughout the codebase, mistakes are more likely to be &quot;missed, blindly trusted, or just misunderstood&quot;.</div><br/><div id="38199425" class="c"><input type="checkbox" id="c-38199425" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38199174">parent</a><span>|</span><a href="#38199563">next</a><span>|</span><label class="collapse" for="c-38199425">[-]</label><label class="expand" for="c-38199425">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but if you have large amounts of unused code throughout the codebase<p>Delete it? Version control is your backup</div><br/></div></div><div id="38199563" class="c"><input type="checkbox" id="c-38199563" checked=""/><div class="controls bullet"><span class="by">jay_kyburz</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38199174">parent</a><span>|</span><a href="#38199425">prev</a><span>|</span><a href="#38199307">next</a><span>|</span><label class="collapse" for="c-38199563">[-]</label><label class="expand" for="c-38199563">[1 more]</label></div><br/><div class="children"><div class="content">I think when the OP says concise they mean using several lines to make some logic clear, rather than a tricky little one liners. (like many of the mistakes in the article)</div><br/></div></div></div></div><div id="38199307" class="c"><input type="checkbox" id="c-38199307" checked=""/><div class="controls bullet"><span class="by">jay_kyburz</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38198869">parent</a><span>|</span><a href="#38199174">prev</a><span>|</span><a href="#38200813">next</a><span>|</span><label class="collapse" for="c-38199307">[-]</label><label class="expand" for="c-38199307">[2 more]</label></div><br/><div class="children"><div class="content">I agree. (!someBool == anotherBool)  very bad code if you ask me.</div><br/><div id="38201886" class="c"><input type="checkbox" id="c-38201886" checked=""/><div class="controls bullet"><span class="by">amatecha</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38199307">parent</a><span>|</span><a href="#38200813">next</a><span>|</span><label class="collapse" for="c-38201886">[-]</label><label class="expand" for="c-38201886">[1 more]</label></div><br/><div class="children"><div class="content">yeah, it&#x27;s reassuring that for most (all?) of these I&#x27;m like &quot;I would never write that&quot;... though I also lean towards very &quot;simple&quot; code that is not only blatantly clear but totally non-&quot;clever&quot;.  I&#x27;d rather the early-in-career dev we bring in 6-12mo later can read it and immediately parse it.  Plus it&#x27;s easier for ME 6-12mo later! hahah :)</div><br/></div></div></div></div><div id="38200813" class="c"><input type="checkbox" id="c-38200813" checked=""/><div class="controls bullet"><span class="by">FranksTV</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38198869">parent</a><span>|</span><a href="#38199307">prev</a><span>|</span><a href="#38201258">next</a><span>|</span><label class="collapse" for="c-38200813">[-]</label><label class="expand" for="c-38200813">[1 more]</label></div><br/><div class="children"><div class="content">agreeWithPreviousCommentOnUselessCode()</div><br/></div></div></div></div><div id="38201258" class="c"><input type="checkbox" id="c-38201258" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198067">parent</a><span>|</span><a href="#38198869">prev</a><span>|</span><a href="#38199559">next</a><span>|</span><label class="collapse" for="c-38201258">[-]</label><label class="expand" for="c-38201258">[1 more]</label></div><br/><div class="children"><div class="content">Author of the rule and post here. I reread the post this morning, and I agree that I should have been less definitive in that sentence. But I stand by the broader point: Useless code is generally not something developers intend to write. When we do, it&#x27;s generally something exceptional, so a lint suppression is a reasonable way to clarify &quot;I meant to do that&quot;. And in the common case where it was an error, the lint rule proves quite helpful.<p>I hope the take away for the reader is: If you can think of other rules that will detect useless code, you should pursue them, because they are likely more valuable than just enabling dead code elimination. They have a high probability of being able to uncover interesting bugs&#x2F;mistakes as well, which is much more valuable.</div><br/></div></div><div id="38199559" class="c"><input type="checkbox" id="c-38199559" checked=""/><div class="controls bullet"><span class="by">Alex3917</span><span>|</span><a href="#38198067">parent</a><span>|</span><a href="#38201258">prev</a><span>|</span><a href="#38201176">next</a><span>|</span><label class="collapse" for="c-38199559">[-]</label><label class="expand" for="c-38199559">[2 more]</label></div><br/><div class="children"><div class="content">I often add an extra line or two of no-op code in order to improve readability. But in these examples, the code clearly wasn&#x27;t written to communicate anything, but rather by mistake.</div><br/><div id="38201820" class="c"><input type="checkbox" id="c-38201820" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198067">root</a><span>|</span><a href="#38199559">parent</a><span>|</span><a href="#38201176">next</a><span>|</span><label class="collapse" for="c-38201820">[-]</label><label class="expand" for="c-38201820">[1 more]</label></div><br/><div class="children"><div class="content">Rule author here. Would love to see some examples! I think the closest I’ve (knowingly) done to this is to add an empty else clause that contains a comment.</div><br/></div></div></div></div></div></div><div id="38201038" class="c"><input type="checkbox" id="c-38201038" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#38198067">prev</a><span>|</span><a href="#38202555">next</a><span>|</span><label class="collapse" for="c-38201038">[-]</label><label class="expand" for="c-38201038">[22 more]</label></div><br/><div class="children"><div class="content">&gt; When trying to define default values, people get confused with expressions like a === b ?? c and assume it will be parsed as a === (b ?? c). When in actuality it will be parsed as (a === b) ?? c.<p>I&#x27;ll never understand why programmers don&#x27;t simply put parens where they <i>want</i> the expression to be evaluated, rather than relying on their (sometimes incorrect) assumption about operator precedence. I want to chalk this up to hubris, but it&#x27;s probably just laziness.</div><br/><div id="38201223" class="c"><input type="checkbox" id="c-38201223" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38201038">parent</a><span>|</span><a href="#38201516">next</a><span>|</span><label class="collapse" for="c-38201223">[-]</label><label class="expand" for="c-38201223">[2 more]</label></div><br/><div class="children"><div class="content">Author of the rule and blog post here. I agree that, for me, I appreciate the extra clarity of explicit parens. This lead me to explore a VSCode plugin which visually show the implicit parens even if they are not present in the code: <a href="https:&#x2F;&#x2F;jordaneldredge.com&#x2F;blog&#x2F;a-vs-code-extension-to-combat-js-precedence-confusion&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;jordaneldredge.com&#x2F;blog&#x2F;a-vs-code-extension-to-comba...</a><p>I like the idea that different readers of the same code base could opt for differing levels of explicitness when it comes to operator precedence. One thing that working on the project helped demonstrate for me is that adding parens around _every_ subexpression is _way_ too noisy. So, you need to draw the line somewhere. But for me, I prefer drawing that line on the noisier side.</div><br/><div id="38202590" class="c"><input type="checkbox" id="c-38202590" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201223">parent</a><span>|</span><a href="#38201516">next</a><span>|</span><label class="collapse" for="c-38202590">[-]</label><label class="expand" for="c-38202590">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One thing that working on the project helped demonstrate for me is that adding parens around _every_ subexpression is _way_ too noisy. But for me, I prefer drawing that line on the noisier side.<p>I prefer the noisier side as well. When adding parens to indicate&#x2F;force precedence, I will sometimes split my expressions into multiple lines, with indentation, as an aid to legibility, e.g. instead of ( ( a + b ) &#x2F; ( ( c - d ) &#x2F; e ) ) I might write:<p><pre><code>  (
    ( a + b )
      &#x2F;
    (
      ( c - d )
        &#x2F;
      e
    )
  )
</code></pre>
I&#x27;ve found this not only quite legible, but also fairly easy to edit because you can easily match parens visually.</div><br/></div></div></div></div><div id="38201516" class="c"><input type="checkbox" id="c-38201516" checked=""/><div class="controls bullet"><span class="by">GeneralMaximus</span><span>|</span><a href="#38201038">parent</a><span>|</span><a href="#38201223">prev</a><span>|</span><a href="#38201285">next</a><span>|</span><label class="collapse" for="c-38201516">[-]</label><label class="expand" for="c-38201516">[3 more]</label></div><br/><div class="children"><div class="content">I personally make liberal use of parens to make the precedence of operators as clear as possible. Then I run formatting tools like Prettier or rustfmt on my code, which remove any parens that are not strictly required. This way, I end up with an expression that is clear as well as concise. Best of both worlds.</div><br/><div id="38201681" class="c"><input type="checkbox" id="c-38201681" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201516">parent</a><span>|</span><a href="#38201285">next</a><span>|</span><label class="collapse" for="c-38201681">[-]</label><label class="expand" for="c-38201681">[2 more]</label></div><br/><div class="children"><div class="content">This is the approach I take as well. But it&#x27;s not necessarily best of both worlds. Removing (or not inserting) technically useless parens can obscure bugs if you are not perfectly fluent in the precedence rules of the language. Their doubly easy to miss if there&#x27;s a lot going on on one line.<p>Here&#x27;s one example that the rule caught: <a href="https:&#x2F;&#x2F;github.com&#x2F;captbaritone&#x2F;vscode&#x2F;blob&#x2F;ab86e0229d6b4d0cb49cfd6747c92cafcd2bd4af&#x2F;src&#x2F;vs&#x2F;workbench&#x2F;contrib&#x2F;terminal&#x2F;browser&#x2F;terminalProfileResolverService.ts#L456:L456">https:&#x2F;&#x2F;github.com&#x2F;captbaritone&#x2F;vscode&#x2F;blob&#x2F;ab86e0229d6b4d0c...</a><p>I&#x27;ve been writing JS for over 10 years now, and I&#x27;m not sure I would have caught that in code review.</div><br/><div id="38201935" class="c"><input type="checkbox" id="c-38201935" checked=""/><div class="controls bullet"><span class="by">amatecha</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201681">parent</a><span>|</span><a href="#38201285">next</a><span>|</span><label class="collapse" for="c-38201935">[-]</label><label class="expand" for="c-38201935">[1 more]</label></div><br/><div class="children"><div class="content">Ahh... there&#x27;s a strict equality operator comparing undefined (both a value and a type) to something that&#x27;s being coerced to a boolean... it will always return false.  The first thing I look at when I see a strict equality comparison is &quot;are the operands actually the same type&quot; because that&#x27;s a very common mistake (or so I&#x27;ve noticed)!<p>Huh, now I&#x27;m curious if my IDE would highlight this with a warning... will have to check!</div><br/></div></div></div></div></div></div><div id="38201285" class="c"><input type="checkbox" id="c-38201285" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#38201038">parent</a><span>|</span><a href="#38201516">prev</a><span>|</span><a href="#38201550">next</a><span>|</span><label class="collapse" for="c-38201285">[-]</label><label class="expand" for="c-38201285">[11 more]</label></div><br/><div class="children"><div class="content">Because there&#x27;s a threshold of where you <i>know</i> how things will be parsed. You wouldn&#x27;t write:<p><pre><code>   a=(b+c)
</code></pre>
Because you know it&#x27;s not necessary. But we&#x27;re human and sometimes make mistakes when we&#x27;re sure we didn&#x27;t.<p>That&#x27;s also why we allow for some misunderstanding, (rather than (writing (using) (sentence trees))).</div><br/><div id="38202646" class="c"><input type="checkbox" id="c-38202646" checked=""/><div class="controls bullet"><span class="by">jug</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201285">parent</a><span>|</span><a href="#38201438">next</a><span>|</span><label class="collapse" for="c-38202646">[-]</label><label class="expand" for="c-38202646">[1 more]</label></div><br/><div class="children"><div class="content">Also it’s easy to make assumptions and have them slip by when more experienced. Like how the ?? operator works in C# or even just the bitshift or logical operator order which is pretty much standardized across languages by now. But still, this can confuse readers or even yourself on a tired day.</div><br/></div></div><div id="38201438" class="c"><input type="checkbox" id="c-38201438" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201285">parent</a><span>|</span><a href="#38202646">prev</a><span>|</span><a href="#38201550">next</a><span>|</span><label class="collapse" for="c-38201438">[-]</label><label class="expand" for="c-38201438">[9 more]</label></div><br/><div class="children"><div class="content">Agreed, that would be one level too far, and thus unnecessary. I&#x27;m not arguing that <i>every</i> operator should be parenthesized, but I think parens should be used more than most programmers tend to do.<p>On a related note, I occasionally write expressions that both assign and test, e.g. if ( ( a = b ) == c ) and in those cases I parenthesize liberally and <i>always</i> write a comment that indicates yes, I intend to make an assignment in the middle of a test for equality.</div><br/><div id="38201561" class="c"><input type="checkbox" id="c-38201561" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201438">parent</a><span>|</span><a href="#38201550">next</a><span>|</span><label class="collapse" for="c-38201561">[-]</label><label class="expand" for="c-38201561">[8 more]</label></div><br/><div class="children"><div class="content">Oof really? That’s a horrible pattern! In my professional opinion of course. Separation of causes, man! :)</div><br/><div id="38202191" class="c"><input type="checkbox" id="c-38202191" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201561">parent</a><span>|</span><a href="#38202037">next</a><span>|</span><label class="collapse" for="c-38202191">[-]</label><label class="expand" for="c-38202191">[5 more]</label></div><br/><div class="children"><div class="content">Yeah, but separation of causes then violates the DRY principle because you have to repeat the &#x27;a&#x27; expression twice:<p><pre><code>  a = b
  if ( a == c ) ...
</code></pre>
The repetition is even worse if you replace &#x27;a&#x27; or &#x27;b&#x27; with a more complex expression:<p><pre><code>  a[foo&#x2F;bar] = b[baz&#x2F;bat]
  if (a[foo&#x2F;bar] == c) ...
</code></pre>
Oof indeed! Just rewrite it as:<p><pre><code>  if ( ( a[foo&#x2F;bar] = b[baz&#x2F;bat] ) == c ) ... &#x2F;&#x2F; Yes, assign and test!</code></pre></div><br/><div id="38202250" class="c"><input type="checkbox" id="c-38202250" checked=""/><div class="controls bullet"><span class="by">iamflimflam1</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38202191">parent</a><span>|</span><a href="#38202378">next</a><span>|</span><label class="collapse" for="c-38202250">[-]</label><label class="expand" for="c-38202250">[2 more]</label></div><br/><div class="children"><div class="content">Wow - I’ve been coding for a long time and find your assign and test really hard to parse.<p>In a code review I would definitely reject this.</div><br/><div id="38202558" class="c"><input type="checkbox" id="c-38202558" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38202250">parent</a><span>|</span><a href="#38202378">next</a><span>|</span><label class="collapse" for="c-38202558">[-]</label><label class="expand" for="c-38202558">[1 more]</label></div><br/><div class="children"><div class="content">Just curious, do you also find the ternary operator hard to parse? This is a serious question: I&#x27;ve found some programmers tend to avoid it entirely, while I think there are some clear cases where it&#x27;s advantageous to use.<p>What I&#x27;m getting at is one person&#x27;s &quot;easy to parse&quot; is another person&#x27;s &quot;difficult to parse&quot;, and there may be no objective answer which makes one any better than the other.</div><br/></div></div></div></div><div id="38202378" class="c"><input type="checkbox" id="c-38202378" checked=""/><div class="controls bullet"><span class="by">nickthesick</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38202191">parent</a><span>|</span><a href="#38202250">prev</a><span>|</span><a href="#38202037">next</a><span>|</span><label class="collapse" for="c-38202378">[-]</label><label class="expand" for="c-38202378">[2 more]</label></div><br/><div class="children"><div class="content">I hope this is satire, DRY is more about extraction of shared function not about individual expressions. You write code once, no need to save yourself typing time at the expense of you and other peoples ability to read and understand the code afterward.</div><br/><div id="38202514" class="c"><input type="checkbox" id="c-38202514" checked=""/><div class="controls bullet"><span class="by">kmoser</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38202378">parent</a><span>|</span><a href="#38202037">next</a><span>|</span><label class="collapse" for="c-38202514">[-]</label><label class="expand" for="c-38202514">[1 more]</label></div><br/><div class="children"><div class="content">&gt; DRY is more about extraction of shared function not about individual expressions<p>I&#x27;m not sure where you get that idea. Repetition anywhere is usually a code smell.<p>&gt; You write code once<p>And then you update it when you add new features or the requirements change or you fix bugs, etc. Having to change two symbols is more error prone than changing one. And having to parse more code is harder than parsing less code.<p>The assign-and-test pattern is common in several languages (e.g. C), and adding a comment that explains the logic should remove all doubt as to what is happening and why, so I see it as a win&#x2F;win.<p>In any case, there is a trade-off between terseness and legibility, and while I usually favor more verbose code, I tend to draw the line at needless repetition. But that&#x27;s my personal preference, and everybody draws that line in different places.</div><br/></div></div></div></div></div></div><div id="38202037" class="c"><input type="checkbox" id="c-38202037" checked=""/><div class="controls bullet"><span class="by">porridgeraisin</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201561">parent</a><span>|</span><a href="#38202191">prev</a><span>|</span><a href="#38201550">next</a><span>|</span><label class="collapse" for="c-38202037">[-]</label><label class="expand" for="c-38202037">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very common in C<p><pre><code>  while((buf = resultofstreamingoperation() != null) {
    
  }
</code></pre>
The ` != null ` is redundant here but you can imagine where it&#x27;d be required.</div><br/><div id="38202417" class="c"><input type="checkbox" id="c-38202417" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38202037">parent</a><span>|</span><a href="#38201550">next</a><span>|</span><label class="collapse" for="c-38202417">[-]</label><label class="expand" for="c-38202417">[1 more]</label></div><br/><div class="children"><div class="content">A more common form (and slightly less evil) is for error checking:<p><pre><code>    if ((error = do_a_thing())) {
        &#x2F;&#x2F; some error happened, good thing we saved the error code
    }
</code></pre>
Given the standard &quot;zero is success&quot; paradigm, handling errors is very succinct.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38201550" class="c"><input type="checkbox" id="c-38201550" checked=""/><div class="controls bullet"><span class="by">demondemidi</span><span>|</span><a href="#38201038">parent</a><span>|</span><a href="#38201285">prev</a><span>|</span><a href="#38201181">next</a><span>|</span><label class="collapse" for="c-38201550">[-]</label><label class="expand" for="c-38201550">[1 more]</label></div><br/><div class="children"><div class="content">I think one reason is that when I am refactoring I am thinking about other larger logic, and as expressions get reduced, I become blind to the details that I and previously internalized as correct.  Linters really help because I can’t always be thinking at both ends of the abstraction.</div><br/></div></div><div id="38201181" class="c"><input type="checkbox" id="c-38201181" checked=""/><div class="controls bullet"><span class="by">SenHeng</span><span>|</span><a href="#38201038">parent</a><span>|</span><a href="#38201550">prev</a><span>|</span><a href="#38201207">next</a><span>|</span><label class="collapse" for="c-38201181">[-]</label><label class="expand" for="c-38201181">[3 more]</label></div><br/><div class="children"><div class="content">Prettier oftentimes removes a lot of parentheses that I had hoped it would leave.<p>I’ve taken naming them as variables instead. Definitely more verbose but more readability.<p><pre><code>    const aIsB = a === b;
    … aIsB ?? c …</code></pre></div><br/><div id="38201280" class="c"><input type="checkbox" id="c-38201280" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#38201038">root</a><span>|</span><a href="#38201181">parent</a><span>|</span><a href="#38201263">next</a><span>|</span><label class="collapse" for="c-38201280">[-]</label><label class="expand" for="c-38201280">[1 more]</label></div><br/><div class="children"><div class="content">That is how it evaluates, not what the original author intended in the example in the OP.<p><pre><code>    return a === b ?? c;
</code></pre>
The intent was<p><pre><code>    const bOrDefault = b ?? c;
    return a === bOrDefault;
</code></pre>
You posted the actual (buggy) evaluation. I agree that its better if that is what you intend.</div><br/></div></div></div></div><div id="38201207" class="c"><input type="checkbox" id="c-38201207" checked=""/><div class="controls bullet"><span class="by">robinson7d</span><span>|</span><a href="#38201038">parent</a><span>|</span><a href="#38201181">prev</a><span>|</span><a href="#38202555">next</a><span>|</span><label class="collapse" for="c-38201207">[-]</label><label class="expand" for="c-38201207">[1 more]</label></div><br/><div class="children"><div class="content">In fact, I’ve seen an extension several times: senior developers performing code review, and requesting that unnecessary, but clarifying, parens be removed. Not excessive parentheses, a single pair in a line or statement.</div><br/></div></div></div></div><div id="38202555" class="c"><input type="checkbox" id="c-38202555" checked=""/><div class="controls bullet"><span class="by">k3vinw</span><span>|</span><a href="#38201038">prev</a><span>|</span><a href="#38199612">next</a><span>|</span><label class="collapse" for="c-38202555">[-]</label><label class="expand" for="c-38202555">[1 more]</label></div><br/><div class="children"><div class="content">Is there an eslint rule inspired by Gary Bernhardt‘s WAT talk?<p><a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;wat" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;wat</a></div><br/></div></div><div id="38199612" class="c"><input type="checkbox" id="c-38199612" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38202555">prev</a><span>|</span><a href="#38198224">next</a><span>|</span><label class="collapse" for="c-38199612">[-]</label><label class="expand" for="c-38199612">[3 more]</label></div><br/><div class="children"><div class="content">Clang and GCC have something like this but restricted to just comparisons, called -Wtautological-compare. I recommend turning it on for the same reasons. Although in practice it may need to be suppressed in macro-heavy or template-heavy code.<p>This has also caught many real world bugs in C such as <a href="https:&#x2F;&#x2F;github.com&#x2F;aircrack-ng&#x2F;rtl8812au&#x2F;issues&#x2F;308">https:&#x2F;&#x2F;github.com&#x2F;aircrack-ng&#x2F;rtl8812au&#x2F;issues&#x2F;308</a></div><br/><div id="38201835" class="c"><input type="checkbox" id="c-38201835" checked=""/><div class="controls bullet"><span class="by">Too</span><span>|</span><a href="#38199612">parent</a><span>|</span><a href="#38201816">next</a><span>|</span><label class="collapse" for="c-38201835">[-]</label><label class="expand" for="c-38201835">[1 more]</label></div><br/><div class="children"><div class="content">C compilers are funny on this one, because instead of warning you about code that don’t do anything, they take advantage of it, in the form of UB optimizations.<p>Like you say, macros often make this very hard to enforce in practice.</div><br/></div></div><div id="38201816" class="c"><input type="checkbox" id="c-38201816" checked=""/><div class="controls bullet"><span class="by">Quentincestino</span><span>|</span><a href="#38199612">parent</a><span>|</span><a href="#38201835">prev</a><span>|</span><a href="#38198224">next</a><span>|</span><label class="collapse" for="c-38201816">[-]</label><label class="expand" for="c-38201816">[1 more]</label></div><br/><div class="children"><div class="content">Well considering the danger an UB can represent in C&#x2F;C++ code you always should run gcc&#x2F;clang with at least -Wall</div><br/></div></div></div></div><div id="38198224" class="c"><input type="checkbox" id="c-38198224" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#38199612">prev</a><span>|</span><a href="#38199237">next</a><span>|</span><label class="collapse" for="c-38198224">[-]</label><label class="expand" for="c-38198224">[2 more]</label></div><br/><div class="children"><div class="content">One thing that reading _The Little Prover_ did for me was correct a sort of lazy preconception I had that you cannot “reason about” code in dynamically typed languages. And it sort of crystallized my experience of large dynamically typed codebases not being as bad as one might expect. The patterns in OP are one case here where the boolean expressions are trivially analyzable and there are other classes of such analysis: e.g. it’s possible to use the condition of an id statement to detect useless expressions in both the then and else clauses.</div><br/><div id="38199553" class="c"><input type="checkbox" id="c-38199553" checked=""/><div class="controls bullet"><span class="by">gwern</span><span>|</span><a href="#38198224">parent</a><span>|</span><a href="#38199237">next</a><span>|</span><label class="collapse" for="c-38199553">[-]</label><label class="expand" for="c-38199553">[1 more]</label></div><br/><div class="children"><div class="content">Benjamin Pierce has a famous quote: &quot;Attempting to prove any nontrivial theorem about your program will expose lots of bugs: The particular choice of theorem makes little difference!&quot; (This is also true of mathematical proofs - any attempt to formalize a nontrivial proof will usually expose several minor but fixable bugs in the proof.)</div><br/></div></div></div></div><div id="38199237" class="c"><input type="checkbox" id="c-38199237" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38198224">prev</a><span>|</span><a href="#38200967">next</a><span>|</span><label class="collapse" for="c-38199237">[-]</label><label class="expand" for="c-38199237">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Comparisons which will always evaluate to true or false and logical expressions (||, &amp;&amp;, ??) which either always short-circuit or never short-circuit are both likely indications of programmer error.<p>I regularly do things like:<p><pre><code>    if (0 &amp;&amp; expression) ...
</code></pre>
and:<p><pre><code>    if (1 || expression) ...
</code></pre>
to temporarily disable a conditional when I&#x27;m looking for a bug.</div><br/><div id="38199284" class="c"><input type="checkbox" id="c-38199284" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#38199237">parent</a><span>|</span><a href="#38200148">next</a><span>|</span><label class="collapse" for="c-38199284">[-]</label><label class="expand" for="c-38199284">[4 more]</label></div><br/><div class="children"><div class="content">Well, then presumably it would be nice to have your linter point that out for you so that you don&#x27;t commit it to the codebase on accident! I&#x27;ve definitely seen a few of those kinds of things accidentally left in in production, which is definitely a code smell</div><br/><div id="38199294" class="c"><input type="checkbox" id="c-38199294" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38199237">root</a><span>|</span><a href="#38199284">parent</a><span>|</span><a href="#38200148">next</a><span>|</span><label class="collapse" for="c-38199294">[-]</label><label class="expand" for="c-38199294">[3 more]</label></div><br/><div class="children"><div class="content">Having them in a linter is fine, but in the compiler itself, maybe not.</div><br/><div id="38199312" class="c"><input type="checkbox" id="c-38199312" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#38199237">root</a><span>|</span><a href="#38199294">parent</a><span>|</span><a href="#38200148">next</a><span>|</span><label class="collapse" for="c-38199312">[-]</label><label class="expand" for="c-38199312">[2 more]</label></div><br/><div class="children"><div class="content">Well, luckily this is a post about linters...? I&#x27;m not sure I understand your comment. How is it related to the article?</div><br/><div id="38201415" class="c"><input type="checkbox" id="c-38201415" checked=""/><div class="controls bullet"><span class="by">gus_massa</span><span>|</span><a href="#38199237">root</a><span>|</span><a href="#38199312">parent</a><span>|</span><a href="#38200148">next</a><span>|</span><label class="collapse" for="c-38201415">[-]</label><label class="expand" for="c-38201415">[1 more]</label></div><br/><div class="children"><div class="content">WalterBright is the mantainer of the D language, so I guess he sees everithing from the point of view of the compiler.<p>I wrote a lot of code for the optimization step of the compiler of Racket, in particular steps to eliminate similar code. I saw those expressions and I inmediately think:<p><i>Macro expansions create a lot of similar expressions, and also more complex expressions that the compiler can reduce to trivialy looking expressions [1]. It&#x27;s nice that the compiler can detect them and eliminate them, but raisng an error would break a lot of code.</i><p>My guess is that all three of us agree that the post is about linters, but it would be very bad to extend this rule to the compiler.<p>[1] For example, after an expansion of a macro or inlining a function you may get:<p><pre><code>  (define x (random 10))
  (if (integer? x)
    (display x)
    (error &quot;The number should be an integer&quot;))</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="38200148" class="c"><input type="checkbox" id="c-38200148" checked=""/><div class="controls bullet"><span class="by">raincole</span><span>|</span><a href="#38199237">parent</a><span>|</span><a href="#38199284">prev</a><span>|</span><a href="#38200822">next</a><span>|</span><label class="collapse" for="c-38200148">[-]</label><label class="expand" for="c-38200148">[1 more]</label></div><br/><div class="children"><div class="content">Keyword: temporarily</div><br/></div></div><div id="38200822" class="c"><input type="checkbox" id="c-38200822" checked=""/><div class="controls bullet"><span class="by">FranksTV</span><span>|</span><a href="#38199237">parent</a><span>|</span><a href="#38200148">prev</a><span>|</span><a href="#38200967">next</a><span>|</span><label class="collapse" for="c-38200822">[-]</label><label class="expand" for="c-38200822">[1 more]</label></div><br/><div class="children"><div class="content">So disable the lining rule with a comment? That way you don&#x27;t accidentally commit it.</div><br/></div></div></div></div><div id="38200967" class="c"><input type="checkbox" id="c-38200967" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#38199237">prev</a><span>|</span><a href="#38198050">next</a><span>|</span><label class="collapse" for="c-38200967">[-]</label><label class="expand" for="c-38200967">[5 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t TypeScript catch this?<p>I thought TypeScript was able to analyze some static code, like below:<p><pre><code>  const alwaysTrue = true
  if (alwaysTrue === false) { } 
  &#x2F;&#x2F; This comparison appears to be unintentional because the types &#x27;true&#x27; and &#x27;false&#x27; have no overlap.(2367)</code></pre></div><br/><div id="38201005" class="c"><input type="checkbox" id="c-38201005" checked=""/><div class="controls bullet"><span class="by">robinson7d</span><span>|</span><a href="#38200967">parent</a><span>|</span><a href="#38201986">next</a><span>|</span><label class="collapse" for="c-38201005">[-]</label><label class="expand" for="c-38201005">[1 more]</label></div><br/><div class="children"><div class="content">There’s a short thread by WalterBright in here that explains why:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38199237">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38199237</a><p>The back and forth on that thread seems to result in advocating for what we’ve got: compiler (TypeScript in your example) not caring, but linter caring.<p>The reason not to in the transpiler is it can be very helpful during testing to block or force some paths.</div><br/></div></div><div id="38201986" class="c"><input type="checkbox" id="c-38201986" checked=""/><div class="controls bullet"><span class="by">amatecha</span><span>|</span><a href="#38200967">parent</a><span>|</span><a href="#38201005">prev</a><span>|</span><a href="#38201214">next</a><span>|</span><label class="collapse" for="c-38201986">[-]</label><label class="expand" for="c-38201986">[1 more]</label></div><br/><div class="children"><div class="content">TypeScript is a superset of JavaScript, so they can&#x27;t just like.. stop you from writing valid JS.  Generally speaking, any valid JS is valid TypeScript.  It&#x27;s not invalid to write that, so TS won&#x27;t do anything to stop you from doing so.  However, fortunately linters exist for the exact reason of catching these sort of &quot;gotchas&quot; or &quot;probably not what you were intending&quot; kind of situations.</div><br/></div></div><div id="38201214" class="c"><input type="checkbox" id="c-38201214" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#38200967">parent</a><span>|</span><a href="#38201986">prev</a><span>|</span><a href="#38198050">next</a><span>|</span><label class="collapse" for="c-38201214">[-]</label><label class="expand" for="c-38201214">[2 more]</label></div><br/><div class="children"><div class="content">TypeScript _has_ to support weird old code.<p>Eslint-typescript works well for this. I also recommend eslint-plugin-sonarjs</div><br/><div id="38201267" class="c"><input type="checkbox" id="c-38201267" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#38200967">root</a><span>|</span><a href="#38201214">parent</a><span>|</span><a href="#38198050">next</a><span>|</span><label class="collapse" for="c-38201267">[-]</label><label class="expand" for="c-38201267">[1 more]</label></div><br/><div class="children"><div class="content">Does the TypeScript team avoid making breaking changes even in major versions?</div><br/></div></div></div></div></div></div><div id="38198050" class="c"><input type="checkbox" id="c-38198050" checked=""/><div class="controls bullet"><span class="by">cultureswitch</span><span>|</span><a href="#38200967">prev</a><span>|</span><a href="#38200832">next</a><span>|</span><label class="collapse" for="c-38198050">[-]</label><label class="expand" for="c-38198050">[4 more]</label></div><br/><div class="children"><div class="content">Having any such binary expression is considered a severe violation of coding rules for certified software (avionics, medical...). There&#x27;s a good reason, because it&#x27;s my almost always hiding a bug. And in gray cases where the duplication is not obvious, forces to think hard about it.</div><br/><div id="38200211" class="c"><input type="checkbox" id="c-38200211" checked=""/><div class="controls bullet"><span class="by">addaon</span><span>|</span><a href="#38198050">parent</a><span>|</span><a href="#38200832">next</a><span>|</span><label class="collapse" for="c-38200211">[-]</label><label class="expand" for="c-38200211">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a good reason, because it&#x27;s my almost always hiding a bug<p>There&#x27;s another good reason -- by definition, it&#x27;s impossible to write a test case with full decision coverage if some of the decisions are themselves impossible.</div><br/><div id="38201858" class="c"><input type="checkbox" id="c-38201858" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198050">root</a><span>|</span><a href="#38200211">parent</a><span>|</span><a href="#38200832">next</a><span>|</span><label class="collapse" for="c-38201858">[-]</label><label class="expand" for="c-38201858">[2 more]</label></div><br/><div class="children"><div class="content">Post author here. That’s a great framing! That means that, in theory, an enforced 100% code coverage would catch these issues as well, which I’m inclined to believe!</div><br/><div id="38201932" class="c"><input type="checkbox" id="c-38201932" checked=""/><div class="controls bullet"><span class="by">thomasrockhu</span><span>|</span><a href="#38198050">root</a><span>|</span><a href="#38201858">parent</a><span>|</span><a href="#38200832">next</a><span>|</span><label class="collapse" for="c-38201932">[-]</label><label class="expand" for="c-38201932">[1 more]</label></div><br/><div class="children"><div class="content">Tom from Codecov here.<p>I&#x27;m a huge proponent that branch coverage is way more important than just statement coverage, because as you mentioned, it&#x27;s way easier to miss these types of bugs just by getting 100% statement coverage.</div><br/></div></div></div></div></div></div></div></div><div id="38200832" class="c"><input type="checkbox" id="c-38200832" checked=""/><div class="controls bullet"><span class="by">peter_l_downs</span><span>|</span><a href="#38198050">prev</a><span>|</span><a href="#38198100">next</a><span>|</span><label class="collapse" for="c-38200832">[-]</label><label class="expand" for="c-38200832">[1 more]</label></div><br/><div class="children"><div class="content">Does an equivalent linter exist for Python, or for Golang, or for Scala? I&#x27;m sold, it would be great to have something like this.<p>EDIT:<p>- pylint: using-constant-test (W0125) <a href="https:&#x2F;&#x2F;docs.pylint.org&#x2F;features.html#id13" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.pylint.org&#x2F;features.html#id13</a><p>- golangci-lint: revive&#x27;s constant-logical-expression <a href="https:&#x2F;&#x2F;golangci-lint.run&#x2F;usage&#x2F;linters&#x2F;#revive" rel="nofollow noreferrer">https:&#x2F;&#x2F;golangci-lint.run&#x2F;usage&#x2F;linters&#x2F;#revive</a></div><br/></div></div><div id="38198100" class="c"><input type="checkbox" id="c-38198100" checked=""/><div class="controls bullet"><span class="by">darraghmckay</span><span>|</span><a href="#38200832">prev</a><span>|</span><a href="#38198631">next</a><span>|</span><label class="collapse" for="c-38198100">[-]</label><label class="expand" for="c-38198100">[1 more]</label></div><br/><div class="children"><div class="content">This was really interesting, particularly seeing how a lot of these are probably mistakes stemming from familiarity with syntax of other languages</div><br/></div></div><div id="38198631" class="c"><input type="checkbox" id="c-38198631" checked=""/><div class="controls bullet"><span class="by">ZephyrBlu</span><span>|</span><a href="#38198100">prev</a><span>|</span><a href="#38201572">next</a><span>|</span><label class="collapse" for="c-38198631">[-]</label><label class="expand" for="c-38198631">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m fascinated by how many examples of this kind of issue there seem to be. Seems like the kind of thing that should be fairly obvious in code review, or should be caught by unit tests.</div><br/><div id="38198835" class="c"><input type="checkbox" id="c-38198835" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#38198631">parent</a><span>|</span><a href="#38198717">next</a><span>|</span><label class="collapse" for="c-38198835">[-]</label><label class="expand" for="c-38198835">[1 more]</label></div><br/><div class="children"><div class="content">No contributor writes consistently (truly) thorough unit tests and no reviewer performs consistently thorough line-by-line analysis.<p>It’s extremely valuable to have multiple layers of verification, and fast-cheap static analysis tools like linters have a tremendously high ROI as one of those layers, especially in languages with many subtle syntax surprises.</div><br/></div></div><div id="38198717" class="c"><input type="checkbox" id="c-38198717" checked=""/><div class="controls bullet"><span class="by">ilumanty</span><span>|</span><a href="#38198631">parent</a><span>|</span><a href="#38198835">prev</a><span>|</span><a href="#38201287">next</a><span>|</span><label class="collapse" for="c-38198717">[-]</label><label class="expand" for="c-38198717">[2 more]</label></div><br/><div class="children"><div class="content">Sure, but I‘d rather have a linter detect this kind of code smell automatically if it provides a reasonable explanation to the author.<p>In my experience, a fairly strict non-aesthetic linter setup makes mentoring much more efficient.</div><br/><div id="38201881" class="c"><input type="checkbox" id="c-38201881" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198631">root</a><span>|</span><a href="#38198717">parent</a><span>|</span><a href="#38201287">next</a><span>|</span><label class="collapse" for="c-38201881">[-]</label><label class="expand" for="c-38201881">[1 more]</label></div><br/><div class="children"><div class="content">I love that framing. I’m the author of the rule&#x2F;post and I see writing rules like this as an opportunity to mentor at scale. Incredibly rewarding to think that, in a sense, I can be in so many engineer’s editors helpfully pointing out (and via documentation explaining) issues right at the moment that the developer needs it.<p>Just in time mentorship!</div><br/></div></div></div></div><div id="38201287" class="c"><input type="checkbox" id="c-38201287" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198631">parent</a><span>|</span><a href="#38198717">prev</a><span>|</span><a href="#38201572">next</a><span>|</span><label class="collapse" for="c-38201287">[-]</label><label class="expand" for="c-38201287">[1 more]</label></div><br/><div class="children"><div class="content">Hey, author of the rule&#x2F;post here. I&#x27;d encourage you to click through to the actual examples linked from the post. Seeing the issues in context, as opposed to the minimal example, can help show how quickly these issues can get lost. It might also be interesting to click &quot;blame&quot; on the line and look at it in the context of the PR that added it.<p>Overall, my point with the examples was to highlight that these are mistakes that even make their way into high visibility projects built by highly competent engineering teams.<p>That said, looking at the issues few were in really critical paths of these projects. Often they cropped up in auxiliary areas like test harnesses or more off-the-beaten-path features. One can assume the same bugs may have existed at some point in the development cycle in other areas of the code base, but they got caught by more rigorous testing&#x2F;review of those areas, or bug reports. But it&#x27;s surely a time saver to identify them _as the developer saves the file_ rather than later in the process. The sooner you catch the bug, the more engineering energy you save.</div><br/></div></div></div></div><div id="38201572" class="c"><input type="checkbox" id="c-38201572" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#38198631">prev</a><span>|</span><a href="#38198422">next</a><span>|</span><label class="collapse" for="c-38201572">[-]</label><label class="expand" for="c-38201572">[4 more]</label></div><br/><div class="children"><div class="content">It seems the hypothetical developer in each example didn&#x27;t know the language that well, and didn&#x27;t use parens when they were in doubt. Prettier will remove the parens automatically on save, if auto format with prettier is set up in your editor, when the parens are not needed.</div><br/><div id="38201654" class="c"><input type="checkbox" id="c-38201654" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#38201572">parent</a><span>|</span><a href="#38198422">next</a><span>|</span><label class="collapse" for="c-38201654">[-]</label><label class="expand" for="c-38201654">[3 more]</label></div><br/><div class="children"><div class="content">In aggregate, near enough nobody knows the language that well.</div><br/><div id="38201665" class="c"><input type="checkbox" id="c-38201665" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#38201572">root</a><span>|</span><a href="#38201654">parent</a><span>|</span><a href="#38198422">next</a><span>|</span><label class="collapse" for="c-38201665">[-]</label><label class="expand" for="c-38201665">[2 more]</label></div><br/><div class="children"><div class="content">Right so what you do is <i>add parens</i> when you don&#x27;t know, you don&#x27;t just write code and go <i>whatever lol</i></div><br/><div id="38201723" class="c"><input type="checkbox" id="c-38201723" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#38201572">root</a><span>|</span><a href="#38201665">parent</a><span>|</span><a href="#38198422">next</a><span>|</span><label class="collapse" for="c-38201723">[-]</label><label class="expand" for="c-38201723">[1 more]</label></div><br/><div class="children"><div class="content">As it turns out, people are fallible.<p>Without rigorous systems in place to catch mistakes, mistakes will [more frequently] happen.</div><br/></div></div></div></div></div></div></div></div><div id="38198422" class="c"><input type="checkbox" id="c-38198422" checked=""/><div class="controls bullet"><span class="by">twisteriffic</span><span>|</span><a href="#38201572">prev</a><span>|</span><a href="#38198532">next</a><span>|</span><label class="collapse" for="c-38198422">[-]</label><label class="expand" for="c-38198422">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Thinking || allows for set operations: states.includes(&#x27;VALID&#x27; || &#x27;IN_PROGRESS&#x27;)<p>Genuinely wondering what language that would have been valid in.</div><br/><div id="38198865" class="c"><input type="checkbox" id="c-38198865" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38198909">next</a><span>|</span><label class="collapse" for="c-38198865">[-]</label><label class="expand" for="c-38198865">[1 more]</label></div><br/><div class="children"><div class="content">The type system in TypeScript can compose types from string literals using a similar syntax.<p>Obviously, this is runtime code, not a type declaration, but you can see how a new or tired&#x2F;busy developer’s brain might spit this out in the wrong place.</div><br/></div></div><div id="38198909" class="c"><input type="checkbox" id="c-38198909" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38198865">prev</a><span>|</span><a href="#38199012">next</a><span>|</span><label class="collapse" for="c-38198909">[-]</label><label class="expand" for="c-38198909">[2 more]</label></div><br/><div class="children"><div class="content">You can do this in C#, which is similar if you squint.<p><pre><code>    states.Any(s =&gt; s is &quot;VALID&quot; or &quot;IN_PROGRESS&quot;)
</code></pre>
I&#x27;m sure there are languages where a match-able pattern is an expression, allowing the original code basically unchanged.</div><br/><div id="38201229" class="c"><input type="checkbox" id="c-38201229" checked=""/><div class="controls bullet"><span class="by">simlevesque</span><span>|</span><a href="#38198422">root</a><span>|</span><a href="#38198909">parent</a><span>|</span><a href="#38199012">next</a><span>|</span><label class="collapse" for="c-38201229">[-]</label><label class="expand" for="c-38201229">[1 more]</label></div><br/><div class="children"><div class="content">You can do it in JS too:<p><pre><code>    states.find(state =&gt; state === &#x27;VALID&#x27; || state === &#x27;IN_PROGRESS&#x27;)
</code></pre>
Or<p><pre><code>    states.find(state =&gt; [&#x27;VALID&#x27;, &#x27;IN_PROGRESS&#x27;].includes(state))</code></pre></div><br/></div></div></div></div><div id="38199012" class="c"><input type="checkbox" id="c-38199012" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38198909">prev</a><span>|</span><a href="#38199144">next</a><span>|</span><label class="collapse" for="c-38199012">[-]</label><label class="expand" for="c-38199012">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Genuinely wondering what language that would have been valid in.<p>Raku, but using “junctive or” | (which creates an <i>any</i> junction of its arguments, which “autothreads” on method calls producing a Junction of the results) instead of “tight or” ||.</div><br/></div></div><div id="38199144" class="c"><input type="checkbox" id="c-38199144" checked=""/><div class="controls bullet"><span class="by">nodoodles</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38199012">prev</a><span>|</span><a href="#38198767">next</a><span>|</span><label class="collapse" for="c-38199144">[-]</label><label class="expand" for="c-38199144">[1 more]</label></div><br/><div class="children"><div class="content">One could abuse Kotlin to make almost this syntax valid. Something like: states.includes { +”VALID” || +”IN_PROGRESS” }<p>Where statestype function ‘includes’ takes a lambda that’s run in states context and overrides plus operator for string to evaluate to states.contains(that string). One could, but should they?</div><br/></div></div><div id="38198767" class="c"><input type="checkbox" id="c-38198767" checked=""/><div class="controls bullet"><span class="by">malfist</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38199144">prev</a><span>|</span><a href="#38199871">next</a><span>|</span><label class="collapse" for="c-38198767">[-]</label><label class="expand" for="c-38198767">[1 more]</label></div><br/><div class="children"><div class="content">English.<p>Have a brain fart one day and you&#x27;ll write something like this and be confused why it doesn&#x27;t work</div><br/></div></div><div id="38199871" class="c"><input type="checkbox" id="c-38199871" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38198767">prev</a><span>|</span><a href="#38200866">next</a><span>|</span><label class="collapse" for="c-38199871">[-]</label><label class="expand" for="c-38199871">[1 more]</label></div><br/><div class="children"><div class="content">I was amazed to discover COBOL has something like this:<p>IF X = 0 OR = 1 OR = 2</div><br/></div></div><div id="38200866" class="c"><input type="checkbox" id="c-38200866" checked=""/><div class="controls bullet"><span class="by">barosl</span><span>|</span><a href="#38198422">parent</a><span>|</span><a href="#38199871">prev</a><span>|</span><a href="#38198532">next</a><span>|</span><label class="collapse" for="c-38200866">[-]</label><label class="expand" for="c-38200866">[2 more]</label></div><br/><div class="children"><div class="content">&gt; states.intersection({&#x27;VALID&#x27;} | {&#x27;IN_PROGRESS&#x27;})<p>Does this Python code count? Haha.</div><br/><div id="38201629" class="c"><input type="checkbox" id="c-38201629" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38198422">root</a><span>|</span><a href="#38200866">parent</a><span>|</span><a href="#38198532">next</a><span>|</span><label class="collapse" for="c-38201629">[-]</label><label class="expand" for="c-38201629">[1 more]</label></div><br/><div class="children"><div class="content">No, that’s the explicit conjunction of two explicit sets.<p><pre><code>    ‘VALID’ or ‘IN_PROGRESS’ in states
</code></pre>
Does not work and I’ve seen it around or SO. Or more commonly it’s variation<p><pre><code>    a == b or c</code></pre></div><br/></div></div></div></div></div></div><div id="38198532" class="c"><input type="checkbox" id="c-38198532" checked=""/><div class="controls bullet"><span class="by">armchairhacker</span><span>|</span><a href="#38198422">prev</a><span>|</span><a href="#38201530">next</a><span>|</span><label class="collapse" for="c-38198532">[-]</label><label class="expand" for="c-38198532">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s surprising how many bugs can be caught by lints like this, which check for code which is obviously flawed in some way (other examples are unused variables, dead code, statements which will always crash, statements which will always throw an exception that aren&#x27;t `throw` or something else where that would be intended)</div><br/></div></div><div id="38199960" class="c"><input type="checkbox" id="c-38199960" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#38201530">prev</a><span>|</span><a href="#38199287">next</a><span>|</span><label class="collapse" for="c-38199960">[-]</label><label class="expand" for="c-38199960">[3 more]</label></div><br/><div class="children"><div class="content">On the one hand, now I really want this for python. On the other, I&#x27;ve made most of these bugs with JS, and very few with python, despite having used it more. So many of them are consequences of JS wats...</div><br/><div id="38201577" class="c"><input type="checkbox" id="c-38201577" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38199960">parent</a><span>|</span><a href="#38200418">next</a><span>|</span><label class="collapse" for="c-38201577">[-]</label><label class="expand" for="c-38201577">[1 more]</label></div><br/><div class="children"><div class="content">Author of the post&#x2F;rule here. I&#x27;d be very curious to see this rule ported&#x2F;translated to Python! While the gotcha&#x27;s would probably be different, I suspect it would uncover real bugs. One interesting challenge with JavaScript is that its so ubiquitous that _everyone_ ends up needing to write it at some point. Even those for whom it is a second or third language. I suspect this makes its gotchas all the more common to encounter. Conversely, it makes the value of tools to guide around those gotchas that much more valuable.</div><br/></div></div><div id="38200418" class="c"><input type="checkbox" id="c-38200418" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#38199960">parent</a><span>|</span><a href="#38201577">prev</a><span>|</span><a href="#38199287">next</a><span>|</span><label class="collapse" for="c-38200418">[-]</label><label class="expand" for="c-38200418">[1 more]</label></div><br/><div class="children"><div class="content">natural language also has its wats</div><br/></div></div></div></div><div id="38199287" class="c"><input type="checkbox" id="c-38199287" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38199960">prev</a><span>|</span><a href="#38200025">next</a><span>|</span><label class="collapse" for="c-38199287">[-]</label><label class="expand" for="c-38199287">[3 more]</label></div><br/><div class="children"><div class="content">D makes expressions like:<p><pre><code>    if (a &lt; b &lt; c)
    if (a &lt; b &amp; c)
    if (a = b)
</code></pre>
and statements like:<p><pre><code>    for (i = 0; i &lt; 10; ++i);
</code></pre>
illegal.</div><br/><div id="38199527" class="c"><input type="checkbox" id="c-38199527" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38199287">parent</a><span>|</span><a href="#38200025">next</a><span>|</span><label class="collapse" for="c-38199527">[-]</label><label class="expand" for="c-38199527">[2 more]</label></div><br/><div class="children"><div class="content">Is the latter special-cased, or do you just always need a braces around a single-line loop?</div><br/><div id="38199673" class="c"><input type="checkbox" id="c-38199673" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38199287">root</a><span>|</span><a href="#38199527">parent</a><span>|</span><a href="#38200025">next</a><span>|</span><label class="collapse" for="c-38199673">[-]</label><label class="expand" for="c-38199673">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you just always need a braces around a single-line loop?<p>Yes. And ditto for `if (expression)` and a couple others. In developing D, I looked at what linters and coding standards did and incorporated into the language rules for troublesome things that there&#x27;s just no excuse for.<p>For another tidbit, the JSF coding standard specifies that using a lower case &#x27;l&#x27; as an integer literal suffix is not allowed, because it is too easily confused with &#x27;1&#x27;. D just doesn&#x27;t allow it; you gotta use &#x27;L&#x27;. No need to write a coding standard about it.</div><br/></div></div></div></div></div></div><div id="38200160" class="c"><input type="checkbox" id="c-38200160" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#38199899">prev</a><span>|</span><a href="#38199914">next</a><span>|</span><label class="collapse" for="c-38200160">[-]</label><label class="expand" for="c-38200160">[1 more]</label></div><br/><div class="children"><div class="content">Ah, Javascript. <a href="https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;wat" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.destroyallsoftware.com&#x2F;talks&#x2F;wat</a></div><br/></div></div><div id="38199914" class="c"><input type="checkbox" id="c-38199914" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#38200160">prev</a><span>|</span><a href="#38198413">next</a><span>|</span><label class="collapse" for="c-38199914">[-]</label><label class="expand" for="c-38199914">[7 more]</label></div><br/><div class="children"><div class="content">This won&#x27;t be a problem if you have 100% test coverage. Potentially useful to point something out as you type it, but I don&#x27;t think it does anything profound.</div><br/><div id="38200326" class="c"><input type="checkbox" id="c-38200326" checked=""/><div class="controls bullet"><span class="by">altano</span><span>|</span><a href="#38199914">parent</a><span>|</span><a href="#38199943">next</a><span>|</span><label class="collapse" for="c-38200326">[-]</label><label class="expand" for="c-38200326">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t have 100% test coverage with these kinds of bugs, because these bugs create unreachable expressions.<p>You can either find out you have these bugs from lint errors or you can find out by finding them in code coverage reports while chasing 100% code coverage. Most people would obviously prefer the former.</div><br/></div></div><div id="38199943" class="c"><input type="checkbox" id="c-38199943" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#38199914">parent</a><span>|</span><a href="#38200326">prev</a><span>|</span><a href="#38201908">next</a><span>|</span><label class="collapse" for="c-38199943">[-]</label><label class="expand" for="c-38199943">[3 more]</label></div><br/><div class="children"><div class="content">Neither would malloc(), and yet we still like Rust&#x27;s borrow checker.<p>I&#x27;ve never seen a project with 100% condition tests coverage. Sure, they exist, but they&#x27;re as rare as unicorns.</div><br/><div id="38200189" class="c"><input type="checkbox" id="c-38200189" checked=""/><div class="controls bullet"><span class="by">heinrich5991</span><span>|</span><a href="#38199914">root</a><span>|</span><a href="#38199943">parent</a><span>|</span><a href="#38201908">next</a><span>|</span><label class="collapse" for="c-38200189">[-]</label><label class="expand" for="c-38200189">[2 more]</label></div><br/><div class="children"><div class="content">Maybe sqlite3: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.sqlite.org&#x2F;testing.html</a>.</div><br/><div id="38202095" class="c"><input type="checkbox" id="c-38202095" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#38199914">root</a><span>|</span><a href="#38200189">parent</a><span>|</span><a href="#38201908">next</a><span>|</span><label class="collapse" for="c-38202095">[-]</label><label class="expand" for="c-38202095">[1 more]</label></div><br/><div class="children"><div class="content">Ironically, that&#x27;s a fantastic example of just how unachievable full test coverage actually is in most projects.<p>&gt; By comparison, the project has 590 times as much test code [as program code].</div><br/></div></div></div></div></div></div><div id="38201908" class="c"><input type="checkbox" id="c-38201908" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38199914">parent</a><span>|</span><a href="#38199943">prev</a><span>|</span><a href="#38200717">next</a><span>|</span><label class="collapse" for="c-38201908">[-]</label><label class="expand" for="c-38201908">[1 more]</label></div><br/><div class="children"><div class="content">I think you’re technically correct. But if you are someone who is writing 100% branch coverage code this rule could still be useful. It will quickly point out parts of your code base that are going be impossible to test with 100% coverage.</div><br/></div></div><div id="38200717" class="c"><input type="checkbox" id="c-38200717" checked=""/><div class="controls bullet"><span class="by">l0b0</span><span>|</span><a href="#38199914">parent</a><span>|</span><a href="#38201908">prev</a><span>|</span><a href="#38198413">next</a><span>|</span><label class="collapse" for="c-38200717">[-]</label><label class="expand" for="c-38200717">[1 more]</label></div><br/><div class="children"><div class="content">100% <i>branch</i> coverage, which is even more rare. I&#x27;ve done it for a couple of projects, and it&#x27;s really useful (there were bugs hidden even in the last few percent), but it is a decent amount of work.</div><br/></div></div></div></div><div id="38198413" class="c"><input type="checkbox" id="c-38198413" checked=""/><div class="controls bullet"><span class="by">lalaithion</span><span>|</span><a href="#38199914">prev</a><span>|</span><label class="collapse" for="c-38198413">[-]</label><label class="expand" for="c-38198413">[9 more]</label></div><br/><div class="children"><div class="content">Ideally this lint would ignore if (false) and if (true), even though these are still constant binary expressions, they aren&#x27;t vectors for similar bugs like the constant expressions in the blog post.<p>Although &quot;real&quot; production software would use feature flags of some kind instead of hardcoding the constant, sometimes you do just need to hide some code behind an if statement that is currently ineffectual, and linters that prevent that are extremely annoying and force me to write a confusing, convoluted expression that is too complicated for the linter to detect as constant true or constant false.</div><br/><div id="38198601" class="c"><input type="checkbox" id="c-38198601" checked=""/><div class="controls bullet"><span class="by">AlexMoffat</span><span>|</span><a href="#38198413">parent</a><span>|</span><a href="#38199300">next</a><span>|</span><label class="collapse" for="c-38198601">[-]</label><label class="expand" for="c-38198601">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you, and shouldn&#x27;t you, just add appropriate comment &#x2F; annotation to tell the linter to ignore the next line? That way you make it clear to others reading the code that you know what&#x27;s going on.</div><br/></div></div><div id="38199300" class="c"><input type="checkbox" id="c-38199300" checked=""/><div class="controls bullet"><span class="by">dragonwriter</span><span>|</span><a href="#38198413">parent</a><span>|</span><a href="#38198601">prev</a><span>|</span><a href="#38199305">next</a><span>|</span><label class="collapse" for="c-38199300">[-]</label><label class="expand" for="c-38199300">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Ideally this lint would ignore if (false) and if (true), even though these are still constant binary expressions,<p>I don&#x27;t think they are: binary expressions affected are expressions constructed with binary logical or comparison operator (==, ===, &amp;&amp;, ||, ??).<p>true and false each aren&#x27;t binary expressions, they are simple constant values, and the lint isn&#x27;t for constant conditionals.<p>(The rule for that is no-constant-condition.)</div><br/><div id="38201915" class="c"><input type="checkbox" id="c-38201915" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198413">root</a><span>|</span><a href="#38199300">parent</a><span>|</span><a href="#38199305">next</a><span>|</span><label class="collapse" for="c-38201915">[-]</label><label class="expand" for="c-38201915">[1 more]</label></div><br/><div class="children"><div class="content">Exactly right. And no-constant-expression is configurable to allow trivial constant expressions for exactly the reason the parent commenter raised.</div><br/></div></div></div></div><div id="38199305" class="c"><input type="checkbox" id="c-38199305" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#38198413">parent</a><span>|</span><a href="#38199300">prev</a><span>|</span><a href="#38198765">next</a><span>|</span><label class="collapse" for="c-38199305">[-]</label><label class="expand" for="c-38199305">[2 more]</label></div><br/><div class="children"><div class="content">Just remove the conditional? If you ever need it back, git is your friend. Or comment it out or something if you <i>really</i> want to keep your code messy, I&#x27;m not your mom. But I don&#x27;t see any reason why `if (true)` would be better then `&#x2F;&#x2F; if (!isAdmin(user)) {`</div><br/><div id="38200000" class="c"><input type="checkbox" id="c-38200000" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#38198413">root</a><span>|</span><a href="#38199305">parent</a><span>|</span><a href="#38198765">next</a><span>|</span><label class="collapse" for="c-38200000">[-]</label><label class="expand" for="c-38200000">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But I don&#x27;t see any reason why `if (true)` would be better then `&#x2F;&#x2F; if (!isAdmin(user)) {`<p>&#x2F;&#x2F; takes editing tools in many situations<p>&#x2F;* doesn&#x27;t nest<p>Setting an if to false is easy and fast.</div><br/></div></div></div></div><div id="38198765" class="c"><input type="checkbox" id="c-38198765" checked=""/><div class="controls bullet"><span class="by">MatthiasPortzel</span><span>|</span><a href="#38198413">parent</a><span>|</span><a href="#38199305">prev</a><span>|</span><label class="collapse" for="c-38198765">[-]</label><label class="expand" for="c-38198765">[3 more]</label></div><br/><div class="children"><div class="content">It’s annoying that linters are responsible for enforcing code-style (indentation, line length, etc.) as well as code correctness (as discussed in the OP), and these sorts of intentional temporary code smells. There’s a huge amount of overlap, so I understand where it comes from. But it means that linters are too intrusive for most small or early-stage projects. (Obviously these lint rules can be turned on and off individually but that’s a hassle.)</div><br/><div id="38201462" class="c"><input type="checkbox" id="c-38201462" checked=""/><div class="controls bullet"><span class="by">captbaritone</span><span>|</span><a href="#38198413">root</a><span>|</span><a href="#38198765">parent</a><span>|</span><a href="#38199919">next</a><span>|</span><label class="collapse" for="c-38201462">[-]</label><label class="expand" for="c-38201462">[1 more]</label></div><br/><div class="children"><div class="content">Author or the rule and post here. ESLint version 9, which is going to enable this rule as part of the set of &quot;recommended&quot; rules, is also removing all of the formatting rules. I&#x27;m pleased to see that. In the era of pretty printers (which ESLint predates) I think it makes sense to encourage linters to focus on correctness and other conventions aimed at improving code quality rather than just style.</div><br/></div></div><div id="38199919" class="c"><input type="checkbox" id="c-38199919" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#38198413">root</a><span>|</span><a href="#38198765">parent</a><span>|</span><a href="#38201462">prev</a><span>|</span><label class="collapse" for="c-38199919">[-]</label><label class="expand" for="c-38199919">[1 more]</label></div><br/><div class="children"><div class="content">In good setups, linters are only responsible for the latter. Autoformatters of the zero config &quot;any color you want as long as it&#x27;s black&quot; variety - gofmt, black, etc&#x27; - take care of the former.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>