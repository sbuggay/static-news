<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735290050552" as="style"/><link rel="stylesheet" href="styles.css?v=1735290050552"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://4zm.org/2024/12/25/a-simple-elf.html">A Simple ELF</a> <span class="domain">(<a href="https://4zm.org">4zm.org</a>)</span></div><div class="subtext"><span>signa11</span> | <span>45 comments</span></div><br/><div><div id="42517406" class="c"><input type="checkbox" id="c-42517406" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42517405">next</a><span>|</span><label class="collapse" for="c-42517406">[-]</label><label class="expand" for="c-42517406">[2 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t done a proper write-up yet but this is my current technique for emitting minimal ELF files written in freestanding C:<p>1. hand-written minimal ELF headers, with enough asm to do `_exit(main(argc, argv))`: <a href="https:&#x2F;&#x2F;github.com&#x2F;DavidBuchanan314&#x2F;kurl&#x2F;blob&#x2F;main&#x2F;golfed&#x2F;elf_entry.s">https:&#x2F;&#x2F;github.com&#x2F;DavidBuchanan314&#x2F;kurl&#x2F;blob&#x2F;main&#x2F;golfed&#x2F;el...</a> (currently only implemented for aarch64)<p>2. &quot;Linux Syscall Support&quot; library for conveniently making raw syscalls from C: <a href="https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;linux-syscall-support&#x2F;" rel="nofollow">https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;linux-syscall-support&#x2F;</a><p>3. To avoid custom linker scripts (which I hate with a passion), I embed my hand-crafted ELF within a regular ELF, and slice it out at the end (using a python script). The &quot;container&quot; ELF is a regular full-fat ELF, potentially including working debug symbols, but the inner ELF has none of the cruft.<p>Using this technique, I wrote a barely-functional TLS1.3 client that fits in ~3.5KB (see the rest of repo from the first link)</div><br/><div id="42520453" class="c"><input type="checkbox" id="c-42520453" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42517406">parent</a><span>|</span><a href="#42517405">next</a><span>|</span><label class="collapse" for="c-42520453">[-]</label><label class="expand" for="c-42520453">[1 more]</label></div><br/><div class="children"><div class="content">&gt; To avoid custom linker scripts (which I hate with a passion)<p>lol why? i mean the syntax sucks but this seems like howling into the wind...</div><br/></div></div></div></div><div id="42517405" class="c"><input type="checkbox" id="c-42517405" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#42517406">prev</a><span>|</span><a href="#42517088">next</a><span>|</span><label class="collapse" for="c-42517405">[-]</label><label class="expand" for="c-42517405">[3 more]</label></div><br/><div class="children"><div class="content">The Linux kernel source tree has nolibc [1], a header-only C standard library implementation that is about as barebones and paper-thin as it gets and is the next step up from a pure freestanding environment as shown in this article. I&#x27;ve used it to create a tiny but working program that prints out the ASCII table [2] as part of my Ghidra extension test suite.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;tree&#x2F;master&#x2F;tools&#x2F;include&#x2F;nolibc">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;tree&#x2F;master&#x2F;tools&#x2F;include&#x2F;...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;boricj&#x2F;ghidra-delinker-extension&#x2F;tree&#x2F;master&#x2F;src&#x2F;test&#x2F;resources&#x2F;ascii-table">https:&#x2F;&#x2F;github.com&#x2F;boricj&#x2F;ghidra-delinker-extension&#x2F;tree&#x2F;mas...</a></div><br/><div id="42519198" class="c"><input type="checkbox" id="c-42519198" checked=""/><div class="controls bullet"><span class="by">perching_aix</span><span>|</span><a href="#42517405">parent</a><span>|</span><a href="#42517088">next</a><span>|</span><label class="collapse" for="c-42519198">[-]</label><label class="expand" for="c-42519198">[2 more]</label></div><br/><div class="children"><div class="content">&gt; from a pure freestanding environment as shown in this article<p>Isn&#x27;t a freestanding enviroment one without an OS? The author in the article explicitly codes against Linux syscalls and is creating an ELF file (so a hosted executable).</div><br/><div id="42520413" class="c"><input type="checkbox" id="c-42520413" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42517405">root</a><span>|</span><a href="#42519198">parent</a><span>|</span><a href="#42517088">next</a><span>|</span><label class="collapse" for="c-42520413">[-]</label><label class="expand" for="c-42520413">[1 more]</label></div><br/><div class="children"><div class="content">I think of &quot;freestanding&quot; as being related to the &quot;-ffreestanding&quot; flag of modern compilers, which merely means something similar to &quot;don&#x27;t assume that functions have their usual C standard definitions, as I don&#x27;t have a normal libc&quot;.</div><br/></div></div></div></div></div></div><div id="42517088" class="c"><input type="checkbox" id="c-42517088" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42517405">prev</a><span>|</span><a href="#42518979">next</a><span>|</span><label class="collapse" for="c-42517088">[-]</label><label class="expand" for="c-42517088">[5 more]</label></div><br/><div class="children"><div class="content">I love articles like this. If you want to see a tutorial on how you can take this a step further, by creating a tiny ELF file that runs on Linux, FreeBSD, NetBSD, and OpenBSD 7.3 then check out <a href="https:&#x2F;&#x2F;justine.lol&#x2F;sizetricks&#x2F;#elf" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;sizetricks&#x2F;#elf</a></div><br/><div id="42517210" class="c"><input type="checkbox" id="c-42517210" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42517088">parent</a><span>|</span><a href="#42518979">next</a><span>|</span><label class="collapse" for="c-42517210">[-]</label><label class="expand" for="c-42517210">[4 more]</label></div><br/><div class="children"><div class="content">I would also recommend the legendary Teensy Files:<p><a href="https:&#x2F;&#x2F;www.muppetlabs.com&#x2F;~breadbox&#x2F;software&#x2F;tiny&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.muppetlabs.com&#x2F;~breadbox&#x2F;software&#x2F;tiny&#x2F;</a><p>They sparked my interest in ELF and freestanding programs.</div><br/><div id="42517365" class="c"><input type="checkbox" id="c-42517365" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42517088">root</a><span>|</span><a href="#42517210">parent</a><span>|</span><a href="#42517264">next</a><span>|</span><label class="collapse" for="c-42517365">[-]</label><label class="expand" for="c-42517365">[1 more]</label></div><br/><div class="children"><div class="content">If anyone&#x27;s interested, last year I replicated this exercise for an x86-64 Linux executable [0], and also golfed a Hello World as small as I could. I ended up using a little-known pattern (an ET_DYN executable with no interpreter, normally only used for the ld.so binary) to shave off more bytes than anyone else who had tried it, to the best of my knowledge.<p>[0] <a href="https:&#x2F;&#x2F;tmpout.sh&#x2F;3&#x2F;22.html" rel="nofollow">https:&#x2F;&#x2F;tmpout.sh&#x2F;3&#x2F;22.html</a></div><br/></div></div><div id="42517264" class="c"><input type="checkbox" id="c-42517264" checked=""/><div class="controls bullet"><span class="by">cylinder714</span><span>|</span><a href="#42517088">root</a><span>|</span><a href="#42517210">parent</a><span>|</span><a href="#42517365">prev</a><span>|</span><a href="#42518979">next</a><span>|</span><label class="collapse" for="c-42517264">[-]</label><label class="expand" for="c-42517264">[2 more]</label></div><br/><div class="children"><div class="content">And Chris Wellons&#x27; &quot;A Magnetized Needle and a Steady Hand,&quot; detailing how to build an ELF implementation of &#x27;true&#x27; using nothing more than &#x27;echo&#x27; or &#x27;printf&#x27;: <a href="https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2016&#x2F;11&#x2F;17&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nullprogram.com&#x2F;blog&#x2F;2016&#x2F;11&#x2F;17&#x2F;</a></div><br/><div id="42517360" class="c"><input type="checkbox" id="c-42517360" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42517088">root</a><span>|</span><a href="#42517264">parent</a><span>|</span><a href="#42518979">next</a><span>|</span><label class="collapse" for="c-42517360">[-]</label><label class="expand" for="c-42517360">[1 more]</label></div><br/><div class="children"><div class="content">Huge fan of that blog and its author!</div><br/></div></div></div></div></div></div></div></div><div id="42518979" class="c"><input type="checkbox" id="c-42518979" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#42517088">prev</a><span>|</span><a href="#42517851">next</a><span>|</span><label class="collapse" for="c-42518979">[-]</label><label class="expand" for="c-42518979">[1 more]</label></div><br/><div class="children"><div class="content">If you think this sort of thing is fun, you&#x27;ll enjoy this: <a href="https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;asmhttpd&#x2F;blob&#x2F;master&#x2F;asmhttpd.asm">https:&#x2F;&#x2F;github.com&#x2F;jcalvinowens&#x2F;asmhttpd&#x2F;blob&#x2F;master&#x2F;asmhttp...</a><p>It&#x27;s a webserver written in x86 assembler, which makes raw syscalls. It has no functions, and unmaps the stack so it uses only one 4KB page of memory at runtime.</div><br/></div></div><div id="42517851" class="c"><input type="checkbox" id="c-42517851" checked=""/><div class="controls bullet"><span class="by">ptspts</span><span>|</span><a href="#42518979">prev</a><span>|</span><a href="#42517592">next</a><span>|</span><label class="collapse" for="c-42517851">[-]</label><label class="expand" for="c-42517851">[1 more]</label></div><br/><div class="children"><div class="content">For 32-bit x86 (i386 and i686), I&#x27;ve written a libc and a toolchain to.automate this: <a href="https:&#x2F;&#x2F;github.com&#x2F;pts&#x2F;minilibc686">https:&#x2F;&#x2F;github.com&#x2F;pts&#x2F;minilibc686</a> . It can use mainstream free C compilers (GCC, Clang, OpenWatcom cc386, TinyCC and PCC) and assemblers (GNU as and NASM) out of the box.<p>A printf-hello-world is about 1 KiB. A write-hello-world (syscalls only) is less than 200 bytes. Assembly programming skills not needed to use it.</div><br/></div></div><div id="42517592" class="c"><input type="checkbox" id="c-42517592" checked=""/><div class="controls bullet"><span class="by">akdas</span><span>|</span><a href="#42517851">prev</a><span>|</span><a href="#42517342">next</a><span>|</span><label class="collapse" for="c-42517592">[-]</label><label class="expand" for="c-42517592">[1 more]</label></div><br/><div class="children"><div class="content">A while ago, I created an interactive explanation of the different parts of a minimal ELF file: <a href="https:&#x2F;&#x2F;scratchpad.avikdas.com&#x2F;elf-explanation&#x2F;elf-explanation.html" rel="nofollow">https:&#x2F;&#x2F;scratchpad.avikdas.com&#x2F;elf-explanation&#x2F;elf-explanati...</a><p>I wrote this page for my own compiler that I&#x27;m working on, but I think it would be a good complement to this article. Note that the page is not that great on mobile, the extra real estate on desktop really helps.</div><br/></div></div><div id="42517342" class="c"><input type="checkbox" id="c-42517342" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#42517592">prev</a><span>|</span><a href="#42517672">next</a><span>|</span><label class="collapse" for="c-42517342">[-]</label><label class="expand" for="c-42517342">[3 more]</label></div><br/><div class="children"><div class="content">If one properly specifies the input, output, and clobber constraints to the asm statement, there is no need for the volatile keyword in any of this.</div><br/><div id="42518898" class="c"><input type="checkbox" id="c-42518898" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#42517342">parent</a><span>|</span><a href="#42517672">next</a><span>|</span><label class="collapse" for="c-42518898">[-]</label><label class="expand" for="c-42518898">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think that&#x27;s correct for the sys_exit() call with no outputs: the compiler doesn&#x27;t know the syscall instruction has side effects, I think it would be within its rights to omit that asm statement without volatile. Adding an output and code to consume the result seems like a waste of space in .text, it doesn&#x27;t return.<p>It reminds me of a funny little bug in ARM Linux, fixed by adding volatile to an asm statement: <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;92a00580828a1bdf96e7e36545f6d229809af04f.1722154575.git.calvin@wbinvd.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;92a00580828a1bdf96e7e36545f6d22...</a></div><br/><div id="42518928" class="c"><input type="checkbox" id="c-42518928" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#42517342">root</a><span>|</span><a href="#42518898">parent</a><span>|</span><a href="#42517672">next</a><span>|</span><label class="collapse" for="c-42518928">[-]</label><label class="expand" for="c-42518928">[1 more]</label></div><br/><div class="children"><div class="content">Well, neither have outputs, doh, so they both need volatile don&#x27;t they?<p>Adding an output for the %rax result would prevent the call from being omitted without volatile (assuming it is actually consumed by something), but it could still be reordered, right? I suppose with general syscalls that <i>might</i> be okay, but certainly not with sys_exit().<p>They also need memory clobbers, but I don&#x27;t think memory clobbers would necessarily prevent reordering? In the case of the ARM bug though, it did: <a href="https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;Zqa4SAyPKPuaXdgg@mozart.vkv.me&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lore.kernel.org&#x2F;lkml&#x2F;Zqa4SAyPKPuaXdgg@mozart.vkv.me&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42517672" class="c"><input type="checkbox" id="c-42517672" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#42517342">prev</a><span>|</span><a href="#42517483">next</a><span>|</span><label class="collapse" for="c-42517672">[-]</label><label class="expand" for="c-42517672">[7 more]</label></div><br/><div class="children"><div class="content">The custom entry points look wrong to me. Aren&#x27;t they breaking the rules over stack alignment when calling functions? Specifically, that rip is supposed to be congruent to 8 mod 16 at the beginning of a function, and supposed to be divisible by 16 right before a call instruction. The problem is that when code execution starts at the entry point, rip is divisible by 16, but by writing it as a C function, the compiler will assume it&#x27;s off by 8 from what it actually is.</div><br/><div id="42517972" class="c"><input type="checkbox" id="c-42517972" checked=""/><div class="controls bullet"><span class="by">fsmv</span><span>|</span><a href="#42517672">parent</a><span>|</span><a href="#42517758">next</a><span>|</span><label class="collapse" for="c-42517972">[-]</label><label class="expand" for="c-42517972">[2 more]</label></div><br/><div class="children"><div class="content">This is from the SysV calling convention not x86 itself. The CPU can do unaligned just fine. You don&#x27;t have to use the calling convention when not calling out to a library.</div><br/><div id="42518021" class="c"><input type="checkbox" id="c-42518021" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#42517672">root</a><span>|</span><a href="#42517972">parent</a><span>|</span><a href="#42517758">next</a><span>|</span><label class="collapse" for="c-42518021">[-]</label><label class="expand" for="c-42518021">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right that it&#x27;s not inherent to the architecture, but even if you&#x27;re only calling your own code, if your own code is written in C, then GCC will assume it too, unless you use command-line arguments or attributes to tell it otherwise, neither of which is being done here.</div><br/></div></div></div></div><div id="42517758" class="c"><input type="checkbox" id="c-42517758" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42517672">parent</a><span>|</span><a href="#42517972">prev</a><span>|</span><a href="#42517483">next</a><span>|</span><label class="collapse" for="c-42517758">[-]</label><label class="expand" for="c-42517758">[4 more]</label></div><br/><div class="children"><div class="content">Does it matter unless you&#x27;re reading a float from varargs? What else can it break?</div><br/><div id="42517822" class="c"><input type="checkbox" id="c-42517822" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#42517672">root</a><span>|</span><a href="#42517758">parent</a><span>|</span><a href="#42517483">next</a><span>|</span><label class="collapse" for="c-42517822">[-]</label><label class="expand" for="c-42517822">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know exactly what, but I know there is more than just that, because calling printf breaks with a misaligned stack even when you&#x27;re not passing it any floating-point arguments. And even if it doesn&#x27;t break anything for you today, you&#x27;re basically committing UB by violating the compiler&#x27;s assumptions.</div><br/><div id="42517881" class="c"><input type="checkbox" id="c-42517881" checked=""/><div class="controls bullet"><span class="by">ptspts</span><span>|</span><a href="#42517672">root</a><span>|</span><a href="#42517822">parent</a><span>|</span><a href="#42517483">next</a><span>|</span><label class="collapse" for="c-42517881">[-]</label><label class="expand" for="c-42517881">[2 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t there GCC command-line flags to specify alignment assumptions?</div><br/><div id="42517971" class="c"><input type="checkbox" id="c-42517971" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#42517672">root</a><span>|</span><a href="#42517881">parent</a><span>|</span><a href="#42517483">next</a><span>|</span><label class="collapse" for="c-42517971">[-]</label><label class="expand" for="c-42517971">[1 more]</label></div><br/><div class="children"><div class="content">Yes (see <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-14.2.0&#x2F;gcc&#x2F;x86-Options.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-14.2.0&#x2F;gcc&#x2F;x86-Options.ht...</a>), but this article doesn&#x27;t use them.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42517483" class="c"><input type="checkbox" id="c-42517483" checked=""/><div class="controls bullet"><span class="by">CaesarA</span><span>|</span><a href="#42517672">prev</a><span>|</span><a href="#42520344">next</a><span>|</span><label class="collapse" for="c-42517483">[-]</label><label class="expand" for="c-42517483">[3 more]</label></div><br/><div class="children"><div class="content">I still don&#x27;t understand how people were able to write software in the days when assembly was the only option for speedy execution.</div><br/><div id="42518539" class="c"><input type="checkbox" id="c-42518539" checked=""/><div class="controls bullet"><span class="by">throw-qqqqq</span><span>|</span><a href="#42517483">parent</a><span>|</span><a href="#42517688">next</a><span>|</span><label class="collapse" for="c-42518539">[-]</label><label class="expand" for="c-42518539">[1 more]</label></div><br/><div class="children"><div class="content">You can define macros over the assembly to gain a high level language sort of similar to an untyped dialect of C.<p>For me it would be sort of like writing programs in C versus higher level languages: much more tedious, will take longer and require better planning&#x2F;upfront design, but doable.<p>With practice you learn some tricks that can seem clever to anyone not writing a lot of asm. It’s “just” a very low level language IMO.</div><br/></div></div><div id="42517688" class="c"><input type="checkbox" id="c-42517688" checked=""/><div class="controls bullet"><span class="by">6SixTy</span><span>|</span><a href="#42517483">parent</a><span>|</span><a href="#42518539">prev</a><span>|</span><a href="#42520344">next</a><span>|</span><label class="collapse" for="c-42517688">[-]</label><label class="expand" for="c-42517688">[1 more]</label></div><br/><div class="children"><div class="content">Keeping things pretty simple in project scope and hardware helps quite a lot</div><br/></div></div></div></div><div id="42520344" class="c"><input type="checkbox" id="c-42520344" checked=""/><div class="controls bullet"><span class="by">moonlion_eth</span><span>|</span><a href="#42517483">prev</a><span>|</span><a href="#42517096">next</a><span>|</span><label class="collapse" for="c-42520344">[-]</label><label class="expand" for="c-42520344">[1 more]</label></div><br/><div class="children"><div class="content">Rich Hickey mentioned</div><br/></div></div><div id="42517096" class="c"><input type="checkbox" id="c-42517096" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42520344">prev</a><span>|</span><a href="#42517442">next</a><span>|</span><label class="collapse" for="c-42517096">[-]</label><label class="expand" for="c-42517096">[10 more]</label></div><br/><div class="children"><div class="content">I would like to note that Linux is the <i>only</i> kernel which will allow you to do this! The Linux system call interface is stable and defined at the instruction set level. Linking against some system library is <i>absolutely</i> required on every other system.<p>I&#x27;ve written an article about this idea:<p><a href="https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;linux-system-calls" rel="nofollow">https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;linux-system-calls</a><p>You can get incredibly far with just this. I wrote a freestanding lisp interpreter with nothing but Linux system calls. It turned into a little framework for freestanding Linux programs. It&#x27;s been incredibly fun.<p>Freestanding C is a much better language. A lot of legacy nonsense is in the standard library. The Linux system call interface is really nice to work with. Calling write is not that hard. It&#x27;s the printf style string building and formatting that I sometimes miss.</div><br/><div id="42517392" class="c"><input type="checkbox" id="c-42517392" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42517096">parent</a><span>|</span><a href="#42518594">next</a><span>|</span><label class="collapse" for="c-42517392">[-]</label><label class="expand" for="c-42517392">[2 more]</label></div><br/><div class="children"><div class="content">&quot;<i>Absolutely</i> required&quot; is some strong language. It&#x27;s perfectly possible to, e.g., perform direct syscalls on Windows, and you&#x27;ll occasionally see malware that does it to avoid certain forms of detection. You just have to switch on the OS version, and update your binary if you want it to be compatible with a newer version.</div><br/><div id="42518857" class="c"><input type="checkbox" id="c-42518857" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42517096">root</a><span>|</span><a href="#42517392">parent</a><span>|</span><a href="#42518594">next</a><span>|</span><label class="collapse" for="c-42518857">[-]</label><label class="expand" for="c-42518857">[1 more]</label></div><br/><div class="children"><div class="content">I agree that it was too strong a claim. It&#x27;s not supported by the developers and if you bypass their system libraries your program will break when they change things up.<p>Linux kernel is known to be able to run binaries compiled in the 90s. Breaking user space makes Linus yell at people until the breakage gets reverted. A platform that stable is worth building on top of. Updating executables is a lot of work, sometimes it&#x27;s straight up impossible.</div><br/></div></div></div></div><div id="42518594" class="c"><input type="checkbox" id="c-42518594" checked=""/><div class="controls bullet"><span class="by">chipsrafferty</span><span>|</span><a href="#42517096">parent</a><span>|</span><a href="#42517392">prev</a><span>|</span><a href="#42517415">next</a><span>|</span><label class="collapse" for="c-42518594">[-]</label><label class="expand" for="c-42518594">[2 more]</label></div><br/><div class="children"><div class="content">As a web developer, 90% of what you just wrote is nonsense to me.  How did you learn this stuff?  Do you use it for useful projects or just for fun?</div><br/><div id="42519654" class="c"><input type="checkbox" id="c-42519654" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42517096">root</a><span>|</span><a href="#42518594">parent</a><span>|</span><a href="#42517415">next</a><span>|</span><label class="collapse" for="c-42519654">[-]</label><label class="expand" for="c-42519654">[1 more]</label></div><br/><div class="children"><div class="content">Curiosity and free time. You learn stuff like this by reading tens of thousands of lines of text and code for every line of code that you write.<p>I&#x27;ve always been all about the hidden fun stuff. The magical little programs that somehow configure audio cards. The ALSA mixer tool for example does it via special ioctls. I was reading its source code not too long ago. The manuals said those definitions were for the curious and that those ioctls were private, as though it was the library&#x27;s author exclusive privilege to use those things. I seriously hate it when they say that. When they imply I&#x27;m some mere mortal who&#x27;s better off using the libraries that were gifted to us by the gods of programming.<p>Good or bad, quite a bit of hubris is involved. Takes a certain audacity to think I can make a better wheel than people who are probably much smarter than I am. Sometimes I start projects just to prove to myself that I&#x27;m not clinically insane for thinking a better way is possible. Sometimes it works, sometimes it doesn&#x27;t. Someone once called an idea I had schizophrenic. I&#x27;ll never forget that day.<p>This Linux system call stuff started after I read an LWN article about glibc and Linux specific system call support, getrandom to be specific. Took glibc years to add support. I started a liblinux project because of that article. The idea was to get rid of libc and talk to Linux directly. In order to accomplish that, I was forced to learn <i>a lot</i> of compiler, linker and executable stuff. The musl libc source code taught me a lot.<p>It <i>seems</i> like the C library is doing a huge amount of stuff but it turns out you don&#x27;t actually need most of it. Linux just puts your binary in memory and jumps into some address specified in the ELF header. Normally this when the C library or dynamic linker takes over in order to prepare to call main(). Turns out I can just replace all that with some simple code that calls a function and then exits the process when it returns. It just works. I won&#x27;t have init&#x2F;fini section processing but I can live with that, that&#x27;s harmful stuff that shouldn&#x27;t even have been invented to begin with.</div><br/></div></div></div></div><div id="42517415" class="c"><input type="checkbox" id="c-42517415" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42517096">parent</a><span>|</span><a href="#42518594">prev</a><span>|</span><a href="#42517442">next</a><span>|</span><label class="collapse" for="c-42517415">[-]</label><label class="expand" for="c-42517415">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Linking against some system library is absolutely required on every other system.<p>Not on FreeBSD, NetBSD, OpenBSD or Solaris.<p>The article you linked says this but it&#x27;s not true:<p>&gt; Sometimes it&#x27;s not even possible to use system calls at all. OpenBSD has implemented system call origin verification, a security mechanism that only allows system calls originating from the system&#x27;s libc. So not only is the kernel ABI unstable, normal programs are not even allowed to interface with the kernel at all.<p>You can still make system calls from normal programs, you just need to list the addresses of system call instructions in an ELF section named openbsd.syscalls.</div><br/><div id="42517603" class="c"><input type="checkbox" id="c-42517603" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42517096">root</a><span>|</span><a href="#42517415">parent</a><span>|</span><a href="#42517442">next</a><span>|</span><label class="collapse" for="c-42517603">[-]</label><label class="expand" for="c-42517603">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Not on FreeBSD, NetBSD, OpenBSD or Solaris.<p>Can you cite any sources? I wasn&#x27;t able to find any documentation that corroborates what you said when I wrote the article. The few texts I found actually suggested otherwise. Maybe things have changed since then?<p>&gt; You can still make system calls from normal programs, you just need to list the addresses of system call instructions in an ELF section named openbsd.syscalls.<p>I see. So they have added a mechanism to list the sections allowed to perform system calls. That&#x27;s news to me. Do they guarantee the system call numbers will remain stable though? That older system calls will remain available?</div><br/><div id="42517896" class="c"><input type="checkbox" id="c-42517896" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42517096">root</a><span>|</span><a href="#42517603">parent</a><span>|</span><a href="#42517740">next</a><span>|</span><label class="collapse" for="c-42517896">[-]</label><label class="expand" for="c-42517896">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Can you cite any sources?<p>For one, the FreeBSD kernel specifically has a compatibility layer for Linux binaries to use their familiar syscalls [0]. For its ordinary syscalls, it also has a policy not to break binary compatibility without good reason [1]. Most other OSes just don&#x27;t maintain quite the level of &#x27;indefinite stability&#x27; that the Linux kernel does across different versions. And even Linux doesn&#x27;t implement older versions of syscalls when the kernel is ported to new architectures, so eventually you have to rotate your implementation regardless, if you want people to run your code on new systems.<p>&gt; The few texts I found actually suggested otherwise.<p>People often say &quot;<i>X</i> is impossible&quot; when the truth is &quot;<i>X</i> is tricky and full of caveats, and I don&#x27;t want to think about it, so stop asking&quot;. (Or if the devs themselves are saying it, it might be &quot;I want to look like I&#x27;m &#x27;tough on crime&#x27; toward users of undocumented behavior&quot;, as if that could stop Hyrum&#x27;s law from running its course.) In this case, it&#x27;s generally &quot;If you do it on an OS other than Linux, you can run into big compatibility issues,&quot; not &quot;It&#x27;s impossible on OSes other than Linux.&quot;<p>As for compatibility issues, you&#x27;re running into that the moment you do undocumented fun stuff like omitting ELF sections or overlapping headers, which future Linux versions could start rejecting on the basis of &quot;no one needs to do that legitimately&quot;. So I wouldn&#x27;t start drawing the line on syscall number compatibility.<p>[0] <a href="https:&#x2F;&#x2F;docs.freebsd.org&#x2F;en&#x2F;books&#x2F;handbook&#x2F;linuxemu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.freebsd.org&#x2F;en&#x2F;books&#x2F;handbook&#x2F;linuxemu&#x2F;</a><p>[1] <a href="https:&#x2F;&#x2F;wiki.freebsd.org&#x2F;AddingSyscalls#Backward_compatibily" rel="nofollow">https:&#x2F;&#x2F;wiki.freebsd.org&#x2F;AddingSyscalls#Backward_compatibily</a></div><br/><div id="42518309" class="c"><input type="checkbox" id="c-42518309" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42517096">root</a><span>|</span><a href="#42517896">parent</a><span>|</span><a href="#42517740">next</a><span>|</span><label class="collapse" for="c-42518309">[-]</label><label class="expand" for="c-42518309">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For one, the FreeBSD kernel specifically has a compatibility layer for Linux binaries to use their familiar syscalls [0].<p>I believe this strengthens my argument. Linux kernel-userspace interface is so stable other projects are implementing it. I remember Justine Tunney mentioning this before, the idea that the x86_64 Linux system call ABI is turning into some kind of lingua franca of systems programming.<p><a href="https:&#x2F;&#x2F;justine.lol&#x2F;ape.html" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;ape.html</a><p>&gt; x86-64 Linux ABI Makes a Pretty Good Lingua Franca<p>Would be interesting if people started targeting Linux because of this, banking on the fact that other systems will just implement Linux. Even Windows has Linux built into it these days.<p>&gt; For its ordinary syscalls, it also has a policy not to break binary compatibility without good reason.<p>Thank you for the source. I don&#x27;t think that&#x27;s a particularly strong guarantee. It&#x27;s certainly stronger than OpenBSD&#x27;s at least.<p>&gt; Most other OSes just don&#x27;t maintain quite the level of &#x27;indefinite stability&#x27; that the Linux kernel does across different versions<p>Yeah. I think this is something that makes Linux unique.<p>&gt; And even Linux doesn&#x27;t implement older versions of syscalls when the kernel is ported to new architectures, so eventually you have to rotate your implementation regardless, if you want people to run your code on new systems.<p>That&#x27;s true. Only new architectures are affected though. The old ones have all the old system calls, many with multiple versions, all supported. Porting to a new architecture doesn&#x27;t invalidate the stability of existing ones.<p>&gt; People often say &quot;X is impossible&quot; when the truth is &quot;X is tricky and full of caveats, and I don&#x27;t want to think about it, so stop asking&quot;.<p>&gt; Or if the devs themselves are saying it, it might be &quot;I want to look like I&#x27;m &#x27;tough on crime&#x27; toward users of undocumented behavior&quot;<p>I get what you&#x27;re saying. I truly apologize if I came across that way. I did <i>not</i> mean to say that.<p>I got interested in this low level direct system call stuff because I literally got sick of reading &quot;but you, mere mortal, are not meant to access these raw system interfaces, that&#x27;s for us, you are meant to call the little library function we made for you&quot; in the Linux and libc manuals. Last thing I want is to end up doing the same to others.<p>By &quot;can&#x27;t do this&quot; I meant to say the developers maintaining the system don&#x27;t want you bypassing their system libraries and won&#x27;t take responsibility for it if you do so. If the program breaks because the kernel interfaces changed, they&#x27;ll tell us it&#x27;s our own fault and refuse fix to it.<p>Linux takes the opposite approach: breaking user space makes Linus Torvalds yell at the people until the breakage is reverted. I&#x27;m enthusiastic about it because it&#x27;s the only system where this is supported.<p>&gt; As for compatibility issues, you&#x27;re running into that the moment you start doing undocumented fun stuff like omitting ELF sections or overlapping headers<p>I agree. Should be fine as long as the ELF specification is respected. It&#x27;s okay though, ELF is flexible enough that even in 2024 it&#x27;s possible to invent some new fun stuff.<p><a href="https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;self-contained-lone-lisp-applications" rel="nofollow">https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;self-contained-lone-...</a><p>Embedding arbitrary files into an existing ELF and patching it so that Linux automatically maps it in before the program even runs. Since Linux gives processes a pointer to the program headers, the file is in memory and reachable without a issuing a single system call.</div><br/></div></div></div></div><div id="42517740" class="c"><input type="checkbox" id="c-42517740" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42517096">root</a><span>|</span><a href="#42517603">parent</a><span>|</span><a href="#42517896">prev</a><span>|</span><a href="#42517442">next</a><span>|</span><label class="collapse" for="c-42517740">[-]</label><label class="expand" for="c-42517740">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Can you cite any sources?<p>Personal experience.<p>&gt; Do they guarantee the system call numbers will remain stable though?<p>No. Doesn&#x27;t mean you can&#x27;t make system calls from outside the libc though.</div><br/></div></div></div></div></div></div></div></div><div id="42517442" class="c"><input type="checkbox" id="c-42517442" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#42517096">prev</a><span>|</span><a href="#42517129">next</a><span>|</span><label class="collapse" for="c-42517442">[-]</label><label class="expand" for="c-42517442">[4 more]</label></div><br/><div class="children"><div class="content">1. X86_64 assumed...<p>2. Why is it that exiting at the end of main() requires a system call? Wouldn&#x27;t a `ret` instruction go &quot;back&quot; to somplace where the OS itself will do cleanup work?</div><br/><div id="42517500" class="c"><input type="checkbox" id="c-42517500" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#42517442">parent</a><span>|</span><a href="#42517746">next</a><span>|</span><label class="collapse" for="c-42517500">[-]</label><label class="expand" for="c-42517500">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why is it that exiting at the end of main() requires a system call? Wouldn&#x27;t a `ret` instruction go &quot;back&quot; to somplace where the OS itself will do cleanup work?<p>Usually that&#x27;s done by the C runtime library, but there isn&#x27;t one there since this is a freestanding environment. Had the program not exited through a syscall (or entered an infinite loop), it would most likely crash after veering off the main() function.</div><br/></div></div><div id="42517746" class="c"><input type="checkbox" id="c-42517746" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#42517442">parent</a><span>|</span><a href="#42517500">prev</a><span>|</span><a href="#42517479">next</a><span>|</span><label class="collapse" for="c-42517746">[-]</label><label class="expand" for="c-42517746">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Why is it that exiting at the end of main() requires a system call? Wouldn&#x27;t a `ret` instruction go &quot;back&quot; to somplace where the OS itself will do cleanup work?<p>The only way for execution to cross the barrier between &quot;user space&quot; and &quot;kernel space&quot; is through a system call or an interrupt (we won&#x27;t speak of call gates). Even if the OS had put an address on the stack, so that the &quot;ret&quot; would go there after returning from main(), the code there would still need to do a system call to go back to the OS.<p>While nowadays Linux has a shared page of code mapped on every process (the vDSO), that wasn&#x27;t the case in the past; all code on the &quot;user space&quot; side had to come from either the executable itself, or a library it loaded. Given that, it&#x27;s natural that it was left to the executable to call the &quot;exit&quot; system call at the end.</div><br/></div></div><div id="42517479" class="c"><input type="checkbox" id="c-42517479" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#42517442">parent</a><span>|</span><a href="#42517746">prev</a><span>|</span><a href="#42517129">next</a><span>|</span><label class="collapse" for="c-42517479">[-]</label><label class="expand" for="c-42517479">[1 more]</label></div><br/><div class="children"><div class="content">Not without libc doing the glue work.<p>A return instruction from main hands things back to libc which does some cleanup and then makes this same syscall.</div><br/></div></div></div></div><div id="42517129" class="c"><input type="checkbox" id="c-42517129" checked=""/><div class="controls bullet"><span class="by">EGreg</span><span>|</span><a href="#42517442">prev</a><span>|</span><a href="#42517837">next</a><span>|</span><label class="collapse" for="c-42517129">[-]</label><label class="expand" for="c-42517129">[1 more]</label></div><br/><div class="children"><div class="content">An ELF, and almost in time for Christmas!</div><br/></div></div><div id="42517837" class="c"><input type="checkbox" id="c-42517837" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42517129">prev</a><span>|</span><label class="collapse" for="c-42517837">[-]</label><label class="expand" for="c-42517837">[2 more]</label></div><br/><div class="children"><div class="content">Christ, why couldn&#x27;t PE have won?</div><br/><div id="42518342" class="c"><input type="checkbox" id="c-42518342" checked=""/><div class="controls bullet"><span class="by">boricj</span><span>|</span><a href="#42517837">parent</a><span>|</span><label class="collapse" for="c-42518342">[-]</label><label class="expand" for="c-42518342">[1 more]</label></div><br/><div class="children"><div class="content">As in the Portable Executable file format? There are no tricks used in this article that rely on the specifics of ELF, unlike some more extreme examples [1] that abuse every trick in the book to shave off more bytes from executables.<p>If anything, PE piggybacks on top of COFF which is a complete mess of a file format. I&#x27;m currently writing a standalone library for reading and writing toolchain file formats [2] (to replace some messy bespoke code in my Ghidra extension) and this under-specified, fragmented into multiple dialects, weirdly contorted relic is a pain to deal with.<p>COFF was a stepping stone from a.out to ELF that should&#x27;ve lasted only a couple of years on Unix systems and somehow it managed to metastasize at a crucial point in time inside multiple software ecosystems, most notably Windows and indirectly .NET and UEFI through PE. Frankly, I&#x27;d ask instead why couldn&#x27;t PE and COFF have lost.<p>[1] <a href="https:&#x2F;&#x2F;nathanotterness.com&#x2F;2021&#x2F;10&#x2F;tiny_elf_modernized.html" rel="nofollow">https:&#x2F;&#x2F;nathanotterness.com&#x2F;2021&#x2F;10&#x2F;tiny_elf_modernized.html</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;boricj&#x2F;binary-file-toolkit">https:&#x2F;&#x2F;github.com&#x2F;boricj&#x2F;binary-file-toolkit</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>