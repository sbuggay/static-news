<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690275648550" as="style"/><link rel="stylesheet" href="styles.css?v=1690275648550"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://paraxial.io/blog/still-safe">Elixir is still safe</a> <span class="domain">(<a href="https://paraxial.io">paraxial.io</a>)</span></div><div class="subtext"><span>manusachi</span> | <span>37 comments</span></div><br/><div><div id="36854386" class="c"><input type="checkbox" id="c-36854386" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#36853237">next</a><span>|</span><label class="collapse" for="c-36854386">[-]</label><label class="expand" for="c-36854386">[20 more]</label></div><br/><div class="children"><div class="content">Without stepping on anyone’s toes, I think we can agree that “safety” could be broken down a bit. Memory safety, thread safety, fine… but there’s a whole forest past those trees.<p>Is it a safety feature to type-check regular expressions using dependent types? Is Python a security vulnerability because the performance can be unpredictable?<p>I don’t know.<p>Rust, for that matter, doesn’t protect you from running out of memory from leaking data on the heap — or from running out of stack space because your infinitely recursive function doesn’t halt. Maybe that’s not part of memory safety — but that’s my point.<p>There’s a whole safety forest out there. Whenever I read an article about safety in software, it seems like a comfy blanket statement. “This is a nice definition which I will live in.”<p>I just don’t see how it’s so flat.</div><br/><div id="36855323" class="c"><input type="checkbox" id="c-36855323" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#36854386">parent</a><span>|</span><a href="#36856424">next</a><span>|</span><label class="collapse" for="c-36855323">[-]</label><label class="expand" for="c-36855323">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I just don’t see how it’s so flat.<p>Because people like making wild and provocative claims to motivate writing a paper for which the conclusion was already decided.<p>Anyone who has used, I dunno, any of programming languages that are being discussed has a more nuanced take, and isn&#x27;t spending time trying to force all things into Box A or Box B.<p>Elixir&#x2F;Erlang has a pleasant concurrency model. It does some things well, it does other things less well. It eliminates a big class of bugs, and yet you can still write bugs in Elixir.<p>These sorts of papers are a waste of space on the internet imo.</div><br/><div id="36855663" class="c"><input type="checkbox" id="c-36855663" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36855323">parent</a><span>|</span><a href="#36856424">next</a><span>|</span><label class="collapse" for="c-36855663">[-]</label><label class="expand" for="c-36855663">[6 more]</label></div><br/><div class="children"><div class="content">“What is sending a message to my process and making it crash?!”<p>“My synchronous reply timed out, so why I am I getting a message after the timeout?!”<p>“Why did deleting my build directory fix the compile error?!”<p>“How do I keep my app from crashing when my supervisor crashed too many times in a given timeframe?!”<p>So many adventures to be had.</div><br/><div id="36859148" class="c"><input type="checkbox" id="c-36859148" checked=""/><div class="controls bullet"><span class="by">josevalim</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36855663">parent</a><span>|</span><a href="#36855942">next</a><span>|</span><label class="collapse" for="c-36859148">[-]</label><label class="expand" for="c-36859148">[1 more]</label></div><br/><div class="children"><div class="content">For the first you can setup a tracer for messages sent and received. Second should not happen from OTP 24.<p>Fourth is the wrong question to ask: if the failure handling mechanism is invoked too frequently, fix the failures, not the recovery.<p>Third is definitely my fault. Bug reports are appreciated whenever possible.<p>But generally speaking, yes, debugging is part of every programming language, and concurrency and distribution will add to the adventure whenever used, to varying degrees depending on the programming language.</div><br/></div></div><div id="36855942" class="c"><input type="checkbox" id="c-36855942" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36855663">parent</a><span>|</span><a href="#36859148">prev</a><span>|</span><a href="#36856424">next</a><span>|</span><label class="collapse" for="c-36855942">[-]</label><label class="expand" for="c-36855942">[4 more]</label></div><br/><div class="children"><div class="content">Plenty. But I&#x27;d take those trivial issues over a blob of microservices any day of the week.<p>In any case, the answer continues to be &quot;it depends&quot;. But people will continue to look for &quot;one weird trick&quot; solutions to every problem.</div><br/><div id="36856074" class="c"><input type="checkbox" id="c-36856074" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36855942">parent</a><span>|</span><a href="#36856424">next</a><span>|</span><label class="collapse" for="c-36856074">[-]</label><label class="expand" for="c-36856074">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fun an games until you have to debug an Erlang RPC call that is timing out w&#x2F;o log messages in a blob of Elixir micro services.</div><br/><div id="36859321" class="c"><input type="checkbox" id="c-36859321" checked=""/><div class="controls bullet"><span class="by">phanimahesh</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36856074">parent</a><span>|</span><a href="#36856999">next</a><span>|</span><label class="collapse" for="c-36859321">[-]</label><label class="expand" for="c-36859321">[1 more]</label></div><br/><div class="children"><div class="content">On erlang vm (beamvm), you can safely trace in production. It makes tracing and debugging tools in other ecosystems look like they are primitive in comparison.<p>I think erlang ecosystem has its own warts like any other one but debugging definitely isn&#x27;t one<p>Here are a few examples of what you can do in erlang&#x2F;elixir:<p>Inspect function calls that match specific argumrnt patterns, which can get pretty detailed.
Tag processes by id, future processes under a supervisor, or other criteria, and limit tracing to these.
Limit tracing to n occurences. As in automatically disable tracing after it triggered n times.<p>Typically one combines these and more to identify issues pretty rapidly.</div><br/></div></div><div id="36856999" class="c"><input type="checkbox" id="c-36856999" checked=""/><div class="controls bullet"><span class="by">rozap</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36856074">parent</a><span>|</span><a href="#36859321">prev</a><span>|</span><a href="#36856424">next</a><span>|</span><label class="collapse" for="c-36856999">[-]</label><label class="expand" for="c-36856999">[1 more]</label></div><br/><div class="children"><div class="content">tracing Erlang in prod is literally a fun game, and very easy. Like...one of the best things about the ecosystem. The dbg module (part of the stdlib) is your friend. Trace messages, function calls, with as wide or as specific a net as you need. I&#x27;ve found bugs quickly that would have taken a lot of trial and error on other platforms.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36856424" class="c"><input type="checkbox" id="c-36856424" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#36854386">parent</a><span>|</span><a href="#36855323">prev</a><span>|</span><a href="#36856136">next</a><span>|</span><label class="collapse" for="c-36856424">[-]</label><label class="expand" for="c-36856424">[11 more]</label></div><br/><div class="children"><div class="content">Safety means no undefined behavaior. It does not mean free of bugs, or security issues, or free from crashes. It simply means every operation has well specified semantics.</div><br/><div id="36857039" class="c"><input type="checkbox" id="c-36857039" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36856424">parent</a><span>|</span><a href="#36857016">next</a><span>|</span><label class="collapse" for="c-36857039">[-]</label><label class="expand" for="c-36857039">[2 more]</label></div><br/><div class="children"><div class="content">Where did you get this definition of safety from? I’ve never heard someone define safety to exclude security issues; that doesn’t seem very useful.</div><br/><div id="36858818" class="c"><input type="checkbox" id="c-36858818" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36857039">parent</a><span>|</span><a href="#36857016">next</a><span>|</span><label class="collapse" for="c-36858818">[-]</label><label class="expand" for="c-36858818">[1 more]</label></div><br/><div class="children"><div class="content">Security can kill safety, yes.<p>Typically you would start with [0] and it&#x27;s derivations for specific domains.<p>The core idea is &quot;The fundamental concept is that any safety-related system must work correctly or fail in a predictable (safe) way.&quot;<p>The interesting question is what to do in corner cases you did not specify explicitly. Typically it is still considered &quot;safe&quot; if you don&#x27;t do what you would have specified in hindsight, but fall into the defined failure reaction. You also try to make security problems take that path.<p>Checking that the system does what is specified is called &quot;verification&quot; and the domain of functional safety. Checkin that this is what you actually meant (it actually solves the user&#x27;s problem) is called &quot;validation&quot; and especially for vehicles called SOTIF [1].<p>[0] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;IEC_61508" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;IEC_61508</a><p>[1] <a href="https:&#x2F;&#x2F;www.iso.org&#x2F;standard&#x2F;77490.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.iso.org&#x2F;standard&#x2F;77490.html</a></div><br/></div></div></div></div><div id="36857016" class="c"><input type="checkbox" id="c-36857016" checked=""/><div class="controls bullet"><span class="by">e-dant</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36856424">parent</a><span>|</span><a href="#36857039">prev</a><span>|</span><a href="#36856852">next</a><span>|</span><label class="collapse" for="c-36857016">[-]</label><label class="expand" for="c-36857016">[5 more]</label></div><br/><div class="children"><div class="content">The ABS system your car’s brakes could crash — literally — and that would be safe?</div><br/><div id="36857575" class="c"><input type="checkbox" id="c-36857575" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36857016">parent</a><span>|</span><a href="#36857018">next</a><span>|</span><label class="collapse" for="c-36857575">[-]</label><label class="expand" for="c-36857575">[1 more]</label></div><br/><div class="children"><div class="content">Ha, this is such a good example of both the advantage of fault tolerant systems and why so many true-to-life computing metaphors fall flat.</div><br/></div></div><div id="36857018" class="c"><input type="checkbox" id="c-36857018" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36857016">parent</a><span>|</span><a href="#36857575">prev</a><span>|</span><a href="#36856852">next</a><span>|</span><label class="collapse" for="c-36857018">[-]</label><label class="expand" for="c-36857018">[3 more]</label></div><br/><div class="children"><div class="content">Safe means that every operation has well specified semantics. Some languages, notably C and C++, lack this property.</div><br/><div id="36857491" class="c"><input type="checkbox" id="c-36857491" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36857018">parent</a><span>|</span><a href="#36858023">next</a><span>|</span><label class="collapse" for="c-36857491">[-]</label><label class="expand" for="c-36857491">[1 more]</label></div><br/><div class="children"><div class="content">I would say those languages are both unsafe and have undefined behavior, and these are two seperate issues.</div><br/></div></div><div id="36858023" class="c"><input type="checkbox" id="c-36858023" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36857018">parent</a><span>|</span><a href="#36857491">prev</a><span>|</span><a href="#36856852">next</a><span>|</span><label class="collapse" for="c-36858023">[-]</label><label class="expand" for="c-36858023">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what undefined behavior means.</div><br/></div></div></div></div></div></div><div id="36856852" class="c"><input type="checkbox" id="c-36856852" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36856424">parent</a><span>|</span><a href="#36857016">prev</a><span>|</span><a href="#36856136">next</a><span>|</span><label class="collapse" for="c-36856852">[-]</label><label class="expand" for="c-36856852">[3 more]</label></div><br/><div class="children"><div class="content">&gt;It does not mean free of bugs<p>What if there is a bug in those well-specified semantics?</div><br/><div id="36857022" class="c"><input type="checkbox" id="c-36857022" checked=""/><div class="controls bullet"><span class="by">Kranar</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36856852">parent</a><span>|</span><a href="#36856136">next</a><span>|</span><label class="collapse" for="c-36857022">[-]</label><label class="expand" for="c-36857022">[2 more]</label></div><br/><div class="children"><div class="content">Then the semantics are not well specified.</div><br/><div id="36857683" class="c"><input type="checkbox" id="c-36857683" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#36854386">root</a><span>|</span><a href="#36857022">parent</a><span>|</span><a href="#36856136">next</a><span>|</span><label class="collapse" for="c-36857683">[-]</label><label class="expand" for="c-36857683">[1 more]</label></div><br/><div class="children"><div class="content">The point being made here is that you can be infinitely specific and still run into unexpected failures.  If you&#x27;re going to claim there is a way out of that you are either <i>very</i> young of just straight up lying.<p>We&#x27;re talking about Erlang here which, to my knowledge, is the only mainstream-ish general-purpose programming language that was developed to solve an actual business problem.  To be that guy that quotes a relatively well-known quip that maybe you&#x27;ve already heard, the unofficial tagline was: &quot;Remember in the 90s when your phone company would call you up and say that you can&#x27;t use your phone for a few hours for &#x27;planned maintenance&#x27;?  Of course you don&#x27;t... and that&#x27;s tanks to Erlang.&quot;<p>That was accomplished because you can just specify the happy path, deal with <i>well-known</i> exceptions (are they really &quot;exceptional&quot; at this point?), and otherwise just turn it off and on again, as we all do.  And, not to start a flame war, but it&#x27;s a dynamically typed language to boot!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36853237" class="c"><input type="checkbox" id="c-36853237" checked=""/><div class="controls bullet"><span class="by">aeurielesn</span><span>|</span><a href="#36854386">prev</a><span>|</span><a href="#36854396">next</a><span>|</span><label class="collapse" for="c-36853237">[-]</label><label class="expand" for="c-36853237">[2 more]</label></div><br/><div class="children"><div class="content">What would normally be the process to debunk a published paper? Simply publishing another paper debunking it in the same journal?</div><br/><div id="36853746" class="c"><input type="checkbox" id="c-36853746" checked=""/><div class="controls bullet"><span class="by">Fomite</span><span>|</span><a href="#36853237">parent</a><span>|</span><a href="#36854396">next</a><span>|</span><label class="collapse" for="c-36853746">[-]</label><label class="expand" for="c-36853746">[1 more]</label></div><br/><div class="children"><div class="content">Often journals will accept &quot;letters&quot; in some form or another if the criticism is brief, and do on occasion publish full papers addressing the shortcomings of another.<p>When that fails, usually one would try another journal or two, and after that it&#x27;s usually some manner of blog posting and social media.</div><br/></div></div></div></div><div id="36854396" class="c"><input type="checkbox" id="c-36854396" checked=""/><div class="controls bullet"><span class="by">greatfilter251</span><span>|</span><a href="#36853237">prev</a><span>|</span><a href="#36852232">next</a><span>|</span><label class="collapse" for="c-36854396">[-]</label><label class="expand" for="c-36854396">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Practitioner perceptions are formed through personal experience, and not based on empirical evidence<p>The disagreement here is rooted in the empirical worldview. Empirically, &quot;rarely&quot; and &quot;never&quot; cannot be (reliably) distinguished, and so adherents of this worldview fail to distinguish claims which are meant to distinguish them.</div><br/></div></div><div id="36852973" class="c"><input type="checkbox" id="c-36852973" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#36852232">prev</a><span>|</span><a href="#36857953">next</a><span>|</span><label class="collapse" for="c-36852973">[-]</label><label class="expand" for="c-36852973">[9 more]</label></div><br/><div class="children"><div class="content">Disproving a report&#x27;s findings is not the same as disproving the existence of vulnerabilities universally.</div><br/><div id="36853074" class="c"><input type="checkbox" id="c-36853074" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#36852973">parent</a><span>|</span><a href="#36857953">next</a><span>|</span><label class="collapse" for="c-36853074">[-]</label><label class="expand" for="c-36853074">[8 more]</label></div><br/><div class="children"><div class="content">Well duh, that&#x27;s what the OG article is about, why the author of this one would need to repeat himself</div><br/><div id="36853374" class="c"><input type="checkbox" id="c-36853374" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36853074">parent</a><span>|</span><a href="#36857953">next</a><span>|</span><label class="collapse" for="c-36853374">[-]</label><label class="expand" for="c-36853374">[7 more]</label></div><br/><div class="children"><div class="content">The original article didn&#x27;t disprove the existence of vulnerabilities though. Is &quot;Concurrency is hard and I think this concurrency model is easier&quot; &quot;proof&quot;? Did you read either article?</div><br/><div id="36854745" class="c"><input type="checkbox" id="c-36854745" checked=""/><div class="controls bullet"><span class="by">csoups14</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36853374">parent</a><span>|</span><a href="#36857953">next</a><span>|</span><label class="collapse" for="c-36854745">[-]</label><label class="expand" for="c-36854745">[6 more]</label></div><br/><div class="children"><div class="content">From the original &quot;Elixir is Safe&quot; article:<p>&gt; 3. “Shared nothing” concurrency<p>&gt; Item 3 is the killer one for safety. Like two people, two processes cannot share memory; they can only communicate by sending each other messages.<p>This makes impossible an entire class of thread safety issues. &quot;Elixir is Safer&quot; might have been a better phrasing, but you&#x27;re misrepresenting the contents of the article if you&#x27;re claiming that it is limited to expounding &quot;concurrency is hard and I think this concurrency model is easier&quot;.</div><br/><div id="36858275" class="c"><input type="checkbox" id="c-36858275" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36854745">parent</a><span>|</span><a href="#36856393">next</a><span>|</span><label class="collapse" for="c-36858275">[-]</label><label class="expand" for="c-36858275">[1 more]</label></div><br/><div class="children"><div class="content">Just so people don’t get the bad idea, message passing is still prone to the general category of race conditions, just not data races (without shared memory).<p>Though there are runtime tools to detect live&#x2F;dead locks.</div><br/></div></div><div id="36856393" class="c"><input type="checkbox" id="c-36856393" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36854745">parent</a><span>|</span><a href="#36858275">prev</a><span>|</span><a href="#36855796">next</a><span>|</span><label class="collapse" for="c-36856393">[-]</label><label class="expand" for="c-36856393">[1 more]</label></div><br/><div class="children"><div class="content">Like the students, I assume that the GP hasn&#x27;t read the original article - which is very clear about what forms of safety it is discussing.</div><br/></div></div><div id="36855796" class="c"><input type="checkbox" id="c-36855796" checked=""/><div class="controls bullet"><span class="by">hosh</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36854745">parent</a><span>|</span><a href="#36856393">prev</a><span>|</span><a href="#36855762">next</a><span>|</span><label class="collapse" for="c-36855796">[-]</label><label class="expand" for="c-36855796">[1 more]</label></div><br/><div class="children"><div class="content">I thought binaries (&gt;= 64 bytes) are one of the exceptions to &quot;share nothing&quot; model? They are still immutable though.<p>Also, ETS, which shares data across processes, and may allow multiple writers. Granted, you have to explicitly opt-in for that.<p>And I am assuming we&#x27;re not considering NIFs, though Rust NIFs makes a lot of sense here.</div><br/></div></div><div id="36855762" class="c"><input type="checkbox" id="c-36855762" checked=""/><div class="controls bullet"><span class="by">alex_lav</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36854745">parent</a><span>|</span><a href="#36855796">prev</a><span>|</span><a href="#36857953">next</a><span>|</span><label class="collapse" for="c-36855762">[-]</label><label class="expand" for="c-36855762">[2 more]</label></div><br/><div class="children"><div class="content">Is static typing &quot;safe&quot;, and have I demonstrated that simply by publishing a blog about bugs in dynamically typed applications?</div><br/><div id="36857035" class="c"><input type="checkbox" id="c-36857035" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#36852973">root</a><span>|</span><a href="#36855762">parent</a><span>|</span><a href="#36857953">next</a><span>|</span><label class="collapse" for="c-36857035">[-]</label><label class="expand" for="c-36857035">[1 more]</label></div><br/><div class="children"><div class="content">Yes, if you demonstrate that entire class of bugs are ommited simply by the language inherently having some feature (like types) then it&#x27;s a decent argument that this language is safer, or even completely safe [from the specific type of bugs]</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36857953" class="c"><input type="checkbox" id="c-36857953" checked=""/><div class="controls bullet"><span class="by">ano88888</span><span>|</span><a href="#36852973">prev</a><span>|</span><label class="collapse" for="c-36857953">[-]</label><label class="expand" for="c-36857953">[3 more]</label></div><br/><div class="children"><div class="content">Deciding which i should use : Elixir or Clojurescript or python or nodejs</div><br/><div id="36858147" class="c"><input type="checkbox" id="c-36858147" checked=""/><div class="controls bullet"><span class="by">Hasnep</span><span>|</span><a href="#36857953">parent</a><span>|</span><a href="#36858705">next</a><span>|</span><label class="collapse" for="c-36858147">[-]</label><label class="expand" for="c-36858147">[1 more]</label></div><br/><div class="children"><div class="content">That really really depends on what you want to do, can you add a bit more information? Also those choices are not mutually exclusive, you can run Clojurescript on Node.js, but you would probably be better off using normal Clojure.</div><br/></div></div><div id="36858705" class="c"><input type="checkbox" id="c-36858705" checked=""/><div class="controls bullet"><span class="by">somecommit</span><span>|</span><a href="#36857953">parent</a><span>|</span><a href="#36858147">prev</a><span>|</span><label class="collapse" for="c-36858705">[-]</label><label class="expand" for="c-36858705">[1 more]</label></div><br/><div class="children"><div class="content">If you are asking out of the blue, it&#x27;s probably you just need to stick with nodejs, that is the most vanilla I think of</div><br/></div></div></div></div></div></div></div></div></div></body></html>