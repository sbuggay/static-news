<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705827653097" as="style"/><link rel="stylesheet" href="styles.css?v=1705827653097"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://axisofeval.blogspot.com/2024/01/common-lisps-block-return-from-and.html">Common Lisp&#x27;s block / return-from and unwind-protect</a> <span class="domain">(<a href="http://axisofeval.blogspot.com">axisofeval.blogspot.com</a>)</span></div><div class="subtext"><span>bshanks</span> | <span>11 comments</span></div><br/><div><div id="39075434" class="c"><input type="checkbox" id="c-39075434" checked=""/><div class="controls bullet"><span class="by">pfdietz</span><span>|</span><a href="#39075390">next</a><span>|</span><label class="collapse" for="c-39075434">[-]</label><label class="expand" for="c-39075434">[1 more]</label></div><br/><div class="children"><div class="content">Block&#x2F;return-from is a lexical transfer of control that can be non-local (you can transfer out of a lambda or defun to an enclosing scope).  For the dynamic equivalent there&#x27;s catch&#x2F;throw.   Both transfers activate unwind-protect if they unwind the stack through it.</div><br/></div></div><div id="39075390" class="c"><input type="checkbox" id="c-39075390" checked=""/><div class="controls bullet"><span class="by">wait_a_minute</span><span>|</span><a href="#39075434">prev</a><span>|</span><a href="#39076760">next</a><span>|</span><label class="collapse" for="c-39075390">[-]</label><label class="expand" for="c-39075390">[8 more]</label></div><br/><div class="children"><div class="content">Gah, another Lisp post to tempt me to add yet another mini project to my plate...I always am curious about trying more Lisp because I keep seeing commentary about how powerful it is to actually build applications once you get moving on building things.<p>Anyone here have any recent practical experience in this direction who would confirm this in Lisp vs in other programming languages? Does effort in Lisp really compound&#x2F;produce great code and great applications that much faster than other languages? (For web development primarily)</div><br/><div id="39076637" class="c"><input type="checkbox" id="c-39076637" checked=""/><div class="controls bullet"><span class="by">f1shy</span><span>|</span><a href="#39075390">parent</a><span>|</span><a href="#39075864">next</a><span>|</span><label class="collapse" for="c-39076637">[-]</label><label class="expand" for="c-39076637">[1 more]</label></div><br/><div class="children"><div class="content">Not so recent, about 6 years ago, I had to communicate with many instruments (PS, Oscilloscope, SMU, etc) to test a new ASIC we developed. There where hundreds of tests to be done. We wanted to automate the measurement and evaluation of results, because they were so many. Also there where 5 fabs and 2 suppliers with different design, but “pin compatible”.
I did the whole framework in emacs lisp, I had to implement ONC RPC and LXI on top to speak to the instruments…
The whole thing took me 2 weeks. At the time I had no idea of Elisp; only a little vit of scheme. I was proficient in C, and I would say it had taken me at least 6 Months to do the same</div><br/></div></div><div id="39075864" class="c"><input type="checkbox" id="c-39075864" checked=""/><div class="controls bullet"><span class="by">tiberius_p</span><span>|</span><a href="#39075390">parent</a><span>|</span><a href="#39076637">prev</a><span>|</span><a href="#39075587">next</a><span>|</span><label class="collapse" for="c-39075864">[-]</label><label class="expand" for="c-39075864">[1 more]</label></div><br/><div class="children"><div class="content">Lisp is great for creating your own domain specific languages. S-expressions are basically abstract syntax trees written as code. Thus you can take any code written in any language and &quot;lispify&quot; it into an S-expression. Then you can apply various transformations&#x2F;analyses on this expression to achieve various goals:linting, semantic modeling, compiling to machine code&#x2F;bytecode, transpiling to another laguage, interpreting, optimizing, etc. Common Lisp also has the possibility of on-the-fly recompilation of classes and methods&#x2F;functions which can be useful for debug and incremental development.I don&#x27;t have much experience in the web development area but I would incline to think that you won&#x27;t get much added value from using CL compared to other languages&#x2F;frameworks. It can be useful if you want to develop your own framework with custom language constructs and features. But if you want to fast prototype a webapp idea you&#x27;re better off trying the more popular solutions.</div><br/></div></div><div id="39075587" class="c"><input type="checkbox" id="c-39075587" checked=""/><div class="controls bullet"><span class="by">rokkitmensch</span><span>|</span><a href="#39075390">parent</a><span>|</span><a href="#39075864">prev</a><span>|</span><a href="#39075940">next</a><span>|</span><label class="collapse" for="c-39075587">[-]</label><label class="expand" for="c-39075587">[4 more]</label></div><br/><div class="children"><div class="content">Yes, building anything non-trivial in CL will show the discerning programmer that there is nothing new under the sun.</div><br/><div id="39075892" class="c"><input type="checkbox" id="c-39075892" checked=""/><div class="controls bullet"><span class="by">waynesonfire</span><span>|</span><a href="#39075390">root</a><span>|</span><a href="#39075587">parent</a><span>|</span><a href="#39075940">next</a><span>|</span><label class="collapse" for="c-39075892">[-]</label><label class="expand" for="c-39075892">[3 more]</label></div><br/><div class="children"><div class="content">Could you clarify what you mean by &#x27;there is nothing new under the sun&#x27; when referring to programming with Common Lisp? Are you indicating that Lisp has already introduced many of the concepts and features that are now found in modern programming languages, implying that contemporary languages have largely assimilated Lisp&#x27;s ideas and paradigms?<p>Your comment left me with a strange sentiment. I&#x27;m somewhat disheartening because it implies that learning Lisp might be redundant given that contemporary languages have already incorporated its best aspects.</div><br/><div id="39076038" class="c"><input type="checkbox" id="c-39076038" checked=""/><div class="controls bullet"><span class="by">phoe-krk</span><span>|</span><a href="#39075390">root</a><span>|</span><a href="#39075892">parent</a><span>|</span><a href="#39076093">next</a><span>|</span><label class="collapse" for="c-39076038">[-]</label><label class="expand" for="c-39076038">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Are you indicating that Lisp has already introduced many of the concepts and features that are now found in modern programming languages, implying that contemporary languages have largely assimilated Lisp&#x27;s ideas and paradigms?</i><p>Yes. See effect handlers for an example, which are making rounds around the programming world as of late. They are equivalent to the Lisp condition system, except formalized to work in strongly statically typed programming environments.<p><i>&gt; I&#x27;m somewhat disheartening because it implies that learning Lisp might be redundant given that contemporary languages have already incorporated its best aspects.</i><p>Sort of, lots of things have thankfully trickled from Lisps to other languages (including whole languages like Julia). The pleasant feeling of conversing with the language and programming bit by bit in it is hard to replicate with things like LSPs, though, since the implementation is always running in the background and programming in it is based on mutating it until it contains the program you seek.</div><br/></div></div><div id="39076093" class="c"><input type="checkbox" id="c-39076093" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#39075390">root</a><span>|</span><a href="#39075892">parent</a><span>|</span><a href="#39076038">prev</a><span>|</span><a href="#39075940">next</a><span>|</span><label class="collapse" for="c-39076093">[-]</label><label class="expand" for="c-39076093">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m somewhat disheartening because it implies that learning Lisp might be redundant given that contemporary languages have already incorporated its best aspects.<p>Indeed, Lisp is no longer as revelatory as it once was, since many innovations have been adopted, even surpassed in specific cases. Still, no other language gives you the total package. The environment is far more than the sum of its features list. CL just gets out of your way and allows you to think about problems not programming.</div><br/></div></div></div></div></div></div><div id="39075940" class="c"><input type="checkbox" id="c-39075940" checked=""/><div class="controls bullet"><span class="by">corinroyal</span><span>|</span><a href="#39075390">parent</a><span>|</span><a href="#39075587">prev</a><span>|</span><a href="#39076760">next</a><span>|</span><label class="collapse" for="c-39075940">[-]</label><label class="expand" for="c-39075940">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m learning programming at age fifty-four and have chosen Common Lisp as my one language for life. If you want something easy to learn with a ton of support pick Python, Elixir, and&#x2F;or JS. CL sucks for mini-projects since the learning curve requires serious commitment and is SO different from what people are used to.  CL requires a long-term commitment and demands the programmer challenge pop programming trends and deeply entrenched styles. You have to think beyond today to what could be and what once was. But if you&#x27;re willing to do that, there is no better language. Not Haskell, not OCamel, not Rust&#x2F;Go&#x2F;Julia&#x2F;Clojure&#x2F;Scheme, or the current lang du jour. Whatever limitations Common Lisp had in the past are long gone.<p>SBCL is blazingly fast, CL abstractions are profound yet practical. The type system gives you power without pettiness. Language-oriented programming is a superpower in a world of cut and paste library-oriented programming. Image-based computing often allows one to skip the impedance mismatch with DBs. In many cases and you can just persist the data structures as they are or serialize them where needed. The tooling with Roswell, Quicklisp, Qlot, Doom Emacs, and Sly make prototyping and exploratory programming wiz by. CLOG, Reblocks and Hunchentoot provide powerful abstractions for web programming, but Phoenix with Liveview is probably better for most. The debugging experience is so insanely powerful it freaks me out and makes other systems look rudimentary. CLOS, the object system, is best of breed and makes most of the standard criticisms of OO programming moot. The homoiconic list-based syntax and prefix notation are beautiful and never get in your way. Parentheses are invisible. The condition system makes flow control and error handling in other systems seem rigid and convoluted. Aspect-oriented programming is just what we do, not a thing tacked on. Macros and the meta-object protocol allow you to build a language on top of Lisp that allows users to conceptualize problems using nouns and verbs they already know.<p>Drop into Coalton or Shen for strong, static typing where necessary, or April (hosted APL) for array wizardry that makes NumPy look like data-flow programming in Basic on a Timex Sinclair with a cassette drive. You can slice and dice whole datasets in a few characters of code. Bundle existing C libs with CFFI when you find a good one you need. Lisp-based systems are alive and grow and change as requirements do. It&#x27;s harder to program yourself into a corner. Refactoring is continuous and mundane. In-source documentation is the right place for it, but Lispers tend to be shamefully lax in providing it. Shaaame! Newer Lispers tend to be better about docs--the culture is changing. Often you ask a question and get no response. Other times you get a detailed response from a legendary mind and just sit there in awe working your way through their thinking and feeling your inadequacy. The code is about as succinct as it can be to maintain readability. There are two camps on readability, some experienced Lispers find it harder, and most find it much easier to parse than ALGOL-derived syntax.<p>Once mastered, quick things are quick, hard things are straightforward, and impossible things are doable. This is a system for people who need, not want, to change the world. It gives single programmers and small teams the power to take on armies of bureaucratic programmers. But you have to be willing to break the mold, handle charges of elitism, not be required to justify your choice to managers, tolerate a small hiring pool, train newbies hard and long, not get freaked out using some libs that are stable and haven&#x27;t been updated in years, deal with the pace of development of a small community, have the patience and joy in problem-solving to handle frequent bafflement, read a ton of source code rather than search the forums, and be willing to roll your own when needed. If you can handle all the idiosyncrasies and have a burning need for elegance and power, then CL will reward and surprise into until dementia takes you.<p>In short, all the good things you&#x27;ve heard are true, many of the standard critiques are uninformed, and problems people talk about that apply to most languages often don&#x27;t apply.</div><br/></div></div></div></div><div id="39076760" class="c"><input type="checkbox" id="c-39076760" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#39075390">prev</a><span>|</span><label class="collapse" for="c-39076760">[-]</label><label class="expand" for="c-39076760">[1 more]</label></div><br/><div class="children"><div class="content">Is Common Lisp the first kitchen sink language (ala C++)? It always seems to me like there&#x27;s a lot of &quot;Oh yeah, Common Lisp has a feature for this, too&quot;-type blog posts, though very little about actual usage of it.</div><br/></div></div></div></div></div></div></div></body></html>