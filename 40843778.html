<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719910855186" as="style"/><link rel="stylesheet" href="styles.css?v=1719910855186"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">RegreSSHion: RCE in OpenSSH&#x27;s server, on glibc-based Linux systems</a> <span class="domain">(<a href="https://www.qualys.com">www.qualys.com</a>)</span></div><div class="subtext"><span>robinhoodexe</span> | <span>174 comments</span></div><br/><div><div id="40844134" class="c"><input type="checkbox" id="c-40844134" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#40846177">next</a><span>|</span><label class="collapse" for="c-40844134">[-]</label><label class="expand" for="c-40844134">[11 more]</label></div><br/><div class="children"><div class="content">Interestingly, the RCE fix was &quot;smuggled&quot; in public almost a month ago.<p><pre><code>    When PerSourcePenalties are enabled, sshd(8) will monitor the exit
    status of its child pre-auth session processes. Through the exit
    status, it can observe situations where the session did not
    authenticate as expected. These conditions include when the client
    repeatedly attempted authentication unsucessfully (possibly indicating
    an attack against one or more accounts, e.g. password guessing), or
    when client behaviour caused sshd to crash (possibly indicating
    attempts to exploit sshd).

    When such a condition is observed, sshd will record a penalty of some
    duration (e.g. 30 seconds) against the client&#x27;s address.
</code></pre>
<a href="https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;81c1099d22b81ebfd20a334ce986c4f753b0db29">https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;81c1099d2...</a><p>It&#x27;s not really a reversable patch that gives anything away to attackers: it changes the binary architecture in a way that has the side-effect of removing the specific vulnerability <i>and also</i> mitigates the whole exploit class, if I understand it correctly. Very clever.</div><br/><div id="40844217" class="c"><input type="checkbox" id="c-40844217" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40844134">parent</a><span>|</span><a href="#40848598">next</a><span>|</span><label class="collapse" for="c-40844217">[-]</label><label class="expand" for="c-40844217">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the RCE fix, this is the RCE fix <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40843865">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40843865</a><p>That&#x27;s a previously-announced feature for dealing with junk connections that also happens to mitigate this vulnerability because it makes it harder to win the race. Discussed previously <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40610621">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40610621</a></div><br/><div id="40844337" class="c"><input type="checkbox" id="c-40844337" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40844217">parent</a><span>|</span><a href="#40844316">next</a><span>|</span><label class="collapse" for="c-40844337">[-]</label><label class="expand" for="c-40844337">[1 more]</label></div><br/><div class="children"><div class="content">The ones you link are the &quot;minimal patches for those can&#x27;t&#x2F;don&#x27;t want to upgrade&quot;. The commit I am linking to is taken straight from the advisory.<p><pre><code>    On June 6, 2024, this signal handler race condition was fixed by commit
    81c1099 (&quot;Add a facility to sshd(8) to penalise particular problematic
    client behaviours&quot;), which moved the async-signal-unsafe code from
    sshd&#x27;s SIGALRM handler to sshd&#x27;s listener process, where it can be
    handled synchronously:

      https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;81c1099d22b81ebfd20a334ce986c4f753b0db29

    Because this fix is part of a large commit (81c1099), on top of an even
    larger defense-in-depth commit (03e3de4, &quot;Start the process of splitting
    sshd into separate binaries&quot;), it might prove difficult to backport. In
    that case, the signal handler race condition itself can be fixed by
    removing or commenting out the async-signal-unsafe code from the
    sshsigdie() function
</code></pre>
The cleverness here is that this commit is <i>both</i> &quot;a previously-announced feature for dealing with junk connections&quot;, <i>and</i> a mitigation for the exploit class against similar but unknown vulnerabilities, <i>and</i> a patch for the specific vulnerability because it &quot;moved the async-signal-unsafe code from sshd&#x27;s SIGALRM handler to sshd&#x27;s listener process, where it can be handled synchronously&quot;.<p>The cleverness is that it fixes the vulnerability as part of doing something that makes sense on its own, so you wouldn&#x27;t know it&#x27;s the patch even looking at it.</div><br/></div></div><div id="40844316" class="c"><input type="checkbox" id="c-40844316" checked=""/><div class="controls bullet"><span class="by">djmdjm</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40844217">parent</a><span>|</span><a href="#40844337">prev</a><span>|</span><a href="#40849364">next</a><span>|</span><label class="collapse" for="c-40844316">[-]</label><label class="expand" for="c-40844316">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s a fix. It completely removes the signal race as well as introducing a mitigation for similar future bugs</div><br/></div></div><div id="40849364" class="c"><input type="checkbox" id="c-40849364" checked=""/><div class="controls bullet"><span class="by">unixpickle</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40844217">parent</a><span>|</span><a href="#40844316">prev</a><span>|</span><a href="#40848598">next</a><span>|</span><label class="collapse" for="c-40849364">[-]</label><label class="expand" for="c-40849364">[1 more]</label></div><br/><div class="children"><div class="content">These lines from the diff linked above are the fix:<p><pre><code>    - &#x2F;\* Log error and exit. \*&#x2F;
    - sigdie(&quot;Timeout before authentication for %s port %d&quot;,
    -     ssh_remote_ipaddr(the_active_state),
    -     ssh_remote_port(the_active_state));
    + _exit(EXIT_LOGIN_GRACE);</code></pre></div><br/></div></div></div></div><div id="40848598" class="c"><input type="checkbox" id="c-40848598" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40844134">parent</a><span>|</span><a href="#40844217">prev</a><span>|</span><a href="#40846177">next</a><span>|</span><label class="collapse" for="c-40848598">[-]</label><label class="expand" for="c-40848598">[6 more]</label></div><br/><div class="children"><div class="content">Has this fix been pushed to &#x2F; pulled by distributions yet?</div><br/><div id="40851979" class="c"><input type="checkbox" id="c-40851979" checked=""/><div class="controls bullet"><span class="by">MrRadar</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40848598">parent</a><span>|</span><a href="#40850512">next</a><span>|</span><label class="collapse" for="c-40851979">[-]</label><label class="expand" for="c-40851979">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fixed in Debian 12[1]. Debian 11 and earlier&#x27;s SSH version was not vulnerable.<p>[1] <a href="https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;source-package&#x2F;openssh" rel="nofollow">https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;source-package&#x2F;o...</a></div><br/></div></div><div id="40850512" class="c"><input type="checkbox" id="c-40850512" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40848598">parent</a><span>|</span><a href="#40851979">prev</a><span>|</span><a href="#40852331">next</a><span>|</span><label class="collapse" for="c-40850512">[-]</label><label class="expand" for="c-40850512">[2 more]</label></div><br/><div class="children"><div class="content">Fedora: not yet.<p><a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=CVE-2024-6387" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=CVE-2024-6387</a> (tracking task)<p><a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2294905" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2294905</a> (Fedora 39 issue)</div><br/><div id="40852321" class="c"><input type="checkbox" id="c-40852321" checked=""/><div class="controls bullet"><span class="by">CaliforniaKarl</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40850512">parent</a><span>|</span><a href="#40852331">next</a><span>|</span><label class="collapse" for="c-40852321">[-]</label><label class="expand" for="c-40852321">[1 more]</label></div><br/><div class="children"><div class="content">And <a href="https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2294904" rel="nofollow">https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id=2294904</a> (Fedora 40 issue)<p>EL 9 is also affected, but not yet released.  The tracking task will update as things move along.</div><br/></div></div></div></div><div id="40852331" class="c"><input type="checkbox" id="c-40852331" checked=""/><div class="controls bullet"><span class="by">CaliforniaKarl</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40848598">parent</a><span>|</span><a href="#40850512">prev</a><span>|</span><a href="#40852243">next</a><span>|</span><label class="collapse" for="c-40852331">[-]</label><label class="expand" for="c-40852331">[1 more]</label></div><br/><div class="children"><div class="content">Ubuntu&#x27;s also got patches out for 22.04 LTS, 23.10, and 24.04 LTS.  See <a href="https:&#x2F;&#x2F;ubuntu.com&#x2F;security&#x2F;notices&#x2F;USN-6859-1" rel="nofollow">https:&#x2F;&#x2F;ubuntu.com&#x2F;security&#x2F;notices&#x2F;USN-6859-1</a>.<p>Amazon Linux 2023 is affected; Amazon Linux 1 &amp; 2 are not.  Status updates will be posted to <a href="https:&#x2F;&#x2F;explore.alas.aws.amazon.com&#x2F;CVE-2024-6387.html" rel="nofollow">https:&#x2F;&#x2F;explore.alas.aws.amazon.com&#x2F;CVE-2024-6387.html</a></div><br/></div></div><div id="40852243" class="c"><input type="checkbox" id="c-40852243" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#40844134">root</a><span>|</span><a href="#40848598">parent</a><span>|</span><a href="#40852331">prev</a><span>|</span><a href="#40846177">next</a><span>|</span><label class="collapse" for="c-40852243">[-]</label><label class="expand" for="c-40852243">[1 more]</label></div><br/><div class="children"><div class="content">SUSE has the fixes under testing. I assume you could install them directly from OBS. I have not tried because I have no exposed system. <a href="https:&#x2F;&#x2F;www.suse.com&#x2F;security&#x2F;cve&#x2F;CVE-2024-6387.html" rel="nofollow">https:&#x2F;&#x2F;www.suse.com&#x2F;security&#x2F;cve&#x2F;CVE-2024-6387.html</a></div><br/></div></div></div></div></div></div><div id="40846177" class="c"><input type="checkbox" id="c-40846177" checked=""/><div class="controls bullet"><span class="by">NelsonMinar</span><span>|</span><a href="#40844134">prev</a><span>|</span><a href="#40849004">next</a><span>|</span><label class="collapse" for="c-40846177">[-]</label><label class="expand" for="c-40846177">[2 more]</label></div><br/><div class="children"><div class="content">One interesting comment in the OpenSSH release notes<p>&gt; Successful exploitation has been demonstrated on 32-bit Linux&#x2F;glibc
systems with ASLR. Under lab conditions, the attack requires on
average 6-8 hours of continuous connections up to the maximum the
server will accept. Exploitation on 64-bit systems is believed to be
possible but has not been demonstrated at this time. It&#x27;s likely that
these attacks will be improved upon.<p><a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html" rel="nofollow">https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html</a></div><br/></div></div><div id="40849004" class="c"><input type="checkbox" id="c-40849004" checked=""/><div class="controls bullet"><span class="by">jamilbk</span><span>|</span><a href="#40846177">prev</a><span>|</span><a href="#40844073">next</a><span>|</span><label class="collapse" for="c-40849004">[-]</label><label class="expand" for="c-40849004">[6 more]</label></div><br/><div class="children"><div class="content">From the diff introducing the bug [1], the issue according to the analysis is that the function was refactored from this:<p><pre><code>  void
  sigdie(const char *fmt,...)
  {
  #ifdef DO_LOG_SAFE_IN_SIGHAND
   va_list args;
  
   va_start(args, fmt);
   do_log(SYSLOG_LEVEL_FATAL, fmt, args);
   va_end(args);
  #endif
   _exit(1);
  }
</code></pre>
to this:<p><pre><code>  void
  sshsigdie(const char *file, const char *func, int line, const char *fmt, ...)
  {
   va_list args;
  
   va_start(args, fmt);
   sshlogv(file, func, line, 0, SYSLOG_LEVEL_FATAL, fmt, args);
   va_end(args);
   _exit(1);
  }
</code></pre>
which lacks the #ifdef.<p>What could have prevented this? More eyes on the pull request? It&#x27;s wild that software nearly the entire world relies on for secure access is maintained by seemingly just two people [2].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;752250caabda3dd24635503c4cd689b32a650794">https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;752250caa...</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;graphs&#x2F;contributors">https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;graphs&#x2F;contribut...</a></div><br/><div id="40850351" class="c"><input type="checkbox" id="c-40850351" checked=""/><div class="controls bullet"><span class="by">unilynx</span><span>|</span><a href="#40849004">parent</a><span>|</span><a href="#40850205">next</a><span>|</span><label class="collapse" for="c-40850351">[-]</label><label class="expand" for="c-40850351">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always easy with hindsight to tell how to prevent something. In this case, a comment might have helped why the #ifdef was needed, eg<p><pre><code>  void CloseAllFromTheHardWay(int firstfd) &#x2F;&#x2F;Code here must be async-signal-safe! Locks may be in indeterminate state
  {
    struct rlimit lim;
    getrlimit(RLIMIT_NOFILE,&amp;lim);

    for (int fd=(lim.rlim_cur == RLIM_INFINITY ? 1024 : lim.rlim_cur);fd&gt;=firstfd;--fd)
      close(fd);
  }
</code></pre>
Although to be honest, getrlimit isn&#x27;t actually on the list here: <a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;signal-safety.7.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;signal-safety.7.html</a><p>But I hope that removing the comment or modifying code with a comment about async-signal-safe might have been noticed in review. The code you quoted only has the mention SAFE_IN_SIGHAND to suggest that this code might need to be async-signal-safe</div><br/><div id="40850504" class="c"><input type="checkbox" id="c-40850504" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#40849004">root</a><span>|</span><a href="#40850351">parent</a><span>|</span><a href="#40850205">next</a><span>|</span><label class="collapse" for="c-40850504">[-]</label><label class="expand" for="c-40850504">[1 more]</label></div><br/><div class="children"><div class="content">The ifdef name was a big clue!  &quot;SIGHAND&quot; is short for signal handler.  Sure, there is an implicit connection here from &quot;signal handler&quot; to &quot;all code must be async signal safe,&quot; but that association is pretty well known to most openssh authors and code reviewers.  Oh well, mistakes happen.</div><br/></div></div></div></div><div id="40850205" class="c"><input type="checkbox" id="c-40850205" checked=""/><div class="controls bullet"><span class="by">ghostpepper</span><span>|</span><a href="#40849004">parent</a><span>|</span><a href="#40850351">prev</a><span>|</span><a href="#40851965">next</a><span>|</span><label class="collapse" for="c-40850205">[-]</label><label class="expand" for="c-40850205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s wild that software nearly the entire world relies on for secure access is maintained by seemingly just two people<p>obligatory xkcd <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;2347&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;2347&#x2F;</a></div><br/></div></div><div id="40851965" class="c"><input type="checkbox" id="c-40851965" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#40849004">parent</a><span>|</span><a href="#40850205">prev</a><span>|</span><a href="#40844073">next</a><span>|</span><label class="collapse" for="c-40851965">[-]</label><label class="expand" for="c-40851965">[2 more]</label></div><br/><div class="children"><div class="content">One of these:<p>1. Using a proper programming language that doesn&#x27;t allow you to setup arbitrary functions as signal handlers (since that&#x27;s obviously unsafe on common libcs...) - e.g. you can&#x27;t do that in safe Rust, or Java, etc.<p>2. Using a well-implemented libc that doesn&#x27;t cause memory corruption when calling async-signal-unsafe functions but only deadlocks (this is very easy to achieve by treating code running in signals as a separate thread for thread-local storage access purposes), and preferably also doesn&#x27;t deadlock (this requires no global mutexes, or the ability to resume interrupted code holding a mutex)<p>3. Thinking when changing and accepting code, not like the people who committed and accepted [1] which just arbitrarily removes an #ifdef with no justification<p>4. Using simple well-engineered software written by good programmers instead of OpenSSH</div><br/><div id="40852786" class="c"><input type="checkbox" id="c-40852786" checked=""/><div class="controls bullet"><span class="by">bigiain</span><span>|</span><a href="#40849004">root</a><span>|</span><a href="#40851965">parent</a><span>|</span><a href="#40844073">next</a><span>|</span><label class="collapse" for="c-40852786">[-]</label><label class="expand" for="c-40852786">[1 more]</label></div><br/><div class="children"><div class="content">This is all great thinking.<p>Except for those of us who live in a world where most of their OS and utilities and libraries were originally written decades before Rust existed, and often even before Java existed. And where &quot;legacy&quot; C code pretty much underpins everything running on the public internet and which you need to connect to.<p>There&#x27;s a very real risk that reimplementing every piece of code on a modern internet connected server in exciting new &quot;safe&quot; languages and libc-type things - by a bunch of &quot;modern&quot; programmers who do not have the learning experience of decades worth of mistakes - will end up with not just new implementation of old and fixed bugs and security problems, but also with new implementations that are incompatible in strange and hard to debug ways with every existing piece of software that uses SSH protocols as they are deployed in the field.<p>I, for one, and not going to install and put into production version 1.0 of some new OpenSSH replacement written in Rust out Go or Java, which has a non zero chance of strange edge case bugs that are different when connecting to SSH on different Linux&#x2F;BSD&#x2F;Windows distros or versions, across different cpu architectures, and probably have subtly different bugs when connecting to different cloud hyperscalers.</div><br/></div></div></div></div></div></div><div id="40844073" class="c"><input type="checkbox" id="c-40844073" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40849004">prev</a><span>|</span><a href="#40844776">next</a><span>|</span><label class="collapse" for="c-40844073">[-]</label><label class="expand" for="c-40844073">[15 more]</label></div><br/><div class="children"><div class="content">It’s also worth reading the release notes <a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html" rel="nofollow">https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html</a><p>This is actually an interesting variant of a signal race bug. The vulnerability report says, “OpenBSD is notably not vulnerable, because its SIGALRM handler calls syslog_r(), an async-signal-safer version of syslog() that was invented by OpenBSD in 2001.” So a signal-safety mitigation encouraged OpenBSD developers to put non-trivial code inside signal handlers, which becomes unsafe when ported to other systems. They would have avoided this bug if they had done one of their refactoring sweeps to minimize the amount of code in signal handlers, according to the usual wisdom and common unix code guidelines.</div><br/><div id="40844257" class="c"><input type="checkbox" id="c-40844257" checked=""/><div class="controls bullet"><span class="by">djmdjm</span><span>|</span><a href="#40844073">parent</a><span>|</span><a href="#40844265">next</a><span>|</span><label class="collapse" for="c-40844257">[-]</label><label class="expand" for="c-40844257">[12 more]</label></div><br/><div class="children"><div class="content">Theo de Raadt made an, I think, cogent observation about this bug and how to prevent similar ones: no signal handler should call any function that isn&#x27;t a signal-safe syscall. The rationale is that, over time, it&#x27;s too way easy for any transitive call (where it&#x27;s not always clear that it can be reached in signal context) to pick up some call that isn&#x27;t async signal safe.</div><br/><div id="40845292" class="c"><input type="checkbox" id="c-40845292" checked=""/><div class="controls bullet"><span class="by">ralferoo</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40844257">parent</a><span>|</span><a href="#40844317">next</a><span>|</span><label class="collapse" for="c-40845292">[-]</label><label class="expand" for="c-40845292">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m kind of surprised advocating calling any syscall other than signal to add the handler back again. It&#x27;s been a long time since I looked at example code, but back in the mid 90s, everything I saw (and so informed my habits) just set a flag, listened to the signal again if it was something like SIGUSR1 and then you&#x27;d pick up the flag on the next iteration of your main loop. Maybe that&#x27;s also because I think of a signal like an interrupt, and something you want to get done as soon as possible to not cause any stalls to the main program.<p>I notice that nowadays signalfd() looks like a much better solution to the signal problem, but I&#x27;ve never tried using it. I think I&#x27;ll give it a go in my next project.</div><br/><div id="40846224" class="c"><input type="checkbox" id="c-40846224" checked=""/><div class="controls bullet"><span class="by">qhwudbebd</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40845292">parent</a><span>|</span><a href="#40846899">next</a><span>|</span><label class="collapse" for="c-40846224">[-]</label><label class="expand" for="c-40846224">[1 more]</label></div><br/><div class="children"><div class="content">In practice when I tried it, I wasn&#x27;t sold on signalfd&#x27;s benefits over the 90s style self-pipe, which is reliably portable too. Either way, being able to handle signals in a poll loop is much nicer than trying to do any real work in an async context.</div><br/></div></div><div id="40846899" class="c"><input type="checkbox" id="c-40846899" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40845292">parent</a><span>|</span><a href="#40846224">prev</a><span>|</span><a href="#40844317">next</a><span>|</span><label class="collapse" for="c-40846899">[-]</label><label class="expand" for="c-40846899">[4 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t the case for OpenSSH but because a lot of environments (essentially all managed runtimes) actually do this transparently for you when you register a signal &quot;handler&quot; it might be that less people are aware that actual signal handlers require a ton of care. On the other hand &quot;you can&#x27;t even call strcmp in a signal handler or you&#x27;ll randomly corrupt program state&quot; used to be a favorite among practicing C lawyers.</div><br/><div id="40850654" class="c"><input type="checkbox" id="c-40850654" checked=""/><div class="controls bullet"><span class="by">lilyball</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40846899">parent</a><span>|</span><a href="#40844317">next</a><span>|</span><label class="collapse" for="c-40850654">[-]</label><label class="expand" for="c-40850654">[3 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t you call strcmp? I think a general practice of &quot;only call functions that are explicitly blessed as async-signal-safe&quot; is a good idea, which means not calling strcmp as it hasn&#x27;t been blessed, but surely it doesn&#x27;t touch any global (or per-thread) state so how can it corrupt program state?<p>Update: according to <a href="https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;signal-safety.7.html" rel="nofollow">https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man7&#x2F;signal-safety.7.html</a> strcmp() actually is async-signal-safe as of POSIX.1-2008 TC2.</div><br/><div id="40853112" class="c"><input type="checkbox" id="c-40853112" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40850654">parent</a><span>|</span><a href="#40853508">next</a><span>|</span><label class="collapse" for="c-40853112">[-]</label><label class="expand" for="c-40853112">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the point. They weren&#x27;t added until TC2 in 2016.</div><br/></div></div><div id="40853508" class="c"><input type="checkbox" id="c-40853508" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40850654">parent</a><span>|</span><a href="#40853112">prev</a><span>|</span><a href="#40844317">next</a><span>|</span><label class="collapse" for="c-40853508">[-]</label><label class="expand" for="c-40853508">[1 more]</label></div><br/><div class="children"><div class="content">&gt; surely it doesn&#x27;t touch any global (or per-thread) state<p>Not necessarily. An implementation might choose to e.g. use some kind of cache similar to what the JVM does with interned strings, and then a function like strcmp() might behave badly if it happened to run while that cache was halfway through being rebuilt.</div><br/></div></div></div></div></div></div></div></div><div id="40844317" class="c"><input type="checkbox" id="c-40844317" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40844257">parent</a><span>|</span><a href="#40845292">prev</a><span>|</span><a href="#40844265">next</a><span>|</span><label class="collapse" for="c-40844317">[-]</label><label class="expand" for="c-40844317">[5 more]</label></div><br/><div class="children"><div class="content">Exactly, yes :-) Signal handlers have so many hazards it&#x27;s vital to keep them as simple as possible.</div><br/><div id="40845854" class="c"><input type="checkbox" id="c-40845854" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40844317">parent</a><span>|</span><a href="#40844910">next</a><span>|</span><label class="collapse" for="c-40845854">[-]</label><label class="expand" for="c-40845854">[2 more]</label></div><br/><div class="children"><div class="content">A rule I try to follow: either set a global variable or write to a self pipe (using the write syscall), and handle the signal in the main loop.</div><br/><div id="40847958" class="c"><input type="checkbox" id="c-40847958" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40845854">parent</a><span>|</span><a href="#40844910">next</a><span>|</span><label class="collapse" for="c-40847958">[-]</label><label class="expand" for="c-40847958">[1 more]</label></div><br/><div class="children"><div class="content">&gt; either set a global variable<p>IIRC, the rule is also that said global variable must have the type &quot;volatile sig_atomic_t&quot;.</div><br/></div></div></div></div><div id="40844910" class="c"><input type="checkbox" id="c-40844910" checked=""/><div class="controls bullet"><span class="by">growse</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40844317">parent</a><span>|</span><a href="#40845854">prev</a><span>|</span><a href="#40844265">next</a><span>|</span><label class="collapse" for="c-40844910">[-]</label><label class="expand" for="c-40844910">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not overly familiar with the language and tooling ecosystem, but how trivial is this to detect on a static analysis?</div><br/><div id="40854042" class="c"><input type="checkbox" id="c-40854042" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40844910">parent</a><span>|</span><a href="#40844265">next</a><span>|</span><label class="collapse" for="c-40854042">[-]</label><label class="expand" for="c-40854042">[1 more]</label></div><br/><div class="children"><div class="content">Quite easy.</div><br/></div></div></div></div></div></div></div></div><div id="40844265" class="c"><input type="checkbox" id="c-40844265" checked=""/><div class="controls bullet"><span class="by">INTPenis</span><span>|</span><a href="#40844073">parent</a><span>|</span><a href="#40844257">prev</a><span>|</span><a href="#40844776">next</a><span>|</span><label class="collapse" for="c-40844265">[-]</label><label class="expand" for="c-40844265">[2 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s very likely that some young sysadmin or intern that will have to patch for this vuln was not even born when OpenBSD implemented the solution.</div><br/><div id="40846424" class="c"><input type="checkbox" id="c-40846424" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40844073">root</a><span>|</span><a href="#40844265">parent</a><span>|</span><a href="#40844776">next</a><span>|</span><label class="collapse" for="c-40846424">[-]</label><label class="expand" for="c-40846424">[1 more]</label></div><br/><div class="children"><div class="content">n&gt;=1, one of our juniors is indeed younger than the OpenBSD fix and dealing with this bug.</div><br/></div></div></div></div></div></div><div id="40844776" class="c"><input type="checkbox" id="c-40844776" checked=""/><div class="controls bullet"><span class="by">qhwudbebd</span><span>|</span><a href="#40844073">prev</a><span>|</span><a href="#40843949">next</a><span>|</span><label class="collapse" for="c-40844776">[-]</label><label class="expand" for="c-40844776">[7 more]</label></div><br/><div class="children"><div class="content">Once I&#x27;d finished upgrading my openssh instances (which are linked against musl not glibc) I thought it&#x27;d be interesting to have a poke at musl&#x27;s syslog(3) and see if it allocates too and so is easily exploitable in the same way. But as far as I can see, it doesn&#x27;t:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;musl&#x2F;blob&#x2F;master&#x2F;src&#x2F;misc&#x2F;syslog.c">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;musl&#x2F;blob&#x2F;master&#x2F;src&#x2F;misc&#x2F;syslog.c</a><p>Everything there is either on stack or in static variables protected from reentrancy by the lock. The {d,sn,vsn}printf() calls there don&#x27;t allocate in musl, although they might in glibc. Have I missed anything here?</div><br/><div id="40847984" class="c"><input type="checkbox" id="c-40847984" checked=""/><div class="controls bullet"><span class="by">qhwudbebd</span><span>|</span><a href="#40844776">parent</a><span>|</span><a href="#40845526">next</a><span>|</span><label class="collapse" for="c-40847984">[-]</label><label class="expand" for="c-40847984">[1 more]</label></div><br/><div class="children"><div class="content">Confirmation from Rich: <a href="https:&#x2F;&#x2F;fosstodon.org&#x2F;@musl&#x2F;112711796005712271" rel="nofollow">https:&#x2F;&#x2F;fosstodon.org&#x2F;@musl&#x2F;112711796005712271</a></div><br/></div></div><div id="40845526" class="c"><input type="checkbox" id="c-40845526" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#40844776">parent</a><span>|</span><a href="#40847984">prev</a><span>|</span><a href="#40843949">next</a><span>|</span><label class="collapse" for="c-40845526">[-]</label><label class="expand" for="c-40845526">[5 more]</label></div><br/><div class="children"><div class="content">If you are right about the allocations, then I think the worst it can do is deadlock since the locks aren&#x27;t recursive. Deadlock in sigalrm could still lead to a DOS since that might prevent it from cleaning up connections.</div><br/><div id="40845779" class="c"><input type="checkbox" id="c-40845779" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40844776">root</a><span>|</span><a href="#40845526">parent</a><span>|</span><a href="#40846263">next</a><span>|</span><label class="collapse" for="c-40845779">[-]</label><label class="expand" for="c-40845779">[3 more]</label></div><br/><div class="children"><div class="content">Heretical opinion: signal handler activations should count as separate threads for the purposes of recursive locking.</div><br/><div id="40847980" class="c"><input type="checkbox" id="c-40847980" checked=""/><div class="controls bullet"><span class="by">bhawks</span><span>|</span><a href="#40844776">root</a><span>|</span><a href="#40845779">parent</a><span>|</span><a href="#40846263">next</a><span>|</span><label class="collapse" for="c-40847980">[-]</label><label class="expand" for="c-40847980">[2 more]</label></div><br/><div class="children"><div class="content">How would be done without introducing deadlock?</div><br/><div id="40848070" class="c"><input type="checkbox" id="c-40848070" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40844776">root</a><span>|</span><a href="#40847980">parent</a><span>|</span><a href="#40846263">next</a><span>|</span><label class="collapse" for="c-40848070">[-]</label><label class="expand" for="c-40848070">[1 more]</label></div><br/><div class="children"><div class="content">You’d get a deadlock, absolutely. But I’m fine with that: if the thread wants to access some state protected by a mutex, then while holding it (effectively) spawns a signal handler activation and waits for it to complete, and the signal handler tries to accept some state protected by the same mutex, then the program has just deadlocked (mutex → signal handler → mutex) and deserves to hang (or die, as this is a very simple situation as far as deadlock detection goes). That’s in any case better than corrupted state.</div><br/></div></div></div></div></div></div><div id="40846263" class="c"><input type="checkbox" id="c-40846263" checked=""/><div class="controls bullet"><span class="by">qhwudbebd</span><span>|</span><a href="#40844776">root</a><span>|</span><a href="#40845526">parent</a><span>|</span><a href="#40845779">prev</a><span>|</span><a href="#40843949">next</a><span>|</span><label class="collapse" for="c-40846263">[-]</label><label class="expand" for="c-40846263">[1 more]</label></div><br/><div class="children"><div class="content">Yes, true: if the alarm signal arrives right in the middle of another syslog() call, this should deadlock. (Safer that it not deadlocking and accessing the static state in the signal handler of course!)</div><br/></div></div></div></div></div></div><div id="40843949" class="c"><input type="checkbox" id="c-40843949" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40844776">prev</a><span>|</span><a href="#40844060">next</a><span>|</span><label class="collapse" for="c-40843949">[-]</label><label class="expand" for="c-40843949">[1 more]</label></div><br/><div class="children"><div class="content">Patch out for FreeBSD.  Not clear if affected (it has only known to be exploitable with glibc, which we don&#x27;t use) but best to be safe.<p><a href="https:&#x2F;&#x2F;www.freebsd.org&#x2F;security&#x2F;advisories&#x2F;FreeBSD-SA-24:04.openssh.asc" rel="nofollow">https:&#x2F;&#x2F;www.freebsd.org&#x2F;security&#x2F;advisories&#x2F;FreeBSD-SA-24:04...</a></div><br/></div></div><div id="40844060" class="c"><input type="checkbox" id="c-40844060" checked=""/><div class="controls bullet"><span class="by">rfmoz</span><span>|</span><a href="#40843949">prev</a><span>|</span><a href="#40843914">next</a><span>|</span><label class="collapse" for="c-40844060">[-]</label><label class="expand" for="c-40844060">[7 more]</label></div><br/><div class="children"><div class="content">From the report:<p>&gt; Finally, if sshd cannot be updated or recompiled, this signal handler
race condition can be fixed by simply setting LoginGraceTime to 0 in the
configuration file. This makes sshd vulnerable to a denial of service
(the exhaustion of all MaxStartups connections), but it makes it safe
from the remote code execution presented in this advisory.<p>Setting &#x27;LoginGraceTime 0&#x27; in sshd_config file seems to mitigate the issue.</div><br/><div id="40845290" class="c"><input type="checkbox" id="c-40845290" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40844060">parent</a><span>|</span><a href="#40852701">next</a><span>|</span><label class="collapse" for="c-40845290">[-]</label><label class="expand" for="c-40845290">[5 more]</label></div><br/><div class="children"><div class="content">Hang on, <a href="https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man5&#x2F;sshd_config.5.html" rel="nofollow">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man5&#x2F;sshd_config.5.html</a> says<p>&gt; If the value is 0, there is no time limit.<p>Isn&#x27;t that <i>worse</i>?</div><br/><div id="40846136" class="c"><input type="checkbox" id="c-40846136" checked=""/><div class="controls bullet"><span class="by">pm215</span><span>|</span><a href="#40844060">root</a><span>|</span><a href="#40845290">parent</a><span>|</span><a href="#40845430">next</a><span>|</span><label class="collapse" for="c-40846136">[-]</label><label class="expand" for="c-40846136">[2 more]</label></div><br/><div class="children"><div class="content">The bug is a race condition which is triggered by code which runs when the timeout expires and the SIGALRM handler is run. If there is no time limit, then the SIGALRM handler will never run, and the race doesn&#x27;t happen.<p>(As the advisory notes, you do then have to deal with the DoS which the timeout setting is intended to avoid, where N clients all connect and then never disconnect, and they aren&#x27;t timed-out and forcibly disconnected on the server end any more.)</div><br/><div id="40847852" class="c"><input type="checkbox" id="c-40847852" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40844060">root</a><span>|</span><a href="#40846136">parent</a><span>|</span><a href="#40845430">next</a><span>|</span><label class="collapse" for="c-40847852">[-]</label><label class="expand" for="c-40847852">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the explanation; I&#x27;d skimmed a little too fast and assumed that this was the more traditional &quot;how many attempts can we squeeze in each connection&quot; rather than something at the end. I guess this makes the hardening advice about lowering that time limit kind of unfortunate.</div><br/></div></div></div></div><div id="40845430" class="c"><input type="checkbox" id="c-40845430" checked=""/><div class="controls bullet"><span class="by">sodality2</span><span>|</span><a href="#40844060">root</a><span>|</span><a href="#40845290">parent</a><span>|</span><a href="#40846136">prev</a><span>|</span><a href="#40846923">next</a><span>|</span><label class="collapse" for="c-40845430">[-]</label><label class="expand" for="c-40845430">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like at the end of the default 600 seconds is when the race condition occurs. Set no limit, and there is no end<p>&gt; In our experiments, it takes ~10,000 tries on average to win this race condition; i.e., with 10 connections (MaxStartups) accepted per 600 seconds (LoginGraceTime), it takes ~1 week on average to obtain a remote root shell.</div><br/></div></div><div id="40846923" class="c"><input type="checkbox" id="c-40846923" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40844060">root</a><span>|</span><a href="#40845290">parent</a><span>|</span><a href="#40845430">prev</a><span>|</span><a href="#40852701">next</a><span>|</span><label class="collapse" for="c-40846923">[-]</label><label class="expand" for="c-40846923">[1 more]</label></div><br/><div class="children"><div class="content">If you can turn on TCP keepalive for the server connections, you would still have a timeout, even if it&#x27;s typically 2 hours. Then if someone wants to keep connections open and run you out of sockets and processes, they&#x27;ve got to keep sockets open on their end (but they might run a less expensive userspace tcp)<p>You can belt and suspenders with an external tool that watches for sshd in pre-auth for your real timeout and kills it or drops the tcp connection [1] (which will make the sshd exit in a more orderly fashion)<p>[1] <a href="https:&#x2F;&#x2F;man.freebsd.org&#x2F;cgi&#x2F;man.cgi?query=tcpdrop" rel="nofollow">https:&#x2F;&#x2F;man.freebsd.org&#x2F;cgi&#x2F;man.cgi?query=tcpdrop</a></div><br/></div></div></div></div><div id="40852701" class="c"><input type="checkbox" id="c-40852701" checked=""/><div class="controls bullet"><span class="by">ranger_danger</span><span>|</span><a href="#40844060">parent</a><span>|</span><a href="#40845290">prev</a><span>|</span><a href="#40843914">next</a><span>|</span><label class="collapse" for="c-40852701">[-]</label><label class="expand" for="c-40852701">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps a more realistic workaround would be simply to make the grace time (or inversely, max connections) long enough that the chances of a successful attack are far too long in the future to be worth attempting.</div><br/></div></div></div></div><div id="40843914" class="c"><input type="checkbox" id="c-40843914" checked=""/><div class="controls bullet"><span class="by">0x0</span><span>|</span><a href="#40844060">prev</a><span>|</span><a href="#40844191">next</a><span>|</span><label class="collapse" for="c-40843914">[-]</label><label class="expand" for="c-40843914">[11 more]</label></div><br/><div class="children"><div class="content">Patch out for Debian 12; Debian 11 not affected.<p><a href="https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;CVE-2024-6387" rel="nofollow">https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;CVE-2024-6387</a></div><br/><div id="40844681" class="c"><input type="checkbox" id="c-40844681" checked=""/><div class="controls bullet"><span class="by">wiredfool</span><span>|</span><a href="#40843914">parent</a><span>|</span><a href="#40844714">next</a><span>|</span><label class="collapse" for="c-40844681">[-]</label><label class="expand" for="c-40844681">[7 more]</label></div><br/><div class="children"><div class="content">Looks like Focal (20.04) isn&#x27;t on an affected version.  Jammy (22.04) looks like it is.</div><br/><div id="40845285" class="c"><input type="checkbox" id="c-40845285" checked=""/><div class="controls bullet"><span class="by">feurio</span><span>|</span><a href="#40843914">root</a><span>|</span><a href="#40844681">parent</a><span>|</span><a href="#40850783">next</a><span>|</span><label class="collapse" for="c-40845285">[-]</label><label class="expand" for="c-40845285">[1 more]</label></div><br/><div class="children"><div class="content">My procrastination pays off ...</div><br/></div></div><div id="40850783" class="c"><input type="checkbox" id="c-40850783" checked=""/><div class="controls bullet"><span class="by">urza</span><span>|</span><a href="#40843914">root</a><span>|</span><a href="#40844681">parent</a><span>|</span><a href="#40845285">prev</a><span>|</span><a href="#40846335">next</a><span>|</span><label class="collapse" for="c-40850783">[-]</label><label class="expand" for="c-40850783">[1 more]</label></div><br/><div class="children"><div class="content">On 22.04 apt update &amp;&amp; upgrade doesn&#x27;t help.. yet?</div><br/></div></div><div id="40846335" class="c"><input type="checkbox" id="c-40846335" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40843914">root</a><span>|</span><a href="#40844681">parent</a><span>|</span><a href="#40850783">prev</a><span>|</span><a href="#40845487">next</a><span>|</span><label class="collapse" for="c-40846335">[-]</label><label class="expand" for="c-40846335">[3 more]</label></div><br/><div class="children"><div class="content">What about, uh, 18.04?<p>Edit: 18.04 Bionic is unaffected, the ssh version is 7.6 which is too old.</div><br/><div id="40846454" class="c"><input type="checkbox" id="c-40846454" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#40843914">root</a><span>|</span><a href="#40846335">parent</a><span>|</span><a href="#40852923">next</a><span>|</span><label class="collapse" for="c-40846454">[-]</label><label class="expand" for="c-40846454">[1 more]</label></div><br/><div class="children"><div class="content">If you have extended support: Just update (if it&#x27;s not so old that it&#x27;s not even affected in the first place)<p>If you don&#x27;t have extended support: You&#x27;re vulnerable to worse, easier to exploit bugs :)</div><br/></div></div><div id="40852923" class="c"><input type="checkbox" id="c-40852923" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40843914">root</a><span>|</span><a href="#40846335">parent</a><span>|</span><a href="#40846454">prev</a><span>|</span><a href="#40845487">next</a><span>|</span><label class="collapse" for="c-40852923">[-]</label><label class="expand" for="c-40852923">[1 more]</label></div><br/><div class="children"><div class="content">I can confirm this 18.04 machine still gets some important updates like kernel upgrades and patched versions of Apache.</div><br/></div></div></div></div></div></div><div id="40844714" class="c"><input type="checkbox" id="c-40844714" checked=""/><div class="controls bullet"><span class="by">theandrewbailey</span><span>|</span><a href="#40843914">parent</a><span>|</span><a href="#40844681">prev</a><span>|</span><a href="#40844288">next</a><span>|</span><label class="collapse" for="c-40844714">[-]</label><label class="expand" for="c-40844714">[2 more]</label></div><br/><div class="children"><div class="content">Just ran an apt update and upgrade on my Debian 12 server. OpenSSH packages were the only ones upgraded.</div><br/><div id="40845960" class="c"><input type="checkbox" id="c-40845960" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#40843914">root</a><span>|</span><a href="#40844714">parent</a><span>|</span><a href="#40844288">next</a><span>|</span><label class="collapse" for="c-40845960">[-]</label><label class="expand" for="c-40845960">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the Debian 12 fix is out. You can verify you&#x27;re patched by running &#x27;ssh -V&#x27; and verifying you see &#x27;deb12u3&#x27;. If you see &#x27;deb12u2&#x27; then you&#x27;re vulnerable [1].<p>[1] <a href="https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;CVE-2024-6387" rel="nofollow">https:&#x2F;&#x2F;security-tracker.debian.org&#x2F;tracker&#x2F;CVE-2024-6387</a></div><br/></div></div></div></div><div id="40844288" class="c"><input type="checkbox" id="c-40844288" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40843914">parent</a><span>|</span><a href="#40844714">prev</a><span>|</span><a href="#40844191">next</a><span>|</span><label class="collapse" for="c-40844288">[-]</label><label class="expand" for="c-40844288">[1 more]</label></div><br/><div class="children"><div class="content">Can confirm, Pi OS bullseye also has the updated openssh.</div><br/></div></div></div></div><div id="40844191" class="c"><input type="checkbox" id="c-40844191" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#40843914">prev</a><span>|</span><a href="#40843865">next</a><span>|</span><label class="collapse" for="c-40844191">[-]</label><label class="expand" for="c-40844191">[18 more]</label></div><br/><div class="children"><div class="content">This is a really good find.<p>One thing which (as an independant person, who isn&#x27;t doing any of the work!) is it often feels like in order to &#x27;win&#x27;, people are expected to find a full chain which gives them remote access, rather than just finding one issue, and getting it fixed &#x2F; getting paid for it.<p>It feels to me like finding a single hole should be sufficient -- one memory corruption, one sandbox escape. Maybe at the moment there are just too many little issues, that you need a full end-to-end hack to really convince people to take you seriously, or pay out bounties?</div><br/><div id="40844233" class="c"><input type="checkbox" id="c-40844233" checked=""/><div class="controls bullet"><span class="by">rlpb</span><span>|</span><a href="#40844191">parent</a><span>|</span><a href="#40844243">next</a><span>|</span><label class="collapse" for="c-40844233">[-]</label><label class="expand" for="c-40844233">[5 more]</label></div><br/><div class="children"><div class="content">There are many wannabe security researchers who find issues that are definitely not exploitable, and then demand CVE numbers and other forms of recognition or even a bounty. For example, there might be an app that crashes when accepting malformed <i>trusted</i> input, but the nature of the app is that it&#x27;s never intended to and realistically never will be exposed to an adversary. In most people&#x27;s eyes, these are simply bugs, not security bugs, and while are nice to fix, aren&#x27;t on the same level. It&#x27;s not very difficult to find one of these!<p>So there is a need to differentiate between &quot;real&quot; security bugs [like this one] and non-security-impacting bugs, and demonstrating how an issue is exploitable is therefore very important.<p>I don&#x27;t see the need to demonstrate this going away any time soon, because there will always be no end of non-security-impacting bugs.</div><br/><div id="40844920" class="c"><input type="checkbox" id="c-40844920" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844233">parent</a><span>|</span><a href="#40844240">next</a><span>|</span><label class="collapse" for="c-40844920">[-]</label><label class="expand" for="c-40844920">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I&#x27;ve seen all kinds of insane stuff, like &quot;setting this public field of a java class to a garbage value will cause a null pointer exception&quot;</div><br/></div></div><div id="40844240" class="c"><input type="checkbox" id="c-40844240" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844233">parent</a><span>|</span><a href="#40844920">prev</a><span>|</span><a href="#40847604">next</a><span>|</span><label class="collapse" for="c-40844240">[-]</label><label class="expand" for="c-40844240">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are many wannabe security researchers who find issues that are definitely not exploitable, and then demand CVE numbers and other forms of recognition or even a bounty<p>I believe this has happened to curl several times recently.</div><br/><div id="40845324" class="c"><input type="checkbox" id="c-40845324" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844240">parent</a><span>|</span><a href="#40847604">next</a><span>|</span><label class="collapse" for="c-40845324">[-]</label><label class="expand" for="c-40845324">[1 more]</label></div><br/><div class="children"><div class="content">It happens constantly to any startup with a security@ email address.</div><br/></div></div></div></div><div id="40847604" class="c"><input type="checkbox" id="c-40847604" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844233">parent</a><span>|</span><a href="#40844240">prev</a><span>|</span><a href="#40844243">next</a><span>|</span><label class="collapse" for="c-40847604">[-]</label><label class="expand" for="c-40847604">[1 more]</label></div><br/><div class="children"><div class="content">So many &quot;Security Researchers&quot; are just throwing ZAP at websites and dumping the result into the security@ mail, because there might be minor security improvements by setting yet another obscure browser security header for cases that might not even be applicable.<p>Or there is no real consideration if that&#x27;s actually an escalation of context. Like, &quot;Oh if I can change these postgres configuration parameters, I can cause a problem&quot;, or &quot;Oh if I can change values in this file I can cause huge trouble&quot;. Except, modifying that file or that config parameter requires root&#x2F;supervisor access, so there is no escalation because you have full access already anyhow?<p>I probably wouldn&#x27;t have to look at documentation too much to get postgres to load arbitrary code from disk if I have supervisor access to the postgres already. Some COPY into some preload plugin, some COPY &#x2F; ALTER SYSTEM, some query to crash the node, and off we probably go.<p>But yeah, I&#x27;m frustrated that we were forced to route our security@ domain to support to filter out this nonsense. I wouldn&#x27;t be surprised if we miss some actually important issue unless demonstrated like this, but it costs too much time otherwise.</div><br/></div></div></div></div><div id="40844243" class="c"><input type="checkbox" id="c-40844243" checked=""/><div class="controls bullet"><span class="by">leftcenterright</span><span>|</span><a href="#40844191">parent</a><span>|</span><a href="#40844233">prev</a><span>|</span><a href="#40844467">next</a><span>|</span><label class="collapse" for="c-40844243">[-]</label><label class="expand" for="c-40844243">[1 more]</label></div><br/><div class="children"><div class="content">Having been on the reporting side, &quot;an exploitable vulnerability&quot; and &quot;security weakness which could eventually result in an exploitable vulnerability&quot; are two very different things. Bounties always get paid for the first category. Reports falling in the second category might even cause reputation&#x2F;signal damage for a lack of proof of concept&#x2F;exploitability.<p>There are almost always various weaknesses which do not become exploitable until and unless certain conditions are met. This also becomes evident in contests like Pwn2Own where multiple vulnerabilities are often chained to eventually take the device over and remain un-patched for years. Researchers often sit on such weaknesses for a long time to eventually maximize the impact.<p>Sad but that is how it is.</div><br/></div></div><div id="40844467" class="c"><input type="checkbox" id="c-40844467" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#40844191">parent</a><span>|</span><a href="#40844243">prev</a><span>|</span><a href="#40844351">next</a><span>|</span><label class="collapse" for="c-40844467">[-]</label><label class="expand" for="c-40844467">[8 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Maybe at the moment there are just too many little issues, that you need a full end-to-end hack to really convince people to take you seriously, or pay out bounties?</i><p>Let me give you a different perspective.<p>Imagine I make a serialisation&#x2F;deserialisation library which would be vulnerable <i>if</i> you fed it untrusted data. This is by design, users can serialise and deserialise anything, including lambda functions. My library is only intended for processing data from trusted sources.<p>To my knowledge, nobody uses my library to process data from untrusted sources. One popular library does use mine to load configuration files, they consider those a trusted data source. And it&#x27;s not my job to police other people&#x27;s use of my library anyway.<p>Is it correct to file a CVE of the highest priority against my project, saying my code has a Remote Code Execution vulnerability?</div><br/><div id="40845995" class="c"><input type="checkbox" id="c-40845995" checked=""/><div class="controls bullet"><span class="by">mtrantalainen</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844467">parent</a><span>|</span><a href="#40849970">next</a><span>|</span><label class="collapse" for="c-40845995">[-]</label><label class="expand" for="c-40845995">[1 more]</label></div><br/><div class="children"><div class="content">I think that if the documented interface of your library is &quot;trusted data only&quot;, then one shouldn&#x27;t even file a bug report against your library if somebody passes it untrusted data.<p>However, if you (or anybody else) catch a program passing untrusted data to any library that says &quot;trusted data only&quot;, that&#x27;s definitely CVE worthy in my books even if you cannot demonstrate full attack chain. However, that CVE should be targeted at the program that passes untrusted data to trusted interface.<p>That said, if you&#x27;re looking for bounty instead of just some publicity in reward for publishing the vulnerability, you must fullfil the requirements of the bounty and those typically say that bounty will be paid for complete attack chain only.<p>I guess that&#x27;s because companies paying bounties are typically interested in real world attacks and are not willing to pay bounties for theoretical vulnerabilities.<p>I think this is problematic because it causes bounty hunters to keep theoretical vulnerabilities secret and wait for possible future combination of new code that can be used to attack the currently-theoretical vulnerability.<p>I would argue that it&#x27;s much better to fix issues while they are still theoretical only. Maybe pay lesser bounty for theoretical vulnerabilities and pay reduced payment for the full attack chain if it&#x27;s based on publicly known theoretical vulnerability. Just make sure that the combination pays at least equally good to publishing full attack chain for 0day vulnerability. That way there would be incentive to publish theoretical vulnerabilities immediately for maximum pay because otherwise somebody else might catch the theoretical part and publish faster than you can.</div><br/></div></div><div id="40849970" class="c"><input type="checkbox" id="c-40849970" checked=""/><div class="controls bullet"><span class="by">Elucalidavah</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844467">parent</a><span>|</span><a href="#40845995">prev</a><span>|</span><a href="#40849951">next</a><span>|</span><label class="collapse" for="c-40849970">[-]</label><label class="expand" for="c-40849970">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Imagine I make a serialisation&#x2F;deserialisation library which would be vulnerable if you fed it untrusted data<p>No need to imagine, the PyYAML has that situation. There have been attempts to use the safe deserialization by default, with an attempt to release a new major version (rolled back), and it settled on having a required argument of which mode &#x2F; loader to use. See: <a href="https:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvekey.cgi?keyword=PyYAML" rel="nofollow">https:&#x2F;&#x2F;cve.mitre.org&#x2F;cgi-bin&#x2F;cvekey.cgi?keyword=PyYAML</a></div><br/></div></div><div id="40849951" class="c"><input type="checkbox" id="c-40849951" checked=""/><div class="controls bullet"><span class="by">brazzy</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40844467">parent</a><span>|</span><a href="#40849970">prev</a><span>|</span><a href="#40844351">next</a><span>|</span><label class="collapse" for="c-40849951">[-]</label><label class="expand" for="c-40849951">[5 more]</label></div><br/><div class="children"><div class="content">That sounds... familiar. Are you perchance the maintainer of SnakeYAML?<p>Yes, it is correct to file a CVE of the highest priority against your project, because &quot;only intended for processing data from trusted sources&quot; is a frankly ridiculous policy for a serialization&#x2F;deserialization library.<p>If it&#x27;s your toy project that you never expected anyone to use anyway, you don&#x27;t care about CVEs. If you want to be taken seriously, you cannot play pass-the-blame and ignore the fact that your policy turns the entire project into a security footgun.</div><br/><div id="40851732" class="c"><input type="checkbox" id="c-40851732" checked=""/><div class="controls bullet"><span class="by">michaelt</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40849951">parent</a><span>|</span><a href="#40844351">next</a><span>|</span><label class="collapse" for="c-40851732">[-]</label><label class="expand" for="c-40851732">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; &quot;only intended for processing data from trusted sources&quot; is a frankly ridiculous policy for a serialization&#x2F;deserialization library.</i><p>Truly, it&#x27;s a design decision so ridiculous nobody else has made it. Except Python&#x27;s pickle, Java&#x27;s serialization, Ruby&#x27;s Marshal and PHP&#x27;s unserialize of course. But other than that, nobody!</div><br/><div id="40853503" class="c"><input type="checkbox" id="c-40853503" checked=""/><div class="controls bullet"><span class="by">YoumuChan</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40851732">parent</a><span>|</span><a href="#40854188">next</a><span>|</span><label class="collapse" for="c-40853503">[-]</label><label class="expand" for="c-40853503">[2 more]</label></div><br/><div class="children"><div class="content">And Lua&#x27;s bytecode loader, recently discussed here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40830005">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40830005</a></div><br/><div id="40853942" class="c"><input type="checkbox" id="c-40853942" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40853503">parent</a><span>|</span><a href="#40854188">next</a><span>|</span><label class="collapse" for="c-40853942">[-]</label><label class="expand" for="c-40853942">[1 more]</label></div><br/><div class="children"><div class="content">I know &quot;code is data&quot;, but it&#x27;s a couple orders of magnitude more reasonable to have unsafe bytecode than to have unsafe data deserialization.<p>If something is <i>supposed</i> to load arbitrary code, not just data, that needs to be super clear at a glance.  If it comes across as a data library, but allows takeover, you have a problem.  Especially if there isn&#x27;t a similar data-only function&#x2F;library.</div><br/></div></div></div></div><div id="40854188" class="c"><input type="checkbox" id="c-40854188" checked=""/><div class="controls bullet"><span class="by">brazzy</span><span>|</span><a href="#40844191">root</a><span>|</span><a href="#40851732">parent</a><span>|</span><a href="#40853503">prev</a><span>|</span><a href="#40844351">next</a><span>|</span><label class="collapse" for="c-40854188">[-]</label><label class="expand" for="c-40854188">[1 more]</label></div><br/><div class="children"><div class="content">Yes, all of those languages made that bad decision back in the 90s and came to regret it. What&#x27;s ridiculous is refusing to learn from that.</div><br/></div></div></div></div></div></div></div></div><div id="40844351" class="c"><input type="checkbox" id="c-40844351" checked=""/><div class="controls bullet"><span class="by">lenlorijn</span><span>|</span><a href="#40844191">parent</a><span>|</span><a href="#40844467">prev</a><span>|</span><a href="#40847769">next</a><span>|</span><label class="collapse" for="c-40844351">[-]</label><label class="expand" for="c-40844351">[1 more]</label></div><br/><div class="children"><div class="content">As the security maxim goes: POC || GTFO</div><br/></div></div><div id="40847769" class="c"><input type="checkbox" id="c-40847769" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40844191">parent</a><span>|</span><a href="#40844351">prev</a><span>|</span><a href="#40844919">next</a><span>|</span><label class="collapse" for="c-40847769">[-]</label><label class="expand" for="c-40847769">[1 more]</label></div><br/><div class="children"><div class="content">Buyers pay for outcomes. Vendors do pay for individual links in the chain.</div><br/></div></div><div id="40844919" class="c"><input type="checkbox" id="c-40844919" checked=""/><div class="controls bullet"><span class="by">bobmcnamara</span><span>|</span><a href="#40844191">parent</a><span>|</span><a href="#40847769">prev</a><span>|</span><a href="#40843865">next</a><span>|</span><label class="collapse" for="c-40844919">[-]</label><label class="expand" for="c-40844919">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It feels to me like finding a single hole should be sufficient -- one memory corruption, one sandbox escape.<p>It should be.<p>&gt; Maybe at the moment there are just too many little issues...<p>There are so many.</div><br/></div></div></div></div><div id="40843865" class="c"><input type="checkbox" id="c-40843865" checked=""/><div class="controls bullet"><span class="by">djmdjm</span><span>|</span><a href="#40844191">prev</a><span>|</span><a href="#40845729">next</a><span>|</span><label class="collapse" for="c-40843865">[-]</label><label class="expand" for="c-40843865">[6 more]</label></div><br/><div class="children"><div class="content">OpenSSH release notes: <a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;txt&#x2F;release-9.8" rel="nofollow">https:&#x2F;&#x2F;www.openssh.com&#x2F;txt&#x2F;release-9.8</a><p>Minimal patches for those can&#x27;t&#x2F;don&#x27;t want to upgrade: <a href="https:&#x2F;&#x2F;marc.info&#x2F;?l=oss-security&amp;m=171982317624594&amp;w=2" rel="nofollow">https:&#x2F;&#x2F;marc.info&#x2F;?l=oss-security&amp;m=171982317624594&amp;w=2</a></div><br/><div id="40843921" class="c"><input type="checkbox" id="c-40843921" checked=""/><div class="controls bullet"><span class="by">morsch</span><span>|</span><a href="#40843865">parent</a><span>|</span><a href="#40845729">next</a><span>|</span><label class="collapse" for="c-40843921">[-]</label><label class="expand" for="c-40843921">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Exploitation on 64-bit systems is believed to be possible but has not been demonstrated at this time.</div><br/><div id="40844411" class="c"><input type="checkbox" id="c-40844411" checked=""/><div class="controls bullet"><span class="by">aaronmdjones</span><span>|</span><a href="#40843865">root</a><span>|</span><a href="#40843921">parent</a><span>|</span><a href="#40844022">next</a><span>|</span><label class="collapse" for="c-40844411">[-]</label><label class="expand" for="c-40844411">[1 more]</label></div><br/><div class="children"><div class="content">Exploits only ever get better. Today&#x27;s possible is next month&#x27;s done.</div><br/></div></div><div id="40844022" class="c"><input type="checkbox" id="c-40844022" checked=""/><div class="controls bullet"><span class="by">djmdjm</span><span>|</span><a href="#40843865">root</a><span>|</span><a href="#40843921">parent</a><span>|</span><a href="#40844411">prev</a><span>|</span><a href="#40845729">next</a><span>|</span><label class="collapse" for="c-40844022">[-]</label><label class="expand" for="c-40844022">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confident that someone will make a workable exploit against 64-bit systems.</div><br/><div id="40847120" class="c"><input type="checkbox" id="c-40847120" checked=""/><div class="controls bullet"><span class="by">runjake</span><span>|</span><a href="#40843865">root</a><span>|</span><a href="#40844022">parent</a><span>|</span><a href="#40845729">next</a><span>|</span><label class="collapse" for="c-40847120">[-]</label><label class="expand" for="c-40847120">[2 more]</label></div><br/><div class="children"><div class="content">Context here: djmdjm is Daniel Miller, an OpenSSH&#x2F;OpenBSD developer.</div><br/><div id="40850167" class="c"><input type="checkbox" id="c-40850167" checked=""/><div class="controls bullet"><span class="by">l9i</span><span>|</span><a href="#40843865">root</a><span>|</span><a href="#40847120">parent</a><span>|</span><a href="#40845729">next</a><span>|</span><label class="collapse" for="c-40850167">[-]</label><label class="expand" for="c-40850167">[1 more]</label></div><br/><div class="children"><div class="content"><i>Damien</i> Miller</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40845729" class="c"><input type="checkbox" id="c-40845729" checked=""/><div class="controls bullet"><span class="by">acatton</span><span>|</span><a href="#40843865">prev</a><span>|</span><a href="#40844016">next</a><span>|</span><label class="collapse" for="c-40845729">[-]</label><label class="expand" for="c-40845729">[8 more]</label></div><br/><div class="children"><div class="content">Yearly reminder to run your ssh server behind spiped.[1] [2] [3]<p>[1] <a href="https:&#x2F;&#x2F;www.tarsnap.com&#x2F;spiped.html" rel="nofollow">https:&#x2F;&#x2F;www.tarsnap.com&#x2F;spiped.html</a><p>[2] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29483092">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29483092</a><p>[3] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28538750">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28538750</a></div><br/><div id="40846142" class="c"><input type="checkbox" id="c-40846142" checked=""/><div class="controls bullet"><span class="by">gruez</span><span>|</span><a href="#40845729">parent</a><span>|</span><a href="#40848274">next</a><span>|</span><label class="collapse" for="c-40846142">[-]</label><label class="expand" for="c-40846142">[6 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the advantage of this relatively obscure tool compared to something standard like wireguard or stunnel?</div><br/><div id="40847199" class="c"><input type="checkbox" id="c-40847199" checked=""/><div class="controls bullet"><span class="by">acatton</span><span>|</span><a href="#40845729">root</a><span>|</span><a href="#40846142">parent</a><span>|</span><a href="#40848274">next</a><span>|</span><label class="collapse" for="c-40847199">[-]</label><label class="expand" for="c-40847199">[5 more]</label></div><br/><div class="children"><div class="content">* The tool is not obscure, it&#x27;s packaged in most distributions.[1][2][3] It was written and maintained by Colin Percival, aka &quot;the tarnsnap guy&quot; or &quot;the guy who invented scrypt&quot;. He is the security officer for FreeBSD.<p>* spiped can be used transparently by just putting a &quot;ProxyCommand&quot; in your ssh_config. This means you can connect to a server just by using &quot;ssh&quot;, normally. (as opposed to wireguard where you need to always be on your VPN, otherwise connnect to your VPN manually before running ssh)<p>* As opposed to wireguard which runs in the kernel, spiped can easily be set-up to run as a user, and be fully hardened by using the correct systemd .service configuration [4]<p>* The protocol is much more lightweight than TLS (used by stunnel), it&#x27;s just AES, padded to 1024 bytes with a 32 bit checksum. [5]<p>* The private key is much easier to set up than stunnel&#x27;s TLS certificate, &quot;dd if=&#x2F;dev&#x2F;urandom count=4 bs=1k of=key&quot; and you&#x27;re good to go.<p>[1] <a href="https:&#x2F;&#x2F;packages.debian.org&#x2F;bookworm&#x2F;spiped" rel="nofollow">https:&#x2F;&#x2F;packages.debian.org&#x2F;bookworm&#x2F;spiped</a><p>[2] <a href="https:&#x2F;&#x2F;www.freshports.org&#x2F;sysutils&#x2F;spiped&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.freshports.org&#x2F;sysutils&#x2F;spiped&#x2F;</a><p>[3] <a href="https:&#x2F;&#x2F;archlinux.org&#x2F;packages&#x2F;extra&#x2F;x86_64&#x2F;spiped&#x2F;" rel="nofollow">https:&#x2F;&#x2F;archlinux.org&#x2F;packages&#x2F;extra&#x2F;x86_64&#x2F;spiped&#x2F;</a><p>[4] <a href="https:&#x2F;&#x2F;ruderich.org&#x2F;simon&#x2F;notes&#x2F;systemd-service-hardening" rel="nofollow">https:&#x2F;&#x2F;ruderich.org&#x2F;simon&#x2F;notes&#x2F;systemd-service-hardening</a><p>[5] <a href="https:&#x2F;&#x2F;github.com&#x2F;Tarsnap&#x2F;spiped&#x2F;blob&#x2F;master&#x2F;DESIGN.md">https:&#x2F;&#x2F;github.com&#x2F;Tarsnap&#x2F;spiped&#x2F;blob&#x2F;master&#x2F;DESIGN.md</a></div><br/><div id="40847355" class="c"><input type="checkbox" id="c-40847355" checked=""/><div class="controls bullet"><span class="by">SparkyMcUnicorn</span><span>|</span><a href="#40845729">root</a><span>|</span><a href="#40847199">parent</a><span>|</span><a href="#40853006">next</a><span>|</span><label class="collapse" for="c-40847355">[-]</label><label class="expand" for="c-40847355">[1 more]</label></div><br/><div class="children"><div class="content">Wireguard can also run in userspace (e.g. boringtun[0], wireguard-go[1], Tailscale).<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;boringtun">https:&#x2F;&#x2F;github.com&#x2F;cloudflare&#x2F;boringtun</a><p>[1] <a href="https:&#x2F;&#x2F;git.zx2c4.com&#x2F;wireguard-go&#x2F;about&#x2F;" rel="nofollow">https:&#x2F;&#x2F;git.zx2c4.com&#x2F;wireguard-go&#x2F;about&#x2F;</a></div><br/></div></div><div id="40853006" class="c"><input type="checkbox" id="c-40853006" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40845729">root</a><span>|</span><a href="#40847199">parent</a><span>|</span><a href="#40847355">prev</a><span>|</span><a href="#40848992">next</a><span>|</span><label class="collapse" for="c-40853006">[-]</label><label class="expand" for="c-40853006">[1 more]</label></div><br/><div class="children"><div class="content">Correction: I was the security officer for FreeBSD... about a dozen years ago.  I&#x27;m now the release engineering lead.</div><br/></div></div><div id="40848992" class="c"><input type="checkbox" id="c-40848992" checked=""/><div class="controls bullet"><span class="by">sisk</span><span>|</span><a href="#40845729">root</a><span>|</span><a href="#40847199">parent</a><span>|</span><a href="#40853006">prev</a><span>|</span><a href="#40848274">next</a><span>|</span><label class="collapse" for="c-40848992">[-]</label><label class="expand" for="c-40848992">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The private key is much easier to set up than stunnel&#x27;s TLS certificate, &quot;dd if=&#x2F;dev&#x2F;urandom count=4 bs=1k of=key&quot; and you&#x27;re good to go.<p>The spiped documentation recommends a key size with a minimum of 256b of entropy. I&#x27;m curious why you&#x27;ve chosen such a large key size (4096b) here? Is there anything to suggest 256b is no longer sufficient for the general case?</div><br/><div id="40851885" class="c"><input type="checkbox" id="c-40851885" checked=""/><div class="controls bullet"><span class="by">acatton</span><span>|</span><a href="#40845729">root</a><span>|</span><a href="#40848992">parent</a><span>|</span><a href="#40848274">next</a><span>|</span><label class="collapse" for="c-40851885">[-]</label><label class="expand" for="c-40851885">[1 more]</label></div><br/><div class="children"><div class="content">Force of habit. No particular reason, &quot;4kiB feels like a nice number&quot;, cargo culting. Choose one :) .<p>It doesn&#x27;t matter if you have more than 256 bits, as your key file gets hashed with SHA256 at the end[1]. It could be 5GiB it would be the same. So yes, you&#x27;re right to mention that more bits don&#x27;t add more security.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Tarsnap&#x2F;spiped&#x2F;blob&#x2F;2194b2c64de65eed119ab01f06c8adb2233caab8&#x2F;lib&#x2F;proto&#x2F;proto_crypt.c#L114">https:&#x2F;&#x2F;github.com&#x2F;Tarsnap&#x2F;spiped&#x2F;blob&#x2F;2194b2c64de65eed119ab...</a></div><br/></div></div></div></div></div></div></div></div><div id="40848274" class="c"><input type="checkbox" id="c-40848274" checked=""/><div class="controls bullet"><span class="by">betaby</span><span>|</span><a href="#40845729">parent</a><span>|</span><a href="#40846142">prev</a><span>|</span><a href="#40844016">next</a><span>|</span><label class="collapse" for="c-40848274">[-]</label><label class="expand" for="c-40848274">[1 more]</label></div><br/><div class="children"><div class="content">I run sshd behind the HAProxy <a href="https:&#x2F;&#x2F;www.haproxy.com&#x2F;blog&#x2F;route-ssh-connections-with-haproxy" rel="nofollow">https:&#x2F;&#x2F;www.haproxy.com&#x2F;blog&#x2F;route-ssh-connections-with-hapr...</a></div><br/></div></div></div></div><div id="40844016" class="c"><input type="checkbox" id="c-40844016" checked=""/><div class="controls bullet"><span class="by">jesprenj</span><span>|</span><a href="#40845729">prev</a><span>|</span><a href="#40854737">next</a><span>|</span><label class="collapse" for="c-40844016">[-]</label><label class="expand" for="c-40844016">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Finally, if sshd cannot be updated or recompiled, this signal handler
race condition can be fixed by simply setting LoginGraceTime to 0 in the
configuration file. This makes sshd vulnerable to a denial of service
(the exhaustion of all MaxStartups connections), but it makes it safe
from the remote code execution presented in this advisory.</div><br/><div id="40846119" class="c"><input type="checkbox" id="c-40846119" checked=""/><div class="controls bullet"><span class="by">NelsonMinar</span><span>|</span><a href="#40844016">parent</a><span>|</span><a href="#40854737">next</a><span>|</span><label class="collapse" for="c-40846119">[-]</label><label class="expand" for="c-40846119">[1 more]</label></div><br/><div class="children"><div class="content">I had to ask an AI: 0 means &quot;no limit to login&quot;, not 0 seconds, hence the DDOS. I wonder if in practice that&#x27;ll be even worse: the moment someone tries to exploit your daemon it gets filled up after just 100 tries (default config).<p>I&#x27;m hoping for some fix for a server whose ssh I can&#x27;t upgrade for reasons. Thinking fail2ban might be helpful?</div><br/></div></div></div></div><div id="40854737" class="c"><input type="checkbox" id="c-40854737" checked=""/><div class="controls bullet"><span class="by">ransom1538</span><span>|</span><a href="#40844016">prev</a><span>|</span><a href="#40844513">next</a><span>|</span><label class="collapse" for="c-40854737">[-]</label><label class="expand" for="c-40854737">[1 more]</label></div><br/><div class="children"><div class="content">If you are on GCP and don&#x27;t have time to patch, GCP recommends turning off your port 22 for now. <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;compute&#x2F;docs&#x2F;security-bulletins" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;compute&#x2F;docs&#x2F;security-bulletins</a><p>1. Find things that are 0.0.0.0 port 22, example, <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;james-ransom&#x2F;97e1c8596e28b9f759bac79a34dd92ac" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;james-ransom&#x2F;97e1c8596e28b9f759bac79...</a><p>2. Force them to the local network, 
gcloud compute firewall-rules update default-allow-ssh --source-ranges=10.0.0.0&#x2F;8 --project=$i;</div><br/></div></div><div id="40844513" class="c"><input type="checkbox" id="c-40844513" checked=""/><div class="controls bullet"><span class="by">INTPenis</span><span>|</span><a href="#40854737">prev</a><span>|</span><a href="#40845563">next</a><span>|</span><label class="collapse" for="c-40844513">[-]</label><label class="expand" for="c-40844513">[3 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m wrong but it seems like sshd on RHEL-based systems is safe because they never call syslog.<p>They run sshd with the -D option already, logging everything to stdout and stderr, as their systemd already catches this output and sends it to journal for logging.<p>So I don&#x27;t see anywhere they would be calling syslog, unless sshd does it on its own.<p>At most maybe add OPTIONS=-e into &#x2F;etc&#x2F;sysconfig&#x2F;sshd.</div><br/><div id="40854546" class="c"><input type="checkbox" id="c-40854546" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40844513">parent</a><span>|</span><a href="#40849910">next</a><span>|</span><label class="collapse" for="c-40854546">[-]</label><label class="expand" for="c-40854546">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40849138">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40849138</a></div><br/></div></div><div id="40849910" class="c"><input type="checkbox" id="c-40849910" checked=""/><div class="controls bullet"><span class="by">betaby</span><span>|</span><a href="#40844513">parent</a><span>|</span><a href="#40854546">prev</a><span>|</span><a href="#40845563">next</a><span>|</span><label class="collapse" for="c-40849910">[-]</label><label class="expand" for="c-40849910">[1 more]</label></div><br/><div class="children"><div class="content">Same question. Aren&#x27;t all systemd based distros use stdin&#x2F;out&#x2F;err for logging and won&#x27;t call syslog?</div><br/></div></div></div></div><div id="40845563" class="c"><input type="checkbox" id="c-40845563" checked=""/><div class="controls bullet"><span class="by">ttul</span><span>|</span><a href="#40844513">prev</a><span>|</span><a href="#40845878">next</a><span>|</span><label class="collapse" for="c-40845563">[-]</label><label class="expand" for="c-40845563">[5 more]</label></div><br/><div class="children"><div class="content">TLDR: this vulnerability does appear to allow an attacker to potentially gain remote root access on vulnerable Linux systems running OpenSSH, with some important caveats:<p>1. It affects OpenSSH versions 8.5p1 to 9.7p1 on glibc-based Linux systems.<p>2. The exploit is not 100% reliable - it requires winning a race condition.<p>3. On a modern system (Debian 12.5.0 from 2024), the researchers estimate it takes:
   - ~3-4 hours on average to win the race condition
   - ~6-8 hours on average to obtain a remote root shell (due to ASLR)<p>4. It requires certain conditions:
   - The system must be using glibc (not other libc implementations)
   - 100 simultaneous SSH connections must be allowed (MaxStartups setting)
   - LoginGraceTime must be set to a non-zero value (default is 120 seconds)<p>5. The researchers demonstrated working exploits on i386 systems. They believe it&#x27;s likely exploitable on amd64 systems as well, but hadn&#x27;t completed that work yet.<p>6. It&#x27;s been patched in OpenSSH 9.8p1 released in June 2024.</div><br/><div id="40852542" class="c"><input type="checkbox" id="c-40852542" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#40845563">parent</a><span>|</span><a href="#40849714">next</a><span>|</span><label class="collapse" for="c-40852542">[-]</label><label class="expand" for="c-40852542">[1 more]</label></div><br/><div class="children"><div class="content">Why is it that the ASLR only adds 1 bit of randomness (doubling the time it takes to win the attack)?</div><br/></div></div><div id="40849714" class="c"><input type="checkbox" id="c-40849714" checked=""/><div class="controls bullet"><span class="by">jonaslejon</span><span>|</span><a href="#40845563">parent</a><span>|</span><a href="#40852542">prev</a><span>|</span><a href="#40851980">next</a><span>|</span><label class="collapse" for="c-40849714">[-]</label><label class="expand" for="c-40849714">[1 more]</label></div><br/><div class="children"><div class="content">OpenSSH 9.8p1 was released July 1, 2024 according to <a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.8p1" rel="nofollow">https:&#x2F;&#x2F;www.openssh.com&#x2F;releasenotes.html#9.8p1</a></div><br/></div></div><div id="40851980" class="c"><input type="checkbox" id="c-40851980" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#40845563">parent</a><span>|</span><a href="#40849714">prev</a><span>|</span><a href="#40845878">next</a><span>|</span><label class="collapse" for="c-40851980">[-]</label><label class="expand" for="c-40851980">[2 more]</label></div><br/><div class="children"><div class="content">I’m not sure how many Linux users would know if they’re using glibc or another variation. Is there a list?</div><br/><div id="40852516" class="c"><input type="checkbox" id="c-40852516" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#40845563">root</a><span>|</span><a href="#40851980">parent</a><span>|</span><a href="#40845878">next</a><span>|</span><label class="collapse" for="c-40852516">[-]</label><label class="expand" for="c-40852516">[1 more]</label></div><br/><div class="children"><div class="content">If you don&#x27;t know, you&#x27;re likely running glibc. Distros that use musl do so intentionally (alpine, etc.)</div><br/></div></div></div></div></div></div><div id="40845878" class="c"><input type="checkbox" id="c-40845878" checked=""/><div class="controls bullet"><span class="by">nfriedly</span><span>|</span><a href="#40845563">prev</a><span>|</span><a href="#40854622">next</a><span>|</span><label class="collapse" for="c-40845878">[-]</label><label class="expand" for="c-40845878">[1 more]</label></div><br/><div class="children"><div class="content">I stopped exposing SSH to the internet years ago. Now I connect over WireGuard, and then run SSH through that when I need to remotely admin something.</div><br/></div></div><div id="40854622" class="c"><input type="checkbox" id="c-40854622" checked=""/><div class="controls bullet"><span class="by">drsanthosh1997</span><span>|</span><a href="#40845878">prev</a><span>|</span><a href="#40844820">next</a><span>|</span><label class="collapse" for="c-40854622">[-]</label><label class="expand" for="c-40854622">[1 more]</label></div><br/><div class="children"><div class="content">how to install openssh 9.8p1 in ubuntu 22.04.4 LTS</div><br/></div></div><div id="40844820" class="c"><input type="checkbox" id="c-40844820" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40854622">prev</a><span>|</span><a href="#40846123">next</a><span>|</span><label class="collapse" for="c-40844820">[-]</label><label class="expand" for="c-40844820">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Exploitation on non-glibc systems is conceivable but has not been examined.<p>( <a href="https:&#x2F;&#x2F;www.openssh.com&#x2F;txt&#x2F;release-9.8" rel="nofollow">https:&#x2F;&#x2F;www.openssh.com&#x2F;txt&#x2F;release-9.8</a> )<p>Darn - here I was hoping Alpine was properly immune, but it sounds more like &quot;nobody&#x27;s checked if it works on musl&quot; at this point.</div><br/><div id="40846802" class="c"><input type="checkbox" id="c-40846802" checked=""/><div class="controls bullet"><span class="by">_ikke_</span><span>|</span><a href="#40844820">parent</a><span>|</span><a href="#40846123">next</a><span>|</span><label class="collapse" for="c-40846802">[-]</label><label class="expand" for="c-40846802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OpenSSH sshd on musl-based systems is not vulnerable to RCE via CVE-2024-6387 (regreSSHion).<p><a href="https:&#x2F;&#x2F;fosstodon.org&#x2F;@musl&#x2F;112711796005712271" rel="nofollow">https:&#x2F;&#x2F;fosstodon.org&#x2F;@musl&#x2F;112711796005712271</a></div><br/></div></div></div></div><div id="40846123" class="c"><input type="checkbox" id="c-40846123" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#40844820">prev</a><span>|</span><a href="#40845734">next</a><span>|</span><label class="collapse" for="c-40846123">[-]</label><label class="expand" for="c-40846123">[2 more]</label></div><br/><div class="children"><div class="content">As someone who does unspeakable, but safe, things in signal handlers, I can confirm that it is easy to stray off the path of async-signal-safety.</div><br/><div id="40846487" class="c"><input type="checkbox" id="c-40846487" checked=""/><div class="controls bullet"><span class="by">guerby</span><span>|</span><a href="#40846123">parent</a><span>|</span><a href="#40845734">next</a><span>|</span><label class="collapse" for="c-40846487">[-]</label><label class="expand" for="c-40846487">[1 more]</label></div><br/><div class="children"><div class="content">I agree and I&#x27;m surprised OpenSSH developpers did not remove the use of SIGALRM and replace it by select&#x2F;poll timer and explicitly managed future event list. Likely more portable and safe by default from this class of bugs that has bitten ssh code more than one time now...<p>Defensive programming tells us to minize code in signal handlers and the safest is to avoid using the signal at all when possible :).</div><br/></div></div></div></div><div id="40845734" class="c"><input type="checkbox" id="c-40845734" checked=""/><div class="controls bullet"><span class="by">poikroequ</span><span>|</span><a href="#40846123">prev</a><span>|</span><a href="#40844556">next</a><span>|</span><label class="collapse" for="c-40845734">[-]</label><label class="expand" for="c-40845734">[9 more]</label></div><br/><div class="children"><div class="content">After the xz backdoor a few months ago, I decided to turn off SSH everywhere I don&#x27;t need it, either by disabling it or uninstalling it entirely. While SSH is quite secure, it&#x27;s too lucrative a target, so it will always pose a risk.</div><br/><div id="40845843" class="c"><input type="checkbox" id="c-40845843" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40845734">parent</a><span>|</span><a href="#40845778">next</a><span>|</span><label class="collapse" for="c-40845843">[-]</label><label class="expand" for="c-40845843">[2 more]</label></div><br/><div class="children"><div class="content">So .. how do you handle remote logins?</div><br/><div id="40846828" class="c"><input type="checkbox" id="c-40846828" checked=""/><div class="controls bullet"><span class="by">daneel_w</span><span>|</span><a href="#40845734">root</a><span>|</span><a href="#40845843">parent</a><span>|</span><a href="#40845778">next</a><span>|</span><label class="collapse" for="c-40846828">[-]</label><label class="expand" for="c-40846828">[1 more]</label></div><br/><div class="children"><div class="content">&quot;everywhere I don&#x27;t need it&quot; likely implies computers he or she only accesses directly on the console.</div><br/></div></div></div></div><div id="40845778" class="c"><input type="checkbox" id="c-40845778" checked=""/><div class="controls bullet"><span class="by">lupusreal</span><span>|</span><a href="#40845734">parent</a><span>|</span><a href="#40845843">prev</a><span>|</span><a href="#40845944">next</a><span>|</span><label class="collapse" for="c-40845778">[-]</label><label class="expand" for="c-40845778">[3 more]</label></div><br/><div class="children"><div class="content">I now only bind services to wireguard interfaces.  The bet is that a compromise in both the service <i>and</i> wireguard at the same time is unlikely (and I have relatively high confidence in wireguard.)</div><br/><div id="40846299" class="c"><input type="checkbox" id="c-40846299" checked=""/><div class="controls bullet"><span class="by">devsda</span><span>|</span><a href="#40845734">root</a><span>|</span><a href="#40845778">parent</a><span>|</span><a href="#40846358">next</a><span>|</span><label class="collapse" for="c-40846299">[-]</label><label class="expand" for="c-40846299">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m confident in making ssh changes while logged in via ssh.<p>Compared to ssh, wireguard configs feel too easy to mess up and risk getting locked out if its the only way of accessing the device.</div><br/></div></div><div id="40846358" class="c"><input type="checkbox" id="c-40846358" checked=""/><div class="controls bullet"><span class="by">someplaceguy</span><span>|</span><a href="#40845734">root</a><span>|</span><a href="#40845778">parent</a><span>|</span><a href="#40846299">prev</a><span>|</span><a href="#40845944">next</a><span>|</span><label class="collapse" for="c-40846358">[-]</label><label class="expand" for="c-40846358">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The bet is that a compromise in both the service <i>and</i> wireguard at the same time is unlikely<p>An RCE in wireguard would be enough -- no need to compromise both.</div><br/></div></div></div></div><div id="40845944" class="c"><input type="checkbox" id="c-40845944" checked=""/><div class="controls bullet"><span class="by">kraftverk_</span><span>|</span><a href="#40845734">parent</a><span>|</span><a href="#40845778">prev</a><span>|</span><a href="#40844556">next</a><span>|</span><label class="collapse" for="c-40845944">[-]</label><label class="expand" for="c-40845944">[3 more]</label></div><br/><div class="children"><div class="content">What do you use in place of it?</div><br/><div id="40848391" class="c"><input type="checkbox" id="c-40848391" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#40845734">root</a><span>|</span><a href="#40845944">parent</a><span>|</span><a href="#40846841">next</a><span>|</span><label class="collapse" for="c-40848391">[-]</label><label class="expand" for="c-40848391">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.aurga.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.aurga.com&#x2F;</a> ?<p>Because an $80 black box wireless KVM from a foreign country is way more secure! (Just kidding, though it is not internet-accesible by default.)</div><br/></div></div><div id="40846841" class="c"><input type="checkbox" id="c-40846841" checked=""/><div class="controls bullet"><span class="by">daneel_w</span><span>|</span><a href="#40845734">root</a><span>|</span><a href="#40845944">parent</a><span>|</span><a href="#40848391">prev</a><span>|</span><a href="#40844556">next</a><span>|</span><label class="collapse" for="c-40846841">[-]</label><label class="expand" for="c-40846841">[1 more]</label></div><br/><div class="children"><div class="content">A keyboard and a display, aka &quot;the console&quot;. For example when using one&#x27;s laptop or sitting at their stationary PC.</div><br/></div></div></div></div></div></div><div id="40844556" class="c"><input type="checkbox" id="c-40844556" checked=""/><div class="controls bullet"><span class="by">djernie</span><span>|</span><a href="#40845734">prev</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40844556">[-]</label><label class="expand" for="c-40844556">[10 more]</label></div><br/><div class="children"><div class="content">RedHat put an 8.1 score on it: <a href="https:&#x2F;&#x2F;access.redhat.com&#x2F;security&#x2F;cve&#x2F;cve-2024-6387" rel="nofollow">https:&#x2F;&#x2F;access.redhat.com&#x2F;security&#x2F;cve&#x2F;cve-2024-6387</a></div><br/><div id="40844605" class="c"><input type="checkbox" id="c-40844605" checked=""/><div class="controls bullet"><span class="by">zshrc</span><span>|</span><a href="#40844556">parent</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40844605">[-]</label><label class="expand" for="c-40844605">[9 more]</label></div><br/><div class="children"><div class="content">Doesn’t affect RHEL7 or RHEL8.</div><br/><div id="40846525" class="c"><input type="checkbox" id="c-40846525" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40844605">parent</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40846525">[-]</label><label class="expand" for="c-40846525">[8 more]</label></div><br/><div class="children"><div class="content">Or RHEL9.<p><pre><code>  $ rpm -q openssh
  openssh-8.7p1-38.0.1.el9.x86_64</code></pre></div><br/><div id="40848559" class="c"><input type="checkbox" id="c-40848559" checked=""/><div class="controls bullet"><span class="by">indigodaddy</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40846525">parent</a><span>|</span><a href="#40846979">next</a><span>|</span><label class="collapse" for="c-40848559">[-]</label><label class="expand" for="c-40848559">[1 more]</label></div><br/><div class="children"><div class="content">Versions from 4.4p1 up to, but not including, 8.5p1 are not vulnerable.<p>The vulnerability resurfaces in versions from 8.5p1 up to, but not including, 9.8p1<p><a href="https:&#x2F;&#x2F;blog.qualys.com&#x2F;vulnerabilities-threat-research&#x2F;2024&#x2F;07&#x2F;01&#x2F;regresshion-remote-unauthenticated-code-execution-vulnerability-in-openssh-server" rel="nofollow">https:&#x2F;&#x2F;blog.qualys.com&#x2F;vulnerabilities-threat-research&#x2F;2024...</a></div><br/></div></div><div id="40846979" class="c"><input type="checkbox" id="c-40846979" checked=""/><div class="controls bullet"><span class="by">Ianvdl</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40846525">parent</a><span>|</span><a href="#40848559">prev</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40846979">[-]</label><label class="expand" for="c-40846979">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Statement<p>&gt; The flaw affects RHEL9 as the regression was introduced after the OpenSSH version shipped with RHEL8 was published.</div><br/><div id="40847679" class="c"><input type="checkbox" id="c-40847679" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40846979">parent</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40847679">[-]</label><label class="expand" for="c-40847679">[5 more]</label></div><br/><div class="children"><div class="content">However, we see the -D option on the listening parent:<p><pre><code>  $ ps ax | grep sshd | head -1
     1306 ?        Ss     0:01 sshd: &#x2F;usr&#x2F;sbin&#x2F;sshd -D [listener] 0 of 10-100 startups
</code></pre>
As mentioned elsewhere here, is -D sufficient to avoid exploitation, or is -e necessary as well?<p><pre><code>  $ man sshd | sed -n &#x27;&#x2F; -[De]&#x2F;,&#x2F;^$&#x2F;p&#x27;
     -D      When this option is specified, sshd will not
             detach and does not become a daemon.  This
             allows easy monitoring of sshd.

     -e      Write debug logs to standard error instead
             of the system log.
</code></pre>
RHEL9 is also 64-bit only, and we see from the notice:<p>&quot;we have started to work on an amd64 exploit, which is much harder because of the stronger ASLR.&quot;<p>On top of writing the exploit to target 32-bit environments, this also requires a DSA key that implements multiple calls to free().<p>There is a section on &quot;Rocky Linux 9&quot; near the end of the linked advisory where unsuccessful exploit attempts are discussed.</div><br/><div id="40854041" class="c"><input type="checkbox" id="c-40854041" checked=""/><div class="controls bullet"><span class="by">babuskov</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40847679">parent</a><span>|</span><a href="#40849138">next</a><span>|</span><label class="collapse" for="c-40854041">[-]</label><label class="expand" for="c-40854041">[1 more]</label></div><br/><div class="children"><div class="content">Speaking of Rocky 9, they suggest to get the new version from the SIG&#x2F;Security repository:<p><a href="https:&#x2F;&#x2F;rockylinux.org&#x2F;news&#x2F;2024-07-01-rocky-linux-9-cve-2024-6378-regression" rel="nofollow">https:&#x2F;&#x2F;rockylinux.org&#x2F;news&#x2F;2024-07-01-rocky-linux-9-cve-202...</a></div><br/></div></div><div id="40849138" class="c"><input type="checkbox" id="c-40849138" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40847679">parent</a><span>|</span><a href="#40854041">prev</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40849138">[-]</label><label class="expand" for="c-40849138">[3 more]</label></div><br/><div class="children"><div class="content">&gt;As mentioned elsewhere here, is -D sufficient to avoid exploitation, or is -e necessary as well?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;blob&#x2F;V_9_8_P1&#x2F;sshd.c">https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;blob&#x2F;V_9_8_P1&#x2F;ss...</a><p>sshd.c handles no_daemon (-D) and log_stderr (-e) independently. log_stderr is what is given to log_init in log.c that gates the call to syslog functions. There is a special case to set log_stderr to true if debug_flag (-d) is set, but nothing for no_daemon.<p>I can&#x27;t test it right now though so I may be missing something.</div><br/><div id="40854653" class="c"><input type="checkbox" id="c-40854653" checked=""/><div class="controls bullet"><span class="by">INTPenis</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40849138">parent</a><span>|</span><a href="#40850002">next</a><span>|</span><label class="collapse" for="c-40854653">[-]</label><label class="expand" for="c-40854653">[1 more]</label></div><br/><div class="children"><div class="content">So in other words, -De is not a workaround. -Dde might be but it will cause more log output than is wanted.</div><br/></div></div><div id="40850002" class="c"><input type="checkbox" id="c-40850002" checked=""/><div class="controls bullet"><span class="by">chasil</span><span>|</span><a href="#40844556">root</a><span>|</span><a href="#40849138">parent</a><span>|</span><a href="#40854653">prev</a><span>|</span><a href="#40849406">next</a><span>|</span><label class="collapse" for="c-40850002">[-]</label><label class="expand" for="c-40850002">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m on Oracle Linux, and they appear to have already issued a patch for this problem:<p><pre><code>  openssh-8.7p1-38.0.2.el9.x86_64.rpm
  openssh-server-8.7p1-38.0.2.el9.x86_64.rpm
  openssh-clients-8.7p1-38.0.2.el9.x86_64.rpm
</code></pre>
The changelog addresses the CVE directly. It does not appear that adding the -e directive is necessary with this patch.<p><pre><code>  $ rpm -q --changelog openssh-server | head -3
  * Wed Jun 26 2024 Alex Burmashev &lt;alexander.burmashev@oracle.com&gt; - 8.7p1-38.0.2
  - Restore dropped earlier ifdef condition for safe _exit(1) call in sshsigdie() [Orabug: 36783468]
    Resolves CVE-2024-6387</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40849406" class="c"><input type="checkbox" id="c-40849406" checked=""/><div class="controls bullet"><span class="by">sharpshadow</span><span>|</span><a href="#40844556">prev</a><span>|</span><a href="#40853306">next</a><span>|</span><label class="collapse" for="c-40849406">[-]</label><label class="expand" for="c-40849406">[1 more]</label></div><br/><div class="children"><div class="content">How refreshing to read a pure txt on the phone. It displays text better than a dozen websites.</div><br/></div></div><div id="40853306" class="c"><input type="checkbox" id="c-40853306" checked=""/><div class="controls bullet"><span class="by">rrix2</span><span>|</span><a href="#40849406">prev</a><span>|</span><a href="#40844059">next</a><span>|</span><label class="collapse" for="c-40853306">[-]</label><label class="expand" for="c-40853306">[1 more]</label></div><br/><div class="children"><div class="content">So what are the odds we ever see a viable x86_64 exploit?</div><br/></div></div><div id="40844059" class="c"><input type="checkbox" id="c-40844059" checked=""/><div class="controls bullet"><span class="by">letters90</span><span>|</span><a href="#40853306">prev</a><span>|</span><a href="#40848915">next</a><span>|</span><label class="collapse" for="c-40844059">[-]</label><label class="expand" for="c-40844059">[31 more]</label></div><br/><div class="children"><div class="content">&gt;   In our experiments, it takes ~10,000 tries on average to win this race
  condition, so ~3-4 hours with 100 connections (MaxStartups) accepted
  per 120 seconds (LoginGraceTime). Ultimately, it takes ~6-8 hours on
  average to obtain a remote root shell, because we can only guess the
  glibc&#x27;s address correctly half of the time (because of ASLR).<p>Mitigate by using fail2ban?<p>Nice to see that Ubuntu isn&#x27;t affected at all</div><br/><div id="40844334" class="c"><input type="checkbox" id="c-40844334" checked=""/><div class="controls bullet"><span class="by">mmsc</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40844216">next</a><span>|</span><label class="collapse" for="c-40844334">[-]</label><label class="expand" for="c-40844334">[15 more]</label></div><br/><div class="children"><div class="content">&gt;Mitigate by using fail2ban?<p>In theory, this could be used (much quicker than the mentioned days&#x2F;weeks) to get local privilege escalation to root, if you already have some type of shell on the system already. I would assume that fail2ban doesn&#x27;t block localhost.</div><br/><div id="40844669" class="c"><input type="checkbox" id="c-40844669" checked=""/><div class="controls bullet"><span class="by">udev4096</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844334">parent</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40844669">[-]</label><label class="expand" for="c-40844669">[13 more]</label></div><br/><div class="children"><div class="content">How is local privilege escalation relevant here? Fail2ban should be able to block the RCE</div><br/><div id="40844915" class="c"><input type="checkbox" id="c-40844915" checked=""/><div class="controls bullet"><span class="by">mmsc</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844669">parent</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40844915">[-]</label><label class="expand" for="c-40844915">[12 more]</label></div><br/><div class="children"><div class="content">How is it not?<p>If fail2ban isn&#x27;t going to blocklist localhost, then it isn&#x27;t a mitigation for this vulnerability because RCE implies LPE.</div><br/><div id="40845340" class="c"><input type="checkbox" id="c-40845340" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844915">parent</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40845340">[-]</label><label class="expand" for="c-40845340">[11 more]</label></div><br/><div class="children"><div class="content">People are generally not trying to get root via an SSH RCE over localhost. That&#x27;s going to be a pretty small sample of people that applies to.<p>But, sure, in that case fail2ban won&#x27;t mitigate, but that&#x27;s pretty damn obviously implied. For 99% of people and situations, it will.</div><br/><div id="40845677" class="c"><input type="checkbox" id="c-40845677" checked=""/><div class="controls bullet"><span class="by">mmsc</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40845340">parent</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40845677">[-]</label><label class="expand" for="c-40845677">[10 more]</label></div><br/><div class="children"><div class="content">&gt;People are generally not trying to get root via an SSH RCE over localhost. That&#x27;s going to be a pretty small sample of people that applies to<p>It&#x27;s going to apply to the amount of servers that an attacker has low-privileged access (think: www-data) and an unpatched sshd. Attackers don&#x27;t care if it&#x27;s an RCE or not: if a public sshd exploit can be used on a system with a Linux version without a public Linux LPE, it will be used. Being local also greatly increases the exploitability.<p>Then consider the networks where port 22 is blocked from the internet but sshd is running in some internal network (or just locally for some reason).</div><br/><div id="40845920" class="c"><input type="checkbox" id="c-40845920" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40845677">parent</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40845920">[-]</label><label class="expand" for="c-40845920">[9 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s going to apply to the amount of servers that an attacker has low-privileged access (think: www-data) and an unpatched sshd.<p>Right, which is almost none. www-data should be set to noshell 99% of the time.<p>&gt; or just locally for some reason).<p>This is all that would be relevant, and this is also very rare.</div><br/><div id="40846134" class="c"><input type="checkbox" id="c-40846134" checked=""/><div class="controls bullet"><span class="by">infotogivenm</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40845920">parent</a><span>|</span><a href="#40847233">next</a><span>|</span><label class="collapse" for="c-40846134">[-]</label><label class="expand" for="c-40846134">[6 more]</label></div><br/><div class="children"><div class="content">Think “illegitimate” access to www-data. It’s very common on linux pentests to need to privesc from some lower-privileged foothold (like a command injection in an httpd cgi script). Most linux servers run openssh. So yes I would expect this turns out to be a useful privesc in practice.</div><br/><div id="40846227" class="c"><input type="checkbox" id="c-40846227" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40846134">parent</a><span>|</span><a href="#40847233">next</a><span>|</span><label class="collapse" for="c-40846227">[-]</label><label class="expand" for="c-40846227">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Think “illegitimate” access to www-data.<p>I get the point.<p>My point was the example being given is less than 1% of affected cases.<p>&gt; It’s very common on linux pentests to need to privesc from some lower-privileged foothold<p>Sure. Been doing pentests for 20+ years :)<p>&gt; So yes I would expect this turns out to be a useful privesc in practice.<p>Nah.</div><br/><div id="40846289" class="c"><input type="checkbox" id="c-40846289" checked=""/><div class="controls bullet"><span class="by">infotogivenm</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40846227">parent</a><span>|</span><a href="#40847233">next</a><span>|</span><label class="collapse" for="c-40846289">[-]</label><label class="expand" for="c-40846289">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Nah<p>I don’t get it then… Do you never end up having to privesc in your pentests on linux systems? No doubt it depends on customer profile but I would guess personally on at least 25% of engagements in Linux environments I have had to find a local path to root.</div><br/><div id="40847029" class="c"><input type="checkbox" id="c-40847029" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40846289">parent</a><span>|</span><a href="#40847233">next</a><span>|</span><label class="collapse" for="c-40847029">[-]</label><label class="expand" for="c-40847029">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Do you never end up having to privesc in your pentests on linux systems?<p>Of course I do.<p>I&#x27;m not saying privsec isn&#x27;t useful, I&#x27;m saying the cases where you will ssh to localhost to get root are very rare.<p>Maybe you test different environment or something, but on most corporate networks I test the linux machines are dev machines just used for compiling&#x2F;testing and basically have shared passwords, or they&#x27;re servers for webapps or something else where normal users most who have a windows machine won&#x27;t have a shell account.<p>If there&#x27;s a server where I only have a local account and I&#x27;m trying to get root and it&#x27;s running an ssh server vulnerable to this attack, of course I&#x27;d try it. I just don&#x27;t expect to be in that situation any time soon, if ever.</div><br/><div id="40847281" class="c"><input type="checkbox" id="c-40847281" checked=""/><div class="controls bullet"><span class="by">mmsc</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40847029">parent</a><span>|</span><a href="#40847233">next</a><span>|</span><label class="collapse" for="c-40847281">[-]</label><label class="expand" for="c-40847281">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I test the linux machines are dev machines just used for compiling&#x2F;testing and basically have shared passwords, or they&#x27;re servers for webapps or something else where normal users most who have a windows machine won&#x27;t have a shell account.<p>And you don&#x27;t actually pentest the software which those users on the windows machine are using on the Linux systems? So you find a Jenkins server which can be used to execute Groovy scripts to execute arbitrary commands, the firewall doesn&#x27;t allow connections through port 22, and it&#x27;s just a &quot;well, I got access, nothing more to see!&quot;?</div><br/><div id="40847491" class="c"><input type="checkbox" id="c-40847491" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40847281">parent</a><span>|</span><a href="#40847233">next</a><span>|</span><label class="collapse" for="c-40847491">[-]</label><label class="expand" for="c-40847491">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And you don&#x27;t actually pentest the software which those users on the windows machine are using on the Linux systems?<p>You really love your assumptions, huh?<p>&gt; it&#x27;s just a &quot;well, I got access, nothing more to see!&quot;?<p>I said nothing like that, and besides that, if you were not just focused on arguing for the sake of it, you would see MY point was about the infrequency of the situation you were talking about (and even then your original point seemed to be contrarian in nature more than anything).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40847233" class="c"><input type="checkbox" id="c-40847233" checked=""/><div class="controls bullet"><span class="by">mmsc</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40845920">parent</a><span>|</span><a href="#40846134">prev</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40847233">[-]</label><label class="expand" for="c-40847233">[2 more]</label></div><br/><div class="children"><div class="content">&gt;www-data should be set to noshell 99% of the time.<p>Huh? execve(2), of course, lets to execute arbitrary files. No need to spawn a tty at all. <a href="https:&#x2F;&#x2F;swisskyrepo.github.io&#x2F;InternalAllTheThings&#x2F;cheatsheets&#x2F;shell-reverse-cheatsheet&#x2F;" rel="nofollow">https:&#x2F;&#x2F;swisskyrepo.github.io&#x2F;InternalAllTheThings&#x2F;cheatshee...</a><p>&gt;This is all that would be relevant, and this is also very rare.<p>Huh? Exploiting an unpatched vulnerability on a server to get access to a user account is.. very rare? That&#x27;s exactly what lateral movement is about.</div><br/><div id="40847470" class="c"><input type="checkbox" id="c-40847470" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40847233">parent</a><span>|</span><a href="#40845775">next</a><span>|</span><label class="collapse" for="c-40847470">[-]</label><label class="expand" for="c-40847470">[1 more]</label></div><br/><div class="children"><div class="content">Instead of taking the time to reply &#x27;huh&#x27; multiple times, you should make sure you read what you&#x27;re replying to.<p>For example:<p>&gt; Huh? Exploiting an unpatched vulnerability on a server to get access to a user account is.. very rare?<p>The &#x27;this&#x27; I refer to is <i>very clearly not</i> what you&#x27;ve decided to map it to here. The &#x27;this&#x27; I refer to, if you follow the comment chain, refers to a subset of something you said which was relevant to your point - the rest was not.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40845775" class="c"><input type="checkbox" id="c-40845775" checked=""/><div class="controls bullet"><span class="by">sgt</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844334">parent</a><span>|</span><a href="#40844669">prev</a><span>|</span><a href="#40844216">next</a><span>|</span><label class="collapse" for="c-40845775">[-]</label><label class="expand" for="c-40845775">[1 more]</label></div><br/><div class="children"><div class="content">Confirmed - fail2ban doesn&#x27;t block localhost.</div><br/></div></div></div></div><div id="40844216" class="c"><input type="checkbox" id="c-40844216" checked=""/><div class="controls bullet"><span class="by">ulrikrasmussen</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40844334">prev</a><span>|</span><a href="#40845711">next</a><span>|</span><label class="collapse" for="c-40844216">[-]</label><label class="expand" for="c-40844216">[2 more]</label></div><br/><div class="children"><div class="content">Where do you see that Ubuntu isn&#x27;t affected?</div><br/><div id="40845080" class="c"><input type="checkbox" id="c-40845080" checked=""/><div class="controls bullet"><span class="by">rs_rs_rs_rs_rs</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844216">parent</a><span>|</span><a href="#40845711">next</a><span>|</span><label class="collapse" for="c-40845080">[-]</label><label class="expand" for="c-40845080">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Side note: we discovered that Ubuntu 24.04 does not re-randomize the
ASLR of its sshd children (it is randomized only once, at boot time); we
tracked this down to the patch below, which turns off sshd&#x27;s rexec_flag.
This is generally a bad idea, but in the particular case of this signal
handler race condition, it prevents sshd from being exploitable: the
syslog() inside the SIGALRM handler does not call any of the malloc
functions, because it is never the very first call to syslog().<p>No mention on 22.04 yet.</div><br/></div></div></div></div><div id="40845711" class="c"><input type="checkbox" id="c-40845711" checked=""/><div class="controls bullet"><span class="by">skeetmtp</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40844216">prev</a><span>|</span><a href="#40844350">next</a><span>|</span><label class="collapse" for="c-40845711">[-]</label><label class="expand" for="c-40845711">[1 more]</label></div><br/><div class="children"><div class="content">Ubuntu released patches though<p><a href="https:&#x2F;&#x2F;ubuntu.com&#x2F;security&#x2F;notices&#x2F;USN-6859-1" rel="nofollow">https:&#x2F;&#x2F;ubuntu.com&#x2F;security&#x2F;notices&#x2F;USN-6859-1</a></div><br/></div></div><div id="40844350" class="c"><input type="checkbox" id="c-40844350" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40845711">prev</a><span>|</span><a href="#40844261">next</a><span>|</span><label class="collapse" for="c-40844350">[-]</label><label class="expand" for="c-40844350">[1 more]</label></div><br/><div class="children"><div class="content">Ubuntu has pushed an updated openssh.</div><br/></div></div><div id="40844261" class="c"><input type="checkbox" id="c-40844261" checked=""/><div class="controls bullet"><span class="by">djmdjm</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40844350">prev</a><span>|</span><a href="#40844075">next</a><span>|</span><label class="collapse" for="c-40844261">[-]</label><label class="expand" for="c-40844261">[2 more]</label></div><br/><div class="children"><div class="content">Ubuntu isn&#x27;t affected _by this exploit_</div><br/><div id="40845416" class="c"><input type="checkbox" id="c-40845416" checked=""/><div class="controls bullet"><span class="by">jgalt212</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844261">parent</a><span>|</span><a href="#40844075">next</a><span>|</span><label class="collapse" for="c-40845416">[-]</label><label class="expand" for="c-40845416">[1 more]</label></div><br/><div class="children"><div class="content">as opposed to the other exploits not being discussed.</div><br/></div></div></div></div><div id="40844075" class="c"><input type="checkbox" id="c-40844075" checked=""/><div class="controls bullet"><span class="by">simonjgreen</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40844261">prev</a><span>|</span><a href="#40844938">next</a><span>|</span><label class="collapse" for="c-40844075">[-]</label><label class="expand" for="c-40844075">[2 more]</label></div><br/><div class="children"><div class="content">For servers you have control over, as an emergency bandaid, sure. Assumes you are not on an embedded system though like a router.</div><br/><div id="40844096" class="c"><input type="checkbox" id="c-40844096" checked=""/><div class="controls bullet"><span class="by">letters90</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844075">parent</a><span>|</span><a href="#40844938">next</a><span>|</span><label class="collapse" for="c-40844096">[-]</label><label class="expand" for="c-40844096">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t consider embedded, probably the biggest target for this.</div><br/></div></div></div></div><div id="40844938" class="c"><input type="checkbox" id="c-40844938" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#40844059">parent</a><span>|</span><a href="#40844075">prev</a><span>|</span><a href="#40848915">next</a><span>|</span><label class="collapse" for="c-40844938">[-]</label><label class="expand" for="c-40844938">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Ultimately, it takes ~6-8 hours on average to obtain a remote root shell, because we can only guess the glibc&#x27;s address correctly half of the time (because of ASLR).<p>AMD to the rescue - fortunately they decided to leave the take-a-way and prefetch-type-3 vulnerability unpatched, and continue to recommend that the KPTI mitigations be disabled by default due to performance costs. This breaks ASLR on all these systems, so these systems can be exploited in a much shorter time ;)<p>AMD’s handling of these issues is WONTFIX, despite (contrary to their assertion) the latter even providing actual kernel data leakage at a higher rate than meltdown itself…<p>(This one they’ve outright pulled down their security bulletin on) <a href="https:&#x2F;&#x2F;pcper.com&#x2F;2020&#x2F;03&#x2F;amd-comments-on-take-a-way-vulnerability&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pcper.com&#x2F;2020&#x2F;03&#x2F;amd-comments-on-take-a-way-vulnera...</a><p>(This one remains unpatched in the third variant with prefetch+TLB) <a href="https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;resources&#x2F;product-security&#x2F;bulletin&#x2F;amd-sb-1017.html" rel="nofollow">https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;resources&#x2F;product-security&#x2F;bulletin&#x2F;a...</a><p>edit: there is a third now building on the first one with an unpatched vulnerabilities in all zen1&#x2F;zen2 as well… so this one is WONTFIX too it seems, like most of the defects TU Graz has turned up.<p><a href="https:&#x2F;&#x2F;www.tomshardware.com&#x2F;news&#x2F;amd-cachewarp-vulnerability-afflicts-epyc-server-cpus" rel="nofollow">https:&#x2F;&#x2F;www.tomshardware.com&#x2F;news&#x2F;amd-cachewarp-vulnerabilit...</a><p>Seriously I don’t know why the community just tolerates these defenses being known-broken on the most popular brand of CPUs within the enthusiast market, while allowing them to knowingly disable the defense that’s already implemented that would prevent this leakage. Is defense-in-depth not a thing anymore?<p>Nobody in the world would ever tell you to explicitly turn off ASLR on an intel system that is exposed to untrusted attackers… yet that’s exactly the spec AMD continues to recommend and everyone goes along without a peep. It’s literally a kernel option that is already running and tested and hardens you against ASLR leakage.<p>The “it’s only metadata” is so tired. Metadata is more important than regular data, in many cases. We kill people, convict people, control all our security and access control via metadata. Like yeah it’s just your ASLR layouts leaking, what’s the worst that could happen? And I mean real data goes too in several of these exploits too, but that’s not a big deal either… not like those ssh keys are important, right?</div><br/><div id="40846278" class="c"><input type="checkbox" id="c-40846278" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40844938">parent</a><span>|</span><a href="#40848915">next</a><span>|</span><label class="collapse" for="c-40846278">[-]</label><label class="expand" for="c-40846278">[6 more]</label></div><br/><div class="children"><div class="content">What are you talking about ?
My early-2022 ryzen 5625U shows:<p><pre><code>  Vulnerabilities:          
    Gather data sampling:   Not affected
    Itlb multihit:          Not affected
    L1tf:                   Not affected
    Mds:                    Not affected
    Meltdown:               Not affected
    Mmio stale data:        Not affected
    Reg file data sampling: Not affected
    Retbleed:               Not affected
    Spec rstack overflow:   Vulnerable: Safe RET, no microcode
    Spec store bypass:      Mitigation; Speculative Store Bypass disabled via prctl
    Spectre v1:             Mitigation; usercopy&#x2F;swapgs barriers and __user pointer sanitization
    Spectre v2:             Mitigation; Retpolines; IBPB conditional; IBRS_FW; STIBP always-on; RSB filling; PBRSB-eIBRS Not affected; BHI Not affected
    Srbds:                  Not affected
    Tsx async abort:        Not affected
</code></pre>
Only regular stuff</div><br/><div id="40847127" class="c"><input type="checkbox" id="c-40847127" checked=""/><div class="controls bullet"><span class="by">SubzeroCarnage</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40846278">parent</a><span>|</span><a href="#40847182">next</a><span>|</span><label class="collapse" for="c-40847127">[-]</label><label class="expand" for="c-40847127">[3 more]</label></div><br/><div class="children"><div class="content">KPTI won&#x27;t be default enabled on Linux on AMD CPUs is the issue here.<p>Yet it provides valuable separation between kernel and userspace address ranges.<p>iirc the predecessor to KPTI was made before these hw flaws were announced as a general enhancement to ASLR.<p>AMD aside, Spectre V2 isn&#x27;t even default mitigated for userspace across the board, you must specify spectre_v2=on for userspace to be protected.<p><a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;admin-guide&#x2F;kernel-parameters.html" rel="nofollow">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;admin-guide&#x2F;kernel-pa...</a></div><br/><div id="40851362" class="c"><input type="checkbox" id="c-40851362" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40847127">parent</a><span>|</span><a href="#40847182">next</a><span>|</span><label class="collapse" for="c-40851362">[-]</label><label class="expand" for="c-40851362">[2 more]</label></div><br/><div class="children"><div class="content">&gt; KPTI won&#x27;t be default enabled on Linux on AMD CPUs is the issue here.  Yet it provides valuable separation between kernel and userspace address ranges.<p>AMD&#x27;s security bulletin is actually <i>incredibly</i> weaselly and in fact quietly acknowledges KPTI as the reason further mitigation is not necessary, and then goes on to recommend that KPTI remain disabled anyway.<p><a href="https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;resources&#x2F;product-security&#x2F;bulletin&#x2F;amd-sb-1017.html" rel="nofollow">https:&#x2F;&#x2F;www.amd.com&#x2F;en&#x2F;resources&#x2F;product-security&#x2F;bulletin&#x2F;a...</a><p>&gt; The attacks discussed in the paper do not directly leak data across address space boundaries. As a result, AMD is not recommending any mitigations at this time.<p>That&#x27;s literally the entire bulletin, other than naming the author and recommending you follow security best-practices.  Two sentences, one of which is &quot;no mitigations required at this time&quot;, for an exploit which is described by the author (who is also a named author of the Meltdown paper!) as &quot;worse than Meltdown&quot;, in the most popular brand of server processor.<p>Like it&#x27;s all <i>very</i> carefully worded to avoid acknowledging the CVE in any way, but to also avoid saying anything that&#x27;s <i>technically</i> false.  If you do not enable KPTI then there is no address space boundary, and leakage from the kernel can occur.  And specifically that leakage is page-table layouts - which AMD considers &quot;only metadata&quot; and therefore not important (not real data!).<p>But it is a building block which amplifies all these <i>other</i> attacks, including Specter itself.  Specter was tested in the paper itself and - contrary to AMD&#x27;s statement (one of the actual falsehoods they make despite their weaseling) - does result in actual leakage of kernel data and not just metadata (the author notes that this is a more severe leak than meltdown itself).  And leaking metadata is bad enough by itself - like many kinds of metadata, the page-table layouts are probably more interesting (per byte exfiltrated) than the actual data itself!<p>AMD&#x27;s interest is in shoving it under the rug as quietly as possible - the solution is flushing the caches every time you enter&#x2F;leave kernel space, just like with Meltdown.  That&#x27;s what KPTI is&#x2F;does, you flush caches to isolate the pages.  And AMD has leaned <i>much</i> more heavily on large last-level caches than Intel has, so this hurts correspondingly more.<p>But I don&#x27;t know why the kernel team is playing along with this.  The sibling commenter is right in the sense that this is not something that is being surfaced to users to let them know they are vulnerable, and that the kernel team continues to follow the AMD recommendation of insecure-by-default and letting the issue go quietly under the rug at the expense of their customers&#x27; security.  This undercuts something that the kernel team has put <i>significant</i> engineering effort into mitigating - not as important as AMD cheating on benchmarks with an insecure configuration I guess.<p>There has always been a weird sickly affection for AMD in the enthusiast community, and you can see it every time there&#x27;s an AMD vulnerability. When the AMD vulns really started to flow a couple years ago, there was basically a collective shrug and we just decided to ignore them instead of mitigating.  So much for &quot;these vulnerabilities only exist because [the vendor] decided to cut corners in the name of performance!&quot;.  Like that&#x27;s <i>explicitly</i> the decision AMD has made with their customers&#x27; security.  And everyone&#x27;s fine with it, same weird sickly affection for AMD as ever among the enthusiast community.  This is a billion-dollar company cutting corners on their customers&#x27; security so they can win benchmarks. It&#x27;s bad.  It shouldn&#x27;t need to be said, but it does.<p>I very much feel that - even given that people&#x27;s interest or concern about these exploits is fading over time - that even today (let alone a couple years ago) Intel certainly would not have received the same level of deference if they just said that a huge, performance-sapping patch was &quot;not really necessary&quot; and that everyone should just run their systems in an insecure configuration so that benchmarks weren&#x27;t unduly harmed.  It&#x27;s a weird thing people have where they need to cover <i>all the bases</i> before they will acknowledge the slightest fault or problem or misbehavior with <i>this specific corporation.</i>  Same as the sibling who disputed all this because Linux said he was secure - yeah, the kernel team doesn&#x27;t seem to care about that, but as I demonstrated there is still a visible timing thing even on current BIOS&#x2F;OS combinations.<p>Same damn thing with Ryzenfall too - despite the skulduggery around Monarch, CTS Labs actually did find a very serious vuln (actually 3-4 very serious exploits that let them break out of guest&#x2F;jailbreak PSP and bypass AMD&#x27;s UEFI signing and achieve persistence, and it&#x27;s funny to look back at the people whining that it doesn&#x27;t deserve a 9.0 severity or whatever.  Shockingly, MITRE doesn&#x27;t give those out for no reason, and AMD doesn&#x27;t patch &quot;root access lets you do root things&quot; for no reason either.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QuqefIZrRWc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QuqefIZrRWc</a><p>I get why AMD is doing it.  I don&#x27;t get why the kernel team plays along.  It&#x27;s unintentionally a <i>really good</i> question from the sibling:  <i>why isn&#x27;t</i> the kernel team applying the standards uniformly?  Here&#x27;s A Modest Security Proposal: if we just don&#x27;t care about this class of exploit anymore, and KASLR isn&#x27;t going to be a meaningful part of a defense-in-depth, shouldn&#x27;t it be disabled for <i>everyone</i> at this point?  Is that a good idea?</div><br/><div id="40854307" class="c"><input type="checkbox" id="c-40854307" checked=""/><div class="controls bullet"><span class="by">JackSlateur</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40851362">parent</a><span>|</span><a href="#40847182">next</a><span>|</span><label class="collapse" for="c-40854307">[-]</label><label class="expand" for="c-40854307">[1 more]</label></div><br/><div class="children"><div class="content">But is this not the same thing on intel CPU ? I believe &quot;new&quot; intel CPU are, too, unaffected by meltdown, and so kpti will be disabled there by default.</div><br/></div></div></div></div></div></div><div id="40847182" class="c"><input type="checkbox" id="c-40847182" checked=""/><div class="controls bullet"><span class="by">SubzeroCarnage</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40846278">parent</a><span>|</span><a href="#40847127">prev</a><span>|</span><a href="#40850526">next</a><span>|</span><label class="collapse" for="c-40847182">[-]</label><label class="expand" for="c-40847182">[1 more]</label></div><br/><div class="children"><div class="content">Also if you don&#x27;t have a bios update available for that newer microcode, give my real-ucode package a try: <a href="https:&#x2F;&#x2F;github.com&#x2F;divestedcg&#x2F;real-ucode">https:&#x2F;&#x2F;github.com&#x2F;divestedcg&#x2F;real-ucode</a><p>The linux-firmware repo does not provide AMD microcode updates to consumer platforms unlike Intel.</div><br/></div></div><div id="40850526" class="c"><input type="checkbox" id="c-40850526" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#40844059">root</a><span>|</span><a href="#40846278">parent</a><span>|</span><a href="#40847182">prev</a><span>|</span><a href="#40848915">next</a><span>|</span><label class="collapse" for="c-40850526">[-]</label><label class="expand" for="c-40850526">[1 more]</label></div><br/><div class="children"><div class="content">these are the tests you need to run:  <a href="https:&#x2F;&#x2F;github.com&#x2F;amdprefetch&#x2F;amd-prefetch-attacks&#x2F;blob&#x2F;master&#x2F;case-studies&#x2F;kaslr-break&#x2F;main.c">https:&#x2F;&#x2F;github.com&#x2F;amdprefetch&#x2F;amd-prefetch-attacks&#x2F;blob&#x2F;mas...</a><p>you probably want to do `export WITH_TLB_EVICT=1` before you make, then run .&#x2F;kaslr.  The power stuff is patched (by removing the RAPL power interface) but there is still timing differences visible on my 5700G and the WITH_TLB_EVICT makes this fairly obvious&#x2F;consistent:<p><a href="https:&#x2F;&#x2F;pastebin.com&#x2F;1n0QbHTH" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;1n0QbHTH</a><p>```csv<p>452,0xffffffffb8000000,92,82,220<p>453,0xffffffffb8200000,94,82,835<p>454,0xffffffffb8400000,110,94,487<p>455,0xffffffffb8600000,83,75,114<p>456,0xffffffffb8800000,83,75,131<p>457,0xffffffffb8a00000,109,92,484<p>458,0xffffffffb8c00000,92,82,172<p>459,0xffffffffb8e00000,110,94,499<p>460,0xffffffffb9000000,92,82,155<p>```<p>those timing differences are the presence&#x2F;nonpresence of kernel pages in the TLB, those are the KASLR pages, they’re slower when the TLB eviction happens because of the extra bookkeeping.<p>then we have the stack protector canary on the last couple pages of course:<p>```csv<p>512,0xffffffffbf800000,91,82,155<p>513,0xffffffffbfa00000,92,82,147<p>514,0xffffffffbfc00000,92,82,151<p>515,0xffffffffbfe00000,91,82,137<p>516,0xffffffffc0000000,112,94,598<p>517,0xffffffffc0200000,110,94,544<p>518,0xffffffffc0400000,110,94,260<p>519,0xffffffffc0600000,110,94,638<p>```<p>edit: the 4 pages at the end of the memory space are very consistent between tests and across reboots, and the higher lookup time goes away if you set the kernel boot option &quot;pti=on&quot; manually at startup, that’s the insecure behavior as described in the paper.<p>log with pti=on kernel option:  <a href="https:&#x2F;&#x2F;pastebin.com&#x2F;GK5KfsYd" rel="nofollow">https:&#x2F;&#x2F;pastebin.com&#x2F;GK5KfsYd</a><p>```csv<p>513,0xffffffffbfa00000,92,82,147<p>514,0xffffffffbfc00000,92,82,123<p>515,0xffffffffbfe00000,92,82,141<p>516,0xffffffffc0000000,91,82,134<p>517,0xffffffffc0200000,91,82,140<p>518,0xffffffffc0400000,91,82,151<p>519,0xffffffffc0600000,91,82,141<p>```<p>environment: ubuntu 22.04.4 live-usb, 5700G, b550i aorus pro ax latest bios</div><br/></div></div></div></div></div></div></div></div><div id="40848915" class="c"><input type="checkbox" id="c-40848915" checked=""/><div class="controls bullet"><span class="by">ementally</span><span>|</span><a href="#40844059">prev</a><span>|</span><a href="#40853535">next</a><span>|</span><label class="collapse" for="c-40848915">[-]</label><label class="expand" for="c-40848915">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dustri.org&#x2F;b&#x2F;notes-on-regresshion-on-musl.html" rel="nofollow">https:&#x2F;&#x2F;dustri.org&#x2F;b&#x2F;notes-on-regresshion-on-musl.html</a></div><br/></div></div><div id="40853535" class="c"><input type="checkbox" id="c-40853535" checked=""/><div class="controls bullet"><span class="by">Sparkyte</span><span>|</span><a href="#40848915">prev</a><span>|</span><a href="#40844703">next</a><span>|</span><label class="collapse" for="c-40853535">[-]</label><label class="expand" for="c-40853535">[1 more]</label></div><br/><div class="children"><div class="content">People still use SSH these days?<p>I kid, but really you probably shouldn&#x27;t on Production. You should be exporting your logs and everything else. The host or VM bootstrapped golden images with everything as needed.<p>It is okay to start that way and figure out your enternals but that isn&#x27;t for Production. Production is a locked down closed environment.<p>Recomment from another Hacker News post.</div><br/></div></div><div id="40844703" class="c"><input type="checkbox" id="c-40844703" checked=""/><div class="controls bullet"><span class="by">marcus0x62</span><span>|</span><a href="#40853535">prev</a><span>|</span><a href="#40848140">next</a><span>|</span><label class="collapse" for="c-40844703">[-]</label><label class="expand" for="c-40844703">[2 more]</label></div><br/><div class="children"><div class="content">Patch out for Arch Linux<p><a href="https:&#x2F;&#x2F;archlinux.org&#x2F;packages&#x2F;core&#x2F;x86_64&#x2F;openssh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;archlinux.org&#x2F;packages&#x2F;core&#x2F;x86_64&#x2F;openssh&#x2F;</a><p><i>edit</i> be sure to manually restart sshd after upgrading; my systems fail during key exchange after package upgrade until restarting the sshd service:<p>% ssh -v 192.168.1.254<p>OpenSSH_9.8p1, OpenSSL 3.3.1 4 Jun 2024<p>... output elided ...<p>debug1: Local version string SSH-2.0-OpenSSH_9.8<p>kex_exchange_identification: read: Connection reset by peer<p>Connection reset by 192.168.1.254 port 22</div><br/><div id="40845500" class="c"><input type="checkbox" id="c-40845500" checked=""/><div class="controls bullet"><span class="by">jiripospisil</span><span>|</span><a href="#40844703">parent</a><span>|</span><a href="#40848140">next</a><span>|</span><label class="collapse" for="c-40845500">[-]</label><label class="expand" for="c-40845500">[1 more]</label></div><br/><div class="children"><div class="content">Same here. It&#x27;s caused by the sshd daemon being split into multiple binaries. In fact, the commit which introduced the change mentions this explicitly:<p>&gt; NB. if you&#x27;re updating via source, please restart sshd after installing, otherwise you run the risk of locking yourself out.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;03e3de416ed7c34faeb692967737be4a7bbe2eb5">https:&#x2F;&#x2F;github.com&#x2F;openssh&#x2F;openssh-portable&#x2F;commit&#x2F;03e3de416...</a><p>Edit: Already reported at <a href="https:&#x2F;&#x2F;gitlab.archlinux.org&#x2F;archlinux&#x2F;packaging&#x2F;packages&#x2F;openssh&#x2F;-&#x2F;issues&#x2F;5" rel="nofollow">https:&#x2F;&#x2F;gitlab.archlinux.org&#x2F;archlinux&#x2F;packaging&#x2F;packages&#x2F;op...</a></div><br/></div></div></div></div><div id="40848140" class="c"><input type="checkbox" id="c-40848140" checked=""/><div class="controls bullet"><span class="by">betaby</span><span>|</span><a href="#40844703">prev</a><span>|</span><a href="#40850025">next</a><span>|</span><label class="collapse" for="c-40848140">[-]</label><label class="expand" for="c-40848140">[2 more]</label></div><br/><div class="children"><div class="content">In some setups I decided to have jumphost via HAproxy ssl as described there <a href="https:&#x2F;&#x2F;www.haproxy.com&#x2F;blog&#x2F;route-ssh-connections-with-haproxy" rel="nofollow">https:&#x2F;&#x2F;www.haproxy.com&#x2F;blog&#x2F;route-ssh-connections-with-hapr...</a> so no ssh directly exposed at all.</div><br/><div id="40849945" class="c"><input type="checkbox" id="c-40849945" checked=""/><div class="controls bullet"><span class="by">aflukasz</span><span>|</span><a href="#40848140">parent</a><span>|</span><a href="#40850025">next</a><span>|</span><label class="collapse" for="c-40849945">[-]</label><label class="expand" for="c-40849945">[1 more]</label></div><br/><div class="children"><div class="content">So this is effectively like ProxyJump, just with the jump node exposed over SSL and backed by HAProxy binary instead of OpenSSH?<p>What benefits do you see? I mean, you still expose some binary that implements authentication and authorization using cryptography.<p>I think that even RBAC scenarios described in the link above should be achievable with OpenSSH, right?</div><br/></div></div></div></div><div id="40850025" class="c"><input type="checkbox" id="c-40850025" checked=""/><div class="controls bullet"><span class="by">thenickdude</span><span>|</span><a href="#40848140">prev</a><span>|</span><a href="#40843918">next</a><span>|</span><label class="collapse" for="c-40850025">[-]</label><label class="expand" for="c-40850025">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a purported PoC exploit that delivers shellcode available on GitHub, but I saw someone comment the link here, and then their comment disappeared on the next refresh.</div><br/></div></div><div id="40843918" class="c"><input type="checkbox" id="c-40843918" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40850025">prev</a><span>|</span><label class="collapse" for="c-40843918">[-]</label><label class="expand" for="c-40843918">[5 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t seen an increase of ssh traffic yet, but the alert only went out a couple hours ago...  hopefully distros will ship the patches quickly.</div><br/><div id="40843961" class="c"><input type="checkbox" id="c-40843961" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40843918">parent</a><span>|</span><a href="#40843950">next</a><span>|</span><label class="collapse" for="c-40843961">[-]</label><label class="expand" for="c-40843961">[3 more]</label></div><br/><div class="children"><div class="content">This is the sort of bug which pre-announcement coordination is designed for.  Anyone who doesn&#x27;t have patches ready was either forgotten (I&#x27;ve seen a few instances of &quot;I thought <i>you</i> were going to tell them!&quot;) or isn&#x27;t on the ball.</div><br/><div id="40844113" class="c"><input type="checkbox" id="c-40844113" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40843918">root</a><span>|</span><a href="#40843961">parent</a><span>|</span><a href="#40843950">next</a><span>|</span><label class="collapse" for="c-40844113">[-]</label><label class="expand" for="c-40844113">[2 more]</label></div><br/><div class="children"><div class="content">Gentoo announced it at the same time as qualys, but they&#x27;re currently trying to backport and bump users to a patched version. <a href="https:&#x2F;&#x2F;bugs.gentoo.org&#x2F;935271" rel="nofollow">https:&#x2F;&#x2F;bugs.gentoo.org&#x2F;935271</a></div><br/><div id="40844502" class="c"><input type="checkbox" id="c-40844502" checked=""/><div class="controls bullet"><span class="by">nubinetwork</span><span>|</span><a href="#40843918">root</a><span>|</span><a href="#40844113">parent</a><span>|</span><a href="#40843950">next</a><span>|</span><label class="collapse" for="c-40844502">[-]</label><label class="expand" for="c-40844502">[1 more]</label></div><br/><div class="children"><div class="content">Gentoo has pushed the patched version now.</div><br/></div></div></div></div></div></div><div id="40843950" class="c"><input type="checkbox" id="c-40843950" checked=""/><div class="controls bullet"><span class="by">booi</span><span>|</span><a href="#40843918">parent</a><span>|</span><a href="#40843961">prev</a><span>|</span><label class="collapse" for="c-40843950">[-]</label><label class="expand" for="c-40843950">[1 more]</label></div><br/><div class="children"><div class="content">i would assume all the distros have patches ready to go awaiting the embargo lift.</div><br/></div></div></div></div></div></div></div></div></div></body></html>