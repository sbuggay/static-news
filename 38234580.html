<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699779654698" as="style"/><link rel="stylesheet" href="styles.css?v=1699779654698"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pthorpe92.github.io/ocaml/ocaml-first-thoughts/">OCaml: a Rust developer&#x27;s first impressions</a> <span class="domain">(<a href="https://pthorpe92.github.io">pthorpe92.github.io</a>)</span></div><div class="subtext"><span>qsantos</span> | <span>94 comments</span></div><br/><div><div id="38238338" class="c"><input type="checkbox" id="c-38238338" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#38237788">next</a><span>|</span><label class="collapse" for="c-38238338">[-]</label><label class="expand" for="c-38238338">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Where are the types?<p>OCaml supports type annotations practically anywhere, if you want to add them. Alternatively, you can use an editor that supports querying or showing types for bindings. VSCode and Emacs support this.<p>&gt; Remember recursion? How about linked lists?<p>A lot of beginner material uses List to introduce algebraic data types, inductive and equational reasoning - but you don&#x27;t have to use them. In fact, the standard library encourages Seq instead over List.<p>It&#x27;s a shame the author did not get past the basics, as there are many interesting comparisons to be made. For example, OCaml 5 effect handlers are a very interesting alternative to Rust&#x27;s Async.</div><br/><div id="38238495" class="c"><input type="checkbox" id="c-38238495" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38238338">parent</a><span>|</span><a href="#38237788">next</a><span>|</span><label class="collapse" for="c-38238495">[-]</label><label class="expand" for="c-38238495">[1 more]</label></div><br/><div class="children"><div class="content">Right but in practice most OCaml code does not have explicit types.<p>Using an editor that shows type inlays (e.g. VSCode) helps a lot but not fully because a lot of types are inferred as generics.<p>You&#x27;re also correct that you don&#x27;t <i>have</i> to use lists, but again most OCaml code <i>does</i>.</div><br/></div></div></div></div><div id="38237788" class="c"><input type="checkbox" id="c-38237788" checked=""/><div class="controls bullet"><span class="by">sintheta</span><span>|</span><a href="#38238338">prev</a><span>|</span><a href="#38238105">next</a><span>|</span><label class="collapse" for="c-38237788">[-]</label><label class="expand" for="c-38237788">[11 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t comment on the comparison to Rust, but I recently spent quite some time learning OCaml, working through the excellent and freely available cs3110 course <a href="https:&#x2F;&#x2F;cs3110.github.io&#x2F;textbook&#x2F;cover.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;cs3110.github.io&#x2F;textbook&#x2F;cover.html</a> ; I really really wanted to like the language... I agree w&#x2F; the submitted article about the heavy reliance on linked lists and recursion, but what disillusioned me from it is that after many weeks of study I discovered competitive programming and on a whim started doing some easy problems.<p>Since I was spending most of my time w&#x2F; OCaml at that point I thought it could also be a way to practice it further. So for a particularly easy problem it would go something like this: A straight forward, easy to read, performant C++ solution took me 10 minutes; an ugly unidiomatic OCaml version took me 30 minutes; and a beautiful idiomatic OCaml version using recursion that still no non-OCaml programmer could ever read took me something like an hour...<p>It really dawned on me that after weeks of studying OCaml I barely knew how to write anything particularly useful in it from scratch. Dealing with user input&#x2F;output still seemed cumbersome, given everything&#x27;s immutability... from an intellectual perspective it feels interesting, and I had fun with it, but for now I decided I couldn&#x27;t see myself becoming productive enough in it to justify further sinking time into it. There&#x27;s so much to still learn for me (doing a network related project at the moment learning a ton about networking, sockets, etc), that trying to become an unproductive OCaml programmer probably shouldn&#x27;t be high up my list of priorities... and that is not to say people aren&#x27;t productive in it, that&#x27;s to say that I don&#x27;t see myself becoming productive in it any time soon, compared to being productive in C++ while being far away from being any expert in it.<p>Maybe I&#x27;m too stupid for it, am not suited for it, need a few years of further programming to appreciate some things about it... but for now, sadly, I feel like I&#x27;ve wasted significant time I should have better spent on studying other topics and actually working on projects. And addendum: Never comment on downvotes, I know, but how I immediately got one for this comment... surprising.</div><br/><div id="38238259" class="c"><input type="checkbox" id="c-38238259" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38237788">parent</a><span>|</span><a href="#38238168">next</a><span>|</span><label class="collapse" for="c-38238259">[-]</label><label class="expand" for="c-38238259">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Dealing with user input&#x2F;output still seemed cumbersome, given everything&#x27;s immutability...<p>This sentence baffled mé, why would immutability be a problém with user input or output?<p>But changing the way how you solve problems takes time.</div><br/></div></div><div id="38238168" class="c"><input type="checkbox" id="c-38238168" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#38237788">parent</a><span>|</span><a href="#38238259">prev</a><span>|</span><a href="#38237990">next</a><span>|</span><label class="collapse" for="c-38238168">[-]</label><label class="expand" for="c-38238168">[7 more]</label></div><br/><div class="children"><div class="content">After a few weeks, I am disappointed in not being an expert at $new_thing. $new_thing bad!</div><br/><div id="38238219" class="c"><input type="checkbox" id="c-38238219" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#38237788">root</a><span>|</span><a href="#38238168">parent</a><span>|</span><a href="#38238236">next</a><span>|</span><label class="collapse" for="c-38238219">[-]</label><label class="expand" for="c-38238219">[1 more]</label></div><br/><div class="children"><div class="content">Downvote it all you want. I&#x27;ve spent the last decade writing in this style and to me it&#x27;s second nature. Starting Rust I&#x27;ve had to basically relearn solving problems with loops and iterators. Solving problems with loops is not the way I think.<p>Never once thought negatively of Rust for this.</div><br/></div></div><div id="38238236" class="c"><input type="checkbox" id="c-38238236" checked=""/><div class="controls bullet"><span class="by">serial_dev</span><span>|</span><a href="#38237788">root</a><span>|</span><a href="#38238168">parent</a><span>|</span><a href="#38238219">prev</a><span>|</span><a href="#38237990">next</a><span>|</span><label class="collapse" for="c-38238236">[-]</label><label class="expand" for="c-38238236">[5 more]</label></div><br/><div class="children"><div class="content">After a few weeks (and I believe it was written many weeks, so to me, that sounds like a couple of months), it&#x27;s not unreasonable for experienced programmer with already a couple of languages in their toolbelt to expect to get _some_ things done in a new programming language.</div><br/><div id="38238570" class="c"><input type="checkbox" id="c-38238570" checked=""/><div class="controls bullet"><span class="by">imadj</span><span>|</span><a href="#38237788">root</a><span>|</span><a href="#38238236">parent</a><span>|</span><a href="#38238441">next</a><span>|</span><label class="collapse" for="c-38238570">[-]</label><label class="expand" for="c-38238570">[1 more]</label></div><br/><div class="children"><div class="content">&quot;An NFL player found that he managed to be good at rugby after 2 months of practice, but when he tried to do gymnastics (or cycling or tennis or motorsports or ...) in the same time frame, the results were terrible.&quot;<p>What does that tell you the sports he tried to do? Not much. It&#x27;s all about his previous experience and skills.</div><br/></div></div><div id="38238441" class="c"><input type="checkbox" id="c-38238441" checked=""/><div class="controls bullet"><span class="by">txs</span><span>|</span><a href="#38237788">root</a><span>|</span><a href="#38238236">parent</a><span>|</span><a href="#38238570">prev</a><span>|</span><a href="#38238271">next</a><span>|</span><label class="collapse" for="c-38238441">[-]</label><label class="expand" for="c-38238441">[1 more]</label></div><br/><div class="children"><div class="content">Many of today&#x27;s popular programming languages are variations on the same theme, leading people to think that their experience is broader than it actually is.</div><br/></div></div><div id="38238271" class="c"><input type="checkbox" id="c-38238271" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38237788">root</a><span>|</span><a href="#38238236">parent</a><span>|</span><a href="#38238441">prev</a><span>|</span><a href="#38238439">next</a><span>|</span><label class="collapse" for="c-38238271">[-]</label><label class="expand" for="c-38238271">[1 more]</label></div><br/><div class="children"><div class="content">But it isn&#x27;t (just) a new programming language, it&#x27;s a different way of solving problems.</div><br/></div></div><div id="38238439" class="c"><input type="checkbox" id="c-38238439" checked=""/><div class="controls bullet"><span class="by">Lewton</span><span>|</span><a href="#38237788">root</a><span>|</span><a href="#38238236">parent</a><span>|</span><a href="#38238271">prev</a><span>|</span><a href="#38237990">next</a><span>|</span><label class="collapse" for="c-38238439">[-]</label><label class="expand" for="c-38238439">[1 more]</label></div><br/><div class="children"><div class="content">After having learned French, German and Spanish, I spent three months learning Chinese and could not speak it fluently, what a shoddy language</div><br/></div></div></div></div></div></div><div id="38237990" class="c"><input type="checkbox" id="c-38237990" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#38237788">parent</a><span>|</span><a href="#38238168">prev</a><span>|</span><a href="#38238024">next</a><span>|</span><label class="collapse" for="c-38237990">[-]</label><label class="expand" for="c-38237990">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not stupid.  Functional programming requires its own way of thinking and it&#x27;s different from procedural languages with mutable-state soup, like C++.  It&#x27;s less that OCaml is hard to learn, and more that you have to leave old habits of thinking and learn new ones.  Don&#x27;t give up just yet.</div><br/></div></div><div id="38238024" class="c"><input type="checkbox" id="c-38238024" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#38237788">parent</a><span>|</span><a href="#38237990">prev</a><span>|</span><a href="#38238105">next</a><span>|</span><label class="collapse" for="c-38238024">[-]</label><label class="expand" for="c-38238024">[1 more]</label></div><br/><div class="children"><div class="content">OCaml is not a very good fit for competitive programming, you&#x27;re better off with a language like Python there.<p>Writing code in a functional language like OCaml requires a mind switch. This can take quite a while. It took me years to really &#x27;get it&#x27; after having programmed for 30 years in imperative languages. Now I prefer writing code in FP for a lot of things, but not for everything. 
E.g. for coding some algorithms you have a much easier time when you can use mutable arrays.<p>A nice advantage of OCaml is, IMO, that it is not so strict about pure FP. E.g. unlike in Haskell, arrays are mutable by default.</div><br/></div></div></div></div><div id="38238105" class="c"><input type="checkbox" id="c-38238105" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#38237788">prev</a><span>|</span><a href="#38235833">next</a><span>|</span><label class="collapse" for="c-38238105">[-]</label><label class="expand" for="c-38238105">[1 more]</label></div><br/><div class="children"><div class="content">&gt; heavy use of chained iterator methods in favor over traditional loops. This is one of the more intimidating hurdles for newcomers to [Rust], but after getting used to it, rarely will you see anyone write a for loop again.<p>I think this varies a lot from person to person. Rust includes syntactic sugar for imperative code (like `if let` and `let else`), and personally I prefer to use that when it&#x27;s not too much trouble. I find it&#x27;s pretty rare that I reach for map&#x2F;and_then&#x2F;etc.</div><br/></div></div><div id="38235833" class="c"><input type="checkbox" id="c-38235833" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38238105">prev</a><span>|</span><a href="#38238201">next</a><span>|</span><label class="collapse" for="c-38235833">[-]</label><label class="expand" for="c-38235833">[56 more]</label></div><br/><div class="children"><div class="content">OCaml is great, we learned it in class back in college, then we learned Rust right afterwards. Oftentimes people say OCaml is Rust without the borrow checker (or that Rust is OCaml with a borrow checker), but that&#x27;s not quite true. Since it is entirely functional and recursive, it takes more time to wrap your head around. Now with OCaml 5, we also have algebraic effect support, something that Rust is looking to add in as well, in a more moderate capacity.<p>Also, if you don&#x27;t like the OCaml syntax, check out ReasonML, which is an alternative OCaml syntax that Facebook developed several years ago. It has the Algol-style that many modern languages today use.</div><br/><div id="38235894" class="c"><input type="checkbox" id="c-38235894" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#38235833">parent</a><span>|</span><a href="#38236699">next</a><span>|</span><label class="collapse" for="c-38235894">[-]</label><label class="expand" for="c-38235894">[26 more]</label></div><br/><div class="children"><div class="content">I think about it the other way; Rust is an ML with a borrow checker. Most of the stuff I hear people gushing about in Rust is IMO them experiencing what&#x27;s it&#x27;s like to write ML.</div><br/><div id="38235919" class="c"><input type="checkbox" id="c-38235919" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235894">parent</a><span>|</span><a href="#38236014">next</a><span>|</span><label class="collapse" for="c-38235919">[-]</label><label class="expand" for="c-38235919">[13 more]</label></div><br/><div class="children"><div class="content">Yes and no, Rust is ML inspired but it is still way too imperative and not as functional to be called a true ML. But yes, things like Result and Option types, do-notion via &quot;?,&quot; at least for Results and Options, algebraic data types are all part of the appeal. There sadly are still no higher kinded types though, but that is a difficult problem to solve and most won&#x27;t encounter such problems anyway in day-to-day coding, so the contributors made generic associated types instead as an alternative.</div><br/><div id="38236135" class="c"><input type="checkbox" id="c-38236135" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235919">parent</a><span>|</span><a href="#38236110">next</a><span>|</span><label class="collapse" for="c-38236135">[-]</label><label class="expand" for="c-38236135">[2 more]</label></div><br/><div class="children"><div class="content">I think the ‘is or is not a true ML’ argument is a bit unwinnable so I won’t comment on it. Regarding ‘functional’, Rust makes it harder to write in a traditional functional style because (a) it doesn’t offer tail-call elimination and (b) the resource-ownership tracking makes most normal functions feel side-effecty. I think it’s pretty hard to have a natural-feeling functional style without cheap allocation and some kind of deferred automatic deallocation (this is carefully phrased to allow for a garbage collector or a kind of arena allocation)<p>I don’t think this is that bad for rust though. For (a), it turns out that tail calls can make debugging harder, and they can be incompatible with certain type system changes you might want in an ML, and lots of OCaml (perhaps not a true ML?) in practice uses little explicit recursion and instead first-class functions with names like map and iter rather than recursion. So I don’t really think it’s very important. Rust also has these first-class iterator functions although a bit less of map for containers that can have many things (e.g. vectors). Rust iterations allow for writing code that is more functional when memory&#x2F;performance are stronger constraints because the pipeline gets composed together instead of producing lots of intermediate objects. For (b) I guess the big difference is that the usual tool in functional programming for manipulating data is creating new copies of immutable data whereas in rust it is controlling ownership and then just updating it (a middle ground may be koka where you write code in the former style but the compiled code inspects recounts to potentially just mutate instead)</div><br/><div id="38236167" class="c"><input type="checkbox" id="c-38236167" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236135">parent</a><span>|</span><a href="#38236110">next</a><span>|</span><label class="collapse" for="c-38236167">[-]</label><label class="expand" for="c-38236167">[1 more]</label></div><br/><div class="children"><div class="content">For sure, I agree with your points, which is why I write Rust these days instead of OCaml. Sometimes you really just want to get stuff done, while also being faster in execution speed of both the machine and the human.</div><br/></div></div></div></div><div id="38236110" class="c"><input type="checkbox" id="c-38236110" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235919">parent</a><span>|</span><a href="#38236135">prev</a><span>|</span><a href="#38235941">next</a><span>|</span><label class="collapse" for="c-38236110">[-]</label><label class="expand" for="c-38236110">[4 more]</label></div><br/><div class="children"><div class="content">True. In this case the author is speaking specifically about OCaml, which is quite comfortable to write imperatively.<p>I think the thing that tickles most people about Rust is the thoroughness of the type inference and type checking, which one generally gets from any ML.</div><br/><div id="38237029" class="c"><input type="checkbox" id="c-38237029" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236110">parent</a><span>|</span><a href="#38235941">next</a><span>|</span><label class="collapse" for="c-38237029">[-]</label><label class="expand" for="c-38237029">[3 more]</label></div><br/><div class="children"><div class="content">Yeah but traditional ML languages are ass slow. If I want to write applications  that are that slow, why not use something that targets the browser or something like Ruby or Python that has a much deeper ecosystem to leverage? Unless you’re just playing around with building a language and trying out different ideas or you think it’s better at some other axis (eg lower defect rate). But I’ve generally found that my incident rate for bugs doesn’t change with languages. What rust has done successfully and “ML” languages have not is how to engage a broader community by exploiting a weakness in some class of problems they can do better on that existing languages cannot. That’s why they shifted into systems languages. Memory safety in systems languages was critically important and ML languages are typically too slow and memory hungry so Rust adopted some of the C&#x2F;C++ communities obsession with speed and memory usage philosophies while allowing for much safer code to be written. I think it’s safe to say they’ve finally dealt a “COBOL” like blow in that completely new code being written is unlikely to be C++ and C++ developer salaries will keep going up because it’s a difficult niche. will take a few decades to play out because C and C++ is so heavily entrenched. And who knows, maybe the memory safety efforts the standards body is taking will help but I think ultimately it will only be useful for hardening existing codebases but that’s a temporary patch on a bleed. Rust used that initial wedge to jam in a code repository, making testing and benchmarking easier, etc etc. some of the Rust libraries are insanely high quality and <i>waaay</i> easier to work with than in C++ land (even at Google and Facebook where it was a record level of easy)</div><br/><div id="38237142" class="c"><input type="checkbox" id="c-38237142" checked=""/><div class="controls bullet"><span class="by">zogrodea</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38237029">parent</a><span>|</span><a href="#38238194">next</a><span>|</span><label class="collapse" for="c-38237142">[-]</label><label class="expand" for="c-38237142">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think ML languages tend to be that slow, depending on what you compare them with and which member of the family you are using for comparison.<p>If we have three stages: (1) system languages, (2) higher level languages like Dart, Java, C#, (3) very high level languages like Python and Ruby, then the those among the most popular languages in the ML family (OCaml and F#) comfortably occupy the same level as (2).<p>Maybe that&#x27;s not what you&#x27;re after. OCaml&#x27;s more rare bytecode implementation (instead of native code) is about on par with Python and SML&#x2F;NJ is pretty slow as well (although faster SML implementations like MLTon exist).</div><br/></div></div><div id="38238194" class="c"><input type="checkbox" id="c-38238194" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38237029">parent</a><span>|</span><a href="#38237142">prev</a><span>|</span><a href="#38235941">next</a><span>|</span><label class="collapse" for="c-38238194">[-]</label><label class="expand" for="c-38238194">[1 more]</label></div><br/><div class="children"><div class="content">As someone that was introduced into ML languages via Caml Light in 1995, and has used a few of them since then, if the program is ass slow maybe the developer should have spent some time reading and practicing Algorithms and Data Structures.</div><br/></div></div></div></div></div></div><div id="38235941" class="c"><input type="checkbox" id="c-38235941" checked=""/><div class="controls bullet"><span class="by">greydius</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235919">parent</a><span>|</span><a href="#38236110">prev</a><span>|</span><a href="#38236415">next</a><span>|</span><label class="collapse" for="c-38235941">[-]</label><label class="expand" for="c-38235941">[2 more]</label></div><br/><div class="children"><div class="content">&gt; still way too imperative and not as functional to be called a true ML<p>As a Haskell fanboy, this is how I feel about Ocaml and F#.</div><br/><div id="38235955" class="c"><input type="checkbox" id="c-38235955" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235941">parent</a><span>|</span><a href="#38236415">next</a><span>|</span><label class="collapse" for="c-38235955">[-]</label><label class="expand" for="c-38235955">[1 more]</label></div><br/><div class="children"><div class="content">What are your thoughts on Idris and other Haskell derivatives? As well as the HVM and its Lisp-like Haskell-like combo of a language [0]?<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;HigherOrderCO&#x2F;hvm">https:&#x2F;&#x2F;github.com&#x2F;HigherOrderCO&#x2F;hvm</a></div><br/></div></div></div></div><div id="38236415" class="c"><input type="checkbox" id="c-38236415" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235919">parent</a><span>|</span><a href="#38235941">prev</a><span>|</span><a href="#38236014">next</a><span>|</span><label class="collapse" for="c-38236415">[-]</label><label class="expand" for="c-38236415">[4 more]</label></div><br/><div class="children"><div class="content">The ? thing, didn&#x27;t that get borrow from Swift, in fact?</div><br/><div id="38236696" class="c"><input type="checkbox" id="c-38236696" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236415">parent</a><span>|</span><a href="#38238090">next</a><span>|</span><label class="collapse" for="c-38236696">[-]</label><label class="expand" for="c-38236696">[1 more]</label></div><br/><div class="children"><div class="content">IANASE (swift expert), but the rust ? operator is used for error propragation in the same way that the try operator in swift is. Swift&#x27;s ?? operator is for unwrapping an option type: x ?? default, similar to x.unwrap_or(default) in Rust. (Swift&#x27;s ? is the ternary operator, as in C; rust does not have a ternary operator, using expression-if instead). Applied to a type, swift&#x27;s ? is the same as Option&lt;x&gt; in Rust.<p>Rust&#x27;s first mechanism for error propagation was the now-deprecated try!() macro, which did basically the same thing.</div><br/></div></div><div id="38238090" class="c"><input type="checkbox" id="c-38238090" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236415">parent</a><span>|</span><a href="#38236696">prev</a><span>|</span><a href="#38237446">next</a><span>|</span><label class="collapse" for="c-38238090">[-]</label><label class="expand" for="c-38238090">[1 more]</label></div><br/><div class="children"><div class="content">No. For starters ? was introduced by C# 2.0 almost 10 years before Swift appeared so it would have been lifted from that if anything, but then Rust’s ? has completely different semantics than everyone else.</div><br/></div></div><div id="38237446" class="c"><input type="checkbox" id="c-38237446" checked=""/><div class="controls bullet"><span class="by">tomca32</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236415">parent</a><span>|</span><a href="#38238090">prev</a><span>|</span><a href="#38236014">next</a><span>|</span><label class="collapse" for="c-38237446">[-]</label><label class="expand" for="c-38237446">[1 more]</label></div><br/><div class="children"><div class="content">Creator of the Rust language Graydon Hoare is working on Swift, so it’s probably the other way around</div><br/></div></div></div></div></div></div><div id="38236014" class="c"><input type="checkbox" id="c-38236014" checked=""/><div class="controls bullet"><span class="by">preommr</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235894">parent</a><span>|</span><a href="#38235919">prev</a><span>|</span><a href="#38236580">next</a><span>|</span><label class="collapse" for="c-38236014">[-]</label><label class="expand" for="c-38236014">[5 more]</label></div><br/><div class="children"><div class="content">Almost like people want some functional features without all the extra baggage.<p>I guess I would even say it&#x27;s like... most people just want the banana, but got a gorilla holding the banana and the rest of the jungle as well.</div><br/><div id="38236117" class="c"><input type="checkbox" id="c-38236117" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236014">parent</a><span>|</span><a href="#38236122">next</a><span>|</span><label class="collapse" for="c-38236117">[-]</label><label class="expand" for="c-38236117">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s the functional part of ML that tickles them. I think it&#x27;s the thoroughness of the type inference and type checking.</div><br/></div></div><div id="38236122" class="c"><input type="checkbox" id="c-38236122" checked=""/><div class="controls bullet"><span class="by">cglong</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236014">parent</a><span>|</span><a href="#38236117">prev</a><span>|</span><a href="#38236580">next</a><span>|</span><label class="collapse" for="c-38236122">[-]</label><label class="expand" for="c-38236122">[3 more]</label></div><br/><div class="children"><div class="content">At least in my piece of corporate software engineering, I&#x27;m looking at Rust as a &quot;gateway drug&quot; for FP. Management doesn&#x27;t want to take the risk of investing in FP, so reliable choices like Java and C++ are usually endorsed; the safety aspects of Rust are a much stronger argument for them.</div><br/><div id="38236186" class="c"><input type="checkbox" id="c-38236186" checked=""/><div class="controls bullet"><span class="by">vips7L</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236122">parent</a><span>|</span><a href="#38236580">next</a><span>|</span><label class="collapse" for="c-38236186">[-]</label><label class="expand" for="c-38236186">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the safety aspects are a much stronger argument. Managed languages like Java and C# are safe. The garbage collector isn&#x27;t going to let you ++ your way into remote code execution and most corporate software engineering isn&#x27;t heavily concurrent.  I think a stronger argument would be to advocate for a more functional language on the same runtime, like Scala or F#.</div><br/><div id="38237096" class="c"><input type="checkbox" id="c-38237096" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236186">parent</a><span>|</span><a href="#38236580">next</a><span>|</span><label class="collapse" for="c-38237096">[-]</label><label class="expand" for="c-38237096">[1 more]</label></div><br/><div class="children"><div class="content">Java and C# will not provide any sanity check on your use of locks and shared mutable state  though. But the Rust borrow checker will. It won&#x27;t prevent deadlock or race conditions, but it will at least guide you there much better than those pass-by-mutable-reference OO languages will.</div><br/></div></div></div></div></div></div></div></div><div id="38236580" class="c"><input type="checkbox" id="c-38236580" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38235894">parent</a><span>|</span><a href="#38236014">prev</a><span>|</span><a href="#38236699">next</a><span>|</span><label class="collapse" for="c-38236580">[-]</label><label class="expand" for="c-38236580">[7 more]</label></div><br/><div class="children"><div class="content">ML with a borrow checker is a bit of an oxymoron though. Because proper closures (the kind Rust can&#x27;t do) are essential for the classic functional programming that ML represents.</div><br/><div id="38238305" class="c"><input type="checkbox" id="c-38238305" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236580">parent</a><span>|</span><a href="#38238203">next</a><span>|</span><label class="collapse" for="c-38238305">[-]</label><label class="expand" for="c-38238305">[1 more]</label></div><br/><div class="children"><div class="content">Jane Street just entered the room:
<a href="https:&#x2F;&#x2F;blog.janestreet.com&#x2F;oxidizing-ocaml-locality&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.janestreet.com&#x2F;oxidizing-ocaml-locality&#x2F;</a><p>This part specially about closures:
<a href="https:&#x2F;&#x2F;blog.janestreet.com&#x2F;oxidizing-ocaml-ownership&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.janestreet.com&#x2F;oxidizing-ocaml-ownership&#x2F;</a><p><a href="https:&#x2F;&#x2F;blog.janestreet.com&#x2F;oxidizing-ocaml-parallelism&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.janestreet.com&#x2F;oxidizing-ocaml-parallelism&#x2F;</a>
And yes, their changes introduce quite some additional syntax.</div><br/></div></div><div id="38238203" class="c"><input type="checkbox" id="c-38238203" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236580">parent</a><span>|</span><a href="#38238305">prev</a><span>|</span><a href="#38237977">next</a><span>|</span><label class="collapse" for="c-38238203">[-]</label><label class="expand" for="c-38238203">[1 more]</label></div><br/><div class="children"><div class="content">Nope, that is what an ML with linear types does.</div><br/></div></div><div id="38237977" class="c"><input type="checkbox" id="c-38237977" checked=""/><div class="controls bullet"><span class="by">iopq</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236580">parent</a><span>|</span><a href="#38238203">prev</a><span>|</span><a href="#38236744">next</a><span>|</span><label class="collapse" for="c-38237977">[-]</label><label class="expand" for="c-38237977">[1 more]</label></div><br/><div class="children"><div class="content">ML does garbage collection, if it didn&#x27;t need it it wouldn&#x27;t do it.</div><br/></div></div><div id="38236744" class="c"><input type="checkbox" id="c-38236744" checked=""/><div class="controls bullet"><span class="by">chmod600</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236580">parent</a><span>|</span><a href="#38237977">prev</a><span>|</span><a href="#38236699">next</a><span>|</span><label class="collapse" for="c-38236744">[-]</label><label class="expand" for="c-38236744">[3 more]</label></div><br/><div class="children"><div class="content">Can you explain &quot;proper closures&quot;?</div><br/><div id="38236871" class="c"><input type="checkbox" id="c-38236871" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236744">parent</a><span>|</span><a href="#38236699">next</a><span>|</span><label class="collapse" for="c-38236871">[-]</label><label class="expand" for="c-38236871">[2 more]</label></div><br/><div class="children"><div class="content">I would hazard that this means closures that can capture (shared) state. In Rust, a closure’s data must either be moved into the closure or outlive the closure (dangling pointers etc etc). In most other languages, GC allows closures to keep a handle to any data at all.</div><br/><div id="38238033" class="c"><input type="checkbox" id="c-38238033" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236871">parent</a><span>|</span><a href="#38236699">next</a><span>|</span><label class="collapse" for="c-38238033">[-]</label><label class="expand" for="c-38238033">[1 more]</label></div><br/><div class="children"><div class="content">Exactly - sharing is the core of FP</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38236699" class="c"><input type="checkbox" id="c-38236699" checked=""/><div class="controls bullet"><span class="by">unstruktured</span><span>|</span><a href="#38235833">parent</a><span>|</span><a href="#38235894">prev</a><span>|</span><a href="#38237775">next</a><span>|</span><label class="collapse" for="c-38236699">[-]</label><label class="expand" for="c-38236699">[3 more]</label></div><br/><div class="children"><div class="content">I like both OCaml and Rust, especially OCaml, but even after 2 years of Rust I&#x27;m still way more productive in OCaml. Unless it&#x27;s absolutely essentially, I really don&#x27;t want to have track the life times of my objects so explicitly.<p>Thus, Rust for me serves mostly as a C&#x2F;C++ alternative. I don&#x27;t plan to ever write anything in C again, and even if it&#x27;s not my goto language otherwise, for that I&#x27;m thankful.</div><br/><div id="38236721" class="c"><input type="checkbox" id="c-38236721" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236699">parent</a><span>|</span><a href="#38237775">next</a><span>|</span><label class="collapse" for="c-38236721">[-]</label><label class="expand" for="c-38236721">[2 more]</label></div><br/><div class="children"><div class="content">I just clone and don&#x27;t worry about it, works well.</div><br/></div></div></div></div><div id="38237775" class="c"><input type="checkbox" id="c-38237775" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#38235833">parent</a><span>|</span><a href="#38236699">prev</a><span>|</span><a href="#38236411">next</a><span>|</span><label class="collapse" for="c-38237775">[-]</label><label class="expand" for="c-38237775">[1 more]</label></div><br/><div class="children"><div class="content">Always felt zig was a lot closer to ocaml than rust was.</div><br/></div></div><div id="38236411" class="c"><input type="checkbox" id="c-38236411" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38235833">parent</a><span>|</span><a href="#38237775">prev</a><span>|</span><a href="#38236005">next</a><span>|</span><label class="collapse" for="c-38236411">[-]</label><label class="expand" for="c-38236411">[2 more]</label></div><br/><div class="children"><div class="content">I kinda just think of Rust as C++ with a vaguely MLish inspired syntax &amp; some aspects of the type &amp; module system -- which is sort of how it explicitly started TBH -- and the borrow checker just grew out of what you end up needing to do if you rip the garbage collector out of a language like that.</div><br/><div id="38237529" class="c"><input type="checkbox" id="c-38237529" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236411">parent</a><span>|</span><a href="#38236005">next</a><span>|</span><label class="collapse" for="c-38237529">[-]</label><label class="expand" for="c-38237529">[1 more]</label></div><br/><div class="children"><div class="content">Rust was originally garbage collected. From Graydon Hoare&#x27;s post, he didn&#x27;t want explicit lifetimes originally either. He agreed because he thought they would always be inferred by the compiler.<p><a href="https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;307291.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;307291.html</a><p>It seems to me that Rust evolved into a better C++, but it did not start out that way.</div><br/></div></div></div></div><div id="38236005" class="c"><input type="checkbox" id="c-38236005" checked=""/><div class="controls bullet"><span class="by">frodowtf</span><span>|</span><a href="#38235833">parent</a><span>|</span><a href="#38236411">prev</a><span>|</span><a href="#38238201">next</a><span>|</span><label class="collapse" for="c-38236005">[-]</label><label class="expand" for="c-38236005">[23 more]</label></div><br/><div class="children"><div class="content">People say that OCaml is like Rust, but unlike Rust, OCaml has Exceptions that could appear everywhere. How is that safe?</div><br/><div id="38238488" class="c"><input type="checkbox" id="c-38238488" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236005">parent</a><span>|</span><a href="#38237644">next</a><span>|</span><label class="collapse" for="c-38238488">[-]</label><label class="expand" for="c-38238488">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t like Exceptions in OCaml (or Haskell or C++ or JS&#x2F;TS) either. But they aren&#x27;t unsafe, except for bugs in the compiler&#x2F;runtime (in OCaml, in C++ there are of course some footguns ;). 
Of course they add &quot;bottom&quot; to any function where an Exceptions can occur (and other things, see for example
<a href="https:&#x2F;&#x2F;markkarpov.com&#x2F;tutorial&#x2F;Exceptions" rel="nofollow noreferrer">https:&#x2F;&#x2F;markkarpov.com&#x2F;tutorial&#x2F;Exceptions</a>) but for stuff like `0&#x2F;0` there are 3 possibilities:<p>use something like `Maybe` for the result - clumsy.<p>return (for example) 0, which is what most theorem provers (like Coq or Lean and dependently typed languages like Idris) do, that need their functions to be total<p>or throw an exception.<p>Now, with OCaml&#x27;s effect systém, there also is no need to use exceptions for control flow - which you should have never done anyway.</div><br/></div></div><div id="38237644" class="c"><input type="checkbox" id="c-38237644" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236005">parent</a><span>|</span><a href="#38238488">prev</a><span>|</span><a href="#38236913">next</a><span>|</span><label class="collapse" for="c-38237644">[-]</label><label class="expand" for="c-38237644">[1 more]</label></div><br/><div class="children"><div class="content">Rust has panics as well and they appear pretty much everywhere, because the Rust stdlb made a conscious decision to panic on allocation failures (later non-panicking APIs were added, but most people dont use them, and in special, most dependencies will not use this and will panic on random occasions), and also because common operations like integer division and array indexing will panic on bugs (and also integer overflow on debug builds)<p>In any case OCaml has memory safety, sort of (it has data races but as described in the paper &quot;data races bounded in time and space&quot;, data races in OCaml doesn&#x27;t lead to unrestricted UB like in Rust, C, C++, and most other languages actually) (unless you opt into OCaml&#x27;s unsafe constructs like Obj.magic, which is like Rust&#x27;s unsafe without using unsafe {} block), because it has a GC<p>So when you talk about safety in the context of exceptions, you probably mean exception safety rather than memory safety. Exception safety basically means you code works even if an exception is raised. Which is really hard to assure since as you said, exceptions are everywhere<p>But Rust suffer from this same problem! In Rust this is called panic safety and mitigating it has taken a great deal of complexity, with things like lock poisoning, which adds overhead but limit the scope of panics in multithreaded programs, and the UnwindSafe trait, which is probably a good attempt but is ignored in most of the ecosystem. Many people think such measures are inadequate and insufficient and prefer to run programs with panic=abort, which means to just terminate the program when there is any panic. (many C++ projects disable exceptions in the same way for example)<p>Which is kind of unfortunate because now there are many Rust programs that are only correct if you run with panic=abort, and will break if you enable stack unwinding (which is the default)</div><br/></div></div><div id="38236913" class="c"><input type="checkbox" id="c-38236913" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236005">parent</a><span>|</span><a href="#38237644">prev</a><span>|</span><a href="#38236053">next</a><span>|</span><label class="collapse" for="c-38236913">[-]</label><label class="expand" for="c-38236913">[3 more]</label></div><br/><div class="children"><div class="content">Rust has panics that could appear anywhere.</div><br/><div id="38237150" class="c"><input type="checkbox" id="c-38237150" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236913">parent</a><span>|</span><a href="#38236053">next</a><span>|</span><label class="collapse" for="c-38237150">[-]</label><label class="expand" for="c-38237150">[2 more]</label></div><br/><div class="children"><div class="content">But the flow control is easier to reason about. You don&#x27;t have to go guessing about non-local catch blocks that the caller may have introduced. The code either panics, or propagates.<p>Exceptions look remarkably wrong headed to me in retrospect. Allowing the caller to change the error handling contract and flow control.</div><br/><div id="38237652" class="c"><input type="checkbox" id="c-38237652" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38237150">parent</a><span>|</span><a href="#38236053">next</a><span>|</span><label class="collapse" for="c-38237652">[-]</label><label class="expand" for="c-38237652">[1 more]</label></div><br/><div class="children"><div class="content">Rust panics can be catched too, but it&#x27;s true that it&#x27;s less common than in languages with exceptions</div><br/></div></div></div></div></div></div><div id="38236053" class="c"><input type="checkbox" id="c-38236053" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236005">parent</a><span>|</span><a href="#38236913">prev</a><span>|</span><a href="#38236047">next</a><span>|</span><label class="collapse" for="c-38236053">[-]</label><label class="expand" for="c-38236053">[6 more]</label></div><br/><div class="children"><div class="content">F# has exceptions. You can just pattern match on them.</div><br/><div id="38236138" class="c"><input type="checkbox" id="c-38236138" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236053">parent</a><span>|</span><a href="#38236047">next</a><span>|</span><label class="collapse" for="c-38236138">[-]</label><label class="expand" for="c-38236138">[5 more]</label></div><br/><div class="children"><div class="content">In OCaml the type checker won&#x27;t force you to handle exceptions (from what I remember.) See e.g. <a href="https:&#x2F;&#x2F;ocaml.org&#x2F;docs&#x2F;error-handling#exceptions" rel="nofollow noreferrer">https:&#x2F;&#x2F;ocaml.org&#x2F;docs&#x2F;error-handling#exceptions</a></div><br/><div id="38236190" class="c"><input type="checkbox" id="c-38236190" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236138">parent</a><span>|</span><a href="#38236047">next</a><span>|</span><label class="collapse" for="c-38236190">[-]</label><label class="expand" for="c-38236190">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, but at least in my experience, it is rarely a problem. Because if you&#x27;re at a point in your program where you don&#x27;t want to bubble up, you can just pattern match against the exceptions just as you would a Result type, which F# also has.<p>I don&#x27;t know Rust, but after searching, it seems that it has a panic facility which seems even more escaping than an exception. Happy to be corrected there.</div><br/><div id="38236393" class="c"><input type="checkbox" id="c-38236393" checked=""/><div class="controls bullet"><span class="by">frodowtf</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236190">parent</a><span>|</span><a href="#38237270">next</a><span>|</span><label class="collapse" for="c-38236393">[-]</label><label class="expand" for="c-38236393">[2 more]</label></div><br/><div class="children"><div class="content">`panic` has nothing to do with error handling though. If you use it, you know that your callers cannot recover from it.<p>Throwing an exception implicitly delegates error handling back to the caller, but they are not even notified about it. (talking about OCaml)</div><br/><div id="38237671" class="c"><input type="checkbox" id="c-38237671" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236393">parent</a><span>|</span><a href="#38237270">next</a><span>|</span><label class="collapse" for="c-38237671">[-]</label><label class="expand" for="c-38237671">[1 more]</label></div><br/><div class="children"><div class="content">No, they can, check the catch_unwind API.<p>Some frameworks catch panics automatically. For example, in the Actix web framework, if you panic in an HTTP response the panic will be catchee, so it won&#x27;t bring the whole server down.<p>Also, by default a panic will terminate only the current thread, which is a major footgun: you now need to reason about what you program will do after some bug or unforseen circunstance happened somewhere in the code and made you program misbehave. Which leads to slightly insane things like lock poisoning.<p>It&#x27;s more sane to compile with panic=abort, but that&#x27;s not the default and it means that on panic you won&#x27;t release resources (which aren&#x27;t just allocated memory to be clear)</div><br/></div></div></div></div><div id="38237270" class="c"><input type="checkbox" id="c-38237270" checked=""/><div class="controls bullet"><span class="by">debo_</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236190">parent</a><span>|</span><a href="#38236393">prev</a><span>|</span><a href="#38236047">next</a><span>|</span><label class="collapse" for="c-38237270">[-]</label><label class="expand" for="c-38237270">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I don&#x27;t find it to be a problem either, but the parent does and I can see where they are coming from. Even Java has checked exceptions.</div><br/></div></div></div></div></div></div></div></div><div id="38236047" class="c"><input type="checkbox" id="c-38236047" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236005">parent</a><span>|</span><a href="#38236053">prev</a><span>|</span><a href="#38236435">next</a><span>|</span><label class="collapse" for="c-38236047">[-]</label><label class="expand" for="c-38236047">[4 more]</label></div><br/><div class="children"><div class="content">why do feel exceptions make a language unsafe?</div><br/><div id="38238206" class="c"><input type="checkbox" id="c-38238206" checked=""/><div class="controls bullet"><span class="by">hurril</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236047">parent</a><span>|</span><a href="#38236179">next</a><span>|</span><label class="collapse" for="c-38238206">[-]</label><label class="expand" for="c-38238206">[1 more]</label></div><br/><div class="children"><div class="content">Safe isn&#x27;t the best word to describe it with. But it does mean that any expression or statement always has two possible control flows. You have the &quot;surface flow&quot; as well as the exceptional flow, so there&#x27;s an added complexity.<p>I never felt this was a problem when I did Java though (despite their awkwardness - basically forcing coders to not use checked exceptions.)<p>Rust&#x27;s control flow syntax for Results and Options are very similar to this but with an added benefit: you don&#x27;t have to use the ?-operator.<p>panics is different, however. They are more akin to the way any Java program will happily OutOfMemoryError or NoClassDefFoundError given circumstances not (always) in your control.</div><br/></div></div><div id="38236179" class="c"><input type="checkbox" id="c-38236179" checked=""/><div class="controls bullet"><span class="by">timschmidt</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236047">parent</a><span>|</span><a href="#38238206">prev</a><span>|</span><a href="#38236435">next</a><span>|</span><label class="collapse" for="c-38236179">[-]</label><label class="expand" for="c-38236179">[2 more]</label></div><br/><div class="children"><div class="content">Second, less-predictable execution path.  Additional cognitive load in evaluating effects across both paths.  Additional opportunity for bugs.  Doesn&#x27;t necessarily mean that exceptions make all software which uses them unsafe, but does tend to mean that exceptions significantly complicate the task of proving safety for any nontrivial program.</div><br/><div id="38237647" class="c"><input type="checkbox" id="c-38237647" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236179">parent</a><span>|</span><a href="#38236435">next</a><span>|</span><label class="collapse" for="c-38237647">[-]</label><label class="expand" for="c-38237647">[1 more]</label></div><br/><div class="children"><div class="content">&gt; proving safety for any nontrivial program.<p>I haven&#x27;t done this, but probably the surest way to do that would be to use a proof assistant and extract the result to Standard ML or to OCaml. Standard ML has verified implementations, too.</div><br/></div></div></div></div></div></div><div id="38236435" class="c"><input type="checkbox" id="c-38236435" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236005">parent</a><span>|</span><a href="#38236047">prev</a><span>|</span><a href="#38238201">next</a><span>|</span><label class="collapse" for="c-38236435">[-]</label><label class="expand" for="c-38236435">[7 more]</label></div><br/><div class="children"><div class="content">Safety was something added to Rust as it developed, not one of the original goals. As I recall it.<p>And you&#x27;re working with multiple definitions of &quot;safety&quot; here, and Rust sorta conflates them all via borrow checker, but the one people are usually most concerned with is memory safety which is not a concern for a garbage collected language.<p>I do seem to recall that StandardML did not have exceptions though. And I always felt that SML was the better language.<p>OCaml adding OO classes and exceptions and other 90s trends that actually have ended up not aging well...</div><br/><div id="38236760" class="c"><input type="checkbox" id="c-38236760" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236435">parent</a><span>|</span><a href="#38236674">next</a><span>|</span><label class="collapse" for="c-38236760">[-]</label><label class="expand" for="c-38236760">[5 more]</label></div><br/><div class="children"><div class="content">From the presentation introducing Rust to Mozilla: <a href="http:&#x2F;&#x2F;venge.net&#x2F;graydon&#x2F;talks&#x2F;intro-talk-2.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;venge.net&#x2F;graydon&#x2F;talks&#x2F;intro-talk-2.pdf</a><p>&gt; I have been writing a compiled, concurrent, safe, systems programming language for the past four and a half years.<p>Safety was always part of it.</div><br/><div id="38237069" class="c"><input type="checkbox" id="c-38237069" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236760">parent</a><span>|</span><a href="#38236674">next</a><span>|</span><label class="collapse" for="c-38237069">[-]</label><label class="expand" for="c-38237069">[4 more]</label></div><br/><div class="children"><div class="content">But those &quot;Safety&quot; definitions are all not like what Rust folks mean by safety now. He&#x27;s talking about immutability and bounds checking and avoiding memory corruption but not at all about borrowing.<p>I guess I should have been more specific. If that&#x27;s what we mean by safe, then OCaml is safe as well.<p>Anyways, I followed it at the time. The borrow checker came later.</div><br/><div id="38237116" class="c"><input type="checkbox" id="c-38237116" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38237069">parent</a><span>|</span><a href="#38237107">next</a><span>|</span><label class="collapse" for="c-38237116">[-]</label><label class="expand" for="c-38237116">[2 more]</label></div><br/><div class="children"><div class="content">I absolutely agree the borrow checker came later. I think of it as that the goals have always been the same, but the enforcement mechanism changed over time, as more and more static ways were found to achieve the goal.</div><br/></div></div></div></div></div></div><div id="38236674" class="c"><input type="checkbox" id="c-38236674" checked=""/><div class="controls bullet"><span class="by">weatherlight</span><span>|</span><a href="#38235833">root</a><span>|</span><a href="#38236435">parent</a><span>|</span><a href="#38236760">prev</a><span>|</span><a href="#38238201">next</a><span>|</span><label class="collapse" for="c-38236674">[-]</label><label class="expand" for="c-38236674">[1 more]</label></div><br/><div class="children"><div class="content">I agree, Standard ML&#x27;s syntax feels a lot cleaner than that of OCamls.</div><br/></div></div></div></div></div></div></div></div><div id="38238201" class="c"><input type="checkbox" id="c-38238201" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38235833">prev</a><span>|</span><a href="#38235991">next</a><span>|</span><label class="collapse" for="c-38238201">[-]</label><label class="expand" for="c-38238201">[4 more]</label></div><br/><div class="children"><div class="content">&gt;... linked lists are slow and inefficient with modern CPU caches, and you should almost never use them<p>You should not use them most of the time in functional languages (like OCaml and Haskell and...) for this reasons either, it&#x27;s just that (almost) all examples for beginners use them because they are &quot;easier&quot; than for example trees.<p>Oh, by the way, OCaml does not have significant whitespace (but e.g.F# and Haskell do).</div><br/><div id="38238417" class="c"><input type="checkbox" id="c-38238417" checked=""/><div class="controls bullet"><span class="by">momentoftop</span><span>|</span><a href="#38238201">parent</a><span>|</span><a href="#38238221">next</a><span>|</span><label class="collapse" for="c-38238417">[-]</label><label class="expand" for="c-38238417">[2 more]</label></div><br/><div class="children"><div class="content">You use them all the time in Haskell and OCaml. Cache locality isn&#x27;t such an issue. You&#x27;re not mallocing linked list nodes. You allocate by a pointer bump of the minor heap, and if the GC copies your list into the major heap, it&#x27;s going to copy the list elements together.<p>You also use recursion all the time, and no, recursion is not generally straightforwardly optimised into iteration unless you&#x27;re doing trivial tail recursion.</div><br/><div id="38238568" class="c"><input type="checkbox" id="c-38238568" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38238201">root</a><span>|</span><a href="#38238417">parent</a><span>|</span><a href="#38238221">next</a><span>|</span><label class="collapse" for="c-38238568">[-]</label><label class="expand" for="c-38238568">[1 more]</label></div><br/><div class="children"><div class="content">Yes I know and at least GHC optimizes lists better than most other data structures (I guess even isomorphic ones).
But I guess your definition of &quot;all the time&quot; is not the samé as mine (yes, I use them in every project too). 
What I wanted to express is that lists are way less used than beginner tutorials may make it seem and there are other data structures available (like in other languages ;).</div><br/></div></div></div></div><div id="38238221" class="c"><input type="checkbox" id="c-38238221" checked=""/><div class="controls bullet"><span class="by">Jaxan</span><span>|</span><a href="#38238201">parent</a><span>|</span><a href="#38238417">prev</a><span>|</span><a href="#38235991">next</a><span>|</span><label class="collapse" for="c-38238221">[-]</label><label class="expand" for="c-38238221">[1 more]</label></div><br/><div class="children"><div class="content">In Haskell you typically don’t allocate any memory when using the default list type, because of laziness. The it’s totally fine and efficient. Just don’t use it to store data for later retrieval.</div><br/></div></div></div></div><div id="38235991" class="c"><input type="checkbox" id="c-38235991" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#38238201">prev</a><span>|</span><a href="#38238533">next</a><span>|</span><label class="collapse" for="c-38235991">[-]</label><label class="expand" for="c-38235991">[2 more]</label></div><br/><div class="children"><div class="content">i had some of the same problems; here&#x27;s how i solved them, though keep in mind i am no ocaml expert, just a dabbler<p>at some point i got sick of trying to debug mysterious compile errors about types in ocaml and started declaring types for all of my function arguments; ocaml lets you do that.  an example is <a href="http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;mukanren.ml" rel="nofollow noreferrer">http:&#x2F;&#x2F;canonical.org&#x2F;~kragen&#x2F;sw&#x2F;dev3&#x2F;mukanren.ml</a> (an implementation of a tiny logic programming language, sort of like prolog with superpowers; cw inappropriate intimacy) where, for example, instead of writing<p><pre><code>    let rec disj g1 g2 t = mplus (g1 t) (g2 t)
</code></pre>
i write<p><pre><code>    let rec
        disj (g1 : goal) (g2 : goal) (t : state) = mplus (g1 t) (g2 t)
</code></pre>
which is more code, to be sure, but i think easier to understand because it&#x27;s more explicit.  and the compiler doesn&#x27;t report your type errors in the wrong function anymore when you do that<p>if you aren&#x27;t sure what the types should be (easy when parametric polymorphism gets involved) you can paste the code without type declarations into the repl and see what it says<p>in this case that looks like this<p><pre><code>    # let rec disj g1 g2 t = mplus (g1 t) (g2 t) ;;
      val disj : (&#x27;a -&gt; &#x27;b stream) -&gt; (&#x27;a -&gt; &#x27;b stream) -&gt; &#x27;a -&gt; &#x27;b stream = &lt;fun&gt;
</code></pre>
and in fact my `goal` type is more specific, `state -&gt; state stream`, thus favoring comprehensibility a bit over flexibility (i can always go back and generalize the type more later)<p>this makes the code a bit more verbose but most functions are more than five words long so it&#x27;s not actually that bad<p>maybe i should declare the return type too<p><pre><code>    let rec
        disj (g1 : goal) (g2 : goal) (t : state) : state stream = mplus (g1 t) (g2 t)
</code></pre>
but so far parameter declarations seem like about the right balance<p>declaring parameter types in your own code doesn&#x27;t help with code you didn&#x27;t write, but you can use the repl to find out what types the compiler inferred for it<p><pre><code>    # List.map ;;
    - : (&#x27;a -&gt; &#x27;b) -&gt; &#x27;a list -&gt; &#x27;b list = &lt;fun&gt;
</code></pre>
presumably editors with lsp support have some magic keystroke to display this on demand in your editor or something, maybe an lsp user can tell us what it is</div><br/><div id="38237646" class="c"><input type="checkbox" id="c-38237646" checked=""/><div class="controls bullet"><span class="by">dazed_confused</span><span>|</span><a href="#38235991">parent</a><span>|</span><a href="#38238533">next</a><span>|</span><label class="collapse" for="c-38237646">[-]</label><label class="expand" for="c-38237646">[1 more]</label></div><br/><div class="children"><div class="content">There is a vscode extension for the ocaml-lsp that will show type annotations above each line of code.</div><br/></div></div></div></div><div id="38238533" class="c"><input type="checkbox" id="c-38238533" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#38235991">prev</a><span>|</span><a href="#38235855">next</a><span>|</span><label class="collapse" for="c-38238533">[-]</label><label class="expand" for="c-38238533">[2 more]</label></div><br/><div class="children"><div class="content">The biggest issue for me with OCaml is OPAM. It&#x27;s pretty awful. Simple things like &quot;install this code&quot; don&#x27;t work reliably - often installing a different branch or just ignoring edits you&#x27;ve made, even <i>after</i> you discover the flag that says it should include them (it seems to be simply broken). It also doesn&#x27;t work on Windows in any meaningful way.<p>It&#x27;s not just me that has these issues. We introduced a tool into my company that is written in OCaml and I ended up spending so much time helping people fight OPAM that I eventually implemented a build cache system so they didn&#x27;t need to actually compile the OCaml code at all. Saved a bunch of hassle.<p>It seems like a pretty decent language, aside from the issues the author of this article mentioned which are 100% true. But OPAM means I would never pick it.<p>Similar issue to Python, which isn&#x27;t really a <i>bad</i> language (I&#x27;d say it&#x27;s mediocre-to-ok), but the packaging and tooling story is abysmal.<p>More languages need to learn from Go, Deno and to a slightly lesser extent Rust which have all prioritised having a packaging system that doesn&#x27;t make you want to tear your eyes out.</div><br/><div id="38238609" class="c"><input type="checkbox" id="c-38238609" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#38238533">parent</a><span>|</span><a href="#38235855">next</a><span>|</span><label class="collapse" for="c-38238609">[-]</label><label class="expand" for="c-38238609">[1 more]</label></div><br/><div class="children"><div class="content">The biggest problém with Opam and OCaml on Windows is that most of the packages won&#x27;t work. Officially, Opam does not support Windows at all, that is going to be included with 2.2 (which is still in alpha AFAIK) 
<a href="https:&#x2F;&#x2F;opam.ocaml.org&#x2F;blog&#x2F;opam-2-2-0-alpha&#x2F;#Windows-Support" rel="nofollow noreferrer">https:&#x2F;&#x2F;opam.ocaml.org&#x2F;blog&#x2F;opam-2-2-0-alpha&#x2F;#Windows-Suppor...</a><p>I always thought of Opam as the best feature of OCaml (especially compared to Haskell with two no-working package managers - and no, Nix is a problém, not a solution either).</div><br/></div></div></div></div><div id="38235855" class="c"><input type="checkbox" id="c-38235855" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#38238533">prev</a><span>|</span><a href="#38237823">next</a><span>|</span><label class="collapse" for="c-38235855">[-]</label><label class="expand" for="c-38235855">[14 more]</label></div><br/><div class="children"><div class="content">Yeah my semi-hot take is that type annotations in functions is a feature not a bug. It forces legible interfaces (with the exception of nasty generics I suppose).</div><br/><div id="38236041" class="c"><input type="checkbox" id="c-38236041" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#38235855">parent</a><span>|</span><a href="#38236136">next</a><span>|</span><label class="collapse" for="c-38236041">[-]</label><label class="expand" for="c-38236041">[7 more]</label></div><br/><div class="children"><div class="content">But they can just be auto-generated in documentation. It gets pretty annoying to type annotate everything for nothing but warm fuzzies when the compiler can figure it all out for you.<p>Also, any decent IDE will show the types any way.<p>The complaint about the types is just strange and shows a failure in getting Rust out of their head. Once you get used to F# and OCaml, then going back to a language that forces type annotations everywhere gets old and seems archaic because you spend all this time telling the compiler what it already knows (in a language like F# and OCaml). However, there are times in which type annotations are needed, especially in F# when dealing with objects. I generally type annotate when I feel the name of the argument doesn&#x27;t capture the type.<p>Writing F# often feels very Pythonic or Scheme-y, but at the end of the day, everything is being statically typechecked, so it&#x27;s the best of both worlds.</div><br/><div id="38236829" class="c"><input type="checkbox" id="c-38236829" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236041">parent</a><span>|</span><a href="#38237118">next</a><span>|</span><label class="collapse" for="c-38236829">[-]</label><label class="expand" for="c-38236829">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The complaint about the types is just strange and shows a failure in getting Rust out of their head.<p>I second this a lot. It&#x27;s very strange to me that the author is complaining about powerful type inference. In my limited experience with ReScript, I&#x27;ve found the type inference to drastically reduce boilerplate while providing the same type safety guarantees as TypeScript. Moreover, your editor or IDE can always tell you what the inferred type is. I am really not sure what I am missing. The author headlines the paragraph with &quot;Where are the types? [sic]&quot; but the types are there! They&#x27;re inferred and visible in your IDE!<p>The provided code snippet doesn&#x27;t really help illustrate the point either, IMO. It will look unfamiliar to those who&#x27;ve never used OCaml before, and to those who have done more than a fizzbuzz in OCaml, it will look okay.</div><br/></div></div><div id="38237118" class="c"><input type="checkbox" id="c-38237118" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236041">parent</a><span>|</span><a href="#38236829">prev</a><span>|</span><a href="#38236816">next</a><span>|</span><label class="collapse" for="c-38237118">[-]</label><label class="expand" for="c-38237118">[1 more]</label></div><br/><div class="children"><div class="content">Well there&#x27;s also the fact that the types flow downward from the interface. Like the source of truth comes from your function parameter types that are always explicitly written. One thing that tripped me up writing OCaml is that you could have a mistake in your function that&#x27;d show up as a bug in a completely different location due to the inference algorithm. Like dumb example but say I have `foo` instead of `foo()` that changes the function return type to be a () -&gt; int instead of int. You&#x27;ll get the error when you use the function result instead of inside the function.</div><br/></div></div><div id="38236816" class="c"><input type="checkbox" id="c-38236816" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236041">parent</a><span>|</span><a href="#38237118">prev</a><span>|</span><a href="#38236181">next</a><span>|</span><label class="collapse" for="c-38236816">[-]</label><label class="expand" for="c-38236816">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It gets pretty annoying to type annotate everything for nothing but warm fuzzies when the compiler can figure it all out for you.<p>This is sometimes fine for internal code, but for external interfaces you want a human to determine the interface contract you’re agreeing to, rather than the minimal set or the maximal set of types the function supports as currently-written.</div><br/><div id="38237610" class="c"><input type="checkbox" id="c-38237610" checked=""/><div class="controls bullet"><span class="by">DiscoDays</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236816">parent</a><span>|</span><a href="#38236181">next</a><span>|</span><label class="collapse" for="c-38237610">[-]</label><label class="expand" for="c-38237610">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but presumably code that is meant to have an external interface will be in a module and will have an *.mli file to it, and that is an excellent place to constrain your types explicitly if you must.</div><br/></div></div></div></div><div id="38236181" class="c"><input type="checkbox" id="c-38236181" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236041">parent</a><span>|</span><a href="#38236816">prev</a><span>|</span><a href="#38238246">next</a><span>|</span><label class="collapse" for="c-38236181">[-]</label><label class="expand" for="c-38236181">[1 more]</label></div><br/><div class="children"><div class="content">In OCaml most people are writing signatures to which their modules conform (usually in separate mli files). The problem is that checking the signature happens after all the type inference so you can’t use it to disambiguate constructors for function arguments&#x2F;results, and they can’t be used much to guide users who make type errors in their functions. I think it was a good idea that rust put the types in arguments to non-anonymous function.</div><br/></div></div><div id="38238246" class="c"><input type="checkbox" id="c-38238246" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236041">parent</a><span>|</span><a href="#38236181">prev</a><span>|</span><a href="#38236136">next</a><span>|</span><label class="collapse" for="c-38238246">[-]</label><label class="expand" for="c-38238246">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately in the 21st century still too many people like to program the hard way without tools that improve their workflows.<p>Maybe they should do batch compilations as well, why bother with interactive programming.</div><br/></div></div></div></div><div id="38236136" class="c"><input type="checkbox" id="c-38236136" checked=""/><div class="controls bullet"><span class="by">Shoop</span><span>|</span><a href="#38235855">parent</a><span>|</span><a href="#38236041">prev</a><span>|</span><a href="#38236848">next</a><span>|</span><label class="collapse" for="c-38236136">[-]</label><label class="expand" for="c-38236136">[1 more]</label></div><br/><div class="children"><div class="content">OCaml has a separate language for module interfaces where types are required. Even better, it allows you to abstract over types and make them entirely opaque, so that users of an interface never have to look at any of the implementation details.</div><br/></div></div><div id="38236848" class="c"><input type="checkbox" id="c-38236848" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#38235855">parent</a><span>|</span><a href="#38236136">prev</a><span>|</span><a href="#38235974">next</a><span>|</span><label class="collapse" for="c-38236848">[-]</label><label class="expand" for="c-38236848">[4 more]</label></div><br/><div class="children"><div class="content">As you get more comfortable with functional programming, the type signatures tend to get more complex for sophisticated code. Those &quot;nasty generics&quot; become reliable friends.<p>For example, since functions are first-class objects, they are often passed around as parameters to other &quot;higher-order&quot; functions. Explicitly declaring the types of all these functions is tedious at best, and confusing at worst.</div><br/><div id="38237157" class="c"><input type="checkbox" id="c-38237157" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38236848">parent</a><span>|</span><a href="#38235974">next</a><span>|</span><label class="collapse" for="c-38237157">[-]</label><label class="expand" for="c-38237157">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not convinced that these type signatures have to be that bad. You could probably make them pretty tenable, especially with a good code formatter.<p>Also, I&#x27;m confused. We&#x27;re using type driven development and writing the type signatures as part of the documentation, we should be thinking in terms of types, why would they be difficult to write?</div><br/><div id="38237625" class="c"><input type="checkbox" id="c-38237625" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38237157">parent</a><span>|</span><a href="#38237261">next</a><span>|</span><label class="collapse" for="c-38237625">[-]</label><label class="expand" for="c-38237625">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not bad. They&#x27;re just a pain to type out in detail every time. Here&#x27;s an example signature from an F# library I like called FParsec:<p><pre><code>    pipe2: Parser&lt;&#x27;a,&#x27;u&gt; -&gt; Parser&lt;&#x27;b,&#x27;u&gt; -&gt; (&#x27;a -&gt; &#x27;b -&gt; &#x27;c) -&gt; Parser&lt;&#x27;c,&#x27;u&gt;
</code></pre>
That&#x27;s fine for documentation, but I&#x27;m glad it&#x27;s not cluttering up the actual implementation, which starts like this:<p><pre><code>    let pipe2 (p1: Parser&lt;&#x27;a,&#x27;u&gt;) (p2: Parser&lt;&#x27;b,&#x27;u&gt;) f =
        ...
</code></pre>
You can see how the code does explicitly specify the types of `p1` and `p2`, but doesn&#x27;t bother spelling out the type of `f` or the return type. Although we are thinking in types the whole time, this sort of flexibility in the implementation is important for real-world functional code.<p>(For anyone wondering, this function takes two parsers and a function as input. It sends the output of each parser to the function, and the result is itself a parser. This is equivalent to a well-known abstract function called `liftA2` in a language that supports typeclasses, like Haskell.)<p>[0]: <a href="https:&#x2F;&#x2F;www.quanttec.com&#x2F;fparsec&#x2F;reference&#x2F;primitives.html#members.pipe2" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.quanttec.com&#x2F;fparsec&#x2F;reference&#x2F;primitives.html#m...</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;stephan-tolksdorf&#x2F;fparsec&#x2F;blob&#x2F;master&#x2F;FParsec&#x2F;Primitives.fs">https:&#x2F;&#x2F;github.com&#x2F;stephan-tolksdorf&#x2F;fparsec&#x2F;blob&#x2F;master&#x2F;FPa...</a><p>[2]: <a href="https:&#x2F;&#x2F;hoogle.haskell.org&#x2F;?hoogle=liftA2" rel="nofollow noreferrer">https:&#x2F;&#x2F;hoogle.haskell.org&#x2F;?hoogle=liftA2</a></div><br/></div></div><div id="38237261" class="c"><input type="checkbox" id="c-38237261" checked=""/><div class="controls bullet"><span class="by">jasperry</span><span>|</span><a href="#38235855">root</a><span>|</span><a href="#38237157">parent</a><span>|</span><a href="#38237625">prev</a><span>|</span><a href="#38235974">next</a><span>|</span><label class="collapse" for="c-38237261">[-]</label><label class="expand" for="c-38237261">[1 more]</label></div><br/><div class="children"><div class="content">This is a really good question. When you write generic code in a language with higher-order functions, type signatures can get pretty hairy with type variables and quantifiers flying around (forall a. a -&gt; foo a). In a functional language with type inference, it&#x27;s mostly managing those for you, and you can (usually) just write code in a natural way and it automatically is polymorphic, but in a safer way than dynamically-typed languages.</div><br/></div></div></div></div></div></div><div id="38235974" class="c"><input type="checkbox" id="c-38235974" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#38235855">parent</a><span>|</span><a href="#38236848">prev</a><span>|</span><a href="#38237823">next</a><span>|</span><label class="collapse" for="c-38235974">[-]</label><label class="expand" for="c-38235974">[1 more]</label></div><br/><div class="children"><div class="content">I think that is not a hot take at all, haha. For some reason, in TypeScript people like to have return types inferred, and while I do that just because I&#x27;m lazy in my own projects, we enforce explicit return types in our work codebases simply because you never know when something might change in the function body.</div><br/></div></div></div></div><div id="38237823" class="c"><input type="checkbox" id="c-38237823" checked=""/><div class="controls bullet"><span class="by">iopq</span><span>|</span><a href="#38235855">prev</a><span>|</span><label class="collapse" for="c-38237823">[-]</label><label class="expand" for="c-38237823">[1 more]</label></div><br/><div class="children"><div class="content">Horizontal scrolling code does make it quite impossible for me to follow the examples</div><br/></div></div></div></div></div></div></div></body></html>