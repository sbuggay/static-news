<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731747659969" as="style"/><link rel="stylesheet" href="styles.css?v=1731747659969"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://simondobson.org/2024/06/21/c%2B%2B-template-macroprogramming-versus-lisp-macros/">C++ Template Macroprogramming versus Lisp Macros</a> <span class="domain">(<a href="https://simondobson.org">simondobson.org</a>)</span></div><div class="subtext"><span>oumua_don17</span> | <span>51 comments</span></div><br/><div><div id="42151249" class="c"><input type="checkbox" id="c-42151249" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42152221">next</a><span>|</span><label class="collapse" for="c-42151249">[-]</label><label class="expand" for="c-42151249">[12 more]</label></div><br/><div class="children"><div class="content">Factorial macro example in C++23 metaprogramming,<p><pre><code>  #include &lt;iostream&gt;

  consteval long factorial (int n) {
    if (n == 0) return 1;

    return n * factorial(n - 1);
  }

  int main() {
    std::cout &lt;&lt; factorial(7) &lt;&lt; std::endl;
  }
</code></pre>
Exercise for the reader if using VC++ or clang&#x2F;ninja, use <i>import std</i> instead.<p>-- <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;TWe11hM6j" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;TWe11hM6j</a><p>Nicely put 5040 in ESI register at compile time.<p>Granted, C++ isn&#x27;t Lisp, but already has quite a room for creativity at compile time, and C++26 might finally have compile time reflection as well.</div><br/><div id="42153652" class="c"><input type="checkbox" id="c-42153652" checked=""/><div class="controls bullet"><span class="by">cornstalks</span><span>|</span><a href="#42151249">parent</a><span>|</span><a href="#42151697">next</a><span>|</span><label class="collapse" for="c-42153652">[-]</label><label class="expand" for="c-42153652">[2 more]</label></div><br/><div class="children"><div class="content">The terms &quot;macro&quot; and &quot;metaprogramming&quot; already have well-defined meanings in the C++ community. You&#x27;re just hijacking the terms and using them with some new definition.<p>The C++ standard is consistent in how it uses &quot;macro,&quot; and it&#x27;s strictly about the preprocessor kind of macros. &quot;Metaprogramming&quot; is also used in the standard, though not as extensively or rigidly (only 8 times in N4950), but both in the specification and colloquially it&#x27;s more than just slapping consteval on a function.</div><br/><div id="42155195" class="c"><input type="checkbox" id="c-42155195" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42151249">root</a><span>|</span><a href="#42153652">parent</a><span>|</span><a href="#42151697">next</a><span>|</span><label class="collapse" for="c-42155195">[-]</label><label class="expand" for="c-42155195">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, because using preprocessor macros would do the trick. &#x2F;s</div><br/></div></div></div></div><div id="42151697" class="c"><input type="checkbox" id="c-42151697" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42151249">parent</a><span>|</span><a href="#42153652">prev</a><span>|</span><a href="#42153973">next</a><span>|</span><label class="collapse" for="c-42151697">[-]</label><label class="expand" for="c-42151697">[3 more]</label></div><br/><div class="children"><div class="content">macro programming in Lisp would be &quot;programming programs&quot;.<p>I don&#x27;t see it here. This looks like compile-time execution to compute values. If it would be a macro, it could return source code.</div><br/><div id="42151953" class="c"><input type="checkbox" id="c-42151953" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42151249">root</a><span>|</span><a href="#42151697">parent</a><span>|</span><a href="#42153020">next</a><span>|</span><label class="collapse" for="c-42151953">[-]</label><label class="expand" for="c-42151953">[1 more]</label></div><br/><div class="children"><div class="content">In general, a macro produces code at compile time, doesn&#x27;t matter in which form it ends up in the binary, as long as the observable side effects are the same.<p>Example of a library that generates serialization code, <a href="https:&#x2F;&#x2F;github.com&#x2F;getml&#x2F;reflect-cpp">https:&#x2F;&#x2F;github.com&#x2F;getml&#x2F;reflect-cpp</a><p>As mentioned the ongoing C++26 proposal with produce the desired source code at compile time, thus reducing the amount of code of libraries such that one.</div><br/></div></div><div id="42153020" class="c"><input type="checkbox" id="c-42153020" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#42151249">root</a><span>|</span><a href="#42151697">parent</a><span>|</span><a href="#42151953">prev</a><span>|</span><a href="#42153973">next</a><span>|</span><label class="collapse" for="c-42153020">[-]</label><label class="expand" for="c-42153020">[1 more]</label></div><br/><div class="children"><div class="content">Some people are calling this &quot;multistage programming&quot; [1] which is kind of related but not exactly the same as a macro system.<p>--<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multi-stage_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multi-stage_programming</a></div><br/></div></div></div></div><div id="42153973" class="c"><input type="checkbox" id="c-42153973" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42151249">parent</a><span>|</span><a href="#42151697">prev</a><span>|</span><a href="#42152632">next</a><span>|</span><label class="collapse" for="c-42153973">[-]</label><label class="expand" for="c-42153973">[2 more]</label></div><br/><div class="children"><div class="content">That is not a macro.</div><br/><div id="42155198" class="c"><input type="checkbox" id="c-42155198" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42151249">root</a><span>|</span><a href="#42153973">parent</a><span>|</span><a href="#42152632">next</a><span>|</span><label class="collapse" for="c-42155198">[-]</label><label class="expand" for="c-42155198">[1 more]</label></div><br/><div class="children"><div class="content">I doubt a #define would suffice.</div><br/></div></div></div></div><div id="42154283" class="c"><input type="checkbox" id="c-42154283" checked=""/><div class="controls bullet"><span class="by">signa11</span><span>|</span><a href="#42151249">parent</a><span>|</span><a href="#42152632">prev</a><span>|</span><a href="#42152221">next</a><span>|</span><label class="collapse" for="c-42154283">[-]</label><label class="expand" for="c-42154283">[3 more]</label></div><br/><div class="children"><div class="content">one fundamental difference being that clisp (i keep writing this as &#x27;clips&#x27;, talk about lisp !) does not suffer from precision issues, f.e. writing this<p><pre><code>    [1]&gt; (defmacro factorial (n)
             (labels ((fact (m)
                 (if (= m 0)
                     1
                 (* m (fact (1- m)))))) `,(fact n)))


    [2]&gt; (factorial 1000)</code></pre>
402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<p><pre><code>    [3]&gt;
</code></pre>
works as expected.<p>for the c++ version i don&#x27;t think even `unsigned long long` can accommodate results from larger than approx. 21! or thereabouts.</div><br/><div id="42155203" class="c"><input type="checkbox" id="c-42155203" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42151249">root</a><span>|</span><a href="#42154283">parent</a><span>|</span><a href="#42155095">next</a><span>|</span><label class="collapse" for="c-42155203">[-]</label><label class="expand" for="c-42155203">[1 more]</label></div><br/><div class="children"><div class="content">That is when you would take advantage of C++ type system and use a class implementing multi-precision numbers and operator overloading.</div><br/></div></div><div id="42155095" class="c"><input type="checkbox" id="c-42155095" checked=""/><div class="controls bullet"><span class="by">medo-bear</span><span>|</span><a href="#42151249">root</a><span>|</span><a href="#42154283">parent</a><span>|</span><a href="#42155203">prev</a><span>|</span><a href="#42152221">next</a><span>|</span><label class="collapse" for="c-42155095">[-]</label><label class="expand" for="c-42155095">[1 more]</label></div><br/><div class="children"><div class="content">clisp is an unfortunately named specific implementation of common lisp, like sbcl ecl clasp ccl abcl etc.</div><br/></div></div></div></div></div></div><div id="42152221" class="c"><input type="checkbox" id="c-42152221" checked=""/><div class="controls bullet"><span class="by">thunkingdeep</span><span>|</span><a href="#42151249">prev</a><span>|</span><a href="#42151895">next</a><span>|</span><label class="collapse" for="c-42152221">[-]</label><label class="expand" for="c-42152221">[13 more]</label></div><br/><div class="children"><div class="content">Common misconception of non Lispers that macros are equivalent to compile time programming. You’re not simply moving the evaluation to compile time, you’re moving it upwards outside the program space into a higher dimension of programmability.<p>Not to dog on C++ unfairly, CTE is pretty neat after all.<p>Funnily enough, PGs “On Lisp” has some really neat macros in it that demonstrate capabilities that just can’t be replicated with template based macros, iirc.</div><br/><div id="42152815" class="c"><input type="checkbox" id="c-42152815" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#42152221">parent</a><span>|</span><a href="#42151895">next</a><span>|</span><label class="collapse" for="c-42152815">[-]</label><label class="expand" for="c-42152815">[12 more]</label></div><br/><div class="children"><div class="content">&quot;outside the program space into a higher dimension of programmability&quot;<p>I can visualize this metaphor just fine, but I can&#x27;t tell why it&#x27;s useful. Can you make this concept more concrete?</div><br/><div id="42153780" class="c"><input type="checkbox" id="c-42153780" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42152815">parent</a><span>|</span><a href="#42153468">next</a><span>|</span><label class="collapse" for="c-42153780">[-]</label><label class="expand" for="c-42153780">[1 more]</label></div><br/><div class="children"><div class="content">This is probably not the whole picture, and I have a very Rust-centric view of this, but I&#x27;ll take a stab at it.<p>The correct analogue for Lisp macros is not C++ templates, but the C preprocessor itself. Specifically, a Lisp macro gets to take a particular section of code and change it as it wishes, with everything already conveniently tokenized for the programmer&#x27;s convenience. Imagine if you could just write your own C preprocessor as part of your program and have the compiler automatically execute it on specific program areas that want your preprocessing.<p>Rust macros work similarly to this, the main difference being your syntax needs to be tokenizable as Rust instead of Lisp. But they&#x27;re also rather powerful. So, for example, in Rust you only have one object system which has structs, traits, and very limited higher-kindedness[0]. But there&#x27;s plenty of other object systems Rust would like to interop with: Objective-C, Swift, COM, and C++ among others.<p>The canonical way of doing this in Rust is to write a macro[1] that takes your class definition and converts it into a series of structs, traits, and&#x2F;or function pointers that suitably interop with the foreign code. Code outside the macro then can reference the class created by the system.<p>If you don&#x27;t have macros, your other options are:<p>- Metaclasses, which are the canonical way in Python of doing foreign object interfaces, though with an added wrinkle: multiple inheritance from classes of different metaclasses requires writing a combined metaclass that does both. In macros you usually just can&#x27;t mix them like that, though I doubt you&#x27;d need to define a single class accessible from, say, both Objective-C and Windows COM.<p>- Write your own damned preprocessor. This is what Qt did with MOC (metaobject compiler) to get signals and slots[2]. If C++ had macros, Trolltech probably would have written MOC as a macro instead of a separate build step with a separate C++ tokenizer.<p>[0] A concept which I will not be explaining in this post, but it has to do with things like generic associated types which were needed for lifetime bounds on async traits<p>[1] Usually a &quot;procedural macro&quot;, which is different from the pattern-matching macros Rust usually teaches in ways that don&#x27;t matter here<p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signals_and_slots" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signals_and_slots</a></div><br/></div></div><div id="42153468" class="c"><input type="checkbox" id="c-42153468" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42152815">parent</a><span>|</span><a href="#42153780">prev</a><span>|</span><a href="#42152926">next</a><span>|</span><label class="collapse" for="c-42153468">[-]</label><label class="expand" for="c-42153468">[5 more]</label></div><br/><div class="children"><div class="content">Let’s say, you’re writing a web application. In most programming language you’d be using libraries or rely on a framework. With Lisp macros, you can program the archetype of a web application. And then use a simpler language to describe you application. Think of it as programmable snippets. Something like Ultisnips [0], but inherent to the language.<p>Think how much common code can exist in a software but cannot be refactored to a functions because it will have too many variables. Or the multiple problems with classes tree and overloading. Macros let you solve that.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;SirVer&#x2F;ultisnips">https:&#x2F;&#x2F;github.com&#x2F;SirVer&#x2F;ultisnips</a></div><br/><div id="42153684" class="c"><input type="checkbox" id="c-42153684" checked=""/><div class="controls bullet"><span class="by">ConspiracyFact</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42153468">parent</a><span>|</span><a href="#42153550">next</a><span>|</span><label class="collapse" for="c-42153684">[-]</label><label class="expand" for="c-42153684">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Think how much common code can exist in a software but cannot be refactored to a functions because it will have too many variables.<p>Interesting...can you give an example of a macro that solves this refactoring problem?</div><br/><div id="42153839" class="c"><input type="checkbox" id="c-42153839" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42153684">parent</a><span>|</span><a href="#42153550">next</a><span>|</span><label class="collapse" for="c-42153839">[-]</label><label class="expand" for="c-42153839">[1 more]</label></div><br/><div class="children"><div class="content">One example is the ~use-package~ macro (Emacs plugin) [0]. Using packages in emacs is mostly the same code over and over. They&#x27;ve already been abstracted in functions, but you still find yourself juggling with so many utilities. You could write a bigger functions, but it will then have a lot of conditional branches. This macro selectively select the code it needs and transforming it if needs be and then the result will be evaluated.<p>It&#x27;s a bit hard to explain for me (English is not my native language). But it&#x27;s the difference between coding a solution with all the edge cases baked in and coding an archetype that let you add your own cases. With functions, you abstract common algorithms, with macros you abstract common architecture.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;jwiegley&#x2F;use-package&#x2F;blob&#x2F;a6e856418d2ebd053b34e0ab2fda328abeba731c&#x2F;use-package-core.el#L1614">https:&#x2F;&#x2F;github.com&#x2F;jwiegley&#x2F;use-package&#x2F;blob&#x2F;a6e856418d2ebd0...</a></div><br/></div></div></div></div><div id="42153550" class="c"><input type="checkbox" id="c-42153550" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42153468">parent</a><span>|</span><a href="#42153684">prev</a><span>|</span><a href="#42152926">next</a><span>|</span><label class="collapse" for="c-42153550">[-]</label><label class="expand" for="c-42153550">[2 more]</label></div><br/><div class="children"><div class="content">&gt; cannot be refactored to a functions because it will have too many variables.<p>I&#x27;m skeptical of this. Sounds ugly.</div><br/><div id="42154621" class="c"><input type="checkbox" id="c-42154621" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42153550">parent</a><span>|</span><a href="#42152926">next</a><span>|</span><label class="collapse" for="c-42154621">[-]</label><label class="expand" for="c-42154621">[1 more]</label></div><br/><div class="children"><div class="content">Meaning create a domain specific language for that web app.</div><br/></div></div></div></div></div></div><div id="42152926" class="c"><input type="checkbox" id="c-42152926" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42152815">parent</a><span>|</span><a href="#42153468">prev</a><span>|</span><a href="#42154247">next</a><span>|</span><label class="collapse" for="c-42152926">[-]</label><label class="expand" for="c-42152926">[4 more]</label></div><br/><div class="children"><div class="content">I think an example would be helpful, conditionals:<p>Within the &quot;program dimension&quot; there is just no way to run code conditionally without an if, no matter how much you move left and right, you are constrained. It is only possible by using the &quot;higher dimension&quot;.</div><br/><div id="42153554" class="c"><input type="checkbox" id="c-42153554" checked=""/><div class="controls bullet"><span class="by">nightowl_games</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42152926">parent</a><span>|</span><a href="#42153032">next</a><span>|</span><label class="collapse" for="c-42153554">[-]</label><label class="expand" for="c-42153554">[1 more]</label></div><br/><div class="children"><div class="content">&quot;move left and right&quot;? This meant nothing to me. &#x27;higher dimension&#x27; Still pretty abstract.</div><br/></div></div><div id="42153032" class="c"><input type="checkbox" id="c-42153032" checked=""/><div class="controls bullet"><span class="by">jcul</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42152926">parent</a><span>|</span><a href="#42153554">prev</a><span>|</span><a href="#42154247">next</a><span>|</span><label class="collapse" for="c-42153032">[-]</label><label class="expand" for="c-42153032">[2 more]</label></div><br/><div class="children"><div class="content">This is different from constexpr if in C++? Where one branch will not exist in the compiled code?</div><br/><div id="42153507" class="c"><input type="checkbox" id="c-42153507" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42153032">parent</a><span>|</span><a href="#42154247">next</a><span>|</span><label class="collapse" for="c-42153507">[-]</label><label class="expand" for="c-42153507">[1 more]</label></div><br/><div class="children"><div class="content">Lisp macros take zero [0] or more unevaluated forms, does something with them (which may be computing a value, see the factorial example elsewhere in this discussion and the submitted blog), and then returns a new form (which could be that computed value, again see the factorial example) which the Lisp system evaluates eventually.<p>One way to see this would be to do something like:<p><pre><code>  (defmacro print-value (a) (print a) a)
  (print (print-value 1))
  (print (print-value (+ 1 2))
  ;; output
  1
  1
  (+ 1 2)
  3
</code></pre>
<a href="https:&#x2F;&#x2F;tio.run&#x2F;##S87JLC74&#x2F;18jJTUtNzG5KF@hoCgzr0S3LDGnNFVBI1FTQQMsoABkJWpycUF5GsiqDDU1sYpraCsYKhhpamr@&#x2F;w8A" rel="nofollow">https:&#x2F;&#x2F;tio.run&#x2F;##S87JLC74&#x2F;18jJTUtNzG5KF@hoCgzr0S3LDGnNFVBI1...</a><p>The value bound to a inside the macro is the unevaluated form (the first and third items printed out). In this case the macro itself is just the identity macro other than its print effect so it returns the original form, which is why we get 1 and 3 printed as well.<p>Here&#x27;s an example of processing (very primitive) the unevaluated form to produce something new:<p><pre><code>  (defmacro infix (a op b)
    `(,op ,a ,b)) ;; alternatively: (list op a b)
  (print (infix 10 + 20))
  ;; output
  30
</code></pre>
Now we can get fancy (this is primitive still, but works):<p><a href="https:&#x2F;&#x2F;tio.run&#x2F;##fZDBDoMgEETvfsXculh7qP2hImJKSpUgSf17uiqJ1Vr3QMjbmVkWZU3vYqRaNy@pfAfTNmYA6cF5kQFkZaVtD6K3tM@Fb4pU19a&#x2F;mBvEA4LD5MOdCur1qE2gSLGN8X2Y2QLDw&#x2F;gk5NpND@v2bEwoI@dNG0DTYgwljz1RWrBEjpv4lm0ax3aJM6qV3Wo@mF8FqELJe&#x2F;zX7kayLocSLGb&#x2F;hW@H8fzl4zNx6I7xAw" rel="nofollow">https:&#x2F;&#x2F;tio.run&#x2F;##fZDBDoMgEETvfsXculh7qP2hImJKSpUgSf17uiqJ1V...</a><p><pre><code>  (defmacro infix (expr)
    (labels ((walk (expr)
                   (cond
                     ((listp expr) `(,(second expr) ,(walk (first expr)) ,(walk (third expr))))
                     (t expr))))
      (walk expr)))
</code></pre>
This generates a valid (prefix notation) lisp form from a more traditional infix form from mathematics. If I were being more clever I wouldn&#x27;t use the second item in the list (the operation) directly but restrict it to valid arithmetic operators and change how I walk the structure. That would remove the need to force explicit parentheses since I could add in a proper parsing step. This is a very primitive version of what loop and other complex macros do. They take essentially a different language, parse it, and emit a valid Lisp form which is then evaluated.<p>You could use this to get constexpr like behavior but once you do that you run into problems, you can&#x27;t do this for example:<p><pre><code>  (defmacro foo (a b) (+ a b))
  (foo (+ 1 2) (+ 3 4)) ;; error
  (let ((a 1) (b 2)) (foo a b)) ;; error
  (foo 1 2) ;; =&gt; 3
</code></pre>
It only partially works because it only works, when a and b are both numbers. If they&#x27;re symbols (second case) or other forms (first case) then the macro attempts to compute something that cannot be computed. You can fix the first case by doing:<p><pre><code>  (defmacro foo (a b) (+ (eval a) (eval b))
</code></pre>
But that still leaves the second case erroring out. You could do something like what I did with infix which walks the forms and determines if they can be evaluated (no unbound variables) and then evaluate them conditionally, leaving expressions with unbound symbols intact to be processed later.<p>So C++ constexprs are less than Lisp macros, but if you want to use Lisp macros to do the same thing as constexprs you have to do more work. Check out <i>On Lisp</i> and <i>Let Over Lambda</i> for two books that go deep into macros in Common Lisp.<p>[0] I honestly don&#x27;t know why you&#x27;d want to do this, but technically it&#x27;s valid to do:<p><pre><code>  (defmacro foo () (some form to return))
  (macroexpand &#x27;(foo))
  ;; =&gt; (some form to return)
</code></pre>
I cannot think of a case where this would be useful, but someone else might think of one.</div><br/></div></div></div></div></div></div><div id="42154247" class="c"><input type="checkbox" id="c-42154247" checked=""/><div class="controls bullet"><span class="by">stackghost</span><span>|</span><a href="#42152221">root</a><span>|</span><a href="#42152815">parent</a><span>|</span><a href="#42152926">prev</a><span>|</span><a href="#42151895">next</a><span>|</span><label class="collapse" for="c-42154247">[-]</label><label class="expand" for="c-42154247">[1 more]</label></div><br/><div class="children"><div class="content">You can give the language new features, using the features that the language provides.</div><br/></div></div></div></div></div></div><div id="42151895" class="c"><input type="checkbox" id="c-42151895" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#42152221">prev</a><span>|</span><a href="#42150870">next</a><span>|</span><label class="collapse" for="c-42151895">[-]</label><label class="expand" for="c-42151895">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    (defmacro factorial (n)
      (labels ((fact (m)
                 (if (= m 0)
                     1
                     (* m (fact (1- m))))))
        `,(fact n)))
</code></pre>
The `, has no use here and can be removed. Here the backquote and the evaluation just returns the computed value.<p>Thus, this is okay:<p><pre><code>    (defmacro factorial (n)
      (labels ((fact (m)
                 (if (= m 0)
                     1
                     (* m (fact (1- m))))))
        (fact n)))
</code></pre>
LABELS defines local recursive functions. The macro returns the result of calling FACT, which is a number and which is a valid <i>form</i> in Common Lisp. A number evaluates to itself.<p><pre><code>    CL-USER &gt; (macroexpand-1 &#x27;(factorial 10))
    3628800
    T</code></pre></div><br/></div></div><div id="42150870" class="c"><input type="checkbox" id="c-42150870" checked=""/><div class="controls bullet"><span class="by">scott_s</span><span>|</span><a href="#42151895">prev</a><span>|</span><a href="#42154463">next</a><span>|</span><label class="collapse" for="c-42150870">[-]</label><label class="expand" for="c-42150870">[3 more]</label></div><br/><div class="children"><div class="content">Agreed with the technical content and conclusion. However, I think it is worth pointing out that since C++11, it has had a mechanism to specify (maybe) compile-time computations that are written in plain C++:  constexpr, <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;constexpr" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;constexpr</a><p>(My parenthetical &quot;maybe&quot; is that I don&#x27;t think compilers <i>have</i> to compute constexpr expressions at compile time. The compiler will be forced to when such expressions are used in contexts that require values at compile time. But I think it would be permissible for a compile to defer computation of a constexpr to runtime if the value isn&#x27;t needed until runtime.)</div><br/><div id="42151035" class="c"><input type="checkbox" id="c-42151035" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#42150870">parent</a><span>|</span><a href="#42151149">next</a><span>|</span><label class="collapse" for="c-42151035">[-]</label><label class="expand" for="c-42151035">[1 more]</label></div><br/><div class="children"><div class="content">Note that C++20 introduced <i>consteval</i> as a means to enforce compile time computation. See <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;consteval" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;consteval</a></div><br/></div></div><div id="42151149" class="c"><input type="checkbox" id="c-42151149" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42150870">parent</a><span>|</span><a href="#42151035">prev</a><span>|</span><a href="#42154463">next</a><span>|</span><label class="collapse" for="c-42151149">[-]</label><label class="expand" for="c-42151149">[1 more]</label></div><br/><div class="children"><div class="content">Besides consteval and constinit, you can force evaluation with static constexpr.</div><br/></div></div></div></div><div id="42154463" class="c"><input type="checkbox" id="c-42154463" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42150870">prev</a><span>|</span><a href="#42154300">next</a><span>|</span><label class="collapse" for="c-42154463">[-]</label><label class="expand" for="c-42154463">[1 more]</label></div><br/><div class="children"><div class="content">It’s clumsy because C++ templates are an implementation of generic and dependent types, while C++ constexpr and consteval functions are for arbitrary computation.  The fact that template metaprogramming _can_ be used for arbitrary computation is actually an unhappy accident of its design that was only proven after its publication.</div><br/></div></div><div id="42154300" class="c"><input type="checkbox" id="c-42154300" checked=""/><div class="controls bullet"><span class="by">rottc0dd</span><span>|</span><a href="#42154463">prev</a><span>|</span><a href="#42150712">next</a><span>|</span><label class="collapse" for="c-42154300">[-]</label><label class="expand" for="c-42154300">[1 more]</label></div><br/><div class="children"><div class="content">Another post comparing C and lisp Macros: <a href="http:&#x2F;&#x2F;lists.warhead.org.uk&#x2F;pipermail&#x2F;iwe&#x2F;2005-July&#x2F;000130.html" rel="nofollow">http:&#x2F;&#x2F;lists.warhead.org.uk&#x2F;pipermail&#x2F;iwe&#x2F;2005-July&#x2F;000130.h...</a><p>HN discussion: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31199992">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31199992</a></div><br/></div></div><div id="42150712" class="c"><input type="checkbox" id="c-42150712" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42154300">prev</a><span>|</span><a href="#42152631">next</a><span>|</span><label class="collapse" for="c-42150712">[-]</label><label class="expand" for="c-42150712">[8 more]</label></div><br/><div class="children"><div class="content">Lisp macros can take arbitrary parameters and are written in lisp.<p>C++ macros can only take types and numbers (until variadic), and writing any code to operate on those inputs is challenging.</div><br/><div id="42151117" class="c"><input type="checkbox" id="c-42151117" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#42150712">parent</a><span>|</span><a href="#42150840">next</a><span>|</span><label class="collapse" for="c-42151117">[-]</label><label class="expand" for="c-42151117">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;knome&#x2F;metabrainfuck&#x2F;blob&#x2F;master&#x2F;bf.cpp">https:&#x2F;&#x2F;github.com&#x2F;knome&#x2F;metabrainfuck&#x2F;blob&#x2F;master&#x2F;bf.cpp</a><p>It&#x27;s not too bad :)</div><br/><div id="42151493" class="c"><input type="checkbox" id="c-42151493" checked=""/><div class="controls bullet"><span class="by">Etheryte</span><span>|</span><a href="#42150712">root</a><span>|</span><a href="#42151117">parent</a><span>|</span><a href="#42152547">next</a><span>|</span><label class="collapse" for="c-42151493">[-]</label><label class="expand" for="c-42151493">[1 more]</label></div><br/><div class="children"><div class="content">As a code golfer, this is beyond satisfying. Doing things in a few bytes is nice, yes, but doing them in a way no reasonable mortal ever would is even better.</div><br/></div></div><div id="42152547" class="c"><input type="checkbox" id="c-42152547" checked=""/><div class="controls bullet"><span class="by">liontwist</span><span>|</span><a href="#42150712">root</a><span>|</span><a href="#42151117">parent</a><span>|</span><a href="#42151493">prev</a><span>|</span><a href="#42150840">next</a><span>|</span><label class="collapse" for="c-42152547">[-]</label><label class="expand" for="c-42152547">[1 more]</label></div><br/><div class="children"><div class="content">There is the lisp meme “mom can we have defmacro? No we have defmacro at home”</div><br/></div></div></div></div><div id="42150840" class="c"><input type="checkbox" id="c-42150840" checked=""/><div class="controls bullet"><span class="by">spacechild1</span><span>|</span><a href="#42150712">parent</a><span>|</span><a href="#42151117">prev</a><span>|</span><a href="#42154445">next</a><span>|</span><label class="collapse" for="c-42150840">[-]</label><label class="expand" for="c-42150840">[1 more]</label></div><br/><div class="children"><div class="content">The post is actually about template <i>meta</i>programming. &#x27;template macroprogramming&#x27; isn&#x27;t really a thing.</div><br/></div></div><div id="42154445" class="c"><input type="checkbox" id="c-42154445" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42150712">parent</a><span>|</span><a href="#42150840">prev</a><span>|</span><a href="#42153182">next</a><span>|</span><label class="collapse" for="c-42154445">[-]</label><label class="expand" for="c-42154445">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the purpose of C++ templates (not macros, macros are C preprocessor) is to implement generic classes and functions, not to implement arbitrary computation, and (iirc) it was only discovered after their publication that they are in fact Turing-complete.</div><br/></div></div><div id="42153182" class="c"><input type="checkbox" id="c-42153182" checked=""/><div class="controls bullet"><span class="by">dataangel</span><span>|</span><a href="#42150712">parent</a><span>|</span><a href="#42154445">prev</a><span>|</span><a href="#42152631">next</a><span>|</span><label class="collapse" for="c-42153182">[-]</label><label class="expand" for="c-42153182">[2 more]</label></div><br/><div class="children"><div class="content">C++ templates can also take other C++ templates (the template itself, not just an instantiation), enum values and I think in C++23 maybe even structs but I need to check</div><br/><div id="42153560" class="c"><input type="checkbox" id="c-42153560" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#42150712">root</a><span>|</span><a href="#42153182">parent</a><span>|</span><a href="#42152631">next</a><span>|</span><label class="collapse" for="c-42153560">[-]</label><label class="expand" for="c-42153560">[1 more]</label></div><br/><div class="children"><div class="content">C++20 added the ability to take class instances as non-type parameters but the rules around the types of classes that can be used in this way are pretty restrictive (for good reason).</div><br/></div></div></div></div></div></div><div id="42152631" class="c"><input type="checkbox" id="c-42152631" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#42150712">prev</a><span>|</span><a href="#42152193">next</a><span>|</span><label class="collapse" for="c-42152631">[-]</label><label class="expand" for="c-42152631">[2 more]</label></div><br/><div class="children"><div class="content">Does this article have a (2002) that I missed or something?</div><br/><div id="42153978" class="c"><input type="checkbox" id="c-42153978" checked=""/><div class="controls bullet"><span class="by">andyg_blog</span><span>|</span><a href="#42152631">parent</a><span>|</span><a href="#42152193">next</a><span>|</span><label class="collapse" for="c-42153978">[-]</label><label class="expand" for="c-42153978">[1 more]</label></div><br/><div class="children"><div class="content">I hate to agree. For an article about metaprogramming in C++, you&#x27;d expect expert level C++ code, and not what&#x27;s presented here. It&#x27;s bad. And the first example with the list even has a bug.</div><br/></div></div></div></div><div id="42152193" class="c"><input type="checkbox" id="c-42152193" checked=""/><div class="controls bullet"><span class="by">James_K</span><span>|</span><a href="#42152631">prev</a><span>|</span><a href="#42153619">next</a><span>|</span><label class="collapse" for="c-42152193">[-]</label><label class="expand" for="c-42152193">[1 more]</label></div><br/><div class="children"><div class="content">Macaroni art versus the Mona Lisa.</div><br/></div></div><div id="42153619" class="c"><input type="checkbox" id="c-42153619" checked=""/><div class="controls bullet"><span class="by">mwkaufma</span><span>|</span><a href="#42152193">prev</a><span>|</span><a href="#42155126">next</a><span>|</span><label class="collapse" for="c-42153619">[-]</label><label class="expand" for="c-42153619">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;next&quot; field in the lead code sample is supposed to be a pointer, right?</div><br/></div></div><div id="42155126" class="c"><input type="checkbox" id="c-42155126" checked=""/><div class="controls bullet"><span class="by">anothername12</span><span>|</span><a href="#42153619">prev</a><span>|</span><a href="#42151474">next</a><span>|</span><label class="collapse" for="c-42155126">[-]</label><label class="expand" for="c-42155126">[1 more]</label></div><br/><div class="children"><div class="content">Pffft, I’d just #. that factorial call and it’d be a normal defun.</div><br/></div></div><div id="42151474" class="c"><input type="checkbox" id="c-42151474" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42155126">prev</a><span>|</span><a href="#42151941">next</a><span>|</span><label class="collapse" for="c-42151474">[-]</label><label class="expand" for="c-42151474">[5 more]</label></div><br/><div class="children"><div class="content">I don’t have any experience with Lisp. But I think C++ templates and Rust macros are both super bad and impoverished compared to what can be done in Jai.<p><a href="https:&#x2F;&#x2F;www.forrestthewoods.com&#x2F;blog&#x2F;using-jais-unique-and-powerful-compiler-for-typesafe-units&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.forrestthewoods.com&#x2F;blog&#x2F;using-jais-unique-and-p...</a></div><br/><div id="42151960" class="c"><input type="checkbox" id="c-42151960" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42151474">parent</a><span>|</span><a href="#42151606">next</a><span>|</span><label class="collapse" for="c-42151960">[-]</label><label class="expand" for="c-42151960">[3 more]</label></div><br/><div class="children"><div class="content">Except Jai is never going to get the use any of them have, so we use what is there.</div><br/><div id="42153347" class="c"><input type="checkbox" id="c-42153347" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#42151474">root</a><span>|</span><a href="#42151960">parent</a><span>|</span><a href="#42151606">next</a><span>|</span><label class="collapse" for="c-42153347">[-]</label><label class="expand" for="c-42153347">[2 more]</label></div><br/><div class="children"><div class="content">That is not a coherent sentence.<p>I share it not to say “use Jai instead of C++&#x2F;Rust”. But to instead say “templates and macros suck and it’d be great if Rust or other language copied good ideas into their ecosystem”.</div><br/><div id="42155191" class="c"><input type="checkbox" id="c-42155191" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42151474">root</a><span>|</span><a href="#42153347">parent</a><span>|</span><a href="#42151606">next</a><span>|</span><label class="collapse" for="c-42155191">[-]</label><label class="expand" for="c-42155191">[1 more]</label></div><br/><div class="children"><div class="content">First we need to be able to use Jai, so that those folks can validate in practice how it works, not watching videos about someone using their creation.</div><br/></div></div></div></div></div></div><div id="42151606" class="c"><input type="checkbox" id="c-42151606" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42151474">parent</a><span>|</span><a href="#42151960">prev</a><span>|</span><a href="#42151941">next</a><span>|</span><label class="collapse" for="c-42151606">[-]</label><label class="expand" for="c-42151606">[1 more]</label></div><br/><div class="children"><div class="content">The `#modify` thing looks pretty cool, but I can&#x27;t help but think how a compiler&#x2F;ide is supposed to analyze the body of such function and provide suggestions. Rust macros have a similar issue, but it&#x27;s offsetted by the fact that generics are pretty powerful too and can be fully analyzed by the compiler.</div><br/></div></div></div></div></div></div></div></div></div></body></html>