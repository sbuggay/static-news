<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731315674157" as="style"/><link rel="stylesheet" href="styles.css?v=1731315674157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/WebAssembly/memory64/blob/main/proposals/memory64/Overview.md">Memory64</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>tosh</span> | <span>32 comments</span></div><br/><div><div id="42103092" class="c"><input type="checkbox" id="c-42103092" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#42104774">next</a><span>|</span><label class="collapse" for="c-42103092">[-]</label><label class="expand" for="c-42103092">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious to see what the performance impact of using 64bit memory ends up being. WASM runtimes currently use a clever trick on 64bit host platforms where they allocate a solid 4GB block of virtual memory up front, and then rely on the MMU to catch out-of-bounds accesses by faulting on unmapped pages, so bounds checking is effectively free. That won&#x27;t work with 64bit WASM though so runtimes will have to do old fashioned explicit bounds checking on every single heap access.</div><br/><div id="42103180" class="c"><input type="checkbox" id="c-42103180" checked=""/><div class="controls bullet"><span class="by">pstoll</span><span>|</span><a href="#42103092">parent</a><span>|</span><a href="#42103401">next</a><span>|</span><label class="collapse" for="c-42103180">[-]</label><label class="expand" for="c-42103180">[3 more]</label></div><br/><div class="children"><div class="content">I also wonder what the perf overhead will be for programs that only need i32. I didn’t dig deep enough on the implementation, but these type of variadic runtime options often cause perf regressions because of all the “ifs” &#x2F; lookups of type configs&#x2F;parameters, etc. I just imagine some inner loops where mem.get adds a few instructions from the “if u32&#x2F;64&#x2F;“.<p>Unless it ends up being seamless &#x2F; no cost via loading different u32&#x2F;u64 implementations.<p>I mostly agree with the old c++ mantra of - no feature should have a runtime cost unless used.</div><br/><div id="42103228" class="c"><input type="checkbox" id="c-42103228" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#42103092">root</a><span>|</span><a href="#42103180">parent</a><span>|</span><a href="#42103401">next</a><span>|</span><label class="collapse" for="c-42103228">[-]</label><label class="expand" for="c-42103228">[2 more]</label></div><br/><div class="children"><div class="content">I would hope it&#x27;s set up such that the runtime always knows whether a memory access is 32bit or 64bit at JIT-time so it can generate unconditional native code. Runtimes that use an interpreter instead of a JIT might be hurt by having to branch every time, but interpreters being slow is already kind of a given.</div><br/><div id="42103634" class="c"><input type="checkbox" id="c-42103634" checked=""/><div class="controls bullet"><span class="by">cornstalks</span><span>|</span><a href="#42103092">root</a><span>|</span><a href="#42103228">parent</a><span>|</span><a href="#42103401">next</a><span>|</span><label class="collapse" for="c-42103634">[-]</label><label class="expand" for="c-42103634">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the bitcode specifies whether a memory operation&#x2F;address uses 32-bit or 64-bit addressing, so a runtime&#x2F;JIT can determine this ahead of time during the static analysis phase.</div><br/></div></div></div></div></div></div><div id="42103401" class="c"><input type="checkbox" id="c-42103401" checked=""/><div class="controls bullet"><span class="by">wild_pointer</span><span>|</span><a href="#42103092">parent</a><span>|</span><a href="#42103180">prev</a><span>|</span><a href="#42104774">next</a><span>|</span><label class="collapse" for="c-42103401">[-]</label><label class="expand" for="c-42103401">[5 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t the same trick be used for slightly more bits? 64-bit uses 48 bits nowadays AFAIK, which is 256 TB. It&#x27;s usually 50&#x2F;50 for user&#x2F;kernel mode. If, say, WASM takes half of the user mode address space, it&#x27;s still 46 bits which is 64 TB (ought to be enough for anybody?). Or maybe I&#x27;m way off, I don&#x27;t really know the specifics of the trick you&#x27;re referring to.</div><br/><div id="42104194" class="c"><input type="checkbox" id="c-42104194" checked=""/><div class="controls bullet"><span class="by">Findecanor</span><span>|</span><a href="#42103092">root</a><span>|</span><a href="#42103401">parent</a><span>|</span><a href="#42103435">next</a><span>|</span><label class="collapse" for="c-42104194">[-]</label><label class="expand" for="c-42104194">[3 more]</label></div><br/><div class="children"><div class="content">The trick takes advantage of 32-bit registers automatically being zero-extended to 64.
It actually uses 8GB of allocated address space because WASM&#x27;s address mode takes both a &quot;pointer&quot; and a 32-bit offset, making the effective index 33 bits. On x86-64, there are address modes that can add those and the base address in a single instruction.<p>When that trick can&#x27;t be used, I think the most efficient method would be to clamp the top of the address so that the max would land on a single guard page.
On x86-64 and ARM that would be done with a `cmp`and a conditional move. RISC-V (RVA22 profile and up) has a `max` instruction. That would be typically one additional cycle.<p>The new proposal is for using a 64-bit pointer and a 64-bit offset, which would create a 65-bit effective index.
So neither method above could be used. I think each address calculation would first have to add and check for overflow, <i>then</i> do the bounds-check, and <i>then</i> add the base address to the linear memory.</div><br/><div id="42105149" class="c"><input type="checkbox" id="c-42105149" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42103092">root</a><span>|</span><a href="#42104194">parent</a><span>|</span><a href="#42105140">prev</a><span>|</span><a href="#42103435">next</a><span>|</span><label class="collapse" for="c-42105149">[-]</label><label class="expand" for="c-42105149">[1 more]</label></div><br/><div class="children"><div class="content">A saturating add instruction could help do the same trick without checking for overflows first, although they seem fairly uncommon outside of SIMD instruction sets (aarch64 has UQADD for example)</div><br/></div></div></div></div><div id="42103435" class="c"><input type="checkbox" id="c-42103435" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#42103092">root</a><span>|</span><a href="#42103401">parent</a><span>|</span><a href="#42104194">prev</a><span>|</span><a href="#42104774">next</a><span>|</span><label class="collapse" for="c-42103435">[-]</label><label class="expand" for="c-42103435">[1 more]</label></div><br/><div class="children"><div class="content">The problem is you need the virtual memory allocation to span every possible address the untrusted WASM code might try to access, so that any possible OOB operation lands in an unmapped page and triggers a fault. That&#x27;s only feasible if the WASM address space is a lot smaller than the host address space.<p>I suppose there might be a compromise where you cap a 64bit WASM instance to (for example) an effective 35bit address space, allocate 32GB of virtual memory and then generate code which masks off the top bits of pointers so OOB operations safely wrap around without having to branch, but I&#x27;m not sure if the spec allows that. IIRC illegal operations are <i>required</i> to throw an exception.</div><br/></div></div></div></div></div></div><div id="42104774" class="c"><input type="checkbox" id="c-42104774" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#42103092">prev</a><span>|</span><a href="#42104688">next</a><span>|</span><label class="collapse" for="c-42104774">[-]</label><label class="expand" for="c-42104774">[3 more]</label></div><br/><div class="children"><div class="content">Is there movement on allowing larger memory usage for JS in browsers too? It&#x27;s pretty limiting in some cases, say if you want to open a large file locally.</div><br/><div id="42104809" class="c"><input type="checkbox" id="c-42104809" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#42104774">parent</a><span>|</span><a href="#42104688">next</a><span>|</span><label class="collapse" for="c-42104809">[-]</label><label class="expand" for="c-42104809">[2 more]</label></div><br/><div class="children"><div class="content">You can open a large file using a File or Blob, which do not store all the data in memory at once. Then you can read slices from it. That even works synchronously, in Workers:<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;FileReaderSync" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;FileReaderS...</a></div><br/><div id="42104838" class="c"><input type="checkbox" id="c-42104838" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#42104774">root</a><span>|</span><a href="#42104809">parent</a><span>|</span><a href="#42104688">next</a><span>|</span><label class="collapse" for="c-42104838">[-]</label><label class="expand" for="c-42104838">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I have done this. But sometimes you need a large chunk of data in memory and things get dicey quickly.</div><br/></div></div></div></div></div></div><div id="42104688" class="c"><input type="checkbox" id="c-42104688" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#42104774">prev</a><span>|</span><a href="#42102894">next</a><span>|</span><label class="collapse" for="c-42104688">[-]</label><label class="expand" for="c-42104688">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Safari: ?<p>What an understatement.</div><br/></div></div><div id="42102894" class="c"><input type="checkbox" id="c-42102894" checked=""/><div class="controls bullet"><span class="by">lahcim2000</span><span>|</span><a href="#42104688">prev</a><span>|</span><label class="collapse" for="c-42102894">[-]</label><label class="expand" for="c-42102894">[18 more]</label></div><br/><div class="children"><div class="content">32GB in single browser window running web assembly...<p>Why would you ever want to go above this? What is your scenario?</div><br/><div id="42102957" class="c"><input type="checkbox" id="c-42102957" checked=""/><div class="controls bullet"><span class="by">umvi</span><span>|</span><a href="#42102894">parent</a><span>|</span><a href="#42103274">next</a><span>|</span><label class="collapse" for="c-42102957">[-]</label><label class="expand" for="c-42102957">[2 more]</label></div><br/><div class="children"><div class="content">32-bit memory addressing means you only have 4GB, not 32GB.<p>The company I current work for makes radiotherapy software. Most of our native apps run in clinics under .NET.<p>There are some cases where we want users or employees to be able to access our radiotherapy tooling from a browser. Microsoft has a pretty phenomenal .NET -&gt; WASM compiler. We can compile our .NET DICOM image viewer tooling to WASM, for example, and it is more performant and full-featured than Cornerstone.js (<a href="https:&#x2F;&#x2F;www.cornerstonejs.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cornerstonejs.org&#x2F;</a>).<p>However, medical imagery is memory heavy. We frequently run into the 4GB limit, especially if the CT&#x2F;MR image uses 32-bit voxels instead of 16-bit voxels. Or if the field of view was resized. Or if we accidentally introduce an extra image copy in memory.</div><br/><div id="42104671" class="c"><input type="checkbox" id="c-42104671" checked=""/><div class="controls bullet"><span class="by">azakai</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42102957">parent</a><span>|</span><a href="#42103274">next</a><span>|</span><label class="collapse" for="c-42104671">[-]</label><label class="expand" for="c-42104671">[1 more]</label></div><br/><div class="children"><div class="content">A related example is image editing software like Adobe Photoshop on the Web. Large images can require more then 4GB in many cases.</div><br/></div></div></div></div><div id="42103274" class="c"><input type="checkbox" id="c-42103274" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#42102894">parent</a><span>|</span><a href="#42102957">prev</a><span>|</span><a href="#42102917">next</a><span>|</span><label class="collapse" for="c-42103274">[-]</label><label class="expand" for="c-42103274">[2 more]</label></div><br/><div class="children"><div class="content">You can compile most anything to webassembly. I believe Unreal Engine supports it.<p>So no reason why a big game with fancy graphics and lots of textures couldn&#x27;t use it.</div><br/></div></div><div id="42102917" class="c"><input type="checkbox" id="c-42102917" checked=""/><div class="controls bullet"><span class="by">dagmx</span><span>|</span><a href="#42102894">parent</a><span>|</span><a href="#42103274">prev</a><span>|</span><a href="#42103600">next</a><span>|</span><label class="collapse" for="c-42102917">[-]</label><label class="expand" for="c-42102917">[3 more]</label></div><br/><div class="children"><div class="content">I agree that wanting to have more than 32bits of addressable space (not 32GB of memory) in a web app seems excessive.<p>However the real win is the ability to use 64 bit types more easily, if for nothing else other than it simplifies making wasm ports of desktop libraries.</div><br/><div id="42103485" class="c"><input type="checkbox" id="c-42103485" checked=""/><div class="controls bullet"><span class="by">CryZe</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42102917">parent</a><span>|</span><a href="#42103600">next</a><span>|</span><label class="collapse" for="c-42103485">[-]</label><label class="expand" for="c-42103485">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ability to use 64 bit types more easily<p>Those are available on wasm32 just the same.</div><br/><div id="42104045" class="c"><input type="checkbox" id="c-42104045" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42103485">parent</a><span>|</span><a href="#42103600">next</a><span>|</span><label class="collapse" for="c-42104045">[-]</label><label class="expand" for="c-42104045">[1 more]</label></div><br/><div class="children"><div class="content">It goes beyond that. Many languages expect that you use types such as size_t or usize for things that are conceptually collection sizes, array offsets, and similar things. In some applications, it&#x27;s common that the conceptual collection is larger than 2^32 while using relatively little memory. For example, you could have a sparse set of integers or a set of disjoint intervals in a universe of size 2^40. In a 64-bit environment, you can safely mix 64-bit types and idiomatic interfaces using size_t &#x2F; usize. In a 32-bit environment, most things using those types (including the standard library) become footguns.<p>I work in bioinformatics. A couple of times a year I check if browsers finally support Memory64 by default. They don&#x27;t, and I conclude that Wasm is still irrelevant to my work. I no longer remember how long I&#x27;ve been doing that. Cross-platform applications running in a browser would be convenient for many purposes, but the technology is not ready for that.</div><br/></div></div></div></div></div></div><div id="42103600" class="c"><input type="checkbox" id="c-42103600" checked=""/><div class="controls bullet"><span class="by">peutetre</span><span>|</span><a href="#42102894">parent</a><span>|</span><a href="#42102917">prev</a><span>|</span><a href="#42103339">next</a><span>|</span><label class="collapse" for="c-42103600">[-]</label><label class="expand" for="c-42103600">[3 more]</label></div><br/><div class="children"><div class="content">WebAssembly doesn&#x27;t only apply to the browser. It will also be used server side and in applications other than browsers.</div><br/><div id="42105377" class="c"><input type="checkbox" id="c-42105377" checked=""/><div class="controls bullet"><span class="by">eapriv</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42103600">parent</a><span>|</span><a href="#42103339">next</a><span>|</span><label class="collapse" for="c-42105377">[-]</label><label class="expand" for="c-42105377">[2 more]</label></div><br/><div class="children"><div class="content">Why would anyone do that?</div><br/><div id="42105420" class="c"><input type="checkbox" id="c-42105420" checked=""/><div class="controls bullet"><span class="by">peutetre</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42105377">parent</a><span>|</span><a href="#42103339">next</a><span>|</span><label class="collapse" for="c-42105420">[-]</label><label class="expand" for="c-42105420">[1 more]</label></div><br/><div class="children"><div class="content">Because they want to run arbitrary code in a sandboxed environment with well defined interfaces.</div><br/></div></div></div></div></div></div><div id="42103339" class="c"><input type="checkbox" id="c-42103339" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42102894">parent</a><span>|</span><a href="#42103600">prev</a><span>|</span><a href="#42104035">next</a><span>|</span><label class="collapse" for="c-42103339">[-]</label><label class="expand" for="c-42103339">[3 more]</label></div><br/><div class="children"><div class="content">Some of us are trying to convince the Node team that pointer compression should be on by default. If you need more than 4G per isolate you&#x27;re probably doing something wrong that you shouldn&#x27;t be doing in Node. With compression it&#x27;s not actually 4GB, it&#x27;s k * 4GB.<p>Java pointer compression promises up to 32GB of heap with 32 bit pointers, for instance.</div><br/><div id="42103549" class="c"><input type="checkbox" id="c-42103549" checked=""/><div class="controls bullet"><span class="by">felipellrocha</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42103339">parent</a><span>|</span><a href="#42104035">next</a><span>|</span><label class="collapse" for="c-42103549">[-]</label><label class="expand" for="c-42103549">[2 more]</label></div><br/><div class="children"><div class="content">Wait, how does that work?</div><br/><div id="42103607" class="c"><input type="checkbox" id="c-42103607" checked=""/><div class="controls bullet"><span class="by">tzot</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42103549">parent</a><span>|</span><a href="#42104035">next</a><span>|</span><label class="collapse" for="c-42103607">[-]</label><label class="expand" for="c-42103607">[1 more]</label></div><br/><div class="children"><div class="content">Think<p><pre><code>    uint64_t buffer[1&lt;&lt;32];
</code></pre>
and your “pointers” are indexes to that array:<p><pre><code>    (void*)(buffer+index)</code></pre></div><br/></div></div></div></div></div></div><div id="42104035" class="c"><input type="checkbox" id="c-42104035" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#42102894">parent</a><span>|</span><a href="#42103339">prev</a><span>|</span><label class="collapse" for="c-42104035">[-]</label><label class="expand" for="c-42104035">[4 more]</label></div><br/><div class="children"><div class="content">Look son, the only way we&#x27;re gonna get anything done is abstracting the abstractions so we can actually get some abstracted code running on the abstracted abstractions. That means we need 128 gallonbytes of abstracted neural silicon to fit all our abstracted abstractions written by our very best abstracted intelligences.<p>In other words: JavaShit ho!</div><br/><div id="42104595" class="c"><input type="checkbox" id="c-42104595" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42104035">parent</a><span>|</span><label class="collapse" for="c-42104595">[-]</label><label class="expand" for="c-42104595">[3 more]</label></div><br/><div class="children"><div class="content">The web took off because cross compiling sucks.<p>Change my mind.</div><br/><div id="42104635" class="c"><input type="checkbox" id="c-42104635" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42104595">parent</a><span>|</span><label class="collapse" for="c-42104635">[-]</label><label class="expand" for="c-42104635">[2 more]</label></div><br/><div class="children"><div class="content">Then why didn&#x27;t Java do better? Its tagline was write once, run everywhere.<p>I remember back in the day setting up cross compiling was horrendous though, so I agree, I just don&#x27;t think it&#x27;s the only reason. These days all you do is set a flag and rerun &quot;go build&quot;, it&#x27;s stupidly easy, as far as <i>compiling</i> goes.<p>The other two things that come to mind is that on the web users expect things to look different, so the fact that your cross compiled app looked&#x2F;behaved like ass on at least one platform unless you basically rewrote the front end to conform to each platforms user interface guidelines (aka write once, rewrite everywhere), meant that websites could look more how the company making the website wanted it to look, and less like how Redmond or Cupertino-bases companies wanted it to look.<p>The real killer feature though, imo, was upgrading of software. Customer support is a big expense that ends up sinking developer time, and if you got bug reports and you fixed the problem, you&#x27;d keep getting bug reports for that issue and the CS team would have to figure out which version the customer is on, buried three menus deep, before getting them to upgrade. The website,
however is basically always running the latest version, so no more wasting everyone&#x27;s time with an old install on a customer&#x27;s computer. And they showed up in metrics for management to see.</div><br/><div id="42104724" class="c"><input type="checkbox" id="c-42104724" checked=""/><div class="controls bullet"><span class="by">peutetre</span><span>|</span><a href="#42102894">root</a><span>|</span><a href="#42104635">parent</a><span>|</span><label class="collapse" for="c-42104724">[-]</label><label class="expand" for="c-42104724">[1 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s done really well. It&#x27;s in lots of things:<p><a href="https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;</a><p>Java compiles to WebAssembly too. Google uses it:<p><a href="https:&#x2F;&#x2F;web.dev&#x2F;case-studies&#x2F;google-sheets-wasmgc" rel="nofollow">https:&#x2F;&#x2F;web.dev&#x2F;case-studies&#x2F;google-sheets-wasmgc</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>