<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729933251992" as="style"/><link rel="stylesheet" href="styles.css?v=1729933251992"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.trailofbits.com/2024/10/25/a-deep-dive-into-linuxs-new-mseal-syscall/">A deep dive into Linux&#x27;s new mseal syscall</a> <span class="domain">(<a href="https://blog.trailofbits.com">blog.trailofbits.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>43 comments</span></div><br/><div><div id="41947112" class="c"><input type="checkbox" id="c-41947112" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41948044">next</a><span>|</span><label class="collapse" for="c-41947112">[-]</label><label class="expand" for="c-41947112">[18 more]</label></div><br/><div class="children"><div class="content">Interesting.  The article mentions &quot;spicy discussions&quot; in the kernel mailing list.  Is there any insider who can summarize objections and concerns?  I tend to avoid reading the mailing list itself since it can get too spicy, and my headaches are already strong enough!<p>The mechanism itself seems reasonable, but I am surprised that something like this doesn&#x27;t already exist in the kernel.</div><br/><div id="41947207" class="c"><input type="checkbox" id="c-41947207" checked=""/><div class="controls bullet"><span class="by">ziddoap</span><span>|</span><a href="#41947112">parent</a><span>|</span><a href="#41947866">next</a><span>|</span><label class="collapse" for="c-41947207">[-]</label><label class="expand" for="c-41947207">[13 more]</label></div><br/><div class="children"><div class="content">Not sure if there was much more to it than the thread linked to, but it was basically Linus being Linus. He said stuff that made sense in a pretty blunt fashion.<p>There were flags proposed that allowed the seal to be ignored.<p>&gt;<i>So you say &quot;we can&#x27;t munmap in this *one* place, but all others ignore the sealing&quot;.</i><p>Later was the spice.<p>&gt;<i>And dammit, once something is sealed, it is SEALED. None of this crazy
&quot;one place honors the sealing, random other places do not&quot;.</i><p>And later, even spicier, Linus says that seals cannot be ignored and that is non-negotiable. Any further suggestions to ignore a seal via a flag would result in the person being added to Linus&#x27; ignore list. (He, of course, said this with some profanities and capitals sprinkled in.)</div><br/><div id="41953385" class="c"><input type="checkbox" id="c-41953385" checked=""/><div class="controls bullet"><span class="by">santiagobasulto</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41947207">parent</a><span>|</span><a href="#41947570">next</a><span>|</span><label class="collapse" for="c-41953385">[-]</label><label class="expand" for="c-41953385">[1 more]</label></div><br/><div class="children"><div class="content">Is that considered &quot;spicy&quot;? Is the sensitivity threshold maybe too low?</div><br/></div></div><div id="41947570" class="c"><input type="checkbox" id="c-41947570" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41947207">parent</a><span>|</span><a href="#41953385">prev</a><span>|</span><a href="#41947866">next</a><span>|</span><label class="collapse" for="c-41947570">[-]</label><label class="expand" for="c-41947570">[11 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t just Linus. Earlier, from Theo de Raadt:<p>&gt; I don&#x27;t think you understand the problem space well enough to come up with
your own solution for it.  I spent a year on this, and ship a complete system
using it.  You are asking such simplistic questions above it shocks me.<p><a href="https:&#x2F;&#x2F;lwn.net&#x2F;ml&#x2F;linux-kernel&#x2F;95482.1697587015@cvs.openbsd.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;ml&#x2F;linux-kernel&#x2F;95482.1697587015@cvs.openbsd...</a><p>Via <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;948129&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;948129&#x2F;</a></div><br/><div id="41948384" class="c"><input type="checkbox" id="c-41948384" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41947570">parent</a><span>|</span><a href="#41948496">prev</a><span>|</span><a href="#41947866">next</a><span>|</span><label class="collapse" for="c-41948384">[-]</label><label class="expand" for="c-41948384">[9 more]</label></div><br/><div class="children"><div class="content">Not a great perspective... &quot;It took me a year [or more] to understand this. The fact that you don&#x27;t understand it shocks me.&quot; Dude, not everybody&#x27;s as smart or experienced as you. Here&#x27;s an opportunity to be a mentor.</div><br/><div id="41949403" class="c"><input type="checkbox" id="c-41949403" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41948384">parent</a><span>|</span><a href="#41948640">next</a><span>|</span><label class="collapse" for="c-41949403">[-]</label><label class="expand" for="c-41949403">[4 more]</label></div><br/><div class="children"><div class="content">My reading of this is a lot more generous to the maintainers and a lot less sympathetic to the author than yours is. The maintainers highlighted the problems and the author came back basically with &quot;I don&#x27;t believe you so let&#x27;s go with my approach to stay more general&quot; - it&#x27;s one thing to disagree, it&#x27;s another to straight up not acknowledge the feedback. The author ate a lot of very senior people&#x27;s time arguing instead of listening to them and learning from their experience and that was justifiably frustrating forcing much more direct feedback. The kind of mistake the author made - having to enforce at each individual syscall level instead of it being a protection on the memory itself enforced on all accesses - indicates a poor understanding of how to think about security and build security APIs which is a problem when you&#x27;re proposing a security API.<p>It&#x27;s particularly impressive how misguided the patch is given that they took inspiration from the OpenBSD API implementation, changed both API &amp; implementation, &amp; then argued with both Linus and Theo who started Linux &amp; OpenBSD respectively and were trying to give direct feedback about how OpenBSD is different and why it took the approach it did.<p>Hopefully the author has taken the more forceful feedback as a learning opportunity about listening to feedback when the people giving it to you have a lot more experience. Or their team is coaching them about what went wrong now that this became so visible to learn what they got wrong.<p>From Matthew Wilcox who is another senior Linux maintainer:<p>&gt;  I concur with Theo &amp; Linus.  You don&#x27;t know what you&#x27;re doing.  I think the underlying idea of mimmutable() is good, but how you&#x27;ve split it up and how you&#x27;ve implemented it is terrible.<p>It&#x27;s delivered directly and bluntly but it&#x27;s not mean or personal. The author proposed a bad patch &amp; argued from a position of ignorance.</div><br/><div id="41951182" class="c"><input type="checkbox" id="c-41951182" checked=""/><div class="controls bullet"><span class="by">jorvi</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41949403">parent</a><span>|</span><a href="#41948640">next</a><span>|</span><label class="collapse" for="c-41951182">[-]</label><label class="expand" for="c-41951182">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The maintainers highlighted the problems and the author came back basically with &quot;I don&#x27;t believe you so let&#x27;s go with my approach to stay more general&quot; - it&#x27;s one thing to disagree, it&#x27;s another to straight up not acknowledge the feedback.<p>Isn&#x27;t that the Linux kernel in a nutshell?<p>Of the top of my head I can name:<p>- The zram maintainer that&#x27;s for a few years been blocking the patches that add the zpool api to zram. This would go a long way to unifying zram and zswap in the future.<p>- TuxOnIce being permablocked by some heels-in-sand maintainers until the kernel diverged to much and the patch writer gave up. This one would have fixed hibernation on Linux.. in other words, hibernation still sucks because of these maintainers.<p>- Of course the trench warfare all the C-proficient maintainers are waging to chase all the Rust-in-Linux people away, lest they have to learn Rust. ~80% of CVEs are memory-related, so you could say that in say.. 10 years time, ~80% of the CVEs happening in the Linux kernel are the legacy of Ted &amp; co.</div><br/><div id="41951430" class="c"><input type="checkbox" id="c-41951430" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41951182">parent</a><span>|</span><a href="#41948640">next</a><span>|</span><label class="collapse" for="c-41951430">[-]</label><label class="expand" for="c-41951430">[2 more]</label></div><br/><div class="children"><div class="content">You can roughly be:<p>1. Wrong and ignorant<p>2. Wrong and knowledgeable<p>3. Right and ignorant<p>4. Right and knowledgeable<p>There&#x27;s also when there&#x27;s just a disagreement of opinion because you weight the tradeoffs differently, in which case there&#x27;s less of a right or wrong.<p>The main difference is that in those cases the people involved were in camps 2-4 or simply weighted tradeoffs differently. In this case the author seemed much more clearly in camp 1.<p>Regarding the claim that &quot;this one would have fixed hibernation on Linux&quot; - maybe, but it&#x27;s hard to evaluate a road not taken. It could have made other tradeoffs or caused other issues down the road that aren&#x27;t visible to you right now because it didn&#x27;t get mainlined or maybe hibernation would still have been broken. Or maybe it would have been hunky dorry. But it kind of doesn&#x27;t matter because the author in this case was clearly wrong (i.e. the patch wouldn&#x27;t have achieved the goal it set out to do and would have predictably caused vulnerabilities to become possible in the future as the kernel evolved).<p>As for Rust-in-Linux, it sounds like your not actually up to date [1]. I&#x27;ll forgive Ted&#x27;s emotional volatility at the infamous filesystem talk as he&#x27;s been much more calm about it now:<p>&gt; There is a need for documentation and tutorials on how to write filesystem code in idiomatic Rust. He said that he has a lot to learn; he is willing to do that, but needs help on what to learn.<p>I&#x27;d say &quot;trench resistance&quot; not warfare. The Rust movement is trying to shift the daily work of ~15k developers in a mostly bazaar development model. There&#x27;s going to be resistance and push back and some of it will feel unfair to the Rust folks and some will feel unfair to the C folk and both will be right.<p>[1] <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;991062&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;991062&#x2F;</a></div><br/><div id="41952140" class="c"><input type="checkbox" id="c-41952140" checked=""/><div class="controls bullet"><span class="by">jorvi</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41951430">parent</a><span>|</span><a href="#41948640">next</a><span>|</span><label class="collapse" for="c-41952140">[-]</label><label class="expand" for="c-41952140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But it kind of doesn&#x27;t matter because the author in this case was clearly wrong (i.e. the patch wouldn&#x27;t have achieved the goal it set out to do and would have predictably caused vulnerabilities to become possible in the future as the kernel evolved).<p>I was speaking in general terms, of how recognizable the &quot;heels-in-the-sand&quot; attitude is. In this particular case yes, it does sound right that the current &quot;mseal&quot; proposal &#x2F; patches is not up to snuff.<p>Edit: also reading through it again, props to Theo&#x27;s response. Stern but with a lot of edification.<p>&gt; Regarding the claim that &quot;this one would have fixed hibernation on Linux&quot; - maybe, but it&#x27;s hard to evaluate a road not taken. It could have made other tradeoffs or caused other issues down the road that aren&#x27;t visible to you right now because it didn&#x27;t get mainlined or maybe hibernation would still have been broken.<p>The nice thing about TuxOnIce is that it would have pushed  large parts of hibernation into userspace, which would have made it much more versatile and much easier to iterate on.<p>&gt; As for Rust-in-Linux, it sounds like your not actually up to date [1].<p>One of the main Rust spearhead developers felt the need to quit, and almost immediately thereafter Asahi Lina posted an article about how &quot;a subset of C kernel developers just seem determined to make the lives of the Rust maintainers as difficult as possible.&quot; By my count that is 0-2. How is that &quot;some of it will feel unfair to the Rust folks and some will feel unfair to the C folk&quot;?<p>&gt; I&#x27;d say &quot;trench resistance&quot; not warfare. The Rust movement is trying to shift the daily work of ~15k developers in a mostly bazaar development model.<p>They&#x27;re not trying to shift the daily work of ~15k developers. They&#x27;re asking for some shims, stubs, adaptations, and some general flexibility &amp; willingness. They&#x27;re not expecting everyone to write Rust within the next 18 months.<p>[0]<a href="https:&#x2F;&#x2F;vt.social&#x2F;@lina&#x2F;113045455229442533" rel="nofollow">https:&#x2F;&#x2F;vt.social&#x2F;@lina&#x2F;113045455229442533</a></div><br/></div></div></div></div></div></div></div></div><div id="41948640" class="c"><input type="checkbox" id="c-41948640" checked=""/><div class="controls bullet"><span class="by">nativeit</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41948384">parent</a><span>|</span><a href="#41949403">prev</a><span>|</span><a href="#41950709">next</a><span>|</span><label class="collapse" for="c-41948640">[-]</label><label class="expand" for="c-41948640">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Google has no shortage of experienced developers who could have reviewed this submission before it was posted publicly, but that does not appear to have happened, with the result that a relatively inexperienced developer was put into a difficult position. Feedback on the proposal was resisted rather than listened to. The result was an interaction that pleased nobody.</div><br/><div id="41948875" class="c"><input type="checkbox" id="c-41948875" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41948640">parent</a><span>|</span><a href="#41950709">next</a><span>|</span><label class="collapse" for="c-41948875">[-]</label><label class="expand" for="c-41948875">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Google has no shortage of experienced developers who could have reviewed this submission before it was posted publicly,<p>You&#x27;d be surprised. My understanding from folks on Chrome OS is they&#x27;ve already shedded most, if not all, of the most experienced old hands. (n.b. Chrome OS was absorbed by Android and development is, by and large, ceased on it according to same sources directly, and indirectly via Blind.)</div><br/></div></div></div></div><div id="41950709" class="c"><input type="checkbox" id="c-41950709" checked=""/><div class="controls bullet"><span class="by">terribleperson</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41948384">parent</a><span>|</span><a href="#41948640">prev</a><span>|</span><a href="#41947866">next</a><span>|</span><label class="collapse" for="c-41950709">[-]</label><label class="expand" for="c-41950709">[2 more]</label></div><br/><div class="children"><div class="content">The time of the people who maintain the free and open source software we rely on is not free. From the people I&#x27;ve talked to, maintainers of successful projects are overworked and underappreciated.<p>Mentorship from one of those people would be valuable, but arguing with them about the implementation of something you don&#x27;t understand isn&#x27;t how you get that mentorship.</div><br/><div id="41950780" class="c"><input type="checkbox" id="c-41950780" checked=""/><div class="controls bullet"><span class="by">Onavo</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41950709">parent</a><span>|</span><a href="#41947866">next</a><span>|</span><label class="collapse" for="c-41950780">[-]</label><label class="expand" for="c-41950780">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Mentorship from one of those people would be valuable, but arguing with them about the implementation of something you don&#x27;t understand isn&#x27;t how you get that mentorship.</i><p>Actually that&#x27;s exactly how you can provoke them into explaining themselves. Too many experienced people sit in their ivory towers and basically appeal to their authority, &quot;I wrote a kernel therefore I know everything, &lt;insert profanity here&gt;&quot;. There&#x27;s a reason why Cunningham&#x27;s Law exist, &quot;The best way to get the right answer on the Internet is not to ask a question, it&#x27;s to post the wrong answer.&quot;</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41947866" class="c"><input type="checkbox" id="c-41947866" checked=""/><div class="controls bullet"><span class="by">greenavocado</span><span>|</span><a href="#41947112">parent</a><span>|</span><a href="#41947207">prev</a><span>|</span><a href="#41947907">next</a><span>|</span><label class="collapse" for="c-41947866">[-]</label><label class="expand" for="c-41947866">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;lwn.net&#x2F;ml&#x2F;linux-kernel&#x2F;7071.1697661373@cvs.openbsd.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;ml&#x2F;linux-kernel&#x2F;7071.1697661373@cvs.openbsd....</a><p><pre><code>    From:   Theo de Raadt &lt;deraadt-AT-openbsd.org&gt;
    To:   Jeff Xu &lt;jeffxu-AT-google.com&gt;

    &gt; On Wed, Oct 18, 2023 at 8:17 AM Matthew Wilcox &lt;willy@infradead.org&gt; wrote:
    &gt; &gt;
    &gt; &gt; Let&#x27;s start with the purpose.  The point of mimmutable&#x2F;mseal&#x2F;whatever is
    &gt; &gt; to fix the mapping of an address range to its underlying object, be it
    &gt; &gt; a particular file mapping or anonymous memory.  After the call succeeds,
    &gt; &gt; it must not be possible to make any address in that virtual range point
    &gt; &gt; into any other object.
    &gt; &gt;
    &gt; &gt; The secondary purpose is to lock down permissions on that range.
    &gt; &gt; Possibly to fix them where they are, possibly to allow RW-&gt;RO transitions.
    &gt; &gt;
    &gt; &gt; With those purposes in mind, you should be able to deduce for any syscall
    &gt; &gt; or any madvise(), ... whether it should be allowed.
    &gt; &gt;
    &gt; I got it.
    &gt; 
    &gt; IMO: The approaches mimmutable() and mseal() took are different, but
    &gt; we all want to seal the memory from attackers and make the linux
    &gt; application safer.

    I think you are building mseal for chrome, and chrome alone.

    I do not think this will work out for the rest of the application space
    because

    1) it is too complicated
    2) experience with mimmutable() says that applications don&#x27;t do any of it
    themselves, it is all in execve(), libc initialization, and ld.so.
    You don&#x27;t strike me as an execve, libc, or ld.so developer.</code></pre></div><br/></div></div><div id="41947907" class="c"><input type="checkbox" id="c-41947907" checked=""/><div class="controls bullet"><span class="by">greenavocado</span><span>|</span><a href="#41947112">parent</a><span>|</span><a href="#41947866">prev</a><span>|</span><a href="#41947535">next</a><span>|</span><label class="collapse" for="c-41947907">[-]</label><label class="expand" for="c-41947907">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    From:   Matthew Wilcox &lt;willy-AT-infradead.org&gt;
    To:   Jeff Xu &lt;jeffxu-AT-google.com&gt;

    ...

    Yes, thank you for demonstrating that you have no idea what you need to
    block.

    &gt; It is practical to keep syscall extentable, when the business logic is the same.

    I concur with Theo &amp; Linus.  You don&#x27;t know what you&#x27;re doing.  I think
    the underlying idea of mimmutable() is good, but how you&#x27;ve split it up
    and how you&#x27;ve implemented it is terrible.

    ...</code></pre></div><br/></div></div><div id="41947535" class="c"><input type="checkbox" id="c-41947535" checked=""/><div class="controls bullet"><span class="by">lathiat</span><span>|</span><a href="#41947112">parent</a><span>|</span><a href="#41947907">prev</a><span>|</span><a href="#41948044">next</a><span>|</span><label class="collapse" for="c-41947535">[-]</label><label class="expand" for="c-41947535">[2 more]</label></div><br/><div class="children"><div class="content">This may help a bit:
<a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;948129&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;948129&#x2F;</a></div><br/><div id="41947553" class="c"><input type="checkbox" id="c-41947553" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#41947112">root</a><span>|</span><a href="#41947535">parent</a><span>|</span><a href="#41948044">next</a><span>|</span><label class="collapse" for="c-41947553">[-]</label><label class="expand" for="c-41947553">[1 more]</label></div><br/><div class="children"><div class="content">Very nice, thanks!<p>Edit: I always find it funny that these articles on the mailing list tend to read like a sports announcer describing a boxing match!</div><br/></div></div></div></div></div></div><div id="41948044" class="c"><input type="checkbox" id="c-41948044" checked=""/><div class="controls bullet"><span class="by">throw0101a</span><span>|</span><a href="#41947112">prev</a><span>|</span><a href="#41947130">next</a><span>|</span><label class="collapse" for="c-41948044">[-]</label><label class="expand" for="c-41948044">[1 more]</label></div><br/><div class="children"><div class="content">mseal() and what comes after, October 20, 2023: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;948129&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;948129&#x2F;</a><p>mseal() gets closer, January 19, 2024: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;958438&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;958438&#x2F;</a><p>Memory sealing for the GNU C Library, June 12, 2024: <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;978010&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;978010&#x2F;</a></div><br/></div></div><div id="41947130" class="c"><input type="checkbox" id="c-41947130" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41948044">prev</a><span>|</span><a href="#41949798">next</a><span>|</span><label class="collapse" for="c-41947130">[-]</label><label class="expand" for="c-41947130">[12 more]</label></div><br/><div class="children"><div class="content">Will it be possible to override &#x2F; disable the `mseal&#x27; syscall with the LD_PRELOAD trick?</div><br/><div id="41947292" class="c"><input type="checkbox" id="c-41947292" checked=""/><div class="controls bullet"><span class="by">eska</span><span>|</span><a href="#41947130">parent</a><span>|</span><a href="#41947327">next</a><span>|</span><label class="collapse" for="c-41947292">[-]</label><label class="expand" for="c-41947292">[2 more]</label></div><br/><div class="children"><div class="content"><i>mseal digresses from prior memory protection schemes on Linux because it is a syscall tailored specifically for exploit mitigation against remote attackers seeking code execution rather than potentially local ones looking to exfiltrate sensitive secrets in-memory.</i><p>If a remote attacker can change the local environment then they must have already broken into your system.</div><br/></div></div><div id="41947327" class="c"><input type="checkbox" id="c-41947327" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#41947130">parent</a><span>|</span><a href="#41947292">prev</a><span>|</span><a href="#41949051">next</a><span>|</span><label class="collapse" for="c-41947327">[-]</label><label class="expand" for="c-41947327">[4 more]</label></div><br/><div class="children"><div class="content">Probably not LD_PRELOAD.  It would need to be an imported function in order for LD_PRELOAD to have any effect.  A raw syscall would not be interceptable that way.<p>Discussion about intercepting linux syscalls: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;69859&#x2F;how-could-i-intercept-linux-sys-calls" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;69859&#x2F;how-could-i-interc...</a><p>But building your own patched kernel that pretends that mseal works would be the simplest way to &quot;disable&quot; that feature.  Programs that use mseal could still do sanity checks to see if mseal actually works or not.  Then a compromised kernel would need secret ways to disable mseal after it has been applied, to stop the apps from checking for a non-functional mseal.</div><br/><div id="41947498" class="c"><input type="checkbox" id="c-41947498" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#41947130">root</a><span>|</span><a href="#41947327">parent</a><span>|</span><a href="#41949051">next</a><span>|</span><label class="collapse" for="c-41947498">[-]</label><label class="expand" for="c-41947498">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what protection you could expect on any system where the kernel has been replaced by the attacker.  Sure they can bypass mseal, but they are also bypassing <i>all other security</i> on the box.</div><br/><div id="41948597" class="c"><input type="checkbox" id="c-41948597" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#41947130">root</a><span>|</span><a href="#41947498">parent</a><span>|</span><a href="#41949051">next</a><span>|</span><label class="collapse" for="c-41948597">[-]</label><label class="expand" for="c-41948597">[2 more]</label></div><br/><div class="children"><div class="content">Two different considerations for when you&#x27;d want to deny memory to other processes:<p>Protecting against outside attackers<p>Digital Rights Management<p>Faking &quot;mseal&quot; is something you might intentionally do if you are trying to break DRM, and something you would not want to do if you are trying to defend against outside attackers.</div><br/><div id="41953498" class="c"><input type="checkbox" id="c-41953498" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41947130">root</a><span>|</span><a href="#41948597">parent</a><span>|</span><a href="#41949051">next</a><span>|</span><label class="collapse" for="c-41953498">[-]</label><label class="expand" for="c-41953498">[1 more]</label></div><br/><div class="children"><div class="content">The kernel can bypass any memory protection, it does not need to fake mseal. Controlling the memory protection is one of the most important functions of any OS kernel and one of the few that could not be implemented in any other place.<p>Some CPUs have special hardware means for protecting some memory region against the kernel (&quot;secure enclaves&quot;, e.g. Intel SGX), and that is the feature that the supporters of DRM want.<p>&quot;Mseal&quot; is only against attackers who do not control the kernel.</div><br/></div></div></div></div></div></div></div></div><div id="41949051" class="c"><input type="checkbox" id="c-41949051" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41947130">parent</a><span>|</span><a href="#41947327">prev</a><span>|</span><a href="#41947304">next</a><span>|</span><label class="collapse" for="c-41949051">[-]</label><label class="expand" for="c-41949051">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bunch of ways to override it if you have early control over the process.  Another example: ptrace the executable, watch the system calls, and skip over any mseal(2)s.<p>This system call is meant for a different threat model than &quot;attacker has early access to your process before it started initializing&quot;.</div><br/></div></div><div id="41947304" class="c"><input type="checkbox" id="c-41947304" checked=""/><div class="controls bullet"><span class="by">chucky_z</span><span>|</span><a href="#41947130">parent</a><span>|</span><a href="#41949051">prev</a><span>|</span><a href="#41947287">next</a><span>|</span><label class="collapse" for="c-41947304">[-]</label><label class="expand" for="c-41947304">[2 more]</label></div><br/><div class="children"><div class="content">You can override the mseal call wrapper but not the syscall itself.<p>This is an interesting thought so I looked it up and this is how (all?) preload syscall overrides work.  You override the wrapper but not the syscalls itself so if you’re doing direct syscalls I don’t think that can be overridden.  Technically you could override the syscall function itself maybe?</div><br/><div id="41948778" class="c"><input type="checkbox" id="c-41948778" checked=""/><div class="controls bullet"><span class="by">jmmv</span><span>|</span><a href="#41947130">root</a><span>|</span><a href="#41947304">parent</a><span>|</span><a href="#41947287">next</a><span>|</span><label class="collapse" for="c-41948778">[-]</label><label class="expand" for="c-41948778">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Technically you could override the syscall function itself maybe?<p>But then you can just write assembly code to issue the system call.</div><br/></div></div></div></div><div id="41947287" class="c"><input type="checkbox" id="c-41947287" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#41947130">parent</a><span>|</span><a href="#41947304">prev</a><span>|</span><a href="#41947357">next</a><span>|</span><label class="collapse" for="c-41947287">[-]</label><label class="expand" for="c-41947287">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;978010&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;978010&#x2F;</a> says there&#x27;ll be a glibc tunable</div><br/></div></div><div id="41947357" class="c"><input type="checkbox" id="c-41947357" checked=""/><div class="controls bullet"><span class="by">cataphract</span><span>|</span><a href="#41947130">parent</a><span>|</span><a href="#41947287">prev</a><span>|</span><a href="#41949798">next</a><span>|</span><label class="collapse" for="c-41947357">[-]</label><label class="expand" for="c-41947357">[1 more]</label></div><br/><div class="children"><div class="content">Depends whether the program calls into libc or inlines the syscalls, I imagine. Though you could use other mechanisms like secccomp.</div><br/></div></div></div></div><div id="41949798" class="c"><input type="checkbox" id="c-41949798" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41947130">prev</a><span>|</span><a href="#41947318">next</a><span>|</span><label class="collapse" for="c-41949798">[-]</label><label class="expand" for="c-41949798">[2 more]</label></div><br/><div class="children"><div class="content">A question about using this call:<p>Chrome is the one who wants it. But you can’t unmap sealed pages because an attacker could then re-map them with different flags.<p>So that basically means this can never be used on pages allocated at runtime unless you intend to hold them for the entire process lifetime, right?<p>Doesn’t that mean it can’t be used for all the memory used by, say, the JS sandbox which would be a very very tempting target?<p>Or is the idea that you deal with this by always running that kind of stuff in a different process where you can seal the memory and then you can just kill the process when you’re done?<p>I’m not familiar with how Chrome manages memory&#x2F;processes, so I’m not exactly sure why this wouldn’t be an issue.<p>Is this also the reason why the articles about this often mention it’s not useful to most programs (outside of how memory is set up at processes start up)?</div><br/><div id="41949838" class="c"><input type="checkbox" id="c-41949838" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#41949798">parent</a><span>|</span><a href="#41947318">next</a><span>|</span><label class="collapse" for="c-41949838">[-]</label><label class="expand" for="c-41949838">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Doesn’t that mean it can’t be used for all the memory used by, say, the JS sandbox which would be a very very tempting target?<p>Multiprocessing is an option here. I think chrome uses it extensively, so that might be the play here. You need separate processes for other stuff anyway, like isolation via namespaces.</div><br/></div></div></div></div><div id="41947318" class="c"><input type="checkbox" id="c-41947318" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#41949798">prev</a><span>|</span><a href="#41949990">next</a><span>|</span><label class="collapse" for="c-41947318">[-]</label><label class="expand" for="c-41947318">[2 more]</label></div><br/><div class="children"><div class="content">Meta: the mseal() prototype in the article needs some editing, it is not syntacticallly correct as shown now. The first argument is shown as<p><pre><code>    unsigned start addr
</code></pre>
But should probably be<p><pre><code>    unsigned long start_addr</code></pre></div><br/><div id="41948636" class="c"><input type="checkbox" id="c-41948636" checked=""/><div class="controls bullet"><span class="by">hifromwork</span><span>|</span><a href="#41947318">parent</a><span>|</span><a href="#41949990">next</a><span>|</span><label class="collapse" for="c-41948636">[-]</label><label class="expand" for="c-41948636">[1 more]</label></div><br/><div class="children"><div class="content">Seems to be OK now:<p><pre><code>    int mseal(unsigned long start, size_t len, unsigned long flags)</code></pre></div><br/></div></div></div></div><div id="41949990" class="c"><input type="checkbox" id="c-41949990" checked=""/><div class="controls bullet"><span class="by">sim7c00</span><span>|</span><a href="#41947318">prev</a><span>|</span><a href="#41948610">next</a><span>|</span><label class="collapse" for="c-41949990">[-]</label><label class="expand" for="c-41949990">[2 more]</label></div><br/><div class="children"><div class="content">i am sad operating systems need to have such calls implemented while most modern (x86_64) architectures have so many features to facilitate safe and sound programming and computing. legacy crap en mentality , and trying to patch old systems built on paradigms not matching the current world and knowledge rather than rebuilding really put a break on progress in computing, and put litterally billions at risk.<p>not to say these things arent steps in the right direction, but if you let go of current ideals on how operating systems work, and take into account current systems, knowledge about them, and knowledge about what people want from systems, you can envision systems free from the burden and risks put on developers and users today.<p>yes architecture bugs exist, but software hardly takes advantage of current features truly,so arguing about architectural bugs is a moot point. theres cheaper ways to compromise, and always will be if things are built on shaky foundations</div><br/><div id="41951969" class="c"><input type="checkbox" id="c-41951969" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#41949990">parent</a><span>|</span><a href="#41948610">next</a><span>|</span><label class="collapse" for="c-41951969">[-]</label><label class="expand" for="c-41951969">[1 more]</label></div><br/><div class="children"><div class="content">Elighten me: what unused&#x2F;underused safety features x86_64 has that wouldn&#x27;t require the OS to have some method of using or enabling them? Why do you think mseal isn&#x27;t warranted and what would be better instead?</div><br/></div></div></div></div><div id="41948610" class="c"><input type="checkbox" id="c-41948610" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#41949990">prev</a><span>|</span><a href="#41949086">next</a><span>|</span><label class="collapse" for="c-41948610">[-]</label><label class="expand" for="c-41948610">[1 more]</label></div><br/><div class="children"><div class="content">- &quot;Memory Sealing &quot;Mseal&quot; System Call Merged for Linux 6.10&quot; (2024) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40474510#40474551">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40474510#40474551</a> :<p>&gt; <i>How should CPython support the mseal() syscall?</i></div><br/></div></div><div id="41949086" class="c"><input type="checkbox" id="c-41949086" checked=""/><div class="controls bullet"><span class="by">xterminator</span><span>|</span><a href="#41948610">prev</a><span>|</span><label class="collapse" for="c-41949086">[-]</label><label class="expand" for="c-41949086">[4 more]</label></div><br/><div class="children"><div class="content">OpenBSD has had it since forever [1]. Why is such an obvious feature only reaching Linux now?<p>[1]<a href="https:&#x2F;&#x2F;man.openbsd.org&#x2F;mimmutable.2" rel="nofollow">https:&#x2F;&#x2F;man.openbsd.org&#x2F;mimmutable.2</a></div><br/><div id="41949163" class="c"><input type="checkbox" id="c-41949163" checked=""/><div class="controls bullet"><span class="by">gilgamesh3</span><span>|</span><a href="#41949086">parent</a><span>|</span><a href="#41949164">next</a><span>|</span><label class="collapse" for="c-41949163">[-]</label><label class="expand" for="c-41949163">[2 more]</label></div><br/><div class="children"><div class="content">&gt;OpenBSD has had it since forever.<p>OpenBSD introduced mimmutable in OpenBSD 7.3, which was released 10&#x2F;4&#x2F;2023 (for US people, it would be 4&#x2F;10&#x2F;2023), so it isn&#x27;t &quot;forever&quot;.<p>Meanwhile Linux and FreeBSD has &quot;memfd_create&quot; forever while OpenBSD doesn&#x27;t have anonymous files and relies on &quot;shm_open&quot;.</div><br/><div id="41951834" class="c"><input type="checkbox" id="c-41951834" checked=""/><div class="controls bullet"><span class="by">pushupentry1219</span><span>|</span><a href="#41949086">root</a><span>|</span><a href="#41949163">parent</a><span>|</span><a href="#41949164">next</a><span>|</span><label class="collapse" for="c-41951834">[-]</label><label class="expand" for="c-41951834">[1 more]</label></div><br/><div class="children"><div class="content">&gt; OpenBSD introduced mimmutable in OpenBSD 7.3<p>Correct but they did have a very similar syscall for a long time that they deprecated after the release of mimmutable iirc</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>