<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694336471950" as="style"/><link rel="stylesheet" href="styles.css?v=1694336471950"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://underjord.io/unpacking-elixir-realtime-latency.html">Unpacking Elixir: Real-Time and Latency</a> <span class="domain">(<a href="https://underjord.io">underjord.io</a>)</span></div><div class="subtext"><span>lawik</span> | <span>19 comments</span></div><br/><div><div id="37453789" class="c"><input type="checkbox" id="c-37453789" checked=""/><div class="controls bullet"><span class="by">isodev</span><span>|</span><a href="#37451821">next</a><span>|</span><label class="collapse" for="c-37453789">[-]</label><label class="expand" for="c-37453789">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the post, Lars! I&#x27;m loving the “Unpacking Elixir” series so far.<p>I really wish I had been exposed to Erlang&#x2F;Elixir much sooner in my career. The inherent pragmatism and the overall desire to consolidate as much as possible within the BEAM makes for a very pleasant developer experience.</div><br/></div></div><div id="37451821" class="c"><input type="checkbox" id="c-37451821" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#37453789">prev</a><span>|</span><label class="collapse" for="c-37451821">[-]</label><label class="expand" for="c-37451821">[17 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe by modern standard that Elixir is aiming at low latency.</div><br/><div id="37453818" class="c"><input type="checkbox" id="c-37453818" checked=""/><div class="controls bullet"><span class="by">59nadir</span><span>|</span><a href="#37451821">parent</a><span>|</span><a href="#37452115">next</a><span>|</span><label class="collapse" for="c-37453818">[-]</label><label class="expand" for="c-37453818">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re getting a lot of downvotes but I think it&#x27;s mostly because of a misunderstanding of the bigger picture. Erlang can provide a low median latency and won&#x27;t be very sensitive to outliers where many other languages will have schedulers that are much more sensitive to outliers (because they&#x27;ll steal too many resources and can potentially steal an entire core for too long) while they can still have lower minimum latency.<p>It&#x27;s not that hard to accidentally exhaust the thread pool of some runtimes whereas you have to end up in pretty deep pathological areas in Erlang in order to do so. Notably `term_to_binary` on massive structures has historically been mis-bookkept (if you can call it that) by the runtime and will only count as one function call despite its high cost. This means the scheduler can&#x27;t preempt it and wouldn&#x27;t be able to nicely schedule N processes (where N is the amount of schedulers you have currently running, i.e. usually your core count) that were executing it.<p>But again, these are much deeper pathological cases than you&#x27;d find causing issues in most runtimes.</div><br/></div></div><div id="37452115" class="c"><input type="checkbox" id="c-37452115" checked=""/><div class="controls bullet"><span class="by">keep_reading</span><span>|</span><a href="#37451821">parent</a><span>|</span><a href="#37453818">prev</a><span>|</span><a href="#37452139">next</a><span>|</span><label class="collapse" for="c-37452115">[-]</label><label class="expand" for="c-37452115">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Goldman Sach uses Erlang in its hedge-fund trading platform for its low-latency (microseconds) event-driven order-submission engine.<p>if it&#x27;s good enough for a hedge fund HFT platform, it&#x27;s good enough for anyone aiming for low latency<p><a href="https:&#x2F;&#x2F;medium.com&#x2F;hybrid-cloud-engineering&#x2F;beam-otp-on-ocp-a-partnership-for-reliable-and-resilient-services-c0bfeebca10e" rel="nofollow noreferrer">https:&#x2F;&#x2F;medium.com&#x2F;hybrid-cloud-engineering&#x2F;beam-otp-on-ocp-...</a></div><br/><div id="37452624" class="c"><input type="checkbox" id="c-37452624" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452115">parent</a><span>|</span><a href="#37452536">next</a><span>|</span><label class="collapse" for="c-37452624">[-]</label><label class="expand" for="c-37452624">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s used for monitoring, not the actual trading. The Erlang scheduler is fantastic, but it targets a context switch roughly every 1ms, it&#x27;s obviously not suitable for HFT where a process must respond to a network event within microseconds.<p><a href="https:&#x2F;&#x2F;hackernoon.com&#x2F;successful-companies-use-erlang-and-elixir-470188bceb9f" rel="nofollow noreferrer">https:&#x2F;&#x2F;hackernoon.com&#x2F;successful-companies-use-erlang-and-e...</a><p>&gt; Erlang is used as part of the real-time monitoring solution for this distributed trading system.<p><a href="http:&#x2F;&#x2F;zerohedge.blogspot.com&#x2F;2009&#x2F;07&#x2F;is-case-of-quant-trading-industrial.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;zerohedge.blogspot.com&#x2F;2009&#x2F;07&#x2F;is-case-of-quant-tradi...</a><p>&gt; Implemented a real-time monitoring solution for the distributed trading system using a combination of technologies (SNMP, Erlang&#x2F;OTP, boost, ACE, TibcoRV, real-time distributed replicated database, etc) to monitor load and health of trading processes in the mother-ship and co-located sites so that trading decisions can be prioritized based on congestion and queuing delays.</div><br/></div></div><div id="37452536" class="c"><input type="checkbox" id="c-37452536" checked=""/><div class="controls bullet"><span class="by">vgatherps</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452115">parent</a><span>|</span><a href="#37452624">prev</a><span>|</span><a href="#37452254">next</a><span>|</span><label class="collapse" for="c-37452536">[-]</label><label class="expand" for="c-37452536">[1 more]</label></div><br/><div class="children"><div class="content">This is almost certainly incorrect, unless it’s using a very stretched definition of “hft” and using microseconds to mean 99th% &lt;1ms instead of say &lt;5us (reasonably competitive software range depending on your trade).<p>They might be forwarding non latency sensitive client&#x2F;internal orders through a system written in erlang, or using erlang for an orchestration layer, but they’re not competing with other hft traders in one.<p>Source: I work in the field and have built &lt;5us systems.<p><a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=NH1Tta7purM">https:&#x2F;&#x2F;m.youtube.com&#x2F;watch?v=NH1Tta7purM</a> Is a free great watch about the things you have to do to very reliably have such low latencies</div><br/></div></div><div id="37452254" class="c"><input type="checkbox" id="c-37452254" checked=""/><div class="controls bullet"><span class="by">rubyskills</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452115">parent</a><span>|</span><a href="#37452536">prev</a><span>|</span><a href="#37452425">next</a><span>|</span><label class="collapse" for="c-37452254">[-]</label><label class="expand" for="c-37452254">[2 more]</label></div><br/><div class="children"><div class="content">Was it HFT or just processing large client orders? I&#x27;m having a hard time finding this out</div><br/><div id="37452494" class="c"><input type="checkbox" id="c-37452494" checked=""/><div class="controls bullet"><span class="by">keep_reading</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452254">parent</a><span>|</span><a href="#37452425">next</a><span>|</span><label class="collapse" for="c-37452494">[-]</label><label class="expand" for="c-37452494">[1 more]</label></div><br/><div class="children"><div class="content">It could be the C++ for executing trades and BEAM for the client orders. Obviously you&#x27;d want something like C++ there when you&#x27;re racing. Though if they did the trading as a C++ NIF it could all still run on the BEAM avoiding a memory copy. Interesting thought exercise anyway.</div><br/></div></div></div></div><div id="37452425" class="c"><input type="checkbox" id="c-37452425" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452115">parent</a><span>|</span><a href="#37452254">prev</a><span>|</span><a href="#37452139">next</a><span>|</span><label class="collapse" for="c-37452425">[-]</label><label class="expand" for="c-37452425">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s hard to find details though.</div><br/></div></div></div></div><div id="37452139" class="c"><input type="checkbox" id="c-37452139" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#37451821">parent</a><span>|</span><a href="#37452115">prev</a><span>|</span><a href="#37452086">next</a><span>|</span><label class="collapse" for="c-37452139">[-]</label><label class="expand" for="c-37452139">[6 more]</label></div><br/><div class="children"><div class="content">Erlang, which Elixir compiles to, is literally built for low latency. It prioritizes latency while almost every other language prioritizes throughput.</div><br/><div id="37453456" class="c"><input type="checkbox" id="c-37453456" checked=""/><div class="controls bullet"><span class="by">vgatherps</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452139">parent</a><span>|</span><a href="#37452366">next</a><span>|</span><label class="collapse" for="c-37453456">[-]</label><label class="expand" for="c-37453456">[1 more]</label></div><br/><div class="children"><div class="content">Erlang is built for easily achieving fairly low and reliable latencies, with easy distribution&#x2F;concurrency primitives, and building highly reliable systems.<p>It’s not very good for “make packet in to packet out as fast as possible at the cost of all else”. All of the abstraction layers come at a performance cost and aren’t all useful in the first place for low latency trading systems.</div><br/></div></div><div id="37452366" class="c"><input type="checkbox" id="c-37452366" checked=""/><div class="controls bullet"><span class="by">edvinbesic</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452139">parent</a><span>|</span><a href="#37453456">prev</a><span>|</span><a href="#37452086">next</a><span>|</span><label class="collapse" for="c-37452366">[-]</label><label class="expand" for="c-37452366">[4 more]</label></div><br/><div class="children"><div class="content">Is it fairer to say that Elixir compiles to Erlang or that Erlang &amp; Elixir compile to Beam byte code?<p>Genuine question.</div><br/><div id="37452450" class="c"><input type="checkbox" id="c-37452450" checked=""/><div class="controls bullet"><span class="by">di4na</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452366">parent</a><span>|</span><a href="#37452086">next</a><span>|</span><label class="collapse" for="c-37452450">[-]</label><label class="expand" for="c-37452450">[3 more]</label></div><br/><div class="children"><div class="content">Neither but the former is closer to it.</div><br/><div id="37452472" class="c"><input type="checkbox" id="c-37452472" checked=""/><div class="controls bullet"><span class="by">swixmix</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452450">parent</a><span>|</span><a href="#37452086">next</a><span>|</span><label class="collapse" for="c-37452472">[-]</label><label class="expand" for="c-37452472">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Elixir compiles into BEAM byte code (via Erlang Abstract Format). This means that Elixir code can be called from Erlang and vice versa, without the need to write any bindings. All Elixir modules start with the Elixir. prefix followed by the regular Elixir name.&quot;<p>From <a href="https:&#x2F;&#x2F;elixir-lang.org&#x2F;crash-course.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;elixir-lang.org&#x2F;crash-course.html</a> &quot;Erlang&#x2F;Elixir Syntax: A Crash Course&quot;</div><br/><div id="37453496" class="c"><input type="checkbox" id="c-37453496" checked=""/><div class="controls bullet"><span class="by">di4na</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452472">parent</a><span>|</span><a href="#37452086">next</a><span>|</span><label class="collapse" for="c-37453496">[-]</label><label class="expand" for="c-37453496">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the Erlang Abstract Format is at least half a dozen IR above the bytecode, and lowering this is done by the erlang compiler.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37452086" class="c"><input type="checkbox" id="c-37452086" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#37451821">parent</a><span>|</span><a href="#37452139">prev</a><span>|</span><label class="collapse" for="c-37452086">[-]</label><label class="expand" for="c-37452086">[3 more]</label></div><br/><div class="children"><div class="content">Would you mind elaborating in more detail why.</div><br/><div id="37454064" class="c"><input type="checkbox" id="c-37454064" checked=""/><div class="controls bullet"><span class="by">jnsaff2</span><span>|</span><a href="#37451821">root</a><span>|</span><a href="#37452086">parent</a><span>|</span><a href="#37452245">next</a><span>|</span><label class="collapse" for="c-37454064">[-]</label><label class="expand" for="c-37454064">[1 more]</label></div><br/><div class="children"><div class="content">I guess this is similar to me going to a wine store. I am readily persuaded that a good 20 euro wine is actually much more enjoyable for me than a 5 euro wine. But I get no additional enjoyment from 500 euro wine over that 20 euro wine.<p>So it depends where you are looking from.<p>If you are a ruby shop and your regular out of the box latency is in the hundreds of milliseconds which under load falls apart into at first some and then all taking seconds or tens of seconds then the BEAM is fantastic, you go down to single-double digit responses and under load the latencies start to grow but very gradually. Every request gets more or less same latency.<p>When you come from microsecond latencies then it looks like the BEAM is doing a lot but is mostly in your way in achieving the lowest latency possible.<p>Completely different problem sets which gets confused by the writer not giving the necessary context for their claim.<p>In the Nerves&#x2F;IoT&#x2F;HW space one pattern used is to use Elixir for all the soft-realtime stuff and enjoy the QoL and other benefits of the BEAM and use other tools more suitable for hard-realtime tasks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>