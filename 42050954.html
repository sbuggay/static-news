<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731229252712" as="style"/><link rel="stylesheet" href="styles.css?v=1731229252712"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.openmymind.net/Zigs-weird-syntax/">Zig&#x27;s (.{}){} Syntax</a> <span class="domain">(<a href="https://www.openmymind.net">www.openmymind.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>87 comments</span></div><br/><div><div id="42096703" class="c"><input type="checkbox" id="c-42096703" checked=""/><div class="controls bullet"><span class="by">kristoff_it</span><span>|</span><a href="#42096846">next</a><span>|</span><label class="collapse" for="c-42096703">[-]</label><label class="expand" for="c-42096703">[2 more]</label></div><br/><div class="children"><div class="content">As people have pointed already elsewhere, the same declaration can be made more clear by isolating the type like so:<p><pre><code>    var gpa: std.mem.GeneralPurposeAllocator(.{}) = .{};</code></pre></div><br/><div id="42098524" class="c"><input type="checkbox" id="c-42098524" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#42096703">parent</a><span>|</span><a href="#42096846">next</a><span>|</span><label class="collapse" for="c-42098524">[-]</label><label class="expand" for="c-42098524">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes. Much more clear. Thank you.</div><br/></div></div></div></div><div id="42096846" class="c"><input type="checkbox" id="c-42096846" checked=""/><div class="controls bullet"><span class="by">kcbanner</span><span>|</span><a href="#42096703">prev</a><span>|</span><a href="#42098835">next</a><span>|</span><label class="collapse" for="c-42096846">[-]</label><label class="expand" for="c-42096846">[17 more]</label></div><br/><div class="children"><div class="content">After you&#x27;ve been writing zig for a while, seeing `.{}` in an argument list intuitively means &quot;default arguments&quot;.</div><br/><div id="42097770" class="c"><input type="checkbox" id="c-42097770" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#42096846">parent</a><span>|</span><a href="#42096854">next</a><span>|</span><label class="collapse" for="c-42097770">[-]</label><label class="expand" for="c-42097770">[2 more]</label></div><br/><div class="children"><div class="content">i have never used zig before, but after reading the article i came to the same conclusion. the &quot;problem&quot; (if it is a problem at all, that is) really is that .{} is the syntax for a struct whose type is to be figured out by the compiler, that new users will be unfamiliar with.<p>i don&#x27;t know if there are other uses for . and {} that would make this hard to read. if there are, then maybe that&#x27;s an issue, but otherwise, i don&#x27;t see that as a problem. it&#x27;s something to learn.<p>ideally, each syntax element has only one obvious use. that&#x27;s not always possible, but as long as the right meaning can easily be inferred from the context, then that&#x27;s good enough for most cases.</div><br/><div id="42098675" class="c"><input type="checkbox" id="c-42098675" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42097770">parent</a><span>|</span><a href="#42096854">next</a><span>|</span><label class="collapse" for="c-42098675">[-]</label><label class="expand" for="c-42098675">[1 more]</label></div><br/><div class="children"><div class="content">One will quickly become accustomed to the .{} pattern learning Zig.  It&#x27;s used for struct constructors:<p><pre><code>  const a_struct: StructType = .{ .foo = &quot;baz&quot;}; 
</code></pre>
As well as union initialization.  So .{} is a struct constructor for a struct where every field has a default value, which chooses all of those fields.</div><br/></div></div></div></div><div id="42096854" class="c"><input type="checkbox" id="c-42096854" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#42096846">parent</a><span>|</span><a href="#42097770">prev</a><span>|</span><a href="#42098835">next</a><span>|</span><label class="collapse" for="c-42096854">[-]</label><label class="expand" for="c-42096854">[14 more]</label></div><br/><div class="children"><div class="content">Seems like it could just be elided entirely. Why can&#x27;t it be?</div><br/><div id="42096951" class="c"><input type="checkbox" id="c-42096951" checked=""/><div class="controls bullet"><span class="by">Veserv</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096854">parent</a><span>|</span><a href="#42098343">next</a><span>|</span><label class="collapse" for="c-42096951">[-]</label><label class="expand" for="c-42096951">[2 more]</label></div><br/><div class="children"><div class="content">I do not know Zig, but it looks like it just means &quot;call default constructor for parameter&#x2F;variable&#x2F;type&quot;. I do not see how you could expect it to be elided unless every function auto-constructs any elided arguments or always has default arguments.<p>In other words, for a function f(x : T), f(.{}) is f(T()), not f(), where T() is the default constructor for type T.<p>If we had a function with two parameters g(x : T, y : T2) it would be g(.{}, .{}) which means g(T(), T2()), not g().<p>It looks like the feature exists to avoid things like:<p>x : really_long_type = really_long_type(), which can be replaced with x : T = .{} to avoid unnecessary duplication.</div><br/><div id="42097249" class="c"><input type="checkbox" id="c-42097249" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096951">parent</a><span>|</span><a href="#42098343">next</a><span>|</span><label class="collapse" for="c-42097249">[-]</label><label class="expand" for="c-42097249">[1 more]</label></div><br/><div class="children"><div class="content">I do not know Zig either; I had assumed that it has default parameters, but it seems that it does not[0]. So, yes, it makes sense now why it cannot be elided.<p>They should add default parameters to avoid this sort of thing. Maybe they ought to consider named&#x2F;labelled parameters, too, if they&#x27;re so concerned about clarity.<p>0: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;484">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;484</a></div><br/></div></div></div></div><div id="42098343" class="c"><input type="checkbox" id="c-42098343" checked=""/><div class="controls bullet"><span class="by">drcode</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096854">parent</a><span>|</span><a href="#42096951">prev</a><span>|</span><a href="#42097037">next</a><span>|</span><label class="collapse" for="c-42098343">[-]</label><label class="expand" for="c-42098343">[5 more]</label></div><br/><div class="children"><div class="content">Zig believes that all code needs to be explicit, to prevent surprises- You never want code that &quot;just executes on its own&quot; in places you may not expect it. Therefore, if you want default arguments, you have to perform some action to indicate this.</div><br/><div id="42099008" class="c"><input type="checkbox" id="c-42099008" checked=""/><div class="controls bullet"><span class="by">cztomsik</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42098343">parent</a><span>|</span><a href="#42098430">next</a><span>|</span><label class="collapse" for="c-42099008">[-]</label><label class="expand" for="c-42099008">[1 more]</label></div><br/><div class="children"><div class="content">explicit about branching and allocations, not so for types. we&#x27;ve recently got .decl() syntax, which is even more implicit than .{}</div><br/></div></div><div id="42098430" class="c"><input type="checkbox" id="c-42098430" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42098343">parent</a><span>|</span><a href="#42099008">prev</a><span>|</span><a href="#42097037">next</a><span>|</span><label class="collapse" for="c-42098430">[-]</label><label class="expand" for="c-42098430">[3 more]</label></div><br/><div class="children"><div class="content">Except it&#x27;s not entirely explicit. It allows the type name of the object being constructed to be elided.<p>Per the article, this is the explicit form:<p><pre><code>    var gpa = std.heap.GeneralPurposeAllocator(std.heap.GeneralPurposeAllocatorConfig{}){};</code></pre></div><br/><div id="42098587" class="c"><input type="checkbox" id="c-42098587" checked=""/><div class="controls bullet"><span class="by">superb_dev</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42098430">parent</a><span>|</span><a href="#42097037">next</a><span>|</span><label class="collapse" for="c-42098587">[-]</label><label class="expand" for="c-42098587">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think type elision make the codes execution less explicit. Nothing else could go there</div><br/><div id="42098653" class="c"><input type="checkbox" id="c-42098653" checked=""/><div class="controls bullet"><span class="by">necovek</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42098587">parent</a><span>|</span><a href="#42097037">next</a><span>|</span><label class="collapse" for="c-42098653">[-]</label><label class="expand" for="c-42098653">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a textbook definition of &quot;implicit&quot;, as in not directly specified, but assumed.<p>The fact that unacceptable parameter would fail compile time validation does not make it any more readable.</div><br/></div></div></div></div></div></div></div></div><div id="42097037" class="c"><input type="checkbox" id="c-42097037" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096854">parent</a><span>|</span><a href="#42098343">prev</a><span>|</span><a href="#42096928">next</a><span>|</span><label class="collapse" for="c-42097037">[-]</label><label class="expand" for="c-42097037">[1 more]</label></div><br/><div class="children"><div class="content">Declaring a variable doesn&#x27;t initialize it in Zig, so maybe the correct semantics in ellisions would be to allocate an unitialized argument.</div><br/></div></div><div id="42096928" class="c"><input type="checkbox" id="c-42096928" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096854">parent</a><span>|</span><a href="#42097037">prev</a><span>|</span><a href="#42098835">next</a><span>|</span><label class="collapse" for="c-42096928">[-]</label><label class="expand" for="c-42096928">[5 more]</label></div><br/><div class="children"><div class="content">For the same reason you can&#x27;t pass a Python function expecting a list an empty list with foo(), you have to use foo([]). They mean different things.</div><br/><div id="42097092" class="c"><input type="checkbox" id="c-42097092" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096928">parent</a><span>|</span><a href="#42097089">next</a><span>|</span><label class="collapse" for="c-42097092">[-]</label><label class="expand" for="c-42097092">[2 more]</label></div><br/><div class="children"><div class="content">However, in Python, if you routinely call foo([]), you&#x27;d specify that (or rather an empty tuple since it&#x27;s immutable) as the default value for that argument.</div><br/></div></div><div id="42097089" class="c"><input type="checkbox" id="c-42097089" checked=""/><div class="controls bullet"><span class="by">owl57</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42096928">parent</a><span>|</span><a href="#42097092">prev</a><span>|</span><a href="#42098835">next</a><span>|</span><label class="collapse" for="c-42097089">[-]</label><label class="expand" for="c-42097089">[2 more]</label></div><br/><div class="children"><div class="content">I believe that if most foo&#x27;s users should just call it with [], the Pythonic way is to make the argument optional.</div><br/><div id="42097531" class="c"><input type="checkbox" id="c-42097531" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42096846">root</a><span>|</span><a href="#42097089">parent</a><span>|</span><a href="#42098835">next</a><span>|</span><label class="collapse" for="c-42097531">[-]</label><label class="expand" for="c-42097531">[1 more]</label></div><br/><div class="children"><div class="content">Well yes, but if it&#x27;s someone else&#x27;s library, realistically you&#x27;re not going to change it.<p>Zig is a static language without variadic parameters, so you can&#x27;t make it optional in that sense. You could make the options a `?T` and pass `null` instead, but it isn&#x27;t idiomatic, because passing `.{}` to a parameter expecting a `T` will fill in all the default values for you.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42098835" class="c"><input type="checkbox" id="c-42098835" checked=""/><div class="controls bullet"><span class="by">NoelJacob</span><span>|</span><a href="#42096846">prev</a><span>|</span><a href="#42096916">next</a><span>|</span><label class="collapse" for="c-42098835">[-]</label><label class="expand" for="c-42098835">[3 more]</label></div><br/><div class="children"><div class="content">Why did they keep the dot in Struct initialisation? Why not the syntax of just using without dot:
const c1 = Config{
    port = 8000,
    host = &quot;127.0.0.1&quot;,
};
Is there some other use with dotless one?</div><br/><div id="42099169" class="c"><input type="checkbox" id="c-42099169" checked=""/><div class="controls bullet"><span class="by">thezipcreator</span><span>|</span><a href="#42098835">parent</a><span>|</span><a href="#42098881">next</a><span>|</span><label class="collapse" for="c-42099169">[-]</label><label class="expand" for="c-42099169">[1 more]</label></div><br/><div class="children"><div class="content">Just `{}` means a code block; in Zig you could do something like<p><pre><code>  const c = blk: { const x = 5; break :blk x-3; }; &#x2F;&#x2F; c = 2
</code></pre>
just having an empty block `{}` is exactly that—an empty block of type `void`. having a dot or something else distinguishing it from a block is necessary in order for it to not be that.</div><br/></div></div><div id="42098881" class="c"><input type="checkbox" id="c-42098881" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#42098835">parent</a><span>|</span><a href="#42099169">prev</a><span>|</span><a href="#42096916">next</a><span>|</span><label class="collapse" for="c-42098881">[-]</label><label class="expand" for="c-42098881">[1 more]</label></div><br/><div class="children"><div class="content">Because your type name might be std.foo.bar.baz.quux.Config</div><br/></div></div></div></div><div id="42096916" class="c"><input type="checkbox" id="c-42096916" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42098835">prev</a><span>|</span><a href="#42099086">next</a><span>|</span><label class="collapse" for="c-42096916">[-]</label><label class="expand" for="c-42096916">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m glad I read the last line, for those who may not have gotten that far: this is about to become a much less prevalent pattern in Zig code, replaced with declaration literals.  The new syntax will look like this:<p><pre><code>   var gpa: std.mem.GeneralPurposeAllocator(.{}) = .init;
</code></pre>
Which finds the declaration literal `std.mem.GeneralPurposeAllocator.init`, a pre-declared instance of the GPA with the correct starting configuration.</div><br/></div></div><div id="42099086" class="c"><input type="checkbox" id="c-42099086" checked=""/><div class="controls bullet"><span class="by">indulona</span><span>|</span><a href="#42096916">prev</a><span>|</span><a href="#42097982">next</a><span>|</span><label class="collapse" for="c-42099086">[-]</label><label class="expand" for="c-42099086">[1 more]</label></div><br/><div class="children"><div class="content">fugly syntax is one of the biggest reasons i will never touch rust. zig is not far too off, unfortunately. i i needed non-gc language, i would go for odin. not perfect but closes to usable. it&#x27;s just too hard to do anything but Go, once you get comfortable with it. they got too many things right to see grass being greener elsewhere.</div><br/></div></div><div id="42097982" class="c"><input type="checkbox" id="c-42097982" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#42099086">prev</a><span>|</span><a href="#42097025">next</a><span>|</span><label class="collapse" for="c-42097982">[-]</label><label class="expand" for="c-42097982">[8 more]</label></div><br/><div class="children"><div class="content">Using parens to pass type arguments was one of the things that turned me off on Zig. For a language that prioritizes &quot;no hidden control flow,&quot; it sure did a lot to make various syntax conventions _masquerade_ as control flow instead.</div><br/><div id="42098028" class="c"><input type="checkbox" id="c-42098028" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#42097982">parent</a><span>|</span><a href="#42098042">next</a><span>|</span><label class="collapse" for="c-42098028">[-]</label><label class="expand" for="c-42098028">[6 more]</label></div><br/><div class="children"><div class="content">What do you mean? It <i>is</i> control flow. Generic functions are just higher-order functions that get evaluated at compile time.</div><br/><div id="42098899" class="c"><input type="checkbox" id="c-42098899" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#42097982">root</a><span>|</span><a href="#42098028">parent</a><span>|</span><a href="#42098235">next</a><span>|</span><label class="collapse" for="c-42098899">[-]</label><label class="expand" for="c-42098899">[2 more]</label></div><br/><div class="children"><div class="content">Seeing your reply reminded me why I try not to write comments on this site</div><br/><div id="42099085" class="c"><input type="checkbox" id="c-42099085" checked=""/><div class="controls bullet"><span class="by">hu3</span><span>|</span><a href="#42097982">root</a><span>|</span><a href="#42098899">parent</a><span>|</span><a href="#42098235">next</a><span>|</span><label class="collapse" for="c-42099085">[-]</label><label class="expand" for="c-42099085">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it. Their reply looks normal to me.<p>Is it because they disagree with you?<p>I take these instances as learning opportunities and that makes me want to comment more, not less.</div><br/></div></div></div></div><div id="42098235" class="c"><input type="checkbox" id="c-42098235" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#42097982">root</a><span>|</span><a href="#42098028">parent</a><span>|</span><a href="#42098899">prev</a><span>|</span><a href="#42098042">next</a><span>|</span><label class="collapse" for="c-42098235">[-]</label><label class="expand" for="c-42098235">[3 more]</label></div><br/><div class="children"><div class="content">It is an interesting question of definitions. Is control flow only at runtime? Is `#if` control flow in C?<p>If I had to define it, I would go with runtime-only, but I could see the other way too.</div><br/><div id="42098640" class="c"><input type="checkbox" id="c-42098640" checked=""/><div class="controls bullet"><span class="by">strogonoff</span><span>|</span><a href="#42097982">root</a><span>|</span><a href="#42098235">parent</a><span>|</span><a href="#42098605">next</a><span>|</span><label class="collapse" for="c-42098640">[-]</label><label class="expand" for="c-42098640">[1 more]</label></div><br/><div class="children"><div class="content">Macros can have control flow, so compile-time control flow is definitely possible, but perhaps we trained ourselves to not think of control flow in this way because using complicated compile-time logic is generally frowned upon as a footgun.<p>Perhaps Zig is the language that on purpose blurs the line between what runs when (by basically having what looks like macros integrated into runtime code without any conspicuous hashtaggy syntax), and so a Ziggy would not see compile-time control flow as something weird.</div><br/></div></div><div id="42098605" class="c"><input type="checkbox" id="c-42098605" checked=""/><div class="controls bullet"><span class="by">superb_dev</span><span>|</span><a href="#42097982">root</a><span>|</span><a href="#42098235">parent</a><span>|</span><a href="#42098640">prev</a><span>|</span><a href="#42098042">next</a><span>|</span><label class="collapse" for="c-42098605">[-]</label><label class="expand" for="c-42098605">[1 more]</label></div><br/><div class="children"><div class="content">Zig’s comptime is just code that runs at compile time. Unless we have another term, we must call it control flow</div><br/></div></div></div></div></div></div></div></div><div id="42097025" class="c"><input type="checkbox" id="c-42097025" checked=""/><div class="controls bullet"><span class="by">kvark</span><span>|</span><a href="#42097982">prev</a><span>|</span><a href="#42096861">next</a><span>|</span><label class="collapse" for="c-42097025">[-]</label><label class="expand" for="c-42097025">[15 more]</label></div><br/><div class="children"><div class="content">That “.” substitution of an inferred type is going to fire back. I really appreciate when code has one simple property: you search a type by name and you get all of the places where it’s constructed. Makes it easy to refactor the code and reason about it with <i>local</i> context. It’s the case with Rust, but not C++ or Zig.</div><br/><div id="42099147" class="c"><input type="checkbox" id="c-42099147" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42097025">parent</a><span>|</span><a href="#42097083">next</a><span>|</span><label class="collapse" for="c-42099147">[-]</label><label class="expand" for="c-42099147">[1 more]</label></div><br/><div class="children"><div class="content">This is tedious in Rust when initializing a struct which has nested structs. A language which has type inference at all should at least be consistent about it.</div><br/></div></div><div id="42097083" class="c"><input type="checkbox" id="c-42097083" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42097025">parent</a><span>|</span><a href="#42099147">prev</a><span>|</span><a href="#42097060">next</a><span>|</span><label class="collapse" for="c-42097083">[-]</label><label class="expand" for="c-42097083">[10 more]</label></div><br/><div class="children"><div class="content">Any IDE worth its salt will let you search a type by name and get all the places where it&#x27;s referenced, regardless of type inference.</div><br/><div id="42097299" class="c"><input type="checkbox" id="c-42097299" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097083">parent</a><span>|</span><a href="#42097782">next</a><span>|</span><label class="collapse" for="c-42097299">[-]</label><label class="expand" for="c-42097299">[6 more]</label></div><br/><div class="children"><div class="content">A language that promotes itself as simple and with no hidden control flow etc shouldn&#x27;t need an IDE to find hidden things imho.<p>But that kind of shortcut seems to be optional.</div><br/><div id="42097347" class="c"><input type="checkbox" id="c-42097347" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097299">parent</a><span>|</span><a href="#42097782">next</a><span>|</span><label class="collapse" for="c-42097347">[-]</label><label class="expand" for="c-42097347">[5 more]</label></div><br/><div class="children"><div class="content">&quot;No hidden control flow&quot; is completely orthogonal to &quot;no implicit typing&quot;. I think anyone looking at Zig would immediately recognize that it is firmly in the type inference camp by choice.<p>As far as simplicity, I think their pitch is &quot;simpler than Rust&quot;, not in absolute terms. The whole comptime thing is hardly simple in general.</div><br/><div id="42097819" class="c"><input type="checkbox" id="c-42097819" checked=""/><div class="controls bullet"><span class="by">ablob</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097347">parent</a><span>|</span><a href="#42098169">next</a><span>|</span><label class="collapse" for="c-42097819">[-]</label><label class="expand" for="c-42097819">[2 more]</label></div><br/><div class="children"><div class="content">I think it is simple, but not easy to grasp. I might be quibbling over words, but these things are not quite the same in my eyes.<p><pre><code>  simple &lt;-&gt; complex
    easy &lt;-&gt; difficult</code></pre></div><br/><div id="42098425" class="c"><input type="checkbox" id="c-42098425" checked=""/><div class="controls bullet"><span class="by">chamomeal</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097819">parent</a><span>|</span><a href="#42098169">next</a><span>|</span><label class="collapse" for="c-42098425">[-]</label><label class="expand" for="c-42098425">[1 more]</label></div><br/><div class="children"><div class="content">I know this gets shared all the time, but in case anybody in this thread hasn’t seen the rich hickey talk: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;SxdOUGdseq4?si=3sa6JRg6Ei1Cf_Wl" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;SxdOUGdseq4?si=3sa6JRg6Ei1Cf_Wl</a></div><br/></div></div></div></div><div id="42098169" class="c"><input type="checkbox" id="c-42098169" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097347">parent</a><span>|</span><a href="#42097819">prev</a><span>|</span><a href="#42097675">next</a><span>|</span><label class="collapse" for="c-42098169">[-]</label><label class="expand" for="c-42098169">[1 more]</label></div><br/><div class="children"><div class="content">I am not a big Zig aficionado but I definitely contrast it in my mind moreso with C and C++ rather than Rust.  It definitely aims at being a “better C” sort of language moreso than a “better C++” which Rust seems to be focusing on.</div><br/></div></div><div id="42097675" class="c"><input type="checkbox" id="c-42097675" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097347">parent</a><span>|</span><a href="#42098169">prev</a><span>|</span><a href="#42097782">next</a><span>|</span><label class="collapse" for="c-42097675">[-]</label><label class="expand" for="c-42097675">[1 more]</label></div><br/><div class="children"><div class="content">Their pitch is &quot;A Simple Language&quot; as seen on the website.</div><br/></div></div></div></div></div></div><div id="42097782" class="c"><input type="checkbox" id="c-42097782" checked=""/><div class="controls bullet"><span class="by">Klonoar</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097083">parent</a><span>|</span><a href="#42097299">prev</a><span>|</span><a href="#42097653">next</a><span>|</span><label class="collapse" for="c-42097782">[-]</label><label class="expand" for="c-42097782">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t cover every use case (e.g, reviewing a PR and just trying to - you know - read the PR).</div><br/></div></div><div id="42097653" class="c"><input type="checkbox" id="c-42097653" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097083">parent</a><span>|</span><a href="#42097782">prev</a><span>|</span><a href="#42097060">next</a><span>|</span><label class="collapse" for="c-42097653">[-]</label><label class="expand" for="c-42097653">[2 more]</label></div><br/><div class="children"><div class="content">Better than that would be a language that doesn&#x27;t require &#x2F; almost compel  users (by &quot;almost compel&quot;, I mean the user community, obviously, not the language literally, since it is not sentient) to use an IDE in order to use the language, and using which (language) you can still do what you said above, by just using a text editor.<p>In the same vein as what you said here about orthogonality ( <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42097347">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42097347</a> ), programming languages and IDEs should be orthogonal (and actually are, unless deliberately linked). People were using languages much before IDEs existed. And they got a hell of a lot done using the primitive surrounding tools that existed back then, including, you know, gems like Lisp and the concepts embodied in it, many of which have, much later, been adopted by many modern languages.<p>And I still meant &quot;almost compel&quot;, even by the community, because of course they cannot really compel you. I meant it in the sense of, for example, so many people using VS Code for programming posts.</div><br/><div id="42098554" class="c"><input type="checkbox" id="c-42098554" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097653">parent</a><span>|</span><a href="#42097060">next</a><span>|</span><label class="collapse" for="c-42098554">[-]</label><label class="expand" for="c-42098554">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Better than that would be a language that doesn&#x27;t require &#x2F; almost compel users (by &quot;almost compel&quot;, I mean the user community, obviously, not the language literally, since it is not sentient) to use an IDE in order to use the language, and using which (language) you can still do what you said above, by just using a text editor.<p>It&#x27;s ironic that you complain about this because Zig is probably the most &quot;normal editor&quot; friendly programming language for <i>exactly the kind of thing mentioned in the article</i>.<p>I don&#x27;t need an IDE to figure out the 12 options to that function and fill them out with the correct defaults.  I don&#x27;t have to hunt through 23 layers of mysterious header files to find the declaration I need to figure everything out.  etc.<p>Just try figuring out a foo(12).bar(14).baz(&quot;HELP!&quot;).fixme(&quot;ARRGH!&quot;) construction chain in C++ or Rust without an IDE.  Oof.<p>1) Zig doesn&#x27;t encourage those and 2) in Zig I can trace the @import() calls and actually run &quot;grep&quot; on things.</div><br/></div></div></div></div></div></div><div id="42097060" class="c"><input type="checkbox" id="c-42097060" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#42097025">parent</a><span>|</span><a href="#42097083">prev</a><span>|</span><a href="#42096861">next</a><span>|</span><label class="collapse" for="c-42097060">[-]</label><label class="expand" for="c-42097060">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s meaningfully different in Rust&#x27;s type inference. E.g.:<p><pre><code>  fn example() {
      let p = returns_a_point_type(args);
  }
</code></pre>
Where create_point() is a function from a module (e.g. not even defined in that file) which returns the Point type automatically inferred for p? I mean sure, it&#x27;s technically constructed in the called function... but is that often a useful distinction in context of trying to find all of the places new instances of types are being assigned? In any case, this is something the IDE should be more than capable of making easier for you than manually finding them anyways.</div><br/><div id="42097102" class="c"><input type="checkbox" id="c-42097102" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097060">parent</a><span>|</span><a href="#42096861">next</a><span>|</span><label class="collapse" for="c-42097102">[-]</label><label class="expand" for="c-42097102">[2 more]</label></div><br/><div class="children"><div class="content">GP is talking about how easy it is to find places where the type is instantiated. Seems to me that create_point() will have one such site. And then it’s trivial to find callsites of create_point() with the LSP&#x2F;IDE. What’s the issue?</div><br/><div id="42097161" class="c"><input type="checkbox" id="c-42097161" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#42097025">root</a><span>|</span><a href="#42097102">parent</a><span>|</span><a href="#42096861">next</a><span>|</span><label class="collapse" for="c-42097161">[-]</label><label class="expand" for="c-42097161">[1 more]</label></div><br/><div class="children"><div class="content">The IDE can find all places new variables are assigned to the type (regardless of whether it&#x27;s direct instantiation, return value, inferred, or whatever way it comes about) so what&#x27;s the special value of being able to manually find only the local instantiations find ctrl+f if you&#x27;d still need to manually track down the rest of the paths anyways?</div><br/></div></div></div></div></div></div></div></div><div id="42096861" class="c"><input type="checkbox" id="c-42096861" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#42097025">prev</a><span>|</span><a href="#42096885">next</a><span>|</span><label class="collapse" for="c-42096861">[-]</label><label class="expand" for="c-42096861">[28 more]</label></div><br/><div class="children"><div class="content">A whole lot of cleverness for a language that refuses to compile when you have unused parameters.</div><br/><div id="42097224" class="c"><input type="checkbox" id="c-42097224" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#42096861">parent</a><span>|</span><a href="#42096907">next</a><span>|</span><label class="collapse" for="c-42097224">[-]</label><label class="expand" for="c-42097224">[16 more]</label></div><br/><div class="children"><div class="content">I am not a fan of zig, but I am a fan of discipline so I like this particular design decision.</div><br/><div id="42097322" class="c"><input type="checkbox" id="c-42097322" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097224">parent</a><span>|</span><a href="#42097564">next</a><span>|</span><label class="collapse" for="c-42097322">[-]</label><label class="expand" for="c-42097322">[12 more]</label></div><br/><div class="children"><div class="content">I would be fine with it if it only threw an error about that when building in release mode or if there was a flag to silence it temporarily.<p>But while trying out some things and learning the language I find it annoying. And I don&#x27;t know how it makes me more disciplined when I can just write `_ = unused;` to suppress the error. Even worse, if I forget that assignment in the code the compiler will never warn me about it again even when I want it to.<p>So far I haven&#x27;t seen any upside to this.</div><br/><div id="42099171" class="c"><input type="checkbox" id="c-42099171" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097322">parent</a><span>|</span><a href="#42098661">next</a><span>|</span><label class="collapse" for="c-42099171">[-]</label><label class="expand" for="c-42099171">[1 more]</label></div><br/><div class="children"><div class="content">Just use an editor with language server support and you don&#x27;t need to worry about adding or removing the `_ = unused; &#x2F;&#x2F; autofix`.<p>I wrote a 16kloc Zig project a couple of months ago, and not once was that annoying (<a href="https:&#x2F;&#x2F;floooh.github.io&#x2F;2024&#x2F;08&#x2F;24&#x2F;zig-and-emulators.html" rel="nofollow">https:&#x2F;&#x2F;floooh.github.io&#x2F;2024&#x2F;08&#x2F;24&#x2F;zig-and-emulators.html</a>)</div><br/></div></div><div id="42098661" class="c"><input type="checkbox" id="c-42098661" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097322">parent</a><span>|</span><a href="#42099171">prev</a><span>|</span><a href="#42097454">next</a><span>|</span><label class="collapse" for="c-42098661">[-]</label><label class="expand" for="c-42098661">[1 more]</label></div><br/><div class="children"><div class="content">The way I deal with this in my language, which also bans unused variables, is simple: I delete the unused variable or I use it.<p>My workflow is probably very different from yours I&#x27;m guessing. I have my editor configured to save on every keystroke and I have a watch process that then recompiles my code. I pretty much never manually compile. My compiler is sufficiently fast that I almost never wait more than 1 second to build and run my code. I notice every error immediately and fix them as they arise. This is what I am talking about with discipline. I never allow my code to get into an unexpectedly broken state and don&#x27;t need a linter since I just make the compiler as strict as I would make the linter. This ultimately simplifies both the compiler and the build pipeline.<p>These are all huge upsides for me. The cost of occasionally deleting a definition and then restoring it are for me minor compared to the cost of, say, writing a separate linter or adding feature flags to the compiler (the latter of which doesn&#x27;t fit into my workflow anyway since I auto compile).</div><br/></div></div><div id="42097454" class="c"><input type="checkbox" id="c-42097454" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097322">parent</a><span>|</span><a href="#42098661">prev</a><span>|</span><a href="#42097564">next</a><span>|</span><label class="collapse" for="c-42097454">[-]</label><label class="expand" for="c-42097454">[9 more]</label></div><br/><div class="children"><div class="content">I feel like this is like saying “python shouldn’t care so much about indentation, I’m just trying to learn!”</div><br/><div id="42097498" class="c"><input type="checkbox" id="c-42097498" checked=""/><div class="controls bullet"><span class="by">Phil_Latio</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097454">parent</a><span>|</span><a href="#42097707">next</a><span>|</span><label class="collapse" for="c-42097498">[-]</label><label class="expand" for="c-42097498">[3 more]</label></div><br/><div class="children"><div class="content">Wrong syntax is (and must be) an error. Totally different. The Problem in Go and Zig is that they put theory over practice: No compiler warnings is a good idea in theory, but fails in practice for things like unused variables or unused imports. Defending that makes it even worse and begs the question what other treasures they have burried in their language design. This thread is a testament to that.</div><br/><div id="42098413" class="c"><input type="checkbox" id="c-42098413" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097498">parent</a><span>|</span><a href="#42098767">next</a><span>|</span><label class="collapse" for="c-42098413">[-]</label><label class="expand" for="c-42098413">[1 more]</label></div><br/><div class="children"><div class="content">Forbidding unused imports was a direct response to the practical difficulty of compiling google-scale C++ binaries: <a href="https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;splash.article#TOC_5" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;splash.article#TOC_5</a>.<p>In theory, programmers can just be disciplined enough or set up CI lints for unused imports. In practice…</div><br/></div></div><div id="42098767" class="c"><input type="checkbox" id="c-42098767" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097498">parent</a><span>|</span><a href="#42098413">prev</a><span>|</span><a href="#42097707">next</a><span>|</span><label class="collapse" for="c-42098767">[-]</label><label class="expand" for="c-42098767">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I see the total difference between matching parens and matching defs and refs.<p>Sure, saying &quot;an open paren must have a matching close&quot; is quantitatively different from &quot;a def must have at least one matching ref&quot;, but is it really qualitatively different?</div><br/></div></div></div></div><div id="42097707" class="c"><input type="checkbox" id="c-42097707" checked=""/><div class="controls bullet"><span class="by">alpaca128</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097454">parent</a><span>|</span><a href="#42097498">prev</a><span>|</span><a href="#42097516">next</a><span>|</span><label class="collapse" for="c-42097707">[-]</label><label class="expand" for="c-42097707">[1 more]</label></div><br/><div class="children"><div class="content">You are comparing invalid syntax to a purely cosmetic temporary non-issue.</div><br/></div></div><div id="42097516" class="c"><input type="checkbox" id="c-42097516" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097454">parent</a><span>|</span><a href="#42097707">prev</a><span>|</span><a href="#42097564">next</a><span>|</span><label class="collapse" for="c-42097516">[-]</label><label class="expand" for="c-42097516">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very different thing and you know it. Indentation is syntax. You can&#x27;t just omit braces and expect it to parse.</div><br/><div id="42097810" class="c"><input type="checkbox" id="c-42097810" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097516">parent</a><span>|</span><a href="#42097564">next</a><span>|</span><label class="collapse" for="c-42097810">[-]</label><label class="expand" for="c-42097810">[3 more]</label></div><br/><div class="children"><div class="content">Zig treats unused variables as a syntax error.</div><br/><div id="42098723" class="c"><input type="checkbox" id="c-42098723" checked=""/><div class="controls bullet"><span class="by">smallstepforman</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097810">parent</a><span>|</span><a href="#42097564">next</a><span>|</span><label class="collapse" for="c-42098723">[-]</label><label class="expand" for="c-42098723">[2 more]</label></div><br/><div class="children"><div class="content">Lets say I gather Diag data, which I conditionally print during testing. Are you saying that I cannot leave the diag code in place after I comment out the print function?  Thats unproductive and a major obstacle to using Zig. I’m still pissed at Andrews stance of preventing Tabs, operator overloading, polymorphism, and this just seals my “stay away” stance. I really do want to like Zig, but cannot.</div><br/><div id="42098928" class="c"><input type="checkbox" id="c-42098928" checked=""/><div class="controls bullet"><span class="by">kcbanner</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42098723">parent</a><span>|</span><a href="#42097564">next</a><span>|</span><label class="collapse" for="c-42098928">[-]</label><label class="expand" for="c-42098928">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need to comment out the print function - it could gate its behavior on a comptime-known configuration variable. This would allow you to keep your debug variables in place.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42097564" class="c"><input type="checkbox" id="c-42097564" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097224">parent</a><span>|</span><a href="#42097322">prev</a><span>|</span><a href="#42097416">next</a><span>|</span><label class="collapse" for="c-42097564">[-]</label><label class="expand" for="c-42097564">[1 more]</label></div><br/><div class="children"><div class="content">if you are a fan, you cannot be disciplined, because that is a contradiction in terms.<p>fans are indisciplined. ;)</div><br/></div></div><div id="42097416" class="c"><input type="checkbox" id="c-42097416" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097224">parent</a><span>|</span><a href="#42097564">prev</a><span>|</span><a href="#42096907">next</a><span>|</span><label class="collapse" for="c-42097416">[-]</label><label class="expand" for="c-42097416">[2 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re a fan of discipline then you could also just call lint (or equivalent) before compiling.</div><br/><div id="42097691" class="c"><input type="checkbox" id="c-42097691" checked=""/><div class="controls bullet"><span class="by">em-bee</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097416">parent</a><span>|</span><a href="#42096907">next</a><span>|</span><label class="collapse" for="c-42097691">[-]</label><label class="expand" for="c-42097691">[1 more]</label></div><br/><div class="children"><div class="content">doesn&#x27;t help me when i have to deal with other peoples code. a language that enforces discipline by itself tends to be easier to read.</div><br/></div></div></div></div></div></div><div id="42096907" class="c"><input type="checkbox" id="c-42096907" checked=""/><div class="controls bullet"><span class="by">conradev</span><span>|</span><a href="#42096861">parent</a><span>|</span><a href="#42097224">prev</a><span>|</span><a href="#42097061">next</a><span>|</span><label class="collapse" for="c-42096907">[-]</label><label class="expand" for="c-42096907">[1 more]</label></div><br/><div class="children"><div class="content">With the Zig language server it’s not terribly annoying:<p>_ = foo; &#x2F;&#x2F; autofix</div><br/></div></div><div id="42097061" class="c"><input type="checkbox" id="c-42097061" checked=""/><div class="controls bullet"><span class="by">MineBill</span><span>|</span><a href="#42096861">parent</a><span>|</span><a href="#42096907">prev</a><span>|</span><a href="#42097021">next</a><span>|</span><label class="collapse" for="c-42097061">[-]</label><label class="expand" for="c-42097061">[8 more]</label></div><br/><div class="children"><div class="content">If you want to see true cleverness just go see the last devlog on the zig website.</div><br/><div id="42097185" class="c"><input type="checkbox" id="c-42097185" checked=""/><div class="controls bullet"><span class="by">mtlynch</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097061">parent</a><span>|</span><a href="#42097204">next</a><span>|</span><label class="collapse" for="c-42097185">[-]</label><label class="expand" for="c-42097185">[6 more]</label></div><br/><div class="children"><div class="content">I think this is the post parent is referencing:<p><a href="https:&#x2F;&#x2F;ziglang.org&#x2F;devlog&#x2F;2024&#x2F;#2024-11-04" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;devlog&#x2F;2024&#x2F;#2024-11-04</a><p>It seems like an interesting idea, but I wish Andrew spent more time fleshing it out with complete examples. I can&#x27;t tell if the _ characters are eliding values or if that&#x27;s literally what&#x27;s in his code.</div><br/><div id="42097232" class="c"><input type="checkbox" id="c-42097232" checked=""/><div class="controls bullet"><span class="by">defen</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097185">parent</a><span>|</span><a href="#42097314">next</a><span>|</span><label class="collapse" for="c-42097232">[-]</label><label class="expand" for="c-42097232">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s Zig&#x27;s equivalent of the newtype idiom: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;generics&#x2F;new_types.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;generics&#x2F;new_types...</a> for integers.<p>The underscores mean that it&#x27;s a non-exhaustive enum. An exhaustive enum is where you list all the names of the possible enum values, and other values are illegal. A non-exhaustive enum means any value in the underlying storage is allowed. So at root this code is creating a bunch of new integer types which are all backed by u32 but which can&#x27;t be directly assigned or compared to each other. That means you can&#x27;t accidentally pass a SectionIndex into a function expecting an ObjectFunctionImportIndex, which would be impossible to do if those functions just took raw u32&#x27;s.</div><br/><div id="42098074" class="c"><input type="checkbox" id="c-42098074" checked=""/><div class="controls bullet"><span class="by">mtlynch</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097232">parent</a><span>|</span><a href="#42097314">next</a><span>|</span><label class="collapse" for="c-42098074">[-]</label><label class="expand" for="c-42098074">[2 more]</label></div><br/><div class="children"><div class="content">Ah, thanks! I tried converting that example to Zig:<p><a href="https:&#x2F;&#x2F;tars.run&#x2F;t3eInpPFAgc" rel="nofollow">https:&#x2F;&#x2F;tars.run&#x2F;t3eInpPFAgc</a><p>Is that the idea?<p>You can do the same thing wrapping integers with structs, but enum makes it slightly more concise?</div><br/><div id="42098243" class="c"><input type="checkbox" id="c-42098243" checked=""/><div class="controls bullet"><span class="by">ImprobableTruth</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42098074">parent</a><span>|</span><a href="#42097314">next</a><span>|</span><label class="collapse" for="c-42098243">[-]</label><label class="expand" for="c-42098243">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s how it works.<p>I think in Zig for new types you&#x27;d use enums for ints and packed structs for more complex types.</div><br/></div></div></div></div></div></div><div id="42097314" class="c"><input type="checkbox" id="c-42097314" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097185">parent</a><span>|</span><a href="#42097232">prev</a><span>|</span><a href="#42097204">next</a><span>|</span><label class="collapse" for="c-42097314">[-]</label><label class="expand" for="c-42097314">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an interesting pattern, but it&#x27;s a shame there&#x27;s no way to efficiently use one of those OptionalXIndex with zig&#x27;s actual null syntax, `?` and `orelse` and etc. It would be smoother if you could constraint the nonexhaustive range, and let the compiler use an unused value as the niche for null. Maybe something like `enum(u32) { _ = 1...std.math.maxInt(u32) }`</div><br/><div id="42097566" class="c"><input type="checkbox" id="c-42097566" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097314">parent</a><span>|</span><a href="#42097204">next</a><span>|</span><label class="collapse" for="c-42097566">[-]</label><label class="expand" for="c-42097566">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an issue tracking that: <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;3806">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;3806</a></div><br/></div></div></div></div></div></div><div id="42097204" class="c"><input type="checkbox" id="c-42097204" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#42096861">root</a><span>|</span><a href="#42097061">parent</a><span>|</span><a href="#42097185">prev</a><span>|</span><a href="#42097021">next</a><span>|</span><label class="collapse" for="c-42097204">[-]</label><label class="expand" for="c-42097204">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just newtype.</div><br/></div></div></div></div><div id="42097021" class="c"><input type="checkbox" id="c-42097021" checked=""/><div class="controls bullet"><span class="by">AlienRobot</span><span>|</span><a href="#42096861">parent</a><span>|</span><a href="#42097061">prev</a><span>|</span><a href="#42097473">next</a><span>|</span><label class="collapse" for="c-42097021">[-]</label><label class="expand" for="c-42097021">[1 more]</label></div><br/><div class="children"><div class="content">And has no multi-line comments.</div><br/></div></div></div></div><div id="42096885" class="c"><input type="checkbox" id="c-42096885" checked=""/><div class="controls bullet"><span class="by">andout_</span><span>|</span><a href="#42096861">prev</a><span>|</span><a href="#42097165">next</a><span>|</span><label class="collapse" for="c-42096885">[-]</label><label class="expand" for="c-42096885">[6 more]</label></div><br/><div class="children"><div class="content">The article spends a lot of time justifying a syntax that really just papers over Zig&#x27;s lack of parameter pack support. The same pattern in Rust would just use variadic templates&#x2F;generics.</div><br/><div id="42097153" class="c"><input type="checkbox" id="c-42097153" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#42096885">parent</a><span>|</span><a href="#42097518">next</a><span>|</span><label class="collapse" for="c-42097153">[-]</label><label class="expand" for="c-42097153">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The same pattern in Rust would just use variadic templates&#x2F;generics.<p>Are you sure Rust has variadic generics? Last I checked, the extent of progress was a draft RFC. <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;376">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;376</a></div><br/><div id="42097798" class="c"><input type="checkbox" id="c-42097798" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#42096885">root</a><span>|</span><a href="#42097153">parent</a><span>|</span><a href="#42097518">next</a><span>|</span><label class="collapse" for="c-42097798">[-]</label><label class="expand" for="c-42097798">[1 more]</label></div><br/><div class="children"><div class="content">To be super clear: it does not.</div><br/></div></div></div></div><div id="42097518" class="c"><input type="checkbox" id="c-42097518" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#42096885">parent</a><span>|</span><a href="#42097153">prev</a><span>|</span><a href="#42096921">next</a><span>|</span><label class="collapse" for="c-42097518">[-]</label><label class="expand" for="c-42097518">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>The same pattern in Rust would just use variadic templates&#x2F;generics.</i><p>Man, must be nice to be a time traveler from the 2030s. How does Covid25 turn out?</div><br/></div></div><div id="42096921" class="c"><input type="checkbox" id="c-42096921" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42096885">parent</a><span>|</span><a href="#42097518">prev</a><span>|</span><a href="#42097474">next</a><span>|</span><label class="collapse" for="c-42096921">[-]</label><label class="expand" for="c-42096921">[1 more]</label></div><br/><div class="children"><div class="content">This comment might be valuable if you added some elaboration, and an example of what it looks like.</div><br/></div></div></div></div><div id="42097165" class="c"><input type="checkbox" id="c-42097165" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42096885">prev</a><span>|</span><label class="collapse" for="c-42097165">[-]</label><label class="expand" for="c-42097165">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s amazing they couldn&#x27;t figure out how to get f(.{}) down to just f({}).  Like here is this brace enclosed thing being matched against the argument type.</div><br/><div id="42097644" class="c"><input type="checkbox" id="c-42097644" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42097165">parent</a><span>|</span><a href="#42098691">next</a><span>|</span><label class="collapse" for="c-42097644">[-]</label><label class="expand" for="c-42097644">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how it is in c++ so I&#x27;m used to it now, but I don&#x27;t think I mind the dot. It differentiates a block scope from a struct initializer.</div><br/><div id="42098538" class="c"><input type="checkbox" id="c-42098538" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42097165">root</a><span>|</span><a href="#42097644">parent</a><span>|</span><a href="#42098691">next</a><span>|</span><label class="collapse" for="c-42098538">[-]</label><label class="expand" for="c-42098538">[2 more]</label></div><br/><div class="children"><div class="content">In C&#x27;s grammar you would need to wrap the {} as ({}) in order to get into a block expression scope from an argument list.</div><br/><div id="42098919" class="c"><input type="checkbox" id="c-42098919" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42097165">root</a><span>|</span><a href="#42098538">parent</a><span>|</span><a href="#42098691">next</a><span>|</span><label class="collapse" for="c-42098919">[-]</label><label class="expand" for="c-42098919">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s GNU C, not standard C.<p>Standard C has no such feature as blocks being expressions.<p>Compound literals are grotesque. The braces have to be proceeded by cast syntax indicating the type. It could be subject to inference. Maybe the current draft has something.</div><br/></div></div></div></div></div></div><div id="42098691" class="c"><input type="checkbox" id="c-42098691" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42097165">parent</a><span>|</span><a href="#42097644">prev</a><span>|</span><label class="collapse" for="c-42098691">[-]</label><label class="expand" for="c-42098691">[1 more]</label></div><br/><div class="children"><div class="content">Those mean different things.<p>f(.{}) is calling a function, which takes a struct, using an in-place constructor which provides the default arguments for the necessary struct type.<p>f({}) is passing an instance of `void` to a function with a `void` type parameter. Do you need to do this, specifically? No. But you can.<p><pre><code>  fn voidPass(v: void) void {
      _ = v;
  }
  
  test &quot;void pass&quot; {
      voidPass({});
  }</code></pre></div><br/></div></div></div></div></div></div></div></div></div></body></html>