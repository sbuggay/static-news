<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693645255709" as="style"/><link rel="stylesheet" href="styles.css?v=1693645255709"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/coroutines-philosophy/">Philosophy of Coroutines</a> <span class="domain">(<a href="https://www.chiark.greenend.org.uk">www.chiark.greenend.org.uk</a>)</span></div><div class="subtext"><span>Tomte</span> | <span>40 comments</span></div><br/><div><div id="37359596" class="c"><input type="checkbox" id="c-37359596" checked=""/><div class="controls bullet"><span class="by">samsquire</span><span>|</span><a href="#37358420">next</a><span>|</span><label class="collapse" for="c-37359596">[-]</label><label class="expand" for="c-37359596">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for this article. I also really like coroutines but how they manifest in codebases can sometimes be hard to follow (async Rust, async Python).<p>I have played around with protothreads and use generators in Python but Marce Coll has an amazing blog post about coroutines in assembly, which is down right now.<p>If you save the RSP register somewhere and restore it later, you can switch stacks.<p>I&#x27;m currently working on an architecture to unify coroutines and threads. I am taking inspiration from &quot;Bulk synchronous parallel programming&quot; in that I am using barriers. I hope to apply structured concurrency to it too. A coroutine can be remote in a thread or in a different current thread and parallel.<p>I am curious about stackless python.</div><br/></div></div><div id="37358420" class="c"><input type="checkbox" id="c-37358420" checked=""/><div class="controls bullet"><span class="by">runald</span><span>|</span><a href="#37359596">prev</a><span>|</span><a href="#37354825">next</a><span>|</span><label class="collapse" for="c-37358420">[-]</label><label class="expand" for="c-37358420">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;coroutines.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.chiark.greenend.org.uk&#x2F;~sgtatham&#x2F;coroutines.html</a><p><pre><code>  int function(void) {
      static int i, state = 0;
      switch (state) {
          case 0: &#x2F;* start of function *&#x2F;
          for (i = 0; i &lt; 10; i++) {
              state = 1; &#x2F;* so we will come back to &quot;case 1&quot; *&#x2F;
              return i;
              case 1:; &#x2F;* resume control straight after the return *&#x2F;
          }
      }
  }


</code></pre>
Huh, I didn&#x27;t know you could put <i>case</i> statements arbitrarily anywhere inside a switch block in C. Past the initial WTF, it&#x27;s a nice hack for implementing coroutines.</div><br/><div id="37358516" class="c"><input type="checkbox" id="c-37358516" checked=""/><div class="controls bullet"><span class="by">zoky</span><span>|</span><a href="#37358420">parent</a><span>|</span><a href="#37354825">next</a><span>|</span><label class="collapse" for="c-37358516">[-]</label><label class="expand" for="c-37358516">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah, you can toss ‘em in just about anywhere. The most well-known application of this would be Duff’s device: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Duff%27s_device" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Duff%27s_device</a></div><br/></div></div></div></div><div id="37354825" class="c"><input type="checkbox" id="c-37354825" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37358420">prev</a><span>|</span><a href="#37359028">next</a><span>|</span><label class="collapse" for="c-37354825">[-]</label><label class="expand" for="c-37354825">[11 more]</label></div><br/><div class="children"><div class="content">Coroutines really are powerful. Here&#x27;s to hoping Rust stabilizes generators (full semicoroutines, not the enhanced iteration construct) sooner rather than later. It would give programmers greater control to express state machine logic without being boxed into async&#x2F;await. I do wonder if the `Context` parameter used for async tasks is appropriate for arbitrary generators, so if someone could chime in on this I would be grateful.</div><br/><div id="37359341" class="c"><input type="checkbox" id="c-37359341" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#37354825">parent</a><span>|</span><a href="#37356004">next</a><span>|</span><label class="collapse" for="c-37359341">[-]</label><label class="expand" for="c-37359341">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think `Context` is appropriate for generic generators, since it has no way to get data in or out of the `async` block. The more general `generator` feature allows a custom context type though.</div><br/></div></div><div id="37356004" class="c"><input type="checkbox" id="c-37356004" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#37354825">parent</a><span>|</span><a href="#37359341">prev</a><span>|</span><a href="#37356266">next</a><span>|</span><label class="collapse" for="c-37356004">[-]</label><label class="expand" for="c-37356004">[6 more]</label></div><br/><div class="children"><div class="content">Or provide continuations and use them to implement coroutines.</div><br/><div id="37356341" class="c"><input type="checkbox" id="c-37356341" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37356004">parent</a><span>|</span><a href="#37357901">next</a><span>|</span><label class="collapse" for="c-37356341">[-]</label><label class="expand" for="c-37356341">[4 more]</label></div><br/><div class="children"><div class="content">A couple of us have been experimenting with deliminited continuations and I think it’s gonna take off soon in TS<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;uRbqLGj_6mI?si=kgKKjpCnehJ9bpIG" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;uRbqLGj_6mI?si=kgKKjpCnehJ9bpIG</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;neurosnap&#x2F;starfx">https:&#x2F;&#x2F;github.com&#x2F;neurosnap&#x2F;starfx</a>
<a href="https:&#x2F;&#x2F;github.com&#x2F;thefrontside&#x2F;effection&#x2F;tree&#x2F;v3">https:&#x2F;&#x2F;github.com&#x2F;thefrontside&#x2F;effection&#x2F;tree&#x2F;v3</a></div><br/><div id="37356698" class="c"><input type="checkbox" id="c-37356698" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37356341">parent</a><span>|</span><a href="#37357235">next</a><span>|</span><label class="collapse" for="c-37356698">[-]</label><label class="expand" for="c-37356698">[1 more]</label></div><br/><div class="children"><div class="content">To my understanding, delimited continuations and coroutines are equivalent in power. Out of curiosity, can delimited continuations be implemented as efficiently (in Rust or otherwise) as stackless coroutines?</div><br/></div></div><div id="37357235" class="c"><input type="checkbox" id="c-37357235" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37356341">parent</a><span>|</span><a href="#37356698">prev</a><span>|</span><a href="#37357901">next</a><span>|</span><label class="collapse" for="c-37357235">[-]</label><label class="expand" for="c-37357235">[2 more]</label></div><br/><div class="children"><div class="content">These don’t look like continuations to me, just ways to use generators? Continuations would involve reifying the current control flow into a value, which these examples don’t seem to do and still rely on generators to yield control.</div><br/><div id="37357361" class="c"><input type="checkbox" id="c-37357361" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37357235">parent</a><span>|</span><a href="#37357901">next</a><span>|</span><label class="collapse" for="c-37357361">[-]</label><label class="expand" for="c-37357361">[1 more]</label></div><br/><div class="children"><div class="content">These libraries rely on deliminited continuations:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;thefrontside&#x2F;continuation">https:&#x2F;&#x2F;github.com&#x2F;thefrontside&#x2F;continuation</a><p>Because of this tiny implementation we are able to express any async flow construct with less code than relying on something like async&#x2F;await or callbacks.</div><br/></div></div></div></div></div></div><div id="37357901" class="c"><input type="checkbox" id="c-37357901" checked=""/><div class="controls bullet"><span class="by">smasher164</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37356004">parent</a><span>|</span><a href="#37356341">prev</a><span>|</span><a href="#37356266">next</a><span>|</span><label class="collapse" for="c-37357901">[-]</label><label class="expand" for="c-37357901">[1 more]</label></div><br/><div class="children"><div class="content">Single-shot continuations in the form of lexical effect handlers would be a good fit for a systems language nowadays. I feel it&#x27;s a bit too late to staple that onto Rust though.</div><br/></div></div></div></div><div id="37356266" class="c"><input type="checkbox" id="c-37356266" checked=""/><div class="controls bullet"><span class="by">pflanze</span><span>|</span><a href="#37354825">parent</a><span>|</span><a href="#37356004">prev</a><span>|</span><a href="#37359028">next</a><span>|</span><label class="collapse" for="c-37356266">[-]</label><label class="expand" for="c-37356266">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using genawaiter[1] for writing generators in Rust. Are there things you can&#x27;t build on top of async-await? Or is it just that it&#x27;s simpler without that indirection?<p>[1]: <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;genawaiter" rel="nofollow noreferrer">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;genawaiter</a></div><br/><div id="37356673" class="c"><input type="checkbox" id="c-37356673" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37356266">parent</a><span>|</span><a href="#37357992">next</a><span>|</span><label class="collapse" for="c-37356673">[-]</label><label class="expand" for="c-37356673">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking that the semantics around async&#x2F;await (function coloring) would make some usages more frustrating. This crate probably sidesteps that, if it is a problem at all. I have a bad habit of not dabbling around when I lack understanding.</div><br/></div></div><div id="37357992" class="c"><input type="checkbox" id="c-37357992" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37354825">root</a><span>|</span><a href="#37356266">parent</a><span>|</span><a href="#37356673">prev</a><span>|</span><a href="#37359028">next</a><span>|</span><label class="collapse" for="c-37357992">[-]</label><label class="expand" for="c-37357992">[1 more]</label></div><br/><div class="children"><div class="content">This feels circular, since async&#x2F;await is futures which are generators</div><br/></div></div></div></div></div></div><div id="37359028" class="c"><input type="checkbox" id="c-37359028" checked=""/><div class="controls bullet"><span class="by">grumbel</span><span>|</span><a href="#37354825">prev</a><span>|</span><a href="#37359121">next</a><span>|</span><label class="collapse" for="c-37359028">[-]</label><label class="expand" for="c-37359028">[1 more]</label></div><br/><div class="children"><div class="content">The one big issue I have with coroutines is that they are often impossible to serialize. With a state machine you can just take your state and write it to disk, but with coroutines that state is hidden in the stack of the coroutine and the stack is not a first-class data structure you can access by normal programming language means.</div><br/></div></div><div id="37359121" class="c"><input type="checkbox" id="c-37359121" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#37359028">prev</a><span>|</span><a href="#37356352">next</a><span>|</span><label class="collapse" for="c-37359121">[-]</label><label class="expand" for="c-37359121">[3 more]</label></div><br/><div class="children"><div class="content">I think that the biggest missing &quot;killer feature&quot; for systems programming languages is the ability to treat stackless coroutines as just another &quot;plain old data&quot; struct. Here&#x27;s a list of things I can do with structs that I can&#x27;t do with C++ coroutines or Rust generator objects (much to my chagrin):<p>* Get their size&#x2F;alignment at compile time<p>* Allocate them on the stack<p>* Allocate them in a memory region of my choosing<p>* Create a contiguous array of them<p>* Copy them<p>* Serialize&#x2F;deserialize them<p>Imagine being able to save coroutines to your filesystem, reboot your machine, restart your program, and have it pick up where it left off. Or, migrating lots of actively running coroutines to another machine by serializing it and sending it over the network. Or creating a high-performance, high-concurrency event loop using a giant map of coroutine objects.</div><br/><div id="37359254" class="c"><input type="checkbox" id="c-37359254" checked=""/><div class="controls bullet"><span class="by">ttctciyf</span><span>|</span><a href="#37359121">parent</a><span>|</span><a href="#37359360">next</a><span>|</span><label class="collapse" for="c-37359254">[-]</label><label class="expand" for="c-37359254">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you missed that the article explicitly talks about the cloning&#x2F;deep copy of coroutines:<p>&gt; Using my C&#x2F;C++ preprocessor coroutine system, this is perfectly possible. In that system, all the persistent variables of the coroutine – including the state variable that says where to resume from next – have to live in an explicitly declared structure (in C) or be members of a class (in C++). Either way, there’s no difficulty with making an exact copy [...]<p>&gt; After you do that, you’ve got two copies of the coroutine, and each of them will resume from the same part of the code when it next runs [...] This isn’t a deliberate feature of my preprocessor system; it’s just a thing that drops out naturally from the implementation strategy<p>Resuming from an on-disk copy seems tougher - you need to supply all relevant execution context.</div><br/></div></div><div id="37359360" class="c"><input type="checkbox" id="c-37359360" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37359121">parent</a><span>|</span><a href="#37359254">prev</a><span>|</span><a href="#37356352">next</a><span>|</span><label class="collapse" for="c-37359360">[-]</label><label class="expand" for="c-37359360">[1 more]</label></div><br/><div class="children"><div class="content">You can do 1-4 with Zig frames, but 5 and 6 are tougher since there&#x27;s no guarantee that you won&#x27;t end up with internal pointers.</div><br/></div></div></div></div><div id="37356352" class="c"><input type="checkbox" id="c-37356352" checked=""/><div class="controls bullet"><span class="by">krylon</span><span>|</span><a href="#37359121">prev</a><span>|</span><a href="#37359269">next</a><span>|</span><label class="collapse" for="c-37356352">[-]</label><label class="expand" for="c-37356352">[2 more]</label></div><br/><div class="children"><div class="content">Lua makes coroutines first class citizens. I have only built one toy project with it, but it was very enjoyable. Someone even managed to implement Erlang-style concurrency on top of Lua&#x27;s coroutines. That was a lot of fun to play with. (&#x2F;stares into the night, reminiscing&#x2F;)</div><br/><div id="37356855" class="c"><input type="checkbox" id="c-37356855" checked=""/><div class="controls bullet"><span class="by">max_k</span><span>|</span><a href="#37356352">parent</a><span>|</span><a href="#37359269">next</a><span>|</span><label class="collapse" for="c-37356855">[-]</label><label class="expand" for="c-37356855">[1 more]</label></div><br/><div class="children"><div class="content">If you like Lua coroutines and C++20 coroutines, I have written a piece of code that allows to combine both: <a href="https:&#x2F;&#x2F;github.com&#x2F;CM4all&#x2F;libcommon&#x2F;blob&#x2F;master&#x2F;src&#x2F;lua&#x2F;CoAwaitable.hxx">https:&#x2F;&#x2F;github.com&#x2F;CM4all&#x2F;libcommon&#x2F;blob&#x2F;master&#x2F;src&#x2F;lua&#x2F;CoAw...</a><p>It&#x27;s used for example by our &quot;myproxy&quot; project: <a href="https:&#x2F;&#x2F;github.com&#x2F;CM4all&#x2F;myproxy&#x2F;blob&#x2F;master&#x2F;src&#x2F;Connection.cxx">https:&#x2F;&#x2F;github.com&#x2F;CM4all&#x2F;myproxy&#x2F;blob&#x2F;master&#x2F;src&#x2F;Connection...</a> (Ctrl-F Lua::CoAwaitable) - a Lua coroutine is launched from within a C++20 coroutine and the C++20 coroutine awaits the Lua coroutine. Everything integrated in a non-blocking I&#x2F;O event loop.</div><br/></div></div></div></div><div id="37359269" class="c"><input type="checkbox" id="c-37359269" checked=""/><div class="controls bullet"><span class="by">vinay_ys</span><span>|</span><a href="#37356352">prev</a><span>|</span><a href="#37357414">next</a><span>|</span><label class="collapse" for="c-37359269">[-]</label><label class="expand" for="c-37359269">[1 more]</label></div><br/><div class="children"><div class="content">This takes me back more than 20 years when I first started to use Putty and learnt about Simon Tatham, and incidentally I learnt about coroutines at the same time from another source and later learned that PuTTY used them!</div><br/></div></div><div id="37357414" class="c"><input type="checkbox" id="c-37357414" checked=""/><div class="controls bullet"><span class="by">exfalso</span><span>|</span><a href="#37359269">prev</a><span>|</span><a href="#37357622">next</a><span>|</span><label class="collapse" for="c-37357414">[-]</label><label class="expand" for="c-37357414">[7 more]</label></div><br/><div class="children"><div class="content">I think coroutines are one of those abstractions that are easy to fall in love with, but in reality they do more harm than good. There are extremely few circumstances where coroutines are useful, and those are <i>not</i> the ones most people use them for.<p>Coroutines are <i>not</i> cheap threads, and if they are used as such, your software will end up either leaking resources or contending on resources under any considerable load. A very simple demonstrative is: yes you can have a million coroutines, but you have 10 database connections. No matter how smart you make the scheduler, you will be bound by your IO resources in almost all applications. (This also hints at the few instances where coroutines <i>can</i> be useful: pure compute).<p>The above problem is exacerbated by coroutines literally undoing one of the most powerful abstractions for resource management: RAII. Your resource allocations stop being tied to lexical scope, and a misplaced yield will leak the resource very easily. And even if you know about this, it is quite difficult to do correct resource management or provide proper backpressure, and the resulting code will be unintuitive and difficult to maintain. You&#x27;ll need to introduce explicit queues&#x2F;semaphore-like structures in places where a simple threadpool would have sufficed for all your resource management needs.<p>So what are the examples where coroutines <i>are</i> useful? Pure compute. This is very <i>very</i> rare, but for example one could use coroutines to fuse stream processors and create bounded-memory compute. There was also one paper that described how software transactional memory was used to essentially race coroutines to find optimal circuitry layouts. This kind of compute is kind of it. And this is most definitely not what people are using coroutines for. Instead, they throw around &quot;threads are expensive&quot; and treat Rust async like Java futures, completely missing the point.<p>Sidenote: the particular way that Rust async was adopted, and specifically the tokio family of libraries is a whole other hellhole which sidetracked the entire Rust ecosystem, but admittedly this is not the coroutine concept&#x27;s fault.</div><br/><div id="37357759" class="c"><input type="checkbox" id="c-37357759" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#37357414">parent</a><span>|</span><a href="#37358009">next</a><span>|</span><label class="collapse" for="c-37357759">[-]</label><label class="expand" for="c-37357759">[5 more]</label></div><br/><div class="children"><div class="content">Coroutines and concurrency are orthogonal. Coroutines can be used as a primitive in concurrent programs, but the core concept is that of a suspended computation; think replacing callbacks with &#x27;async&#x27;, not replacing threads with coroutines.<p>For example, coroutines work great in GUI code because typically you have an event loop, and you want to schedule work to return a value (or send an event) later on during some future execution of the loop. This can all be done on a single thread without bringing concurrency into the mix.<p>As far as resource contention, I can provide a couple of counter-examples. In Kotlin, if you know you are performing I&#x2F;O-bound work, you use the &quot;IO&quot; scheduler, which uses an unbounded thread pool to block a thread per-task. In Java, Project Loom makes this altogether unnecessary by yielding IO-blocked virtual threads for you.</div><br/><div id="37359457" class="c"><input type="checkbox" id="c-37359457" checked=""/><div class="controls bullet"><span class="by">exfalso</span><span>|</span><a href="#37357414">root</a><span>|</span><a href="#37357759">parent</a><span>|</span><a href="#37358660">next</a><span>|</span><label class="collapse" for="c-37359457">[-]</label><label class="expand" for="c-37359457">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not talking about whether the scheduler <i>can</i> block the task on IO. This is trivial.<p>Let&#x27;s see a couple of examples.<p>Database connection contention:<p><pre><code>    async function() {
      let connection = getConnection().await; &#x2F;&#x2F; Allocate resource
      connection.execute(&quot;SELECT &#x27;Hello World!&#x27;&quot;).await; &#x2F;&#x2F; &lt;- yield to the scheduler, connection is held onto until continuation is scheduled
      connection.close().await; &#x2F;&#x2F; Release resource
    }
</code></pre>
This is an extremely trivial example, and this already leaks resources. If you launch 100 of these then there is a chance that there will be 100 open connections at the same time. Had you used a simple thread pool, the size of that pool limits the number of open connections.<p>Memory leak:<p><pre><code>    async function() {
      let object = stream.readLargeObject().await; &lt;- Memory allocated
      process1(object).await; &lt;- Memory leaked to scheduler until continuation is scheduled
      return process2(object).await;
    }
</code></pre>
Again, very trivial example, already leaking. process1 and process2 are not tied together with direct control flow edges but rather the flow dispatches through the coroutine scheduler, and they are holding onto the resources while sitting in the scheduler&#x27;s bookkeeping. Again, yields disrupt the allocation&#x27;s scope, and if you launch a lot of these coroutines you&#x27;ll run out of memory.<p>This issue is made worse if you need to use <i>combinations</i> of resource allocations. For example DB connection + memory allocation or network + disk or even network+network are common combos. Depending on the complexity of the allocation nesting you can run into very nasty contention issues or even deadlocks, where - again - a threadpool would have worked well. N threads, N number of resources. Done.<p>I want to stress that there <i>are</i> ways to mitigate the above (queues&#x2F;resource pools&#x2F;semaphores), however they are not nearly as intuitive as using a threadpool, and you need to be constantly aware of these leaks when you&#x27;re writing async code.</div><br/></div></div><div id="37358660" class="c"><input type="checkbox" id="c-37358660" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#37357414">root</a><span>|</span><a href="#37357759">parent</a><span>|</span><a href="#37359457">prev</a><span>|</span><a href="#37357970">next</a><span>|</span><label class="collapse" for="c-37358660">[-]</label><label class="expand" for="c-37358660">[1 more]</label></div><br/><div class="children"><div class="content">You’re confusing concurrency with parallelism. A single-threaded event loop a la node is indeed concurrent. Multiple threads a la the Kotlin IO pool you mention would be both concurrent and parallel. Concurrency isn’t about different parts of the code <i>actually</i> executing at the same time, merely about being able to structure and think about code as if it were executing that way.</div><br/></div></div><div id="37357970" class="c"><input type="checkbox" id="c-37357970" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#37357414">root</a><span>|</span><a href="#37357759">parent</a><span>|</span><a href="#37358660">prev</a><span>|</span><a href="#37358385">next</a><span>|</span><label class="collapse" for="c-37357970">[-]</label><label class="expand" for="c-37357970">[1 more]</label></div><br/><div class="children"><div class="content">Your understanding of the use of coroutines is much superior to the parent post.<p>Think &quot;cooperating sequential processes&quot;.  If you don&#x27;t have that, coroutines are likely not fit for the problem.</div><br/></div></div><div id="37358385" class="c"><input type="checkbox" id="c-37358385" checked=""/><div class="controls bullet"><span class="by">aatd86</span><span>|</span><a href="#37357414">root</a><span>|</span><a href="#37357759">parent</a><span>|</span><a href="#37357970">prev</a><span>|</span><a href="#37358009">next</a><span>|</span><label class="collapse" for="c-37358385">[-]</label><label class="expand" for="c-37358385">[1 more]</label></div><br/><div class="children"><div class="content">Is it perhaps a bit more nuanced?<p>Green threads à la Go with channels would be a way to deal with several communicating &quot;event loops&quot; at the same time via coroutines, hence the name goroutines?</div><br/></div></div></div></div><div id="37358009" class="c"><input type="checkbox" id="c-37358009" checked=""/><div class="controls bullet"><span class="by">verdagon</span><span>|</span><a href="#37357414">parent</a><span>|</span><a href="#37357759">prev</a><span>|</span><a href="#37357622">next</a><span>|</span><label class="collapse" for="c-37358009">[-]</label><label class="expand" for="c-37358009">[1 more]</label></div><br/><div class="children"><div class="content">I believe coroutines are mostly unrelated to RAII. One can still have coroutines in a single ownership world and guarantee destructors are called.<p>(If not, I have a lot of redesigning to do for Vale!)<p>Also, doesn&#x27;t your mentioned problem also happen for full threads? I&#x27;d imagine they&#x27;d contend for those 10 connections no matter how you did your concurrency.</div><br/></div></div></div></div><div id="37357622" class="c"><input type="checkbox" id="c-37357622" checked=""/><div class="controls bullet"><span class="by">stephc_int13</span><span>|</span><a href="#37357414">prev</a><span>|</span><a href="#37357940">next</a><span>|</span><label class="collapse" for="c-37357622">[-]</label><label class="expand" for="c-37357622">[3 more]</label></div><br/><div class="children"><div class="content">I admit that coroutines can make the code simpler to write and also to understand, they can feel natural in some cases to replace complex state machines.<p>But I am not in favor of &quot;magical&quot; abstractions, especially anything related to hidden control flow. I don&#x27;t have much experience with coroutines but I have the intuition that tracking bugs can be nasty.</div><br/><div id="37359526" class="c"><input type="checkbox" id="c-37359526" checked=""/><div class="controls bullet"><span class="by">movpasd</span><span>|</span><a href="#37357622">parent</a><span>|</span><a href="#37357955">next</a><span>|</span><label class="collapse" for="c-37359526">[-]</label><label class="expand" for="c-37359526">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m totally on board with fewer magical abstractions. But I would consider coroutines to be at the same layer of abstraction as simple procedures.<p>Now, you can build coroutine systems on top of procedural semantics (and trivially vice-versa) — indeed this is how many coroutine implementations are built under the hood — and since we&#x27;re so used to procedural programming it&#x27;s natural to assume that coroutines are a magical abstraction layer on top of procedures.<p>But from a strictly semantic perspective (disregarding implementation), I think coroutines are best thought of as their own distinct class of non-procedural control flow, as generalisations of procedures.<p>Being generalisations, coroutines provide fewer restrictions, but also fewer guarantees than procedures. So I don&#x27;t think they&#x27;re appropriate for all code. Specifically, coroutines kill temporal proximity guarantees: if everything is a coroutine, everything can suspend at any time (to be fair, any procedure can fail to return, but this is rarer). It&#x27;s similar to exceptions in that respect.<p>So your point about tracking bugs is extremely relevant. With great power comes great responsibility. The current approach is to isolate coroutine functionality from the procedural core (either by very explicitly making them objects like Python generators, or by colouring them and requiring them to be executed in a context like in Kotlin). But I don&#x27;t think they are quite as magical as they seem, rather just different.<p>(Tangential note: I&#x27;ve always thought it would be interesting to have a language that flipped this, and embedded procedural guarantees within an all-coroutine (or even all-continuations) semantic structure.)</div><br/></div></div><div id="37357955" class="c"><input type="checkbox" id="c-37357955" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#37357622">parent</a><span>|</span><a href="#37359526">prev</a><span>|</span><a href="#37357940">next</a><span>|</span><label class="collapse" for="c-37357955">[-]</label><label class="expand" for="c-37357955">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps with experience with coroutines in the right problem environment you might have a different idea.<p>There isn&#x27;t really anything magical about them. They are a good way to build cooperating sequential processes.<p>My experience is that coroutines not only made it easier to find bugs in interrupt driven code, but it made it easier to avoid them in the first place, as the code in front of you was much easier to understand.</div><br/></div></div></div></div><div id="37357940" class="c"><input type="checkbox" id="c-37357940" checked=""/><div class="controls bullet"><span class="by">wglb</span><span>|</span><a href="#37357622">prev</a><span>|</span><a href="#37358183">next</a><span>|</span><label class="collapse" for="c-37357940">[-]</label><label class="expand" for="c-37357940">[1 more]</label></div><br/><div class="children"><div class="content">I first used coroutines in the 1970s in Sigma 5 assembler for an application that was in an interrupt-rich environment.<p>Once we tuned our approach, using a macro or two, the code for an process attached to an interrupt could hardly have been clearer. As a result, we were able to build a program to dial out and send text (this was in the days when the data modem and the dialing modem were separate) with no multi-thread errors and only one single-thread error.<p>This was significantly easier than doing coroutines in C, which is allegedly close to the machine.<p>In a later project, we discovered that bliss 36 had a built-in coroutine feature, but we didn&#x27;t see any advantage to using this in building a compiler.</div><br/></div></div><div id="37358183" class="c"><input type="checkbox" id="c-37358183" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37357940">prev</a><span>|</span><a href="#37357941">next</a><span>|</span><label class="collapse" for="c-37358183">[-]</label><label class="expand" for="c-37358183">[1 more]</label></div><br/><div class="children"><div class="content">Setting up pipelines seem fairly easy to do in JavaScript using async&#x2F;await. Unfortunately, the Streams API is complicated and so are Node’s streams. I ended up inventing my own.</div><br/></div></div><div id="37357941" class="c"><input type="checkbox" id="c-37357941" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#37358183">prev</a><span>|</span><a href="#37357401">next</a><span>|</span><label class="collapse" for="c-37357941">[-]</label><label class="expand" for="c-37357941">[2 more]</label></div><br/><div class="children"><div class="content">When the author here speaks of coroutines vs explicit state machine, by the latter they are referring to doing things like checking if `currentState == State.LOADING` or setting `currentState = State.COMPLETE`?</div><br/><div id="37359545" class="c"><input type="checkbox" id="c-37359545" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#37357941">parent</a><span>|</span><a href="#37357401">next</a><span>|</span><label class="collapse" for="c-37359545">[-]</label><label class="expand" for="c-37359545">[1 more]</label></div><br/><div class="children"><div class="content">Mostly the second one. You’ll have a single bit of boilerplate checking the current state and jumping to the right bit of code; but when you’re actually implementing the core logic of your state machine, you’ll be doing lots of “state = do_the_next_thing; return” instead of just calling “do_the_next_thing()” directly.</div><br/></div></div></div></div><div id="37357401" class="c"><input type="checkbox" id="c-37357401" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37357941">prev</a><span>|</span><a href="#37357711">next</a><span>|</span><label class="collapse" for="c-37357401">[-]</label><label class="expand" for="c-37357401">[3 more]</label></div><br/><div class="children"><div class="content">Poor man&#x27;s delimited continuations.</div><br/><div id="37359570" class="c"><input type="checkbox" id="c-37359570" checked=""/><div class="controls bullet"><span class="by">tonyg</span><span>|</span><a href="#37357401">parent</a><span>|</span><a href="#37357605">next</a><span>|</span><label class="collapse" for="c-37359570">[-]</label><label class="expand" for="c-37359570">[1 more]</label></div><br/><div class="children"><div class="content">Yep. Delimited continuations and proper tail calls gives a superpower. (Even PTC alone...)</div><br/></div></div><div id="37357605" class="c"><input type="checkbox" id="c-37357605" checked=""/><div class="controls bullet"><span class="by">bear8642</span><span>|</span><a href="#37357401">parent</a><span>|</span><a href="#37359570">prev</a><span>|</span><a href="#37357711">next</a><span>|</span><label class="collapse" for="c-37357605">[-]</label><label class="expand" for="c-37357605">[1 more]</label></div><br/><div class="children"><div class="content">Could you expand?<p>I have a limited understanding of continuations and never used them myself.</div><br/></div></div></div></div><div id="37357711" class="c"><input type="checkbox" id="c-37357711" checked=""/><div class="controls bullet"><span class="by">ioquatix</span><span>|</span><a href="#37357401">prev</a><span>|</span><label class="collapse" for="c-37357711">[-]</label><label class="expand" for="c-37357711">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;socketry&#x2F;async">https:&#x2F;&#x2F;github.com&#x2F;socketry&#x2F;async</a> uses coroutines and I think in general it’s been a great model with very few downsides in practice.</div><br/></div></div></div></div></div></div></div></body></html>