<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1686992467816" as="style"/><link rel="stylesheet" href="styles.css?v=1686992467816"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://pboyd.io/posts/productivity-limit/">Limits of Programmer Productivity: A lesson from Fred Brooks</a> <span class="domain">(<a href="https://pboyd.io">pboyd.io</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>15 comments</span></div><br/><div><div id="36367880" class="c"><input type="checkbox" id="c-36367880" checked=""/><div class="controls bullet"><span class="by">PeterStuer</span><span>|</span><a href="#36368195">next</a><span>|</span><label class="collapse" for="c-36367880">[-]</label><label class="expand" for="c-36367880">[3 more]</label></div><br/><div class="children"><div class="content">My first year at university was the last year studends had to use punched cards.<p>Your programming workflow was:<p>1) write your complete program on paper<p>2) grab a box of fresh punch cards, find an empty and functioning card punch and type out your complete program onto cards.<p>3) very carefully pack them and walk them over to a card reader. Yes. I saw on more than one occasion grown men brought to tears because they dropped a box of cards scattering them across the floor and they would have to spend many hours sorting them.<p>4) stand in the queue at the reader waiting for your turn to read in the cards. In some places you did this yourself. In others you had to hand your cards to an operator that controlled the reader.<p>5) if you were in the main programming room of the datacenter, you would now walk over to the queue at the line printer awaiting the output of your program. Each output on green&#x2F;gray continuous linked A3 paper started with a full listing of your code as typed. If there were errors in your code this would be followed by a huge pile of full code repeats indicating were things went wrong. I still think the enormous stack of pages printed in those cases was mainly to shame the programmer as they had to stand there waiting for the relentless ongoing machine gun like soundings of the line printer anoucing your failiure to the chuckles head shakes of the others standing in line. However, if you were at one of the satelite programming rooms spread around the campusses, , now was the time to go home as your output print would be delivered by van in the following batch typically the next day when you would go and pick up your output from all of them lying on a set of tables, hoping yours was not one of the bigger stacks indicating an error had been found.</div><br/><div id="36368287" class="c"><input type="checkbox" id="c-36368287" checked=""/><div class="controls bullet"><span class="by">comfypotato</span><span>|</span><a href="#36367880">parent</a><span>|</span><a href="#36368515">next</a><span>|</span><label class="collapse" for="c-36368287">[-]</label><label class="expand" for="c-36368287">[1 more]</label></div><br/><div class="children"><div class="content">Ah, the quintessential punchcard-drop story. Every old programmer has one of those stories.<p>My dad was just a mechanical engineer, and just crunched numbers with punch cards, but even he has stories about worrying about dropping punch cards.</div><br/></div></div><div id="36368515" class="c"><input type="checkbox" id="c-36368515" checked=""/><div class="controls bullet"><span class="by">NoRelToEmber</span><span>|</span><a href="#36367880">parent</a><span>|</span><a href="#36368287">prev</a><span>|</span><a href="#36368195">next</a><span>|</span><label class="collapse" for="c-36368515">[-]</label><label class="expand" for="c-36368515">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I saw on more than one occasion grown men brought to tears because they dropped a box of cards scattering them across the floor and they would have to spend many hours sorting them.<p>I realize I may be a bit late with this suggestion, but why not number the cards, like the pages of a book?</div><br/></div></div></div></div><div id="36368195" class="c"><input type="checkbox" id="c-36368195" checked=""/><div class="controls bullet"><span class="by">stakhanov</span><span>|</span><a href="#36367880">prev</a><span>|</span><a href="#36368005">next</a><span>|</span><label class="collapse" for="c-36368195">[-]</label><label class="expand" for="c-36368195">[1 more]</label></div><br/><div class="children"><div class="content">My reading of these excerpts from the mythical man month is slightly different:<p>Increasing the &quot;number of shots&quot; per unit of time doesn&#x27;t buy you anything if the shots you take yield proportionally lower output.  For example, in the days of punchcards and batch processing, if you were unsure about the syntax of one line of code, you wouldn&#x27;t have just run the compiler, as it meant wasting an entire cycle.  So the productive output of one run of the compiler back then would have been much higher than one run of the compiler nowadays.<p>Also, hitting a wait-state on any one task doesn&#x27;t necessarily block the programmer as a whole, and doesn&#x27;t necessarily decrease that programmer&#x27;s throughput.  You could imagine a scenario where a programmer is on ten projects.  Whenever they get blocked on project A, chances are high that among their other nine projects, there is some project B that became unblocked while they were working on A.  ...so, in theory, the programmer would never themselves be blocked, they would always have something productive that they could do, and the throughput of an entire team or company could remain unaffected.<p>The reason why there&#x27;s negative productivity impact to organizing work in such a way has to do with &quot;context switching overhead&quot; when a programmer needs to context switch between different tasks&#x2F;projects, or, if you will, a kind of &quot;cost of retooling&quot; a programmer&#x27;s brain to focus on a different task.<p>It&#x27;s also a productivity trap for psychological reasons.  On one hand, you have the positive psychological impact of &quot;flow state&quot; which requires immediate feedback.  On the other hand, you have a situation where, every time you have to wait for something, it&#x27;s an invitation to focus on a distraction instead of something productive.<p>And then, last but not least, the amount of time a project takes to finish (talking latency now, rather than throughput) is a function of how densely you can schedule the tasks that are on its critical path, and if the programmers are actually in a position of having to context-switch a lot to stay productive, then that would introduce a lot of wait cycles into the critical path, unless it were counteracted by deliberate planning of the kind which is extremely hard to do, unpractical, and would come with its own overhead.<p>I think it&#x27;s things like that which Brooks must have intuitively grasped when he made that statement.</div><br/></div></div><div id="36368005" class="c"><input type="checkbox" id="c-36368005" checked=""/><div class="controls bullet"><span class="by">someweirdperson</span><span>|</span><a href="#36368195">prev</a><span>|</span><a href="#36364624">next</a><span>|</span><label class="collapse" for="c-36368005">[-]</label><label class="expand" for="c-36368005">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There’s only one server, and it’s the only way to realistically run the code.<p>That seems a bit extreme. On the other hand, where a complete build and tests take excessive amount of time, running everything by everyone would be similarly bad.<p>Maybe the optimum is in between. Quick checks with a reasonable chance to catch frequent problems by everyone, long-running rarely failing checks centralized.</div><br/></div></div><div id="36364624" class="c"><input type="checkbox" id="c-36364624" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36368005">prev</a><span>|</span><a href="#36367090">next</a><span>|</span><label class="collapse" for="c-36364624">[-]</label><label class="expand" for="c-36364624">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious to hear what tools or techniques people here are using at work that they think makes a big difference in the developer experience.</div><br/><div id="36367515" class="c"><input type="checkbox" id="c-36367515" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36364624">parent</a><span>|</span><a href="#36365126">next</a><span>|</span><label class="collapse" for="c-36367515">[-]</label><label class="expand" for="c-36367515">[3 more]</label></div><br/><div class="children"><div class="content">1. Keep teams small. Down to the smallest you can. E.g. 2 devs on a project, one is more front-end-y, the other is more db-y, but both can fix code top to bottom. If a lot of sync up are necessary with stakeholders, add a third person for that, a doco guru.<p>I&#x27;ve had this period where I worked with another contractor and we just blended in like one. We spoke twice a week and we got so much done because we both knew what needed to be done and got the ability to do it.<p>The key is that *the sum of the people should be worth more than the individual output of each*. The larger the team, the harder this is to achieve.<p>2. This classic from xkcd really makes a difference <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1205&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xkcd.com&#x2F;1205&#x2F;</a> - Automate, eliminate, speed up. The sum adds up to massive savings.<p>3. Minimise cross-teams interruption. No sync up between teams, or having repeat meetings about the same thing; have clear meeting agendas. Divide the work in asynchronous output. For this you need good documentation and standards. Don&#x27;t let other teams set your standards.<p>4. Have clear priorities. I&#x27;ve seen teams waste huge amount of time because priorities weren&#x27;t clear. Flat-orgs are a thing, sure, but you better be able to justify how you spend your time. Consider every hour as a billable, not as a lifestyle.<p>5. Let people do their job. Because they&#x27;re quiet doesn&#x27;t mean they&#x27;re not working. You might not be busy but they might be. Treat silence as deep work, not stillness.<p>Many personal hours are wasted because we&#x27;re waiting on other people. Many team hours are wasted because priorities aren&#x27;t clear or not well allocated. Finally, we&#x27;re all slaves to slow systems, builds, deploys: be ruthless about those.<p>These are the main culprit of waste (imho!).</div><br/><div id="36367600" class="c"><input type="checkbox" id="c-36367600" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36364624">root</a><span>|</span><a href="#36367515">parent</a><span>|</span><a href="#36365126">next</a><span>|</span><label class="collapse" for="c-36367600">[-]</label><label class="expand" for="c-36367600">[2 more]</label></div><br/><div class="children"><div class="content">These are great, thanks. Not what I had in mind with my question, but actually more foundational and important than what I was asking about.</div><br/><div id="36367766" class="c"><input type="checkbox" id="c-36367766" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36364624">root</a><span>|</span><a href="#36367600">parent</a><span>|</span><a href="#36365126">next</a><span>|</span><label class="collapse" for="c-36367766">[-]</label><label class="expand" for="c-36367766">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, you mentioned &quot;Developer Experience&quot;. This is what makes a difference for me in the last 20+ years...<p>1. Know your tools inside out. If you&#x27;re a Vim user or not (I&#x27;m not), make sure you do most things with shortcuts as much you can. Take notice of every time you use the mouse and consider whether that could be keyboard driven. You&#x27;ll first save seconds, which turn into minutes, then hours.<p>1b. Same for the terminal tools. My &#x27;profile&#x27; is shock full of aliases and functions that make my life easier to talk to containers, other tools, etc. It almost becomes a library of power tools.<p>2. Effective navigation through code, forward, backwards, definitions, declarations. These should become second nature and effortless to save a ton of time!<p>3. Use every power tools available, whether it&#x27;s static analysis tools like Rust Clippy, or language servers (LSP) in VSCode, Neovim or elsewhere; or chatGPT, make sure you make technology work for you, as much as possible.<p>4. Hook up to Dash or DevDocs to reduce your time clicking about Google trying to solve a problem. Knowing everything is impossible, knowing where to find the information quickly is a life saver.<p>5. Sometimes you&#x27;ll find a really hairy bug, document it for your future self. Whether you blog it up at night or simply keep it in your (searchable) notes, it can save you 20 mins down the line, it&#x27;s worth it. Sometimes it&#x27;s a recipe list of &quot;how do I do that with X&quot; systems that can&#x27;t be automated. If you can go home and forget everything, you&#x27;re doing it right.<p>6. Turn off notifications etc. as much as possible. This is well known... It&#x27;s perfectly fine to browse HN in my mind as it&#x27;s a net addition to my life, but be conscious about time spent on socials and more importantly knowing when to turn them off.</div><br/></div></div></div></div></div></div><div id="36365126" class="c"><input type="checkbox" id="c-36365126" checked=""/><div class="controls bullet"><span class="by">nunuvit</span><span>|</span><a href="#36364624">parent</a><span>|</span><a href="#36367515">prev</a><span>|</span><a href="#36367090">next</a><span>|</span><label class="collapse" for="c-36365126">[-]</label><label class="expand" for="c-36365126">[1 more]</label></div><br/><div class="children"><div class="content">Having coworkers who are too curmudgeony to overuse chat apps and wikis.</div><br/></div></div></div></div><div id="36367090" class="c"><input type="checkbox" id="c-36367090" checked=""/><div class="controls bullet"><span class="by">r2b2</span><span>|</span><a href="#36364624">prev</a><span>|</span><label class="collapse" for="c-36367090">[-]</label><label class="expand" for="c-36367090">[4 more]</label></div><br/><div class="children"><div class="content">Yes, using a watch + compile + restart development environment where everything can be worked on locally reduces cycle time to 5ms, which is ~100,000x quicker than the 10m compile time in the parent post.<p>I&#x27;ve deployed 35,000+ lines of code to prod in 2023 with this flow. I&#x27;ve only had 2 small bugs.<p>This is by <i>far</i> the most efficient setup I&#x27;ve ever used.</div><br/><div id="36368379" class="c"><input type="checkbox" id="c-36368379" checked=""/><div class="controls bullet"><span class="by">rtontic</span><span>|</span><a href="#36367090">parent</a><span>|</span><a href="#36367480">next</a><span>|</span><label class="collapse" for="c-36368379">[-]</label><label class="expand" for="c-36368379">[1 more]</label></div><br/><div class="children"><div class="content">On my current project, any deploy that we want to do to an AWS environment, including dev, takes at least 10 minutes. So, as soon as you have to work on AWS functionality, you are transported to the past, similarly to the programmers of old. I&#x27;m not saying this is a bad thing actually, just to note that we still haven&#x27;t managed to eliminate the &quot;turn-around time&quot;.</div><br/></div></div><div id="36367480" class="c"><input type="checkbox" id="c-36367480" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#36367090">parent</a><span>|</span><a href="#36368379">prev</a><span>|</span><label class="collapse" for="c-36367480">[-]</label><label class="expand" for="c-36367480">[2 more]</label></div><br/><div class="children"><div class="content">The biggest latency in any large software project is... other people.</div><br/><div id="36367739" class="c"><input type="checkbox" id="c-36367739" checked=""/><div class="controls bullet"><span class="by">readthenotes1</span><span>|</span><a href="#36367090">root</a><span>|</span><a href="#36367480">parent</a><span>|</span><label class="collapse" for="c-36367739">[-]</label><label class="expand" for="c-36367739">[1 more]</label></div><br/><div class="children"><div class="content">I think Fred Brooks also talked about that in one of his essays didn&#x27;t he?<p>(I guess I&#x27;m being facetious because I think everyone should read his book of essays. The hardware platforms have changed dramatically since the 1960s, but the wetware hasn&#x27;t changed a bit)</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>