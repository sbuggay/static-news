<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689498054811" as="style"/><link rel="stylesheet" href="styles.css?v=1689498054811"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/nh2/haskell-jobs-statistics">The Haskell job market has been growing steaily since 2008</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>nh2</span> | <span>55 comments</span></div><br/><div><div id="36743834" class="c"><input type="checkbox" id="c-36743834" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36743447">next</a><span>|</span><label class="collapse" for="c-36743834">[-]</label><label class="expand" for="c-36743834">[13 more]</label></div><br/><div class="children"><div class="content">I spun up two Haskell teams at work, and now it composes about half of our codebases. Happy to answer questions about the experience.</div><br/><div id="36744904" class="c"><input type="checkbox" id="c-36744904" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36743834">parent</a><span>|</span><a href="#36743982">next</a><span>|</span><label class="collapse" for="c-36744904">[-]</label><label class="expand" for="c-36744904">[1 more]</label></div><br/><div class="children"><div class="content">What were the positive surprises, the negative surprises (even simple stuff).<p>What&#x27;s your team workflow around designing the code ?<p>Do you follow mainstream ideas or do you have very special tricks (say innovation on top of property based testing.. metaprogramming.. whatever)</div><br/></div></div><div id="36743982" class="c"><input type="checkbox" id="c-36743982" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36743834">parent</a><span>|</span><a href="#36744904">prev</a><span>|</span><a href="#36744385">next</a><span>|</span><label class="collapse" for="c-36743982">[-]</label><label class="expand" for="c-36743982">[2 more]</label></div><br/><div class="children"><div class="content">Any regrets?</div><br/><div id="36744430" class="c"><input type="checkbox" id="c-36744430" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36743834">root</a><span>|</span><a href="#36743982">parent</a><span>|</span><a href="#36744385">next</a><span>|</span><label class="collapse" for="c-36744430">[-]</label><label class="expand" for="c-36744430">[1 more]</label></div><br/><div class="children"><div class="content">In the broad scheme of things, not really.<p>I think we waited too long to ship our initial prototype to customers, but a big part of that was that we were pretty sloppy in our product management at that stage of the company (I think we had closed the A about a year ago, and did not yet have our first dedicated PM), and our technical rewrite was also partially a feature and UX rewrite. It&#x27;s been several years since, and we have clawed our way out of that hole, and I think our delivery process is actually in a really good place now.<p>If I were to give advice to people looking at adopting new languages, I would say to get it into production ASAP. I believe the keyword to search for is the &quot;tracer bullet pattern&quot;. One of my favorite blog posts on this is <a href="https:&#x2F;&#x2F;blog.thepete.net&#x2F;blog&#x2F;2019&#x2F;10&#x2F;04&#x2F;hello-production&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.thepete.net&#x2F;blog&#x2F;2019&#x2F;10&#x2F;04&#x2F;hello-production&#x2F;</a></div><br/></div></div></div></div><div id="36744385" class="c"><input type="checkbox" id="c-36744385" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#36743834">parent</a><span>|</span><a href="#36743982">prev</a><span>|</span><a href="#36744368">next</a><span>|</span><label class="collapse" for="c-36744385">[-]</label><label class="expand" for="c-36744385">[3 more]</label></div><br/><div class="children"><div class="content">What kind of applications your team are working it?
How&#x27;s the overall development process felt?
I&#x27;d like to know the reason to choose Haskell over other languages.</div><br/><div id="36744492" class="c"><input type="checkbox" id="c-36744492" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36743834">root</a><span>|</span><a href="#36744385">parent</a><span>|</span><a href="#36744368">next</a><span>|</span><label class="collapse" for="c-36744492">[-]</label><label class="expand" for="c-36744492">[2 more]</label></div><br/><div class="children"><div class="content">Re: applications and language comparison, see my answer over at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36744384">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36744384</a><p>Re: development process - it&#x27;s very similar to development in other languages. Write, compile, yell at compiler, push, complain about how slow CI is, deploy. You know, the usual.<p>I think the most interesting difference is the _onboarding_ curve. Haskell&#x27;s curve is pretty brutal, although I think most of this is because of bad pedagogy (many monad tutorials are bad, and beginners can&#x27;t tell) rather than because of intrinsically difficult concepts. Some observations:<p>1. Empirically, zero to code review is roughly six weeks for a professional industry software engineer. It&#x27;s not that much longer than other languages we&#x27;ve had to teach. But it _feels_ very brutal because zero to side project is roughly three or four weeks. Contrast this against Go, where zero to side project is about five minutes.<p>2. Having an experienced Haskell engineer on your team to start with makes a WORLD of a difference. You&#x27;ve gotten a type error - why? Is it because GHC is doing weird backwards type inference stuff again? Or is it because you&#x27;ve misunderstood this fundamental concept? Or is it because you&#x27;ve done a typo, and GHC has inferred a downstream site to be a type error? This sort of thing is very difficult to explain in words and in general, and much easier to pick up through experience and mentorship. If you do not have an experienced Haskeller at your disposal, I would strongly recommend starting with side projects first, and using the Functional Programming Slack (fpslack.com), who are some of the friendliest and most patient folks I&#x27;ve had the pleasure of talking to.</div><br/><div id="36744918" class="c"><input type="checkbox" id="c-36744918" checked=""/><div class="controls bullet"><span class="by">Tade0</span><span>|</span><a href="#36743834">root</a><span>|</span><a href="#36744492">parent</a><span>|</span><a href="#36744368">next</a><span>|</span><label class="collapse" for="c-36744918">[-]</label><label class="expand" for="c-36744918">[1 more]</label></div><br/><div class="children"><div class="content">&gt; (many monad tutorials are bad, and beginners can&#x27;t tell)<p>It appears monads truly are something you can either understand or explain, but not both.<p>I find it suspicious. I mean, plenty of Haskell devs out there, surely it&#x27;s not that hard?</div><br/></div></div></div></div></div></div><div id="36744368" class="c"><input type="checkbox" id="c-36744368" checked=""/><div class="controls bullet"><span class="by">becquerel</span><span>|</span><a href="#36743834">parent</a><span>|</span><a href="#36744385">prev</a><span>|</span><a href="#36744370">next</a><span>|</span><label class="collapse" for="c-36744368">[-]</label><label class="expand" for="c-36744368">[2 more]</label></div><br/><div class="children"><div class="content">What industry? Most Haskell use seems to happen in finance or similar fields.</div><br/><div id="36744453" class="c"><input type="checkbox" id="c-36744453" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36743834">root</a><span>|</span><a href="#36744368">parent</a><span>|</span><a href="#36744370">next</a><span>|</span><label class="collapse" for="c-36744453">[-]</label><label class="expand" for="c-36744453">[1 more]</label></div><br/><div class="children"><div class="content">Developer tools!<p>I think Haskell and OCaml are popular in finance because they&#x27;re high-level and familiar to math&#x2F;quant types (who are broadly--and this is a sweeping generalization--more familiar with expressing algorithms in recursion than in procedural sequences).<p>I don&#x27;t have much experience with OCaml, but I can also say that Haskell in particular has incredible support for building very high-level libraries that are both expressive and have strong compile-time guarantees. I&#x27;ve found it&#x27;s relatively easier for a programming expert to build such a library and a domain expert to consume the library in Haskell than in many other languages I&#x27;ve seen (perhaps Python comes the closest, but that feels to me more like an ecosystem thing than a language thing).</div><br/></div></div></div></div><div id="36744370" class="c"><input type="checkbox" id="c-36744370" checked=""/><div class="controls bullet"><span class="by">edejong</span><span>|</span><a href="#36743834">parent</a><span>|</span><a href="#36744368">prev</a><span>|</span><a href="#36744284">next</a><span>|</span><label class="collapse" for="c-36744370">[-]</label><label class="expand" for="c-36744370">[2 more]</label></div><br/><div class="children"><div class="content">Really curious: Half of the code base in LoC or in functionality?</div><br/><div id="36744394" class="c"><input type="checkbox" id="c-36744394" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36743834">root</a><span>|</span><a href="#36744370">parent</a><span>|</span><a href="#36744284">next</a><span>|</span><label class="collapse" for="c-36744394">[-]</label><label class="expand" for="c-36744394">[1 more]</label></div><br/><div class="children"><div class="content">In functionality, roughly. By LoC, I think the majority of our codebase is still JavaScript&#x2F;TypeScript. Many of the subsystems still in TS are being rewritten in Haskell (not because we have a &quot;rewrite in Haskell&quot; mandate, but because they are due for a rewrite anyway due to scale and requirement changes, and the team that owns that domain now primarily writes in Haskell).</div><br/></div></div></div></div><div id="36744284" class="c"><input type="checkbox" id="c-36744284" checked=""/><div class="controls bullet"><span class="by">badrabbit</span><span>|</span><a href="#36743834">parent</a><span>|</span><a href="#36744370">prev</a><span>|</span><a href="#36743447">next</a><span>|</span><label class="collapse" for="c-36744284">[-]</label><label class="expand" for="c-36744284">[2 more]</label></div><br/><div class="children"><div class="content">If I may ask a naive question: why? Is there a specific advantage it gives you, like Ocaml in finance&#x2F;trading?</div><br/><div id="36744384" class="c"><input type="checkbox" id="c-36744384" checked=""/><div class="controls bullet"><span class="by">ilikebits</span><span>|</span><a href="#36743834">root</a><span>|</span><a href="#36744284">parent</a><span>|</span><a href="#36743447">next</a><span>|</span><label class="collapse" for="c-36744384">[-]</label><label class="expand" for="c-36744384">[1 more]</label></div><br/><div class="children"><div class="content">For us, there were a couple advantages. For context, I work at FOSSA (<a href="https:&#x2F;&#x2F;fossa.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fossa.com&#x2F;</a>). Our core product solves software supply chain needs in enterprises (around licensing and security), and our core technology is around compiler, build, and source code analysis.<p>Off the top of my head, 3 advantages stood out:<p>1. First, if you&#x27;re not going that far off the beaten low-level path, Haskell has incredible productivity benefits. Effect tracking has enormous benefits for testability and understandability. If you&#x27;ve ever been down a debugging rabbit hole shaped like &quot;there&#x27;s no way this logging call is sending that API request&quot;, then you might be pleasantly surprised to discover that you can statically guarantee that this doesn&#x27;t occur in Haskell programs! Pattern matching, algebraic data types (sum types!), and typeclass derivation make it much easier to make it impossible to construct invalid representations of data. Other languages are finally picking this up, but their versions of pattern matching often have caveats for backwards-idiom-compatibility. And monads are a very powerful abstraction. It&#x27;s like being able to write your own semantics for async-await (I&#x27;ve talked more about this before at <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;7cllte&#x2F;monads_part_six_really_what_is_monad#c_nbusni" rel="nofollow noreferrer">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;7cllte&#x2F;monads_part_six_really_what_is_mo...</a>).<p>2. Haskell was a good domain fit for us. One thing we build is the FOSSA CLI (<a href="https:&#x2F;&#x2F;github.com&#x2F;fossas&#x2F;fossa-cli&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;fossas&#x2F;fossa-cli&#x2F;</a>), which runs in customer CI pipelines to analyze their builds. It&#x27;s a very compiler-shaped problem: shell out to some tools, do a lot of parsing, think very hard, and then spit out a JSON blob to send back to the API. Our first version of this was written in Go. At the time of development, writing correct, testable parsers in Go was like pulling teeth. We have a relatively small headcount-to-product-surface-area ratio, and our team was running up against the overhead of rewriting traverse in Go over and over again (that&#x27;s a Haskell-flavored joke, but if you&#x27;ve ever been annoyed at writing yet another for-loop in Go, you get it). We decided to hack out a prototype in Haskell, and it turned out to be a good fit.<p>3. Lastly, the kind of people who wind up working at FOSSA and are interested in the code analysis bits tend to be the same kind of nerds who love Haskell. We had lots of people on our team who were chomping at the bit to try it, so we decided to try it out. I really can&#x27;t understate how big of a productivity difference it makes when people are working with tools that they actually enjoy rather than are merely forcing themselves to use. It is night and day.<p>If you want to learn more, we also did an interview with Serokell on this topic (<a href="https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;haskell-in-production-fossa" rel="nofollow noreferrer">https:&#x2F;&#x2F;serokell.io&#x2F;blog&#x2F;haskell-in-production-fossa</a>), and discussed it on an episode of our engineering podcast (<a href="https:&#x2F;&#x2F;fossa.com&#x2F;blog&#x2F;fossa-podcast-adopting-haskell&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;fossa.com&#x2F;blog&#x2F;fossa-podcast-adopting-haskell&#x2F;</a>).</div><br/></div></div></div></div></div></div><div id="36743447" class="c"><input type="checkbox" id="c-36743447" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#36743834">prev</a><span>|</span><a href="#36743276">next</a><span>|</span><label class="collapse" for="c-36743447">[-]</label><label class="expand" for="c-36743447">[4 more]</label></div><br/><div class="children"><div class="content">Maybe I misunderstand; is this as it says, the <i>cummulative</i> number of jobs posts since 2008? So there have been 400 job posts in total?<p>If so then we should look at the slope of the graph for &#x27;growth&#x27;, and it in fact appears to have flattened recently.<p>And further, as the size of the market increases, you&#x27;d naturally expect more postings, if only because of churn.<p>Are they definitely different jobs, new positions? It could be a handful of people are rotating around a handful of jobs that then need to advertise every few months.<p>I mean, it&#x27;s extremely likely that there are more Haskell programmers employed now than in 2008, but IMHO this doesn&#x27;t show it very clearly, and doesn&#x27;t show that the market is now growing.<p>To me there seems to be some irony in that some nice pure stats about Haskell programmers seem so ungrounded.</div><br/><div id="36743986" class="c"><input type="checkbox" id="c-36743986" checked=""/><div class="controls bullet"><span class="by">one-punch</span><span>|</span><a href="#36743447">parent</a><span>|</span><a href="#36743276">next</a><span>|</span><label class="collapse" for="c-36743986">[-]</label><label class="expand" for="c-36743986">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If so then we should look at the slope of the graph for &#x27;growth&#x27;, and it in fact appears to have flattened recently.<p>The second graph shows the number of job posts per year, and it seems to reflect the bigger macro-economic situation: dip during pandemic, and a slight drop after 2022. I think these features are not specific to Haskell, just showing that the Haskell segment also follows some bigger trend.</div><br/><div id="36744072" class="c"><input type="checkbox" id="c-36744072" checked=""/><div class="controls bullet"><span class="by">petersellers</span><span>|</span><a href="#36743447">root</a><span>|</span><a href="#36743986">parent</a><span>|</span><a href="#36743276">next</a><span>|</span><label class="collapse" for="c-36744072">[-]</label><label class="expand" for="c-36744072">[2 more]</label></div><br/><div class="children"><div class="content">If the second chart is accurate then the first chart should be showing continual upward progress over time, but what we see is that the first chart is starting to flatten out around 2023.<p>Either the term &quot;cumulative&quot; is being used incorrectly, or different rules are being used to classify available jobs in each graph.<p>Maybe the first chart is filtering out duplicates?</div><br/><div id="36744235" class="c"><input type="checkbox" id="c-36744235" checked=""/><div class="controls bullet"><span class="by">one-punch</span><span>|</span><a href="#36743447">root</a><span>|</span><a href="#36744072">parent</a><span>|</span><a href="#36743276">next</a><span>|</span><label class="collapse" for="c-36744235">[-]</label><label class="expand" for="c-36744235">[1 more]</label></div><br/><div class="children"><div class="content">The second chart is bucketed by year, while the first chart is not (appears to have more continual changes). Also, the discrepancy you observed around 2023 is on the edge of the second chart, which can be the result of bucketing and it may not be that surprising after all.</div><br/></div></div></div></div></div></div></div></div><div id="36743276" class="c"><input type="checkbox" id="c-36743276" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#36743447">prev</a><span>|</span><a href="#36743217">next</a><span>|</span><label class="collapse" for="c-36743276">[-]</label><label class="expand" for="c-36743276">[6 more]</label></div><br/><div class="children"><div class="content">Maybe this is a general time trend for many languages not just Haskell. Also, the real question is what percentage of jobs are Haskell related.</div><br/><div id="36743790" class="c"><input type="checkbox" id="c-36743790" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#36743276">parent</a><span>|</span><a href="#36743217">next</a><span>|</span><label class="collapse" for="c-36743790">[-]</label><label class="expand" for="c-36743790">[5 more]</label></div><br/><div class="children"><div class="content">Why is that the real question? 
If I&#x27;m looking for a Haskell job it&#x27;s useful to know there are some, even if there are 100 times more for a different one.<p>Absolute number and percentage are both interesting metrics depending on what you are interested in.</div><br/><div id="36744185" class="c"><input type="checkbox" id="c-36744185" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36743276">root</a><span>|</span><a href="#36743790">parent</a><span>|</span><a href="#36744020">next</a><span>|</span><label class="collapse" for="c-36744185">[-]</label><label class="expand" for="c-36744185">[3 more]</label></div><br/><div class="children"><div class="content">Because job listings = demand. It is not wise to invest your own time into Haskell from a monetary standpoint if there is no demand for that skillset. More job listings also mean that you there is more diversity in the places you can work. It is not wise to choose a company just because they have a tech stack that you are fond of.</div><br/><div id="36744339" class="c"><input type="checkbox" id="c-36744339" checked=""/><div class="controls bullet"><span class="by">Barrin92</span><span>|</span><a href="#36743276">root</a><span>|</span><a href="#36744185">parent</a><span>|</span><a href="#36744020">next</a><span>|</span><label class="collapse" for="c-36744339">[-]</label><label class="expand" for="c-36744339">[2 more]</label></div><br/><div class="children"><div class="content">demand is created, jobs don&#x27;t fall from the heavens like manna, it&#x27;s people who pick new technologies and turn them into established ones, start companies and use them. Reminds me of a PG essay on why he chose Lisp when barely anyone else was doing it.<p>&quot;<i>Robert and I both knew Lisp well, and we couldn&#x27;t see any reason not to trust our instincts and go with Lisp. We knew that everyone else was writing their software in C++ or Perl. But we also knew that that didn&#x27;t mean anything. If you chose technology that way, you&#x27;d be running Windows. When you choose technology, you have to ignore what other people are doing, and consider only what will work the best.&quot;</i><p><a href="http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.paulgraham.com&#x2F;avg.html</a></div><br/><div id="36744468" class="c"><input type="checkbox" id="c-36744468" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36743276">root</a><span>|</span><a href="#36744339">parent</a><span>|</span><a href="#36744020">next</a><span>|</span><label class="collapse" for="c-36744468">[-]</label><label class="expand" for="c-36744468">[1 more]</label></div><br/><div class="children"><div class="content">People looking for a job are not people looking to create a company. While demand can increase by making a company, it can also decreases over time. Demand for other languages can also grow faster too.</div><br/></div></div></div></div></div></div><div id="36744020" class="c"><input type="checkbox" id="c-36744020" checked=""/><div class="controls bullet"><span class="by">EduardoBautista</span><span>|</span><a href="#36743276">root</a><span>|</span><a href="#36743790">parent</a><span>|</span><a href="#36744185">prev</a><span>|</span><a href="#36743217">next</a><span>|</span><label class="collapse" for="c-36744020">[-]</label><label class="expand" for="c-36744020">[1 more]</label></div><br/><div class="children"><div class="content">Because the post is implying that Haskell jobs are growing at a faster rate than other programming languages.</div><br/></div></div></div></div></div></div><div id="36743217" class="c"><input type="checkbox" id="c-36743217" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36743276">prev</a><span>|</span><a href="#36742312">next</a><span>|</span><label class="collapse" for="c-36743217">[-]</label><label class="expand" for="c-36743217">[8 more]</label></div><br/><div class="children"><div class="content">Is it worth learning Haskell with the aim of landing a job working in it?<p>I&#x27;m not after FANG money but would love a job in a functional language.</div><br/><div id="36744237" class="c"><input type="checkbox" id="c-36744237" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#36743217">parent</a><span>|</span><a href="#36743845">next</a><span>|</span><label class="collapse" for="c-36744237">[-]</label><label class="expand" for="c-36744237">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Haskell_in_industry" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Haskell_in_industry</a><p>Everything is worth learning, especially if it interests you.<p>That being said, you should be aware that outside of hyper niche applications, most Haskell jobs are in projects where Haskell was chosen because some lead has an affinity for it, not because of any real practical benefits in comparison to other languages.</div><br/></div></div><div id="36743845" class="c"><input type="checkbox" id="c-36743845" checked=""/><div class="controls bullet"><span class="by">consilient</span><span>|</span><a href="#36743217">parent</a><span>|</span><a href="#36744237">prev</a><span>|</span><a href="#36743574">next</a><span>|</span><label class="collapse" for="c-36743845">[-]</label><label class="expand" for="c-36743845">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t know whether you want a Haskell job if you don&#x27;t know Haskell yet.</div><br/><div id="36744578" class="c"><input type="checkbox" id="c-36744578" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36743217">root</a><span>|</span><a href="#36743845">parent</a><span>|</span><a href="#36743574">next</a><span>|</span><label class="collapse" for="c-36744578">[-]</label><label class="expand" for="c-36744578">[1 more]</label></div><br/><div class="children"><div class="content">I like strongly typed functional languages. I&#x27;d like to pick up Haskell and wondering if it would increase my chances of getting a job using a functional language.</div><br/></div></div></div></div><div id="36743574" class="c"><input type="checkbox" id="c-36743574" checked=""/><div class="controls bullet"><span class="by">granshaw</span><span>|</span><a href="#36743217">parent</a><span>|</span><a href="#36743845">prev</a><span>|</span><a href="#36742312">next</a><span>|</span><label class="collapse" for="c-36743574">[-]</label><label class="expand" for="c-36743574">[4 more]</label></div><br/><div class="children"><div class="content">An Elixir job seems much more attainable?</div><br/><div id="36743925" class="c"><input type="checkbox" id="c-36743925" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#36743217">root</a><span>|</span><a href="#36743574">parent</a><span>|</span><a href="#36743748">next</a><span>|</span><label class="collapse" for="c-36743925">[-]</label><label class="expand" for="c-36743925">[1 more]</label></div><br/><div class="children"><div class="content">I would say so yet. Elixir seem to be growing in popularity but finding a job for a junior is hard.</div><br/></div></div><div id="36743748" class="c"><input type="checkbox" id="c-36743748" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36743217">root</a><span>|</span><a href="#36743574">parent</a><span>|</span><a href="#36743925">prev</a><span>|</span><a href="#36742312">next</a><span>|</span><label class="collapse" for="c-36743748">[-]</label><label class="expand" for="c-36743748">[2 more]</label></div><br/><div class="children"><div class="content">I love static typing. But, I hear this is coming.</div><br/><div id="36743992" class="c"><input type="checkbox" id="c-36743992" checked=""/><div class="controls bullet"><span class="by">adamddev1</span><span>|</span><a href="#36743217">root</a><span>|</span><a href="#36743748">parent</a><span>|</span><a href="#36742312">next</a><span>|</span><label class="collapse" for="c-36743992">[-]</label><label class="expand" for="c-36743992">[1 more]</label></div><br/><div class="children"><div class="content">Yes please, I hope so!</div><br/></div></div></div></div></div></div></div></div><div id="36742312" class="c"><input type="checkbox" id="c-36742312" checked=""/><div class="controls bullet"><span class="by">nh2</span><span>|</span><a href="#36743217">prev</a><span>|</span><a href="#36744269">next</a><span>|</span><label class="collapse" for="c-36742312">[-]</label><label class="expand" for="c-36742312">[2 more]</label></div><br/><div class="children"><div class="content">I crawled, and manually verified, &#x2F;r&#x2F;haskell Reddit job postings between 2008 and now.<p>It turns out the Haskell job market has been growing steadily since then, with a dip during Covid.</div><br/></div></div><div id="36744269" class="c"><input type="checkbox" id="c-36744269" checked=""/><div class="controls bullet"><span class="by">hackandthink</span><span>|</span><a href="#36742312">prev</a><span>|</span><a href="#36744695">next</a><span>|</span><label class="collapse" for="c-36744269">[-]</label><label class="expand" for="c-36744269">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to look at the raw data. There are some surprises:<p>02&#x2F;01&#x2F;2011 16 The F# Team are Hiring (functional programming jobs)  
08&#x2F;27&#x2F;2022 425 Looking for a Haskell Job in Germany</div><br/></div></div><div id="36744695" class="c"><input type="checkbox" id="c-36744695" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36744269">prev</a><span>|</span><a href="#36743057">next</a><span>|</span><label class="collapse" for="c-36744695">[-]</label><label class="expand" for="c-36744695">[1 more]</label></div><br/><div class="children"><div class="content">Apparently &quot;failing at any cost&quot; isn&#x27;t working that well. :)<p>Good to see the adoption growth.</div><br/></div></div><div id="36743057" class="c"><input type="checkbox" id="c-36743057" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#36744695">prev</a><span>|</span><a href="#36742495">next</a><span>|</span><label class="collapse" for="c-36743057">[-]</label><label class="expand" for="c-36743057">[1 more]</label></div><br/><div class="children"><div class="content">How has it grown relative to the overall job market?</div><br/></div></div><div id="36742495" class="c"><input type="checkbox" id="c-36742495" checked=""/><div class="controls bullet"><span class="by">cosmic_quanta</span><span>|</span><a href="#36743057">prev</a><span>|</span><a href="#36743722">next</a><span>|</span><label class="collapse" for="c-36742495">[-]</label><label class="expand" for="c-36742495">[2 more]</label></div><br/><div class="children"><div class="content">Wow that&#x27;s really cool. Good to see growth in Haskell in industry, given the original research focus.<p>At my workplace, we&#x27;ve been toying with Haskell and we&#x27;ll be putting it in production over the next 6-12 months. I might be placing some Haskell job adverts on reddit next year!</div><br/><div id="36743285" class="c"><input type="checkbox" id="c-36743285" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#36742495">parent</a><span>|</span><a href="#36743722">next</a><span>|</span><label class="collapse" for="c-36743285">[-]</label><label class="expand" for="c-36743285">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget the monthly HN job post. This is my last social network (not that I know Haskell).</div><br/></div></div></div></div><div id="36743722" class="c"><input type="checkbox" id="c-36743722" checked=""/><div class="controls bullet"><span class="by">nambiyaar</span><span>|</span><a href="#36742495">prev</a><span>|</span><a href="#36742998">next</a><span>|</span><label class="collapse" for="c-36743722">[-]</label><label class="expand" for="c-36743722">[1 more]</label></div><br/><div class="children"><div class="content">Man I&#x27;m graduating in 2025...would be a dream to land my first job with Haskell.</div><br/></div></div><div id="36742998" class="c"><input type="checkbox" id="c-36742998" checked=""/><div class="controls bullet"><span class="by">hsavit1</span><span>|</span><a href="#36743722">prev</a><span>|</span><label class="collapse" for="c-36742998">[-]</label><label class="expand" for="c-36742998">[15 more]</label></div><br/><div class="children"><div class="content">What percentage of Haskell jobs are crypto jobs? I bet itâs high</div><br/><div id="36743231" class="c"><input type="checkbox" id="c-36743231" checked=""/><div class="controls bullet"><span class="by">mighmi</span><span>|</span><a href="#36742998">parent</a><span>|</span><label class="collapse" for="c-36743231">[-]</label><label class="expand" for="c-36743231">[14 more]</label></div><br/><div class="children"><div class="content">How&#x27;d it get high adoption in that field?</div><br/><div id="36744069" class="c"><input type="checkbox" id="c-36744069" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743231">parent</a><span>|</span><a href="#36743497">next</a><span>|</span><label class="collapse" for="c-36744069">[-]</label><label class="expand" for="c-36744069">[3 more]</label></div><br/><div class="children"><div class="content">Smart contracts are foot guns and so they are an interesting case for formal verification and advanced static typing people. They usually like Haskell. I like formal verification but not blockchain, however , the jobs are there. Saving actual lives with formal methods is not worth the money, so we prove Ponzi schemes to be correct. A little over the top, sorry, but it is hurting just a tad that chemo delivery devices have less rigid software than something that is marketed as an everyone wins lottery type of thing.</div><br/><div id="36744878" class="c"><input type="checkbox" id="c-36744878" checked=""/><div class="controls bullet"><span class="by">Gigachad</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36744069">parent</a><span>|</span><a href="#36744404">next</a><span>|</span><label class="collapse" for="c-36744878">[-]</label><label class="expand" for="c-36744878">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t be surprised if a huge factor is just marketing. Most crypto products are only built to be sold to some investor. And saying it&#x27;s all built on Haskell probably sells better than saying it&#x27;s a bog standard typescript program.</div><br/></div></div><div id="36744404" class="c"><input type="checkbox" id="c-36744404" checked=""/><div class="controls bullet"><span class="by">peterbecich</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36744069">parent</a><span>|</span><a href="#36744878">prev</a><span>|</span><a href="#36743497">next</a><span>|</span><label class="collapse" for="c-36744404">[-]</label><label class="expand" for="c-36744404">[1 more]</label></div><br/><div class="children"><div class="content">Yes, to add to this, it was an opportune time at the beginning of a new sector with no legacy code. I&#x27;ve read that iOS Apps benefited in a similar way in security over Mac OS; there was an opportunity to start fresh without backward compatibility requirements.</div><br/></div></div></div></div><div id="36743497" class="c"><input type="checkbox" id="c-36743497" checked=""/><div class="controls bullet"><span class="by">hudon</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743231">parent</a><span>|</span><a href="#36744069">prev</a><span>|</span><a href="#36744271">next</a><span>|</span><label class="collapse" for="c-36743497">[-]</label><label class="expand" for="c-36743497">[9 more]</label></div><br/><div class="children"><div class="content">Sorry to be blunt, but it&#x27;s probably because of how crypto is a Rube Goldberg machine that attracts similar tinkerers as those attracted by Haskell&#x27;s Rube Goldberg machine aspects. Both technologies seem to be doing a lot of complicated stuff, and so they attract a kind of technologist that enjoys technology for technology&#x27;s sake.</div><br/><div id="36744240" class="c"><input type="checkbox" id="c-36744240" checked=""/><div class="controls bullet"><span class="by">peterbecich</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743497">parent</a><span>|</span><a href="#36744371">next</a><span>|</span><label class="collapse" for="c-36744240">[-]</label><label class="expand" for="c-36744240">[2 more]</label></div><br/><div class="children"><div class="content">I like Scala and Haskell. The selling points of high assurances by their compilers appealed to me.<p>Opinion:
Something I did not anticipate is these languages allow a high degree of individual choice in coding style by a programmer, and companies tend to dislike this. I have read this sentiment about Clojure shops; the original authors are very capable in the codebase but it can be hard to bring in new team members later. It seems to me most companies prefer less expressive languages with opinionated style guidelines. I have never worked with Python professionally, but apparently there is a high emphasis on style consistency in the community.<p>Obviously there exist projects in less expressive languages that are hard to maintain, so maybe ease-of-onboarding and ease-of-maintenance depend on something else.<p>I still believe the type system of Haskell can provide great benefits to codebase maintenance over the long term. If the coding style were restricted and opinionated, it might assist with company adoption.</div><br/><div id="36744459" class="c"><input type="checkbox" id="c-36744459" checked=""/><div class="controls bullet"><span class="by">Tanjreeve</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36744240">parent</a><span>|</span><a href="#36744371">next</a><span>|</span><label class="collapse" for="c-36744459">[-]</label><label class="expand" for="c-36744459">[1 more]</label></div><br/><div class="children"><div class="content">If your products biggest concern is fungibility of developers and controlling what developers can do then you likely wouldn&#x27;t be getting any value from any of the group of expressive languages anyway.<p>&gt;Obviously there exist projects in less expressive languages that are hard to maintain<p>This is the flip side of more conservative language choices. The moment you&#x27;re off the beaten path you&#x27;re doing way more custom stuff to work around the language. My favourite one I point at is Instagram&#x27;s use of Python is commonly held up as &quot;Python can do everything&quot; but when you read their tech blogs you&#x27;re basically reading &quot;here&#x27;s how we got some extremely skilled specialist language Devs to Jerry rig custom functionality onto python to create a flavour that could be doing absolutely anything. All to avoid hiring a few devs with a copy of a standard manual for some other language.<p>&gt; I still believe the type system of Haskell can provide great benefits to codebase maintenance over the long term. If the coding style were restricted and opinionated, it might assist with company adoption.<p>Counterpoint. What if it&#x27;s an impossible task for languages to encode a business domain and they should give your developers the tools to do it and then get out of the way? Its still opinionated. Its just that the opinions are coming from your businesses stack.</div><br/></div></div></div></div><div id="36744371" class="c"><input type="checkbox" id="c-36744371" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743497">parent</a><span>|</span><a href="#36744240">prev</a><span>|</span><a href="#36743535">next</a><span>|</span><label class="collapse" for="c-36744371">[-]</label><label class="expand" for="c-36744371">[3 more]</label></div><br/><div class="children"><div class="content">Haskell is a well designed language. Designed by some of worlds best experts on programming language theory. I don&#x27;t think it has any &quot;Rube Goldberg machine aspects&quot;, Solidity on the other hand...</div><br/><div id="36744431" class="c"><input type="checkbox" id="c-36744431" checked=""/><div class="controls bullet"><span class="by">peterbecich</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36744371">parent</a><span>|</span><a href="#36743535">next</a><span>|</span><label class="collapse" for="c-36744431">[-]</label><label class="expand" for="c-36744431">[2 more]</label></div><br/><div class="children"><div class="content">I agree completely. Haskell is a more difficult language to learn in my opinion than Python or Java, but there are real benefits in the runtime errors it can prevent.</div><br/><div id="36744537" class="c"><input type="checkbox" id="c-36744537" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36744431">parent</a><span>|</span><a href="#36743535">next</a><span>|</span><label class="collapse" for="c-36744537">[-]</label><label class="expand" for="c-36744537">[1 more]</label></div><br/><div class="children"><div class="content">Not sure why you are getting downvoted, but I agree. There is a learning curve to Haskell, which should not be surprising. Haskell is to Python what Python is to ARM assembly. ARM assembly has less of a learning curve than Python. There&#x27;s simply much less to learn and it&#x27;s much more flexible. But of course it&#x27;s not at all productive and even harder to build correct software with.<p>Once the learning curve has been overcome, most would agree that higher-level languages are more productive. I am significantly more productive in Haskell than Python, especially for any highly non-trivial problem.</div><br/></div></div></div></div></div></div><div id="36743535" class="c"><input type="checkbox" id="c-36743535" checked=""/><div class="controls bullet"><span class="by">Buttons840</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743497">parent</a><span>|</span><a href="#36744371">prev</a><span>|</span><a href="#36744101">next</a><span>|</span><label class="collapse" for="c-36743535">[-]</label><label class="expand" for="c-36743535">[1 more]</label></div><br/><div class="children"><div class="content">Maybe. I thought it had more to do with smart contracts, where the the mathematical and research oriented nature of Haskell helps somehow? I figured it had something to do with the &quot;if it compiles, it works&quot; aspect of Haskell (granted, Haskell has bugs like any language, but it&#x27;s closer to the compiles = perfect standard.)<p>I know the one and only Haskell job I personally looked into was about smart contracts.</div><br/></div></div><div id="36744101" class="c"><input type="checkbox" id="c-36744101" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743497">parent</a><span>|</span><a href="#36743535">prev</a><span>|</span><a href="#36744271">next</a><span>|</span><label class="collapse" for="c-36744101">[-]</label><label class="expand" for="c-36744101">[2 more]</label></div><br/><div class="children"><div class="content">And using the latest webframework garbage react iteration is not tech for tech sake? Or worse tech for resume sake. At least with the former I get to enjoy myself.</div><br/><div id="36744300" class="c"><input type="checkbox" id="c-36744300" checked=""/><div class="controls bullet"><span class="by">intelVISA</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36744101">parent</a><span>|</span><a href="#36744271">next</a><span>|</span><label class="collapse" for="c-36744300">[-]</label><label class="expand" for="c-36744300">[1 more]</label></div><br/><div class="children"><div class="content">Plus, at least using Haskell exercises the mind: most web frameworks seem designed to keep one&#x27;s thoughts sedentary.</div><br/></div></div></div></div></div></div><div id="36744271" class="c"><input type="checkbox" id="c-36744271" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#36742998">root</a><span>|</span><a href="#36743231">parent</a><span>|</span><a href="#36743497">prev</a><span>|</span><label class="collapse" for="c-36744271">[-]</label><label class="expand" for="c-36744271">[1 more]</label></div><br/><div class="children"><div class="content">Insert something about &quot;our coin is secure because we code in a language that prevents programmers from making mistakes&quot;.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>