<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716109254797" as="style"/><link rel="stylesheet" href="styles.css?v=1716109254797"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jverzani.github.io/CalculusWithJuliaNotes.jl/">Calculus with Julia</a> <span class="domain">(<a href="https://jverzani.github.io">jverzani.github.io</a>)</span></div><div class="subtext"><span>barrenko</span> | <span>95 comments</span></div><br/><div><div id="40403059" class="c"><input type="checkbox" id="c-40403059" checked=""/><div class="controls bullet"><span class="by">ultrasounder</span><span>|</span><a href="#40402238">next</a><span>|</span><label class="collapse" for="c-40403059">[-]</label><label class="expand" for="c-40403059">[10 more]</label></div><br/><div class="children"><div class="content">This comes at a very opportune time in my life. when, my ward enters their HS -Junior year and they are taking SVC. Question to the Author(in case they are monitoring this thread), is it appropriate for a High-schooler with just an intro to Python?</div><br/><div id="40404709" class="c"><input type="checkbox" id="c-40404709" checked=""/><div class="controls bullet"><span class="by">seanhunter</span><span>|</span><a href="#40403059">parent</a><span>|</span><a href="#40404560">next</a><span>|</span><label class="collapse" for="c-40404709">[-]</label><label class="expand" for="c-40404709">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m going to say a strong no to that.  The programming parts are fine, but on a quick skim, the mathematics is written in a way they will likely find very confusing unless they already know calculus and leave them thinking they are bad at maths whereas actually the author is just not really trying to explain the maths to someone who doesn&#x27;t already know it.<p>For example look at the diagram on[1]. It has unlabled axes of a shaded L-shaped box with a curve going through it and then it is followed by a bunch of equations where he derives the formula for integration by parts using a set of parametric equations with multiple substitutions etc. I know what integration by parts is and how it works really well. This is possibly the most confusing way you could possibly derive the formula and&#x2F;or explain it, and this diagram really adds absolutely nothing unless you already know and understand the concept. If you have seen the exceptional diagrams and illustrations and clarity of explanation in a book like &quot;Calculus&quot; by James Stewart the contrast is so stark it really jumps out.<p>The normal way of explaining integration by parts starts the way the author does (with the product rule for derivitives) and shows a few examples of taking the derivitive of things using the product rule so you get an intuition for what the form of the resulting antiderivitive looks like.  You then go through the derivation of the formula for integration by parts by using the product rule for derivitives, integrating both sides and splitting the resulting integral[2]. Its very clear and easy to follow. And if they want to actually help the student to do this they teach something like the tabular&#x2F;&quot;DI&quot; method so the student isn&#x27;t tearing their hair out getting the signs mixed up when integrating by parts multiple times.<p>[1] <a href="https:&#x2F;&#x2F;jverzani.github.io&#x2F;CalculusWithJuliaNotes.jl&#x2F;integrals&#x2F;integration_by_parts.html" rel="nofollow">https:&#x2F;&#x2F;jverzani.github.io&#x2F;CalculusWithJuliaNotes.jl&#x2F;integra...</a><p>[2] My own notes on this derivation which I took when learning this are here.  Note that this isn&#x27;t me really trying to explain it to a beginner - it&#x27;s just my personal notes but it&#x27;s still a lot easier to follow than the example given <a href="https:&#x2F;&#x2F;publish.obsidian.md&#x2F;uncarved&#x2F;3+Resources&#x2F;Public&#x2F;Integration+by+parts" rel="nofollow">https:&#x2F;&#x2F;publish.obsidian.md&#x2F;uncarved&#x2F;3+Resources&#x2F;Public&#x2F;Inte...</a></div><br/><div id="40404854" class="c"><input type="checkbox" id="c-40404854" checked=""/><div class="controls bullet"><span class="by">barrenko</span><span>|</span><a href="#40403059">root</a><span>|</span><a href="#40404709">parent</a><span>|</span><a href="#40404560">next</a><span>|</span><label class="collapse" for="c-40404854">[-]</label><label class="expand" for="c-40404854">[1 more]</label></div><br/><div class="children"><div class="content">Hi sean, we have the same end-goal possibly.</div><br/></div></div></div></div><div id="40404560" class="c"><input type="checkbox" id="c-40404560" checked=""/><div class="controls bullet"><span class="by">hyencomper</span><span>|</span><a href="#40403059">parent</a><span>|</span><a href="#40404709">prev</a><span>|</span><a href="#40403578">next</a><span>|</span><label class="collapse" for="c-40404560">[-]</label><label class="expand" for="c-40404560">[1 more]</label></div><br/><div class="children"><div class="content">IMHO a HS student learning Calculus should first learn the subject with pen and paper for a while before programming. It is important to work through the problems and think about the fundamental concepts involved, rather than thinking about the syntax involved in coding their solutions. Practising with pen and paper helps to internalize the subject matter better.</div><br/></div></div><div id="40403578" class="c"><input type="checkbox" id="c-40403578" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40403059">parent</a><span>|</span><a href="#40404560">prev</a><span>|</span><a href="#40403405">next</a><span>|</span><label class="collapse" for="c-40403578">[-]</label><label class="expand" for="c-40403578">[1 more]</label></div><br/><div class="children"><div class="content">I disagree with sibling comment. No prior exposure to Julia or even programming is required for this course.</div><br/></div></div><div id="40403405" class="c"><input type="checkbox" id="c-40403405" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#40403059">parent</a><span>|</span><a href="#40403578">prev</a><span>|</span><a href="#40402238">next</a><span>|</span><label class="collapse" for="c-40403405">[-]</label><label class="expand" for="c-40403405">[5 more]</label></div><br/><div class="children"><div class="content">Stick with Python. Try SymPy.</div><br/><div id="40404017" class="c"><input type="checkbox" id="c-40404017" checked=""/><div class="controls bullet"><span class="by">ssivark</span><span>|</span><a href="#40403059">root</a><span>|</span><a href="#40403405">parent</a><span>|</span><a href="#40404404">next</a><span>|</span><label class="collapse" for="c-40404017">[-]</label><label class="expand" for="c-40404017">[1 more]</label></div><br/><div class="children"><div class="content">I imagine a language with decent support for macros would be much much more ergonomic for symbolic computation. Even ignoring all the other pros &amp; cons, just this one reason would push one strongly towards Julia, Lisp(s), Mathematica, etc for symbolic computation.</div><br/></div></div><div id="40404404" class="c"><input type="checkbox" id="c-40404404" checked=""/><div class="controls bullet"><span class="by">cfgauss2718</span><span>|</span><a href="#40403059">root</a><span>|</span><a href="#40403405">parent</a><span>|</span><a href="#40404017">prev</a><span>|</span><a href="#40403507">next</a><span>|</span><label class="collapse" for="c-40404404">[-]</label><label class="expand" for="c-40404404">[1 more]</label></div><br/><div class="children"><div class="content">Sympy is a poor tool to learn because it simply doesn’t scale to problems one most often encounters, even in schooling. Frankly, CAS are so general and unintelligent that problems with well known and elegant closed-form solutions, when presented to a system like sympy, result in an output which is often not even human readable - thousands of algebraic terms for instance to describe the equations of motion for a simple double pendulum.<p>Personally I have found that the best tools are 1) a firm grasp of elementary calculus (differential, series, and integral) and 2) exposure to simple numerical methods that apply to a broad range of problems.<p>Armed with this knowledge, in my opinion, Julia is a far superior language to python and its package ecosystem has a brighter future. Indeed, the language has been built with a focus on mathematical modeling and efficient numerical computation. It is a more natural starting point for those with an interest in mathematical modeling and engineering science, and will serve anyone who learns it better than python+numpy+sympy+scipy.</div><br/></div></div><div id="40403507" class="c"><input type="checkbox" id="c-40403507" checked=""/><div class="controls bullet"><span class="by">ultrasounder</span><span>|</span><a href="#40403059">root</a><span>|</span><a href="#40403405">parent</a><span>|</span><a href="#40404404">prev</a><span>|</span><a href="#40402238">next</a><span>|</span><label class="collapse" for="c-40403507">[-]</label><label class="expand" for="c-40403507">[2 more]</label></div><br/><div class="children"><div class="content">Great. Thanks. Any suggestions for a book or course that uses sympy to teach calculus( svc)?</div><br/><div id="40403752" class="c"><input type="checkbox" id="c-40403752" checked=""/><div class="controls bullet"><span class="by">nl</span><span>|</span><a href="#40403059">root</a><span>|</span><a href="#40403507">parent</a><span>|</span><a href="#40402238">next</a><span>|</span><label class="collapse" for="c-40403752">[-]</label><label class="expand" for="c-40403752">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;applied-calculus-with-python" rel="nofollow">https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;applied-calculus-with-python</a><p><a href="https:&#x2F;&#x2F;www.udemy.com&#x2F;course&#x2F;pycalc1_x&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.udemy.com&#x2F;course&#x2F;pycalc1_x&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="40402238" class="c"><input type="checkbox" id="c-40402238" checked=""/><div class="controls bullet"><span class="by">dfee</span><span>|</span><a href="#40403059">prev</a><span>|</span><a href="#40403117">next</a><span>|</span><label class="collapse" for="c-40402238">[-]</label><label class="expand" for="c-40402238">[57 more]</label></div><br/><div class="children"><div class="content">I skipped around in the book a bit and found it interesting. I’d consider encouraging my kids to learn calculus this way.<p>However, I am curious about the first paragraph of the preface:<p>&gt; Julia is an open-source programming language with an easy to learn syntax that is well suited for this task.<p>Why is Julia better suited than any other language?</div><br/><div id="40402543" class="c"><input type="checkbox" id="c-40402543" checked=""/><div class="controls bullet"><span class="by">staplung</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40402495">next</a><span>|</span><label class="collapse" for="c-40402543">[-]</label><label class="expand" for="c-40402543">[35 more]</label></div><br/><div class="children"><div class="content">Julia has a bunch of little niceties for mathematics:<p>* Prefixing a variable with a scaler will implicitly multiply, as in standard math notation (e.g. 3x would evaluate to 6 if x is 2)<p>* Lots of unicode support. Some feel almost gratuitous (∈ and ∉ are operators that work as you would expect) but it&#x27;s pretty nice to have π predefined (it&#x27;s even an irrational datatype) and to use √ as an operator (e.g. √2 is a valid expression and evaluates to a float). It&#x27;s not just that Julia supports these constructions but provides a convenient way to get them to appear.<p>* This is a little less relevant for calculus but vectors and matrices are fist class types in Julia. Entering and visually parsing matrices is so much easier in Julia than in Python.<p><pre><code>  m = [1 2 3;
       4 5 6;
       7 8 9]
</code></pre>
vs.<p><pre><code>  m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
Transposition is a single character operator (&#x27;). Dot product can be done with the dot operator (m ⋅ n). A\b works as it does in matlab.<p>* Julia supports broadcasting. It also has comprehensions but with broadcasting I personally find much less need for comprehensions.<p>* Rationals are built-in with very simple syntax (1&#x2F;&#x2F;2))</div><br/><div id="40402695" class="c"><input type="checkbox" id="c-40402695" checked=""/><div class="controls bullet"><span class="by">RivieraKid</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402543">parent</a><span>|</span><a href="#40403080">next</a><span>|</span><label class="collapse" for="c-40402695">[-]</label><label class="expand" for="c-40402695">[21 more]</label></div><br/><div class="children"><div class="content">I quite like and use Julia but wish there was a language mixing the best aspects of Julia and Swift (which I think can be done without many compromises, i.e. it would be a better language overall).<p>Some things I don&#x27;t like about Julia:<p>- array.mean().round(digits=2) is more readable than round(mean(array), digits=2)<p>- Poor support for OOP (no, pure FP is not the optimal programming approach).</div><br/><div id="40402805" class="c"><input type="checkbox" id="c-40402805" checked=""/><div class="controls bullet"><span class="by">staplung</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402695">parent</a><span>|</span><a href="#40403541">next</a><span>|</span><label class="collapse" for="c-40402805">[-]</label><label class="expand" for="c-40402805">[2 more]</label></div><br/><div class="children"><div class="content">Well, Julia also has a pipeline operator built in so:<p><pre><code>  array |&gt; mean |&gt; x-&gt;round(x; digits=2)
</code></pre>
will do what you want and is arguably <i>more</i> readable than dot notation.<p>Not supporting OOP is very much intentional. It has structs and multiple dispatch (which has proven to be insanely useful in Julia&#x27;s domain of scientific computing) so about the only thing you lose is the namespacing that dot syntax facilitates.</div><br/><div id="40405442" class="c"><input type="checkbox" id="c-40405442" checked=""/><div class="controls bullet"><span class="by">celrod</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402805">parent</a><span>|</span><a href="#40403541">next</a><span>|</span><label class="collapse" for="c-40405442">[-]</label><label class="expand" for="c-40405442">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not supporting OOP is very much intentional. It has structs and multiple dispatch (which has proven to be insanely useful in Julia&#x27;s domain of scientific computing) so about the only thing you lose is the namespacing that dot syntax facilitates.<p>I&#x27;m speaking only for myself here, but --<p>Lack of being able to instantiate non-leaf types really hurts libraries like Symbolics.jl or LLVM.jl.
You can directly compare LLVM.jl to the LLVM C++ API, and see how badly Julia suffers in expressing dynamic code compared to C++. Where C++ has single function specializations, Julia needs to monormphize creating a combinatoric explosion of identical method specializations and dynamic dispatch between them.<p>Intentional or not, it is questionable whether it was a good decision.<p>I&#x27;d suggest drawing inspiration from ML languages (and Rust) rather than C++ (although it might get pattern matching in C++26). E.g., I would strongly encourage Julia developers creating inherently dynamic types to favor MLStyle.jl over method dispatch for control flow, and to prefer closed type systems using a library like Expronicon.jl or SumTypes.jl.<p>Although the way Julia currently works is probably better for engineers and scientists. They want Julia to do what they intend, while having to know as little as possible about programming or how anything works.<p>I think Julia does well in requiring very little knowledge from the developer to get a working result, but the bar is much higher to get reasonable compile time performance, pre-compile-ability, and runtime performance when code is dynamic in behavior.</div><br/></div></div></div></div><div id="40403541" class="c"><input type="checkbox" id="c-40403541" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402695">parent</a><span>|</span><a href="#40402805">prev</a><span>|</span><a href="#40402739">next</a><span>|</span><label class="collapse" for="c-40403541">[-]</label><label class="expand" for="c-40403541">[12 more]</label></div><br/><div class="children"><div class="content">&gt; round(mean(array), digits=2)<p>is how mathematicians have thought for hundreds of years now. They do so in this way, because it&#x27;s indeed easier to parse, and philosophically it correctly represents what is happening mathematically.<p>&gt; array.mean().round(digits=2)<p>is how a subset of software engineers have thought about computation in the last couple of decades.<p>Technology should whenever possible adopt already existing conventions, because technology is created to serve the user, and not vice versa.</div><br/><div id="40403602" class="c"><input type="checkbox" id="c-40403602" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403541">parent</a><span>|</span><a href="#40402739">next</a><span>|</span><label class="collapse" for="c-40403602">[-]</label><label class="expand" for="c-40403602">[11 more]</label></div><br/><div class="children"><div class="content">&gt; is how mathematicians have thought for hundreds of years now.<p>&quot;Because tradition&quot; is not a good argument. We can and should strive for better.<p>The modern OOP-derived style of `array.mean().round(digits=2)` is just as exact in its specification, and arguably more semantically precise as well as it organizes the meaningful bits to be together.<p>Also I think you don&#x27;t account for how much mathematical notation has changed over the years. The `round(mean(array), digits=2)` structure is relatively recent, early 20th century I believe, and the result of active reforms.</div><br/><div id="40404266" class="c"><input type="checkbox" id="c-40404266" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403602">parent</a><span>|</span><a href="#40404408">next</a><span>|</span><label class="collapse" for="c-40404266">[-]</label><label class="expand" for="c-40404266">[6 more]</label></div><br/><div class="children"><div class="content">&gt; mathematical notation has changed over the years.<p>I agree. Math notation has changed in response to problems mathematicians have faced, and as their thinking have evolved. It should not change because tool builders for mathematicians - when the tool builders in most cases are not even professional mathematicians - decide some other notation is better.<p>&gt; array.mean().round(digits=2)<p>might be good (it is not) when you are operating on one object. As soon as you have a binary operation (say multiplication), this notation completely breaks down. Because the operation is often symmetric, or &quot;near&quot; symmetric, meaning it is not so different as to write something as ridiculous as x.product(y).<p>But more importantly, (common&#x2F;dominant) mathematics is functional in nature. It&#x27;s decidedly not object oriented. Given a matrix, M, doing something like M.eigenvalues() is vomit-inducing because eigenvalues is not a property of a matrix M. For matrices, its a map from a set of linear transformations (of which M is merely one item) onto a set of numbers. It is its own thing, separate from M.</div><br/><div id="40404570" class="c"><input type="checkbox" id="c-40404570" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404266">parent</a><span>|</span><a href="#40404288">next</a><span>|</span><label class="collapse" for="c-40404570">[-]</label><label class="expand" for="c-40404570">[1 more]</label></div><br/><div class="children"><div class="content">In programming it is typical to have an “eig” function, or something of the sort, which returns the eigenvalues of a matrix. eig(M) seems no less vomit inducing than M.eigenvaues(). Usually when mathematicians want eigenvalues they write something like “Given a matrix M with eigenvalues \lambda” and the eigenvalues just show up.</div><br/></div></div><div id="40404288" class="c"><input type="checkbox" id="c-40404288" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404266">parent</a><span>|</span><a href="#40404570">prev</a><span>|</span><a href="#40404408">next</a><span>|</span><label class="collapse" for="c-40404288">[-]</label><label class="expand" for="c-40404288">[4 more]</label></div><br/><div class="children"><div class="content">Now you&#x27;re gatekeeping on who is a real mathematician?<p>I don&#x27;t think this subthread is going to be productive and I&#x27;m bowing out.</div><br/><div id="40404533" class="c"><input type="checkbox" id="c-40404533" checked=""/><div class="controls bullet"><span class="by">nightlyherb</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404288">parent</a><span>|</span><a href="#40404408">next</a><span>|</span><label class="collapse" for="c-40404533">[-]</label><label class="expand" for="c-40404533">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the GP, but I&#x27;m sorry you felt gatekeeped. I don&#x27;t think GP conveyed &quot;real mathematicians should do FP&quot;, but rather something else, so I&#x27;ll try my best to share what I understood from that comment. Hope this makes you feel better.<p>Even though the notation changed over the years, the paradigm of &quot;numbers as immutable entities and pure functions&quot; has been the dominant way that math is presented, compared to something like &quot;encapsulated objects that interact with each other via sending messages&quot;.<p>I don&#x27;t think this <i>has</i> to be this way, and I do think that &quot;real math&quot; can also be laid out assuming principles of OOP. However, I do suspect it&#x27;s the way it is because the laws of nature are unchanging, in contrast to the logic of a business application.<p>Because Julia is a tool with the target audience of mathematicians and scientists, I think it&#x27;s a sensible decision to embrace the usual way of thinking, as opposed to presenting a relatively different way of thinking which steepens the learning curve. Not because data and functions are fundamentally better than OOP, but because it&#x27;s more pragmatic for the target audience.</div><br/><div id="40404852" class="c"><input type="checkbox" id="c-40404852" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404533">parent</a><span>|</span><a href="#40404408">next</a><span>|</span><label class="collapse" for="c-40404852">[-]</label><label class="expand" for="c-40404852">[2 more]</label></div><br/><div class="children"><div class="content">I understood the other poster correctly. This view of mathematics is as limiting and ignorant as the other poster’s.<p>The entire field of theoretical computer science, to which functional programming and type theory is closely tied, is a branch of mathematics. The Church-Turing thesis which gives both to our field equates the two at a very fundamental level. Questions about type theory, programming language design, and programmer ergonomics are fundamentally about math and applied math.<p>Maybe you and the other poster have in mind specific fields of math, but then you need to make claims for why those fields are sufficiently different as to be exempt from applicability of any of the advances in notation observed in other fields.<p>Your implicit assumption that you can divide computer science into a different bucket from “real math” is incorrect, and gatekeeping.<p>As I said though, I don’t think this is a profitable debate to have here on HN.</div><br/><div id="40405100" class="c"><input type="checkbox" id="c-40405100" checked=""/><div class="controls bullet"><span class="by">nightlyherb</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404852">parent</a><span>|</span><a href="#40404408">next</a><span>|</span><label class="collapse" for="c-40405100">[-]</label><label class="expand" for="c-40405100">[1 more]</label></div><br/><div class="children"><div class="content">Okay, I see what you mean.<p>&gt; Maybe you and the other poster have in mind specific fields of math,<p>Yes, because this is about Julia, I assumed we are talking about the specific fields of math that happen to be commonly used in mathematical and scientific computing, such as the ones learned in university math and science courses.<p>&gt; Your implicit assumption that you can divide computer science into a different bucket from “real math” is incorrect, and gatekeeping.<p>It is regretful that we had a miscommunication. I agree with you that computer science belongs into the same bucket as &quot;real math&quot;. The thing is, in the context of Julia it is not easy to read &quot;math&quot; as &quot;math, but not only the domains that Julia is concerned in, but really all fields of math, including theoretical computer science&quot;. At least thanks to your comment, I see what you mean more clearly, and I think it&#x27;ll help some other potential readers as well.<p>&gt; but then you need to make claims for why those fields are sufficiently different as to be exempt from applicability of any of the advances in notation observed in other fields.<p>I&#x27;m curious to know specifically about the specific advances of notation observed in other fields. By this you mean dot notation for method application? I&#x27;m unsure if `a.method(b).anotherMethod(c)` is more advanced than `a |&gt; method(b) |&gt; anotherMethod(c)` (Edit: or `(anotherMethod(c) . method(b))(a)`) notation-wise.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40404408" class="c"><input type="checkbox" id="c-40404408" checked=""/><div class="controls bullet"><span class="by">nightlyherb</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403602">parent</a><span>|</span><a href="#40404266">prev</a><span>|</span><a href="#40403910">next</a><span>|</span><label class="collapse" for="c-40404408">[-]</label><label class="expand" for="c-40404408">[1 more]</label></div><br/><div class="children"><div class="content">As a person who respects many programming paradigms including OOP and FP, I beg to disagree. Specifically, I&#x27;m assuming you&#x27;re talking about OOP the paradigm, not only the dot notation, for which the pipe operator is a viable alternative.<p>&gt; The modern OOP-derived style of `array.mean().round(digits=2)` is just as exact in its specification, and arguably more semantically precise as well as it organizes the meaningful bits to be together.<p>I would have agreed with you if I were developing business applications. However, for the domain of math and science, every piece of material that I have seen assumes the paradigm of numbers as immutable entities and functions, not the paradigm of mutable encapsulated objects and interacting messages. To a mathematician or scientist the semantics of a `Vector` (as data) and a `mean` function that takes the `Vector` as input should be more natural than a black-box `Vector` object that can receive a `mean` method.</div><br/></div></div><div id="40403910" class="c"><input type="checkbox" id="c-40403910" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403602">parent</a><span>|</span><a href="#40404408">prev</a><span>|</span><a href="#40402739">next</a><span>|</span><label class="collapse" for="c-40403910">[-]</label><label class="expand" for="c-40403910">[3 more]</label></div><br/><div class="children"><div class="content">I used to miss &quot;OOP&quot; in Julia. The funny thing about the dot notation is that it makes the limitations of single dispatch seem natural. Once you get used to multiple dispatch and its benefits, the dot notation seems limiting.<p>`x.plus(y)` dispatches based on (runtime) type of x (polymorphism) (single dispatch), and might call different functions based on the (compile time) type of y (function overloading).<p>In Julia, it would be `plus(x, y)`, and it can dispatch based on the runtime type of both x and y (or determine the correct method to call at compile time already, if the types of x and y can be determined then).</div><br/><div id="40404878" class="c"><input type="checkbox" id="c-40404878" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403910">parent</a><span>|</span><a href="#40402739">next</a><span>|</span><label class="collapse" for="c-40404878">[-]</label><label class="expand" for="c-40404878">[2 more]</label></div><br/><div class="children"><div class="content">Virtual method dispatch isn’t always a good thing though. It’s a tradeoff and typically you really want one or the other. C++ makes both available for that reason, although C++’s syntax is horrible.</div><br/><div id="40405290" class="c"><input type="checkbox" id="c-40405290" checked=""/><div class="controls bullet"><span class="by">jakobnissen</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404878">parent</a><span>|</span><a href="#40402739">next</a><span>|</span><label class="collapse" for="c-40405290">[-]</label><label class="expand" for="c-40405290">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s multiple dispatch though, not virtual dispatch. If I understand correctly, virtual dispatch means the method is picked at runtime. In Julia, the compiler is able to pick the correct method at compile time, even when dispatching on all arguments of the function.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40402739" class="c"><input type="checkbox" id="c-40402739" checked=""/><div class="controls bullet"><span class="by">abisen</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402695">parent</a><span>|</span><a href="#40403541">prev</a><span>|</span><a href="#40404046">next</a><span>|</span><label class="collapse" for="c-40402739">[-]</label><label class="expand" for="c-40402739">[3 more]</label></div><br/><div class="children"><div class="content">If I am not using named arguments I find myself using the pipe operator a lot. I also find it more readable.<p>array |&gt; mean |&gt; round<p>For scenarios with named arguments there is a little not so cleaner workaround<p>array |&gt; mean |&gt; x-&gt;round(x, digits=2)</div><br/><div id="40402998" class="c"><input type="checkbox" id="c-40402998" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402739">parent</a><span>|</span><a href="#40404046">next</a><span>|</span><label class="collapse" for="c-40402998">[-]</label><label class="expand" for="c-40402998">[2 more]</label></div><br/><div class="children"><div class="content">array |&gt; mean |&gt; round(; digits=2) should also work and is a bit more concise.</div><br/><div id="40403917" class="c"><input type="checkbox" id="c-40403917" checked=""/><div class="controls bullet"><span class="by">SatvikBeri</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402998">parent</a><span>|</span><a href="#40404046">next</a><span>|</span><label class="collapse" for="c-40403917">[-]</label><label class="expand" for="c-40403917">[1 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t work, at least for me on 1.10. `round(; digits=2)` would have to produce a function. But Julia doesn&#x27;t have automatic currying, so that only happens if someone has implemented a special-case version (e.g. (==)(3) returns a partial function that tests for equality with 3.)</div><br/></div></div></div></div></div></div><div id="40404046" class="c"><input type="checkbox" id="c-40404046" checked=""/><div class="controls bullet"><span class="by">ssivark</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402695">parent</a><span>|</span><a href="#40402739">prev</a><span>|</span><a href="#40402731">next</a><span>|</span><label class="collapse" for="c-40404046">[-]</label><label class="expand" for="c-40404046">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Poor support for OOP (no, pure FP is not the optimal programming approach).<p>Julia is not really a pure functional programming language, though it does support that style if one desires.<p>It&#x27;s actually a <i>&quot;multiple dispatch&quot;</i> language... thinking of OOP as single dispatch, Julia is conceptually OOP on steroids -- but to benefit from the full expressiveness, the programming style looks different from the typical OOP syntax&#x2F;patterns one is used to.</div><br/><div id="40404458" class="c"><input type="checkbox" id="c-40404458" checked=""/><div class="controls bullet"><span class="by">waveBidder</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404046">parent</a><span>|</span><a href="#40402731">next</a><span>|</span><label class="collapse" for="c-40404458">[-]</label><label class="expand" for="c-40404458">[1 more]</label></div><br/><div class="children"><div class="content">having spent my PhD writing in Julia, coming back to object oriented programming felt like programming with a hand tied to my back. many operations just make more sense dispatching on multiple arguments rather than just one, and. cramming methods into a class felt unnatural</div><br/></div></div></div></div><div id="40402731" class="c"><input type="checkbox" id="c-40402731" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402695">parent</a><span>|</span><a href="#40404046">prev</a><span>|</span><a href="#40403080">next</a><span>|</span><label class="collapse" for="c-40402731">[-]</label><label class="expand" for="c-40402731">[1 more]</label></div><br/><div class="children"><div class="content">You <i>can</i> overload your own types to get a lot of those things (poor support for OOP is harder but you can sort of emulate it with traits). Overloading `getproperty` for the former case.<p>Of course it&#x27;s not built in, which I understand is annoying if that&#x27;s your preferred coding style. I personally am sad that really good traits aren&#x27;t encoded in the language.</div><br/></div></div></div></div><div id="40403080" class="c"><input type="checkbox" id="c-40403080" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402543">parent</a><span>|</span><a href="#40402695">prev</a><span>|</span><a href="#40402930">next</a><span>|</span><label class="collapse" for="c-40403080">[-]</label><label class="expand" for="c-40403080">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    m = [[1, 2, 3],
         [4, 5, 6],
         [7, 8, 9]]</code></pre></div><br/></div></div><div id="40402930" class="c"><input type="checkbox" id="c-40402930" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402543">parent</a><span>|</span><a href="#40403080">prev</a><span>|</span><a href="#40402495">next</a><span>|</span><label class="collapse" for="c-40402930">[-]</label><label class="expand" for="c-40402930">[12 more]</label></div><br/><div class="children"><div class="content">But why would be better than Mathematica for example for calculus?</div><br/><div id="40403018" class="c"><input type="checkbox" id="c-40403018" checked=""/><div class="controls bullet"><span class="by">moelf</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402930">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403018">[-]</label><label class="expand" for="c-40403018">[10 more]</label></div><br/><div class="children"><div class="content">it&#x27;s very hard to argue anything is &quot;better&quot; than Wolfram&#x2F;Mathematica when it comes to symbolic stuff, after all, most theoretical physicists use Mathematica for their professional work.<p>But for (entry-level) learning and possibly pivoting to application, Julia is delightful to use and can transit into some symbolics and numerical. Besides, it&#x27;s free and open source.</div><br/><div id="40403090" class="c"><input type="checkbox" id="c-40403090" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403018">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403090">[-]</label><label class="expand" for="c-40403090">[9 more]</label></div><br/><div class="children"><div class="content">&gt;most theoretical physicists use Mathematica for their professional work.<p>They do not.</div><br/><div id="40403144" class="c"><input type="checkbox" id="c-40403144" checked=""/><div class="controls bullet"><span class="by">fiforpg</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403090">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403144">[-]</label><label class="expand" for="c-40403144">[8 more]</label></div><br/><div class="children"><div class="content">Surely, <i>many</i> do? The ones I interacted with did, for example. I&#x27;d venture that the preferred CAS varies with schools and countries.</div><br/><div id="40403251" class="c"><input type="checkbox" id="c-40403251" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403144">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403251">[-]</label><label class="expand" for="c-40403251">[7 more]</label></div><br/><div class="children"><div class="content">Some do, most don&#x27;t.<p>Unless you&#x27;re working on undergraduate integrals then it&#x27;s pretty useless for advanced stuff without writing your own library. By that point you may as well write it in a language that&#x27;s more performant and cheaper.</div><br/><div id="40404082" class="c"><input type="checkbox" id="c-40404082" checked=""/><div class="controls bullet"><span class="by">ssivark</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403251">parent</a><span>|</span><a href="#40403513">next</a><span>|</span><label class="collapse" for="c-40404082">[-]</label><label class="expand" for="c-40404082">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Unless you&#x27;re working on undergraduate integrals then it&#x27;s pretty useless for advanced stuff without writing your own library. By that point you may as well write it in a language that&#x27;s more performant and cheaper.<p>Hard disagree. Mathematica&#x27;s symbolic dexterity makes abstract reasoning (with equations&#x2F;expressions) very easy. Think of it as the companion tool for anyone doing pages of algebra that would go into a paper, or form the backend for some code.<p>The numerical capabilities of Mathematica are passable but nothing fancy. Once you have the math figured out, you might even want to reimplement <i>&quot;in a language that&#x27;s more performant and cheaper.&quot;</i> But I haven&#x27;t see anything come close to Mathematica for convenience of symbolic reasoning -- not just as a technology (lisp is pretty good) but as a ready-for-use product.</div><br/></div></div><div id="40403513" class="c"><input type="checkbox" id="c-40403513" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403251">parent</a><span>|</span><a href="#40404082">prev</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403513">[-]</label><label class="expand" for="c-40403513">[5 more]</label></div><br/><div class="children"><div class="content">I agree that only some physicists use Mathematica. But I haven&#x27;t really seen it being used it for calculus. Maybe some differential equations.<p>But mostly for symbolic algebriac manipulation. I used it during my phd to work with groups. Instead of having to calculate stuff by hand, you can just ask Mathematica to do it. Also lots of stuff with tensors in GR is so easy to do in Mathematica.</div><br/><div id="40403669" class="c"><input type="checkbox" id="c-40403669" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403513">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403669">[-]</label><label class="expand" for="c-40403669">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fair to say that most math&#x2F;physics people use mathematica from time to time, but largely for different things than they use other programming languages for. It&#x27;s very good as a CAS, but it&#x27;s a pretty bad programming language for things that don&#x27;t have analytical solutions.</div><br/><div id="40403786" class="c"><input type="checkbox" id="c-40403786" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403669">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40403786">[-]</label><label class="expand" for="c-40403786">[3 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t. Mathematica is very much a niche product in academia.<p>The people who would get most out of it are students, but for some god forsaken reason universities don&#x27;t support them.<p>I was in a pilot class with Mathematica back in 2006 and the review of the class were _all_ 5 stars and students on average got 10% higher marks in all other subjects they took that year.<p>They didn&#x27;t run the course again.<p>Sagemath is now equally good if a teacher defines a DSL for the students to use in a class.</div><br/><div id="40404587" class="c"><input type="checkbox" id="c-40404587" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403786">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40404587">[-]</label><label class="expand" for="c-40404587">[2 more]</label></div><br/><div class="children"><div class="content">Sagemath seems much more appropriate; it is better not to bind students to proprietary tools.</div><br/><div id="40405287" class="c"><input type="checkbox" id="c-40405287" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404587">parent</a><span>|</span><a href="#40403611">next</a><span>|</span><label class="collapse" for="c-40405287">[-]</label><label class="expand" for="c-40405287">[1 more]</label></div><br/><div class="children"><div class="content">The only &quot;problem&quot; with sagemath is that it is based on Python.  The rationale is that Python is easy to start using and widely known.  This is the usual &quot;make it easy for newcomers&quot; trap.<p>For the mathematical constructs we care about in symbolic programming, I have found Python&#x27;s syntax and Sage&#x27;s menagerie of objects awful to use.  Initially you feel comfortable, but when you want to do some real work, it gets horribly in the way.  The Wolfram language, a LISP variant, is less familiar and harder for a newbie to learn but it is vastly superior for actual work.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40403611" class="c"><input type="checkbox" id="c-40403611" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402930">parent</a><span>|</span><a href="#40403018">prev</a><span>|</span><a href="#40402495">next</a><span>|</span><label class="collapse" for="c-40403611">[-]</label><label class="expand" for="c-40403611">[1 more]</label></div><br/><div class="children"><div class="content">TFA covers that question:<p>&gt; There are many examples of integrating a computer algebra system (such as Mathematica, Maple, or Sage) into the calculus conversation. Computer algebra systems can be magical. The popular WolframAlpha website calls the full power of Mathematica while allowing an informal syntax that is flexible enough to be used as a backend for Apple’s Siri feature. (“Siri what is the graph of x squared minus 4?”) For learning purposes, computer algebra systems model very well the algebraic&#x2F;symbolic treatment of the material while providing means to illustrate the numeric aspects. These notes are a bit different in that Julia is primarily used for the numeric style of computing and the algebraic&#x2F;symbolic treatment is added on. Doing the symbolic treatment by hand can be very beneficial while learning, and computer algebra systems make those exercises seem kind of redundant, as the finished product can be produced much easier.<p>TL;DR: they want the student to actually do some of the work that Mathematic magics away.</div><br/></div></div></div></div></div></div><div id="40402495" class="c"><input type="checkbox" id="c-40402495" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40402543">prev</a><span>|</span><a href="#40402274">next</a><span>|</span><label class="collapse" for="c-40402495">[-]</label><label class="expand" for="c-40402495">[13 more]</label></div><br/><div class="children"><div class="content">&gt;Why is Julia better suited than any other language?<p>Because it is a language specifically targeted for doing numerical analysis.<p>Python, which is it&#x27;s main &quot;competitor&quot; has a notoriously poor syntax for mathematical operations with miniscule standard library support for mathematics, a very limited type system and abysmal runtime performance. Julia addresses all of these issues and gives a relatively simple to read language, which often closely resembles mathematical notation and has quite decent performance.</div><br/><div id="40402567" class="c"><input type="checkbox" id="c-40402567" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402495">parent</a><span>|</span><a href="#40402274">next</a><span>|</span><label class="collapse" for="c-40402567">[-]</label><label class="expand" for="c-40402567">[12 more]</label></div><br/><div class="children"><div class="content">&quot;its&quot; not &quot;it&#x27;s&quot;<p>numpy has similar syntax to MATLAB and Julia<p>Python&#x27;s type system is pretty rich and allows overloading all operators</div><br/><div id="40402629" class="c"><input type="checkbox" id="c-40402629" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402567">parent</a><span>|</span><a href="#40402707">next</a><span>|</span><label class="collapse" for="c-40402629">[-]</label><label class="expand" for="c-40402629">[3 more]</label></div><br/><div class="children"><div class="content">&gt;numpy has similar syntax to MATLAB and Julia<p>Numpy has absolutely awful syntax compared to Julia or MATLAB. It is fundamentally limited by pythons syntax, which was never meant to support the rich operations you can do in Julia.<p>I have done quite a bit in both languages and it is extremely clear which language was designed for numerical analysis and which wasn&#x27;t .<p>&gt;Python&#x27;s type system is pretty rich and allows overloading all operators<p>The language barely has support for type annotations. Duck typing is actually a very bad thing for doing numerical analysis, since you actually care a lot about the data types you are operating on.<p>Pythons type system is so utterly inadequate that you need an external library to have things like proper float types.</div><br/><div id="40404733" class="c"><input type="checkbox" id="c-40404733" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402629">parent</a><span>|</span><a href="#40402707">next</a><span>|</span><label class="collapse" for="c-40404733">[-]</label><label class="expand" for="c-40404733">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re just repeating that it&#x27;s bad without any argument.<p>Numpy&#x27;s syntax is the same as MATLAB&#x27;s.<p>Both MATLAB and Julia also use dynamic typing, though it is true Julia does have support for ad-hoc static typing through annotations in a way that is stricter than Python&#x27;s.<p>Numpy does provide all the traditional floating-point types.</div><br/><div id="40405101" class="c"><input type="checkbox" id="c-40405101" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40404733">parent</a><span>|</span><a href="#40402707">next</a><span>|</span><label class="collapse" for="c-40405101">[-]</label><label class="expand" for="c-40405101">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Numpy&#x27;s syntax is the same as MATLAB&#x27;s.<p>That is just plain false. Can you try reading the numpy documentation? They have an article about exactly that topic and even say that numpys Syntax is more verbose.<p>If you read that documentation you would also realize that numpy has a different approach to Arrays than both MATLAB and Julia.<p>Here: <a href="https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;user&#x2F;numpy-for-matlab-users.html" rel="nofollow">https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;stable&#x2F;user&#x2F;numpy-for-matlab-users.htm...</a><p>&quot;MATLAB’s scripting language was created for linear algebra so the syntax for some array manipulations is more compact than NumPy’s.&quot;</div><br/></div></div></div></div></div></div><div id="40402707" class="c"><input type="checkbox" id="c-40402707" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402567">parent</a><span>|</span><a href="#40402629">prev</a><span>|</span><a href="#40402274">next</a><span>|</span><label class="collapse" for="c-40402707">[-]</label><label class="expand" for="c-40402707">[8 more]</label></div><br/><div class="children"><div class="content">I would argue that default element-wise operations and 0 based indexing can lead to a lot of cognitive overhead vs the &quot;more math-y&quot; notation of MATLAB or Julia. And overloaded operators like block matrix notation or linear solves are much closer.<p>The type system in Julia is perhaps even better than MATLAB for some linear algebra operations (a Vector is always a Vector, a scalar is always a scalar). But the Python ecosystem is often far superior to both, and MATLAB has toolboxes which don&#x27;t have equivalents in either other language. Julia has some uniquely strong package ecosystems (autodiff to some extent, differential equations, optimization), but far fewer.</div><br/><div id="40402963" class="c"><input type="checkbox" id="c-40402963" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402707">parent</a><span>|</span><a href="#40402943">next</a><span>|</span><label class="collapse" for="c-40402963">[-]</label><label class="expand" for="c-40402963">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the Python ecosystem is often far superior to both<p>What would you say does the Python ecosystem have that the others are missing? The obvious thing is pytorch&#x2F;tensorflow&#x2F;.... I can&#x27;t think of much else though.</div><br/><div id="40405116" class="c"><input type="checkbox" id="c-40405116" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402963">parent</a><span>|</span><a href="#40402943">next</a><span>|</span><label class="collapse" for="c-40405116">[-]</label><label class="expand" for="c-40405116">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The obvious thing is pytorch&#x2F;tensorflow&#x2F;.... I can&#x27;t think of much else though.<p>Julia has Flux, which is <i>great</i>. To create a neural network with Flux, you write the forward operation however you want and just auto differentiate the whole thing automatically and get a trainable net.<p>It is extremely flexible and intuitive.<p>What Julia lacks is everything which isn&#x27;t numerical analysis though.</div><br/></div></div></div></div><div id="40402943" class="c"><input type="checkbox" id="c-40402943" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402707">parent</a><span>|</span><a href="#40402963">prev</a><span>|</span><a href="#40403174">next</a><span>|</span><label class="collapse" for="c-40402943">[-]</label><label class="expand" for="c-40402943">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  0 based indexing<p>I mean, zero based indexing isn&#x27;t exclusive to computing.  Plenty of times in physics or math we do x_0 for the start of a sequence vs x_1.<p>Although, fair, our textbook had the definition of a sequence being a mapping of elements to z+, which is zero exclusive</div><br/></div></div><div id="40403174" class="c"><input type="checkbox" id="c-40403174" checked=""/><div class="controls bullet"><span class="by">daynthelife</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402707">parent</a><span>|</span><a href="#40402943">prev</a><span>|</span><a href="#40402274">next</a><span>|</span><label class="collapse" for="c-40403174">[-]</label><label class="expand" for="c-40403174">[4 more]</label></div><br/><div class="children"><div class="content">I disagree on the zero-based indexing complaint. Indeed, the fact that Julia indexed from 1 is the <i>sole</i> reason I will never use an otherwise great language. I can’t comprehend how people came to the conclusion this was a good idea.</div><br/><div id="40403649" class="c"><input type="checkbox" id="c-40403649" checked=""/><div class="controls bullet"><span class="by">dmz73</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403174">parent</a><span>|</span><a href="#40405131">next</a><span>|</span><label class="collapse" for="c-40403649">[-]</label><label class="expand" for="c-40403649">[1 more]</label></div><br/><div class="children"><div class="content">It seems that a lot of programmers have trouble distinguishing between indexing and offsets.
This is probably due to legacy of C language which conflates those two, possibly for performance and simplicity reasons. Same goes for case sensitivity in programming languages, again a legacy of C...are Print, print and PRINT really different functions, is that really what you intended???
Anyway, indexing is enumerating elements and it naturally starts at 1 for the first element and goes to Count for the last.
Offsets are pointer arithmetic artifact where first element is at offset of 0 for most but not all data structures.
Then you get &quot;modern&quot; languages like Python where they adopt indexing from 0 (no offsets since there are no pointers) and range where start is inclusive and end is exclusive...very natural behavior there. Oh, and lets make it case sensitive so you never know if it&#x27;s Print, print, PRINT...or count, Count and COUNT until you run for 20 min and then crash.</div><br/></div></div><div id="40405131" class="c"><input type="checkbox" id="c-40405131" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403174">parent</a><span>|</span><a href="#40403649">prev</a><span>|</span><a href="#40403945">next</a><span>|</span><label class="collapse" for="c-40405131">[-]</label><label class="expand" for="c-40405131">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I can’t comprehend how people came to the conclusion this was a good idea.<p>If you look at a textbook for numerical analysis likely the algorithms will be 1-indexed. Julia is a language primarily for writing down mathematics, it would be quite silly not to use mathematical conventions.</div><br/></div></div><div id="40403945" class="c"><input type="checkbox" id="c-40403945" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40403174">parent</a><span>|</span><a href="#40405131">prev</a><span>|</span><a href="#40402274">next</a><span>|</span><label class="collapse" for="c-40403945">[-]</label><label class="expand" for="c-40403945">[1 more]</label></div><br/><div class="children"><div class="content">You think mathematicians had it all wrong for centuries?<p>Incidentally, I find it amusing that in Europe, the ground floor is zero, while in the US, it&#x27;s one. (A friend of mine arrived at college in the US and was told that her room was on the first floor. She asked whether there was a lift as her suitcase was quite heavy...)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40402274" class="c"><input type="checkbox" id="c-40402274" checked=""/><div class="controls bullet"><span class="by">blagie</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40402495">prev</a><span>|</span><a href="#40404561">next</a><span>|</span><label class="collapse" for="c-40402274">[-]</label><label class="expand" for="c-40402274">[1 more]</label></div><br/><div class="children"><div class="content">This is a good overview:<p><a href="https:&#x2F;&#x2F;computationalthinking.mit.edu&#x2F;Spring21&#x2F;" rel="nofollow">https:&#x2F;&#x2F;computationalthinking.mit.edu&#x2F;Spring21&#x2F;</a><p>The very short story is that it&#x27;s a language somewhat similar to Python (and, likewise, easy-to-use), but with much richer syntax for expressing mathematics directly.<p>It also has richer notebooks. The key property is that in python notebooks, you run cells. In julia notebooks, it handles things like dependencies. If I change x, either as a number or a slider, all the dependencies things update. You can define a plot, add sliders, and it just works.<p>(Also: I&#x27;m not an expert in Julia; most of my work is in Python and JavaScript. I&#x27;m sure there are other reasons as well, but the two above come out very clearly in similar courses)</div><br/></div></div><div id="40404561" class="c"><input type="checkbox" id="c-40404561" checked=""/><div class="controls bullet"><span class="by">g0wda</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40402274">prev</a><span>|</span><a href="#40402328">next</a><span>|</span><label class="collapse" for="c-40404561">[-]</label><label class="expand" for="c-40404561">[1 more]</label></div><br/><div class="children"><div class="content">Multiple-dispatch is the right abstraction for programming mathematics. It provides both the flexibility required to create scientific software in layers (science has a LOT more function overloading compared to any other field.), and the information required to compile to fast machine code.</div><br/></div></div><div id="40402328" class="c"><input type="checkbox" id="c-40402328" checked=""/><div class="controls bullet"><span class="by">dnfsod</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40404561">prev</a><span>|</span><a href="#40402290">next</a><span>|</span><label class="collapse" for="c-40402328">[-]</label><label class="expand" for="c-40402328">[2 more]</label></div><br/><div class="children"><div class="content">I also clicked around and felt the formatting and progression of the book was a bit confusing, but found some of the Julia features intriguing. (like “postfixing” allowing the same pencil notation of f’ and f’’ et al)<p>In my opinion, and experience, the best “calculus book” is Learn Physics with Functional Programming which only relies on libraries for plotting, and uses Haskell rather than Julia.<p><a href="https:&#x2F;&#x2F;www.lpfp.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.lpfp.io&#x2F;</a><p>&gt; Why is Julia better suited than any other language?<p>Julia is known as a “programming language for math” and was designed with that conceit steering a lot of its development.<p>Explicitly it supports a lot of mathematical notation that matches handwritten or latex symbols.<p>Implicitly they may be referencing the simplified (see Pythtonic) syntax, combined with broad interoperability (this tutorial uses SymPy for a lot of the heavy lifting), lots of built in parallel computing primitives, and its use of JIT compilation allowing for fast iteration&#x2F;exploration.</div><br/><div id="40404717" class="c"><input type="checkbox" id="c-40404717" checked=""/><div class="controls bullet"><span class="by">barrenko</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402328">parent</a><span>|</span><a href="#40402290">next</a><span>|</span><label class="collapse" for="c-40404717">[-]</label><label class="expand" for="c-40404717">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for reminding me of LPFP!</div><br/></div></div></div></div><div id="40402290" class="c"><input type="checkbox" id="c-40402290" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40402328">prev</a><span>|</span><a href="#40402332">next</a><span>|</span><label class="collapse" for="c-40402290">[-]</label><label class="expand" for="c-40402290">[1 more]</label></div><br/><div class="children"><div class="content">Julia inherited a lot of MATLAB DNA like standard library linear algebra and 1 based indices. In addition it&#x27;s got very commonly used Unicode support and intentionally can look like pseudocode in many cases.</div><br/></div></div><div id="40402332" class="c"><input type="checkbox" id="c-40402332" checked=""/><div class="controls bullet"><span class="by">jakderrida</span><span>|</span><a href="#40402238">parent</a><span>|</span><a href="#40402290">prev</a><span>|</span><a href="#40403117">next</a><span>|</span><label class="collapse" for="c-40402332">[-]</label><label class="expand" for="c-40402332">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just guessing, but:<p>1. Open Source.<p>2. Easy to learn. (kind of)<p>3. Robust plotting and visualization capabilities, which are integral (I f*cking swear no pun intended) to understanding calculus, the foundational purpose of calculus being to find the area under the curve. (something I really wish they told me day one of Pre-Calc)<p>4. This one is just a vague feeling, but the fact that Python&#x27;s most robust Symbolic Regression package, SymPy, relies on running Julia in the background to do all the real work suggests to me that Julia is somehow just superior when it comes to formulas as opposed to just calculations. IDK how, though.</div><br/><div id="40402504" class="c"><input type="checkbox" id="c-40402504" checked=""/><div class="controls bullet"><span class="by">constantcrying</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402332">parent</a><span>|</span><a href="#40403117">next</a><span>|</span><label class="collapse" for="c-40402504">[-]</label><label class="expand" for="c-40402504">[2 more]</label></div><br/><div class="children"><div class="content">1-3 apply exactly the same to python, 4 is just false, SymPy is written in python, it has nothing to do with Julia.</div><br/><div id="40402746" class="c"><input type="checkbox" id="c-40402746" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#40402238">root</a><span>|</span><a href="#40402504">parent</a><span>|</span><a href="#40403117">next</a><span>|</span><label class="collapse" for="c-40402746">[-]</label><label class="expand" for="c-40402746">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re thinking of PySR but you are right on all points!</div><br/></div></div></div></div></div></div></div></div><div id="40403117" class="c"><input type="checkbox" id="c-40403117" checked=""/><div class="controls bullet"><span class="by">fiforpg</span><span>|</span><a href="#40402238">prev</a><span>|</span><a href="#40403041">next</a><span>|</span><label class="collapse" for="c-40403117">[-]</label><label class="expand" for="c-40403117">[4 more]</label></div><br/><div class="children"><div class="content">One has to be a little careful with designing courses like this. They are most likely to be of interest to people who already know, at least to some extent, both (i) calculus and (ii) programming. That is, the (presumable) target audience — those who are learning either of these subjects — is not really ready to take in such a class.<p>Anecdotally, my personal attempts at incorporating only slightly exotic CASes (Maxima or Sagemath) into calculus courses were met with tepid response at best. Part of the issue was, I believe, that freshmen are rarely interested in setting up software for a non-CS course.<p>That being said, for slightly higher-level classes it can work quite well as an <i>optional</i> component — I&#x27;ve had really good results with Python projects in an ODE course. Python not being a niche language certainly helped, too.</div><br/><div id="40405205" class="c"><input type="checkbox" id="c-40405205" checked=""/><div class="controls bullet"><span class="by">__rito__</span><span>|</span><a href="#40403117">parent</a><span>|</span><a href="#40403298">next</a><span>|</span><label class="collapse" for="c-40405205">[-]</label><label class="expand" for="c-40405205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;I&#x27;ve had really good results with Python projects in an ODE course.&quot;</i><p>Which textbook did you use for this course? What were the reference material? Could you share with me anything about this course? Lecture notes, code, slides, books, anything.</div><br/></div></div><div id="40403298" class="c"><input type="checkbox" id="c-40403298" checked=""/><div class="controls bullet"><span class="by">dr_kiszonka</span><span>|</span><a href="#40403117">parent</a><span>|</span><a href="#40405205">prev</a><span>|</span><a href="#40404409">next</a><span>|</span><label class="collapse" for="c-40403298">[-]</label><label class="expand" for="c-40403298">[1 more]</label></div><br/><div class="children"><div class="content">This is a common challenge in teaching stats where students have to learn statistical concepts and using statistical software simultaneously. In the end, I think it is worth the challenge and beats having students calculate everything by hand &amp; look up values in tables.</div><br/></div></div><div id="40404409" class="c"><input type="checkbox" id="c-40404409" checked=""/><div class="controls bullet"><span class="by">Egrodo</span><span>|</span><a href="#40403117">parent</a><span>|</span><a href="#40403298">prev</a><span>|</span><a href="#40403041">next</a><span>|</span><label class="collapse" for="c-40404409">[-]</label><label class="expand" for="c-40404409">[1 more]</label></div><br/><div class="children"><div class="content">As a self taught programmer who never got farther than algebra, this looks awesome to me and I may be that small target audience haha.</div><br/></div></div></div></div><div id="40403041" class="c"><input type="checkbox" id="c-40403041" checked=""/><div class="controls bullet"><span class="by">kickingvegas</span><span>|</span><a href="#40403117">prev</a><span>|</span><a href="#40402011">next</a><span>|</span><label class="collapse" for="c-40403041">[-]</label><label class="expand" for="c-40403041">[2 more]</label></div><br/><div class="children"><div class="content">Related: if you use Emacs it has the Calc package which supports computer algebra. I recently published an interface for Calc that makes it significantly easier to use and wrote about it here. <a href="http:&#x2F;&#x2F;yummymelon.com&#x2F;devnull&#x2F;mathing-in-emacs-with-casual.html" rel="nofollow">http:&#x2F;&#x2F;yummymelon.com&#x2F;devnull&#x2F;mathing-in-emacs-with-casual.h...</a></div><br/><div id="40403191" class="c"><input type="checkbox" id="c-40403191" checked=""/><div class="controls bullet"><span class="by">fiforpg</span><span>|</span><a href="#40403041">parent</a><span>|</span><a href="#40402011">next</a><span>|</span><label class="collapse" for="c-40403191">[-]</label><label class="expand" for="c-40403191">[1 more]</label></div><br/><div class="children"><div class="content">Nice work!<p>Emacs folks may also like the Maxima mode, a very capable interface to a full-blown CAS: <a href="https:&#x2F;&#x2F;www.emacswiki.org&#x2F;emacs&#x2F;MaximaMode" rel="nofollow">https:&#x2F;&#x2F;www.emacswiki.org&#x2F;emacs&#x2F;MaximaMode</a></div><br/></div></div></div></div><div id="40402011" class="c"><input type="checkbox" id="c-40402011" checked=""/><div class="controls bullet"><span class="by">jagged-chisel</span><span>|</span><a href="#40403041">prev</a><span>|</span><a href="#40402288">next</a><span>|</span><label class="collapse" for="c-40402011">[-]</label><label class="expand" for="c-40402011">[2 more]</label></div><br/><div class="children"><div class="content">PDF link in the page header is 404</div><br/><div id="40402164" class="c"><input type="checkbox" id="c-40402164" checked=""/><div class="controls bullet"><span class="by">mhd</span><span>|</span><a href="#40402011">parent</a><span>|</span><a href="#40402288">next</a><span>|</span><label class="collapse" for="c-40402164">[-]</label><label class="expand" for="c-40402164">[1 more]</label></div><br/><div class="children"><div class="content">I assume they turned it off intentionally:<p><i>&quot;These notes may be compiled into a pdf file through Quarto. As the result is rather large, we do not provide that file for download. For the interested reader, downloading the repository, instantiating the environment, and running quarto to render to pdf in the quarto subdirectory should produce that file (after some time).&quot;</i></div><br/></div></div></div></div><div id="40402288" class="c"><input type="checkbox" id="c-40402288" checked=""/><div class="controls bullet"><span class="by">blagie</span><span>|</span><a href="#40402011">prev</a><span>|</span><a href="#40402327">next</a><span>|</span><label class="collapse" for="c-40402288">[-]</label><label class="expand" for="c-40402288">[2 more]</label></div><br/><div class="children"><div class="content">I like the concept.<p>I&#x27;d much rather have this built on top of or from something like MOOCulus.<p><a href="https:&#x2F;&#x2F;ximera.osu.edu&#x2F;mooculus&#x2F;calculus1" rel="nofollow">https:&#x2F;&#x2F;ximera.osu.edu&#x2F;mooculus&#x2F;calculus1</a><p>Holistically, I prefer MOOCulus. However, the value-add of Calculus with Julia is large. If the two could integrate somehow... the key thing about MOOCulus is the writing quality is better (much less verbose), and the integrated exercises means kids follow it closely. It&#x27;s also very refined, from a lot of classroom use.<p>If it were forked and Julia-enhanced, that would be a very big step up, though. As would the addition of applications.</div><br/><div id="40402426" class="c"><input type="checkbox" id="c-40402426" checked=""/><div class="controls bullet"><span class="by">bmitc</span><span>|</span><a href="#40402288">parent</a><span>|</span><a href="#40402327">next</a><span>|</span><label class="collapse" for="c-40402426">[-]</label><label class="expand" for="c-40402426">[1 more]</label></div><br/><div class="children"><div class="content">I checked out the website, and it&#x27;s really hard to even know how to use. Plus, the first thing I clicked on, &quot;Equal or Not?&quot;, has errors.</div><br/></div></div></div></div><div id="40402327" class="c"><input type="checkbox" id="c-40402327" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#40402288">prev</a><span>|</span><a href="#40402715">next</a><span>|</span><label class="collapse" for="c-40402327">[-]</label><label class="expand" for="c-40402327">[11 more]</label></div><br/><div class="children"><div class="content">For someone coming from Matlab, is Julia a valid replacement?</div><br/><div id="40403952" class="c"><input type="checkbox" id="c-40403952" checked=""/><div class="controls bullet"><span class="by">SatvikBeri</span><span>|</span><a href="#40402327">parent</a><span>|</span><a href="#40403989">next</a><span>|</span><label class="collapse" for="c-40403952">[-]</label><label class="expand" for="c-40403952">[1 more]</label></div><br/><div class="children"><div class="content">In some ways – it&#x27;s much faster, it generally has a lot of features that make it better as a programming language, it&#x27;s much easier to parallelize. As someone who&#x27;s written both professionally, I would say Julia is usually the better choice today.<p>But there is a huge array of existing algorithms that are already implemented in languages like matlab or stata that may not have corresponding equivalents. If what you want is one of these, it&#x27;s often hard to justify using another language (though in practice I&#x27;ve usually found it pretty easy to port matlab&#x2F;python&#x2F;stat to Julia.)</div><br/></div></div><div id="40403989" class="c"><input type="checkbox" id="c-40403989" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#40402327">parent</a><span>|</span><a href="#40403952">prev</a><span>|</span><a href="#40402355">next</a><span>|</span><label class="collapse" for="c-40403989">[-]</label><label class="expand" for="c-40403989">[1 more]</label></div><br/><div class="children"><div class="content">Yes. It&#x27;s like giving a glass of ice water to somebody in hell (with apologies to Steve Jobs, who said that about iTunes on Windows, back when iTunes was not the mess it turned into later).<p>Mind you, I have huge respect for Cleve Moler and Matlab and all they have accomplished (making LINPACK and EISPACK and all that easily accessible). And they&#x27;ve worked hard to overcome the limitations of initially having only one datatype: a matrix.<p>But Julia as a modern general purpose language is just so much more pleasant to work with, while retaining nearly all of Matlab&#x27;s power.</div><br/></div></div><div id="40402355" class="c"><input type="checkbox" id="c-40402355" checked=""/><div class="controls bullet"><span class="by">goerz</span><span>|</span><a href="#40402327">parent</a><span>|</span><a href="#40403989">prev</a><span>|</span><a href="#40402565">next</a><span>|</span><label class="collapse" for="c-40402355">[-]</label><label class="expand" for="c-40402355">[5 more]</label></div><br/><div class="children"><div class="content">Very much so. See <a href="https:&#x2F;&#x2F;docs.julialang.org&#x2F;en&#x2F;v1&#x2F;manual&#x2F;noteworthy-differences&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.julialang.org&#x2F;en&#x2F;v1&#x2F;manual&#x2F;noteworthy-differenc...</a> for some details</div><br/><div id="40402600" class="c"><input type="checkbox" id="c-40402600" checked=""/><div class="controls bullet"><span class="by">BenFranklin100</span><span>|</span><a href="#40402327">root</a><span>|</span><a href="#40402355">parent</a><span>|</span><a href="#40402565">next</a><span>|</span><label class="collapse" for="c-40402600">[-]</label><label class="expand" for="c-40402600">[4 more]</label></div><br/><div class="children"><div class="content">While not a Matlab nor Julia user, I think you may be neglecting the nearly 40 years of code, toolboxes, and countless examples of common engineering problems solved in Matlab. Engineers tend to be more of a practical sort than developers, and just want to apply a known solution to a problem than mess around with newish software languages.</div><br/><div id="40402820" class="c"><input type="checkbox" id="c-40402820" checked=""/><div class="controls bullet"><span class="by">agucova</span><span>|</span><a href="#40402327">root</a><span>|</span><a href="#40402600">parent</a><span>|</span><a href="#40402565">next</a><span>|</span><label class="collapse" for="c-40402820">[-]</label><label class="expand" for="c-40402820">[3 more]</label></div><br/><div class="children"><div class="content">This is true, but even engineers see the advantages of Julia. My engineering school has went from almost pure Matlab usage to many key engineering courses switching to Julia due to its simplicity and friendliness.<p>It&#x27;s also SOTA for many engineering applications, particularly for acausal modelling and scientific machine learning (see <a href="https:&#x2F;&#x2F;sciml.ai" rel="nofollow">https:&#x2F;&#x2F;sciml.ai</a>), which has led to big companies like Pfizer adopting it [1]. And for engineers writing novel libraries, it clearly has a strong edge. See for example the work by NASA&#x27;s JPL [2, 3], the FAA [4] or the CliMa project [5].<p>[1]: <a href="https:&#x2F;&#x2F;juliahub.com&#x2F;case-studies&#x2F;pfizer&#x2F;" rel="nofollow">https:&#x2F;&#x2F;juliahub.com&#x2F;case-studies&#x2F;pfizer&#x2F;</a> (see also <a href="https:&#x2F;&#x2F;info.juliahub.com&#x2F;case-studies" rel="nofollow">https:&#x2F;&#x2F;info.juliahub.com&#x2F;case-studies</a>)
[2]: <a href="https:&#x2F;&#x2F;exoplanets.nasa.gov&#x2F;news&#x2F;1669&#x2F;seven-rocky-trappist-1-planets-may-be-made-of-similar-stuff&#x2F;" rel="nofollow">https:&#x2F;&#x2F;exoplanets.nasa.gov&#x2F;news&#x2F;1669&#x2F;seven-rocky-trappist-1...</a>
[3]: <a href="https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;citations&#x2F;20170008266" rel="nofollow">https:&#x2F;&#x2F;ntrs.nasa.gov&#x2F;citations&#x2F;20170008266</a>
[4]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;19zm1Fn0S9M" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;19zm1Fn0S9M</a>
[5]: <a href="https:&#x2F;&#x2F;clima.caltech.edu&#x2F;" rel="nofollow">https:&#x2F;&#x2F;clima.caltech.edu&#x2F;</a></div><br/><div id="40402902" class="c"><input type="checkbox" id="c-40402902" checked=""/><div class="controls bullet"><span class="by">logtempo</span><span>|</span><a href="#40402327">root</a><span>|</span><a href="#40402820">parent</a><span>|</span><a href="#40402565">next</a><span>|</span><label class="collapse" for="c-40402902">[-]</label><label class="expand" for="c-40402902">[2 more]</label></div><br/><div class="children"><div class="content">Tools are valid regarding a context (when you have a hammer everything is a nail etc.). In the industrial context, Julia is not valid. In the research&#x2F;education, it is valid. It does not mean that Julia will never be relevant in research.</div><br/><div id="40402991" class="c"><input type="checkbox" id="c-40402991" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#40402327">root</a><span>|</span><a href="#40402902">parent</a><span>|</span><a href="#40402565">next</a><span>|</span><label class="collapse" for="c-40402991">[-]</label><label class="expand" for="c-40402991">[1 more]</label></div><br/><div class="children"><div class="content">Our upcoming JuliaCon 2024 has a significant number of industrial talks and a minisymposium. ASML uses Julia quite widely in a definitively industrial context.<p><a href="https:&#x2F;&#x2F;juliacon.org&#x2F;2024&#x2F;" rel="nofollow">https:&#x2F;&#x2F;juliacon.org&#x2F;2024&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40402565" class="c"><input type="checkbox" id="c-40402565" checked=""/><div class="controls bullet"><span class="by">nsajko</span><span>|</span><a href="#40402327">parent</a><span>|</span><a href="#40402355">prev</a><span>|</span><a href="#40402744">next</a><span>|</span><label class="collapse" for="c-40402565">[-]</label><label class="expand" for="c-40402565">[1 more]</label></div><br/><div class="children"><div class="content">Very much so. Julia code can be both much nicer and much more performant than Matlab code can.</div><br/></div></div><div id="40402744" class="c"><input type="checkbox" id="c-40402744" checked=""/><div class="controls bullet"><span class="by">antegamisou</span><span>|</span><a href="#40402327">parent</a><span>|</span><a href="#40402565">prev</a><span>|</span><a href="#40402359">next</a><span>|</span><label class="collapse" for="c-40402744">[-]</label><label class="expand" for="c-40402744">[1 more]</label></div><br/><div class="children"><div class="content">No because Matlab is never going away from the industry. Same for Python&#x2F;matplotlib btw.</div><br/></div></div><div id="40402359" class="c"><input type="checkbox" id="c-40402359" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40402327">parent</a><span>|</span><a href="#40402744">prev</a><span>|</span><a href="#40402715">next</a><span>|</span><label class="collapse" for="c-40402359">[-]</label><label class="expand" for="c-40402359">[1 more]</label></div><br/><div class="children"><div class="content">yes.</div><br/></div></div></div></div><div id="40402715" class="c"><input type="checkbox" id="c-40402715" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#40402327">prev</a><span>|</span><label class="collapse" for="c-40402715">[-]</label><label class="expand" for="c-40402715">[6 more]</label></div><br/><div class="children"><div class="content">LuaJIT faster<p>I find it interesting that after all these year of little development on LuaJIT, and active development in Julia - that LuaJIT is still faster (while also being general purpose).<p><a href="https:&#x2F;&#x2F;julialang.org&#x2F;benchmarks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;julialang.org&#x2F;benchmarks&#x2F;</a></div><br/><div id="40402874" class="c"><input type="checkbox" id="c-40402874" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40402715">parent</a><span>|</span><a href="#40402842">next</a><span>|</span><label class="collapse" for="c-40402874">[-]</label><label class="expand" for="c-40402874">[1 more]</label></div><br/><div class="children"><div class="content">&quot;<i>Please don&#x27;t post shallow dismissals, especially of other people&#x27;s work. A good critical comment teaches us something.</i>&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div><div id="40402842" class="c"><input type="checkbox" id="c-40402842" checked=""/><div class="controls bullet"><span class="by">gc9</span><span>|</span><a href="#40402715">parent</a><span>|</span><a href="#40402874">prev</a><span>|</span><a href="#40402766">next</a><span>|</span><label class="collapse" for="c-40402842">[-]</label><label class="expand" for="c-40402842">[1 more]</label></div><br/><div class="children"><div class="content">Note that &quot;The benchmark data shown above were computed with Julia v1.0.0&quot; (2018)</div><br/></div></div><div id="40402766" class="c"><input type="checkbox" id="c-40402766" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#40402715">parent</a><span>|</span><a href="#40402842">prev</a><span>|</span><a href="#40402736">next</a><span>|</span><label class="collapse" for="c-40402766">[-]</label><label class="expand" for="c-40402766">[1 more]</label></div><br/><div class="children"><div class="content">LuaJIT is only appreciably faster on text ingestion and printing in those benchmarks. Julia is also plenty general purpose, just targeted (initially at least) towards the numerical community. LuaJIT is fantastically impressive though.</div><br/></div></div><div id="40402736" class="c"><input type="checkbox" id="c-40402736" checked=""/><div class="controls bullet"><span class="by">slwvx</span><span>|</span><a href="#40402715">parent</a><span>|</span><a href="#40402766">prev</a><span>|</span><label class="collapse" for="c-40402736">[-]</label><label class="expand" for="c-40402736">[2 more]</label></div><br/><div class="children"><div class="content">I find it interesting that after all these years of HN, commenters still ignore the main topic of the OP (a calculus book) to focus on the language it&#x27;s written in</div><br/><div id="40402873" class="c"><input type="checkbox" id="c-40402873" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40402715">root</a><span>|</span><a href="#40402736">parent</a><span>|</span><label class="collapse" for="c-40402873">[-]</label><label class="expand" for="c-40402873">[1 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t respond to a bad comment by breaking the site guidelines yourself. That only makes things worse.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>