<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1721379649402" as="style"/><link rel="stylesheet" href="styles.css?v=1721379649402"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arendjr.nl/blog/2024/07/post-architecture-premature-abstraction-is-the-root-of-all-evil/">Premature Abstraction</a> <span class="domain">(<a href="https://arendjr.nl">arendjr.nl</a>)</span></div><div class="subtext"><span>arendjr</span> | <span>85 comments</span></div><br/><div><div id="40995903" class="c"><input type="checkbox" id="c-40995903" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#40995812">next</a><span>|</span><label class="collapse" for="c-40995903">[-]</label><label class="expand" for="c-40995903">[41 more]</label></div><br/><div class="children"><div class="content">My general take (and w&#x2F; the caveat that every system is different) is as follows:<p>- procedural code to enter into the system (and perhaps that&#x27;s all you need)<p>- object oriented code for domain modeling<p>- functional code for data structure transformations &amp; some light custom control flow implementation (but not too much)<p>I like the imperative shell, functional core pattern quite a bit, and focusing on data structures is great advice as well.  The anti-OO trend in the industry has been richly earned by the OO architecture astronauts[1], but the idea of gathering a data structure and the operations on that data structure in a single place, with data hiding, is a good one, particularly for domain modeling.<p>In general I think we are maturing as an industry, recognizing that various approaches have their strengths and weaknesses and a good software engineer can mix and match them when building a successful software project.<p>There is no silver bullet.  If only someone had told us that years ago!<p>[1] - <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2001&#x2F;04&#x2F;21&#x2F;dont-let-architecture-astronauts-scare-you&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2001&#x2F;04&#x2F;21&#x2F;dont-let-architect...</a></div><br/><div id="40996367" class="c"><input type="checkbox" id="c-40996367" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#41002812">next</a><span>|</span><label class="collapse" for="c-40996367">[-]</label><label class="expand" for="c-40996367">[22 more]</label></div><br/><div class="children"><div class="content">OO code for domain modeling might be, to date, the single greatest source of disillusionment in my career.<p>There are absolutely use cases where it works very well. GUI toolkits come to mind. But for general line-of-business domain modeling, I keep noticing two big mismatches between the OO paradigm and the problem at hand. First and foremost, allowing subtyping into your business domain model is a trap. The problem is that your business rules are subject to change, you likely have limited or even no control over how they change, and the people who do get to make those decisions don&#x27;t know and don&#x27;t care about the Liskov Substitution Principle. In short, using one of the headline features of OOP for business domain modeling exposes you to outsize risk of being forced to start doing it wrong, regardless of your intentions or skill level. (Incidentally, this phenomenon is just a specific example of premature abstraction being the root of all evil.)<p>And then, second, dynamic dispatch makes it harder for newcomers to figure out the business logic by reading the code. It creates a bit of a catch-22 situation where figuring out which methods will run when - an essential part of understanding how the code behaves - almost requires already knowing how the code works. Not actually, of course, but reading unfamiliar code that uses dynamic dispatch is and advanced skill, and nobody enjoys it. Also, this problem can easily be mitigated with documentation. But that solution is unsatisfying. Just using procedural code and banging out whatever boilerplate you need to get things working using static dispatch creates less additional work than what it takes to write and maintain satisfying documentation for an object-oriented codebase, and comes with the added advantage that it <i>cannot</i> fall out of sync with what the code actually does.<p>Incidentally, Donald Knuth made a similar observation in his interview in the book <i>Coders at Work</i>. He expressed dissatisfaction with OOP on the grounds that, for the purposes of maintainability, he found code reuse to be less valuable than modifiability and readability.</div><br/><div id="40996558" class="c"><input type="checkbox" id="c-40996558" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996367">parent</a><span>|</span><a href="#40997023">next</a><span>|</span><label class="collapse" for="c-40996558">[-]</label><label class="expand" for="c-40996558">[10 more]</label></div><br/><div class="children"><div class="content">This is a strong argument against inheritance, but that isn&#x27;t everything about OOP. Just one well supported advanced abstraction (That I would also argue should be rarely used.)<p>I would argue that just having strong type system and bundling methods with data gets you the vast majority of the usefulness of OOP. Liskov, Open&#x2F;Closed, Message Passing, and other theoretical abstractions be damned.<p>EDIT - Where are the good places to use inheritance?<p>There are only a few I can think.<p>One is when you are trying to create a system that inverts dependencies by allowing a plugin system or follows some sort of nuanced workflow that others might want to &quot;hook into&quot;. But that isn&#x27;t the only way to do that, maybe other ways would be better like passing in functors.<p>Another situation I have seen recently is when creating a kind of data or messages that differ only by type and maybe a few small pieces of behavior and they are all known up front.</div><br/><div id="41001461" class="c"><input type="checkbox" id="c-41001461" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996558">parent</a><span>|</span><a href="#40996944">next</a><span>|</span><label class="collapse" for="c-41001461">[-]</label><label class="expand" for="c-41001461">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would argue that just having strong type system and bundling methods with data gets you the vast majority of the usefulness of OOP.<p>Yes, a module system brings almost all of the advantages of OOP. The one remaining is structure abstraction (things like interfaces on Java derived languages, or type classes on Haskell derived ones).<p>But well, none of those are even typically associated with OOP. The OOP languages just have those features, like they have variables too.</div><br/></div></div><div id="40996944" class="c"><input type="checkbox" id="c-40996944" checked=""/><div class="controls bullet"><span class="by">moth-fuzz</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996558">parent</a><span>|</span><a href="#41001461">prev</a><span>|</span><a href="#40997639">next</a><span>|</span><label class="collapse" for="c-40996944">[-]</label><label class="expand" for="c-40996944">[2 more]</label></div><br/><div class="children"><div class="content">&gt; One is when you are trying to create a system that inverts dependencies by allowing a plugin system or follows some sort of nuanced workflow that others might want to &quot;hook into&quot;.<p>I’m fairly certain that’s <i>the</i> use case of inheritance - at least in the Simula tradition. Classes as a means of lifetime management, moving parts that have well defined steps of operation (methods), and interchangeable parts (subtypes) which you can more or less slot into the larger system (polymorphism).<p>It’s easier to think about classes not as nouns, but as verbs over time (or rather, bounded by time): at a specific moment in the assembly line, call this particular method, at another moment, call that other method…<p>Object oriented programming in the Simula tradition I would even go as far as to say is just best practices in structured&#x2F;procedural programming taken to their logical extremes.</div><br/><div id="40998830" class="c"><input type="checkbox" id="c-40998830" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996944">parent</a><span>|</span><a href="#40997639">next</a><span>|</span><label class="collapse" for="c-40998830">[-]</label><label class="expand" for="c-40998830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Classes as a means of lifetime management<p>Wrt plugin systems: at least as the class level, are classes really a means of lifetime management in practice?<p>IIRC, audio plugin APIs follow the shell command pattern of memory management for loading new classes-- the user dynamically loads a library into a running instance of an application, and there it stays until the application exits.<p>And even if plugin systems as implemented are actually unloading classes, the user is almost always just restarting the app to make sure it took. :)<p>Edit: clarification</div><br/></div></div></div></div><div id="40997639" class="c"><input type="checkbox" id="c-40997639" checked=""/><div class="controls bullet"><span class="by">recursivedoubts</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996558">parent</a><span>|</span><a href="#40996944">prev</a><span>|</span><a href="#40997023">next</a><span>|</span><label class="collapse" for="c-40997639">[-]</label><label class="expand" for="c-40997639">[6 more]</label></div><br/><div class="children"><div class="content">Agree 100%: static typing (for code completion) + method&#x2F;data bundling is the major win in OO, and it rarely gets talked about for whatever reason.<p>It&#x27;s unfortunate that inheritance became such a major focus of practical OO languages.  Would love to see a composition-first OO language.  Might have its own problems, but would at least be interesting.</div><br/><div id="41002795" class="c"><input type="checkbox" id="c-41002795" checked=""/><div class="controls bullet"><span class="by">cjblomqvist</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997639">parent</a><span>|</span><a href="#40997805">next</a><span>|</span><label class="collapse" for="c-41002795">[-]</label><label class="expand" for="c-41002795">[1 more]</label></div><br/><div class="children"><div class="content">Typescript and it&#x27;s structural typing my be what you&#x27;re looking for.</div><br/></div></div><div id="40997805" class="c"><input type="checkbox" id="c-40997805" checked=""/><div class="controls bullet"><span class="by">1propionyl</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997639">parent</a><span>|</span><a href="#41002795">prev</a><span>|</span><a href="#40998041">next</a><span>|</span><label class="collapse" for="c-40997805">[-]</label><label class="expand" for="c-40997805">[3 more]</label></div><br/><div class="children"><div class="content">Go, Rust, Zig, etc all support static typing and method&#x2F;data bundling without any explicit language support for implementation inheritance (interface inheritance in general and especially when structural rather than nominal is not nearly as much of an issue and doesn&#x27;t create strict tree hierarchies).<p>Rust has support for variance and subtupint so perhaps it&#x27;s not as pure of an example, but it&#x27;s pretty heavily restricted.<p>Zig&#x27;s support for method&#x2F;data bundling being used for &quot;objects&quot; isn&#x27;t even first class so I wouldn&#x27;t call it OO (object-<i>oriented</i>) so much as object-orientation-capable with less fuss than if one wanted to build their own objects system in C.</div><br/><div id="41002994" class="c"><input type="checkbox" id="c-41002994" checked=""/><div class="controls bullet"><span class="by">mjevans</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997805">parent</a><span>|</span><a href="#40998118">next</a><span>|</span><label class="collapse" for="c-41002994">[-]</label><label class="expand" for="c-41002994">[1 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s first class support for typed return tuples and Interfaces is a lovely replacement for inheritance (E.G. an Interface of type blah supports this signature). They function as an API contract, if a given class implements the requirements of the Interface, it can be cast to and used as that anywhere which accepts that interface.</div><br/></div></div><div id="40998118" class="c"><input type="checkbox" id="c-40998118" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997805">parent</a><span>|</span><a href="#41002994">prev</a><span>|</span><a href="#40998041">next</a><span>|</span><label class="collapse" for="c-40998118">[-]</label><label class="expand" for="c-40998118">[1 more]</label></div><br/><div class="children"><div class="content">Even in C++ the last time I thought I might need inheritance I made a simple class&#x2F;struct with a few members that were `std::function` instances. Instead of needing inheritance this worked and I managed to keep type safety checks on all function return and parameter types. Once upon a time this would have been weird function pointers and `void*` with dangerous casts. Last month when I did it, there were just lambdas passed to typesafe constructors.</div><br/></div></div></div></div><div id="40998041" class="c"><input type="checkbox" id="c-40998041" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997639">parent</a><span>|</span><a href="#40997805">prev</a><span>|</span><a href="#40997023">next</a><span>|</span><label class="collapse" for="c-40998041">[-]</label><label class="expand" for="c-40998041">[1 more]</label></div><br/><div class="children"><div class="content">Whether you&#x27;d call &quot;composition-first&quot; is probably asking for a big argument about what &quot;composition first&quot; really means, but Go is certainly a language that syntactically privileges a particular type of composition over inheritance. It doesn&#x27;t even have syntax for inheritance, and frankly even manually implementing it is rather a pain (best I&#x27;ve ever done requires you to pass the &quot;object&quot; as a separate parameter to every method call... and, yes, I said that correctly, to every <i>method</i> call).<p>I&#x27;m not ready to try to stake a position on the top of some &quot;composition first&quot; hill because the syntactic composition it supports is not something I use all the time. It&#x27;s an occasional convenience more than a fundamental primitive in the language, the way inheritance is in inheritance-based languages. Most of the composition is just done through methods that happen to use in composed-in values, but it is generally not particularly supported by syntax.</div><br/></div></div></div></div></div></div><div id="40997023" class="c"><input type="checkbox" id="c-40997023" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996367">parent</a><span>|</span><a href="#40996558">prev</a><span>|</span><a href="#41001093">next</a><span>|</span><label class="collapse" for="c-40997023">[-]</label><label class="expand" for="c-40997023">[1 more]</label></div><br/><div class="children"><div class="content">&gt; dynamic dispatch makes it harder for newcomers to figure out the business logic by reading the code<p>This is definitely a potential problem, but I note that you can also get into this mess without OO in any language that lets you put a (reference to) function in a variable. Or, god help you, operator overloading.</div><br/></div></div><div id="41001093" class="c"><input type="checkbox" id="c-41001093" checked=""/><div class="controls bullet"><span class="by">fenomas</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996367">parent</a><span>|</span><a href="#40997023">prev</a><span>|</span><a href="#41000530">next</a><span>|</span><label class="collapse" for="c-41001093">[-]</label><label class="expand" for="c-41001093">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a big thinker on such things, but my general rule is that subtyping is okay only for implementation details.<p>I.e. it&#x27;s okay for ConsoleLogger to be a subtype of Logger, but PaidUser probably shouldn&#x27;t be a subtype of User.</div><br/></div></div><div id="41000530" class="c"><input type="checkbox" id="c-41000530" checked=""/><div class="controls bullet"><span class="by">beryilma</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996367">parent</a><span>|</span><a href="#41001093">prev</a><span>|</span><a href="#40996756">next</a><span>|</span><label class="collapse" for="c-41000530">[-]</label><label class="expand" for="c-41000530">[3 more]</label></div><br/><div class="children"><div class="content">But, in a way, OO modeling and design was invented to solve the mess that &quot;banging out&quot; procedural code created in the first place.<p>You have to model your business domain in software one way or another anyway. Why should it be bad to try to be more methodical about it using OO methods? We do it with relational databases all the time where tables are pretty similar to objects.</div><br/><div id="41001986" class="c"><input type="checkbox" id="c-41001986" checked=""/><div class="controls bullet"><span class="by">nanomonkey</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#41000530">parent</a><span>|</span><a href="#41002042">next</a><span>|</span><label class="collapse" for="c-41001986">[-]</label><label class="expand" for="c-41001986">[1 more]</label></div><br/><div class="children"><div class="content">OO and Relational databases really don&#x27;t mix well, so much that there are wikipedia articles on the subject [0].<p>ORMs create some of the worst SQL table layouts that I&#x27;ve ever seen, not to mention they generally cause tons of N+1 query problems.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object%E2%80%93relational_impedance_mismatch" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object%E2%80%93relational_impe...</a></div><br/></div></div><div id="41002042" class="c"><input type="checkbox" id="c-41002042" checked=""/><div class="controls bullet"><span class="by">arendjr</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#41000530">parent</a><span>|</span><a href="#41001986">prev</a><span>|</span><a href="#40996756">next</a><span>|</span><label class="collapse" for="c-41002042">[-]</label><label class="expand" for="c-41002042">[1 more]</label></div><br/><div class="children"><div class="content">I actually have nothing against objects and methods, but that’s a very limited subset of OO. I prefer to use algebraic data types for domain modeling, and giving them methods is totally fine too. But I do prefer them to be immutable in most cases, which is also quite counterintuitive from an OO perspective.</div><br/></div></div></div></div><div id="40996756" class="c"><input type="checkbox" id="c-40996756" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996367">parent</a><span>|</span><a href="#41000530">prev</a><span>|</span><a href="#41002812">next</a><span>|</span><label class="collapse" for="c-40996756">[-]</label><label class="expand" for="c-40996756">[6 more]</label></div><br/><div class="children"><div class="content">The real world definitely isn&#x27;t OO all the time.<p>Maybe more functional and event based.<p>The oscillation between the two as what&#x27;s in favour is also humorous.<p>The right thing for the right need for the present and near future, especially the newer the codebase, and the greater the need to learn, is often the way to consider pursuit.</div><br/><div id="40997311" class="c"><input type="checkbox" id="c-40997311" checked=""/><div class="controls bullet"><span class="by">temporarely</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40996756">parent</a><span>|</span><a href="#41002812">next</a><span>|</span><label class="collapse" for="c-40997311">[-]</label><label class="expand" for="c-40997311">[5 more]</label></div><br/><div class="children"><div class="content">&gt; The real world definitely isn&#x27;t<p>Ironically, (ime&#x2F;o!h;) it turns out this the &quot;root of evil&quot; plaguing <i>abstraction</i>: thinking that software architecture must map to &quot;the real world&quot;.</div><br/><div id="40997553" class="c"><input type="checkbox" id="c-40997553" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997311">parent</a><span>|</span><a href="#40997860">next</a><span>|</span><label class="collapse" for="c-40997553">[-]</label><label class="expand" for="c-40997553">[3 more]</label></div><br/><div class="children"><div class="content">I think you have it backwards.<p>Software exists in the real world, and is used to solve real world problem. In building software we inevitably invent or use abstractions to represent or effect real world things. Abstractions that make it easier to do this are good, abstractions that make it harder to do this are just getting in the way.</div><br/><div id="40997810" class="c"><input type="checkbox" id="c-40997810" checked=""/><div class="controls bullet"><span class="by">temporarely</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997553">parent</a><span>|</span><a href="#40997860">next</a><span>|</span><label class="collapse" for="c-40997810">[-]</label><label class="expand" for="c-40997810">[2 more]</label></div><br/><div class="children"><div class="content">1 - (Application) System exist in the real world, not software. Software exists in machines.<p>2 - Computing is used to solve real world problem.<p>3 - &quot;In building software we inevitably invent or use abstractions to represent or effect real world things.&quot; Here is the problem where we part company.<p>4 - Abstractions that inform computing systems are indeed useful.<p>[edit+ps]<p>self disclosure: I&#x27;ve reached &#x27;architectural orbit&#x27; numerous times in my career. 30 years later, I am sharing a subtle point. Effective software models <i>cutout attributes</i> of real world elements of the problem domain. All attempt to &quot;model the world&quot; end in tears.</div><br/><div id="40999887" class="c"><input type="checkbox" id="c-40999887" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997810">parent</a><span>|</span><a href="#40997860">next</a><span>|</span><label class="collapse" for="c-40999887">[-]</label><label class="expand" for="c-40999887">[1 more]</label></div><br/><div class="children"><div class="content">This reads like nonsense to me, so I can only assume the disagreement is semantic.</div><br/></div></div></div></div></div></div><div id="40997860" class="c"><input type="checkbox" id="c-40997860" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997311">parent</a><span>|</span><a href="#40997553">prev</a><span>|</span><a href="#41002812">next</a><span>|</span><label class="collapse" for="c-40997860">[-]</label><label class="expand" for="c-40997860">[1 more]</label></div><br/><div class="children"><div class="content">For me, software and tech that is for someone, exists to work for people, who are end users.<p>End users and customers don&#x27;t exist to serve at the leisure and pleasure of software and it&#x27;s creators.<p>Making people work harder than they need to operate software is selfish.<p>DevOps and DevEx is important, but if no one uses it with those being great, the Customer and their experience are often lost and never gained.<p>Learning to model something flexible enough for absorbing and quickly implementing the early customer feedback that is relevant is critical to boring things like retention.<p>Helping customers earn enough to eat every month, helps the tool makers earn enough to eat every month.</div><br/></div></div></div></div></div></div></div></div><div id="41002812" class="c"><input type="checkbox" id="c-41002812" checked=""/><div class="controls bullet"><span class="by">mejutoco</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#40996367">prev</a><span>|</span><a href="#41000639">next</a><span>|</span><label class="collapse" for="c-41002812">[-]</label><label class="expand" for="c-41002812">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but the idea of gathering a data structure and the operations on that data structure in a single place, with data hiding, is a good one, particularly for domain modeling.<p>One can do this in a module without OOP.<p>The idea of mixing data and behaviour&#x2F;state (OOP) instead of keeping data structure and functions transforming those (functional) is IMO the biggest mistake of OOP, together with using inheritance.<p>I believe making part of the program data instead of code (and thus, empty of bugs) is such a big advantage. Already lisp was talking about it. Mixing data with behaviour, without a clear delimitation creates a tight-coupled implementation full of implicit assumptions. Outside the class things are clean, but inside they ossify, and grow in complexity. Pure functions with data in data out are such a big improvement in clarity when possible.</div><br/></div></div><div id="41000639" class="c"><input type="checkbox" id="c-41000639" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#41002812">prev</a><span>|</span><a href="#40997507">next</a><span>|</span><label class="collapse" for="c-41000639">[-]</label><label class="expand" for="c-41000639">[1 more]</label></div><br/><div class="children"><div class="content">&gt; object oriented code for domain modeling<p>I&#x27;m not sure about that.<p>If we&#x27;re talking about IT (information processing in general), then the domain model is just data representing facts and should probably be treated as that, and not some metaphorical simulation of the world.<p>I&#x27;ve come up with a pretty useful test for when to apply OO:<p>When you need to model a _computational unit_[0] in terms of _operational semantics_, then use OO.<p>[0] Decidedly _not_ a simulation of a metaphor for the &quot;real world&quot;.<p>---<p>Examples:<p>A resizable buffer: You want operations like adding, removing, preemptively resizing etc. on a buffer. It&#x27;s useless to think of the internal bookkeeping of a buffer that is represented in its data structure when you use it.<p>A database object: It wraps a driver, a connection pool etc. From the outside you want to configure it at the start, then you want to interact with it via operations.<p>A HTTP server: You send messages to it via HTTP methods, you don&#x27;t care about it&#x27;s internal state, but only about your current representation of it (HATEOAS) and what you can do with it.<p>A memory allocator: The name gives away that you can _do_ things with it. You first choose the allocator that fits your needs, but then you _operate_ on it via alloc&#x2F;free etc.<p>---<p>Some of us wince when we hear &quot;OO&quot;, because it has been an overused paradigm. Some advocates of OO have been telling us that it is somehow total (similar to FP advocates) and people have been pushing back on this for a while now.<p>When applied to information processing especially, it becomes ridiculous, complex and distracting. I call this &quot;Kindergarten OO&quot;: You to write code as if you explain the problem to a child via metaphors.<p>Computational objects however arise naturally and are very obvious. I don&#x27;t care if those are encoded as classes, with closures or if we syntactically pretend as if they aren&#x27;t objects. They are still objects.</div><br/></div></div><div id="40997507" class="c"><input type="checkbox" id="c-40997507" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#41000639">prev</a><span>|</span><a href="#40996499">next</a><span>|</span><label class="collapse" for="c-40997507">[-]</label><label class="expand" for="c-40997507">[8 more]</label></div><br/><div class="children"><div class="content">If you think OOP is particularly well-suited to domain modelling, you should try the FP approach to domain modelling.<p>You will never be able to unsee the complexity inherent to OOP.</div><br/><div id="41002432" class="c"><input type="checkbox" id="c-41002432" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997507">parent</a><span>|</span><a href="#40998036">next</a><span>|</span><label class="collapse" for="c-41002432">[-]</label><label class="expand" for="c-41002432">[1 more]</label></div><br/><div class="children"><div class="content">You can try the FP approach today in most languages that are not even FP:<p>* Rust
* Kotlin
* Dart
* Java<p>Yep, even Java. Check this out: <a href="https:&#x2F;&#x2F;blog.jdriven.com&#x2F;2021&#x2F;10&#x2F;sealed-classes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.jdriven.com&#x2F;2021&#x2F;10&#x2F;sealed-classes&#x2F;</a></div><br/></div></div><div id="40998036" class="c"><input type="checkbox" id="c-40998036" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40997507">parent</a><span>|</span><a href="#41002432">prev</a><span>|</span><a href="#40996499">next</a><span>|</span><label class="collapse" for="c-40998036">[-]</label><label class="expand" for="c-40998036">[6 more]</label></div><br/><div class="children"><div class="content">Do you happen to have a link to an example or explanation?</div><br/><div id="40998432" class="c"><input type="checkbox" id="c-40998432" checked=""/><div class="controls bullet"><span class="by">arendjr</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998036">parent</a><span>|</span><a href="#41001938">next</a><span>|</span><label class="collapse" for="c-40998432">[-]</label><label class="expand" for="c-40998432">[3 more]</label></div><br/><div class="children"><div class="content">The keyword to search for is algebraic data types, which are common in functional languages, but for instance Rust also has them.<p>Here is an example comparing C# with F#, where the latter also algebraic data types: <a href="https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2016&#x2F;11&#x2F;28&#x2F;easy-domain-modelling-with-types&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2016&#x2F;11&#x2F;28&#x2F;easy-domain-modelling-with-...</a></div><br/><div id="40998628" class="c"><input type="checkbox" id="c-40998628" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998432">parent</a><span>|</span><a href="#41001938">next</a><span>|</span><label class="collapse" for="c-40998628">[-]</label><label class="expand" for="c-40998628">[2 more]</label></div><br/><div class="children"><div class="content">The syntax has improved quite substantially since 2016 for pattern matching at C#&#x27;s end, and it&#x27;s very easy to model ADTs with records (and the experience of using them even before that was decent with methods accepting lambdas).<p>Today, you write it in a similar way you would write a match in Rust.</div><br/><div id="41001776" class="c"><input type="checkbox" id="c-41001776" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998628">parent</a><span>|</span><a href="#41001938">next</a><span>|</span><label class="collapse" for="c-41001776">[-]</label><label class="expand" for="c-41001776">[1 more]</label></div><br/><div class="children"><div class="content">How do you represent sum types in C# today? Can enum members hold records as data, or do you do it differently?</div><br/></div></div></div></div></div></div><div id="41001938" class="c"><input type="checkbox" id="c-41001938" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998036">parent</a><span>|</span><a href="#40998432">prev</a><span>|</span><a href="#40999924">next</a><span>|</span><label class="collapse" for="c-41001938">[-]</label><label class="expand" for="c-41001938">[1 more]</label></div><br/><div class="children"><div class="content">Domain Modeling Made Functional [0] by Scott Wlaschin<p>[0] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2JB1_e5wZmU" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=2JB1_e5wZmU</a></div><br/></div></div><div id="40999924" class="c"><input type="checkbox" id="c-40999924" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998036">parent</a><span>|</span><a href="#41001938">prev</a><span>|</span><a href="#40996499">next</a><span>|</span><label class="collapse" for="c-40999924">[-]</label><label class="expand" for="c-40999924">[1 more]</label></div><br/><div class="children"><div class="content">The other commenter is <i>not technically wrong</i> to point at “algebraic data types”, but I don’t think that answer is helpful at all. It’s like saying the answer to data modelling is tuples.<p>I would instead recommend searching for “functional programming and domain driven design”.</div><br/></div></div></div></div></div></div><div id="40996499" class="c"><input type="checkbox" id="c-40996499" checked=""/><div class="controls bullet"><span class="by">sqeaky</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#40997507">prev</a><span>|</span><a href="#40998928">next</a><span>|</span><label class="collapse" for="c-40996499">[-]</label><label class="expand" for="c-40996499">[1 more]</label></div><br/><div class="children"><div class="content">I hadn&#x27;t thought about it explicitly like this before, and I think I agree. My more nebulous thought process was something like:<p>1. Try to solve the problem purely functionally.<p>2. If that failed because of data issue, model the data with objects and simple operations in an OOP style or well thought collection of arrays (game devs answer to OOP causing memory and caching problems, but the end result programming is similar to OOP thought process)<p>3. If that is can&#x27;t happen because some external restriction is impose use the minimal amount of procedural logic to solve the problem and round off as many sharp corners as is practical until it is unlikely any on the team gets cut.<p>Logically that is very close to inversion of thought process and ordering of operations to what you suggested. But I think we would recognize each others attempts to pick a design paradigm in code.<p>Now I want to think about this more. Is there some underlying principle here? Is this some kind of underlying principle? Where do domain specific languages fit in? Do other paradigms fit in? What are the bounds of this pattern, where does this process fail?</div><br/></div></div><div id="40998928" class="c"><input type="checkbox" id="c-40998928" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#40996499">prev</a><span>|</span><a href="#40996123">next</a><span>|</span><label class="collapse" for="c-40998928">[-]</label><label class="expand" for="c-40998928">[1 more]</label></div><br/><div class="children"><div class="content">&gt; These things might be good architectures, they will certainly benefit the developers that use them, but they are not, I repeat, not, a good substitute for the messiah riding his white ass into Jerusalem, or world peace. No, Microsoft, computers are not suddenly going to start reading our minds and doing what we want automatically just because everyone in the world has to have a Passport account.<p>Priceless.</div><br/></div></div><div id="40996123" class="c"><input type="checkbox" id="c-40996123" checked=""/><div class="controls bullet"><span class="by">kingofthehill98</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#40998928">prev</a><span>|</span><a href="#40998276">next</a><span>|</span><label class="collapse" for="c-40996123">[-]</label><label class="expand" for="c-40996123">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the strategy I always take when designing a system. Funny that I never thought about it before, I think most PHP developers will relate to that aswell.<p>- Procedural single point entrance into the system (network -&gt; public&#x2F;index.php, cli -&gt; bin&#x2F;console)<p>- OOP core for business logic, heavily borrowed (copied) from Java OOP model<p>- Functional code inside classes&#x2F;methods whenever possible (callables&#x2F;closures, array_map&#x2F;filter&#x2F;reduce&#x2F;walk, illuminate&#x2F;collections, etc.)</div><br/></div></div><div id="40998276" class="c"><input type="checkbox" id="c-40998276" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#40996123">prev</a><span>|</span><a href="#40996492">next</a><span>|</span><label class="collapse" for="c-40998276">[-]</label><label class="expand" for="c-40998276">[3 more]</label></div><br/><div class="children"><div class="content">When you write a procedure that has to maintain an internal state between calls, changing it into a class makes sense.  As for the name, you change the verb (write) into a noun (writer), and you now have a name for the class.<p>C# will silently create hidden closure classes for you when you use lambdas or yield.</div><br/><div id="40998403" class="c"><input type="checkbox" id="c-40998403" checked=""/><div class="controls bullet"><span class="by">arendjr</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998276">parent</a><span>|</span><a href="#40998747">next</a><span>|</span><label class="collapse" for="c-40998403">[-]</label><label class="expand" for="c-40998403">[1 more]</label></div><br/><div class="children"><div class="content">Just know that if you do this, you’re injecting statefulness in the center of wherever it was this procedure was being used. If your entire system already has statefulness everywhere, nobody will bet an eye. But if you want to have any chance at creating a functional core or island, it’s the opposite of what you should be doing.</div><br/></div></div><div id="40998747" class="c"><input type="checkbox" id="c-40998747" checked=""/><div class="controls bullet"><span class="by">alex-robbins</span><span>|</span><a href="#40995903">root</a><span>|</span><a href="#40998276">parent</a><span>|</span><a href="#40998403">prev</a><span>|</span><a href="#40996492">next</a><span>|</span><label class="collapse" for="c-40998747">[-]</label><label class="expand" for="c-40998747">[1 more]</label></div><br/><div class="children"><div class="content">When you write a procedure that has to maintain an internal state between calls, stopping what you&#x27;re doing and switching to functional programming makes sense.</div><br/></div></div></div></div><div id="41002839" class="c"><input type="checkbox" id="c-41002839" checked=""/><div class="controls bullet"><span class="by">NomDePlum</span><span>|</span><a href="#40995903">parent</a><span>|</span><a href="#40996492">prev</a><span>|</span><a href="#40995812">next</a><span>|</span><label class="collapse" for="c-41002839">[-]</label><label class="expand" for="c-41002839">[1 more]</label></div><br/><div class="children"><div class="content">James Gosling, who I&#x27;d consider the father of one of the most popular OO languages gave this advice:<p>&quot;You should avoid implementation inheritance whenever possible&quot;<p>My early days of Java where largely building unmaintainable inheritance trees into my code and then regretting it. This quote gave me comfort that it wasn&#x27;t really that good an idea.<p>Decent discussion on inheritance Vs composition also found here: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Composition_over_inheritance" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Composition_over_inheritance</a></div><br/></div></div></div></div><div id="40995812" class="c"><input type="checkbox" id="c-40995812" checked=""/><div class="controls bullet"><span class="by">sevensor</span><span>|</span><a href="#40995903">prev</a><span>|</span><a href="#41001591">next</a><span>|</span><label class="collapse" for="c-40995812">[-]</label><label class="expand" for="c-40995812">[14 more]</label></div><br/><div class="children"><div class="content">Although I agree with the recommendations, I cringe at the definition of abstraction.  In a sane world, abstraction doesn&#x27;t mean defining classes so much as it means identifying important unifying concepts.  DRYing your code by moving a method to a common base class isn&#x27;t abstraction in any important way, it&#x27;s just adding a level of indirection.  In fact, I&#x27;d argue that this example is the opposite of abstraction: it&#x27;s concretion.  Now every subclass relies implicitly on a particular implementation of that shared method.  Not that doing this is never useful, but it&#x27;s a mistake to call it abstraction when it&#x27;s nothing of the sort.  No wonder people complain that their abstractions leak.</div><br/><div id="40996017" class="c"><input type="checkbox" id="c-40996017" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40995812">parent</a><span>|</span><a href="#41002742">next</a><span>|</span><label class="collapse" for="c-40996017">[-]</label><label class="expand" for="c-40996017">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m currently dealing with a codebase that does this to a ridiculous extent. Like, literally, every change affects the entire project because everything is made of base-classes mixed in weird ways. Every concrete object inherits multiple base classes and no individual behavior. Imagine something like this:<p><pre><code>    class Book extends ShelfableItem, Pagable, Authored, Readable, BaseBook {}
</code></pre>
It&#x27;s absolutely insane.</div><br/><div id="40996286" class="c"><input type="checkbox" id="c-40996286" checked=""/><div class="controls bullet"><span class="by">patmorgan23</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996017">parent</a><span>|</span><a href="#41000887">next</a><span>|</span><label class="collapse" for="c-40996286">[-]</label><label class="expand" for="c-40996286">[5 more]</label></div><br/><div class="children"><div class="content">Oof. 
I know this is an example but all of those look like they would be better served as interfaces.</div><br/><div id="41000561" class="c"><input type="checkbox" id="c-41000561" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996286">parent</a><span>|</span><a href="#40998203">next</a><span>|</span><label class="collapse" for="c-41000561">[-]</label><label class="expand" for="c-41000561">[1 more]</label></div><br/><div class="children"><div class="content">Even if they were interfaces, it screams of the &quot;model your code after physical objects&quot; approach, where a system has 1 enormous &quot;Book&quot; type which represents all the things you can do with a physical book.<p>It seems unlikely that the same type should be &quot;Shelfable&quot; and &quot;Readable&quot; &#x2F; &quot;Pagable,&quot; because they describe distinct sets of operations.  When a book is on a shelf, you can&#x27;t page through it.  If you &quot;read&quot; a book on a shelf, you only see the title, author, and maybe some pull quotes.</div><br/></div></div><div id="40998203" class="c"><input type="checkbox" id="c-40998203" checked=""/><div class="controls bullet"><span class="by">dakiol</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996286">parent</a><span>|</span><a href="#41000561">prev</a><span>|</span><a href="#40996449">next</a><span>|</span><label class="collapse" for="c-40998203">[-]</label><label class="expand" for="c-40998203">[1 more]</label></div><br/><div class="children"><div class="content">It depends. Of course we don’t see the whole picture because it’s just an example by OP, but I also find weird that the de facto solution to abstract classes is: interfaces.   Sometimes, duplication is better than interfaces.</div><br/></div></div><div id="40996449" class="c"><input type="checkbox" id="c-40996449" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996286">parent</a><span>|</span><a href="#40998203">prev</a><span>|</span><a href="#41000887">next</a><span>|</span><label class="collapse" for="c-40996449">[-]</label><label class="expand" for="c-40996449">[2 more]</label></div><br/><div class="children"><div class="content">Yes. Did I mention there are interfaces too, with almost the same name, but it’s only used for the base classes. (Yes, there is only one implementation of all interfaces).</div><br/><div id="41002506" class="c"><input type="checkbox" id="c-41002506" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996449">parent</a><span>|</span><a href="#41000887">next</a><span>|</span><label class="collapse" for="c-41002506">[-]</label><label class="expand" for="c-41002506">[1 more]</label></div><br/><div class="children"><div class="content">Having lots of interfaces for common things is not a bad thing. See how Rust traits work... even basic structs you create will probably implement lots of basic traits (some of which can be done automatically, thankfully) like  `Display`, `Default`, several `From` or `Into` impls, `Clone`, `Copy` if your type is &quot;light&quot;, `AsRef`, `Send` and many more!<p>This makes code much more reusable as so many functions are written based on those basic traits alone.<p>Of course, finding the right basic types is really hard and your company seems to have done that badly, but in principle, having some basic types to model very common &quot;things&quot; is a necessary thing.</div><br/></div></div></div></div></div></div><div id="41000887" class="c"><input type="checkbox" id="c-41000887" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996017">parent</a><span>|</span><a href="#40996286">prev</a><span>|</span><a href="#40997473">next</a><span>|</span><label class="collapse" for="c-41000887">[-]</label><label class="expand" for="c-41000887">[1 more]</label></div><br/><div class="children"><div class="content">crying in rails concerns :*-(</div><br/></div></div><div id="40997473" class="c"><input type="checkbox" id="c-40997473" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996017">parent</a><span>|</span><a href="#41000887">prev</a><span>|</span><a href="#41002742">next</a><span>|</span><label class="collapse" for="c-40997473">[-]</label><label class="expand" for="c-40997473">[1 more]</label></div><br/><div class="children"><div class="content">Except usually the name of every type the Book inherits from or implements is so long it has to be put on a separate line.</div><br/></div></div></div></div><div id="41002742" class="c"><input type="checkbox" id="c-41002742" checked=""/><div class="controls bullet"><span class="by">bubblyworld</span><span>|</span><a href="#40995812">parent</a><span>|</span><a href="#40996017">prev</a><span>|</span><a href="#40996487">next</a><span>|</span><label class="collapse" for="c-41002742">[-]</label><label class="expand" for="c-41002742">[1 more]</label></div><br/><div class="children"><div class="content">I had to mull over this for a while, but I think I agree - abstractions at a conceptual level are much more powerful than object-level &quot;compression&quot;.<p>Concepts&#x2F;domain model&#x2F;whatever tend to change over time though (at least in the business world, maybe not so much tooling etc). I think that&#x27;s another source of leaky abstractions - things that conceptually made sense together at one point grow apart, and now you&#x27;re left with common code that is deeply integrated but doesn&#x27;t <i>quite</i> fit any more.</div><br/></div></div><div id="40996487" class="c"><input type="checkbox" id="c-40996487" checked=""/><div class="controls bullet"><span class="by">sevnin</span><span>|</span><a href="#40995812">parent</a><span>|</span><a href="#41002742">prev</a><span>|</span><a href="#40997994">next</a><span>|</span><label class="collapse" for="c-40996487">[-]</label><label class="expand" for="c-40996487">[3 more]</label></div><br/><div class="children"><div class="content">If by abstraction you mean identifying unifying concepts then I cant understand how you reasoned yourself into thinking that identifying  a common method and sharing it between multiple classes by the means of the super class is not abstraction. You have identified a commonality - the common code, common method. By your definition it&#x27;s abstraction.</div><br/><div id="41002910" class="c"><input type="checkbox" id="c-41002910" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996487">parent</a><span>|</span><a href="#41000816">next</a><span>|</span><label class="collapse" for="c-41002910">[-]</label><label class="expand" for="c-41002910">[1 more]</label></div><br/><div class="children"><div class="content">Example of abstraction vs indirection:<p>If I said &#x27;User&#x27;, we both know exactly what that means.  It&#x27;s so semantically simple that laypeople know what it means.  But our implementations could vary wildly.  Someone who&#x27;s just taken Java 101 will be thinking of a class with getName() and setName().  But someone who&#x27;s just taken SQL 101 will think of a User as an INT or UUID, where features are added by referencing that user&#x27;s id from different tables.  User is abstract because it&#x27;s understandable and not locked into any particular implementation.<p>I love Kafka.  But it&#x27;s a PITA to program against, at least in Java. I cannot code directly against it and always need to make my own wrapper classes to construct and poll it.  I&#x27;ll make ResumingKafkaReader and RewindingKafkaConsumerFactory, etc.  These are not abstract, because they are very specific about what and how they do things.  They are concrete behaviours wrapped with 1-2 levels of concrete indirection.<p>However, I might inject one of my Kafka indirections into a business logic class, interfaced as a Supplier&lt;User&gt;, which makes it abstract.  I can then unit test my class, safe in the knowledge that my class cannot know if a User came from Kafka or just a test stub.<p>So I push back on the thesis of the article, and double-down on doing things abstractly first and foremost.  This is closely related to the dependency inversion principle.  Write (and test) your business classes around Users and other abstract things.  Once you&#x27;ve done it wrong a few times and eventually gotten it right, then you can start writing the <i>indirections</i> (e.g. AbstractKafkaFactory) which the article rightly claims slow you down in the beginning.</div><br/></div></div><div id="41000816" class="c"><input type="checkbox" id="c-41000816" checked=""/><div class="controls bullet"><span class="by">chowells</span><span>|</span><a href="#40995812">root</a><span>|</span><a href="#40996487">parent</a><span>|</span><a href="#41002910">prev</a><span>|</span><a href="#40997994">next</a><span>|</span><label class="collapse" for="c-41000816">[-]</label><label class="expand" for="c-41000816">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not abstraction because it&#x27;s not presenting a simpler mental model. It&#x27;s just shoving some code located somewhere else into scope. It&#x27;s mere indirection.</div><br/></div></div></div></div><div id="40997994" class="c"><input type="checkbox" id="c-40997994" checked=""/><div class="controls bullet"><span class="by">mannykannot</span><span>|</span><a href="#40995812">parent</a><span>|</span><a href="#40996487">prev</a><span>|</span><a href="#41001591">next</a><span>|</span><label class="collapse" for="c-40997994">[-]</label><label class="expand" for="c-40997994">[1 more]</label></div><br/><div class="children"><div class="content">I came to say more-or-less the same thing. The author is making some valid points, but the moral is that premature <i>reification</i> of abstract concepts may be harmful, especially if there is something vague about them.</div><br/></div></div></div></div><div id="41001591" class="c"><input type="checkbox" id="c-41001591" checked=""/><div class="controls bullet"><span class="by">jaynate</span><span>|</span><a href="#40995812">prev</a><span>|</span><a href="#40995529">next</a><span>|</span><label class="collapse" for="c-41001591">[-]</label><label class="expand" for="c-41001591">[2 more]</label></div><br/><div class="children"><div class="content">Gall’s law: “A complex system that works is invariably found to have evolved from a simple system that worked. The inverse proposition also appears to be true: A complex system designed from scratch never works and cannot be made to work. You have to start over, beginning with a working simple system.”<p>Your theory of premature architecture reinforces Gall’s law.<p>This is from the book Systemantics: How systems work and especially how they fail (1977).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Systemantics" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Systemantics</a></div><br/><div id="41002058" class="c"><input type="checkbox" id="c-41002058" checked=""/><div class="controls bullet"><span class="by">arendjr</span><span>|</span><a href="#41001591">parent</a><span>|</span><a href="#40995529">next</a><span>|</span><label class="collapse" for="c-41002058">[-]</label><label class="expand" for="c-41002058">[1 more]</label></div><br/><div class="children"><div class="content">I like this one, thanks!</div><br/></div></div></div></div><div id="40995529" class="c"><input type="checkbox" id="c-40995529" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#41001591">prev</a><span>|</span><a href="#40996819">next</a><span>|</span><label class="collapse" for="c-40995529">[-]</label><label class="expand" for="c-40995529">[2 more]</label></div><br/><div class="children"><div class="content">Anyone who wants to do a deep dive into understanding effective abstractions, I <i>highly</i> recommend SICP. The full book[0] and lectures[1] are available online for free. You don&#x27;t have to know Scheme to follow along.<p>[0] <a href="https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;books_pres_0&#x2F;6515&#x2F;sicp.zip&#x2F;full-text&#x2F;book&#x2F;book.html" rel="nofollow">https:&#x2F;&#x2F;mitp-content-server.mit.edu&#x2F;books&#x2F;content&#x2F;sectbyfn&#x2F;b...</a><p>[1] <a href="https:&#x2F;&#x2F;ocw.mit.edu&#x2F;courses&#x2F;6-001-structure-and-interpretation-of-computer-programs-spring-2005&#x2F;video_galleries&#x2F;video-lectures&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ocw.mit.edu&#x2F;courses&#x2F;6-001-structure-and-interpretati...</a></div><br/><div id="40995596" class="c"><input type="checkbox" id="c-40995596" checked=""/><div class="controls bullet"><span class="by">morkalork</span><span>|</span><a href="#40995529">parent</a><span>|</span><a href="#40996819">next</a><span>|</span><label class="collapse" for="c-40995596">[-]</label><label class="expand" for="c-40995596">[1 more]</label></div><br/><div class="children"><div class="content">&gt;You don&#x27;t have to know Scheme to follow along.<p>Is a hilarious understatement. No, you don&#x27;t need to know it when you start the book but when you finish, you certainly will.</div><br/></div></div></div></div><div id="40996819" class="c"><input type="checkbox" id="c-40996819" checked=""/><div class="controls bullet"><span class="by">t43562</span><span>|</span><a href="#40995529">prev</a><span>|</span><a href="#41003487">next</a><span>|</span><label class="collapse" for="c-40996819">[-]</label><label class="expand" for="c-40996819">[4 more]</label></div><br/><div class="children"><div class="content">I like to start with a fairly unambitious bit of procedural code and gradually introduce abstractions when it starts to get complicated or repetitious.<p>Straight code becomes functions, occasionally a group of functions cry out to become a class.<p>In C++ this is a huge effort to do - change hurts more there. In python it&#x27;s much less painful and I end up with a program that is some imperfect composite of object oriented with functions.  Next week when I want it to do more I move it further down the road to structure.<p>I also like keeping side effects in their own ghettos and extracting everything else out of those if possible but I&#x27;m not a big functional programming person - it&#x27;s just about testing. Testing things with side effects is a pain.</div><br/><div id="40998347" class="c"><input type="checkbox" id="c-40998347" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40996819">parent</a><span>|</span><a href="#40998477">next</a><span>|</span><label class="collapse" for="c-40998347">[-]</label><label class="expand" for="c-40998347">[1 more]</label></div><br/><div class="children"><div class="content">I find that JS&#x2F;TS also lends itself towards this in terms of Node&#x2F;Deno&#x2F;Bun usage for apps.  You can have a file&#x2F;module that simply exports a function, a collection of functions, a class, etc.  It&#x27;s easy to keep it simple and then combine with a mix of procedural, functional and oo concepts as best fits the use case.</div><br/></div></div><div id="40998477" class="c"><input type="checkbox" id="c-40998477" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#40996819">parent</a><span>|</span><a href="#40998347">prev</a><span>|</span><a href="#41003487">next</a><span>|</span><label class="collapse" for="c-40998477">[-]</label><label class="expand" for="c-40998477">[2 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;m doing that a lot, too. I&#x27;m often astounded how hostile some languages are to later changes - e.g. java always feels resistant to change, while dotnet and especially python are more amenable. I.e. I totally transformed a program from function to oo in python without much sweat - would have been a total pain in dotnet or java</div><br/><div id="41002983" class="c"><input type="checkbox" id="c-41002983" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#40996819">root</a><span>|</span><a href="#40998477">parent</a><span>|</span><a href="#41003487">next</a><span>|</span><label class="collapse" for="c-41002983">[-]</label><label class="expand" for="c-41002983">[1 more]</label></div><br/><div class="children"><div class="content">Can you give examples for what you changed?</div><br/></div></div></div></div></div></div><div id="41003487" class="c"><input type="checkbox" id="c-41003487" checked=""/><div class="controls bullet"><span class="by">TurboHaskal</span><span>|</span><a href="#40996819">prev</a><span>|</span><a href="#41000376">next</a><span>|</span><label class="collapse" for="c-41003487">[-]</label><label class="expand" for="c-41003487">[1 more]</label></div><br/><div class="children"><div class="content">It seems to me the author just wants multiple dispatch.</div><br/></div></div><div id="41000376" class="c"><input type="checkbox" id="c-41000376" checked=""/><div class="controls bullet"><span class="by">aliasxneo</span><span>|</span><a href="#41003487">prev</a><span>|</span><a href="#40998126">next</a><span>|</span><label class="collapse" for="c-41000376">[-]</label><label class="expand" for="c-41000376">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not &quot;formally&quot; trained in software engineering and am primarily self-taught. This area, in particular, has been confusing to me over the years, especially after consuming so many contradictory blog posts.<p>I tried to model DDD in a recent Golang project and am mostly unhappy with the result. Perhaps in my eagerness, I fell into the trap of premature abstraction, but there&#x27;s not anything in particular that I can point to that might lead to that conclusion. It just feels like the overall code base is more challenging to read and has a ton of indirection. The feeling is made worse when I consider how much extra time I spent trying to be authentic in implementing it.<p>Now, I&#x27;m starting a new project, and I&#x27;m left in this uncertain state, not knowing what to do. Is there a fine balance? How is it achieved? I appreciate the author&#x27;s attempt at bringing clarity, but I honestly walked away feeling even more confident that I don&#x27;t understand how this all works out.</div><br/><div id="41001564" class="c"><input type="checkbox" id="c-41001564" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#41000376">parent</a><span>|</span><a href="#41001318">next</a><span>|</span><label class="collapse" for="c-41001564">[-]</label><label class="expand" for="c-41001564">[1 more]</label></div><br/><div class="children"><div class="content">The one point of DDD is that you make a dictionary of all of the domain terms and get everybody to accept them.<p>You can cut those 4 pages and throw the rest of the book away. But it is one of the best books on software engineering, and only gets better once you do that.</div><br/></div></div><div id="41001318" class="c"><input type="checkbox" id="c-41001318" checked=""/><div class="controls bullet"><span class="by">RaftPeople</span><span>|</span><a href="#41000376">parent</a><span>|</span><a href="#41001564">prev</a><span>|</span><a href="#40998126">next</a><span>|</span><label class="collapse" for="c-41001318">[-]</label><label class="expand" for="c-41001318">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I&#x27;m not &quot;formally&quot; trained in software engineering and am primarily self-taught</i><p>Welcome to the club and I wouldn&#x27;t be too worried about it (but definitely read and learn what others have figured out).<p>Software design and development is still an unsolved problem. The industry has not collectively found a foundational set of standard practices that apply across the board other than some of the most basic (e.g. organization is good).<p>You can tell that it&#x27;s not solved by the relentless flow of industry trends that become the new &quot;best practice&quot; until some years later when we figure out &quot;well, that approach has these pros and these cons and tends to fit with these types of problems, but definitely not a silver bullet, let&#x27;s try the next thing&quot;<p>Regarding your specific issue on your new project: just be pragmatic, get it working and learn from your decisions, it&#x27;s all just a collection of pros and cons and the analysis of pro vs con changes depending on the angle you look at it (e.g. short term vs long term, slow changing environment vs fast changing environment, cost to value ratio, etc., etc., etc.)</div><br/></div></div></div></div><div id="40998126" class="c"><input type="checkbox" id="c-40998126" checked=""/><div class="controls bullet"><span class="by">resters</span><span>|</span><a href="#41000376">prev</a><span>|</span><a href="#40995888">next</a><span>|</span><label class="collapse" for="c-40998126">[-]</label><label class="expand" for="c-40998126">[1 more]</label></div><br/><div class="children"><div class="content">A well chosen abstraction dramatically simplifies code and understanding, and a poorly chosen abstraction has the opposite effect.<p>When building a system some choices about abstractions can be made early, before the problem domain is fully understood. Sometimes they stand the test of time, other times they need to be reworked.  Being aware of this and mindful of the importance of good abstractions is key to good system design.</div><br/></div></div><div id="40995888" class="c"><input type="checkbox" id="c-40995888" checked=""/><div class="controls bullet"><span class="by">aswerty</span><span>|</span><a href="#40998126">prev</a><span>|</span><a href="#40996896">next</a><span>|</span><label class="collapse" for="c-40995888">[-]</label><label class="expand" for="c-40995888">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Post-Architecture is a method of defining architecture incrementally, rather than designing it upfront<p>For anyone else wondering what it means.<p>I&#x27;m going to be honest, almost all architecture I&#x27;ve seen out in the wild has followed a more incremental approach. But then again everywhere I&#x27;ve worked hasn&#x27;t separated the architecture&#x2F;coding roles.</div><br/><div id="40998362" class="c"><input type="checkbox" id="c-40998362" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40995888">parent</a><span>|</span><a href="#40996896">next</a><span>|</span><label class="collapse" for="c-40998362">[-]</label><label class="expand" for="c-40998362">[1 more]</label></div><br/><div class="children"><div class="content">If you work with C# or Java in a lot of places, such as Banking in particular, you&#x27;ll definitely see a lot of up-front architecture and excess abstractions early on.</div><br/></div></div></div></div><div id="40996896" class="c"><input type="checkbox" id="c-40996896" checked=""/><div class="controls bullet"><span class="by">jimmaswell</span><span>|</span><a href="#40995888">prev</a><span>|</span><a href="#40998154">next</a><span>|</span><label class="collapse" for="c-40996896">[-]</label><label class="expand" for="c-40996896">[1 more]</label></div><br/><div class="children"><div class="content">Fine blog post overall, but the author fell to premature abstraction themselves in declaring that little Foo class bad. It&#x27;s entirely too generalized for me to say anything negative about at all. Depending on the context, a tiny class like that could be completely sensible or utterly unnecessary.</div><br/></div></div><div id="40998154" class="c"><input type="checkbox" id="c-40998154" checked=""/><div class="controls bullet"><span class="by">feoren</span><span>|</span><a href="#40996896">prev</a><span>|</span><a href="#40997671">next</a><span>|</span><label class="collapse" for="c-40998154">[-]</label><label class="expand" for="c-40998154">[2 more]</label></div><br/><div class="children"><div class="content">I know HN doesn&#x27;t like quibbles about site design, but I&#x27;m literally having difficulty reading the article due to the font size being forced to be at least 1.3vw. Zooming out doesn&#x27;t decrease the font size! Downvote if this is boring, but (a) I&#x27;ve never seen a site that did that before, so it&#x27;s just notable from a &quot;Daily WTF&quot; kind of perspective, and (b) just in case the submitter is on HN: it&#x27;s actually preventing me from reading the content (without changing it in DevTools anyway).</div><br/><div id="41002162" class="c"><input type="checkbox" id="c-41002162" checked=""/><div class="controls bullet"><span class="by">arendjr</span><span>|</span><a href="#40998154">parent</a><span>|</span><a href="#40997671">next</a><span>|</span><label class="collapse" for="c-41002162">[-]</label><label class="expand" for="c-41002162">[1 more]</label></div><br/><div class="children"><div class="content">That’s useful feedback, thanks!</div><br/></div></div></div></div><div id="40997671" class="c"><input type="checkbox" id="c-40997671" checked=""/><div class="controls bullet"><span class="by">commandlinefan</span><span>|</span><a href="#40998154">prev</a><span>|</span><a href="#40999134">next</a><span>|</span><label class="collapse" for="c-40997671">[-]</label><label class="expand" for="c-40997671">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The real problem with the class Foo above is that it is utterly and entirely unnecessary<p>I see this sentiment a _lot_ in anti-OO rants, and the problem is that the ranter is missing the point of OO _entirely_.  Hard to fault them, since missing the point of OO entirely is pretty common but... if you&#x27;re creating classes as dumb-data wrappers and reflexively creating getters and setters for all of your private variables then yes what you&#x27;re doing _is_ utterly and entirely unnecessary, but you&#x27;re not doing object-oriented design at all.  The idea, all the way back to the creation of OO, was to expose actions and hide data.  If you&#x27;re adding a lot of syntax just to turn around and expose your data, you&#x27;re just doing procedural programming with a redundant syntax.</div><br/><div id="40998222" class="c"><input type="checkbox" id="c-40998222" checked=""/><div class="controls bullet"><span class="by">HdS84</span><span>|</span><a href="#40997671">parent</a><span>|</span><a href="#40999134">next</a><span>|</span><label class="collapse" for="c-40998222">[-]</label><label class="expand" for="c-40998222">[1 more]</label></div><br/><div class="children"><div class="content">As someone who dies a lot of python, TS, dotnet and java - I disagree. The problem of dotnet and java is that everything is a object. And for many cases, I don&#x27;t need that object at all, it can be a static class - but honestly, the python concept of a module fits a lot better. It&#x27;s a grouping of functions in a module, not a class holding functions.</div><br/></div></div></div></div><div id="40999134" class="c"><input type="checkbox" id="c-40999134" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#40997671">prev</a><span>|</span><a href="#40997444">next</a><span>|</span><label class="collapse" for="c-40999134">[-]</label><label class="expand" for="c-40999134">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Often, an abstraction doesn’t truly hide the data structures underneath, but it is bound by the limitations of the initial data structure(s) used to implement it. You want to refactor and use a new data structure? Chances are you need a new abstraction.<p>Data structures <i>are abstractions</i> :-)</div><br/></div></div><div id="40997444" class="c"><input type="checkbox" id="c-40997444" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40999134">prev</a><span>|</span><a href="#41000858">next</a><span>|</span><label class="collapse" for="c-40997444">[-]</label><label class="expand" for="c-40997444">[1 more]</label></div><br/><div class="children"><div class="content">The discussion of procedural code doesn&#x27;t make sense to me, because it seems to mix together some orthogonal concepts.<p>Procedural is not the opposite of object-oriented (nor is it particularly contrasting); idiomatic OOP is procedural to a large degree. Effective functional programming happens when you ditch the procedural approach in favour of a more declarative approach.</div><br/></div></div><div id="41000858" class="c"><input type="checkbox" id="c-41000858" checked=""/><div class="controls bullet"><span class="by">cryptica</span><span>|</span><a href="#40997444">prev</a><span>|</span><a href="#40996835">next</a><span>|</span><label class="collapse" for="c-41000858">[-]</label><label class="expand" for="c-41000858">[3 more]</label></div><br/><div class="children"><div class="content">Though I agree about the point about not creating objects&#x2F;instances where a pure function will get the job done, I disagree with the general stance against OOP. I think OOP is absolutely essential to simplicity. FP tends to lead to too many indirections with data traversing too many conceptual boundaries. FP (if used dogmatically) tends to encourage low cohesion. I want high cohesion and loose coupling. Some degree of co-location of state and logic is important since that affects cohesion and coupling of my modules.<p>The key to good OOP is to aim to only pass simple primitives or simple cloned objects as arguments to methods&#x2F;functions. &#x27;Spooky action at a distance&#x27; is really the only major issue with &#x27;OOP&#x27; and it can be easily solved by simple pass-by-value function signatures. So really, it&#x27;s not a fundamental issue with OOP itself. OOP doesn&#x27;t demand pass by reference. Alan Kay emphasized messaging; which is more leaning on &#x27;pass by value&#x27;; a message is information, not an object. We shouldn&#x27;t throw out the baby with the bathwater.<p>When I catch a taxi, do I have to provide the taxi driver with a jerrycan full of petrol and a steering wheel? No. I just give the taxi driver the message of where I want to go. The taxi driver is responsible for the state of his car. I give him a message, not objects.<p>If I have to give a taxi driver a jerrycan full of petrol, that&#x27;s the definition of a leaky abstraction... Possibly literally in this case.<p>That said, I generally agree with this article. That&#x27;s why I tend to write everything in 1 file at the beginning and wait for the file size to become a problem before breaking things up.<p>There are many different ways to slice things up and if you don&#x27;t have a complete understanding of your business domain and possible future requirement changes, there is no way you will come up with the best abstractions and it&#x27;s going to cost you dearly in the medium and long term.<p>A lot of developers throw their arms up and say stuff like &quot;We cannot anticipate future requirement changes&quot;... Well of course, not on day 1 of your new system!!! You shouldn&#x27;t be creating complex abstractions from the beginning when you haven&#x27;t fully absorbed the problem domain. You&#x27;re locking yourself into anti-patterns and lots of busy-work by forcing yourself to constantly re-imagine your flawed original vision. It&#x27;s easier to come up with a good vision for the future if you do it from scratch without conceptual baggage. Otherwise, you&#x27;re just seeding bias into the project. Once you have absorbed it, you will see, you CAN predict many possible requirement changes. It will impact your architecture positively.<p>Coming up with good abstractions is really difficult. It&#x27;s not about intelligence because even top engineers working in big tech struggle with it. Most of the working code we see is spaghetti.</div><br/><div id="41002588" class="c"><input type="checkbox" id="c-41002588" checked=""/><div class="controls bullet"><span class="by">arendjr</span><span>|</span><a href="#41000858">parent</a><span>|</span><a href="#40996835">next</a><span>|</span><label class="collapse" for="c-41002588">[-]</label><label class="expand" for="c-41002588">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! I would just like to clarify I’m actually not opposed to OOP at all, and at several points I tell people it’s fine to go in that direction for the problems where you need it. I do try to warn against it as a go-to solution before you’ve understood what are the  problems that actually need fixing, which it sounds like we’re pretty aligned on.<p>Indeed if you pass by value&#x2F;use immutability where feasible, you already avoid most of the issues I’m warning against, so it sounds like you found a sensible way to apply it while avoiding the pitfalls.<p>&gt; If I have to give a taxi driver a jerrycan full of petrol, that&#x27;s the definition of a leaky abstraction... Possibly literally in this case.<p>:D</div><br/><div id="41003208" class="c"><input type="checkbox" id="c-41003208" checked=""/><div class="controls bullet"><span class="by">cryptica</span><span>|</span><a href="#41000858">root</a><span>|</span><a href="#41002588">parent</a><span>|</span><a href="#40996835">next</a><span>|</span><label class="collapse" for="c-41003208">[-]</label><label class="expand" for="c-41003208">[1 more]</label></div><br/><div class="children"><div class="content">My view on FP is that one of its main benefits in terms of avoiding bugs is that it forces you to turn all your &#x27;movable state&#x27; into raw messages. The fact that it also abolishes &#x27;unmovable state&#x27; is just a quirk of it, not necessarily a benefit.<p>My main point in support of OOP is that OOP doesn&#x27;t prevent you from making all your &#x27;movable state&#x27; into raw messages too. Properly encapsulated instance state is not dangerous. What I like about OOP is that it offers some additional benefits in terms of high cohesion and loose coupling because co-locating logic with related state helps to write high cohesion, loosely coupled modules. It reduces the amount and complexity of state that needs to be transferred between modules. It allows my messages and function&#x2F;method signatures to be even leaner than FP allows.<p>If you want to catch a taxi to the airport, FP still requires that you bring a jerrycan of fuel and steering wheel to give to your taxi driver, the only restriction is that he cannot alter them (no mutations). The benefit of this is that you can fully trust that the integrity of your jerrycan and steering wheel has been maintained after the trip and you can then confidently re-use them for your airplane as well... Anyway, as elegant as that seems in theory, it&#x27;s not quite how the world works.</div><br/></div></div></div></div></div></div><div id="40996835" class="c"><input type="checkbox" id="c-40996835" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#41000858">prev</a><span>|</span><a href="#40998453">next</a><span>|</span><label class="collapse" for="c-40996835">[-]</label><label class="expand" for="c-40996835">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that mostly a question of composability?</div><br/></div></div><div id="40998453" class="c"><input type="checkbox" id="c-40998453" checked=""/><div class="controls bullet"><span class="by">MisterBastahrd</span><span>|</span><a href="#40996835">prev</a><span>|</span><a href="#40999386">next</a><span>|</span><label class="collapse" for="c-40998453">[-]</label><label class="expand" for="c-40998453">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no greater joy in life than jumping through an abstract object, an object interface, and a factory method only to find out that the factory only services one object.</div><br/></div></div><div id="40999386" class="c"><input type="checkbox" id="c-40999386" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#40998453">prev</a><span>|</span><a href="#40998171">next</a><span>|</span><label class="collapse" for="c-40999386">[-]</label><label class="expand" for="c-40999386">[1 more]</label></div><br/><div class="children"><div class="content">I would love a language that has this gradual evolutional abstracting as a core concern. That makes it easy. Where you can start from simplest imperative code and easily abstract it as the need for this arises.<p>For example a language that requires &quot;this.&quot; or &quot;self.&quot; prefix is not such language because you can&#x27;t easily turn a script or a function into a method of some object.</div><br/></div></div><div id="40998171" class="c"><input type="checkbox" id="c-40998171" checked=""/><div class="controls bullet"><span class="by">m3kw9</span><span>|</span><a href="#40999386">prev</a><span>|</span><label class="collapse" for="c-40998171">[-]</label><label class="expand" for="c-40998171">[1 more]</label></div><br/><div class="children"><div class="content">Here’s the scenario, hot shot intern comes in, calls a meeting to use generics so things can be done “easier”. He does a good job at presenting it and its value, the dumbass team lead oks it.  Fast forward 1 week everyone complains behind on how much pain it is to use</div><br/></div></div></div></div></div></div></div></body></html>