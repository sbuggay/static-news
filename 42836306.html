<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1738314065005" as="style"/><link rel="stylesheet" href="styles.css?v=1738314065005"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://muratbuffalo.blogspot.com/2024/01/scalable-oltp-in-cloud-whats-big-deal.html">Scalable OLTP in the Cloud: What&#x27;s the Big Deal?</a>Â <span class="domain">(<a href="http://muratbuffalo.blogspot.com">muratbuffalo.blogspot.com</a>)</span></div><div class="subtext"><span>SchwKatze</span> | <span>40 comments</span></div><br/><div><div id="42879850" class="c"><input type="checkbox" id="c-42879850" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42883170">next</a><span>|</span><label class="collapse" for="c-42879850">[-]</label><label class="expand" for="c-42879850">[18 more]</label></div><br/><div class="children"><div class="content">Fun read.  I am a bit curious on not mentioning OLAP, at all?<p>From my experience, the vast majority of complications in systems is people not realizing they are asking an OLAP question while wanting parts of OLTP semantics.<p>I&#x27;m also curious how much of this extra complication comes from having a central database that tries to be a source of truth for everything?  As an easy example, inventory systems that try and have a cloud source of truth have obvious problems when on the ground inventory issues crop up.  That is, a lot of the complication is between the distributed nature of the application and database, sure.  But, another large source is the non-distributed abstraction that a central database can represent not centralized activity.</div><br/><div id="42880803" class="c"><input type="checkbox" id="c-42880803" checked=""/><div class="controls bullet"><span class="by">mamcx</span><span>|</span><a href="#42879850">parent</a><span>|</span><a href="#42880140">next</a><span>|</span><label class="collapse" for="c-42880803">[-]</label><label class="expand" for="c-42880803">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m also curious how much of this extra complication comes from having a central database that tries to be a source of truth for everything?<p>You can reverse this as &#x27;how much extra complication comes from having many disparate databases, so now you push all ACID complications at the company level instead of the software(rdbms)&#x27;<p>It is a tricky problem!<p>Having a single source of truth is a tremendous simplification, especially for the <i>people</i>.<p>It should be ideal that the other databases are <i>pure</i> materializations on top of it, but then not matter what you have the need to <i>input</i> more stuff that is not part of the central one, and now you <i>have both problems</i>.</div><br/><div id="42880908" class="c"><input type="checkbox" id="c-42880908" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880803">parent</a><span>|</span><a href="#42881348">next</a><span>|</span><label class="collapse" for="c-42880908">[-]</label><label class="expand" for="c-42880908">[1 more]</label></div><br/><div class="children"><div class="content">A single source of truth for facts is fine.  A single source of truth that has to be reflected by external reality?  Less fine.  At that point, you pretty much have to have reconciliation processes to account for when they don&#x27;t match.<p>Oddly, I&#x27;d argue that the better way to view this is that the central database is the materialization of the data sources scattered around where work actually happens.  As such, you have to have constructs that account for provenance and timing introduced there that aren&#x27;t as necessary at the edges.</div><br/></div></div><div id="42881348" class="c"><input type="checkbox" id="c-42881348" checked=""/><div class="controls bullet"><span class="by">nyrikki</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880803">parent</a><span>|</span><a href="#42880908">prev</a><span>|</span><a href="#42880140">next</a><span>|</span><label class="collapse" for="c-42881348">[-]</label><label class="expand" for="c-42881348">[1 more]</label></div><br/><div class="children"><div class="content">Single source of truth is different in distributed systems, well the costs are different.<p>Using the language of &#x27;software architecture: thee hard parts&#x27; this forces your entire system into a single &#x27;architectural quanta&#x27;, basically it is a monolith.<p>There are situations where monoliths are acceptable or even the least worst option.<p>The &#x27;Fallacies of distributed computing&#x27; covers most of these.<p>It can work better if you use a hierarchical model, but OLTP is almost exclusively the relational model.<p>ACID transactions become pretty brittle, software becomes set in stone etc...<p>There are use cases, but the value proposition is typically much weaker</div><br/></div></div></div></div><div id="42880140" class="c"><input type="checkbox" id="c-42880140" checked=""/><div class="controls bullet"><span class="by">honestSysAdmin</span><span>|</span><a href="#42879850">parent</a><span>|</span><a href="#42880803">prev</a><span>|</span><a href="#42880661">next</a><span>|</span><label class="collapse" for="c-42880140">[-]</label><label class="expand" for="c-42880140">[8 more]</label></div><br/><div class="children"><div class="content">&gt; From my experience, the vast majority of complications in systems is people not realizing they are asking an OLAP question while wanting parts of OLTP semantics.<p>If you could elaborate on this further, I and others are probably very interested in reading more about it.</div><br/><div id="42880657" class="c"><input type="checkbox" id="c-42880657" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880140">parent</a><span>|</span><a href="#42880480">next</a><span>|</span><label class="collapse" for="c-42880657">[-]</label><label class="expand" for="c-42880657">[3 more]</label></div><br/><div class="children"><div class="content">As the sibling says, it is easy to think about in terms of what you are doing with the data.  Reporting on how many transactions of a type have happened over a duration?  Probably OLAP.  Really, if the word &quot;report&quot; shows up, at all, probably OLAP.  Executing parts of a workflow for an active transaction?  OLTP.<p>Briefly looking, I can&#x27;t find the books that I thought covered a lot of this in a good way.  Will keep looking, apologies.</div><br/><div id="42880668" class="c"><input type="checkbox" id="c-42880668" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880657">parent</a><span>|</span><a href="#42880480">next</a><span>|</span><label class="collapse" for="c-42880668">[-]</label><label class="expand" for="c-42880668">[2 more]</label></div><br/><div class="children"><div class="content">Designing Data Intensive Applications is a very good book in this space.</div><br/><div id="42885186" class="c"><input type="checkbox" id="c-42885186" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880668">parent</a><span>|</span><a href="#42880480">next</a><span>|</span><label class="collapse" for="c-42885186">[-]</label><label class="expand" for="c-42885186">[1 more]</label></div><br/><div class="children"><div class="content">Designing Data Intensive Applications by Martin Kleppmann is required reading if you&#x27;re in this space.<p>I can&#x27;t recommend it highly enough.<p>[1] <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Designing-Data-Intensive-Applications-Reliable-Maintainable&#x2F;dp&#x2F;1449373321" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Designing-Data-Intensive-Applications...</a></div><br/></div></div></div></div></div></div><div id="42880480" class="c"><input type="checkbox" id="c-42880480" checked=""/><div class="controls bullet"><span class="by">juancn</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880140">parent</a><span>|</span><a href="#42880657">prev</a><span>|</span><a href="#42880661">next</a><span>|</span><label class="collapse" for="c-42880480">[-]</label><label class="expand" for="c-42880480">[4 more]</label></div><br/><div class="children"><div class="content">The main data access difference between OLAP systems and OLTP systems is how many records on average do you need to access:<p>- OLAP: most queries need most records (aggregations span large swaths of data)<p>- OLTP: most queries access just a few records<p>Also, in OLAP, in many cases, you can live with a single-updater model without much trouble, where OLTP, the strength is to have many concurrent updaters (but mostly non-overlapping).</div><br/><div id="42882233" class="c"><input type="checkbox" id="c-42882233" checked=""/><div class="controls bullet"><span class="by">greggyb</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880480">parent</a><span>|</span><a href="#42882702">next</a><span>|</span><label class="collapse" for="c-42882233">[-]</label><label class="expand" for="c-42882233">[1 more]</label></div><br/><div class="children"><div class="content">- OLAP: read-mostly, table-scan heavy, many queries run ad-hoc by users<p>- OLTP: write-mostly, index-seek heavy, ~all queries pre-defined up front</div><br/></div></div><div id="42882702" class="c"><input type="checkbox" id="c-42882702" checked=""/><div class="controls bullet"><span class="by">yoda97</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880480">parent</a><span>|</span><a href="#42882233">prev</a><span>|</span><a href="#42881133">next</a><span>|</span><label class="collapse" for="c-42882702">[-]</label><label class="expand" for="c-42882702">[1 more]</label></div><br/><div class="children"><div class="content">So the first focuses on analytics and reporting, the second on transactions and performance.
They are not meant to replace each other, they serve different purposes. Some teams may need both.</div><br/></div></div><div id="42881133" class="c"><input type="checkbox" id="c-42881133" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880480">parent</a><span>|</span><a href="#42882702">prev</a><span>|</span><a href="#42880661">next</a><span>|</span><label class="collapse" for="c-42881133">[-]</label><label class="expand" for="c-42881133">[1 more]</label></div><br/><div class="children"><div class="content">OLAP - Most queries need an aggregate of records. Generally you do NOT need most records, but simply the records grouped by dimensions per interval (for almost all olap reporting). You do not change the data, you observe it. If you change it, you are not dealing with OLAP data.<p>OLTP - You are dealing with the ins and outs of people using stuff to do things. You buy something, you check out something, you some way perturb the state of things. This should not require large amount of row lookups in 99.9% of cases.</div><br/></div></div></div></div></div></div><div id="42880661" class="c"><input type="checkbox" id="c-42880661" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#42879850">parent</a><span>|</span><a href="#42880140">prev</a><span>|</span><a href="#42883170">next</a><span>|</span><label class="collapse" for="c-42880661">[-]</label><label class="expand" for="c-42880661">[6 more]</label></div><br/><div class="children"><div class="content">I agree that analytical queries cause a significant portion of the complication in transactional systems.<p>However, at global&#x2F;twitter scale, just basic CRUD operations become pretty hard for OLTP, so scalable OLTP in the cloud is a pretty big deal, especially when you get fun things like phantom read&#x2F;writes as writes may take time to get to distributed read replicas, so a user may send a tweet and then not see it on their profile for a while.</div><br/><div id="42880933" class="c"><input type="checkbox" id="c-42880933" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880661">parent</a><span>|</span><a href="#42883170">next</a><span>|</span><label class="collapse" for="c-42880933">[-]</label><label class="expand" for="c-42880933">[5 more]</label></div><br/><div class="children"><div class="content">I mean, sure?  I hesitate to take the global&#x2F;twitter scale debates seriously, unfortunately.  They are dominated by straw men arguments that you can get sub 50ms latency on every action for all viewers.  :(</div><br/><div id="42882867" class="c"><input type="checkbox" id="c-42882867" checked=""/><div class="controls bullet"><span class="by">tharkun__</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42880933">parent</a><span>|</span><a href="#42883170">next</a><span>|</span><label class="collapse" for="c-42882867">[-]</label><label class="expand" for="c-42882867">[4 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t and it shouldn&#x27;t matter and I don&#x27;t care if everyone sees my upvotes on Reddit right away &#x2F; at the same time as others or if I see theirs or when exactly my comments show up.<p>But global&#x2F;twitter&#x2F;reddit etc. scale does matter in that I don&#x27;t really remember a PHPBB or slashdot or HN swallowing my comments, ever. Even if you get an error you can always just go back in the browser and your input box is there with your comment.<p>But reddit has been effing atrocious over the last few months. You get &quot;Internal Server Error&quot; when trying to do any voting or commenting a <i>lot</i> and it won&#x27;t go away until you refresh the page like 17 times (until presumably you round robin get to some BE server that actually works. It&#x27;s also been swallowing comments, where about every third or fourth comment it accepts the comment instead of throwing an Internal Server Error at you (which would be preferable) and instead it &quot;accepts&quot; it but it will never show up. Ever. Only chance is to copy every comment before submitting, in case you have to re-submit it from scratch.</div><br/><div id="42884730" class="c"><input type="checkbox" id="c-42884730" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42882867">parent</a><span>|</span><a href="#42885079">next</a><span>|</span><label class="collapse" for="c-42884730">[-]</label><label class="expand" for="c-42884730">[1 more]</label></div><br/><div class="children"><div class="content">&gt; don&#x27;t really remember a PHPBB or slashdot or HN swallowing my comments, ever.<p>Really? I remember it happening a lot.<p>&gt; Even if you get an error you can always just go back in the browser and your input box is there with your comment.<p>That&#x27;s a relatively new feature and doesn&#x27;t always work. (Old, I can&#x27;t speak to new) Reddit&#x27;s &quot;push a button and it submits without moving off the page&quot; is much nicer.</div><br/></div></div><div id="42885079" class="c"><input type="checkbox" id="c-42885079" checked=""/><div class="controls bullet"><span class="by">zo1</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42882867">parent</a><span>|</span><a href="#42884730">prev</a><span>|</span><a href="#42882902">next</a><span>|</span><label class="collapse" for="c-42885079">[-]</label><label class="expand" for="c-42885079">[1 more]</label></div><br/><div class="children"><div class="content">You can tell a lot about Reddit and it&#x27;s early &quot;architecture&quot; from this video.<p><a href="https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;reddit-architecture-evolution&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;reddit-architecture-evol...</a><p>That and the Instagram architecture video are such eye-opening examples that I always send to juniors when they have doubts about their own abilities. In most cases, we&#x27;re astronomically no where near Reddit&#x2F;Twitter&#x2F;Instagram scale, and yet we avoid a lot of the common pitfalls we see presented in those videos. Side note, I&#x27;m shocked at the quality, but hey &quot;Time To Market!&quot;<p>The Instagram video: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hnpzNAPiC0E" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=hnpzNAPiC0E</a></div><br/></div></div><div id="42882902" class="c"><input type="checkbox" id="c-42882902" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#42879850">root</a><span>|</span><a href="#42882867">parent</a><span>|</span><a href="#42885079">prev</a><span>|</span><a href="#42883170">next</a><span>|</span><label class="collapse" for="c-42882902">[-]</label><label class="expand" for="c-42882902">[1 more]</label></div><br/><div class="children"><div class="content">Exactly on that first statement.<p>I think I agree across the board.  HN and Stack Overflow are both amusing examples of much simpler architectures that kind of get to the point, though?  Such that I&#x27;m not clear if we are on the same page, there.<p>(And I, sadly, have zero experience with Reddit.)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42883170" class="c"><input type="checkbox" id="c-42883170" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42879850">prev</a><span>|</span><a href="#42880440">next</a><span>|</span><label class="collapse" for="c-42883170">[-]</label><label class="expand" for="c-42883170">[4 more]</label></div><br/><div class="children"><div class="content">Surprising that neither this post nor the linked paper that it&#x27;s about talk about Spanner, and instead only look at Oracle&#x2F;SQL Server&#x2F;Postgres. From what I understand, Spanner really does scale up OLTP to global level, where those alternatives struggle beyond regional level.</div><br/><div id="42884364" class="c"><input type="checkbox" id="c-42884364" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42883170">parent</a><span>|</span><a href="#42883321">next</a><span>|</span><label class="collapse" for="c-42884364">[-]</label><label class="expand" for="c-42884364">[2 more]</label></div><br/><div class="children"><div class="content">I think this is really talking about an orthogonal sort of scaling to what you&#x27;re looking at. Yes, given sufficiently balanced traffic patterns, spanner can serve essentially arbitrary load. If I understand correctly, this article is proposing that most of the work of transaction processing can be done in a layer that&#x27;s not affinitized, and only do the bare minimum in the key order affinitized server that is responsible for enforcing consistent ordering. This way, single key ranges can handle significantly greater load than they otherwise could, and load from read only calls can be entirely offloaded.</div><br/><div id="42884826" class="c"><input type="checkbox" id="c-42884826" checked=""/><div class="controls bullet"><span class="by">danpalmer</span><span>|</span><a href="#42883170">root</a><span>|</span><a href="#42884364">parent</a><span>|</span><a href="#42883321">next</a><span>|</span><label class="collapse" for="c-42884826">[-]</label><label class="expand" for="c-42884826">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but I think that&#x27;s just a function of where you draw the database boundary. My naive (external to Google) understanding of Spanner is that it probably is drawn to include these sorts of things, and similarly FoundationDB&#x27;s internal architecture looks a bit like this setup.<p>I think perhaps the view of a database being a single server codebase like this is a bit naive. When you read about how Meta deploy MySQL for example, it&#x27;s a whole service ecosystem that provides different levels of caching, replication, etc, to create a database at a higher level of abstraction that provides the necessary properties. FoundationDB is similarly better viewed as a set of microservices. When you architect a database like that it is possible to achieve these things, but that doesn&#x27;t seem to be a new idea, that seems to be just how it has been done in the industry for a while now. The article isn&#x27;t entirely clear on whether they realise this or are proposing something new.</div><br/></div></div></div></div><div id="42883321" class="c"><input type="checkbox" id="c-42883321" checked=""/><div class="controls bullet"><span class="by">jburbank</span><span>|</span><a href="#42883170">parent</a><span>|</span><a href="#42884364">prev</a><span>|</span><a href="#42880440">next</a><span>|</span><label class="collapse" for="c-42883321">[-]</label><label class="expand" for="c-42883321">[1 more]</label></div><br/><div class="children"><div class="content">Spanner really can. It has its own quirks, but I&#x27;ve enjoyed working with it.</div><br/></div></div></div></div><div id="42880440" class="c"><input type="checkbox" id="c-42880440" checked=""/><div class="controls bullet"><span class="by">whartung</span><span>|</span><a href="#42883170">prev</a><span>|</span><a href="#42884541">next</a><span>|</span><label class="collapse" for="c-42880440">[-]</label><label class="expand" for="c-42880440">[11 more]</label></div><br/><div class="children"><div class="content">Maybe someone can answer how this is done.<p>Simply, the mad crushing dash to get the last bit of committed inventory.<p>Ticketmaster has 50,000 General Admission Taylor Swift tickets and 1M fans eager to hoover them up.<p>This is a crushing load on a shared resource.<p>I don&#x27;t know if there&#x27;s any reasonable outcome from this besides the data center not catching on fire.</div><br/><div id="42882313" class="c"><input type="checkbox" id="c-42882313" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#42880440">parent</a><span>|</span><a href="#42880455">next</a><span>|</span><label class="collapse" for="c-42882313">[-]</label><label class="expand" for="c-42882313">[1 more]</label></div><br/><div class="children"><div class="content">Add a rate limit in nginx so that a single client has bounded work on your backend (e.g. 1&#x2F;1-10s), and batch your requests into ~100&#x2F;transaction using an in-memory queue. 1 server has been able to deal with ~1M connections for many years. No fires needed.<p>On a business side, they drastically lower the request load and make scalping unprofitable by holding a Dutch auction.</div><br/></div></div><div id="42880455" class="c"><input type="checkbox" id="c-42880455" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#42880440">parent</a><span>|</span><a href="#42882313">prev</a><span>|</span><a href="#42883343">next</a><span>|</span><label class="collapse" for="c-42880455">[-]</label><label class="expand" for="c-42880455">[1 more]</label></div><br/><div class="children"><div class="content">You build systems designed for this workload, you don&#x27;t foolishy try to use the same patterns as a CRUD app.</div><br/></div></div><div id="42883343" class="c"><input type="checkbox" id="c-42883343" checked=""/><div class="controls bullet"><span class="by">bigmutant</span><span>|</span><a href="#42880440">parent</a><span>|</span><a href="#42880455">prev</a><span>|</span><a href="#42881509">next</a><span>|</span><label class="collapse" for="c-42883343">[-]</label><label class="expand" for="c-42883343">[5 more]</label></div><br/><div class="children"><div class="content">As others have said, this is a solved problem in a lot of companies. Basic answers are:
1. Queuing
2. Asynchronous APIs (don&#x27;t wait for the &#x27;real&#x27; response, just submit the transaction)
3. Call-backs to the Client<p>A good async setup can easily handle 100k+ TPS<p>If you want to go the synchronous route, it&#x27;s more complicated but amounts to partitioning and creating separate swim-lanes (copies of the system, both at the compute and data layers)</div><br/><div id="42883986" class="c"><input type="checkbox" id="c-42883986" checked=""/><div class="controls bullet"><span class="by">ndriscoll</span><span>|</span><a href="#42880440">root</a><span>|</span><a href="#42883343">parent</a><span>|</span><a href="#42884031">next</a><span>|</span><label class="collapse" for="c-42883986">[-]</label><label class="expand" for="c-42883986">[1 more]</label></div><br/><div class="children"><div class="content">Note that the client doesn&#x27;t need to know about async operations&#x2F;you don&#x27;t need an async api at the http layer. Put the queue in memory. Have your queue workers wait up to ~5 ms to build a batch, or run the transaction when a batch is big enough (at 100k RPS, you already have a batch of 100 every ms). You&#x27;re adding ~1-5 ms latency, so no reason not to respond synchronously to the client. Conceptually, the queue and workers are an implementation detail within the model. As far as the controller knows, the db query just took an extra ms (or under any real load, responded <i>more</i> quickly).</div><br/></div></div><div id="42884031" class="c"><input type="checkbox" id="c-42884031" checked=""/><div class="controls bullet"><span class="by">zapkyeskrill</span><span>|</span><a href="#42880440">root</a><span>|</span><a href="#42883343">parent</a><span>|</span><a href="#42883986">prev</a><span>|</span><a href="#42881509">next</a><span>|</span><label class="collapse" for="c-42884031">[-]</label><label class="expand" for="c-42884031">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but no matter how many async request you accept you still only have 50k items available. You also presumably take people&#x27;s money, having them input their personal and card information so not waiting for real response means what? Thank you for your money and the data, we&#x27;ll be in touch soon; pinky promise?</div><br/><div id="42884858" class="c"><input type="checkbox" id="c-42884858" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#42880440">root</a><span>|</span><a href="#42884031">parent</a><span>|</span><a href="#42884397">next</a><span>|</span><label class="collapse" for="c-42884858">[-]</label><label class="expand" for="c-42884858">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Thank you for your money and the data, we&#x27;ll be in touch soon; pinky promise?<p>That&#x27;s very much an option when it&#x27;s something this popular - the Olympics I went to did an even more extreme version of that (&quot;Thank you for putting in which events you wanted to see, your card may be charged up to x some time within the next month&quot;).<p>Or you can do it like plane seats: allocate 50k provisional tickets during the initial release (async but on a small timescale), and then if a provisional ticket isn&#x27;t paid for within e.g. 3 days you put it back on sale.<p>Ultimately if it takes you x minutes to confirm payment details then you have to either take payment details from some people who then don&#x27;t get tickets, or put some tickets back on sale when payment for them fails. But that&#x27;s not really a scaling issue - you have the same problem trying to sell 1 thing to 5 people on an online shop.</div><br/></div></div><div id="42884397" class="c"><input type="checkbox" id="c-42884397" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42880440">root</a><span>|</span><a href="#42884031">parent</a><span>|</span><a href="#42884858">prev</a><span>|</span><a href="#42881509">next</a><span>|</span><label class="collapse" for="c-42884397">[-]</label><label class="expand" for="c-42884397">[1 more]</label></div><br/><div class="children"><div class="content">You have 50,000 tickets to spread between one million people, you can partition people to tickets and only have 20 people per ticket. You won&#x27;t have strict ordering (e.g., someone who applied after may get a ticket where someone who applied earlier doesn&#x27;t), but we&#x27;d be talking about errors in the milliseconds.</div><br/></div></div></div></div></div></div><div id="42881509" class="c"><input type="checkbox" id="c-42881509" checked=""/><div class="controls bullet"><span class="by">dangets</span><span>|</span><a href="#42880440">parent</a><span>|</span><a href="#42883343">prev</a><span>|</span><a href="#42882780">next</a><span>|</span><label class="collapse" for="c-42881509">[-]</label><label class="expand" for="c-42881509">[1 more]</label></div><br/><div class="children"><div class="content">Sharding, pre-allocating leases of blocks of tickets across available resources, and eventual consistency.  You don&#x27;t need to keep the UX transactionally correct; you are able to say &quot;0 tickets remaining&quot; and then a minute or hour or day later say &quot;100 tickets remaining&quot;.  For something as popular as Taylor Swift, the fans will keep checking.</div><br/></div></div><div id="42882780" class="c"><input type="checkbox" id="c-42882780" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#42880440">parent</a><span>|</span><a href="#42881509">prev</a><span>|</span><a href="#42881515">next</a><span>|</span><label class="collapse" for="c-42882780">[-]</label><label class="expand" for="c-42882780">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ticketmaster has 50,000 General Admission Taylor Swift tickets and 1M fans eager to hoover them up.<p>I think something like trivial postgres setup can handle this thing..</div><br/></div></div><div id="42881515" class="c"><input type="checkbox" id="c-42881515" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42880440">parent</a><span>|</span><a href="#42882780">prev</a><span>|</span><a href="#42884541">next</a><span>|</span><label class="collapse" for="c-42881515">[-]</label><label class="expand" for="c-42881515">[1 more]</label></div><br/><div class="children"><div class="content">You, as a business entity, have to figure out how you want to allocate them. They aren&#x27;t going to get sold the normal way, so you get to choose whether you want to acknowledge that and design the system, or not design it and let nature take its course.<p>I&#x27;ve been to events that used a lottery. You order a ticket any time in, say, a month window. At the end, they tell you if you actually got a ticket. They have a process for linking orders together so you can choose to get a ticket if and only if your friends do.<p>I&#x27;ve also been to C3, which (in the second phase) knowingly used a first-come-first-serve three times, putting some kind of lightweight proxy in front of the actual shop that would only allow a certain number of people to access it at a time (this is important because you don&#x27;t know how many tickets each user is going to order). In the first phase, they use a system of &quot;self-replicating vouchers&quot; for various trusted C3-affiliated groups: one voucher is given to each group, allowing an order; at the end of each day until this portion of the ticket pool runs out, a new voucher is given to whoever made an order the previous day. I don&#x27;t know the reasons why self-replicating vouchers are designed exactly that way, but it means each group gets to run down their own self-determined priority order and gets punished for inefficiency.<p>The capitalist approach is, of course, raise the price to twenty thousand dollars or whatever level it takes for only 50,000 people to <i>want</i> to buy a ticket.</div><br/></div></div></div></div><div id="42884541" class="c"><input type="checkbox" id="c-42884541" checked=""/><div class="controls bullet"><span class="by">vsipuli</span><span>|</span><a href="#42880440">prev</a><span>|</span><a href="#42883770">next</a><span>|</span><label class="collapse" for="c-42884541">[-]</label><label class="expand" for="c-42884541">[1 more]</label></div><br/><div class="children"><div class="content">How does this compare to Amazon Aurora DSQL (<a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;rds&#x2F;aurora&#x2F;dsql&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aws.amazon.com&#x2F;rds&#x2F;aurora&#x2F;dsql&#x2F;</a>)?</div><br/></div></div><div id="42883770" class="c"><input type="checkbox" id="c-42883770" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#42884541">prev</a><span>|</span><a href="#42880164">next</a><span>|</span><label class="collapse" for="c-42883770">[-]</label><label class="expand" for="c-42883770">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really curious about the capabilities of <a href="https:&#x2F;&#x2F;cedardb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cedardb.com&#x2F;</a> they claim that they can make a single DB that does both OLTP and OLAP. It&#x27;s basically the production version of umbra.</div><br/><div id="42883990" class="c"><input type="checkbox" id="c-42883990" checked=""/><div class="controls bullet"><span class="by">tomrod</span><span>|</span><a href="#42883770">parent</a><span>|</span><a href="#42880164">next</a><span>|</span><label class="collapse" for="c-42883990">[-]</label><label class="expand" for="c-42883990">[1 more]</label></div><br/><div class="children"><div class="content">They seem to be missing a pricing page (or pricing information of any kind) as well as how to actually purchase the product.</div><br/></div></div></div></div><div id="42880164" class="c"><input type="checkbox" id="c-42880164" checked=""/><div class="controls bullet"><span class="by">honestSysAdmin</span><span>|</span><a href="#42883770">prev</a><span>|</span><label class="collapse" for="c-42880164">[-]</label><label class="expand" for="c-42880164">[3 more]</label></div><br/><div class="children"><div class="content">I could be wrong here, I&#x27;m not an expert with databases, but I believe -- this is a belief, please help me disconfirm it if you think it is wrong -- that CitusDB&#x27;s approach that shards Postgres across redundant mirrors, should successfully scale horizontally for OLTP without sacrificing consistency.</div><br/><div id="42880842" class="c"><input type="checkbox" id="c-42880842" checked=""/><div class="controls bullet"><span class="by">AlexB138</span><span>|</span><a href="#42880164">parent</a><span>|</span><a href="#42880468">next</a><span>|</span><label class="collapse" for="c-42880842">[-]</label><label class="expand" for="c-42880842">[1 more]</label></div><br/><div class="children"><div class="content">Citus still has a centralized coordinator that all requests go through to be routed to their shard, or at least it did several years ago when I last ran it in production. It definitely scales further than single instances, but it&#x27;s not a magic bullet.</div><br/></div></div><div id="42880468" class="c"><input type="checkbox" id="c-42880468" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#42880164">parent</a><span>|</span><a href="#42880842">prev</a><span>|</span><label class="collapse" for="c-42880468">[-]</label><label class="expand" for="c-42880468">[1 more]</label></div><br/><div class="children"><div class="content">Others can do it too: Spanner, FoundationDB. SI just has generally better performance because there is less to check, and you can always opt-in to row locking if you need (because of write-write conflicts)</div><br/></div></div></div></div></div></div></div></div></div></body></html>