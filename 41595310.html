<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1726822877095" as="style"/><link rel="stylesheet" href="styles.css?v=1726822877095"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.zombiezen.com/blog/2024/09/zb-early-stage-build-system/">Zb: An Early-Stage Build System</a> <span class="domain">(<a href="https://www.zombiezen.com">www.zombiezen.com</a>)</span></div><div class="subtext"><span>zombiezen</span> | <span>85 comments</span></div><br/><div><div id="41597670" class="c"><input type="checkbox" id="c-41597670" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41600026">next</a><span>|</span><label class="collapse" for="c-41597670">[-]</label><label class="expand" for="c-41597670">[2 more]</label></div><br/><div class="children"><div class="content">Whatever choices this project makes (I have some opinions, but I think they&#x27;re not too important) I don&#x27;t see it mentioning one of the most absolutely critical choices Nix made that was absolutely key to its insane success (at least, IMO, as a hardcore contributor and user for like 10+ years): the monorepo, containing all of the packages and all the libraries for use by everyone downstream, and all contributions trying to go there.<p>Please do not give into the temptation to just write a version manager and stitch together some hodgepodge and throw the hard problem over the fence to the &quot;community&quot;, a set of balkanized repositories to make everything work. It is really really really hard to overstate how much value Nixpkgs gets from going the monorepo route and how much the project has been able to improve, adapt, and overcome things thanks to it. It feels like Nixpkgs regularly pulls off major code-wide changes on an average Tuesday that other projects would balk at.<p>(It&#x27;s actually a benefit early on to just keep everything in one repo too, because you can just... clean up all the code in one spot if you do something like make a major breaking change. Huge huge benefit!)<p>Finally: as a die hard Nix user, I also have been using Buck2 as a kind of thing-that-is-hermetic-cloud-based-and-supports-Windows tool, and it competes in the same space as Zb; a monorepo containing all BUILD files is incredibly important for things to work reliably and it&#x27;s what I&#x27;m exploring right now and seeing if that can be viable. I&#x27;m even exploring the possibility of starting from stage0-posix as well. Good luck! There&#x27;s still work to be done in this space and Nix isn&#x27;t the final answer, even if I love it.</div><br/><div id="41599067" class="c"><input type="checkbox" id="c-41599067" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#41597670">parent</a><span>|</span><a href="#41600026">next</a><span>|</span><label class="collapse" for="c-41599067">[-]</label><label class="expand" for="c-41599067">[1 more]</label></div><br/><div class="children"><div class="content">Buck2 looks very principled. Will definitely be interesting as it gets mature in the open source world.<p>I&#x27;m personally convinced monorepo is strictly superior (provided you have the right tooling to support it).</div><br/></div></div></div></div><div id="41600026" class="c"><input type="checkbox" id="c-41600026" checked=""/><div class="controls bullet"><span class="by">fizlebit</span><span>|</span><a href="#41597670">prev</a><span>|</span><a href="#41596154">next</a><span>|</span><label class="collapse" for="c-41600026">[-]</label><label class="expand" for="c-41600026">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t help but wonder whether the major problem is actually API changing from version to version of software and keeping everything compatible.<p>If the build language is LUA, doesn&#x27;t it support top level variables. It probably just takes a few folks manipulating top level variables before the build steps and build logic is no longer hermetic, but instead plagued by side effects.<p>I think you need to build inside very effective sandboxes to stop build side effects and then you need your sandboxes to be very fast.<p>Anyway, nice to see attempts at more innovation in the build space.<p>I imagine a kind of merging between build systems, deployment systems, and running systems. Somehow a manageable sea of distributed processes running on a distributed operating system. I suspect Alan Kay thought that smalltalk might evolve in that direction, but there are many things to solve including billing, security, and somehow making the sea of objects comprehensible. It has the hope of everything being data driven, aka structured, schemad, versions, json like data rather than the horrendous mess that is unix configuration files and system information.<p>There was an interested talk on Developer Voice perhaps related to a merger of Ocaml and Erlang that moved a little in that direction.</div><br/></div></div><div id="41596154" class="c"><input type="checkbox" id="c-41596154" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41600026">prev</a><span>|</span><a href="#41596140">next</a><span>|</span><label class="collapse" for="c-41596154">[-]</label><label class="expand" for="c-41596154">[24 more]</label></div><br/><div class="children"><div class="content">Happy to see someone inspired by Nix, but wanting to carve their own path. Nix popularized some powerful ideas in the Linux world, but it has a steep learning curve and a very unfriendly UI, so there is plenty of room for improvement there.<p>I&#x27;m not sure if Lua is the right choice, though. A declarative language seems like a better fit for reproducibility. The goal of supporting non-deterministic builds also seems to go against this. But I&#x27;m interested to know how this would work in practice. Good luck!</div><br/><div id="41596321" class="c"><input type="checkbox" id="c-41596321" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41596154">parent</a><span>|</span><a href="#41596894">next</a><span>|</span><label class="collapse" for="c-41596321">[-]</label><label class="expand" for="c-41596321">[19 more]</label></div><br/><div class="children"><div class="content">If you design it like SCons, it&#x27;ll look imperative but behave more declaratively.<p>If I understand the architecture correctly, the imperative calls in the config file don&#x27;t actually run the build process. They run a Builder Pattern that sets up the state machine necessary for the builds to happen. So it&#x27;s a bit like LINQ in C# (but older).<p>I have no idea how that plays out single-step debugging build problems though. That depends on how it&#x27;s implemented and a lot of abstractions (especially frameworks) seem to forget that breakpoints are things other people want to use as well.</div><br/><div id="41596662" class="c"><input type="checkbox" id="c-41596662" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41596321">parent</a><span>|</span><a href="#41596894">next</a><span>|</span><label class="collapse" for="c-41596662">[-]</label><label class="expand" for="c-41596662">[18 more]</label></div><br/><div class="children"><div class="content">That&#x27;s accurate (unless the config file attempts to read something from the build process, that will trigger a build).<p>It&#x27;s a good point about debugging build problems. This is an issue I&#x27;ve experienced in Nix and Bazel as well. I&#x27;m not convinced that I have a great solution yet, but at least for my own debugging while using the system, I&#x27;ve included a `zb derivation env` command which spits out a .env file that matches the environment the builder runs under. I&#x27;d like to extend that to pop open a shell.</div><br/><div id="41597282" class="c"><input type="checkbox" id="c-41597282" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41596662">parent</a><span>|</span><a href="#41597212">next</a><span>|</span><label class="collapse" for="c-41597282">[-]</label><label class="expand" for="c-41597282">[13 more]</label></div><br/><div class="children"><div class="content">Surface-level feedback: get rid of the word &quot;derivation&quot;. Surely there must be a better way to describe the underlying thing...</div><br/><div id="41599076" class="c"><input type="checkbox" id="c-41599076" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597282">parent</a><span>|</span><a href="#41597544">next</a><span>|</span><label class="collapse" for="c-41599076">[-]</label><label class="expand" for="c-41599076">[3 more]</label></div><br/><div class="children"><div class="content">Agreed! It&#x27;s such an alien term to describe something quite mundane. Language clarity is a big part of a friendly UI.</div><br/><div id="41599893" class="c"><input type="checkbox" id="c-41599893" checked=""/><div class="controls bullet"><span class="by">ulbu</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41599076">parent</a><span>|</span><a href="#41597544">next</a><span>|</span><label class="collapse" for="c-41599893">[-]</label><label class="expand" for="c-41599893">[2 more]</label></div><br/><div class="children"><div class="content">what word would you fit to what a nix derivation is?</div><br/><div id="41600089" class="c"><input type="checkbox" id="c-41600089" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41599893">parent</a><span>|</span><a href="#41597544">next</a><span>|</span><label class="collapse" for="c-41600089">[-]</label><label class="expand" for="c-41600089">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure, I&#x27;m not a Nix expert. The comments here also refer to it as both instructions to build something, as well as the intermediate build artifact. This discussion[1] on the NixOS forums explains it as a &quot;blueprint&quot; or &quot;recipe&quot;. So there&#x27;s clearly a lot of confusion about what it is, yet everyone understands &quot;blueprint&quot;, &quot;recipe&quot;, or even &quot;intermediate build artifact&quot; if you want to be technical.<p>The same is true for &quot;flakes&quot;. It&#x27;s a uniquely Nix term with no previous technical usage AFAIK.<p>Ideally you want to avoid using specialized terms if possible. But if you do decide to do that, then your documentation must be very clear and precise, which is another thing that Nix(OS) spectacularly fumbles. Take this page[2] that&#x27;s supposed to explain derivations, for example. The first sentence is a circular reference to the term, without actually explaining what the thing is. There are examples like this in many places, even without general problems of it being outdated or incomplete.<p>Though I don&#x27;t think going the other way and overloading general terms is a good idea either. For example, Homebrew likes to use terms like &quot;tap&quot; and &quot;bottle&quot; to describe technical concepts, which has the similar effect of having to explain what the thing actually is.<p>Docker is a good example of getting this right: containers, images, layers, build stages, intermediate images, etc. It uses already familiar technical terms and adopts them where they make most sense. When you additionally have excelent documentation, all these things make up a good user experience, and become essential to a widespread adoption of the tool.<p>[1]: <a href="https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;what-is-a-derivation&#x2F;28311&#x2F;6" rel="nofollow">https:&#x2F;&#x2F;discourse.nixos.org&#x2F;t&#x2F;what-is-a-derivation&#x2F;28311&#x2F;6</a><p>[2]: <a href="https:&#x2F;&#x2F;nix.dev&#x2F;manual&#x2F;nix&#x2F;2.18&#x2F;language&#x2F;derivations" rel="nofollow">https:&#x2F;&#x2F;nix.dev&#x2F;manual&#x2F;nix&#x2F;2.18&#x2F;language&#x2F;derivations</a></div><br/></div></div></div></div></div></div><div id="41597544" class="c"><input type="checkbox" id="c-41597544" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597282">parent</a><span>|</span><a href="#41599076">prev</a><span>|</span><a href="#41599409">next</a><span>|</span><label class="collapse" for="c-41597544">[-]</label><label class="expand" for="c-41597544">[7 more]</label></div><br/><div class="children"><div class="content">What’s wrong with it? It’s a term of art that means a specific thing in both nix and guix; it’d just be confusing if zb renamed it to something else.</div><br/><div id="41598299" class="c"><input type="checkbox" id="c-41598299" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597544">parent</a><span>|</span><a href="#41599409">next</a><span>|</span><label class="collapse" for="c-41598299">[-]</label><label class="expand" for="c-41598299">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m 80% finished moving all of my servers from NixOS to Debian. I used NixOS for 3 years (even wrote some custom flakes) before finally giving up (for the final year I was just too scared to touch it, and then said &quot;I shouldn&#x27;t be scared of my OS&quot;). I should know what &quot;derivation&quot; means, but I can&#x27;t for the life of me remember...</div><br/><div id="41599084" class="c"><input type="checkbox" id="c-41599084" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41598299">parent</a><span>|</span><a href="#41598574">next</a><span>|</span><label class="collapse" for="c-41599084">[-]</label><label class="expand" for="c-41599084">[1 more]</label></div><br/><div class="children"><div class="content">I don’t know Nix, but I’ll describe how Guix works, and hopefully it will be obvious what the corresponding Nix concepts are.<p>A “package” is a high-level description (written in scheme) of how to build something, like: “using the GNU build system with inputs a, b, c, and configure flags x, y, z, build the source available at <a href="https:&#x2F;&#x2F;github.com&#x2F;foo&#x2F;bar”">https:&#x2F;&#x2F;github.com&#x2F;foo&#x2F;bar”</a><p>The actual builder daemon doesn’t know about the GNU build system, or how to fetch things from GitHub, or how to compute nested dependencies, etc.; it is very simple. All it knows is how to build derivations, which are low-level descriptions of how to build something: “create a container that can see paths a, b, and c (which are themselves other derivations or files stored in the store and addressed by their hash), then invoke the builder script x.”<p>So when you ask guix to build something, it reads the package definition, finds the source and stores it in the store, generates the builder script (which is by convention usually <i>also</i> written in scheme, though theoretically nothing stops you from defining a package whose builder was written in some other language), computes the input derivation paths, etc., and ultimately generates a derivation which it then asks the daemon to build.<p>I believe in Nix, rather than scheme, packages are written in nix lang and builder scripts can be written in any language but by convention are usually bash.<p>So basically long story short, the package is the higher-level representation on the guix side, and the derivation is the lower-level representation on the guix-daemon side.</div><br/></div></div><div id="41598574" class="c"><input type="checkbox" id="c-41598574" checked=""/><div class="controls bullet"><span class="by">Modified3019</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41598299">parent</a><span>|</span><a href="#41599084">prev</a><span>|</span><a href="#41598464">next</a><span>|</span><label class="collapse" for="c-41598574">[-]</label><label class="expand" for="c-41598574">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I ended up with the same issue. While I’m technically inclined, I’m not nearly to the point where I can handle the fire hose of (badly named) abstraction at all levels like some people.<p>I could never have pulled off what this guy did <a href="https:&#x2F;&#x2F;roscidus.com&#x2F;blog&#x2F;blog&#x2F;2021&#x2F;03&#x2F;07&#x2F;qubes-lite-with-kvm-and-wayland&#x2F;" rel="nofollow">https:&#x2F;&#x2F;roscidus.com&#x2F;blog&#x2F;blog&#x2F;2021&#x2F;03&#x2F;07&#x2F;qubes-lite-with-kv...</a>, though ironically his journal is probably one of the best “how nix actually works” tutorials I’ve ever seen, even though it isn’t intended for that or complete for such a purpose. He’s the only reason I know that a derivation is basically an intermediate build object.</div><br/></div></div><div id="41598464" class="c"><input type="checkbox" id="c-41598464" checked=""/><div class="controls bullet"><span class="by">smilliken</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41598299">parent</a><span>|</span><a href="#41598574">prev</a><span>|</span><a href="#41599409">next</a><span>|</span><label class="collapse" for="c-41598464">[-]</label><label class="expand" for="c-41598464">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Derivation&quot; refers to the nix intermediate build artifact, a .drv file, which contains the instructions to perform the build itself. Basically a nix program compiles to a derivation file which gets run to produce the build outputs. The hash in the &#x2F;nix&#x2F;store for a dependency is the hash of the derivation. Conveniently if the hash is already in a build cache, you can download the cached build outputs instead of building it yourself.</div><br/><div id="41598572" class="c"><input type="checkbox" id="c-41598572" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41598464">parent</a><span>|</span><a href="#41599409">next</a><span>|</span><label class="collapse" for="c-41598572">[-]</label><label class="expand" for="c-41598572">[2 more]</label></div><br/><div class="children"><div class="content">Ah OK, then I&#x27;d actually never actually understood what a derivation is. But then again, the name &quot;derivation&quot; doesn&#x27;t at all lead to guessing at such a definition, either.</div><br/><div id="41600007" class="c"><input type="checkbox" id="c-41600007" checked=""/><div class="controls bullet"><span class="by">umanwizard</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41598572">parent</a><span>|</span><a href="#41599409">next</a><span>|</span><label class="collapse" for="c-41600007">[-]</label><label class="expand" for="c-41600007">[1 more]</label></div><br/><div class="children"><div class="content">“Build plan” would maybe be a more obvious name, but it’d still be confusing to deviate from what Nox uses, IMO.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41599409" class="c"><input type="checkbox" id="c-41599409" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597282">parent</a><span>|</span><a href="#41597544">prev</a><span>|</span><a href="#41597212">next</a><span>|</span><label class="collapse" for="c-41599409">[-]</label><label class="expand" for="c-41599409">[2 more]</label></div><br/><div class="children"><div class="content">It is the name of a feature in Nix. This is as obfuscated as calling a rock a rock.</div><br/><div id="41599436" class="c"><input type="checkbox" id="c-41599436" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41599409">parent</a><span>|</span><a href="#41597212">next</a><span>|</span><label class="collapse" for="c-41599436">[-]</label><label class="expand" for="c-41599436">[1 more]</label></div><br/><div class="children"><div class="content">Strange thing to say but you do you.<p>I tried to dabble in Nix several times and the term never stuck.<p>I suppose for you it&#x27;s impossible to accept that the term is just bad and unintuitive. And other comments here say the same.</div><br/></div></div></div></div></div></div><div id="41597212" class="c"><input type="checkbox" id="c-41597212" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41596662">parent</a><span>|</span><a href="#41597282">prev</a><span>|</span><a href="#41596894">next</a><span>|</span><label class="collapse" for="c-41597212">[-]</label><label class="expand" for="c-41597212">[4 more]</label></div><br/><div class="children"><div class="content">One thing I like to see is a &#x27;dry run&#x27; like &#x27;make -n&#x27;. Although, maybe that&#x27;s not possible in all cases.<p>Another possibility might be to output a something like a shell script that would do a rebuild the same way, so you can see what it did and hack it when debugging.</div><br/><div id="41597654" class="c"><input type="checkbox" id="c-41597654" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597212">parent</a><span>|</span><a href="#41596894">next</a><span>|</span><label class="collapse" for="c-41597654">[-]</label><label class="expand" for="c-41597654">[3 more]</label></div><br/><div class="children"><div class="content">Yes.  Dry runs at least, and better yet terraform-style planning that produces an artifact that can be applied.  These should really be more common with all kinds of software</div><br/><div id="41597740" class="c"><input type="checkbox" id="c-41597740" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597654">parent</a><span>|</span><a href="#41596894">next</a><span>|</span><label class="collapse" for="c-41597740">[-]</label><label class="expand" for="c-41597740">[2 more]</label></div><br/><div class="children"><div class="content">I would like to see more tools iterate on trying to do terraform-like output because while terraform diffs are interesting, practically most of my teammates couldn’t tell what the fuck they said and a couple times I missed important lines that caused us prod issues. I think we can do a better job than showing a wall of text.</div><br/><div id="41598014" class="c"><input type="checkbox" id="c-41598014" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41597740">parent</a><span>|</span><a href="#41596894">next</a><span>|</span><label class="collapse" for="c-41598014">[-]</label><label class="expand" for="c-41598014">[1 more]</label></div><br/><div class="children"><div class="content">Presentation is a separate matter though, just like with git diffs ideally you could choose a wall of text or a side by side ui, see things at a high level or drill down to line by line.  A tag layer plus custom validation between plan&#x2F;apply gives you an automatic way to short circuit things.  But none of it can work without a plan as a first class object.<p>Thing is the plan&#x2F;apply split isn’t even primarily <i>for</i> users necessarily, it’s just good design.  It makes testing easier, and leaves open the possibility for plugging in totally different resolution strategies without rewriting the whole core.  The benefits are so big there that I’d strongly prefer that more software is using it more often, even if I’m going to shut my eyes and auto apply every time without glancing at the plan.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41596894" class="c"><input type="checkbox" id="c-41596894" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#41596154">parent</a><span>|</span><a href="#41596321">prev</a><span>|</span><a href="#41598248">next</a><span>|</span><label class="collapse" for="c-41596894">[-]</label><label class="expand" for="c-41596894">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The goal of supporting non-deterministic builds also seems to go against this.<p>I think this is actually a great escape hatch. Supporting non-deterministic builds means more folks will be able to migrate their existing build to zb. Postel&#x27;s law and all that.</div><br/><div id="41599056" class="c"><input type="checkbox" id="c-41599056" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41596894">parent</a><span>|</span><a href="#41598248">next</a><span>|</span><label class="collapse" for="c-41599056">[-]</label><label class="expand" for="c-41599056">[1 more]</label></div><br/><div class="children"><div class="content">Right, could be.<p>One of the insane things with Nix is that the suggested workflow is to manage _everything_ with it. This means that it wants to replace every package manager in existence, so you see Python, Emacs and other dependency trees entirely replicated in Nix. As well as every possible configuration format. It&#x27;s craziness... Now I don&#x27;t need to depend on just the upstream package, I also have to wait for these changes to propagate to Nix packages. And sometimes I just want to do things manually as a quick fix, instead of spending hours figuring out why the Nix implementation doesn&#x27;t work.<p>So, yeah, having an escape hatch that allows easier integration with other ecosystems or doing things manually in some cases, would be nice to have.</div><br/></div></div></div></div><div id="41598248" class="c"><input type="checkbox" id="c-41598248" checked=""/><div class="controls bullet"><span class="by">sweeter</span><span>|</span><a href="#41596154">parent</a><span>|</span><a href="#41596894">prev</a><span>|</span><a href="#41596140">next</a><span>|</span><label class="collapse" for="c-41598248">[-]</label><label class="expand" for="c-41598248">[2 more]</label></div><br/><div class="children"><div class="content">I thought of creating something similar and I was going to use a personal fork of the Go compiler with some mods, anko (which is a really cool go binding language) or righting my own DSL. It&#x27;s quite the undertaking.<p>I like Nix and NixOS a lot, its really cool, but it has some really odd management issues and the language IMO is horrendous. I used NixOS for around a year and I was changing my Nixpkgs version and I got that same generic nonsense error that doesn&#x27;t have any semantic meaning and I was just over it. I&#x27;m not too fond of commenting out random parts of code to figure out where something minor and obscure failed. Sometimes it tells you the module it had a problem with, or will point out an out of place comma, and other times its just like &quot;idk bruh ¯\_(ツ)_&#x2F;¯ &quot;failed at builtin &#x27;seq&#x27;&quot; is the best I can do&quot;<p>the paradigm is a million dollar idea though. I have no doubt its the future of a large portion of the future, both for programming and generic systems. I just wish it wasn&#x27;t a pain to write and it had some sensible error handling.</div><br/><div id="41599124" class="c"><input type="checkbox" id="c-41599124" checked=""/><div class="controls bullet"><span class="by">danmur</span><span>|</span><a href="#41596154">root</a><span>|</span><a href="#41598248">parent</a><span>|</span><a href="#41596140">next</a><span>|</span><label class="collapse" for="c-41599124">[-]</label><label class="expand" for="c-41599124">[1 more]</label></div><br/><div class="children"><div class="content">The language has grown on me a bit. I initially hated it but a lot of my pain was not actually the language but the lack of good docs for the standard library.<p>Still struggle with the tracebacks though. It&#x27;s painful when things go wrong.</div><br/></div></div></div></div></div></div><div id="41596140" class="c"><input type="checkbox" id="c-41596140" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#41596154">prev</a><span>|</span><a href="#41596102">next</a><span>|</span><label class="collapse" for="c-41596140">[-]</label><label class="expand" for="c-41596140">[8 more]</label></div><br/><div class="children"><div class="content">Whoa, nifty. Can you speak more to the interop issues with Nix? I&#x27;ve been working on a pretty large Nix deployment in the robotics space for the past 3ish years, and the infrastructure side is the biggest pain point:<p>* Running a bare `nix build` in your CI isn&#x27;t really enough— no hosted logs, lack of proper prioritization, may end up double-building things.<p>* Running your own instance of Hydra is a gigantic pain; it&#x27;s a big ball of perl and has compiled components that link right into Nix internals, and architectural fiasco.<p>* SaaS solutions are limited and lack maturity (Hercules CI is Github-only, nixbuild.net is based in Europe and last I checked was still missing some features I needed).<p>* Tvix is cool but not ready for primetime, and the authors oppose flakes, which is a deal-breaker for me.<p>Something that&#x27;s a barebones capable of running these builds and could be wrapped in a sane REST API and simple web frontend would be very appealing.</div><br/><div id="41596512" class="c"><input type="checkbox" id="c-41596512" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596140">parent</a><span>|</span><a href="#41596313">next</a><span>|</span><label class="collapse" for="c-41596512">[-]</label><label class="expand" for="c-41596512">[1 more]</label></div><br/><div class="children"><div class="content">Tracking issue is <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;2">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;2</a><p>The hurdles to interop I see are:<p>- Nixpkgs is not content-addressed (yet). I made a conscious decision to only support content-addressed derivations in zb to simplify the build model and provide easier-to-understand guarantees to users. As a result, the store paths are different (&#x2F;zb&#x2F;store instead of &#x2F;nix&#x2F;store). Which leads to...
- Nix store objects have no notion of cross-store references. I am not sure how many assumptions are made on this in the codebases, but it seems gnarly in general. (e.g. how would GC work, how do you download the closure of a cross-store object, etc.)
- In order to obtain Nixpkgs derivations, you need to run a Nix evaluator, which means you still need Nix installed. I&#x27;m not sure of a way around this, and seems like it would be a hassle for users.<p>I have experienced the same friction in build infra for Nix. My hope is that by reusing the binary cache layer and introducing a JSON-RPC-based public API (already checked in, but needs to be documented and cleaned up) for running builds that the infrastructure ecosystem will be easier.</div><br/></div></div><div id="41596313" class="c"><input type="checkbox" id="c-41596313" checked=""/><div class="controls bullet"><span class="by">flurie</span><span>|</span><a href="#41596140">parent</a><span>|</span><a href="#41596512">prev</a><span>|</span><a href="#41596199">next</a><span>|</span><label class="collapse" for="c-41596313">[-]</label><label class="expand" for="c-41596313">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been wondering idly if it&#x27;s possible for Nix to support the Bazel Remote Execution API that seems to be catching on[1] more generally.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;remote-apis?tab=readme-ov-file#clients">https:&#x2F;&#x2F;github.com&#x2F;bazelbuild&#x2F;remote-apis?tab=readme-ov-file...</a></div><br/><div id="41597485" class="c"><input type="checkbox" id="c-41597485" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#41596140">root</a><span>|</span><a href="#41596313">parent</a><span>|</span><a href="#41596199">next</a><span>|</span><label class="collapse" for="c-41597485">[-]</label><label class="expand" for="c-41597485">[2 more]</label></div><br/><div class="children"><div class="content">I’m very interested in better bidirectional interop between bazel and nix; it seems such a travesty that for two projects that are so ideologically aligned to work so poorly together. Nix should be able to run builds on bazel and bazel builds should decompose and cache into multiple store paths in a nix environment (think how poetry2nix works).</div><br/><div id="41597687" class="c"><input type="checkbox" id="c-41597687" checked=""/><div class="controls bullet"><span class="by">flurie</span><span>|</span><a href="#41596140">root</a><span>|</span><a href="#41597485">parent</a><span>|</span><a href="#41596199">next</a><span>|</span><label class="collapse" for="c-41597687">[-]</label><label class="expand" for="c-41597687">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re attending BazelCon I&#x27;d love to have a chat with you about this stuff in some more detail. (If you&#x27;re not I&#x27;d still love to have a chat!)</div><br/></div></div></div></div></div></div><div id="41596199" class="c"><input type="checkbox" id="c-41596199" checked=""/><div class="controls bullet"><span class="by">Rucadi</span><span>|</span><a href="#41596140">parent</a><span>|</span><a href="#41596313">prev</a><span>|</span><a href="#41597519">next</a><span>|</span><label class="collapse" for="c-41596199">[-]</label><label class="expand" for="c-41596199">[2 more]</label></div><br/><div class="children"><div class="content">Why are flakes such a deal-breaker? While not ideal, you can still tag your versions in the .nix file instead of the lockfile.<p>I even had to avoid flakes in a system I developed used by ~200 developers since it involved a non-nixos OS and it involved user secrets (Tokens etc...) So with flakes I had to keep track of the secrets (and was a pain point, since they obviously didn&#x27;t have to push them into the git repo) but nix flakes doesn&#x27;t handle well omitting files on git (it ignores them also on nix commands). In the end, the workarounds were too messy and had to drop flakes entirely.</div><br/><div id="41597489" class="c"><input type="checkbox" id="c-41597489" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#41596140">root</a><span>|</span><a href="#41596199">parent</a><span>|</span><a href="#41597519">next</a><span>|</span><label class="collapse" for="c-41597489">[-]</label><label class="expand" for="c-41597489">[1 more]</label></div><br/><div class="children"><div class="content">As a new user, I learned flakes first, and the tie-in with git tags&#x2F;branches and the corresponding cli ergonomics aren’t something I’d be able to give up.</div><br/></div></div></div></div><div id="41597519" class="c"><input type="checkbox" id="c-41597519" checked=""/><div class="controls bullet"><span class="by">xyzsparetimexyz</span><span>|</span><a href="#41596140">parent</a><span>|</span><a href="#41596199">prev</a><span>|</span><a href="#41596102">next</a><span>|</span><label class="collapse" for="c-41597519">[-]</label><label class="expand" for="c-41597519">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;edolstra&#x2F;flake-compat">https:&#x2F;&#x2F;github.com&#x2F;edolstra&#x2F;flake-compat</a> should make flakes work with tvix</div><br/></div></div></div></div><div id="41596102" class="c"><input type="checkbox" id="c-41596102" checked=""/><div class="controls bullet"><span class="by">laurentlb</span><span>|</span><a href="#41596140">prev</a><span>|</span><a href="#41596116">next</a><span>|</span><label class="collapse" for="c-41596102">[-]</label><label class="expand" for="c-41596102">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to know more about the &quot;Support for non-determinism&quot; and how that differs from other build systems. Usually, build systems rerun actions when at least one of the inputs has changed. Are non-deterministic targets rerun all the time?<p>Also, I&#x27;m curious to know if you&#x27;ve considered using Starlark or the build file syntax used in multiple other recent build systems (Bazel, Buck, Please, Pants).</div><br/><div id="41596426" class="c"><input type="checkbox" id="c-41596426" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596102">parent</a><span>|</span><a href="#41596116">next</a><span>|</span><label class="collapse" for="c-41596426">[-]</label><label class="expand" for="c-41596426">[3 more]</label></div><br/><div class="children"><div class="content">(Hi! I recognize your name from Bazel mailing lists but I forget whether we&#x27;ve talked before.)<p>I&#x27;m mostly contrasting from Nix, which has difficulty with poisoning cache when faced with non-deterministic build steps when using input-addressing (the default mode). If zb encounters a build target with multiple cached outputs for the same inputs, it rebuilds and then relies on content-addressing to obtain build outputs for subsequent steps if possible. (I have an open issue for marking a target as intentionally non-deterministic and always triggering this re-run behavior: <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;33">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;33</a>)<p>I&#x27;ll admit I haven&#x27;t done my research into how Bazel handles non-determinism, especially nowadays, so I can&#x27;t remark there. I know from my Google days that even writing genrules you had to be careful about introducing non-determinism, but I forget how that failure mode plays out. If you have a good link (or don&#x27;t mind giving a quick summary), I&#x27;d love to read up.<p>I have considered Starlark, and still might end up using it. The critical feature I wanted to bolt in from Nix was having strings carrying dependency information (see <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;blob&#x2F;2f678331d59451dd6f1d9512cb6d92e4ecb9750f&#x2F;src&#x2F;libexpr&#x2F;value.hh#L192-L211">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;blob&#x2F;2f678331d59451dd6f1d9512cb...</a> for a description of the feature). In my prototyping, this was pretty simple to bolt on to Lua, but I&#x27;m not sure how disruptive that would be to Starlark. Nix configurations tend to be a bit more complex than Bazel ones, so having a more full-featured language felt more appropriate. Still exploring the design space!</div><br/><div id="41597699" class="c"><input type="checkbox" id="c-41597699" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41596102">root</a><span>|</span><a href="#41596426">parent</a><span>|</span><a href="#41596116">next</a><span>|</span><label class="collapse" for="c-41597699">[-]</label><label class="expand" for="c-41597699">[2 more]</label></div><br/><div class="children"><div class="content">I mean, to be fair, Nix is nothing more than a big ass pile of genrule() calls, at the end of the day. Everything is really just genrule. Nix just makes it all work with the sandbox it puts all builds in. Bazel has an equivalent sandbox and I&#x27;m pretty sure you can sandbox genrule so it&#x27;s in a nice, hermetic container. (Side note, but one of my biggest pet peeves is that Nix without the sandbox is actually fundamentally _broken_, yet we let people install it without the sandbox. I have no idea why &quot;Install this thing in a broken way!&quot; is even offered as an option. Ridiculous.)<p>The way Nix-like systems achieve hermetic sandboxing isn&#x27;t so much a technical feat, in my mind. That&#x27;s part of it -- sure, you need to get rid of &#x2F;dev devices, and every build always has to look like it happens at &#x2F;tmp&#x2F;build within a mount namespace, and you need to set SOURCE_EPOCH_DATE and blah blah, stuff like that.<p>But it&#x27;s also a social one, because with Nix you are expected to wrap arbitrary build systems and package mechanisms and &quot;go where they are.&quot; That means you have to bludgeon every random hostile badly written thing into working inside the sandbox you designed, carve out exceptions, and write ptaches for things that don&#x27;t -- and get them working in a deterministic way. For example, you have to change the default search paths for nearly every single tool to look inside calculated Nix store path. That&#x27;s not a technical feat, it&#x27;s mostly just a huge amount of hard work to write all the abstractions, like buildRustPackage or makeDerivation. You need to patch every build system like CMake or Scons in order to alleviate some of their assumptions, and so on and so forth.<p>Bazel and Buck like systems do not avoid this pain but they do pay for it in a different way. They don&#x27;t &quot;go where they are&quot;, they expect everyone to &quot;come to them.&quot; Culturally, Bazel users do <i>not</i> accept &quot;just run Make under a sandbox&quot; nearly as much. The idea is to write everything as a BUILD file rule, from scratch rewriting the build system, and those BUILD files instead should perform the build &quot;natively&quot; in a way that is designed to work hermetically. So you don&#x27;t run .&#x2F;configure, you actually pick an exact set of configuration options and build with that 100% of the time. Therefore, the impurities in the build are removed &quot;by design&quot;, which makes the strict requirements on a sandbox somewhat more lenient. You still need the sandbox, but by definition your builds are much more robust anyway. So you are trading the pain of wrapping every system for the pain of integrating every system manually. They&#x27;re not the same thing but have a lot of overlap.<p>So the answer is, yes you can write impure genrules, but the vast majority of impurity is totally encapsulated in a way that forces it to be pure, just like Nix, so it&#x27;s mostly just a small nit rather than truly fundamental. The real question is a matter of when you want to pay the pied piper.</div><br/><div id="41599892" class="c"><input type="checkbox" id="c-41599892" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#41596102">root</a><span>|</span><a href="#41597699">parent</a><span>|</span><a href="#41596116">next</a><span>|</span><label class="collapse" for="c-41599892">[-]</label><label class="expand" for="c-41599892">[1 more]</label></div><br/><div class="children"><div class="content">You (plural) seem to know a great deal about build systems, so I figured I would ask - what’s your opinion about Mill? It’s a not so well known build tool written in scala, but I find its underlying primitives are absolutely on point.<p>For those who don’t know, its build descriptors are just Scala classes with functions. A function calling another function denotes a dependency, and that’s pretty much it. The build tool will automatically take care of parallelizing build steps and caching them.<p>How do you think it relates to Nix and alia on a technical level?</div><br/></div></div></div></div></div></div></div></div><div id="41596116" class="c"><input type="checkbox" id="c-41596116" checked=""/><div class="controls bullet"><span class="by">msvan</span><span>|</span><a href="#41596102">prev</a><span>|</span><a href="#41595723">next</a><span>|</span><label class="collapse" for="c-41596116">[-]</label><label class="expand" for="c-41596116">[7 more]</label></div><br/><div class="children"><div class="content">As a current Nix user, what I would really like is a statically typed language to define builds. Recreating Nix without addressing that feels like a missed opportunity.</div><br/><div id="41596181" class="c"><input type="checkbox" id="c-41596181" checked=""/><div class="controls bullet"><span class="by">Rucadi</span><span>|</span><a href="#41596116">parent</a><span>|</span><a href="#41596131">next</a><span>|</span><label class="collapse" for="c-41596181">[-]</label><label class="expand" for="c-41596181">[4 more]</label></div><br/><div class="children"><div class="content">For me the killer feature is Windows Support, Ericsson is doing a great job bringing nix into Windows, but the process it&#x27;s understandably slow, If this project is similar enough to nix that I can kind-off translate easily the zb derivations to nix derivations, I&#x27;m willing to use it in windows (It&#x27;s not like nix has windows programs in the nixpkgs either way I have to bring them in my own).<p>The problem for me is that I see no benefit on using this over nix language (which I kinda like a lot right now)</div><br/><div id="41596329" class="c"><input type="checkbox" id="c-41596329" checked=""/><div class="controls bullet"><span class="by">droelf</span><span>|</span><a href="#41596116">root</a><span>|</span><a href="#41596181">parent</a><span>|</span><a href="#41596691">next</a><span>|</span><label class="collapse" for="c-41596329">[-]</label><label class="expand" for="c-41596329">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re working on rattler-build (<a href="https:&#x2F;&#x2F;github.com&#x2F;prefix-dev&#x2F;rattler-build&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;prefix-dev&#x2F;rattler-build&#x2F;</a>) - which is a build system inspired by Apko &#x2F; conda-build and uses YAML files to statically define dependencies. It works really well with pixi (our package manager) but also any other conda compatible package managers (mamba, conda).<p>And it has Windows support, of course. It can also be used to build your own distribution (e.g. here is one for a bunch of Rust utilities: <a href="https:&#x2F;&#x2F;github.com&#x2F;wolfv&#x2F;rust-forge">https:&#x2F;&#x2F;github.com&#x2F;wolfv&#x2F;rust-forge</a>)</div><br/></div></div><div id="41596691" class="c"><input type="checkbox" id="c-41596691" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#41596116">root</a><span>|</span><a href="#41596181">parent</a><span>|</span><a href="#41596329">prev</a><span>|</span><a href="#41596131">next</a><span>|</span><label class="collapse" for="c-41596691">[-]</label><label class="expand" for="c-41596691">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  Ericsson is doing a great job bringing nix into Windows<p>Is this Ericsson... the corporation? Windows support for nix is something I don&#x27;t hear much about, but if there is progress being made (even slowly) I&#x27;d love to know more.</div><br/><div id="41596829" class="c"><input type="checkbox" id="c-41596829" checked=""/><div class="controls bullet"><span class="by">Rucadi</span><span>|</span><a href="#41596116">root</a><span>|</span><a href="#41596691">parent</a><span>|</span><a href="#41596131">next</a><span>|</span><label class="collapse" for="c-41596829">[-]</label><label class="expand" for="c-41596829">[1 more]</label></div><br/><div class="children"><div class="content">John Ericson (@Ericson2314)<p>You can read a post on that here:
<a href="https:&#x2F;&#x2F;lastlog.de&#x2F;blog&#x2F;libnix_roadmap.html" rel="nofollow">https:&#x2F;&#x2F;lastlog.de&#x2F;blog&#x2F;libnix_roadmap.html</a></div><br/></div></div></div></div></div></div><div id="41596131" class="c"><input type="checkbox" id="c-41596131" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596116">parent</a><span>|</span><a href="#41596181">prev</a><span>|</span><a href="#41595723">next</a><span>|</span><label class="collapse" for="c-41596131">[-]</label><label class="expand" for="c-41596131">[2 more]</label></div><br/><div class="children"><div class="content">The Lua VSCode extension adds a type system that works really well IME</div><br/><div id="41596156" class="c"><input type="checkbox" id="c-41596156" checked=""/><div class="controls bullet"><span class="by">0cf8612b2e1e</span><span>|</span><a href="#41596116">root</a><span>|</span><a href="#41596131">parent</a><span>|</span><a href="#41595723">next</a><span>|</span><label class="collapse" for="c-41596156">[-]</label><label class="expand" for="c-41596156">[1 more]</label></div><br/><div class="children"><div class="content">There are Lua flavors with typing. Teal is one I have heard that compiles down to regular Lua like a typescript</div><br/></div></div></div></div></div></div><div id="41595723" class="c"><input type="checkbox" id="c-41595723" checked=""/><div class="controls bullet"><span class="by">Iceland_jack</span><span>|</span><a href="#41596116">prev</a><span>|</span><a href="#41595570">next</a><span>|</span><label class="collapse" for="c-41595723">[-]</label><label class="expand" for="c-41595723">[2 more]</label></div><br/><div class="children"><div class="content">I appreciate the link to <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3236774" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;3236774</a></div><br/><div id="41596414" class="c"><input type="checkbox" id="c-41596414" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41595723">parent</a><span>|</span><a href="#41595570">next</a><span>|</span><label class="collapse" for="c-41596414">[-]</label><label class="expand" for="c-41596414">[1 more]</label></div><br/><div class="children"><div class="content">Definitely interesting, but it&#x27;s flat-out wrong about the limitations of `make`.<p>In particular, the `release.txt` task is trivial by adding a dummy rule to generate and include dependencies; see <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;manual&#x2F;html_node&#x2F;Remaking-Makefiles.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;manual&#x2F;html_node&#x2F;Remaking-...</a> (be sure to add empty rules to handle the case of deleted dynamic dependencies). You can use hashes instead of file modification times by adding a different kind of dummy rule. The only downside is that you have to think about the performance a little.<p>I imagine it&#x27;s <i>possible</i> for a project to have some kind of dynamic dependencies that GNU make can&#x27;t handle, but I dare say that any such dependency tree is hard to understand for humans too, and thus should be avoided regardless. By contrast, in many other build tools it is <i>impossible</i> to handle some of the things that are trivial in `make`.<p>(if you&#x27;re not using GNU make, <i>you</i> are the problem; do not blame `make`)</div><br/></div></div></div></div><div id="41595570" class="c"><input type="checkbox" id="c-41595570" checked=""/><div class="controls bullet"><span class="by">evanjrowley</span><span>|</span><a href="#41595723">prev</a><span>|</span><a href="#41599881">next</a><span>|</span><label class="collapse" for="c-41595570">[-]</label><label class="expand" for="c-41595570">[2 more]</label></div><br/><div class="children"><div class="content">This looks really exciting and I absolutely must give it a try. Well done! At face value the vision and design choices appear to be great.</div><br/><div id="41595584" class="c"><input type="checkbox" id="c-41595584" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41595570">parent</a><span>|</span><a href="#41599881">next</a><span>|</span><label class="collapse" for="c-41595584">[-]</label><label class="expand" for="c-41595584">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! &lt;3</div><br/></div></div></div></div><div id="41599881" class="c"><input type="checkbox" id="c-41599881" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#41595570">prev</a><span>|</span><a href="#41599988">next</a><span>|</span><label class="collapse" for="c-41599881">[-]</label><label class="expand" for="c-41599881">[1 more]</label></div><br/><div class="children"><div class="content">It’s amazing the lengths some people will go to in order to avoid scary parentheses.</div><br/></div></div><div id="41599988" class="c"><input type="checkbox" id="c-41599988" checked=""/><div class="controls bullet"><span class="by">Nikhilbidkar1</span><span>|</span><a href="#41599881">prev</a><span>|</span><a href="#41597140">next</a><span>|</span><label class="collapse" for="c-41599988">[-]</label><label class="expand" for="c-41599988">[1 more]</label></div><br/><div class="children"><div class="content">This looks awesome....</div><br/></div></div><div id="41597140" class="c"><input type="checkbox" id="c-41597140" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#41599988">prev</a><span>|</span><a href="#41597926">next</a><span>|</span><label class="collapse" for="c-41597140">[-]</label><label class="expand" for="c-41597140">[2 more]</label></div><br/><div class="children"><div class="content">Nice to see Windows support. We&#x2F;I are working on that with upstream Nix too.<p>Also I hope we can keep the store layer compatible. It would be good to replace ATerm with JSON, for example. We should coordinate that!</div><br/><div id="41597967" class="c"><input type="checkbox" id="c-41597967" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41597140">parent</a><span>|</span><a href="#41597926">next</a><span>|</span><label class="collapse" for="c-41597967">[-]</label><label class="expand" for="c-41597967">[1 more]</label></div><br/><div class="children"><div class="content">Rad! Yes, please keep me in the loop!</div><br/></div></div></div></div><div id="41597462" class="c"><input type="checkbox" id="c-41597462" checked=""/><div class="controls bullet"><span class="by">stmonty</span><span>|</span><a href="#41597926">prev</a><span>|</span><a href="#41596067">next</a><span>|</span><label class="collapse" for="c-41597462">[-]</label><label class="expand" for="c-41597462">[1 more]</label></div><br/><div class="children"><div class="content">This looks awesome. I&#x27;ve had this same exact idea for a build system, but I haven&#x27;t had the time to build it yet. Cool to see someone basically build what I had imagined!</div><br/></div></div><div id="41596067" class="c"><input type="checkbox" id="c-41596067" checked=""/><div class="controls bullet"><span class="by">steeleduncan</span><span>|</span><a href="#41597462">prev</a><span>|</span><a href="#41595913">next</a><span>|</span><label class="collapse" for="c-41596067">[-]</label><label class="expand" for="c-41596067">[3 more]</label></div><br/><div class="children"><div class="content">Looks great, Nix-with-Lua that also supports Windows would be amazing. Two questions if I may<p>- Does this sandbox builds the way flakes do?<p>- What is MinGW used for on Windows? Does this rely on the MinGW userland, or is it just because it would be painful to write a full bootstrap for a windows compiler while also developing Zb?<p>Also, its great to see the live-bootstrap in there. I love the purity of how Guix&#x27;s packages are built, and I like the idea Zb will be that way from the start</div><br/><div id="41596578" class="c"><input type="checkbox" id="c-41596578" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596067">parent</a><span>|</span><a href="#41595913">next</a><span>|</span><label class="collapse" for="c-41596578">[-]</label><label class="expand" for="c-41596578">[2 more]</label></div><br/><div class="children"><div class="content">Nix sandboxes derivation runs on Linux even without flakes, and I&#x27;m planning on implementing that, yes: <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;29">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;29</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;31">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;31</a><p>MinGW is used to build Lua using cgo. I&#x27;d like to remove that part, see <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;28">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;28</a> I haven&#x27;t started the userspace for Windows yet (<a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;6">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;6</a>), but I suspect that it will be more &quot;download the Visual C++ compiler binary from this URL&quot; than the Linux source bootstrap.<p>Yeah, I&#x27;m happy with live-bootstrap, too! I tried emulating Guix&#x27;s bootstrap, but it depended a little too much on Scheme for me to use as-is. live-bootstrap has mostly worked out-of-the-box, which was a great validation test for this approach.</div><br/><div id="41599868" class="c"><input type="checkbox" id="c-41599868" checked=""/><div class="controls bullet"><span class="by">steeleduncan</span><span>|</span><a href="#41596067">root</a><span>|</span><a href="#41596578">parent</a><span>|</span><a href="#41595913">next</a><span>|</span><label class="collapse" for="c-41599868">[-]</label><label class="expand" for="c-41599868">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for answering and I really hope it works out. A Nix alternative with less friction would be very welcome!</div><br/></div></div></div></div></div></div><div id="41595913" class="c"><input type="checkbox" id="c-41595913" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#41596067">prev</a><span>|</span><a href="#41596411">next</a><span>|</span><label class="collapse" for="c-41595913">[-]</label><label class="expand" for="c-41595913">[3 more]</label></div><br/><div class="children"><div class="content">One request that I would make of a project like this is to support distributed builds out of the box. Like, really basic support for identical builder hosts (this is much easier now than in the past with containers) and caching of targets. Otherwise, this looks great! Big fan of the choice of Lua, though the modifications to strings might make it difficult to onboard new users depending on how the modification was made.</div><br/><div id="41596172" class="c"><input type="checkbox" id="c-41596172" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41595913">parent</a><span>|</span><a href="#41596625">next</a><span>|</span><label class="collapse" for="c-41596172">[-]</label><label class="expand" for="c-41596172">[1 more]</label></div><br/><div class="children"><div class="content">Yup, remote building and caching is on my radar. I expect it will work much in the same way Nix does now, although I&#x27;m being a bit more deliberate in creating an RPC layer so build coordinators and other such tools are more straightforward to build.<p>The string tweak is transparent to users broadly speaking. IME with Nix this thing works the way people expect (i.e if you use a dependency variable in your build target, it adds a dependency).</div><br/></div></div><div id="41596625" class="c"><input type="checkbox" id="c-41596625" checked=""/><div class="controls bullet"><span class="by">Glacia</span><span>|</span><a href="#41595913">parent</a><span>|</span><a href="#41596172">prev</a><span>|</span><a href="#41596411">next</a><span>|</span><label class="collapse" for="c-41596625">[-]</label><label class="expand" for="c-41596625">[1 more]</label></div><br/><div class="children"><div class="content">Xmake?</div><br/></div></div></div></div><div id="41596411" class="c"><input type="checkbox" id="c-41596411" checked=""/><div class="controls bullet"><span class="by">droelf</span><span>|</span><a href="#41595913">prev</a><span>|</span><a href="#41596555">next</a><span>|</span><label class="collapse" for="c-41596411">[-]</label><label class="expand" for="c-41596411">[2 more]</label></div><br/><div class="children"><div class="content">Cool that this space is getting more attention - I just came from the reproducible builds summit in Hamburg. We&#x27;re working on similar low level build system tools with rattler-build and pixi. Would love to have a chat and potentially figure out if collaboration is possible.</div><br/><div id="41596753" class="c"><input type="checkbox" id="c-41596753" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596411">parent</a><span>|</span><a href="#41596555">next</a><span>|</span><label class="collapse" for="c-41596753">[-]</label><label class="expand" for="c-41596753">[1 more]</label></div><br/><div class="children"><div class="content">Cool! Contact info is in my profile and on my website. :)</div><br/></div></div></div></div><div id="41596555" class="c"><input type="checkbox" id="c-41596555" checked=""/><div class="controls bullet"><span class="by">greener_grass</span><span>|</span><a href="#41596411">prev</a><span>|</span><a href="#41596382">next</a><span>|</span><label class="collapse" for="c-41596555">[-]</label><label class="expand" for="c-41596555">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m excited by this!<p>Quick question: if the build graph can be dynamic (I think they call it monadic in the paper), then does it become impossible to reason about the build statically? I think this is why Bazel has a static graph and why it scales so well.</div><br/><div id="41596744" class="c"><input type="checkbox" id="c-41596744" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596555">parent</a><span>|</span><a href="#41597595">next</a><span>|</span><label class="collapse" for="c-41596744">[-]</label><label class="expand" for="c-41596744">[3 more]</label></div><br/><div class="children"><div class="content">According to Build systems à la carte, &quot;it is not possible
to express dynamic dependencies in [Bazel&#x27;s] user-defined build rules; however some of the pre-defined build rules require dynamic dependencies and the internal build engine can cope with them by using a restarting task scheduler, which is similar to that of Excel but does not use the calc chain.&quot; (p6)<p>IME import-from-derivation and similar in Nix is usually used for importing build configurations from remote repositories. Bazel has a repository rule system that is similar: <a href="https:&#x2F;&#x2F;bazel.build&#x2F;extending&#x2F;repo" rel="nofollow">https:&#x2F;&#x2F;bazel.build&#x2F;extending&#x2F;repo</a><p>So to answer your question: yes from the strictest possible definition, but in practice, I believe the tradeoffs are acceptable.</div><br/><div id="41596841" class="c"><input type="checkbox" id="c-41596841" checked=""/><div class="controls bullet"><span class="by">Ericson2314</span><span>|</span><a href="#41596555">root</a><span>|</span><a href="#41596744">parent</a><span>|</span><a href="#41597595">next</a><span>|</span><label class="collapse" for="c-41596841">[-]</label><label class="expand" for="c-41596841">[2 more]</label></div><br/><div class="children"><div class="content">You should look at Nix&#x27;s experimental dynamic derivations, which provide functionality entirely at the level of derivation language &#x2F; store layer.</div><br/><div id="41597044" class="c"><input type="checkbox" id="c-41597044" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596555">root</a><span>|</span><a href="#41596841">parent</a><span>|</span><a href="#41597595">next</a><span>|</span><label class="collapse" for="c-41597044">[-]</label><label class="expand" for="c-41597044">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! Thanks, hadn&#x27;t seen that yet. (For anyone else curious, the RFC is here: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;rfcs&#x2F;0092-plan-dynamism.md">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;rfcs&#x2F;0092-plan-dyn...</a>)</div><br/></div></div></div></div></div></div><div id="41597595" class="c"><input type="checkbox" id="c-41597595" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#41596555">parent</a><span>|</span><a href="#41596744">prev</a><span>|</span><a href="#41596382">next</a><span>|</span><label class="collapse" for="c-41597595">[-]</label><label class="expand" for="c-41597595">[1 more]</label></div><br/><div class="children"><div class="content">Buck2 can express dynamic dependencies, so it can capture dynamic compilation problems like C++ modules, OCaml&#x2F;Fortran modules, etc. in &quot;user space&quot; without built-in support like Bazel requires. The secret to why is twofold. One, your internal build graph can be fully dynamic at the implementation level; rather, it&#x27;s a matter of how much expressivity you expose to the user in letting them leverage and control the dynamic graph. Just because you have a Monad, doesn&#x27;t mean you have to have to expose it. You can just expose an Applicative.<p>And actually, if you take the view that build systems are a form of staged programming, then <i>all build systems</i> are monadic because the first stage is building the graph at all, and the second stage is evaluating it. Make, for example, has to parse the Makefiles, and during this phase it constructs the graph... dynamically! Based on the input source code! Rather it is during the second phase done later, when rules are evaluated, and that is now the time when the graph is static and all edges must be known. See some notes from Neil Mitchell about that.[1]<p>The other key is in a system like Buck or Bazel, there are actually two graphs that are clearly defined. There is the target graph where you have abstract dependencies between things (a cxx_binary depends on a cxx_library), and there is the action graph (the command gcc must run before the ld command can run).<p>You cannot have dynamic nodes in the <i>target graph</i>. Target graph construction MUST be deterministic and &quot;complete&quot; in the sense it captures all nodes. This is really important because it breaks features like target determination: given a list of changed files, what changed targets need to be rebuilt? You cannot know the complete list of targets when the target graph is dynamic, and evaluation can produce new nodes. That&#x27;s what everyone means when they say it&#x27;s &quot;scalable.&quot; That you can detect, only given a list of input files from version control, what the difference between these two build graphs are. And then you can go build those targets exactly and skip everything else. So, if you make a small change to a monumentally sized codebase, you don&#x27;t have to rebuild everything. Just a very small, locally impacted part of the whole pie.<p>In other words, &quot;small changes to the code should have small changes in the resulting build.&quot; That&#x27;s incremental programming in a nutshell.<p>OK, so there&#x27;s no target graph dynamism. But you <i>can</i> have dynamic actions in the <i>action</i> graph, where the edges to those dynamic actions are well defined. For example, compiling an OCaml module first requires you to build a .m file, then read it, then run some set of commands in an order dictated by the .m file. The output is an .a file. So you always know the in&#x2F;out edges for these actions, but you just don&#x27;t know what order you need to run compiler commands in. That dynamic action can be captured without breaking the other stuff. There are some more notes from Neil about this.[2]<p>Under this interpretation, Nix also defines a static target graph in the sense that every store path&#x2F;derivation is a node represented as term in the pure, lazy lambda calculus (with records). When you evaluate a Nix expression, it produces a fully closed term, and terms that are already evaluated previously (packaged and built) are shared and reused. The sharing is how &quot;target determination&quot; is achieved; you actually evaluate everything and anything that is shared is &quot;free.&quot;<p>And under this same interpretation, the pure subset of Zb programs should, by definition, also construct a static target graph. It&#x27;s not enough to just sandboxing I&#x2F;O but also some other things; for example if you construct hash tables with undefined iteration order you might screw the pooch somewhere down the line. Or you could just make up things out of thin air I guess. But if you restrict yourself to the pure subset of Zb programs, you should in theory be fine (and that pure subset is arguably the actual valuable, useful subset, so it&#x27;s maybe fine.)<p>[1] <a href="https:&#x2F;&#x2F;ndmitchell.com&#x2F;downloads&#x2F;paper-implementing_applicative_build_systems_monadically-01_jan_2022.pdf" rel="nofollow">https:&#x2F;&#x2F;ndmitchell.com&#x2F;downloads&#x2F;paper-implementing_applicat...</a><p>[2] <a href="https:&#x2F;&#x2F;ndmitchell.com&#x2F;downloads&#x2F;slides-somewhat_dynamic_build_systems-07_mar_2024.pdf" rel="nofollow">https:&#x2F;&#x2F;ndmitchell.com&#x2F;downloads&#x2F;slides-somewhat_dynamic_bui...</a></div><br/></div></div></div></div><div id="41596382" class="c"><input type="checkbox" id="c-41596382" checked=""/><div class="controls bullet"><span class="by">alxmng</span><span>|</span><a href="#41596555">prev</a><span>|</span><a href="#41595934">next</a><span>|</span><label class="collapse" for="c-41596382">[-]</label><label class="expand" for="c-41596382">[3 more]</label></div><br/><div class="children"><div class="content">Did you consider writing a nicer language that compiles to Nix? A &quot;friendly&quot; tool on the outside with Nix inside.</div><br/><div id="41596452" class="c"><input type="checkbox" id="c-41596452" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596382">parent</a><span>|</span><a href="#41596460">next</a><span>|</span><label class="collapse" for="c-41596452">[-]</label><label class="expand" for="c-41596452">[1 more]</label></div><br/><div class="children"><div class="content">Yup, that was how I built the prototype: <a href="https:&#x2F;&#x2F;www.zombiezen.com&#x2F;blog&#x2F;2024&#x2F;06&#x2F;zb-build-system-prototype&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.zombiezen.com&#x2F;blog&#x2F;2024&#x2F;06&#x2F;zb-build-system-proto...</a><p>The last commit using that approach was <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;tree&#x2F;558c6f52b7ef915428c9af9a9997edca84dfd831">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;tree&#x2F;558c6f52b7ef915428c9af9...</a> if you want to try it out. And actually, I haven&#x27;t touched the Lua frontend much since I swapped out the backend: the .drv files it writes are the same.<p>The motivation behind replacing the backend was content-addressibility and Windows support, which have been slow to be adopted in Nix core.</div><br/></div></div><div id="41596460" class="c"><input type="checkbox" id="c-41596460" checked=""/><div class="controls bullet"><span class="by">Rucadi</span><span>|</span><a href="#41596382">parent</a><span>|</span><a href="#41596452">prev</a><span>|</span><a href="#41595934">next</a><span>|</span><label class="collapse" for="c-41596460">[-]</label><label class="expand" for="c-41596460">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think nix is that awful, while there are some tasks that are more difficult or can be a little bit verbose (if you want to play a lot with the attribute sets &#x2F; lists 
or string manip) When using nix most of the time you&#x27;ll end up just writing bash or using it as a templating language.</div><br/></div></div></div></div><div id="41595934" class="c"><input type="checkbox" id="c-41595934" checked=""/><div class="controls bullet"><span class="by">bsnnkv</span><span>|</span><a href="#41596382">prev</a><span>|</span><a href="#41595680">next</a><span>|</span><label class="collapse" for="c-41595934">[-]</label><label class="expand" for="c-41595934">[2 more]</label></div><br/><div class="children"><div class="content">You had my interest at Windows support! I&#x27;ll carve out some time this weekend to see if I can write a build for komorebi</div><br/><div id="41596585" class="c"><input type="checkbox" id="c-41596585" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41595934">parent</a><span>|</span><a href="#41595680">next</a><span>|</span><label class="collapse" for="c-41596585">[-]</label><label class="expand" for="c-41596585">[1 more]</label></div><br/><div class="children"><div class="content">Nice! It might be a little too rough until I&#x27;ve got a working C compiler for Windows: <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;6">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;6</a> (and Linux for that matter: <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;30">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;30</a>)</div><br/></div></div></div></div><div id="41595680" class="c"><input type="checkbox" id="c-41595680" checked=""/><div class="controls bullet"><span class="by">ramon156</span><span>|</span><a href="#41595934">prev</a><span>|</span><a href="#41596900">next</a><span>|</span><label class="collapse" for="c-41595680">[-]</label><label class="expand" for="c-41595680">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d definitely write a build systen in lua, looks promising!</div><br/></div></div><div id="41596900" class="c"><input type="checkbox" id="c-41596900" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#41595680">prev</a><span>|</span><a href="#41597409">next</a><span>|</span><label class="collapse" for="c-41596900">[-]</label><label class="expand" for="c-41596900">[4 more]</label></div><br/><div class="children"><div class="content">How do you pronounce &quot;Zb&quot;? Zee-bee?</div><br/><div id="41596977" class="c"><input type="checkbox" id="c-41596977" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596900">parent</a><span>|</span><a href="#41597409">next</a><span>|</span><label class="collapse" for="c-41596977">[-]</label><label class="expand" for="c-41596977">[3 more]</label></div><br/><div class="children"><div class="content">Heh, I think I need to add something to the README. I&#x27;ve been pronouncing it as &quot;zeeb&quot; in my head as in the first syllable Zebesian Space Pirate from Metroid, but TIL that that&#x27;s canonically &quot;Zay-bay-zee-uhn&quot; so idk.<p>Naming is hard.</div><br/><div id="41597685" class="c"><input type="checkbox" id="c-41597685" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#41596900">root</a><span>|</span><a href="#41596977">parent</a><span>|</span><a href="#41597409">next</a><span>|</span><label class="collapse" for="c-41597685">[-]</label><label class="expand" for="c-41597685">[2 more]</label></div><br/><div class="children"><div class="content">I kinda dig zeeb! Naming is hard. Really awesome project by the way! Should have mentioned that first. Build systems are neat. I&#x27;ve always wanted to try building a build system, in a &quot;learn how it works&quot; sense, not so much &quot;yet another build tool&quot;.</div><br/><div id="41597993" class="c"><input type="checkbox" id="c-41597993" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596900">root</a><span>|</span><a href="#41597685">parent</a><span>|</span><a href="#41597409">next</a><span>|</span><label class="collapse" for="c-41597993">[-]</label><label class="expand" for="c-41597993">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! And go for it, it&#x27;s a good learning experience! It&#x27;s a really interesting problem domain and there&#x27;s a lot of different directions you can take it.</div><br/></div></div></div></div></div></div></div></div><div id="41597409" class="c"><input type="checkbox" id="c-41597409" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41596900">prev</a><span>|</span><a href="#41596182">next</a><span>|</span><label class="collapse" for="c-41597409">[-]</label><label class="expand" for="c-41597409">[1 more]</label></div><br/><div class="children"><div class="content">From the Build Systems à la Carte paper:<p><i>Topological.</i> The topological scheduler pre-computes a linear order of tasks, which when
followed, ensures the build result is correct regardless of the initial store. Given a task description
and the output key, you can compute the linear order by first finding the (acyclic) graph of the
key’s reachable dependencies, and then computing a topological sort. However this rules out dynamic dependencies.<p><i>Restarting.</i> To handle dynamic dependencies we can use the following approach: build
tasks in an arbitrary initial order, discovering their dependencies on the fly; whenever a task
calls fetch on an out-of-date key dep, abort the task, and switch to building the dependency dep;
eventually the previously aborted task is restarted and makes further progress thanks to dep now
being up to date. This approach requires a way to abort tasks that have failed due to out-of-date
dependencies. It is also not minimal in the sense that a task may start, do some meaningful work,
and then abort.<p><i>Suspending.</i> An alternative approach, utilised by the busy build system and Shake,
is to simply build dependencies when they are requested, suspending the currently running task.
By combining that with tracking the keys that have already been built, one can obtain a minimal
build system with dynamic dependencies. This approach requires that a task may be started and then suspended until another task is complete. Suspending can be done with cheap green threads and blocking (the original approach
of Shake) or using continuation-passing style (what Shake currently does).</div><br/></div></div><div id="41596182" class="c"><input type="checkbox" id="c-41596182" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41597409">prev</a><span>|</span><label class="collapse" for="c-41596182">[-]</label><label class="expand" for="c-41596182">[4 more]</label></div><br/><div class="children"><div class="content">Interesting. I feel like I would have gone with Starlark over Lua, but I guess it&#x27;s good to have options.<p>Does it support sandboxing?</div><br/><div id="41596596" class="c"><input type="checkbox" id="c-41596596" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596182">parent</a><span>|</span><a href="#41596771">next</a><span>|</span><label class="collapse" for="c-41596596">[-]</label><label class="expand" for="c-41596596">[2 more]</label></div><br/><div class="children"><div class="content">Not yet, but I&#x27;ve hacked up most of the Linux sandboxing: <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;29">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;29</a><p>I want to introduce Windows sandboxing, too, but I&#x27;m not as confident about how to do that: <a href="https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;31">https:&#x2F;&#x2F;github.com&#x2F;256lights&#x2F;zb&#x2F;issues&#x2F;31</a></div><br/><div id="41596990" class="c"><input type="checkbox" id="c-41596990" checked=""/><div class="controls bullet"><span class="by">zombiezen</span><span>|</span><a href="#41596182">root</a><span>|</span><a href="#41596596">parent</a><span>|</span><a href="#41596771">next</a><span>|</span><label class="collapse" for="c-41596990">[-]</label><label class="expand" for="c-41596990">[1 more]</label></div><br/><div class="children"><div class="content">Oh and as for Starlark, I went into more detail over in this thread: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41596426">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41596426</a></div><br/></div></div></div></div><div id="41596771" class="c"><input type="checkbox" id="c-41596771" checked=""/><div class="controls bullet"><span class="by">israrkhan</span><span>|</span><a href="#41596182">parent</a><span>|</span><a href="#41596596">prev</a><span>|</span><label class="collapse" for="c-41596771">[-]</label><label class="expand" for="c-41596771">[1 more]</label></div><br/><div class="children"><div class="content">You need bazel if you need starlark &amp; sandboxing</div><br/></div></div></div></div></div></div></div></div></div></body></html>