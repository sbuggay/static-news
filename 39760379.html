<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710925267191" as="style"/><link rel="stylesheet" href="styles.css?v=1710925267191"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://hrmacbeth.github.io/math2001/index.html">The Mechanics of Proof</a> <span class="domain">(<a href="https://hrmacbeth.github.io">hrmacbeth.github.io</a>)</span></div><div class="subtext"><span>segfaultbuserr</span> | <span>25 comments</span></div><br/><div><div id="39763949" class="c"><input type="checkbox" id="c-39763949" checked=""/><div class="controls bullet"><span class="by">hackandthink</span><span>|</span><a href="#39763977">next</a><span>|</span><label class="collapse" for="c-39763949">[-]</label><label class="expand" for="c-39763949">[1 more]</label></div><br/><div class="children"><div class="content">Some mathematicians are afraid of being censored or only becoming mechanics.<p>&quot;What some people like to call the progress of mathematics has always consisted in the subversion of paradigms. Pierre Deligne made this point in a lecture on Voevodsky’s univalent foundations: he said it reminds him of Orwell’s Newspeak, where the ideal was to have a language where it is impossible to express heretical thoughts.&quot;<p><a href="https:&#x2F;&#x2F;siliconreckoner.substack.com&#x2F;p&#x2F;the-central-dogma-of-mathematical" rel="nofollow">https:&#x2F;&#x2F;siliconreckoner.substack.com&#x2F;p&#x2F;the-central-dogma-of-...</a></div><br/></div></div><div id="39761112" class="c"><input type="checkbox" id="c-39761112" checked=""/><div class="controls bullet"><span class="by">derbOac</span><span>|</span><a href="#39763977">prev</a><span>|</span><a href="#39760628">next</a><span>|</span><label class="collapse" for="c-39761112">[-]</label><label class="expand" for="c-39761112">[10 more]</label></div><br/><div class="children"><div class="content">One thing that&#x27;s always been a little unclear to me is this:<p>With proofs, I normally think of the &quot;work&quot; as being in the derivation of a statement that is shown to be true. That is, the value is in deriving a new true statement that was not previously known to be true.<p>In the examples I usually see for using something like Lean, there&#x27;s a true statement given, and the question is how to prove it. Although there are reasons this could be interesting, it doesn&#x27;t seem quite as valuable as deriving some truth statement that wasn&#x27;t previously known to be true.<p>Can something like Lean be used generatively, to generate multiple true statements given a set of assumptions?</div><br/><div id="39762170" class="c"><input type="checkbox" id="c-39762170" checked=""/><div class="controls bullet"><span class="by">tshaddox</span><span>|</span><a href="#39761112">parent</a><span>|</span><a href="#39763238">next</a><span>|</span><label class="collapse" for="c-39762170">[-]</label><label class="expand" for="c-39762170">[1 more]</label></div><br/><div class="children"><div class="content">I would think you’d generally need to have something interesting in mind that you think might be true before bothering to prove it. Certainly you’ll need it to be interesting if you want anyone else to notice. It’s trivial to generate an endless tree of true statements by just tree searching with whatever valid operators your proof system has.</div><br/></div></div><div id="39763238" class="c"><input type="checkbox" id="c-39763238" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#39761112">parent</a><span>|</span><a href="#39762170">prev</a><span>|</span><a href="#39761305">next</a><span>|</span><label class="collapse" for="c-39763238">[-]</label><label class="expand" for="c-39763238">[1 more]</label></div><br/><div class="children"><div class="content">Question is: Is something true or not?  If you can prove it then you know it is true. If you cannot prove it all you know is you cannot prove it. It still could be true, or false. So the best you can do is to TRY to prove it, and&#x2F;or  try to prove its negation.<p>As pointed out by others generating random true statements is not very interesting because you can generate such trivially by appending &amp;&amp; true as many times as you want to the statement.<p>So in general you always want to prove something, because only that can tell you something about what is true and what is not.</div><br/></div></div><div id="39761305" class="c"><input type="checkbox" id="c-39761305" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#39761112">parent</a><span>|</span><a href="#39763238">prev</a><span>|</span><a href="#39761659">next</a><span>|</span><label class="collapse" for="c-39761305">[-]</label><label class="expand" for="c-39761305">[6 more]</label></div><br/><div class="children"><div class="content">How do you know the statement is true if you have not proven it to be true?<p>Proof of true statements and discovery of new true statements go hand in hand. This is also because the proof tells you something about why the theorem is interesting. Generating multiple true statements given a set of assumptions is not very interesting per se.<p>But yes, something like, &quot;in your situation, this is an interesting conjecture&quot; would be nice in a proof assistant. Maybe AI will get us there.</div><br/><div id="39761764" class="c"><input type="checkbox" id="c-39761764" checked=""/><div class="controls bullet"><span class="by">derbOac</span><span>|</span><a href="#39761112">root</a><span>|</span><a href="#39761305">parent</a><span>|</span><a href="#39761659">next</a><span>|</span><label class="collapse" for="c-39761764">[-]</label><label class="expand" for="c-39761764">[5 more]</label></div><br/><div class="children"><div class="content">I guess in my research (which has involved proofs), I haven&#x27;t always known where a proof would lead a priori? I don&#x27;t usually start with a statement I want and then look to prove it, it&#x27;s more like I explore various derivations to see where they lead (probably with some kind of hunches), and then some of them end up in an interesting place.<p>But yes, I agree some kind of AI-ish guided suggestion process would be interesting. You&#x27;d have to quantify &quot;interesting&quot; probably to build such a thing but I suspect it could be done.</div><br/><div id="39763830" class="c"><input type="checkbox" id="c-39763830" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#39761112">root</a><span>|</span><a href="#39761764">parent</a><span>|</span><a href="#39762235">next</a><span>|</span><label class="collapse" for="c-39763830">[-]</label><label class="expand" for="c-39763830">[1 more]</label></div><br/><div class="children"><div class="content">Maybe what you are saying is that you want to use the proof assistant like a computer algebra system. You apply correct transformations, and so you are at the same time proving and exploring.<p>I would agree that this aspect is underdeveloped in proof assistants. At the root of it is that people believe that logic is different from algebra, while it really isn&#x27;t.</div><br/></div></div><div id="39762235" class="c"><input type="checkbox" id="c-39762235" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#39761112">root</a><span>|</span><a href="#39761764">parent</a><span>|</span><a href="#39763830">prev</a><span>|</span><a href="#39761804">next</a><span>|</span><label class="collapse" for="c-39762235">[-]</label><label class="expand" for="c-39762235">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s like solving a maze or exploring a dungeon. Exploring from the start might find something interesting, but having an interesting goal in mind can suggest a possible path and is a guarantee that the proof is rewarding. Whereas untargeted exploration can end up somewhere more surprising and fun, but also less likely to generate anything interesting.</div><br/></div></div><div id="39761804" class="c"><input type="checkbox" id="c-39761804" checked=""/><div class="controls bullet"><span class="by">couchand</span><span>|</span><a href="#39761112">root</a><span>|</span><a href="#39761764">parent</a><span>|</span><a href="#39762235">prev</a><span>|</span><a href="#39762298">next</a><span>|</span><label class="collapse" for="c-39761804">[-]</label><label class="expand" for="c-39761804">[1 more]</label></div><br/><div class="children"><div class="content">This is an interesting perspective.  I&#x27;ve recently been playing with sequent calculus, and I&#x27;m writing everything upside-down because I&#x27;m starting with the statement to prove and applying the derivations mechanically to produce the proof tree.<p>But hearing how you approach proofs makes the standard directionality make much more sense.</div><br/></div></div><div id="39762298" class="c"><input type="checkbox" id="c-39762298" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#39761112">root</a><span>|</span><a href="#39761764">parent</a><span>|</span><a href="#39761804">prev</a><span>|</span><a href="#39761659">next</a><span>|</span><label class="collapse" for="c-39762298">[-]</label><label class="expand" for="c-39762298">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t usually start with a statement I want and then look to prove it, it&#x27;s more like I explore various derivations to see where they lead (probably with some kind of hunches), and then some of them end up in an interesting place.<p>You can work this way in Lean. You need to have a goal to make the engine happy, but there&#x27;s no need for the goal to be true -- you can just do something like<p><pre><code>    have h : ∀x, ∀y, x = y := by
      -- h is not true, but in the attempt to prove it,
      -- we can do whatever we want.
      -- If we find something interesting, we can redefine h</code></pre></div><br/></div></div></div></div></div></div><div id="39761659" class="c"><input type="checkbox" id="c-39761659" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#39761112">parent</a><span>|</span><a href="#39761305">prev</a><span>|</span><a href="#39760628">next</a><span>|</span><label class="collapse" for="c-39761659">[-]</label><label class="expand" for="c-39761659">[1 more]</label></div><br/><div class="children"><div class="content">Yes, easily, but they are infinite and, unlike a given statement, mostly uninteresting.</div><br/></div></div></div></div><div id="39760628" class="c"><input type="checkbox" id="c-39760628" checked=""/><div class="controls bullet"><span class="by">ufferop</span><span>|</span><a href="#39761112">prev</a><span>|</span><a href="#39761727">next</a><span>|</span><label class="collapse" for="c-39760628">[-]</label><label class="expand" for="c-39760628">[1 more]</label></div><br/><div class="children"><div class="content">I much prefer this resource over the official offerings.<p><a href="https:&#x2F;&#x2F;lean-lang.org&#x2F;theorem_proving_in_lean4&#x2F;title_page.html" rel="nofollow">https:&#x2F;&#x2F;lean-lang.org&#x2F;theorem_proving_in_lean4&#x2F;title_page.ht...</a><p>You may need to use them in tandem, but I have found it much more productive to jump to the “number theory” section of TFA then to step through the official resource.<p>This resource also has its code online: <a href="https:&#x2F;&#x2F;github.com&#x2F;hrmacbeth&#x2F;math2001&#x2F;tree&#x2F;main&#x2F;Math2001">https:&#x2F;&#x2F;github.com&#x2F;hrmacbeth&#x2F;math2001&#x2F;tree&#x2F;main&#x2F;Math2001</a><p>One major ommission from TFA is lean&#x27;s built in package manager and package builder lake: <a href="https:&#x2F;&#x2F;lean-lang.org&#x2F;lean4&#x2F;doc&#x2F;setup.html#lake" rel="nofollow">https:&#x2F;&#x2F;lean-lang.org&#x2F;lean4&#x2F;doc&#x2F;setup.html#lake</a></div><br/></div></div><div id="39761727" class="c"><input type="checkbox" id="c-39761727" checked=""/><div class="controls bullet"><span class="by">buzzin_</span><span>|</span><a href="#39760628">prev</a><span>|</span><a href="#39760809">next</a><span>|</span><label class="collapse" for="c-39761727">[-]</label><label class="expand" for="c-39761727">[4 more]</label></div><br/><div class="children"><div class="content">What is going on in the third example?<p>&quot;Let a,b,m,n be integers, and suppose that b^2 = 2a^2 ...&quot;<p>So, 
(b^2)&#x2F;(a^2)=2
b&#x2F;a = sqrt(2)<p>or, in other words, sqrt(2) is rational.  then it goes and uses this in the rest of the example.</div><br/><div id="39762211" class="c"><input type="checkbox" id="c-39762211" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#39761727">parent</a><span>|</span><a href="#39763195">next</a><span>|</span><label class="collapse" for="c-39762211">[-]</label><label class="expand" for="c-39762211">[1 more]</label></div><br/><div class="children"><div class="content">You are referring to
<a href="https:&#x2F;&#x2F;hrmacbeth.github.io&#x2F;math2001&#x2F;01_Proofs_by_Calculation.html#id6" rel="nofollow">https:&#x2F;&#x2F;hrmacbeth.github.io&#x2F;math2001&#x2F;01_Proofs_by_Calculatio...</a><p>That&#x27;s hilarious. It&#x27;s the brick joke, in math.
 <a href="https:&#x2F;&#x2F;plantsarethestrangestpeople.blogspot.com&#x2F;2012&#x2F;01&#x2F;brick-joke.html?m=1" rel="nofollow">https:&#x2F;&#x2F;plantsarethestrangestpeople.blogspot.com&#x2F;2012&#x2F;01&#x2F;bri...</a>
It&#x27;s a great example, made terrible (for teaching) because the punchline is never explained.<p>Your excerpt left out key information, which is the secondary hypothesis that 
am+bn=1<p>Hint: what are a and b? I won&#x27;t wait for you to find values that satisfy the hypotheses.<p>It&#x27;s the same flavor as: assume a=b+1, and b=a+1. Then a-b=b-a
You can prove that p=&gt;q, sometimes, even if p is false. (Especially if p is false!)<p>A later chapter provides the punchline.<p><a href="https:&#x2F;&#x2F;hrmacbeth.github.io&#x2F;math2001&#x2F;07_Number_Theory.html#the-square-root-of-two" rel="nofollow">https:&#x2F;&#x2F;hrmacbeth.github.io&#x2F;math2001&#x2F;07_Number_Theory.html#t...</a></div><br/></div></div><div id="39763195" class="c"><input type="checkbox" id="c-39763195" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#39761727">parent</a><span>|</span><a href="#39762211">prev</a><span>|</span><a href="#39762309">next</a><span>|</span><label class="collapse" for="c-39763195">[-]</label><label class="expand" for="c-39763195">[1 more]</label></div><br/><div class="children"><div class="content">It is correct, true, and funny. Funny in the way that it creates a seeming contradiction and your brain feels good when it solves it.<p>Nothing special is going on there, but it may be distracting if the joke doesn&#x27;t land.</div><br/></div></div><div id="39762309" class="c"><input type="checkbox" id="c-39762309" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#39761727">parent</a><span>|</span><a href="#39763195">prev</a><span>|</span><a href="#39760809">next</a><span>|</span><label class="collapse" for="c-39762309">[-]</label><label class="expand" for="c-39762309">[1 more]</label></div><br/><div class="children"><div class="content">The point is that in order to prove something by contradiction, you must assume something that turns out to be false and see what you can derive from that assumption (ideally a contradiction). The last link in the sibling comments does indeed contain proofs that the given premise is impossible. Think about how you know that the square root of 2 is irrational.</div><br/></div></div></div></div><div id="39760809" class="c"><input type="checkbox" id="c-39760809" checked=""/><div class="controls bullet"><span class="by">jml7c5</span><span>|</span><a href="#39761727">prev</a><span>|</span><a href="#39761556">next</a><span>|</span><label class="collapse" for="c-39760809">[-]</label><label class="expand" for="c-39760809">[2 more]</label></div><br/><div class="children"><div class="content">See also the Lean Game Server at <a href="https:&#x2F;&#x2F;adam.math.hhu.de&#x2F;" rel="nofollow">https:&#x2F;&#x2F;adam.math.hhu.de&#x2F;</a> , and in particular the &quot;Natural Number Game&quot; (for Lean 4!), which has done the rounds on HN a few times.<p>Does anyone know of a Lean book that builds up the basics from absolutely nothing, not even the Lean standard library? I&#x27;m curious about the foundations that lie just above the language.</div><br/><div id="39760926" class="c"><input type="checkbox" id="c-39760926" checked=""/><div class="controls bullet"><span class="by">ykonstant</span><span>|</span><a href="#39760809">parent</a><span>|</span><a href="#39761556">next</a><span>|</span><label class="collapse" for="c-39760926">[-]</label><label class="expand" for="c-39760926">[1 more]</label></div><br/><div class="children"><div class="content">Your best bet lies with the introductory Functional Programming in Lean: <a href="https:&#x2F;&#x2F;lean-lang.org&#x2F;functional_programming_in_lean&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lean-lang.org&#x2F;functional_programming_in_lean&#x2F;</a></div><br/></div></div></div></div><div id="39761556" class="c"><input type="checkbox" id="c-39761556" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#39760809">prev</a><span>|</span><a href="#39760964">next</a><span>|</span><label class="collapse" for="c-39761556">[-]</label><label class="expand" for="c-39761556">[3 more]</label></div><br/><div class="children"><div class="content">Anyone who wants to learn more about the calculational proof style as it applies to computing science would do very well to read Dijkstra.</div><br/><div id="39761608" class="c"><input type="checkbox" id="c-39761608" checked=""/><div class="controls bullet"><span class="by">vector_spaces</span><span>|</span><a href="#39761556">parent</a><span>|</span><a href="#39760964">next</a><span>|</span><label class="collapse" for="c-39761608">[-]</label><label class="expand" for="c-39761608">[2 more]</label></div><br/><div class="children"><div class="content">What by Dijkstra, specifically?</div><br/><div id="39761923" class="c"><input type="checkbox" id="c-39761923" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#39761556">root</a><span>|</span><a href="#39761608">parent</a><span>|</span><a href="#39760964">next</a><span>|</span><label class="collapse" for="c-39761923">[-]</label><label class="expand" for="c-39761923">[1 more]</label></div><br/><div class="children"><div class="content">This[1] contains an explanation of his proof format. More generally many of the later monographs from that archive have interesting proofs. Also the book Predicate Calculus and Program Semantics is chock full of proofs.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD13xx&#x2F;EWD1300.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;users&#x2F;EWD&#x2F;transcriptions&#x2F;EWD13xx&#x2F;E...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>