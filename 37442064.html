<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694250058644" as="style"/><link rel="stylesheet" href="styles.css?v=1694250058644"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://discourse.julialang.org/t/julia-mojo-mandelbrot-benchmark/103638">Julia and Mojo Mandelbrot Benchmark</a> <span class="domain">(<a href="https://discourse.julialang.org">discourse.julialang.org</a>)</span></div><div class="subtext"><span>npalli</span> | <span>45 comments</span></div><br/><div><div id="37442442" class="c"><input type="checkbox" id="c-37442442" checked=""/><div class="controls bullet"><span class="by">torrance</span><span>|</span><a href="#37443200">next</a><span>|</span><label class="collapse" for="c-37442442">[-]</label><label class="expand" for="c-37442442">[4 more]</label></div><br/><div class="children"><div class="content">Whilst the Julia version currently beats Mojo, I fully expect both to approach basically the same performance with enough tinkering, and for that performance to be on par with C or Fortran.<p>A more interesting question is which version is more elegant, ‘obvious’ and maintainable. (Deeply familiar with both, but money is on Julia).</div><br/><div id="37443012" class="c"><input type="checkbox" id="c-37443012" checked=""/><div class="controls bullet"><span class="by">sa-code</span><span>|</span><a href="#37442442">parent</a><span>|</span><a href="#37443200">next</a><span>|</span><label class="collapse" for="c-37443012">[-]</label><label class="expand" for="c-37443012">[3 more]</label></div><br/><div class="children"><div class="content">IMO the reason Julia gets to be this fast is because of LLVM, and the guy who created LLVM is also the creator of Mojo so there is something to be said about that</div><br/><div id="37443386" class="c"><input type="checkbox" id="c-37443386" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#37442442">root</a><span>|</span><a href="#37443012">parent</a><span>|</span><a href="#37443041">next</a><span>|</span><label class="collapse" for="c-37443386">[-]</label><label class="expand" for="c-37443386">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that Julia gets to be this fast because the language design was optimized for performance from the beginning, by clever use of its type hierarchy and multiple dispatch for compilation into very specific and efficient machine code (plus a thousand other little optimizations like constant propagation, auto-vectorization, etc.)<p>LLVM helps with its own optimizations, but more and more of those optimizations are being moved to the Julia side nowadays (since the language has more semantic understanding of the code and can do better optimizations). I believe the main thing LLVM helps with is portability across many platforms, without having to write individual backends for each one.</div><br/></div></div></div></div></div></div><div id="37443200" class="c"><input type="checkbox" id="c-37443200" checked=""/><div class="controls bullet"><span class="by">anoy8888</span><span>|</span><a href="#37442442">prev</a><span>|</span><a href="#37442418">next</a><span>|</span><label class="collapse" for="c-37443200">[-]</label><label class="expand" for="c-37443200">[4 more]</label></div><br/><div class="children"><div class="content">It is still fascinating that lisp languages lost to python for AI and data processing and now pretty much everything else. In a perfect world , we would be using lisp or lisp like languages for everything</div><br/><div id="37443424" class="c"><input type="checkbox" id="c-37443424" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#37443200">parent</a><span>|</span><a href="#37443430">next</a><span>|</span><label class="collapse" for="c-37443424">[-]</label><label class="expand" for="c-37443424">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean by lisp-like?<p>If you mean “primarily uses S-expressions” then I guess I dont really see why that’s so important to you.<p>If you mean a language that is semantically similar to lisps and learned a lot of the important lessons that Lisp taught the programming world, I think Julia is one of the Lispiest languages in this space right now.<p>The syntax may not be S-expression based on the surface, but our Exprs are actually essentially just S-espressions so writing syntactic macros is very easy. The language is about as dynamic as is possible without major performance concessions, and is very heavily influenced by a lot of design ideas from the CLOS, with some features missing but also some cool features CLOS doesnt have.</div><br/></div></div><div id="37443430" class="c"><input type="checkbox" id="c-37443430" checked=""/><div class="controls bullet"><span class="by">dgb23</span><span>|</span><a href="#37443200">parent</a><span>|</span><a href="#37443424">prev</a><span>|</span><a href="#37443330">next</a><span>|</span><label class="collapse" for="c-37443430">[-]</label><label class="expand" for="c-37443430">[1 more]</label></div><br/><div class="children"><div class="content">For reference:<p>Julia is basically a Lisp under the hood. From playing around with it, it seems like the REPL experience is up there too.</div><br/></div></div><div id="37443330" class="c"><input type="checkbox" id="c-37443330" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#37443200">parent</a><span>|</span><a href="#37443430">prev</a><span>|</span><a href="#37442418">next</a><span>|</span><label class="collapse" for="c-37443330">[-]</label><label class="expand" for="c-37443330">[1 more]</label></div><br/><div class="children"><div class="content">And dialects of Lisp a-likes will fight each other. <a href="https:&#x2F;&#x2F;locklessinc.com&#x2F;articles&#x2F;why_lisp_failed&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;locklessinc.com&#x2F;articles&#x2F;why_lisp_failed&#x2F;</a></div><br/></div></div></div></div><div id="37442418" class="c"><input type="checkbox" id="c-37442418" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#37443200">prev</a><span>|</span><a href="#37442822">next</a><span>|</span><label class="collapse" for="c-37442418">[-]</label><label class="expand" for="c-37442418">[4 more]</label></div><br/><div class="children"><div class="content">In my opinion, the issue that will make more of a difference in the long run is Mojo&#x27;s first-class support for AoT compiled binaries (as well as JIT compilation).<p>Julia&#x27;s poor AoT support (with small binaries) is a major Achilles heel. I really wish that the Julia developers had taken that more seriously earlier on.</div><br/><div id="37442510" class="c"><input type="checkbox" id="c-37442510" checked=""/><div class="controls bullet"><span class="by">arbitrandomuser</span><span>|</span><a href="#37442418">parent</a><span>|</span><a href="#37443037">next</a><span>|</span><label class="collapse" for="c-37442510">[-]</label><label class="expand" for="c-37442510">[2 more]</label></div><br/><div class="children"><div class="content">If anyone is interested in compiling small binaries with Julia do check out staticcompiler.jl and supporting statictools.jl that manages to produce small binaries without the Julia runtime , 
Ofcourse it&#x27;s a wip , and not fully mature , I&#x27;m just putting it out there for people to know.
There&#x27;s some really cool demonstrations come out of this ...<p>Wasm fluid simulation in Julia:
<a href="https:&#x2F;&#x2F;alexander-barth.github.io&#x2F;FluidSimDemo-WebAssembly&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;alexander-barth.github.io&#x2F;FluidSimDemo-WebAssembly&#x2F;</a><p>Differential equations demo in the browser:
<a href="https:&#x2F;&#x2F;tshort.github.io&#x2F;Lorenz-WebAssembly-Model.jl&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;tshort.github.io&#x2F;Lorenz-WebAssembly-Model.jl&#x2F;</a><p>Someone even setup Julia to run on AVR mcus for Arduino
(Directly using gpucompiler which statictools uses to compile to binaries):<p><a href="https:&#x2F;&#x2F;seelengrab.github.io&#x2F;articles&#x2F;Running%20Julia%20baremetal%20on%20an%20Arduino&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;seelengrab.github.io&#x2F;articles&#x2F;Running%20Julia%20bare...</a></div><br/><div id="37442535" class="c"><input type="checkbox" id="c-37442535" checked=""/><div class="controls bullet"><span class="by">ubj</span><span>|</span><a href="#37442418">root</a><span>|</span><a href="#37442510">parent</a><span>|</span><a href="#37443037">next</a><span>|</span><label class="collapse" for="c-37442535">[-]</label><label class="expand" for="c-37442535">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I was aware of StaticCompiler.jl. I wish it was more mature.<p>Static compilation is indeed possible with Julia. But it&#x27;s very limited in its capabilities and certainly not as effortless as a simple `mojo build myfile.mojo`.</div><br/></div></div></div></div><div id="37443037" class="c"><input type="checkbox" id="c-37443037" checked=""/><div class="controls bullet"><span class="by">Certhas</span><span>|</span><a href="#37442418">parent</a><span>|</span><a href="#37442510">prev</a><span>|</span><a href="#37442822">next</a><span>|</span><label class="collapse" for="c-37443037">[-]</label><label class="expand" for="c-37443037">[1 more]</label></div><br/><div class="children"><div class="content">In the long run I think the determining factors will be:<p>Connection to the Python ecosystem. Python remains the number 1 teaching language by a large margin.<p>AI funding. If they can get the buy in from the AI community that Julia never got, they have the resources to engineer around any challenges faced.<p>Solid foundation in modern language design, and with that,  a focus on correct code produced by larger teams.</div><br/></div></div></div></div><div id="37442822" class="c"><input type="checkbox" id="c-37442822" checked=""/><div class="controls bullet"><span class="by">turndown</span><span>|</span><a href="#37442418">prev</a><span>|</span><a href="#37442309">next</a><span>|</span><label class="collapse" for="c-37442822">[-]</label><label class="expand" for="c-37442822">[1 more]</label></div><br/><div class="children"><div class="content">IMO this is just not a great example on either side. As others have pointed out, the Julia implementation was refined to be 8x faster. The Mojo code has to run the CPython interpreter to run numpy.</div><br/></div></div><div id="37442309" class="c"><input type="checkbox" id="c-37442309" checked=""/><div class="controls bullet"><span class="by">WantonQuantum</span><span>|</span><a href="#37442822">prev</a><span>|</span><a href="#37442641">next</a><span>|</span><label class="collapse" for="c-37442309">[-]</label><label class="expand" for="c-37442309">[7 more]</label></div><br/><div class="children"><div class="content">Be sure to check out the comments on the page - lots of optimisations for the julia code.</div><br/><div id="37442524" class="c"><input type="checkbox" id="c-37442524" checked=""/><div class="controls bullet"><span class="by">ayhanfuat</span><span>|</span><a href="#37442309">parent</a><span>|</span><a href="#37442641">next</a><span>|</span><label class="collapse" for="c-37442524">[-]</label><label class="expand" for="c-37442524">[6 more]</label></div><br/><div class="children"><div class="content">Not if you want to avoid condescending &quot;I cannot look at the Python code my eyes hurt&quot; comments. Good to know the Julia community hasn&#x27;t made any progress in that regard, though.</div><br/><div id="37442911" class="c"><input type="checkbox" id="c-37442911" checked=""/><div class="controls bullet"><span class="by">drt5b7j</span><span>|</span><a href="#37442309">root</a><span>|</span><a href="#37442524">parent</a><span>|</span><a href="#37442732">next</a><span>|</span><label class="collapse" for="c-37442911">[-]</label><label class="expand" for="c-37442911">[2 more]</label></div><br/><div class="children"><div class="content">In that long list of replies, that&#x27;s the reply you chose to comment on? Maybe you yourself don&#x27;t have much substance...?</div><br/><div id="37443455" class="c"><input type="checkbox" id="c-37443455" checked=""/><div class="controls bullet"><span class="by">ayhanfuat</span><span>|</span><a href="#37442309">root</a><span>|</span><a href="#37442911">parent</a><span>|</span><a href="#37442732">next</a><span>|</span><label class="collapse" for="c-37443455">[-]</label><label class="expand" for="c-37443455">[1 more]</label></div><br/><div class="children"><div class="content">Personally insulting someone because they pointed out something negative about the community kind of supports what I said.</div><br/></div></div></div></div><div id="37442732" class="c"><input type="checkbox" id="c-37442732" checked=""/><div class="controls bullet"><span class="by">amj7e</span><span>|</span><a href="#37442309">root</a><span>|</span><a href="#37442524">parent</a><span>|</span><a href="#37442911">prev</a><span>|</span><a href="#37442733">next</a><span>|</span><label class="collapse" for="c-37442732">[-]</label><label class="expand" for="c-37442732">[1 more]</label></div><br/><div class="children"><div class="content">Well, still a much better community than most where having an opinion is considered a sin.</div><br/></div></div><div id="37442733" class="c"><input type="checkbox" id="c-37442733" checked=""/><div class="controls bullet"><span class="by">ballooney</span><span>|</span><a href="#37442309">root</a><span>|</span><a href="#37442524">parent</a><span>|</span><a href="#37442732">prev</a><span>|</span><a href="#37442785">next</a><span>|</span><label class="collapse" for="c-37442733">[-]</label><label class="expand" for="c-37442733">[1 more]</label></div><br/><div class="children"><div class="content">I only see one of those among 32 constructive ones - a rather better ratio than this site!</div><br/></div></div><div id="37442785" class="c"><input type="checkbox" id="c-37442785" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#37442309">root</a><span>|</span><a href="#37442524">parent</a><span>|</span><a href="#37442733">prev</a><span>|</span><a href="#37442641">next</a><span>|</span><label class="collapse" for="c-37442785">[-]</label><label class="expand" for="c-37442785">[1 more]</label></div><br/><div class="children"><div class="content">So Julia has --pedantic by default ?</div><br/></div></div></div></div></div></div><div id="37442641" class="c"><input type="checkbox" id="c-37442641" checked=""/><div class="controls bullet"><span class="by">eddtests</span><span>|</span><a href="#37442309">prev</a><span>|</span><a href="#37442786">next</a><span>|</span><label class="collapse" for="c-37442641">[-]</label><label class="expand" for="c-37442641">[4 more]</label></div><br/><div class="children"><div class="content">Mojo released an example of their new language which will mean readability and simplicity compared to the Python implementation will surely have been a requirement… I get someone within Modular doing some horrific looking low-level Mojo stuff could get it much quicker.</div><br/><div id="37443431" class="c"><input type="checkbox" id="c-37443431" checked=""/><div class="controls bullet"><span class="by">eigenspace</span><span>|</span><a href="#37442641">parent</a><span>|</span><a href="#37442987">next</a><span>|</span><label class="collapse" for="c-37443431">[-]</label><label class="expand" for="c-37443431">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mojo released an example of their new language which will mean readability and simplicity compared to the Python implementation will surely have been a requirement…<p>Did you read the Mojo code? It’s very messy and low-level dealing with explicit SIMD intrinsics and such.</div><br/></div></div><div id="37442987" class="c"><input type="checkbox" id="c-37442987" checked=""/><div class="controls bullet"><span class="by">oivey</span><span>|</span><a href="#37442641">parent</a><span>|</span><a href="#37443431">prev</a><span>|</span><a href="#37443068">next</a><span>|</span><label class="collapse" for="c-37442987">[-]</label><label class="expand" for="c-37442987">[1 more]</label></div><br/><div class="children"><div class="content">The Mojo one is already doing some pretty horrific low-level stuff with fairly manual SIMD. That’s why it was faster than Julia in the initial example, and the edge is lost when a couple of posters did similar things for Julia.</div><br/></div></div><div id="37443068" class="c"><input type="checkbox" id="c-37443068" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#37442641">parent</a><span>|</span><a href="#37442987">prev</a><span>|</span><a href="#37442786">next</a><span>|</span><label class="collapse" for="c-37443068">[-]</label><label class="expand" for="c-37443068">[1 more]</label></div><br/><div class="children"><div class="content">We have yet to see Mojo do any &quot;sufficiently smart compiler&quot; optimizations that Julia or similar languages don&#x27;t already do. The Mojo code in the blog post does the same ugly optimizations to get good SIMD as the Julia code.<p>Convincing LLVM to vectorize is still a problem in both languages. I do hope Mojo can make some headway there in the future. Especially since with MLIR they might be able to capture some higher level semantics Julia can&#x27;t.</div><br/></div></div></div></div><div id="37442786" class="c"><input type="checkbox" id="c-37442786" checked=""/><div class="controls bullet"><span class="by">shric</span><span>|</span><a href="#37442641">prev</a><span>|</span><a href="#37442486">next</a><span>|</span><label class="collapse" for="c-37442786">[-]</label><label class="expand" for="c-37442786">[1 more]</label></div><br/><div class="children"><div class="content">It would have been more appropriate to render a Julia set in Julia.</div><br/></div></div><div id="37442486" class="c"><input type="checkbox" id="c-37442486" checked=""/><div class="controls bullet"><span class="by">moelf</span><span>|</span><a href="#37442786">prev</a><span>|</span><a href="#37442739">next</a><span>|</span><label class="collapse" for="c-37442486">[-]</label><label class="expand" for="c-37442486">[1 more]</label></div><br/><div class="children"><div class="content">For a similar &quot;benchmark&quot; (also Mandelbrot) but took place in Jax repo discussion: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;jax&#x2F;discussions&#x2F;11078#discussioncomment-3051481">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;jax&#x2F;discussions&#x2F;11078#discussionco...</a></div><br/></div></div><div id="37442739" class="c"><input type="checkbox" id="c-37442739" checked=""/><div class="controls bullet"><span class="by">classner</span><span>|</span><a href="#37442486">prev</a><span>|</span><a href="#37442883">next</a><span>|</span><label class="collapse" for="c-37442739">[-]</label><label class="expand" for="c-37442739">[3 more]</label></div><br/><div class="children"><div class="content">Does anyone know of examples of Mojo for GPU computations? The website makes multiple claims about it being able to run seamlessly on the GPU but I couldn&#x27;t find any documentation on it...</div><br/><div id="37442769" class="c"><input type="checkbox" id="c-37442769" checked=""/><div class="controls bullet"><span class="by">sa-code</span><span>|</span><a href="#37442739">parent</a><span>|</span><a href="#37442883">next</a><span>|</span><label class="collapse" for="c-37442769">[-]</label><label class="expand" for="c-37442769">[2 more]</label></div><br/><div class="children"><div class="content">The language is really new, it only supports amd64 Linux at the moment (at least publicly)</div><br/><div id="37442850" class="c"><input type="checkbox" id="c-37442850" checked=""/><div class="controls bullet"><span class="by">classner</span><span>|</span><a href="#37442739">root</a><span>|</span><a href="#37442769">parent</a><span>|</span><a href="#37442883">next</a><span>|</span><label class="collapse" for="c-37442850">[-]</label><label class="expand" for="c-37442850">[1 more]</label></div><br/><div class="children"><div class="content">I am aware it&#x27;s new, but they state for example on their website:<p>&gt; Write Python or scale all the way down to the metal. Program the multitude of low-level AI hardware. No C++ or CUDA required.<p>I just thought they might already have something to show on that end...</div><br/></div></div></div></div></div></div><div id="37442883" class="c"><input type="checkbox" id="c-37442883" checked=""/><div class="controls bullet"><span class="by">BaculumMeumEst</span><span>|</span><a href="#37442739">prev</a><span>|</span><a href="#37442636">next</a><span>|</span><label class="collapse" for="c-37442883">[-]</label><label class="expand" for="c-37442883">[2 more]</label></div><br/><div class="children"><div class="content">there are so many fractal benchmarks floating around, but i’ve never seen any cool interactive fractal applications, eg interactive visualizations that smoothly redraw changes over time, or respond to input.<p>has anyone seen programs like that?</div><br/><div id="37443125" class="c"><input type="checkbox" id="c-37443125" checked=""/><div class="controls bullet"><span class="by">thanatos519</span><span>|</span><a href="#37442883">parent</a><span>|</span><a href="#37442636">next</a><span>|</span><label class="collapse" for="c-37443125">[-]</label><label class="expand" for="c-37443125">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;xaos-project&#x2F;XaoS">https:&#x2F;&#x2F;github.com&#x2F;xaos-project&#x2F;XaoS</a> is still awesome but could really use a GPU backend :)</div><br/></div></div></div></div><div id="37442636" class="c"><input type="checkbox" id="c-37442636" checked=""/><div class="controls bullet"><span class="by">rvz</span><span>|</span><a href="#37442883">prev</a><span>|</span><a href="#37442316">next</a><span>|</span><label class="collapse" for="c-37442636">[-]</label><label class="expand" for="c-37442636">[3 more]</label></div><br/><div class="children"><div class="content">As long as you can copy and paste Python code to Mojo and it is 1:1 compatible with all your existing libraries and is hundreds of times faster than Python, that is much better than wasting time rewriting it in another language that is 8x faster than Mojo (in its first release) with hand-optimizations from Julia language experts.<p>I expect Mojo&#x27;s first release to be fast enough that it would get the Python folks using it over Julia and that the next Mojo release or future ones will get another 8x or 10x faster.<p>The same outcome happened with Bun 1.0 and already claimed the top spot in speed and compatibility in the node ecosystem in its first release and it isn&#x27;t even done yet.<p>The least amount of effort to get something done much faster wins by default.</div><br/><div id="37442738" class="c"><input type="checkbox" id="c-37442738" checked=""/><div class="controls bullet"><span class="by">stellalo</span><span>|</span><a href="#37442636">parent</a><span>|</span><a href="#37442754">next</a><span>|</span><label class="collapse" for="c-37442738">[-]</label><label class="expand" for="c-37442738">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The least amount of effort to get something done much faster wins by default.<p>And then you’re stuck with a proprietary language “subscribe to download”? Not sure it’s the least amount of effort honestly.</div><br/></div></div><div id="37442754" class="c"><input type="checkbox" id="c-37442754" checked=""/><div class="controls bullet"><span class="by">liuliu</span><span>|</span><a href="#37442636">parent</a><span>|</span><a href="#37442738">prev</a><span>|</span><a href="#37442316">next</a><span>|</span><label class="collapse" for="c-37442754">[-]</label><label class="expand" for="c-37442754">[1 more]</label></div><br/><div class="children"><div class="content">The Mojo code in this post cannot be run in Python. So in this case, you wrote code for Mojo language, not Python.</div><br/></div></div></div></div><div id="37442316" class="c"><input type="checkbox" id="c-37442316" checked=""/><div class="controls bullet"><span class="by">orliesaurus</span><span>|</span><a href="#37442636">prev</a><span>|</span><label class="collapse" for="c-37442316">[-]</label><label class="expand" for="c-37442316">[10 more]</label></div><br/><div class="children"><div class="content">tldr: in the test&#x27;s first implementation mojo was faster but then the refactored and made the julia code faster by 8x over mojo.<p>that&#x27;s cool but mojo literally just came out</div><br/><div id="37442467" class="c"><input type="checkbox" id="c-37442467" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#37442316">parent</a><span>|</span><a href="#37442431">next</a><span>|</span><label class="collapse" for="c-37442467">[-]</label><label class="expand" for="c-37442467">[7 more]</label></div><br/><div class="children"><div class="content">We have seen many languages cycle in popularity, but Julia is one of the few high-level languages that could actually match... or in some cases exceed C&#x2F;C++ performance.<p>There are always tradeoffs, and it usually takes a few weeks for people to come to terms with why Julia is unique.<p>Definitely falls into the fun category. =)</div><br/><div id="37442870" class="c"><input type="checkbox" id="c-37442870" checked=""/><div class="controls bullet"><span class="by">eoverride</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37442467">parent</a><span>|</span><a href="#37442431">next</a><span>|</span><label class="collapse" for="c-37442870">[-]</label><label class="expand" for="c-37442870">[6 more]</label></div><br/><div class="children"><div class="content">How can Julia exceed C&#x2F;C++ performance?</div><br/><div id="37443159" class="c"><input type="checkbox" id="c-37443159" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37442870">parent</a><span>|</span><a href="#37442983">next</a><span>|</span><label class="collapse" for="c-37443159">[-]</label><label class="expand" for="c-37443159">[1 more]</label></div><br/><div class="children"><div class="content">In general, parallelization was a messy kludge in older languages originally intended for single CPU machine contexts.  Additionally, many modern languages inherited the same old library ecosystem issues with Simplified Wrapper and Interface Generator template  code (Julia also offers similar support).<p>Only a few like Go ecosystem developers tended to take the time to refactor many useful core tools into clean parallelized versions in the native ecosystem, and to a lesser extent Julia devs seem to focus on similar goals due to the inherent ease of doing this correctly.<p>When one compares the complexity of a broadcast operator version of some function in Julia, and the amount of effort needed to achieve similar results in pure C&#x2F;C++... the answer of where the efficiency gains arise should be self evident.<p>One could always embed a Julia programs inside a c wrapper if it makes you happier.  =)<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=GZEOb6p1yvU">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=GZEOb6p1yvU</a></div><br/></div></div><div id="37442983" class="c"><input type="checkbox" id="c-37442983" checked=""/><div class="controls bullet"><span class="by">markkitti</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37442870">parent</a><span>|</span><a href="#37443159">prev</a><span>|</span><a href="#37443004">next</a><span>|</span><label class="collapse" for="c-37442983">[-]</label><label class="expand" for="c-37442983">[3 more]</label></div><br/><div class="children"><div class="content">C is not the fastest language. Fortran can often beat them because is has non-aliasing function arguments and does not treat arrays like pointers.<p><a href="https:&#x2F;&#x2F;fortran-lang.discourse.group&#x2F;t&#x2F;fortran-is-faster-than-c&#x2F;5058" rel="nofollow noreferrer">https:&#x2F;&#x2F;fortran-lang.discourse.group&#x2F;t&#x2F;fortran-is-faster-tha...</a></div><br/><div id="37443168" class="c"><input type="checkbox" id="c-37443168" checked=""/><div class="controls bullet"><span class="by">RossBencina</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37442983">parent</a><span>|</span><a href="#37443004">next</a><span>|</span><label class="collapse" for="c-37443168">[-]</label><label class="expand" for="c-37443168">[2 more]</label></div><br/><div class="children"><div class="content">I do not dispute that C is not the fastest language. However C99 has the `restrict` keyword, which when combined with strict aliasing rules gives non-aliasing function arguments (I believe).</div><br/><div id="37443224" class="c"><input type="checkbox" id="c-37443224" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37443168">parent</a><span>|</span><a href="#37443004">next</a><span>|</span><label class="collapse" for="c-37443224">[-]</label><label class="expand" for="c-37443224">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be cowed without evidence friend. You are not wrong. =)<p>gcc is notoriously:<p>1. inefficient compared to the Intel or LLVM compiler<p>2. nondeterministic with -O3, which is why most people use g++ to check the code... and even then all bets are off on some hardware.<p>3. thrashes ram layouts, and slowly chokes to death if used as intended.<p>It comes down to the use-case, but fortran has killed too many to trust anywhere. =)</div><br/></div></div></div></div></div></div><div id="37443004" class="c"><input type="checkbox" id="c-37443004" checked=""/><div class="controls bullet"><span class="by">patagurbon</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37442870">parent</a><span>|</span><a href="#37442983">prev</a><span>|</span><a href="#37442431">next</a><span>|</span><label class="collapse" for="c-37443004">[-]</label><label class="expand" for="c-37443004">[1 more]</label></div><br/><div class="children"><div class="content">There are a few cases where it&#x27;s easier to get LLVM to generate certain code I imagine. Semantic things like aliasing, in lining, and type information.<p>In general though it&#x27;s just a question of which hoops you have to jump through for which language comparing C&#x2F;C++&#x2F;Julia&#x2F;Fortran when using LLVM</div><br/></div></div></div></div></div></div><div id="37442431" class="c"><input type="checkbox" id="c-37442431" checked=""/><div class="controls bullet"><span class="by">CraftingLinks</span><span>|</span><a href="#37442316">parent</a><span>|</span><a href="#37442467">prev</a><span>|</span><label class="collapse" for="c-37442431">[-]</label><label class="expand" for="c-37442431">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what the presented benchmarks show, though.</div><br/><div id="37442514" class="c"><input type="checkbox" id="c-37442514" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#37442316">root</a><span>|</span><a href="#37442431">parent</a><span>|</span><label class="collapse" for="c-37442514">[-]</label><label class="expand" for="c-37442514">[1 more]</label></div><br/><div class="children"><div class="content">What do you mean by that?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>