<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714122122619" as="style"/><link rel="stylesheet" href="styles.css?v=1714122122619"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mitxela.com/projects/ddc-oled">DDC OLED (2022)</a> <span class="domain">(<a href="https://mitxela.com">mitxela.com</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>22 comments</span></div><br/><div><div id="40162714" class="c"><input type="checkbox" id="c-40162714" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40162276">next</a><span>|</span><label class="collapse" for="c-40162714">[-]</label><label class="expand" for="c-40162714">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time:<p><i>The smallest and worst HDMI display</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30869140">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30869140</a> - March 2022 (162 comments)</div><br/></div></div><div id="40162276" class="c"><input type="checkbox" id="c-40162276" checked=""/><div class="controls bullet"><span class="by">sgroppino</span><span>|</span><a href="#40162714">prev</a><span>|</span><a href="#40161121">next</a><span>|</span><label class="collapse" for="c-40162276">[-]</label><label class="expand" for="c-40162276">[1 more]</label></div><br/><div class="children"><div class="content">Nice one :D reminds me of my little project back in 2020 with a raspberry pi and a similar type of display... <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25566132">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25566132</a></div><br/></div></div><div id="40161121" class="c"><input type="checkbox" id="c-40161121" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40162276">prev</a><span>|</span><a href="#40160973">next</a><span>|</span><label class="collapse" for="c-40161121">[-]</label><label class="expand" for="c-40161121">[3 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a video about making an OLED device from scratch, and all the physics involved:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=qg8pMUd-tSk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=qg8pMUd-tSk</a></div><br/><div id="40162995" class="c"><input type="checkbox" id="c-40162995" checked=""/><div class="controls bullet"><span class="by">kurthr</span><span>|</span><a href="#40161121">parent</a><span>|</span><a href="#40162378">next</a><span>|</span><label class="collapse" for="c-40162995">[-]</label><label class="expand" for="c-40162995">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this more foundational information. It&#x27;s a bit simplified since most displays are flexible now and multi-color, but at least it doesn&#x27;t ignore the entire OLED material, TFTs, and display driver IC as if the digital communication to the controller was the most important or even remotely common solution.</div><br/></div></div></div></div><div id="40160973" class="c"><input type="checkbox" id="c-40160973" checked=""/><div class="controls bullet"><span class="by">Liftyee</span><span>|</span><a href="#40161121">prev</a><span>|</span><label class="collapse" for="c-40160973">[-]</label><label class="expand" for="c-40160973">[16 more]</label></div><br/><div class="children"><div class="content">Fun little project, wonder if DDC could be used as a way to control devices like HDMI capture cards or KVM switches? Honestly surprised that bare i2c interface is exposed to the OS and not hidden by some firmware...</div><br/><div id="40161720" class="c"><input type="checkbox" id="c-40161720" checked=""/><div class="controls bullet"><span class="by">myself248</span><span>|</span><a href="#40160973">parent</a><span>|</span><a href="#40161217">next</a><span>|</span><label class="collapse" for="c-40161720">[-]</label><label class="expand" for="c-40161720">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about that, but I&#x27;ve used it to reprogram the i2c EEPROM in SFP transceivers. Cooking up a little board to make that easy, actually; I&#x27;ll publish the files as soon as I prove the prototype works.</div><br/></div></div><div id="40161217" class="c"><input type="checkbox" id="c-40161217" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#40160973">parent</a><span>|</span><a href="#40161720">prev</a><span>|</span><a href="#40161095">next</a><span>|</span><label class="collapse" for="c-40161217">[-]</label><label class="expand" for="c-40161217">[2 more]</label></div><br/><div class="children"><div class="content">it&#x27;s hidden on most windows drivers.<p>on Linux it&#x27;s exposed and have user tools for most standard things. it&#x27;s infuriating how changing the settings on random external displays is easier than most integrated laptop screens.<p>some kvm do abuse that comms channel already. forgot which brand but it completely hijacks it and my brightness hacks wouldn&#x27;t work</div><br/><div id="40164906" class="c"><input type="checkbox" id="c-40164906" checked=""/><div class="controls bullet"><span class="by">extraduder_ire</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161217">parent</a><span>|</span><a href="#40161095">next</a><span>|</span><label class="collapse" for="c-40164906">[-]</label><label class="expand" for="c-40164906">[1 more]</label></div><br/><div class="children"><div class="content">DDC works over HDMI on linux? I switched to a displayport cable because I thought it wouldn&#x27;t, and wanted to use ddcutil for setting brightness. I&#x27;ll have to check that out. It might make the lack of CEC on PCs less annoying.</div><br/></div></div></div></div><div id="40161095" class="c"><input type="checkbox" id="c-40161095" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40160973">parent</a><span>|</span><a href="#40161217">prev</a><span>|</span><label class="collapse" for="c-40161095">[-]</label><label class="expand" for="c-40161095">[12 more]</label></div><br/><div class="children"><div class="content">Yeah, the main issue with I2C for this sort of thing is device discovery. It doesn&#x27;t have any mechanism for it so you would need to magically know your device&#x27;s address.<p>I believe for things like controlling monitors they just hard-code the addresses. I think that&#x27;s how it works anyway. Unfortunately the DDC&#x2F;CI spec is <i>really</i> badly written, incomplete, <i>and</i> full of legacy stuff that nobody actually implements.</div><br/><div id="40164419" class="c"><input type="checkbox" id="c-40164419" checked=""/><div class="controls bullet"><span class="by">metaphor</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161095">parent</a><span>|</span><a href="#40161238">next</a><span>|</span><label class="collapse" for="c-40164419">[-]</label><label class="expand" for="c-40164419">[1 more]</label></div><br/><div class="children"><div class="content">Confusing remark; I haven&#x27;t sleuthed the standard in over a decade, but DDC&#x2F;CI v1.1 (available for free here[1]) § 2.3 makes this abundantly clear:<p>&gt;&gt; <i>The DDC&#x2F;CI display is considered a fixed address display device at adddress 0x6Eh &#x2F; 6Fh, and uses only I2C slave mode to communicate with the host.</i><p>...while § 3.3.1 specifies addresses for external display dependent devices.<p>[1] <a href="https:&#x2F;&#x2F;vesa.org&#x2F;vesa-standards&#x2F;" rel="nofollow">https:&#x2F;&#x2F;vesa.org&#x2F;vesa-standards&#x2F;</a></div><br/></div></div><div id="40161238" class="c"><input type="checkbox" id="c-40161238" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161095">parent</a><span>|</span><a href="#40164419">prev</a><span>|</span><label class="collapse" for="c-40161238">[-]</label><label class="expand" for="c-40161238">[10 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah, the main issue with I2C for this sort of thing is device discovery. It doesn&#x27;t have any mechanism for it so you would need to magically know your device&#x27;s address.<p>The typical address space is 7-bits, so you can just try a transaction to everyone... Or have some convention about what device number the display is?</div><br/><div id="40161938" class="c"><input type="checkbox" id="c-40161938" checked=""/><div class="controls bullet"><span class="by">utensil4778</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161238">parent</a><span>|</span><a href="#40161342">next</a><span>|</span><label class="collapse" for="c-40161938">[-]</label><label class="expand" for="c-40161938">[6 more]</label></div><br/><div class="children"><div class="content">I2C has no concept of a discovery or identification packet. The host can write any data to any address, and you have to already know in advance what address and data structure you need. The device <i>can&#x27;t</i> tell you what its data format is.<p>An I2C transaction begins with a client address, and the host waits for an acknowledge signal that a client has answered the message. That&#x27;s it, that&#x27;s the only standard part. From there, the host <i>typically</i> sends a register address and then some number of data bytes, or the client sends back some number of bytes. What those addresses and bytes mean are totally application-specific. There is no standard at all here.<p>You could absolutely broadcast standard DDC commands to all addresses, but you have no way of knowing what actually happened. You might have turned off one monitor and set another to VGA mode. You might have just crashed some random device on the bus. You have no way to tell.<p>All your host can possibly know is that there is <i>a</i> device at a given address, and it either did or did not send an acknowledge bit after a command. That&#x27;s all the information available to you, and it is not enough to do what you suggest</div><br/><div id="40162326" class="c"><input type="checkbox" id="c-40162326" checked=""/><div class="controls bullet"><span class="by">FredFS456</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161938">parent</a><span>|</span><a href="#40161995">next</a><span>|</span><label class="collapse" for="c-40162326">[-]</label><label class="expand" for="c-40162326">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not technically true - you can probe for I2C devices by only sending a START, an address, waiting for the client device to ACK (or not), and then sending a STOP. I don&#x27;t think the linux kernel driver allows us to do this, but I&#x27;ve implemented this on some microcontrollers with lower-level control over the I2C hardware. It worked on all clients I tried it on.</div><br/><div id="40163747" class="c"><input type="checkbox" id="c-40163747" checked=""/><div class="controls bullet"><span class="by">joezydeco</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40162326">parent</a><span>|</span><a href="#40165373">next</a><span>|</span><label class="collapse" for="c-40163747">[-]</label><label class="expand" for="c-40163747">[2 more]</label></div><br/><div class="children"><div class="content">You can install i2c-tools and run i2cdetect from userspace.<p><a href="https:&#x2F;&#x2F;learn.adafruit.com&#x2F;scanning-i2c-addresses&#x2F;raspberry-pi" rel="nofollow">https:&#x2F;&#x2F;learn.adafruit.com&#x2F;scanning-i2c-addresses&#x2F;raspberry-...</a></div><br/><div id="40166197" class="c"><input type="checkbox" id="c-40166197" checked=""/><div class="controls bullet"><span class="by">rasz</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40163747">parent</a><span>|</span><a href="#40165373">next</a><span>|</span><label class="collapse" for="c-40166197">[-]</label><label class="expand" for="c-40166197">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Warning
This program can confuse your I2C bus, cause data loss and worse!&quot;</div><br/></div></div></div></div><div id="40165373" class="c"><input type="checkbox" id="c-40165373" checked=""/><div class="controls bullet"><span class="by">BobbyTables2</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40162326">parent</a><span>|</span><a href="#40163747">prev</a><span>|</span><a href="#40161995">next</a><span>|</span><label class="collapse" for="c-40165373">[-]</label><label class="expand" for="c-40165373">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, I’ve also done the same.  It’s frustrating how Linux doesn’t allow this.<p>Part of me wonders if all devices actually handle a STOP before the first data byte correctly — without side effects…</div><br/></div></div></div></div><div id="40161995" class="c"><input type="checkbox" id="c-40161995" checked=""/><div class="controls bullet"><span class="by">myself248</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161938">parent</a><span>|</span><a href="#40162326">prev</a><span>|</span><a href="#40161342">next</a><span>|</span><label class="collapse" for="c-40161995">[-]</label><label class="expand" for="c-40161995">[1 more]</label></div><br/><div class="children"><div class="content">In recognition of this chaos, <a href="https:&#x2F;&#x2F;i2cdevices.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;i2cdevices.org&#x2F;</a> is putting together a pretty good list.</div><br/></div></div></div></div><div id="40161342" class="c"><input type="checkbox" id="c-40161342" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161238">parent</a><span>|</span><a href="#40161938">prev</a><span>|</span><label class="collapse" for="c-40161342">[-]</label><label class="expand" for="c-40161342">[3 more]</label></div><br/><div class="children"><div class="content">Problem is: <i>every</i> i2c transaction is a READ or a WRITE. The spec is mum on the semantics of what that means. Some devices will get into a weird state or irrevocably pop data off a FIFO if you READ them (eg: some IMUs). Others take a WRITE, even with no data, to have a non-idempotent meaning (eg: SMBUS). Some devices will not even ACK their address on a READ request unless it is preceded by a write and a RESTART. Basically there is no safe way to scan an i2c bus and be sure you did not modify some state or put some device into some weird state.</div><br/><div id="40164105" class="c"><input type="checkbox" id="c-40164105" checked=""/><div class="controls bullet"><span class="by">buescher</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40161342">parent</a><span>|</span><label class="collapse" for="c-40164105">[-]</label><label class="expand" for="c-40164105">[2 more]</label></div><br/><div class="children"><div class="content">Right.  But if you have a finite space of possible i2c devices it&#x27;s not quite that bad.  You can scan for known addresses and there are frequently mitigations for clogging FIFOs - like clocking out the bus or forcing a reset - that you might have to do anyway, depending on what your failure modes for power sequencing are.  i2c is just fine when it works, but there are reasons why it can be worth spending the extra pins for SPI.</div><br/><div id="40164363" class="c"><input type="checkbox" id="c-40164363" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#40160973">root</a><span>|</span><a href="#40164105">parent</a><span>|</span><label class="collapse" for="c-40164363">[-]</label><label class="expand" for="c-40164363">[1 more]</label></div><br/><div class="children"><div class="content">The post I was replying to was suggesting scanning the bus for any kind of device. That is impossible. I could make a i2c device right now and not tell you how it works. You will have no way to scan for it safely (say I specify that unless the first access to it is a write of 0x55 0xAA, it’ll not talk again, but if it is, the byte sent after 0xAA becomes its i2c address)<p>I have seen devices that respond to address zero, which is against the spec. Stopped nobody.<p>I have seen devices that use the bus arbitration meant for multi-master during a READ to allow only one of them to win after responding to a zero-address read.<p>I’ve used an i2c device that had an additional chip select line for some reason. Unless you lowered that, it would not respond to any traffic on the bus.<p>You cannot even imagine the fucked up shit that happens over i2c<p>There is no safe, generic way to scan an i2c bus. If the world of possible devices is limited, it may be possible. But there is no safe generic way.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>