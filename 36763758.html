<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1689670852196" as="style"/><link rel="stylesheet" href="styles.css?v=1689670852196"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://newatlas.com/electronics/computer-memory-resistive-switching-denser-data-storage/">Computer memory prototype ditches 1s and 0s for denser data storage</a> <span class="domain">(<a href="https://newatlas.com">newatlas.com</a>)</span></div><div class="subtext"><span>DamnInteresting</span> | <span>77 comments</span></div><br/><div><div id="36769607" class="c"><input type="checkbox" id="c-36769607" checked=""/><div class="controls bullet"><span class="by">nomercy400</span><span>|</span><a href="#36767617">next</a><span>|</span><label class="collapse" for="c-36769607">[-]</label><label class="expand" for="c-36769607">[1 more]</label></div><br/><div class="children"><div class="content">0 and 1 are human definitions like time and date. You can define any state to be a 0 and any other to be 1, whether it is flowing electrons, flowing water, on-off light, etc. By doing this you gain a simpler model on which you can reason.<p>You can even expand it to whether a &#x27;neuron&#x27; is firing (1) or not (0). What causes the firing does not matter, may it be digital or analog, discrete or continuous.<p>You want to represent more than two states? Use multiple 1s or 0s, and you can still use the model.<p>Use something else? Now you have to create your own model where you can map your states and state changes, along with all mathematics associated.<p>You can no longer compare a USB &#x27;byte&#x27; with this new model &#x27;byte&#x27;. What even is a &#x27;byte&#x27; in your new model? It&#x27;s like comparing apples and oranges.<p>It usually all depends on how accurately you can measure your states, often limited by the signal-to-noise ratio. When is a 0 really a 0 (signal) and not a 1 (noise).<p>A good example is telecommunications, where the data is sent over an electromagnetic wave (analog, continuous). In the past you could only identify between 32 states, but now due to better sensors you can identify 2048 states, increasing your data density by 64x.
Same goes for HDD and SD card storage.</div><br/></div></div><div id="36767617" class="c"><input type="checkbox" id="c-36767617" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#36769607">prev</a><span>|</span><a href="#36769073">next</a><span>|</span><label class="collapse" for="c-36767617">[-]</label><label class="expand" for="c-36767617">[2 more]</label></div><br/><div class="children"><div class="content">The Intel 8087 math coprocessor (1980) had too much microcode to fit into a standard ROM. It was implemented with a special ROM that stored two bits per transistor by using four different transistor sizes, almost doubling the density. Each value read from the ROM was thresholded to generate two output bits. This technique was also used in the iAPX 432&#x27;s I&#x2F;O processor chip.</div><br/><div id="36768994" class="c"><input type="checkbox" id="c-36768994" checked=""/><div class="controls bullet"><span class="by">yonatan8070</span><span>|</span><a href="#36767617">parent</a><span>|</span><a href="#36769073">next</a><span>|</span><label class="collapse" for="c-36768994">[-]</label><label class="expand" for="c-36768994">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this exactly what modern TLC&#x2F;QLC do?</div><br/></div></div></div></div><div id="36769073" class="c"><input type="checkbox" id="c-36769073" checked=""/><div class="controls bullet"><span class="by">dcow</span><span>|</span><a href="#36767617">prev</a><span>|</span><a href="#36763996">next</a><span>|</span><label class="collapse" for="c-36769073">[-]</label><label class="expand" for="c-36769073">[1 more]</label></div><br/><div class="children"><div class="content">Ah, <i>memristors</i>.<p>I didn&#x27;t know term had fallen out of popularity.<p>These things were all the rage up till about 10 years ago. “The 4th fundamental missing electrical circuit component”: resistor, inductor, capacitor, and.. memristor. We were supposed to build hardware neural nets the size of human brains with these things, and get petabytes of storage in unheard-of densities. What happened?</div><br/></div></div><div id="36763996" class="c"><input type="checkbox" id="c-36763996" checked=""/><div class="controls bullet"><span class="by">failuser</span><span>|</span><a href="#36769073">prev</a><span>|</span><a href="#36766272">next</a><span>|</span><label class="collapse" for="c-36763996">[-]</label><label class="expand" for="c-36763996">[38 more]</label></div><br/><div class="children"><div class="content">Vinyl records also don’t have 0’s and zeroes, it does not make them better than Blu-ray. MLC NAND have more than just 1’s and 0’s, they have 0..7 or even 0..15. 
Does anyone really want to process analog data?</div><br/><div id="36767729" class="c"><input type="checkbox" id="c-36767729" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36764245">next</a><span>|</span><label class="collapse" for="c-36767729">[-]</label><label class="expand" for="c-36767729">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Does anyone really want to process analog data?</i><p>But.. you do all the time. pretty much <i>all the time</i> these binary states are calculated from curves, or approximations. The state isn&#x27;t 1 or 0, its the set of states which make 1 or 0 depending, under error correcting codes, over-sampling, things like manchester encoding.<p>We&#x27;re fundamentally imposing binary on a non-binary state, by making deterministic judgement calls about which side of a divide things fall on, but to do that we have to look at analogue qualities.<p>I like to imagine people who work in VLSI smile at this statement, but at some level its analogue everywhere. It&#x27;s higher-states which get to act like its binary, but they map to an analogue signal substrate.</div><br/></div></div><div id="36764245" class="c"><input type="checkbox" id="c-36764245" checked=""/><div class="controls bullet"><span class="by">mcdonje</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36767729">prev</a><span>|</span><a href="#36765534">next</a><span>|</span><label class="collapse" for="c-36764245">[-]</label><label class="expand" for="c-36764245">[10 more]</label></div><br/><div class="children"><div class="content">1. Vinyl ridges are much larger than DVD lines. Kind of a silly comparison considering the article claims the density of this scheme would exceed what we currently have.<p>2. It appears to not be analog.<p>&gt;An energy barrier is created at the points where the bridges meet the device contacts, and the height of this barrier can be controlled which changes the electrical resistance of the overall material. That in turn is what encodes the data.<p>That seems to indicate they can have a base-n encoding where n is what they can practically achieve with the barrier&#x2F;bridge layering scheme.</div><br/><div id="36768041" class="c"><input type="checkbox" id="c-36768041" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764245">parent</a><span>|</span><a href="#36764570">next</a><span>|</span><label class="collapse" for="c-36768041">[-]</label><label class="expand" for="c-36768041">[1 more]</label></div><br/><div class="children"><div class="content">Where it gets interesteing is laserdisc, since that IS the same size (more or less) as a 12&quot; lP, play time is roughly 30 minutes per side, and the video signal is full analog. The audio is analog + an optional PCM or Dolby Digital signal.<p>Both the audio and video are FM encoded.<p>(Yea, 30 minutes per side is long for an LP, more like 20-22 minutes is typical, but hey, it&#x27;s analog. To a point you could increase playing time by deceasing volume.<p>The most extreme case of this I&#x27;m aware of is &quot;90 minutes with Aurthur Felder and the Boston Pops&quot;, which what it says it is... the first side alone is a hair over 47 minutes).</div><br/></div></div><div id="36764570" class="c"><input type="checkbox" id="c-36764570" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764245">parent</a><span>|</span><a href="#36768041">prev</a><span>|</span><a href="#36764464">next</a><span>|</span><label class="collapse" for="c-36764570">[-]</label><label class="expand" for="c-36764570">[3 more]</label></div><br/><div class="children"><div class="content">Something that&#x27;s continuous is analog. I would even say that the MLC&#x2F;TLC&#x2F;QLC use analog storage to represent multiple bits per site.<p>We would already have something similar with SSD and many more bits&#x2F;levels per site if voltages were precise and stable over time and number of overwrites.<p>An interesting use would be for storing 1-dimensional data. In effect the errors would be minor and not randomized&#x2F;scattered as it would be for digital encodings.</div><br/><div id="36764874" class="c"><input type="checkbox" id="c-36764874" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764570">parent</a><span>|</span><a href="#36764464">next</a><span>|</span><label class="collapse" for="c-36764874">[-]</label><label class="expand" for="c-36764874">[2 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t optane a pretty noticeable leap in voltage stability? They could&#x27;ve eventually pivoted to high density packing if they hadn&#x27;t given up.</div><br/><div id="36765482" class="c"><input type="checkbox" id="c-36765482" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764874">parent</a><span>|</span><a href="#36764464">next</a><span>|</span><label class="collapse" for="c-36765482">[-]</label><label class="expand" for="c-36765482">[1 more]</label></div><br/><div class="children"><div class="content">Optane was never going to reach Flash levels of density. It was always in that awkward zone between DDR4 and Flash. Slower than DDR4 but faster than Flash. More dense than DDR4 but less dense than Flash.<p>It was a failure of marketing and building. Today&#x27;s computers use a team of DRAM (like DDR5) and Flash. (GPU-ram like HBM or GDDR6 are still DRAM fundamentally).</div><br/></div></div></div></div></div></div><div id="36764464" class="c"><input type="checkbox" id="c-36764464" checked=""/><div class="controls bullet"><span class="by">failuser</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764245">parent</a><span>|</span><a href="#36764570">prev</a><span>|</span><a href="#36765534">next</a><span>|</span><label class="collapse" for="c-36764464">[-]</label><label class="expand" for="c-36764464">[5 more]</label></div><br/><div class="children"><div class="content">They claim it’s continuous. If continuous values itself were that great then the vinyl records were great for data storage. The problem with continuous values is noise, durability and precision. You can made vinyl disks with incredibly high precision, but preventing damage and reading back those values is not practical. That’s why even the first analog laser medium had discrete pits and lands instead of a continuous signal.</div><br/><div id="36769625" class="c"><input type="checkbox" id="c-36769625" checked=""/><div class="controls bullet"><span class="by">voldacar</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764464">parent</a><span>|</span><a href="#36764535">next</a><span>|</span><label class="collapse" for="c-36769625">[-]</label><label class="expand" for="c-36769625">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a Japanese company that makes a laser turntable that can play a vinyl record without any physical contact. It&#x27;s pretty cool.</div><br/></div></div><div id="36764535" class="c"><input type="checkbox" id="c-36764535" checked=""/><div class="controls bullet"><span class="by">AnotherGoodName</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764464">parent</a><span>|</span><a href="#36769625">prev</a><span>|</span><a href="#36765534">next</a><span>|</span><label class="collapse" for="c-36764535">[-]</label><label class="expand" for="c-36764535">[3 more]</label></div><br/><div class="children"><div class="content">It can be continuous but still have a limit to data due to noise. In vinyls case the more data you store the higher the error rate (at some point the differences in states is hidden in noise).<p>The data rate from a noisy channel or storage can be derived from Shannon-hartley theorem.<p>This is why the old analogue phones could only do 56k for example.</div><br/><div id="36768978" class="c"><input type="checkbox" id="c-36768978" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764535">parent</a><span>|</span><a href="#36764744">next</a><span>|</span><label class="collapse" for="c-36768978">[-]</label><label class="expand" for="c-36768978">[1 more]</label></div><br/><div class="children"><div class="content">&gt;<i>This is why the old analogue phones could only do 56k for example.</i><p>And somehow, on analogue circuit switch phone call mode, still sounded better with less artifacts than most mobile phone calls!</div><br/></div></div><div id="36764744" class="c"><input type="checkbox" id="c-36764744" checked=""/><div class="controls bullet"><span class="by">failuser</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764535">parent</a><span>|</span><a href="#36768978">prev</a><span>|</span><a href="#36765534">next</a><span>|</span><label class="collapse" for="c-36764744">[-]</label><label class="expand" for="c-36764744">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that’s why I hate their headline.</div><br/></div></div></div></div></div></div></div></div><div id="36765534" class="c"><input type="checkbox" id="c-36765534" checked=""/><div class="controls bullet"><span class="by">dragontamer</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36764245">prev</a><span>|</span><a href="#36766867">next</a><span>|</span><label class="collapse" for="c-36765534">[-]</label><label class="expand" for="c-36765534">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Does anyone really want to process analog data?<p>I mean... maybe we should?<p>All radio waves, such as 802.11, are fundamentally analog data. And then they are converted back into digital with incredible QAM-encoding levels. If you think QLC 4-bits per Flash-cell is big, wait till you see 256-QAM (aka: 8-bits per 802.11 timeslice), or more.<p>I believe I saw some spec for some fiber-optic cable that is 32768-QAM (aka: 15-bits per timeslice).<p>--------<p>Then again, Flash (and other memory) are composed of individual cells. True-analog signals like radio-waves are truly analog, so maybe its not quite the same.<p>But maybe we should think of things like tape or hard-drives as an analog signal. Or maybe not, who knows? I&#x27;m not actually a storage specialist so I don&#x27;t really know.  (Nor am I really in communications, lol).</div><br/><div id="36767623" class="c"><input type="checkbox" id="c-36767623" checked=""/><div class="controls bullet"><span class="by">analog31</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765534">parent</a><span>|</span><a href="#36765612">next</a><span>|</span><label class="collapse" for="c-36767623">[-]</label><label class="expand" for="c-36767623">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Analog&quot; and &quot;digital&quot; do not refer to the physical process of transmission, such as radio waves, but the <i>interpretation</i> of the signal. A digital system has rules for forming and interpreting the signal, so that the transmitted and received messages are identical. These rules typically involve things like signal level thresholds and timing.<p>Well-engineered systems have &quot;noise immunity&quot; meaning that the thresholds are well above the noise floor, making the likelihood of an error negligible.<p>If you hang an oscilloscope probe on a &quot;digital&quot; signal, such as the data lines on a memory chip, it might look like a frightening mess, but so long as the rules are obeyed, data transfer occurs faithfully.<p>In a true analog medium, there&#x27;s no way that the receiver can make out precisely what was sent, and two receivers will get different information.</div><br/><div id="36768012" class="c"><input type="checkbox" id="c-36768012" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36767623">parent</a><span>|</span><a href="#36765612">next</a><span>|</span><label class="collapse" for="c-36768012">[-]</label><label class="expand" for="c-36768012">[1 more]</label></div><br/><div class="children"><div class="content">All mediums are ultimately analog.</div><br/></div></div></div></div><div id="36765612" class="c"><input type="checkbox" id="c-36765612" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765534">parent</a><span>|</span><a href="#36767623">prev</a><span>|</span><a href="#36765782">next</a><span>|</span><label class="collapse" for="c-36765612">[-]</label><label class="expand" for="c-36765612">[3 more]</label></div><br/><div class="children"><div class="content">256+ QAM is there but you will almost never see it in practice unless you’re next to the AP. Wifi7 defines up to 4096 so maybe the economics will drive improvements that didn’t land in 6E APs.</div><br/><div id="36767346" class="c"><input type="checkbox" id="c-36767346" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765612">parent</a><span>|</span><a href="#36766103">next</a><span>|</span><label class="collapse" for="c-36767346">[-]</label><label class="expand" for="c-36767346">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll see it on almost every cableTV channel these days</div><br/></div></div><div id="36766103" class="c"><input type="checkbox" id="c-36766103" checked=""/><div class="controls bullet"><span class="by">tguvot</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765612">parent</a><span>|</span><a href="#36767346">prev</a><span>|</span><a href="#36765782">next</a><span>|</span><label class="collapse" for="c-36766103">[-]</label><label class="expand" for="c-36766103">[1 more]</label></div><br/><div class="children"><div class="content">docsis. up to 16384</div><br/></div></div></div></div><div id="36765782" class="c"><input type="checkbox" id="c-36765782" checked=""/><div class="controls bullet"><span class="by">enkid</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765534">parent</a><span>|</span><a href="#36765612">prev</a><span>|</span><a href="#36766867">next</a><span>|</span><label class="collapse" for="c-36765782">[-]</label><label class="expand" for="c-36765782">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure that Einstein proved that light (including radio) is not, in-fact, analog, but rather has discrete levels of energy in quantum steps.</div><br/><div id="36768285" class="c"><input type="checkbox" id="c-36768285" checked=""/><div class="controls bullet"><span class="by">urinotherapist</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765782">parent</a><span>|</span><a href="#36766943">next</a><span>|</span><label class="collapse" for="c-36768285">[-]</label><label class="expand" for="c-36768285">[1 more]</label></div><br/><div class="children"><div class="content">Light is produced and consumed in quanta (photons) by reguar matter. Light itself is just radio wave. Radiowave has not such limitation. It&#x27;s limitation of atomic particles.</div><br/></div></div><div id="36766943" class="c"><input type="checkbox" id="c-36766943" checked=""/><div class="controls bullet"><span class="by">tlb</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36765782">parent</a><span>|</span><a href="#36768285">prev</a><span>|</span><a href="#36766867">next</a><span>|</span><label class="collapse" for="c-36766943">[-]</label><label class="expand" for="c-36766943">[3 more]</label></div><br/><div class="children"><div class="content">That turns out not to matter, because the noise is always at least several quanta at whatever frequency you’re using so you can’t get close to the quantization limit anyway.</div><br/><div id="36767175" class="c"><input type="checkbox" id="c-36767175" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36766943">parent</a><span>|</span><a href="#36766867">next</a><span>|</span><label class="collapse" for="c-36767175">[-]</label><label class="expand" for="c-36767175">[2 more]</label></div><br/><div class="children"><div class="content">Also our physiological sensory and processing equipment (ie, eyes, ears, brain...) translates analog &#x2F; continuous input into discrete electrical signals; a given neuron fires or doesn&#x27;t.</div><br/><div id="36768181" class="c"><input type="checkbox" id="c-36768181" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36767175">parent</a><span>|</span><a href="#36766867">next</a><span>|</span><label class="collapse" for="c-36768181">[-]</label><label class="expand" for="c-36768181">[1 more]</label></div><br/><div class="children"><div class="content">That’s not how that works.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36766867" class="c"><input type="checkbox" id="c-36766867" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36765534">prev</a><span>|</span><a href="#36765463">next</a><span>|</span><label class="collapse" for="c-36766867">[-]</label><label class="expand" for="c-36766867">[5 more]</label></div><br/><div class="children"><div class="content">I think this is a faulty analogy. The data is still encoded (or, at least, interpreted) as digital data, except that instead of each bit being just 0 or 1, you can have components that represent 0 to n. But each state is still discrete, the only difference is whether representing, say, 0 to 3 requires 2 components (2 bits) or a single component (a qit?).</div><br/><div id="36766927" class="c"><input type="checkbox" id="c-36766927" checked=""/><div class="controls bullet"><span class="by">arcticbull</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36766867">parent</a><span>|</span><a href="#36767091">next</a><span>|</span><label class="collapse" for="c-36766927">[-]</label><label class="expand" for="c-36766927">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that just how MLC NAND works though?<p>Also the article is just describing memristor memory isn&#x27;t it? Intel&#x27;s been shipping Optane memristor based memory (which they deny, but others are skeptical of the denial) for years, so clearly I&#x27;m missing something.</div><br/><div id="36767210" class="c"><input type="checkbox" id="c-36767210" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36766927">parent</a><span>|</span><a href="#36767091">next</a><span>|</span><label class="collapse" for="c-36767210">[-]</label><label class="expand" for="c-36767210">[1 more]</label></div><br/><div class="children"><div class="content">Actually, Intel has discontinued Optane:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;3D_XPoint" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;3D_XPoint</a><p><a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;07&#x2F;29&#x2F;intel_optane_memory_dead&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.theregister.com&#x2F;2022&#x2F;07&#x2F;29&#x2F;intel_optane_memory_d...</a></div><br/></div></div></div></div><div id="36767091" class="c"><input type="checkbox" id="c-36767091" checked=""/><div class="controls bullet"><span class="by">noam_k</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36766867">parent</a><span>|</span><a href="#36766927">prev</a><span>|</span><a href="#36765463">next</a><span>|</span><label class="collapse" for="c-36767091">[-]</label><label class="expand" for="c-36767091">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ... representing, say, 0 to 3 requires 2 components (2 bits) or a single component (a qit?).<p>I think the term you&#x27;re looking for is trit (ternary&#x2F;trinary digit).</div><br/><div id="36767349" class="c"><input type="checkbox" id="c-36767349" checked=""/><div class="controls bullet"><span class="by">Nursie</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36767091">parent</a><span>|</span><a href="#36765463">next</a><span>|</span><label class="collapse" for="c-36767349">[-]</label><label class="expand" for="c-36767349">[1 more]</label></div><br/><div class="children"><div class="content">A trit is 0,1,2, no? Tri-state.</div><br/></div></div></div></div></div></div><div id="36765463" class="c"><input type="checkbox" id="c-36765463" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36766867">prev</a><span>|</span><a href="#36768936">next</a><span>|</span><label class="collapse" for="c-36765463">[-]</label><label class="expand" for="c-36765463">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that modern hard drives all use probability and error detection&#x2F;correction to convert a gooey analog signal into chunky discrete goodness.</div><br/></div></div><div id="36768936" class="c"><input type="checkbox" id="c-36768936" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36765463">prev</a><span>|</span><a href="#36764071">next</a><span>|</span><label class="collapse" for="c-36768936">[-]</label><label class="expand" for="c-36768936">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t about analog data. The states will still be quantized&#x2F;digitized. Besides, currently used transistors in regular CPUs are analog too.<p>And, does anyone want more than 0 and 1? If it&#x27;s faster and has largest capacities, with equally feasible manufacturing, then yes.</div><br/></div></div><div id="36764071" class="c"><input type="checkbox" id="c-36764071" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36768936">prev</a><span>|</span><a href="#36764813">next</a><span>|</span><label class="collapse" for="c-36764071">[-]</label><label class="expand" for="c-36764071">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Does anyone really want to process analog data?<p>I imagine at some point in the abstractions it&#x27;ll get a compat layer. Also, I could be wrong about MLC NAND but I thought it still stored 0&#x2F;1 and just had more bits stored per cell through stacking.</div><br/><div id="36764222" class="c"><input type="checkbox" id="c-36764222" checked=""/><div class="controls bullet"><span class="by">whatevaa</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764071">parent</a><span>|</span><a href="#36764244">next</a><span>|</span><label class="collapse" for="c-36764222">[-]</label><label class="expand" for="c-36764222">[2 more]</label></div><br/><div class="children"><div class="content">No, multi-level NAND has extra voltage levels. Instead of a just regular off (0) and on (1) they have intermediate states too. For QLC, that&#x27;s 16 levels, it&#x27;s quite granular, and the margins of error are very small.</div><br/><div id="36764539" class="c"><input type="checkbox" id="c-36764539" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764222">parent</a><span>|</span><a href="#36764244">next</a><span>|</span><label class="collapse" for="c-36764539">[-]</label><label class="expand" for="c-36764539">[1 more]</label></div><br/><div class="children"><div class="content">The margins for error are wider than one might immediately assume, since they combine it with error correction codes.</div><br/></div></div></div></div><div id="36764244" class="c"><input type="checkbox" id="c-36764244" checked=""/><div class="controls bullet"><span class="by">sp332</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764071">parent</a><span>|</span><a href="#36764222">prev</a><span>|</span><a href="#36764813">next</a><span>|</span><label class="collapse" for="c-36764244">[-]</label><label class="expand" for="c-36764244">[4 more]</label></div><br/><div class="children"><div class="content">TLC NAND stores one of eight values in the cell. There aren&#x27;t three separate values like 1, 0, 1, there is only one value, like &quot;5&quot;.</div><br/><div id="36764589" class="c"><input type="checkbox" id="c-36764589" checked=""/><div class="controls bullet"><span class="by">AussieWog93</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764244">parent</a><span>|</span><a href="#36764813">next</a><span>|</span><label class="collapse" for="c-36764589">[-]</label><label class="expand" for="c-36764589">[3 more]</label></div><br/><div class="children"><div class="content">I mean, 101 is just 5 in binary.<p>So each cell stores either three pieces of binary or one piece of octal.  It&#x27;s the same thing.</div><br/><div id="36767491" class="c"><input type="checkbox" id="c-36767491" checked=""/><div class="controls bullet"><span class="by">koromak</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764589">parent</a><span>|</span><a href="#36765437">next</a><span>|</span><label class="collapse" for="c-36767491">[-]</label><label class="expand" for="c-36767491">[1 more]</label></div><br/><div class="children"><div class="content">Its absolutely not the same thing from a hardware perspective. Normal components always operate on bits. We see &quot;5&quot;, but the computer sees (at least) 3 bits. It then sends its output as bits to the next one. A 5 must require 3 wires, or 3 cycles of the clock over a single wire.<p>Building a computer where each wire can encode multiple bits of data at the exact same time fundamentally changes the way operations are done. The entire thing would need to be built in a different way, with different consequences.<p>It might be a bad idea, or impossible, but it would be different.</div><br/></div></div><div id="36765437" class="c"><input type="checkbox" id="c-36765437" checked=""/><div class="controls bullet"><span class="by">failuser</span><span>|</span><a href="#36763996">root</a><span>|</span><a href="#36764589">parent</a><span>|</span><a href="#36767491">prev</a><span>|</span><a href="#36764813">next</a><span>|</span><label class="collapse" for="c-36765437">[-]</label><label class="expand" for="c-36765437">[1 more]</label></div><br/><div class="children"><div class="content">5 is not stored as 101, it’s stored as charge level number 5 out of 8 other valid charge levels.</div><br/></div></div></div></div></div></div></div></div><div id="36764813" class="c"><input type="checkbox" id="c-36764813" checked=""/><div class="controls bullet"><span class="by">PhasmaFelis</span><span>|</span><a href="#36763996">parent</a><span>|</span><a href="#36764071">prev</a><span>|</span><a href="#36766272">next</a><span>|</span><label class="collapse" for="c-36764813">[-]</label><label class="expand" for="c-36764813">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does anyone really want to process analog data?<p>If they can get it to encode binary data more densely than existing systems, with acceptable speed&#x2F;reliability&#x2F;cost? Yes, of course they would.</div><br/></div></div></div></div><div id="36766272" class="c"><input type="checkbox" id="c-36766272" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36763996">prev</a><span>|</span><a href="#36765494">next</a><span>|</span><label class="collapse" for="c-36766272">[-]</label><label class="expand" for="c-36766272">[13 more]</label></div><br/><div class="children"><div class="content">Actually if you think in the sense of informatics...base 3 is more efficient than base 2, but natural base (base e = base 2.718...) is the most efficient, and 3 - e is closer to e than e - 2. So it is more natural for computers to go in multiple bases but unnatural to human.</div><br/><div id="36767093" class="c"><input type="checkbox" id="c-36767093" checked=""/><div class="controls bullet"><span class="by">rlpb</span><span>|</span><a href="#36766272">parent</a><span>|</span><a href="#36766496">next</a><span>|</span><label class="collapse" for="c-36767093">[-]</label><label class="expand" for="c-36767093">[2 more]</label></div><br/><div class="children"><div class="content">How are you measuring efficiency? Why is base 3 more efficient than base 2? Why is e the most efficient?</div><br/><div id="36767318" class="c"><input type="checkbox" id="c-36767318" checked=""/><div class="controls bullet"><span class="by">ravi-delia</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36767093">parent</a><span>|</span><a href="#36766496">next</a><span>|</span><label class="collapse" for="c-36767318">[-]</label><label class="expand" for="c-36767318">[1 more]</label></div><br/><div class="children"><div class="content">There is a particular notion of &quot;radix economy&quot; which takes into account both the length of a number compared to its size and the informational complexity of more symbols. It doesn&#x27;t really have anything to do with data storage though. If you could create a device to store 1000 10-bits (10its?) for exactly the same cost as one that stores 1000 3-bits you&#x27;d obviously pick the base 10 one, no matter what radix economy says.</div><br/></div></div></div></div><div id="36766496" class="c"><input type="checkbox" id="c-36766496" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#36766272">parent</a><span>|</span><a href="#36767093">prev</a><span>|</span><a href="#36766572">next</a><span>|</span><label class="collapse" for="c-36766496">[-]</label><label class="expand" for="c-36766496">[2 more]</label></div><br/><div class="children"><div class="content">See: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ternary_computer" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ternary_computer</a></div><br/><div id="36766834" class="c"><input type="checkbox" id="c-36766834" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36766496">parent</a><span>|</span><a href="#36766572">next</a><span>|</span><label class="collapse" for="c-36766834">[-]</label><label class="expand" for="c-36766834">[1 more]</label></div><br/><div class="children"><div class="content">Yes -- The soviets did the right thing, but it was too costly.</div><br/></div></div></div></div><div id="36766572" class="c"><input type="checkbox" id="c-36766572" checked=""/><div class="controls bullet"><span class="by">aYsY4dDQ2NrcNzA</span><span>|</span><a href="#36766272">parent</a><span>|</span><a href="#36766496">prev</a><span>|</span><a href="#36766408">next</a><span>|</span><label class="collapse" for="c-36766572">[-]</label><label class="expand" for="c-36766572">[7 more]</label></div><br/><div class="children"><div class="content">&gt; 3 - e is closer to e than e - 2<p>I don&#x27;t get it.</div><br/><div id="36766699" class="c"><input type="checkbox" id="c-36766699" checked=""/><div class="controls bullet"><span class="by">hulahoof</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36766572">parent</a><span>|</span><a href="#36766408">next</a><span>|</span><label class="collapse" for="c-36766699">[-]</label><label class="expand" for="c-36766699">[6 more]</label></div><br/><div class="children"><div class="content">I assume they mean absolute distance<p>abs(3-e) &lt; abs(2-e)</div><br/><div id="36767226" class="c"><input type="checkbox" id="c-36767226" checked=""/><div class="controls bullet"><span class="by">dismalpedigree</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36766699">parent</a><span>|</span><a href="#36766408">next</a><span>|</span><label class="collapse" for="c-36767226">[-]</label><label class="expand" for="c-36767226">[5 more]</label></div><br/><div class="children"><div class="content">I still don’t understand why base e is the most efficient ideal. There has to be some more info on this.</div><br/><div id="36767639" class="c"><input type="checkbox" id="c-36767639" checked=""/><div class="controls bullet"><span class="by">davidnc</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36767226">parent</a><span>|</span><a href="#36767560">next</a><span>|</span><label class="collapse" for="c-36767639">[-]</label><label class="expand" for="c-36767639">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Radix_economy" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Radix_economy</a><p>The idea is that if it costs $r to store a base-r digit, then base 3 (or e in a continuous scale) turns out to be the most efficient. Obviously, there&#x27;s no a priori reason to think that a 3-level gate is exactly 1.5x more expensive than a 2-level gate, so this is mostly of theoretical interest.</div><br/></div></div><div id="36767560" class="c"><input type="checkbox" id="c-36767560" checked=""/><div class="controls bullet"><span class="by">gretch</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36767226">parent</a><span>|</span><a href="#36767639">prev</a><span>|</span><a href="#36766408">next</a><span>|</span><label class="collapse" for="c-36767560">[-]</label><label class="expand" for="c-36767560">[3 more]</label></div><br/><div class="children"><div class="content">Yeah I don’t even understand non-whole bases.<p>For example, how does someone express the number 5 in base e…</div><br/><div id="36767946" class="c"><input type="checkbox" id="c-36767946" checked=""/><div class="controls bullet"><span class="by">ez667</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36767560">parent</a><span>|</span><a href="#36767855">next</a><span>|</span><label class="collapse" for="c-36767946">[-]</label><label class="expand" for="c-36767946">[1 more]</label></div><br/><div class="children"><div class="content">12.0200112_e = e+2+2&#x2F;e^2+e^-5+e^-6+2e^-7 = 4.99999285804.....<p>so 5 in base e is an infinite sequence of digits starting with 12.020011....</div><br/></div></div><div id="36767855" class="c"><input type="checkbox" id="c-36767855" checked=""/><div class="controls bullet"><span class="by">joquarky</span><span>|</span><a href="#36766272">root</a><span>|</span><a href="#36767560">parent</a><span>|</span><a href="#36767946">prev</a><span>|</span><a href="#36766408">next</a><span>|</span><label class="collapse" for="c-36767855">[-]</label><label class="expand" for="c-36767855">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always visualized it like fractals</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36765494" class="c"><input type="checkbox" id="c-36765494" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#36766272">prev</a><span>|</span><a href="#36764135">next</a><span>|</span><label class="collapse" for="c-36765494">[-]</label><label class="expand" for="c-36765494">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Normally it’s challenging to use [hafnium oxide] for memory because it has no structure at the atomic level – its hafnium and oxygen atoms are randomly mixed together.<p>What on earth does this mean? Looks like a typically non-random crystal to me:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hafnium(IV)_oxide" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hafnium(IV)_oxide</a><p>The actual article is open access, but rather dense:<p><a href="https:&#x2F;&#x2F;www.science.org&#x2F;doi&#x2F;10.1126&#x2F;sciadv.adg1946" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.science.org&#x2F;doi&#x2F;10.1126&#x2F;sciadv.adg1946</a><p>It seems they used <i>amorphous</i> hafnium oxide:<p>&gt; To create this amorphous nanocomposite, we added Ba to hafnium oxide during the single-step thin film deposition, and because of its simplicity of compositional control, we used pulsed laser deposition (PLD) to deposit the films. The PLD target had a Ba:Hf cation ratio of 1:2, which exceeds the solubility limit of dopants (with large atomic radii) in (crystalline) hafnium oxide, so that the formation of a second (amorphous) phase could be expected (22).<p>Is that what the article means? Because it also then talks about adding barium on top of this, whereas you don&#x27;t even get the amorphous phase without barium.<p>Anyway, the paper also explains the deal with the Barium &quot;bridges&quot;, which the authors call columns, fairly clearly (but it&#x27;s too long to copy here).<p>Other observations:<p>- The authors seem to be very proud of producing this device mostly using &quot;industry-compatible&quot; processes, which i think means stuff you could do in a conventional chip fab, and where they don&#x27;t, they have a story about how they could. This seems to contrast with other experiments in this field where the techniques would be very difficult to export from the lab.<p>- Switching time seems to be &gt; ~100 ns. Maybe that can be optimised a lot. And i don&#x27;t know what that translates to in terms of latency at bus level. But that time is ~100x SRAM, ~30x DRAM, ~10x some of these other wacky high-speed storage technologies, but ~1000x less than flash. Could have those numbers highly mixed up, so correct me if i&#x27;m wrong.<p>- There is some chat about &quot;neuromorphic&quot; functionality, where storage works like neurons. I won&#x27;t go into the details but this sounds like a fad that is probably getting semiconductor researchers nice big grants, and will go absolutely nowhere.</div><br/></div></div><div id="36764135" class="c"><input type="checkbox" id="c-36764135" checked=""/><div class="controls bullet"><span class="by">1024core</span><span>|</span><a href="#36765494">prev</a><span>|</span><a href="#36764119">next</a><span>|</span><label class="collapse" for="c-36764135">[-]</label><label class="expand" for="c-36764135">[6 more]</label></div><br/><div class="children"><div class="content">How long have we been talking about &quot;new&quot; types of memory&#x2F;storage? Anyone remember memristors?</div><br/><div id="36764606" class="c"><input type="checkbox" id="c-36764606" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#36764135">parent</a><span>|</span><a href="#36764236">next</a><span>|</span><label class="collapse" for="c-36764606">[-]</label><label class="expand" for="c-36764606">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that any new technology has to compete with half a century of improvement made to the current one.<p>It&#x27;s not enough to make a proof of concept of your MRAM, FRAM, or whatnot. If you want it to catch on you have to also come up with a way to quickly start making say, 16GB modules competitive with modern DDR5.<p>That&#x27;s tough.</div><br/></div></div><div id="36764236" class="c"><input type="checkbox" id="c-36764236" checked=""/><div class="controls bullet"><span class="by">renegade-otter</span><span>|</span><a href="#36764135">parent</a><span>|</span><a href="#36764606">prev</a><span>|</span><a href="#36764719">next</a><span>|</span><label class="collapse" for="c-36764236">[-]</label><label class="expand" for="c-36764236">[1 more]</label></div><br/><div class="children"><div class="content">The article literally links to another one that talks about the &quot;emerging type of memory&quot; - from 2012.</div><br/></div></div><div id="36764719" class="c"><input type="checkbox" id="c-36764719" checked=""/><div class="controls bullet"><span class="by">hanniabu</span><span>|</span><a href="#36764135">parent</a><span>|</span><a href="#36764236">prev</a><span>|</span><a href="#36764119">next</a><span>|</span><label class="collapse" for="c-36764719">[-]</label><label class="expand" for="c-36764719">[3 more]</label></div><br/><div class="children"><div class="content">Has anything happened with memristors?</div><br/><div id="36764901" class="c"><input type="checkbox" id="c-36764901" checked=""/><div class="controls bullet"><span class="by">p1esk</span><span>|</span><a href="#36764135">root</a><span>|</span><a href="#36764719">parent</a><span>|</span><a href="#36767076">next</a><span>|</span><label class="collapse" for="c-36764901">[-]</label><label class="expand" for="c-36764901">[1 more]</label></div><br/><div class="children"><div class="content">With the recent successes quantizing LLMs to 4 bits, memristors can actually be useful. Basically the lower the precision the more attractive analog computation becomes.</div><br/></div></div><div id="36767076" class="c"><input type="checkbox" id="c-36767076" checked=""/><div class="controls bullet"><span class="by">mchannon</span><span>|</span><a href="#36764135">root</a><span>|</span><a href="#36764719">parent</a><span>|</span><a href="#36764901">prev</a><span>|</span><a href="#36764119">next</a><span>|</span><label class="collapse" for="c-36767076">[-]</label><label class="expand" for="c-36767076">[1 more]</label></div><br/><div class="children"><div class="content">You can buy them at knowm.com so I&#x27;d guess.. maybe?</div><br/></div></div></div></div></div></div><div id="36764119" class="c"><input type="checkbox" id="c-36764119" checked=""/><div class="controls bullet"><span class="by">chimeracoder</span><span>|</span><a href="#36764135">prev</a><span>|</span><a href="#36766480">next</a><span>|</span><label class="collapse" for="c-36764119">[-]</label><label class="expand" for="c-36764119">[13 more]</label></div><br/><div class="children"><div class="content">Binary data simply means that each datum encodes exactly one of two states. We represent them as 0s and 1s, but that&#x27;s just an abstraction of convenience - physically, that maps to something like &quot;high voltage&quot; and &quot;low voltage&quot;, or &quot;dark&quot; and &quot;light&quot;, or &quot;on&quot; and &quot;off&quot;, depending on the physical medium.<p>We could have three states - &quot;high voltage&quot;, &quot;medium voltage&quot; and &quot;low voltage&quot; - but the advantage of having exactly two is that it makes it harder to mistake one state for another (e.g. if voltage fluctuates within a specific range). If the measurement range for each datum is (0, 100), you can decide that anything below 50 is &quot;low voltage&quot; and anything below 100 is &quot;high voltage&quot;. You can also do the same thing with (0,33), &lt;33,66), &lt;66,100), but that requires assuming more precise tools throughout the entire pipeline. When we talk about bits getting flipped (the entire reason that checksums exist in wire protocols), that&#x27;s the reason: the medium conducting the signal is imprecise, and sometimes the reading is off.<p>Traditionally, this represents a tradeoff between density and fidelity. If your system has high enough fidelity, you can take advantage of the additional precision and distinguish between more states, representing additional information.<p>If your system has 8 states (0,8.3), &lt;8.3, 16.6)... etc., you can look at this as an octal system, or you can think of it as a binary system in which a read&#x2F;write error affects an entire byte, rather than a single bit.<p>At the end of the day, this is a question of signal processing - binary representation is a convenient abstraction that allows us to understand the way that we&#x27;re interpreting the signals we&#x27;re reading, but it&#x27;s fundamentally an arbitrary choice.</div><br/><div id="36764203" class="c"><input type="checkbox" id="c-36764203" checked=""/><div class="controls bullet"><span class="by">quasse</span><span>|</span><a href="#36764119">parent</a><span>|</span><a href="#36765100">next</a><span>|</span><label class="collapse" for="c-36764203">[-]</label><label class="expand" for="c-36764203">[10 more]</label></div><br/><div class="children"><div class="content">This is multi-level cell flash memory, and it&#x27;s been in use for years. Instead of &quot;high&quot; or &quot;low&quot; voltage they use the in-between states to encode more bits per cell. [1]<p>I worked at an embedded startup when SD cards started switching to MLC and we saw a really notable decrease in storage reliability. We ended up sourcing special SD cards that were flashed with embedded controller firmware restoring them to single level cell functionality. Your storage space is divided by 2^n going from n levels of voltage per cell back to SLC, but we saw greatly increased data integrity.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multi-level_cell" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multi-level_cell</a></div><br/><div id="36766768" class="c"><input type="checkbox" id="c-36766768" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764203">parent</a><span>|</span><a href="#36765288">next</a><span>|</span><label class="collapse" for="c-36766768">[-]</label><label class="expand" for="c-36766768">[2 more]</label></div><br/><div class="children"><div class="content">Increasing the number of bits per cell is an exponential decrease in reliability for a multiplicative increase in capacity. Flash manufacturers have become notoriously secretive about TLC&#x2F;QLC retention and endurance and hope that you don&#x27;t notice. Meanwhile SLC is near extinct and sells for much more than the 2x-3x-4x multiples over MLC&#x2F;TLC&#x2F;QLC that it should normally cost. It&#x27;s none other than planned obsolescence.</div><br/><div id="36767252" class="c"><input type="checkbox" id="c-36767252" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36766768">parent</a><span>|</span><a href="#36765288">next</a><span>|</span><label class="collapse" for="c-36767252">[-]</label><label class="expand" for="c-36767252">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Increasing the number of bits per cell is an exponential decrease in reliability for a multiplicative increase in capacity. Flash manufacturers have become notoriously secretive about TLC&#x2F;QLC retention and endurance and hope that you don&#x27;t notice. Meanwhile SLC is near extinct and sells for much more than the 2x-3x-4x multiples over MLC&#x2F;TLC&#x2F;QLC that it should normally cost.<p>Yes.<p>&gt; It&#x27;s none other than planned obsolescence.<p>What makes you say this?<p>Even products that are built for a long lifetime of heavy use only <i>sometimes</i> need to drop down to MLC.  Most servers and basically any consumer devices are fine with TLC.<p>Lack of SLC is not making drives die early.<p>Even on those 4-5 bit devices, the impact on performance tends to be a bigger deal than the impact on endurance.  And there&#x27;s no great push to get people onto those drives.  TLC drives get most of the attention.</div><br/></div></div></div></div><div id="36765288" class="c"><input type="checkbox" id="c-36765288" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764203">parent</a><span>|</span><a href="#36766768">prev</a><span>|</span><a href="#36764529">next</a><span>|</span><label class="collapse" for="c-36765288">[-]</label><label class="expand" for="c-36765288">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Your storage space is divided by 2^n going from n levels of voltage per cell back to SLC<p>it&#x27;s not that bad, it&#x27;s divided by log2(n).</div><br/></div></div><div id="36764529" class="c"><input type="checkbox" id="c-36764529" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764203">parent</a><span>|</span><a href="#36765288">prev</a><span>|</span><a href="#36764229">next</a><span>|</span><label class="collapse" for="c-36764529">[-]</label><label class="expand" for="c-36764529">[1 more]</label></div><br/><div class="children"><div class="content">Those are known as pseudo-SLC, they are common in industrial applications.</div><br/></div></div><div id="36764229" class="c"><input type="checkbox" id="c-36764229" checked=""/><div class="controls bullet"><span class="by">chimeracoder</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764203">parent</a><span>|</span><a href="#36764529">prev</a><span>|</span><a href="#36765100">next</a><span>|</span><label class="collapse" for="c-36764229">[-]</label><label class="expand" for="c-36764229">[5 more]</label></div><br/><div class="children"><div class="content">&gt;  This is multi-level cell flash memory, and it&#x27;s been in use for years. Instead of &quot;high&quot; or &quot;low&quot; voltage they use the in-between states to encode more bits per cell. [1]<p>Yes, I&#x27;m explaining it with high and low voltage because that&#x27;s an easy example to wrap your head around if you haven&#x27;t thought about signal processing or hardware engineering before.</div><br/><div id="36764591" class="c"><input type="checkbox" id="c-36764591" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764229">parent</a><span>|</span><a href="#36765100">next</a><span>|</span><label class="collapse" for="c-36764591">[-]</label><label class="expand" for="c-36764591">[4 more]</label></div><br/><div class="children"><div class="content">How much calculus would it require in order to get a decent grasp on signal processing? Not to work in the field or become an expert, but to gain an at least somewhat intelligent outsider’s understanding of it?</div><br/><div id="36764818" class="c"><input type="checkbox" id="c-36764818" checked=""/><div class="controls bullet"><span class="by">tiberius_p</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764591">parent</a><span>|</span><a href="#36764722">next</a><span>|</span><label class="collapse" for="c-36764818">[-]</label><label class="expand" for="c-36764818">[1 more]</label></div><br/><div class="children"><div class="content">Learn what&#x27;s the deal with the Fourier Transform and the Z transform. Then learn how to design some digital FIR filters. Oh and do learn about the Nyquist-Shannon sampling theorem, it&#x27;s very important. And that&#x27;s about it...just joking, there&#x27;s tons more. But that would be a good start.</div><br/></div></div><div id="36764722" class="c"><input type="checkbox" id="c-36764722" checked=""/><div class="controls bullet"><span class="by">rcarr</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764591">parent</a><span>|</span><a href="#36764818">prev</a><span>|</span><a href="#36764777">next</a><span>|</span><label class="collapse" for="c-36764722">[-]</label><label class="expand" for="c-36764722">[1 more]</label></div><br/><div class="children"><div class="content">Don’t work in the field but I believe fast fourier transforms are commonplace so at least enough to have a solid grasp of that?</div><br/></div></div><div id="36764777" class="c"><input type="checkbox" id="c-36764777" checked=""/><div class="controls bullet"><span class="by">AYoung010</span><span>|</span><a href="#36764119">root</a><span>|</span><a href="#36764591">parent</a><span>|</span><a href="#36764722">prev</a><span>|</span><a href="#36765100">next</a><span>|</span><label class="collapse" for="c-36764777">[-]</label><label class="expand" for="c-36764777">[1 more]</label></div><br/><div class="children"><div class="content">Most intro classes require calculus 1 &amp; 2.</div><br/></div></div></div></div></div></div></div></div><div id="36765100" class="c"><input type="checkbox" id="c-36765100" checked=""/><div class="controls bullet"><span class="by">mr_toad</span><span>|</span><a href="#36764119">parent</a><span>|</span><a href="#36764203">prev</a><span>|</span><a href="#36766080">next</a><span>|</span><label class="collapse" for="c-36765100">[-]</label><label class="expand" for="c-36765100">[1 more]</label></div><br/><div class="children"><div class="content">&gt; fundamentally an arbitrary choice<p>It’s not arbitrary, it’s an engineering choice.  It’s just easier to design binary circuits.</div><br/></div></div><div id="36766080" class="c"><input type="checkbox" id="c-36766080" checked=""/><div class="controls bullet"><span class="by">masswerk</span><span>|</span><a href="#36764119">parent</a><span>|</span><a href="#36765100">prev</a><span>|</span><a href="#36766480">next</a><span>|</span><label class="collapse" for="c-36766080">[-]</label><label class="expand" for="c-36766080">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We could have three states…<p>&quot;With the advent of mass-produced binary components for computers, ternary computers have diminished in significance. However, Donald Knuth argues that they will be brought back into development in the future to take advantage of ternary logic&#x27;s elegance and efficiency.&quot;<p>(Wikpedia article on ternary computer(s), <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ternary_computer" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ternary_computer</a>, Donald Knuth&#x27;s observation is found in The Art of Computer Programming.)</div><br/></div></div></div></div><div id="36766480" class="c"><input type="checkbox" id="c-36766480" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#36764119">prev</a><span>|</span><label class="collapse" for="c-36766480">[-]</label><label class="expand" for="c-36766480">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As powerful as current computer technology can be, there are a few hard limits to it. Data is encoded into just two states – one or zero. And this data is stored and processed in different parts of a computer system, so it needs to be shuttled back and forth, which consumes energy and time.<p>This kinda reads like someone who doesn&#x27;t know how storage works. Storage is rarely encoded as &quot;one and zero&quot; in the form you see it, say, in a hex editor. In fact that&#x27;s what&#x27;s it decoded to. Storage schemes vary, to limit run length, add error correction, and in some cases includes analog states like the ones described in the article, to make more efficient use of charge and material state.<p>This is trivial, because actually the smallest unit you work with in a computer is not a bit, but a byte. And often in fact a word, which is typically 16 bytes (64 bits), or 64 bytes (512 bits) the size of a cache line, or even 4096 bytes, the size of a typical memory page or disk sector. So we have plenty of leeway to comfortably encode these larger units however we wish, and the rest can stay as-is.</div><br/></div></div></div></div></div></div></div></body></html>