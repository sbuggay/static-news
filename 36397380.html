<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687251655311" as="style"/><link rel="stylesheet" href="styles.css?v=1687251655311"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stephenn.com/2023/06/gopher-wrangling.-effective-error-handling-in-go/">Gopher Wrangling: Effective error handling in Go</a> <span class="domain">(<a href="https://stephenn.com">stephenn.com</a>)</span></div><div class="subtext"><span>stephen123</span> | <span>193 comments</span></div><br/><div><div id="36399924" class="c"><input type="checkbox" id="c-36399924" checked=""/><div class="controls bullet"><span class="by">janosdebugs</span><span>|</span><a href="#36397877">next</a><span>|</span><label class="collapse" for="c-36399924">[-]</label><label class="expand" for="c-36399924">[10 more]</label></div><br/><div class="children"><div class="content">Go&#x27;s error handling is a horrible mess:<p>1. It&#x27;s easy to ignore returned errors without any compiler warnings. You have to rely on third party tools such as golangci-lint to report missing error handling.<p>2. Errors don&#x27;t carry stack traces with them, you have to rely on third party libraries or custom errors to get that functionality and you will only get it for your own code, not in other libraries you are using.<p>3. It&#x27;s unclear who should add context to error messages  is it the caller or callee? Usually it gets skipped, leading to useless error messages.<p>4. Errors are untyped. If you want to decide based on error types, you have to use errors.Is or errors.As, which, surprise, is roughly as expensive computationally as panic-recover. (Source: I did a performance tests on this with Go 1.18) Go might as well add a simpler way to create exceptions. (I wrote a prototype library to that effect a while ago: <a href="https:&#x2F;&#x2F;github.com&#x2F;APItalist&#x2F;lang">https:&#x2F;&#x2F;github.com&#x2F;APItalist&#x2F;lang</a> )<p>5. Error messages are too terse and hard to read when using the recommended semantic of &quot;message (cause(cause(cause)))&quot;. I&#x27;d rather see stack traces, that&#x27;s much more useful.<p>6. Most loggers are globally scoped and cannot be injected into code, leading to an all-or-nothing approach. It is not uncommon that you have 3-4 logging libraries as dependencies, which you need to configure separately (if you even can). Also, good luck securing this mess.</div><br/><div id="36400234" class="c"><input type="checkbox" id="c-36400234" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#36399924">parent</a><span>|</span><a href="#36401063">next</a><span>|</span><label class="collapse" for="c-36400234">[-]</label><label class="expand" for="c-36400234">[3 more]</label></div><br/><div class="children"><div class="content">&gt;3. It&#x27;s unclear who should add context to error messages is it the caller or callee? Usually it gets skipped, leading to useless error messages<p>Why is that unclear?<p>Let&#x27;s say you are writting a db client package and a service around it.<p>The package&#x27;s db.Exec(query) method should return and error that will have an error text received from db if any AND\OR context from the package itself.<p>Then in your service you add additional context to this error if needed.<p>Finally you log your typical &quot;failed to write HackerNews comment do db with err: %db_package_context: db_error_text_here%&quot;<p>&gt;6<p>Not sure about &quot;most&quot; loggers, but I have no problem with zap. Popular, definetelly can be injected etc.</div><br/><div id="36400338" class="c"><input type="checkbox" id="c-36400338" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#36399924">root</a><span>|</span><a href="#36400234">parent</a><span>|</span><a href="#36401063">next</a><span>|</span><label class="collapse" for="c-36400338">[-]</label><label class="expand" for="c-36400338">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;3<p>&gt; Why is that unclear?<p>The usual advice is to follow what the stdlib does. Let&#x27;s look at an example. Let&#x27;s say we close a file and then try to set a deadline on it:<p><pre><code>    f, _ := os.Create(&quot;&#x2F;tmp&#x2F;filename&quot;)
    f.Close()
    fmt.Printf(&quot;%v&quot;, f.SetDeadline(time.Now()))

    &#x2F;&#x2F; output: use of closed file
</code></pre>
Okay, so in this case, it&#x27;s the caller&#x27;s responsibility to keep track of the filename and add the context of what file was already closed, resulting in that error.<p>However, what about the error for trying to write to a closed file?<p><pre><code>    _, err := f.Write(nil)
    fmt.Printf(&quot;%v&quot;, err)    
    
    &#x2F;&#x2F; output: write &#x2F;tmp&#x2F;filename: file already closed
</code></pre>
Oh, I see, it&#x27;s Write&#x27;s responsibility to add the context of the filename. Huh.<p>This is a clear example of the problem the parent is talking about. The &#x27;os.File&#x27; construct knows the filename. Sometimes it adds that as context to errors, sometimes it doesn&#x27;t. Sometimes the caller needs to add it in, sometimes the callee has already added it.</div><br/><div id="36401300" class="c"><input type="checkbox" id="c-36401300" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36399924">root</a><span>|</span><a href="#36400338">parent</a><span>|</span><a href="#36401063">next</a><span>|</span><label class="collapse" for="c-36401300">[-]</label><label class="expand" for="c-36401300">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The usual advice is to follow what the stdlib does.<p>This seems to be a significant problem in general, because gophers want clear direction (after all the language was created specifically for… choices to be limited) so they take quips as gospels, but robpike, rsc, etc… take them more as suggestions &#x2F; guidance (90&#x2F;10, possibly even 80&#x2F;20) to be moderated by taste.<p>I don’t remember which one but I think it was robpike who expressed frustration on one of the recently popular issues &#x2F; proposals, because the proposal was essentially to legislate one of the more common quips, and they like being able to break those when useful or convenient.<p>I think there was also something similar to your exploration here with zero values, where despite the quip that you should “make the zero value meaningful” multiple standard library modules will straight up panic if fed zero values (a classic example being the File struct, `File.Name()` panics and pretty much every other method returns ErrInvalid, so a zero-valued File is useless, actively problematic, and the source of unnecessary overheads).<p>An other fun one is that you can’t call IsZero on a zero `reflect.Value`, and the error message is quite amazing:<p><pre><code>    panic: call of reflect.Value.IsZero on zero Value
</code></pre>
You need to carefully read the doc and notice that th middle paragraph documenting Value itself says:<p>&gt; The zero Value represents no value. Its IsValid method returns false, its Kind method returns invalid, its String method returns “&lt;invalid Value&gt;”, <i>and all other methods panic</i>.</div><br/></div></div></div></div></div></div><div id="36401063" class="c"><input type="checkbox" id="c-36401063" checked=""/><div class="controls bullet"><span class="by">amedvednikov</span><span>|</span><a href="#36399924">parent</a><span>|</span><a href="#36400234">prev</a><span>|</span><a href="#36400899">next</a><span>|</span><label class="collapse" for="c-36401063">[-]</label><label class="expand" for="c-36401063">[1 more]</label></div><br/><div class="children"><div class="content">One of the main reasons I created V.<p>It&#x27;s pretty much Go with Option&#x2F;Result that forces you to handle errors:<p>f := os.create(&#x27;foo.txt&#x27;) or { println(err) return }<p><a href="https:&#x2F;&#x2F;vlang.io&#x2F;compare#go" rel="nofollow noreferrer">https:&#x2F;&#x2F;vlang.io&#x2F;compare#go</a></div><br/></div></div><div id="36400899" class="c"><input type="checkbox" id="c-36400899" checked=""/><div class="controls bullet"><span class="by">nbraxf100</span><span>|</span><a href="#36399924">parent</a><span>|</span><a href="#36401063">prev</a><span>|</span><a href="#36399989">next</a><span>|</span><label class="collapse" for="c-36400899">[-]</label><label class="expand" for="c-36400899">[3 more]</label></div><br/><div class="children"><div class="content">The error handling is second nature to anyone who has done C or Unix programming. It just feels dirty not to check for an an error.<p>This is one part I like about Go.</div><br/><div id="36401403" class="c"><input type="checkbox" id="c-36401403" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399924">root</a><span>|</span><a href="#36400899">parent</a><span>|</span><a href="#36401101">next</a><span>|</span><label class="collapse" for="c-36401403">[-]</label><label class="expand" for="c-36401403">[1 more]</label></div><br/><div class="children"><div class="content">An if err with some random one-liner in the err part is not error handling.<p>You can’t reasonably handle an error condition on a local basis, that’s why exceptions (especially checked ones) are superior. They do the correct thing — either bubble up if it doesn’t make sense to handle them in place, or have them in as broad of a scope as it makes sense with try-catches. Oh and they store the stacktrace, so when an exception does inevitably happen in your software you will actually have a decent shot of fixing it instead of grepping for that generic error message throughout the program (especially if it’s not even written by you!). I swear people lie to themselves with all those if-errs believing they have properly handled an error condition because it took effort.</div><br/></div></div><div id="36401101" class="c"><input type="checkbox" id="c-36401101" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#36399924">root</a><span>|</span><a href="#36400899">parent</a><span>|</span><a href="#36401403">prev</a><span>|</span><a href="#36399989">next</a><span>|</span><label class="collapse" for="c-36401101">[-]</label><label class="expand" for="c-36401101">[1 more]</label></div><br/><div class="children"><div class="content">Which rules out the majority of people who learnt to code in the last 25 years (many unis have taught java since 2000ish)</div><br/></div></div></div></div><div id="36399989" class="c"><input type="checkbox" id="c-36399989" checked=""/><div class="controls bullet"><span class="by">notTooFarGone</span><span>|</span><a href="#36399924">parent</a><span>|</span><a href="#36400899">prev</a><span>|</span><a href="#36397877">next</a><span>|</span><label class="collapse" for="c-36399989">[-]</label><label class="expand" for="c-36399989">[2 more]</label></div><br/><div class="children"><div class="content">Calling a linter thirdparty in Go is really disingenuous.
Like you install go in your favourite IDE and it&#x27;s batteries included. It&#x27;s part of the standard set.</div><br/><div id="36400797" class="c"><input type="checkbox" id="c-36400797" checked=""/><div class="controls bullet"><span class="by">aniforprez</span><span>|</span><a href="#36399924">root</a><span>|</span><a href="#36399989">parent</a><span>|</span><a href="#36397877">next</a><span>|</span><label class="collapse" for="c-36400797">[-]</label><label class="expand" for="c-36400797">[1 more]</label></div><br/><div class="children"><div class="content">golangci-lint does not come batteries included. It is a third party library. Saying it&#x27;s &quot;part of the standard set&quot; is really disingenuous</div><br/></div></div></div></div></div></div><div id="36397877" class="c"><input type="checkbox" id="c-36397877" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#36399924">prev</a><span>|</span><a href="#36399650">next</a><span>|</span><label class="collapse" for="c-36397877">[-]</label><label class="expand" for="c-36397877">[69 more]</label></div><br/><div class="children"><div class="content">There is a lot that I like about Go. Error handling is not one of them. On one hand, I appreciate the simplicity of it all. Nothing special about an error, it’s just part of how you do everything else. But on the other hand, there is something clearly special about an error. It’s something 100% of go users have to deal with in almost every single function call. There is something clearly special about it. These grassroots patterns and efforts to handle multiple errors per function, or async errors etc all should really have better solutions in the language.<p>I understand that maybe the language authors in the early days didn’t want to lock anyone into a strict paradigm for how to deal with errors. Like I’m not thrilled about Java’s approach either, but that can never change. But Go is a very popular and established language now. It’s time to fix the error handling mess. There are so many good examples out there to get inspiration from. F#, Swift and Rust have a perfect error handling mechanism.</div><br/><div id="36398060" class="c"><input type="checkbox" id="c-36398060" checked=""/><div class="controls bullet"><span class="by">dlisboa</span><span>|</span><a href="#36397877">parent</a><span>|</span><a href="#36398059">next</a><span>|</span><label class="collapse" for="c-36398060">[-]</label><label class="expand" for="c-36398060">[61 more]</label></div><br/><div class="children"><div class="content">One thing I don&#x27;t get (and would honestly appreciate if was explained to me) is how the Result monad differs significantly from Go&#x27;s error handling, other than being a &quot;true&quot; monad. Most Rust code I see does things like (from the docs):<p><pre><code>      let greeting_file_result = File::open(&quot;hello.txt&quot;);

      let greeting_file = match greeting_file_result {
          Ok(file) =&gt; file,
          Err(error) =&gt; &#x2F;&#x2F; handle err
      };
</code></pre>
It isn&#x27;t much different from:<p><pre><code>      file, err := os.Open(&quot;hello.txt&quot;)
      if err != nil {
          &#x2F;&#x2F; handle error
      }
</code></pre>
I&#x27;ve come to appreciate Go&#x27;s simple solution as you get pretty much 90% of what you want from an operation that might produce an error (either the value or an error), and the flow control aspect of it is more explicit than with exceptions.<p>Maybe I don&#x27;t get Monads, but it seems pretty much equivalent for the common use case.</div><br/><div id="36398510" class="c"><input type="checkbox" id="c-36398510" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398060">parent</a><span>|</span><a href="#36398090">next</a><span>|</span><label class="collapse" for="c-36398510">[-]</label><label class="expand" for="c-36398510">[36 more]</label></div><br/><div class="children"><div class="content">Result is better because it actually encodes the correct situation. You either get a file or an error. Not neither, not both.<p>Go&#x27;s encodes instead &quot;you may or may not have a file&quot; and &quot;you may or may not have an error&quot;. Not the same thing, and extremely rarely what you want, IME.<p>Other languages also do a better job of helping you verify that you actually handled both cases too.<p>By the way I wouldn&#x27;t say we need Monad here, I&#x27;d be happy if Go could at least encode Sum types.</div><br/><div id="36398590" class="c"><input type="checkbox" id="c-36398590" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398510">parent</a><span>|</span><a href="#36398762">next</a><span>|</span><label class="collapse" for="c-36398590">[-]</label><label class="expand" for="c-36398590">[9 more]</label></div><br/><div class="children"><div class="content">This seems like a distinction without a difference. In reality, in code, I&#x27;m still doing something like `if (!result.failed) { do the thing } else { do the other thing }`<p>Like...this makes no difference to my ergonomics at all. In many cases it&#x27;s arguably worse because now 1 token is potentially representing two very different types I want to deal with.<p>The primary benefit to me seems like it&#x27;s more to do with the ease of generic code handling: everything can be Results, and then I can evaluate them all to see if any of them are errors, which in turn makes failing out of many different operations easier - I&#x27;m not handling a file type, a string, some numbers etc.</div><br/><div id="36398656" class="c"><input type="checkbox" id="c-36398656" checked=""/><div class="controls bullet"><span class="by">mkehrt</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398590">parent</a><span>|</span><a href="#36398762">next</a><span>|</span><label class="collapse" for="c-36398656">[-]</label><label class="expand" for="c-36398656">[8 more]</label></div><br/><div class="children"><div class="content">In rust the type system <i>enforces</i> you check the error.  In go, it doesn&#x27;t.  (Because rust error types are enums&#x2F;sums and go error types are structs&#x2F;products).  This seems like a huge difference.<p>&gt; In many cases it&#x27;s arguably worse because now 1 token is potentially representing two very different types I want to deal with.<p>Yes, that&#x27;s what an enum&#x2F;sum type is? That&#x27;s the whole point.</div><br/><div id="36398685" class="c"><input type="checkbox" id="c-36398685" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398656">parent</a><span>|</span><a href="#36398762">next</a><span>|</span><label class="collapse" for="c-36398685">[-]</label><label class="expand" for="c-36398685">[7 more]</label></div><br/><div class="children"><div class="content">In rust it is not possible to use incorrectly, and in go it is, sure. But whether it is possible or not is only one dimension. Does it matter that it’s possible to misuse errors in Go if it virtually never happens?<p>I just don’t find the point about what is possible interesting. The other trade offs around readability, ergonomics, and so on seem more impactful.</div><br/><div id="36398874" class="c"><input type="checkbox" id="c-36398874" checked=""/><div class="controls bullet"><span class="by">nulld3v</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398685">parent</a><span>|</span><a href="#36398802">next</a><span>|</span><label class="collapse" for="c-36398874">[-]</label><label class="expand" for="c-36398874">[4 more]</label></div><br/><div class="children"><div class="content">&gt; virtually never happens<p>Ah yes, like it &quot;never happened&quot; in the Kubernetes project?<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;60962">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;60962</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;80700">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;80700</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;27793">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;27793</a><p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;110879">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;pull&#x2F;110879</a><p>I can find tons of these, just by searching any larger Go project&#x27;s Github.<p>Here&#x27;s one from docker too: <a href="https:&#x2F;&#x2F;github.com&#x2F;moby&#x2F;moby&#x2F;pull&#x2F;10321">https:&#x2F;&#x2F;github.com&#x2F;moby&#x2F;moby&#x2F;pull&#x2F;10321</a><p>What about from CockroachDB? <a href="https:&#x2F;&#x2F;github.com&#x2F;cockroachdb&#x2F;cockroach&#x2F;pull&#x2F;74743">https:&#x2F;&#x2F;github.com&#x2F;cockroachdb&#x2F;cockroach&#x2F;pull&#x2F;74743</a> Even the linter missed this one!</div><br/><div id="36399250" class="c"><input type="checkbox" id="c-36399250" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398874">parent</a><span>|</span><a href="#36398952">next</a><span>|</span><label class="collapse" for="c-36399250">[-]</label><label class="expand" for="c-36399250">[2 more]</label></div><br/><div class="children"><div class="content">Kubernetes is a huge project and not idiomatically written, so it would be shocking if it didn’t exhibit everything that can go wrong with Go.<p>CockroachDB is a better example.</div><br/><div id="36399386" class="c"><input type="checkbox" id="c-36399386" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399250">parent</a><span>|</span><a href="#36398952">next</a><span>|</span><label class="collapse" for="c-36399386">[-]</label><label class="expand" for="c-36399386">[1 more]</label></div><br/><div class="children"><div class="content">This is a No True Scotsman fallacy. &quot;No <i>REAL</i> Go code fails to handle errors.&quot;<p>OP demonstrated that failing to handle errors does in fact happen in the wild, while in Rust the compiler enforces that you must handle them. The question is whether this difference between the systems has practical implications, and it seems it does. The existence of community idioms that help avoid the problem doesn&#x27;t change the fact that the languages themselves are meaningfully different.</div><br/></div></div></div></div><div id="36398952" class="c"><input type="checkbox" id="c-36398952" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398874">parent</a><span>|</span><a href="#36399250">prev</a><span>|</span><a href="#36398802">next</a><span>|</span><label class="collapse" for="c-36398952">[-]</label><label class="expand" for="c-36398952">[1 more]</label></div><br/><div class="children"><div class="content">Of course it happens, I’ve done it. But it’s obvious, it’s the least interesting aspect of the debate. And I think it is less impactful than e.g making exceptions easy for devs to ignore.</div><br/></div></div></div></div><div id="36398802" class="c"><input type="checkbox" id="c-36398802" checked=""/><div class="controls bullet"><span class="by">consilient</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398685">parent</a><span>|</span><a href="#36398874">prev</a><span>|</span><a href="#36398771">next</a><span>|</span><label class="collapse" for="c-36398802">[-]</label><label class="expand" for="c-36398802">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Does it matter that it’s possible to misuse errors in Go if it virtually never happens? I just don’t find the point about what is possible interesting.<p>If you knew for sure that it virtually never happened, maybe not. But you don&#x27;t. At best you know that a few particular individuals you&#x27;re familiar with never mess it up (but then again, consider the people who &quot;virtually never&quot; write incorrect C). You can&#x27;t trust random packages you haven&#x27;t vetted, and you <i>certainly</i> can&#x27;t trust code written by your junior software engineers.<p>&gt; The other trade offs around readability, ergonomics, and so on seem more impactful.<p>Sum types have significantly better ergonomics. `(Result | null, Error | null)` takes four branches to handle properly, whereas `Either Result Error` takes two. And of course things get much worse once you&#x27;re more than one layer deep, which in a language as procedural as Go you almost always are.</div><br/></div></div><div id="36398771" class="c"><input type="checkbox" id="c-36398771" checked=""/><div class="controls bullet"><span class="by">go_explore_5</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398685">parent</a><span>|</span><a href="#36398802">prev</a><span>|</span><a href="#36398762">next</a><span>|</span><label class="collapse" for="c-36398771">[-]</label><label class="expand" for="c-36398771">[1 more]</label></div><br/><div class="children"><div class="content">It depends if you find value in exhaustive pattern matching.<p>From years of using C&#x27;s switch statements, I&#x27;m not going back.</div><br/></div></div></div></div></div></div></div></div><div id="36398762" class="c"><input type="checkbox" id="c-36398762" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398510">parent</a><span>|</span><a href="#36398590">prev</a><span>|</span><a href="#36398090">next</a><span>|</span><label class="collapse" for="c-36398762">[-]</label><label class="expand" for="c-36398762">[26 more]</label></div><br/><div class="children"><div class="content">The Result approach believes that the producer knows what is best for the caller regardless of who the caller is. The Go approach believes that the producer shouldn&#x27;t assume it knows the caller.<p>I&#x27;m not sure one is better than the other, just different tradeoffs.</div><br/><div id="36399140" class="c"><input type="checkbox" id="c-36399140" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398762">parent</a><span>|</span><a href="#36398789">next</a><span>|</span><label class="collapse" for="c-36399140">[-]</label><label class="expand" for="c-36399140">[4 more]</label></div><br/><div class="children"><div class="content">This doesn&#x27;t really make much sense. The producer knows what it&#x27;s returning. In the _vastly_ common case, it&#x27;s either returning an error or a success object, but the Go type system is unable to represent that.<p>The caller trying to pretend that the success object is there isn&#x27;t a freedom the caller gets in the current system, it&#x27;s an artifact of the type system not being powerful enough to encode the situation accurately.<p>In practice (for the success object) it means you need to check for a nil pointer, make sure you don&#x27;t use a zombie object, or just rely on an assumption that it&#x27;s not nil, depending on which poor choice the producer function went for.<p>If you have a function that can return both an object and an error, there still should be a way to represent that (exactly the current way). Having Sum types would just allow a way to represent the common case accurately.</div><br/><div id="36399360" class="c"><input type="checkbox" id="c-36399360" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399140">parent</a><span>|</span><a href="#36398789">next</a><span>|</span><label class="collapse" for="c-36399360">[-]</label><label class="expand" for="c-36399360">[3 more]</label></div><br/><div class="children"><div class="content"><i>&gt; The producer knows what it&#x27;s returning.</i><p>But doesn&#x27;t know how the return values will be used by the caller. What is perhaps lost in this is where Go says that values should <i>always</i> be useful?<p><i>&gt; If you have a function that can return both an object and an error, there still should be a way to represent that (exactly the current way).</i><p>Exactly the current way is what is said to be deficient, though. A function of this type is naturally going to return a file every time because a file is <i>always</i> useful, even when there is failure. Whereas Result assumes that you won&#x27;t find the file useful when there is failure.<p>If you know the callers you can discuss if the file will ever be useful to the callers who use it under failure condition. Always useful does not mean always used. But Go, no doubt of a product of Google&#x27;s organizational structure, believes that you cannot get to know your callers. You have to give them what you&#x27;ve got and let them decide what and what isn&#x27;t important to their specific needs.<p>Tradeoffs, as always.</div><br/><div id="36399512" class="c"><input type="checkbox" id="c-36399512" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399360">parent</a><span>|</span><a href="#36399731">next</a><span>|</span><label class="collapse" for="c-36399512">[-]</label><label class="expand" for="c-36399512">[1 more]</label></div><br/><div class="children"><div class="content">This tries to sound profound but it really just misunderstands basic sum types. In Rust&#x2F;Haskell&#x2F;etc you&#x27;re free to return multiple values if that&#x27;s even potentially useful. If you have a function that can completely fail, partially fail (in this example, opening a file but then something else fails), or entirely succeed, you can encode that in the type system. In Go you cannot define this in the type system, you just have comments explaining how it works and hoping both that you implement it correctly and callers of your code read and understand them. If your code does return both files and errors in some cases, chances are callers are going to handle it incorrectly, especially if, say, the caller is responsible for closing files&#x2F;responses&#x2F;streams&#x2F;etc.<p>In Rust&#x2F;Haskell I can write a type with three values like Success(file), PartialSuccess(file, error), or Failure(error). Callers must then handle all of these. In Go I always have four cases for a simple function including those three and the final case of neither file nor error. Most Go callers will not handle the case where err != nil and file != nil and often the case where err == nil and file  == nil will cause a panic and crash the program.<p>There was a tradeoff for this, but in this case the tradeoff was entirely in making the Go compiler simpler at the cost of making the Go language weaker and Go code more error-prone.</div><br/></div></div><div id="36399731" class="c"><input type="checkbox" id="c-36399731" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399360">parent</a><span>|</span><a href="#36399512">prev</a><span>|</span><a href="#36398789">next</a><span>|</span><label class="collapse" for="c-36399731">[-]</label><label class="expand" for="c-36399731">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But doesn&#x27;t know how the return values will be used by the caller. What is perhaps lost in this is where Go says that values should always be useful?<p>It doesn&#x27;t matter how it will be used by the caller. If I&#x27;m writing a function that can fail, no magic in existence can create a success object out of nothing, especially one that &quot;should always be useful&quot;. At that point you&#x27;re stuck either returning a nil pointer or a zombie object (along with the error).<p>&gt; Exactly the current way is what is said to be deficient, though.<p>It&#x27;s deficient because it&#x27;s modelling the wrong (in the common case) thing. I&#x27;m saying if you&#x27;re in the uncommon case and that actually _is_ what you&#x27;re trying to model, then you still can.<p>&gt; A function of this type is naturally going to return a file every time because a file is always useful, even when there is failure.<p>What? No. It&#x27;s not useful if there is no file, if the error is &quot;wtf, that file doesn&#x27;t exist&quot;.</div><br/></div></div></div></div></div></div><div id="36398789" class="c"><input type="checkbox" id="c-36398789" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398762">parent</a><span>|</span><a href="#36399140">prev</a><span>|</span><a href="#36398090">next</a><span>|</span><label class="collapse" for="c-36398789">[-]</label><label class="expand" for="c-36398789">[21 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t the producer know best whether the producer failed?</div><br/><div id="36398940" class="c"><input type="checkbox" id="c-36398940" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398789">parent</a><span>|</span><a href="#36398090">next</a><span>|</span><label class="collapse" for="c-36398940">[-]</label><label class="expand" for="c-36398940">[20 more]</label></div><br/><div class="children"><div class="content">Does the caller care?<p>By day I work with a team in a language that sees errors ride on the exception handling system. Staying within the original example, I see code like this all the time (<i>too often</i>, even, but that&#x27;s another topic for another day):<p><pre><code>    try {
        file = getFile()
    } catch(&#x2F;* ... *&#x2F;) {
        fileUnavailable()
    }
</code></pre>
Here, the assumption of getFile that the caller wanted an error was incorrect. A Result-using language would end up in a similar place.<p>Idiomatic Go says leave it to the caller. Like above, when only wants to know if there is &quot;file or no file&quot; without concern for why there is no file, then:<p><pre><code>    file, _ := getFile() &#x2F;&#x2F; The second return argument is an error.
    if file == nil {
        fileUnavailable()
    }
</code></pre>
I doubt either way makes much difference in this contrived example, but the difference shows up when it extends out into real code. There are plusses and minuses to each way of seeing the world. Tradeoffs, as always.</div><br/><div id="36399039" class="c"><input type="checkbox" id="c-36399039" checked=""/><div class="controls bullet"><span class="by">nulld3v</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398940">parent</a><span>|</span><a href="#36399227">next</a><span>|</span><label class="collapse" for="c-36399039">[-]</label><label class="expand" for="c-36399039">[18 more]</label></div><br/><div class="children"><div class="content">But in Rust you can do the same, I do this all the time:<p><pre><code>  let _ = fs::mkdir_all() &#x2F;&#x2F; Error ignored, Rust will not complain because you explicitly assigned to _

</code></pre>
Or if the function returns something I need but I don&#x27;t care about the error:<p><pre><code>  let Ok(file) = get_file() else {
    file_unavailable();
    return
  }

  upload_file(file);
</code></pre>
Or this:<p><pre><code>  let file = get_file().unwrap_or_default()</code></pre></div><br/><div id="36399225" class="c"><input type="checkbox" id="c-36399225" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399039">parent</a><span>|</span><a href="#36399227">next</a><span>|</span><label class="collapse" for="c-36399225">[-]</label><label class="expand" for="c-36399225">[17 more]</label></div><br/><div class="children"><div class="content">Is this yet another thinly veiled Rust advertisement or did you forget to finish writing the comment? There was no question about whether or not you could achieve the same outcome in Rust... or any other language under the sun.</div><br/><div id="36399309" class="c"><input type="checkbox" id="c-36399309" checked=""/><div class="controls bullet"><span class="by">nulld3v</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399225">parent</a><span>|</span><a href="#36399227">next</a><span>|</span><label class="collapse" for="c-36399309">[-]</label><label class="expand" for="c-36399309">[16 more]</label></div><br/><div class="children"><div class="content">So what is the point of the distinction then? The examples I gave were idomatic Rust too.<p>Both Go and Rust hand the caller an error and the caller then must do something with the error. In both Go and Rust, you can assign the error to underscore and ignore it.<p>Java is different but we aren&#x27;t talking about Java right now.<p>The only difference is that in Go the function can (and must) still provide a value for &quot;file&quot; even when there is an error. In Rust you can kind of do something similar, by giving the File struct a default value (that&#x27;s what &quot;unwrap_or_default()&quot; is) but it isn&#x27;t exactly the same. I would argue that such a case is extremely rare though.</div><br/><div id="36399499" class="c"><input type="checkbox" id="c-36399499" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399309">parent</a><span>|</span><a href="#36399227">next</a><span>|</span><label class="collapse" for="c-36399499">[-]</label><label class="expand" for="c-36399499">[15 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Both Go and Rust hand the caller an error and the caller then must do something with the error.</i><p>This is simply not true. Go preaches that values should always be useful. Given a return signature (T, error), the value of type T can be used irrespective of what is contained in the value of type error. They are independent states.<p><i>&gt; The only difference is that Go provides a value for &quot;file&quot; when there is an error.</i><p>Yes, that is ultimately the difference. Result takes what are independent states and tries to make them dependent. Result&lt;T, error&gt; assumes that if there is a value of type error then the caller would not make use of the value of type T.<p>Often they will be dependent for all practical purposes. It is not an unreasonable assumption to assume that they are, especially if you know the caller. However, Go believes you cannot make that assumption. That you have to let the caller determine what it finds useful, not what you think it might find useful. Ease of code reusability is clearly a design goal of Go, so the idea that you can&#x27;t get to know your callers and how they will use your function isn&#x27;t unwarranted.<p>Tradeoffs, as always.</div><br/><div id="36399563" class="c"><input type="checkbox" id="c-36399563" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399499">parent</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36399563">[-]</label><label class="expand" for="c-36399563">[13 more]</label></div><br/><div class="children"><div class="content">Result covers the very common case where there is T or error but never both. Having a decent type system doesn&#x27;t prevent you from returning both. In Go I simply cannot have something as simple as &quot;A or B, but never both or neither&quot; as a type.<p>&gt;However, Go believes you cannot make that assumption.<p>This is trying to twist a weakness of Go&#x27;s type system as a virtue. In Go I always have &quot;A or B, including neither and both&quot;. I can have that in Rust or Haskell if I want, but usually I want &quot;A or B, never both or neither&quot; and rarely &quot;A or B, sometimes both but never neither&quot; which Rust and Haskell can do but Go cannot. This comes from Go using product types as a poor replacement for sum types.</div><br/><div id="36399627" class="c"><input type="checkbox" id="c-36399627" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399563">parent</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36399627">[-]</label><label class="expand" for="c-36399627">[12 more]</label></div><br/><div class="children"><div class="content"><i>&gt; This is trying to twist a weakness of Go&#x27;s type system as a virtue. </i><p>No. There is no discussion about type systems taking place here at all. The discussion is about patterns where the producer or the consumer is in control. Specifically, Result puts the producer in control. Idiomatic Go (T, error) sees the consumer in control.<p>There is likely no language in existence that prevents you from choosing. You can write code where the producer is in control in Go, and you can write code where the consumer is in control in every other. These are not features of a language, although language idioms do often push developers one way or the other.</div><br/><div id="36399696" class="c"><input type="checkbox" id="c-36399696" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399627">parent</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36399696">[-]</label><label class="expand" for="c-36399696">[11 more]</label></div><br/><div class="children"><div class="content">This entire discussion is about the type system and how it interacts with the language. Go does not have sum types, so the producer cannot signal to the consumer what it can produce and what the consumer has to handle. The consumer in Go must pessimistically assume the all combinations of return values are possible, where in a language with a decent type system the possible cases can be enumerated and handled appropriately.<p>&gt;Idiomatic Go sees the caller in control.<p>This is simply not true. If the producer never returns A+B, then the consumer is never going to magic that into existence. The producer is always in control of what the producer returns.<p>&gt;Specifically, Result puts the producer in control.<p>Result is just a convenience type for the very common case of a function returning &quot;A or B, but never both or neither.&quot; If your producer does not match that, you are not forced by the language to use Result. In Go, you are always forced by the language to return a value of type &quot;A or B, including both or neither.&quot; The consumer isn&#x27;t any more in control, it just has to guess whether &quot;both or neither&quot; are possible return types. In Rust&#x2F;Haskell&#x2F;Ocaml&#x2F;Java, hell even C++ with variant or C with union, I can return something or with a more restrictive type. Honestly Go is uniquely incapable of representing these cases in its type system and control flow.</div><br/><div id="36399911" class="c"><input type="checkbox" id="c-36399911" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399696">parent</a><span>|</span><a href="#36399863">next</a><span>|</span><label class="collapse" for="c-36399911">[-]</label><label class="expand" for="c-36399911">[6 more]</label></div><br/><div class="children"><div class="content">&gt; In Go, you are always forced by the language to return a value of type &quot;A or B, including both or neither.&quot; The consumer isn&#x27;t any more in control, it just has to guess whether &quot;both or neither&quot; are possible return types.<p>it does not have to guess<p>convention dictates either one or the other<p>is convention enough? is it roughly the same as compiler-enforced rules? you&#x27;re free to say &quot;no&quot; but it is not like a guarantee</div><br/><div id="36399945" class="c"><input type="checkbox" id="c-36399945" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399911">parent</a><span>|</span><a href="#36399863">next</a><span>|</span><label class="collapse" for="c-36399945">[-]</label><label class="expand" for="c-36399945">[5 more]</label></div><br/><div class="children"><div class="content">&gt;convention dictates either one or the other<p>Convention is just an educated guess.<p>&gt;is it [convention] roughly the same as compiler-enforced rules?<p>No. The answer is no. I&#x27;m not only free to say &quot;no,&quot; but if I&#x27;m honest and truthful I am compelled to say &quot;no.&quot;</div><br/><div id="36400137" class="c"><input type="checkbox" id="c-36400137" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399945">parent</a><span>|</span><a href="#36399863">next</a><span>|</span><label class="collapse" for="c-36400137">[-]</label><label class="expand" for="c-36400137">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Convention is just an educated guess.<p>at some absolute level yes, but at any pragmatic level no, definitely not<p>&gt; No. The answer is no. I&#x27;m not only free to say &quot;no,&quot; but if I&#x27;m honest and truthful I am compelled to say &quot;no.&quot;<p>nope! wrong. do not pass go, etc. -- it&#x27;s a spectrum</div><br/><div id="36400183" class="c"><input type="checkbox" id="c-36400183" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36400137">parent</a><span>|</span><a href="#36399863">next</a><span>|</span><label class="collapse" for="c-36400183">[-]</label><label class="expand" for="c-36400183">[3 more]</label></div><br/><div class="children"><div class="content">&gt;nope! wrong. do not pass go, etc. -- it&#x27;s a spectrum<p>You are simply incorrect, there&#x27;s no nuance or room for interpretation. A compiler can guarantee &quot;A or B, but not both or neither&quot;, &quot;A or B or both, but never neither&quot;, or even &quot;A or B or both or neither&quot; but convention for (A, B) in Go cannot, therefore it is not as good. Go&#x27;s conventions are not as good as a decent type system, there&#x27;s no spectrum about it; Go is always &quot;A or B or both or neither&quot; with no ability to exclude impossible&#x2F;nonsense cases. In Go if I want to write robust, correct code I must always handle all 2^N cases for N arguments, which no one actually does.</div><br/><div id="36400392" class="c"><input type="checkbox" id="c-36400392" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36400183">parent</a><span>|</span><a href="#36399863">next</a><span>|</span><label class="collapse" for="c-36400392">[-]</label><label class="expand" for="c-36400392">[2 more]</label></div><br/><div class="children"><div class="content">you&#x27;re saying that guarantees which are not enforced by the compiler are &quot;not as good&quot; as those which are<p>this is not correct<p>but i&#x27;m not sure how to convince you of this truth, so (shrug)</div><br/><div id="36400452" class="c"><input type="checkbox" id="c-36400452" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36400392">parent</a><span>|</span><a href="#36399863">next</a><span>|</span><label class="collapse" for="c-36400452">[-]</label><label class="expand" for="c-36400452">[1 more]</label></div><br/><div class="children"><div class="content">Well, yes. I do think something that is guaranteed is better than something that is not guaranteed. You&#x27;ve at least somewhat accurately captured my position, though with the weird implicit assumption that &quot;guaranteed by convention&quot; means anything at all.<p>&gt;but i&#x27;m not sure how to convince you of this truth, so (shrug)<p>You&#x27;d need some pretty compelling evidence to convince me that something that is not guaranteed is as good as something that is guaranteed, so I can see why you&#x27;re struggling. With your admissions, all I can really say is good luck convincing me or anyone.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36399863" class="c"><input type="checkbox" id="c-36399863" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399696">parent</a><span>|</span><a href="#36399911">prev</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36399863">[-]</label><label class="expand" for="c-36399863">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; This entire discussion is about the type system and how it interacts with the language.</i><p>No. The discussion opened to say that Result is better than the pattern used in Go. In other words, dependent state is better than independent state. I said that dependent state puts the producer in control, while independent state puts the consumer in control and that there are pluses and minuses to each approach, with neither being better, just different tradeoffs.<p>We continued to discuss that control and how Result, exceptions, and the (T, error) pattern play into that. Somewhere in the middle was a regularly scheduled Rust advertisement, but following that returned to the same topic. A topic that is not, and never has been, about type systems. And it isn&#x27;t even about any particular programming language, even if Go was used to call out a pattern that the original commenter didn&#x27;t have a better name for.<p><i>&gt; If your producer does not match that, you are not forced by the language to use Result.</i><p>So, in other words: Dependent state puts the producer in control, while independent state puts the consumer in control and that there are pluses and minuses to each approach, with neither being better, just different tradeoffs...?<p>It is curious how the word Go causes minds to shut down.</div><br/><div id="36399930" class="c"><input type="checkbox" id="c-36399930" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399863">parent</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36399930">[-]</label><label class="expand" for="c-36399930">[3 more]</label></div><br/><div class="children"><div class="content">&gt;The discussion opened to say that Result is better than the pattern used in Go<p>You are trying to paint a false dichotomy between Rust&#x27;s Result&lt;T, error&gt; and Go&#x27;s (T, error). In reality the dichotomy is between sum types (which Result is a very simple case of) and languages without sum types, of which Go is one of a very small set. The key difference is that Result is available as an option in Rust&#x2F;Haskell&#x2F;Ocaml&#x2F;etc, and I&#x27;m free to not use Result if it&#x27;s not the right fit, where in Go the only option is to use a product type.<p>Result&lt;A,B&gt; and the ? operator are shortcuts for concisely handling the very common case of handling &quot;A or B, but never both or neither.&quot; If your producer doesn&#x27;t fit that, you&#x27;re free to define your own sum type. In Go, you are simply unable to represent these and must cover all four cases (or eight, or sixteen, or thirty-two, etc, as the function grows in complexity).<p>Nothing I&#x27;m saying is specific to Rust either, despite your appealing to conspiracies, and Rust&#x27;s ideas are not new, not by decades. Haskell, Ocaml, Java, C++, typescript, etc, (even C with a bit of squinting) all have basic sum types and can encode &quot;A or B, but never both or neither&quot; and &quot;A or B or both, but never neither&quot; in their type systems and control flow in a way that Go cannot. Rust didn&#x27;t pioneer the idea of a basic sum types, Go is just uniquely (among popular statically types languages from the last 50 years) incapable of representing them.<p>&gt;So, in other words: Dependent state puts the producer in control, while independent state puts the consumer in control and that there are pluses and minuses to each approach, with neither being better, just different tradeoffs...?<p>No, this is complete nonsense. In Go, if I never write &quot;return nonNilFile, nonNilError&quot;, the consumer cannot magic that into existence. Your entire position about languages being consumer controlled vs producer controlled is entirely nonsense. Consumers cannot rewrite the code of the functions they call.</div><br/><div id="36399993" class="c"><input type="checkbox" id="c-36399993" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399930">parent</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36399993">[-]</label><label class="expand" for="c-36399993">[2 more]</label></div><br/><div class="children"><div class="content">The thing is, that very false dichotomy was painted before my time. I refuted it. And you have spent your time claiming to refute what I said, albeit using random tangents that don&#x27;t pertain to anything, which must mean that you too want to paint the false dichotomy? That or you didn&#x27;t bother to read anything and just hope and pray that if you say type system enough times someone will bite even though it is the most boring topic imaginable and, as such, nobody ever will.</div><br/><div id="36400045" class="c"><input type="checkbox" id="c-36400045" checked=""/><div class="controls bullet"><span class="by">awused</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399993">parent</a><span>|</span><a href="#36400336">next</a><span>|</span><label class="collapse" for="c-36400045">[-]</label><label class="expand" for="c-36400045">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The thing is, the false dichotomy was painted before my time. I refuted it.<p>No, it wasn&#x27;t and you didn&#x27;t. Result is one option among many in Rust which covers the common case with concise syntax, where (T, error) is the only option in Go. I am free to return a Success&lt;T&gt;, PartialSucceess&lt;T + Error&gt;, Failure &lt;Error&gt; in Rust&#x2F;Java&#x2F;C++&#x2F;Ocaml&#x2F;Typescript. I think you&#x27;re operating on some profound misunderstandings about Rust, Haskell, Ocaml, Java, Typescript, C++, and even C. I don&#x27;t think you&#x27;re open to trying Rust, but maybe you&#x27;d be open to playing with std::variant in C++ or manually tagging unions in C, to see what those languages can do that Go cannot. Try writing a C++ function that returns std::variant between T, std:::tuple&lt;T, Error&gt;, and Error. That&#x27;s only 3 cases, which Go cannot do.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="36400336" class="c"><input type="checkbox" id="c-36400336" checked=""/><div class="controls bullet"><span class="by">nulld3v</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399499">parent</a><span>|</span><a href="#36399563">prev</a><span>|</span><a href="#36399227">next</a><span>|</span><label class="collapse" for="c-36400336">[-]</label><label class="expand" for="c-36400336">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go preaches that values should always be useful<p>This is already false. Not all values are useful, for example, the value of this string is not useful to you: &quot;i have cheese&quot;.<p>Without knowing the caller, values can be &quot;possibly useful&quot; at best.<p>&gt; Often they will be dependent for all practical purposes. It is not an unreasonable assumption to assume that they are, especially if you know the caller. However, Go believes you cannot make that assumption. That you have to let the caller determine what it finds useful, not what you think it might find useful.<p>In Go, functions always assume the caller needs both a valid value of T and error, even when T has no value. Functions should synthesize some value for T should T not currently have a value at return time.<p>In Rust, most functions assume the caller needs either a valid value of T or Error. Should a valid value of T exist at return time, it will be discarded.<p>Both languages make assumptions.<p>&gt; Tradeoffs, as always.<p>Assumptions come with tradeoffs, however, not all tradeoffs are equal in consequence and possibility.<p>99% of the time, a caller does not need T if there is an Error. Therefore, why make this tradeoff?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36399227" class="c"><input type="checkbox" id="c-36399227" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398940">parent</a><span>|</span><a href="#36399039">prev</a><span>|</span><a href="#36398090">next</a><span>|</span><label class="collapse" for="c-36399227">[-]</label><label class="expand" for="c-36399227">[1 more]</label></div><br/><div class="children"><div class="content">You mean file == nil.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36398090" class="c"><input type="checkbox" id="c-36398090" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398060">parent</a><span>|</span><a href="#36398510">prev</a><span>|</span><a href="#36398693">next</a><span>|</span><label class="collapse" for="c-36398090">[-]</label><label class="expand" for="c-36398090">[6 more]</label></div><br/><div class="children"><div class="content">The killer feature of Rust&#x27;s Result isn&#x27;t actually the monad itself, it&#x27;s the ? operator. Being able to concisely say &quot;if there&#x27;s an error, bail out by returning it&quot; gets you pretty close to exception-level convenience with just a bit more explicit syntax showing where an error might come from.</div><br/><div id="36400491" class="c"><input type="checkbox" id="c-36400491" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398090">parent</a><span>|</span><a href="#36398719">next</a><span>|</span><label class="collapse" for="c-36400491">[-]</label><label class="expand" for="c-36400491">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve not used Rust. Do you get to add context at the point of bailing?</div><br/><div id="36400959" class="c"><input type="checkbox" id="c-36400959" checked=""/><div class="controls bullet"><span class="by">dthul</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36400491">parent</a><span>|</span><a href="#36398719">next</a><span>|</span><label class="collapse" for="c-36400959">[-]</label><label class="expand" for="c-36400959">[1 more]</label></div><br/><div class="children"><div class="content">That depends on the type you use to represent errors. A more &quot;fancy&quot; error type will allow you to add context &#x2F; backtraces &#x2F; whatever you want, while a simpler error type, for example just an error code, does not. (The error type is the E in Result&lt;T, E&gt;).</div><br/></div></div></div></div><div id="36398719" class="c"><input type="checkbox" id="c-36398719" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398090">parent</a><span>|</span><a href="#36400491">prev</a><span>|</span><a href="#36398693">next</a><span>|</span><label class="collapse" for="c-36398719">[-]</label><label class="expand" for="c-36398719">[3 more]</label></div><br/><div class="children"><div class="content">you don&#x27;t want exception-style &quot;convenience&quot;, that&#x27;s the whole point<p>you want to be able to read code and see a single control flow<p>? subverts that core requirement</div><br/><div id="36398828" class="c"><input type="checkbox" id="c-36398828" checked=""/><div class="controls bullet"><span class="by">nulld3v</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398719">parent</a><span>|</span><a href="#36398693">next</a><span>|</span><label class="collapse" for="c-36398828">[-]</label><label class="expand" for="c-36398828">[2 more]</label></div><br/><div class="children"><div class="content">The problem with exceptions is that they can come from any line of code and cause a &quot;return&quot;. Rust&#x27;s question mark solves the issue because it marks which lines of code can cause a &quot;return&quot;.<p>Therefore, you can always see see the control flow of a function.<p>Moreover, you can go even further if you really really really want a single control flow. You can write a clippy lint to disallow early returns (ban &quot;return&quot; keyword) and question marks. That said, I really don&#x27;t think this is a good idea. The &quot;return&quot; keyword exists for a good reason.</div><br/><div id="36399339" class="c"><input type="checkbox" id="c-36399339" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398828">parent</a><span>|</span><a href="#36398693">next</a><span>|</span><label class="collapse" for="c-36399339">[-]</label><label class="expand" for="c-36399339">[1 more]</label></div><br/><div class="children"><div class="content">? enables chaining, chaining subverts comprehensibility in exactly the ways i&#x27;m describing</div><br/></div></div></div></div></div></div></div></div><div id="36398693" class="c"><input type="checkbox" id="c-36398693" checked=""/><div class="controls bullet"><span class="by">nemothekid</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398060">parent</a><span>|</span><a href="#36398090">prev</a><span>|</span><a href="#36398377">next</a><span>|</span><label class="collapse" for="c-36398693">[-]</label><label class="expand" for="c-36398693">[6 more]</label></div><br/><div class="children"><div class="content">The Rust code you have isn&#x27;t idiomatic. It&#x27;s gar more likely to see:<p><pre><code>    let greeting_file = File::open(&quot;hello.txt&quot;)?l
</code></pre>
vs<p><pre><code>    file, err := os.Open(&quot;hello.txt&quot;)
    if err != nil {
          return fmt.errorf(&quot;faild to open hello; %w, err)
    }
</code></pre>
However, I would argue the distinction isn&#x27;t just cosmetic. The compiler <i>prevents</i> me from not checking the error and blowing up the application with a nil pointer exception.<p>The TFA even capes this pattern:<p><pre><code>    type Result[T any] struct {
        Value T
        Error error
    }
</code></pre>
and I wonder if we will start to see it more now that generics are in Go.</div><br/><div id="36398813" class="c"><input type="checkbox" id="c-36398813" checked=""/><div class="controls bullet"><span class="by">dlisboa</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398693">parent</a><span>|</span><a href="#36398756">next</a><span>|</span><label class="collapse" for="c-36398813">[-]</label><label class="expand" for="c-36398813">[2 more]</label></div><br/><div class="children"><div class="content">Not a Rust programmer, but I took the Rust code from the Rust book. Admittedly I didn’t read the whole chapter, perhaps they talk idioms later.</div><br/><div id="36399450" class="c"><input type="checkbox" id="c-36399450" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398813">parent</a><span>|</span><a href="#36398756">next</a><span>|</span><label class="collapse" for="c-36399450">[-]</label><label class="expand" for="c-36399450">[1 more]</label></div><br/><div class="children"><div class="content">You just needed to go down a bit further [0]. They understandably didn&#x27;t want to introduce syntactic sugar until after they&#x27;d introduced the syntax it desugars into.<p>[0] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch09-02-recoverable-errors-wi...</a></div><br/></div></div></div></div><div id="36398756" class="c"><input type="checkbox" id="c-36398756" checked=""/><div class="controls bullet"><span class="by">philozzzozzz</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398693">parent</a><span>|</span><a href="#36398813">prev</a><span>|</span><a href="#36398377">next</a><span>|</span><label class="collapse" for="c-36398756">[-]</label><label class="expand" for="c-36398756">[3 more]</label></div><br/><div class="children"><div class="content">Where is the error handling in your Rust code?</div><br/><div id="36398832" class="c"><input type="checkbox" id="c-36398832" checked=""/><div class="controls bullet"><span class="by">kinghajj</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398756">parent</a><span>|</span><a href="#36398377">next</a><span>|</span><label class="collapse" for="c-36398832">[-]</label><label class="expand" for="c-36398832">[2 more]</label></div><br/><div class="children"><div class="content">The `?` at the end of the Rust example expands into the equivalent of the Go `if err != nil` idiom.</div><br/><div id="36400718" class="c"><input type="checkbox" id="c-36400718" checked=""/><div class="controls bullet"><span class="by">philozzzozzz</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398832">parent</a><span>|</span><a href="#36398377">next</a><span>|</span><label class="collapse" for="c-36400718">[-]</label><label class="expand" for="c-36400718">[1 more]</label></div><br/><div class="children"><div class="content">You are illustrating the point beautifully.</div><br/></div></div></div></div></div></div></div></div><div id="36398377" class="c"><input type="checkbox" id="c-36398377" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398060">parent</a><span>|</span><a href="#36398693">prev</a><span>|</span><a href="#36398517">next</a><span>|</span><label class="collapse" for="c-36398377">[-]</label><label class="expand" for="c-36398377">[5 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s error handling and option types actually aren&#x27;t monads, they just have similar ergonomics for end users.  There&#x27;s some tricks that have to be done to make them work in a eager evaluation context, and as a result implementing iterator combinators does <i>not</i> feel like working with modads.</div><br/><div id="36398679" class="c"><input type="checkbox" id="c-36398679" checked=""/><div class="controls bullet"><span class="by">mkehrt</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398377">parent</a><span>|</span><a href="#36398517">next</a><span>|</span><label class="collapse" for="c-36398679">[-]</label><label class="expand" for="c-36398679">[4 more]</label></div><br/><div class="children"><div class="content">In what sense aren&#x27;t they monads? They have a bind method (&quot;and_then&quot;) and a return method (Which is just the variant for constructing the success case, i.e. &quot;Ok&quot; or &quot;Some&quot;).  It&#x27;s more idiomatic to use &quot;map&quot;, but that&#x27;s just a degenerate case of bind.<p>&gt; There&#x27;s some tricks that have to be done to make them work in a eager evaluation context...<p>Monads have nothing to do with laziness, though.  In Haskell, IO actions are used with laziness and to work around purity, and IO actions form a monad.  But that&#x27;s just one instance of monad.</div><br/><div id="36399323" class="c"><input type="checkbox" id="c-36399323" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398679">parent</a><span>|</span><a href="#36398517">next</a><span>|</span><label class="collapse" for="c-36399323">[-]</label><label class="expand" for="c-36399323">[3 more]</label></div><br/><div class="children"><div class="content">After doing some research to refresh my memory I found this old thread: <a href="https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;what-is-a-monad-and-who-needs-haskell-anyway&#x2F;45710&#x2F;7" rel="nofollow noreferrer">https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;what-is-a-monad-and-who-needs-...</a><p>I believe what I had originally told that makes them not monads is that because Rust goes through some convlutions to <i>fake</i> the <i>laziness</i> of Haskell monads, it makes them not be typed like Haskell monads.<p>For example, the declaration of the `.flat_map` on an iterator is actually `fn flat_map&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt; where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -&gt; U`, which uses a &quot;do-er&quot; struct instance of `FlatMap` and is itself another iterator.  Evaluating the entire monad-ish iterator combinator chain with something like `.collect()` or `.last()` or something is what triggers the evaluation.</div><br/><div id="36400127" class="c"><input type="checkbox" id="c-36400127" checked=""/><div class="controls bullet"><span class="by">yw3410</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399323">parent</a><span>|</span><a href="#36399864">next</a><span>|</span><label class="collapse" for="c-36400127">[-]</label><label class="expand" for="c-36400127">[1 more]</label></div><br/><div class="children"><div class="content">Monads have nothing to do with laziness and we&#x27;re talking about the Result type anyway.<p>OP is correct. If it has a bind, pure and map (which it does!) then for all intents it forms a monad.<p>Now the fact is you can&#x27;t _manipulate_ monads in Rust easily (see kinds and discussions wrt GAT), but nonetheless monads are present in all languages with ADTs in the same way that rings are present in all languages with addition.</div><br/></div></div><div id="36399864" class="c"><input type="checkbox" id="c-36399864" checked=""/><div class="controls bullet"><span class="by">mkehrt</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36399323">parent</a><span>|</span><a href="#36400127">prev</a><span>|</span><a href="#36398517">next</a><span>|</span><label class="collapse" for="c-36399864">[-]</label><label class="expand" for="c-36399864">[1 more]</label></div><br/><div class="children"><div class="content">Ah interesting.  I think it&#x27;s close enough as to make no difference, but I see what you&#x27;re saying.</div><br/></div></div></div></div></div></div></div></div><div id="36398517" class="c"><input type="checkbox" id="c-36398517" checked=""/><div class="controls bullet"><span class="by">justinsaccount</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398060">parent</a><span>|</span><a href="#36398377">prev</a><span>|</span><a href="#36398059">next</a><span>|</span><label class="collapse" for="c-36398517">[-]</label><label class="expand" for="c-36398517">[7 more]</label></div><br/><div class="children"><div class="content">The biggest difference is in rust you have to handle the error case, but in go you can accidentally ignore it.</div><br/><div id="36398818" class="c"><input type="checkbox" id="c-36398818" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398517">parent</a><span>|</span><a href="#36398930">next</a><span>|</span><label class="collapse" for="c-36398818">[-]</label><label class="expand" for="c-36398818">[1 more]</label></div><br/><div class="children"><div class="content">I believe there is a vet check for this. So while the compiler won’t stop you from ignoring errors, it will tell you that you aren’t checking an error. Yes, you can ignore the error with _, but then it isn’t accidental.</div><br/></div></div><div id="36398930" class="c"><input type="checkbox" id="c-36398930" checked=""/><div class="controls bullet"><span class="by">jppittma</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398517">parent</a><span>|</span><a href="#36398818">prev</a><span>|</span><a href="#36398680">next</a><span>|</span><label class="collapse" for="c-36398930">[-]</label><label class="expand" for="c-36398930">[3 more]</label></div><br/><div class="children"><div class="content">This seams silly and nitpicks to my. In go, you have to assign the error, and if you assign it you have to use the variable. I&#x27;ve never seen this mistake before in my years of using go.</div><br/><div id="36399690" class="c"><input type="checkbox" id="c-36399690" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398930">parent</a><span>|</span><a href="#36399119">next</a><span>|</span><label class="collapse" for="c-36399690">[-]</label><label class="expand" for="c-36399690">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In go, you have to assign the error, and if you assign it you have to use the variable.<p>Nope. Go errors on dead variables, not on dead stores.<p>And because idiomatic go tends to reassign errors to the same variable if you have multiple error-returning functions in the same scope any one of them being checked will make the compiler happy.<p>You also do not have to assign the error at all, you can just ignore the entire thing.</div><br/></div></div><div id="36399119" class="c"><input type="checkbox" id="c-36399119" checked=""/><div class="controls bullet"><span class="by">nulld3v</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398930">parent</a><span>|</span><a href="#36399690">prev</a><span>|</span><a href="#36398680">next</a><span>|</span><label class="collapse" for="c-36399119">[-]</label><label class="expand" for="c-36399119">[1 more]</label></div><br/><div class="children"><div class="content">Going to link my comment here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36398874">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36398874</a></div><br/></div></div></div></div><div id="36398680" class="c"><input type="checkbox" id="c-36398680" checked=""/><div class="controls bullet"><span class="by">philozzzozzz</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398517">parent</a><span>|</span><a href="#36398930">prev</a><span>|</span><a href="#36398059">next</a><span>|</span><label class="collapse" for="c-36398680">[-]</label><label class="expand" for="c-36398680">[2 more]</label></div><br/><div class="children"><div class="content">No compiler can force you to handle an error.<p>Rust might force you to access a value. Big. Fucking. Deal.</div><br/><div id="36398706" class="c"><input type="checkbox" id="c-36398706" checked=""/><div class="controls bullet"><span class="by">mkehrt</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398680">parent</a><span>|</span><a href="#36398059">next</a><span>|</span><label class="collapse" for="c-36398706">[-]</label><label class="expand" for="c-36398706">[1 more]</label></div><br/><div class="children"><div class="content">The point isn&#x27;t that it forces you to access the error.  The point is that it <i>prevents</i> you from accessing an invalid return value.</div><br/></div></div></div></div></div></div></div></div><div id="36398059" class="c"><input type="checkbox" id="c-36398059" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#36397877">parent</a><span>|</span><a href="#36398060">prev</a><span>|</span><a href="#36398528">next</a><span>|</span><label class="collapse" for="c-36398059">[-]</label><label class="expand" for="c-36398059">[3 more]</label></div><br/><div class="children"><div class="content">&gt; F#, Swift and Rust have a perfect error handling mechanism.<p>Rust&#x27;s is good but not perfect. I often find myself missing stack traces (there are solutions but they&#x27;re not easy to use), and you&#x27;re still constrained to a single type of error per function, which means you see a proliferation of specialized error types that are mutually incompatible and have to be converted back and forth.</div><br/><div id="36398149" class="c"><input type="checkbox" id="c-36398149" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398059">parent</a><span>|</span><a href="#36398390">next</a><span>|</span><label class="collapse" for="c-36398149">[-]</label><label class="expand" for="c-36398149">[1 more]</label></div><br/><div class="children"><div class="content">Interesting. That’s fair. To be completely honest, out of the 3 I listed, I’m only familiar with putting an F# service into production. We’re a very heavy C# shop (legacy Java shop, but anything since 2015 has been in C#) and I thought I could slip in an F# project in there. And I was able to until I needed to hand it over to another team that wrote wrappers to all the F# code in C# and did all new development in C#. Swift and Rust error handling reminded me of how nice error handing felt in F#. But I only did very simple toy projects in them.</div><br/></div></div><div id="36398390" class="c"><input type="checkbox" id="c-36398390" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398059">parent</a><span>|</span><a href="#36398149">prev</a><span>|</span><a href="#36398528">next</a><span>|</span><label class="collapse" for="c-36398390">[-]</label><label class="expand" for="c-36398390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you&#x27;re still constrained to a single type of error per function<p>This is true, but the ? operator expands into a form that does `.into()` conversions of the error variants.  If there&#x27;s a implementation of `From`&#x2F;`Into` between the error type you&#x27;re unwrapping and the error type on the function, it automatically converts.  This is aided by the &quot;thiserror&quot; crate which provides a derive macro that can generate these automatically.</div><br/></div></div></div></div><div id="36398528" class="c"><input type="checkbox" id="c-36398528" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#36397877">parent</a><span>|</span><a href="#36398059">prev</a><span>|</span><a href="#36398663">next</a><span>|</span><label class="collapse" for="c-36398528">[-]</label><label class="expand" for="c-36398528">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; It’s something 100% of go users have to deal with in almost every single function call. There is something clearly special about it.</i><p>I can&#x27;t help but feel there is an even greater generalization here. The error problem you speak of actually applies to every type. To zoom in on errors alone may be missing the forest for the trees. It seems what is special is the need to handle values returned by a function, which includes, but is not limited to, error values. It is something 100% of Go users will have to do almost every time they call a function. Even those which do not return errors.<p><i>&gt; Swift and Rust have a perfect error handling mechanism.</i><p>Within their respective languages they may be a good fit, but those languages are producer centric. Go is consumer centric. That leaves an impedance mismatch. I do think there is something better out there for Go, but I&#x27;m not sure that is where we are going to find it.</div><br/></div></div><div id="36398663" class="c"><input type="checkbox" id="c-36398663" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397877">parent</a><span>|</span><a href="#36398528">prev</a><span>|</span><a href="#36399650">next</a><span>|</span><label class="collapse" for="c-36398663">[-]</label><label class="expand" for="c-36398663">[3 more]</label></div><br/><div class="children"><div class="content">if you write a line of code that can fail, then you should deal with the possibility of that line failing there, directly, in-line<p>_how_ you deal with that failure is a separate question<p>but it&#x27;s critical that every fallible expression explicitly and visibly demonstrates the possibility of failure<p>this is in no way an &quot;error handling mess&quot; -- on the contrary, it is basically the only way to produce robust and reliable software at scale</div><br/><div id="36400024" class="c"><input type="checkbox" id="c-36400024" checked=""/><div class="controls bullet"><span class="by">cwalv</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398663">parent</a><span>|</span><a href="#36398795">next</a><span>|</span><label class="collapse" for="c-36400024">[-]</label><label class="expand" for="c-36400024">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, the vast majority of the time the best (or only) way to correctly deal with the error is to propagate it up the stack. Making this optional (having to explicitly check return values) doesn&#x27;t make it more likely to be done.</div><br/></div></div><div id="36398795" class="c"><input type="checkbox" id="c-36398795" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36397877">root</a><span>|</span><a href="#36398663">parent</a><span>|</span><a href="#36400024">prev</a><span>|</span><a href="#36399650">next</a><span>|</span><label class="collapse" for="c-36398795">[-]</label><label class="expand" for="c-36398795">[1 more]</label></div><br/><div class="children"><div class="content">i wish people understood this thinking about and handling all errors, as a prime functiom of the code, is why things like Linux and C Python and X server and git and so on are so reliable.</div><br/></div></div></div></div></div></div><div id="36399650" class="c"><input type="checkbox" id="c-36399650" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36397877">prev</a><span>|</span><a href="#36401309">next</a><span>|</span><label class="collapse" for="c-36399650">[-]</label><label class="expand" for="c-36399650">[43 more]</label></div><br/><div class="children"><div class="content">Could someone explain why is Go so hyped?<p>In my personal opinion it is just not a good language, and I think many judge it based on some false basis that it is somehow “close to the hardware” because it produces a binary. Like, the amount of time it is put next to Rust when the two have almost nothing in common..<p>It is very verbose, yet Java is the one that is called that, often by Gophers, which is much more concise. It has terrible expressivity, a managed language which is a perfectly fine design choice, yet seemingly every other language with a GC is somehow living in sin.<p>And still, it doesn’t fail to show up each day on HN.</div><br/><div id="36399727" class="c"><input type="checkbox" id="c-36399727" checked=""/><div class="controls bullet"><span class="by">SmooL</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400229">next</a><span>|</span><label class="collapse" for="c-36399727">[-]</label><label class="expand" for="c-36399727">[5 more]</label></div><br/><div class="children"><div class="content">1. It&#x27;s opinionated, so there&#x27;s often only one way of doings things. Largely, the &quot;one way&quot; is a good way, so people appreciate the forced consistency
2. It&#x27;s simple. It is very easy to read and write. It is hard to shoot yourself in the foot.
3. It&#x27;s powerful. They have a few core abstractions that compose well (generic io, http stuff).
4. It&#x27;s fast. It runs fast because it&#x27;s compiled, and it compiles fast because it&#x27;s simple.<p>Me personally: I appreciate the simplicity of it. It&#x27;s a great language for working with in a team. I wish it was more functional, and had better ways to handle errors, but the simplicity of it all was a breath of fresh air using it in a working environment.</div><br/><div id="36399869" class="c"><input type="checkbox" id="c-36399869" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399727">parent</a><span>|</span><a href="#36400229">next</a><span>|</span><label class="collapse" for="c-36399869">[-]</label><label class="expand" for="c-36399869">[4 more]</label></div><br/><div class="children"><div class="content">You can shoot yourself in the foot with null pointers.</div><br/><div id="36399885" class="c"><input type="checkbox" id="c-36399885" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399869">parent</a><span>|</span><a href="#36400229">next</a><span>|</span><label class="collapse" for="c-36399885">[-]</label><label class="expand" for="c-36399885">[3 more]</label></div><br/><div class="children"><div class="content">You can find a gun to shoot yourself in the foot in any language.</div><br/><div id="36399957" class="c"><input type="checkbox" id="c-36399957" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399885">parent</a><span>|</span><a href="#36400009">next</a><span>|</span><label class="collapse" for="c-36399957">[-]</label><label class="expand" for="c-36399957">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is hard to shoot yourself in the foot.<p>&gt;&gt; You can find a gun to shoot yourself in the foot in any language.<p>Sure, but finding that one isn&#x27;t particularly hard, which is what GP was responding to</div><br/></div></div><div id="36400009" class="c"><input type="checkbox" id="c-36400009" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399885">parent</a><span>|</span><a href="#36399957">prev</a><span>|</span><a href="#36400229">next</a><span>|</span><label class="collapse" for="c-36400009">[-]</label><label class="expand" for="c-36400009">[1 more]</label></div><br/><div class="children"><div class="content">Well, it&#x27;s million dollar one though. It has been solved in many languages. It gives quite uneasy feeling that high percentage of your LoCs can be potentially affected, it doesn&#x27;t come from some contrived edge case code, it&#x27;s everywhere.</div><br/></div></div></div></div></div></div></div></div><div id="36400229" class="c"><input type="checkbox" id="c-36400229" checked=""/><div class="controls bullet"><span class="by">w7</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36399727">prev</a><span>|</span><a href="#36400235">next</a><span>|</span><label class="collapse" for="c-36400229">[-]</label><label class="expand" for="c-36400229">[1 more]</label></div><br/><div class="children"><div class="content">It has:<p>* Relatively simple syntax.<p>* &quot;Good enough&quot; expressivity-- nothing that&#x27;s considered &quot;missing&quot; has been a true blocker for most projects.<p>* An easily accessible concurrency primitive, with the bonus that the runtime can choose to execute goroutines in parallel (when able)-- this comes with no required function coloring or split in a code base.<p>* A well opinionated environment packaged with the compiler: default formatter, default method for fetching remote deps, default documentation generator, default race detector, default profiler, default testing system.<p>* Decent portability-- can cross compile relatively easily from one platform to another, doesn&#x27;t require a larger runtime pre-installed on the foreign host.<p>* &quot;Batteries included&quot; standard library.<p>* Inertia-- enough of an active community to pull what you need from the Internet, whether it&#x27;s guides or code.<p>* A &quot;good enough&quot; type system to catch some errors before they become runtime errors.<p>* A &quot;good enough&quot; abstraction for operating on data with: structs, interfaces, and methods. With composition being preferred over inheritance, and embedding bringing handy sugar.<p>No language is perfect, everyone has an opinion, but for many people this is &quot;close enough&quot; to what they prefer to work with.<p>Gophers may just be a bit more vocal about it.</div><br/></div></div><div id="36400235" class="c"><input type="checkbox" id="c-36400235" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400229">prev</a><span>|</span><a href="#36400314">next</a><span>|</span><label class="collapse" for="c-36400235">[-]</label><label class="expand" for="c-36400235">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m strongly convinced that the google brand name gave it a big push. Its predecessor (Limbo if I recall correctly) went nowhere. It did bring uncolored async to the mainstream, but as in typical golang fashion, it was very verbose and error prone.<p>Java learned the right lessons and I&#x27;m quite excited to see their structured concurrency approach. No need to pass channels and contexts everywhere to manually manage hierarchies from what I gather.</div><br/><div id="36400778" class="c"><input type="checkbox" id="c-36400778" checked=""/><div class="controls bullet"><span class="by">stephen123</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400235">parent</a><span>|</span><a href="#36400762">next</a><span>|</span><label class="collapse" for="c-36400778">[-]</label><label class="expand" for="c-36400778">[1 more]</label></div><br/><div class="children"><div class="content">Yea, I find go&#x27;s concurrency very error prone compared to something with futures.<p>I&#x27;ve even got a library for using futures in Go.
<a href="https:&#x2F;&#x2F;stephenn.com&#x2F;2022&#x2F;05&#x2F;simplifying-go-concurrency-with-future&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;stephenn.com&#x2F;2022&#x2F;05&#x2F;simplifying-go-concurrency-with...</a></div><br/></div></div><div id="36400762" class="c"><input type="checkbox" id="c-36400762" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400235">parent</a><span>|</span><a href="#36400778">prev</a><span>|</span><a href="#36400314">next</a><span>|</span><label class="collapse" for="c-36400762">[-]</label><label class="expand" for="c-36400762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It did bring uncolored async to the mainstream<p>I believe that uncolored async (Erlang) precedes colored async (python)<p>Correction: c# was the first language with colored aaync, still way after Erlang</div><br/></div></div></div></div><div id="36400314" class="c"><input type="checkbox" id="c-36400314" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400235">prev</a><span>|</span><a href="#36400143">next</a><span>|</span><label class="collapse" for="c-36400314">[-]</label><label class="expand" for="c-36400314">[1 more]</label></div><br/><div class="children"><div class="content">Go is hyped because it&#x27;s amazing to work with. It&#x27;s clean, simple, readable, very powerful and fast, has goroutines and a ton of libraries which are very easy to get,</div><br/></div></div><div id="36400143" class="c"><input type="checkbox" id="c-36400143" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400314">prev</a><span>|</span><a href="#36400062">next</a><span>|</span><label class="collapse" for="c-36400143">[-]</label><label class="expand" for="c-36400143">[8 more]</label></div><br/><div class="children"><div class="content">In my personal opinion it&#x27;s a great language to solve problems _I_ have to deal with in course of my work. Can I solve them with Java?<p>Sure.<p>Difference is go does not have the complexity you can find in Java and quite opinionated. So you don&#x27;t have to spend as much time working with the language inself and can focus on getting the job done.<p>Go is not as expressive and some other languages and does not have the same abstractions that make other languages more suited to be used while developing comlex software.<p>Thing is - in many cases you simple do not need any of it, but need a fast verbose language with good tooling.<p>Call it Java Light or something.</div><br/><div id="36400675" class="c"><input type="checkbox" id="c-36400675" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400143">parent</a><span>|</span><a href="#36400226">next</a><span>|</span><label class="collapse" for="c-36400675">[-]</label><label class="expand" for="c-36400675">[3 more]</label></div><br/><div class="children"><div class="content">Java is absolutely not a complex language. The “enterprise java” style is an unfortunate one that can actually be traced back to C++, but it is not a necessity at all, and due to the sheer size of the java ecosystem you will find plenty of examples of a more barebones approach — also supported by the language developers.<p>I fail to see why I would go with go over java, besides.. perhaps some CLI app? With Graal even that can be implemented in Java.</div><br/><div id="36400985" class="c"><input type="checkbox" id="c-36400985" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400675">parent</a><span>|</span><a href="#36400226">next</a><span>|</span><label class="collapse" for="c-36400985">[-]</label><label class="expand" for="c-36400985">[2 more]</label></div><br/><div class="children"><div class="content">&gt;The “enterprise java” style is an unfortunate one
&gt;but it is not a necessity at all<p>The thing is in real life you have to deal with this kind of code most of the time.  Because most of the time you deal with the old code or people who are used to some patterns you have to use too because you are part of the team.<p>Go enforces (kind of) a more barebones approach by default.<p>PS: I think it&#x27;s poinless to compare two languages. We should rather compare real practices and read examples.</div><br/><div id="36401306" class="c"><input type="checkbox" id="c-36401306" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400985">parent</a><span>|</span><a href="#36400226">next</a><span>|</span><label class="collapse" for="c-36401306">[-]</label><label class="expand" for="c-36401306">[1 more]</label></div><br/><div class="children"><div class="content">Ad absurdum than a new language will always be better, because usage patterns change and the new language doesn’t yet have any existing code bases using the old ones.</div><br/></div></div></div></div></div></div><div id="36400226" class="c"><input type="checkbox" id="c-36400226" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400143">parent</a><span>|</span><a href="#36400675">prev</a><span>|</span><a href="#36400062">next</a><span>|</span><label class="collapse" for="c-36400226">[-]</label><label class="expand" for="c-36400226">[4 more]</label></div><br/><div class="children"><div class="content">Could you elaborate on exactly what complexity in Java you&#x27;re referring to?<p>By having an overly simplistic language, you end up pushing more complexity onto the programmer and into the code base. There is no free lunch.<p>I find it much more sane to solve and express code in Java. You get terser, more to the point code that reflects the underlying logic more clearly, compared to having to read many lines or pages to understand what&#x27;s going on.</div><br/><div id="36400413" class="c"><input type="checkbox" id="c-36400413" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400226">parent</a><span>|</span><a href="#36400821">next</a><span>|</span><label class="collapse" for="c-36400413">[-]</label><label class="expand" for="c-36400413">[1 more]</label></div><br/><div class="children"><div class="content">&gt;By having an overly simplistic language, you end up pushing more complexity onto the programmer and into the code base. There is no free lunch.<p>Sure, I just don&#x27;t see this as a problem.<p>As a result you have<p>a) a number of third party packages to chose from depending on your needs\opinions<p>b) you have a more verbose codebase, some people find it harder to deal witih while I find it easier to deal with.<p>&gt;compared to having to read many lines or pages to understand what&#x27;s going on.<p>Different people different ways of thinking I guess.<p>In my eyes Java code looks to much like a specification in for of a code. Easier to do a code review but harder to actually understand how it works. And I personally need this dive into internals to actually feel confident about the code.<p>&gt;Could you elaborate on exactly what complexity in Java you&#x27;re referring to?<p>I don&#x27;t have too much experience in Java, but from what I&#x27;ve seen - Java has too many abstractions and OOP for the sake of paradigm and nothing else.<p>UPD:  adezxc&#x27;s comment is a good addition to mine</div><br/></div></div><div id="36400821" class="c"><input type="checkbox" id="c-36400821" checked=""/><div class="controls bullet"><span class="by">adezxc</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400226">parent</a><span>|</span><a href="#36400413">prev</a><span>|</span><a href="#36400062">next</a><span>|</span><label class="collapse" for="c-36400821">[-]</label><label class="expand" for="c-36400821">[2 more]</label></div><br/><div class="children"><div class="content">It is frustrating to read Java code. I don&#x27;t want to understand your abstractions or class definitions like final, static and whatever.<p>I don&#x27;t want to learn about Gradle or Maven to understand how a package is working, I&#x27;d rather do it in code.<p>Consider even the current &quot;Hello, world&quot; example in Java (Yes, I know about the proposal about simplifying it), it is tedious, why would I need to understand public&#x2F;private and classes before launching a simple program?<p>I fully agree it is a terrific piece of software, especially for industry-grade applications, yet it just isn&#x27;t attractive.<p>Main thing IMO, is that you can start out writing pretty good Go code after 24 hours and just improve on your skills as a general programmer. With Java, after a few months you would still need to know about some methods or OOP tips&#x2F;tricks, design patterns etc. to become proficient.</div><br/><div id="36401338" class="c"><input type="checkbox" id="c-36401338" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400821">parent</a><span>|</span><a href="#36400062">next</a><span>|</span><label class="collapse" for="c-36401338">[-]</label><label class="expand" for="c-36401338">[1 more]</label></div><br/><div class="children"><div class="content">There is no going around abstraction, that’s a necessary part of any non-trivial program as that’s the only method we have to control complexity. Your struct is also an abstraction, you could have defined another one, use it differently, etc.<p>Many of the design patterns are useless bullshit, that is long superseded by a language feature, so that point doesn’t stand imo.<p>Go also has public&#x2F;protected, it is just case-specific. If anything, that makes it <i>harder</i> to understand, how should I knew that Asd is different from asd beforehand?</div><br/></div></div></div></div></div></div></div></div><div id="36400062" class="c"><input type="checkbox" id="c-36400062" checked=""/><div class="controls bullet"><span class="by">kinghajj</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400143">prev</a><span>|</span><a href="#36399738">next</a><span>|</span><label class="collapse" for="c-36400062">[-]</label><label class="expand" for="c-36400062">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Worse_is_better" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Worse_is_better</a><p>Go is a language made by Googlers, so its design helps with Google problems. And many of Google&#x27;s problems are ones of scale.<p>* Go is straightforward to read. Any reasonably-competent college graduate should have little trouble understanding it and be able to become productive quickly.<p>* Go compiles into <i>completely static</i> binaries. You don&#x27;t have issues like &quot;oops, the build system runs CentOS 7 but we&#x27;re deploying it to Ubuntu 18.04 and their libc&#x27;s aren&#x27;t compatible.&quot; With containers, you can copy many Go programs into `FROM scratch` images and they will work fine, greatly reducing the attack surface area.<p>I used to dislike for Go for similar reasons to you and others, but after using it for a few years at $employer, I&#x27;ve come to appreciate its merits. Sure, it can be a bit annoying to write<p><pre><code>    if err != nil {
        return err
    }
</code></pre>
again and again at first, but I just type 3yy7jp to yank+paste it as needed. You could also configure some editors to detect when you type `if err` and generate it automatically. It&#x27;s also not uncommon for editors to fold the lines down into a single line.</div><br/><div id="36400181" class="c"><input type="checkbox" id="c-36400181" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400062">parent</a><span>|</span><a href="#36400766">next</a><span>|</span><label class="collapse" for="c-36400181">[-]</label><label class="expand" for="c-36400181">[1 more]</label></div><br/><div class="children"><div class="content">Yet, the bulk of code written at Google remains Java and C++. golang&#x27;s approach to uncolored async was decent, yet in the same manner of the language, overly verbose and error prone. Passing channels everywhere gets tricky quickly, and you have to manually ensure that contexts and deadlines are handled everywhere.<p>Errors in golang do not have stack traces, and wrapping errors is just an error prone way of manually (and apparently nonperformant way of) generating stack traces.</div><br/></div></div><div id="36400766" class="c"><input type="checkbox" id="c-36400766" checked=""/><div class="controls bullet"><span class="by">stephen123</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400062">parent</a><span>|</span><a href="#36400181">prev</a><span>|</span><a href="#36400913">next</a><span>|</span><label class="collapse" for="c-36400766">[-]</label><label class="expand" for="c-36400766">[1 more]</label></div><br/><div class="children"><div class="content">&quot;completely static&quot; has a gotcha though. I was getting segfaults yesterday because libc was removed from my docker image.<p>I had to add `CGO_ENABLED=0`</div><br/></div></div><div id="36400913" class="c"><input type="checkbox" id="c-36400913" checked=""/><div class="controls bullet"><span class="by">bombolo</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400062">parent</a><span>|</span><a href="#36400766">prev</a><span>|</span><a href="#36399738">next</a><span>|</span><label class="collapse" for="c-36400913">[-]</label><label class="expand" for="c-36400913">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Go compiles into completely static binaries<p>* sometimes.<p>It can also dynamically link stuff on occasions, depending what options you use.</div><br/></div></div></div></div><div id="36399738" class="c"><input type="checkbox" id="c-36399738" checked=""/><div class="controls bullet"><span class="by">andrewjf</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400062">prev</a><span>|</span><a href="#36400399">next</a><span>|</span><label class="collapse" for="c-36399738">[-]</label><label class="expand" for="c-36399738">[8 more]</label></div><br/><div class="children"><div class="content">I feel like a lot, if not all, has to do with the Google backing.  Back when Go was announced, the company had _a lot_ of goodwill, and were envied by anyone doing software engineering.  So, pretty much anything they did had an immediate following and base of engineers willing to blindly adopt whatever they did.</div><br/><div id="36400261" class="c"><input type="checkbox" id="c-36400261" checked=""/><div class="controls bullet"><span class="by">danjac</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399738">parent</a><span>|</span><a href="#36399992">next</a><span>|</span><label class="collapse" for="c-36400261">[-]</label><label class="expand" for="c-36400261">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but then look at Dart - a Google language whose real-world application so far has been the niche of Flutter app development.<p>I suspect it&#x27;s a bit more than the Google stamp of approval - the innate simplicity of the language is attractive, it has almost Python-like simplicity without the performance concerns, and it has a &quot;one true way&quot; approach to formatting that settles any bikeshedding arguments in dev teams.<p>It&#x27;s not my personal favourite language - the poor error handling discussed in this thread, the mess of the package management system (I mean, Python has a mess of a package management system, but that&#x27;s more forgivable in a language from the 1990s, not the 2010s), the lack of decent standard library collections, etc. But I can see the appeal.</div><br/></div></div><div id="36399992" class="c"><input type="checkbox" id="c-36399992" checked=""/><div class="controls bullet"><span class="by">kodah</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399738">parent</a><span>|</span><a href="#36400261">prev</a><span>|</span><a href="#36399774">next</a><span>|</span><label class="collapse" for="c-36399992">[-]</label><label class="expand" for="c-36399992">[2 more]</label></div><br/><div class="children"><div class="content">Hard disagree. Go provided a simple answer for asynchronousness in 2012 and was used to build Kubernetes. Because it was used to build Kubernetes a lot of patterns and influence developed very quickly, which made the language very agreeable to anyone writing APIs, systems tooling, or daemons. The portability and cross compilation were also developer favorites as they have downline effects in how simple it is to produce your final product in a CI pipeline.<p>To me, there were a lot of obvious reasons to choose Go in a corporate environment where my success is graded on my ability to deliver and the quality of what I deliver.<p>For every popular Google project you read about there are many flops, including ones they appear to develop in spite of.</div><br/><div id="36401389" class="c"><input type="checkbox" id="c-36401389" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399992">parent</a><span>|</span><a href="#36399774">next</a><span>|</span><label class="collapse" for="c-36401389">[-]</label><label class="expand" for="c-36401389">[1 more]</label></div><br/><div class="children"><div class="content">Kubernetes needed an awful lot of code generation to work around what the language was missing, though. I see some of the same at my employer; if anything we aren’t automating as much as we should.</div><br/></div></div></div></div><div id="36399774" class="c"><input type="checkbox" id="c-36399774" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399738">parent</a><span>|</span><a href="#36399992">prev</a><span>|</span><a href="#36400399">next</a><span>|</span><label class="collapse" for="c-36399774">[-]</label><label class="expand" for="c-36399774">[4 more]</label></div><br/><div class="children"><div class="content">I don’t buy it. I can’t think of a single other Google backed programming language with anywhere near to the following of Go.<p>I think Googles stamp gives it some legitimacy, but I think the much likelier explanation is that the values in Go and its design speak to frustrations a lot of people actually have. This thread is full of people arguing in favor of gos error handling. You can dismiss them all as cranks or sheep if you want, but I think that would be misunderstanding something.</div><br/><div id="36399853" class="c"><input type="checkbox" id="c-36399853" checked=""/><div class="controls bullet"><span class="by">andrewjf</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399774">parent</a><span>|</span><a href="#36399896">next</a><span>|</span><label class="collapse" for="c-36399853">[-]</label><label class="expand" for="c-36399853">[2 more]</label></div><br/><div class="children"><div class="content">I mean, maybe - but there&#x27;s a lot of examples of things being as popular as they are because google did them - gRPC, Protobuf, Kubernetes, Chromium.<p>None of these things were technically bankrupt (including Go), but their adoption curve would not have been what they have been without Googles name on it.<p>There&#x27;s likely other OSS that&#x27;s technically better, but did not have the network effects google-backed software had from day 1.</div><br/><div id="36399867" class="c"><input type="checkbox" id="c-36399867" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399853">parent</a><span>|</span><a href="#36399896">next</a><span>|</span><label class="collapse" for="c-36399867">[-]</label><label class="expand" for="c-36399867">[1 more]</label></div><br/><div class="children"><div class="content">Go almost certainly would not have been as successful Without googles brand. But also, without its funding. Google has poured tens of millions of dollars in to go. all of the good qualities of go are due to its incredible funding, whether that’s tooling or the fact that three or four extremely experienced engineers were given years of time to design and implement it.</div><br/></div></div></div></div><div id="36399896" class="c"><input type="checkbox" id="c-36399896" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399774">parent</a><span>|</span><a href="#36399853">prev</a><span>|</span><a href="#36400399">next</a><span>|</span><label class="collapse" for="c-36399896">[-]</label><label class="expand" for="c-36399896">[1 more]</label></div><br/><div class="children"><div class="content">It does feel like mostly google backing (other aspects are important as well). Imagine if google would be behind ie. Crystal - you&#x27;d see it everywhere.</div><br/></div></div></div></div></div></div><div id="36400399" class="c"><input type="checkbox" id="c-36400399" checked=""/><div class="controls bullet"><span class="by">mtzet</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36399738">prev</a><span>|</span><a href="#36400928">next</a><span>|</span><label class="collapse" for="c-36400399">[-]</label><label class="expand" for="c-36400399">[5 more]</label></div><br/><div class="children"><div class="content">I agree that go and rust have different areas, but that was less clear when they were getting started. Back then go was trying to figure out what it meant by &#x27;systems programming language&#x27; and rust had a similar threading model.<p>Another point is that they do share similarities, which might we might now just describe as being &#x27;modern&#x27;: They&#x27;re generally procedual -- you organize your code into modules (not classes) with structs and functions, they generally like static linking, type inference for greater ergonomics, the compiler includes the build system and a packager manager, there&#x27;s a good formatter.<p>The above are points for both rust and go compared to C&#x2F;C++, Python, Java, etc.<p>So why do I like go? I think mostly it&#x27;s that it makes some strong engineering trade-offs, trying to get 80% for 20% of the price. That manifests itself in a number of ways.<p>It&#x27;s not the fastest language, but neither is it slow.<p>I really dislike exceptions because there&#x27;s no documentation for how a function can fail. For this reason I prefer go style errors, which are an improvement on the C error story. Yes it has warts, but it&#x27;s 80% good enough.<p>It&#x27;s a simple language with batteries included. You can generally follow the direction set and be happy. It leads itself to simple, getting-things-done kind of code, rather than being over-abstracted. Being simple also makes for great compile times.</div><br/><div id="36400659" class="c"><input type="checkbox" id="c-36400659" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400399">parent</a><span>|</span><a href="#36400676">next</a><span>|</span><label class="collapse" for="c-36400659">[-]</label><label class="expand" for="c-36400659">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I agree that go and rust have different areas, but that was less clear when they were getting started<p>That I agree with.<p>But Go is anything but modern on a language front. It shares almost nothing with Rust, which actually has a modern type system (from ML&#x2F;Haskell).<p>Even if we disagree about exceptions (I do like them as they do the correct thing most of the time, while they don’t mask errors, but include a proper stacktrace), go’s error handling is just catastrophic, being an update from c which is even worse is not a positive.</div><br/><div id="36401179" class="c"><input type="checkbox" id="c-36401179" checked=""/><div class="controls bullet"><span class="by">mtzet</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400659">parent</a><span>|</span><a href="#36400676">next</a><span>|</span><label class="collapse" for="c-36401179">[-]</label><label class="expand" for="c-36401179">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not arguying that go has modern tech, but rather that it has modern sensibilities. This means not trying to force 90s style OOP, preferring static linking for easier deployment, including a build system and package manager with the compiler and preferring static types with type inference to dynamic types.<p>This differentiates go, rust, zig, odin etc., from languages like C++, Java, C#, Python etc. I think it makes sense to describe that difference as one of modern sensibilities.</div><br/></div></div></div></div><div id="36400676" class="c"><input type="checkbox" id="c-36400676" checked=""/><div class="controls bullet"><span class="by">hibbelig</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400399">parent</a><span>|</span><a href="#36400659">prev</a><span>|</span><a href="#36400928">next</a><span>|</span><label class="collapse" for="c-36400676">[-]</label><label class="expand" for="c-36400676">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I really dislike exceptions because there&#x27;s no documentation for how a function can fail. For this reason I prefer go style errors, which are an improvement on the C error story. Yes it has warts, but it&#x27;s 80% good enough.<p>I’m not a go developer. How does go document how a function can fail?<p>A Java developer can use checked exceptions so that some information is in the signature. For unchecked exceptions the documentation must explain.<p>I guess in Go the type of the error return value provides some information but the rest needs to be filled in by the documentation, just like the Java checked exceptions case.</div><br/><div id="36401241" class="c"><input type="checkbox" id="c-36401241" checked=""/><div class="controls bullet"><span class="by">mtzet</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400676">parent</a><span>|</span><a href="#36400928">next</a><span>|</span><label class="collapse" for="c-36401241">[-]</label><label class="expand" for="c-36401241">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’m not a go developer. How does go document how a function can fail?<p>There&#x27;s no magic to it. Errors are values, so it&#x27;s a part of the function signature that there&#x27;s an error code to check. In C++ any function can throw an exception and there&#x27;s no way of knowing that it wont.<p>It&#x27;s true that go doesn&#x27;t document what _kinds_ of errors it can throw, but at least I know there&#x27;s something to check.</div><br/></div></div></div></div></div></div><div id="36400928" class="c"><input type="checkbox" id="c-36400928" checked=""/><div class="controls bullet"><span class="by">nbraxf100</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400399">prev</a><span>|</span><a href="#36400424">next</a><span>|</span><label class="collapse" for="c-36400928">[-]</label><label class="expand" for="c-36400928">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a fan of the syntax either. My impression is that &quot;close to the hardware&quot; is not the selling point, but &quot;close to Unix&quot; is.<p>If you view the language as a safer super shell script, it becomes more obvious.<p>Go was hyped in the beginning, but I get the impression that now it isn&#x27;t. The most persistently hyped language here is Python. Fortunately, we see more Elixir, Ruby and Go posts lately.</div><br/></div></div><div id="36400424" class="c"><input type="checkbox" id="c-36400424" checked=""/><div class="controls bullet"><span class="by">jhoechtl</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400928">prev</a><span>|</span><a href="#36399758">next</a><span>|</span><label class="collapse" for="c-36400424">[-]</label><label class="expand" for="c-36400424">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Could someone explain why is Go so hyped?<p>You can write huge code bases with it, the tooling is good.<p>You can use a moderately skilled work force to achieve good results. When some team members leave, you are not left with some wizardry code base behind.</div><br/></div></div><div id="36399758" class="c"><input type="checkbox" id="c-36399758" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36400424">prev</a><span>|</span><a href="#36400481">next</a><span>|</span><label class="collapse" for="c-36399758">[-]</label><label class="expand" for="c-36399758">[4 more]</label></div><br/><div class="children"><div class="content">I think this claim is too reductionistic to go anywhere. There is no single thing that can explain go’s success. There are hundreds of small differences in the language (and tooling, which arguably is more important).<p>Most people are not going to care enough (or have the time) to enumerate every single difference between go and Java, and why they prefer the trade off go makes. I use Java professionally, and go where I can, and there is a lot I prefer about go (I won’t pretend it’s uniformly better, though.)<p>And fwiw, me and you have gone back and forth about this question in many threads previously. I think asking it from such a high level is not going to very effectively get into the details that actually matter to people.<p>Finally, I also think a lot of what makes go preferable is not in the realm of language design (at least not the algebraic type theory kind) or specific features. It’s much squishier than that, and involves feelings about how teams work and what developers do in practice (and why they fail).</div><br/><div id="36399833" class="c"><input type="checkbox" id="c-36399833" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399758">parent</a><span>|</span><a href="#36400481">next</a><span>|</span><label class="collapse" for="c-36399833">[-]</label><label class="expand" for="c-36399833">[3 more]</label></div><br/><div class="children"><div class="content">Then let me ask instead: why does Go hit the HN front page each day? I would say Rust used to be&#x2F;is similarly hyped, but it is sort of understandable there, as it is built on a novel idea and fits a previously unoccupied space.<p>This is not true of Go, and we could just as well see just as many D, Java, C#, Haskell, OCaml posts, yet they combined are not as frequent “visitors”.</div><br/><div id="36400111" class="c"><input type="checkbox" id="c-36400111" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36399833">parent</a><span>|</span><a href="#36400481">next</a><span>|</span><label class="collapse" for="c-36400111">[-]</label><label class="expand" for="c-36400111">[2 more]</label></div><br/><div class="children"><div class="content">I think there is something that advocates&#x2F;users of Go see in it that they don&#x27;t feel has been understood by its detractors. And on the flip side, I think the detractors are not very interested in understanding what is good about Go, instead it seems more like a nuisance to be swatted away. I think this creates a great deal of tension between the two, and leads to massive blowup threads. So long as issues (like error handling) persist where these groups cant understand each other, i think the same arguments will repeat.</div><br/><div id="36400697" class="c"><input type="checkbox" id="c-36400697" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#36399650">root</a><span>|</span><a href="#36400111">parent</a><span>|</span><a href="#36400481">next</a><span>|</span><label class="collapse" for="c-36400697">[-]</label><label class="expand" for="c-36400697">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, you are likely correct.</div><br/></div></div></div></div></div></div></div></div><div id="36400481" class="c"><input type="checkbox" id="c-36400481" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#36399650">parent</a><span>|</span><a href="#36399758">prev</a><span>|</span><a href="#36401309">next</a><span>|</span><label class="collapse" for="c-36400481">[-]</label><label class="expand" for="c-36400481">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Could someone explain why is Go so hyped?<p>For me, it&#x27;s:<p>1) channels (and goroutines, of course)<p>2) explicit error handling (panics are <i>actually</i> fatal, in contrast to exceptions which are often even used for flow control)<p>3) easy (cross-)compilation - just go build<p>And probably a few more reasons I can&#x27;t remember at the moment. It&#x27;s just fun to write Go!</div><br/></div></div></div></div><div id="36401309" class="c"><input type="checkbox" id="c-36401309" checked=""/><div class="controls bullet"><span class="by">evercast</span><span>|</span><a href="#36399650">prev</a><span>|</span><a href="#36399987">next</a><span>|</span><label class="collapse" for="c-36401309">[-]</label><label class="expand" for="c-36401309">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Usually this isn’t necessary and its better to just return the error unwrapped.<p>This is a terrible advice. Wrapping is extremely helpful in providing additional context for the error travelling up the call stack. Without wrapping, one typically ends up with software logging generic errors like &quot;file not found&quot; , which you can&#x27;t act on because... you don&#x27;t know where it&#x27;s coming from. If you skip error wrapping, better be ready to enjoy quality time when production crashes.</div><br/></div></div><div id="36399987" class="c"><input type="checkbox" id="c-36399987" checked=""/><div class="controls bullet"><span class="by">skarlso</span><span>|</span><a href="#36401309">prev</a><span>|</span><a href="#36401286">next</a><span>|</span><label class="collapse" for="c-36399987">[-]</label><label class="expand" for="c-36399987">[1 more]</label></div><br/><div class="children"><div class="content">This feels like it has been written by someone who recently started using the language, considering that the code in many places simply doesn&#x27;t compile and has syntax errors or logical errors in it.<p>Many people coming into Go as a new language immediately start bickering about how they want their previous language features in Go rather than accept what Go has to offer and at least try to understand it. This is the equivalent of moving to another country and then refusing to integrate but being very vocal about how said country sucks.<p>I genuinely appreciate Go&#x27;s error handling because it&#x27;s clean and on the nose. It&#x27;s not hidden behind weird syntax&#x2F;values that you have to unpack. It&#x27;s right in your face all the time. When you read the code, it reads cleanly and understandably, even for a beginner. They don&#x27;t have to adapt to some weird combination of failures &#x2F; unpacking&#x2F;choosing something different when there is an error; you immediately see that there could be an error.<p>And regarding stack traces, wrapping errors will provide you with failure locations to the line code. You can have all sorts of nice output for errors you can later parse and identify.<p>I get that some people go into Go because of a shift in the company and have no choice; I feel you. For me, it was a life changer. I learned to love coding again after 15 years of writing Java Beans, Spring annotations, CreateMyFriggingObjectFactorySingletonBuilderFactoryBuilders.</div><br/></div></div><div id="36401286" class="c"><input type="checkbox" id="c-36401286" checked=""/><div class="controls bullet"><span class="by">nathants</span><span>|</span><a href="#36399987">prev</a><span>|</span><a href="#36398600">next</a><span>|</span><label class="collapse" for="c-36401286">[-]</label><label class="expand" for="c-36401286">[1 more]</label></div><br/><div class="children"><div class="content">gopls, staticcheck, errcheck and ineffassign are non-optional for golang dev.<p>add them to flycheck or similar, and go is a fantastic experience.<p>should they be part of the compiler? maybe. i’m not losing sleep over it.</div><br/></div></div><div id="36398600" class="c"><input type="checkbox" id="c-36398600" checked=""/><div class="controls bullet"><span class="by">bedobi</span><span>|</span><a href="#36401286">prev</a><span>|</span><a href="#36398056">next</a><span>|</span><label class="collapse" for="c-36398600">[-]</label><label class="expand" for="c-36398600">[6 more]</label></div><br/><div class="children"><div class="content">For the love of all that is good in the world, this is a solved problem, I don&#x27;t understand why languages like Go, Kotlin, Python etc etc etc continue to insist on not having sane Option, Either, Try etc types.</div><br/><div id="36399585" class="c"><input type="checkbox" id="c-36399585" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#36398600">parent</a><span>|</span><a href="#36399031">next</a><span>|</span><label class="collapse" for="c-36399585">[-]</label><label class="expand" for="c-36399585">[1 more]</label></div><br/><div class="children"><div class="content">It was only in recent years that Rust has proven that monadic error-handling can be accepted in a mainstream language. At least, I hope it convinced enough people.<p>The more generic approach to error handling, using do monads (in Haskell and Scala) require some sort of do-notation (Scala&#x27;s &quot;for comprehensions&quot;) to be convenient. And I think this is a step that most mainstream languages are still too afraid to take. I would personally be glad for mainstream and some sort of monadic comprehension to become a mainstream language feature the same way closures became, but this is far from the reality.<p>So we are left with special-case solutions for specific problems like error-handling, iteration and nullability. Kotlin made it very easy do deal with nulls without a much ceremony (this is slightly more troublesome in Rust or Scala, for instance), while Rust chose to make error handling easier. Of course, they both repurposed the same operator (&quot;?&quot;) for this purpose.<p>What Kotlin does with nullability and what Rust does with error-handling are both becoming quite palatable for mainstream language developers, but it&#x27;s quite late to change language which have used exceptions (like Kotlin, Java and Python) or error values (like Go) to use monads right now. Entire APIs are built on the existing (and insufficient) error handling scheme.<p>For instance, we&#x27;re using Arrow&#x27;s Either on most new projects at work, but still have to deal with a lot of existing Java APIs, which are exception-based.</div><br/></div></div><div id="36399031" class="c"><input type="checkbox" id="c-36399031" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36398600">parent</a><span>|</span><a href="#36399585">prev</a><span>|</span><a href="#36399610">next</a><span>|</span><label class="collapse" for="c-36399031">[-]</label><label class="expand" for="c-36399031">[2 more]</label></div><br/><div class="children"><div class="content">Kotlin is deliberately trying to stay closer to Java and more approachable than, say, Scala. It does have sum types and a generic Result, but the builtin special cases for nullability and exceptions are a little more ergonomic (and simplify interop with JVM APIs).</div><br/><div id="36399083" class="c"><input type="checkbox" id="c-36399083" checked=""/><div class="controls bullet"><span class="by">bedobi</span><span>|</span><a href="#36398600">root</a><span>|</span><a href="#36399031">parent</a><span>|</span><a href="#36399610">next</a><span>|</span><label class="collapse" for="c-36399083">[-]</label><label class="expand" for="c-36399083">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand this. Kotlin has very deliberately made many choices that <i>don&#x27;t</i> align with Java, that&#x27;s the whole point. But more and more people are realizing that Kotlins error handling is a failed experiment and are adopting Arrow instead, as they should. There&#x27;s nothing demanding about Option, Either, Try etc types, they&#x27;re literally just objects no different to any other, and they enable you to write functions that <i>actually</i> only return what they say they do, unlike with exceptions. It is exceptions that are difficult and demanding lol. And the Result type isn&#x27;t very good and not even meant to be used by users of the language.</div><br/></div></div></div></div><div id="36399610" class="c"><input type="checkbox" id="c-36399610" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#36398600">parent</a><span>|</span><a href="#36399031">prev</a><span>|</span><a href="#36399548">next</a><span>|</span><label class="collapse" for="c-36399610">[-]</label><label class="expand" for="c-36399610">[1 more]</label></div><br/><div class="children"><div class="content">Yeah this is a solved problem... with exceptions</div><br/></div></div><div id="36399548" class="c"><input type="checkbox" id="c-36399548" checked=""/><div class="controls bullet"><span class="by">enriquto</span><span>|</span><a href="#36398600">parent</a><span>|</span><a href="#36399610">prev</a><span>|</span><a href="#36398056">next</a><span>|</span><label class="collapse" for="c-36399548">[-]</label><label class="expand" for="c-36399548">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this is a solved problem, I don&#x27;t understand why languages (...) insist on not having sane Option, Either, Try etc types.<p>This is not a &quot;problem&quot; as much as a conscious philosophical stance:<p>Errors don&#x27;t actually exist, only conditions that you dislike.  All the error handling you need is if&#x2F;else.  Everything else is unnecessary emotional baggage on some conditions that should not pollute your language.  And even less so, gasp, your <i>types</i> (!).</div><br/></div></div></div></div><div id="36398056" class="c"><input type="checkbox" id="c-36398056" checked=""/><div class="controls bullet"><span class="by">tester457</span><span>|</span><a href="#36398600">prev</a><span>|</span><a href="#36398792">next</a><span>|</span><label class="collapse" for="c-36398056">[-]</label><label class="expand" for="c-36398056">[13 more]</label></div><br/><div class="children"><div class="content">Go error &quot;handling&quot; blocks don&#x27;t seem like error handling, when it&#x27;s 3+ visual polluting LOC that just return the error up the call stack, occasionally with context like tip #4 of the blogpost.<p>I&#x27;ve tried to like go&#x27;s verbose error handling (follow the “happy path”) but the error handling signal to noise ratio is skewed in a way that makes developing in go feel slow and boring.</div><br/><div id="36398612" class="c"><input type="checkbox" id="c-36398612" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36398056">parent</a><span>|</span><a href="#36398792">next</a><span>|</span><label class="collapse" for="c-36398612">[-]</label><label class="expand" for="c-36398612">[12 more]</label></div><br/><div class="children"><div class="content">the idea that error handling &quot;pollutes&quot; code is a misunderstanding which go addresses<p>the &quot;sad path&quot; of error handling is equally as important as the &quot;happy path&quot;</div><br/><div id="36398833" class="c"><input type="checkbox" id="c-36398833" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36398612">parent</a><span>|</span><a href="#36399990">next</a><span>|</span><label class="collapse" for="c-36398833">[-]</label><label class="expand" for="c-36398833">[9 more]</label></div><br/><div class="children"><div class="content">How does it address it? By making it painstakingly verbose (not to mention error prone) to deal with errors?<p>Not referring to you personally, but I&#x27;ve heard that sentiment several times now, and I have not seen anything to back it up (as with several other golang claims).</div><br/><div id="36399195" class="c"><input type="checkbox" id="c-36399195" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36398833">parent</a><span>|</span><a href="#36398877">next</a><span>|</span><label class="collapse" for="c-36399195">[-]</label><label class="expand" for="c-36399195">[6 more]</label></div><br/><div class="children"><div class="content">given a function fn that can fail, it will return a result and an error e.g.<p><pre><code>    result, error = fn(...)
</code></pre>
calling this function should yield to the caller two possibilities, somehow: a success value _or_ a failure error<p>the important thing is that in both cases, the control flow is visible in the source code as written<p><pre><code>    result, error = fn(...)
    if there was an error, ...
    if it was successful, ...
</code></pre>
when an expression fails, you want to see the consequence in-line<p>the success path and the failure path are equally important</div><br/><div id="36400153" class="c"><input type="checkbox" id="c-36400153" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36399195">parent</a><span>|</span><a href="#36399998">next</a><span>|</span><label class="collapse" for="c-36400153">[-]</label><label class="expand" for="c-36400153">[3 more]</label></div><br/><div class="children"><div class="content">Nothing is preventing the code from returning both at the same time. I&#x27;ve seen code (including in the standard library) that returns both an error and a return value. In a language with disjoint unions, such cases would be encoded properly.</div><br/><div id="36400411" class="c"><input type="checkbox" id="c-36400411" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36400153">parent</a><span>|</span><a href="#36399998">next</a><span>|</span><label class="collapse" for="c-36400411">[-]</label><label class="expand" for="c-36400411">[2 more]</label></div><br/><div class="children"><div class="content">convention prevents it<p>and in the case where returning both is OK, then documentation makes that clear<p>this is not difficult</div><br/><div id="36400915" class="c"><input type="checkbox" id="c-36400915" checked=""/><div class="controls bullet"><span class="by">aniforprez</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36400411">parent</a><span>|</span><a href="#36399998">next</a><span>|</span><label class="collapse" for="c-36400915">[-]</label><label class="expand" for="c-36400915">[1 more]</label></div><br/><div class="children"><div class="content">Convention in no way prevents anything. Convention is simply that. People are free to not follow convention when nothing is enforcing it. You frequently see juniors, who may be brand new to the language, making mistakes with conventions. If I&#x27;m supposed to depend on the vagaries of some accepted standard that is only documented in text then it is less than useless in the real world</div><br/></div></div></div></div></div></div><div id="36399998" class="c"><input type="checkbox" id="c-36399998" checked=""/><div class="controls bullet"><span class="by">andrewjf</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36399195">parent</a><span>|</span><a href="#36400153">prev</a><span>|</span><a href="#36398877">next</a><span>|</span><label class="collapse" for="c-36399998">[-]</label><label class="expand" for="c-36399998">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, but you&#x27;re still relying on the programmer to do it correctly which is nothing but false hope.</div><br/><div id="36400403" class="c"><input type="checkbox" id="c-36400403" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36399998">parent</a><span>|</span><a href="#36398877">next</a><span>|</span><label class="collapse" for="c-36400403">[-]</label><label class="expand" for="c-36400403">[1 more]</label></div><br/><div class="children"><div class="content">no, it isn&#x27;t</div><br/></div></div></div></div></div></div><div id="36398877" class="c"><input type="checkbox" id="c-36398877" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36398833">parent</a><span>|</span><a href="#36399195">prev</a><span>|</span><a href="#36399990">next</a><span>|</span><label class="collapse" for="c-36398877">[-]</label><label class="expand" for="c-36398877">[2 more]</label></div><br/><div class="children"><div class="content">with robust and potentially high volume code, the most important feature is good behavior in failure domains. disk full, do you abort or continue once the cron job frees some space; cant alloc memory, do you abort or return a static 503 page? bad contents in some file, do you exit or log the error and carry on? does a bad pyc file generate a good error message or crash python. this robustness is the famed second 90% of the project.  normal go looks a cerain way when it is handling these errors.</div><br/><div id="36400177" class="c"><input type="checkbox" id="c-36400177" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36398877">parent</a><span>|</span><a href="#36399990">next</a><span>|</span><label class="collapse" for="c-36400177">[-]</label><label class="expand" for="c-36400177">[1 more]</label></div><br/><div class="children"><div class="content">Nothing you wrote is specific to golang&#x27;s error handling though, and in actuality, ends up being more brittle because it is possible to miss handling such errors. At least an exception would bubble up instead of keeping the program running in an undefined state.</div><br/></div></div></div></div></div></div><div id="36399990" class="c"><input type="checkbox" id="c-36399990" checked=""/><div class="controls bullet"><span class="by">andrewjf</span><span>|</span><a href="#36398056">root</a><span>|</span><a href="#36398612">parent</a><span>|</span><a href="#36398833">prev</a><span>|</span><a href="#36398842">next</a><span>|</span><label class="collapse" for="c-36399990">[-]</label><label class="expand" for="c-36399990">[1 more]</label></div><br/><div class="children"><div class="content">Then it would seem that it&#x27;s required for the compiler to make sure you&#x27;re consuming the return values (happy and sad) correctly by having the compiler enforce access to them, which go completely punts.</div><br/></div></div></div></div></div></div><div id="36398792" class="c"><input type="checkbox" id="c-36398792" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398056">prev</a><span>|</span><a href="#36397892">next</a><span>|</span><label class="collapse" for="c-36398792">[-]</label><label class="expand" for="c-36398792">[11 more]</label></div><br/><div class="children"><div class="content">The provided examples highlight exactly why error handling in golang is verbose, error prone, and lacks context. Do people really not care about stack traces?</div><br/><div id="36399466" class="c"><input type="checkbox" id="c-36399466" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#36398792">parent</a><span>|</span><a href="#36400772">next</a><span>|</span><label class="collapse" for="c-36399466">[-]</label><label class="expand" for="c-36399466">[8 more]</label></div><br/><div class="children"><div class="content">Less than I thought I would. I work with a very large Go codebase, and I don&#x27;t remember the last time I had problems because I needed a stack trace. Just grepping for the error message is enough to show me exactly where it happened.<p>Still, this doesn&#x27;t mean that Go does not have stack traces. It does have stack traces for panics, and you can create stack traces by wrapping errors.</div><br/><div id="36399700" class="c"><input type="checkbox" id="c-36399700" checked=""/><div class="controls bullet"><span class="by">iudqnolq</span><span>|</span><a href="#36398792">root</a><span>|</span><a href="#36399466">parent</a><span>|</span><a href="#36400133">next</a><span>|</span><label class="collapse" for="c-36399700">[-]</label><label class="expand" for="c-36399700">[6 more]</label></div><br/><div class="children"><div class="content">I frequently am sad about the kind of Rust error that doesn&#x27;t have stack traces. Do you not often see something like &quot;file not found&quot; and need to know what file wasn&#x27;t found? Or do the lowest level go error types carry more context?</div><br/><div id="36399855" class="c"><input type="checkbox" id="c-36399855" checked=""/><div class="controls bullet"><span class="by">tail_exchange</span><span>|</span><a href="#36398792">root</a><span>|</span><a href="#36399700">parent</a><span>|</span><a href="#36399834">next</a><span>|</span><label class="collapse" for="c-36399855">[-]</label><label class="expand" for="c-36399855">[3 more]</label></div><br/><div class="children"><div class="content">The programmer needs to be aware that they will need to provide enough context in case of a failure. One thing I see a lot in Go examples is this pattern:<p><pre><code>  body, err := readFile(fileName)
  if err != nil {
    return &quot;&quot;, err
  }
</code></pre>
If the error returned by readFile is just &quot;not found&quot;, it would indeed be very vague. This is still poor error handling, in my opinion, since a lot of the context is lost. Yes, they are &quot;handling&quot; the error, but only enough to stop the linter from complaining. I prefer something like this:<p><pre><code>  body, err := readFile(fileName)
  if err != nil {
    return &quot;&quot;, errors.Wrapf(err, &quot;readFile(%s)&quot;, fileName)
  }
</code></pre>
This would result inan error like this:<p><pre><code>  readFile(file.txt): not found
</code></pre>
This way I get all the context I need to know where the error happened and the arguments that caused the error.<p>If the error happened not because of a function call, but, say, an invalid value, instead of this:<p><pre><code>  if n &lt; 10 {
    return fmt.Error(&quot;invalid argument&quot;)
  }
</code></pre>
Do this:<p><pre><code>  if n &lt; 10 {
    return fmt.Errorf(&quot;invalid argument n=%d is less than 10&quot;, n)
  }
</code></pre>
In languages like Java, it feels very tempting to let errors bubble up and then let the stack trace take care of explaining what went wrong, but it is often insufficient and may result in hours of debugging. I feel like Go makes it very easy to add extra context to errors, and if you foster the practice of adding context every time you return an errlr, it will be much richer than a stack trace.</div><br/><div id="36400141" class="c"><input type="checkbox" id="c-36400141" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398792">root</a><span>|</span><a href="#36399855">parent</a><span>|</span><a href="#36399834">next</a><span>|</span><label class="collapse" for="c-36400141">[-]</label><label class="expand" for="c-36400141">[2 more]</label></div><br/><div class="children"><div class="content">You basically end up reinventing stack traces, with all the possible ways context can be missed. This summarizes the language quite well.</div><br/><div id="36400633" class="c"><input type="checkbox" id="c-36400633" checked=""/><div class="controls bullet"><span class="by">kitd</span><span>|</span><a href="#36398792">root</a><span>|</span><a href="#36400141">parent</a><span>|</span><a href="#36399834">next</a><span>|</span><label class="collapse" for="c-36400633">[-]</label><label class="expand" for="c-36400633">[1 more]</label></div><br/><div class="children"><div class="content">IME, it&#x27;s stack traces that miss all the context. So an error occurred 20 levels down? What was it doing? With what?</div><br/></div></div></div></div></div></div><div id="36399724" class="c"><input type="checkbox" id="c-36399724" checked=""/><div class="controls bullet"><span class="by">philosopher1234</span><span>|</span><a href="#36398792">root</a><span>|</span><a href="#36399700">parent</a><span>|</span><a href="#36399834">prev</a><span>|</span><a href="#36400133">next</a><span>|</span><label class="collapse" for="c-36399724">[-]</label><label class="expand" for="c-36399724">[1 more]</label></div><br/><div class="children"><div class="content">IIRC os.Open includes the pathname of the file it’s operating on. But still, if you don’t wrap your errors, you get useless errors which are unlocatable. Wrapping is essential in go. Thankfully the STL has good facilities for adding relevant data (like pathnames) to your wrapping</div><br/></div></div></div></div><div id="36400133" class="c"><input type="checkbox" id="c-36400133" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398792">root</a><span>|</span><a href="#36399466">parent</a><span>|</span><a href="#36399700">prev</a><span>|</span><a href="#36400772">next</a><span>|</span><label class="collapse" for="c-36400133">[-]</label><label class="expand" for="c-36400133">[1 more]</label></div><br/><div class="children"><div class="content">I also worked on a very large golang codebase, and error traces were sorely missed. Searching for the error string is not sufficient. What happens when the string changes in the master branch, which is different from the deployed version? What about when there are different code paths to get to the same error message?<p>I&#x27;m aware that it has stack traces for panics, but those should be rare in practice. Day to day debugging was more tedious in golang.</div><br/></div></div></div></div><div id="36400772" class="c"><input type="checkbox" id="c-36400772" checked=""/><div class="controls bullet"><span class="by">philozzzozzz</span><span>|</span><a href="#36398792">parent</a><span>|</span><a href="#36399466">prev</a><span>|</span><a href="#36400247">next</a><span>|</span><label class="collapse" for="c-36400772">[-]</label><label class="expand" for="c-36400772">[1 more]</label></div><br/><div class="children"><div class="content">A descriptive error message beats any stack trace. A stack trace does not actually tell you anything that&#x27;s particularly interesting, there is a ton of irrelevant information and it&#x27;s generally missing the values bound to the arguments and variables.</div><br/></div></div><div id="36400247" class="c"><input type="checkbox" id="c-36400247" checked=""/><div class="controls bullet"><span class="by">marwis</span><span>|</span><a href="#36398792">parent</a><span>|</span><a href="#36400772">prev</a><span>|</span><a href="#36397892">next</a><span>|</span><label class="collapse" for="c-36400247">[-]</label><label class="expand" for="c-36400247">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps simple language and lack of abstractions lead to less code reuse so you can more easily tell where a particular error is coming from without context (less possible code paths).</div><br/></div></div></div></div><div id="36397892" class="c"><input type="checkbox" id="c-36397892" checked=""/><div class="controls bullet"><span class="by">dvt</span><span>|</span><a href="#36398792">prev</a><span>|</span><a href="#36397831">next</a><span>|</span><label class="collapse" for="c-36397892">[-]</label><label class="expand" for="c-36397892">[3 more]</label></div><br/><div class="children"><div class="content">For a language where coroutines are such a first-class citizen, I wish there was a more idiomatic way of returning and handling async errors in Go. I know it&#x27;s all over the docs, but using a channel has always felt so &quot;wrong.&quot; The errgroup lib tries to fix this, but it&#x27;s still not as flexible as using a channel (for example, if you want to store or log <i>all</i> routine errors).</div><br/><div id="36399803" class="c"><input type="checkbox" id="c-36399803" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#36397892">parent</a><span>|</span><a href="#36397831">next</a><span>|</span><label class="collapse" for="c-36399803">[-]</label><label class="expand" for="c-36399803">[2 more]</label></div><br/><div class="children"><div class="content">As far as I understand Go, passing back results via channels is the idiomatic approach for this.<p>But the provided example is wrong - it is synchronous, as it awaits the computations to finish; and it is broken, because if either `refresh` call panics the caller will hang indefinitely. So it needs some extra defers and maybe a sync.WaitGroup<p>Also, example 5 is also somewhat not good, because it uses `if err == context.DeadlineExceeded` where it should&#x27;ve said `errors.Is(err, context.DeadlineExceeded)` as it&#x27;s a good practice to always assume that exceptions may get wrapped (#4 just mentioned that).</div><br/><div id="36400213" class="c"><input type="checkbox" id="c-36400213" checked=""/><div class="controls bullet"><span class="by">dvt</span><span>|</span><a href="#36397892">root</a><span>|</span><a href="#36399803">parent</a><span>|</span><a href="#36397831">next</a><span>|</span><label class="collapse" for="c-36400213">[-]</label><label class="expand" for="c-36400213">[1 more]</label></div><br/><div class="children"><div class="content">&gt; As far as I understand Go, passing back results via channels is the idiomatic approach for this.<p>It&#x27;s definitely the <i>canonical</i> way, but communicating errors via channels feels very.. weird, for the lack of a better word (hence why I don&#x27;t find it idiomatic).</div><br/></div></div></div></div></div></div><div id="36397831" class="c"><input type="checkbox" id="c-36397831" checked=""/><div class="controls bullet"><span class="by">showdeddd</span><span>|</span><a href="#36397892">prev</a><span>|</span><a href="#36398531">next</a><span>|</span><label class="collapse" for="c-36397831">[-]</label><label class="expand" for="c-36397831">[4 more]</label></div><br/><div class="children"><div class="content">For #3 you can also use errgroup from sync&#x2F;errgroup. It&#x27;s a nice recent addition to the stdlib.<p>For #4 wrapping your errors creates pretty and logical error messages for free. It should be done in most cases.</div><br/><div id="36398501" class="c"><input type="checkbox" id="c-36398501" checked=""/><div class="controls bullet"><span class="by">benhoyt</span><span>|</span><a href="#36397831">parent</a><span>|</span><a href="#36398531">next</a><span>|</span><label class="collapse" for="c-36398501">[-]</label><label class="expand" for="c-36398501">[3 more]</label></div><br/><div class="children"><div class="content">It looks like sync&#x2F;errgroup is a proposal, but not in the standard library (not yet, at any rate): <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57534">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;57534</a></div><br/><div id="36398735" class="c"><input type="checkbox" id="c-36398735" checked=""/><div class="controls bullet"><span class="by">showdeddd</span><span>|</span><a href="#36397831">root</a><span>|</span><a href="#36398501">parent</a><span>|</span><a href="#36398531">next</a><span>|</span><label class="collapse" for="c-36398735">[-]</label><label class="expand" for="c-36398735">[2 more]</label></div><br/><div class="children"><div class="content">Oh that&#x27;s right. I imported it via golang.org&#x2F;x&#x2F;sync&#x2F;errgroup</div><br/><div id="36400364" class="c"><input type="checkbox" id="c-36400364" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#36397831">root</a><span>|</span><a href="#36398735">parent</a><span>|</span><a href="#36398531">next</a><span>|</span><label class="collapse" for="c-36400364">[-]</label><label class="expand" for="c-36400364">[1 more]</label></div><br/><div class="children"><div class="content">Even the author of errgroup does not want errgroup to enter the stdlib for the reasons he mentions:<p>There are two significant problems with the API:<p>An errgroup.WithContext today cancels the Context when its Wait method returns, which makes it easier to avoid leaking resources but somewhat prone to bugs involving accidental reuse of the Context after the call to Wait.<p>The need to call Wait in order to free resources makes errgroup.WithContext unfortunately still somewhat prone to leaks. If you start a bunch of goroutines and then encounter an error while setting up another one, it&#x27;s easy to accidentally leak all of the goroutines started so far — along with their associated Context — by writing</div><br/></div></div></div></div></div></div></div></div><div id="36398531" class="c"><input type="checkbox" id="c-36398531" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#36397831">prev</a><span>|</span><a href="#36397851">next</a><span>|</span><label class="collapse" for="c-36398531">[-]</label><label class="expand" for="c-36398531">[6 more]</label></div><br/><div class="children"><div class="content">Surprised that the &quot;always wrap your errors&quot; rule isn&#x27;t in there. It&#x27;s been the rule in the last few Go teams I&#x27;ve been in.</div><br/><div id="36399671" class="c"><input type="checkbox" id="c-36399671" checked=""/><div class="controls bullet"><span class="by">stephen123</span><span>|</span><a href="#36398531">parent</a><span>|</span><a href="#36398670">next</a><span>|</span><label class="collapse" for="c-36399671">[-]</label><label class="expand" for="c-36399671">[2 more]</label></div><br/><div class="children"><div class="content">It seems like a waste of time to me. Wrapping errors adds context. But you can usually get enough context from stack traces.</div><br/><div id="36399716" class="c"><input type="checkbox" id="c-36399716" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#36398531">root</a><span>|</span><a href="#36399671">parent</a><span>|</span><a href="#36398670">next</a><span>|</span><label class="collapse" for="c-36399716">[-]</label><label class="expand" for="c-36399716">[1 more]</label></div><br/><div class="children"><div class="content">But you don’t have stacktraces.</div><br/></div></div></div></div><div id="36398670" class="c"><input type="checkbox" id="c-36398670" checked=""/><div class="controls bullet"><span class="by">AlexCoventry</span><span>|</span><a href="#36398531">parent</a><span>|</span><a href="#36399671">prev</a><span>|</span><a href="#36397851">next</a><span>|</span><label class="collapse" for="c-36398670">[-]</label><label class="expand" for="c-36398670">[3 more]</label></div><br/><div class="children"><div class="content">We moved away from wrapping them recently for performance reasons.</div><br/><div id="36398784" class="c"><input type="checkbox" id="c-36398784" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36398531">root</a><span>|</span><a href="#36398670">parent</a><span>|</span><a href="#36397851">next</a><span>|</span><label class="collapse" for="c-36398784">[-]</label><label class="expand" for="c-36398784">[2 more]</label></div><br/><div class="children"><div class="content">How much of a performance hit were they causing?</div><br/><div id="36398834" class="c"><input type="checkbox" id="c-36398834" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#36398531">root</a><span>|</span><a href="#36398784">parent</a><span>|</span><a href="#36397851">next</a><span>|</span><label class="collapse" for="c-36398834">[-]</label><label class="expand" for="c-36398834">[1 more]</label></div><br/><div class="children"><div class="content">and how many errors are they getting?</div><br/></div></div></div></div></div></div></div></div><div id="36397851" class="c"><input type="checkbox" id="c-36397851" checked=""/><div class="controls bullet"><span class="by">movedx</span><span>|</span><a href="#36398531">prev</a><span>|</span><a href="#36399737">next</a><span>|</span><label class="collapse" for="c-36397851">[-]</label><label class="expand" for="c-36397851">[1 more]</label></div><br/><div class="children"><div class="content">One thing I did for a project of mine was define my own error type, so that I can include some specific information for the next layer up. In short, I added information about the severity of the error so that the calling function that&#x27;s capturing it can decide if it can recover from it or not based on the severity, and I added a flag to determine if the result value (think &quot;T, error&quot;) is empty, partial, or complete.<p>I added .Empty() and .Partial() because if you&#x27;re returning &quot;string, error&quot; from a function, for example, then &quot;&quot; doesn&#x27;t cut it for me and instead of checking for &quot;&quot; in the calling function, I can instead check for err.Empty(). This doesn&#x27;t seem like it&#x27;s useful, but take that idea and apply it to two additional scenarios: a non-pointer to a struct{} with 10 fields (are they <i>all</i> empty?), and partial return values i.e. the function you called threw a warning and only partially populated the return value. Now the calling function can shift the &quot;is empty&quot; checks to the function that actually constructs the return value (or not.)<p>Now I can call a function, get my custom error type back, and I can determine if there was an issue and whether or not the value is empty or partial regardless of the type (and its complexity.) This paid me back in dividends the moment I wanted to be able to return a warning <i>and</i> a partial result - so not workflow breaking, but also not everything the caller asked for... it&#x27;s up to the caller to determine if it has what it needs to continue.</div><br/></div></div><div id="36399737" class="c"><input type="checkbox" id="c-36399737" checked=""/><div class="controls bullet"><span class="by">Jacobinski</span><span>|</span><a href="#36397851">prev</a><span>|</span><a href="#36401097">next</a><span>|</span><label class="collapse" for="c-36399737">[-]</label><label class="expand" for="c-36399737">[1 more]</label></div><br/><div class="children"><div class="content">In the last example, it is preferable to use `if errors.Is(err, context.DeadlineExceeded) {...}`  instead of the given `if err == context.DeadlineExceeded {...}` since the `errors.Is()` function will recursively unwrap error chains to find the specified error.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;go1.13-errors" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;go1.13-errors</a></div><br/></div></div><div id="36401097" class="c"><input type="checkbox" id="c-36401097" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#36399737">prev</a><span>|</span><a href="#36400334">next</a><span>|</span><label class="collapse" for="c-36401097">[-]</label><label class="expand" for="c-36401097">[1 more]</label></div><br/><div class="children"><div class="content">I differ with the author here, I prefer to log errors as soon as they come into &quot;my&quot; code (e.g. from external library or network call, etc.).<p>This is a good rule for any language, because you always ensure an error is logged once. In Go, you can add additional info from the caller to the Context to log higher level info, e.g. a trace span Id.</div><br/></div></div><div id="36400334" class="c"><input type="checkbox" id="c-36400334" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#36401097">prev</a><span>|</span><a href="#36398454">next</a><span>|</span><label class="collapse" for="c-36400334">[-]</label><label class="expand" for="c-36400334">[1 more]</label></div><br/><div class="children"><div class="content">Majority of people who complain about errors in Go don&#x27;t primarily work with compiled languages that produce programs that run indefinitely or for a very long periods of time. It&#x27;s easy to throw exception in PHP which is interpreted on the fly and run once so any failure can be simply thrown out and ignored. With constantly running programs one has to always handle all the cases where things don&#x27;t go as wanted to prevent program form crashing. If people truly hate Go&#x27;s errors, just panic, it&#x27;s literally no different than exceptions in other languages. You can catch them and stop or continue whatever code you want. Just STFU about errors in Go already!</div><br/></div></div><div id="36398454" class="c"><input type="checkbox" id="c-36398454" checked=""/><div class="controls bullet"><span class="by">dpifke</span><span>|</span><a href="#36400334">prev</a><span>|</span><a href="#36397825">next</a><span>|</span><label class="collapse" for="c-36398454">[-]</label><label class="expand" for="c-36398454">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve mostly evolved to making err a named return parameter, and inverting the err != nil check.  For example:<p><pre><code>  func foo() (err error) {
    var x any
    if x, err = bar(); err == nil {
      err = baz(x)
    }
    if err == nil {
      err = bat()
    }
    if err != nil {
      err = fmt.Errorf(&quot;%w doing foo &lt;additional info here&gt;&quot;, err)
    }
    return
  }
</code></pre>
This feels somewhat cleaner to me, in particular by combining error handling (in this case just a simple wrap) in a single place at the end of the function.</div><br/><div id="36398587" class="c"><input type="checkbox" id="c-36398587" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36398454">parent</a><span>|</span><a href="#36398569">next</a><span>|</span><label class="collapse" for="c-36398587">[-]</label><label class="expand" for="c-36398587">[7 more]</label></div><br/><div class="children"><div class="content">please don&#x27;t do this<p>it obfuscates the control flow, specifically the value that is actually returned<p>early returns on errors are good, not bad<p><i>edit</i> you want<p><pre><code>    func foo() error {
        x, err := bar()
        if err != nil {
          return fmt.Errorf(&quot;bar: %w&quot;, err)
        }
        
        if err := baz(x); err != nil {
          return fmt.Errorf(&quot;baz: %w&quot;, err)
        }
        
        if err := bat(); err != nil {
          return fmt.Errorf(&quot;bat: %w&quot;, err)
        }
        
        return nil
    }</code></pre></div><br/><div id="36398908" class="c"><input type="checkbox" id="c-36398908" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#36398454">root</a><span>|</span><a href="#36398587">parent</a><span>|</span><a href="#36398967">next</a><span>|</span><label class="collapse" for="c-36398908">[-]</label><label class="expand" for="c-36398908">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I absolutely agree with this. I think there is great value in returning early on error; think of them as guards checking that you have the values you need for the next logic step. In the original version you may have to read the whole function to understand why it failed.</div><br/></div></div><div id="36398967" class="c"><input type="checkbox" id="c-36398967" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#36398454">root</a><span>|</span><a href="#36398587">parent</a><span>|</span><a href="#36398908">prev</a><span>|</span><a href="#36399116">next</a><span>|</span><label class="collapse" for="c-36398967">[-]</label><label class="expand" for="c-36398967">[4 more]</label></div><br/><div class="children"><div class="content">I’m all for generating that. I don’t want it in source where rereading it wastes expensive developers’ time and mistakes become possible.</div><br/><div id="36399022" class="c"><input type="checkbox" id="c-36399022" checked=""/><div class="controls bullet"><span class="by">meling</span><span>|</span><a href="#36398454">root</a><span>|</span><a href="#36398967">parent</a><span>|</span><a href="#36399226">next</a><span>|</span><label class="collapse" for="c-36399022">[-]</label><label class="expand" for="c-36399022">[2 more]</label></div><br/><div class="children"><div class="content">Copilot is pretty good at recognizing and generating the error check ; it will even propose error messages for you. Clearly you may want to change it to your specific case. So I don’t think dev time will be significantly slower. My experience has been positive. I think the go plugin also has some helpers for this pattern, but I don’t recall exactly how they work.</div><br/></div></div><div id="36399226" class="c"><input type="checkbox" id="c-36399226" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36398454">root</a><span>|</span><a href="#36398967">parent</a><span>|</span><a href="#36399022">prev</a><span>|</span><a href="#36399116">next</a><span>|</span><label class="collapse" for="c-36399226">[-]</label><label class="expand" for="c-36399226">[1 more]</label></div><br/><div class="children"><div class="content">nope<p>error handling (as expressed here) is equivalent in priority to core business logic<p>it absolutely belongs in source, because it is important for developers to see</div><br/></div></div></div></div></div></div><div id="36398569" class="c"><input type="checkbox" id="c-36398569" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#36398454">parent</a><span>|</span><a href="#36398587">prev</a><span>|</span><a href="#36399154">next</a><span>|</span><label class="collapse" for="c-36398569">[-]</label><label class="expand" for="c-36398569">[2 more]</label></div><br/><div class="children"><div class="content">Curious why you&#x27;re using fmt.Fprintf and not fmt.Errorf? Or is that a typo?<p>And I think you&#x27;re going to have problems with this pattern if you join a team using Go in an organisation. The `if err != nil` pattern is the norm, and everyone&#x27;s used to it (and the regular cadence of Go code; &quot;do the thing, check the error, do the thing, check the error&quot; is very readable).</div><br/><div id="36399001" class="c"><input type="checkbox" id="c-36399001" checked=""/><div class="controls bullet"><span class="by">dpifke</span><span>|</span><a href="#36398454">root</a><span>|</span><a href="#36398569">parent</a><span>|</span><a href="#36399154">next</a><span>|</span><label class="collapse" for="c-36399001">[-]</label><label class="expand" for="c-36399001">[1 more]</label></div><br/><div class="children"><div class="content">That was a typo, thanks for pointing it out. :)</div><br/></div></div></div></div><div id="36399154" class="c"><input type="checkbox" id="c-36399154" checked=""/><div class="controls bullet"><span class="by">dpifke</span><span>|</span><a href="#36398454">parent</a><span>|</span><a href="#36398569">prev</a><span>|</span><a href="#36397825">next</a><span>|</span><label class="collapse" for="c-36399154">[-]</label><label class="expand" for="c-36399154">[1 more]</label></div><br/><div class="children"><div class="content">Some other variants I&#x27;ve played with:<p><pre><code>  func foo() (err error) {
    var x any
    if x, err = bar(); err != nil {
      goto fooError
    }
    if err = baz(x); err != nil {
      goto fooError
    }
    if err = bat(); err != nil {
      goto fooError
    }
    return

  fooError:
    return fmt.Errorf(&quot;%w doing foo &lt;additional info here&gt;&quot;, err)
  }
</code></pre>
Or:<p><pre><code>  func foo() (err error) {
    defer func() {
      if err != nil {
        err = fmt.Errorf(&quot;%w doing foo &lt;additional info here&gt;&quot;, err)
      }
    }()
    var x any
    if x, err = bar(); err != nil {
      return
    }
    if err = baz(x); err != nil {
      return
    }
    err = bat()
    return
  }
</code></pre>
Seeking out different patterns is obviously most applicable in cases where error handling is actually doing something useful or more complicated than just wrapping the error.<p>(My comment was meant to spur first principles discussion from intellectually curious folks, not &quot;nobody does it that way&quot; or &quot;don&#x27;t do that&quot; edicts.  Much of the argument against adding additional language features for error handling is that many of them aren&#x27;t any better than what can be accomplished already, using existing syntax but different code style conventions.  The goto pattern in particular is found all over the stdlib.)</div><br/></div></div></div></div><div id="36397825" class="c"><input type="checkbox" id="c-36397825" checked=""/><div class="controls bullet"><span class="by">softirq</span><span>|</span><a href="#36398454">prev</a><span>|</span><a href="#36397901">next</a><span>|</span><label class="collapse" for="c-36397825">[-]</label><label class="expand" for="c-36397825">[3 more]</label></div><br/><div class="children"><div class="content">Always wrapping errors can be a good way to get a stack trace of the error path in the logs.</div><br/><div id="36398004" class="c"><input type="checkbox" id="c-36398004" checked=""/><div class="controls bullet"><span class="by">linux2647</span><span>|</span><a href="#36397825">parent</a><span>|</span><a href="#36397901">next</a><span>|</span><label class="collapse" for="c-36398004">[-]</label><label class="expand" for="c-36398004">[2 more]</label></div><br/><div class="children"><div class="content">Is that a real stack trace, or just a trace of error message wrapping?  I haven’t figured out how to extract a real error message using Go stdlib</div><br/><div id="36399605" class="c"><input type="checkbox" id="c-36399605" checked=""/><div class="controls bullet"><span class="by">coffeebeqn</span><span>|</span><a href="#36397825">root</a><span>|</span><a href="#36398004">parent</a><span>|</span><a href="#36397901">next</a><span>|</span><label class="collapse" for="c-36399605">[-]</label><label class="expand" for="c-36399605">[1 more]</label></div><br/><div class="children"><div class="content">No it’s a manual “stack” you build yourself with wrap. It’ll take you to the nearest error handler to the error which is usually not that far from the real problem</div><br/></div></div></div></div></div></div><div id="36397901" class="c"><input type="checkbox" id="c-36397901" checked=""/><div class="controls bullet"><span class="by">incompatible</span><span>|</span><a href="#36397825">prev</a><span>|</span><a href="#36400131">next</a><span>|</span><label class="collapse" for="c-36397901">[-]</label><label class="expand" for="c-36397901">[5 more]</label></div><br/><div class="children"><div class="content">&quot;Always handle errors&quot; sounds good until you remember that every read or write can potentially fail. My go programs are littered with unchecked fmt.Printf or Println statements.</div><br/><div id="36398157" class="c"><input type="checkbox" id="c-36398157" checked=""/><div class="controls bullet"><span class="by">BobbyJo</span><span>|</span><a href="#36397901">parent</a><span>|</span><a href="#36398618">next</a><span>|</span><label class="collapse" for="c-36398157">[-]</label><label class="expand" for="c-36398157">[2 more]</label></div><br/><div class="children"><div class="content">That seems like the kind of thing you&#x27;d want to wrap and panic on rather than ignore.<p>If fmt.Print doesn&#x27;t work, you should probably just kill the process.</div><br/><div id="36400747" class="c"><input type="checkbox" id="c-36400747" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#36397901">root</a><span>|</span><a href="#36398157">parent</a><span>|</span><a href="#36398618">next</a><span>|</span><label class="collapse" for="c-36400747">[-]</label><label class="expand" for="c-36400747">[1 more]</label></div><br/><div class="children"><div class="content">That has the downside that if the user pipes your program’s standard output to, say, `head`, then once `head` is done reading the first few lines and exits, the program will blow up and probably print a message to standard error that clutters the user’s terminal (where they were expecting to see the first few lines of output).<p>Though, continuing to spend time generating more output that goes nowhere may not be particularly useful either, depending on what the program does.<p>Still I think ignoring errors writing to stdout is better as a general default.  If nothing else, it’s the most common behavior and is thus more likely to fit the user’s expectations.</div><br/></div></div></div></div><div id="36398618" class="c"><input type="checkbox" id="c-36398618" checked=""/><div class="controls bullet"><span class="by">preseinger</span><span>|</span><a href="#36397901">parent</a><span>|</span><a href="#36398157">prev</a><span>|</span><a href="#36400131">next</a><span>|</span><label class="collapse" for="c-36398618">[-]</label><label class="expand" for="c-36398618">[2 more]</label></div><br/><div class="children"><div class="content">fmt.Printf failures are un-actionable, so there&#x27;s no reason to handle them</div><br/><div id="36400621" class="c"><input type="checkbox" id="c-36400621" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#36397901">root</a><span>|</span><a href="#36398618">parent</a><span>|</span><a href="#36400131">next</a><span>|</span><label class="collapse" for="c-36400621">[-]</label><label class="expand" for="c-36400621">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what the parent comment means, I think.</div><br/></div></div></div></div></div></div><div id="36400131" class="c"><input type="checkbox" id="c-36400131" checked=""/><div class="controls bullet"><span class="by">saturn_vk</span><span>|</span><a href="#36397901">prev</a><span>|</span><label class="collapse" for="c-36400131">[-]</label><label class="expand" for="c-36400131">[1 more]</label></div><br/><div class="children"><div class="content">1. It&#x27;s so easy to skip errors that I have yet to encounter such a problem across two companies now. It&#x27;s weird</div><br/></div></div></div></div></div></div></div></body></html>