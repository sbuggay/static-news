<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698915667480" as="style"/><link rel="stylesheet" href="styles.css?v=1698915667480"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.blog/2023-08-17-mtls-when-certificate-authentication-is-done-wrong/">GitHub Engineering: When mTLS Is Done Wrong</a>Â <span class="domain">(<a href="https://github.blog">github.blog</a>)</span></div><div class="subtext"><span>sgammon</span> | <span>5 comments</span></div><br/><div><div id="38110710" class="c"><input type="checkbox" id="c-38110710" checked=""/><div class="controls bullet"><span class="by">kreetx</span><span>|</span><a href="#38110269">next</a><span>|</span><label class="collapse" for="c-38110710">[-]</label><label class="expand" for="c-38110710">[1 more]</label></div><br/><div class="children"><div class="content">mTLS has warts when used cross-origin. Fetch spec says that pre-flight requests mustn&#x27;t include client certificates[1], so as a consequence servers behind mTLS authenticated proxy won&#x27;t get a chance to reply to those pre-flight. Yet for non-preflighted requests it&#x27;s fine to include client certificates..<p>[1] <a href="https:&#x2F;&#x2F;fetch.spec.whatwg.org&#x2F;#cors-protocol-and-credentials" rel="nofollow noreferrer">https:&#x2F;&#x2F;fetch.spec.whatwg.org&#x2F;#cors-protocol-and-credentials</a></div><br/></div></div><div id="38110269" class="c"><input type="checkbox" id="c-38110269" checked=""/><div class="controls bullet"><span class="by">billpg</span><span>|</span><a href="#38110710">prev</a><span>|</span><a href="#38110385">next</a><span>|</span><label class="collapse" for="c-38110269">[-]</label><label class="expand" for="c-38110269">[2 more]</label></div><br/><div class="children"><div class="content">(Shameless plug.) I had some thoughts in this area.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;billpg&#x2F;CrossRequestTokenExchange">https:&#x2F;&#x2F;github.com&#x2F;billpg&#x2F;CrossRequestTokenExchange</a></div><br/><div id="38110536" class="c"><input type="checkbox" id="c-38110536" checked=""/><div class="controls bullet"><span class="by">buzer</span><span>|</span><a href="#38110269">parent</a><span>|</span><a href="#38110385">next</a><span>|</span><label class="collapse" for="c-38110536">[-]</label><label class="expand" for="c-38110536">[1 more]</label></div><br/><div class="children"><div class="content">One big issue I see is that you will need to keep the connection open. Malicious client could make the Initiator endpoint to hold the connection open (or to be more exact, they could simply drop the connection after acking the HTTP request), essentially causing 2 long-lived open connections for Issuer (for whatever the timeout is on server).</div><br/></div></div></div></div></div></div></div></div></div></body></html>