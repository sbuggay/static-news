<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731056467293" as="style"/><link rel="stylesheet" href="styles.css?v=1731056467293"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.dnmfarrell.com/post/incomplete-data-structures/">I&#x27;m not mutable, I&#x27;m partially instantiated</a> <span class="domain">(<a href="https://blog.dnmfarrell.com">blog.dnmfarrell.com</a>)</span></div><div class="subtext"><span>tlack</span> | <span>67 comments</span></div><br/><div><div id="42076929" class="c"><input type="checkbox" id="c-42076929" checked=""/><div class="controls bullet"><span class="by">openasocket</span><span>|</span><a href="#42076892">next</a><span>|</span><label class="collapse" for="c-42076929">[-]</label><label class="expand" for="c-42076929">[27 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never used it in production, but I have a deep love of Prolog, just because of how different it is from any other programming language I&#x27;ve used. As a programming paradigm, it found it as eye-opening as functional programming. What I found interesting is that you are operating on logical statements and pattern matching, which often means that the same &quot;function&quot; can be used for multiple different things. For example:<p>append([], List, List).<p>append([Head|Tail], List, [Head|Rest]) :-
    append(Tail, List, Rest).<p>Is a simple list append function: append(X, Y, Z) is a predicate that match if Z is the list of all elements of X, followed by all elements of Y. You can use it to concatenate lists, of course. But you can also use it to confirm that a particular list start with a particular sequence, or ends with a particular sequence! The idea that the same predicate can be used in multiple different ways is really fascinating to me. I have no idea to what extent that would scale in a large system, but it&#x27;s very interesting</div><br/><div id="42079462" class="c"><input type="checkbox" id="c-42079462" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42076929">parent</a><span>|</span><a href="#42079440">next</a><span>|</span><label class="collapse" for="c-42079462">[-]</label><label class="expand" for="c-42079462">[10 more]</label></div><br/><div class="children"><div class="content">I always thought that pattern matching would be an excellent feature for other programming languages, but it seems that it hasn&#x27;t become popular. Many strategies available to Prolog could become possible just by the addition of this feature. One possible implementation of the idea occurs with C++ templates specialized with numerical parameters. It also seems that Mathematica provides pattern matching, but I don&#x27;t use that language.</div><br/><div id="42079625" class="c"><input type="checkbox" id="c-42079625" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079462">parent</a><span>|</span><a href="#42080730">next</a><span>|</span><label class="collapse" for="c-42079625">[-]</label><label class="expand" for="c-42079625">[3 more]</label></div><br/><div class="children"><div class="content">Matching of <i>patterns</i>, with only a single occurrence allowed for each variable, is fairly popular in languages designed in the last two decades, isn’t it? A lot of those have or at least borrow from ML heritage, and that of course places a big emphasis on algebraic types and pattern matching. Full-blown unification remains niche, that’s true, but it’s just a fairly heavyweight feature, and I don’t really know how you’d integrate it without turning your language into (a superset of) Prolog.</div><br/><div id="42082684" class="c"><input type="checkbox" id="c-42082684" checked=""/><div class="controls bullet"><span class="by">iamwil</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079625">parent</a><span>|</span><a href="#42080730">next</a><span>|</span><label class="collapse" for="c-42082684">[-]</label><label class="expand" for="c-42082684">[2 more]</label></div><br/><div class="children"><div class="content">Simon Peyton Jones (of Haskell) is working on Verse, a functional relational programming language, that merges the ideas of both functional and logical programming into one.<p>It’s being done to facilitate Fortnite metaverse, as he’s doing this work at Epic.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;OJv8rFap0Nw?si=OmBT9CBJIxdJE1Jv" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;OJv8rFap0Nw?si=OmBT9CBJIxdJE1Jv</a></div><br/><div id="42085124" class="c"><input type="checkbox" id="c-42085124" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42082684">parent</a><span>|</span><a href="#42080730">next</a><span>|</span><label class="collapse" for="c-42085124">[-]</label><label class="expand" for="c-42085124">[1 more]</label></div><br/><div class="children"><div class="content">Functional logic programming much before Verse 
<a href="https:&#x2F;&#x2F;mercurylang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mercurylang.org&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42080730" class="c"><input type="checkbox" id="c-42080730" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079462">parent</a><span>|</span><a href="#42079625">prev</a><span>|</span><a href="#42079440">next</a><span>|</span><label class="collapse" for="c-42080730">[-]</label><label class="expand" for="c-42080730">[6 more]</label></div><br/><div class="children"><div class="content">Erlang, Elixir, Swift, Rust, Python, probably some others.<p>That list is roughly in order of how capable and useful the pattern matching is in each of those languages. Erlang was originally written in Prolog.<p>Also, I definitely agree it&#x27;s a feature I miss everywhere when not using Erlang&#x2F;Elixir.</div><br/><div id="42081050" class="c"><input type="checkbox" id="c-42081050" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42080730">parent</a><span>|</span><a href="#42083333">next</a><span>|</span><label class="collapse" for="c-42081050">[-]</label><label class="expand" for="c-42081050">[3 more]</label></div><br/><div class="children"><div class="content">I mostly ignored Python until my job required it, about 8 years ago. Coming from Erlang, I was pleasantly astonished to find that I could use tuple pattern matching in function headers… until I discovered that was dropped in Python 3 and I had been using the mostly-dead version 2 runtime.</div><br/><div id="42081544" class="c"><input type="checkbox" id="c-42081544" checked=""/><div class="controls bullet"><span class="by">harrisi</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42081050">parent</a><span>|</span><a href="#42083333">next</a><span>|</span><label class="collapse" for="c-42081544">[-]</label><label class="expand" for="c-42081544">[2 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;d call this destructuring, as opposed to patterns and matches, and Python still does it, just not in the function head.<p>I do wish they went the opposite direction and made the feature better instead of keeping it as a weird assignment thing in the body. The match statement is a similarly unfortunate solution, in my opinion.<p>Oh well. :)</div><br/><div id="42082299" class="c"><input type="checkbox" id="c-42082299" checked=""/><div class="controls bullet"><span class="by">macintux</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42081544">parent</a><span>|</span><a href="#42083333">next</a><span>|</span><label class="collapse" for="c-42082299">[-]</label><label class="expand" for="c-42082299">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re correct, destructuring is the appropriate term.<p>I checked the release notes, and the reason they removed it: no one was using it. I guess it&#x27;s unsurprising, but sad.</div><br/></div></div></div></div></div></div><div id="42083333" class="c"><input type="checkbox" id="c-42083333" checked=""/><div class="controls bullet"><span class="by">needlesslygrim</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42080730">parent</a><span>|</span><a href="#42081050">prev</a><span>|</span><a href="#42079440">next</a><span>|</span><label class="collapse" for="c-42083333">[-]</label><label class="expand" for="c-42083333">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious, how does Swift have better pattern matching than Rust?</div><br/><div id="42083456" class="c"><input type="checkbox" id="c-42083456" checked=""/><div class="controls bullet"><span class="by">sulam</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42083333">parent</a><span>|</span><a href="#42079440">next</a><span>|</span><label class="collapse" for="c-42083456">[-]</label><label class="expand" for="c-42083456">[1 more]</label></div><br/><div class="children"><div class="content">These are probably tied TBH.</div><br/></div></div></div></div></div></div></div></div><div id="42079440" class="c"><input type="checkbox" id="c-42079440" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#42076929">parent</a><span>|</span><a href="#42079462">prev</a><span>|</span><a href="#42077339">next</a><span>|</span><label class="collapse" for="c-42079440">[-]</label><label class="expand" for="c-42079440">[6 more]</label></div><br/><div class="children"><div class="content">Do you have a suggestion on where to &#x2F; how to start learning Prolog beyond towers-of-hanoi?  Prolog is basically the last language on my list of things I want to look at, but whenever I tried, I failed to find anything practical to do&#x2F;try.</div><br/><div id="42079639" class="c"><input type="checkbox" id="c-42079639" checked=""/><div class="controls bullet"><span class="by">dbcurtis</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079440">parent</a><span>|</span><a href="#42079641">next</a><span>|</span><label class="collapse" for="c-42079639">[-]</label><label class="expand" for="c-42079639">[2 more]</label></div><br/><div class="children"><div class="content">Try a rules-based synthesis problem. Prolog style (put simplisticly) is to write down what is true about a solution, and turn the search engine loose. Prolog is still procedural, unfortunately, so practical Prolog requires understanding the search algorithm. A suggestion: produce the XY locations of the nails for a building-code-compliant nailing pattern for a panel of plywood roof sheathing.  Allow different stud spacing and wind speed zones. This is a small toy problem but will channel your thought process toward something Prologgy.</div><br/><div id="42083240" class="c"><input type="checkbox" id="c-42083240" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079639">parent</a><span>|</span><a href="#42079641">next</a><span>|</span><label class="collapse" for="c-42083240">[-]</label><label class="expand" for="c-42083240">[1 more]</label></div><br/><div class="children"><div class="content">I love this example so much. I used a similar kind of problem a year or so ago when playing with some kind of logic&#x2F;linear programming&#x2F;optimization system: given a set of shelves (width and length), find the set of guillotine cuts (cuts across the entire sheet) that minimizes how many sheets of plywood are needed. If I recall the general problem is actually in NP but by formulating it as a problem of finding a list of operations (new sheet, cut sheet X horizontally, cut sheet X vertically) the solver was able to come up with high quality solutions in seconds.<p>I then took it and added a second level: once it has found a minimal number of sheets, minimize the number of cuts. Super handy little tool! Once I had the solver part figured out and added a little tweak for handling kerf, it was quite simple to have it spit out an SVG that showed all of the pieces and cuts.<p>And now… I want to go find that code and play with it again. Super fun stuff outside of the daily grind.</div><br/></div></div></div></div><div id="42079641" class="c"><input type="checkbox" id="c-42079641" checked=""/><div class="controls bullet"><span class="by">amock</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079440">parent</a><span>|</span><a href="#42079639">prev</a><span>|</span><a href="#42083679">next</a><span>|</span><label class="collapse" for="c-42079641">[-]</label><label class="expand" for="c-42079641">[2 more]</label></div><br/><div class="children"><div class="content">I’ve enjoyed <a href="https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog" rel="nofollow">https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog</a> but I’m not a Prolog Programmer.</div><br/><div id="42079907" class="c"><input type="checkbox" id="c-42079907" checked=""/><div class="controls bullet"><span class="by">lynx23</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079641">parent</a><span>|</span><a href="#42083679">next</a><span>|</span><label class="collapse" for="c-42079907">[-]</label><label class="expand" for="c-42079907">[1 more]</label></div><br/><div class="children"><div class="content">Ah, thanks for the link!  I know his YouTube channel, but somehow I never realized there is a webpage too!</div><br/></div></div></div></div><div id="42083679" class="c"><input type="checkbox" id="c-42083679" checked=""/><div class="controls bullet"><span class="by">lordwarnut</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079440">parent</a><span>|</span><a href="#42079641">prev</a><span>|</span><a href="#42077339">next</a><span>|</span><label class="collapse" for="c-42083679">[-]</label><label class="expand" for="c-42083679">[1 more]</label></div><br/><div class="children"><div class="content">I have been going through <a href="https:&#x2F;&#x2F;www.ic.unicamp.br&#x2F;~meidanis&#x2F;courses&#x2F;mc336&#x2F;2009s2&#x2F;prolog&#x2F;problemas&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ic.unicamp.br&#x2F;~meidanis&#x2F;courses&#x2F;mc336&#x2F;2009s2&#x2F;pro...</a><p>It starts out pretty easy but gets harder and requires more thought. It has different sections on things like list processing or graph problems.</div><br/></div></div></div></div><div id="42077339" class="c"><input type="checkbox" id="c-42077339" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#42076929">parent</a><span>|</span><a href="#42079440">prev</a><span>|</span><a href="#42077227">next</a><span>|</span><label class="collapse" for="c-42077339">[-]</label><label class="expand" for="c-42077339">[9 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t scale that well because integers are their own, opaque thing in Prolog, and the is predicate is unidirectional. However, there&#x27;s no inherent reason this has to be the case: you can construct your own representation of the integers from the Peano axioms, and recover bidirectionality of addition. (You&#x27;ll want to be using some typed variant of Prolog with the &quot;unary tree of units&quot; optimisation, otherwise integers take O(n) space in memory, but it&#x27;s possible in the language.) Prolog works how it does, because it&#x27;s (mostly) backwards-compatible with a facts database used for symbolic AI research, where all atoms were opaque.</div><br/><div id="42077598" class="c"><input type="checkbox" id="c-42077598" checked=""/><div class="controls bullet"><span class="by">lmkg</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42077339">parent</a><span>|</span><a href="#42078265">next</a><span>|</span><label class="collapse" for="c-42077598">[-]</label><label class="expand" for="c-42077598">[2 more]</label></div><br/><div class="children"><div class="content">Check out the CLP(ℤ) library by Markus Triska, who is also the author of Scryer Prolog. It defines new comparison predicates that lets you use bidirectional logical programming on standard integers with standard math operations.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;triska&#x2F;clpz">https:&#x2F;&#x2F;github.com&#x2F;triska&#x2F;clpz</a></div><br/><div id="42081735" class="c"><input type="checkbox" id="c-42081735" checked=""/><div class="controls bullet"><span class="by">dsabanin</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42077598">parent</a><span>|</span><a href="#42078265">next</a><span>|</span><label class="collapse" for="c-42081735">[-]</label><label class="expand" for="c-42081735">[1 more]</label></div><br/><div class="children"><div class="content">Markus is not the author of Scryer Prolog, Mark Thom is.</div><br/></div></div></div></div><div id="42078265" class="c"><input type="checkbox" id="c-42078265" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42077339">parent</a><span>|</span><a href="#42077598">prev</a><span>|</span><a href="#42078048">next</a><span>|</span><label class="collapse" for="c-42078265">[-]</label><label class="expand" for="c-42078265">[2 more]</label></div><br/><div class="children"><div class="content">There are many ways to recover relational behaviour. Libs such as clp(fd) (superseded by clp(Z)), clp(BNR) and others.</div><br/><div id="42078694" class="c"><input type="checkbox" id="c-42078694" checked=""/><div class="controls bullet"><span class="by">Avshalom</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42078265">parent</a><span>|</span><a href="#42078048">next</a><span>|</span><label class="collapse" for="c-42078694">[-]</label><label class="expand" for="c-42078694">[1 more]</label></div><br/><div class="children"><div class="content">BNR notably works with real numbers and non linear constraints.</div><br/></div></div></div></div><div id="42078048" class="c"><input type="checkbox" id="c-42078048" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42077339">parent</a><span>|</span><a href="#42078265">prev</a><span>|</span><a href="#42079406">next</a><span>|</span><label class="collapse" for="c-42078048">[-]</label><label class="expand" for="c-42078048">[1 more]</label></div><br/><div class="children"><div class="content">“you can construct your own representation of the integers from the Peano axioms”<p>This is how the Idris prelude defines nat, the type of natural numbers (with some magic making it actually  fast). I think that’s very cool.</div><br/></div></div><div id="42079406" class="c"><input type="checkbox" id="c-42079406" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42077339">parent</a><span>|</span><a href="#42078048">prev</a><span>|</span><a href="#42077227">next</a><span>|</span><label class="collapse" for="c-42079406">[-]</label><label class="expand" for="c-42079406">[3 more]</label></div><br/><div class="children"><div class="content">Modern Prolog libraries have handled the issues of unidirectional integer predicates, so the old ways of handling numeric values is not relevant for most problems.</div><br/><div id="42084644" class="c"><input type="checkbox" id="c-42084644" checked=""/><div class="controls bullet"><span class="by">jfmc</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42079406">parent</a><span>|</span><a href="#42077227">next</a><span>|</span><label class="collapse" for="c-42084644">[-]</label><label class="expand" for="c-42084644">[2 more]</label></div><br/><div class="children"><div class="content">Many times the algorithm that you are implementing requires a precise data flow that is not reversible, so using traditional arithmetic (is&#x2F;2) is better for catching errors.<p>On the other hand CLP(FD) is not new at all (it is very popular for constraint programming).</div><br/><div id="42085208" class="c"><input type="checkbox" id="c-42085208" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#42076929">root</a><span>|</span><a href="#42084644">parent</a><span>|</span><a href="#42077227">next</a><span>|</span><label class="collapse" for="c-42085208">[-]</label><label class="expand" for="c-42085208">[1 more]</label></div><br/><div class="children"><div class="content">Why would it be better for error handling? If you&#x27;ll be using unidirectional flow only, then the point is moot. But using clp is arguably better IMO, allowing type and range checks while allowing relational execution.</div><br/></div></div></div></div></div></div></div></div><div id="42077227" class="c"><input type="checkbox" id="c-42077227" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#42076929">parent</a><span>|</span><a href="#42077339">prev</a><span>|</span><a href="#42076892">next</a><span>|</span><label class="collapse" for="c-42077227">[-]</label><label class="expand" for="c-42077227">[1 more]</label></div><br/><div class="children"><div class="content">Same, I love the bidirectional aspect of relations</div><br/></div></div></div></div><div id="42076892" class="c"><input type="checkbox" id="c-42076892" checked=""/><div class="controls bullet"><span class="by">anfelor</span><span>|</span><a href="#42076929">prev</a><span>|</span><a href="#42079828">next</a><span>|</span><label class="collapse" for="c-42076892">[-]</label><label class="expand" for="c-42076892">[9 more]</label></div><br/><div class="children"><div class="content">Partially instantiated data structures are also available in Haskell (via Laziness), in OCaml (via tail modulo cons, <a href="https:&#x2F;&#x2F;inria.hal.science&#x2F;hal-03146495&#x2F;document" rel="nofollow">https:&#x2F;&#x2F;inria.hal.science&#x2F;hal-03146495&#x2F;document</a>) and Koka (via constructor contexts, <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3656398" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;3656398</a>)</div><br/><div id="42079154" class="c"><input type="checkbox" id="c-42079154" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#42076892">parent</a><span>|</span><a href="#42078838">next</a><span>|</span><label class="collapse" for="c-42079154">[-]</label><label class="expand" for="c-42079154">[2 more]</label></div><br/><div class="children"><div class="content">Laziness and TMC are fundamentally different from partial instantiation in that they are implementation details, mostly&#x2F;wholly invisible to the language semantics themselves.<p>A key aspect of partial instantiation is that the &quot;holes&quot; may be filled in by a <i>semantically unrelated</i> piece of code, which is not the case for either laziness or TMC (wherein the contents data structure must be defined in one place, even if the implementation does not evaluate it immediately).<p>(I don&#x27;t know Koka so I can&#x27;t speak to that.)</div><br/><div id="42080404" class="c"><input type="checkbox" id="c-42080404" checked=""/><div class="controls bullet"><span class="by">anfelor</span><span>|</span><a href="#42076892">root</a><span>|</span><a href="#42079154">parent</a><span>|</span><a href="#42078838">next</a><span>|</span><label class="collapse" for="c-42080404">[-]</label><label class="expand" for="c-42080404">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that is true! Koka&#x27;s constructor contexts also allow you to do this. A constructor context is a data structure with exactly one hole which you can fill in with an arbitrary value (or even several arbitrary values, copying the constructor context in the process).</div><br/></div></div></div></div><div id="42078838" class="c"><input type="checkbox" id="c-42078838" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42076892">parent</a><span>|</span><a href="#42079154">prev</a><span>|</span><a href="#42077770">next</a><span>|</span><label class="collapse" for="c-42078838">[-]</label><label class="expand" for="c-42078838">[1 more]</label></div><br/><div class="children"><div class="content">Also, you can do lazy initialization in any language that has functions by passing a getter function around instead of a value.<p>I recently had need for this to implement validation for recursive data structures in TypeScript. It depends on support for forward references in the body of a function. The tricky bit is ensuring that the getter isn’t called until the cycle is completed by defining the forward reference’s target. The type system doesn’t help; you just have to write the implementation so it doesn’t call the getter.</div><br/></div></div><div id="42077770" class="c"><input type="checkbox" id="c-42077770" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#42076892">parent</a><span>|</span><a href="#42078838">prev</a><span>|</span><a href="#42079828">next</a><span>|</span><label class="collapse" for="c-42077770">[-]</label><label class="expand" for="c-42077770">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think Haskell <i>can</i> do this, can have a growable linked list for example. &#x27;last a&#x27; is &#x27;last a&#x27;, regardless what is between them (modulo shadowing and such).<p>And I suspect that Prolog&#x27;s Partial Instantiation is, while not mutating data, but it is mutating references somewhere</div><br/><div id="42079115" class="c"><input type="checkbox" id="c-42079115" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#42076892">root</a><span>|</span><a href="#42077770">parent</a><span>|</span><a href="#42079110">next</a><span>|</span><label class="collapse" for="c-42079115">[-]</label><label class="expand" for="c-42079115">[1 more]</label></div><br/><div class="children"><div class="content">Technically, Haskell laziness is just mutability under the hood :)<p>And the &quot;difference list&quot; mentioned in the article is also in Haskell - although framed differently (more &quot;functionally&quot;)<p><pre><code>    type DList a = [a] -&gt; [a]

    concat :: DList a -&gt; DList a -&gt; DList a
    concat = (.)

    toList :: DList a -&gt; [a]
    toList d = d []

    fromList :: [a] -&gt; DList a
    fromList = (++)</code></pre></div><br/></div></div><div id="42079110" class="c"><input type="checkbox" id="c-42079110" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42076892">root</a><span>|</span><a href="#42077770">parent</a><span>|</span><a href="#42079115">prev</a><span>|</span><a href="#42079828">next</a><span>|</span><label class="collapse" for="c-42079110">[-]</label><label class="expand" for="c-42079110">[3 more]</label></div><br/><div class="children"><div class="content">Haskell has cyclic data structures, which also can’t be implemented without a mutable reference somewhere, though it may be buried in the implementation.<p>The difference is being able to define an incomplete data structure (with a forward reference) and then defining the target of the reference <i>at runtime.</i> Most languages will complain about an undefined reference if it’s not defined by the end of a module.<p>You could do it with soft references, though. Use a symbol or string to refer to something and define it later.</div><br/><div id="42079445" class="c"><input type="checkbox" id="c-42079445" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#42076892">root</a><span>|</span><a href="#42079110">parent</a><span>|</span><a href="#42079227">next</a><span>|</span><label class="collapse" for="c-42079445">[-]</label><label class="expand" for="c-42079445">[1 more]</label></div><br/><div class="children"><div class="content">I rather think the fact the the same symbol&#x2F;string always denotes the same thing is especially helpful for cyclic structures.<p>Anyway I think I misunderstood the article, I thought they added things to a dictionary in the prolog repl, which would be impossible in haskell&#x2F;ghci afaik.</div><br/></div></div></div></div></div></div></div></div><div id="42079828" class="c"><input type="checkbox" id="c-42079828" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42076892">prev</a><span>|</span><a href="#42076304">next</a><span>|</span><label class="collapse" for="c-42079828">[-]</label><label class="expand" for="c-42079828">[2 more]</label></div><br/><div class="children"><div class="content">It seems like whether this represents a mutable or immutable data structure depends on the operations you allow. If polling with nonvar() is allowed, couldn’t you see variables mutate as you do more unification? But if it’s not allowed, I guess you get a variable to be defined later?<p>Compare with a Promise. If you can check whether it resolved, you can see it mutate. If the only operation allowed is to await it then from the code’s point of view, it might be considered an immutable reference to the pending result.</div><br/><div id="42081739" class="c"><input type="checkbox" id="c-42081739" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#42079828">parent</a><span>|</span><a href="#42076304">next</a><span>|</span><label class="collapse" for="c-42081739">[-]</label><label class="expand" for="c-42081739">[1 more]</label></div><br/><div class="children"><div class="content">Yes, `nonvar&#x2F;1` is considered &quot;extralogical&quot;, in that it can be used to observe these side effects. If one sticks to &quot;pure&quot; logical operations (which unintuitively excludes `\+` negation) they are not observable.</div><br/></div></div></div></div><div id="42076304" class="c"><input type="checkbox" id="c-42076304" checked=""/><div class="controls bullet"><span class="by">p4bl0</span><span>|</span><a href="#42079828">prev</a><span>|</span><a href="#42082830">next</a><span>|</span><label class="collapse" for="c-42076304">[-]</label><label class="expand" for="c-42076304">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get where the `-` comes from in `key-value` result lines after the &quot;refactoring&quot; title. I feel like it should stay a `,` like at the beginning. Can someone more knowledgeable in Prolog explain that? Is that because of an hidden use of this `to_list` predicate that comes later in the post?</div><br/><div id="42076461" class="c"><input type="checkbox" id="c-42076461" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#42076304">parent</a><span>|</span><a href="#42077356">next</a><span>|</span><label class="collapse" for="c-42076461">[-]</label><label class="expand" for="c-42076461">[1 more]</label></div><br/><div class="children"><div class="content">Operators like <i>-</i> are just an infix functor for a Prolog term with arity 2:<p><pre><code>    ?- functor(123-&quot;foo&quot;, Name, Arity, Type).
    Name = (-),
    Arity = 2,
    Type = compound.

    ?- 1-&quot;foo&quot; = &#x27;-&#x27;(1,&quot;foo&quot;).
    true.
</code></pre>
Functors like <i>-</i> only become arithmetic in combination with <i>is</i>:<p><pre><code>    ?- A is &#x27;-&#x27;(42, 1).
    A = 41.
    
    ?- A is 42 - 1.
    A = 41.</code></pre></div><br/></div></div><div id="42077356" class="c"><input type="checkbox" id="c-42077356" checked=""/><div class="controls bullet"><span class="by">tannhaeuser</span><span>|</span><a href="#42076304">parent</a><span>|</span><a href="#42076461">prev</a><span>|</span><a href="#42076347">next</a><span>|</span><label class="collapse" for="c-42077356">[-]</label><label class="expand" for="c-42077356">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s purely a convention to use terms of the form &quot;key - value&quot; for 2-tuples here (or &#x27;-&#x27;(key, value) in funtional&#x2F;canonical notation which can be used as well). minus is just used because it&#x27;s already predeclared as an infix operator, and indeed &#x27;,&#x27;(key, value) could be used as well but comma is also used as argument separator and for conjunctions in clause bodies and thus tends to be avoided. You also can see &#x27;=&#x27; being used for the same thing eg.<p><pre><code>    [ key = value, ...]
</code></pre>
(for example, as used for representing attributes by SGML&#x2F;XML parsing libs for SWI, Quintus&#x2F;SICStus, and others), not to be confused with &#x27;=&#x27; being interpreted as unification operation in goals&#x2F;clause bodies.<p>If you think about it, the simplest convention in Prolog to represent &quot;assignment&quot; of a value to a symbol (not a variable) would be<p><pre><code>    key(value).
</code></pre>
That is, to use the &quot;key&quot; atom as functor itself, rather than use functors&#x2F;operators in ad-hoc ways. This is exactly what Quantum Prolog can do (optionally, and in addition to ISO Prolog&#x27;s conventions).<p>Specifically, if you have a list of fact-like terms<p><pre><code>    L = [ p(1), q(2), r(what(ever)) ]
</code></pre>
then Quantum Prolog can answer queries against such term list, just like answering against the global default database eg.<p><pre><code>    call(L ?- q(X))
</code></pre>
binds<p><pre><code>    X = 2
</code></pre>
and would also bind additional values for q(X) on backtracking if the term list contained any. This is a natural extension to regular querying in Prolog because a term list [a, b] in Prolog&#x27;s square bracket notation is just syntactic sugar for using the dot operator<p><pre><code>    &#x27;.&#x27;(a, &#x27;.&#x27;(b, []))
</code></pre>
and a Prolog program is syntactically just a list of clause terms.<p>In the container planning demo on the Quantum Prolog site [1], this feature is used for backtracking over (un)loading and travelling actions which would normally change state via destructive assert and retract calls and hence not allow backtracking to search for optimal sequences of actions.<p>[1]: <a href="https:&#x2F;&#x2F;quantumprolog.sgml.net&#x2F;container-planning-demo&#x2F;part2.html" rel="nofollow">https:&#x2F;&#x2F;quantumprolog.sgml.net&#x2F;container-planning-demo&#x2F;part2...</a></div><br/><div id="42077571" class="c"><input type="checkbox" id="c-42077571" checked=""/><div class="controls bullet"><span class="by">YeGoblynQueenne</span><span>|</span><a href="#42076304">root</a><span>|</span><a href="#42077356">parent</a><span>|</span><a href="#42076347">next</a><span>|</span><label class="collapse" for="c-42077571">[-]</label><label class="expand" for="c-42077571">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no -&#x2F;2 operator in the initial definition of lookup&#x2F;3 though:<p><pre><code>  lookup(Key, dict(Key,X,Left,Right), Value) :-
      !
      ,X=Value.
  lookup(Key, dict(Keyl,X,Left,Right), Value) :-
      Key &lt; Keyl
      ,lookup(Key,Left,Value).
  lookup(Key, dict(Keyl,X,Left,Right), Value) :-
      Key &gt; Keyl
      ,lookup(Key,Right,Value).
</code></pre>
You can also see that in the first call to lookup&#x2F;3 where there&#x27;s no -&#x2F;2.<p>If I understand correctly, that&#x27;s what the OP is asking: Where did the -&#x2F;2 come from, not what it&#x27;s for.<p>The call with the -&#x2F;2 is under the heading &quot;Refactoring the dictionary&quot; so it&#x27;s possible the author mixed up the implementations while writing the article and listed the output of an implementation that represents key-value pairs as -&#x2F;2 terms.<p>The refactored version makes more sense btw and indeed I see the author switches to K-V later on in the article.</div><br/></div></div></div></div><div id="42076347" class="c"><input type="checkbox" id="c-42076347" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#42076304">parent</a><span>|</span><a href="#42077356">prev</a><span>|</span><a href="#42082830">next</a><span>|</span><label class="collapse" for="c-42076347">[-]</label><label class="expand" for="c-42076347">[1 more]</label></div><br/><div class="children"><div class="content">(The initial version of this comment missed the point of your question; sorry.) The author says:<p>&gt; We also store pairs as the pair type (Key-Value), instead of two separate values. This makes easy to serialize a dictionary into a list of pairs, which are sortable using the builtin keysort&#x2F;2.<p>`Key, Value` is two values, not one. I suspect something like `kv(Key, Value)` would work as well.<p>By the way, I disagree that the refactored version doesn&#x27;t cut; `-&gt; ;` is syntactic sugar over a cut.</div><br/></div></div></div></div><div id="42082830" class="c"><input type="checkbox" id="c-42082830" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#42076304">prev</a><span>|</span><a href="#42080542">next</a><span>|</span><label class="collapse" for="c-42082830">[-]</label><label class="expand" for="c-42082830">[1 more]</label></div><br/><div class="children"><div class="content">It’s a beautiful construction. It reminds me a bit of the “canonical” quicksort in Haskell [1].<p>Neither of these implementations is going to be displacing absl::btree_map or std::sort any time soon, but I do feel we have a lot of “room at the bottom” for making simple and elegant code practical on real machines.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7717691&#x2F;why-is-the-minimalist-example-haskell-quicksort-not-a-true-quicksort" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7717691&#x2F;why-is-the-minim...</a><p>Edit: replaced poorly formatted code with SO link.</div><br/></div></div><div id="42080542" class="c"><input type="checkbox" id="c-42080542" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#42082830">prev</a><span>|</span><a href="#42076739">next</a><span>|</span><label class="collapse" for="c-42080542">[-]</label><label class="expand" for="c-42080542">[2 more]</label></div><br/><div class="children"><div class="content">Is &quot;The Art of Prolog&quot; a good place to start with the lanugage?</div><br/><div id="42085260" class="c"><input type="checkbox" id="c-42085260" checked=""/><div class="controls bullet"><span class="by">rscho</span><span>|</span><a href="#42080542">parent</a><span>|</span><a href="#42076739">next</a><span>|</span><label class="collapse" for="c-42085260">[-]</label><label class="expand" for="c-42085260">[1 more]</label></div><br/><div class="children"><div class="content">The book is ok for core Prolog, but quite old and many new features have been made available since then. Including stuff making parts of the core language obsolete.<p>Honestly, the language is super small. Best way to learn IMO is to go on <a href="https:&#x2F;&#x2F;swish.swi-prolog.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;swish.swi-prolog.org&#x2F;</a> and do the examples &#x2F; play with it. If you stick to it, then you can branch to other engines later (there are many systems with unique features).</div><br/></div></div></div></div><div id="42076739" class="c"><input type="checkbox" id="c-42076739" checked=""/><div class="controls bullet"><span class="by">jfmc</span><span>|</span><a href="#42080542">prev</a><span>|</span><a href="#42077048">next</a><span>|</span><label class="collapse" for="c-42076739">[-]</label><label class="expand" for="c-42076739">[1 more]</label></div><br/><div class="children"><div class="content">A classic library, you can play with it here: <a href="https:&#x2F;&#x2F;ciao-lang.org&#x2F;playground&#x2F;#https:&#x2F;&#x2F;github.com&#x2F;ciao-lang&#x2F;ciao&#x2F;blob&#x2F;master&#x2F;core&#x2F;lib&#x2F;dict.pl" rel="nofollow">https:&#x2F;&#x2F;ciao-lang.org&#x2F;playground&#x2F;#https:&#x2F;&#x2F;github.com&#x2F;ciao-la...</a></div><br/></div></div><div id="42077048" class="c"><input type="checkbox" id="c-42077048" checked=""/><div class="controls bullet"><span class="by">samweb3</span><span>|</span><a href="#42076739">prev</a><span>|</span><a href="#42077481">next</a><span>|</span><label class="collapse" for="c-42077048">[-]</label><label class="expand" for="c-42077048">[5 more]</label></div><br/><div class="children"><div class="content">I am actually working on a logical query language that&#x27;s a successor to prolog here: <a href="https:&#x2F;&#x2F;memelang.net&#x2F;02&#x2F;" rel="nofollow">https:&#x2F;&#x2F;memelang.net&#x2F;02&#x2F;</a>. Any feedback appreciated!</div><br/><div id="42080902" class="c"><input type="checkbox" id="c-42080902" checked=""/><div class="controls bullet"><span class="by">shawa_a_a</span><span>|</span><a href="#42077048">parent</a><span>|</span><a href="#42080714">next</a><span>|</span><label class="collapse" for="c-42080902">[-]</label><label class="expand" for="c-42080902">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bold statement to call something a Prolog successor! Are you aiming for a general purpose logic programming language like Prolog, or targeting the use case of querying knowledge bases?<p>One of the draws to Prolog is its immensely simple syntax:
A.R:B = true in your case would be represented as simply r(A, B).<p>It looks like you&#x27;ve elevated some set theory properties to syntax, and have added some neat sugar over chained relations. Have you found areas where this really shines as compared to writing more standard Prolog&#x2F;Datalog queries? I&#x27;m afraid I couldn&#x27;t see many examples on first look at your Github.</div><br/></div></div><div id="42080714" class="c"><input type="checkbox" id="c-42080714" checked=""/><div class="controls bullet"><span class="by">simplify</span><span>|</span><a href="#42077048">parent</a><span>|</span><a href="#42080902">prev</a><span>|</span><a href="#42077391">next</a><span>|</span><label class="collapse" for="c-42080714">[-]</label><label class="expand" for="c-42080714">[2 more]</label></div><br/><div class="children"><div class="content">Alternative would be interesting, but successor is thought provoking. Do you mean to say most all Prolog capabilities will be possible to do in Meme?</div><br/><div id="42081387" class="c"><input type="checkbox" id="c-42081387" checked=""/><div class="controls bullet"><span class="by">samweb3</span><span>|</span><a href="#42077048">root</a><span>|</span><a href="#42080714">parent</a><span>|</span><a href="#42077391">next</a><span>|</span><label class="collapse" for="c-42081387">[-]</label><label class="expand" for="c-42081387">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the goal, but please let me know if there&#x27;s anything you find that you can&#x27;t do.</div><br/></div></div></div></div><div id="42077391" class="c"><input type="checkbox" id="c-42077391" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#42077048">parent</a><span>|</span><a href="#42080714">prev</a><span>|</span><a href="#42077481">next</a><span>|</span><label class="collapse" for="c-42077391">[-]</label><label class="expand" for="c-42077391">[1 more]</label></div><br/><div class="children"><div class="content">It might be worth using standard vocabulary. For example:<p>&gt; Reciprocal relations are their own inverse.<p>The usual word for this is &quot;symmetric&quot;.<p>&gt; Recursive relations can be chained to themselves infinitely. For example, &quot;my ancestor&#x27;s ancestor is also my ancestor.&quot;<p>The usual word for this is &quot;transitive&quot;.<p>A reflexive, symmetric, transitive relation is called an &quot;equivalence relation&quot;, and it can be used much like equality. It&#x27;d be nice if your language had support for this, though I don&#x27;t immediately see how to add it.</div><br/></div></div></div></div><div id="42077481" class="c"><input type="checkbox" id="c-42077481" checked=""/><div class="controls bullet"><span class="by">tolerance</span><span>|</span><a href="#42077048">prev</a><span>|</span><a href="#42076178">next</a><span>|</span><label class="collapse" for="c-42077481">[-]</label><label class="expand" for="c-42077481">[1 more]</label></div><br/><div class="children"><div class="content">This is philosophically intriguing.</div><br/></div></div><div id="42076178" class="c"><input type="checkbox" id="c-42076178" checked=""/><div class="controls bullet"><span class="by">lelag</span><span>|</span><a href="#42077481">prev</a><span>|</span><a href="#42077568">next</a><span>|</span><label class="collapse" for="c-42076178">[-]</label><label class="expand" for="c-42076178">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve noticed quite a lot of Prolog content lately. I don&#x27;t know if it&#x27;s just a case of the Baader–Meinhof phenomenon, but it looks to me that recent article[1] about Prolog being able to improve LLM reasoning abilities renewed some interest in the language.<p>[1] <a href="https:&#x2F;&#x2F;shchegrikovich.substack.com&#x2F;p&#x2F;use-prolog-to-improve-llms-reasoning" rel="nofollow">https:&#x2F;&#x2F;shchegrikovich.substack.com&#x2F;p&#x2F;use-prolog-to-improve-...</a></div><br/><div id="42076249" class="c"><input type="checkbox" id="c-42076249" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#42076178">parent</a><span>|</span><a href="#42076445">next</a><span>|</span><label class="collapse" for="c-42076249">[-]</label><label class="expand" for="c-42076249">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the hacker news post: 
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41831735">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41831735</a></div><br/><div id="42079691" class="c"><input type="checkbox" id="c-42079691" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076249">parent</a><span>|</span><a href="#42076445">next</a><span>|</span><label class="collapse" for="c-42079691">[-]</label><label class="expand" for="c-42079691">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Macroexpanded:<p><i>Use Prolog to improve LLM&#x27;s reasoning</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41831735">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41831735</a> - Oct 2024 (155 comments)</div><br/></div></div></div></div><div id="42076445" class="c"><input type="checkbox" id="c-42076445" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42076178">parent</a><span>|</span><a href="#42076249">prev</a><span>|</span><a href="#42076379">next</a><span>|</span><label class="collapse" for="c-42076445">[-]</label><label class="expand" for="c-42076445">[7 more]</label></div><br/><div class="children"><div class="content">Which is strange considering how old and limited Prolog in a sense is. I wonder why no superset ever gained traction and what it would look like. I imagine it fitting somewhere in the hierarchy<p>Theorem Prover ⊃ SMT Solver ⊃ SAT Solver<p>since<p>Theorem Prover ⊃ Prolog</div><br/><div id="42076566" class="c"><input type="checkbox" id="c-42076566" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076445">parent</a><span>|</span><a href="#42076465">next</a><span>|</span><label class="collapse" for="c-42076566">[-]</label><label class="expand" for="c-42076566">[1 more]</label></div><br/><div class="children"><div class="content">The post in OP has the following hyphothesis:<p>&gt; Why Prolog? [...] Due to it&#x27;s declarative nature it might be a bit easier for LLMs to generate code, because LLM doesn&#x27;t need to generate precise control flow.<p>This is an interesting point, and my guess is that prolog is the declarative programming language with most example code out there for it to learn on(excluding SQL). Alternatively it could try to create some problem description for an automated theorem prover. My (absolute ignorant) guess is that the prolog aproach works better for two reasons:<p>- The amount of prolog code in the training set is higher<p>- It is still only able to create code for problems easy enough that prolog can handle them.</div><br/></div></div><div id="42076465" class="c"><input type="checkbox" id="c-42076465" checked=""/><div class="controls bullet"><span class="by">Byamarro</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076445">parent</a><span>|</span><a href="#42076566">prev</a><span>|</span><a href="#42076503">next</a><span>|</span><label class="collapse" for="c-42076465">[-]</label><label class="expand" for="c-42076465">[1 more]</label></div><br/><div class="children"><div class="content">Learning curve perhaps? There doesn&#x27;t have to be an overlap between people working on this and the tools you have mentioned</div><br/></div></div><div id="42076503" class="c"><input type="checkbox" id="c-42076503" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076445">parent</a><span>|</span><a href="#42076465">prev</a><span>|</span><a href="#42076518">next</a><span>|</span><label class="collapse" for="c-42076503">[-]</label><label class="expand" for="c-42076503">[2 more]</label></div><br/><div class="children"><div class="content">limited in what sense?<p>prolog is turing complete.</div><br/><div id="42076591" class="c"><input type="checkbox" id="c-42076591" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076503">parent</a><span>|</span><a href="#42076518">next</a><span>|</span><label class="collapse" for="c-42076591">[-]</label><label class="expand" for="c-42076591">[1 more]</label></div><br/><div class="children"><div class="content">He might be thinking about the SLDNF resolution happening. But yes, you can implement any prover in prolog. This distinction is discussed a bit here: <a href="https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog&#x2F;theoremproving" rel="nofollow">https:&#x2F;&#x2F;www.metalevel.at&#x2F;prolog&#x2F;theoremproving</a></div><br/></div></div></div></div><div id="42076518" class="c"><input type="checkbox" id="c-42076518" checked=""/><div class="controls bullet"><span class="by">sixfiveotwo</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076445">parent</a><span>|</span><a href="#42076503">prev</a><span>|</span><a href="#42076612">next</a><span>|</span><label class="collapse" for="c-42076518">[-]</label><label class="expand" for="c-42076518">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, you can get a lot more from dependent types than Damas-Hindley-Milner inference, yet does it mean that you should use the former everywhere?</div><br/></div></div><div id="42076612" class="c"><input type="checkbox" id="c-42076612" checked=""/><div class="controls bullet"><span class="by">dsabanin</span><span>|</span><a href="#42076178">root</a><span>|</span><a href="#42076445">parent</a><span>|</span><a href="#42076518">prev</a><span>|</span><a href="#42076379">next</a><span>|</span><label class="collapse" for="c-42076612">[-]</label><label class="expand" for="c-42076612">[1 more]</label></div><br/><div class="children"><div class="content">Another attractive feature of Prolog is that it’s homoiconic, like lisp.</div><br/></div></div></div></div></div></div><div id="42077568" class="c"><input type="checkbox" id="c-42077568" checked=""/><div class="controls bullet"><span class="by">bedobi</span><span>|</span><a href="#42076178">prev</a><span>|</span><label class="collapse" for="c-42077568">[-]</label><label class="expand" for="c-42077568">[2 more]</label></div><br/><div class="children"><div class="content">Partial instantiation is cool and all, but tbh I prefer just capturing the initial incomplete attributes in one complete record, pass that around, and then instantiate the real thing when you have all attributes<p><pre><code>    data class IncompletePerson(val name: String)

    data class Person(
      val name: String, 
      val email: String
    )
</code></pre>
or<p><pre><code>    data class Person(
      val initialAttributes: IncompletePerson, 
      val email: String
    )
</code></pre>
if you want to nest it.<p>if you&#x27;re the type to instead do this<p><pre><code>    data class Person(
      val name: String, 
      val email: String?
    )
</code></pre>
I never want to work with your code. Now, there&#x27;s no disambiguation between the complete object and the incomplete one, I always have to check before doing anything with it, and people will inevitably try send an incomplete object someplace that can&#x27;t handle it and generate bugs.</div><br/><div id="42079173" class="c"><input type="checkbox" id="c-42079173" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42077568">parent</a><span>|</span><label class="collapse" for="c-42079173">[-]</label><label class="expand" for="c-42079173">[1 more]</label></div><br/><div class="children"><div class="content">How would you define a cyclic data structure?</div><br/></div></div></div></div></div></div></div></div></div></body></html>