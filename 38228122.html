<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699866063396" as="style"/><link rel="stylesheet" href="styles.css?v=1699866063396"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://poignardazur.github.io//2023/11/08/time-for-variadic-generics/">Variadic generics, again</a> <span class="domain">(<a href="https://poignardazur.github.io">poignardazur.github.io</a>)</span></div><div class="subtext"><span>lukastyrychtr</span> | <span>24 comments</span></div><br/><div><div id="38248146" class="c"><input type="checkbox" id="c-38248146" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#38246109">next</a><span>|</span><label class="collapse" for="c-38248146">[-]</label><label class="expand" for="c-38248146">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  Focus on the compile error story. In particular, the design should avoid anything that leads to post-monomorphization errors.
</code></pre>
This is the single biggest mistake of Rust imho. I don&#x27;t care in which compiler pass an error occurs as long as it happens at compile time.
Rust has this anyways, you can already create types that fail after monomorphization, so you don&#x27;t get any of the touted advantages anyways. You might as well bite the bullet accept that the people who say “You guys are dumb, just copy Zig’s type system” have a point, and shed some of the ivory tower dogma in exchange for a better language. It&#x27;s completely fine for monomorphization to fail, and it allows you to create much more powerfull types.<p>Rust is already incredibly complex, and most of that complexity comes from dozens of different systems that share few concepts all with their own syntax (modules, macros, traits, e.t.c.), so adding yet another syntax for static loops begs the question if some of this can&#x27;t be unified.<p>Zig is a seriously flawed language, but comptime is the right abstraction for metaprogramming in an imperative language.</div><br/><div id="38248165" class="c"><input type="checkbox" id="c-38248165" checked=""/><div class="controls bullet"><span class="by">ngrilly</span><span>|</span><a href="#38248146">parent</a><span>|</span><a href="#38246109">next</a><span>|</span><label class="collapse" for="c-38248165">[-]</label><label class="expand" for="c-38248165">[2 more]</label></div><br/><div class="children"><div class="content">A bit off-topic, but since you mentioned it, why is Zig a &quot;seriously flawed language&quot;?</div><br/><div id="38248226" class="c"><input type="checkbox" id="c-38248226" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#38248146">root</a><span>|</span><a href="#38248165">parent</a><span>|</span><a href="#38246109">next</a><span>|</span><label class="collapse" for="c-38248226">[-]</label><label class="expand" for="c-38248226">[1 more]</label></div><br/><div class="children"><div class="content">Priorities. The team is too focused on global maxima, speed and reinventing compiler design at the cost of a reference implementation that&#x27;s fundamentally broken, and too complex to fix.<p>This results in miscompilations, broken buildins, features added that are then ripped out again.<p>I think fast iterations and experimental stuff are ok if you have a stable core.
I.e. I don&#x27;t mind if zig decides to change its for loop syntax after 5 years, so long as there is a simpler stable construct like `loop { break; }` that people that use the language in production and library maintainers can use.<p>You need a certain critical mass for a language to be self sustaining, and that requires people to actually use your stuff, which in turn requires at least some stability guarantees for some subset of the language.<p>Zig&#x27;s response to that is &quot;I&#x27;m just my inventors toy yet, but it will be grand when version 1.0 hits in 10-50 years.&quot;<p>The fact that they now want to replace LLVM with their own backend makes me think that even 50 years would be optimistic.</div><br/></div></div></div></div></div></div><div id="38246109" class="c"><input type="checkbox" id="c-38246109" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#38248146">prev</a><span>|</span><a href="#38246041">next</a><span>|</span><label class="collapse" for="c-38246109">[-]</label><label class="expand" for="c-38246109">[7 more]</label></div><br/><div class="children"><div class="content">I wonder if one could write a truly statically typed tensor implementation with something like this. Where you can then say Tensor&lt;f64, 16, 16, 2000&gt; but also Tensor&lt;bool, 32&gt; and Tensor&lt;f32, 4, 4&gt; etc. Then some way of specializing for certain sizes to better use SIMD instructions etc. Even if it&#x27;s just via something like `const if` inside of a single method, but with the assurance that the if is applied at compile time and thus e.g. illegal element access in the other branch is ignored etc.</div><br/><div id="38248227" class="c"><input type="checkbox" id="c-38248227" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#38246109">parent</a><span>|</span><a href="#38247592">next</a><span>|</span><label class="collapse" for="c-38248227">[-]</label><label class="expand" for="c-38248227">[1 more]</label></div><br/><div class="children"><div class="content">Since the early 90&#x27;s but in C++ through TMP and class template specializations. If you don&#x27;t have many specializations, and those are sharing most of the code, you can simplify writing this code through if-constexpr since C++17.<p>But soon after you will realize that you need to do some operations with those tensors such as A + B + C. To compute this expression compiler will first need to compute (A + B) sub-expression and store the result into the temporary tensor. Only then it will be able to use this temporary result to compute the final expression by adding the C tensor. When you have a lot of such expressions to compute, and expressions are arbitrarily complex, you will want to avoid inefficiencies caused by creating many temporaries - there&#x27;s an attached cost to them both in memory and in compute. And sometimes you will be able to fuse multiple operations into a single one.<p>This is a problem that can be solved with lazy evaluation and in C++ this can be done in compile-time through expression templates. And this is what basically all linear algebra C++ libraries are famous of doing.</div><br/></div></div><div id="38247592" class="c"><input type="checkbox" id="c-38247592" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#38246109">parent</a><span>|</span><a href="#38248227">prev</a><span>|</span><a href="#38246437">next</a><span>|</span><label class="collapse" for="c-38247592">[-]</label><label class="expand" for="c-38247592">[1 more]</label></div><br/><div class="children"><div class="content">That high-level idea is viable in many languages. I particularly like Zig&#x27;s comptime as a clean way to implement it.<p>You often don&#x27;t want that sort of specialization. Code like deep neural nets is a pain to handle (unless each layer is identical, which is admittedly moderately common) even with variadic generics and especially without, and it&#x27;s hard for the compiler to generate the right specializations for (and the right number of specializations; anecdotally, you can expect enough code bloat that it causes problems).<p>Using branded types you can get a weak form of dependent typing and use that to get features like Tensor&lt;f64, Dim&lt;16&gt;, Dim&lt;MultipleOf&lt;8&gt;&gt;, Dim&lt;SensorChannel&gt;&gt;, where you&#x27;re allowed to pass in concrete numbers, comptime-known constraints on runtime-known values, or even just weak information like that there&#x27;s a particular brand (SensorChannel) on the type which allows you to match fully runtime-known values at compile-time and let the type-checker handle it (think of functions like matmul(Mat(A,B), Mat(B,C)), where the B has to be the same for both, but you very well might want to know it at runtime). It&#x27;s still the library writer&#x27;s job, unfortunately, to use `inline` and other such keywords appropriately to guide the compiler to the right number of specializations, but the API presented to people using that tensor library can be reasonably nice.<p>Incidentally, Zig _also_ makes that second thing (branded types) easy to write. I hacked a demo together [0] if you&#x27;d like to play around with the concept, but a dedicated tensor library should eventually offer something less verbose IMO.<p>If you&#x27;re doing this with ML, my preferred strategy is to go the other way. Only write specializations that are easy for the chip to execute (e.g., appropriately aligned and length-aligned large powers of 2), and build code on top of that. If the computational kernel has to do padding or shifting or other garbage, even at the head&#x2F;tail of a vector, then something in your model is horribly wrong anyway; just make that unrepresentable.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;hmusgrave&#x2F;pdv">https:&#x2F;&#x2F;github.com&#x2F;hmusgrave&#x2F;pdv</a></div><br/></div></div><div id="38246437" class="c"><input type="checkbox" id="c-38246437" checked=""/><div class="controls bullet"><span class="by">cpgxiii</span><span>|</span><a href="#38246109">parent</a><span>|</span><a href="#38247592">prev</a><span>|</span><a href="#38246348">next</a><span>|</span><label class="collapse" for="c-38246437">[-]</label><label class="expand" for="c-38246437">[1 more]</label></div><br/><div class="children"><div class="content">In C++, Eigen comes pretty close to this interface for defining vectors and matrices and mixing size-at-compile-time and dynamically sized quantities. And then, given the size of the vectors&#x2F;matrices being used, dispatching the appropriate SIMD implementation.</div><br/></div></div><div id="38246348" class="c"><input type="checkbox" id="c-38246348" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38246109">parent</a><span>|</span><a href="#38246437">prev</a><span>|</span><a href="#38246136">next</a><span>|</span><label class="collapse" for="c-38246348">[-]</label><label class="expand" for="c-38246348">[1 more]</label></div><br/><div class="children"><div class="content">From the perpsective pure type checking, Python&#x2F;Numpy is heading in this direction: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0646&#x2F;#motivation" rel="nofollow noreferrer">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0646&#x2F;#motivation</a>.<p>However what you <i>can&#x27;t</i> do without dependent types (as far as I know) is infer or verify statically that the transpose of a Tensor&lt;f64,20,10&gt; is a Tensor&lt;f64,10,20&gt;.</div><br/></div></div><div id="38246136" class="c"><input type="checkbox" id="c-38246136" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38246109">parent</a><span>|</span><a href="#38246348">prev</a><span>|</span><a href="#38247062">next</a><span>|</span><label class="collapse" for="c-38246136">[-]</label><label class="expand" for="c-38246136">[1 more]</label></div><br/><div class="children"><div class="content">Why not something like Tensor&lt;element_type, index_type&gt; where index_type can then be your 16 x 16 x 2000 or 32 or 4 x 4 etc?</div><br/></div></div><div id="38247062" class="c"><input type="checkbox" id="c-38247062" checked=""/><div class="controls bullet"><span class="by">rdedev</span><span>|</span><a href="#38246109">parent</a><span>|</span><a href="#38246136">prev</a><span>|</span><a href="#38246041">next</a><span>|</span><label class="collapse" for="c-38247062">[-]</label><label class="expand" for="c-38247062">[1 more]</label></div><br/><div class="children"><div class="content">I know about dfdx in rust that has type checked tensors for rank and shape. Don&#x27;t know if it ticks all your boxes</div><br/></div></div></div></div><div id="38246041" class="c"><input type="checkbox" id="c-38246041" checked=""/><div class="controls bullet"><span class="by">BobbyJo</span><span>|</span><a href="#38246109">prev</a><span>|</span><label class="collapse" for="c-38246041">[-]</label><label class="expand" for="c-38246041">[13 more]</label></div><br/><div class="children"><div class="content">I cant think of a single real use case for variadic generics.<p>When you&#x27;re talking about functions operating on mixed, variable length, types, what meaningful logic can you actually apply, that doesn&#x27;t fall into requiring the types to implement an interface anyway?<p>When you&#x27;re talking about struct&#x2F;classes&#x2F;etc, what do you need over and above defining a class&#x2F;record&#x2F;dataclass? It would seem to me, you&#x27;re just skipping the part where you give your tuple a name, but is that even a good idea to do?<p>To be clear, I did not find the examples in the post convincing, as they represent mostly wrappers&#x2F;adapters for implementing or consuming arbitrary types, but there are no examples for how that might <i>actually</i> be useful downstream.</div><br/><div id="38246137" class="c"><input type="checkbox" id="c-38246137" checked=""/><div class="controls bullet"><span class="by">oddlama</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246363">next</a><span>|</span><label class="collapse" for="c-38246137">[-]</label><label class="expand" for="c-38246137">[1 more]</label></div><br/><div class="children"><div class="content">I can think of plenty real world usecases. Take for example a network interface that can send or receive predefined packet structs.<p>Imagine each packet requires a size header. When you want to send multiple packets at once, you now want to optimize that and only write a single initial header to the interface, preceding the data.<p>With variadic generics, you can enable a syntax like `interface.write_packets(packet1, packet2, packet3, &#x2F;* ... *&#x2F;);` which writes the packets in the desired optimized way. It can internally construct a serializable data tuple from the variadic generics and add the correct header only to the beginning.<p>Without variadic generics a similar syntax is only possible with macros, which means that it cannot be implemented as a reusable trait.<p>&gt; It would seem to me, you&#x27;re just skipping the part where you give your tuple a name, but is that even a good idea to do?<p>Sometimes you explicitly don&#x27;t want to require naming the tuple for flexibility, like in the example above.</div><br/></div></div><div id="38246363" class="c"><input type="checkbox" id="c-38246363" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246137">prev</a><span>|</span><a href="#38246254">next</a><span>|</span><label class="collapse" for="c-38246363">[-]</label><label class="expand" for="c-38246363">[2 more]</label></div><br/><div class="children"><div class="content">I think the utility is strongly dependent on the kind of code you write and the sophistication of the metaprogramming your code will benefit from. Many C++ programmers made similar comments when it was introduced with C++11 and a few still maintain it has no real use case. However, for C++ library writers it was a game changer. In practice, they replace a lot of use cases for code generators. It took me a while to get into variadic generics, but now that I understand them I would feel crippled using a language without them.<p>A lot of the value <i>is</i> to derive complex structs programmatically that may never be realized concretely but feed other metaprogramming algorithms that slice and dice them and make decisions based on the properties of the individual types. You don’t want to name them because (1) there may be hundreds from an unbounded set and (2) your may never need to reference them directly, so it saves a mountain of code and eliminates a massive amount of edge cases. At their best, you can use them to express insanely complex things with surprisingly little code.<p>It is not the kind of feature you use profligately in a code base. But when you need them, you <i>really</i> need them. Most of what they can express in ordinary code would otherwise require complex code generators, compiler magic, or outrageous amounts of boilerplate.</div><br/><div id="38246558" class="c"><input type="checkbox" id="c-38246558" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#38246041">root</a><span>|</span><a href="#38246363">parent</a><span>|</span><a href="#38246254">next</a><span>|</span><label class="collapse" for="c-38246558">[-]</label><label class="expand" for="c-38246558">[1 more]</label></div><br/><div class="children"><div class="content">I used variadic templates to implement, drumroll please, a variant library that wasn’t as awful as what came before.<p>Rust has enums, which are so much better it isn’t even funny.</div><br/></div></div></div></div><div id="38246254" class="c"><input type="checkbox" id="c-38246254" checked=""/><div class="controls bullet"><span class="by">norir</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246363">prev</a><span>|</span><a href="#38246410">next</a><span>|</span><label class="collapse" for="c-38246254">[-]</label><label class="expand" for="c-38246254">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I cant think of a single real use case for variadic generics.<p>Even if you could think of one, I personally think the rust community does a poor job of weighing the tradeoff between supporting a niche feature and adding complexity to the language. Rust is already so huge that all but the most dedicated have little hope of understanding even half of the language features. I&#x27;m not sure I understand the incentive structure that makes it this way, but it is hard for me to see how rust avoids becoming the next c++ unless they learn how to say no. Honestly I believe it&#x27;s already too late and that rust&#x27;s best ideas will be adopted by a smaller language with better ergonomics, compiler performance and learnability that will eat its lunch.</div><br/><div id="38246499" class="c"><input type="checkbox" id="c-38246499" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38246041">root</a><span>|</span><a href="#38246254">parent</a><span>|</span><a href="#38246410">next</a><span>|</span><label class="collapse" for="c-38246499">[-]</label><label class="expand" for="c-38246499">[3 more]</label></div><br/><div class="children"><div class="content">The status quo is that people who would like to use variadics but can&#x27;t, instead settle for complicated ad-hoc macros. Those are far worse for &quot;ergonomics, compiler performance and learnability.&quot;</div><br/><div id="38246845" class="c"><input type="checkbox" id="c-38246845" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#38246041">root</a><span>|</span><a href="#38246499">parent</a><span>|</span><a href="#38246410">next</a><span>|</span><label class="collapse" for="c-38246845">[-]</label><label class="expand" for="c-38246845">[2 more]</label></div><br/><div class="children"><div class="content">Instead of extending the language with ever more niche features, they could pull a Zig and make macros not suck.</div><br/><div id="38247815" class="c"><input type="checkbox" id="c-38247815" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#38246041">root</a><span>|</span><a href="#38246845">parent</a><span>|</span><a href="#38246410">next</a><span>|</span><label class="collapse" for="c-38247815">[-]</label><label class="expand" for="c-38247815">[1 more]</label></div><br/><div class="children"><div class="content">Zig&#x27;s `comptime` is not a silver bullet though:<p>- it is duck typed, which to be fair macros are also, but variadic generics would be type checked at the definition;<p>- it interacts badly with traits, that is if you allow both querying for implemented traits and creating new trait `impl`s then this can create cycles in the execution of comptime blocks, meaning the compiler needs to compute a fixpoint or arbitrarily give an error.</div><br/></div></div></div></div></div></div></div></div><div id="38246410" class="c"><input type="checkbox" id="c-38246410" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246254">prev</a><span>|</span><a href="#38247744">next</a><span>|</span><label class="collapse" for="c-38246410">[-]</label><label class="expand" for="c-38246410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When you&#x27;re talking about functions operating on mixed, variable length, types, what meaningful logic can you actually apply, that doesn&#x27;t fall into requiring the types to implement an interface anyway?<p>Anything higher-order. At the most basic level you want to be able to take a bundle of values and a bundle of functions and apply the functions to the values, or take a bundle of functions and another bundle of functions and make a bundle of composed functions. You will probably complain that these examples are trivial, but if we don&#x27;t have the syntax or vocabulary to handle the trivial cases then how can we even start to think about the more complex cases?<p>&gt; When you&#x27;re talking about struct&#x2F;classes&#x2F;etc, what do you need over and above defining a class&#x2F;record&#x2F;dataclass? It would seem to me, you&#x27;re just skipping the part where you give your tuple a name, but is that even a good idea to do?<p>It is, if only because you want to be able to transform existing records generically rather than having to concretely write out every specialised possible version of your record. For example, think of writing a generic &quot;patch&quot; method for use in the &quot;update&quot;  route of a CRUD webservice - something that lets you call it with an existing record (e.g. a user) and some representation of a few deeply nested fields of that record (e.g. the postal code that&#x27;s on that user&#x27;s address) and get an updated version of the record, without having to write out the type for that &quot;patch&quot; input longhand. This is a basic, trivial thing that people do in TypeScript every day, but you still can&#x27;t even write a type for it in Rust, yet alone implement it.</div><br/></div></div><div id="38247744" class="c"><input type="checkbox" id="c-38247744" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246410">prev</a><span>|</span><a href="#38246176">next</a><span>|</span><label class="collapse" for="c-38247744">[-]</label><label class="expand" for="c-38247744">[1 more]</label></div><br/><div class="children"><div class="content">For a quick example, Bevy needs to implement some trait for functions with a variable number of inputs. However it doesn&#x27;t stop there, it also needs to store some state for each input, in other words it need to map that `fn(...T)` into a `(...State&lt;T&gt;)`. How do you model this with generics? When I tried to think about this every way I found to express this didn&#x27;t allow the consumer code to call any methods on those `State`s, essentially making this useless.</div><br/></div></div><div id="38246176" class="c"><input type="checkbox" id="c-38246176" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38247744">prev</a><span>|</span><a href="#38246449">next</a><span>|</span><label class="collapse" for="c-38246176">[-]</label><label class="expand" for="c-38246176">[1 more]</label></div><br/><div class="children"><div class="content">!!!<p>Consider having multiple (heterogenous) Promises and wanting to wait for all to complete, and return the results.</div><br/></div></div><div id="38246449" class="c"><input type="checkbox" id="c-38246449" checked=""/><div class="controls bullet"><span class="by">Georgelemental</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246176">prev</a><span>|</span><a href="#38246765">next</a><span>|</span><label class="collapse" for="c-38246449">[-]</label><label class="expand" for="c-38246449">[1 more]</label></div><br/><div class="children"><div class="content">From the post:<p>&gt; I think variadics aren’t necessarily useful for application developers, or people working on libraries with mostly concrete types (eg web libraries). But for people working on libraries with lots of type manipulation, variadic generics have obvious benefits. They let you go from manipulating types to collections of types.<p>One example is in SQL libraries. If you have a trait `DatabaseColumnStorable` for types you can store in a database column (integers, strings, etc), then with variadics you could have a `struct DatabaseRow&lt;...Columns: DatabaseColumnStorable&gt;(...Columns)` to represent rows of a database table in a type-safe manner.</div><br/></div></div><div id="38246765" class="c"><input type="checkbox" id="c-38246765" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#38246041">parent</a><span>|</span><a href="#38246449">prev</a><span>|</span><label class="collapse" for="c-38246765">[-]</label><label class="expand" for="c-38246765">[1 more]</label></div><br/><div class="children"><div class="content">Any time you see traits going<p><pre><code>   impl Trait for (T1)
   impl Trait for (T1, T2)
   impl Trait for (T1, T2, T3)
   ... 
</code></pre>
And bunch of macro invocations in the body on (T1), (T1, T2), etc.<p>Someone, somewhere cursed there weren&#x27;t variadics there.</div><br/></div></div></div></div></div></div></div></div></div></body></html>