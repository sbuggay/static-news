<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1684746064258" as="style"/><link rel="stylesheet" href="styles.css?v=1684746064258"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/stepchowfun/typical">Typical: Data interchange with algebraic data types</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>g0xA52A2A</span> | <span>40 comments</span></div><br/><div><div id="36026030" class="c"><input type="checkbox" id="c-36026030" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36024243">next</a><span>|</span><label class="collapse" for="c-36026030">[-]</label><label class="expand" for="c-36026030">[18 more]</label></div><br/><div class="children"><div class="content">Typical creator here. I&#x27;m pleasantly surprised to find this on HN today! Happy to answer any questions about it.</div><br/><div id="36028440" class="c"><input type="checkbox" id="c-36028440" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#36026030">parent</a><span>|</span><a href="#36026431">next</a><span>|</span><label class="collapse" for="c-36028440">[-]</label><label class="expand" for="c-36028440">[2 more]</label></div><br/><div class="children"><div class="content">It seems like the safety rules are buggy because some assumptions are missing?<p>The safety rules say that adding an asymmetric field is safe, and converting asymmetric to required is safe. If you do both steps, then this implies that adding a required field is safe. But it’s not. As you say, it’s not transitive.<p>But lack of transitivity also means that a pull request that converts a field from asymmetric to required is <i>not</i> safe, in general. You need to know the history of that field. If you know that the field has always been asymmetric (unlikely) or all the older binaries are gone, then it’s safe. A reviewer can’t determine this by reading a pull request alone.<p>Maybe waiting until old binaries are gone is what you mean by “a single change” but it seems like that should be made explicit?</div><br/><div id="36028520" class="c"><input type="checkbox" id="c-36028520" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36028440">parent</a><span>|</span><a href="#36026431">next</a><span>|</span><label class="collapse" for="c-36028520">[-]</label><label class="expand" for="c-36028520">[1 more]</label></div><br/><div class="children"><div class="content">No IDL that supports required fields can offer the transitivity property you&#x27;re referring to.<p>Typical has no notion of commits or pull requests in your codebase. The only meaningful notion of a &quot;change&quot; from Typical&#x27;s perspective is a deployment which updates the live version of the code.<p>When promoting an asymmetric field to required (for example), you need to be sure the asymmetric field has been rolled out first. If you were using any other IDL framework (like Protocol Buffers) and you wanted to promote an optional field to required, you&#x27;d be faced with the same situation: you first need to make sure that the code running in production is always setting that field before you do the promotion. Typical just helps more than other IDL frameworks by making it a compile-time guarantee in the meantime. The fact that other frameworks offer no help with this has led many organizations to ban required fields entirely, which only kicks the can down the road.<p>We should be more careful about how we use the overloaded word &quot;change&quot;, so I&#x27;m grateful you pointed this out. Another comment also helped me realize how confusing the word &quot;update&quot; can be.</div><br/></div></div></div></div><div id="36026431" class="c"><input type="checkbox" id="c-36026431" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#36026030">parent</a><span>|</span><a href="#36028440">prev</a><span>|</span><a href="#36028156">next</a><span>|</span><label class="collapse" for="c-36026431">[-]</label><label class="expand" for="c-36026431">[4 more]</label></div><br/><div class="children"><div class="content">I was wondering if you&#x27;ve considered having an alternative, human readable encoding (either your own syntax or a JSON-based schema)?<p>I find it quite useful to be able to inspect data by eye and even hand-editing payloads occassionally, and having a standard syntax for doing so would be nice.<p>(More generally, it&#x27;s a shame JSON doesn&#x27;t support sum types &quot;natively&quot; and I think a human readable format with Typical&#x27;s data model would be really cool).</div><br/><div id="36027891" class="c"><input type="checkbox" id="c-36027891" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36026431">parent</a><span>|</span><a href="#36026559">next</a><span>|</span><label class="collapse" for="c-36027891">[-]</label><label class="expand" for="c-36027891">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s a shame JSON doesn&#x27;t support sum types &quot;natively&quot;<p>You can describe it using JSON Schema though[1], using &quot;oneOf&quot; and &quot;const&quot;. Though I prefer the more explicit way of using &quot;oneOf&quot; combined with &quot;required&quot; to select one of a number of keys[2].<p>[1]: <a href="https:&#x2F;&#x2F;www.jsonschemavalidator.net&#x2F;s&#x2F;6SCuYNBe" rel="nofollow">https:&#x2F;&#x2F;www.jsonschemavalidator.net&#x2F;s&#x2F;6SCuYNBe</a><p>[2]: <a href="https:&#x2F;&#x2F;www.jsonschemavalidator.net&#x2F;s&#x2F;tNnQmsTd" rel="nofollow">https:&#x2F;&#x2F;www.jsonschemavalidator.net&#x2F;s&#x2F;tNnQmsTd</a></div><br/></div></div><div id="36026559" class="c"><input type="checkbox" id="c-36026559" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36026431">parent</a><span>|</span><a href="#36027891">prev</a><span>|</span><a href="#36028156">next</a><span>|</span><label class="collapse" for="c-36026559">[-]</label><label class="expand" for="c-36026559">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good question! The binary format is completely inscrutable to human eyes and is not designed for manual inspection&#x2F;editing. However:<p>1) For Rust, the generated types implement the `Debug` trait, so they can be printed in a textual format that Rust programmers are accustomed to reading.<p>2) For JavaScript&#x2F;TypeScript, deserialized messages are simple passive data objects that can be logged or inspected in the developer console.<p>So it&#x27;s easy to log&#x2F;inspect deserialized messages in a human-readable format, but there&#x27;s currently no way to read&#x2F;edit encoded messages directly. In the future, we may add an option to encode messages as JSON which would match the representation currently used for decoded messages in JavaScript&#x2F;TypeScript, with sums being encoded as tagged unions.</div><br/><div id="36027183" class="c"><input type="checkbox" id="c-36027183" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36026559">parent</a><span>|</span><a href="#36028156">next</a><span>|</span><label class="collapse" for="c-36027183">[-]</label><label class="expand" for="c-36027183">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. That&#x27;s a good answer.</div><br/></div></div></div></div></div></div><div id="36028156" class="c"><input type="checkbox" id="c-36028156" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#36026030">parent</a><span>|</span><a href="#36026431">prev</a><span>|</span><a href="#36027814">next</a><span>|</span><label class="collapse" for="c-36028156">[-]</label><label class="expand" for="c-36028156">[4 more]</label></div><br/><div class="children"><div class="content">From the description:<p><i>Thus, asymmetric fields in choices behave like optional fields for writers and like required fields for readers—the opposite of their behavior in structs.</i><p>So if you have a schema change which adds an asymmetric field to both a struct and a choice, it seems both writers and readers needs to be updated in order to successfully transmit to each other?<p>Or am I missing something fundamental?</div><br/><div id="36028298" class="c"><input type="checkbox" id="c-36028298" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36028156">parent</a><span>|</span><a href="#36027814">next</a><span>|</span><label class="collapse" for="c-36028298">[-]</label><label class="expand" for="c-36028298">[3 more]</label></div><br/><div class="children"><div class="content">If you add an asymmetric field to a struct, writers need to be updated to set the field <i>for the code to compile</i>.<p>If you also add an asymmetric field to a choice, readers need to be updated to be able to handle the new case <i>for the code to compile</i>.<p>You can do both in the same change. The new code can be deployed to the writers and readers in any order. Messages generated from the old code can be read by the new code and vice versa, so it&#x27;s fine for both versions of the code to coexist during the rollout.<p>After that first change is rolled out, you can promote the new fields to required. This change can also be deployed to writers and readers in any order. Since writers are already setting the new field in the struct, it&#x27;s fine for readers to start relying on it. And since readers can already handle the new case in the choice, it&#x27;s fine for writers to start using it.</div><br/><div id="36028448" class="c"><input type="checkbox" id="c-36028448" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36028298">parent</a><span>|</span><a href="#36027814">next</a><span>|</span><label class="collapse" for="c-36028448">[-]</label><label class="expand" for="c-36028448">[2 more]</label></div><br/><div class="children"><div class="content">Ah, I was thinking in terms of the actual messages, not compilation. So it should read &quot;Fields are required <i>for compilation</i> by default&quot;?<p>This leads me to versioning. Imagine you have some old code which won&#x27;t be upgraded, say an embedded system. Either you don&#x27;t promote to &quot;required&quot;, or you do versioning.<p>Given the lack of any mention of versioning, I take it that&#x27;s to be deal with externally? Ie as a separate schema, and detected before handing the rest of the data to the generated code?<p>edit: Really cool project btw!</div><br/><div id="36028714" class="c"><input type="checkbox" id="c-36028714" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36028448">parent</a><span>|</span><a href="#36027814">next</a><span>|</span><label class="collapse" for="c-36028714">[-]</label><label class="expand" for="c-36028714">[1 more]</label></div><br/><div class="children"><div class="content">If I understand you correctly, I believe your understanding is correct.</div><br/></div></div></div></div></div></div></div></div><div id="36027814" class="c"><input type="checkbox" id="c-36027814" checked=""/><div class="controls bullet"><span class="by">texuf</span><span>|</span><a href="#36026030">parent</a><span>|</span><a href="#36028156">prev</a><span>|</span><a href="#36027471">next</a><span>|</span><label class="collapse" for="c-36027814">[-]</label><label class="expand" for="c-36027814">[2 more]</label></div><br/><div class="children"><div class="content">Do you think you could ever generate types for go? The protobuf implementation of oneof in go is pretty rough to look at, and not fun to type over and over.</div><br/><div id="36027908" class="c"><input type="checkbox" id="c-36027908" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36027814">parent</a><span>|</span><a href="#36027471">next</a><span>|</span><label class="collapse" for="c-36027908">[-]</label><label class="expand" for="c-36027908">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love for Typical to support Go! We&#x27;d need someone with enough time to implement it.<p>If anyone is interested in contributing any code generators, you can start by copying the Rust or TypeScript generator and modifying it appropriately. See the contributing guide here: <a href="https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical&#x2F;blob&#x2F;main&#x2F;CONTRIBUTING.md">https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical&#x2F;blob&#x2F;main&#x2F;CONTRIBUTIN...</a></div><br/></div></div></div></div><div id="36027471" class="c"><input type="checkbox" id="c-36027471" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#36026030">parent</a><span>|</span><a href="#36027814">prev</a><span>|</span><a href="#36024243">next</a><span>|</span><label class="collapse" for="c-36027471">[-]</label><label class="expand" for="c-36027471">[5 more]</label></div><br/><div class="children"><div class="content">Really cool! Does it work in browser if I want to compile .t spec using JS&#x2F;TS?</div><br/><div id="36027676" class="c"><input type="checkbox" id="c-36027676" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36027471">parent</a><span>|</span><a href="#36024243">next</a><span>|</span><label class="collapse" for="c-36027676">[-]</label><label class="expand" for="c-36027676">[4 more]</label></div><br/><div class="children"><div class="content">Yes! We have comprehensive integration tests that run in the browser to ensure the generated code only uses browser-compatible APIs. Also, the generated code never uses reflection or dynamic code evaluation, so it works in Content Security Policy-restricted environments.<p>See this section of the README for more info: <a href="https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical#javascript-and-typescript">https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical#javascript-and-typesc...</a></div><br/><div id="36027821" class="c"><input type="checkbox" id="c-36027821" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36027676">parent</a><span>|</span><a href="#36024243">next</a><span>|</span><label class="collapse" for="c-36027821">[-]</label><label class="expand" for="c-36027821">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nice that generated code works in browser but I was curious whether it&#x27;s possible to actually generate code from .t syntax all in browser.<p>By the looks of it typical is only a CLI tool, so I guess not for now. Maybe unless it is ported to WASM...</div><br/><div id="36027940" class="c"><input type="checkbox" id="c-36027940" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36027821">parent</a><span>|</span><a href="#36024243">next</a><span>|</span><label class="collapse" for="c-36027940">[-]</label><label class="expand" for="c-36027940">[2 more]</label></div><br/><div class="children"><div class="content">A wasm port doesn&#x27;t seem too farfetched. What&#x27;s the use case for running the code generator in the browser?</div><br/><div id="36028200" class="c"><input type="checkbox" id="c-36028200" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#36026030">root</a><span>|</span><a href="#36027940">parent</a><span>|</span><a href="#36024243">next</a><span>|</span><label class="collapse" for="c-36028200">[-]</label><label class="expand" for="c-36028200">[1 more]</label></div><br/><div class="children"><div class="content">Something that could involve giving the end user some control over schema...</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36024243" class="c"><input type="checkbox" id="c-36024243" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#36026030">prev</a><span>|</span><a href="#36028436">next</a><span>|</span><label class="collapse" for="c-36024243">[-]</label><label class="expand" for="c-36024243">[3 more]</label></div><br/><div class="children"><div class="content">This seems like the thing I wish protocol buffers were, but learning from them and removing the warts. Very promising.<p>Also, implementing in rust and typescript as the first languages was a smart choice</div><br/><div id="36027631" class="c"><input type="checkbox" id="c-36027631" checked=""/><div class="controls bullet"><span class="by">anitil</span><span>|</span><a href="#36024243">parent</a><span>|</span><a href="#36024301">next</a><span>|</span><label class="collapse" for="c-36027631">[-]</label><label class="expand" for="c-36027631">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know a lot about protocol buffers. What are the warts? I think they don&#x27;t have a canonical format, is that one of them?</div><br/></div></div><div id="36024301" class="c"><input type="checkbox" id="c-36024301" checked=""/><div class="controls bullet"><span class="by">revskill</span><span>|</span><a href="#36024243">parent</a><span>|</span><a href="#36027631">prev</a><span>|</span><a href="#36028436">next</a><span>|</span><label class="collapse" for="c-36024301">[-]</label><label class="expand" for="c-36024301">[1 more]</label></div><br/><div class="children"><div class="content">Protocol buffer lacks of good documentation for beginners which fits in a README.md. It&#x27;s not a community project i guess.<p>Basically enterprisey toolings bored me to death.<p>Nowadays i trust toolings whose documentation could fit in a README file. It means it&#x27;s concise, simplicity.</div><br/></div></div></div></div><div id="36028436" class="c"><input type="checkbox" id="c-36028436" checked=""/><div class="controls bullet"><span class="by">padator</span><span>|</span><a href="#36024243">prev</a><span>|</span><a href="#36025513">next</a><span>|</span><label class="collapse" for="c-36028436">[-]</label><label class="expand" for="c-36028436">[2 more]</label></div><br/><div class="children"><div class="content">What is the difference with ATD: <a href="https:&#x2F;&#x2F;atd.readthedocs.io&#x2F;en&#x2F;latest&#x2F;atd-project.html" rel="nofollow">https:&#x2F;&#x2F;atd.readthedocs.io&#x2F;en&#x2F;latest&#x2F;atd-project.html</a> which also was designed with algebraic data types in mind?</div><br/><div id="36028784" class="c"><input type="checkbox" id="c-36028784" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36028436">parent</a><span>|</span><a href="#36025513">next</a><span>|</span><label class="collapse" for="c-36028784">[-]</label><label class="expand" for="c-36028784">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak with authority about ATD, but the following might be helpful:<p>Aside from algebraic data types, the big selling point of Typical is asymmetric fields. That&#x27;s the crucial feature that distinguishes Typical from every other framework. Without asymmetric fields, there is no safe way to introduce or retire required fields. People using other frameworks fear required fields (rightly so), whereas Typical gives you the tools to embrace them.</div><br/></div></div></div></div><div id="36025513" class="c"><input type="checkbox" id="c-36025513" checked=""/><div class="controls bullet"><span class="by">parhamn</span><span>|</span><a href="#36028436">prev</a><span>|</span><a href="#36026869">next</a><span>|</span><label class="collapse" for="c-36025513">[-]</label><label class="expand" for="c-36025513">[3 more]</label></div><br/><div class="children"><div class="content">Curious how this will look when they get to implementations with less expressive type systems. Typescript &amp; Rust are particularly good. Making a usable library for this in golang won&#x27;t be easy.<p>And now that I think about it, Protobuf&#x2F;Thrift&#x2F;etc type tools are heavily constrained by finding lowest-common-demoninator of language features to allow for cross serialization. Maybe in the next generation of these tools, languages like golang don&#x27;t get a seat at the table for the sake of progress -- I could be fine with it.</div><br/><div id="36028275" class="c"><input type="checkbox" id="c-36028275" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#36025513">parent</a><span>|</span><a href="#36026128">next</a><span>|</span><label class="collapse" for="c-36028275">[-]</label><label class="expand" for="c-36028275">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d imagine that most people voluntarily using go or similar languages wouldn&#x27;t be too bothered by just having all the checks occur at runtime in the generated code, rather than encoding them in the type system.<p>Sum types are still awkward, but most languages can at least approximate them, minus some compile-time checks.</div><br/></div></div><div id="36026128" class="c"><input type="checkbox" id="c-36026128" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36025513">parent</a><span>|</span><a href="#36028275">prev</a><span>|</span><a href="#36026869">next</a><span>|</span><label class="collapse" for="c-36026128">[-]</label><label class="expand" for="c-36026128">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re exactly right about other frameworks appealing to the lowest common denominator, whereas Typical isn&#x27;t willing to make such compromises.<p>Languages without proper sum types are at a disadvantage here, but it&#x27;s possible to encode sum types with exhaustive pattern matching in such languages using the visitor pattern. That approach requires some ergonomic sacrifices (e.g., having to use a reified eliminator rather than the built-in `switch` statement), and people using those languages may prefer convenience over strong guarantees. It&#x27;s an unfortunate impedance mismatch.</div><br/></div></div></div></div><div id="36026869" class="c"><input type="checkbox" id="c-36026869" checked=""/><div class="controls bullet"><span class="by">spenczar5</span><span>|</span><a href="#36025513">prev</a><span>|</span><a href="#36026099">next</a><span>|</span><label class="collapse" for="c-36026869">[-]</label><label class="expand" for="c-36026869">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Typical offers a new solution (&quot;asymmetric&quot; fields) to the classic problem of how to safely add or remove fields in record types without breaking compatibility. The concept of asymmetric fields also solves the dual problem of how to preserve compatibility when adding or removing cases in sum types.<p>This is indeed an elegant solution, although I am not so sure about its novelty. It seems very similar to how Avro achieves forward and backward compatibility. I wonder how the two strategies differ?</div><br/><div id="36027634" class="c"><input type="checkbox" id="c-36027634" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026869">parent</a><span>|</span><a href="#36026099">next</a><span>|</span><label class="collapse" for="c-36027634">[-]</label><label class="expand" for="c-36027634">[1 more]</label></div><br/><div class="children"><div class="content">Avro has no equivalent of Typical&#x27;s asymmetric fields. In Avro:<p>1. Record types can have optional (but not asymmetric) fields, just like in most IDLs. Avro implements this by taking the union of the field type with a special `null` type, but in practice it&#x27;s equivalent to having optional fields.<p>2. Avro doesn&#x27;t support proper sum types, but it has two approximations of them: unions (but not <i>tagged</i> unions) and enums. Unions have no support for adding&#x2F;removing new cases safely. Enums can have a default value that is used if the case is not recognized.<p>From the &quot;Typical perspective&quot;, both of these are problematic:<p>1. If you are trying to introduce a required field in Avro, you first introduce it as optional, and then at some point in the future when you have manually confirmed that the field is always being set by every writer, you can promote the field to required. Typical&#x27;s asymmetric fields offload the burden of having to do that manual confirmation onto the type checker.<p>2. For unions, Avro offers no equivalent of optional or asymmetric cases. If you add a new case, you better not use it until all readers can handle it, and the type checker won&#x27;t enforce that. For enums, the solution of having default values is unsatisfactory, because not every type has a suitable default. In practice, this usually means adding a catch-all default that is only used to signal an unrecognized input, but then what is a reader supposed to do with that? With Typical, if a writer introduces a new optional or asymmetric case, it must then provide an appropriate fallback to use when the new case isn&#x27;t recognized by readers. For example, if a new specific type of error is introduced (e.g., with a stack trace), the fallback might be a more general type of error (e.g., with only an error message) that readers already know how to handle. If the new case is asymmetric, then you know readers can handle it, so once its rolled out you know it&#x27;s safe to subsequently promote the case to required (so that writers no longer need to provide a fallback).<p>Here I&#x27;ve only discussed the challenges with adding new required fields&#x2F;cases, but you run into similar trouble when removing them. This section of the README discusses all the pitfalls: <a href="https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical#required-optional-and-asymmetric-fields">https:&#x2F;&#x2F;github.com&#x2F;stepchowfun&#x2F;typical#required-optional-and...</a></div><br/></div></div></div></div><div id="36026099" class="c"><input type="checkbox" id="c-36026099" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#36026869">prev</a><span>|</span><a href="#36024955">next</a><span>|</span><label class="collapse" for="c-36026099">[-]</label><label class="expand" for="c-36026099">[2 more]</label></div><br/><div class="children"><div class="content">It seems that there are two approaches to schema encoding:<p>* Writing OpenAPI&#x2F;Avro and then generating deserializing&#x2F;serializing from that (like e.g. 
 Avro[0] or Tie[1] or Typical)<p>* Writing the schema using an in-language DSL (e.g. Autodocodec[2])<p>If I have a single language codebase, why should I prefer the first approach? You can always make your in-language DSL serialize out to a dedicated language at a later point.<p>Typical isn&#x27;t focused on JSON, so it doesn&#x27;t seem like it is optimized for web. Not doing web makes it more likely that you don&#x27;t need multiple language support.<p>You can limit the metaprogramming also: You don&#x27;t strictly need GHC.Generics for the in-language DSL. But if you&#x27;re generating code, it&#x27;s always going to be opaque and hard to debug.<p>If you keep the DSL in-language, you don&#x27;t need to generate stubs since you can use the languages own type system to enforce the mapping to the native records[2].<p>I have heard the argument that everything should be &#x27;documentation first&#x27;, which was given as an argument for using Tie. But I don&#x27;t see why an in-language DSL can&#x27;t provide enough detail. There is so much manually written OpenAPI out there, any of these approaches is vastly better than that.<p>I have been reading Designing Data Intensive Applications by Martin Kleppmann but it doesn&#x27;t cover this trade-off. Which makes sense, since it isn&#x27;t really a book on programming using DSLs.<p>[0]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;avro#generating-code-from-avro-schema" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;avro#generating-code-fro...</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;scarf-sh&#x2F;tie">https:&#x2F;&#x2F;github.com&#x2F;scarf-sh&#x2F;tie</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;NorfairKing&#x2F;autodocodec#fully-featured-example">https:&#x2F;&#x2F;github.com&#x2F;NorfairKing&#x2F;autodocodec#fully-featured-ex...</a></div><br/><div id="36026271" class="c"><input type="checkbox" id="c-36026271" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36026099">parent</a><span>|</span><a href="#36024955">next</a><span>|</span><label class="collapse" for="c-36026271">[-]</label><label class="expand" for="c-36026271">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If I have a single language codebase, why should I prefer the first approach?<p>Probably the most compelling reason is that a single language codebase might not be a single language codebase forever. But, as you suggested, the switch to a language-agnostic framework can be deferred until it becomes necessary.<p>However, there&#x27;s a reason to use Typical specifically: asymmetric fields. This feature allows you to change your schema over time without breaking compatibility and without sacrificing type safety.<p>If you ever expect to have newer versions of the codebase reading messages that were generated by older versions of the codebase (or vice versa), this is a concern that will need to be addressed. This can happen when you have a system that isn&#x27;t deployed atomically (e.g., microservices, web&#x2F;mobile applications, etc.) or when you have persisted messages that can outlive a single version of the codebase (e.g., files or database records).<p>An embedded DSL could in principle provide asymmetric fields, but I&#x27;m not aware of any that do.<p>&gt; Typical isn&#x27;t focused on JSON, so it doesn&#x27;t seem like it is optimized for web.<p>It just makes different trade-offs than most web-based systems, but that doesn&#x27;t make it unsuitable for web use. We have comprehensive integration tests that run in the browser. Deserialized messages are simple passive data objects [1] that can be logged or inspected in the developer console.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Passive_data_structure" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Passive_data_structure</a></div><br/></div></div></div></div><div id="36024955" class="c"><input type="checkbox" id="c-36024955" checked=""/><div class="controls bullet"><span class="by">tiziano88</span><span>|</span><a href="#36026099">prev</a><span>|</span><a href="#36025298">next</a><span>|</span><label class="collapse" for="c-36024955">[-]</label><label class="expand" for="c-36024955">[1 more]</label></div><br/><div class="children"><div class="content">Brilliant, I have been thinking of doing exactly this for a while now, glad I waited for someone else to do it in a better way :)</div><br/></div></div><div id="36025298" class="c"><input type="checkbox" id="c-36025298" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#36024955">prev</a><span>|</span><a href="#36026246">next</a><span>|</span><label class="collapse" for="c-36025298">[-]</label><label class="expand" for="c-36025298">[1 more]</label></div><br/><div class="children"><div class="content">Asymmetric fields is a really clever idea.</div><br/></div></div><div id="36026246" class="c"><input type="checkbox" id="c-36026246" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#36025298">prev</a><span>|</span><a href="#36025379">next</a><span>|</span><label class="collapse" for="c-36026246">[-]</label><label class="expand" for="c-36026246">[1 more]</label></div><br/><div class="children"><div class="content">Nice that algebraic types are getting more love. Would be nice if these could be imported into existing systems, like Cap &#x27;n Proto.</div><br/></div></div><div id="36025379" class="c"><input type="checkbox" id="c-36025379" checked=""/><div class="controls bullet"><span class="by">pickledish</span><span>|</span><a href="#36026246">prev</a><span>|</span><a href="#36024489">next</a><span>|</span><label class="collapse" for="c-36025379">[-]</label><label class="expand" for="c-36025379">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Note: An optional field in a choice isn&#x27;t simply a field with an option type&#x2F;nullable type. The word &quot;optional&quot; here means that readers can ignore it and use a fallback instead, not that its payload might be missing<p>Hmm, this is new to me -- is this a Typical concept, or something more general around protobuf-enums that I just haven&#x27;t run into before?<p>(oh, and besides my question, strong agreement with everyone else here, cool lib and great documentation!)</div><br/><div id="36026025" class="c"><input type="checkbox" id="c-36026025" checked=""/><div class="controls bullet"><span class="by">stepchowfun</span><span>|</span><a href="#36025379">parent</a><span>|</span><a href="#36024489">next</a><span>|</span><label class="collapse" for="c-36026025">[-]</label><label class="expand" for="c-36026025">[1 more]</label></div><br/><div class="children"><div class="content">This is a Typical concept. I haven&#x27;t seen this approach to optionality for sum types in any other serialization framework.<p>Programmers have good intuition for what it means for a field in a struct to be optional: it&#x27;s either there or it&#x27;s not. But for a sum type, what does it mean for a case to be &quot;missing&quot;? It&#x27;s not quite as obvious, but it helps to think about what responsibilities are placed on writers vs. readers: optionality for a struct relaxes the burden on writers (they don&#x27;t have to set the field), whereas for a sum type the burden is relaxed on readers (they don&#x27;t have to handle the case).</div><br/></div></div></div></div><div id="36024489" class="c"><input type="checkbox" id="c-36024489" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#36025379">prev</a><span>|</span><a href="#36025373">next</a><span>|</span><label class="collapse" for="c-36024489">[-]</label><label class="expand" for="c-36024489">[1 more]</label></div><br/><div class="children"><div class="content">Looks phenomenal, especially regarding robustness around union types</div><br/></div></div><div id="36025373" class="c"><input type="checkbox" id="c-36025373" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36024489">prev</a><span>|</span><a href="#36025272">next</a><span>|</span><label class="collapse" for="c-36025373">[-]</label><label class="expand" for="c-36025373">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love to use this if it had .net support.<p>We use Nats to communicate between services and use JSON for a lack of better options. I&#x27;ve been looking for something more efficient and strict. This looks like it would be a good match for F#s types.</div><br/></div></div><div id="36025272" class="c"><input type="checkbox" id="c-36025272" checked=""/><div class="controls bullet"><span class="by">bombolo</span><span>|</span><a href="#36025373">prev</a><span>|</span><label class="collapse" for="c-36025272">[-]</label><label class="expand" for="c-36025272">[2 more]</label></div><br/><div class="children"><div class="content">It seems we&#x27;re back to corba</div><br/><div id="36025397" class="c"><input type="checkbox" id="c-36025397" checked=""/><div class="controls bullet"><span class="by">xupybd</span><span>|</span><a href="#36025272">parent</a><span>|</span><label class="collapse" for="c-36025397">[-]</label><label class="expand" for="c-36025397">[1 more]</label></div><br/><div class="children"><div class="content">IMO Corba was still better than SOAP.</div><br/></div></div></div></div></div></div></div></div></div></body></html>