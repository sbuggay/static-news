<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737536470554" as="style"/><link rel="stylesheet" href="styles.css?v=1737536470554"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.sigstore.dev/">Sigstore: Making sure your software is what it claims to be</a> <span class="domain">(<a href="https://www.sigstore.dev">www.sigstore.dev</a>)</span></div><div class="subtext"><span>saikatsg</span> | <span>24 comments</span></div><br/><div><div id="42785468" class="c"><input type="checkbox" id="c-42785468" checked=""/><div class="controls bullet"><span class="by">linkregister</span><span>|</span><a href="#42785831">next</a><span>|</span><label class="collapse" for="c-42785468">[-]</label><label class="expand" for="c-42785468">[11 more]</label></div><br/><div class="children"><div class="content">Has anyone implemented this end-to-end? This seems production ready for smaller shops where it&#x27;s feasible for developers to sign artifacts individually. For a system where you&#x27;d want CI to publish artifacts, and then use the k8s policy controller to only run verified artifacts, it seems incomplete.<p>It appears the reason to include this system in a toolchain would be to meet compliance requirements, but even the GCP, AWS, and Azure implementations of artifact signing &amp; verification are in beta.</div><br/><div id="42787631" class="c"><input type="checkbox" id="c-42787631" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#42785468">parent</a><span>|</span><a href="#42787368">next</a><span>|</span><label class="collapse" for="c-42787631">[-]</label><label class="expand" for="c-42787631">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Has anyone implemented this end-to-end?<p>Yes; I (along with a bunch of other fantastic folks) implemented it end-to-end for both Homebrew[1] and PyPI[2]. This is at a &quot;lower&quot; level than most corporate uses, however: the goal with integrating Sigstore into these OSS ecosystems is not to build up complex verifiable policies (which OSS maintainers don&#x27;t want to deal with), but to enable signing with misuse-resistant machine identities.<p>[1]: <a href="https:&#x2F;&#x2F;blog.trailofbits.com&#x2F;2023&#x2F;11&#x2F;06&#x2F;adding-build-provenance-to-homebrew&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.trailofbits.com&#x2F;2023&#x2F;11&#x2F;06&#x2F;adding-build-provena...</a><p>[2]: <a href="https:&#x2F;&#x2F;blog.pypi.org&#x2F;posts&#x2F;2024-11-14-pypi-now-supports-digital-attestations&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.pypi.org&#x2F;posts&#x2F;2024-11-14-pypi-now-supports-dig...</a></div><br/><div id="42790463" class="c"><input type="checkbox" id="c-42790463" checked=""/><div class="controls bullet"><span class="by">arianvanp</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42787631">parent</a><span>|</span><a href="#42788352">next</a><span>|</span><label class="collapse" for="c-42790463">[-]</label><label class="expand" for="c-42790463">[1 more]</label></div><br/><div class="children"><div class="content">Is GitHub id tokens a misuse-resistent though? It seems a very weak machine identity.<p>1. It&#x27;s a repayable bearer token and not a proof of possession. A compromised action (which 99% of people do not pin to specific hashes) could exfiltrate an id token and use it for 15 minutes.
2. There is no proof of provenance of the build machine attached to it all. No attestation about machine state. The only thing you know is &quot;signed by GitHub&quot; which doesn&#x27;t really tell you anything interesting. Given Microsofts track record of security vulnerabilities in Azure regarding cross-tenant contamination I&#x27;d like to see a stronger attestation statement here.<p>Minimally this provenance stuff should be built on top of some proof of possession mechanism where a challenge is generated and the builder signs the challenge with its machine identity key.<p>Then ideally have an attestation statement that shows you the provenance of the entire machine (what packages , dm-verity hashes, whatever) together with that public key.<p>Sure it&#x27;s better than nothing what GitHub has now. And an attack is obvious in hindsight and clearly in the transparency log . But its definitely not a misuse resistent machine identity. We need something better for this IMO.</div><br/></div></div><div id="42788352" class="c"><input type="checkbox" id="c-42788352" checked=""/><div class="controls bullet"><span class="by">KennyBlanken</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42787631">parent</a><span>|</span><a href="#42790463">prev</a><span>|</span><a href="#42787368">next</a><span>|</span><label class="collapse" for="c-42788352">[-]</label><label class="expand" for="c-42788352">[4 more]</label></div><br/><div class="children"><div class="content">What you all should have done was figured out how to use that very mysterious and new technology called &quot;sudo&quot;, so that Homebrew doesn&#x27;t add user-writable directories to user&#x27;s paths, thus enabling anything they might run on their computer to modify binaries the user might run later, or anyone who sits down at their system unsupervised to do the same.</div><br/><div id="42788544" class="c"><input type="checkbox" id="c-42788544" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42788352">parent</a><span>|</span><a href="#42787368">next</a><span>|</span><label class="collapse" for="c-42788544">[-]</label><label class="expand" for="c-42788544">[3 more]</label></div><br/><div class="children"><div class="content">Apart from the snark (which is unwarranted), I can&#x27;t even parse what you&#x27;re saying.<p>(Mentioning sudo in the context of Homebrew suggests that you&#x27;re one of those incoherent threat model people, so I&#x27;m going to assume it&#x27;s that. So I&#x27;ll say what Homebrew&#x27;s maintainers have been saying for years: having a user writable Homebrew prefix is no more or less exploitable in the presence of attacker code execution than <i>literally anything else</i>. The attacker can always modify your shell initialization script, or your local Python bin directory, or anything else.)</div><br/><div id="42789313" class="c"><input type="checkbox" id="c-42789313" checked=""/><div class="controls bullet"><span class="by">saidinesh5</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42788544">parent</a><span>|</span><a href="#42787368">next</a><span>|</span><label class="collapse" for="c-42789313">[-]</label><label class="expand" for="c-42789313">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not much of a Mac user but I&#x27;m guessing the parent comment wanted  readonly user install path so accidental&#x2F;malicious rm -rf only affects the user data and not the installed programs?<p>Nothing to do with exploits as part of homebrew etc .</div><br/><div id="42789390" class="c"><input type="checkbox" id="c-42789390" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42789313">parent</a><span>|</span><a href="#42787368">next</a><span>|</span><label class="collapse" for="c-42789390">[-]</label><label class="expand" for="c-42789390">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not much of a Mac user but I&#x27;m guessing the parent comment wanted readonly user install path so accidental&#x2F;malicious rm -rf only affects the user data and not the installed programs?<p>That&#x27;s one possible interpretation, but it&#x27;s at odds with how most people use the `$PATH` anyways -- there&#x27;s lots of local read-writable stuff on it in typical cases. And of course, even without that, persistence is trivial for an attacker with local code execution.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42787368" class="c"><input type="checkbox" id="c-42787368" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42785468">parent</a><span>|</span><a href="#42787631">prev</a><span>|</span><a href="#42785690">next</a><span>|</span><label class="collapse" for="c-42787368">[-]</label><label class="expand" for="c-42787368">[1 more]</label></div><br/><div class="children"><div class="content">End-to-end it would require something like a web-of-trust or similar. There is little benefit in knowing that your package was definitely built by GitHub Actions definitely from the code that definitely came from the fingers of the random guy who maintains that particular tool.<p>Unless you have some trust relationship with the author, or with someone that audited the code, the whole cryptographically-authenticated chain hangs from nothing.<p>Tools like Crev did a lot of work in that area but it never really took off, people don&#x27;t want to think about trust: <a href="https:&#x2F;&#x2F;github.com&#x2F;crev-dev&#x2F;cargo-crev">https:&#x2F;&#x2F;github.com&#x2F;crev-dev&#x2F;cargo-crev</a></div><br/></div></div><div id="42785690" class="c"><input type="checkbox" id="c-42785690" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#42785468">parent</a><span>|</span><a href="#42787368">prev</a><span>|</span><a href="#42785831">next</a><span>|</span><label class="collapse" for="c-42785690">[-]</label><label class="expand" for="c-42785690">[3 more]</label></div><br/><div class="children"><div class="content">yes, i&#x27;ve implemented it in multiple companies. cosign supports using generated keys and kms services, that&#x27;s been pretty stable and usable for a long time.
keyless signing is different and you need to think a bit more carefully about what you&#x27;re trusting.</div><br/><div id="42786339" class="c"><input type="checkbox" id="c-42786339" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42785690">parent</a><span>|</span><a href="#42786987">next</a><span>|</span><label class="collapse" for="c-42786339">[-]</label><label class="expand" for="c-42786339">[1 more]</label></div><br/><div class="children"><div class="content">I recently implemented a software updating system using [The Update Framework](<a href="https:&#x2F;&#x2F;theupdateframework.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;theupdateframework.io&#x2F;</a>) directly, with [go-tuf](<a href="https:&#x2F;&#x2F;github.com&#x2F;theupdateframework&#x2F;go-tuf">https:&#x2F;&#x2F;github.com&#x2F;theupdateframework&#x2F;go-tuf</a>). It required a lot of design work around how we were going to do package management on top of using it for a secure updating system. This was due to TUF&#x27;s designing around the capability for existing package management systems to adopt it and integrate it into their system. So TUF is very unopinionated and flexible.<p>Given how TUF made it particularly hard to implement a system from scratch... How was your experience using Sigstore? Is it designed more around building systems from scratch? I.E. Is it more opinionated?<p>Thanks.</div><br/></div></div><div id="42786987" class="c"><input type="checkbox" id="c-42786987" checked=""/><div class="controls bullet"><span class="by">linkregister</span><span>|</span><a href="#42785468">root</a><span>|</span><a href="#42785690">parent</a><span>|</span><a href="#42786339">prev</a><span>|</span><a href="#42785831">next</a><span>|</span><label class="collapse" for="c-42786987">[-]</label><label class="expand" for="c-42786987">[1 more]</label></div><br/><div class="children"><div class="content">I designed a system using Sigstore where the signing key is in a secret store, and the CI shells out to the cosign CLI to perform the signing. Is this an antipattern?<p>For verification, did you use the policy controller in kubernetes? Or are you manually performing the verification at runtime?</div><br/></div></div></div></div></div></div><div id="42785831" class="c"><input type="checkbox" id="c-42785831" checked=""/><div class="controls bullet"><span class="by">djhn</span><span>|</span><a href="#42785468">prev</a><span>|</span><a href="#42785479">next</a><span>|</span><label class="collapse" for="c-42785831">[-]</label><label class="expand" for="c-42785831">[8 more]</label></div><br/><div class="children"><div class="content">Somewhat adjacent question: are there people working on ways to verify that a particular server or API backend are running the specific signed release that is open sourced? Can a company somehow cryptographically prove to its users that the running build is derived from the source unmodified?</div><br/><div id="42787187" class="c"><input type="checkbox" id="c-42787187" checked=""/><div class="controls bullet"><span class="by">kfreds</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42787487">next</a><span>|</span><label class="collapse" for="c-42787187">[-]</label><label class="expand" for="c-42787187">[1 more]</label></div><br/><div class="children"><div class="content">Yes. My colleagues and I have been working on it (and related concepts) for six years.<p>glasklarteknik.se<p>system-transparency.org<p>sigsum.org<p>tillitis.se<p>This presentation explains the idea and lists similar projects.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;Lo0gxBWwwQE" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;Lo0gxBWwwQE</a></div><br/></div></div><div id="42787487" class="c"><input type="checkbox" id="c-42787487" checked=""/><div class="controls bullet"><span class="by">mpysc</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42787187">prev</a><span>|</span><a href="#42787908">next</a><span>|</span><label class="collapse" for="c-42787487">[-]</label><label class="expand" for="c-42787487">[1 more]</label></div><br/><div class="children"><div class="content">You can get most of the way there with something like the SLSA&#x2F;BCID framework, with the final artifact including some trusted provenance from an attested builder. You could go further and aim for full reproducibility on top of the provenance, but reproducible builds across different environments can get messy fast if you&#x27;re looking to independently build and achieve the same result. Either way the end result is you have some artifact that you reasonably trust to represent some specific source input (ignoring the potential for backdoored compiler or other malicious intermediate code generation step).<p>Now for the last mile, I&#x27;ll admit I&#x27;m not particularly well-versed on the confidential compute side of things, so bridging the gap from trusted binary to trusted workload is something I can only speculate wildly on. Assuming you have a confidential compute environment that allows for workload attestation, I imagine that you could deploy this trusted binary and record the appropriate provenance information as part of the initial environment attestation report, then provide that to customers on demand (assuming they trust your attestation service).</div><br/></div></div><div id="42787908" class="c"><input type="checkbox" id="c-42787908" checked=""/><div class="controls bullet"><span class="by">captn3m0</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42787487">prev</a><span>|</span><a href="#42786032">next</a><span>|</span><label class="collapse" for="c-42787908">[-]</label><label class="expand" for="c-42787908">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the enclave routes, I have a proposal to build this with AWS Lambda as a poor man’s attestation: <a href="https:&#x2F;&#x2F;github.com&#x2F;captn3m0&#x2F;ideas?tab=readme-ov-file#verifiable-code-execution-on-cloud">https:&#x2F;&#x2F;github.com&#x2F;captn3m0&#x2F;ideas?tab=readme-ov-file#verifia...</a></div><br/></div></div><div id="42786032" class="c"><input type="checkbox" id="c-42786032" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42787908">prev</a><span>|</span><a href="#42786196">next</a><span>|</span><label class="collapse" for="c-42786032">[-]</label><label class="expand" for="c-42786032">[1 more]</label></div><br/><div class="children"><div class="content">You can do this with e.g. EC2 enclaves.  Of course that&#x27;s kind of begging the question, since you need to trust the enclaves.</div><br/></div></div><div id="42786196" class="c"><input type="checkbox" id="c-42786196" checked=""/><div class="controls bullet"><span class="by">shortsunblack</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42786032">prev</a><span>|</span><a href="#42786085">next</a><span>|</span><label class="collapse" for="c-42786196">[-]</label><label class="expand" for="c-42786196">[1 more]</label></div><br/><div class="children"><div class="content">See Keylime for this.</div><br/></div></div><div id="42786085" class="c"><input type="checkbox" id="c-42786085" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42786196">prev</a><span>|</span><a href="#42786338">next</a><span>|</span><label class="collapse" for="c-42786085">[-]</label><label class="expand" for="c-42786085">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what remote attestation in Intel SGX does. There&#x27;s similar features in other platforms as well.</div><br/></div></div><div id="42786338" class="c"><input type="checkbox" id="c-42786338" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#42785831">parent</a><span>|</span><a href="#42786085">prev</a><span>|</span><a href="#42785479">next</a><span>|</span><label class="collapse" for="c-42786338">[-]</label><label class="expand" for="c-42786338">[1 more]</label></div><br/><div class="children"><div class="content">Detecting physical ingress in a co-location server is not uncommon after contacting political representatives in some countries.  It is wise to have password protected SSL certs as the bare minimum non-resettable tripwire, close monitoring of the HDD&#x2F;SSD drives s.m.a.r.t. firmware power-cycle counter, and of course an encrypted partition for logs and other mutable&#x2F;sensitive content.  Note for performance, a &quot;sudo debsums -sac&quot; command along with other tripwire software can audit unencrypted system binaries efficiently. Most modern ephemeral malware (on android especially) is not written to disk to avoid forensic audits assigning accountability, as the chance of re-infection is higher if you hide the exploit methodology.<p>Folks should operate like they already have someone with a leaked instance of their key files.   In general,  a offline key-self-signing authority issuing client&#x2F;peer certs is also important, as on rare occasion one can&#x27;t trust 3rd parties not to re-issue certs for Google&#x2F;Facebook&#x2F;Github etc. to jack users.<p>Eventually one should localize your database design to specific users, and embed user action telemetry into a design.  i.e. damage or hostile activity is inherently limited to a specific users content, sanity checking quota systems limit the damage they can cause, and windowed data-lifecycle limits the credentials to read-only or does garbage collection after some time.<p>In general, the rabbitMQ AMQP over SSL client signed cert credential system has proven rather reliable. Erlang&#x2F;Elixir is far from perfect, but it can be made fairly robust with firewall rules.<p>Good luck, YMMV of course... =3</div><br/></div></div></div></div><div id="42785479" class="c"><input type="checkbox" id="c-42785479" checked=""/><div class="controls bullet"><span class="by">rough-sea</span><span>|</span><a href="#42785831">prev</a><span>|</span><a href="#42786943">next</a><span>|</span><label class="collapse" for="c-42785479">[-]</label><label class="expand" for="c-42785479">[1 more]</label></div><br/><div class="children"><div class="content">JSR supports sigstore <a href="https:&#x2F;&#x2F;jsr.io&#x2F;docs&#x2F;trust" rel="nofollow">https:&#x2F;&#x2F;jsr.io&#x2F;docs&#x2F;trust</a></div><br/></div></div><div id="42786943" class="c"><input type="checkbox" id="c-42786943" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#42785479">prev</a><span>|</span><a href="#42785873">next</a><span>|</span><label class="collapse" for="c-42786943">[-]</label><label class="expand" for="c-42786943">[1 more]</label></div><br/><div class="children"><div class="content">Does this help when a project change ownership or in cases like the xz backdoor?</div><br/></div></div></div></div></div></div></div></body></html>