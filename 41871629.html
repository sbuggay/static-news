<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729242071367" as="style"/><link rel="stylesheet" href="styles.css?v=1729242071367"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.thecoder.cafe/p/unit-tests-as-documentation">Unit tests as documentation</a> <span class="domain">(<a href="https://www.thecoder.cafe">www.thecoder.cafe</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>128 comments</span></div><br/><div><div id="41874483" class="c"><input type="checkbox" id="c-41874483" checked=""/><div class="controls bullet"><span class="by">bunderbunder</span><span>|</span><a href="#41872163">next</a><span>|</span><label class="collapse" for="c-41874483">[-]</label><label class="expand" for="c-41874483">[28 more]</label></div><br/><div class="children"><div class="content">I share this ideal, but also have to gripe that &quot;descriptive test name&quot; is where this falls apart, every single time.<p>Getting all your teammates to quit giving all their tests names like &quot;testTheThing&quot; is darn near impossible. It&#x27;s socially painful to be the one constantly nagging people about names, but it really does take constant nagging to keep the quality high. As soon as the nagging stops, someone invariably starts cutting corners on the test names, and after that everyone who isn&#x27;t a pedantic weenie about these things will start to follow suit.<p>Which is honestly the sensible, well-adjusted decision. I&#x27;m the pedantic weenie on my team, and even I have to agree that I&#x27;d rather my team have a frustrating test suite than frustrating social dynamics.<p>Personally - and this absolutely echoes the article&#x27;s last point - I&#x27;ve been increasingly moving toward Donald Knuth&#x27;s literate style of programming. It helps me organize my thoughts even better than TDD does, and it&#x27;s earned me far more compliments about the readability of my code than a squeaky-clean test suite ever does. So much so that I&#x27;m beginning to hold hope that if you can build enough team mass around working that way it might even develop into a stable equilibrium point as people start to see how it really does make the job more enjoyable.</div><br/><div id="41877538" class="c"><input type="checkbox" id="c-41877538" checked=""/><div class="controls bullet"><span class="by">macspoofing</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41877415">next</a><span>|</span><label class="collapse" for="c-41877538">[-]</label><label class="expand" for="c-41877538">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Getting all your teammates to quit giving all their tests names like &quot;testTheThing&quot; is darn near impossible.<p>You can do better than &quot;testTheThing&quot;.<p>Have your team (or a working group composed of your team, if your team is too big) put together a set of guidelines on naming conventions for unit test methods. Have your team agree to these conventions (assumption is that the working group would have consulted with rest of team and incorporated their feedback).<p>Then make that part of the code review checklist (so you aren&#x27;t the one that is actually enforcing the policy). Do spot checks for the first little while, or empower some individuals to be responsible for that - if you really want to. Do a retrospective after a month or 2 months to see how everyone is doing and see how successful this initiative was.</div><br/></div></div><div id="41877415" class="c"><input type="checkbox" id="c-41877415" checked=""/><div class="controls bullet"><span class="by">ojkelly</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41877538">prev</a><span>|</span><a href="#41875926">next</a><span>|</span><label class="collapse" for="c-41877415">[-]</label><label class="expand" for="c-41877415">[1 more]</label></div><br/><div class="children"><div class="content">Test names are one of those things that are painful because it’s obvious to you as you write it, but there’s an extra hassle to switch gears in your head to describe what the contents of the test is doing.<p>It is really valuable when they are named well.<p>I’ve found this is where LLM can be quite useful, they’re pretty good at summarising.<p>Someday soon I think we’ll see a language server that checks if comments still match what they’re documenting. The same for tests being named accurately.</div><br/></div></div><div id="41875926" class="c"><input type="checkbox" id="c-41875926" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41877415">prev</a><span>|</span><a href="#41877265">next</a><span>|</span><label class="collapse" for="c-41875926">[-]</label><label class="expand" for="c-41875926">[1 more]</label></div><br/><div class="children"><div class="content">Hah, I swing the other way!  If module <i>foo</i> had a function <i>bar</i> then my test is in module <i>test_foo</i> and the test is called <i>test_bar</i>.<p>Nine times out of ten this is the only test, which is mostly there to ensure the code gets exercised in a sensible way and returns a thing, and ideally to document and enforce the contract of the function.<p>What I absolutely agree with you on is that being able to describe this contract alongside the function itself is far more preferable.  It’s not quite literate programming but tools like Python’s <i>doctest</i> offer a close approximation to interleaving discourse with machine readable implementation:<p><pre><code>  def double(n: int) -&gt; int:
    “””Increase by 100%

    &gt;&gt;&gt; double(7)
    14
    “””
    return 2 * n</code></pre></div><br/></div></div><div id="41877265" class="c"><input type="checkbox" id="c-41877265" checked=""/><div class="controls bullet"><span class="by">yesbabyyes</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41875926">prev</a><span>|</span><a href="#41876977">next</a><span>|</span><label class="collapse" for="c-41877265">[-]</label><label class="expand" for="c-41877265">[2 more]</label></div><br/><div class="children"><div class="content">As a fan of literate programming, I hope this could be a tool in the box for Node.js developers: Testy is basically doctests for Node.js, building off JSDoc&#x27;s @examples stanza.<p>I would be honored by anyone checking it out: <a href="https:&#x2F;&#x2F;github.com&#x2F;linus&#x2F;testy">https:&#x2F;&#x2F;github.com&#x2F;linus&#x2F;testy</a></div><br/></div></div><div id="41876977" class="c"><input type="checkbox" id="c-41876977" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41877265">prev</a><span>|</span><a href="#41876835">next</a><span>|</span><label class="collapse" for="c-41876977">[-]</label><label class="expand" for="c-41876977">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the hint about Knuth&#x27;s literate programming! I hadn&#x27;t heard about it before but it immediately looks great. (For those of us who hadn&#x27;t heard about it before either, here is a link: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Literate_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Literate_programming</a>)<p>About your other point: I have experienced exactly the same. It just seems impossible to instill the belief into most developers that readable tests lead to faster solving of bugs. And by the way, it makes tests more maintainable as well, just like readable code makes the code more maintainable anywhere else.</div><br/></div></div><div id="41875790" class="c"><input type="checkbox" id="c-41875790" checked=""/><div class="controls bullet"><span class="by">ronnier</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41876835">prev</a><span>|</span><a href="#41874705">next</a><span>|</span><label class="collapse" for="c-41875790">[-]</label><label class="expand" for="c-41875790">[2 more]</label></div><br/><div class="children"><div class="content">I’d rather leave a good comment instead of good test names. I mean do both, but a good comment is better imo. All I really care about is comments anymore. Just leave context, clues, and a general idea of what it’s trying to accomplish.</div><br/><div id="41876142" class="c"><input type="checkbox" id="c-41876142" checked=""/><div class="controls bullet"><span class="by">lallysingh</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41875790">parent</a><span>|</span><a href="#41874705">next</a><span>|</span><label class="collapse" for="c-41876142">[-]</label><label class="expand" for="c-41876142">[1 more]</label></div><br/><div class="children"><div class="content">Four test failures in different systems, each named well, will more quickly and accurately point me to my introduced bug than comments in those systems.<p>Identifiers matter.</div><br/></div></div></div></div><div id="41874705" class="c"><input type="checkbox" id="c-41874705" checked=""/><div class="controls bullet"><span class="by">wubrr</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41875790">prev</a><span>|</span><a href="#41874655">next</a><span>|</span><label class="collapse" for="c-41874705">[-]</label><label class="expand" for="c-41874705">[12 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s socially painful to be the one constantly nagging people about names, but it really does take constant nagging to keep the quality high.<p>What do test names have to do with quality? If you want to use it as some sort of name&#x2F;key, just have a comment&#x2F;annotation&#x2F;parameter that succinctly defines that,  along with any other metadata you want to add in readable English. Many testing frameworks support this. There&#x27;s exactly zero benefit toTryToFitTheTestDescriptionIntoItsName.</div><br/><div id="41876888" class="c"><input type="checkbox" id="c-41876888" checked=""/><div class="controls bullet"><span class="by">serial_dev</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41877002">next</a><span>|</span><label class="collapse" for="c-41876888">[-]</label><label class="expand" for="c-41876888">[2 more]</label></div><br/><div class="children"><div class="content">Some languages &#x2F; test tools don’t enforce testNamesLikesThisThatLookStupidForTestDescriptions, and you can use proper strings, so you can just say meaningful requirements with a readable text, like “extracts task ID from legacy staging URLs”.<p>It looks, feels, and reads much better.</div><br/><div id="41877015" class="c"><input type="checkbox" id="c-41877015" checked=""/><div class="controls bullet"><span class="by">lbreakjai</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41876888">parent</a><span>|</span><a href="#41877002">next</a><span>|</span><label class="collapse" for="c-41877015">[-]</label><label class="expand" for="c-41877015">[1 more]</label></div><br/><div class="children"><div class="content">With jest (Amonsts others), you can nest the statements. I find it really useful to describe what the tests are doing:<p><pre><code>    describe(&#x27;The foo service&#x27;, () =&gt; {

      describe(&#x27;When called with an array of strings&#x27;, () =&gt; {

        describe(&#x27;And the bar API is down&#x27;, () =&gt; {

          it(&#x27;pushes the values to a DLQ&#x27; () =&gt; {
            &#x2F;&#x2F; test here
          })

          it(&#x27;logs the error somewhere&#x27; () =&gt; {
            &#x2F;&#x2F; test here
          })

          it(&#x27;Returns a proper error message`, () =&gt; {
            &#x2F;&#x2F; test here
          })
        })
      })
    })

</code></pre>
You could throw all those assertions into one test, but they’re probably cheap enough that performance won’t really take a hit. Even if there is a slight impact, I find the reduced cognitive load of not having to decipher the purpose of &#x27;callbackSpyMock&#x27; to be a worthwhile trade-off.</div><br/></div></div></div></div><div id="41877002" class="c"><input type="checkbox" id="c-41877002" checked=""/><div class="controls bullet"><span class="by">misja111</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41876888">prev</a><span>|</span><a href="#41874814">next</a><span>|</span><label class="collapse" for="c-41877002">[-]</label><label class="expand" for="c-41877002">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny, you are asking what test names have to do with quality, and you proceed with mentioning a really bad test name, &#x27;toTryToFitTheTestDescriptionIntoItsName&#x27;, and (correctly) stating that this has zero benefit.<p>Just like normal code, test methods should indicate what they are doing. This will help you colleague when he&#x27;s trying to fix the failing test when you&#x27;re not around.
There are other ways of doing that of course which can be fine as well, such as describing the test case with some kind of meta data that the test framework supports.<p>But the problem that OP is talking about, is that many developers simply don&#x27;t see the point of putting much effort into making tests readable. They won&#x27;t give tests a readable name, they won&#x27;t give it a readable description in metadata either.</div><br/></div></div><div id="41874814" class="c"><input type="checkbox" id="c-41874814" checked=""/><div class="controls bullet"><span class="by">6r17</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41877002">prev</a><span>|</span><a href="#41876871">next</a><span>|</span><label class="collapse" for="c-41874814">[-]</label><label class="expand" for="c-41874814">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not the point of the article. The code should be readable no exception. The only reason we should be ysing x y z are for coordinates ; i should be left for index_what ; same goes for parameters ; they should also contain what unit they are on (not scale, but scale_float) only exception I see are typed languages ; and even then I&#x27;m occasionally asked a detail about some obscure parameter that we set up a year ago. I understand it can sound goofy, but the extra effort is made towards other people working on the project, or future self. There is no way I can remember keys or where I left the meaning of those, and there is no justification to just write it down.<p>Readability of the code makes a lot of it&#x27;s quality. A working code that is not maintainable will be refactored. A non working cofe that is maintainable will be fixed.</div><br/></div></div><div id="41876871" class="c"><input type="checkbox" id="c-41876871" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41874814">prev</a><span>|</span><a href="#41874867">next</a><span>|</span><label class="collapse" for="c-41876871">[-]</label><label class="expand" for="c-41876871">[2 more]</label></div><br/><div class="children"><div class="content">Kotlin has an interesting approach to solving this. You can name functions using backticks, and in those backticks you can put basically anything.<p>So it&#x27;s common to see unit tests like<p><pre><code>  @Test
  fun `this tests something very complicated`() {
    ...
  }</code></pre></div><br/><div id="41877009" class="c"><input type="checkbox" id="c-41877009" checked=""/><div class="controls bullet"><span class="by">sfn42</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41876871">parent</a><span>|</span><a href="#41874867">next</a><span>|</span><label class="collapse" for="c-41877009">[-]</label><label class="expand" for="c-41877009">[1 more]</label></div><br/><div class="children"><div class="content">You can do that in Java as well. Can&#x27;t remember if it&#x27;s exactly the same syntax</div><br/></div></div></div></div><div id="41874867" class="c"><input type="checkbox" id="c-41874867" checked=""/><div class="controls bullet"><span class="by">8note</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41876871">prev</a><span>|</span><a href="#41875382">next</a><span>|</span><label class="collapse" for="c-41874867">[-]</label><label class="expand" for="c-41874867">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s important to this article because its claiming that the name is coupled functionally to what the code tests -- that the test will fail if the name is wrong.<p>I don&#x27;t know if any test tools that work like that though.</div><br/><div id="41875993" class="c"><input type="checkbox" id="c-41875993" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874867">parent</a><span>|</span><a href="#41875382">next</a><span>|</span><label class="collapse" for="c-41875993">[-]</label><label class="expand" for="c-41875993">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not what the article claims at all.<p>It claims that, in order for tests to serve as documentation, they must follow a set of best practices, one of which is descriptive test names. It says nothing about failing tests when the name of the test doesn&#x27;t match the actual test case.<p>Note I&#x27;m not saying whether I consider this to be good advice; I&#x27;m merely clarifying what the article states.</div><br/></div></div></div></div><div id="41875382" class="c"><input type="checkbox" id="c-41875382" checked=""/><div class="controls bullet"><span class="by">seadan83</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41874867">prev</a><span>|</span><a href="#41876013">next</a><span>|</span><label class="collapse" for="c-41875382">[-]</label><label class="expand" for="c-41875382">[2 more]</label></div><br/><div class="children"><div class="content">What kinds of things would you say are best as annotation vs in the test method name? Would you mind giving a few examples?<p>Also, are you a fan of nesting test classes? Any opinions? Eg:<p>Class fibrulatatorTest {<p><pre><code>  Class highVoltages{

      Void tooMuchWillNoOp() {}
      Void maxVoltage() {}</code></pre>
}
}</div><br/><div id="41876463" class="c"><input type="checkbox" id="c-41876463" checked=""/><div class="controls bullet"><span class="by">biggc</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41875382">parent</a><span>|</span><a href="#41876013">next</a><span>|</span><label class="collapse" for="c-41876463">[-]</label><label class="expand" for="c-41876463">[1 more]</label></div><br/><div class="children"><div class="content">Table tests can enable useful test naming without a bunch of clunky named test functions. I use them most often in Go but I’m sure other languages have support<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;wiki&#x2F;TableDrivenTests" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;wiki&#x2F;TableDrivenTests</a></div><br/></div></div></div></div><div id="41876013" class="c"><input type="checkbox" id="c-41876013" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41874483">root</a><span>|</span><a href="#41874705">parent</a><span>|</span><a href="#41875382">prev</a><span>|</span><a href="#41874655">next</a><span>|</span><label class="collapse" for="c-41876013">[-]</label><label class="expand" for="c-41876013">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>What do test names have to do with quality?</i><p>The quality of the tests.<p>If we go by the article, <i>specifically</i> their readability and quality as documentation.<p>It says nothing about the quality of the resulting software (though, presumably, this will also be indirectly affected).</div><br/></div></div></div></div><div id="41874655" class="c"><input type="checkbox" id="c-41874655" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41874705">prev</a><span>|</span><a href="#41875904">next</a><span>|</span><label class="collapse" for="c-41874655">[-]</label><label class="expand" for="c-41874655">[1 more]</label></div><br/><div class="children"><div class="content">Obviously this is slightly implementation dependent but if your tests are accompanied by programmatic documentation (that is output together with the test), doesn&#x27;t that eliminate the need for a descriptive test name in the first place?<p>If anything, in this scenario, I wouldn&#x27;t even bother printing the test names, and would just give them generated identifier names instead. Otherwise, isn&#x27;t it a bit like expecting git hashes to be meaningful when there&#x27;s a commit message right there?</div><br/></div></div><div id="41875904" class="c"><input type="checkbox" id="c-41875904" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41874655">prev</a><span>|</span><a href="#41874662">next</a><span>|</span><label class="collapse" for="c-41875904">[-]</label><label class="expand" for="c-41875904">[1 more]</label></div><br/><div class="children"><div class="content">It’s practically a sociology experiment at this point: half of the time when I suggest people force themselves to use a thesaurus whether they think they need it or not, I get upvoted. And half the time I get downvoted until I get hidden.<p>People grab the first word they think of. And subconsciously they know if they obsess about the name it’ll have an opportunity cost - dropping one or more of the implementation details they’re juggling in their short term memory.<p>But if “slow” is the first word you think of that’s not very good. And if you look at the synonyms and antonyms you can solidify your understanding of the purpose of the function in your head. Maybe you meant thorough, or conservative. And maybe you meant to do one but actually did another. So now you can not just chose a name but revisit the intent.<p>Plus you’re not polluting the namespace by recycling a jargon word that means something else in another part of the code, complicating refactoring and self discovery later on.</div><br/></div></div><div id="41874662" class="c"><input type="checkbox" id="c-41874662" checked=""/><div class="controls bullet"><span class="by">zoover2020</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41875904">prev</a><span>|</span><a href="#41875392">next</a><span>|</span><label class="collapse" for="c-41874662">[-]</label><label class="expand" for="c-41874662">[1 more]</label></div><br/><div class="children"><div class="content">Have you considered a linter rule for test names? Both Checkstyle and ESLint did great work for our team</div><br/></div></div><div id="41875392" class="c"><input type="checkbox" id="c-41875392" checked=""/><div class="controls bullet"><span class="by">yourapostasy</span><span>|</span><a href="#41874483">parent</a><span>|</span><a href="#41874662">prev</a><span>|</span><a href="#41877459">next</a><span>|</span><label class="collapse" for="c-41875392">[-]</label><label class="expand" for="c-41875392">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; ...increasingly moving toward Donald Knuth&#x27;s literate style of programming.</i><p>I&#x27;ve been wishing for a long time that the industry would move towards this, but it is tough to get developers to write more than performative documentation that checks an agile sprint box, much less get product owners to allocate time test the documentation (throw someone unfamiliar with the code to do something small with it armed with only its documentation, like code another few necessary tests and document them, and correct the bumps in the consumption of the documentation). Even tougher to move towards the kind of Knuth&#x27;ian TeX&#x27;ish-quality and -sophistication documentation, which I consider necessary (though perhaps not sufficient) for taming increasing software complexity.<p>I hoped the kind of deep technical writing at large scales supported by Adobe Framemaker would make its way into open source alternatives like Scribus, but instead we&#x27;re stuck with Markdown and Mermaid, which have their place but are painful when maintaining content over a long time, sprawling audience roles, and broad scopes. Unfortunate, since LLM&#x27;s could support a quite rich technical writing and editing delivery sitting on top of a Framemaker-feature&#x27;ish document processing system oriented towards supporting literal programming.</div><br/></div></div></div></div><div id="41872163" class="c"><input type="checkbox" id="c-41872163" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41874483">prev</a><span>|</span><a href="#41871877">next</a><span>|</span><label class="collapse" for="c-41872163">[-]</label><label class="expand" for="c-41872163">[28 more]</label></div><br/><div class="children"><div class="content">One - unit tests <i>explain</i> nothing. They show what the output should be for a given input, but not why, or how you get there. I&#x27;m surprised by the nonchalant claim that &quot;unit tests explain code&quot;. Am I missing something about the meaning of the english word &quot;explain&quot;?<p>Two - so any input value outside of those in unit tests is undocumented &#x2F; unspecified behavior? A documentation can contain an explanation in words, like what relation should hold between the inputs and outputs <i>in all cases</i>. Unit tests by their nature can only enumerate a finite number of cases.<p>This seems like such an obviously not great idea...</div><br/><div id="41872317" class="c"><input type="checkbox" id="c-41872317" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41872378">next</a><span>|</span><label class="collapse" for="c-41872317">[-]</label><label class="expand" for="c-41872317">[7 more]</label></div><br/><div class="children"><div class="content">Not sure about this, but I like it the way it is done in the Rust ecosystem.<p>In Rust, there are two types of comments. Regular ones (e.g. starting with &#x2F;&#x2F;) and doc-comments (e.g. starting with &#x2F;&#x2F;&#x2F;). The latter will land in in the generated documentation when you run <i>cargo doc</i>.<p>And now the cool thing: If you have example code in these doc comments, e.g. to explain how a feature of your library can be used, that script will automatically become part of the tests per default. That means you are unlikey to forget to update these examples when your code changes <i>and</i> you can use them as tests at the same time by asserting something at the end (which also communicates the outcome to the reader).</div><br/><div id="41876631" class="c"><input type="checkbox" id="c-41876631" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872317">parent</a><span>|</span><a href="#41874298">next</a><span>|</span><label class="collapse" for="c-41876631">[-]</label><label class="expand" for="c-41876631">[1 more]</label></div><br/><div class="children"><div class="content">I discovered that completely by surprise when I was learning Rust. I wrote code and unit tests, wrote some documentation, and I was blown away when I saw that my documentation also ran as part of the suite. Such a magical moment.</div><br/></div></div><div id="41874298" class="c"><input type="checkbox" id="c-41874298" checked=""/><div class="controls bullet"><span class="by">readline_prompt</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872317">parent</a><span>|</span><a href="#41876631">prev</a><span>|</span><a href="#41872805">next</a><span>|</span><label class="collapse" for="c-41874298">[-]</label><label class="expand" for="c-41874298">[2 more]</label></div><br/><div class="children"><div class="content">Doctests are great aren&#x27;t they?</div><br/><div id="41874460" class="c"><input type="checkbox" id="c-41874460" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41874298">parent</a><span>|</span><a href="#41872805">next</a><span>|</span><label class="collapse" for="c-41874460">[-]</label><label class="expand" for="c-41874460">[1 more]</label></div><br/><div class="children"><div class="content">IDK, they sound like they overflow the &quot;maximum code&quot; counter and land up straight in the literate programming land. I wonder how far you could go writing your whole program as doctests spliced between commentary.</div><br/></div></div></div></div><div id="41872805" class="c"><input type="checkbox" id="c-41872805" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872317">parent</a><span>|</span><a href="#41874298">prev</a><span>|</span><a href="#41872703">next</a><span>|</span><label class="collapse" for="c-41872805">[-]</label><label class="expand" for="c-41872805">[1 more]</label></div><br/><div class="children"><div class="content">Does your IDE handle syntax-highlighting and intellisense -type enhancements for these unit tests written as doc-comments?</div><br/></div></div><div id="41872703" class="c"><input type="checkbox" id="c-41872703" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872317">parent</a><span>|</span><a href="#41872805">prev</a><span>|</span><a href="#41872378">next</a><span>|</span><label class="collapse" for="c-41872703">[-]</label><label class="expand" for="c-41872703">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, combining unit tests and written docs in various ways seems fine. My reading of the article was that the tests are the only documentation. Maybe that was not the intent but just a bad interpretation on my part.<p>Though some replies here seem to keep arguing for my interpretation, so it&#x27;s not just me.</div><br/><div id="41876048" class="c"><input type="checkbox" id="c-41876048" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872703">parent</a><span>|</span><a href="#41872378">next</a><span>|</span><label class="collapse" for="c-41876048">[-]</label><label class="expand" for="c-41876048">[1 more]</label></div><br/><div class="children"><div class="content">Combining is what TFA suggests. They even go as far as closing the article with:<p>&gt; <i>Note also that I’m not suggesting that unit tests should replace any form of documentation but rather that they should complement and enrich it.</i></div><br/></div></div></div></div></div></div><div id="41872378" class="c"><input type="checkbox" id="c-41872378" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41872317">prev</a><span>|</span><a href="#41875896">next</a><span>|</span><label class="collapse" for="c-41872378">[-]</label><label class="expand" for="c-41872378">[2 more]</label></div><br/><div class="children"><div class="content">Unit tests <i>can</i> explain nothing. But so can paragraphs of prose.<p>The benefit of explanations in tests is that running them gets you closer to knowing if any of the explanations have bit rotted.</div><br/><div id="41872921" class="c"><input type="checkbox" id="c-41872921" checked=""/><div class="controls bullet"><span class="by">mannykannot</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872378">parent</a><span>|</span><a href="#41875896">next</a><span>|</span><label class="collapse" for="c-41872921">[-]</label><label class="expand" for="c-41872921">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The benefit of explanations in tests is...<p>What you appear to have in mind here is the documentation of a test. Any documentation that correctly explains why it matters that the test should pass will likely tell you something about what the purpose of the unit is, how it is supposed to work, or what preconditions must be satisfied in order for it to work correctly, but the first bullet point in the article seems to be making a much stronger claim than that.<p>The observation that both tests and documentation <i>may</i> fail to explain their subject sheds no light on the question of whether (or to what extent) tests <i>in themselves</i> can explain the things they test.</div><br/></div></div></div></div><div id="41875896" class="c"><input type="checkbox" id="c-41875896" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41872378">prev</a><span>|</span><a href="#41872545">next</a><span>|</span><label class="collapse" for="c-41875896">[-]</label><label class="expand" for="c-41875896">[1 more]</label></div><br/><div class="children"><div class="content">For something like this:<p><pre><code>  def get_examples(
    source: Path,
    minimum_size: float,
    maximum_size: float,
    total_size: float,
    seed: float = 123,
  ) -&gt; Iterator[Path]:
      …
</code></pre>
…it’s pretty obvious what those float arguments are for but the “source” is just a Path.   Is there an example “source” I can look at to see what sort of thing I am supposed to pass there?<p>Well you could document that abstractly in the function (“your source must be a directory available via NFS to all devs as well as the build infra”) but you could also use the function in a test and describe it there, and let that be the “living documentation” of which the original author speaks.<p>Obviously if this is a top level function in some open source library with a readthedocs page then it’s good to actually document the function <i>and</i> have a test.  If it’s just some internal thing though then doc-rot can be more harmful than no docs at all, so the best docs are therefore verified, living docs: the tests.<p>(…or make your source an enumeration type so you don’t even need the docs!)</div><br/></div></div><div id="41872545" class="c"><input type="checkbox" id="c-41872545" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41875896">prev</a><span>|</span><a href="#41874890">next</a><span>|</span><label class="collapse" for="c-41872545">[-]</label><label class="expand" for="c-41872545">[7 more]</label></div><br/><div class="children"><div class="content">One: Can we test the tests using some somewhat formal specification of the why?<p>Two: my intuition says that exhaustively specifying the intended input output pairs would only hold marginal utility compared to testing a few well selected input output pairs. It&#x27;s more like attaching the corners of a sheet to the wall than gluing the whole sheet to the wall. And glue is potentially harder to remove. The sheet is n-dimensional though.</div><br/><div id="41872651" class="c"><input type="checkbox" id="c-41872651" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872545">parent</a><span>|</span><a href="#41874890">next</a><span>|</span><label class="collapse" for="c-41872651">[-]</label><label class="expand" for="c-41872651">[6 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t understand the &quot;exhaustive specification&quot; thing. How else is software supposed to work but with exhaustive specification? Is the operator + not specified exhaustively? Does your intuition tell you it is enough to give some pairs of numbers and their sums, and no need for some words that explain + computes the algebraic sum of its operands? There are an infinite number of functions of two arguments that pass through a finite number of specified points. Without the words saying what + does, it could literally do anything outside the test cases.<p>Of course, for + it&#x27;s relatively easy to intuit what it is supposed to mean. But if I develop a &quot;joe&#x27;s interpolation operator&quot;, you think you&#x27;ll understand it well enough from 5-10 unit tests, and actually giving you the formula would add nothing? Again I find myself wondering if I&#x27;m missing some english knowledge...<p>Can you imagine understanding the Windows API from nothing but unit tests? I really cannot. No text to explain the concepts of process, memory protection, file system? There is absolutely no way I would get it.</div><br/><div id="41873282" class="c"><input type="checkbox" id="c-41873282" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872651">parent</a><span>|</span><a href="#41874180">next</a><span>|</span><label class="collapse" for="c-41873282">[-]</label><label class="expand" for="c-41873282">[4 more]</label></div><br/><div class="children"><div class="content">The thing about Joe&#x27;s interpolation operator is that Joe doesn&#x27;t work here anymore but thousands of users are relying on his work and we need to change it such that as few of them scream as possible.<p>That&#x27;s the natural habitat for code, not formally specified, but partially functioning in situ.  Often the best you can do is contribute a few more test cases towards a decent spec for existing code because there just isn&#x27;t time to re-architect the thing.<p>If you are working with code in an environment where spending time improving the specification can be made a prerequisite of whatever insane thing the stakeholders want today... Hang on to that job. For the rest of us, it&#x27;s a game of which-hack-is-least-bad.</div><br/><div id="41875738" class="c"><input type="checkbox" id="c-41875738" checked=""/><div class="controls bullet"><span class="by">invaderzirp</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41873282">parent</a><span>|</span><a href="#41874180">next</a><span>|</span><label class="collapse" for="c-41875738">[-]</label><label class="expand" for="c-41875738">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s stopping someone from reading the code, studying it deeply, and then writing down what it does? That&#x27;s what I do, but I see people struggle with it because they just want to get more tickets done.</div><br/><div id="41876363" class="c"><input type="checkbox" id="c-41876363" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41875738">parent</a><span>|</span><a href="#41876389">next</a><span>|</span><label class="collapse" for="c-41876363">[-]</label><label class="expand" for="c-41876363">[1 more]</label></div><br/><div class="children"><div class="content">Nothing, sounds like a great plan.<p>But if you want other people to benefit from it, a good place to put it is right next to a test that will start failing as soon as the code changes in a way that no longer conforms to the spec.<p>Otherwise those people who just want to get more tickets done will change the code without changing the spec. Or you&#x27;ll end up working on something else and they&#x27;ll never even know about your document, because they&#x27;re accustomed to everybody else&#x27;s bad habits.<p>If you&#x27;re going to be abnormally diligent, you might as well so in a way that the less diligent can approach gradually: One test at a time.</div><br/></div></div><div id="41876389" class="c"><input type="checkbox" id="c-41876389" checked=""/><div class="controls bullet"><span class="by">dullcrisp</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41875738">parent</a><span>|</span><a href="#41876363">prev</a><span>|</span><a href="#41874180">next</a><span>|</span><label class="collapse" for="c-41876389">[-]</label><label class="expand" for="c-41876389">[1 more]</label></div><br/><div class="children"><div class="content">The code already says what it does.</div><br/></div></div></div></div></div></div><div id="41874180" class="c"><input type="checkbox" id="c-41874180" checked=""/><div class="controls bullet"><span class="by">worldsayshi</span><span>|</span><a href="#41872163">root</a><span>|</span><a href="#41872651">parent</a><span>|</span><a href="#41873282">prev</a><span>|</span><a href="#41874890">next</a><span>|</span><label class="collapse" for="c-41874180">[-]</label><label class="expand" for="c-41874180">[1 more]</label></div><br/><div class="children"><div class="content">I suspect we&#x27;re thinking about quite different use cases for our testing code. If the input-output pairs are describing a highly technical relationship I would probably want a more rigorous testing procedure. Possibly proofs.<p>Most of the tests I write daily is about moving and transforming data in ways that are individually rather trivial, but when features pile up, keeping track of all requirements is hard, so you want regression tests. But you also don&#x27;t want a bunch of regression tests that are hard to change when you change requirements, which will happen. So you want a decent amount of simple tests for individually simple requirements that make up a complex whole.</div><br/></div></div></div></div></div></div><div id="41874890" class="c"><input type="checkbox" id="c-41874890" checked=""/><div class="controls bullet"><span class="by">tpoacher</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41872545">prev</a><span>|</span><a href="#41872973">next</a><span>|</span><label class="collapse" for="c-41874890">[-]</label><label class="expand" for="c-41874890">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests are programmatic specification. I&#x27;m assuming it is in this manner that the article is referring to them as documentation, rather than as &quot;explanations&quot; per se.<p>Obviously unit tests cannot enumerate all inputs, but as a form of programmatic specification, neither do they have to.<p>For the case you mention where a broad relation should hold, this is a special kind of unit test strategy, which is property testing. Though admittedly other aspects of design-by-contract are also better suited here; nobody&#x27;s claiming that tests are the best or only programmatic documentation strategy.<p>Finally, there&#x27;s another kind of unit testing, which is more appropriately called characterisation testing, as per M. Feathers book on legacy code. The difference being, unit tests are for developing a feature and ensuring adherence to a spec, whereas characterisation tests are for exploring the actual behaviour of existing code (which may or may not be behaving according to the intended spec). These are definitely then tests as programmatic documentation.</div><br/></div></div><div id="41872973" class="c"><input type="checkbox" id="c-41872973" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41874890">prev</a><span>|</span><a href="#41875148">next</a><span>|</span><label class="collapse" for="c-41872973">[-]</label><label class="expand" for="c-41872973">[1 more]</label></div><br/><div class="children"><div class="content">This is one of those thing that is &quot;by philosophy&quot;, and I understand, i think, what you are saying.<p>I do think that tests should not explain the why, that would be leaking too much detail, but at the same time the why is somewhat the result of the test. A test is a documentation of a regression, not of how code it tests is implemented&#x2F;why.<p>The finite number of cases is interesting. You can definitely run single tests with a high number of inputs which of course is still finite but perhaps closer to a possible way of ensuring validity.</div><br/></div></div><div id="41875148" class="c"><input type="checkbox" id="c-41875148" checked=""/><div class="controls bullet"><span class="by">tmoertel</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41872973">prev</a><span>|</span><a href="#41874910">next</a><span>|</span><label class="collapse" for="c-41875148">[-]</label><label class="expand" for="c-41875148">[1 more]</label></div><br/><div class="children"><div class="content">In some cases, unit tests can both test and <i>specify</i> the semantics of the system being tested. My favorite example is the ReadP parsing library for Haskell. The source code ends with a short and automatically testable specification of the semantics of the combinators that make up the library. So, in this example, the tests tell you almost everything you need to know  about the library.<p><a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;ghc-internal-9.1001.0&#x2F;docs&#x2F;src&#x2F;GHC.Internal.Text.ParserCombinators.ReadP.html#readS_to_P" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;ghc-internal-9.1001.0&#x2F;do...</a></div><br/></div></div><div id="41874910" class="c"><input type="checkbox" id="c-41874910" checked=""/><div class="controls bullet"><span class="by">m000</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41875148">prev</a><span>|</span><a href="#41872470">next</a><span>|</span><label class="collapse" for="c-41874910">[-]</label><label class="expand" for="c-41874910">[1 more]</label></div><br/><div class="children"><div class="content">One - Why do you care how you got there? You need to read the code for that. But the tests do explain&#x2F;document how you can expect the test to work. If the code is unreadable, well that sucks. But you at least have a programmatic (and hopefully annotated) description of how the code is expected to work, so you have a stable base for rewritting it to be more clear.<p>Two - Ever heard of code coverage? Type systems&#x2F;type checkers? Also, there&#x27;s nothing precluding you from using assertions in the test that make any assumed relations explicit before you actually test anything.</div><br/></div></div><div id="41872470" class="c"><input type="checkbox" id="c-41872470" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41874910">prev</a><span>|</span><a href="#41873690">next</a><span>|</span><label class="collapse" for="c-41872470">[-]</label><label class="expand" for="c-41872470">[1 more]</label></div><br/><div class="children"><div class="content">Often, tests are parameterized over lists of cases such that you can document the general case near the code and document the specific cases near each parameter. I&#x27;ve even seen test frameworks that consume an excel spreadsheet provided by product so that the test results are literally a function of the requirements.<p>Would we prefer better docs than some comments sprinkled in strategic places in test files? Yes.  Is having them with the tests maybe the best we can do for a certain level of effort? Maybe.<p>If the alternative is an entirely standalone repository of docs which will probably not be up to date, I&#x27;ll take the comments near the tests. (Although I don&#x27;t think this approach lends itself to <i>unit</i> tests.)</div><br/></div></div><div id="41873690" class="c"><input type="checkbox" id="c-41873690" checked=""/><div class="controls bullet"><span class="by">lcall</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41872470">prev</a><span>|</span><a href="#41873888">next</a><span>|</span><label class="collapse" for="c-41873690">[-]</label><label class="expand" for="c-41873690">[1 more]</label></div><br/><div class="children"><div class="content">At least sometimes, it really helps for a test to say WHY it is done that way.  I had a case where I needed to change some existing code, and all the unit tests passed but one.  The author was unavailable.  It was very unclear whether I should change the test.  I asked around.  I was about to commit the changes to the code and test when someone came back from vacation and helpfully explained.  I hope I added a useful comment.</div><br/></div></div><div id="41873888" class="c"><input type="checkbox" id="c-41873888" checked=""/><div class="controls bullet"><span class="by">Etherlord87</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41873690">prev</a><span>|</span><a href="#41875681">next</a><span>|</span><label class="collapse" for="c-41873888">[-]</label><label class="expand" for="c-41873888">[1 more]</label></div><br/><div class="children"><div class="content">Documentation:<p>&gt; returns a sum of reciprocals of inputs<p>Unit Test:<p><pre><code>    assert_eq(foo(2, 5), 1&#x2F;2 + 1&#x2F;5)
    assert_eq(foo(4, 7), 1&#x2F;4 + 1&#x2F;7)
    assert_eq(foo(10, 100, 10000), 0.1101)</code></pre></div><br/></div></div><div id="41875681" class="c"><input type="checkbox" id="c-41875681" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41873888">prev</a><span>|</span><a href="#41876058">next</a><span>|</span><label class="collapse" for="c-41875681">[-]</label><label class="expand" for="c-41875681">[1 more]</label></div><br/><div class="children"><div class="content">Yes, actually. Sometimes the edge cases that <i>aren&#x27;t</i> covered by unit tests <i>are</i> undefined behavior. I don&#x27;t recommend doing this frequently but sometimes it&#x27;s hard to know the best way to handle weird edge cases until you gather more use cases so deliberately not writing a test for such things is a legit strategy IMO. You should probably also add to the method doc comment that invoking with X is not well defined.</div><br/></div></div><div id="41876058" class="c"><input type="checkbox" id="c-41876058" checked=""/><div class="controls bullet"><span class="by">the_af</span><span>|</span><a href="#41872163">parent</a><span>|</span><a href="#41875681">prev</a><span>|</span><a href="#41874566">next</a><span>|</span><label class="collapse" for="c-41876058">[-]</label><label class="expand" for="c-41876058">[1 more]</label></div><br/><div class="children"><div class="content">I think the line of thought behind the article is making the tests be like a &quot;living spec&quot;. Well written tests (especially those using things like QuickCheck, aka &quot;property testing&quot;) will cover more than simply a few edge cases. I don&#x27;t think many developers know how to write good test cases like this, though, so it becomes a perilous proposition.<p>Do note TFA doesn&#x27;t suggest replacing all other forms of documentation with just tests.</div><br/></div></div></div></div><div id="41871877" class="c"><input type="checkbox" id="c-41871877" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41872163">prev</a><span>|</span><a href="#41877238">next</a><span>|</span><label class="collapse" for="c-41871877">[-]</label><label class="expand" for="c-41871877">[2 more]</label></div><br/><div class="children"><div class="content">A trick I use a lot these days is to take the unit tests from an under-documented library, dump them into an LLM and ask it to write me detailed usage documentation.<p>This works REALLY well. I&#x27;ve even occasionally done some of my own reviewing and editing of those docs and submitted them back to the project. Here&#x27;s an example: <a href="https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;jiter&#x2F;pull&#x2F;143">https:&#x2F;&#x2F;github.com&#x2F;pydantic&#x2F;jiter&#x2F;pull&#x2F;143</a> - Claude transcript here: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;simonw&#x2F;264d487db1a18f8585c2ca0c68e50d1e" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;simonw&#x2F;264d487db1a18f8585c2ca0c68e50...</a></div><br/></div></div><div id="41877238" class="c"><input type="checkbox" id="c-41877238" checked=""/><div class="controls bullet"><span class="by">nissarup</span><span>|</span><a href="#41871877">prev</a><span>|</span><a href="#41872611">next</a><span>|</span><label class="collapse" for="c-41877238">[-]</label><label class="expand" for="c-41877238">[1 more]</label></div><br/><div class="children"><div class="content">For one narrow definition of documentation, yes.<p>I&#x27;m pretty sure our end-users would get no value out of reading the unit tests in the code of the application they are using.</div><br/></div></div><div id="41872611" class="c"><input type="checkbox" id="c-41872611" checked=""/><div class="controls bullet"><span class="by">benrutter</span><span>|</span><a href="#41877238">prev</a><span>|</span><a href="#41872995">next</a><span>|</span><label class="collapse" for="c-41872611">[-]</label><label class="expand" for="c-41872611">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard &quot;tests are documentation&quot; a lot, and even said it without thinkibg much myself. It sounds good, and I definitely like the <i>idea</i> of it, but I&#x27;m not sure it&#x27;s true. Here&#x27;s my thinking:<p>- I&#x27;ve never tried to understand a code base by looking at the tlunit tests first. They often require more in depth understanding (due to things like monkeypatching) than just reading the code. I haven&#x27;t seen anyone else attempt this either.<p>- Good documentation is good <i>as far as it aids understanding</i>. This might be a side effect of tests, but I don&#x27;t think it&#x27;s their goal. A good test will catch breaks in behaviour, I&#x27;d never trade completeness for readability in tests, in docs it&#x27;s the reverse.<p>So I think maybe, unit tests are just <i>tests</i>? They can be part of your documentation, but calling them documentation in and of themselves I think is maybe just a category error?</div><br/><div id="41877033" class="c"><input type="checkbox" id="c-41877033" checked=""/><div class="controls bullet"><span class="by">sixthDot</span><span>|</span><a href="#41872611">parent</a><span>|</span><a href="#41875780">next</a><span>|</span><label class="collapse" for="c-41877033">[-]</label><label class="expand" for="c-41877033">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Good documentation is good as far as it aids understanding. This might be a side effect of tests, but I don&#x27;t think it&#x27;s their goal. A good test will catch breaks in behaviour, I&#x27;d never trade completeness for readability in tests, in docs it&#x27;s the reverse.<p>The D language standard library uses both. When you generate the documentation from the comments attached to a declaration, the following unittests (they are identified using a special markup, (that is just triple slashes...) are also included.<p>Example once rendered [0], in the source you see the examples are actually unit tests [1].<p>[0]: <a href="https:&#x2F;&#x2F;dlang.org&#x2F;phobos&#x2F;std_algorithm_searching.html#.all" rel="nofollow">https:&#x2F;&#x2F;dlang.org&#x2F;phobos&#x2F;std_algorithm_searching.html#.all</a><p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;phobos&#x2F;blob&#x2F;master&#x2F;std&#x2F;algorithm&#x2F;searching.d#L112-L156">https:&#x2F;&#x2F;github.com&#x2F;dlang&#x2F;phobos&#x2F;blob&#x2F;master&#x2F;std&#x2F;algorithm&#x2F;se...</a></div><br/></div></div><div id="41875780" class="c"><input type="checkbox" id="c-41875780" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#41872611">parent</a><span>|</span><a href="#41877033">prev</a><span>|</span><a href="#41872995">next</a><span>|</span><label class="collapse" for="c-41875780">[-]</label><label class="expand" for="c-41875780">[1 more]</label></div><br/><div class="children"><div class="content">I definitely do look at tests to see examples of how library is meant to be used. But thats quite different</div><br/></div></div></div></div><div id="41872995" class="c"><input type="checkbox" id="c-41872995" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41872611">prev</a><span>|</span><a href="#41877300">next</a><span>|</span><label class="collapse" for="c-41872995">[-]</label><label class="expand" for="c-41872995">[3 more]</label></div><br/><div class="children"><div class="content">Nobody is mentioning this. Tests are for change over time, they are not just for testing the output is the same.<p>When you have a codebase sitting around rotting for years and you need to go back and refactor things to add a feature or change the behavior, how do you know you aren&#x27;t breaking some dependent code down the line?<p>What happens when you upgrade a 3rd party dependency, how do you know it isn&#x27;t breaking your code? The javascript ecosystem is rife with this. You can&#x27;t upgrade anything years later or you have to start over again.<p>Tests are especially important when you&#x27;ve quit your company and someone else is stuck maintaining your code. The only way they can be sure to have all your ingrained knowledge is to have some sort of reliable way of knowing when things break.<p>Tests are for preventing the next developer from cursing you under their breath.</div><br/><div id="41876009" class="c"><input type="checkbox" id="c-41876009" checked=""/><div class="controls bullet"><span class="by">luisgvv</span><span>|</span><a href="#41872995">parent</a><span>|</span><a href="#41877300">next</a><span>|</span><label class="collapse" for="c-41876009">[-]</label><label class="expand" for="c-41876009">[2 more]</label></div><br/><div class="children"><div class="content">I used to work for a company that was in the fintech space and had several scenarios and rules for deciding whether a person could apply for a loan, the interest rate, prime, insurance etc. A lot of the code written was way back from the early 2000s in Visual Basic and migrated improved towards C#.<p>I didn&#x27;t knew a thing about how the business operated and the rationale behind the loans and the transactions. The parts of the application that had unit and behavior tests were easy to work on. Everyone dreaded touching the old pieces that didn&#x27;t have tests.</div><br/><div id="41876438" class="c"><input type="checkbox" id="c-41876438" checked=""/><div class="controls bullet"><span class="by">latchkey</span><span>|</span><a href="#41872995">root</a><span>|</span><a href="#41876009">parent</a><span>|</span><a href="#41877300">next</a><span>|</span><label class="collapse" for="c-41876438">[-]</label><label class="expand" for="c-41876438">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve got a typescript react component library that integrates 3 different projects together. It gets 36k downloads on npm every month. I started the project 5 years ago.<p>When I originally wrote it, I knew that I would have to maintain it over time, so I wrote a ton of unit tests that mostly were just snapshots of the html output. I have two choices, running through my relatively complicated example app by hand and verifying things still work, or writing tests. I used this project to prove to myself that tests are indeed valuable.<p>Over the years, I&#x27;ve made many releases. The 3 projects have been independently upgraded over time. The only way that I would have kept any sanity and been motivated to even work on this project (I no longer even use it myself!), is the fact that it takes almost zero effort to upgrade the dependencies, run the tests and build a release.<p>If there are too many things to fix, I just wait for the community to eventually submit a PR. The best part is that if they break something, it is easy to spot in the snapshots (or test failures). I can almost accept PR&#x27;s without having to even read them, just because the tests pass. That&#x27;s pretty cool.</div><br/></div></div></div></div></div></div><div id="41877300" class="c"><input type="checkbox" id="c-41877300" checked=""/><div class="controls bullet"><span class="by">noobermin</span><span>|</span><a href="#41872995">prev</a><span>|</span><a href="#41877041">next</a><span>|</span><label class="collapse" for="c-41877300">[-]</label><label class="expand" for="c-41877300">[1 more]</label></div><br/><div class="children"><div class="content">This article is almost jumping the shark. It&#x27;s fine to say it&#x27;s in the constellation of things that help document code, but the end where you&#x27;re starting to limit the tests you can do to highlight an ideal, for example, the &quot;atomic&quot; bullet, that&#x27;s where you&#x27;re now doing things for ideology, not really for their utility. A similar thing occurred with function purity, etc, etc.<p>I don&#x27;t know who this helps but if you&#x27;re a young developer, always beware what you read on substack about how you should constrain yourself. Take them with a grain of salt.</div><br/></div></div><div id="41877041" class="c"><input type="checkbox" id="c-41877041" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#41877300">prev</a><span>|</span><a href="#41872507">next</a><span>|</span><label class="collapse" for="c-41877041">[-]</label><label class="expand" for="c-41877041">[1 more]</label></div><br/><div class="children"><div class="content">Tests and documentation are things that I&#x27;m increasingly using LLMs for. Writing exhaustive tests and documentation is somewhat tedious work. You do it to help others. Or if you are smart enough to realize it, your future self. But LLMs take the tedium away.<p>Example: I wrote a little fast api endpoint and realized that having some decent openapi documentation would be nice. Support for that is built in. So, copy paste into chat gpt, &quot;add openapi documentation to these endpoints&quot; paste it back. And then &quot;write me an integration test that exercises these endpoints and tests all the exceptional responses&quot;. Simple stuff. But the point is that the generated documentation is pretty good and helpful. It&#x27;s exhaustive. It documents all the essentials. I could sit down and do it manually for an hour. Or I could just generate it.<p>I also generated a README for the same project with instructions on how to setup all the tools and do all the key things (run tests, run a dev server, build a docker container, etc. The Dockerfile was generated too. Dockerfiles are also great as documentation artifacts because it precisely defines how to build and run your software.<p>LLMs are really good at documenting and summarizing things.</div><br/></div></div><div id="41872507" class="c"><input type="checkbox" id="c-41872507" checked=""/><div class="controls bullet"><span class="by">jaredcwhite</span><span>|</span><a href="#41877041">prev</a><span>|</span><a href="#41875095">next</a><span>|</span><label class="collapse" for="c-41872507">[-]</label><label class="expand" for="c-41872507">[5 more]</label></div><br/><div class="children"><div class="content">I very much disagree with this.<p>Good code can be documentation, both in the way it&#x27;s written and structured and obviously in the form of comments.<p>Good tests simply verify what the author of the test believes the behavior of what is being tested should be. That&#x27;s it. It&#x27;s not documentation, it rarely &quot;explains&quot; anything, and any time someone eschews actually writing documentation in the form of good code hygiene and actual docs in favor of just writing tests causes the codebase to suffer.</div><br/><div id="41874406" class="c"><input type="checkbox" id="c-41874406" checked=""/><div class="controls bullet"><span class="by">RangerScience</span><span>|</span><a href="#41872507">parent</a><span>|</span><a href="#41875095">next</a><span>|</span><label class="collapse" for="c-41874406">[-]</label><label class="expand" for="c-41874406">[4 more]</label></div><br/><div class="children"><div class="content">I disagree in a very specific and limited way: good tests show you how to <i>use</i> the code, which can be as simple as just “here’s some typical parameters for this function.”<p>In more complex situations, good tests also show you the environmental set up - for example, all the various odd database records the code needs or expects.<p>It’s not everything you’d want out of a doc, but it’s a chunk of it.</div><br/><div id="41875127" class="c"><input type="checkbox" id="c-41875127" checked=""/><div class="controls bullet"><span class="by">bluefirebrand</span><span>|</span><a href="#41872507">root</a><span>|</span><a href="#41874406">parent</a><span>|</span><a href="#41875744">next</a><span>|</span><label class="collapse" for="c-41875127">[-]</label><label class="expand" for="c-41875127">[2 more]</label></div><br/><div class="children"><div class="content">&gt; good tests show you how to use the code<p>If you can&#x27;t find examples of how to use the code <i>in the code</i> then why does the code even exist?</div><br/><div id="41875986" class="c"><input type="checkbox" id="c-41875986" checked=""/><div class="controls bullet"><span class="by">esafak</span><span>|</span><a href="#41872507">root</a><span>|</span><a href="#41875127">parent</a><span>|</span><a href="#41875744">next</a><span>|</span><label class="collapse" for="c-41875986">[-]</label><label class="expand" for="c-41875986">[1 more]</label></div><br/><div class="children"><div class="content">Code is not always meant to be run by strangers, if it&#x27;s internal to a team. The interface for customers should be documented.</div><br/></div></div></div></div><div id="41875744" class="c"><input type="checkbox" id="c-41875744" checked=""/><div class="controls bullet"><span class="by">invaderzirp</span><span>|</span><a href="#41872507">root</a><span>|</span><a href="#41874406">parent</a><span>|</span><a href="#41875127">prev</a><span>|</span><a href="#41875095">next</a><span>|</span><label class="collapse" for="c-41875744">[-]</label><label class="expand" for="c-41875744">[1 more]</label></div><br/><div class="children"><div class="content">Erm, this is what docs are for. Like a man page, where it&#x27;ll give you function signatures and return types and explain what those functions do. Unit tests are not that, and they shouldn&#x27;t be that, because that&#x27;s not their purpose.<p>New rule: if you write a function, you also have to write down what it does, and why. Deal?</div><br/></div></div></div></div></div></div><div id="41875095" class="c"><input type="checkbox" id="c-41875095" checked=""/><div class="controls bullet"><span class="by">hombre_fatal</span><span>|</span><a href="#41872507">prev</a><span>|</span><a href="#41872129">next</a><span>|</span><label class="collapse" for="c-41875095">[-]</label><label class="expand" for="c-41875095">[1 more]</label></div><br/><div class="children"><div class="content">I like how they couldn&#x27;t be bothered to show examples of this ideal unit test code they think is just as good as documentation, just like people who can&#x27;t be bothered to write docs.<p>In reality, except for the most trivial projects or vigilant test writers, tests are too complicated to act as a stand in for docs.<p>They are usually abstract in an effort to DRY things up such that you don&#x27;t even get to see all the API in one place.<p>I&#x27;d rather keep tests optimized for testing rather than nerfing them to be readable to end users.</div><br/></div></div><div id="41872129" class="c"><input type="checkbox" id="c-41872129" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#41875095">prev</a><span>|</span><a href="#41871879">next</a><span>|</span><label class="collapse" for="c-41872129">[-]</label><label class="expand" for="c-41872129">[9 more]</label></div><br/><div class="children"><div class="content">Why just unit tests? Integration tests seem much more valuable as documentation of what the users will do in the app. Unit tests have limited benefits overall, and add a bunch of support time, slowing down development. If you have good (90%+) coverage just from integration tests, you are likely doing 90%+ coverage of the unit tests at the same time, without the extra effort or support burden. You can use the same reasoning to describe the benefits for understanding the code, you get a clear understanding of the important usage cases, plus you get the unit-level &quot;documentation&quot; for free.</div><br/><div id="41876571" class="c"><input type="checkbox" id="c-41876571" checked=""/><div class="controls bullet"><span class="by">bni</span><span>|</span><a href="#41872129">parent</a><span>|</span><a href="#41872618">next</a><span>|</span><label class="collapse" for="c-41876571">[-]</label><label class="expand" for="c-41876571">[1 more]</label></div><br/><div class="children"><div class="content">I do Integrunit tests<p>Rules:
Cover a whole functionality, not just a single file&#x2F;class&#x2F;function.<p>Can&#x27;t use I&#x2F;O except reading in-codebase test-data files.<p>Must be fast.<p>Mock only external technical dependencies, not own code.</div><br/></div></div><div id="41872618" class="c"><input type="checkbox" id="c-41872618" checked=""/><div class="controls bullet"><span class="by">avensec</span><span>|</span><a href="#41872129">parent</a><span>|</span><a href="#41876571">prev</a><span>|</span><a href="#41872352">next</a><span>|</span><label class="collapse" for="c-41872618">[-]</label><label class="expand" for="c-41872618">[1 more]</label></div><br/><div class="children"><div class="content">Your point is valid, and some of the dialog in the replies to your comment is also valid. So, I&#x27;m just responding to the root of the dialog. What architectures are you working with that suggest higher integration test strategies?<p>I&#x27;d suggest that the balance between Unit Test(s) and Integration Test(s) is a trade-off and depends on the architecture&#x2F;shape of the System Under Test.<p>Example: I agree with your assertion that I can get &quot;90%+ coverage&quot; of Units at an integration test layer. However, the underlying system would suggest <i>if</i> I would guide my teams to follow this pattern. In my current stack, the number of faulty service boundaries means that, while an integration test will provide good coverage, the overhead of debugging the root cause of an integration failure creates a significant burden. So, I recommend more unit testing, as the failing behaviors can be identified directly.<p>And, if I were working at a company with better underlying architecture and service boundaries, I&#x27;d be pointing them toward a higher rate of integration testing.<p>So, re: Kent Dodds &quot;we write tests for confidence and understanding.&quot; What layer we write tests at for confidence and understanding really depends on the underlying architectures.</div><br/></div></div><div id="41872352" class="c"><input type="checkbox" id="c-41872352" checked=""/><div class="controls bullet"><span class="by">evil-olive</span><span>|</span><a href="#41872129">parent</a><span>|</span><a href="#41872618">prev</a><span>|</span><a href="#41872168">next</a><span>|</span><label class="collapse" for="c-41872352">[-]</label><label class="expand" for="c-41872352">[3 more]</label></div><br/><div class="children"><div class="content">unit vs integration tests is not an either&#x2F;or. you need both, and in appropriate coverage amounts.<p>a common way to think about this is called the &quot;test pyramid&quot; - unit tests at the base, supporting integration tests that are farther up the pyramid. [0]<p>roughly speaking, the X-axis of the pyramid is number of test cases, the Y-axis is number of dependencies &#x2F; things that can cause a test to fail.<p>as you travel up the Y-axis, you get more &quot;lifelike&quot; in your testing...but you also generally increase the time &amp; complexity it takes to find the root-cause of a test failure.<p>many times I&#x27;ve had to troubleshoot a failure in an integration test that is trying to test subsystem A, and it turns out the failure was caused by unrelated flakiness in subsystem B. it&#x27;s good to find that flakiness...but it&#x27;s also important to be able to push that testing &quot;down the pyramid&quot; and add a unit test of subsystem B to prevent the flakiness from reoccurring, and to point directly at the problem if it does.<p>&gt; Unit tests have limited benefits overall, and add a bunch of support time, slowing down development<p>unit tests, _when done poorly_, have limited benefits, require additional maintenance, and slow down development.<p>integration tests can also have limited benefits, require additional maintenance, and slow down development time, _when done poorly_.<p>testing in general, _when done well_, increases development velocity and improves product quality in a way that completely justifies the maintenance burden of the additional code.<p>0: <a href="https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;practical-test-pyramid.html" rel="nofollow">https:&#x2F;&#x2F;martinfowler.com&#x2F;articles&#x2F;practical-test-pyramid.htm...</a></div><br/><div id="41876521" class="c"><input type="checkbox" id="c-41876521" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41872129">root</a><span>|</span><a href="#41872352">parent</a><span>|</span><a href="#41872168">next</a><span>|</span><label class="collapse" for="c-41876521">[-]</label><label class="expand" for="c-41876521">[2 more]</label></div><br/><div class="children"><div class="content">&gt; unit vs integration tests is not an either&#x2F;or. you need both, and in appropriate coverage amounts.<p>Agreed. But I also agree with the commenter that for <i>documentation</i> purposes, integration tests are an order of magnitude more useful.<p>&gt; a common way to think about this is called the &quot;test pyramid&quot; - unit tests at the base, supporting integration tests that are farther up the pyramid.<p>I used to be a believer in that pyramid, but my experience has shown me it depends on the project. Wherever it&#x27;s feasible (i.e. doesn&#x27;t involve long test times), I&#x27;ve found integration tests to be far more useful than unit tests. I&#x27;ve had experiences where I&#x27;d do a project and have really high unit test coverage, only to unveil fairly trivial bugs. The reverse hasn&#x27;t happened - if I start a project with solid integration tests, I almost never encounter trivial bugs.<p>Generally, I now write integration tests and mock away time consuming&#x2F;resource heavy parts (e.g. network calls, DB calls, etc). Better for documentation. Better for testing.</div><br/><div id="41877339" class="c"><input type="checkbox" id="c-41877339" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41872129">root</a><span>|</span><a href="#41876521">parent</a><span>|</span><a href="#41872168">next</a><span>|</span><label class="collapse" for="c-41877339">[-]</label><label class="expand" for="c-41877339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; for documentation purposes, integration tests are an order of magnitude more useful.<p>Not just documentation purposes. In almost all cases integration is better than unit tests: they cover the same code paths, they actually test observed behaviour of the app, etc.<p>Notable exceptions: complex calculations, library functions.<p>&gt; I&#x27;ve found integration tests to be far more useful than unit tests. I&#x27;ve had experiences where I&#x27;d do a project and have really high unit test coverage, only to unveil fairly trivial bugs. The reverse hasn&#x27;t happened - if I start a project with solid integration tests, I almost never encounter trivial bugs.<p>If I could upvote this several times, I would :)</div><br/></div></div></div></div></div></div><div id="41872168" class="c"><input type="checkbox" id="c-41872168" checked=""/><div class="controls bullet"><span class="by">smrtinsert</span><span>|</span><a href="#41872129">parent</a><span>|</span><a href="#41872352">prev</a><span>|</span><a href="#41872167">next</a><span>|</span><label class="collapse" for="c-41872168">[-]</label><label class="expand" for="c-41872168">[2 more]</label></div><br/><div class="children"><div class="content">If you look for edge cases in integration tests, you will have a combinatorial explosion of integration tests and you will be adding much more work.  Unit tests save time, not lose it.<p>I make this part of my filtering potential companies to work with now.  I can&#x27;t believe how often people avoid doing unit tests.</div><br/><div id="41872237" class="c"><input type="checkbox" id="c-41872237" checked=""/><div class="controls bullet"><span class="by">danjl</span><span>|</span><a href="#41872129">root</a><span>|</span><a href="#41872168">parent</a><span>|</span><a href="#41872167">next</a><span>|</span><label class="collapse" for="c-41872237">[-]</label><label class="expand" for="c-41872237">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s funny, since I wouldn&#x27;t code at a place that mandates unit tests. Sure, they have a very minor role, in very specific cases, but I&#x27;d say 90% of projects can get 90% of the benefits by writing only integration tests with 90% coverage. If you&#x27;d like a more in-depth discussion of why integration testing is better: <a href="https:&#x2F;&#x2F;kentcdodds.com&#x2F;blog&#x2F;write-tests" rel="nofollow">https:&#x2F;&#x2F;kentcdodds.com&#x2F;blog&#x2F;write-tests</a></div><br/></div></div></div></div><div id="41872167" class="c"><input type="checkbox" id="c-41872167" checked=""/><div class="controls bullet"><span class="by">theLiminator</span><span>|</span><a href="#41872129">parent</a><span>|</span><a href="#41872168">prev</a><span>|</span><a href="#41871879">next</a><span>|</span><label class="collapse" for="c-41872167">[-]</label><label class="expand" for="c-41872167">[1 more]</label></div><br/><div class="children"><div class="content">I think unit testing if you&#x27;re testing in a blackbox manner. Whitebox unit testing tends to be very fragile and nowhere near as valuable as an integration test.</div><br/></div></div></div></div><div id="41871879" class="c"><input type="checkbox" id="c-41871879" checked=""/><div class="controls bullet"><span class="by">tln</span><span>|</span><a href="#41872129">prev</a><span>|</span><a href="#41872038">next</a><span>|</span><label class="collapse" for="c-41871879">[-]</label><label class="expand" for="c-41871879">[8 more]</label></div><br/><div class="children"><div class="content">Extracting unit tests from your docs: great!<p>Somehow extracting your docs from unit tests: might be ok!<p>Pointing people at unit tests instead of writing docs: not even remotely ok.<p>Is that really what this guy is advocating??</div><br/><div id="41872139" class="c"><input type="checkbox" id="c-41872139" checked=""/><div class="controls bullet"><span class="by">bluefirebrand</span><span>|</span><a href="#41871879">parent</a><span>|</span><a href="#41875354">next</a><span>|</span><label class="collapse" for="c-41872139">[-]</label><label class="expand" for="c-41872139">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Pointing people at unit tests instead of writing docs: not even remotely ok.<p>Couldn&#x27;t agree more<p>I&#x27;m trying to integrate with a team at work that is doing this, and I&#x27;m finding it impossible to get a full picture of what their service can do.<p>I&#x27;ve brought it up with my boss, their boss, nothing happens<p>And then the person writing the service is angry that everyone is asking him questions about it all the time. &quot;Just go read the tests! You&#x27;ll see what it does if you read the tests!&quot;<p>Incredibly frustrating to deal with when my questions are about the business rules for the service, not the functionality of the service</div><br/><div id="41873496" class="c"><input type="checkbox" id="c-41873496" checked=""/><div class="controls bullet"><span class="by">alphanumeric0</span><span>|</span><a href="#41871879">root</a><span>|</span><a href="#41872139">parent</a><span>|</span><a href="#41875354">next</a><span>|</span><label class="collapse" for="c-41873496">[-]</label><label class="expand" for="c-41873496">[4 more]</label></div><br/><div class="children"><div class="content">The code, tests and comments convey what actual business rules are implemented.<p>While documentation is someone&#x27;s non-precise natural language expression of what (to the best of their imperfect human capacity) expected the code to implement at the time of writing.</div><br/><div id="41873994" class="c"><input type="checkbox" id="c-41873994" checked=""/><div class="controls bullet"><span class="by">bluefirebrand</span><span>|</span><a href="#41871879">root</a><span>|</span><a href="#41873496">parent</a><span>|</span><a href="#41875753">next</a><span>|</span><label class="collapse" for="c-41873994">[-]</label><label class="expand" for="c-41873994">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it is absolutely more valuable to know what the code &quot;should&quot; be doing than to know what the code is doing<p>Otherwise there is no way to know what is expected behavior or just a mistake built into it by accident</div><br/><div id="41875761" class="c"><input type="checkbox" id="c-41875761" checked=""/><div class="controls bullet"><span class="by">invaderzirp</span><span>|</span><a href="#41871879">root</a><span>|</span><a href="#41873994">parent</a><span>|</span><a href="#41875753">next</a><span>|</span><label class="collapse" for="c-41875761">[-]</label><label class="expand" for="c-41875761">[1 more]</label></div><br/><div class="children"><div class="content">Especially on teams where deviance has been normalized, and broken things are just expected. I&#x27;ve been bitten both ways before: is this an obvious mistake? Or the lynchpin holding up the house of cards? Of course, if someone had just written some text explaining it, or perhaps a decent commit message instead of just &quot;WIP&quot;, maybe we wouldn&#x27;t have to do archaeology every single time.</div><br/></div></div></div></div><div id="41875753" class="c"><input type="checkbox" id="c-41875753" checked=""/><div class="controls bullet"><span class="by">invaderzirp</span><span>|</span><a href="#41871879">root</a><span>|</span><a href="#41873496">parent</a><span>|</span><a href="#41873994">prev</a><span>|</span><a href="#41875354">next</a><span>|</span><label class="collapse" for="c-41875753">[-]</label><label class="expand" for="c-41875753">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Oh yeah, those tests are always flaky. We just rerun them until they pass. Or we turn them off. I mean, Jeff wrote them like three years ago and he quit last year, so...&quot;<p>I&#x27;d rather have the prose. And if it&#x27;s wrong, then fix it. I&#x27;m so tired of these excuses.</div><br/></div></div></div></div></div></div><div id="41872279" class="c"><input type="checkbox" id="c-41872279" checked=""/><div class="controls bullet"><span class="by">teivah</span><span>|</span><a href="#41871879">parent</a><span>|</span><a href="#41875354">prev</a><span>|</span><a href="#41872038">next</a><span>|</span><label class="collapse" for="c-41872279">[-]</label><label class="expand" for="c-41872279">[1 more]</label></div><br/><div class="children"><div class="content">No, not replacing documentation is a way to enrich documentation. That being said, that should have been clearer; I will update it.<p>Thanks,
&quot;This guy&quot;</div><br/></div></div></div></div><div id="41872038" class="c"><input type="checkbox" id="c-41872038" checked=""/><div class="controls bullet"><span class="by">rglover</span><span>|</span><a href="#41871879">prev</a><span>|</span><a href="#41871656">next</a><span>|</span><label class="collapse" for="c-41872038">[-]</label><label class="expand" for="c-41872038">[14 more]</label></div><br/><div class="children"><div class="content">Just write the docs. A simple template:<p>- What is it?<p>- What does it do?<p>- Why does it do that?<p>- What is the API?<p>- What does it return?<p>- What are some examples of proper, real world usage (that don&#x27;t involve foo&#x2F;bar but instead, real world inputs&#x2F;outputs I&#x27;d likely see)?</div><br/><div id="41872141" class="c"><input type="checkbox" id="c-41872141" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41872038">parent</a><span>|</span><a href="#41873752">next</a><span>|</span><label class="collapse" for="c-41872141">[-]</label><label class="expand" for="c-41872141">[9 more]</label></div><br/><div class="children"><div class="content">I was going to say that unit tests have the benefit of breaking when the truth changes.<p>But then I realized that a lot of what makes a set of tests good documentation is comments, and those rot, maybe worse than dedicated documentation.<p>Keeping documentation up to date is a hard problem that I haven&#x27;t yet seen solved in my career.</div><br/><div id="41872241" class="c"><input type="checkbox" id="c-41872241" checked=""/><div class="controls bullet"><span class="by">rglover</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872141">parent</a><span>|</span><a href="#41872424">next</a><span>|</span><label class="collapse" for="c-41872241">[-]</label><label class="expand" for="c-41872241">[5 more]</label></div><br/><div class="children"><div class="content">The only fix for that is discipline. You can&#x27;t automate away quality. The best people&#x2F;teams understand that and make good docs a feature requirement, not an afterthought.<p>My favorite example is Stripe. They&#x27;ve never skimped on docs and you can tell they&#x27;ve made it a core competency requirement for their team.</div><br/><div id="41876506" class="c"><input type="checkbox" id="c-41876506" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872241">parent</a><span>|</span><a href="#41872469">next</a><span>|</span><label class="collapse" for="c-41876506">[-]</label><label class="expand" for="c-41876506">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The only fix for that is discipline.<p>The one lesson I have learned over my career: Don&#x27;t work in teams (or for managers) that rely on discipline to get things done. Every time I&#x27;ve encountered them, they&#x27;ve been using it as an excuse to avoid better processes.<p>Sure, some counterexamples exist. Chances are, those counterexamples aren&#x27;t where a given reader of your comment is working.</div><br/></div></div><div id="41872469" class="c"><input type="checkbox" id="c-41872469" checked=""/><div class="controls bullet"><span class="by">hitchdev</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872241">parent</a><span>|</span><a href="#41876506">prev</a><span>|</span><a href="#41872339">next</a><span>|</span><label class="collapse" for="c-41872469">[-]</label><label class="expand" for="c-41872469">[2 more]</label></div><br/><div class="children"><div class="content">I dont think it is about discipline. Discipline is required if you&#x27;re duplicating tedious work, not for creativity.<p>At its core, a good test will take an example and do something with it to demonstrate an outcome.<p>That&#x27;s exactly what how to docs do - often with the exact same examples.<p>Logically, they should be the same thing.<p>You just need a (non turing complete) language that is dual use - it generates docs and runs tests.<p>For example:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;crdoconnor&#x2F;strictyaml&#x2F;blob&#x2F;master&#x2F;hitch&#x2F;story&#x2F;email-url.story">https:&#x2F;&#x2F;github.com&#x2F;crdoconnor&#x2F;strictyaml&#x2F;blob&#x2F;master&#x2F;hitch&#x2F;s...</a><p>And:<p><a href="https:&#x2F;&#x2F;hitchdev.com&#x2F;strictyaml&#x2F;using&#x2F;alpha&#x2F;scalar&#x2F;email-and-url&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hitchdev.com&#x2F;strictyaml&#x2F;using&#x2F;alpha&#x2F;scalar&#x2F;email-and...</a></div><br/><div id="41875786" class="c"><input type="checkbox" id="c-41875786" checked=""/><div class="controls bullet"><span class="by">invaderzirp</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872469">parent</a><span>|</span><a href="#41872339">next</a><span>|</span><label class="collapse" for="c-41875786">[-]</label><label class="expand" for="c-41875786">[1 more]</label></div><br/><div class="children"><div class="content">No, you just need to both understand how your system works and then clearly write down what it&#x27;s doing and why. If projects like Postgres and SQLite and musl libc and the Linux kernel can all do it, I think the CRUD app authors can do it, too. But it&#x27;s not magic, and another tool won&#x27;t solve it (source: I&#x27;ve seen a hundred of these tools on scores of teams, and they don&#x27;t help when people have no clue what&#x27;s happening and then they don&#x27;t write anything down).</div><br/></div></div></div></div><div id="41872339" class="c"><input type="checkbox" id="c-41872339" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872241">parent</a><span>|</span><a href="#41872469">prev</a><span>|</span><a href="#41872424">next</a><span>|</span><label class="collapse" for="c-41872339">[-]</label><label class="expand" for="c-41872339">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if there&#x27;s some conservation law for &quot;concerted mental effort.&quot; As if by spending time and energy on the often exasperating task of keeping documentation relevant, you reduce the time and energy required to comprehend the system.<p>You&#x27;re right, it is a matter of culture and discipline. It&#x27;s much harder to maintain a consistent and legible theory of a software component than it is to wing it with your 1-2 other teammates. Naming things is hard, especially when the names and their meanings eventually change.</div><br/></div></div></div></div><div id="41872424" class="c"><input type="checkbox" id="c-41872424" checked=""/><div class="controls bullet"><span class="by">sbuttgereit</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872141">parent</a><span>|</span><a href="#41872241">prev</a><span>|</span><a href="#41874894">next</a><span>|</span><label class="collapse" for="c-41872424">[-]</label><label class="expand" for="c-41872424">[1 more]</label></div><br/><div class="children"><div class="content">Elixir&#x27;s documentation (ExDoc) &amp; unit testing framework (ExUnit) doesn&#x27;t solve this problem but provides a facility to ease it a bit.<p>In the documentation, you can include code examples that, if written a certain way, not only looks good when rendered but can also be tested for their form and documented outputs as well.  While this doesn&#x27;t help with the descriptive text of documentation, at least it can flag you when the documented examples are no longer valid... which can in turn capture your attention enough to check out the descriptive elements of that same area of documentation.<p>This isn&#x27;t to say these documentation tests are intended to replace regular unit tests: these documentation tests are really just testing what is easily testable to validate the documentation, the code examples.<p>Something can be better than nothing and I think that&#x27;s true here.</div><br/></div></div><div id="41874894" class="c"><input type="checkbox" id="c-41874894" checked=""/><div class="controls bullet"><span class="by">starkparker</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872141">parent</a><span>|</span><a href="#41872424">prev</a><span>|</span><a href="#41872394">next</a><span>|</span><label class="collapse" for="c-41874894">[-]</label><label class="expand" for="c-41874894">[1 more]</label></div><br/><div class="children"><div class="content">Not that this solves the hard problem, but there&#x27;s a simonw post for that: <a href="https:&#x2F;&#x2F;simonwillison.net&#x2F;2018&#x2F;Jul&#x2F;28&#x2F;documentation-unit-tests&#x2F;" rel="nofollow">https:&#x2F;&#x2F;simonwillison.net&#x2F;2018&#x2F;Jul&#x2F;28&#x2F;documentation-unit-tes...</a><p>Including screenshots, which a lot of tech writing teams raise as a maintenance burden: <a href="https:&#x2F;&#x2F;simonwillison.net&#x2F;2022&#x2F;Oct&#x2F;14&#x2F;automating-screenshots&#x2F;" rel="nofollow">https:&#x2F;&#x2F;simonwillison.net&#x2F;2022&#x2F;Oct&#x2F;14&#x2F;automating-screenshots...</a><p>Then there are tools like Doc Detective to inline tests in the docs, making them dependent on each other; if documented steps stop working, the test derived from them fails: <a href="https:&#x2F;&#x2F;doc-detective.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;doc-detective.com&#x2F;</a></div><br/></div></div><div id="41872394" class="c"><input type="checkbox" id="c-41872394" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872141">parent</a><span>|</span><a href="#41874894">prev</a><span>|</span><a href="#41873752">next</a><span>|</span><label class="collapse" for="c-41872394">[-]</label><label class="expand" for="c-41872394">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Keeping documentation up to date is a hard problem that I haven&#x27;t yet seen solved in my career.<p>Rust doctests. They unite documentation and unit test. Basically documentation that&#x27;s never so out of sync its assert fail.</div><br/></div></div></div></div><div id="41873752" class="c"><input type="checkbox" id="c-41873752" checked=""/><div class="controls bullet"><span class="by">alphanumeric0</span><span>|</span><a href="#41872038">parent</a><span>|</span><a href="#41872141">prev</a><span>|</span><a href="#41872068">next</a><span>|</span><label class="collapse" for="c-41873752">[-]</label><label class="expand" for="c-41873752">[1 more]</label></div><br/><div class="children"><div class="content">- What is it?
- What does it do?
- Why does it do that?<p>This could all easily fit in the top-level comments of a main() function or the help text of a CLI app.<p>- What is the API?<p>This could be gleaned from the code, either by reading it or by generating automatic documentation from it.<p>- What does it return?<p>This is commonly documented in function code.<p>- What are some examples of proper, real world usage (that don&#x27;t involve foo&#x2F;bar but instead, real world inputs&#x2F;outputs I&#x27;d likely see)?<p>This is typically in comments or help text if it&#x27;s a CLI app.</div><br/></div></div><div id="41872068" class="c"><input type="checkbox" id="c-41872068" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#41872038">parent</a><span>|</span><a href="#41873752">prev</a><span>|</span><a href="#41871656">next</a><span>|</span><label class="collapse" for="c-41872068">[-]</label><label class="expand" for="c-41872068">[3 more]</label></div><br/><div class="children"><div class="content">Why is a hard question.<p>And what should be obvious or it’s still too complex.</div><br/><div id="41872144" class="c"><input type="checkbox" id="c-41872144" checked=""/><div class="controls bullet"><span class="by">rglover</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872068">parent</a><span>|</span><a href="#41871656">next</a><span>|</span><label class="collapse" for="c-41872144">[-]</label><label class="expand" for="c-41872144">[2 more]</label></div><br/><div class="children"><div class="content">If why is hard it may not need to exist. For example:<p>&quot;This function exists to generate PDFs for reports and customer documents.&quot;<p>&quot;This endpoint exists to provide a means for pre-flight authorization of requests to other endpoints.&quot;</div><br/><div id="41872655" class="c"><input type="checkbox" id="c-41872655" checked=""/><div class="controls bullet"><span class="by">croes</span><span>|</span><a href="#41872038">root</a><span>|</span><a href="#41872144">parent</a><span>|</span><a href="#41871656">next</a><span>|</span><label class="collapse" for="c-41872655">[-]</label><label class="expand" for="c-41872655">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t that the same as the what?</div><br/></div></div></div></div></div></div></div></div><div id="41871656" class="c"><input type="checkbox" id="c-41871656" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#41872038">prev</a><span>|</span><a href="#41871864">next</a><span>|</span><label class="collapse" for="c-41871656">[-]</label><label class="expand" for="c-41871656">[2 more]</label></div><br/><div class="children"><div class="content">Actually every example in the documentation should be backed by a unit test, as in the example is transcluded from the unit test into the docs. Since you often want to show examples that don’t compile in docs you also should be able to write tests for compile errors.</div><br/><div id="41871925" class="c"><input type="checkbox" id="c-41871925" checked=""/><div class="controls bullet"><span class="by">red2awn</span><span>|</span><a href="#41871656">parent</a><span>|</span><a href="#41871864">next</a><span>|</span><label class="collapse" for="c-41871925">[-]</label><label class="expand" for="c-41871925">[1 more]</label></div><br/><div class="children"><div class="content">Better yet, use doc test as featured in Python [1] or Rust [2]. This makes sure your documentation examples are always up-to-date and runnable.<p>[1]: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;doctest.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;doctest.html</a><p>[2]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustdoc&#x2F;write-documentation&#x2F;documentation-tests.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustdoc&#x2F;write-documentation&#x2F;docume...</a></div><br/></div></div></div></div><div id="41871864" class="c"><input type="checkbox" id="c-41871864" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#41871656">prev</a><span>|</span><a href="#41871957">next</a><span>|</span><label class="collapse" for="c-41871864">[-]</label><label class="expand" for="c-41871864">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests are a _kind_ of documentation, but are rarely a complete solution to &quot;documenting code&quot;. In general, the folks who don&#x27;t do adequate code documentation are the same folks who don&#x27;t do adequate unit tests. :&#x2F;</div><br/></div></div><div id="41871957" class="c"><input type="checkbox" id="c-41871957" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#41871864">prev</a><span>|</span><a href="#41874409">next</a><span>|</span><label class="collapse" for="c-41871957">[-]</label><label class="expand" for="c-41871957">[2 more]</label></div><br/><div class="children"><div class="content">Is this &quot;article&quot; written by a LLM?<p>&quot;Tomorrow, you will receive your weekly recap on unit tests.&quot;<p>Please, no.</div><br/><div id="41872205" class="c"><input type="checkbox" id="c-41872205" checked=""/><div class="controls bullet"><span class="by">teivah</span><span>|</span><a href="#41871957">parent</a><span>|</span><a href="#41874409">next</a><span>|</span><label class="collapse" for="c-41872205">[-]</label><label class="expand" for="c-41872205">[1 more]</label></div><br/><div class="children"><div class="content">As the post&#x27;s author, no, it&#x27;s not written by an LLM.<p>The Coder Cafe is a daily newsletter for coders; we go over different topics from Monday to Thursday, and on Friday, there&#x27;s a recap ;)</div><br/></div></div></div></div><div id="41874409" class="c"><input type="checkbox" id="c-41874409" checked=""/><div class="controls bullet"><span class="by">janalsncm</span><span>|</span><a href="#41871957">prev</a><span>|</span><a href="#41875719">next</a><span>|</span><label class="collapse" for="c-41874409">[-]</label><label class="expand" for="c-41874409">[1 more]</label></div><br/><div class="children"><div class="content">Code and tests tell you <i>what</i>. They don’t tell you <i>why</i>. And if there’s a bug not covered in the tests, neither code nor tests can help you figure that out.</div><br/></div></div><div id="41875719" class="c"><input type="checkbox" id="c-41875719" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#41874409">prev</a><span>|</span><a href="#41877372">next</a><span>|</span><label class="collapse" for="c-41875719">[-]</label><label class="expand" for="c-41875719">[1 more]</label></div><br/><div class="children"><div class="content">Okay, I&#x27;ll go with it: statically defined types are also documentation!<p>And the method names are equivalent to the test names. Of course, only if you don&#x27;t wildly throw around exceptions or return null (without indicating it clearly in the type signature).</div><br/></div></div><div id="41877372" class="c"><input type="checkbox" id="c-41877372" checked=""/><div class="controls bullet"><span class="by">player1234</span><span>|</span><a href="#41875719">prev</a><span>|</span><a href="#41871919">next</a><span>|</span><label class="collapse" for="c-41877372">[-]</label><label class="expand" for="c-41877372">[1 more]</label></div><br/><div class="children"><div class="content">Just read the code.</div><br/></div></div><div id="41871919" class="c"><input type="checkbox" id="c-41871919" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41877372">prev</a><span>|</span><a href="#41874992">next</a><span>|</span><label class="collapse" for="c-41871919">[-]</label><label class="expand" for="c-41871919">[2 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t at all a new idea, but it&#x27;s the first time I&#x27;ve seen it presented with this textbook AI style.</div><br/><div id="41872252" class="c"><input type="checkbox" id="c-41872252" checked=""/><div class="controls bullet"><span class="by">teivah</span><span>|</span><a href="#41871919">parent</a><span>|</span><a href="#41874992">next</a><span>|</span><label class="collapse" for="c-41872252">[-]</label><label class="expand" for="c-41872252">[1 more]</label></div><br/><div class="children"><div class="content">Is there something problematic you think about the style? It&#x27;s a genuine question.<p>I wrote a book, and when I created my newsletter, I wanted to have a shift in terms of style because, on the Internet, people don&#x27;t have time. You can&#x27;t write a post the same way you write a book. So, I&#x27;m following some principles taken here and there. But happy to hear if you have some feedback about the style itself :)</div><br/></div></div></div></div><div id="41874992" class="c"><input type="checkbox" id="c-41874992" checked=""/><div class="controls bullet"><span class="by">ssalka</span><span>|</span><a href="#41871919">prev</a><span>|</span><a href="#41872436">next</a><span>|</span><label class="collapse" for="c-41874992">[-]</label><label class="expand" for="c-41874992">[1 more]</label></div><br/><div class="children"><div class="content">I forget where I heard this, but early in my career someone described unit tests to me as &quot;a contract between you and your code.&quot; Which seems largely true – when I write a test, I&#x27;m saying &quot;this is how a given function should behave, and that contract should hold true over time.&quot; If my future self wants the code to behave differently, so be it, but the contract needs to be amended so that the new code changes are also in agreement with it.<p>Conversely, if you fail to write a unit test, there is no contract, and the code can freely diverge over time from what you think it ought to be doing.</div><br/></div></div><div id="41872436" class="c"><input type="checkbox" id="c-41872436" checked=""/><div class="controls bullet"><span class="by">kubectl_h</span><span>|</span><a href="#41874992">prev</a><span>|</span><a href="#41875397">next</a><span>|</span><label class="collapse" for="c-41872436">[-]</label><label class="expand" for="c-41872436">[3 more]</label></div><br/><div class="children"><div class="content">I am starting to notice more and more unit tests in my org are written by AI -- I&#x27;m guessing usually after the implementation. I know this because I have, guiltily, done it and can tell when someone else has done it as well. I don&#x27;t think anything can be done about this technically so it probably needs to be something discussed socially within the team.</div><br/><div id="41872516" class="c"><input type="checkbox" id="c-41872516" checked=""/><div class="controls bullet"><span class="by">_thisdot</span><span>|</span><a href="#41872436">parent</a><span>|</span><a href="#41875397">next</a><span>|</span><label class="collapse" for="c-41872516">[-]</label><label class="expand" for="c-41872516">[2 more]</label></div><br/><div class="children"><div class="content">What is wrong with this? Tests involve a lot of hardcoding and mocking. I see this as an excellent use case for AI.</div><br/><div id="41872801" class="c"><input type="checkbox" id="c-41872801" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#41872436">root</a><span>|</span><a href="#41872516">parent</a><span>|</span><a href="#41875397">next</a><span>|</span><label class="collapse" for="c-41872801">[-]</label><label class="expand" for="c-41872801">[1 more]</label></div><br/><div class="children"><div class="content">Generating tests that match the implementation doesn&#x27;t tell you the implementation is doing the right thing. If it isn&#x27;t, changing the implementation will break the tests, which in the best case wastes time and in the worst means the bugfix is abandoned.<p>I deeply hate &quot;regression tests&quot; that turn red when the implementation changes, so you regenerate the tests to match the new implementation and maybe glance at the diff, but the diff is thousands of lines long so really it&#x27;s not telling you anything other than &quot;something changed&quot;.</div><br/></div></div></div></div></div></div><div id="41875397" class="c"><input type="checkbox" id="c-41875397" checked=""/><div class="controls bullet"><span class="by">1980phipsi</span><span>|</span><a href="#41872436">prev</a><span>|</span><a href="#41875674">next</a><span>|</span><label class="collapse" for="c-41875397">[-]</label><label class="expand" for="c-41875397">[1 more]</label></div><br/><div class="children"><div class="content">D has documented unit tests.<p><a href="https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;unittest.html#documented-unittests" rel="nofollow">https:&#x2F;&#x2F;dlang.org&#x2F;spec&#x2F;unittest.html#documented-unittests</a><p>Nice when combined with CI since you’ll know if you accidentally break your examples.</div><br/></div></div><div id="41875674" class="c"><input type="checkbox" id="c-41875674" checked=""/><div class="controls bullet"><span class="by">youainti</span><span>|</span><a href="#41875397">prev</a><span>|</span><a href="#41875013">next</a><span>|</span><label class="collapse" for="c-41875674">[-]</label><label class="expand" for="c-41875674">[1 more]</label></div><br/><div class="children"><div class="content">Something I&#x27;ve been thinking of is that unit tests may now become useful as examples to be input into LLMs. If each function has a couple of tests with appropriate documentation, that may be useful as RAG input.</div><br/></div></div><div id="41875013" class="c"><input type="checkbox" id="c-41875013" checked=""/><div class="controls bullet"><span class="by">hannasm</span><span>|</span><a href="#41875674">prev</a><span>|</span><a href="#41875202">next</a><span>|</span><label class="collapse" for="c-41875013">[-]</label><label class="expand" for="c-41875013">[2 more]</label></div><br/><div class="children"><div class="content">I like the idea of this article but I would say that  it&#x27;s actually integration tests that are documentation.<p>When learning a new codebase, and I&#x27;m looking for an example of how to use feature X I would look in the tests first 
or shortly after a web search.<p>It seems to me like the second half of this article  also undermines the main idea and goal of using unit tests in this way though.<p><pre><code>  &gt; Descriptive test name, Atomic, Keep tests simple, Keep tests independent
</code></pre>
A unit test that is good at documenting the system needs to be comprehensive, clear and in many cases filled with complexity that a unit test would ignore or hide.<p>A test with a bunch of mocks, helpers, overrides and assumptions does not help anyone understand things like how to use feature X or the correct way to solve a problem with the software.<p>There are merits to both kinds of tests in their time and place but good integration tests are really the best ones for documenting and learning.</div><br/><div id="41876063" class="c"><input type="checkbox" id="c-41876063" checked=""/><div class="controls bullet"><span class="by">Terretta</span><span>|</span><a href="#41875013">parent</a><span>|</span><a href="#41875202">next</a><span>|</span><label class="collapse" for="c-41876063">[-]</label><label class="expand" for="c-41876063">[1 more]</label></div><br/><div class="children"><div class="content">Executable documentation:<p>Hitchstory is a type-safe StrictYAML python integration testing framework exploring some interesting ideas around this.<p><a href="https:&#x2F;&#x2F;hitchdev.com&#x2F;hitchstory&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hitchdev.com&#x2F;hitchstory&#x2F;</a><p>Example:<p><a href="https:&#x2F;&#x2F;hitchdev.com&#x2F;hitchstory&#x2F;using&#x2F;behavior&#x2F;run-single-named-story&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hitchdev.com&#x2F;hitchstory&#x2F;using&#x2F;behavior&#x2F;run-single-na...</a><p>Source:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;hitchdev&#x2F;hitchstory&#x2F;blob&#x2F;master&#x2F;hitch&#x2F;story&#x2F;success.story">https:&#x2F;&#x2F;github.com&#x2F;hitchdev&#x2F;hitchstory&#x2F;blob&#x2F;master&#x2F;hitch&#x2F;sto...</a><p>See also the explanation of self-rewriting tests:<p><a href="https:&#x2F;&#x2F;hitchdev.com&#x2F;hitchstory&#x2F;why&#x2F;rewrite&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hitchdev.com&#x2F;hitchstory&#x2F;why&#x2F;rewrite&#x2F;</a></div><br/></div></div></div></div><div id="41875202" class="c"><input type="checkbox" id="c-41875202" checked=""/><div class="controls bullet"><span class="by">exabrial</span><span>|</span><a href="#41875013">prev</a><span>|</span><a href="#41872109">next</a><span>|</span><label class="collapse" for="c-41875202">[-]</label><label class="expand" for="c-41875202">[1 more]</label></div><br/><div class="children"><div class="content">If you want to see how to do this right, go look at the CDI specification for Java.<p>Every statement in the spec has a corresponding unit test, and it’s unbelievably incredible. Hats of to everyone that worked on this.</div><br/></div></div><div id="41872109" class="c"><input type="checkbox" id="c-41872109" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#41875202">prev</a><span>|</span><a href="#41873005">next</a><span>|</span><label class="collapse" for="c-41872109">[-]</label><label class="expand" for="c-41872109">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests as documentation have proven their worth over the years.<p>For example this recent feature was added through unit test as documentation.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Attumm&#x2F;redis-dict&#x2F;blob&#x2F;main&#x2F;extend_types_tests.py">https:&#x2F;&#x2F;github.com&#x2F;Attumm&#x2F;redis-dict&#x2F;blob&#x2F;main&#x2F;extend_types_...</a></div><br/></div></div><div id="41873005" class="c"><input type="checkbox" id="c-41873005" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#41872109">prev</a><span>|</span><a href="#41874611">next</a><span>|</span><label class="collapse" for="c-41873005">[-]</label><label class="expand" for="c-41873005">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests is documentation of assertions. Hence it documents the result of how the code results to specification.<p>It&#x27;s of course not documentation in the sense of a manual to the detail of code it exercises, but it definitely helps if tests are proper crafted.</div><br/></div></div><div id="41874611" class="c"><input type="checkbox" id="c-41874611" checked=""/><div class="controls bullet"><span class="by">tqi</span><span>|</span><a href="#41873005">prev</a><span>|</span><a href="#41872164">next</a><span>|</span><label class="collapse" for="c-41874611">[-]</label><label class="expand" for="c-41874611">[1 more]</label></div><br/><div class="children"><div class="content">Without further documentation (beyond a descriptive test name), I fear that unit tests inevitably become a kind of Chesterton&#x27;s Fence...</div><br/></div></div><div id="41872164" class="c"><input type="checkbox" id="c-41872164" checked=""/><div class="controls bullet"><span class="by">kbbgl87</span><span>|</span><a href="#41874611">prev</a><span>|</span><label class="collapse" for="c-41872164">[-]</label><label class="expand" for="c-41872164">[1 more]</label></div><br/><div class="children"><div class="content">I believe that doctest is the best of both worlds, <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;doctest.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;doctest.html</a></div><br/></div></div></div></div></div></div></div></body></html>