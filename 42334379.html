<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733475653505" as="style"/><link rel="stylesheet" href="styles.css?v=1733475653505"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://litdb.dev/">Litdb – type safe SQL for JavaScript/TS</a> <span class="domain">(<a href="https://litdb.dev">litdb.dev</a>)</span></div><div class="subtext"><span>crummy</span> | <span>52 comments</span></div><br/><div><div id="42335088" class="c"><input type="checkbox" id="c-42335088" checked=""/><div class="controls bullet"><span class="by">nathas</span><span>|</span><a href="#42336213">next</a><span>|</span><label class="collapse" for="c-42335088">[-]</label><label class="expand" for="c-42335088">[2 more]</label></div><br/><div class="children"><div class="content">Hmmm I&#x27;ve recently been evaluating <a href="https:&#x2F;&#x2F;www.kysely.dev" rel="nofollow">https:&#x2F;&#x2F;www.kysely.dev</a> after finding that Prisma can&#x27;t support foreign data warehousing (FDW) with Postgres.<p>I don&#x27;t really know enough about Kysely yet to make an informed opinion between those two. If you know more than me, can you give me your take??<p>Edit: Hmmm perhaps based on the primary author&#x27;s other repos (<a href="https:&#x2F;&#x2F;github.com&#x2F;mythz">https:&#x2F;&#x2F;github.com&#x2F;mythz</a>) it looks like they&#x27;re a fan of C#. Perhaps it&#x27;s the LINQ-like syntax that separates them the most.</div><br/><div id="42335368" class="c"><input type="checkbox" id="c-42335368" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335088">parent</a><span>|</span><a href="#42336213">next</a><span>|</span><label class="collapse" for="c-42335368">[-]</label><label class="expand" for="c-42335368">[1 more]</label></div><br/><div class="children"><div class="content">Right, it&#x27;s effectively a spiritual port of our C# LINQ OrmLite library [1].<p>I&#x27;ve been using a lot of bun:sqlite [2] lately which has an amazing DX and lets you create lots of stand-alone .ts scripts (i.e. without deps) to access SQLite DB&#x27;s. The only issue is that I didn&#x27;t want all my SQL queries to be coupled to a single driver, so I created litdb to provide a RDBMS-agnostic API + Query Builders so all my queries could easily be run on different DBs.<p>TypeScript has an amazingly powerful type system which let me build the ideal abstraction I wanted where I could use expressive SQL Expressions but still have typed references to our App&#x27;s classes (tables) &#x2F; properties (columns) to benefit from static analysis&#x2F;intelli-sense during development whilst making it safe to refactor &#x2F; find references &#x2F; etc.<p>Things that are hard&#x2F;impossible in C# is easy in TypeScript, e.g. the QueryBuilders lets you have a variable number of generic args which isn&#x27;t possible in C# also it was much easier to support composable queries [3] than trying to combine multiple LINQ queries with shared references.<p>[1] <a href="https:&#x2F;&#x2F;docs.servicestack.net&#x2F;ormlite&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.servicestack.net&#x2F;ormlite&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;bun.sh&#x2F;docs&#x2F;api&#x2F;sqlite" rel="nofollow">https:&#x2F;&#x2F;bun.sh&#x2F;docs&#x2F;api&#x2F;sqlite</a><p>[3] <a href="https:&#x2F;&#x2F;litdb.dev&#x2F;#composable" rel="nofollow">https:&#x2F;&#x2F;litdb.dev&#x2F;#composable</a></div><br/></div></div></div></div><div id="42336213" class="c"><input type="checkbox" id="c-42336213" checked=""/><div class="controls bullet"><span class="by">jeswin</span><span>|</span><a href="#42335088">prev</a><span>|</span><a href="#42334812">next</a><span>|</span><label class="collapse" for="c-42336213">[-]</label><label class="expand" for="c-42336213">[8 more]</label></div><br/><div class="children"><div class="content">This looks great.<p>But in my view there&#x27;s still some scope for improvement in expressive-ness (compared to something like LINQ). A future area of exploration could be to add a parser to the mix, so that we can write:<p><pre><code>  const jane = db.contacts.one(c =&gt; c.email === janeEmail);
</code></pre>
instead of:<p><pre><code>  const jane = db.one&lt;Contact&gt;($.from(Contact).where(c =&gt; $`${c.email} = ${janeEmail}`))!
</code></pre>
The former is so naturally typesafe, without having to resort to advanced typescript tricks. I got half way there [1], before dropping the project due to work pressure (but many years back, so the code is quite stale).  Parsers were viable with caching back then. These days, performance is not going to be problem whatever you do. If anyone is interested, happy to exchange notes.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;isotropy&#x2F;isotropy-db&#x2F;blob&#x2F;master&#x2F;src&#x2F;test&#x2F;test.ts">https:&#x2F;&#x2F;github.com&#x2F;isotropy&#x2F;isotropy-db&#x2F;blob&#x2F;master&#x2F;src&#x2F;test...</a></div><br/><div id="42336418" class="c"><input type="checkbox" id="c-42336418" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42336213">parent</a><span>|</span><a href="#42336444">next</a><span>|</span><label class="collapse" for="c-42336418">[-]</label><label class="expand" for="c-42336418">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an intentional decision that drivers are decoupled from the Application and query builder it executes, i.e. all driver APIs provide different ways of executing SQL + Params or a function that returns SQL + Params (Query Builder). This allows drivers to remain flexible to executing (non-litdb) SQL&#x2F;Params or Query builders from a different library.<p>Your proposed API would require augmenting the driver with an application schema which would couple drivers to both litdb implementations and an application&#x27;s schema where it would no longer be suitable for querying outside of your Application schema. Also not a fan of global Application schemas, i.e. litdb classes are self encapsulating so you could create a class at runtime and execute it without having to register it with a global application schema.<p>With that said you could implement a similar API to what you want with something like:<p><pre><code>    class AppDb {
      constructor(public $:ReturnType&lt;typeof Sql.create&gt;) {}
      contacts() { return this.$.from(Contact) }
    }
    const app = new AppDb($)
</code></pre>
Which you could then use like:<p><pre><code>    db.one(app.contacts.where(c =&gt; $`${c.email} = ${janeEmail}`))
</code></pre>
I also prefer APIs to be SQL-like (i.e. instead of inventing a custom object model) where APIs and Typed Query Builders designed around SQL so it&#x27;s intuitive how to construct queries and what SQL a query would execute. At the moment there&#x27;s a clear separation of Query Builders which generates SQL + Params and the drivers which just executes them.<p>BTW you don&#x27;t need the generic type if you only have &quot;1 table without a custom select&quot;, i.e. this will implicitly return a Contact instance:<p><pre><code>    const jane = db.one($.from(Contact).where(c =&gt; $`${c.email} = ${janeEmail}`))
</code></pre>
Specifying `one&lt;Contact&gt;` generic type is similar to `as Contact` inert type hint, i.e. it informs TS what the shape of the returned object is but doesn&#x27;t change behavior, it&#x27;s preferable to use `.into(Contact)` which explicitly returns a `Contact` instance.<p><pre><code>    const jane = db.one($.from(Contact).where(c =&gt; $`${c.email} = ${janeEmail}`).into(Contact))</code></pre></div><br/><div id="42336500" class="c"><input type="checkbox" id="c-42336500" checked=""/><div class="controls bullet"><span class="by">jeswin</span><span>|</span><a href="#42336213">root</a><span>|</span><a href="#42336418">parent</a><span>|</span><a href="#42336444">next</a><span>|</span><label class="collapse" for="c-42336500">[-]</label><label class="expand" for="c-42336500">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s an intentional decision that drivers are decoupled from the Application and query builder it executes, i.e. all driver APIs provide different ways of executing SQL + Params or a function that returns SQL + Params (Query Builder). This allows drivers to flexible to exec (non-litdb) SQL&#x2F;Params or Query builders from a different library.<p>But my suggestion doesn&#x27;t couple the driver and the Application&#x2F;query builder. Here&#x27;s a simplified example.<p><pre><code>  const db = {
    &#x2F;&#x2F; table() is a factory that returns (for example) PostgresTable 
    &#x2F;&#x2F; or MySQLTable or even MongoTable based on config
    customers: table() 
  }
</code></pre>
This has some other interesting properties - for example, you could stub these tables with pure JS lists for tests. The broad applicability of this approach has been proven to work by EF being the defacto DB access method in the .Net world (over 15 years now).</div><br/><div id="42336536" class="c"><input type="checkbox" id="c-42336536" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42336213">root</a><span>|</span><a href="#42336500">parent</a><span>|</span><a href="#42336444">next</a><span>|</span><label class="collapse" for="c-42336536">[-]</label><label class="expand" for="c-42336536">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The broad applicability of this approach has been proven to work by EF being the defacto DB access method in the .Net work (over 15 years now).<p>It&#x27;s only the defacto DB access method in .NET because that&#x27;s what Microsoft&#x27;s EF library chose and .NET ecosystem just uses the default MS option but EF&#x27;s influence doesn&#x27;t extend outside of .NET. AFAIK no other .NET ORM does this including our .NET ORM [1] which litdb is the spiritual port of.<p>[1] <a href="https:&#x2F;&#x2F;docs.servicestack.net&#x2F;ormlite&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.servicestack.net&#x2F;ormlite&#x2F;</a></div><br/><div id="42336584" class="c"><input type="checkbox" id="c-42336584" checked=""/><div class="controls bullet"><span class="by">jeswin</span><span>|</span><a href="#42336213">root</a><span>|</span><a href="#42336536">parent</a><span>|</span><a href="#42336444">next</a><span>|</span><label class="collapse" for="c-42336584">[-]</label><label class="expand" for="c-42336584">[1 more]</label></div><br/><div class="children"><div class="content">The approach has more to do with C# the language, and the Code-as-Data principles it explored and executed well. I had seen various ORMs starting from the early 2000s (Hibernate etc), and when C# added Code-as-Data into the mix my jaw dropped. Like a bit of Lisp in a mainstream language, with mainstream applicability.<p>Nothing wrong with your approach, I was just arguing that language-native query patterns (such as customers.filter(c =&gt; c.country === &quot;Chile&quot;)) can be  appealing. And at the same time, reachable with current JS&#x2F;TS tooling.<p>But like you said, it may not be the direction litdb wants to go.</div><br/></div></div></div></div></div></div></div></div><div id="42336444" class="c"><input type="checkbox" id="c-42336444" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#42336213">parent</a><span>|</span><a href="#42336418">prev</a><span>|</span><a href="#42334812">next</a><span>|</span><label class="collapse" for="c-42336444">[-]</label><label class="expand" for="c-42336444">[3 more]</label></div><br/><div class="children"><div class="content">That won&#x27;t be possible without a lot of work. You&#x27;ll need to tweak the TypeScript compiler to make the parser comprehend exported variables.<p>For example,<p><pre><code>  import { contacts } from &quot;db&quot;
  const jane = contacts.one(c =&gt; c.email === janeEmail)
</code></pre>
Marco-like magic can be confusing, as we learned from Svelte. Especially when it&#x27;s half-baked like the one you are suggesting.<p>Another drawback is that you&#x27;ll need to compile the code twice to run it: once with the custom parser and once with the TypeScript compiler.</div><br/><div id="42336532" class="c"><input type="checkbox" id="c-42336532" checked=""/><div class="controls bullet"><span class="by">jeswin</span><span>|</span><a href="#42336213">root</a><span>|</span><a href="#42336444">parent</a><span>|</span><a href="#42334812">next</a><span>|</span><label class="collapse" for="c-42336532">[-]</label><label class="expand" for="c-42336532">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Marco-like magic can be confusing, as we learned from Svelte. Especially when it&#x27;s half-baked like the one you are suggesting.<p>When I&#x27;m giving examples on a forum thread, I try to provide one that&#x27;s simpler to understand and captures the essence of the argument. I am not making any claims on completeness.<p>&gt; Marco-like magic can be confusing, as we learned from Svelte. Especially when it&#x27;s half-baked like the one you are suggesting.<p>Svelte invents new syntax, which in my view isn&#x27;t great. This is pure JS, and it could even run in a browser against arrays (for tables).<p>Add:<p>&gt; That won&#x27;t be possible without a lot of work. You&#x27;ll need to tweak the TypeScript compiler to make the parser comprehend exported variables.<p>Not required. I was suggesting that the expression could be parsed at runtime. There are various options, with different tradeoffs.</div><br/><div id="42336932" class="c"><input type="checkbox" id="c-42336932" checked=""/><div class="controls bullet"><span class="by">maxloh</span><span>|</span><a href="#42336213">root</a><span>|</span><a href="#42336532">parent</a><span>|</span><a href="#42334812">next</a><span>|</span><label class="collapse" for="c-42336932">[-]</label><label class="expand" for="c-42336932">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Not required. I was suggesting that the expression could be parsed at runtime. There are various options, with different tradeoffs.<p>Good idea. That might be possible, though not every JavaScript runtime implements Function.prototype.toString. I&#x27;m not sure if Node does.<p><pre><code>  const aFunction = arg =&gt; arg.a === arg.b
  
  const aFunctionSrc = aFunction.toString()
  console.log(aFunctionSrc) &#x2F;&#x2F; &#x27;arg =&gt; arg.a === arg.b&#x27;

  const transformedFunctionSrc = transform(aFunctionSrc)
  const transformedFunction = new Function(transformedFunctionSrc)
  console.log(transformedFunction) &#x2F;&#x2F; [Function: anonymous]
  
  &#x2F;&#x2F; Cache the transformed function in a WeakMap
  &#x2F;&#x2F; WeakMap values are garbage collected when their keys are garbage collected
  const functionMap = new WeakMap()
  functionMap.set(aFunction, transformedFunction)
  console.log(functionMap.get(aFunction)) &#x2F;&#x2F; [Function: anonymous]</code></pre></div><br/></div></div></div></div></div></div></div></div><div id="42334812" class="c"><input type="checkbox" id="c-42334812" checked=""/><div class="controls bullet"><span class="by">valenterry</span><span>|</span><a href="#42336213">prev</a><span>|</span><a href="#42335271">next</a><span>|</span><label class="collapse" for="c-42334812">[-]</label><label class="expand" for="c-42334812">[2 more]</label></div><br/><div class="children"><div class="content">I like it. First glance and they chose the &quot;proper&quot; order (from -&gt; where -&gt; select) over the classical order (select -&gt; from -&gt; where). Probably because that improves&#x2F;enables autocomplete and typehandling. This is good</div><br/><div id="42335361" class="c"><input type="checkbox" id="c-42335361" checked=""/><div class="controls bullet"><span class="by">aethr</span><span>|</span><a href="#42334812">parent</a><span>|</span><a href="#42335271">next</a><span>|</span><label class="collapse" for="c-42335361">[-]</label><label class="expand" for="c-42335361">[1 more]</label></div><br/><div class="children"><div class="content">Using (from -&gt; where -&gt; select), how would you provide type hints on the where clause when your select includes non-table columns?<p><pre><code>  SELECT
    COUNT(col_a) as count
  WHERE
    count &gt; 0
 </code></pre>
Kysely uses (from -&gt; select -&gt; where), and allows joins and selects in multiple places, like (from -&gt; join -&gt; select -&gt; join -&gt; select -&gt; where).</div><br/></div></div></div></div><div id="42335271" class="c"><input type="checkbox" id="c-42335271" checked=""/><div class="controls bullet"><span class="by">aethr</span><span>|</span><a href="#42334812">prev</a><span>|</span><a href="#42337543">next</a><span>|</span><label class="collapse" for="c-42335271">[-]</label><label class="expand" for="c-42335271">[5 more]</label></div><br/><div class="children"><div class="content">Having recently been down this journey with kysely, these type-safe query builders still seem to have a large gap when it comes to the return types of SQL functions and opaque types.<p>My current project uses PostGIS which uses opaque types for storing geometry. Geometry columns are added to tables via a function instead of traditional alter table syntax, and select&#x2F;where clauses on geometry columns need to use PostGIS functions to render the column into useable data.<p>Unless a system like Litdb includes an easy way to provide type definitions for function return types, it won&#x27;t be usable with an extension like PostGIS without heavy use of escape hatches, at which point most of the value is lost.</div><br/><div id="42335753" class="c"><input type="checkbox" id="c-42335753" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335271">parent</a><span>|</span><a href="#42337543">next</a><span>|</span><label class="collapse" for="c-42335753">[-]</label><label class="expand" for="c-42335753">[4 more]</label></div><br/><div class="children"><div class="content">litdb does include support for registering TypeConverters for mapping custom RDBMS types [1]. The drivers doesn&#x27;t include any converters for custom RDBMS-specific types yet, but you should be able to register your own in your App or even better submit a PR to the postgres driver [2] so it&#x27;ll work OOB (tho it&#x27;ll be dependent on whatever postgres.js can be configured to support).<p>[1] <a href="https:&#x2F;&#x2F;litdb.dev&#x2F;customize#type-converters" rel="nofollow">https:&#x2F;&#x2F;litdb.dev&#x2F;customize#type-converters</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;litdb&#x2F;postgres">https:&#x2F;&#x2F;github.com&#x2F;litdb&#x2F;postgres</a></div><br/><div id="42335928" class="c"><input type="checkbox" id="c-42335928" checked=""/><div class="controls bullet"><span class="by">aethr</span><span>|</span><a href="#42335271">root</a><span>|</span><a href="#42335753">parent</a><span>|</span><a href="#42337543">next</a><span>|</span><label class="collapse" for="c-42335928">[-]</label><label class="expand" for="c-42335928">[3 more]</label></div><br/><div class="children"><div class="content">Correct me if I&#x27;m misunderstanding, but this would allow me to register the desired conversion type for a basic postgres type, to and from JavaScript but not for the return value of a specific function or even a specific invocation of a function.<p>PostGIS uses a lot of functions like ST_AsEWKT, ST_AsMVT or ST_AsGeoJSON [1] to marshal data. While ST_AsGeoJSON will always return &quot;text&quot;, ideally you&#x27;d want an invocation of ST_AsGeoJSON to return JSON to your JavaScript, but this wouldn&#x27;t be true of all &quot;text&quot;.<p>Even better, you would want to declare the structure of the returned JSON via a TypeScript type. GeoJSON is a structured format, so this would likely be a generic GeoJSON type wrapped around a custom type for the specific structure you expect for each geometry type &#x2F; query.<p>Anyway, it&#x27;s a tough problem to solve without introducing TS versions of each specialty function, which would be a large effort for an extension the size of PostGIS. For now I use typed raw queries via the sql&lt;T&gt;`` escape hatch provided by kysely, but if your library made this more ergonomic&#x2F;safe I&#x27;d consider switching!<p>[1] <a href="https:&#x2F;&#x2F;postgis.net&#x2F;docs&#x2F;manual-3.5&#x2F;ST_AsGeoJSON.html" rel="nofollow">https:&#x2F;&#x2F;postgis.net&#x2F;docs&#x2F;manual-3.5&#x2F;ST_AsGeoJSON.html</a></div><br/><div id="42336760" class="c"><input type="checkbox" id="c-42336760" checked=""/><div class="controls bullet"><span class="by">retropragma</span><span>|</span><a href="#42335271">root</a><span>|</span><a href="#42335928">parent</a><span>|</span><a href="#42336267">next</a><span>|</span><label class="collapse" for="c-42336760">[-]</label><label class="expand" for="c-42336760">[1 more]</label></div><br/><div class="children"><div class="content">Hey, I&#x27;m developing a different approach that may appeal to a Kysely user such as yourself. I&#x27;d be glad to get your thoughts on it :)<p>Raw SQL (or PL&#x2F;pgSQL which can be quite powerful) with generated, type-safe client &quot;bindings&quot; (TypeScript functions). It also includes &quot;declarative SQL schema&quot; (instantly update the schema of your dev DB on file save). Generated migrations and &quot;seed scripts&quot; are also on the roadmap.<p>If any of that interests you, check it out (<a href="https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano">https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano</a>). I would also be happy to discuss it with you on Discord (@aleclarson).</div><br/></div></div><div id="42336267" class="c"><input type="checkbox" id="c-42336267" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335271">root</a><span>|</span><a href="#42335928">parent</a><span>|</span><a href="#42336760">prev</a><span>|</span><a href="#42337543">next</a><span>|</span><label class="collapse" for="c-42336267">[-]</label><label class="expand" for="c-42336267">[1 more]</label></div><br/><div class="children"><div class="content">Type Converters lets you change the parameter value that&#x27;s executed with the underlying provider (postgres driver uses postgres.js [1]) and what value is converted from the provider&#x27;s resultset to your class property. So it would be up to whether the underlying provider can be configured to support the custom RDBMS type. If you leave a feature request [2] I can let you know when it&#x27;s implemented or it&#x27;s not possible with postgres.js when I get around to it.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;porsager&#x2F;postgres">https:&#x2F;&#x2F;github.com&#x2F;porsager&#x2F;postgres</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;litdb&#x2F;litdb&#x2F;discussions&#x2F;categories&#x2F;ideas">https:&#x2F;&#x2F;github.com&#x2F;litdb&#x2F;litdb&#x2F;discussions&#x2F;categories&#x2F;ideas</a></div><br/></div></div></div></div></div></div></div></div><div id="42337543" class="c"><input type="checkbox" id="c-42337543" checked=""/><div class="controls bullet"><span class="by">gmac</span><span>|</span><a href="#42335271">prev</a><span>|</span><a href="#42335009">next</a><span>|</span><label class="collapse" for="c-42337543">[-]</label><label class="expand" for="c-42337543">[1 more]</label></div><br/><div class="children"><div class="content">With similar goals (but Postgres-only): <a href="https:&#x2F;&#x2F;jawj.github.io&#x2F;zapatos&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jawj.github.io&#x2F;zapatos&#x2F;</a></div><br/></div></div><div id="42335009" class="c"><input type="checkbox" id="c-42335009" checked=""/><div class="controls bullet"><span class="by">rohan_</span><span>|</span><a href="#42337543">prev</a><span>|</span><a href="#42334960">next</a><span>|</span><label class="collapse" for="c-42335009">[-]</label><label class="expand" for="c-42335009">[4 more]</label></div><br/><div class="children"><div class="content">Seems very similar to [drizzle](<a href="https:&#x2F;&#x2F;orm.drizzle.team&#x2F;" rel="nofollow">https:&#x2F;&#x2F;orm.drizzle.team&#x2F;</a>) - although drizzle is a more mature product.</div><br/><div id="42335068" class="c"><input type="checkbox" id="c-42335068" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335009">parent</a><span>|</span><a href="#42334960">next</a><span>|</span><label class="collapse" for="c-42335068">[-]</label><label class="expand" for="c-42335068">[3 more]</label></div><br/><div class="children"><div class="content">From Drizzle&#x27;s SQL-like example [1] by following classical SQL and including .select() first it wont to be able to provide type-safe queries. E.g. In litdb every from&#x2F;join returns a new typed query builder where every reference is typed to a joined table that&#x27;s included in the query.<p>Drizzle also uses its own custom query language e.g.<p><pre><code>    .where(eq(countries.id, 10))
</code></pre>
Whereas litdb lets you use the full expressiveness of SQL but ensures all references are typed:<p><pre><code>    .where(c =&gt; $`${c.id} = 10`)
</code></pre>
[1] <a href="https:&#x2F;&#x2F;orm.drizzle.team&#x2F;docs&#x2F;overview" rel="nofollow">https:&#x2F;&#x2F;orm.drizzle.team&#x2F;docs&#x2F;overview</a></div><br/><div id="42336896" class="c"><input type="checkbox" id="c-42336896" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#42335009">root</a><span>|</span><a href="#42335068">parent</a><span>|</span><a href="#42334960">next</a><span>|</span><label class="collapse" for="c-42336896">[-]</label><label class="expand" for="c-42336896">[2 more]</label></div><br/><div class="children"><div class="content">Does using template strings not compromise with type-safety? The drizzle example will be a compile time error for example if id wasn&#x27;t a numeric column.<p>Seems a strange design choice for a library that claims to offer a type-safe sql builder.</div><br/><div id="42337026" class="c"><input type="checkbox" id="c-42337026" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335009">root</a><span>|</span><a href="#42336896">parent</a><span>|</span><a href="#42334960">next</a><span>|</span><label class="collapse" for="c-42337026">[-]</label><label class="expand" for="c-42337026">[1 more]</label></div><br/><div class="children"><div class="content">Right the SQL expression is validating that you&#x27;re referencing tables that are included in the query and that all column references exist, not that the parameter value matches the property type, although SQLite and MySQL <i>does</i> allow you to use a string to query an int column, e.g:<p><pre><code>    SELECT * from Contact where id = &#x27;1&#x27;
</code></pre>
With that said you can achieve something similar in litdb with a custom expression:<p><pre><code>    const eq = &lt;T,V&gt;(ref:(x:T)=&gt;V, value:V) =&gt; (x:T) =&gt; $`${ref(x)} = ${value}`
</code></pre>
Which will type check that the value matches the column type:<p><pre><code>    .where(eq(c =&gt; c.id, 2))
</code></pre>
and fail type check when they don&#x27;t:<p><pre><code>    .where(eq(c =&gt; c.id, &#x27;2&#x27;))
</code></pre>
Examples of other custom expressions: <a href="https:&#x2F;&#x2F;litdb.dev&#x2F;#composable" rel="nofollow">https:&#x2F;&#x2F;litdb.dev&#x2F;#composable</a></div><br/></div></div></div></div></div></div></div></div><div id="42334960" class="c"><input type="checkbox" id="c-42334960" checked=""/><div class="controls bullet"><span class="by">hresvelgr</span><span>|</span><a href="#42335009">prev</a><span>|</span><a href="#42334977">next</a><span>|</span><label class="collapse" for="c-42334960">[-]</label><label class="expand" for="c-42334960">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure a lot of effort went into this, but I would rather raw dog my database layer with node-postgres&#x2F;postgres.js and zod. The decorator heavy implementation is visually very busy. Also, I would not consider any SQL toolkit for serious use unless it comes with a sufficiently competent code generation accompaniment.</div><br/><div id="42336699" class="c"><input type="checkbox" id="c-42336699" checked=""/><div class="controls bullet"><span class="by">retropragma</span><span>|</span><a href="#42334960">parent</a><span>|</span><a href="#42335151">next</a><span>|</span><label class="collapse" for="c-42336699">[-]</label><label class="expand" for="c-42336699">[1 more]</label></div><br/><div class="children"><div class="content">Manual type declarations are error prone, tedious, and subject to drift. Meanwhile, query builders are clumsy and sometimes limiting or buggy, so I don&#x27;t blame you for betting on raw SQL.<p>I&#x27;m building a middle ground of sorts. Raw SQL (or PL&#x2F;pgSQL which can be quite powerful) with generated, type-safe client &quot;bindings&quot; (TypeScript functions). It also includes &quot;declarative SQL schema&quot; (instantly update the schema of your dev DB on file save). Generated migrations and &quot;seed scripts&quot; are also on the roadmap.<p>If any of that interests you, check it out (<a href="https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano">https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano</a>). I would also love to discuss it with whoever&#x27;s reading this on Discord (@aleclarson).</div><br/></div></div><div id="42335151" class="c"><input type="checkbox" id="c-42335151" checked=""/><div class="controls bullet"><span class="by">plopz</span><span>|</span><a href="#42334960">parent</a><span>|</span><a href="#42336699">prev</a><span>|</span><a href="#42334977">next</a><span>|</span><label class="collapse" for="c-42335151">[-]</label><label class="expand" for="c-42335151">[5 more]</label></div><br/><div class="children"><div class="content">My feelings are similar and I cringe every time I see a &quot;typesafe&quot; db interface that doesn&#x27;t run time validate the data.</div><br/><div id="42336199" class="c"><input type="checkbox" id="c-42336199" checked=""/><div class="controls bullet"><span class="by">bluepnume</span><span>|</span><a href="#42334960">root</a><span>|</span><a href="#42335151">parent</a><span>|</span><a href="#42335728">next</a><span>|</span><label class="collapse" for="c-42336199">[-]</label><label class="expand" for="c-42336199">[1 more]</label></div><br/><div class="children"><div class="content">Runtime validate at the database boundary? Isn&#x27;t it better to just do runtime validation at the api boundary instead? Then any of the types that make it into the database should be mostly guaranteed by TS (and of course, whatever types are enforced by the database schema itself).</div><br/></div></div><div id="42335728" class="c"><input type="checkbox" id="c-42335728" checked=""/><div class="controls bullet"><span class="by">jadbox</span><span>|</span><a href="#42334960">root</a><span>|</span><a href="#42335151">parent</a><span>|</span><a href="#42336199">prev</a><span>|</span><a href="#42335414">next</a><span>|</span><label class="collapse" for="c-42335728">[-]</label><label class="expand" for="c-42335728">[1 more]</label></div><br/><div class="children"><div class="content">What do you use for runtime? I&#x27;ve used pgtyped in the past and it does a good job at taking raw SQL and generating the return types from runtime:
<a href="https:&#x2F;&#x2F;github.com&#x2F;adelsz&#x2F;pgtyped">https:&#x2F;&#x2F;github.com&#x2F;adelsz&#x2F;pgtyped</a></div><br/></div></div><div id="42335414" class="c"><input type="checkbox" id="c-42335414" checked=""/><div class="controls bullet"><span class="by">lerp-io</span><span>|</span><a href="#42334960">root</a><span>|</span><a href="#42335151">parent</a><span>|</span><a href="#42335728">prev</a><span>|</span><a href="#42334977">next</a><span>|</span><label class="collapse" for="c-42335414">[-]</label><label class="expand" for="c-42335414">[2 more]</label></div><br/><div class="children"><div class="content">typescript people want types on everything cuz it feels good that way.</div><br/><div id="42336805" class="c"><input type="checkbox" id="c-42336805" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#42334960">root</a><span>|</span><a href="#42335414">parent</a><span>|</span><a href="#42334977">next</a><span>|</span><label class="collapse" for="c-42336805">[-]</label><label class="expand" for="c-42336805">[1 more]</label></div><br/><div class="children"><div class="content">Also it allows AI tools in IDEs like Cursor to work a lot more effectivley because they can leverage type&#x2F;lint errors to make sure suggestions are correct on the first try.</div><br/></div></div></div></div></div></div></div></div><div id="42334977" class="c"><input type="checkbox" id="c-42334977" checked=""/><div class="controls bullet"><span class="by">kevlened</span><span>|</span><a href="#42334960">prev</a><span>|</span><a href="#42335549">next</a><span>|</span><label class="collapse" for="c-42334977">[-]</label><label class="expand" for="c-42334977">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really curious to see new DX for the problem of &quot;type-safe queries with intellisense&quot;. Litdb provides SQL-like syntax, but it feels like knowing actual SQL should be enough.<p>If the problem is seen as an editor or build-time problem, rather than a library one, you don&#x27;t have to learn anything new, and you can save the weight in your dependencies.<p>A fusion of ts-safeql [0] and postgres_lsp [1] is the closest I&#x27;ve seen to solving this as an editor&#x2F;build problem.<p>[0] - <a href="https:&#x2F;&#x2F;github.com&#x2F;ts-safeql&#x2F;safeql">https:&#x2F;&#x2F;github.com&#x2F;ts-safeql&#x2F;safeql</a><p>[1] - <a href="https:&#x2F;&#x2F;github.com&#x2F;supabase-community&#x2F;postgres_lsp">https:&#x2F;&#x2F;github.com&#x2F;supabase-community&#x2F;postgres_lsp</a></div><br/><div id="42335019" class="c"><input type="checkbox" id="c-42335019" checked=""/><div class="controls bullet"><span class="by">nikeee</span><span>|</span><a href="#42334977">parent</a><span>|</span><a href="#42335549">next</a><span>|</span><label class="collapse" for="c-42335019">[-]</label><label class="expand" for="c-42335019">[1 more]</label></div><br/><div class="children"><div class="content">I played around with parsing and inferring SQL on a type level. Simple stuff works, but as soon as you have a DB-specific dialect, it becomes hard. Parsing is already hard enough, but type inference on a type level is just not maintainable on the long run.<p>You can find it here:
<a href="https:&#x2F;&#x2F;github.com&#x2F;nikeee&#x2F;sequelts">https:&#x2F;&#x2F;github.com&#x2F;nikeee&#x2F;sequelts</a></div><br/></div></div></div></div><div id="42335549" class="c"><input type="checkbox" id="c-42335549" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#42334977">prev</a><span>|</span><a href="#42335994">next</a><span>|</span><label class="collapse" for="c-42335549">[-]</label><label class="expand" for="c-42335549">[6 more]</label></div><br/><div class="children"><div class="content">It seems like a step back to have to write SQL in Javascript syntax with a non-standard API.<p>You can use real SQL and get type-safety just using typescript’s “… as MyType”. Of course it blows up if the database doesn’t match up, but so does this, I think. (Yes, you may want some mechanisms to validate the data has the expected form.)</div><br/><div id="42335677" class="c"><input type="checkbox" id="c-42335677" checked=""/><div class="controls bullet"><span class="by">aethr</span><span>|</span><a href="#42335549">parent</a><span>|</span><a href="#42336796">next</a><span>|</span><label class="collapse" for="c-42335677">[-]</label><label class="expand" for="c-42335677">[3 more]</label></div><br/><div class="children"><div class="content">Using `as` in TypeScript is a dangerous practice, since it sidesteps the entire type safety system. If it has to be used, it should be used minimally, in controlled circumstances. Using a system like this allows your types to be specified in a very small surface for re-use. If they have to be changed, they can be changed in one place (the schema) which will cause type warnings to flow out if there are any problems.<p>Futhermore, a lot of the value of these systems is to provide type safety <i>within the query</i>. You choose a typed column in your select clause, and then in your join or where clause the column type is inferred, and warns you if you attempt a comparison that doesn&#x27;t work with that type.<p>If the purpose of TypeScript is to add type safety to your logic, why wouldn&#x27;t you want type safety in the logic that happens to be database queries? I haven&#x27;t used this library but have used kysely which seems very similar, and all the benefits I enjoy from TypeScript, I now enjoy in my SQL.<p>&gt; It seems like a step back to have to write SQL in Javascript syntax with a non-standard API.<p>Like TypeScript, this is an attempt to add type safety and hinting to an untyped language: SQL. With that in mind, some compromises seem inevitable.</div><br/><div id="42335801" class="c"><input type="checkbox" id="c-42335801" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#42335549">root</a><span>|</span><a href="#42335677">parent</a><span>|</span><a href="#42336796">next</a><span>|</span><label class="collapse" for="c-42335801">[-]</label><label class="expand" for="c-42335801">[2 more]</label></div><br/><div class="children"><div class="content">&gt; …why wouldn&#x27;t you want type safety in the logic that happens to be database queries?<p>The problem is you’re writing queries in Litdb’s Javascript&#x2F;typescript-based query language instead of SQL, but the types it provides still aren’t real — you need to ensure they match the data some other way, just like with “as”.<p>What the types here really accomplish is code-completion. That’s nice but there are ways to do that without giving up real SQL. Not to mention databases have their own type systems, which differ from each other and typescript. Maybe they nail all the mapping, but I suspect their are misses (probably by not allowing valid things, since typescript is generally more strict that dbms’s).</div><br/><div id="42336072" class="c"><input type="checkbox" id="c-42336072" checked=""/><div class="controls bullet"><span class="by">aethr</span><span>|</span><a href="#42335549">root</a><span>|</span><a href="#42335801">parent</a><span>|</span><a href="#42336796">next</a><span>|</span><label class="collapse" for="c-42336072">[-]</label><label class="expand" for="c-42336072">[1 more]</label></div><br/><div class="children"><div class="content">Systems like litdb typically include (or work alongside) a schema migration tool, which either reads the current structure of the database and writes that back to a TypeScript file, or reads a TypeScript&#x2F;schema file and generates a migration to update the database to match the schema. I haven&#x27;t seen one that works perfectly, and it&#x27;s up to you to keep it up to date, but as I said it shrinks the surface of where &quot;mistypes&quot; can occur.<p>It&#x27;s quite similar to working with a web API. You can invent all the types you want, maybe generated from an OpenAPI schema, but if the server sends something different, TypeScript can&#x27;t help you. That&#x27;s not what TypeScript is for.<p>At the end of the day, most non-scalar TypeScript types &quot;aren&#x27;t real&quot;. Objects can be mutated at runtime, libraries can ship incorrect types, TS can be mixed with JS, etc. We try to introduce types as early as possible to catch a wide swath of possible errors, but where it&#x27;s really important you still need to verify at runtime.</div><br/></div></div></div></div></div></div><div id="42336796" class="c"><input type="checkbox" id="c-42336796" checked=""/><div class="controls bullet"><span class="by">retropragma</span><span>|</span><a href="#42335549">parent</a><span>|</span><a href="#42335677">prev</a><span>|</span><a href="#42335588">next</a><span>|</span><label class="collapse" for="c-42336796">[-]</label><label class="expand" for="c-42336796">[1 more]</label></div><br/><div class="children"><div class="content">You sound like someone who might be intrigued about what I&#x27;m building.<p>Raw SQL (or PL&#x2F;pgSQL which can be quite powerful) with generated, type-safe client &quot;bindings&quot; (TypeScript functions). It also includes &quot;declarative SQL schema&quot; (instantly update the schema of your dev DB on file save). Generated migrations and &quot;seed scripts&quot; are also on the roadmap.<p>If any of that interests you, check it out (<a href="https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano">https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano</a>). I would also love to discuss it with whoever&#x27;s reading this on Discord (@aleclarson).</div><br/></div></div><div id="42335588" class="c"><input type="checkbox" id="c-42335588" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335549">parent</a><span>|</span><a href="#42336796">prev</a><span>|</span><a href="#42335994">next</a><span>|</span><label class="collapse" for="c-42335588">[-]</label><label class="expand" for="c-42335588">[1 more]</label></div><br/><div class="children"><div class="content">If you try to reference a property that doesn&#x27;t exist in litdb you first get an intelli-sense error at dev time &#x2F; compile error at build time and a runtime validation error at runtime that prevents the query from being executed.<p>The idea is that your App models represents your database&#x27;s schema which your App&#x27;s logic is bound to. You can also use litdb schema APIs [1] to create your database tables so that they&#x27;re in sync.<p>[1] <a href="https:&#x2F;&#x2F;litdb.dev&#x2F;schema" rel="nofollow">https:&#x2F;&#x2F;litdb.dev&#x2F;schema</a></div><br/></div></div></div></div><div id="42335994" class="c"><input type="checkbox" id="c-42335994" checked=""/><div class="controls bullet"><span class="by">ZYbCRq22HbJ2y7</span><span>|</span><a href="#42335549">prev</a><span>|</span><a href="#42335675">next</a><span>|</span><label class="collapse" for="c-42335994">[-]</label><label class="expand" for="c-42335994">[6 more]</label></div><br/><div class="children"><div class="content">I sort of see the value here, but isn&#x27;t SQL already mostly &quot;type safe&quot;? Isn&#x27;t following a repository pattern or something sufficient to ensure this behavior?<p>My IDE already cries from how slow tsc &#x2F; the ts language server is.</div><br/><div id="42336052" class="c"><input type="checkbox" id="c-42336052" checked=""/><div class="controls bullet"><span class="by">0x6c6f6c</span><span>|</span><a href="#42335994">parent</a><span>|</span><a href="#42335675">next</a><span>|</span><label class="collapse" for="c-42336052">[-]</label><label class="expand" for="c-42336052">[5 more]</label></div><br/><div class="children"><div class="content">Your repository return type may say what it returns, but how would you statically prove the structure of the raw SQL string? Most of the detection today is at runtime perhaps building a class or validating the data.</div><br/><div id="42336970" class="c"><input type="checkbox" id="c-42336970" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42335994">root</a><span>|</span><a href="#42336052">parent</a><span>|</span><a href="#42336108">next</a><span>|</span><label class="collapse" for="c-42336970">[-]</label><label class="expand" for="c-42336970">[1 more]</label></div><br/><div class="children"><div class="content">You can take the raw SQL string and pass it--at compile time, treating the database itself as part of the product you are linking against (and it doesn&#x27;t have to be the full production one: it can be a local one built from the artifacts in the repository)--to the database server along with the types of the input placeholders and it should be able to tell you the types of the output columns in the result set. I&#x27;ve implemented this before as a macro for Clojure and it was a godsend.</div><br/></div></div><div id="42336108" class="c"><input type="checkbox" id="c-42336108" checked=""/><div class="controls bullet"><span class="by">ZYbCRq22HbJ2y7</span><span>|</span><a href="#42335994">root</a><span>|</span><a href="#42336052">parent</a><span>|</span><a href="#42336970">prev</a><span>|</span><a href="#42335675">next</a><span>|</span><label class="collapse" for="c-42336108">[-]</label><label class="expand" for="c-42336108">[3 more]</label></div><br/><div class="children"><div class="content">With tests? Or just a schema definition?</div><br/><div id="42336140" class="c"><input type="checkbox" id="c-42336140" checked=""/><div class="controls bullet"><span class="by">0x6c6f6c</span><span>|</span><a href="#42335994">root</a><span>|</span><a href="#42336108">parent</a><span>|</span><a href="#42335675">next</a><span>|</span><label class="collapse" for="c-42336140">[-]</label><label class="expand" for="c-42336140">[2 more]</label></div><br/><div class="children"><div class="content">Tests are a type of runtime validation, they require literal execution of your code to perform the validation.<p>This supports static verification of queries, your code doesn&#x27;t need to run to validate the type is correct.<p>I don&#x27;t care to argue either way for tests vs static types (I write both frankly), just want the distinction to be clear.</div><br/></div></div></div></div></div></div></div></div><div id="42335675" class="c"><input type="checkbox" id="c-42335675" checked=""/><div class="controls bullet"><span class="by">floodfx</span><span>|</span><a href="#42335994">prev</a><span>|</span><a href="#42335264">next</a><span>|</span><label class="collapse" for="c-42335675">[-]</label><label class="expand" for="c-42335675">[1 more]</label></div><br/><div class="children"><div class="content">Not as well marketed but this is an awesome Typescript ORM <a href="https:&#x2F;&#x2F;joist-orm.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;joist-orm.io&#x2F;</a></div><br/></div></div><div id="42335678" class="c"><input type="checkbox" id="c-42335678" checked=""/><div class="controls bullet"><span class="by">zekenie</span><span>|</span><a href="#42335264">prev</a><span>|</span><a href="#42335204">next</a><span>|</span><label class="collapse" for="c-42335678">[-]</label><label class="expand" for="c-42335678">[1 more]</label></div><br/><div class="children"><div class="content">nit: i feel like this is a typesafe sql query builder and not typesafe sql. i&#x27;m always on the look out for _good_ typesafe sql which i have yet to encounter.</div><br/></div></div><div id="42335204" class="c"><input type="checkbox" id="c-42335204" checked=""/><div class="controls bullet"><span class="by">gabes</span><span>|</span><a href="#42335678">prev</a><span>|</span><a href="#42336112">next</a><span>|</span><label class="collapse" for="c-42335204">[-]</label><label class="expand" for="c-42335204">[3 more]</label></div><br/><div class="children"><div class="content">What does a migration look like with something like this?</div><br/><div id="42335434" class="c"><input type="checkbox" id="c-42335434" checked=""/><div class="controls bullet"><span class="by">mythz</span><span>|</span><a href="#42335204">parent</a><span>|</span><a href="#42336112">next</a><span>|</span><label class="collapse" for="c-42335434">[-]</label><label class="expand" for="c-42335434">[2 more]</label></div><br/><div class="children"><div class="content">If there&#x27;s enough usage&#x2F;interest in litdb I plan to create a similar migration solution to our C# OrmLite DB Migrations: [1]<p>[1] <a href="https:&#x2F;&#x2F;docs.servicestack.net&#x2F;ormlite&#x2F;db-migrations" rel="nofollow">https:&#x2F;&#x2F;docs.servicestack.net&#x2F;ormlite&#x2F;db-migrations</a></div><br/><div id="42336025" class="c"><input type="checkbox" id="c-42336025" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#42335204">root</a><span>|</span><a href="#42335434">parent</a><span>|</span><a href="#42336112">next</a><span>|</span><label class="collapse" for="c-42336025">[-]</label><label class="expand" for="c-42336025">[1 more]</label></div><br/><div class="children"><div class="content">If it helps, the reason we don’t use any typesafe SQL library for node is because of lack of migration support - which was exactly what I first looked for here.</div><br/></div></div></div></div></div></div><div id="42336112" class="c"><input type="checkbox" id="c-42336112" checked=""/><div class="controls bullet"><span class="by">itpcc</span><span>|</span><a href="#42335204">prev</a><span>|</span><a href="#42334717">next</a><span>|</span><label class="collapse" for="c-42336112">[-]</label><label class="expand" for="c-42336112">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, another ORM pretending to be SQL-like syntax. Uhhhhhh<p>EDIT: They don&#x27;t even support, not to not mention, CTE! Come on!</div><br/></div></div><div id="42334717" class="c"><input type="checkbox" id="c-42334717" checked=""/><div class="controls bullet"><span class="by">paxcoder</span><span>|</span><a href="#42336112">prev</a><span>|</span><label class="collapse" for="c-42334717">[-]</label><label class="expand" for="c-42334717">[1 more]</label></div><br/><div class="children"><div class="content">Title makes it seem as if you writr typesafe SQL, but you really use a builder which generates SQL for you.<p>I was expecting something more like sqlx, which I believe provides compile-time checking for SQL queries without a DSL, but for Rust</div><br/></div></div></div></div></div></div></div></body></html>