<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720861252406" as="style"/><link rel="stylesheet" href="styles.css?v=1720861252406"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://labs.quansight.org/blog/free-threaded-python-rollout">Free-threaded CPython is ready to experiment with</a> <span class="domain">(<a href="https://labs.quansight.org">labs.quansight.org</a>)</span></div><div class="subtext"><span>ngoldbaum</span> | <span>249 comments</span></div><br/><div><div id="40949522" class="c"><input type="checkbox" id="c-40949522" checked=""/><div class="controls bullet"><span class="by">eigenvalue</span><span>|</span><a href="#40950641">next</a><span>|</span><label class="collapse" for="c-40949522">[-]</label><label class="expand" for="c-40949522">[61 more]</label></div><br/><div class="children"><div class="content">Really excited for this. Once some more time goes by and the most important python libraries update to support no GIL, there is just a tremendous amount of performance that can be automatically unlocked with almost no incremental effort for so many organizations and projects. It&#x27;s also a good opportunity for new and more actively maintained projects to take market share from older and more established libraries if the older libraries don&#x27;t take making these changes seriously and finish them in a timely manner. It&#x27;s going to be amazing to saturate all the cores on a big machine using simple threads instead of dealing with the massive overhead and complexity and bugs of using something like multiprocessing.</div><br/><div id="40952245" class="c"><input type="checkbox" id="c-40952245" checked=""/><div class="controls bullet"><span class="by">pizza234</span><span>|</span><a href="#40949522">parent</a><span>|</span><a href="#40949637">next</a><span>|</span><label class="collapse" for="c-40952245">[-]</label><label class="expand" for="c-40952245">[3 more]</label></div><br/><div class="children"><div class="content">&gt; using simple threads instead of dealing with the massive overhead and complexity and bugs of using something like multiprocessing.<p>Depending on the domain, the reality can be the reverse.<p>Multiprocessing in the web serving domain, as in &quot;spawning separate processes&quot;, is actually simpler and less bug-prone, because there is considerably less resource sharing. The considerably higher difficulty of writing, testing and debugging parallel code is evident to anybody who&#x27;s worked on it.<p>As for the overhead, this again depends on the domain. It&#x27;s hard to quantify, but generalizing to &quot;massive&quot; is not accurate, especially for app servers with COW support.</div><br/><div id="40952704" class="c"><input type="checkbox" id="c-40952704" checked=""/><div class="controls bullet"><span class="by">bausgwi678</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952245">parent</a><span>|</span><a href="#40952457">next</a><span>|</span><label class="collapse" for="c-40952704">[-]</label><label class="expand" for="c-40952704">[1 more]</label></div><br/><div class="children"><div class="content">Using multiple processes is simpler in terms of locks etc, but python libraries like multiprocessing or even subprocess.popen[1] which make using multiple processes seem easy are full of footguns which cause deadlocks due to fork-safe code not being well understood. I’ve seen this lead to code ‘working’ and being merged but then triggering sporadic deadlocks in production after a few weeks.<p>The default for multiprocessing is still to fork (fortunately changing in 3.14), which means all of your parent process’ threaded code (incl. third party libraries) has to be fork-safe. There’s no static analysis checks for this.<p>This kind of easy to use but incredibly hard to use safely library has made python for long running production services incredibly painful in my experience.<p>[1] Some arguments to subprocess.popen look handy but actually cause python interpreter code to be executed after the fork and before the execve, which has caused production logging-related deadlocks for me. The original author was very bright but didn’t notice the footgun.</div><br/></div></div><div id="40952457" class="c"><input type="checkbox" id="c-40952457" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952245">parent</a><span>|</span><a href="#40952704">prev</a><span>|</span><a href="#40949637">next</a><span>|</span><label class="collapse" for="c-40952457">[-]</label><label class="expand" for="c-40952457">[1 more]</label></div><br/><div class="children"><div class="content">Just the other day I was trying to do two things in parallel in Python using threads - and then I switched to multiprocessing - why? I wanted to immediately terminate one thing whenever the other failed. That’s straightforwardly supported with multiprocessing. With threads, it gets a lot more complicated and can involve things with dubious supportability</div><br/></div></div></div></div><div id="40949637" class="c"><input type="checkbox" id="c-40949637" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#40949522">parent</a><span>|</span><a href="#40952245">prev</a><span>|</span><a href="#40952465">next</a><span>|</span><label class="collapse" for="c-40949637">[-]</label><label class="expand" for="c-40949637">[51 more]</label></div><br/><div class="children"><div class="content">I feel like most things that will benefit from moving to multiple cores for performance should probably not be written in Python. OTH &quot;most&quot; is not &quot;all&quot; so it&#x27;s gonna be awesome for some.</div><br/><div id="40950295" class="c"><input type="checkbox" id="c-40950295" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40950703">next</a><span>|</span><label class="collapse" for="c-40950295">[-]</label><label class="expand" for="c-40950295">[9 more]</label></div><br/><div class="children"><div class="content">I often reach for python multiprocessing for code that will run $singleDigit number of times but is annoyingly slow when run sequentially. I could never justify the additional development time for using a more performant language, but I can easily justify spending 5-10 minutes making the embarrassingly parallel stuff execute in parallel.</div><br/><div id="40952003" class="c"><input type="checkbox" id="c-40952003" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950295">parent</a><span>|</span><a href="#40950703">next</a><span>|</span><label class="collapse" for="c-40952003">[-]</label><label class="expand" for="c-40952003">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve generally been able to deal with embarassing parallelism by just chopping up the input and running multiple processes with GNU Parallel.  I haven&#x27;t needed the multiprocessing module or free threading so far.  I believe CPython still relies on various bytecodes to run atomically, which you get automatically with the GIL present.  So I wonder if hard-to-reproduce concurrency bugs will keep surfacing in the free-threaded CPython for quite some time.<p>I feel like all of this is tragic and Python should have gone to a BEAM-like model some years ago, like as part of the 2 to 3 transition.  Instead we get async wreckage and now free threading with its attendant hazards.  Plus who knows how many C modules won&#x27;t be expecting this.</div><br/><div id="40952230" class="c"><input type="checkbox" id="c-40952230" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952003">parent</a><span>|</span><a href="#40950703">next</a><span>|</span><label class="collapse" for="c-40952230">[-]</label><label class="expand" for="c-40952230">[7 more]</label></div><br/><div class="children"><div class="content">Async seems fine? What&#x27;s wrong with it?</div><br/><div id="40952317" class="c"><input type="checkbox" id="c-40952317" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952230">parent</a><span>|</span><a href="#40950703">next</a><span>|</span><label class="collapse" for="c-40952317">[-]</label><label class="expand" for="c-40952317">[6 more]</label></div><br/><div class="children"><div class="content">Watch this video and maybe you&#x27;ll understand ;).  Warning, NSFW (lots of swearing), use headphones.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=bzkRVzciAZg" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=bzkRVzciAZg</a><p>This is also good:<p><a href="https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-your-function&#x2F;" rel="nofollow">https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-...</a><p>web search on &quot;colored functions&quot; finds lots of commentary on that article.</div><br/><div id="40952485" class="c"><input type="checkbox" id="c-40952485" checked=""/><div class="controls bullet"><span class="by">wesselbindt</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952317">parent</a><span>|</span><a href="#40950703">next</a><span>|</span><label class="collapse" for="c-40952485">[-]</label><label class="expand" for="c-40952485">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always found the criticism leveled by the colored functions blog post a bit contrived. Yes, when you replace the words async&#x2F;await with meaningless concepts I do not care about, it&#x27;s very annoying to have to arbitrarily mark a function as blue or red. But when you replace the word &quot;aync&quot; with something like &quot;expensive&quot;, or &quot;does network calls&quot;, it becomes clear that &quot;async&#x2F;await&quot; makes intrinsic properties about your code (e.g., is it a bad idea to put this call in a loop from a performance perspective) explicit rather than implicit.<p>In short, &quot;await&quot; gives me an extra piece of data about the function, without having to read the body of the function (and the ones it calls, and the ones they call, etc). That&#x27;s a good thing.<p>There are serious drawbacks to async&#x2F;await, and the red&#x2F;blue blog post manages to list none of them.<p>EDIT: all of the above is predicated on the idea that reading code is harder than writing it. If you believe the opposite, then blue&#x2F;red has a point.</div><br/><div id="40952654" class="c"><input type="checkbox" id="c-40952654" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952485">parent</a><span>|</span><a href="#40952612">next</a><span>|</span><label class="collapse" for="c-40952654">[-]</label><label class="expand" for="c-40952654">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>when you replace the word &quot;aync&quot; with something like &quot;expensive&quot;, or &quot;does network calls&quot;, it becomes clear that &quot;async&#x2F;await&quot; makes intrinsic properties about your code explicit rather than implicit.</i><p>Do you think we should be annotating functions with `expensive` and&#x2F;or `networking`? And also annotating all of their callers, recursively? And maintaining 4 copies of every higher-order function depending on whether the functions it calls are `expensive`, `networking`, neither or both?<p>No, we rely on documentation for those things, and IMO we should for `async` as well. The reason we can’t, and why `async`&#x2F;`await` exist, is because of shortcomings (lack of support for stackful coroutines) in language runtimes. The best solution is to fix those shortcomings, not add viral annotations everywhere.</div><br/><div id="40952672" class="c"><input type="checkbox" id="c-40952672" checked=""/><div class="controls bullet"><span class="by">hiddew</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952654">parent</a><span>|</span><a href="#40952612">next</a><span>|</span><label class="collapse" for="c-40952672">[-]</label><label class="expand" for="c-40952672">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The reason we can’t, and why `async`&#x2F;`await` exist, is because of shortcomings (lack of support for stackful coroutines) in language runtimes<p>The JVM runtime has solved this problem neatly with virtual threads in my opinion. Run a web request in a virtual thread, and all blocking I&#x2F;O is suddenly no longer blocking the OS thread, but yielding&#x2F;suspending and giving and giving another virtual thread run time. And all that without language keywords that go viral through your program.</div><br/><div id="40952702" class="c"><input type="checkbox" id="c-40952702" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952672">parent</a><span>|</span><a href="#40952612">next</a><span>|</span><label class="collapse" for="c-40952702">[-]</label><label class="expand" for="c-40952702">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is similar to how Go works. IIRC the same approach was available in Python as a library, “greenlet”, but Python’s core developers rejected it in favour of `async`&#x2F;`await`.</div><br/></div></div></div></div></div></div><div id="40952612" class="c"><input type="checkbox" id="c-40952612" checked=""/><div class="controls bullet"><span class="by">adament</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40952485">parent</a><span>|</span><a href="#40952654">prev</a><span>|</span><a href="#40950703">next</a><span>|</span><label class="collapse" for="c-40952612">[-]</label><label class="expand" for="c-40952612">[1 more]</label></div><br/><div class="children"><div class="content">But a synchronous function can and many do make network calls or write to files. It is a rather vague signal about the functions behavior as opposed to the lack of the IO monad in Haskell.<p>To me the difficulty is more with writing generic code and maintaining abstraction boundaries. Unless the language provides a way to generalise over asyncness of functions, we need a combinatorial explosion of async variants of generic functions. Consider a simple filter algorithm it needs versions for: (synchronous vs asynchronous iterator) times (synchronous vs asynchronous predicate). We end up with a pragmatic but ugly solution: provide 2 versions of each algorithm: an async and a sync, and force the user of the async one to wrap their synchronous arguments.<p>Similarly changing some implementation detail of a function might change it from a synchronous to an asynchronous function, and this change must now propagate through the entire call chain (or the function must start its own async runtime). Again we end up in a place where the most future proof promise to give for an abstraction barrier is to mark everything as async.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40950703" class="c"><input type="checkbox" id="c-40950703" checked=""/><div class="controls bullet"><span class="by">eigenvalue</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40950295">prev</a><span>|</span><a href="#40951861">next</a><span>|</span><label class="collapse" for="c-40950703">[-]</label><label class="expand" for="c-40950703">[6 more]</label></div><br/><div class="children"><div class="content">I personally optimize more for development time and overall productivity in creating and refactoring, adding new features, etc. I&#x27;m just so much faster using Python than anything else, it&#x27;s not even close. There is such an incredible world of great libraries easily available on pip for one thing.<p>Also, I&#x27;ve found that ChatGPT&#x2F;Claude3.5 are much, much smarter and better at Python than they are at C++ or Rust. I can usually get code that works basically the first or second time with Python, but very rarely can do that using those more performant languages. That&#x27;s increasingly a huge concern for me as I use these AI tools to speed up my own development efforts very dramatically. Computers are so fast already anyway that the ceiling for optimization of network oriented software that can be done in a mostly async way in Python is already pretty compelling, so then it just comes back again to developer productivity, at least for my purposes.</div><br/><div id="40952068" class="c"><input type="checkbox" id="c-40952068" checked=""/><div class="controls bullet"><span class="by">goosejuice</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950703">parent</a><span>|</span><a href="#40951139">next</a><span>|</span><label class="collapse" for="c-40952068">[-]</label><label class="expand" for="c-40952068">[1 more]</label></div><br/><div class="children"><div class="content">Kind of sounds like you are optimizing for convenience :)</div><br/></div></div><div id="40951139" class="c"><input type="checkbox" id="c-40951139" checked=""/><div class="controls bullet"><span class="by">indigodaddy</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950703">parent</a><span>|</span><a href="#40952068">prev</a><span>|</span><a href="#40951861">next</a><span>|</span><label class="collapse" for="c-40951139">[-]</label><label class="expand" for="c-40951139">[4 more]</label></div><br/><div class="children"><div class="content">Ever messed about with Claude and php?</div><br/><div id="40951174" class="c"><input type="checkbox" id="c-40951174" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951139">parent</a><span>|</span><a href="#40951861">next</a><span>|</span><label class="collapse" for="c-40951174">[-]</label><label class="expand" for="c-40951174">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think we are supposed to use HN for humor only posts.</div><br/><div id="40951417" class="c"><input type="checkbox" id="c-40951417" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951174">parent</a><span>|</span><a href="#40951206">next</a><span>|</span><label class="collapse" for="c-40951417">[-]</label><label class="expand" for="c-40951417">[1 more]</label></div><br/><div class="children"><div class="content">You think wrong</div><br/></div></div><div id="40951206" class="c"><input type="checkbox" id="c-40951206" checked=""/><div class="controls bullet"><span class="by">jacob019</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951174">parent</a><span>|</span><a href="#40951417">prev</a><span>|</span><a href="#40951861">next</a><span>|</span><label class="collapse" for="c-40951206">[-]</label><label class="expand" for="c-40951206">[1 more]</label></div><br/><div class="children"><div class="content">lol</div><br/></div></div></div></div></div></div></div></div><div id="40951861" class="c"><input type="checkbox" id="c-40951861" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40950703">prev</a><span>|</span><a href="#40951432">next</a><span>|</span><label class="collapse" for="c-40951861">[-]</label><label class="expand" for="c-40951861">[1 more]</label></div><br/><div class="children"><div class="content">Right now you are right. This is about taking away that argument. There&#x27;s no technical reason for this to stay true. Other than that the process of fixing this is a lot of work of course. But now that the work has started, it&#x27;s probably going to progress pretty steadily.<p>It will be interesting to see how this goes over the next few years. My guess is that a lot of lessons were learned from the python 2 to 3 move. This plan seems pretty solid.<p>And of course there&#x27;s a relatively easy fix for code that can&#x27;t work without a GIL: just do what people are doing today and just don&#x27;t fork any threads in python. It&#x27;s kind of pointless in any case with the GIL in place so not a lot of code actually depends on threads in python.<p>Preventing the forking of threads in the presence of things still requiring the GIL sounds like a good plan. This is a bit of meta data that you could build into packages. This plan is actually proposing keeping track of what packages work without a GIL. So, that should keep people safe enough if dependency tools are updated to make use of this meta data and actively stop people from adding thread unsafe packages when threading is used.<p>So, I have good hopes that this is going to be a much smoother transition than python 2 to 3. The initial phase is probably going to flush out a lot of packages that need fixing. But once those fixes start coming in, it&#x27;s probably going to be straightforward to move forward.</div><br/></div></div><div id="40951432" class="c"><input type="checkbox" id="c-40951432" checked=""/><div class="controls bullet"><span class="by">jodrellblank</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40951861">prev</a><span>|</span><a href="#40951592">next</a><span>|</span><label class="collapse" for="c-40951432">[-]</label><label class="expand" for="c-40951432">[5 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.servethehome.com&#x2F;wp-content&#x2F;uploads&#x2F;2023&#x2F;01&#x2F;Intel-and-AMD-Core-Count-Growth-by-Year-2010-2023.jpg" rel="nofollow">https:&#x2F;&#x2F;www.servethehome.com&#x2F;wp-content&#x2F;uploads&#x2F;2023&#x2F;01&#x2F;Inte...</a><p>AMD EPYC 9754 with 128-cores&#x2F;256-threads, and EPYC 9734 with 112-cores&#x2F;224-threads. TomsHardware says they &quot;will compete with Intel&#x27;s 144-core Sierra Forest chips, which mark the debut of Intel&#x27;s Efficiency cores (E-cores) in its Xeon data center lineup, and Ampre&#x27;s 192-core AmpereOne processors&quot;.<p>What in 5 years? 10? 20? How long will &quot;1 core should be enough for anyone using Python&quot; stand?</div><br/><div id="40951682" class="c"><input type="checkbox" id="c-40951682" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951432">parent</a><span>|</span><a href="#40951546">next</a><span>|</span><label class="collapse" for="c-40951682">[-]</label><label class="expand" for="c-40951682">[2 more]</label></div><br/><div class="children"><div class="content">Number crunching code in Python (such as using numpy&#x2F;pytorch) performs the vast vast majority of its calculations in C&#x2F;Fortran code under the hood where GIL can be released. Single python process can use multiple CPUs.<p>There is code that may benefit from the free threaded implementation  but it is not as often as it might appear and it is not without  its own downsides. In general, GIL simplifies multithreaded code.<p>There were no-GIL Python implementations such as Jython, IronPython. They hadn&#x27;t replaced CPython, Pypy implementation which use GIL i.e., other concerns dominate.</div><br/><div id="40951999" class="c"><input type="checkbox" id="c-40951999" checked=""/><div class="controls bullet"><span class="by">imachine1980_</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951682">parent</a><span>|</span><a href="#40951546">next</a><span>|</span><label class="collapse" for="c-40951999">[-]</label><label class="expand" for="c-40951999">[1 more]</label></div><br/><div class="children"><div class="content">Yes but jython am iron aren&#x27;t the standard, and I feel the more relevant part is inertia, puppy is design whit lots of concern of compatibility, then being the new standard can totally make difference making both cases not a good comparison.</div><br/></div></div></div></div></div></div><div id="40951592" class="c"><input type="checkbox" id="c-40951592" checked=""/><div class="controls bullet"><span class="by">Derbasti</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40951432">prev</a><span>|</span><a href="#40949956">next</a><span>|</span><label class="collapse" for="c-40951592">[-]</label><label class="expand" for="c-40951592">[1 more]</label></div><br/><div class="children"><div class="content">A thought experiment:<p>A piece of code takes 6h to develop in C++, and 1h to run.<p>The same algorithm takes 3h to code in Python, but 6h to run.<p>If I could thread-spam that Python code on my 24 core machine, going Python would make sense. I&#x27;ve certainly been in such situations a few times.</div><br/></div></div><div id="40949956" class="c"><input type="checkbox" id="c-40949956" checked=""/><div class="controls bullet"><span class="by">DanielVZ</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40951592">prev</a><span>|</span><a href="#40951796">next</a><span>|</span><label class="collapse" for="c-40949956">[-]</label><label class="expand" for="c-40949956">[7 more]</label></div><br/><div class="children"><div class="content">Usually performance critical code is written in cpp, fortran, etc, and then wrapped in libraries for Python. Python still has a use case for glue code.</div><br/><div id="40950681" class="c"><input type="checkbox" id="c-40950681" checked=""/><div class="controls bullet"><span class="by">andmkl</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949956">parent</a><span>|</span><a href="#40951019">prev</a><span>|</span><a href="#40951796">next</a><span>|</span><label class="collapse" for="c-40950681">[-]</label><label class="expand" for="c-40950681">[5 more]</label></div><br/><div class="children"><div class="content">Yes, but then extensions can already release the GIL and use the simple and industrial strength std::thread, which is orders of magnitude easier to debug.</div><br/><div id="40950852" class="c"><input type="checkbox" id="c-40950852" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950681">parent</a><span>|</span><a href="#40950861">next</a><span>|</span><label class="collapse" for="c-40950852">[-]</label><label class="expand" for="c-40950852">[1 more]</label></div><br/><div class="children"><div class="content">Concurrent operations exist at all levels of the software stack. Just because native extensions might want to release the GIL and use OS threads doesn&#x27;t mean pure Python can&#x27;t also want (or need) that.<p>(And as a side note: I have never, in around a decade of writing C++, heard std::thread described as &quot;easy to debug.&quot;)</div><br/></div></div><div id="40950861" class="c"><input type="checkbox" id="c-40950861" checked=""/><div class="controls bullet"><span class="by">ipsod</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950681">parent</a><span>|</span><a href="#40950852">prev</a><span>|</span><a href="#40951796">next</a><span>|</span><label class="collapse" for="c-40950861">[-]</label><label class="expand" for="c-40950861">[3 more]</label></div><br/><div class="children"><div class="content">Really?  Cool.<p>I expected that dropping down to C&#x2F;C++ would be a large jump in difficulty and quantity of code, but I&#x27;ve found it isn&#x27;t, and the dev experience isn&#x27;t entirely worse, as, for example, in-editor code-intelligence is rock solid and very fast in every corner of my code and the libraries I&#x27;m using.<p>If anyone could benefit from speeding up some Python code, I&#x27;d highly recommend installing cppyy and giving it a try.</div><br/><div id="40951004" class="c"><input type="checkbox" id="c-40951004" checked=""/><div class="controls bullet"><span class="by">woodson</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950861">parent</a><span>|</span><a href="#40951796">next</a><span>|</span><label class="collapse" for="c-40951004">[-]</label><label class="expand" for="c-40951004">[2 more]</label></div><br/><div class="children"><div class="content">Thanks, I haven’t come across cppyy! But I’ve worked with pybind11, which works well, too.</div><br/><div id="40951462" class="c"><input type="checkbox" id="c-40951462" checked=""/><div class="controls bullet"><span class="by">ipsod</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951004">parent</a><span>|</span><a href="#40951796">next</a><span>|</span><label class="collapse" for="c-40951462">[-]</label><label class="expand" for="c-40951462">[1 more]</label></div><br/><div class="children"><div class="content">Sure! I tried pybind11, and some other things.  cppyy was the first I tried that didn&#x27;t give me any trouble.  I&#x27;ve been using it pretty heavily for about a year, and still no trouble.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40951796" class="c"><input type="checkbox" id="c-40951796" checked=""/><div class="controls bullet"><span class="by">tho34234234</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40949956">prev</a><span>|</span><a href="#40949913">next</a><span>|</span><label class="collapse" for="c-40951796">[-]</label><label class="expand" for="c-40951796">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just about &quot;raw-flop performance&quot; though; it affects even basic things like creating data-loaders that run in the background while your main thread is doing some hard ML crunching.<p>Every DL library comes with its own C++ backend that does this for now, but it&#x27;s annoyingly inflexible. And dealing with GIL is a nightmare if you&#x27;re dealing with mixed Python code.</div><br/></div></div><div id="40949913" class="c"><input type="checkbox" id="c-40949913" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40951796">prev</a><span>|</span><a href="#40950477">next</a><span>|</span><label class="collapse" for="c-40949913">[-]</label><label class="expand" for="c-40949913">[3 more]</label></div><br/><div class="children"><div class="content">But it would give you more headroom before rewriting for performance would make sense right? That alone could be beneficial to a lot of people.</div><br/><div id="40950403" class="c"><input type="checkbox" id="c-40950403" checked=""/><div class="controls bullet"><span class="by">rty32</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949913">parent</a><span>|</span><a href="#40950477">next</a><span>|</span><label class="collapse" for="c-40950403">[-]</label><label class="expand" for="c-40950403">[2 more]</label></div><br/><div class="children"><div class="content">I think it is beneficial to some people, but not a lot. My guess is that most Python users (from beginners to advanced users, including many professional data scientists) have never heard of GIL or thought of doing any parallelization in Python<i>. Code that needs performance and would benefit from multithreading, usually written by professional software engineers, likely isn&#x27;t written in Python in the first place. It would make sense for projects that can benefit from disabling GIL without a ton of changes. Remember it is not trivial to update single threaded code to use multithreading </i>correctly<i>.<p></i> in Python language specifically. Their library may have already done some form of parallelization under the hood</div><br/><div id="40951702" class="c"><input type="checkbox" id="c-40951702" checked=""/><div class="controls bullet"><span class="by">bdd8f1df777b</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950403">parent</a><span>|</span><a href="#40950477">next</a><span>|</span><label class="collapse" for="c-40951702">[-]</label><label class="expand" for="c-40951702">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Code that needs performance and would benefit from multithreading, usually written by professional software engineers, likely isn&#x27;t written in Python in the first place.<p>There are a lot of simple cases where multi-threading can easily triple or quadruple the performance.</div><br/></div></div></div></div></div></div><div id="40950477" class="c"><input type="checkbox" id="c-40950477" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40949637">parent</a><span>|</span><a href="#40949913">prev</a><span>|</span><a href="#40952465">next</a><span>|</span><label class="collapse" for="c-40950477">[-]</label><label class="expand" for="c-40950477">[17 more]</label></div><br/><div class="children"><div class="content">&gt;I feel like most things that will benefit from moving to multiple cores for performance should probably not be written in Python.<p>I feel like most things that will benefit from performance should probably not be written in Python.</div><br/><div id="40950490" class="c"><input type="checkbox" id="c-40950490" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950477">parent</a><span>|</span><a href="#40951145">next</a><span>|</span><label class="collapse" for="c-40950490">[-]</label><label class="expand" for="c-40950490">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40949956">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40949956</a></div><br/></div></div><div id="40951145" class="c"><input type="checkbox" id="c-40951145" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950477">parent</a><span>|</span><a href="#40950490">prev</a><span>|</span><a href="#40951161">next</a><span>|</span><label class="collapse" for="c-40951145">[-]</label><label class="expand" for="c-40951145">[8 more]</label></div><br/><div class="children"><div class="content">wonder if the fearful and ignorant downvoter knows that python is one of the slower among the dynamic languages, forget about the static languages, which are a hell of a lot faster. e.g. perl, which a lot of stupid ignorant hners deride, is a lot faster than python, orders of magnitudes faster.<p>the guy is probably suffering from the Upton Sinclair effect:<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Upton_Sinclair" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Upton_Sinclair</a><p>He is also well remembered for the quote: &quot;It is difficult to get a man to understand something, when his salary depends upon his not understanding it.&quot;[4]<p>same thing applies here.</div><br/><div id="40951226" class="c"><input type="checkbox" id="c-40951226" checked=""/><div class="controls bullet"><span class="by">jacob019</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951145">parent</a><span>|</span><a href="#40951824">next</a><span>|</span><label class="collapse" for="c-40951226">[-]</label><label class="expand" for="c-40951226">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s very unpopular to mention Perl, but I did many cool things with it back in the day, and it still holds a special place for me.  Perl taught me the power of regex--it&#x27;s really first class in Perl.  I still have some Perl code in production today.  But to be fair, it is really easy to write spaghetti in Perl if you don&#x27;t know what you&#x27;re doing.</div><br/><div id="40952091" class="c"><input type="checkbox" id="c-40952091" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951226">parent</a><span>|</span><a href="#40951824">next</a><span>|</span><label class="collapse" for="c-40952091">[-]</label><label class="expand" for="c-40952091">[1 more]</label></div><br/><div class="children"><div class="content">don&#x27;t worry about unpopularity, bro. worry about being true. the rest will take care of itself. if not, you are in the wrong company, forum, or place, and better to work on getting out of there.</div><br/></div></div></div></div><div id="40951824" class="c"><input type="checkbox" id="c-40951824" checked=""/><div class="controls bullet"><span class="by">dr_kiszonka</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951145">parent</a><span>|</span><a href="#40951226">prev</a><span>|</span><a href="#40951658">next</a><span>|</span><label class="collapse" for="c-40951824">[-]</label><label class="expand" for="c-40951824">[3 more]</label></div><br/><div class="children"><div class="content">One day your ISP emails you that they increased your upload and download speeds. Sweet, right? Same here with Python.</div><br/><div id="40951883" class="c"><input type="checkbox" id="c-40951883" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951824">parent</a><span>|</span><a href="#40951658">next</a><span>|</span><label class="collapse" for="c-40951883">[-]</label><label class="expand" for="c-40951883">[2 more]</label></div><br/><div class="children"><div class="content">sweet? no, bitter. &#x27;cause you&#x27;re moving goalposts, ha ha. utterly flawed logic, bro, on a site which is about software, so about logic. but you know it, don&#x27;t you? so stop trying to con me. ain&#x27;t gonna work.<p>as I said in this thread, see the Upton Sinclair quote.<p>getting a speed improvement is fine but not the same thing as being slow in the first place, like python is. don&#x27;t pretend you don&#x27;t know it. or if you don&#x27;t, you have no business talking.<p>kthxbye ;)<p>why so much deliberate fakery on hn? i know. upton sinclair again.</div><br/><div id="40952096" class="c"><input type="checkbox" id="c-40952096" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951883">parent</a><span>|</span><a href="#40951658">next</a><span>|</span><label class="collapse" for="c-40952096">[-]</label><label class="expand" for="c-40952096">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40951145">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40951145</a></div><br/></div></div></div></div></div></div><div id="40951658" class="c"><input type="checkbox" id="c-40951658" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951145">parent</a><span>|</span><a href="#40951824">prev</a><span>|</span><a href="#40951161">next</a><span>|</span><label class="collapse" for="c-40951658">[-]</label><label class="expand" for="c-40951658">[2 more]</label></div><br/><div class="children"><div class="content">They’re probably downvoting you because you’ve posted like the laziest trope comment there is. lol Python slow everyone is paid to hide the truth amirite</div><br/><div id="40952046" class="c"><input type="checkbox" id="c-40952046" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951658">parent</a><span>|</span><a href="#40951161">next</a><span>|</span><label class="collapse" for="c-40952046">[-]</label><label class="expand" for="c-40952046">[1 more]</label></div><br/><div class="children"><div class="content">thanks for your viewpoint, but i doubt it. one of them (user jacob019) talked about the &quot;need&quot; to be tactful (in a thread about software, aka logic !!!) and the same guy tried to divert the topic to perl, in another comment. I&#x27;m damn sure it&#x27;s the upton sinclair syndrome at work, as I posted, also in this subthread, i.e. they are lying because of vested interests, like salary.  another way of describing it is &quot;The emperor&#x27;s new clothes&quot;, that well known fable about hypocrisy and sycophancy for gain.</div><br/></div></div></div></div></div></div><div id="40951161" class="c"><input type="checkbox" id="c-40951161" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950477">parent</a><span>|</span><a href="#40951145">prev</a><span>|</span><a href="#40951844">next</a><span>|</span><label class="collapse" for="c-40951161">[-]</label><label class="expand" for="c-40951161">[4 more]</label></div><br/><div class="children"><div class="content">hee hee hee, downvoters, showing your lack of calibre, hee hee hee.<p>see here:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40951145">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40951145</a></div><br/><div id="40951256" class="c"><input type="checkbox" id="c-40951256" checked=""/><div class="controls bullet"><span class="by">jacob019</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951161">parent</a><span>|</span><a href="#40951844">next</a><span>|</span><label class="collapse" for="c-40951256">[-]</label><label class="expand" for="c-40951256">[3 more]</label></div><br/><div class="children"><div class="content">Bashing Python in Python development thread is not tactful.</div><br/><div id="40951922" class="c"><input type="checkbox" id="c-40951922" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951256">parent</a><span>|</span><a href="#40951844">next</a><span>|</span><label class="collapse" for="c-40951922">[-]</label><label class="expand" for="c-40951922">[2 more]</label></div><br/><div class="children"><div class="content">it may not be tactful but it sure is <i>factful</i> (even if that last word is ungrammatical, at least the sentence is  poetical). he he he.<p>jfc. guido knows ;), this thread is getting weirder and weirder, creepier and creepier.<p>are you literally implying that I should lie about known facts about python slowness?<p>&quot;tactful&quot; my foot.<p>then I guess the creators of PyPy and Unladen Swallow (the latter project was by Google) were&#x2F;are not being tactful either, because those were two very prominent projects to speed up Python, in other words, to reduce its very well known slowness.<p>There is&#x2F;was also Cython and Pyston (the latter at Dropbox, where Guido (GvR, Python creator) worked for a while. Those were or are also projects to speed up Python program execution.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;PyPy" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;PyPy</a><p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-3146&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-3146&#x2F;</a><p>Excerpt from the section titled &quot;Rationale, Implementation&quot; from the above link (italics mine):<p>[<p><i>Many companies and individuals would like Python to be faster</i>, to enable its use in more projects. <i>Google is one such company</i>.<p><i>Unladen Swallow is a Google-sponsored branch of CPython, initiated to improve the performance of Google’s numerous Python libraries, tools and applications</i>. To make the adoption of Unladen Swallow as easy as possible, the project initially aimed at four goals:<p><pre><code>    A performance improvement of 5x over the baseline of CPython 2.6.4 for single-threaded code.
    100% source compatibility with valid CPython 2.6 applications.
    100% source compatibility with valid CPython 2.6 C extension modules.
    Design for eventual merger back into CPython.
</code></pre>
]<p>Your honor, I rest my case.</div><br/><div id="40952114" class="c"><input type="checkbox" id="c-40952114" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951922">parent</a><span>|</span><a href="#40951844">next</a><span>|</span><label class="collapse" for="c-40952114">[-]</label><label class="expand" for="c-40952114">[1 more]</label></div><br/><div class="children"><div class="content">if Google wanted a <i>performance increase of 5x over the then existing python</i>, I guess we can safely say that <i>Python was slow, amirite</i>. and yes, I know the version number mentioned, and what it is today.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40952465" class="c"><input type="checkbox" id="c-40952465" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#40949522">parent</a><span>|</span><a href="#40949637">prev</a><span>|</span><a href="#40951822">next</a><span>|</span><label class="collapse" for="c-40952465">[-]</label><label class="expand" for="c-40952465">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there is just a tremendous amount of performance that can be automatically unlocked with almost no incremental effort for so many organizations and projects<p>This just isn’t true.<p>This does not improve single threaded performance (it’s worse) and concurrent programming is already available.<p>This will make it <i>less annoying</i> to do concurrent processing.<p>It also makes <i>everything</i> slower (arguable where that ends up, currently <i>significantly slower</i>) overall.<p>This way over hyped.<p>At the end of the day this will be a change that (most likely) makes the existing workloads for everyone slightly slower and makes the lives of a few people a bit easier when they implement natively parallel processing like ML easier and better.<p>It’s an incremental win for the ML community, and a meaningless&#x2F;slight loss for everyone else.<p>At the cost of a great. Deal. Of. Effort.<p>If you’re excited about it because of the hype and don’t really understand it, probably calm down.<p>Mostly likely, at the end of the day, it s a change that is totally meaningless to you, won’t really affect you other than making some libraries you use a bit faster, and others a bit slower.<p>Overall, your standard web application will run a bit slower as a result of it. You probably won’t notice.<p>Your data stack will run a bit faster. That’s nice.<p>That’s it.<p>Over hyped. 100%.</div><br/></div></div><div id="40951822" class="c"><input type="checkbox" id="c-40951822" checked=""/><div class="controls bullet"><span class="by">Demiurge</span><span>|</span><a href="#40949522">parent</a><span>|</span><a href="#40952465">prev</a><span>|</span><a href="#40950539">next</a><span>|</span><label class="collapse" for="c-40951822">[-]</label><label class="expand" for="c-40951822">[2 more]</label></div><br/><div class="children"><div class="content">Massive overhead of multiprocessing? How have I not noticed this for tens of years?<p>I use coroutines and multiprocessing all the time, and saturate every core and all the IO, as needed. I use numpy, pandas, xarray, pytorch, etc.<p>How did this terrible GIL overhead completely went unnoticed?</div><br/><div id="40951848" class="c"><input type="checkbox" id="c-40951848" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40951822">parent</a><span>|</span><a href="#40950539">next</a><span>|</span><label class="collapse" for="c-40951848">[-]</label><label class="expand" for="c-40951848">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I use numpy, pandas, xarray, pytorch, etc.<p>That means your code is using python as glue and you do most of your work completely outside of cPython. That&#x27;s why you don&#x27;t see the impact - those libraries drop GIL when you use them, so there&#x27;s much less overhead.</div><br/></div></div></div></div><div id="40950539" class="c"><input type="checkbox" id="c-40950539" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#40949522">parent</a><span>|</span><a href="#40951822">prev</a><span>|</span><a href="#40951583">next</a><span>|</span><label class="collapse" for="c-40950539">[-]</label><label class="expand" for="c-40950539">[2 more]</label></div><br/><div class="children"><div class="content">FWIW, I think the concern though is&#x2F;was that for most of us who aren&#x27;t doing shared-data multiprocessing this is going to make Python even slower; maybe they figured out how to avoid that?</div><br/><div id="40951371" class="c"><input type="checkbox" id="c-40951371" checked=""/><div class="controls bullet"><span class="by">eigenvalue</span><span>|</span><a href="#40949522">root</a><span>|</span><a href="#40950539">parent</a><span>|</span><a href="#40951583">next</a><span>|</span><label class="collapse" for="c-40951371">[-]</label><label class="expand" for="c-40951371">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure they offset any possible slowdowns by doing heroic optimizations in other parts of CPython. There was even some talk about keeping just those optimizations and leaving the GIL in place, but fortunately they went for the full GILectomy.</div><br/></div></div></div></div><div id="40951583" class="c"><input type="checkbox" id="c-40951583" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#40949522">parent</a><span>|</span><a href="#40950539">prev</a><span>|</span><a href="#40950641">next</a><span>|</span><label class="collapse" for="c-40951583">[-]</label><label class="expand" for="c-40951583">[1 more]</label></div><br/><div class="children"><div class="content">What about the pessimization of single-threaded workloads? I&#x27;m still not convinced a completely free-threaded Python is better overall than a multi-interpreter, separate-GIL model with explicit instead of implicit parallelism.<p>Everyone wants parallelism in Python. Removing the GIL isn&#x27;t the only way to get it.</div><br/></div></div></div></div><div id="40950641" class="c"><input type="checkbox" id="c-40950641" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40949522">prev</a><span>|</span><a href="#40952439">next</a><span>|</span><label class="collapse" for="c-40950641">[-]</label><label class="expand" for="c-40950641">[2 more]</label></div><br/><div class="children"><div class="content">I got this working on macOS and wrote up some notes on the installation process and a short script I wrote to demonstrate how it differs from non-free-threaded Python: <a href="https:&#x2F;&#x2F;til.simonwillison.net&#x2F;python&#x2F;trying-free-threaded-python" rel="nofollow">https:&#x2F;&#x2F;til.simonwillison.net&#x2F;python&#x2F;trying-free-threaded-py...</a></div><br/><div id="40951886" class="c"><input type="checkbox" id="c-40951886" checked=""/><div class="controls bullet"><span class="by">vanous</span><span>|</span><a href="#40950641">parent</a><span>|</span><a href="#40952439">next</a><span>|</span><label class="collapse" for="c-40951886">[-]</label><label class="expand" for="c-40951886">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the example and explanations Simon!</div><br/></div></div></div></div><div id="40952439" class="c"><input type="checkbox" id="c-40952439" checked=""/><div class="controls bullet"><span class="by">vegabook</span><span>|</span><a href="#40950641">prev</a><span>|</span><a href="#40949610">next</a><span>|</span><label class="collapse" for="c-40952439">[-]</label><label class="expand" for="c-40952439">[1 more]</label></div><br/><div class="children"><div class="content">Clearly the Python 2 to 3 war was so traumatising (and so badly handled) that the core Python team is too scared to do the obvious thing, and call this Python 4.<p>This is a big fundamental and (in many cases breaking) change, even if it&#x27;s &quot;optional&quot;.</div><br/></div></div><div id="40949610" class="c"><input type="checkbox" id="c-40949610" checked=""/><div class="controls bullet"><span class="by">Sparkyte</span><span>|</span><a href="#40952439">prev</a><span>|</span><a href="#40952530">next</a><span>|</span><label class="collapse" for="c-40949610">[-]</label><label class="expand" for="c-40949610">[56 more]</label></div><br/><div class="children"><div class="content">My body is ready. I love python because the ease of writing and logic. Hopefully the more complicated free-threaded approach is comprehensive enough to write it like we traditionally write python. Not saying it is or isn&#x27;t I just haven&#x27;t dived enough into python multithreading because it is hard to put those demons back once you pull them out.</div><br/><div id="40949681" class="c"><input type="checkbox" id="c-40949681" checked=""/><div class="controls bullet"><span class="by">ameliaquining</span><span>|</span><a href="#40949610">parent</a><span>|</span><a href="#40949860">next</a><span>|</span><label class="collapse" for="c-40949681">[-]</label><label class="expand" for="c-40949681">[25 more]</label></div><br/><div class="children"><div class="content">The semantic changes are negligible for authors of Python code. All the complexity falls on the maintainers of the CPython interpreter and on authors of native extension modules.</div><br/><div id="40950083" class="c"><input type="checkbox" id="c-40950083" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949681">parent</a><span>|</span><a href="#40949860">next</a><span>|</span><label class="collapse" for="c-40950083">[-]</label><label class="expand" for="c-40950083">[24 more]</label></div><br/><div class="children"><div class="content">Well, I&#x27;m not looking forward to the day when I upgrade my Python and suddenly I have to debug a ton of fun race conditions.</div><br/><div id="40950370" class="c"><input type="checkbox" id="c-40950370" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950083">parent</a><span>|</span><a href="#40950103">next</a><span>|</span><label class="collapse" for="c-40950370">[-]</label><label class="expand" for="c-40950370">[19 more]</label></div><br/><div class="children"><div class="content">As I understand it, if your code would have race conditions with free threaded python, than it probably already has them.</div><br/><div id="40950624" class="c"><input type="checkbox" id="c-40950624" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950370">parent</a><span>|</span><a href="#40950103">next</a><span>|</span><label class="collapse" for="c-40950624">[-]</label><label class="expand" for="c-40950624">[18 more]</label></div><br/><div class="children"><div class="content">Not when there&#x27;s a global interpreter lock.</div><br/><div id="40950768" class="c"><input type="checkbox" id="c-40950768" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950624">parent</a><span>|</span><a href="#40950775">next</a><span>|</span><label class="collapse" for="c-40950768">[-]</label><label class="expand" for="c-40950768">[3 more]</label></div><br/><div class="children"><div class="content">The GIL does not prevent race conditions in your Python code. It only prevents race conditions in internal data structures inside the interpreter and in atomic operations, i.e., operations that take a single Python bytecode. But many things that appear atomic in Python code take more than one Python bytecode. The GIL gives you no protection if you do such operations in multiple threads on the same object.</div><br/><div id="40950976" class="c"><input type="checkbox" id="c-40950976" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950768">parent</a><span>|</span><a href="#40950775">next</a><span>|</span><label class="collapse" for="c-40950976">[-]</label><label class="expand" for="c-40950976">[2 more]</label></div><br/><div class="children"><div class="content">I answered in a sibling reply: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40950798">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40950798</a></div><br/><div id="40951065" class="c"><input type="checkbox" id="c-40951065" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950976">parent</a><span>|</span><a href="#40950775">next</a><span>|</span><label class="collapse" for="c-40951065">[-]</label><label class="expand" for="c-40951065">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll respond there.</div><br/></div></div></div></div></div></div><div id="40950775" class="c"><input type="checkbox" id="c-40950775" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950624">parent</a><span>|</span><a href="#40950768">prev</a><span>|</span><a href="#40950103">next</a><span>|</span><label class="collapse" for="c-40950775">[-]</label><label class="expand" for="c-40950775">[14 more]</label></div><br/><div class="children"><div class="content">Are you writing an extension or Python code?<p>If you are writing Python code, the GIL can already be dropped at pretty much any point and there isn&#x27;t much way of controlling when. Iirc, this includes in the middle of things like +=. There are some operations that Python defines as atomic, but, as I recall, there aren&#x27;t all that many.<p>In what way is the GIL preventing races for your use case?</div><br/><div id="40951723" class="c"><input type="checkbox" id="c-40951723" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950775">parent</a><span>|</span><a href="#40950798">next</a><span>|</span><label class="collapse" for="c-40951723">[-]</label><label class="expand" for="c-40951723">[2 more]</label></div><br/><div class="children"><div class="content">It is not about your code, it is about C extensions you are relying on. Without GIL, you can&#x27;t even be sure that refcounting works reliably. Bugs in C extensions are always possible. No GIL makes them more likely. Even if you are not the author of C extension, you have to debug the consequences.</div><br/><div id="40952358" class="c"><input type="checkbox" id="c-40952358" checked=""/><div class="controls bullet"><span class="by">dudus</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40951723">parent</a><span>|</span><a href="#40950798">next</a><span>|</span><label class="collapse" for="c-40952358">[-]</label><label class="expand" for="c-40952358">[1 more]</label></div><br/><div class="children"><div class="content">Does that mean rewriting all the extensions to Rust? Or maybe CPython itself?<p>Would that be enough to make Python no gill viable?</div><br/></div></div></div></div><div id="40950798" class="c"><input type="checkbox" id="c-40950798" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950775">parent</a><span>|</span><a href="#40951723">prev</a><span>|</span><a href="#40950103">next</a><span>|</span><label class="collapse" for="c-40950798">[-]</label><label class="expand" for="c-40950798">[11 more]</label></div><br/><div class="children"><div class="content">I mean that, if the GIL didn&#x27;t prevent races, it would be trivially removable. Races that are already there in people&#x27;s Python code have probably been debugged (or at least they are tolerated), so there are some races that will happen when the GIL is removed, and they will be a surprise.</div><br/><div id="40950927" class="c"><input type="checkbox" id="c-40950927" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950798">parent</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40950927">[-]</label><label class="expand" for="c-40950927">[9 more]</label></div><br/><div class="children"><div class="content">The GIL prevents the corruption of Pythons internal structures. It&#x27;s hard to remove because:<p>1. Lots of extensions, which can control when they release the GIL unlike regular Python code, depend on it
2. Removing the GIL requires some sort of other mechanism to protect internal Python stuff
3. But for a long time, such a mechanism was resisted by th Python team because all attempts to remove the GIL either made single threaded code slower or were considered too complicated.<p>But, as far as I understand, the GIL does somewhere between nothing and very little to prevent races in pure Python code. And, my rough understanding, is that removing the GIL isn&#x27;t expected to really impact pure Python code.</div><br/><div id="40950942" class="c"><input type="checkbox" id="c-40950942" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950927">parent</a><span>|</span><a href="#40951101">next</a><span>|</span><label class="collapse" for="c-40950942">[-]</label><label class="expand" for="c-40950942">[2 more]</label></div><br/><div class="children"><div class="content">Hmm, that&#x27;s interesting, thank you. I didn&#x27;t realize extensions can control the GIL.</div><br/><div id="40951158" class="c"><input type="checkbox" id="c-40951158" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950942">parent</a><span>|</span><a href="#40951101">next</a><span>|</span><label class="collapse" for="c-40951158">[-]</label><label class="expand" for="c-40951158">[1 more]</label></div><br/><div class="children"><div class="content">Yup, I think its described here: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;c-api&#x2F;init.html#releasing-the-gil-from-extension-code" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;c-api&#x2F;init.html#releasing-the-gil-...</a>.<p>My understanding, is that many extensions will release the GIL when doing anything expensive. So, if you are doing CPU or IO bound operations in an extension _and_ you are calling that operation in multiple threads, even with the GIL you can potentially fully utilize all of the CPUs in your machine.</div><br/></div></div></div></div><div id="40951101" class="c"><input type="checkbox" id="c-40951101" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950927">parent</a><span>|</span><a href="#40950942">prev</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40951101">[-]</label><label class="expand" for="c-40951101">[6 more]</label></div><br/><div class="children"><div class="content"><i>&gt; removing the GIL isn&#x27;t expected to really impact pure Python code.</i><p>If your Python code assumes it&#x27;s just going to run in a single thread now, and it is run in a single thread without the GIL, yes, removing the GIL will make no difference.</div><br/><div id="40951130" class="c"><input type="checkbox" id="c-40951130" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40951101">parent</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40951130">[-]</label><label class="expand" for="c-40951130">[5 more]</label></div><br/><div class="children"><div class="content">&gt; If your Python code assumes it&#x27;s just going to run in a single thread now, and it is run in a single thread without the GIL, yes, removing the GIL will make no difference.<p>I&#x27;m not sure I understand your point.<p>Yes, singled thread code will run the same with or without the GIL.<p>My understanding, was that multi-threaded pure-Python code would also run more or less the same without the GIL. In that, removing the GIL won&#x27;t introduce races into pure-Python code that is already race free with the GIL. (and that relatedly, pure-Python code that suffers from races without the GIL also already suffers from them with the GIL)<p>Are you saying that you expect that pure-Python code will be significantly impacted by the removal of the GIL? If so, I&#x27;d love to learn more.</div><br/><div id="40951348" class="c"><input type="checkbox" id="c-40951348" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40951130">parent</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40951348">[-]</label><label class="expand" for="c-40951348">[4 more]</label></div><br/><div class="children"><div class="content"><i>&gt; removing the GIL won&#x27;t introduce races into pure-Python code that is already race free with the GIL.</i><p>What do you mean by &quot;race free&quot;? Do you mean the code expects to be run in multiple threads and uses the tools provided by Python, such as locks, mutexes, and semaphores, to ensure thread safety, and has been tested to ensure that it is race free when run multi-threaded? If that is what you mean, then yes, of course such code will still be race free without the GIL, because it was never depending on the GIL to protect it in the first place.<p>But there is a lot of pure Python code out there that is <i>not</i> written that way. Removal of the GIL would allow such code to be naively run in multiple threads using, for example, Python&#x27;s support for thread pools. Anyone under the impression that removing the GIL was intended to allow this sort of thing without any further checking of the code is mistaken. That is the kind of thing my comment was intended to exclude.</div><br/><div id="40951459" class="c"><input type="checkbox" id="c-40951459" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40951348">parent</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40951459">[-]</label><label class="expand" for="c-40951459">[3 more]</label></div><br/><div class="children"><div class="content">&gt; But there is a lot of pure Python code out there that is not written that way. Removal of the GIL would allow such code to be naively run in multiple threads using, for example, Python&#x27;s support for thread pools.<p>I guess this is what I don&#x27;t understand. This code could already be run in multiple threads today, with a GIL. And it would be broken - in all the same ways it would be broken without a GIL, correct?<p>&gt; Anyone under the impression that removing the GIL was intended to allow this sort of thing without any further checking of the code is mistaken. That is the kind of thing my comment was intended to exclude.<p>Ah, so, is your point that removing the GIL will cause people to take non-multithread code and run it in multiple threads without realizing that it is broken in that context? That its not so much a technical change, but a change of perception that will lead to issues?</div><br/><div id="40951523" class="c"><input type="checkbox" id="c-40951523" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40951459">parent</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40951523">[-]</label><label class="expand" for="c-40951523">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; This code could already be run in multiple threads today, with a GIL.</i><p>Yes.<p><i>&gt; And it would be broken - in all the same ways it would be broken without a GIL, correct?</i><p>Yes, but the absence of the GIL would make race conditions more likely to happen.<p><i>&gt; is your point that removing the GIL will cause people to take non-multithread code and run it in multiple threads without realizing that it is broken in that context?</i><p>Yes. They could run it in multiple threads with the GIL today, but as above, race conditions might not show up as often, so it might not be realized that the code is broken. But also, with the GIL there is the common perception that Python doesn&#x27;t do multithreading well anyway, so it&#x27;s less likely to be used for that. With the GIL removed, I suspect many people will want to use multithreading a lot more in Python to parallelize code, without fully realizing the implications.</div><br/><div id="40951754" class="c"><input type="checkbox" id="c-40951754" checked=""/><div class="controls bullet"><span class="by">dagenix</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40951523">parent</a><span>|</span><a href="#40951085">next</a><span>|</span><label class="collapse" for="c-40951754">[-]</label><label class="expand" for="c-40951754">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yes, but the absence of the GIL would make race conditions more likely to happen.<p>Does it though? I&#x27;m not saying it doesn&#x27;t, I&#x27;m quite curious. Switching between threads with the GIL is already fairly unpredictable from the perspective of pure-Python code. Does it get significantly more troublesome without the GIL?<p>&gt; Yes. They could run it in multiple threads with the GIL today, but as above, race conditions might not show up as often, so it might not be realized that the code is broken. But also, with the GIL there is the common perception that Python doesn&#x27;t do multithreading well anyway, so it&#x27;s less likely to be used for that. With the GIL removed, I suspect many people will want to use multithreading a lot more in Python to parallelize code, without fully realizing the implications.<p>Fair</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40951085" class="c"><input type="checkbox" id="c-40951085" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950798">parent</a><span>|</span><a href="#40950927">prev</a><span>|</span><a href="#40950103">next</a><span>|</span><label class="collapse" for="c-40951085">[-]</label><label class="expand" for="c-40951085">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; if the GIL didn&#x27;t prevent races, it would be trivially removable</i><p>Nobody is saying the GIL doesn&#x27;t prevent races at all. We are saying that the GIL does not prevent races <i>in your Python code</i>. It&#x27;s not &quot;trivially removable&quot; because it <i>does</i> prevent races in the interpreter&#x27;s internal data structures and in operations that are done in a single Python bytecode, and there are a lot of possible races in those places.<p>Also, perhaps you haven&#x27;t considered the fact that Python provides tools such as mutexes, locks, and semaphores to help you prevent races in your Python code. Python programmers who do write multi-threaded Python code (for example, code where threads spend most of their time waiting on I&#x2F;O, which releases the GIL and allows other threads to run) do have to use these tools. Why? Because the GIL by itself does not prevent races in your Python code. You have to do it, just as you do with multi-threaded code in any language.<p><i>&gt; Races that are already there in people&#x27;s Python code have probably been debugged</i><p>Um, no, they haven&#x27;t, because they&#x27;ve never been exposed to multi-threading. Most people&#x27;s Python code is not written to be thread-safe, so it can&#x27;t safely be parallelized as it is, GIL or no GIL.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40950103" class="c"><input type="checkbox" id="c-40950103" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950083">parent</a><span>|</span><a href="#40950370">prev</a><span>|</span><a href="#40949860">next</a><span>|</span><label class="collapse" for="c-40950103">[-]</label><label class="expand" for="c-40950103">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kept behind a flag. Hopefully will be forever.</div><br/><div id="40950354" class="c"><input type="checkbox" id="c-40950354" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950103">parent</a><span>|</span><a href="#40950266">next</a><span>|</span><label class="collapse" for="c-40950354">[-]</label><label class="expand" for="c-40950354">[1 more]</label></div><br/><div class="children"><div class="content">The article states the goal is to eventually (after some years of working out the major kinks and performance regressions) promote Free-Threaded Python to be the default cPython distribution.</div><br/></div></div><div id="40950266" class="c"><input type="checkbox" id="c-40950266" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950103">parent</a><span>|</span><a href="#40950354">prev</a><span>|</span><a href="#40949860">next</a><span>|</span><label class="collapse" for="c-40950266">[-]</label><label class="expand" for="c-40950266">[2 more]</label></div><br/><div class="children"><div class="content">Oh, very interesting, that&#x27;s a great solution then.</div><br/><div id="40950345" class="c"><input type="checkbox" id="c-40950345" checked=""/><div class="controls bullet"><span class="by">geekone</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950266">parent</a><span>|</span><a href="#40949860">next</a><span>|</span><label class="collapse" for="c-40950345">[-]</label><label class="expand" for="c-40950345">[1 more]</label></div><br/><div class="children"><div class="content">Looks like according to the PEP it may eventually be default in 4-6 releases down the road: <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#python-build-modes" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0703&#x2F;#python-build-modes</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="40949860" class="c"><input type="checkbox" id="c-40949860" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">parent</a><span>|</span><a href="#40949681">prev</a><span>|</span><a href="#40949656">next</a><span>|</span><label class="collapse" for="c-40949860">[-]</label><label class="expand" for="c-40949860">[29 more]</label></div><br/><div class="children"><div class="content">What are the common use cases for threading in Python? I feel like that&#x27;s a lower level tool than most Python projects would want, compared to asyncio or multiprocessing.Pool. JS is the most comparable thing to Python, and it got pretty darn far without threads.</div><br/><div id="40949885" class="c"><input type="checkbox" id="c-40949885" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949860">parent</a><span>|</span><a href="#40950435">next</a><span>|</span><label class="collapse" for="c-40949885">[-]</label><label class="expand" for="c-40949885">[25 more]</label></div><br/><div class="children"><div class="content">Working with asyncio sucks when all you want is to be able to do some things in the background, possibly concurrently. You have to rewrite the worker code using those stupid async await keywords. It&#x27;s an obnoxious constraint that completely breaks down when you want to use unaware libraries. The thread model is just a million times easier to use because you don&#x27;t have to change the code.</div><br/><div id="40949908" class="c"><input type="checkbox" id="c-40949908" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949885">parent</a><span>|</span><a href="#40952023">next</a><span>|</span><label class="collapse" for="c-40949908">[-]</label><label class="expand" for="c-40949908">[19 more]</label></div><br/><div class="children"><div class="content">Asyncio is designed for things like webservers or UIs where some framework is probably already handling the main event loop. What are you doing where you just want to run something else in the background, and IPC isn&#x27;t good enough?</div><br/><div id="40949921" class="c"><input type="checkbox" id="c-40949921" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949908">parent</a><span>|</span><a href="#40952023">next</a><span>|</span><label class="collapse" for="c-40949921">[-]</label><label class="expand" for="c-40949921">[18 more]</label></div><br/><div class="children"><div class="content">Non-blocking HTTP requests is an extremely common need, for instance. Why the hell did we need to reinvent special asyncio-aware request libraries for it? It&#x27;s absolute madness. Thread pools are much easier to work with.<p>&gt; <i>where some framework is probably already handling the main event loop</i><p>This is both not really true and also irrelevant. When you need a flask (or whatever) request handler to do parallel work, asyncio is still pretty bullshit to use vs threads.</div><br/><div id="40949973" class="c"><input type="checkbox" id="c-40949973" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949921">parent</a><span>|</span><a href="#40951742">next</a><span>|</span><label class="collapse" for="c-40949973">[-]</label><label class="expand" for="c-40949973">[13 more]</label></div><br/><div class="children"><div class="content">Non-blocking HTTP request is the bread and butter use case for asyncio. Most JS projects are doing something like this, and they don&#x27;t need to manage threads for it. You want to manage your own thread pool for this, or are you going to spawn and kill a thread every time you make a request?</div><br/><div id="40949996" class="c"><input type="checkbox" id="c-40949996" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949973">parent</a><span>|</span><a href="#40951742">next</a><span>|</span><label class="collapse" for="c-40949996">[-]</label><label class="expand" for="c-40949996">[12 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Non-blocking HTTP request is the bread and butter use case for asyncio</i><p>And the amount of contorting that has to be done for it in Python would be hilarious if it weren&#x27;t so sad.<p>&gt; <i>Most JS projects</i><p>I don&#x27;t know what JavaScript does, but I do know that Python is not JavaScript.<p>&gt; <i>You want to manage your own thread pool for this...</i><p>In Python, concurrent futures&#x27; ThreadPoolExecutor is actually nice to use and doesn&#x27;t require rewriting existing worker code. It&#x27;s already done, has a clean interface, and was part of the standard library before asyncio was.</div><br/><div id="40950112" class="c"><input type="checkbox" id="c-40950112" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949996">parent</a><span>|</span><a href="#40950091">next</a><span>|</span><label class="collapse" for="c-40950112">[-]</label><label class="expand" for="c-40950112">[7 more]</label></div><br/><div class="children"><div class="content">ThreadPoolExecutor is the most similar thing to asyncio: It hands out promises, and when you call .result(), it&#x27;s the same as await. JS even made its own promises implicitly compatible with async&#x2F;await. I&#x27;m mentioning what JS does because you&#x27;re describing a very common JS use case, and Python isn&#x27;t all that different.<p>If you have async stuff happening all over the place, what do you use, a global ThreadPoolExecutor? It&#x27;s not bad, but a bit more cumbersome and probably less efficient. You&#x27;re running multiple OS threads that are locking, vs a single-threaded event loop. Gets worse the more long-running blocking calls there are.<p>Also, I was originally asking about free threads. GIL isn&#x27;t a problem if you&#x27;re just waiting on I&#x2F;O. If you want to compute on multiple cores at once, there&#x27;s multiprocessing, or more likely you&#x27;re using stuff like numpy that uses C threads anyway.</div><br/><div id="40950189" class="c"><input type="checkbox" id="c-40950189" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950112">parent</a><span>|</span><a href="#40950091">next</a><span>|</span><label class="collapse" for="c-40950189">[-]</label><label class="expand" for="c-40950189">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Python isn&#x27;t all that different</i><p>Again, Python&#x27;s implementation of asyncio does not allow you to background worker code without explicitly altering that worker code to be aware of asyncio. Threads do. They just don&#x27;t occupy the same space.<p>&gt; <i>Also, I was originally asking about free threads...there&#x27;s multiprocessing</i><p>Eh, the obvious reason to not want to use separate processes is a desire for some kind of shared state without the cost or burden of IPC. The fact that you suggested multiprocessing.Pool instead of concurrent_futures.ProcessPoolExecutor and asked about manual pool management feels like it tells me a little bit about where your head is at here wrt Python.</div><br/><div id="40950319" class="c"><input type="checkbox" id="c-40950319" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950189">parent</a><span>|</span><a href="#40950091">next</a><span>|</span><label class="collapse" for="c-40950319">[-]</label><label class="expand" for="c-40950319">[5 more]</label></div><br/><div class="children"><div class="content">Basically true in JS too. You&#x27;re not supposed to do blocking calls in async code. You also can&#x27;t &quot;await&quot; an async call inside a non-async func, though you could fire-and-forget it.<p>Right, but how often does a Python program have complex shared state across threads, rather than some simple fan-out-fan-in, and also need to take advantage of multiple cores?</div><br/><div id="40950548" class="c"><input type="checkbox" id="c-40950548" checked=""/><div class="controls bullet"><span class="by">nilamo</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950319">parent</a><span>|</span><a href="#40950091">next</a><span>|</span><label class="collapse" for="c-40950548">[-]</label><label class="expand" for="c-40950548">[4 more]</label></div><br/><div class="children"><div class="content">The primary thing that tripped me up about async&#x2F;await, specifically only in Python, is that the called function does not begin running until you await it. Before that moment, it&#x27;s just an unstarted generator.<p>To make background jobs, I&#x27;ve used the class-based version to start a thread, then the magic method that&#x27;s called on await simply joins the thread. Which is a lot of boilerplate to get a little closer to how async works in (at least) js and c#.</div><br/><div id="40952188" class="c"><input type="checkbox" id="c-40952188" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950548">parent</a><span>|</span><a href="#40950721">next</a><span>|</span><label class="collapse" for="c-40952188">[-]</label><label class="expand" for="c-40952188">[1 more]</label></div><br/><div class="children"><div class="content">There is also <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio-task.html#eager-task-factory" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;asyncio-task.html#eager-ta...</a> if you want your task to start on creation.</div><br/></div></div><div id="40950721" class="c"><input type="checkbox" id="c-40950721" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950548">parent</a><span>|</span><a href="#40952188">prev</a><span>|</span><a href="#40951175">next</a><span>|</span><label class="collapse" for="c-40950721">[-]</label><label class="expand" for="c-40950721">[1 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s version of async&#x2F;await is the same in that respect, where futures don&#x27;t do anything until you poll them (e.g., by awaiting them): if you want something to just start right away, you have to call out to the executor you&#x27;re using, and get it to spawn a new task for it.<p>Though to be fair, people complain about this in Rust as well. I can&#x27;t comment much on it myself, since I haven&#x27;t had any need for concurrent workloads that Rayon (a basic thread-pool library with work stealing) can&#x27;t handle.</div><br/></div></div><div id="40951175" class="c"><input type="checkbox" id="c-40951175" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950548">parent</a><span>|</span><a href="#40950721">prev</a><span>|</span><a href="#40950091">next</a><span>|</span><label class="collapse" for="c-40951175">[-]</label><label class="expand" for="c-40951175">[1 more]</label></div><br/><div class="children"><div class="content">That is a common split in language design decisions. I think the argument for the python-style where you have to drive it to begin is more useful as you can always just start it immediately but also let&#x27;s you delay computation or pass it around similar to a Haskell thunk.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40950091" class="c"><input type="checkbox" id="c-40950091" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949996">parent</a><span>|</span><a href="#40950112">prev</a><span>|</span><a href="#40951742">next</a><span>|</span><label class="collapse" for="c-40950091">[-]</label><label class="expand" for="c-40950091">[4 more]</label></div><br/><div class="children"><div class="content">I feel you. I know asyncio is &quot;the future&quot;, but I usually just want to write a background task, and really hate all the gymnastics I have to do with the color of my functions.</div><br/><div id="40950129" class="c"><input type="checkbox" id="c-40950129" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950091">parent</a><span>|</span><a href="#40951742">next</a><span>|</span><label class="collapse" for="c-40950129">[-]</label><label class="expand" for="c-40950129">[3 more]</label></div><br/><div class="children"><div class="content">I feel like &quot;asyncio is the future&quot; was invented by the same people who think it&#x27;s totally normal to switch to a new javascript web framework every 6 months.</div><br/><div id="40950243" class="c"><input type="checkbox" id="c-40950243" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950129">parent</a><span>|</span><a href="#40950268">next</a><span>|</span><label class="collapse" for="c-40950243">[-]</label><label class="expand" for="c-40950243">[1 more]</label></div><br/><div class="children"><div class="content">JS had an event loop since the start. It&#x27;s an old concept that Python seems to have lifted, as did Rust. I used Python for a decade and never really liked the way it did threads.</div><br/></div></div><div id="40950268" class="c"><input type="checkbox" id="c-40950268" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950129">parent</a><span>|</span><a href="#40950243">prev</a><span>|</span><a href="#40951742">next</a><span>|</span><label class="collapse" for="c-40950268">[-]</label><label class="expand" for="c-40950268">[1 more]</label></div><br/><div class="children"><div class="content">I agree, I find Go&#x27;s way much easier to reason about. It&#x27;s all just functions.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40951742" class="c"><input type="checkbox" id="c-40951742" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949921">parent</a><span>|</span><a href="#40949973">prev</a><span>|</span><a href="#40950035">next</a><span>|</span><label class="collapse" for="c-40951742">[-]</label><label class="expand" for="c-40951742">[1 more]</label></div><br/><div class="children"><div class="content">Ordinary CPython code releases GIL during blocking I&#x2F;O. You can do http requests + thread pool in Python.</div><br/></div></div><div id="40950035" class="c"><input type="checkbox" id="c-40950035" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949921">parent</a><span>|</span><a href="#40951742">prev</a><span>|</span><a href="#40952023">next</a><span>|</span><label class="collapse" for="c-40950035">[-]</label><label class="expand" for="c-40950035">[3 more]</label></div><br/><div class="children"><div class="content">You don’t?  concurrent.futures.ThreadPoolExecutor can get a lot done without touching async code.</div><br/><div id="40950050" class="c"><input type="checkbox" id="c-40950050" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950035">parent</a><span>|</span><a href="#40952023">next</a><span>|</span><label class="collapse" for="c-40950050">[-]</label><label class="expand" for="c-40950050">[2 more]</label></div><br/><div class="children"><div class="content">I am a big advocate for ThreadPoolExecutor. I&#x27;m saying it&#x27;s superior to asyncio. The person I&#x27;m responding to was asking why use threads when you can use asyncio instead.</div><br/><div id="40950406" class="c"><input type="checkbox" id="c-40950406" checked=""/><div class="controls bullet"><span class="by">kristjansson</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950050">parent</a><span>|</span><a href="#40952023">next</a><span>|</span><label class="collapse" for="c-40950406">[-]</label><label class="expand" for="c-40950406">[1 more]</label></div><br/><div class="children"><div class="content">Ach, I posted before I saw the rest of your thread, apologies.<p>Totally agree, concurrent.futures strikes a great balance. Enough to get work done, a bit more constrained than threads on their own.<p>Asyncio is a lot of cud to chew if you just want a background task in an otherwise sync application</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40952023" class="c"><input type="checkbox" id="c-40952023" checked=""/><div class="controls bullet"><span class="by">throwaway81523</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949885">parent</a><span>|</span><a href="#40949908">prev</a><span>|</span><a href="#40950499">next</a><span>|</span><label class="collapse" for="c-40952023">[-]</label><label class="expand" for="c-40952023">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;ve never liked the async stuff.  I&#x27;ve used the existing theading library and it&#x27;s been fine, for those programs that are blocked on i&#x2F;o most of the time.  The GIL hasn&#x27;t been a problem.  Those programs often ran on single core machines anyway.  We would have been better off without the GIL in the first place, but we may be in for headaches by removing it now.</div><br/></div></div><div id="40950499" class="c"><input type="checkbox" id="c-40950499" checked=""/><div class="controls bullet"><span class="by">j1elo</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949885">parent</a><span>|</span><a href="#40952023">prev</a><span>|</span><a href="#40950435">next</a><span>|</span><label class="collapse" for="c-40950499">[-]</label><label class="expand" for="c-40950499">[4 more]</label></div><br/><div class="children"><div class="content">So, in Rust they had threading since forever and they are now hyped with this new toy called async&#x2F;await (and all the new problems it brings), while in Python they&#x27;ve had async&#x2F;await and are now excited to see the possibilities of this new toy called threads (and all its problems). That&#x27;s funny!</div><br/><div id="40950607" class="c"><input type="checkbox" id="c-40950607" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950499">parent</a><span>|</span><a href="#40950590">next</a><span>|</span><label class="collapse" for="c-40950607">[-]</label><label class="expand" for="c-40950607">[1 more]</label></div><br/><div class="children"><div class="content">Yes?  They have different use cases which they are good at.</div><br/></div></div><div id="40950590" class="c"><input type="checkbox" id="c-40950590" checked=""/><div class="controls bullet"><span class="by">BugsJustFindMe</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950499">parent</a><span>|</span><a href="#40950607">prev</a><span>|</span><a href="#40951116">next</a><span>|</span><label class="collapse" for="c-40950590">[-]</label><label class="expand" for="c-40950590">[1 more]</label></div><br/><div class="children"><div class="content">Well, Python had threads already. This is just a slightly different form of them behind the scenes.</div><br/></div></div><div id="40951116" class="c"><input type="checkbox" id="c-40951116" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950499">parent</a><span>|</span><a href="#40950590">prev</a><span>|</span><a href="#40950435">next</a><span>|</span><label class="collapse" for="c-40951116">[-]</label><label class="expand" for="c-40951116">[1 more]</label></div><br/><div class="children"><div class="content">Being hyped for &lt;feature other languages have had for years&gt; is totally on-brand for the Rust community.</div><br/></div></div></div></div></div></div><div id="40950435" class="c"><input type="checkbox" id="c-40950435" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949860">parent</a><span>|</span><a href="#40949885">prev</a><span>|</span><a href="#40949907">next</a><span>|</span><label class="collapse" for="c-40950435">[-]</label><label class="expand" for="c-40950435">[2 more]</label></div><br/><div class="children"><div class="content">It’s hard to say because we’ve come up with a lot of ways to work around the fact that threaded Python has always sucked. Why? Because there’d been no demand to improve it. Why? Because no one used it. Why? Because it sucked.<p>I’m looking forward to seeing how people use a Python that can be meaningfully threaded. While It may take a bit to built momentum, I suspect that in a few years there’ll be obvious use cases that are widely deployed that no one today has even really considered.</div><br/><div id="40952105" class="c"><input type="checkbox" id="c-40952105" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40950435">parent</a><span>|</span><a href="#40949907">next</a><span>|</span><label class="collapse" for="c-40952105">[-]</label><label class="expand" for="c-40952105">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a place to look for obvious use cases is in other languages. JS doesn&#x27;t have threads, but Swift does. The reason I can&#x27;t think of one is, free threads are most useful for full parallelism that isn&#x27;t &quot;embarrassingly parallel,&quot; otherwise IPC does fine.<p>So far, I&#x27;ve rarely seen that. Best example I deal with was a networking project with lots of communication across threads, and that one was too performance-sensitive to even use C++, let alone Py. Other things I can think of are OS programming which again has to be C or Rust.</div><br/></div></div></div></div><div id="40949907" class="c"><input type="checkbox" id="c-40949907" checked=""/><div class="controls bullet"><span class="by">bongodongobob</span><span>|</span><a href="#40949610">root</a><span>|</span><a href="#40949860">parent</a><span>|</span><a href="#40950435">prev</a><span>|</span><a href="#40949656">next</a><span>|</span><label class="collapse" for="c-40949907">[-]</label><label class="expand" for="c-40949907">[1 more]</label></div><br/><div class="children"><div class="content">Same as any other language. Separating UI from calculations is my most common need for it.</div><br/></div></div></div></div><div id="40949656" class="c"><input type="checkbox" id="c-40949656" checked=""/><div class="controls bullet"><span class="by">ZhongXina</span><span>|</span><a href="#40949610">parent</a><span>|</span><a href="#40949860">prev</a><span>|</span><a href="#40952530">next</a><span>|</span><label class="collapse" for="c-40949656">[-]</label><label class="expand" for="c-40949656">[1 more]</label></div><br/><div class="children"><div class="content">Precisely, ease of <i>writing</i>, not ease of reading (the whole project, not just a tiny snippet of code) or supporting it long-term.</div><br/></div></div></div></div><div id="40952530" class="c"><input type="checkbox" id="c-40952530" checked=""/><div class="controls bullet"><span class="by">grandimam</span><span>|</span><a href="#40949610">prev</a><span>|</span><a href="#40949378">next</a><span>|</span><label class="collapse" for="c-40952530">[-]</label><label class="expand" for="c-40952530">[2 more]</label></div><br/><div class="children"><div class="content">How is the no-gil performance compared to other languages like - javascript (nodejs), go, rust, and even java? If it&#x27;s bearable then I believe there is enormous value that could be generated instead of spending time porting to other languages.</div><br/><div id="40952683" class="c"><input type="checkbox" id="c-40952683" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40952530">parent</a><span>|</span><a href="#40949378">next</a><span>|</span><label class="collapse" for="c-40952683">[-]</label><label class="expand" for="c-40952683">[1 more]</label></div><br/><div class="children"><div class="content">No-GIL Python is still interpreted - single-threaded performance is slower that standard Python, which is in turn <i>much</i> slower than the languages you mentioned.<p>Maybe if you’ve got an embarrassingly parallel problem, and dozen(s) of cores to spare, you can match the performance of a single-threaded JIT&#x2F;AOT compiled program.</div><br/></div></div></div></div><div id="40949378" class="c"><input type="checkbox" id="c-40949378" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40952530">prev</a><span>|</span><a href="#40949810">next</a><span>|</span><label class="collapse" for="c-40949378">[-]</label><label class="expand" for="c-40949378">[90 more]</label></div><br/><div class="children"><div class="content">Python 3 progress so far:<p><pre><code>  [x] Async.
  [x] Optional static typing.
  [x] Threading.
  [ ] JIT.
  [ ] Efficient dependency management.</code></pre></div><br/><div id="40949416" class="c"><input type="checkbox" id="c-40949416" checked=""/><div class="controls bullet"><span class="by">janice1999</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40951283">next</a><span>|</span><label class="collapse" for="c-40949416">[-]</label><label class="expand" for="c-40949416">[39 more]</label></div><br/><div class="children"><div class="content">Not sure what this list means, there are successful languages without these feature. Also Python 3.13 [1] has an optional JIT [2], disabled by default.<p>[1] <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.13&#x2F;whatsnew&#x2F;3.13.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3.13&#x2F;whatsnew&#x2F;3.13.html</a><p>[2] <a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0744&#x2F;" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0744&#x2F;</a></div><br/><div id="40949460" class="c"><input type="checkbox" id="c-40949460" checked=""/><div class="controls bullet"><span class="by">jolux</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949416">parent</a><span>|</span><a href="#40951283">next</a><span>|</span><label class="collapse" for="c-40949460">[-]</label><label class="expand" for="c-40949460">[38 more]</label></div><br/><div class="children"><div class="content">The successful languages without efficient dependency management are painful to manage dependencies in, though. I think Python should be shooting for a better package management user experience than C++.</div><br/><div id="40949500" class="c"><input type="checkbox" id="c-40949500" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949460">parent</a><span>|</span><a href="#40950240">next</a><span>|</span><label class="collapse" for="c-40949500">[-]</label><label class="expand" for="c-40949500">[12 more]</label></div><br/><div class="children"><div class="content">If Python&#x27;s dependency management is better than anything, it&#x27;s better than C++&#x27;s. Python has pip and venv. C++ has nothing (you could say less than nothing since you also have ample opportunity for inconsistent build due to mismatching #defines as well as using the wrong binaries for your .h files and nothing remotely like type-safe linkage to mitigate human error. It also has an infinite number of build systems where each system of makefiles or cmakefiles is its own build system with its own conventions and features). In fact python is the best dependency management system for C++ code when you can get binaries build from C++ via pip install...</div><br/><div id="40949846" class="c"><input type="checkbox" id="c-40949846" checked=""/><div class="controls bullet"><span class="by">wiseowise</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949500">parent</a><span>|</span><a href="#40950578">next</a><span>|</span><label class="collapse" for="c-40949846">[-]</label><label class="expand" for="c-40949846">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If Python&#x27;s dependency management is better than anything, it&#x27;s better than C++&#x27;s.<p>That’s like the lowest possible bar to clear.</div><br/><div id="40952563" class="c"><input type="checkbox" id="c-40952563" checked=""/><div class="controls bullet"><span class="by">yosefk</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949846">parent</a><span>|</span><a href="#40950578">next</a><span>|</span><label class="collapse" for="c-40952563">[-]</label><label class="expand" for="c-40952563">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, but that was the bar set by the comment I was replying to, which claimed Python doesn&#x27;t clear it.</div><br/></div></div></div></div><div id="40950578" class="c"><input type="checkbox" id="c-40950578" checked=""/><div class="controls bullet"><span class="by">andmkl</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949500">parent</a><span>|</span><a href="#40949846">prev</a><span>|</span><a href="#40950282">next</a><span>|</span><label class="collapse" for="c-40950578">[-]</label><label class="expand" for="c-40950578">[2 more]</label></div><br/><div class="children"><div class="content">C++ has apt-get etc. because the libraries do not change all the time. Also, of course there are vcpkg and conan.<p>Whenever you try to build something via pip, the build will invariably fail. The times that NumPy built from source from PyPI are long over. In fact, at least 50% of attempted package builds fail.<p>The alternative of binary wheels is flaky.</div><br/><div id="40951921" class="c"><input type="checkbox" id="c-40951921" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950578">parent</a><span>|</span><a href="#40950282">next</a><span>|</span><label class="collapse" for="c-40951921">[-]</label><label class="expand" for="c-40951921">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C++ has apt-get<p>That&#x27;s not a development dependency manager. System package management is a different kind of issue, even if there&#x27;s a bit of overlap.<p>&gt; because the libraries do not change all the time<p>That&#x27;s not true in practice. Spend enough time with larger projects or do some software packaging and you&#x27;ll learn that the pain is everywhere.</div><br/></div></div></div></div><div id="40950282" class="c"><input type="checkbox" id="c-40950282" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949500">parent</a><span>|</span><a href="#40950578">prev</a><span>|</span><a href="#40950240">next</a><span>|</span><label class="collapse" for="c-40950282">[-]</label><label class="expand" for="c-40950282">[7 more]</label></div><br/><div class="children"><div class="content">That was the entire point, that C++ is the absolute worst.</div><br/><div id="40950902" class="c"><input type="checkbox" id="c-40950902" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950282">parent</a><span>|</span><a href="#40950240">next</a><span>|</span><label class="collapse" for="c-40950902">[-]</label><label class="expand" for="c-40950902">[6 more]</label></div><br/><div class="children"><div class="content">I pip3 installed something today. It didn’t work, at all.<p>I then yum installed a lib and headers, it worked well.<p>C++ on an msft platform is the worst. I can’t speak for Mac. C++ on a linux is quite pleasant. Feels like most of the comments like yours are biased for un-stated reasons.</div><br/><div id="40951938" class="c"><input type="checkbox" id="c-40951938" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950902">parent</a><span>|</span><a href="#40951076">next</a><span>|</span><label class="collapse" for="c-40951938">[-]</label><label class="expand" for="c-40951938">[1 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with languages. You can yum install python packages and expect them to work fine.  You can install C++ files using an actual dependency manager like vcpkg or conan and have issues.<p>You&#x27;re pointing out differences between software package management styles, not languages.</div><br/></div></div><div id="40951076" class="c"><input type="checkbox" id="c-40951076" checked=""/><div class="controls bullet"><span class="by">yupyupyups</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950902">parent</a><span>|</span><a href="#40951938">prev</a><span>|</span><a href="#40950915">next</a><span>|</span><label class="collapse" for="c-40951076">[-]</label><label class="expand" for="c-40951076">[1 more]</label></div><br/><div class="children"><div class="content">Mac has the Brew project, which is sort of like apt-get or yum.</div><br/></div></div><div id="40950915" class="c"><input type="checkbox" id="c-40950915" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950902">parent</a><span>|</span><a href="#40951076">prev</a><span>|</span><a href="#40950240">next</a><span>|</span><label class="collapse" for="c-40950915">[-]</label><label class="expand" for="c-40950915">[3 more]</label></div><br/><div class="children"><div class="content">If I had a penny for every time I gave up on compiling C++ software because there&#x27;s no way to know what dependencies it needs, I&#x27;d be a millionaire. Python at least lists them.</div><br/><div id="40952677" class="c"><input type="checkbox" id="c-40952677" checked=""/><div class="controls bullet"><span class="by">ahartmetz</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950915">parent</a><span>|</span><a href="#40951071">next</a><span>|</span><label class="collapse" for="c-40952677">[-]</label><label class="expand" for="c-40952677">[1 more]</label></div><br/><div class="children"><div class="content">Is that because the compiler failed with &quot;foo.h not found&quot; or the build system said &quot;libfoo not found&quot;? CMake is most common and it will tell you. Worst case it&#x27;s difficult to derive the package name from the name in the diagnostic.<p>It&#x27;s not great, but usually not a big deal neither IME. Typically a couple of minutes to e.g. find that required libSDL2 addon module or whatever, if there is that kind of problem at all.</div><br/></div></div><div id="40951071" class="c"><input type="checkbox" id="c-40951071" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950915">parent</a><span>|</span><a href="#40952677">prev</a><span>|</span><a href="#40950240">next</a><span>|</span><label class="collapse" for="c-40951071">[-]</label><label class="expand" for="c-40951071">[1 more]</label></div><br/><div class="children"><div class="content">If I had a penny every time I heard something like that on sites like this, I’d be a billionaire :)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40950240" class="c"><input type="checkbox" id="c-40950240" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949460">parent</a><span>|</span><a href="#40949500">prev</a><span>|</span><a href="#40949605">next</a><span>|</span><label class="collapse" for="c-40950240">[-]</label><label class="expand" for="c-40950240">[3 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s dependency management sucks because they&#x27;re audacious enough to attempt packaging non-python dependencies. People always bring Maven up as a system that got it right, but Maven only does JVM things.<p>I think the real solution here is to just only use python dependency management for python things and to use something like nix for everything else.</div><br/><div id="40950334" class="c"><input type="checkbox" id="c-40950334" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950240">parent</a><span>|</span><a href="#40949605">next</a><span>|</span><label class="collapse" for="c-40950334">[-]</label><label class="expand" for="c-40950334">[2 more]</label></div><br/><div class="children"><div class="content">Julia&#x27;s package manager (for one) works great and can manage non Julia packages. the problem with python&#x27;s system is that rejecting semver makes writing a package manager basically impossible since there is no way to automatically resolve packages.</div><br/><div id="40950874" class="c"><input type="checkbox" id="c-40950874" checked=""/><div class="controls bullet"><span class="by">woodruffw</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950334">parent</a><span>|</span><a href="#40949605">next</a><span>|</span><label class="collapse" for="c-40950874">[-]</label><label class="expand" for="c-40950874">[1 more]</label></div><br/><div class="children"><div class="content">Could you clarify what you mean? pip and every other Python package installer is absolutely doing automatic package resolution, and the standard (PEP 440) dependency operators include a compatible version operator (~=) that&#x27;s predicated on SemVer-style version behavior.</div><br/></div></div></div></div></div></div><div id="40949605" class="c"><input type="checkbox" id="c-40949605" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949460">parent</a><span>|</span><a href="#40950240">prev</a><span>|</span><a href="#40949750">next</a><span>|</span><label class="collapse" for="c-40949605">[-]</label><label class="expand" for="c-40949605">[21 more]</label></div><br/><div class="children"><div class="content">Not sure this is still a valid critic of Python in 2024.<p>Between pip, poetry and pyproject.toml, things are now quite good IMHO.</div><br/><div id="40949957" class="c"><input type="checkbox" id="c-40949957" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949605">parent</a><span>|</span><a href="#40949678">next</a><span>|</span><label class="collapse" for="c-40949957">[-]</label><label class="expand" for="c-40949957">[16 more]</label></div><br/><div class="children"><div class="content">I guess that depends from your perspective. I&#x27;m not a Python developer, but like many people I do want to run Python programs from time to time.<p>I don&#x27;t really know Rust, or Cargo, but I never have trouble building any Rust program: &quot;cargo build [--release]&quot; is all I need to know. Easy. Even many C programs are actually quite easy: &quot;.&#x2F;configure&quot;, &quot;make&quot;, and optionally &quot;make install&quot;. &quot;.&#x2F;configure&quot; has a nice &quot;--help&quot;. There is a lot to be said about the ugly generated autotools soup, but the UX for people just wanting to build&#x2F;run it without in-depth knowledge of the system is actually quite decent. cmake is a regression here.<p>With Python, &quot;pip install&quot; gives me an entire screen full of errors about venv and &quot;externally managed&quot; and whatnot. I don&#x27;t care. I just want to run it. I don&#x27;t want a bunch of venvs, I just want to install or run the damn program. I&#x27;ve taken to just use &quot;pip install --break-system-packages&quot;, which installs to ~&#x2F;.local. It works <i>shrug</i>.<p>Last time I wanted to just run a project with a few small modifications I had a hard time. I ended up just editing ~&#x2F;.local&#x2F;lib&#x2F;python&#x2F;[...] Again, it worked so whatever.<p>All of this is really where Python and some other languages&#x2F;build systems fail. Many people running this are not $language_x programmers or experts, and I don&#x27;t want to read up on every system I come across. That&#x27;s not a reasonable demand.<p>Any system that doesn&#x27;t allow non-users of that language to use it in simple easy steps needs work. Python&#x27;s system is one such system.</div><br/><div id="40950079" class="c"><input type="checkbox" id="c-40950079" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949957">parent</a><span>|</span><a href="#40950417">next</a><span>|</span><label class="collapse" for="c-40950079">[-]</label><label class="expand" for="c-40950079">[8 more]</label></div><br/><div class="children"><div class="content">&quot;I don&#x27;t want a bunch of venvs&quot;<p>That&#x27;s your problem right there.<p>Virtual environments are the Python ecosystem&#x27;s solution to the problem of wanting to install different things on the same machine that have different conflicting requirements.<p>If you refuse to use virtual environments and you install more than one separate Python project you&#x27;re going to run into conflicting requirements and it&#x27;s going to suck.<p>Have you tried pipx? If you&#x27;re just installing Python tools (and not hacking on them yourself) it&#x27;s fantastic - it manages separate virtual environments for each of your installations without you having to think about them (or even know what a virtual environment is).</div><br/><div id="40950213" class="c"><input type="checkbox" id="c-40950213" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950079">parent</a><span>|</span><a href="#40950232">next</a><span>|</span><label class="collapse" for="c-40950213">[-]</label><label class="expand" for="c-40950213">[4 more]</label></div><br/><div class="children"><div class="content">Managing a farm of virtualenvs and mucking about with my PATH doesn&#x27;t address the user-installable problem at all. And it seems there&#x27;s a new tool to try every few months that really will fix all problems this time.<p>And maybe if you&#x27;re a Python developer working on the code every day that&#x27;s all brilliant. But most people aren&#x27;t Python developers, and I just want to try that &quot;Show HN&quot; project or whatnot.<p>Give me a single command I can run. Always. For any project. And that always works. If you don&#x27;t have that then your build system needs work.</div><br/><div id="40950743" class="c"><input type="checkbox" id="c-40950743" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950213">parent</a><span>|</span><a href="#40951996">next</a><span>|</span><label class="collapse" for="c-40950743">[-]</label><label class="expand" for="c-40950743">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Give me a single command I can run. Always. For any project. And that always works.&quot;<p><pre><code>    pipx install X</code></pre></div><br/><div id="40952474" class="c"><input type="checkbox" id="c-40952474" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950743">parent</a><span>|</span><a href="#40951996">next</a><span>|</span><label class="collapse" for="c-40952474">[-]</label><label class="expand" for="c-40952474">[1 more]</label></div><br/><div class="children"><div class="content">Right so; I&#x27;ll try that next time. Thanks. I just go by the very prominent &quot;pip install X&quot; on every pypi page (as well as &quot;pip install ..&quot; in many READMEs).</div><br/></div></div></div></div><div id="40951996" class="c"><input type="checkbox" id="c-40951996" checked=""/><div class="controls bullet"><span class="by">Ringz</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950213">parent</a><span>|</span><a href="#40950743">prev</a><span>|</span><a href="#40950232">next</a><span>|</span><label class="collapse" for="c-40951996">[-]</label><label class="expand" for="c-40951996">[1 more]</label></div><br/><div class="children"><div class="content">That single command is pipx.</div><br/></div></div></div></div><div id="40950232" class="c"><input type="checkbox" id="c-40950232" checked=""/><div class="controls bullet"><span class="by">guhidalg</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950079">parent</a><span>|</span><a href="#40950213">prev</a><span>|</span><a href="#40950417">next</a><span>|</span><label class="collapse" for="c-40950232">[-]</label><label class="expand" for="c-40950232">[3 more]</label></div><br/><div class="children"><div class="content">Normal users who just want to run some code shouldn&#x27;t need to learn why they need a venv or any of its alternatives. Normal users just want to download a package and run some code without having to think about interfering with other packages. Many programming languages package managers give them that UX and you can&#x27;t blame them for expecting that from Python. The added step of having to think about venvs with Python is not good. It is a non-trivial system that every single Python user is forced to learn, understand, and the continually remember every time they switch from one project to another.</div><br/><div id="40950672" class="c"><input type="checkbox" id="c-40950672" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950232">parent</a><span>|</span><a href="#40950748">next</a><span>|</span><label class="collapse" for="c-40950672">[-]</label><label class="expand" for="c-40950672">[1 more]</label></div><br/><div class="children"><div class="content">This is correct. The whole <i>application</i> installation process, including the creation of a venv, installing stuff into it, and registering it with some on-PATH launcher should be one command.<p>BTW pyenv comes relatively close.</div><br/></div></div><div id="40950748" class="c"><input type="checkbox" id="c-40950748" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950232">parent</a><span>|</span><a href="#40950672">prev</a><span>|</span><a href="#40950417">next</a><span>|</span><label class="collapse" for="c-40950748">[-]</label><label class="expand" for="c-40950748">[1 more]</label></div><br/><div class="children"><div class="content">I agree with that. Until we solve that larger problem, people need to learn to use virtual environments, or at least learn to install Python tools using pipx.</div><br/></div></div></div></div></div></div><div id="40950417" class="c"><input type="checkbox" id="c-40950417" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949957">parent</a><span>|</span><a href="#40950079">prev</a><span>|</span><a href="#40951962">next</a><span>|</span><label class="collapse" for="c-40950417">[-]</label><label class="expand" for="c-40950417">[1 more]</label></div><br/><div class="children"><div class="content">This is mostly a curse of Python’s popularity. The reason you can’t pip install with system Python is that it can break things, and when your system is relying on Python to run various tools, that can’t be allowed. No one (sane) is building OS-level scripts with Node.<p>The simplest answer, IMO, is to download the Python source code, build it, and then run make altinstall. It’ll install in parallel with system Python, and you can then alias the new executable path so you no longer have to think about it. Assuming you already have gcc’s tool chain installed, it takes roughly 10-15 minutes to build. Not a big deal.</div><br/></div></div><div id="40951962" class="c"><input type="checkbox" id="c-40951962" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949957">parent</a><span>|</span><a href="#40950417">prev</a><span>|</span><a href="#40950267">next</a><span>|</span><label class="collapse" for="c-40951962">[-]</label><label class="expand" for="c-40951962">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I am biased, because I learned these things so long ago and I don&#x27;t realize that it&#x27;s a pain to learn. But what exactly is so confusing about virtualenvs ?<p>They really not that different from any other packaging system like JS or Rust. The only difference is instead of relying on your current directory to find the the libraries &#x2F; binaries (and thus requiring you to wrap binaries call with some wrapper to search in a specific path), they rely on you sourcing an `activate` script. That&#x27;s really just it.<p>Create a Virtualenv:<p><pre><code>    $ virtualenv myenv
</code></pre>
Activate it, now it is added to your $PATH:<p><pre><code>    $ . myenv&#x2F;bin&#x2F;activate
</code></pre>
There really is nothing more in the normal case.<p>If you don&#x27;t want to have to remember it, create a global Virtualenv somewhere, source it&#x27;s activate in your .bashrc, and forget it ever existed.</div><br/></div></div><div id="40950267" class="c"><input type="checkbox" id="c-40950267" checked=""/><div class="controls bullet"><span class="by">vhcr</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949957">parent</a><span>|</span><a href="#40951962">prev</a><span>|</span><a href="#40949678">next</a><span>|</span><label class="collapse" for="c-40950267">[-]</label><label class="expand" for="c-40950267">[5 more]</label></div><br/><div class="children"><div class="content">Do you have a problem with Node.js too because it creates a node_modules folder, or is the problem that it is not handled automatically?</div><br/><div id="40950347" class="c"><input type="checkbox" id="c-40950347" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950267">parent</a><span>|</span><a href="#40949678">next</a><span>|</span><label class="collapse" for="c-40950347">[-]</label><label class="expand" for="c-40950347">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t care about the internals. I care about &quot;just&quot; being able to run it.<p>I find that most JS projects work fairly well: &quot;npm install&quot; maybe followed by &quot;npm run build&quot; or the like. This isn&#x27;t enforced by npm and I don&#x27;t think npm is perfect here, but practical speaking as a non-JS dev just wanting to run some JS projects: it works fairly well for almost all JS projects I&#x27;ve wanted to run in the last five years or so.<p>A &quot;run_me.py&quot; that would *Just Work™&quot; is fine. I don&#x27;t overly care what it does internally as long as it&#x27;s not hugely slow or depends on anything other than &quot;python&quot;. Ideally this should be consistent throughout the ecosystem.<p>To be honest I can&#x27;t imagine shipping any project intended to be run by users and not have a simple, fool-proof, and low-effort way of running it by anyone of any skill level, which doesn&#x27;t depend on any real knowledge of the language.</div><br/><div id="40950443" class="c"><input type="checkbox" id="c-40950443" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950347">parent</a><span>|</span><a href="#40949678">next</a><span>|</span><label class="collapse" for="c-40950443">[-]</label><label class="expand" for="c-40950443">[3 more]</label></div><br/><div class="children"><div class="content">&gt; To be honest I can&#x27;t imagine shipping any project intended to be run by users and not have a simple, fool-proof, and low-effort way of running it by anyone of any skill level, which doesn&#x27;t depend on any real knowledge of the language.<p>This is how we got GH Issues full of inane comments, and blogs from mediocre devs recommending things they know nothing about.<p>I see nothing wrong with not catering to the lowest common denominator.</div><br/><div id="40950511" class="c"><input type="checkbox" id="c-40950511" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950443">parent</a><span>|</span><a href="#40949678">next</a><span>|</span><label class="collapse" for="c-40950511">[-]</label><label class="expand" for="c-40950511">[2 more]</label></div><br/><div class="children"><div class="content">Like people with actual lives to live and useful stuff to do that&#x27;s not learning about and hand-holding a dozen different half-baked build systems.<p>But sure, keep up the cynical illusion that everyone is an idiot if that&#x27;s what you need to go through life.</div><br/><div id="40950570" class="c"><input type="checkbox" id="c-40950570" checked=""/><div class="controls bullet"><span class="by">sgarland</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950511">parent</a><span>|</span><a href="#40949678">next</a><span>|</span><label class="collapse" for="c-40950570">[-]</label><label class="expand" for="c-40950570">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t say that everyone is an idiot. I implied that gate keeping is useful as a first pass against people who are unlikely to have the drive to keep going when they experience difficulty.<p>When I was a kid, docs were literally a book. If you asked for help and didn’t cite what you had already tried &#x2F; read, you’d be told to RTFM.<p>Python has several problems. Its relative import system is deranged, packaging is a mess, and yes, on its face needing to run a parallel copy of the interpreter to pip install something is absurd. I still love it. It’s baked into every *nix distro, a REPL is a command away, and its syntax is intuitive.<p>I maintain that the relative ease of JS – and more powerfully, Node – has created a monstrous ecosystem of poorly written software, with its adherents jumping to the latest shiny every few months because this time, it’s different. And I _like_ JS (as a frontend language).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40949678" class="c"><input type="checkbox" id="c-40949678" checked=""/><div class="controls bullet"><span class="by">Arcanum-XIII</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949605">parent</a><span>|</span><a href="#40949957">prev</a><span>|</span><a href="#40949750">next</a><span>|</span><label class="collapse" for="c-40949678">[-]</label><label class="expand" for="c-40949678">[4 more]</label></div><br/><div class="children"><div class="content">All is well, then, one day, you have to update one library.<p>Some days later, in some woods or cave, people will hear your screams of rage and despair.</div><br/><div id="40949740" class="c"><input type="checkbox" id="c-40949740" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949678">parent</a><span>|</span><a href="#40949750">next</a><span>|</span><label class="collapse" for="c-40949740">[-]</label><label class="expand" for="c-40949740">[3 more]</label></div><br/><div class="children"><div class="content">Been using python for 15 years now, and these screams were never heard.<p>Dev&#x2F;test with relaxed pip installs, freeze deployment dependencies with pip freeze&#x2F;pip-tools&#x2F;poetry&#x2F;whateveryoulike, and what&#x27;s the problem?</div><br/><div id="40949982" class="c"><input type="checkbox" id="c-40949982" checked=""/><div class="controls bullet"><span class="by">neeleshs</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949740">parent</a><span>|</span><a href="#40951213">next</a><span>|</span><label class="collapse" for="c-40949982">[-]</label><label class="expand" for="c-40949982">[1 more]</label></div><br/><div class="children"><div class="content">same here. Been using python&#x2F;pip for 10+ years and this was never a problem. In the java world, there is jar hell, but it was never a crippling issue, but a minor annoyance once a year or so.<p>In general, is dependency management such a massive problem it is made to be on HN? Maybe people here are doing far more complex&#x2F;different things than I&#x27;ve done in the past 20 years</div><br/></div></div><div id="40951213" class="c"><input type="checkbox" id="c-40951213" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949740">parent</a><span>|</span><a href="#40949982">prev</a><span>|</span><a href="#40949750">next</a><span>|</span><label class="collapse" for="c-40951213">[-]</label><label class="expand" for="c-40951213">[1 more]</label></div><br/><div class="children"><div class="content">Guessing that folks who write such things are lacking sysad skills like manipulating paths, etc.<p>It does take Python expertise to fix other issues on occasion but they are fixable.  Why I think flags like ‘pip —break-system-packages’ are silly.  It’s an optimization for non-users over experienced ones.</div><br/></div></div></div></div></div></div></div></div><div id="40949750" class="c"><input type="checkbox" id="c-40949750" checked=""/><div class="controls bullet"><span class="by">est</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949460">parent</a><span>|</span><a href="#40949605">prev</a><span>|</span><a href="#40951283">next</a><span>|</span><label class="collapse" for="c-40949750">[-]</label><label class="expand" for="c-40949750">[1 more]</label></div><br/><div class="children"><div class="content">Deps in CPython are more about .so&#x2F;.dll problem, not much can be done since stuff happens outside python itself.</div><br/></div></div></div></div></div></div><div id="40951283" class="c"><input type="checkbox" id="c-40951283" checked=""/><div class="controls bullet"><span class="by">whoiscroberts</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40949416">prev</a><span>|</span><a href="#40951733">next</a><span>|</span><label class="collapse" for="c-40951283">[-]</label><label class="expand" for="c-40951283">[1 more]</label></div><br/><div class="children"><div class="content">Optional static typing, not really. Those type hints are not used at runtime for performance. Type hint a var as a string then set it to an init, that code still gonna try to execute.</div><br/></div></div><div id="40951733" class="c"><input type="checkbox" id="c-40951733" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40951283">prev</a><span>|</span><a href="#40949718">next</a><span>|</span><label class="collapse" for="c-40951733">[-]</label><label class="expand" for="c-40951733">[2 more]</label></div><br/><div class="children"><div class="content">Python 3.12 introduces a little bit of JIT. Also, there is always pypy.<p>For efficient dependency management, there is now rye and UV. So maybe you can check all those boxes?</div><br/><div id="40952067" class="c"><input type="checkbox" id="c-40952067" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40951733">parent</a><span>|</span><a href="#40949718">next</a><span>|</span><label class="collapse" for="c-40952067">[-]</label><label class="expand" for="c-40952067">[1 more]</label></div><br/><div class="children"><div class="content">Rye is pretty alpha, uv is young, too, and they are not part of &quot;core&quot; Python, not under the Python Foundation umbrella (like e.g. mypy is).<p>So there&#x27;s plenty of well-founded hope, but the boxes are still not checked.</div><br/></div></div></div></div><div id="40949718" class="c"><input type="checkbox" id="c-40949718" checked=""/><div class="controls bullet"><span class="by">ramses0</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40951733">prev</a><span>|</span><a href="#40949547">next</a><span>|</span><label class="collapse" for="c-40949718">[-]</label><label class="expand" for="c-40949718">[2 more]</label></div><br/><div class="children"><div class="content">You forgot:<p><pre><code>    [X] print requires parentheses</code></pre></div><br/><div id="40951447" class="c"><input type="checkbox" id="c-40951447" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949718">parent</a><span>|</span><a href="#40949547">next</a><span>|</span><label class="collapse" for="c-40951447">[-]</label><label class="expand" for="c-40951447">[1 more]</label></div><br/><div class="children"><div class="content">Fair. But it was importable from __future__ back in 2.7.</div><br/></div></div></div></div><div id="40949547" class="c"><input type="checkbox" id="c-40949547" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40949718">prev</a><span>|</span><a href="#40949901">next</a><span>|</span><label class="collapse" for="c-40949547">[-]</label><label class="expand" for="c-40949547">[2 more]</label></div><br/><div class="children"><div class="content">The conda-forge ecosystem is making big strides in dependency management. No more are we stuck with the abysmal pip+venv story.</div><br/><div id="40950633" class="c"><input type="checkbox" id="c-40950633" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949547">parent</a><span>|</span><a href="#40949901">next</a><span>|</span><label class="collapse" for="c-40950633">[-]</label><label class="expand" for="c-40950633">[1 more]</label></div><br/><div class="children"><div class="content">I definitely like some aspects of conda, but at least pip doesn&#x27;t give me these annoying infinite &quot;Solving environment&quot; loops [0].<p>[0] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;56262012&#x2F;conda-install-takes-forever-stuck-as-sat-solver" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;56262012&#x2F;conda-install-t...</a></div><br/></div></div></div></div><div id="40949901" class="c"><input type="checkbox" id="c-40949901" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40949547">prev</a><span>|</span><a href="#40949736">next</a><span>|</span><label class="collapse" for="c-40949901">[-]</label><label class="expand" for="c-40949901">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m eager to see what a simple JIT can bring to computing energy savings on python apps.</div><br/><div id="40952280" class="c"><input type="checkbox" id="c-40952280" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949901">parent</a><span>|</span><a href="#40949736">next</a><span>|</span><label class="collapse" for="c-40952280">[-]</label><label class="expand" for="c-40952280">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d wager the energy savings could put multiple power plants out of service.<p>I regularly encounter python code which takes minutes to execute but runs in less than a second when replacing key parts with compiled code.</div><br/></div></div></div></div><div id="40949736" class="c"><input type="checkbox" id="c-40949736" checked=""/><div class="controls bullet"><span class="by">VeejayRampay</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40949901">prev</a><span>|</span><a href="#40949506">next</a><span>|</span><label class="collapse" for="c-40949736">[-]</label><label class="expand" for="c-40949736">[3 more]</label></div><br/><div class="children"><div class="content">the efficient dependency management is coming, the good people of astral will take care of that with the uv-backed version of rye (initially created by Armin Ronacher with inspirations from Cargo), I&#x27;m really confident it&#x27;ll be good like ruff and uv were good</div><br/><div id="40950952" class="c"><input type="checkbox" id="c-40950952" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949736">parent</a><span>|</span><a href="#40949506">next</a><span>|</span><label class="collapse" for="c-40950952">[-]</label><label class="expand" for="c-40950952">[2 more]</label></div><br/><div class="children"><div class="content">rye&#x27;s habit of insisting on creating a .venv per project is a deal-breaker. I don&#x27;t want .venvs spread all over my projects eating into space (made worse by the ml&#x2F;LLM related mega packages). It should atleast respect activated venvs.</div><br/><div id="40951467" class="c"><input type="checkbox" id="c-40951467" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950952">parent</a><span>|</span><a href="#40949506">next</a><span>|</span><label class="collapse" for="c-40951467">[-]</label><label class="expand" for="c-40951467">[1 more]</label></div><br/><div class="children"><div class="content">A venv per project is a very sane way.
Put them into the ignore file. Hopefully they also could live elsewhere in the tree.</div><br/></div></div></div></div></div></div><div id="40949506" class="c"><input type="checkbox" id="c-40949506" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#40949378">parent</a><span>|</span><a href="#40949736">prev</a><span>|</span><a href="#40949810">next</a><span>|</span><label class="collapse" for="c-40949506">[-]</label><label class="expand" for="c-40949506">[38 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get how this optional static typing works. I had a quick look at [1], and it begins with a note saying that Python&#x27;s runtime doesn&#x27;t enforce types, leaving the impression that you need to use third-party tools to do actual type checking. But then it continues just like Python does the check. Consider that I&#x27;m not a Python programmer, but the main reason I stay away from it is the lack of a proper type system. If this is going to change, I might reconsider it.<p>[1] <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;typing.html" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;typing.html</a></div><br/><div id="40949563" class="c"><input type="checkbox" id="c-40949563" checked=""/><div class="controls bullet"><span class="by">sveiss</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949588">next</a><span>|</span><label class="collapse" for="c-40949563">[-]</label><label class="expand" for="c-40949563">[2 more]</label></div><br/><div class="children"><div class="content">The parser supports the type hint syntax, and the standard library provides various type hint related objects.<p>So you can do things like “from typing import Optional” to bring Optional into scope, and then annotate a function with -&gt; Optional[int] to indicate it returns None or an int.<p>Unlike a system using special comments for type hints, the interpreter will complain if you make a typo in the word Optional or don’t bring it into scope.<p>But the interpreter doesn’t do anything else; if you actually return a string from that annotated function it won’t complain.<p>You need an external third party tool like MyPy or Pyre to consume the hint information and produce warnings.<p>In practice it’s quite usable, so long as you have CI enforcing the type system. You can gradually add types to an existing code base, and IDEs can use the hint information to support code navigation and error highlighting.</div><br/><div id="40951616" class="c"><input type="checkbox" id="c-40951616" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949563">parent</a><span>|</span><a href="#40949588">next</a><span>|</span><label class="collapse" for="c-40951616">[-]</label><label class="expand" for="c-40951616">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In practice it’s quite usable<p>It would be super helpful if the interpreter had a type-enforcing mode though. All the various external runtime enforcement packages leave something to be desired.</div><br/></div></div></div></div><div id="40949588" class="c"><input type="checkbox" id="c-40949588" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949563">prev</a><span>|</span><a href="#40949551">next</a><span>|</span><label class="collapse" for="c-40949588">[-]</label><label class="expand" for="c-40949588">[3 more]</label></div><br/><div class="children"><div class="content">At MPOW most Python code is well-type-hinted, and mypy and pyright are very helpful at finding issues, and also for stuff like code completion and navigation, e.g. &quot;go to the definition of the type of this variable&quot;.<p>Works pretty efficiently.<p>BTW, Typescript also does not enforce types at runtime. Heck, C++ does not enforce types at runtime either. It does not mean that their static typing systems don&#x27;t help during at development time.</div><br/><div id="40949721" class="c"><input type="checkbox" id="c-40949721" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949588">parent</a><span>|</span><a href="#40949551">next</a><span>|</span><label class="collapse" for="c-40949721">[-]</label><label class="expand" for="c-40949721">[2 more]</label></div><br/><div class="children"><div class="content">&gt; BTW, Typescript also does not enforce types at runtime. Heck, C++ does not enforce types at runtime either. It does not mean that their static typing systems don&#x27;t help during at development time.<p>Speaking of C here as I don&#x27;t have web development experience. The static type system does help, but in this case, it&#x27;s the compiler doing the check at compile time to spare you many surprises at runtime. And it&#x27;s part of the language&#x27;s standard. Python itself doesn&#x27;t do that. Good that you can use external tools, but I would prefer if this was part of Python&#x27;s spec.<p>Edit: these days I&#x27;m thinking of having a look at Mojo, it seems to do what I would like from Python.</div><br/><div id="40950880" class="c"><input type="checkbox" id="c-40950880" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949721">parent</a><span>|</span><a href="#40949551">next</a><span>|</span><label class="collapse" for="c-40950880">[-]</label><label class="expand" for="c-40950880">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;mypy">https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;mypy</a><p>&gt; Python itself doesn&#x27;t do that<p>The type syntax <i>is</i> python. MyPy is part of Python. It&#x27;s maintained by the python foundation. Mypy is not part of <i>CPython</i> because modularity is good, the same way that ANSI C doesn&#x27;t compile anything, that&#x27;s what gcc, clang, etc are for.<p>Mojo is literally exactly the same way, the types are optional, and the tooling handles type checking and compilation.</div><br/></div></div></div></div></div></div><div id="40949551" class="c"><input type="checkbox" id="c-40949551" checked=""/><div class="controls bullet"><span class="by">davepeck</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949588">prev</a><span>|</span><a href="#40949562">next</a><span>|</span><label class="collapse" for="c-40949551">[-]</label><label class="expand" for="c-40949551">[1 more]</label></div><br/><div class="children"><div class="content">Third party tools (mypy, pyright, etc) are expected to check types. cpython itself does not. This will run just fine:<p>python -c &quot;x: int = &#x27;not_an_int&#x27;&quot;<p>My opinion is that with PEP 695 landing in Python 3.12, the type system itself is starting to feel robust.<p>These days, the python ecosystem&#x27;s key packages all tend to have extensive type hints.<p>The type checkers are of varying quality; my experience is that pyright is fast and correct, while mypy (not having the backing of a Microsoft) is slower and lags on features a little bit -- for instance, mypy still hasn&#x27;t finalized support for PEP 695 syntax.</div><br/></div></div><div id="40949562" class="c"><input type="checkbox" id="c-40949562" checked=""/><div class="controls bullet"><span class="by">zitterbewegung</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949551">prev</a><span>|</span><a href="#40949536">next</a><span>|</span><label class="collapse" for="c-40949562">[-]</label><label class="expand" for="c-40949562">[6 more]</label></div><br/><div class="children"><div class="content">Optional static typing is just like a comment (real term is annotation) of the input variable(s) and return variable(s). No optimization is performed. Using a tool such as mypy that kicks off on a CI&#x2F;CD process technically enforces types but they are ignored by the interpreter unless you make a syntax error.</div><br/><div id="40949593" class="c"><input type="checkbox" id="c-40949593" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949562">parent</a><span>|</span><a href="#40950888">next</a><span>|</span><label class="collapse" for="c-40949593">[-]</label><label class="expand" for="c-40949593">[4 more]</label></div><br/><div class="children"><div class="content">A language server in your IDE kicks in much earlier, and is even more helpful.</div><br/><div id="40950779" class="c"><input type="checkbox" id="c-40950779" checked=""/><div class="controls bullet"><span class="by">zitterbewegung</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949593">parent</a><span>|</span><a href="#40950888">next</a><span>|</span><label class="collapse" for="c-40950779">[-]</label><label class="expand" for="c-40950779">[3 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used an IDE that has that but it is still just giving you a hint that there is an error and the interpreter is not throwing an error which was my point.</div><br/><div id="40950913" class="c"><input type="checkbox" id="c-40950913" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950779">parent</a><span>|</span><a href="#40950888">next</a><span>|</span><label class="collapse" for="c-40950913">[-]</label><label class="expand" for="c-40950913">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true of most compiled languages. Unless we are talking about asserts, reflection, I think type erasure, and maybe a few other concepts, language runtimes don&#x27;t check types. C does not check types at runtime. You compile it and then rely on control of invariants and data flow to keep everything on rails. In python, this is tricky because <i>everything</i> is behind at least one layer of indirection, and thus virtually everything is mutable, so it&#x27;s hard to enforce total control of all data structures. But you can get really close with modern tooling.</div><br/><div id="40951360" class="c"><input type="checkbox" id="c-40951360" checked=""/><div class="controls bullet"><span class="by">cwalv</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950913">parent</a><span>|</span><a href="#40950888">next</a><span>|</span><label class="collapse" for="c-40951360">[-]</label><label class="expand" for="c-40951360">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; and the interpreter is not throwing an error which was my point.
&gt; That&#x27;s true of most compiled languages<p>True of most statically typed languages (usually no need to check at runtime), but not true in Python or other dynamically typed languages. Python would have been unusable for decades (prior to typehints) if that was true.</div><br/></div></div></div></div></div></div></div></div><div id="40950888" class="c"><input type="checkbox" id="c-40950888" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949562">parent</a><span>|</span><a href="#40949593">prev</a><span>|</span><a href="#40949536">next</a><span>|</span><label class="collapse" for="c-40950888">[-]</label><label class="expand" for="c-40950888">[1 more]</label></div><br/><div class="children"><div class="content">Nope. Type annotations can be executed and accessed by the runtime. That&#x27;s how things like Pydantic, msgspec, etc, do runtime type enforcement and coercion.<p>There are also multiple compilers (mypyc, nuitka, others I forget) which take advantage of types to compile python to machine code.</div><br/></div></div></div></div><div id="40949536" class="c"><input type="checkbox" id="c-40949536" checked=""/><div class="controls bullet"><span class="by">wk_end</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949562">prev</a><span>|</span><a href="#40950909">next</a><span>|</span><label class="collapse" for="c-40949536">[-]</label><label class="expand" for="c-40949536">[2 more]</label></div><br/><div class="children"><div class="content">The interpreter does not and probably never will check types. The annotations are treated as effectively meaningless at runtime. External tools like mypy can be run over your code and check them.</div><br/><div id="40951375" class="c"><input type="checkbox" id="c-40951375" checked=""/><div class="controls bullet"><span class="by">cwalv</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949536">parent</a><span>|</span><a href="#40950909">next</a><span>|</span><label class="collapse" for="c-40951375">[-]</label><label class="expand" for="c-40951375">[1 more]</label></div><br/><div class="children"><div class="content">It checks types .. it doesn&#x27;t check type annotations.<p>Just try:<p><pre><code>  $ Python
  &gt;&gt;&gt; 1 + &#x27;3&#x27;</code></pre></div><br/></div></div></div></div><div id="40950909" class="c"><input type="checkbox" id="c-40950909" checked=""/><div class="controls bullet"><span class="by">NegativeK</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949536">prev</a><span>|</span><a href="#40949535">next</a><span>|</span><label class="collapse" for="c-40950909">[-]</label><label class="expand" for="c-40950909">[1 more]</label></div><br/><div class="children"><div class="content">Python&#x27;s typing must accommodate Python&#x27;s other goal as quick scripting language. The solution is to document the optional typing system as part of the language&#x27;s spec and let other tools do the checking, if a user wants to use them.<p>The other tools are trivially easy to set up and run (or let your IDE run for you.) As in, one command to install, one command to run. It&#x27;s an elegant compromise that brings something that&#x27;s sorely needed to Python, and users will spend more time loading the typing spec in their browser than they will installing the type checker.</div><br/></div></div><div id="40949760" class="c"><input type="checkbox" id="c-40949760" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949535">prev</a><span>|</span><a href="#40949744">next</a><span>|</span><label class="collapse" for="c-40949760">[-]</label><label class="expand" for="c-40949760">[10 more]</label></div><br/><div class="children"><div class="content">I think static typing is a waste of time, but given that you want it, I can see why you wouldn&#x27;t want to use Python. Its type-checking is more half-baked and cumbersome than other languages, even TS.</div><br/><div id="40950153" class="c"><input type="checkbox" id="c-40950153" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949760">parent</a><span>|</span><a href="#40950425">next</a><span>|</span><label class="collapse" for="c-40950153">[-]</label><label class="expand" for="c-40950153">[5 more]</label></div><br/><div class="children"><div class="content">I used to think like that until I tried.<p>There are areas where typing is more important: public interfaces. You don&#x27;t have to make every piece of your program well-typed. But signatures of your public functions &#x2F; methods matter a lot, and from them types of many internal things can be inferred.<p>If your code has a well-typed interface, it&#x27;s pleasant to work with. If interfaces of the libraries you use are well-typed, you have easier time writing your code (that interacts with them). Eventually you type more and more code you write and alter, and keep reaping the benefits.</div><br/><div id="40950201" class="c"><input type="checkbox" id="c-40950201" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950153">parent</a><span>|</span><a href="#40950169">next</a><span>|</span><label class="collapse" for="c-40950201">[-]</label><label class="expand" for="c-40950201">[2 more]</label></div><br/><div class="children"><div class="content">This was the thing that started to bring me around to optional typing as well. It makes the most sense to me as a form of documentation - it&#x27;s really useful to know what types are expected (and returned) by a Python function!<p>If that&#x27;s baked into the code itself, your text editor can show inline information - which saves you from having to go and look at the documentation yourself.<p>I&#x27;ve started trying to add types to my libraries that expose a public API now. I think it&#x27;s worth the extra effort just for the documentation benefit it provides.</div><br/><div id="40950222" class="c"><input type="checkbox" id="c-40950222" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950201">parent</a><span>|</span><a href="#40950169">next</a><span>|</span><label class="collapse" for="c-40950222">[-]</label><label class="expand" for="c-40950222">[1 more]</label></div><br/><div class="children"><div class="content">This is what made me give it a shot in TS, but the problem is your types at interface boundaries tend to be annoyingly complex. The other problem is any project with optional types soon becomes a project with required types everywhere.<p>There might be more merit in widely-used public libraries, though. I don&#x27;t make those.</div><br/></div></div></div></div><div id="40950169" class="c"><input type="checkbox" id="c-40950169" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40950153">parent</a><span>|</span><a href="#40950201">prev</a><span>|</span><a href="#40950425">next</a><span>|</span><label class="collapse" for="c-40950169">[-]</label><label class="expand" for="c-40950169">[2 more]</label></div><br/><div class="children"><div class="content">I shouldn&#x27;t have said it&#x27;s a waste of time period, cause every project I work on <i>does</i> have static typing in two very important places: the RPC or web API (OpenAPI, gRPC, whatever it is), and the relational database. But not in the main JS or Py code. That&#x27;s all I&#x27;ve ever needed.<p>I did try migrating a NodeJS backend to TS along with a teammate driving that effort. The type-checking never ended up catching any bugs, and the extra time we spent on that stuff could&#x27;ve gone into better testing instead. So it actually made things more dangerous.</div><br/></div></div></div></div><div id="40950425" class="c"><input type="checkbox" id="c-40950425" checked=""/><div class="controls bullet"><span class="by">grumpyprole</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949760">parent</a><span>|</span><a href="#40950153">prev</a><span>|</span><a href="#40949826">next</a><span>|</span><label class="collapse" for="c-40950425">[-]</label><label class="expand" for="c-40950425">[1 more]</label></div><br/><div class="children"><div class="content">A type checker is only going to add limited value if you don&#x27;t put the effort in yourself. If everything string-like is just a string, and if data is not parsed into types that maintain invariants, then little is being constrained and there is little to &quot;check&quot;. It becomes increasingly difficult the more sophisticated the type system is, but in some statically typed languages like Coq, clever programmers can literally prove the correctness of their program using the type system. Whereas a unit test can only prove the presence of bugs, not their absence.</div><br/></div></div><div id="40949826" class="c"><input type="checkbox" id="c-40949826" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949760">parent</a><span>|</span><a href="#40950425">prev</a><span>|</span><a href="#40949916">next</a><span>|</span><label class="collapse" for="c-40949826">[-]</label><label class="expand" for="c-40949826">[2 more]</label></div><br/><div class="children"><div class="content">Typescript is pretty much the gold standard, it’s amazing how much JavaScript madness you can work around just on the typechecking level.<p>IMHO Python should shamelessly steal as much typescript’s typing as possible. It’s tough since the Microsoft typescript team is apparently amazing at what they do so for now it’s a very fast moving target but some day…</div><br/><div id="40950143" class="c"><input type="checkbox" id="c-40950143" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949826">parent</a><span>|</span><a href="#40949916">next</a><span>|</span><label class="collapse" for="c-40950143">[-]</label><label class="expand" for="c-40950143">[1 more]</label></div><br/><div class="children"><div class="content">Well the TS tooling is more painful in ways. It&#x27;s not compatible with some stuff like the NodeJS profiler. Also there&#x27;s some mess around modules vs &quot;require&quot; syntax that I don&#x27;t understand fully but TS somehow plays a role.</div><br/></div></div></div></div><div id="40949916" class="c"><input type="checkbox" id="c-40949916" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949760">parent</a><span>|</span><a href="#40949826">prev</a><span>|</span><a href="#40949744">next</a><span>|</span><label class="collapse" for="c-40949916">[-]</label><label class="expand" for="c-40949916">[1 more]</label></div><br/><div class="children"><div class="content">I instead think that the lack of static typing is a waste of time, since without it you can have programs that waste hours of computation due to an exception that would have been prevented by a proper type system ;)</div><br/></div></div></div></div><div id="40949744" class="c"><input type="checkbox" id="c-40949744" checked=""/><div class="controls bullet"><span class="by">VeejayRampay</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949506">parent</a><span>|</span><a href="#40949760">prev</a><span>|</span><a href="#40949810">next</a><span>|</span><label class="collapse" for="c-40949744">[-]</label><label class="expand" for="c-40949744">[11 more]</label></div><br/><div class="children"><div class="content">python will never be &quot;properly typed&quot;<p>what it has is &quot;type hints&quot; which is way to have richer integration with type checkers and your IDE, but will never offer more than that as is</div><br/><div id="40950762" class="c"><input type="checkbox" id="c-40950762" checked=""/><div class="controls bullet"><span class="by">infamia</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949744">parent</a><span>|</span><a href="#40950948">next</a><span>|</span><label class="collapse" for="c-40950762">[-]</label><label class="expand" for="c-40950762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; what it has is &quot;type hints&quot; which is way to have richer integration with type checkers and your IDE, but will never offer more than that as is<p>Python is strongly typed and it&#x27;s interpreter is type aware of it&#x27;s variables, so you&#x27;re probably overreaching with that statement. Because Python&#x27;s internals are type aware, it&#x27;s how folks are able to create type checkers like mypy and pydantic both written in Python. Maybe you&#x27;re thinking about TS&#x2F;JSDoc, which is just window dressing for IDEs to display hints as you described?</div><br/></div></div><div id="40950948" class="c"><input type="checkbox" id="c-40950948" checked=""/><div class="controls bullet"><span class="by">kortex</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949744">parent</a><span>|</span><a href="#40950762">prev</a><span>|</span><a href="#40949766">next</a><span>|</span><label class="collapse" for="c-40950948">[-]</label><label class="expand" for="c-40950948">[1 more]</label></div><br/><div class="children"><div class="content">s&#x2F;will never be&#x2F;already is&#x2F;g<p><a href="https:&#x2F;&#x2F;github.com&#x2F;mypyc&#x2F;mypyc">https:&#x2F;&#x2F;github.com&#x2F;mypyc&#x2F;mypyc</a><p>You can compile python to c. Right now. Compatibility with extensions still needs a bit of work. But you can write extremely strict python.<p>That&#x27;s without getting into things like cython.</div><br/></div></div><div id="40949766" class="c"><input type="checkbox" id="c-40949766" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949744">parent</a><span>|</span><a href="#40950948">prev</a><span>|</span><a href="#40949810">next</a><span>|</span><label class="collapse" for="c-40949766">[-]</label><label class="expand" for="c-40949766">[8 more]</label></div><br/><div class="children"><div class="content">It is properly typed: it has dynamic types :)</div><br/><div id="40949887" class="c"><input type="checkbox" id="c-40949887" checked=""/><div class="controls bullet"><span class="by">GTP</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949766">parent</a><span>|</span><a href="#40949810">next</a><span>|</span><label class="collapse" for="c-40949887">[-]</label><label class="expand" for="c-40949887">[7 more]</label></div><br/><div class="children"><div class="content">Then we have very different ideas of what proper typing is :D
Look at this function, can you tell me what it does?<p><pre><code>  def plus(x, y):
    return x+y
</code></pre>
If your answer is among the lines of &quot;It returns the sum x and y&quot; then I would ask you who said that x and y are numbers. If these are strings, it concatenates them. If instead you pass a string and a number, you will get a runtime exception. So not only you can&#x27;t tell what a function does just by looking at it, you can&#x27;t even know if the function is correct (in the sense that will not raise an exception).</div><br/><div id="40949966" class="c"><input type="checkbox" id="c-40949966" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949887">parent</a><span>|</span><a href="#40950290">next</a><span>|</span><label class="collapse" for="c-40949966">[-]</label><label class="expand" for="c-40949966">[2 more]</label></div><br/><div class="children"><div class="content">It calls x.__add__(y).<p>Python types are strictly specified, but also dynamic.  You don&#x27;t need <i>static</i> types in order to have <i>strict</i> types, and indeed just because you&#x27;ve got static types (in TS, for example) doesn&#x27;t mean you have strict types.<p>A Python string is always a string, nothing is going to magically turn it into a number just because it&#x27;s a string representation of a number.  The same (sadly) can&#x27;t be said of Javascript.</div><br/><div id="40950274" class="c"><input type="checkbox" id="c-40950274" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949966">parent</a><span>|</span><a href="#40950290">next</a><span>|</span><label class="collapse" for="c-40950274">[-]</label><label class="expand" for="c-40950274">[1 more]</label></div><br/><div class="children"><div class="content">Yeah and even with static typing, a string can be many things. Some people even wrap their strings into singleton structs to avoid something like sending a customerId string into a func that wants an orderId string, which I think is overkill. Same with int.</div><br/></div></div></div></div><div id="40950290" class="c"><input type="checkbox" id="c-40950290" checked=""/><div class="controls bullet"><span class="by">vhcr</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949887">parent</a><span>|</span><a href="#40949966">prev</a><span>|</span><a href="#40950001">next</a><span>|</span><label class="collapse" for="c-40950290">[-]</label><label class="expand" for="c-40950290">[1 more]</label></div><br/><div class="children"><div class="content">In theory it&#x27;s nice that the compiler would catch those kinds of problems, but in practice it doesn&#x27;t matters.</div><br/></div></div><div id="40950001" class="c"><input type="checkbox" id="c-40950001" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949887">parent</a><span>|</span><a href="#40950290">prev</a><span>|</span><a href="#40949964">next</a><span>|</span><label class="collapse" for="c-40950001">[-]</label><label class="expand" for="c-40950001">[1 more]</label></div><br/><div class="children"><div class="content">Both Haskell and OCaml can raise exceptions for you, yet most people would say that they are properly typed.<p>The plus function you wrote is not more confusing than any generic function in a language that supports that.</div><br/></div></div><div id="40949964" class="c"><input type="checkbox" id="c-40949964" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949887">parent</a><span>|</span><a href="#40950001">prev</a><span>|</span><a href="#40951304">next</a><span>|</span><label class="collapse" for="c-40949964">[-]</label><label class="expand" for="c-40949964">[1 more]</label></div><br/><div class="children"><div class="content">When is the last time you had a bug IRL caused by passing the wrong kind of thing into plus(x, y), which your tests didn&#x27;t catch?</div><br/></div></div><div id="40951304" class="c"><input type="checkbox" id="c-40951304" checked=""/><div class="controls bullet"><span class="by">mixmastamyk</span><span>|</span><a href="#40949378">root</a><span>|</span><a href="#40949887">parent</a><span>|</span><a href="#40949964">prev</a><span>|</span><a href="#40949810">next</a><span>|</span><label class="collapse" for="c-40951304">[-]</label><label class="expand" for="c-40951304">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  you can&#x27;t tell what a function does just by looking at it<p>You just <i>did</i> tell us what it does by looking at it, for the 90% case at least.  It might be useful to throw two lists in there as well.  Throw a custom object in there?  It will work if you planned ahead with dunder add and radd.  If not fix, implement, or roll back.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40949810" class="c"><input type="checkbox" id="c-40949810" checked=""/><div class="controls bullet"><span class="by">discreteevent</span><span>|</span><a href="#40949378">prev</a><span>|</span><a href="#40950507">next</a><span>|</span><label class="collapse" for="c-40949810">[-]</label><label class="expand" for="c-40949810">[3 more]</label></div><br/><div class="children"><div class="content">I remember back around 2007 all the anxious blog posts about the free lunch (Moore&#x27;s law) being over. Parallelism was mandatory now. We were going to need exotic solutions like software transactional memory to get out of the crisis (and we could certainly forget about object orientation).<p>Meanwhile what takes the crown? -  Single threaded python.<p>(Well, ok Rust looks like it&#x27;s taking first place where you really need the speed and it does help parallelism without requiring absolute purity)</div><br/><div id="40951381" class="c"><input type="checkbox" id="c-40951381" checked=""/><div class="controls bullet"><span class="by">jeremycarter</span><span>|</span><a href="#40949810">parent</a><span>|</span><a href="#40950507">next</a><span>|</span><label class="collapse" for="c-40951381">[-]</label><label class="expand" for="c-40951381">[2 more]</label></div><br/><div class="children"><div class="content">Takes what crown? Python is horrifically slow even single threaded. It&#x27;s by far the slowest and most energy inefficient of the major choices available today.</div><br/><div id="40951393" class="c"><input type="checkbox" id="c-40951393" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40949810">root</a><span>|</span><a href="#40951381">parent</a><span>|</span><a href="#40950507">next</a><span>|</span><label class="collapse" for="c-40951393">[-]</label><label class="expand" for="c-40951393">[1 more]</label></div><br/><div class="children"><div class="content">Popularity</div><br/></div></div></div></div></div></div><div id="40950507" class="c"><input type="checkbox" id="c-40950507" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#40949810">prev</a><span>|</span><a href="#40949564">next</a><span>|</span><label class="collapse" for="c-40950507">[-]</label><label class="expand" for="c-40950507">[1 more]</label></div><br/><div class="children"><div class="content">It remains to be seen how many subtle bugs are now introduced by programmers who have never dealt with real multithreading.</div><br/></div></div><div id="40949564" class="c"><input type="checkbox" id="c-40949564" checked=""/><div class="controls bullet"><span class="by">mihaic</span><span>|</span><a href="#40950507">prev</a><span>|</span><a href="#40950475">next</a><span>|</span><label class="collapse" for="c-40949564">[-]</label><label class="expand" for="c-40949564">[7 more]</label></div><br/><div class="children"><div class="content">Does anyone know if there is more serious single threaded performance degradation (more than a few percent for instance)? I couldn&#x27;t find any benchmarks, just some generic reassurance that everything is fine.</div><br/><div id="40949628" class="c"><input type="checkbox" id="c-40949628" checked=""/><div class="controls bullet"><span class="by">ngoldbaum</span><span>|</span><a href="#40949564">parent</a><span>|</span><a href="#40949644">next</a><span>|</span><label class="collapse" for="c-40949628">[-]</label><label class="expand" for="c-40949628">[4 more]</label></div><br/><div class="children"><div class="content">Right now there is a significant single-threaded performance cost. Somewhere from 30-50%. Part of what my colleague Ken Jin and others are working on is getting back some of that lost performance by applying some optimizations. Expect single-threaded performance to improve for Python 3.14 next year.</div><br/><div id="40950708" class="c"><input type="checkbox" id="c-40950708" checked=""/><div class="controls bullet"><span class="by">andmkl</span><span>|</span><a href="#40949564">root</a><span>|</span><a href="#40949628">parent</a><span>|</span><a href="#40950025">next</a><span>|</span><label class="collapse" for="c-40950708">[-]</label><label class="expand" for="c-40950708">[1 more]</label></div><br/><div class="children"><div class="content">That would be in the order of previous GIL-removal projects, which were abandoned for that reason.</div><br/></div></div><div id="40950025" class="c"><input type="checkbox" id="c-40950025" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40949564">root</a><span>|</span><a href="#40949628">parent</a><span>|</span><a href="#40950708">prev</a><span>|</span><a href="#40949644">next</a><span>|</span><label class="collapse" for="c-40950025">[-]</label><label class="expand" for="c-40950025">[2 more]</label></div><br/><div class="children"><div class="content">To be honest, that seems a lot. Even today a lot of code is single-threaded, and this performance hit will also affect a lot of code running in parallel today.<p>There have been patches to remove the GIL going back to the 90s and Python 1.5 or thereabouts. But the performance impact has always been the show-stopper.</div><br/><div id="40950144" class="c"><input type="checkbox" id="c-40950144" checked=""/><div class="controls bullet"><span class="by">ngoldbaum</span><span>|</span><a href="#40949564">root</a><span>|</span><a href="#40950025">parent</a><span>|</span><a href="#40949644">next</a><span>|</span><label class="collapse" for="c-40950144">[-]</label><label class="expand" for="c-40950144">[1 more]</label></div><br/><div class="children"><div class="content">It’s an experimental release in 3.13. Another example: objects that will have deffered reference counts in 3.14 are made immortal in 3.13 to avoid scaling issues from reference count thrashing. This wasn’t originally the plan but deferred reference counting didn’t land in time for 3.13. It will be several years before free-threading becomes the default, at that point there will no longer be any single-threaded performance drop. Of course that assumes everything shakes out as planned, we’ll see.<p>This post is a call to ask people to “kick the tires”, experiment, and report issues they run into, not announcing that all work is done.</div><br/></div></div></div></div></div></div><div id="40949644" class="c"><input type="checkbox" id="c-40949644" checked=""/><div class="controls bullet"><span class="by">deschutes</span><span>|</span><a href="#40949564">parent</a><span>|</span><a href="#40949628">prev</a><span>|</span><a href="#40951740">next</a><span>|</span><label class="collapse" for="c-40949644">[-]</label><label class="expand" for="c-40949644">[1 more]</label></div><br/><div class="children"><div class="content">To my understanding there is and there isn&#x27;t. The driving force behind this demonstrated that it was possible to speed up the existing CPython interpreter by more than the performance cost of free threading with changes to the allocator and various other things.<p>So the net is actually a small performance win but lesser than if there was no free threading. That said, many of the techniques he identified were immediately incorporated into CPython and so I would expect benchmarks to show some regression as compared with the single threaded interpreter of the previous revision.</div><br/></div></div><div id="40951740" class="c"><input type="checkbox" id="c-40951740" checked=""/><div class="controls bullet"><span class="by">nhumrich</span><span>|</span><a href="#40949564">parent</a><span>|</span><a href="#40949644">prev</a><span>|</span><a href="#40950475">next</a><span>|</span><label class="collapse" for="c-40951740">[-]</label><label class="expand" for="c-40951740">[1 more]</label></div><br/><div class="children"><div class="content">Irrelevant, because even if there was, you would use the normal GIL python for it.</div><br/></div></div></div></div><div id="40950475" class="c"><input type="checkbox" id="c-40950475" checked=""/><div class="controls bullet"><span class="by">jmward01</span><span>|</span><a href="#40949564">prev</a><span>|</span><a href="#40949912">next</a><span>|</span><label class="collapse" for="c-40950475">[-]</label><label class="expand" for="c-40950475">[6 more]</label></div><br/><div class="children"><div class="content">I know, I know, &#x27;not every story needs to be about ML&#x27; but....   I can only imagine how unlocking the GIL will change the nature of ML training and inference. There is so much waste and complexity in passing memory around and coordinating processes. I know that libraries have made it (somewhat) easier and more efficient but I can&#x27;t wait to see what can be done with things like pytorch when optimized for this.</div><br/><div id="40950760" class="c"><input type="checkbox" id="c-40950760" checked=""/><div class="controls bullet"><span class="by">ipsum2</span><span>|</span><a href="#40950475">parent</a><span>|</span><a href="#40951881">next</a><span>|</span><label class="collapse" for="c-40950760">[-]</label><label class="expand" for="c-40950760">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;ll mostly help for debugging and lowering RAM (not VRAM) usage. Otherwise it won&#x27;t impact ML much.</div><br/><div id="40951164" class="c"><input type="checkbox" id="c-40951164" checked=""/><div class="controls bullet"><span class="by">jmward01</span><span>|</span><a href="#40950475">root</a><span>|</span><a href="#40950760">parent</a><span>|</span><a href="#40951881">next</a><span>|</span><label class="collapse" for="c-40951164">[-]</label><label class="expand" for="c-40951164">[1 more]</label></div><br/><div class="children"><div class="content">Pretty universally I have seen performance improvements in code when complexity is reduced and this could drop complexity considerably. I wouldn&#x27;t be surprised to see a double digit percent improvement in tokens per sec when an optimized pytorch eventually comes out with this. There may even be hidden gains on GPU memory usage that come out of this as people clean up code and start implementing better tricks because of it.</div><br/></div></div></div></div><div id="40951881" class="c"><input type="checkbox" id="c-40951881" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#40950475">parent</a><span>|</span><a href="#40950760">prev</a><span>|</span><a href="#40949912">next</a><span>|</span><label class="collapse" for="c-40951881">[-]</label><label class="expand" for="c-40951881">[3 more]</label></div><br/><div class="children"><div class="content">huh?<p>Any python library that cares about performance is written in C&#x2F;C++&#x2F;Rust&#x2F;Fortran and only provides a python interface.<p>ML will have 0 benefit from this.</div><br/><div id="40952005" class="c"><input type="checkbox" id="c-40952005" checked=""/><div class="controls bullet"><span class="by">jmward01</span><span>|</span><a href="#40950475">root</a><span>|</span><a href="#40951881">parent</a><span>|</span><a href="#40952290">next</a><span>|</span><label class="collapse" for="c-40952005">[-]</label><label class="expand" for="c-40952005">[1 more]</label></div><br/><div class="children"><div class="content">Have you done any multi-gpu training? Generally every GPU gets a process. Coordinating between them and passing around data between them is complex and can easily have performance issues since normal communication between python processes requires some sort of serialization&#x2F;de-serialization of objects (there are many * here when it comes to GPU training). This has the potential to simplify all of that and remove a lot of inter-process communication which is just pure overhead.</div><br/></div></div><div id="40952290" class="c"><input type="checkbox" id="c-40952290" checked=""/><div class="controls bullet"><span class="by">KeplerBoy</span><span>|</span><a href="#40950475">root</a><span>|</span><a href="#40951881">parent</a><span>|</span><a href="#40952005">prev</a><span>|</span><a href="#40949912">next</a><span>|</span><label class="collapse" for="c-40952290">[-]</label><label class="expand" for="c-40952290">[1 more]</label></div><br/><div class="children"><div class="content">Of course ML will benefit from it. Soon you will be able to run your dataloaders&#x2F;data preprocessing in different threads which will not starve your GPUs of data.</div><br/></div></div></div></div></div></div><div id="40949912" class="c"><input type="checkbox" id="c-40949912" checked=""/><div class="controls bullet"><span class="by">elijahbenizzy</span><span>|</span><a href="#40950475">prev</a><span>|</span><a href="#40949184">next</a><span>|</span><label class="collapse" for="c-40949912">[-]</label><label class="expand" for="c-40949912">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really curious to see how this will work with async. There&#x27;s a natural barrier (I&#x2F;O versus CPU-bound code), which isn&#x27;t always a perfect distinction.<p>I&#x27;d love to see a more fluid model between the two -- E.G. if I&#x27;m doing a &quot;gather&quot; on CPU-bound coroutines, I&#x27;m curious if there&#x27;s something that can be smart enough to JIT between async and multithreaded implementations.<p>&quot;Oh, the first few tasks were entirely CPU-bound? Cool, let&#x27;s launch another thread. Oh, the first few threads were I&#x2F;O-bound? Cool, let&#x27;s use in-thread coroutines&quot;.<p>Probably not feasible for a myriad of reasons, but even a more fluid programming model could be really cool (similar interfaces with a quick swap between?).</div><br/><div id="40950525" class="c"><input type="checkbox" id="c-40950525" checked=""/><div class="controls bullet"><span class="by">bastawhiz</span><span>|</span><a href="#40949912">parent</a><span>|</span><a href="#40949184">next</a><span>|</span><label class="collapse" for="c-40950525">[-]</label><label class="expand" for="c-40950525">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;d be hard pressed to find a workload where that behavior needs to be generalized to the degree you&#x27;re talking.<p>If you&#x27;re serving HTTP requests, for instance, simply serving each request on its own thread with its own event loop should be sufficient at scale. Multiple requests each with CPU-bound tasks will still saturate the CPUs.<p>Very little code teeters between CPU-bound and io-bound while also serving few enough requests that you have cores to spare to effectively parallelize <i>all</i> the CPU-bound work. If that&#x27;s the case, why do you need the runtime to do this for you? A simple profile would show what&#x27;s holding up the event loop.<p>But still, the runtime can&#x27;t naively parallelize coroutines. Coroutines are expected not to be run in parallel and that code isn&#x27;t expected to be thread safe. Instead of a gather on futures, your code would have been using a thread pool executor in the first place if you&#x27;d gone out of your way to ensure your CPU-bound code was thread safe: the benefits of async&#x2F;await are mostly lost.<p>I also don&#x27;t think an event loop can be shared between two running threads: if you were to parallelize coroutines, those coroutines&#x27; spawned coroutines could run in parallel. If you used an async library that isn&#x27;t thread safe because it expects only one coroutine is executing at a time, you could run into serious bugs.</div><br/></div></div></div></div><div id="40949184" class="c"><input type="checkbox" id="c-40949184" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#40949912">prev</a><span>|</span><a href="#40950855">next</a><span>|</span><label class="collapse" for="c-40949184">[-]</label><label class="expand" for="c-40949184">[5 more]</label></div><br/><div class="children"><div class="content">It has been ready for a few months now, at least since 3.13.0 beta 1 which released on 2024-05-08, although alpha versions had it working too. I don&#x27;t know why this is news <i>now</i>.<p>With it, the single-threaded case is slower.</div><br/><div id="40949375" class="c"><input type="checkbox" id="c-40949375" checked=""/><div class="controls bullet"><span class="by">JBorrow</span><span>|</span><a href="#40949184">parent</a><span>|</span><a href="#40949208">next</a><span>|</span><label class="collapse" for="c-40949375">[-]</label><label class="expand" for="c-40949375">[2 more]</label></div><br/><div class="children"><div class="content">This release coincides with the SciPy 2024 conference and a number of other things. I would suggest reading the article to learn more.</div><br/><div id="40949664" class="c"><input type="checkbox" id="c-40949664" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#40949184">root</a><span>|</span><a href="#40949375">parent</a><span>|</span><a href="#40949208">next</a><span>|</span><label class="collapse" for="c-40949664">[-]</label><label class="expand" for="c-40949664">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This release<p>What release. The last release of CPython was 3.13.0b3 on 2024-06-27.<p>SciPy is irrelevant to the title.</div><br/></div></div></div></div><div id="40949208" class="c"><input type="checkbox" id="c-40949208" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#40949184">parent</a><span>|</span><a href="#40949375">prev</a><span>|</span><a href="#40950855">next</a><span>|</span><label class="collapse" for="c-40949208">[-]</label><label class="expand" for="c-40949208">[2 more]</label></div><br/><div class="children"><div class="content">FTA: &quot;Yesterday, py-free-threading.github.io launched! It&#x27;s both a resource with documentation around adding support for free-threaded Python, and a status tracker for the rollout across open source projects in the Python ecosystem.&quot;</div><br/><div id="40949642" class="c"><input type="checkbox" id="c-40949642" checked=""/><div class="controls bullet"><span class="by">OutOfHere</span><span>|</span><a href="#40949184">root</a><span>|</span><a href="#40949208">parent</a><span>|</span><a href="#40950855">next</a><span>|</span><label class="collapse" for="c-40949642">[-]</label><label class="expand" for="c-40949642">[1 more]</label></div><br/><div class="children"><div class="content">Before the article came the misleading title: &quot;Free-threaded CPython is ready to experiment with&quot;.<p>The link should have been to <a href="https:&#x2F;&#x2F;py-free-threading.github.io&#x2F;tracking&#x2F;" rel="nofollow">https:&#x2F;&#x2F;py-free-threading.github.io&#x2F;tracking&#x2F;</a></div><br/></div></div></div></div></div></div><div id="40950855" class="c"><input type="checkbox" id="c-40950855" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40949184">prev</a><span>|</span><a href="#40949703">next</a><span>|</span><label class="collapse" for="c-40950855">[-]</label><label class="expand" for="c-40950855">[3 more]</label></div><br/><div class="children"><div class="content">PEP703 explains that with the GIL removed, operations on lists such as `append` remain thread-safe because of the addition of per-list locks.<p>What about simple operations like incrementing an integer? IIRC this is currently thread-safe because the GIL guarantees each bytecode instruction is executed atomically.</div><br/><div id="40950987" class="c"><input type="checkbox" id="c-40950987" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#40950855">parent</a><span>|</span><a href="#40949703">next</a><span>|</span><label class="collapse" for="c-40950987">[-]</label><label class="expand" for="c-40950987">[2 more]</label></div><br/><div class="children"><div class="content">Ah, `i += 1` isn’t currently thread-safe because Python does (LOAD, +=, STORE) as 3 separate bytecode instructions.<p>I guess the only things that are a single instruction are some modifications to mutable objects, and those are already heavyweight enough that it’s OK to add a per-object lock.</div><br/><div id="40951971" class="c"><input type="checkbox" id="c-40951971" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#40950855">root</a><span>|</span><a href="#40950987">parent</a><span>|</span><a href="#40949703">next</a><span>|</span><label class="collapse" for="c-40951971">[-]</label><label class="expand" for="c-40951971">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like the kind of thing that a JIT compiler should be optimizing. The problem with threading isn&#x27;t stuff like this but people doing a lot of silly things like having global mutable state or stateful objects that are being passed around a lot.<p>I&#x27;ve done quite a bit of stuff with Java and Kotlin in the past quarter century and it&#x27;s interesting to see how much things have evolved. Early on there were a lot of people doing silly things with threads and overusing the, at the time, not so great language features for that. But a lot of that stuff replaced by better primitives and libraries.<p>If you look at Kotlin these days, there&#x27;s very little of that silliness going on. It has no synchronized keyword. Or a volatile keyword, like Java has. But it does have co-routines and co-routine scopes. And some of those scopes may be backed by thread pools (or virtual thread pools on recent JVMs).<p>Now that python has async, it&#x27;s probably a good idea to start thinking about some way to add structured concurrency similar to that on top of that. So, you have async stuff and some of that async stuff might happen on different threads. It&#x27;s a good mental model for dealing with concurrency and parallelism. There&#x27;s no need to repeat two decades of mistakes that happened in the Java world; you can fast forward to the good stuff without doing that.</div><br/></div></div></div></div></div></div><div id="40949703" class="c"><input type="checkbox" id="c-40949703" checked=""/><div class="controls bullet"><span class="by">vldmrs</span><span>|</span><a href="#40950855">prev</a><span>|</span><a href="#40950109">next</a><span>|</span><label class="collapse" for="c-40949703">[-]</label><label class="expand" for="c-40949703">[1 more]</label></div><br/><div class="children"><div class="content">Great news !
It would be interesting to see performance comparison for IO-bound tasks like http requests between single-threaded asyncio code and multi-threaded asyncio</div><br/></div></div><div id="40950109" class="c"><input type="checkbox" id="c-40950109" checked=""/><div class="controls bullet"><span class="by">gnatolf</span><span>|</span><a href="#40949703">prev</a><span>|</span><a href="#40949152">next</a><span>|</span><label class="collapse" for="c-40950109">[-]</label><label class="expand" for="c-40950109">[1 more]</label></div><br/><div class="children"><div class="content">Good to hear. The authors are touching on the journey it is to make Cython continue to work. I wonder how hard it&#x27;ll be to continue to provide bdist packages, or within what timeframe, if at all, Cython can transparently ensure correctness for a no-gil build. Anyone got any insights?</div><br/></div></div><div id="40949152" class="c"><input type="checkbox" id="c-40949152" checked=""/><div class="controls bullet"><span class="by">nas</span><span>|</span><a href="#40950109">prev</a><span>|</span><a href="#40949987">next</a><span>|</span><label class="collapse" for="c-40949152">[-]</label><label class="expand" for="c-40949152">[1 more]</label></div><br/><div class="children"><div class="content">Very encouraging news!</div><br/></div></div><div id="40949987" class="c"><input type="checkbox" id="c-40949987" checked=""/><div class="controls bullet"><span class="by">throwaway5752</span><span>|</span><a href="#40949152">prev</a><span>|</span><a href="#40949442">next</a><span>|</span><label class="collapse" for="c-40949987">[-]</label><label class="expand" for="c-40949987">[1 more]</label></div><br/><div class="children"><div class="content">GVR, you are sorely missed, though I hope you are enjoying life.</div><br/></div></div><div id="40949937" class="c"><input type="checkbox" id="c-40949937" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#40950814">prev</a><span>|</span><label class="collapse" for="c-40949937">[-]</label><label class="expand" for="c-40949937">[1 more]</label></div><br/><div class="children"><div class="content">Was ready for this 15 years ago when I loved Python and regularly contributed. At the time, nobody wanted to do it and I got bored and went to Go.</div><br/></div></div></div></div></div></div></div></body></html>