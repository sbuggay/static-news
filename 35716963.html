<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1682568400931" as="style"/><link rel="stylesheet" href="styles.css?v=1682568400931"/><link rel="apple-touch-startup-image" href="https://png.pngtree.com/png-clipart/20210309/original/pngtree-a-squatting-tabby-cat-png-image_5803660.jpg"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ottertune.com/blog/the-part-of-postgresql-we-hate-the-most/">The part of Postgres we hate the most: Multi-version concurrency control</a> <span class="domain">(<a href="https://ottertune.com">ottertune.com</a>)</span></div><div class="subtext"><span>andrenotgiant</span> | <span>85 comments</span></div><br/><div><div id="35720540" class="c"><input type="checkbox" id="c-35720540" checked=""/><div class="controls bullet"><span class="by">fdr</span><span>|</span><a href="#35718481">next</a><span>|</span><label class="collapse" for="c-35720540">[-]</label><label class="expand" for="c-35720540">[2 more]</label></div><br/><div class="children"><div class="content">One of the weird things about Postgres MVCC is that it is &quot;optimized for rollback,&quot; as one person memorably quipped to me. This is not to imply a design principle, it&#x27;s more a description of how things ended up, and the general argument behind this quip is Postgres lacks &quot;UNDO&quot; segments.<p>On the one hand, this does make the model Postgres uses admirably simple: the WAL is all &quot;REDO,&quot; and the heap is all you need to accomplish any kind of read, but at the expense that stuff that normally would be copied off to a sequential UNDO log and then vaporized when the transaction commits and all possible readers have exited remains comingled with everything else in the main database heap, needing to be fished out again by VACUUM for purging and figuring out how to reclaim numerical space for more transactions.<p>There may be other solutions to this, but it&#x27;s one unusual quality Postgres has relative to other MVCC databases, many of which sport an UNDO log.<p>There are downsides to UNDO, however: if a read needs an old copy of the tuple, it needs to fish around in UNDO, all the indices and synchronization need to account for this, and if there&#x27;s a rollback or crash recovery event (i.e. mass-rollback of all transactions open at the time), everything has to be shuffled back into the main database storage. Hence the memorable initial comment: &quot;Postgres is optimized for rollback.&quot;</div><br/><div id="35721603" class="c"><input type="checkbox" id="c-35721603" checked=""/><div class="controls bullet"><span class="by">thinkx</span><span>|</span><a href="#35720540">parent</a><span>|</span><a href="#35718481">next</a><span>|</span><label class="collapse" for="c-35721603">[-]</label><label class="expand" for="c-35721603">[1 more]</label></div><br/><div class="children"><div class="content">Coming to Postgres, UNDO logs and no vacuum<p><a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;</a></div><br/></div></div></div></div><div id="35718481" class="c"><input type="checkbox" id="c-35718481" checked=""/><div class="controls bullet"><span class="by">mmaunder</span><span>|</span><a href="#35720540">prev</a><span>|</span><a href="#35719471">next</a><span>|</span><label class="collapse" for="c-35718481">[-]</label><label class="expand" for="c-35718481">[17 more]</label></div><br/><div class="children"><div class="content">I must admit as a web practitioner since 1994 I have a bit of an issue with this:<p>&gt; In the 2000s, the conventional wisdom selected MySQL because rising tech stars like Google and Facebook were using it. Then in the 2010s, it was MongoDB because non-durable writes made it “webscale“. In the last five years, PostgreSQL has become the Internet’s darling DBMS. And for good reasons!<p>Different DB&#x27;s, different strengths and it&#x27;s not a zero sum came as implied. MySQL was popular before Google was born - we used it heavily at eToys in the 90s for massive transaction volume and replacing it with Oracle was one of the reasons for the catastrophic failure of eToys circa 2001. MongoDB gained traction not because it&#x27;s an alternative to MySQL or PostgreSQL. And PostgreSQL&#x27;s marketshare today is on a par with Mongo and both are dwarfed by MySQL which IMO is the true darling of web DB&#x27;s given it&#x27;s global popularity.</div><br/><div id="35720854" class="c"><input type="checkbox" id="c-35720854" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35721399">next</a><span>|</span><label class="collapse" for="c-35720854">[-]</label><label class="expand" for="c-35720854">[5 more]</label></div><br/><div class="children"><div class="content">A non-trivial component to MySQL popularity was that easy installation (not necessarily administration) and comparatively low resource usage with good performance <i>at default settings</i> (even today one needs to run some basic calculations for postgres in production, IMO) meant that cheapest possible dynamic hosting using Linux, Apache, PHP3, and MySQL 3, was what simply was the only available option for many. This codified LAMP stack, people learned from tutorials&#x2F;courses&#x2F;word of mouth how to write web apps with PHP and MySQL, used cheap LAMP hosting, optionally installed LAMP servers themselves, etc.<p>This also led to popularity of bigger reselling setups (I don&#x27;t miss installing cpanel...) and services like Dreamhost.<p>MySQL in this way gained a virtuous cycle completely unrelated to Google. Hell, most people I know, who dealt with LAMP space for years, never knew Google had anything to do with MySQL (most people that knew about it were... Lispers. Because of who built the first version of Google Ads)<p>Even Mac OS X Server shipped with MySQL and PHP because of that, in 2001.</div><br/><div id="35721595" class="c"><input type="checkbox" id="c-35721595" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35720854">parent</a><span>|</span><a href="#35721399">next</a><span>|</span><label class="collapse" for="c-35721595">[-]</label><label class="expand" for="c-35721595">[4 more]</label></div><br/><div class="children"><div class="content">Another factor besides performance vs earlier versions of Postgres (they&#x27;re now more at parity) was Postgres didn&#x27;t come with replication included. I think that was a big hinderance for adoption during the LAMP stack&#x27;s hey day.</div><br/><div id="35721608" class="c"><input type="checkbox" id="c-35721608" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35721595">parent</a><span>|</span><a href="#35721399">next</a><span>|</span><label class="collapse" for="c-35721608">[-]</label><label class="expand" for="c-35721608">[3 more]</label></div><br/><div class="children"><div class="content">Honestly, at the time when LAMP was gaining the userbase, said userbase for considerable portion <i>did not care about replication because there was only one server they had</i>.<p>Replication was something you did when you got succesful enough to have it, or were a MSP providing it at premium to others.</div><br/><div id="35722128" class="c"><input type="checkbox" id="c-35722128" checked=""/><div class="controls bullet"><span class="by">edmundsauto</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35721608">parent</a><span>|</span><a href="#35721399">next</a><span>|</span><label class="collapse" for="c-35722128">[-]</label><label class="expand" for="c-35722128">[2 more]</label></div><br/><div class="children"><div class="content">I remember it differently - we needed replication for &quot;hot&quot; backups. At that time, scalability was a major issue - so anyone (including businesspeople) wanted to have a scalable architecture. MySQL spoke to the practical (default install on cPanel hosts, easy replication) and the aspirational (you&#x27;re going to blow up and need to scale).<p>Digg.com also had a really influential technical team - hearing about how they did things set a lot of baseline defaults for a lot of people.</div><br/><div id="35722212" class="c"><input type="checkbox" id="c-35722212" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35722128">parent</a><span>|</span><a href="#35721399">next</a><span>|</span><label class="collapse" for="c-35722212">[-]</label><label class="expand" for="c-35722212">[1 more]</label></div><br/><div class="children"><div class="content">maybe you were on the more funded side of history in this. As for me, Digg is way after LAMP got solidly plonked into &quot;what I need for a dynamic website on cheap&quot;.<p>Essentially, start at 2000-2001 and more and more people going into running websites for all kinds of reasons (forums, blogs, webshops, etc. often hosted on low end offerings)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="35721399" class="c"><input type="checkbox" id="c-35721399" checked=""/><div class="controls bullet"><span class="by">hodgesrm</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35720854">prev</a><span>|</span><a href="#35721593">next</a><span>|</span><label class="collapse" for="c-35721399">[-]</label><label class="expand" for="c-35721399">[4 more]</label></div><br/><div class="children"><div class="content">&gt; A non-trivial component to MySQL popularity was that easy installation<p>...Along with replication and being joined with the hip to PHP. As to installation, there was a point in time in the early 2000s where you could sudo to root, type &#x27;mysql&#x27; and be talking to a live MySQL on most Linux distros that I used. No wonder a lot of people defaulted to it.</div><br/><div id="35721597" class="c"><input type="checkbox" id="c-35721597" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35721399">parent</a><span>|</span><a href="#35721593">next</a><span>|</span><label class="collapse" for="c-35721597">[-]</label><label class="expand" for="c-35721597">[3 more]</label></div><br/><div class="children"><div class="content">Replication came later - but the fact that you could do<p><pre><code>  sudo apt-get install mysql-server mysql-client
  sudo -i mysql
</code></pre>
and be logged in as admin into mysql database was indeed a huge reason for defaulting to it.<p>EDIT: Of course, at that time, there was no Ubuntu teaching everyone to <i>sudo</i> all the time, so drop all instances of sudo and add a <i>su -</i> at start ;)</div><br/><div id="35722012" class="c"><input type="checkbox" id="c-35722012" checked=""/><div class="controls bullet"><span class="by">tomnipotent</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35721597">parent</a><span>|</span><a href="#35721593">next</a><span>|</span><label class="collapse" for="c-35722012">[-]</label><label class="expand" for="c-35722012">[2 more]</label></div><br/><div class="children"><div class="content">MySQL has had replication since May 2000.</div><br/><div id="35722162" class="c"><input type="checkbox" id="c-35722162" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35722012">parent</a><span>|</span><a href="#35721593">next</a><span>|</span><label class="collapse" for="c-35722162">[-]</label><label class="expand" for="c-35722162">[1 more]</label></div><br/><div class="children"><div class="content">Replication being easier <i>as driver for developers defaulting to MySQL</i></div><br/></div></div></div></div></div></div></div></div><div id="35721593" class="c"><input type="checkbox" id="c-35721593" checked=""/><div class="controls bullet"><span class="by">pier25</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35721399">prev</a><span>|</span><a href="#35722020">next</a><span>|</span><label class="collapse" for="c-35721593">[-]</label><label class="expand" for="c-35721593">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>MongoDB gained traction not because it&#x27;s an alternative to MySQL or PostgreSQL.</i><p>Honestly I think it only gained traction because many Node devs refused to learn SQL and the document model is familiar because it&#x27;s closer to JSON data.<p>These days Mongo is good but that wasn&#x27;t the case back 10+ years ago.</div><br/></div></div><div id="35722020" class="c"><input type="checkbox" id="c-35722020" checked=""/><div class="controls bullet"><span class="by">steve_taylor</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35721593">prev</a><span>|</span><a href="#35722762">next</a><span>|</span><label class="collapse" for="c-35722020">[-]</label><label class="expand" for="c-35722020">[1 more]</label></div><br/><div class="children"><div class="content">PostgreSQL became the internet&#x27;s darling DBMS long before that. Oracle&#x27;s acquisition of MySQL in 2008 made people finally take notice of PostgreSQL. Before that, most developers barely knew it existed.</div><br/></div></div><div id="35722762" class="c"><input type="checkbox" id="c-35722762" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35722020">prev</a><span>|</span><a href="#35721446">next</a><span>|</span><label class="collapse" for="c-35722762">[-]</label><label class="expand" for="c-35722762">[1 more]</label></div><br/><div class="children"><div class="content">&gt; MongoDB gained traction not because it&#x27;s an alternative to MySQL or PostgreSQL.<p>Disagree. It gained traction because it was an alternative to MySQL in the ways that mattered - fast, easy to administer, widely known, good enough. Yes, there are significant differences in the details of what they do - but in terms of someone looking for a backing datastore for their webapp, they&#x27;re actually competing in a very similar space.</div><br/></div></div><div id="35721446" class="c"><input type="checkbox" id="c-35721446" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35722762">prev</a><span>|</span><a href="#35719169">next</a><span>|</span><label class="collapse" for="c-35721446">[-]</label><label class="expand" for="c-35721446">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; MySQL which IMO is the true darling of web DB&#x27;s<p>A &quot;darling&quot; is something you want to use, not something that you are using. Many do not want to use MySQL due to Oracle control. Postgres is definitely the darling of the past few years.</div><br/></div></div><div id="35719169" class="c"><input type="checkbox" id="c-35719169" checked=""/><div class="controls bullet"><span class="by">LambdaComplex</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35721446">prev</a><span>|</span><a href="#35721330">next</a><span>|</span><label class="collapse" for="c-35719169">[-]</label><label class="expand" for="c-35719169">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in the 2010s, it was MongoDB because non-durable writes made it “webscale“<p>I think this is the best video on that topic: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=b2F-DItXtZs">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=b2F-DItXtZs</a></div><br/></div></div><div id="35721330" class="c"><input type="checkbox" id="c-35721330" checked=""/><div class="controls bullet"><span class="by">zaphirplane</span><span>|</span><a href="#35718481">parent</a><span>|</span><a href="#35719169">prev</a><span>|</span><a href="#35719471">next</a><span>|</span><label class="collapse" for="c-35721330">[-]</label><label class="expand" for="c-35721330">[2 more]</label></div><br/><div class="children"><div class="content">Part of the popularity of the early MySQL was marketing. I hope I’m not wrong here, there was something written about MySQL people posting misinformation in forums. Another is the ease of having it up and running. Another was I think there was some IP address component to setting up users which made it look complicated</div><br/><div id="35722584" class="c"><input type="checkbox" id="c-35722584" checked=""/><div class="controls bullet"><span class="by">rodgerd</span><span>|</span><a href="#35718481">root</a><span>|</span><a href="#35721330">parent</a><span>|</span><a href="#35719471">next</a><span>|</span><label class="collapse" for="c-35722584">[-]</label><label class="expand" for="c-35722584">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there was something written about MySQL people posting misinformation in forums.<p>They were absolute liars of the first water back in the day, absolutely. In the 3.x era there were claims that transactions were only for people who didn&#x27;t know how to program! You&#x27;d struggle to find most of the absolute nonsense that was being pushed, because it&#x27;s mostly gone down various memory holes, but it was absolutely breathtaking.</div><br/></div></div></div></div></div></div><div id="35719471" class="c"><input type="checkbox" id="c-35719471" checked=""/><div class="controls bullet"><span class="by">dale_glass</span><span>|</span><a href="#35718481">prev</a><span>|</span><a href="#35718321">next</a><span>|</span><label class="collapse" for="c-35719471">[-]</label><label class="expand" for="c-35719471">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, MVCC was the thing that drew me to Postgres to begin with!<p>Way back I was working on an in-house inventory app written in Visual Basic against SQL Server 2000, I think. That one just put locks on tables. It had the &quot;charming&quot; characteristic of that if you weren&#x27;t very, very careful with Enterprise Manager, loading a table in the GUI put a lock on it and just keep on holding it until that window was closed.<p>Then the running app would eventually snag on that lock, maybe keep holding some other lock that something else would snag on, and 5 minutes later I&#x27;d hear one of the operators screaming &quot;Nothing is working! I can&#x27;t take any orders!&quot; from the room next to me.</div><br/><div id="35719580" class="c"><input type="checkbox" id="c-35719580" checked=""/><div class="controls bullet"><span class="by">miohtama</span><span>|</span><a href="#35719471">parent</a><span>|</span><a href="#35722059">next</a><span>|</span><label class="collapse" for="c-35719580">[-]</label><label class="expand" for="c-35719580">[1 more]</label></div><br/><div class="children"><div class="content">MVCC and optimistic concurrency control are very pleasant to work with for anyone who spent a decade with manually locking SQL databases. It takes the human error and developer mistakes away from the process, or protect against it. You can still slow down your queries with deadlocks, but at least you cannot corrupt your data by accident.<p>Though, any other optimistic concurrency control scheme can be better, but PostgreSQL was at the right place at the right time when people started to leave from MySQL.</div><br/></div></div><div id="35722059" class="c"><input type="checkbox" id="c-35722059" checked=""/><div class="controls bullet"><span class="by">geophile</span><span>|</span><a href="#35719471">parent</a><span>|</span><a href="#35719580">prev</a><span>|</span><a href="#35718321">next</a><span>|</span><label class="collapse" for="c-35722059">[-]</label><label class="expand" for="c-35722059">[1 more]</label></div><br/><div class="children"><div class="content">There are many alternatives to table locking, including more conventional row locks.<p>MVCC is great, but this article does identify some of the puzzling design choices of the Postgres implementation. The index problems are particularly bad, and seemingly avoidable.</div><br/></div></div></div></div><div id="35718321" class="c"><input type="checkbox" id="c-35718321" checked=""/><div class="controls bullet"><span class="by">spprashant</span><span>|</span><a href="#35719471">prev</a><span>|</span><a href="#35720135">next</a><span>|</span><label class="collapse" for="c-35718321">[-]</label><label class="expand" for="c-35718321">[6 more]</label></div><br/><div class="children"><div class="content">This post has a valid point. But the last line makes it clear why they care so much about it.<p>Yeah, table bloat and transaction ID wraparounds are terrible, but easily avoidable if you follow a few simple guidelines. Typically in my experience, best way to avoid these issues are to set sensible vacuum settings and track long running queries.<p>I do hate the some of the defaults in the Postgres configuration are too conservative for most workloads.</div><br/><div id="35720793" class="c"><input type="checkbox" id="c-35720793" checked=""/><div class="controls bullet"><span class="by">spudlyo</span><span>|</span><a href="#35718321">parent</a><span>|</span><a href="#35720733">next</a><span>|</span><label class="collapse" for="c-35720793">[-]</label><label class="expand" for="c-35720793">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;But making sure that PostgreSQL’s autovacuum is running as best as possible is difficult due to its complexity.&quot;<p>The problem, as the article states it, is that a &quot;sensible&quot; vacuum setting for one table is a terrible setting for another depending on how large these tables are. On a 100 million tuple table you&#x27;d be waiting &#x27;til there there were 20 million garbage tuples before taking action.</div><br/></div></div><div id="35720733" class="c"><input type="checkbox" id="c-35720733" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#35718321">parent</a><span>|</span><a href="#35720793">prev</a><span>|</span><a href="#35718567">next</a><span>|</span><label class="collapse" for="c-35720733">[-]</label><label class="expand" for="c-35720733">[2 more]</label></div><br/><div class="children"><div class="content">What last line? The literal last line is &quot;We’ll cover more about what we can do in our next article.&quot;<p>Do you mean this one?<p>&gt; At OtterTune, we see this problem often in our customers’ databases. One PostgreSQL RDS instance had a long-running query caused by stale statistics after bulk insertions. This query blocked the autovacuum from updating the statistics, resulting in more long-running queries. OtterTune’s automated health checks identified the problem, but the administrator still had to kill the query manually and run ANALYZE after bulk insertions. The good news is that the long query’s execution time went from 52 minutes to just 34 seconds.</div><br/><div id="35723087" class="c"><input type="checkbox" id="c-35723087" checked=""/><div class="controls bullet"><span class="by">cipheredStones</span><span>|</span><a href="#35718321">root</a><span>|</span><a href="#35720733">parent</a><span>|</span><a href="#35718567">next</a><span>|</span><label class="collapse" for="c-35723087">[-]</label><label class="expand" for="c-35723087">[1 more]</label></div><br/><div class="children"><div class="content">It previously had this closing line, with links to their products (<a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230426171217&#x2F;https:&#x2F;&#x2F;ottertune.com&#x2F;blog&#x2F;the-part-of-postgresql-we-hate-the-most" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230426171217&#x2F;https:&#x2F;&#x2F;ottertune...</a>):<p>&gt; A better approach is to use an AI-powered service automatically determine the best way to optimize PostgreSQL. This is what OtterTune does. We’ll cover more about what we can do in our next article. Or you can sign-up for a free trial and try it yourself.<p>That was removed after the article was posted to HN, at dang&#x27;s suggestion - he posted about it elsewhere in these comments.</div><br/></div></div></div></div><div id="35718567" class="c"><input type="checkbox" id="c-35718567" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#35718321">parent</a><span>|</span><a href="#35720733">prev</a><span>|</span><a href="#35720107">next</a><span>|</span><label class="collapse" for="c-35718567">[-]</label><label class="expand" for="c-35718567">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I do hate the some of the defaults in the Postgres configuration are too conservative for most workloads.<p>it is also black magic to tune them.</div><br/></div></div><div id="35720107" class="c"><input type="checkbox" id="c-35720107" checked=""/><div class="controls bullet"><span class="by">LunaSea</span><span>|</span><a href="#35718321">parent</a><span>|</span><a href="#35718567">prev</a><span>|</span><a href="#35720135">next</a><span>|</span><label class="collapse" for="c-35720107">[-]</label><label class="expand" for="c-35720107">[1 more]</label></div><br/><div class="children"><div class="content">Paying an overhead cost of 53 bytes per row is also too expensive for MVCC in my opinion.</div><br/></div></div></div></div><div id="35720135" class="c"><input type="checkbox" id="c-35720135" checked=""/><div class="controls bullet"><span class="by">elijaht</span><span>|</span><a href="#35718321">prev</a><span>|</span><a href="#35722946">next</a><span>|</span><label class="collapse" for="c-35720135">[-]</label><label class="expand" for="c-35720135">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Another problem with the autovacuum in PostgreSQL is that it may get blocked by long-running transactions, which can result in the accumulation of more dead tuples and stale statistics. Failing to clean expired versions in a timely manner leads to numerous performance problems, causing more long-running transactions that block the autovacuum process. It becomes a vicious cycle, requiring humans to intervene manually by killing long-running transactions.<p>Oh man, a previous company I worked at had an issue with a hot table (frequent reads + writes) interfering with autovacuum. Many fires over a six month period arose from all of that. I was (luckily) only on an adjacent team, so I don&#x27;t know the details, other than vacuums taking over 24 hours! I&#x27;m sure it could have been prevented, but it seemed horrible to debug</div><br/><div id="35720645" class="c"><input type="checkbox" id="c-35720645" checked=""/><div class="controls bullet"><span class="by">fdr</span><span>|</span><a href="#35720135">parent</a><span>|</span><a href="#35722946">next</a><span>|</span><label class="collapse" for="c-35720645">[-]</label><label class="expand" for="c-35720645">[1 more]</label></div><br/><div class="children"><div class="content">yeah, this is called &quot;cancellation.&quot; Autovacuum is very polite and tries to let go of a lock when there&#x27;s a conflict. So it lets go, over and over, until it triggers a heuristic deciding &quot;no, not succeeding in this session could be dangerous!&quot; and then people begin to notice it.<p>Last I checked (....a few years ago, so things may have changed,) the theory of autovacuum heuristics may not have changed much since the turn of the millennium, they&#x27;re probably about due.</div><br/></div></div></div></div><div id="35722946" class="c"><input type="checkbox" id="c-35722946" checked=""/><div class="controls bullet"><span class="by">jasonhansel</span><span>|</span><a href="#35720135">prev</a><span>|</span><a href="#35719897">next</a><span>|</span><label class="collapse" for="c-35722946">[-]</label><label class="expand" for="c-35722946">[1 more]</label></div><br/><div class="children"><div class="content">IMHO part of the issue is that Postgres was built on the assumption that snapshot isolation would be widely used. I don&#x27;t think this has proven to be the case.<p>Snapshot isolation isn&#x27;t as robust and straightforward as strict serializability, but it also isn&#x27;t as performant as READ COMMITTED. It seems like the worst of both worlds.</div><br/></div></div><div id="35719897" class="c"><input type="checkbox" id="c-35719897" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#35722946">prev</a><span>|</span><a href="#35718362">next</a><span>|</span><label class="collapse" for="c-35719897">[-]</label><label class="expand" for="c-35719897">[8 more]</label></div><br/><div class="children"><div class="content">Yup. A lot of heavy users of Postgres eventually hit the same barrier. Here&#x27;s another take from Uber: <a href="https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;postgres-to-mysql-migration&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.uber.com&#x2F;blog&#x2F;postgres-to-mysql-migration&#x2F;</a><p>I had a similar personal experience. In my previous job we used Postgres to implement a task queuing system, and it created a major bottleneck, resulting in tons of concurrency failures and bloat.<p>And most dangerously, the system failed catastrophically under load. As the load increased, most transactions ended up in concurrent failures, so very little actual work got committed. This increased the amount of outstanding tasks, resulting in even higher rate of concurrent failures.<p>And this can happen suddenly, one moment the system behaves well, with tasks being processed at a good rate, and the next moment the queue blows up and nothing works.<p>I re-implemented this system using pessimistic locking, and it turned out to work much better. Even under very high load, the system could still make forward progress.<p>The downside was having to make sure that no deadlocks can happen.</div><br/><div id="35721940" class="c"><input type="checkbox" id="c-35721940" checked=""/><div class="controls bullet"><span class="by">DiabloD3</span><span>|</span><a href="#35719897">parent</a><span>|</span><a href="#35721568">next</a><span>|</span><label class="collapse" for="c-35721940">[-]</label><label class="expand" for="c-35721940">[4 more]</label></div><br/><div class="children"><div class="content">I remember when Uber got roasted by the postgresql mailing list over this: ultimately, a post mortem was done on all of Uber&#x27;s claims, and it was basically proven that they were incompetent, did not read any available &quot;best practices&quot; guides, did not seek any external help, and treated it like it was some sort of mysql-esque database and used it as wrong as humanly possible.<p>Uber&#x27;s workload at the time, ironically, was not enough to make a postgresql server running moderately decent hardware to fall over if you <i>actually read the manual</i>.<p>Uber&#x27;s engineering team will never be able to live this down.</div><br/><div id="35722425" class="c"><input type="checkbox" id="c-35722425" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#35719897">root</a><span>|</span><a href="#35721940">parent</a><span>|</span><a href="#35722502">next</a><span>|</span><label class="collapse" for="c-35722425">[-]</label><label class="expand" for="c-35722425">[1 more]</label></div><br/><div class="children"><div class="content">Migrating entire workload is way more fun and exciting than reading manual. How else are you going to demonstrate your impact!</div><br/></div></div><div id="35722502" class="c"><input type="checkbox" id="c-35722502" checked=""/><div class="controls bullet"><span class="by">endorphine</span><span>|</span><a href="#35719897">root</a><span>|</span><a href="#35721940">parent</a><span>|</span><a href="#35722425">prev</a><span>|</span><a href="#35722579">next</a><span>|</span><label class="collapse" for="c-35722502">[-]</label><label class="expand" for="c-35722502">[1 more]</label></div><br/><div class="children"><div class="content">Anyone has a link to that mailing list thread to share?</div><br/></div></div><div id="35722579" class="c"><input type="checkbox" id="c-35722579" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#35719897">root</a><span>|</span><a href="#35721940">parent</a><span>|</span><a href="#35722502">prev</a><span>|</span><a href="#35721568">next</a><span>|</span><label class="collapse" for="c-35722579">[-]</label><label class="expand" for="c-35722579">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a link to the mailing list discussion?</div><br/></div></div></div></div><div id="35721568" class="c"><input type="checkbox" id="c-35721568" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#35719897">parent</a><span>|</span><a href="#35721940">prev</a><span>|</span><a href="#35718362">next</a><span>|</span><label class="collapse" for="c-35721568">[-]</label><label class="expand" for="c-35721568">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; In my previous job we used Postgres to implement a task queuing system, and it created a major bottleneck, resulting in tons of concurrency failures and bloat<p>Yet, every month or two an article about doing exactly this is upvoted to near the top of HN. It can of course work but might hard to replace years later once &quot;barnacles&quot; have grown on it. Every situation is different of course.</div><br/><div id="35721748" class="c"><input type="checkbox" id="c-35721748" checked=""/><div class="controls bullet"><span class="by">guywhocodes</span><span>|</span><a href="#35719897">root</a><span>|</span><a href="#35721568">parent</a><span>|</span><a href="#35718362">next</a><span>|</span><label class="collapse" for="c-35721748">[-]</label><label class="expand" for="c-35721748">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve built this queue system probably 5 times, first 2-3 were failures as consumer concurrency was 1 without us noticing for hours. The bloat comes from updating the work instead of deleting I assume, did for me. There are definitely many ways to not do it right but kinda works.</div><br/><div id="35721889" class="c"><input type="checkbox" id="c-35721889" checked=""/><div class="controls bullet"><span class="by">osigurdson</span><span>|</span><a href="#35719897">root</a><span>|</span><a href="#35721748">parent</a><span>|</span><a href="#35718362">next</a><span>|</span><label class="collapse" for="c-35721889">[-]</label><label class="expand" for="c-35721889">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it is strange that hokey, home grown solutions built on top of Postgres are suddenly in vogue.</div><br/></div></div></div></div></div></div></div></div><div id="35718362" class="c"><input type="checkbox" id="c-35718362" checked=""/><div class="controls bullet"><span class="by">Max-Ganz-II</span><span>|</span><a href="#35719897">prev</a><span>|</span><a href="#35718172">next</a><span>|</span><label class="collapse" for="c-35718362">[-]</label><label class="expand" for="c-35718362">[4 more]</label></div><br/><div class="children"><div class="content">MVCC for Amazon Redshift;<p>(pdf) <a href="https:&#x2F;&#x2F;www.redshiftresearchproject.org&#x2F;white_papers&#x2F;downloads&#x2F;multi_version_concurrency_control_and_serialization_isolation_failure.pdf" rel="nofollow">https:&#x2F;&#x2F;www.redshiftresearchproject.org&#x2F;white_papers&#x2F;downloa...</a><p>(html) <a href="https:&#x2F;&#x2F;www.redshiftresearchproject.org&#x2F;white_papers&#x2F;downloads&#x2F;multi_version_concurrency_control_and_serialization_isolation_failure.html" rel="nofollow">https:&#x2F;&#x2F;www.redshiftresearchproject.org&#x2F;white_papers&#x2F;downloa...</a><p>I&#x27;ve been told, very kindly, by a couple of people that it&#x27;s the best explanation they&#x27;ve ever seen.  I&#x27;d like to get more eyes on it, to pick up any mistakes, and it might be useful in and of itself anyway to reader, as MVCC on Redshift is I believe the same as MVCC was on Postgres before snapshot isolation.</div><br/><div id="35719074" class="c"><input type="checkbox" id="c-35719074" checked=""/><div class="controls bullet"><span class="by">gregw2</span><span>|</span><a href="#35718362">parent</a><span>|</span><a href="#35718538">next</a><span>|</span><label class="collapse" for="c-35719074">[-]</label><label class="expand" for="c-35719074">[2 more]</label></div><br/><div class="children"><div class="content">This paper, at least by my skimming, seems to describe Redshift&#x27;s historic SERIALIZABLE ISOLATION level, but does not mention Redshift&#x27;s newer SNAPSHOT ISOLATION capability.<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;about-aws&#x2F;whats-new&#x2F;2022&#x2F;05&#x2F;amazon-redshift-snapshot-isolation-level-support-concurrent-transactions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aws.amazon.com&#x2F;about-aws&#x2F;whats-new&#x2F;2022&#x2F;05&#x2F;amazon-re...</a><p>For concurrency scalability, AWS now configures SNAPSHOT ISOLATION by default if you use Redshift Serverless but non-serverless still defaults to SERIALIZABLE ISOLATION.</div><br/><div id="35720168" class="c"><input type="checkbox" id="c-35720168" checked=""/><div class="controls bullet"><span class="by">Max-Ganz-II</span><span>|</span><a href="#35718362">root</a><span>|</span><a href="#35719074">parent</a><span>|</span><a href="#35718538">next</a><span>|</span><label class="collapse" for="c-35720168">[-]</label><label class="expand" for="c-35720168">[1 more]</label></div><br/><div class="children"><div class="content">Yes.  I intended to write exactly this at the end of my post, but I managed to word it completely wrongly.  The document describes MVCC as it has been in Redshift until about a year ago, when snapshot isolation was introduced.</div><br/></div></div></div></div><div id="35718538" class="c"><input type="checkbox" id="c-35718538" checked=""/><div class="controls bullet"><span class="by">anecdotal1</span><span>|</span><a href="#35718362">parent</a><span>|</span><a href="#35719074">prev</a><span>|</span><a href="#35718172">next</a><span>|</span><label class="collapse" for="c-35718538">[-]</label><label class="expand" for="c-35718538">[1 more]</label></div><br/><div class="children"><div class="content">Not bad but I like this one too<p><a href="http:&#x2F;&#x2F;www.interdb.jp&#x2F;pg&#x2F;pgsql05.html" rel="nofollow">http:&#x2F;&#x2F;www.interdb.jp&#x2F;pg&#x2F;pgsql05.html</a></div><br/></div></div></div></div><div id="35718172" class="c"><input type="checkbox" id="c-35718172" checked=""/><div class="controls bullet"><span class="by">garyclarke27</span><span>|</span><a href="#35718362">prev</a><span>|</span><a href="#35719692">next</a><span>|</span><label class="collapse" for="c-35718172">[-]</label><label class="expand" for="c-35718172">[17 more]</label></div><br/><div class="children"><div class="content">Clever Clickbait - Of course at the end of the article they offer a solution - their product (and of course it’s AI enhanced) to the problem they have overhyped.</div><br/><div id="35719273" class="c"><input type="checkbox" id="c-35719273" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#35718172">parent</a><span>|</span><a href="#35720967">next</a><span>|</span><label class="collapse" for="c-35719273">[-]</label><label class="expand" for="c-35719273">[5 more]</label></div><br/><div class="children"><div class="content">I asked them to take that bit out at the end and it looks like they did.<p>General remark for startups wanting attention on HN: it&#x27;s not good to end an interesting article with a call-to-action that makes your article feel like an ad. Readers who read to the end experience that as a bait-and-switch and end up feeling betrayed.<p>What works much better is to disclose right up front what your startup is and how it&#x27;s related to the article content. Once you&#x27;ve gotten that out of the way, the reader can then dive into the (hopefully)  interesting content and end the article on a satisfying note.<p>Btw, I have a set of notes on how to write for HN that I&#x27;m working (slowly) on turning into an essay. If anyone wants a copy, email me at hn@ycombinator.com and I&#x27;ll be happy to send it. It includes the above point and a bunch more.</div><br/><div id="35722110" class="c"><input type="checkbox" id="c-35722110" checked=""/><div class="controls bullet"><span class="by">jerrygenser</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35719273">parent</a><span>|</span><a href="#35721101">next</a><span>|</span><label class="collapse" for="c-35722110">[-]</label><label class="expand" for="c-35722110">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s another interesting article on front page about oauth that&#x27;s actually almost exactly the same. A very long article about oauth implementation. And sadly I knew the add was coming the whole time and there it was as the last paragraph. It seems that unfortunately or fortunately some of the best really informative intermediate depth blog posts (read: not medium surface level stuff) tends to be an advert by a company offering a very technical product.</div><br/></div></div><div id="35721101" class="c"><input type="checkbox" id="c-35721101" checked=""/><div class="controls bullet"><span class="by">eduction</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35719273">parent</a><span>|</span><a href="#35722110">prev</a><span>|</span><a href="#35720967">next</a><span>|</span><label class="collapse" for="c-35721101">[-]</label><label class="expand" for="c-35721101">[3 more]</label></div><br/><div class="children"><div class="content">I think it’s disturbing you asked someone to change their content and even more disturbing that they complied. You are experienced at moderating Havker News have no business being a global censor for content out in the world. This sucks.<p>As a reader I’d have appreciated the original. And I’d appreciate a nice HN alternative.</div><br/><div id="35721464" class="c"><input type="checkbox" id="c-35721464" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35721101">parent</a><span>|</span><a href="#35721513">next</a><span>|</span><label class="collapse" for="c-35721464">[-]</label><label class="expand" for="c-35721464">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps I should explain. What I actually did was suggest that it would be in their interest to take out the bit that some readers were complaining about, because it felt like an ad at the end. Of course they were free not to follow my suggestion.<p>I admit that&#x27;s not precisely how I described it in the GP comment but it never crossed my mind that anyone would care. Commenter objections never fail to surprise!<p>Edit: I think I was right that it was in their interest as well as all of ours, because earlier the thread was dominated by complaints like this:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35718321" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35718321</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35718172" rel="nofollow">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35718172</a><p>... and after the change, it has been filling up with much more interesting on-topic comments. From my perspective that&#x27;s a win-win-win, but YMMV.</div><br/></div></div><div id="35721513" class="c"><input type="checkbox" id="c-35721513" checked=""/><div class="controls bullet"><span class="by">vore</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35721101">parent</a><span>|</span><a href="#35721464">prev</a><span>|</span><a href="#35720967">next</a><span>|</span><label class="collapse" for="c-35721513">[-]</label><label class="expand" for="c-35721513">[1 more]</label></div><br/><div class="children"><div class="content">Even if they decided not to change it which is fully within their rights and somehow that gets the article moderated off the front page of Hacker News, isn&#x27;t that still moderating Hacker News? No one is getting censored, just like nobody is entitled to have their article be on Hacker News.</div><br/></div></div></div></div></div></div><div id="35720967" class="c"><input type="checkbox" id="c-35720967" checked=""/><div class="controls bullet"><span class="by">apavlo</span><span>|</span><a href="#35718172">parent</a><span>|</span><a href="#35719273">prev</a><span>|</span><a href="#35718386">next</a><span>|</span><label class="collapse" for="c-35720967">[-]</label><label class="expand" for="c-35720967">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Of course at the end of the article they offer a solution - their product (and of course it’s AI enhanced)<p>We have been working on automatic database optimization using AI&#x2F;ML for a decade at Carnegie Mellon University [1][2]. This is not a gimmick. Furthermore, as you can see from the many comments here, the problem is not overhyped.<p>[1] <a href="https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;projects&#x2F;ottertune&#x2F;" rel="nofollow">https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;projects&#x2F;ottertune&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;projects&#x2F;noisepage&#x2F;" rel="nofollow">https:&#x2F;&#x2F;db.cs.cmu.edu&#x2F;projects&#x2F;noisepage&#x2F;</a></div><br/><div id="35723155" class="c"><input type="checkbox" id="c-35723155" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35720967">parent</a><span>|</span><a href="#35723136">next</a><span>|</span><label class="collapse" for="c-35723155">[-]</label><label class="expand" for="c-35723155">[1 more]</label></div><br/><div class="children"><div class="content">Okay, so, Noisepage appears to be open source <a href="https:&#x2F;&#x2F;github.com&#x2F;cmu-db&#x2F;noisepage&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;cmu-db&#x2F;noisepage&#x2F;</a><p>But I can&#x27;t find the Ottertune Github page<p>Is any part of Ottertune open source?</div><br/></div></div><div id="35722884" class="c"><input type="checkbox" id="c-35722884" checked=""/><div class="controls bullet"><span class="by">evntdrvn</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35720967">parent</a><span>|</span><a href="#35723136">prev</a><span>|</span><a href="#35718386">next</a><span>|</span><label class="collapse" for="c-35722884">[-]</label><label class="expand" for="c-35722884">[1 more]</label></div><br/><div class="children"><div class="content">Is there hope of ever seeing Ottertune for MSSQL ?</div><br/></div></div></div></div><div id="35718386" class="c"><input type="checkbox" id="c-35718386" checked=""/><div class="controls bullet"><span class="by">joevandyk</span><span>|</span><a href="#35718172">parent</a><span>|</span><a href="#35720967">prev</a><span>|</span><a href="#35718800">next</a><span>|</span><label class="collapse" for="c-35718386">[-]</label><label class="expand" for="c-35718386">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve personally ran into the problems mentioned in the article many times, unsure it&#x27;s &quot;overhyped&quot;.</div><br/><div id="35718505" class="c"><input type="checkbox" id="c-35718505" checked=""/><div class="controls bullet"><span class="by">spprashant</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35718386">parent</a><span>|</span><a href="#35718800">next</a><span>|</span><label class="collapse" for="c-35718505">[-]</label><label class="expand" for="c-35718505">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a problem, but not an AI problem. It has a clear cause and obvious mitigation strategies.</div><br/><div id="35722689" class="c"><input type="checkbox" id="c-35722689" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35718505">parent</a><span>|</span><a href="#35718800">next</a><span>|</span><label class="collapse" for="c-35722689">[-]</label><label class="expand" for="c-35722689">[1 more]</label></div><br/><div class="children"><div class="content">If there was a clear cause and obvious mitigation strategies then they would have been built into Postgres already.</div><br/></div></div></div></div></div></div><div id="35718800" class="c"><input type="checkbox" id="c-35718800" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#35718172">parent</a><span>|</span><a href="#35718386">prev</a><span>|</span><a href="#35720197">next</a><span>|</span><label class="collapse" for="c-35718800">[-]</label><label class="expand" for="c-35718800">[3 more]</label></div><br/><div class="children"><div class="content">&gt; and of course it’s AI enhanced<p>did they mention LLM&#x2F;ChatGPT?..</div><br/><div id="35719967" class="c"><input type="checkbox" id="c-35719967" checked=""/><div class="controls bullet"><span class="by">luhn</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35718800">parent</a><span>|</span><a href="#35719057">next</a><span>|</span><label class="collapse" for="c-35719967">[-]</label><label class="expand" for="c-35719967">[1 more]</label></div><br/><div class="children"><div class="content">In a previous version of the article they concluded by pitching their &quot;AI-powered cloud database tuning&quot; product.</div><br/></div></div><div id="35719057" class="c"><input type="checkbox" id="c-35719057" checked=""/><div class="controls bullet"><span class="by">BohanOT</span><span>|</span><a href="#35718172">root</a><span>|</span><a href="#35718800">parent</a><span>|</span><a href="#35719967">prev</a><span>|</span><a href="#35720197">next</a><span>|</span><label class="collapse" for="c-35719057">[-]</label><label class="expand" for="c-35719057">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so</div><br/></div></div></div></div><div id="35720197" class="c"><input type="checkbox" id="c-35720197" checked=""/><div class="controls bullet"><span class="by">Scarbutt</span><span>|</span><a href="#35718172">parent</a><span>|</span><a href="#35718800">prev</a><span>|</span><a href="#35719692">next</a><span>|</span><label class="collapse" for="c-35720197">[-]</label><label class="expand" for="c-35720197">[1 more]</label></div><br/><div class="children"><div class="content">and rhetoric:<p><i>So how does one work around PostgreSQL’s quirks? Well, you can spend an enormous amount of time and effort tuning it yourself. Good luck with that.</i></div><br/></div></div></div></div><div id="35719692" class="c"><input type="checkbox" id="c-35719692" checked=""/><div class="controls bullet"><span class="by">audioheavy</span><span>|</span><a href="#35718172">prev</a><span>|</span><a href="#35722413">next</a><span>|</span><label class="collapse" for="c-35719692">[-]</label><label class="expand" for="c-35719692">[4 more]</label></div><br/><div class="children"><div class="content">My main takeaway from this article: as popular as Postgres and MySQL are, and understanding the legacy systems built for them, it will always require deep expertise and &quot;black magic&quot; to achieve enough performance and scale for hyper scale use cases. It justifies the (current) trend to have DB&#x27;s built for distributed tx&#x2F;writes&#x2F;reads that you don&#x27;t have to become a surgeon to scale. There are other DBs and DBaaS that, although not OSS, have solved this problem in a more cost-efficient way than having a team of surgeons.</div><br/><div id="35719744" class="c"><input type="checkbox" id="c-35719744" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#35719692">parent</a><span>|</span><a href="#35722413">next</a><span>|</span><label class="collapse" for="c-35719744">[-]</label><label class="expand" for="c-35719744">[3 more]</label></div><br/><div class="children"><div class="content">I would argue, you handle the hyper-scale use case when you are actually in hyper-scale.  Trying to pre-maturely optimize this is almost always a waste of time and chances are you will screw it up anyway.  Almost nobody gets to that scale anyway.  If you do get to that scale, you have the money and resources to fix the problem(s) at that time.</div><br/><div id="35721405" class="c"><input type="checkbox" id="c-35721405" checked=""/><div class="controls bullet"><span class="by">dalyons</span><span>|</span><a href="#35719692">root</a><span>|</span><a href="#35719744">parent</a><span>|</span><a href="#35722413">next</a><span>|</span><label class="collapse" for="c-35721405">[-]</label><label class="expand" for="c-35721405">[2 more]</label></div><br/><div class="children"><div class="content">i mean, sort of? There is some subtly lost in this oft-repeated advice. i&#x27;ve worked at 3 companies now that were initially based on a single RDBMS but have outgrown the scale of what is reasonable to serve off that architecture. They are consumer scale (10s of mill) users, but not hyperscale (IMHO 100m+). The amount of engineering cost to migrate a complicated growing company&#x2F;product off a mono-db architecture is <i>astounding</i>.  Conservatively i&#x27;m talking 10+ dev years of effort, at each company. Easily 10s of millions of $$$, maybe 100m+. None of them are &quot;finished&quot;. It&#x27;s really really time consuming and hard, once you have 100s of tables, 100s of thousands of lines of code, dozens of teams, etc.<p>I&#x27;m all about avoiding premature optimization, and its fine to start with a classic postgres. But please don&#x27;t cling to that - if you see MVP success and you actually have a reasonable chance of getting to &gt;1mill users (ie, a successful B2C product) please please dont wait to refactor your datastore to a more scalable solution. You will pay dearly if you wait too long. Absolutist advice serves noone well here - it really does depend on what your goals are as a company.</div><br/><div id="35722528" class="c"><input type="checkbox" id="c-35722528" checked=""/><div class="controls bullet"><span class="by">zie</span><span>|</span><a href="#35719692">root</a><span>|</span><a href="#35721405">parent</a><span>|</span><a href="#35722413">next</a><span>|</span><label class="collapse" for="c-35722528">[-]</label><label class="expand" for="c-35722528">[1 more]</label></div><br/><div class="children"><div class="content">Of course subtlety matters, but as you start scaling and noticing pain points, that is when you start working towards fixing them. First you just throw hardware at the problem and that tends to scale really really well for a really long time. It&#x27;s pretty rare, even at very large scale that you MUST move off of PG, there are plenty of well tested scaling solutions, if you have the $$$&#x27;s to spend.<p>10+ years of dev work for a few hundred tables worries me a lot. My last conversion was about 20 years of data across a few hundred tables and we did two-way data synchronization across DB products with about 1 month of work, with 2 devs.  We kept the sync running for over a year in production because we didn&#x27;t want to force users over to the new system in a big hurry.  We only stopped because the license on the old DB product finally expired and nobody wanted to pay for it anymore.</div><br/></div></div></div></div></div></div></div></div><div id="35722413" class="c"><input type="checkbox" id="c-35722413" checked=""/><div class="controls bullet"><span class="by">zeroimpl</span><span>|</span><a href="#35719692">prev</a><span>|</span><a href="#35720218">next</a><span>|</span><label class="collapse" for="c-35722413">[-]</label><label class="expand" for="c-35722413">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Oracle and MySQL do not have this problem in their MVCC implementation because their secondary indexes do not store the physical addresses of new versions. Instead, they store a logical identifier (e.g., tuple id, primary key) that the DBMS then uses to look up the current version’s physical address.<p>This doesn’t have anything to do with MVCC. I’m sure PostgreSQL could implement an index format that piggybacks on another index rather than pointing at the physical page directly, without overhauling MVCC.</div><br/></div></div><div id="35720218" class="c"><input type="checkbox" id="c-35720218" checked=""/><div class="controls bullet"><span class="by">zinclozenge</span><span>|</span><a href="#35722413">prev</a><span>|</span><a href="#35717949">next</a><span>|</span><label class="collapse" for="c-35720218">[-]</label><label class="expand" for="c-35720218">[1 more]</label></div><br/><div class="children"><div class="content">I guess the question is, which MVCC strategy would be the &quot;right&quot; one to pick for a modern relational database? The paper linked focuses on main memory databases, and being main memory allows you to do things you can&#x27;t do when disk based.</div><br/></div></div><div id="35717949" class="c"><input type="checkbox" id="c-35717949" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#35720218">prev</a><span>|</span><a href="#35719124">next</a><span>|</span><label class="collapse" for="c-35717949">[-]</label><label class="expand" for="c-35717949">[4 more]</label></div><br/><div class="children"><div class="content">Can the MVCC implementation be swapped via Postgres extensions?</div><br/><div id="35718071" class="c"><input type="checkbox" id="c-35718071" checked=""/><div class="controls bullet"><span class="by">BohanOT</span><span>|</span><a href="#35717949">parent</a><span>|</span><a href="#35718044">next</a><span>|</span><label class="collapse" for="c-35718071">[-]</label><label class="expand" for="c-35718071">[1 more]</label></div><br/><div class="children"><div class="content">I think there is a new project from the Postgres community. They try to replace the storage engine to solve the inefficiency caused by MVCC<p><a href="https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb">https:&#x2F;&#x2F;github.com&#x2F;orioledb&#x2F;orioledb</a></div><br/></div></div><div id="35718044" class="c"><input type="checkbox" id="c-35718044" checked=""/><div class="controls bullet"><span class="by">apavlo</span><span>|</span><a href="#35717949">parent</a><span>|</span><a href="#35718071">prev</a><span>|</span><a href="#35718302">next</a><span>|</span><label class="collapse" for="c-35718044">[-]</label><label class="expand" for="c-35718044">[1 more]</label></div><br/><div class="children"><div class="content">No. It would be a major surgery on the internals. See the article for my comment at the attempt to do this with the Zheap project:<p><a href="https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Zheap" rel="nofollow">https:&#x2F;&#x2F;wiki.postgresql.org&#x2F;wiki&#x2F;Zheap</a></div><br/></div></div><div id="35718302" class="c"><input type="checkbox" id="c-35718302" checked=""/><div class="controls bullet"><span class="by">rch</span><span>|</span><a href="#35717949">parent</a><span>|</span><a href="#35718044">prev</a><span>|</span><a href="#35719124">next</a><span>|</span><label class="collapse" for="c-35718302">[-]</label><label class="expand" for="c-35718302">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the use case, I&#x27;d consider a foreign data wrapper.</div><br/></div></div></div></div><div id="35719124" class="c"><input type="checkbox" id="c-35719124" checked=""/><div class="controls bullet"><span class="by">vp8989</span><span>|</span><a href="#35717949">prev</a><span>|</span><a href="#35720992">next</a><span>|</span><label class="collapse" for="c-35719124">[-]</label><label class="expand" for="c-35719124">[1 more]</label></div><br/><div class="children"><div class="content">Am I correct in thinking that PG&#x27;s MVCC implementation results in a worse story around offloading some mild OLAP workloads to a replica without affecting the primary? Anecdotally, it <i>seems</i> that MySQL handles this better but I don&#x27;t understand the internals of both enough to explain why that is.<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;database&#x2F;manage-long-running-read-queries-on-amazon-aurora-postgresql-compatible-edition&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;database&#x2F;manage-long-running-re...</a></div><br/></div></div><div id="35720992" class="c"><input type="checkbox" id="c-35720992" checked=""/><div class="controls bullet"><span class="by">kerblang</span><span>|</span><a href="#35719124">prev</a><span>|</span><a href="#35719420">next</a><span>|</span><label class="collapse" for="c-35720992">[-]</label><label class="expand" for="c-35720992">[3 more]</label></div><br/><div class="children"><div class="content">Question: Why would I need more than one extra version of the same row? I would think that with transactional locking everybody else is waiting on the first update to commit before getting their own changes in, unless the db is somehow trying to lock columns-per-row instead of entire rows.</div><br/><div id="35722015" class="c"><input type="checkbox" id="c-35722015" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#35720992">parent</a><span>|</span><a href="#35721944">next</a><span>|</span><label class="collapse" for="c-35722015">[-]</label><label class="expand" for="c-35722015">[1 more]</label></div><br/><div class="children"><div class="content">That would require all queries, including read only queries, to participate in strict two phase locking. That has very poor performance under even very mild contention, not to mention all that mutual locking and unlocking overhead between read only queries is largely un-needed.<p>So what MVCC databases do is keep enough versions to cover the oldest running query instead. Now read only queries don&#x27;t need to hold any locks at all, they just prune the newest version older than the transaction id the query started at.</div><br/></div></div></div></div><div id="35719420" class="c"><input type="checkbox" id="c-35719420" checked=""/><div class="controls bullet"><span class="by">h1fra</span><span>|</span><a href="#35720992">prev</a><span>|</span><a href="#35717223">next</a><span>|</span><label class="collapse" for="c-35719420">[-]</label><label class="expand" for="c-35719420">[3 more]</label></div><br/><div class="children"><div class="content">Once you figured out all the point in this article, it&#x27;s a matter of fine tuning, can take some times but eventually it will works. 
The only thing I still struggle with is the Table Bloat.<p>On managed Postgres (i.e: gcp, aws) you pay for the disk, but when you can&#x27;t run a VACUUM FULL because it locks the table, you end up with a lot of allocated storage for nothing and you can&#x27;t shrink the disk size (at least on gcp). Storage is cheap but still feels like a waste.</div><br/><div id="35719721" class="c"><input type="checkbox" id="c-35719721" checked=""/><div class="controls bullet"><span class="by">fovc</span><span>|</span><a href="#35719420">parent</a><span>|</span><a href="#35717223">next</a><span>|</span><label class="collapse" for="c-35719721">[-]</label><label class="expand" for="c-35719721">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;reorg.github.io&#x2F;pg_repack&#x2F;" rel="nofollow">https:&#x2F;&#x2F;reorg.github.io&#x2F;pg_repack&#x2F;</a><p>Dead easy to run and no long-held locks</div><br/><div id="35721582" class="c"><input type="checkbox" id="c-35721582" checked=""/><div class="controls bullet"><span class="by">jaggederest</span><span>|</span><a href="#35719420">root</a><span>|</span><a href="#35719721">parent</a><span>|</span><a href="#35717223">next</a><span>|</span><label class="collapse" for="c-35721582">[-]</label><label class="expand" for="c-35721582">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely critical once you get above a certain table size.</div><br/></div></div></div></div></div></div><div id="35717223" class="c"><input type="checkbox" id="c-35717223" checked=""/><div class="controls bullet"><span class="by">Ym9oYW4</span><span>|</span><a href="#35719420">prev</a><span>|</span><label class="collapse" for="c-35717223">[-]</label><label class="expand" for="c-35717223">[7 more]</label></div><br/><div class="children"><div class="content">So why Postgres chooses the worst MVCC design compared to MySQL and Oracle? Is this because of legacy reasons or other factors?</div><br/><div id="35717429" class="c"><input type="checkbox" id="c-35717429" checked=""/><div class="controls bullet"><span class="by">apavlo</span><span>|</span><a href="#35717223">parent</a><span>|</span><label class="collapse" for="c-35717429">[-]</label><label class="expand" for="c-35717429">[6 more]</label></div><br/><div class="children"><div class="content">Legacy reasons. The idea was that you wouldn&#x27;t need a WAL because the table itself is the log. And then you could support time-travel queries if you never cleaned up the expired tuples.</div><br/><div id="35719548" class="c"><input type="checkbox" id="c-35719548" checked=""/><div class="controls bullet"><span class="by">drkp</span><span>|</span><a href="#35717223">root</a><span>|</span><a href="#35717429">parent</a><span>|</span><a href="#35718824">next</a><span>|</span><label class="collapse" for="c-35719548">[-]</label><label class="expand" for="c-35719548">[1 more]</label></div><br/><div class="children"><div class="content">_And_ it wasn&#x27;t even originally designed to be used for concurrency control at all...</div><br/></div></div><div id="35718824" class="c"><input type="checkbox" id="c-35718824" checked=""/><div class="controls bullet"><span class="by">riku_iki</span><span>|</span><a href="#35717223">root</a><span>|</span><a href="#35717429">parent</a><span>|</span><a href="#35719548">prev</a><span>|</span><label class="collapse" for="c-35718824">[-]</label><label class="expand" for="c-35718824">[4 more]</label></div><br/><div class="children"><div class="content">Is MVCC actually superior by some other considerations? Less lock contentions, transactional DML.</div><br/><div id="35720153" class="c"><input type="checkbox" id="c-35720153" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#35717223">root</a><span>|</span><a href="#35718824">parent</a><span>|</span><label class="collapse" for="c-35720153">[-]</label><label class="expand" for="c-35720153">[3 more]</label></div><br/><div class="children"><div class="content">The problem is not mvcc but postgres’ implementation details of it.</div><br/><div id="35720180" class="c"><input type="checkbox" id="c-35720180" checked=""/><div class="controls bullet"><span class="by">Max-Ganz-II</span><span>|</span><a href="#35717223">root</a><span>|</span><a href="#35720153">parent</a><span>|</span><label class="collapse" for="c-35720180">[-]</label><label class="expand" for="c-35720180">[2 more]</label></div><br/><div class="children"><div class="content">In what way?  I didn&#x27;t see anything obviously improper when I learned how serialization isolation worked.</div><br/><div id="35722216" class="c"><input type="checkbox" id="c-35722216" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#35717223">root</a><span>|</span><a href="#35720180">parent</a><span>|</span><label class="collapse" for="c-35722216">[-]</label><label class="expand" for="c-35722216">[1 more]</label></div><br/><div class="children"><div class="content">A delicated full vacuum process that need full locking, how little isolation between tables, etc<p>Lots of the pain point have been mitigated in the last ten years.
It is now as simple as other comparable complex db can go (i.e. Not simple, but you can&#x27;t find better product)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>