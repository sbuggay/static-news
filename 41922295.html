<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730106074427" as="style"/><link rel="stylesheet" href="styles.css?v=1730106074427"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://typesanitizer.com/blog/rethink-optimizers.html">Optimizers need a rethink</a> <span class="domain">(<a href="https://typesanitizer.com">typesanitizer.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>97 comments</span></div><br/><div><div id="41965872" class="c"><input type="checkbox" id="c-41965872" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965815">next</a><span>|</span><label class="collapse" for="c-41965872">[-]</label><label class="expand" for="c-41965872">[32 more]</label></div><br/><div class="children"><div class="content">Compiler optimizers are designed from a “win in the average” mindset - so whether a particular optimization succeeds or not is really not something the user ought to rely on. If you’re relying on it then you’re playing with fire. (I say that as someone who has played with this particular kind of fire. Sometimes I’m ok, other times I get burned.)<p>A great example of when winning in the average works is register allocation. It’s fine there because the cost of any particular variable getting spilled is so low. So, all that matters is that most variables are in registers most of the time. If spill heuristics change for the better, it usually means some of your variables that previously got spilled now are in registers while others that were in registers are now spilled - and the compiler writer declares victory if this is a speedup in some overall average of large benchmarks. Similar thinking plays out in stuff like common subexpression elimination or basically any strength reduction. (In fact, most of those optimizations have the peculiar property that you’ll always be able to craft a program that shows the optimization to be a bad idea; we do them anyway because on average they are a speedup.)<p>In my view, if a compiler optimization is so critical that users rely on it reliably “hitting” then what you really want is for that optimization to be something guaranteed by the language using syntax or types. The way tail calls work in functional languages comes to mind. Also, the way value types work in C#, Rust, C++, etc - you’re guaranteed that passing them around won’t call into the allocator. Basically, relying on the compiler to deliver an optimization whose speedup from hitting is enormous (like order of magnitude, as in the escape analysis to remove GC allocations case) and whose probability of hitting is not 100% is sort of a language design bug.<p>This is sort of what the article is saying, I guess. But for example on the issue of the optimizer definitely removing a GC allocation: the best design there is for the GC’d language to have a notion of value types that don’t involve allocation at all. C# has that, Java doesn’t.</div><br/><div id="41966611" class="c"><input type="checkbox" id="c-41966611" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41965872">parent</a><span>|</span><a href="#41966987">next</a><span>|</span><label class="collapse" for="c-41966611">[-]</label><label class="expand" for="c-41966611">[8 more]</label></div><br/><div class="children"><div class="content">One thing I learned about optimizers is some optimizations undo earlier optimizations. The state of the optimized program will sometimes flip-flop back and forth and never converge on a solution. Then you have to rely on a heuristic to guess at the better form, and live with it. The optimizer has a counter in it so it will &quot;pull the plug&quot; if it fails to converge, and will just go with the last state.<p>My optimizer first appeared in Datalight C around 1984 or so. It was the first DFA optimizer for any C compiler on the PC. C compiler benchmark roundups were popular articles in programming magazines at the time. We breathlessly waited for the next roundup article.<p>When it came, Datalight C was omitted from it! The journalist said they excluded Datalight C because it was buggy, as it deleted the benchmark code and just printed the success message. The benchmarks at the time consisted of things like:<p><pre><code>    for (i = 0; i &lt; 1000; ++i) a = 3;
</code></pre>
so of course it deleted the useless code.<p>I was really angry about that, as the journalist never bothered to call us and ask about DLC&#x27;s behavior. Our sales tanked after that article.<p>But it wasn&#x27;t long until the industry realized that optimizers were the future, the benchmarks were revised, and the survivors in the compiler business all did optimizers. DLC recovered, but as you can tell, I am still annoyed at the whole incident.</div><br/><div id="41967122" class="c"><input type="checkbox" id="c-41967122" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966611">parent</a><span>|</span><a href="#41966772">next</a><span>|</span><label class="collapse" for="c-41967122">[-]</label><label class="expand" for="c-41967122">[3 more]</label></div><br/><div class="children"><div class="content">Recently, a D user remarked that a non-optimized build took a few seconds, but turning on the optimizer caused it to take 35 minutes. I was wondering how this was possible. It turns out his code had a function with 30,000 lines of code in it!<p>Some things one just doesn&#x27;t anticipate.<p>Working on compilers is never dull.</div><br/><div id="41967163" class="c"><input type="checkbox" id="c-41967163" checked=""/><div class="controls bullet"><span class="by">subharmonicon</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41967122">parent</a><span>|</span><a href="#41966772">next</a><span>|</span><label class="collapse" for="c-41967163">[-]</label><label class="expand" for="c-41967163">[2 more]</label></div><br/><div class="children"><div class="content">I’m honestly a bit surprised if that’s the first time you’ve seen something like that.<p>I’ve been working on compilers 30 years, primarily on optimizers (although some frontend work as well). Learned C from Borland C and C++ from…Zortech C++ 1.0, so thank you for that!<p>Within a few years of working on compilers I came across my first examples of 50k+ line functions. These were often (but not always) the result of source code generators that were translating some kind of problem description to code. It taught me very early on that you really need to focus on scalability and compile time in compilers, whether it’s the amount of code within a function, or across functions (for IPO &#x2F; LTO).<p>And yes, working on compilers is never dull. 25 years ago I thought we’d end up in a monolithic world with x86, C++, and Java being the focus of all work. Instead, there’s been an absolute explosion of programming models, languages, and architectures, as well as entirely new problem spaces like graph compilers for ML.</div><br/><div id="41967301" class="c"><input type="checkbox" id="c-41967301" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41967163">parent</a><span>|</span><a href="#41966772">next</a><span>|</span><label class="collapse" for="c-41967301">[-]</label><label class="expand" for="c-41967301">[1 more]</label></div><br/><div class="children"><div class="content">I did see slow optimize builds before, but that was on much, much slower machines. I thought that was a thing of the past with modern CPUs.</div><br/></div></div></div></div></div></div><div id="41966772" class="c"><input type="checkbox" id="c-41966772" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966611">parent</a><span>|</span><a href="#41967122">prev</a><span>|</span><a href="#41966987">next</a><span>|</span><label class="collapse" for="c-41966772">[-]</label><label class="expand" for="c-41966772">[4 more]</label></div><br/><div class="children"><div class="content">&gt; One thing I learned about optimizers is some optimizations undo earlier optimizations. The state of the optimized program will sometimes flip-flop back and forth and never converge on a solution. Then you have to rely on a heuristic to guess at the better form, and live with it. The optimizer has a counter in it so it will &quot;pull the plug&quot; if it fails to converge, and will just go with the last state.<p>The way every optimizer I&#x27;ve worked on (and written) deals with this is canonical forms. Like, you decree that the canonical form of &quot;multiply integer by 2&quot; is &quot;x &lt;&lt; 1&quot;, and then you make sure that no optimization ever turns &quot;x &lt;&lt; 1&quot; into anything else (though the instruction selector may then turn &quot;x &lt;&lt; 1&quot; into &quot;x + x&quot; since that&#x27;s the best thing on most CPUs).<p>But that doesn&#x27;t necessarily make this problem any easier. Just gives you a principled story for how to fix the problem if you find it. I think that usually the canonical forms aren&#x27;t even that well documented, and if you get it wrong, then you&#x27;ll still have valid IR so it&#x27;s not like the IR verifier will tell you that you made a mistake - you&#x27;ll just find out because of some infinite loop.<p>And yeah, lots of compiler optimization fixpoints have a counter to kill them after some limit. The LLVM inliner fixpoint is one example of such a thing.<p>&gt; I was really angry about that, as the journalist never bothered to call us and ask about DLC&#x27;s behavior. Our sales tanked after that article.<p>Whoa! That&#x27;s a crazy story! Thanks for sharing!</div><br/><div id="41968831" class="c"><input type="checkbox" id="c-41968831" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966772">parent</a><span>|</span><a href="#41966987">next</a><span>|</span><label class="collapse" for="c-41968831">[-]</label><label class="expand" for="c-41968831">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if any &quot;real&quot; optimizers are using them yet but in theory e-graphs can store a set of forms and avoid this kind of issue.</div><br/><div id="41968867" class="c"><input type="checkbox" id="c-41968867" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41968831">parent</a><span>|</span><a href="#41966987">next</a><span>|</span><label class="collapse" for="c-41968867">[-]</label><label class="expand" for="c-41968867">[2 more]</label></div><br/><div class="children"><div class="content">Cranelift, the (perenially?) up-and-coming Rust compiler, is based on e-graphs.</div><br/><div id="41969008" class="c"><input type="checkbox" id="c-41969008" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41968867">parent</a><span>|</span><a href="#41966987">next</a><span>|</span><label class="collapse" for="c-41969008">[-]</label><label class="expand" for="c-41969008">[1 more]</label></div><br/><div class="children"><div class="content">I guess it&#x27;s borderline &quot;real&quot; ;)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41966987" class="c"><input type="checkbox" id="c-41966987" checked=""/><div class="controls bullet"><span class="by">typesanitizer</span><span>|</span><a href="#41965872">parent</a><span>|</span><a href="#41966611">prev</a><span>|</span><a href="#41966071">next</a><span>|</span><label class="collapse" for="c-41966987">[-]</label><label class="expand" for="c-41966987">[2 more]</label></div><br/><div class="children"><div class="content">&gt; In my view, if a compiler optimization is so critical that users rely on it reliably “hitting” then what you really want is for that optimization to be something guaranteed by the language using syntax or types. The way tail calls work in functional languages comes to mind. Also, the way value types work in C#, Rust, C++, etc - you’re guaranteed that passing them around won’t call into the allocator. Basically, relying on the compiler to deliver an optimization whose speedup from hitting is enormous (like order of magnitude, as in the escape analysis to remove GC allocations case) and whose probability of hitting is not 100% is sort of a language design bug.
&gt;
&gt; This is sort of what the article is saying, I guess.<p>I agree with this to some extent but not fully. I think there are shades of grey to this -- adding language features is a fairly complex and time-consuming process, especially for mainstream languages. Even for properties which many people would like to have, such as &quot;no GC&quot;, there are complex tradeoffs (e.g. <a href="https:&#x2F;&#x2F;em-tg.github.io&#x2F;csborrow&#x2F;" rel="nofollow">https:&#x2F;&#x2F;em-tg.github.io&#x2F;csborrow&#x2F;</a>)<p>My position is that language users need to empowered in different ways depending on the requirements. If you look at the Haskell example involving inspection testing&#x2F;fusion, there are certain guarantees around some type conversions (A -&gt; B, B -&gt; A) being eliminated -- these are somewhat specific to the library at hand. Trying to formalize each and every performance-sensitive library&#x27;s needs using language features is likely not practical.<p>Rather, I think it makes sense instead focus on a more bottoms-up approach, where you give somewhat general tools to the language users (doesn&#x27;t need to expose a full IR), and see what common patterns emerge before deciding whether to &quot;bless&quot; some of them as first-class language features.</div><br/><div id="41967058" class="c"><input type="checkbox" id="c-41967058" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966987">parent</a><span>|</span><a href="#41966071">next</a><span>|</span><label class="collapse" for="c-41967058">[-]</label><label class="expand" for="c-41967058">[1 more]</label></div><br/><div class="children"><div class="content">I think I agree with all of that.<p>My point is that if in the course of discovering common patterns you find that the optimizer must do a heroic optimization with a 10x upside when it hits and weird flakiness about when it hits, then that’s a good indication that maybe a language feature that lets you skip the optimization and let the programmer sort of dictate the outcome is a good idea.<p>By the way, avoiding GC is not the same thing as having value types. Avoiding GC altogether is super hard. But value types aren’t that hard and aren’t about <i>entirely</i> avoiding GC - just avoiding it in specific cases.</div><br/></div></div></div></div><div id="41966071" class="c"><input type="checkbox" id="c-41966071" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41965872">parent</a><span>|</span><a href="#41966987">prev</a><span>|</span><a href="#41966158">next</a><span>|</span><label class="collapse" for="c-41966071">[-]</label><label class="expand" for="c-41966071">[13 more]</label></div><br/><div class="children"><div class="content">Java doesn&#x27;t have it yet, but they are making progress,<p><a href="https:&#x2F;&#x2F;jdk.java.net&#x2F;valhalla&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jdk.java.net&#x2F;valhalla&#x2F;</a><p>Yes, it was a bummer that Java didn&#x27;t take up on the ideas of Cedar, Oberon linage, Modula-3, Eiffel,... even though some are quoted as its influences.<p>Still I am confident that it might be getting value types, before C++ reflection, networking, senders&#x2F;receivers, or safety gets sorted out. Or even that we can finally write portable C++  code using C++20 modules.</div><br/><div id="41966648" class="c"><input type="checkbox" id="c-41966648" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966071">parent</a><span>|</span><a href="#41966167">next</a><span>|</span><label class="collapse" for="c-41966648">[-]</label><label class="expand" for="c-41966648">[3 more]</label></div><br/><div class="children"><div class="content">When are they going to finish making progress? I&#x27;ve been hearing about this for years now and it doesn&#x27;t seem to have happened. Which means Java continues with just about the worst design for memory efficiency you could have.</div><br/><div id="41968836" class="c"><input type="checkbox" id="c-41968836" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966648">parent</a><span>|</span><a href="#41968263">next</a><span>|</span><label class="collapse" for="c-41968836">[-]</label><label class="expand" for="c-41968836">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t worry, Python is always there to do a worse job.</div><br/></div></div><div id="41968263" class="c"><input type="checkbox" id="c-41968263" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966648">parent</a><span>|</span><a href="#41968836">prev</a><span>|</span><a href="#41966167">next</a><span>|</span><label class="collapse" for="c-41968263">[-]</label><label class="expand" for="c-41968263">[1 more]</label></div><br/><div class="children"><div class="content">When they are sure the design is sound enough not to do a Python 2&#x2F;Python 3.<p>If it was easy it would be done by now.<p>There are plenty of long time efforts on other language ecosystem that have also taken decades and still not fully done, e.g. C++ modules, contracts, reflection,...<p>If you really need value type like objects today, it is possible in Panama, even without language syntax for them.</div><br/></div></div></div></div><div id="41966167" class="c"><input type="checkbox" id="c-41966167" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966071">parent</a><span>|</span><a href="#41966648">prev</a><span>|</span><a href="#41966122">next</a><span>|</span><label class="collapse" for="c-41966167">[-]</label><label class="expand" for="c-41966167">[6 more]</label></div><br/><div class="children"><div class="content">Unfortunately, it doesn&#x27;t look like there&#x27;s much of a guarantee that value objects wouldn&#x27;t result in heap allocations. <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;401" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;401</a> even contains:<p>&gt; So while many small value classes can be flattened, classes that declare, say, 2 int fields or a double field, might have to be encoded as ordinary heap objects.<p>There&#x27;s a further comment about potential of opting out of atomicity guarantees to not have that problem, but then there are more problems - looks like pre-JIT would still allocate, and who knows how consistent would JIT be about scalarization. IIRC there was also some mention somewhere about just forcing large enough value objects to always be heap allocations.</div><br/><div id="41966436" class="c"><input type="checkbox" id="c-41966436" checked=""/><div class="controls bullet"><span class="by">elygre</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966167">parent</a><span>|</span><a href="#41966122">next</a><span>|</span><label class="collapse" for="c-41966436">[-]</label><label class="expand" for="c-41966436">[5 more]</label></div><br/><div class="children"><div class="content">That’s some very selective quoting there. Let’s do the full thing:<p>&gt; Heap flattening must maintain the integrity of objects. For example, the flattened data must be small enough to read and write atomically, or else it may become corrupted. On common platforms, &quot;small enough&quot; may mean as few as 64 bits, including the null flag. So while many small value classes can be flattened, classes that declare, say, 2 int fields or a double field, might have to be encoded as ordinary heap objects.<p>And maybe the end of the next paragraph is even more relevant:<p>&gt; In the future, 128-bit flattened encodings should be possible on platforms that support atomic reads and writes of that size. And the Null-Restricted Value Types JEP will enable heap flattening for even larger value classes in use cases that are willing to opt out of atomicity guarantees.</div><br/><div id="41966591" class="c"><input type="checkbox" id="c-41966591" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966436">parent</a><span>|</span><a href="#41966565">next</a><span>|</span><label class="collapse" for="c-41966591">[-]</label><label class="expand" for="c-41966591">[3 more]</label></div><br/><div class="children"><div class="content">If value types still require allocation for stuff larger than 128 bits then that really sucks! That’s not how value types usually work.</div><br/><div id="41966860" class="c"><input type="checkbox" id="c-41966860" checked=""/><div class="controls bullet"><span class="by">bremac</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966591">parent</a><span>|</span><a href="#41966565">next</a><span>|</span><label class="collapse" for="c-41966860">[-]</label><label class="expand" for="c-41966860">[2 more]</label></div><br/><div class="children"><div class="content">Value types still require allocation for types larger than 128 bits if the value is either nullable or atomic — that seems like a reasonable trade-off to me.</div><br/><div id="41967061" class="c"><input type="checkbox" id="c-41967061" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966860">parent</a><span>|</span><a href="#41966565">next</a><span>|</span><label class="collapse" for="c-41967061">[-]</label><label class="expand" for="c-41967061">[1 more]</label></div><br/><div class="children"><div class="content">Oh! Reasonable trade-off indeed. Thank you for clarifying.</div><br/></div></div></div></div></div></div><div id="41966565" class="c"><input type="checkbox" id="c-41966565" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966436">parent</a><span>|</span><a href="#41966591">prev</a><span>|</span><a href="#41966122">next</a><span>|</span><label class="collapse" for="c-41966565">[-]</label><label class="expand" for="c-41966565">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, had edited my comment to expand a bit on that. Nevertheless, this is just one place where allocation of value objects may appear; and it looks like eliding allocations is still generally in the &quot;optimization&quot; category, rather than &quot;guarantee&quot;.</div><br/></div></div></div></div></div></div><div id="41966122" class="c"><input type="checkbox" id="c-41966122" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966071">parent</a><span>|</span><a href="#41966167">prev</a><span>|</span><a href="#41966572">next</a><span>|</span><label class="collapse" for="c-41966122">[-]</label><label class="expand" for="c-41966122">[2 more]</label></div><br/><div class="children"><div class="content">That is really cool!<p>It’s a dang hard feature to retrofit into the way the JVM works. I wish those folks the best of luck.</div><br/><div id="41966155" class="c"><input type="checkbox" id="c-41966155" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966122">parent</a><span>|</span><a href="#41966572">next</a><span>|</span><label class="collapse" for="c-41966155">[-]</label><label class="expand" for="c-41966155">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that is the biggest engineering effort of the whole thing, how to add the value types concept into the JVM, without breaking the ecosystem.<p>JARs and modules that work on the JVM before value types introduction should keep running, and how can new code interoperate with such jars.</div><br/></div></div></div></div></div></div><div id="41966158" class="c"><input type="checkbox" id="c-41966158" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#41965872">parent</a><span>|</span><a href="#41966071">prev</a><span>|</span><a href="#41965815">next</a><span>|</span><label class="collapse" for="c-41966158">[-]</label><label class="expand" for="c-41966158">[8 more]</label></div><br/><div class="children"><div class="content">&gt; In my view, if a compiler optimization is so critical that users rely on it reliably “hitting” then what you really want is for that optimization to be something guaranteed by the language using syntax or types. The way tail calls work in functional languages comes to mind.<p>Automatic vectorisation is another big one. It feels to me like vectorisation is less reliable &#x2F; more complex than TCO? But on the other hand the downside is a linear slowdown, not &quot;your program blows the stack and crashes&quot;.</div><br/><div id="41966311" class="c"><input type="checkbox" id="c-41966311" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966158">parent</a><span>|</span><a href="#41966242">next</a><span>|</span><label class="collapse" for="c-41966311">[-]</label><label class="expand" for="c-41966311">[2 more]</label></div><br/><div class="children"><div class="content">With clang you can add &quot;#pragma clang loop vectorize(assume_safety)&quot; to a loop to reduce the burden of proof of vectorizability and to do it if at all possible, giving a warning when it fails to. gcc has &quot;#pragma GCC ivdep&quot; to reduce dependency analysis, but it&#x27;s not as powerful as clang&#x27;s pragma.</div><br/><div id="41968592" class="c"><input type="checkbox" id="c-41968592" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966311">parent</a><span>|</span><a href="#41966242">next</a><span>|</span><label class="collapse" for="c-41968592">[-]</label><label class="expand" for="c-41968592">[1 more]</label></div><br/><div class="children"><div class="content">&gt; giving a warning when it fails to<p>This is the critical point. If CI fails or otherwise you are warned when the loop doesn&#x27;t vectorize, then you can count on it to always happen</div><br/></div></div></div></div><div id="41966242" class="c"><input type="checkbox" id="c-41966242" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966158">parent</a><span>|</span><a href="#41966311">prev</a><span>|</span><a href="#41965815">next</a><span>|</span><label class="collapse" for="c-41966242">[-]</label><label class="expand" for="c-41966242">[5 more]</label></div><br/><div class="children"><div class="content">If you’re talking about autovectorization in C++ then you have the option of using intrinsics to get real vector code. So I think that’s fine because you have a way to tell the compiler, “I really want simd”.</div><br/><div id="41966659" class="c"><input type="checkbox" id="c-41966659" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966242">parent</a><span>|</span><a href="#41965815">next</a><span>|</span><label class="collapse" for="c-41966659">[-]</label><label class="expand" for="c-41966659">[4 more]</label></div><br/><div class="children"><div class="content">A better fundamental design would be a SPMD language (like ispc, or GPU languages) and then autoscalarization, which is a lot easier to do reliably than autovectorization.<p>Intrinsics work poorly in some compilers, and Intel&#x27;s intrinsics are so hard to read because of inscrutable Hungarian notation that you should just write in asm instead.</div><br/><div id="41966725" class="c"><input type="checkbox" id="c-41966725" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966659">parent</a><span>|</span><a href="#41965815">next</a><span>|</span><label class="collapse" for="c-41966725">[-]</label><label class="expand" for="c-41966725">[3 more]</label></div><br/><div class="children"><div class="content">Ispc is great but I think you’re also saying that:<p>- it would be better if the intrinsics had sensible names. I couldn’t agree more.<p>- it would be better if compilers consistently did a good job of implementing them. I wonder which compilers do a bad job? Does clang do a good job or not so much?<p>I think intrinsics make sense for the case where the language being used is not otherwise simd and that language already has value types (so it’s easy to add a vector type). It would be great if they at least worked consistently well and had decent names in that case.</div><br/><div id="41968865" class="c"><input type="checkbox" id="c-41968865" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966725">parent</a><span>|</span><a href="#41966915">next</a><span>|</span><label class="collapse" for="c-41968865">[-]</label><label class="expand" for="c-41968865">[1 more]</label></div><br/><div class="children"><div class="content">I have yet to see a compiler that does a good job with autovectorization.</div><br/></div></div><div id="41966915" class="c"><input type="checkbox" id="c-41966915" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#41965872">root</a><span>|</span><a href="#41966725">parent</a><span>|</span><a href="#41968865">prev</a><span>|</span><a href="#41965815">next</a><span>|</span><label class="collapse" for="c-41966915">[-]</label><label class="expand" for="c-41966915">[1 more]</label></div><br/><div class="children"><div class="content">Intrinsics have somewhat saner names in C#, and unify under the same types for both portable and platform-specific variants (Vector64&#x2F;128&#x2F;256&#x2F;512&lt;T&gt;, numeric operators on them and methods on VectorXXX.* or Sse42&#x2F;Avx&#x2F;AdvSimd&#x2F;etc.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41965815" class="c"><input type="checkbox" id="c-41965815" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#41965872">prev</a><span>|</span><a href="#41965603">next</a><span>|</span><label class="collapse" for="c-41965815">[-]</label><label class="expand" for="c-41965815">[14 more]</label></div><br/><div class="children"><div class="content">The standard optimization user case story is absurd.<p>1. You’re not gonna get any guarantees that the optimization will happen. That makes it High Level. Just write code. We won’t force you to pollute your code with ugly annotations or pragmas.<p>2. In turn: check the assembly or whatever the concrete thing that reveals that the optimization you wished for in your head actually went through<p>There’s some kind of abstraction violation in the above somewhere.</div><br/><div id="41966028" class="c"><input type="checkbox" id="c-41966028" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#41965815">parent</a><span>|</span><a href="#41966431">next</a><span>|</span><label class="collapse" for="c-41966028">[-]</label><label class="expand" for="c-41966028">[4 more]</label></div><br/><div class="children"><div class="content">Agreed. You put your finger directly on something that&#x27;s always bugged me about optimistic code optimization strategies. The code I write is supposed to have deterministic behaviour. If the determinism changes, it should be because of a change I made, not a flag in the compiler. The behaviour is completely opaque and uncorrelatable, makes it very hard to figure out if a given change will lead to better or worse performance.<p>&quot;Abstraction violation&quot; is a good way to put it.</div><br/><div id="41966052" class="c"><input type="checkbox" id="c-41966052" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966028">parent</a><span>|</span><a href="#41966431">next</a><span>|</span><label class="collapse" for="c-41966052">[-]</label><label class="expand" for="c-41966052">[3 more]</label></div><br/><div class="children"><div class="content">The excuse for this is that performance is not considered part of the behavior of the program. So it doesn&#x27;t matter to the question of whether your program is deterministic.</div><br/><div id="41966264" class="c"><input type="checkbox" id="c-41966264" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966052">parent</a><span>|</span><a href="#41967077">next</a><span>|</span><label class="collapse" for="c-41966264">[-]</label><label class="expand" for="c-41966264">[1 more]</label></div><br/><div class="children"><div class="content">These days you don&#x27;t know what cpu you run on so you can&#x27;t make performance guarentees anyway. Even in embedded we have been burn with the only cpu going out of production enough to not depend on it anymore in most cases.</div><br/></div></div><div id="41967077" class="c"><input type="checkbox" id="c-41967077" checked=""/><div class="controls bullet"><span class="by">glitchc</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966052">parent</a><span>|</span><a href="#41966264">prev</a><span>|</span><a href="#41966431">next</a><span>|</span><label class="collapse" for="c-41967077">[-]</label><label class="expand" for="c-41967077">[1 more]</label></div><br/><div class="children"><div class="content">Except for the fact that performance optimization frequently does change the behaviour of the program.</div><br/></div></div></div></div></div></div><div id="41966431" class="c"><input type="checkbox" id="c-41966431" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#41965815">parent</a><span>|</span><a href="#41966028">prev</a><span>|</span><a href="#41965998">next</a><span>|</span><label class="collapse" for="c-41966431">[-]</label><label class="expand" for="c-41966431">[1 more]</label></div><br/><div class="children"><div class="content">It is a leaky abstraction, all abstractions are. I didn&#x27;t find it to be much of a problem in practice.<p>Usually, if you don&#x27;t get the optimization you wished for, it means that there is something you didn&#x27;t account for. In C++, it may be exception processing, aliasing rules, etc... Had the compiler made the optimization you wished for, it wouldn&#x27;t have been correct with regard to the specifications of the language, it may even hide a bug. The solution is then to write it in a way that is more explicit, to make the compiler understand that the edge case can never happen, which will then enable the optimization. It is not really an abstraction violation, more like a form of debugging.<p>If you really need to get low level, there is some point where you need to write assembly language, which is obviously not portable, but getting every last bit of performance is simply incompatible with portability.</div><br/></div></div><div id="41965998" class="c"><input type="checkbox" id="c-41965998" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41965815">parent</a><span>|</span><a href="#41966431">prev</a><span>|</span><a href="#41966417">next</a><span>|</span><label class="collapse" for="c-41965998">[-]</label><label class="expand" for="c-41965998">[4 more]</label></div><br/><div class="children"><div class="content">I have the same experience with database query planners. The promise is that you just write your business logic in SQL and the planner takes care of the rest. In practice you spend weeks staring at execution plans.</div><br/><div id="41966105" class="c"><input type="checkbox" id="c-41966105" checked=""/><div class="controls bullet"><span class="by">dspillett</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41965998">parent</a><span>|</span><a href="#41966417">next</a><span>|</span><label class="collapse" for="c-41966105">[-]</label><label class="expand" for="c-41966105">[3 more]</label></div><br/><div class="children"><div class="content">A key difference between many compilers and DB query planners, is that a compiler can spend more time over its optimisations because it is run dev-side and the benefits (and none of the time taken) are felt by the users. A query planner needs to be more conservative with its resource use.<p>This is not true of JIT compilers, of course, which have similar constraints to DB query planners. In these cases the goal is to do a good job pretty quickly, rather than an excellent job in a reasonable time.</div><br/><div id="41968846" class="c"><input type="checkbox" id="c-41968846" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966105">parent</a><span>|</span><a href="#41966459">next</a><span>|</span><label class="collapse" for="c-41968846">[-]</label><label class="expand" for="c-41968846">[1 more]</label></div><br/><div class="children"><div class="content">However most big boys databases also package a JIT compiler into the mix, making it more fun.</div><br/></div></div><div id="41966459" class="c"><input type="checkbox" id="c-41966459" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966105">parent</a><span>|</span><a href="#41968846">prev</a><span>|</span><a href="#41966417">next</a><span>|</span><label class="collapse" for="c-41966459">[-]</label><label class="expand" for="c-41966459">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A query planner needs to be more conservative with its resource use.<p>The number of possible distinct query plans grows very rapidly as the complexity increases (exponentially or factorially... I can&#x27;t remember). So even if you have 10x as much time available for optimisation, it makes a surprisingly small difference.<p>One approach I&#x27;ve seen with systems like Microsoft Exchange and its undrelying Jet database is that queries are expressed in a lower-level syntax tree DOM structure. The specific query plan is &quot;baked in&quot; by developers right from the beginning, which provides stable and consistent performance in production. It&#x27;s also lower latency because the time spent by the optimiser at runtime is zero.</div><br/></div></div></div></div></div></div><div id="41966417" class="c"><input type="checkbox" id="c-41966417" checked=""/><div class="controls bullet"><span class="by">randomNumber7</span><span>|</span><a href="#41965815">parent</a><span>|</span><a href="#41965998">prev</a><span>|</span><a href="#41965603">next</a><span>|</span><label class="collapse" for="c-41966417">[-]</label><label class="expand" for="c-41966417">[4 more]</label></div><br/><div class="children"><div class="content">When you already know what you want to have after the optimization, you could just write that code in the beginning.</div><br/><div id="41966723" class="c"><input type="checkbox" id="c-41966723" checked=""/><div class="controls bullet"><span class="by">aleph_minus_one</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966417">parent</a><span>|</span><a href="#41965603">next</a><span>|</span><label class="collapse" for="c-41966723">[-]</label><label class="expand" for="c-41966723">[3 more]</label></div><br/><div class="children"><div class="content">Not all programming languages have this amount of expressiveness. How do you, for example, tell how a database what the intended execution plan is for some complicated SQL query?<p>You can normally only send SQL queries to a database and not execution plans.</div><br/><div id="41968737" class="c"><input type="checkbox" id="c-41968737" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966723">parent</a><span>|</span><a href="#41966944">next</a><span>|</span><label class="collapse" for="c-41968737">[-]</label><label class="expand" for="c-41968737">[1 more]</label></div><br/><div class="children"><div class="content">Using bit rotation instructions in C is another case I recall.<p>Since there&#x27;s no bit rotate operator in C, you&#x27;re left hoping the compiler recognizes what the shifts and bitwise-ands are trying to do.</div><br/></div></div><div id="41966944" class="c"><input type="checkbox" id="c-41966944" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41965815">root</a><span>|</span><a href="#41966723">parent</a><span>|</span><a href="#41968737">prev</a><span>|</span><a href="#41965603">next</a><span>|</span><label class="collapse" for="c-41966944">[-]</label><label class="expand" for="c-41966944">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wanted to just write the execution plan directly and bypass the planner for a few hot queries.</div><br/></div></div></div></div></div></div></div></div><div id="41965603" class="c"><input type="checkbox" id="c-41965603" checked=""/><div class="controls bullet"><span class="by">leni536</span><span>|</span><a href="#41965815">prev</a><span>|</span><a href="#41966405">next</a><span>|</span><label class="collapse" for="c-41965603">[-]</label><label class="expand" for="c-41965603">[2 more]</label></div><br/><div class="children"><div class="content">I think this is mostly a philosphical question, rather than optimizer quality.<p>Once an optimization becomes part of the interface and it is guaranteed, is it really an optimization? Or did it just became part of the language&#x2F;library&#x2F;database&#x2F;whatever?<p>One example is return value optimization in C++. In C++17 the &quot;optimization&quot; became mandatory in some contexts. What really happened though is that the rules of temporary materialization changed, and in those contexts it just never happens prematurely by the language rules. This ceased to be an optimization and became a mechanism in the language.<p>What I&#x27;m getting at is that unreliability is a defining quality of optimizations.<p>Sure, there are certain optimizations that become load-bearing, in which case it would be better if they became part of the language&#x27;s semantics and guarantees, therefore they ceased to be optimizations.</div><br/><div id="41965710" class="c"><input type="checkbox" id="c-41965710" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#41965603">parent</a><span>|</span><a href="#41966405">next</a><span>|</span><label class="collapse" for="c-41965710">[-]</label><label class="expand" for="c-41965710">[1 more]</label></div><br/><div class="children"><div class="content">It is still a useful distinction. Programming languages are complex enough to understand. It is useful to have a base of &#x27;this is the simplest description of how programs will work&#x27; that is as simple as possible. Then, a separate set of &#x27;and here is a separate description of its performance characteristics; nothing in this portion should be understood to change the defined behavior of any program&quot;.<p>Even if that second description is stable and part of the guarantees you make, keeping it seperate is still incredibly useful from a user perspective.<p>From an implementation perspective, there is also a useful distinction. Optimizations take a valid representation, and turn it into a different valid representation of the same type that shares all defined behavior. This is a fairly different operation than compilation, which converts between representations. In particular, for the compilation step, you typically have only one compilation function for a given pair of representations; and if you have multiple, you select one ahead of time. For optimizations, each representation has a set of optimization functions, and you need to decided what order to apply them and how many times to do so. Compilation functions, for their part, need to deal with every difference between the two representations, whereas optimization functions get to ignore everything except the part they care about.</div><br/></div></div></div></div><div id="41966405" class="c"><input type="checkbox" id="c-41966405" checked=""/><div class="controls bullet"><span class="by">h1fra</span><span>|</span><a href="#41965603">prev</a><span>|</span><a href="#41965701">next</a><span>|</span><label class="collapse" for="c-41966405">[-]</label><label class="expand" for="c-41966405">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t hate query planning, some people are better than me at writing algo and the database knows my data better than me.<p>However, what I hate is the lack of transparency (and I feel like this article tries to pin-point just this). When I execute a query locally I get a different plan vs staging vs prod. A plan than can also change depending on some parameters or load or size.<p>I don&#x27;t care about understanding all the underlying optimizations, I just care that the query plan I saw is the same and is still the same in prod, and that I can be warned when it changes. PG does not return the hash of the query plan or metrics along the data, which is imo a mistake. With this you could track it in your favorite metrics store and be able to point when and why stuff are executing differently.</div><br/></div></div><div id="41965701" class="c"><input type="checkbox" id="c-41965701" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41966405">prev</a><span>|</span><a href="#41966561">next</a><span>|</span><label class="collapse" for="c-41965701">[-]</label><label class="expand" for="c-41965701">[10 more]</label></div><br/><div class="children"><div class="content">One area that I have been exploring is building equivalence proofs between high-level specifications, an implementation in C, and the machine code output from the compiler. I&#x27;m still very early in that work, but one of my hopes is to at least demonstrate that the output still meets the specifications, and that we can control things like timing (e.g. no branching on secret data) and cache in this output.<p>I think that the compilation and optimization step, as a black box, is a disservice for highly reliable software development. Compiler and optimizer bugs are definitely a thing. I was bitten by one that injected timing attacks into certain integer operations by branching on the integer data in order to optimize 32-bit multiplications on 8-bit microcontrollers. Yeah, this makes perfect sense when trying to optimize fixed point multiplication, but it completely destroys the security of DLP or ecDLP based cryptography by introducing timing attacks that can recover the private key. Thankfully, I was fastidious about examining the optimized machine code output of this compiler, and was able to substitute hand coded assembler in its place.</div><br/><div id="41965768" class="c"><input type="checkbox" id="c-41965768" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#41965701">parent</a><span>|</span><a href="#41966154">next</a><span>|</span><label class="collapse" for="c-41965768">[-]</label><label class="expand" for="c-41965768">[2 more]</label></div><br/><div class="children"><div class="content">&gt; One area that I have been exploring is building equivalence proofs between high-level specifications, an implementation in C, and the machine code output from the compiler.<p>AFAIK, that&#x27;s how seL4 is verified. Quoting from <a href="https:&#x2F;&#x2F;docs.sel4.systems&#x2F;projects&#x2F;sel4&#x2F;frequently-asked-questions.html#what-does-sel4s-formal-verification-mean" rel="nofollow">https:&#x2F;&#x2F;docs.sel4.systems&#x2F;projects&#x2F;sel4&#x2F;frequently-asked-que...</a><p>&quot;[...] Specifically, the ARM, ARM_HYP (ARM with virtualisation extensions), X64, and RISCV64 versions of seL4 comprise the first (and still only) general-purpose OS kernel with a full code-level functional correctness proof, meaning a mathematical proof that the implementation (written in C) adheres to its specification. [...] On the ARM and RISCV64 platforms, there is a further proof that the binary code which executes on the hardware is a correct translation of the C code. This means that the compiler does not have to be trusted, and extends the functional correctness property to the binary. [...] Combined with the proofs mentioned above, these properties are guaranteed to be enforced not only by a model of the kernel (the specification) but the actual binary that executes on the hardware.&quot;</div><br/><div id="41965920" class="c"><input type="checkbox" id="c-41965920" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41965701">root</a><span>|</span><a href="#41965768">parent</a><span>|</span><a href="#41966154">next</a><span>|</span><label class="collapse" for="c-41965920">[-]</label><label class="expand" for="c-41965920">[1 more]</label></div><br/><div class="children"><div class="content">Indeed it is. What I&#x27;m working toward is a more efficient way to do the same, that doesn&#x27;t take the touted 30 man years of effort to accomplish.<p>I&#x27;m working on a hybrid approach between SMT solving and constructive proofs. Model checking done with an SMT solver is pretty sound. I&#x27;m actually planning a book on a scalable technique to do this with CBMC. But, the last leg of this really is understanding the compiler output.</div><br/></div></div></div></div><div id="41966154" class="c"><input type="checkbox" id="c-41966154" checked=""/><div class="controls bullet"><span class="by">nlewycky</span><span>|</span><a href="#41965701">parent</a><span>|</span><a href="#41965768">prev</a><span>|</span><a href="#41965779">next</a><span>|</span><label class="collapse" for="c-41966154">[-]</label><label class="expand" for="c-41966154">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I was bitten by one that injected timing attacks into certain integer operations by branching on the integer data in order to optimize 32-bit multiplications on 8-bit microcontrollers.<p>FWIW, I think this should be considered a language design problem rather than an optimizer design problem. Black box optimizer behaviour is good for enabling language designs that have little connection to hardware behaviour, and good for portability including to different extensions within an ISA.<p>C doesn&#x27;t offer a way to express any timing guarantees. The compiler, OS, CPU designer, etc. can&#x27;t even do the right thing if they wanted to because the necessary information isn&#x27;t being received from the programmer.</div><br/><div id="41966258" class="c"><input type="checkbox" id="c-41966258" checked=""/><div class="controls bullet"><span class="by">jcranmer</span><span>|</span><a href="#41965701">root</a><span>|</span><a href="#41966154">parent</a><span>|</span><a href="#41966279">next</a><span>|</span><label class="collapse" for="c-41966258">[-]</label><label class="expand" for="c-41966258">[3 more]</label></div><br/><div class="children"><div class="content">To a large degree, constant-time programming is hampered by the fact that even <i>hardware</i> is often unwilling to provide constant-time guarantees, let alone any guarantees that the compiler would care to preserve. (Although, to be honest, constant-time guarantees are the sort of things that most compiler writers prefer to explicitly not guarantee in any circumstances whatsoever).</div><br/><div id="41966307" class="c"><input type="checkbox" id="c-41966307" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#41965701">root</a><span>|</span><a href="#41966258">parent</a><span>|</span><a href="#41966279">next</a><span>|</span><label class="collapse" for="c-41966307">[-]</label><label class="expand" for="c-41966307">[2 more]</label></div><br/><div class="children"><div class="content">8 bit cpus offer constant time. 16 bit was starting to get into the issues where you cannot off it.</div><br/><div id="41967828" class="c"><input type="checkbox" id="c-41967828" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#41965701">root</a><span>|</span><a href="#41966307">parent</a><span>|</span><a href="#41966279">next</a><span>|</span><label class="collapse" for="c-41967828">[-]</label><label class="expand" for="c-41967828">[1 more]</label></div><br/><div class="children"><div class="content">Your comment makes me wonder about the idea of building a superscalar, out of order, speculative implementation of the 6502 or 8080 instruction sets. Might make a good educational project.</div><br/></div></div></div></div></div></div><div id="41966279" class="c"><input type="checkbox" id="c-41966279" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41965701">root</a><span>|</span><a href="#41966154">parent</a><span>|</span><a href="#41966258">prev</a><span>|</span><a href="#41965779">next</a><span>|</span><label class="collapse" for="c-41966279">[-]</label><label class="expand" for="c-41966279">[1 more]</label></div><br/><div class="children"><div class="content">Few languages provide such guarantees. But, there really was no way with this particular compiler to pass a hint to generate constant time code.<p>Black box designs work until the knob or dial you need to control it isn&#x27;t there. I would have taken a pragma, a command-line option to the compiler, or even a language extension.<p>This is one example of many as to why I think that user-guided code generation should be an option of a modern tool suite. If I build formal specifications indicating the sort of behavior I expect, I should be able to link these specifications to the output. Ultimately, this will come down to engineering, and possibly, overriding or modifying the optimizer itself. An extensible design that makes it possible to do this would significantly improve my work. Barring that, I have to write assembler by hand to work around bad assumptions made by the optimizer.</div><br/></div></div></div></div><div id="41965779" class="c"><input type="checkbox" id="c-41965779" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#41965701">parent</a><span>|</span><a href="#41966154">prev</a><span>|</span><a href="#41966561">next</a><span>|</span><label class="collapse" for="c-41965779">[-]</label><label class="expand" for="c-41965779">[2 more]</label></div><br/><div class="children"><div class="content">If you haven&#x27;t done so, you might want to look at some of the work done by the seL4 microkernel project.<p>They start with a Haskell prototype that is translated programatically into a formal specification for the theorem prover.<p>They then implement the same thing in C, and use a refinement prove to demonstrate that it matches their Haskell implementation.<p>They then compile the program, and create another refinement proof to demonstrate that the binary code matches the C semantics.</div><br/><div id="41965932" class="c"><input type="checkbox" id="c-41965932" checked=""/><div class="controls bullet"><span class="by">nanolith</span><span>|</span><a href="#41965701">root</a><span>|</span><a href="#41965779">parent</a><span>|</span><a href="#41966561">next</a><span>|</span><label class="collapse" for="c-41965932">[-]</label><label class="expand" for="c-41965932">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll refer you to my reply to a sibling comment. I&#x27;m hoping that I can build a more efficient means of doing similar work as with seL4, but without the 30 man year effort.<p>They are on the right track. But, I think there have been some improvements since their effort that can lead to more streamlined equivalence proofs.</div><br/></div></div></div></div></div></div><div id="41966561" class="c"><input type="checkbox" id="c-41966561" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41965701">prev</a><span>|</span><a href="#41968626">next</a><span>|</span><label class="collapse" for="c-41966561">[-]</label><label class="expand" for="c-41966561">[6 more]</label></div><br/><div class="children"><div class="content">&gt; D has first-class support for marking functions as “no GC”.<p>It never occurred to me that this would be considered a hint to the optimizer. It doesn&#x27;t affect code generation. What it does do is flag any use of the gc in the function and any functions it transitively may call.<p>Optimizers have been likened to turning a cow into a hamburger. If you&#x27;re symbolically debugging optimized code, you&#x27;re looking at the hamburger. Nobody has been able to solve that problem.<p>It&#x27;s true that optimizers themselves are hard to show being correct. The one in the D compiler is a conventional DFA optimizer that uses data flow equations I learned from Hennessy and Ullman in a 1982 seminar they taught. So it has been battle tested for 42 years now(!) and it&#x27;s pretty rare to find a problem with it, unless it&#x27;s a new pass I added like SROA. The idea is anytime a problem is identified and corrected, it goes into the test suite. This has the effect of always ratcheting it forward and not regress.<p>The GC dates from around 2000, when I wrote it for a Javascript engine. It was brutally tested for that, and has been pretty solid ever since. People complain about the GC, but not about it being buggy. A buggy GC is a real horror show as it is painfully difficult to debug.</div><br/><div id="41968881" class="c"><input type="checkbox" id="c-41968881" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41966561">parent</a><span>|</span><a href="#41966902">next</a><span>|</span><label class="collapse" for="c-41968881">[-]</label><label class="expand" for="c-41968881">[3 more]</label></div><br/><div class="children"><div class="content">Languages that run in a VM are pretty good at turning the hamburger back into a cow when you&#x27;re looking at it.</div><br/><div id="41968961" class="c"><input type="checkbox" id="c-41968961" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41966561">root</a><span>|</span><a href="#41968881">parent</a><span>|</span><a href="#41966902">next</a><span>|</span><label class="collapse" for="c-41968961">[-]</label><label class="expand" for="c-41968961">[2 more]</label></div><br/><div class="children"><div class="content">But they only allow you to look at it at certain points in time (unless requested more precisely ahead-of-time), and&#x2F;or lose the ability to do a bunch of meaningful optimizations. Whereas compiled programs can be desired to be paused and made sense of at any assembly instruction, and there&#x27;ll always be some people wanting to trade perfect debuggability for perf.</div><br/><div id="41969004" class="c"><input type="checkbox" id="c-41969004" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41966561">root</a><span>|</span><a href="#41968961">parent</a><span>|</span><a href="#41966902">next</a><span>|</span><label class="collapse" for="c-41969004">[-]</label><label class="expand" for="c-41969004">[1 more]</label></div><br/><div class="children"><div class="content">Not really. If you look at HotSpot for example it will deoptimize a function for you all the way if you debug it and then reoptimize it when you stop single-stepping.</div><br/></div></div></div></div></div></div><div id="41966902" class="c"><input type="checkbox" id="c-41966902" checked=""/><div class="controls bullet"><span class="by">typesanitizer</span><span>|</span><a href="#41966561">parent</a><span>|</span><a href="#41968881">prev</a><span>|</span><a href="#41968626">next</a><span>|</span><label class="collapse" for="c-41966902">[-]</label><label class="expand" for="c-41966902">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the feedback.<p>The preceding paragraph had &quot;and occasionally language features&quot; so I thought it would be understood that I didn&#x27;t mean it as an optimizer-specific thing, but on re-reading the post, I totally see how the other wording &quot;The knobs to steer the optimizer are limited. Usually, these [...]&quot; implies the wrong thing.<p>I&#x27;ve changed the wording to be clearer and put the D example into a different bucket.<p>&gt; In some cases, languages have features which enforce performance-related properties at the semantic checking layer, hence, granting more control that integrates with semantic checks instead of relying on the optimizer:
&gt;
&gt; - D has first-class support for marking functions as “no GC”.</div><br/><div id="41967062" class="c"><input type="checkbox" id="c-41967062" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#41966561">root</a><span>|</span><a href="#41966902">parent</a><span>|</span><a href="#41968626">next</a><span>|</span><label class="collapse" for="c-41967062">[-]</label><label class="expand" for="c-41967062">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s better, thanks!</div><br/></div></div></div></div></div></div><div id="41968626" class="c"><input type="checkbox" id="c-41968626" checked=""/><div class="controls bullet"><span class="by">Mikhail_Edoshin</span><span>|</span><a href="#41966561">prev</a><span>|</span><a href="#41968798">next</a><span>|</span><label class="collapse" for="c-41968626">[-]</label><label class="expand" for="c-41968626">[1 more]</label></div><br/><div class="children"><div class="content">One of reasons SQL is declarative is that queries run concurrently yet give the illusion of working in isolation. And unlike the concurrency of independent processes, which is mostly mechanical, this one involves detailed coordination because database queries work on the same data. With these constraints it may be not that easy to come up with an imperative model that is as simple as the current declarative one.</div><br/></div></div><div id="41968798" class="c"><input type="checkbox" id="c-41968798" checked=""/><div class="controls bullet"><span class="by">yxhuvud</span><span>|</span><a href="#41968626">prev</a><span>|</span><a href="#41966517">next</a><span>|</span><label class="collapse" for="c-41968798">[-]</label><label class="expand" for="c-41968798">[1 more]</label></div><br/><div class="children"><div class="content">No. Language designers need to think about what their language promises and when some users have differing needs, they may need to fulfill those needs.</div><br/></div></div><div id="41966517" class="c"><input type="checkbox" id="c-41966517" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#41968798">prev</a><span>|</span><a href="#41966183">next</a><span>|</span><label class="collapse" for="c-41966517">[-]</label><label class="expand" for="c-41966517">[3 more]</label></div><br/><div class="children"><div class="content">If you have any language where it is &quot;semantially correct&quot; to execute it with a simple interpetter, than all optimizations in that language are not semantically important by definition, right? I&#x27;ve even seen interpretters for C... so while I 100% have felt the pain in this article, I don&#x27;t know where that leaves us? These are more like compilation assertions&#x2F;strategies than language features. (Not that these shouldn&#x27;t be written inline with the code, e.g. it can be nice to write unit tests in the same files as the code in some languages).<p>In the case of SQL, I&#x27;d love access to a flavor where I do the joins on indices explicitly, the query is executed as written, and each join (or filter) can be annoted with a strategy (btree lookup, etc). (The most difficult part about using indices by hand is correctly writing all the synchronous triggers on updates, not the queries, IMO).</div><br/><div id="41967023" class="c"><input type="checkbox" id="c-41967023" checked=""/><div class="controls bullet"><span class="by">typesanitizer</span><span>|</span><a href="#41966517">parent</a><span>|</span><a href="#41968140">next</a><span>|</span><label class="collapse" for="c-41967023">[-]</label><label class="expand" for="c-41967023">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you have any language where it is &quot;semantially correct&quot; to execute it with a simple interpetter, than all optimizations in that language are not semantically important by definition, right?<p>Technically, yes. :)<p>But I think this should perhaps be treated as a bug in how we define&#x2F;design languages, rather than as an immutable truth.<p>- We already have time-based versioning for languages.
- We also have &quot;tiers&quot; of support for different platforms in language implementations (e.g. rarer architectures might have Tier 2 or Tier 3 support where the debugging tooling might not quite work)<p>One idea would be to introduce &quot;tiers&quot; into a language&#x27;s definition. A smaller implementation could implement the language at Tier 1 (perhaps this would even be within reach for a university course project). An industrial-strength implementation could implement the language at Tier 3.<p>(Yes, this would also introduce more complications, such as making sure that the dynamic semantics at different tiers are equivalent. At that point, it becomes a matter of tradeoffs -- does introducing tiers help reduce complexity overall?)</div><br/></div></div><div id="41968140" class="c"><input type="checkbox" id="c-41968140" checked=""/><div class="controls bullet"><span class="by">Archit3ch</span><span>|</span><a href="#41966517">parent</a><span>|</span><a href="#41967023">prev</a><span>|</span><a href="#41966183">next</a><span>|</span><label class="collapse" for="c-41968140">[-]</label><label class="expand" for="c-41968140">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you have any language where it is &quot;semantially correct&quot; to execute it with a simple interpetter, than all optimizations in that language are not semantically important by definition, right?<p>Not when &quot;correct&quot; needs optimizations to meet real-time guarantees. It&#x27;s hard to argue that a program which doesn&#x27;t run is &quot;correct&quot;.</div><br/></div></div></div></div><div id="41966183" class="c"><input type="checkbox" id="c-41966183" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41966517">prev</a><span>|</span><a href="#41966290">next</a><span>|</span><label class="collapse" for="c-41966183">[-]</label><label class="expand" for="c-41966183">[6 more]</label></div><br/><div class="children"><div class="content">&gt; The optimizer’s behavior is in some contexts load-bearing and has little margin for error (e.g. missing an optimization).<p>Well, sure, sometimes, to an extent. But if it&#x27;s load-bearing, maybe that&#x27;s a bug? You might have written non-portable code that won&#x27;t last, because it depends on an implementation detail that isn&#x27;t standardized.<p>There are widespread applications where performance isn&#x27;t critical. For example, any time you do a network request. Web pages shouldn&#x27;t break because the network is slow today, if you can possibly avoid it.<p>The web provides no performance guarantees, but it tries pretty hard to provide <i>compatibility</i> guarantees. Your code should, usually, work on new browser versions and on devices that haven&#x27;t been released yet. New browsers will have different JIT compilers with different performance cliffs. And yet, there are websites written many years ago that still work.<p>When standardizing things, we need to be precise about what&#x27;s standardized and what isn&#x27;t, or protocols &quot;rust shut&quot; and can&#x27;t be changed without breaking lots of stuff. <i>Not</i> standardizing performance is often a win. (With some exceptions like video game consoles where the hardware is standardized.)<p>Hyrum&#x27;s law suggests that all compiler optimizations will eventually be load-bearing for someone, but we should usually try to avoid it. To make sure that the code is robust, perhaps performance should vary. Maybe it would be useful to have something like a chaos monkey for programs, where optimizations vary based on a random seed?</div><br/><div id="41966519" class="c"><input type="checkbox" id="c-41966519" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41966183">parent</a><span>|</span><a href="#41966290">next</a><span>|</span><label class="collapse" for="c-41966519">[-]</label><label class="expand" for="c-41966519">[5 more]</label></div><br/><div class="children"><div class="content">&gt; But if it&#x27;s load-bearing, maybe that&#x27;s a bug?<p>If your &quot;debug optimization&quot; code is so slow as to be unusable (see: Rust), then your optimizations qualify as load-bearing.<p>The problem is that &quot;optimization level&quot; needs a mindset change.  The optimization levels should be &quot;release&quot;, &quot;small&quot; and &quot;experimental&quot;.<p>&quot;Release level&quot; needs to be perfectly usable for debugging as well as in production--&quot;debug level&quot; should be &quot;release level&quot;.  Compilation time should be reasonable and run time should be functional.<p>After that, for embedded, you should have &quot;small level&quot;--checks should get turned off and any optimizations that make code significantly bigger should get turned off (loop unrolling, for example).  You might enable some optimizations that make compile time brutally slow.<p>Finally, there should be an &quot;experimental level&quot; which tests out optimizations before they go into release.<p>And there should be <i>no &quot;fast&quot; optimization level</i>.  If your optimization is that situation specific, it should stay stuck in &quot;experimental&quot;.<p>And through all of this, the compiler should <i>also</i> eject files that carry enough information to allow debuggers to make sense of the compiled code, unwind the optimizations when the users asks, and present a coherent version of what is going on.  This is actually where compilers really break down nowadays.  The compiler needs to eject enough information and context that a debugger can unwind what is going on rather than being an afterthought.<p>We need the equivalent of an LSP (Language Server Protocol) for debuggers.</div><br/><div id="41966810" class="c"><input type="checkbox" id="c-41966810" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41966183">root</a><span>|</span><a href="#41966519">parent</a><span>|</span><a href="#41966685">next</a><span>|</span><label class="collapse" for="c-41966810">[-]</label><label class="expand" for="c-41966810">[1 more]</label></div><br/><div class="children"><div class="content">DWARF does contain turing-complete VM for doing unwinding, so theoretically it should already be possible to make a compiler that gives precise debug info everywhere, no new protocol necessary.<p>But completely-reversible-anywhere optimizations are rather limiting, disallowing a bunch of things; including, but not limited to, dead code elimination (more generally, forgetting some fraction of state from somewhere), identical code merging, and instruction reordering (esp. vectorization, which essentially reorders across multiple loop iterations), severely limiting what your optimizer can even do.</div><br/></div></div><div id="41966685" class="c"><input type="checkbox" id="c-41966685" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#41966183">root</a><span>|</span><a href="#41966519">parent</a><span>|</span><a href="#41966810">prev</a><span>|</span><a href="#41966874">next</a><span>|</span><label class="collapse" for="c-41966685">[-]</label><label class="expand" for="c-41966685">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And through all of this, the compiler should also eject files that carry enough information to allow debuggers to make sense of the compiled code, unwind the optimizations when the users asks, and present a coherent version of what is going on.<p>You can&#x27;t do this because some optimizations can&#x27;t be seen through; most obvious one is identical code merging. If you&#x27;re in a merged function then you don&#x27;t know which of the original source lines you&#x27;re looking at.<p>I&#x27;d like to see a system which only had optimized compilation and used an interpreter for debugging.</div><br/></div></div><div id="41966874" class="c"><input type="checkbox" id="c-41966874" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41966183">root</a><span>|</span><a href="#41966519">parent</a><span>|</span><a href="#41966685">prev</a><span>|</span><a href="#41966669">next</a><span>|</span><label class="collapse" for="c-41966874">[-]</label><label class="expand" for="c-41966874">[1 more]</label></div><br/><div class="children"><div class="content">How would this model handle code that <i>needs</i> to be as fast as possible, at the cost of debugging? E.g. all hot-loop code, all high performance numerical code, all latency sensitive and instruction sensitive code?<p>&gt; If your optimization is that situation specific, it should stay stuck in &quot;experimental&quot;.<p>Yeah, I have a feeling that there’s low-key <i>lots</i> of applications for whom many compiler optimisations that you’re branding “experimental” are in fact run-of-the-mill and would just enable “experimental” mode so frequently it’d just be synonymous with “actually release mode”.<p>&gt; And through all of this, the compiler should also eject files that carry enough information to allow debuggers to make sense of the compiled code, unwind the optimizations when the users asks, and present a coherent version of what is going on.<p>This is a pretty cool idea, semi-related, you should check out some of the work around E-Graphs, which attempt to enable the same level of optimisations but also preserve more original context.
It’d be neat to have the equivalent of source-maps for highly optimised code, but I’m not sure how we’d manage them without them becoming <i>enormous</i>. After things like inlining, constant-folding, desugaring, rearrangement operations, etc all take place I suspect you’d be left with code that bears only the merest passing resemblance to its original form.</div><br/></div></div><div id="41966669" class="c"><input type="checkbox" id="c-41966669" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#41966183">root</a><span>|</span><a href="#41966519">parent</a><span>|</span><a href="#41966874">prev</a><span>|</span><a href="#41966290">next</a><span>|</span><label class="collapse" for="c-41966669">[-]</label><label class="expand" for="c-41966669">[1 more]</label></div><br/><div class="children"><div class="content">For the web, there are debuggers, but no apparent &quot;debug mode.&quot;</div><br/></div></div></div></div></div></div><div id="41966290" class="c"><input type="checkbox" id="c-41966290" checked=""/><div class="controls bullet"><span class="by">f33d5173</span><span>|</span><a href="#41966183">prev</a><span>|</span><a href="#41966456">next</a><span>|</span><label class="collapse" for="c-41966290">[-]</label><label class="expand" for="c-41966290">[2 more]</label></div><br/><div class="children"><div class="content">the optimizer should be a magic black box. As soon as you start demanding a particular optimization, it shouldn&#x27;t be an optimization anymore. In C you have inline assembly and intrinsics and pragmas and macros and so on. If you want the compiler to compile your code a particular way you should be using these, not trying to wrangle the optimizer to invoke a particular optimization.</div><br/><div id="41966370" class="c"><input type="checkbox" id="c-41966370" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41966290">parent</a><span>|</span><a href="#41966456">next</a><span>|</span><label class="collapse" for="c-41966370">[-]</label><label class="expand" for="c-41966370">[1 more]</label></div><br/><div class="children"><div class="content">Except even intrinsics aren&#x27;t even that much of a guarantee - clang converts them to its internal operations and applies the same optimization passes over them as it does on its own autovectorized code; and there are no intrinsics for x86&#x27;s inline memory operands, so issues can arise around those (or the inverse - I&#x27;ve seen clang do a memory load of the same constant twice (the second one being behind some branches), despite there being only one such load).<p>And there also are no intrinsics for most scalar operations, e.g. if you wanted to force &quot;x&gt;&gt;48 == 0x1234&quot; to be actually done via the shift and not &quot;x &amp; 0xffff000000000000 == 0x1234000000000000&quot; (or vice versa).<p>And of course assembly means writing platform-specific code (potentially undesirable even if you want to only do the optimization for a single architecture, as it means having to learn to write assembly of said architecture).<p>There is some potential middle-ground of doing black-boxing, but as-is in C&#x2F;C++ the way to do this is with a no-op asm block, but that can make register allocation worse, and still requires some platform-specific logic for deriving the register kind from value type.</div><br/></div></div></div></div><div id="41966456" class="c"><input type="checkbox" id="c-41966456" checked=""/><div class="controls bullet"><span class="by">mcfig</span><span>|</span><a href="#41966290">prev</a><span>|</span><a href="#41966576">next</a><span>|</span><label class="collapse" for="c-41966456">[-]</label><label class="expand" for="c-41966456">[1 more]</label></div><br/><div class="children"><div class="content">Great article. One real case I encountered that I find thought provoking, is where a bunch of test failures were bucketed into the same bucket because link-time code-generation had noticed that a bunch of C++ getter functions had the same output code and combined them all. So stack traces became confusing because the address-to-symbol mapping was more complicated than the logic we had in place was prepared for.<p>i.e. optimization had violated a rule we were implicitly relying on (that each non-inlined function should start at a distinct address, so that address-to-symbol mapping could be done easily). But that’s not an explicit guarantee and optimizers don’t seem to think about it much. (Well for inlining it seems to have had some thought, still sucks, but anyway this case doesn’t fit the pattern of inlining).<p>I find it hard to say anyone is dead wrong in this case… but I would turn off that LTCG optimization any time I could, except where proven necessary.</div><br/></div></div><div id="41966576" class="c"><input type="checkbox" id="c-41966576" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41966456">prev</a><span>|</span><a href="#41966579">next</a><span>|</span><label class="collapse" for="c-41966576">[-]</label><label class="expand" for="c-41966576">[1 more]</label></div><br/><div class="children"><div class="content">Optimizations in compilers like LLVM are done by many individual code transformation passes, one applied to the result of the previous.<p>This layering makes the order of the passes important and very sensitive. The passes usually don&#x27;t have a grand plan, they just keep shuffling code around in different ways. A pass may only be applicable to code in a specific form created by a previous simplification pass. One pass may undo optimizations of a previous pass, or optimize-out a detail required by a later pass.<p>Separation into passes makes it easier to reason about correctness of each transformation in isolation, but the combined result is kinda slow and complicated.</div><br/></div></div><div id="41966579" class="c"><input type="checkbox" id="c-41966579" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#41966576">prev</a><span>|</span><a href="#41966149">next</a><span>|</span><label class="collapse" for="c-41966579">[-]</label><label class="expand" for="c-41966579">[1 more]</label></div><br/><div class="children"><div class="content">We are nearing the death of Proebsting&#x27;s Law. AMD CEO Lisa Su&#x27;s HotChips’19 keynote said that compilers had accounted for 8% performance increase over the decade. That means compilers are now only doubling performance every 90 years.<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nuVBid9e3RA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nuVBid9e3RA</a></div><br/></div></div><div id="41966149" class="c"><input type="checkbox" id="c-41966149" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41966579">prev</a><span>|</span><a href="#41965802">next</a><span>|</span><label class="collapse" for="c-41966149">[-]</label><label class="expand" for="c-41966149">[5 more]</label></div><br/><div class="children"><div class="content">Arguing against query planning by pointing at a quote about databases is wild. Automatic query planning is ubiquitous and hugely succesfull in databases.</div><br/><div id="41966911" class="c"><input type="checkbox" id="c-41966911" checked=""/><div class="controls bullet"><span class="by">typesanitizer</span><span>|</span><a href="#41966149">parent</a><span>|</span><a href="#41966385">next</a><span>|</span><label class="collapse" for="c-41966911">[-]</label><label class="expand" for="c-41966911">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve added a clarification in the post to make my position explicit:<p>&gt; This is not to imply that we should get rid of SQL or get rid of query planning entirely. Rather, more explicit planning would be an additional tool in database user’s toolbelt.<p>I&#x27;m not sure if there was some specific part of the blog post that made you think I&#x27;m against automatic query planning altogether; if there was, please share that so that I can tweak the wording to remove that implication.</div><br/><div id="41967034" class="c"><input type="checkbox" id="c-41967034" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41966149">root</a><span>|</span><a href="#41966911">parent</a><span>|</span><a href="#41966385">next</a><span>|</span><label class="collapse" for="c-41967034">[-]</label><label class="expand" for="c-41967034">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure if there was some specific part of the blog post that made you think I&#x27;m against automatic query planning altogether; if there was, please share that so that I can tweak the wording to remove that implication.<p>The quote from another article (which I didn&#x27;t read) starting with &quot;I dislike query planners&quot;.<p>&quot;Against ... altogether&quot; is mildly stronger than I took away from this, more like &quot;generally of the opinion that the tradeoff nearly everyone is making with sql isn&#x27;t worth it&quot;.<p>Judging by the lack of upvotes other people didn&#x27;t react as strongly to this quote as I did, so take it as you will.</div><br/></div></div></div></div><div id="41966385" class="c"><input type="checkbox" id="c-41966385" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41966149">parent</a><span>|</span><a href="#41966911">prev</a><span>|</span><a href="#41965802">next</a><span>|</span><label class="collapse" for="c-41966385">[-]</label><label class="expand" for="c-41966385">[2 more]</label></div><br/><div class="children"><div class="content">And sometimes highly problematic.<p>I&#x27;m surprised that the &quot;query planner&quot; doesn&#x27;t have a way to eject an opaque object that is the &quot;assembly language of the query&quot; that you can run that it is not allowed to change.</div><br/><div id="41967055" class="c"><input type="checkbox" id="c-41967055" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#41966149">root</a><span>|</span><a href="#41966385">parent</a><span>|</span><a href="#41965802">next</a><span>|</span><label class="collapse" for="c-41967055">[-]</label><label class="expand" for="c-41967055">[1 more]</label></div><br/><div class="children"><div class="content">Sure. It&#x27;s definitely a tradeoff which definitely hurts on rare occasion. I agree that the lack of fallback in most databases is a bit strange. Altogether though the productivity benefits have proven larger than the drawbacks of not defaulting to a query planner.</div><br/></div></div></div></div></div></div><div id="41965802" class="c"><input type="checkbox" id="c-41965802" checked=""/><div class="controls bullet"><span class="by">sebmellen</span><span>|</span><a href="#41966149">prev</a><span>|</span><a href="#41966097">next</a><span>|</span><label class="collapse" for="c-41965802">[-]</label><label class="expand" for="c-41965802">[1 more]</label></div><br/><div class="children"><div class="content">I like that the author included their intended audience up front. Definitely not me, but it helped me read the article with a different perspective.</div><br/></div></div><div id="41966097" class="c"><input type="checkbox" id="c-41966097" checked=""/><div class="controls bullet"><span class="by">jonstewart</span><span>|</span><a href="#41965802">prev</a><span>|</span><a href="#41966318">next</a><span>|</span><label class="collapse" for="c-41966097">[-]</label><label class="expand" for="c-41966097">[3 more]</label></div><br/><div class="children"><div class="content">At least databases have Explain. I&#x27;d love to get feedback from clang or gcc about why particular optimizations were not applied.</div><br/><div id="41966918" class="c"><input type="checkbox" id="c-41966918" checked=""/><div class="controls bullet"><span class="by">typesanitizer</span><span>|</span><a href="#41966097">parent</a><span>|</span><a href="#41966234">next</a><span>|</span><label class="collapse" for="c-41966918">[-]</label><label class="expand" for="c-41966918">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing you&#x27;ve tried these flags mentioned in the blog post but haven&#x27;t had luck with them?<p>&gt; LLVM supports an interesting feature called Optimization Remarks – these remarks track whether an optimization was performed or missed. Clang support recording remarks using -fsave-optimization-record and Rustc supports -Zremark-dir=&lt;blah&gt;. There are also some tools (opt-viewer.py, optview2) to help view and understand the output.</div><br/></div></div><div id="41966234" class="c"><input type="checkbox" id="c-41966234" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#41966097">parent</a><span>|</span><a href="#41966918">prev</a><span>|</span><a href="#41966318">next</a><span>|</span><label class="collapse" for="c-41966234">[-]</label><label class="expand" for="c-41966234">[1 more]</label></div><br/><div class="children"><div class="content">Explain doesn&#x27;t give you that information in many (most?) DBMSes. It&#x27;s a bit like seeing the compiler IR code of your program. It lets you understand some things, while others remain a mystery.</div><br/></div></div></div></div><div id="41966318" class="c"><input type="checkbox" id="c-41966318" checked=""/><div class="controls bullet"><span class="by">QuadmasterXLII</span><span>|</span><a href="#41966097">prev</a><span>|</span><a href="#41966412">next</a><span>|</span><label class="collapse" for="c-41966318">[-]</label><label class="expand" for="c-41966318">[4 more]</label></div><br/><div class="children"><div class="content">Frankly, the problem is that (generally, across languages various compiler hints) @inline sometimes fails to inline. At this point I’ve given up on ever having an @inline that reliably inlines, and I would very happily settle for an @assert_inline that doesn’t change the generated assembly at all but reliably crashes out if the function isn’t inline.<p>Julia is by far the worst language about this. It would be vastly more usable with the addition of @assert_type_stable, @assert_doesn’t_allocate, and @assert_doesn’t_error macros.</div><br/><div id="41966496" class="c"><input type="checkbox" id="c-41966496" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#41966318">parent</a><span>|</span><a href="#41966464">next</a><span>|</span><label class="collapse" for="c-41966496">[-]</label><label class="expand" for="c-41966496">[2 more]</label></div><br/><div class="children"><div class="content">On the Julia front, I believe the evolving effect system may help a little bit with obtaining&#x2F;surfacing that information. JET.jl should be able to solve the type stability (inference) one from a whole-of-program perspective. We have `@inferred` for unit tests. The macros would be a cool addition - I wonder if they would get overused though?<p>I agree that Julia takes the idea of optimization to the extreme - it&#x27;s semantically a very dynamic language and only fast due to non-semantically guaranteed optimization. On the other hand, getting access to the generated IR, LLVM and assembly and iteratively improving it is far easier than any other language I&#x27;ve seen.</div><br/><div id="41968907" class="c"><input type="checkbox" id="c-41968907" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41966318">root</a><span>|</span><a href="#41966496">parent</a><span>|</span><a href="#41966464">next</a><span>|</span><label class="collapse" for="c-41968907">[-]</label><label class="expand" for="c-41968907">[1 more]</label></div><br/><div class="children"><div class="content">What Julia offers is quite common in Common Lisp systems.</div><br/></div></div></div></div><div id="41966464" class="c"><input type="checkbox" id="c-41966464" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#41966318">parent</a><span>|</span><a href="#41966496">prev</a><span>|</span><a href="#41966412">next</a><span>|</span><label class="collapse" for="c-41966464">[-]</label><label class="expand" for="c-41966464">[1 more]</label></div><br/><div class="children"><div class="content">With gcc &amp; clang you can use __attribute__((always_inline)) to force-inline, even at -O0, giving an error if it&#x27;s impossible.</div><br/></div></div></div></div><div id="41966412" class="c"><input type="checkbox" id="c-41966412" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#41966318">prev</a><span>|</span><a href="#41922417">next</a><span>|</span><label class="collapse" for="c-41966412">[-]</label><label class="expand" for="c-41966412">[1 more]</label></div><br/><div class="children"><div class="content">From the article:<p>&gt; Have a good mental model of what the optimizer can and cannot do.<p>Most DB query planner designers and implementers have little imagination, and their mental model of what optimizers can and cannot do is, well, extremely narrow-minded. There is huge unexplored space of what query planning can be (at least for analytic queries, and we think in columnar terms) - if we just stop insisting on thinking of DBMS operations as black boxes.</div><br/></div></div></div></div></div></div></div></body></html>