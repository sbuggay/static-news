<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732266086309" as="style"/><link rel="stylesheet" href="styles.css?v=1732266086309"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://abenezer.org/blog/hyrum-law-in-golang">Hyrum&#x27;s Law in Golang</a> <span class="domain">(<a href="https://abenezer.org">abenezer.org</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>157 comments</span></div><br/><div><div id="42203962" class="c"><input type="checkbox" id="c-42203962" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42202326">next</a><span>|</span><label class="collapse" for="c-42203962">[-]</label><label class="expand" for="c-42203962">[24 more]</label></div><br/><div class="children"><div class="content">Hyrum&#x27;s Law is one of those observations that&#x27;s certainly useful, but be careful not to fixate on it and draw the wrong conclusions. Consider that even the total runtime of a function is an observable property, which means that optimizing a function to make it faster is a breaking change (what if suddenly one of your queues clears too fast and triggers a deadlock??), despite the fact that 99.99999999% of your users would probably appreciate having code that runs faster for no effort on their part.<p>Therefore it&#x27;s unavoidable that what constitutes a &quot;breaking change&quot; is a social contract, not a technical contract, because the alternative is that literally nothing is ever allowed to change. So as a library author, document what parts of your API are guaranteed not to change, be reasonable, and have empathy for your users. And as a library consumer, understand that making undocumented interfaces into load-bearing constructs is done at your own risk, and have empathy for the library authors.</div><br/><div id="42205110" class="c"><input type="checkbox" id="c-42205110" checked=""/><div class="controls bullet"><span class="by">materielle</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42206661">next</a><span>|</span><label class="collapse" for="c-42205110">[-]</label><label class="expand" for="c-42205110">[3 more]</label></div><br/><div class="children"><div class="content">I think everything you said is totally correct for open source library owners.<p>But let me offer a different perspective: Hyrum’s law is neither a technical contract nor a social contract. It’s an emergent technical property in a sufficiently used system.<p>How you respond to that emergent property depends on the social context.<p>If you are a FOSS maintainer, and an optimization speeds up 99.99% of users and requires 0.01% to either fix their code or upgrade to a new API, you ship it.<p>If you are working at a big tech company, you need <i>both</i> the optimization and breaking 0% of the company. So you will work across teams to find the sweet spot.<p>If you are an enterprise software company, and you change breaks 0.1% if users, but that user is one of the top 5 contracts, you don’t ship.</div><br/><div id="42206806" class="c"><input type="checkbox" id="c-42206806" checked=""/><div class="controls bullet"><span class="by">kmacdough</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42205110">parent</a><span>|</span><a href="#42205395">next</a><span>|</span><label class="collapse" for="c-42206806">[-]</label><label class="expand" for="c-42206806">[1 more]</label></div><br/><div class="children"><div class="content">Seems like you&#x27;re saying the same thing, just using &quot;social contract&quot; differently. I think they use social contract not to mean binding, but to highlight the fact that Hyrums Law must be taken in the social context of the project. In the case of large SW company, the social contract would be to not break services, even when folks are misusing an API. And for a popular open source project, it would mean not breaking a widely used behavior, even if it isn&#x27;t specified or officially supported. Determining the social contract seems to be precisely what you describe as &quot;not a social contract&quot;.</div><br/></div></div><div id="42205395" class="c"><input type="checkbox" id="c-42205395" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42205110">parent</a><span>|</span><a href="#42206806">prev</a><span>|</span><a href="#42206661">next</a><span>|</span><label class="collapse" for="c-42205395">[-]</label><label class="expand" for="c-42205395">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s an emergent ... property in a sufficiently used system<p>This is also a sufficient description of &quot;social contract&quot; for this context.</div><br/></div></div></div></div><div id="42206661" class="c"><input type="checkbox" id="c-42206661" checked=""/><div class="controls bullet"><span class="by">SatvikBeri</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42205110">prev</a><span>|</span><a href="#42205152">next</a><span>|</span><label class="collapse" for="c-42206661">[-]</label><label class="expand" for="c-42206661">[1 more]</label></div><br/><div class="children"><div class="content">I once sped up a very suboptimal routine that from ~100s to ~.1s (it was doing database lookups in a for loop), and that broke the reporting system because the original author had made several asynchronous function calls and assumed they would have all finished running by the time the (formerly) slow routine was done. Figuring out exactly what happened took forever.</div><br/></div></div><div id="42205152" class="c"><input type="checkbox" id="c-42205152" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42206661">prev</a><span>|</span><a href="#42204203">next</a><span>|</span><label class="collapse" for="c-42205152">[-]</label><label class="expand" for="c-42205152">[5 more]</label></div><br/><div class="children"><div class="content">That used to be a problem in the 1980s. Thus PCs came with a turbo button to slow them down, and 8 bit computers went the entire decade without upgrading their speed even though faster CPUs were available.  These days nearly everything runs on more than one CPU and so nobody relies on function runtime (other than is if fast enough).  Even in embedded they have been burned by their one CPU going out of production and so try to avoid that dependency because it cannot be relied on anymore.</div><br/><div id="42211902" class="c"><input type="checkbox" id="c-42211902" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42205152">parent</a><span>|</span><a href="#42210679">next</a><span>|</span><label class="collapse" for="c-42211902">[-]</label><label class="expand" for="c-42211902">[1 more]</label></div><br/><div class="children"><div class="content">&gt; nobody relies on function runtime<p>Maybe not intentionally.<p>But there have been several times where I&#x27;ve seen bugs where two tasks are done concurrently, but task A always takes longer than task B, then someone makes A faster, and that exposes some race condition or deadlock that only occurs if A completes before B.</div><br/></div></div><div id="42210679" class="c"><input type="checkbox" id="c-42210679" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42205152">parent</a><span>|</span><a href="#42211902">prev</a><span>|</span><a href="#42207038">next</a><span>|</span><label class="collapse" for="c-42210679">[-]</label><label class="expand" for="c-42210679">[1 more]</label></div><br/><div class="children"><div class="content">In the 8 bit computer era, we knew exactly how much time any given instruction took. Retrieving some precision clock (not available!) and computing the time delta between runs - as is trivially done today - would probably be more computing power than they had at the time. Every cycle counted. Not very surprising that it wasn&#x27;t done at that era. Also, there wasn&#x27;t a &quot;winning&quot; instruction set or compilers able to target different architectures, so there was far more at stake than just clock speeds. If they changed the processor, you lost all your software.<p>DOS didn&#x27;t have any precision clocks either as far as I know (it seems that there&#x27;s interrupt 1A but it only updates 18 times a second, which is an eternity). Apparently there&#x27;s 8254 based timer code after a few PC generations.<p>Windows 95 came up with QueryPerformanceCounter() and that simplified life quite a bit.</div><br/></div></div><div id="42207038" class="c"><input type="checkbox" id="c-42207038" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42205152">parent</a><span>|</span><a href="#42210679">prev</a><span>|</span><a href="#42204203">next</a><span>|</span><label class="collapse" for="c-42207038">[-]</label><label class="expand" for="c-42207038">[2 more]</label></div><br/><div class="children"><div class="content">I found a used copy of Warcraft III and found it was unplayable because the scrolling algorithm ran as fast as possible with no minimum time. Any map bigger than 2x2 screens you could not scroll to the middle.</div><br/><div id="42210201" class="c"><input type="checkbox" id="c-42210201" checked=""/><div class="controls bullet"><span class="by">marcus_holmes</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42207038">parent</a><span>|</span><a href="#42204203">next</a><span>|</span><label class="collapse" for="c-42210201">[-]</label><label class="expand" for="c-42210201">[1 more]</label></div><br/><div class="children"><div class="content">I used to enjoy Wing Commander back in the 90&#x27;s. Then I upgraded my PC and it became unplayably fast - 1 second after I took off the &quot;you died&quot; screen appeared.</div><br/></div></div></div></div></div></div><div id="42204203" class="c"><input type="checkbox" id="c-42204203" checked=""/><div class="controls bullet"><span class="by">rjst01</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42205152">prev</a><span>|</span><a href="#42206063">next</a><span>|</span><label class="collapse" for="c-42204203">[-]</label><label class="expand" for="c-42204203">[5 more]</label></div><br/><div class="children"><div class="content">One day I will give a lighting talk about the load bearing teapot, or how and why I made HTTP Status 418 a load bearing part of an internal API, and why it was the least bad option considering the constraints.</div><br/><div id="42206013" class="c"><input type="checkbox" id="c-42206013" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42204203">parent</a><span>|</span><a href="#42206063">next</a><span>|</span><label class="collapse" for="c-42206013">[-]</label><label class="expand" for="c-42206013">[4 more]</label></div><br/><div class="children"><div class="content">It’s a classic. Binance will give you 429 errors to back off then 418s to tell you you will be IP banned and then they’ll ban you.</div><br/><div id="42207064" class="c"><input type="checkbox" id="c-42207064" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42206013">parent</a><span>|</span><a href="#42206063">next</a><span>|</span><label class="collapse" for="c-42207064">[-]</label><label class="expand" for="c-42207064">[3 more]</label></div><br/><div class="children"><div class="content">Google’s spiders will punish you for giving them too many 429 responses. It’s hell for hosting sites with vanity urls. They can’t tell they’re sending you 50+ req&#x2F;s.<p>It’s practically a protection racket. Only AWS gets the money.</div><br/><div id="42207600" class="c"><input type="checkbox" id="c-42207600" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42207064">parent</a><span>|</span><a href="#42206063">next</a><span>|</span><label class="collapse" for="c-42207600">[-]</label><label class="expand" for="c-42207600">[2 more]</label></div><br/><div class="children"><div class="content">50 requests&#x2F;sec? Did you forget a few zeros?</div><br/><div id="42207799" class="c"><input type="checkbox" id="c-42207799" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42207600">parent</a><span>|</span><a href="#42206063">next</a><span>|</span><label class="collapse" for="c-42207799">[-]</label><label class="expand" for="c-42207799">[1 more]</label></div><br/><div class="children"><div class="content">Little’s law is a bitch, and you can get away with a little throttling but not much.<p>Also, that’s a bit dismissive for HN.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42206063" class="c"><input type="checkbox" id="c-42206063" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42204203">prev</a><span>|</span><a href="#42207782">next</a><span>|</span><label class="collapse" for="c-42206063">[-]</label><label class="expand" for="c-42206063">[5 more]</label></div><br/><div class="children"><div class="content">I feel like this is approaching absurdity, if only because something like the total runtime of a function is not under the control of the author of the function. The operating environment will have an impact on that, for example, as will the load the system is currently experiencing. A GC pass can affect it.<p>In short, I wouldn&#x27;t consider emergent behaviours of a machine as part of an intentional interface or any kind of contract and therefore I wouldn&#x27;t see it as a breaking change, the same as fixing a subtle bug in a function wouldn&#x27;t be seen as a breaking change even if someone depended on the unintentional behaviour.<p>I think it&#x27;s more of a testament to Go&#x27;s hardcore commitment to backwards compatibility, in this case, than anything else.</div><br/><div id="42206407" class="c"><input type="checkbox" id="c-42206407" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42206063">parent</a><span>|</span><a href="#42206363">next</a><span>|</span><label class="collapse" for="c-42206407">[-]</label><label class="expand" for="c-42206407">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s quite common in cryptography for the runtime to be important. For example, password verification time shouldn&#x27;t depend on the value of the key or the password. Systems have been broken because someone wrote a string compare that returned early.</div><br/><div id="42207537" class="c"><input type="checkbox" id="c-42207537" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42206407">parent</a><span>|</span><a href="#42206363">next</a><span>|</span><label class="collapse" for="c-42207537">[-]</label><label class="expand" for="c-42207537">[1 more]</label></div><br/><div class="children"><div class="content">And, since most languages short circuit on basic string comparisons, you&#x27;d have some form of `secure_compare` function that compares two strings in constant time, and that behaviour is contracted in the name of the function.<p>Nobody is rewriting `==` to compare strings in constant time, not because it breaks some kind of API contract, but because it would result in a massive waste of CPU time. The point is, though, that they could. But then they are deciding to sacrifice performance for this one problem.<p>Crypto is obviously a case of it own when it comes to optimisations and as much as I called out the parent for approaching the absurd, we can pull out many similar special cases of our own.</div><br/></div></div></div></div><div id="42206363" class="c"><input type="checkbox" id="c-42206363" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42206063">parent</a><span>|</span><a href="#42206407">prev</a><span>|</span><a href="#42207782">next</a><span>|</span><label class="collapse" for="c-42206363">[-]</label><label class="expand" for="c-42206363">[2 more]</label></div><br/><div class="children"><div class="content">Yes, it’s an absurd example to make a point. We don’t normally consider performance in scope for what’s considered a breaking API change and there are good reasons for that, including being non-portable. Performance guarantees are what hard real-time systems do and they’re hardware-specific. (There is also the “gas fee” system that Ethereum has, to make a performance limit consistent across architectures.)<p>But there are still informal limits. If the performance impact is bad enough, (say, 5x slower, or changing a linear algorithm to quadratic), it’s probably going to be reverted anyway. We just don‘t have any practical way of formalizing rough performance guarantees at an API boundary.</div><br/><div id="42206959" class="c"><input type="checkbox" id="c-42206959" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42206363">parent</a><span>|</span><a href="#42207782">next</a><span>|</span><label class="collapse" for="c-42206959">[-]</label><label class="expand" for="c-42206959">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; If the performance impact is bad enough</i><p>Even worse, it&#x27;s possible to select a new algorithm that improves the best-case and average-case runtimes while degrading the worst-case runtime, so no matter what you do it will punish some users and reward others.</div><br/></div></div></div></div></div></div><div id="42207782" class="c"><input type="checkbox" id="c-42207782" checked=""/><div class="controls bullet"><span class="by">tshaddox</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42206063">prev</a><span>|</span><a href="#42209267">next</a><span>|</span><label class="collapse" for="c-42207782">[-]</label><label class="expand" for="c-42207782">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consider that even the total runtime of a function is an observable property, which means that optimizing a function to make it faster is a breaking change<p>Well yeah, that&#x27;s pretty much the textbook example of Hyrum&#x27;s Law (or some funnier variation like &quot;I was relying on the heat from the CPU to warm my bedroom, can you please revert your change that improved CPU performance&quot;).</div><br/></div></div><div id="42209267" class="c"><input type="checkbox" id="c-42209267" checked=""/><div class="controls bullet"><span class="by">brundolf</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42207782">prev</a><span>|</span><a href="#42204851">next</a><span>|</span><label class="collapse" for="c-42209267">[-]</label><label class="expand" for="c-42209267">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/></div></div><div id="42204851" class="c"><input type="checkbox" id="c-42204851" checked=""/><div class="controls bullet"><span class="by">skovati</span><span>|</span><a href="#42203962">parent</a><span>|</span><a href="#42209267">prev</a><span>|</span><a href="#42202326">next</a><span>|</span><label class="collapse" for="c-42204851">[-]</label><label class="expand" for="c-42204851">[2 more]</label></div><br/><div class="children"><div class="content">reminds me of: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/><div id="42206034" class="c"><input type="checkbox" id="c-42206034" checked=""/><div class="controls bullet"><span class="by">citizenpaul</span><span>|</span><a href="#42203962">root</a><span>|</span><a href="#42204851">parent</a><span>|</span><a href="#42202326">next</a><span>|</span><label class="collapse" for="c-42206034">[-]</label><label class="expand" for="c-42206034">[1 more]</label></div><br/><div class="children"><div class="content">That one always fell flat for me, but I get it.  The idea that an emacs user would communicate with another human rather than tinker with their config to deal with the change is unrealistic. &#x2F;s  &#x2F;sorta</div><br/></div></div></div></div></div></div><div id="42202326" class="c"><input type="checkbox" id="c-42202326" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#42203962">prev</a><span>|</span><a href="#42202204">next</a><span>|</span><label class="collapse" for="c-42202326">[-]</label><label class="expand" for="c-42202326">[24 more]</label></div><br/><div class="children"><div class="content">Hah, I wrote the crypto&#x2F;rsa comments. We take Hyrum&#x27;s Law (and backwards compatibility [1]) extremely seriously in Go. Here are a couple more examples:<p>- We randomly read an extra byte from random streams in various GenerateKey functions (which are not marked like the ones in OP) with MaybeReadByte [2] to avoid having our algorithm locked in<p>- Just yesterday someone reported that a private ECDSA key with a nil public key used to work, and now it doesn&#x27;t, so we probably have to make it work again [3]<p>- Iterating over a map uses a randomized order to avoid exposing the internals<p>- The output of rand.Rand is considered part of the compatibility promise, so we had to go to great lengths to improve it [4]<p>- We discuss <i>all the time</i> what commitments to make in docs and what behaviors to disclaim, knowing we can never change something documented <i>and</i> probably something that&#x27;s not explicitly documented as &quot;this may change&quot; [6]<p>[1]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1compat" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;doc&#x2F;go1compat</a><p>[2]: <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;crypto&#x2F;internal&#x2F;randutil#MaybeReadByte" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;crypto&#x2F;internal&#x2F;randutil#MaybeReadByte</a><p>[3]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;70468" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;issue&#x2F;70468</a><p>[4]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;randv2" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;randv2</a><p>[5]: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;chacha8rand" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;chacha8rand</a><p>[6]: <a href="https:&#x2F;&#x2F;go-review.googlesource.com&#x2F;c&#x2F;go&#x2F;+&#x2F;598336&#x2F;comment&#x2F;5d6877aa_f45d6fa5&#x2F;" rel="nofollow">https:&#x2F;&#x2F;go-review.googlesource.com&#x2F;c&#x2F;go&#x2F;+&#x2F;598336&#x2F;comment&#x2F;5d6...</a></div><br/><div id="42204369" class="c"><input type="checkbox" id="c-42204369" checked=""/><div class="controls bullet"><span class="by">mjw_byrne</span><span>|</span><a href="#42202326">parent</a><span>|</span><a href="#42204222">next</a><span>|</span><label class="collapse" for="c-42204369">[-]</label><label class="expand" for="c-42204369">[8 more]</label></div><br/><div class="children"><div class="content">The map iteration order change helps to avoid breaking changes in future, by preventing reliance on any specific ordering, but when the change was made it was breaking for anything that was relying on the previous ordering behaviour.<p>IMO this is a worthwhile tradeoff.  I use Go a lot and love the strong backwards compatibility, but I would happily accept a (slightly) higher rate of breaking changes if it meant greater freedom for the Go devs to improve performance, add features etc.<p>Based on the kind of hell users of other ecosystems seem willing to tolerate (<i>cough</i> Python <i>cough</i>), I believe I am not alone in this viewpoint.</div><br/><div id="42209932" class="c"><input type="checkbox" id="c-42209932" checked=""/><div class="controls bullet"><span class="by">dsymonds</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204369">parent</a><span>|</span><a href="#42204647">next</a><span>|</span><label class="collapse" for="c-42209932">[-]</label><label class="expand" for="c-42209932">[1 more]</label></div><br/><div class="children"><div class="content">The map iteration order was always &quot;random&quot;, but imperfectly so prior to Go 1.3. From memory, it picked a random initial bucket, but then always iterated over that bucket in order, so small maps (e.g. only a handful of elements) actually got deterministic iteration order. We fixed that in Go 1.3, but it broke a huge number of tests across Google that had inadvertently depended on that quirk; I spent quite a few weeks fixing tests before we could roll out Go 1.3 inside Google. I imagine there was quite a few broken tests on the outside too, but the benefit was deemed big enough to tolerate that.</div><br/></div></div><div id="42204647" class="c"><input type="checkbox" id="c-42204647" checked=""/><div class="controls bullet"><span class="by">wild_egg</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204369">parent</a><span>|</span><a href="#42209932">prev</a><span>|</span><a href="#42206278">next</a><span>|</span><label class="collapse" for="c-42204647">[-]</label><label class="expand" for="c-42204647">[3 more]</label></div><br/><div class="children"><div class="content">Data point of one, but I&#x27;ve been using Go since 2012 and would drop it instantly if any of the backwards compatibility guarantees were relaxed.<p>Having bugs imposed on you from outside your project is a waste of time to deal with and there are dozens of other languages you can pick from if you enjoy that time sink. Most of them give you greater capabilities as the balance.<p>Go&#x27;s stability is a core feature and compensates for the lack of other niceties. Adding features isn&#x27;t a good reason to break things. I can go use something else if I want to make that trade.</div><br/><div id="42205493" class="c"><input type="checkbox" id="c-42205493" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204647">parent</a><span>|</span><a href="#42206278">next</a><span>|</span><label class="collapse" for="c-42205493">[-]</label><label class="expand" for="c-42205493">[2 more]</label></div><br/><div class="children"><div class="content">Respectfully, I don’t think you would just pack up and leave. The cost of switching to an entirely different language—which might have even worse backwards compatibility issues—is significantly higher than fixing bugs you inadvertently introduced due to prior invalid assumptions.<p>I’d call your bluff.</div><br/><div id="42208443" class="c"><input type="checkbox" id="c-42208443" checked=""/><div class="controls bullet"><span class="by">hn34381</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42205493">parent</a><span>|</span><a href="#42206278">next</a><span>|</span><label class="collapse" for="c-42208443">[-]</label><label class="expand" for="c-42208443">[1 more]</label></div><br/><div class="children"><div class="content">Also, there is a time and a place for things.<p>Breaking API changes in a minor version update sucks and is often an unexpected time sink, and often mandatory because it has some security patch, critical bug fix, or something.<p>Breaking API changes in a major version update is expected, can be planned for, and often can be delayed if one chooses.</div><br/></div></div></div></div></div></div><div id="42206278" class="c"><input type="checkbox" id="c-42206278" checked=""/><div class="controls bullet"><span class="by">ljm</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204369">parent</a><span>|</span><a href="#42204647">prev</a><span>|</span><a href="#42207107">next</a><span>|</span><label class="collapse" for="c-42206278">[-]</label><label class="expand" for="c-42206278">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d consider stuff like that part of the opinion the language has. Go&#x27;s opinion is that backwards compatibility at all reasonable cost is a priority.<p>When it comes to ecosystems, the opinions have trade-offs. I would say that Go&#x27;s approach to dependencies, modules and workspaces is one of those. As a language it mostly stays out of your way, but correcting imports because it pulled in the wrong version, or dealing with go.mod, go.work and replace directives in a monorepo, gets old pretty fast (to the extent it&#x27;s easier to just have a monorepo-wide go.mod with literally every dependency in it). At least it&#x27;s an improvement over having to use a fairly specific directory structure though.</div><br/></div></div><div id="42207107" class="c"><input type="checkbox" id="c-42207107" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204369">parent</a><span>|</span><a href="#42206278">prev</a><span>|</span><a href="#42204867">next</a><span>|</span><label class="collapse" for="c-42207107">[-]</label><label class="expand" for="c-42207107">[1 more]</label></div><br/><div class="children"><div class="content">Java 5 was a fun upgrade for a lot of people because it caused JUnit tests to run in a different order. Due to hashtable changes altering the iteration of the reflected function names.<p>Don’t couple your tests, kids!</div><br/></div></div><div id="42204867" class="c"><input type="checkbox" id="c-42204867" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204369">parent</a><span>|</span><a href="#42207107">prev</a><span>|</span><a href="#42204222">next</a><span>|</span><label class="collapse" for="c-42204867">[-]</label><label class="expand" for="c-42204867">[1 more]</label></div><br/><div class="children"><div class="content">Breaking iteration order was also well established as a valid move. Several other languages had already made a similar change, much later in their own lifecycle than Go did. That helps a lot, because it shows it is largely just an annoyance, mostly affecting tests.</div><br/></div></div></div></div><div id="42204222" class="c"><input type="checkbox" id="c-42204222" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#42202326">parent</a><span>|</span><a href="#42204369">prev</a><span>|</span><a href="#42202361">next</a><span>|</span><label class="collapse" for="c-42204222">[-]</label><label class="expand" for="c-42204222">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We randomly read an extra byte from random streams in various GenerateKey functions (which are not marked like the ones in OP) with MaybeReadByte [2] to avoid having our algorithm locked in<p>You don&#x27;t seem to do that in ed25519. Back before ed25519.NewKeyFromSeed() existed, that was the only way to derive a public Ed25519 key from a private key, and I&#x27;m pretty sure I&#x27;ve written code that relied on that (it&#x27;s easy to remember, since I wasn&#x27;t very happy about it, but this was all I could do). The documentation of ed25519.GenerateKey mentions that the output is deterministic, so kudos for that. It seems you&#x27;ve really done a great job with investigating and maintaining ossified behavior in the Go cryptography APIs and preventing new ones from happening.</div><br/></div></div><div id="42202361" class="c"><input type="checkbox" id="c-42202361" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#42202326">parent</a><span>|</span><a href="#42204222">prev</a><span>|</span><a href="#42203192">next</a><span>|</span><label class="collapse" for="c-42202361">[-]</label><label class="expand" for="c-42202361">[5 more]</label></div><br/><div class="children"><div class="content">The nil key case really makes me wonder how sane it is to support these cases. You will be forced to lug this broken behavior with you forever, like the infamous A20 line (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;A20_line" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;A20_line</a>).</div><br/><div id="42202423" class="c"><input type="checkbox" id="c-42202423" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42202361">parent</a><span>|</span><a href="#42203192">next</a><span>|</span><label class="collapse" for="c-42202423">[-]</label><label class="expand" for="c-42202423">[4 more]</label></div><br/><div class="children"><div class="content">&gt; You will be forced to lug this broken behavior with you forever<p>Yep, welcome to my life.</div><br/><div id="42204137" class="c"><input type="checkbox" id="c-42204137" checked=""/><div class="controls bullet"><span class="by">atsjie</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42202423">parent</a><span>|</span><a href="#42204173">next</a><span>|</span><label class="collapse" for="c-42204137">[-]</label><label class="expand" for="c-42204137">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t that broken behaviour be a potential security issue by itself?<p>I do remember Go making backwards incompatible changes in some rare scenarios like that.<p>(and technically the loopvar fix was a big backwards incompatible change; granted that was done with a lot of consideration)</div><br/></div></div><div id="42204173" class="c"><input type="checkbox" id="c-42204173" checked=""/><div class="controls bullet"><span class="by">whizzter</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42202423">parent</a><span>|</span><a href="#42204137">prev</a><span>|</span><a href="#42203192">next</a><span>|</span><label class="collapse" for="c-42204173">[-]</label><label class="expand" for="c-42204173">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t a nil ECDSA key be a security risk?</div><br/><div id="42205369" class="c"><input type="checkbox" id="c-42205369" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42204173">parent</a><span>|</span><a href="#42203192">next</a><span>|</span><label class="collapse" for="c-42205369">[-]</label><label class="expand" for="c-42205369">[1 more]</label></div><br/><div class="children"><div class="content">If a private key is available, the public key can be derived from the private key using scalar multiplication. This is how ecdsa.GenerateKey works by itself - it first generates a private key from the provided random byte stream and then derives a public key from that private key.<p>I don&#x27;t see how this can be a security risk, but allowing a public key that has a curve but a nil value is definitely a messy API.</div><br/></div></div></div></div></div></div></div></div><div id="42203192" class="c"><input type="checkbox" id="c-42203192" checked=""/><div class="controls bullet"><span class="by">boloust</span><span>|</span><a href="#42202326">parent</a><span>|</span><a href="#42202361">prev</a><span>|</span><a href="#42208970">next</a><span>|</span><label class="collapse" for="c-42203192">[-]</label><label class="expand" for="c-42203192">[5 more]</label></div><br/><div class="children"><div class="content">Ironically, I once wrote a load balancer in Go that relied on the randomized map iteration ordering.</div><br/><div id="42203272" class="c"><input type="checkbox" id="c-42203272" checked=""/><div class="controls bullet"><span class="by">aleksi</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42203192">parent</a><span>|</span><a href="#42203939">next</a><span>|</span><label class="collapse" for="c-42203272">[-]</label><label class="expand" for="c-42203272">[1 more]</label></div><br/><div class="children"><div class="content">That is a bad idea: <a href="https:&#x2F;&#x2F;dev.to&#x2F;wallyqs&#x2F;gos-map-iteration-order-is-not-that-random-mag" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;wallyqs&#x2F;gos-map-iteration-order-is-not-that-r...</a></div><br/></div></div><div id="42203939" class="c"><input type="checkbox" id="c-42203939" checked=""/><div class="controls bullet"><span class="by">OskarS</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42203192">parent</a><span>|</span><a href="#42203272">prev</a><span>|</span><a href="#42208970">next</a><span>|</span><label class="collapse" for="c-42203939">[-]</label><label class="expand" for="c-42203939">[3 more]</label></div><br/><div class="children"><div class="content">Man, you really can’t escape Hyrum’s Law ever! Now we have people depending on the iteration order being random!</div><br/><div id="42209009" class="c"><input type="checkbox" id="c-42209009" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42203939">parent</a><span>|</span><a href="#42204071">next</a><span>|</span><label class="collapse" for="c-42209009">[-]</label><label class="expand" for="c-42209009">[1 more]</label></div><br/><div class="children"><div class="content">Clearly you need to randomly decide whether or not to randomise it.</div><br/></div></div><div id="42204071" class="c"><input type="checkbox" id="c-42204071" checked=""/><div class="controls bullet"><span class="by">ahoka</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42203939">parent</a><span>|</span><a href="#42209009">prev</a><span>|</span><a href="#42208970">next</a><span>|</span><label class="collapse" for="c-42204071">[-]</label><label class="expand" for="c-42204071">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why it&#x27;s totally stupid to randomize it.</div><br/></div></div></div></div></div></div><div id="42208970" class="c"><input type="checkbox" id="c-42208970" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#42202326">parent</a><span>|</span><a href="#42203192">prev</a><span>|</span><a href="#42202405">next</a><span>|</span><label class="collapse" for="c-42208970">[-]</label><label class="expand" for="c-42208970">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the least appreciated aspects of Go. Code I wrote 12 years ago still <i>just works</i>.</div><br/></div></div><div id="42202405" class="c"><input type="checkbox" id="c-42202405" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#42202326">parent</a><span>|</span><a href="#42208970">prev</a><span>|</span><a href="#42202204">next</a><span>|</span><label class="collapse" for="c-42202405">[-]</label><label class="expand" for="c-42202405">[3 more]</label></div><br/><div class="children"><div class="content">As a user of your code this is true, and I&#x27;m very grateful indeed that you take this approach.<p>I would add as a slight caveat that to benefit from this policy, users absolutely must read the release notes on major go versions before upgrading. We recently didn&#x27;t, and we were burnt somewhat by the change to disallow negative serial numbers in the x509 parser without enabling the new feature flag. Completely our fault and not yours, but I add the caveat nevertheless.</div><br/><div id="42202444" class="c"><input type="checkbox" id="c-42202444" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42202405">parent</a><span>|</span><a href="#42202204">next</a><span>|</span><label class="collapse" for="c-42202444">[-]</label><label class="expand" for="c-42202444">[2 more]</label></div><br/><div class="children"><div class="content">We have gotten a liiiiittle more liberal ever since we introduced the new GODEBUG feature flag mechanism.<p>I&#x27;ve been meaning to write a &quot;how to safely update Go&quot; post for a while, because the GODEBUG mechanism is very powerful but not well-known and we could build a bit of tooling around it.<p>In short, you can upgrade your toolchain without changing the go.mod version, and these things will keep working like they did, and set a metric every time the behavior <i>would</i> have changed, but didn&#x27;t. (Here&#x27;s where we could build a bit of tooling to check that metric in prod&#x2F;tests&#x2F;CLIs more easily.) Then you can update the go.mod version, which updates the default set of GODEBUGs, and if anything breaks, try reverting GODEBUGs one by one.</div><br/><div id="42202499" class="c"><input type="checkbox" id="c-42202499" checked=""/><div class="controls bullet"><span class="by">gnfargbl</span><span>|</span><a href="#42202326">root</a><span>|</span><a href="#42202444">parent</a><span>|</span><a href="#42202204">next</a><span>|</span><label class="collapse" for="c-42202499">[-]</label><label class="expand" for="c-42202499">[1 more]</label></div><br/><div class="children"><div class="content">That sounds good.<p>Breaking changes in major version updates is a completely normal thing in most software and we usually check for it. Ironically the only reason we weren&#x27;t previously bothering in go is that the maintainers were historically so hyper-focused on absolute backwards compatibility that there were never any breaking changes!</div><br/></div></div></div></div></div></div></div></div><div id="42202204" class="c"><input type="checkbox" id="c-42202204" checked=""/><div class="controls bullet"><span class="by">hambes</span><span>|</span><a href="#42202326">prev</a><span>|</span><a href="#42211889">next</a><span>|</span><label class="collapse" for="c-42202204">[-]</label><label class="expand" for="c-42202204">[34 more]</label></div><br/><div class="children"><div class="content">Solution to the specifically mentioned problem: Don&#x27;t use string-based errors, use sentinel errors [1].<p>More generally: Don&#x27;t produce code where consumers of your API are the least bit inclined to rely on non-technical strings. Instead use first-level language constructs like predefined error values, types or even constants that contain the non-technical string so that API consumers can compare the return value againnst the constant instead of hard-coding the contained string themselves.<p>Hyrum&#x27;s Law is definitely a thing, but its effects can be mitigated.<p>[1]: <a href="https:&#x2F;&#x2F;thomas-guettler.de&#x2F;go&#x2F;wrapping-and-sentinel-errors" rel="nofollow">https:&#x2F;&#x2F;thomas-guettler.de&#x2F;go&#x2F;wrapping-and-sentinel-errors</a></div><br/><div id="42212195" class="c"><input type="checkbox" id="c-42212195" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42202204">parent</a><span>|</span><a href="#42202260">next</a><span>|</span><label class="collapse" for="c-42212195">[-]</label><label class="expand" for="c-42212195">[1 more]</label></div><br/><div class="children"><div class="content">Go original design is to blame, for a long time string based errors were the only way, some standard library packages still have them if I am not mistaken, let alone the whole ecosystem.<p>That is what happens when history of programming languages is ignored on purpose, followed by a &quot;design as we go&quot; approach.</div><br/></div></div><div id="42202260" class="c"><input type="checkbox" id="c-42202260" checked=""/><div class="controls bullet"><span class="by">gwd</span><span>|</span><a href="#42202204">parent</a><span>|</span><a href="#42212195">prev</a><span>|</span><a href="#42202257">next</a><span>|</span><label class="collapse" for="c-42202260">[-]</label><label class="expand" for="c-42202260">[6 more]</label></div><br/><div class="children"><div class="content">The frustrating thing is that the error in question already <i>is</i> a sentinel error -- Grafana (the top-level culprit in the linked search) should be using `errors.As(&amp;http.MaxBytesError{})` rather than doing a string compare.<p>The whole point of Hyrum&#x27;s Law is that it doesn&#x27;t matter how well you design your API: no matter what, people will depend on its behavior rather than its contract.</div><br/><div id="42202472" class="c"><input type="checkbox" id="c-42202472" checked=""/><div class="controls bullet"><span class="by">sssddfffdssasdf</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202260">parent</a><span>|</span><a href="#42202475">next</a><span>|</span><label class="collapse" for="c-42202472">[-]</label><label class="expand" for="c-42202472">[4 more]</label></div><br/><div class="children"><div class="content">But it looks like that until 3 years ago, this string comparison was the only way to do it. <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;pull&#x2F;49359&#x2F;files">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;pull&#x2F;49359&#x2F;files</a></div><br/><div id="42202498" class="c"><input type="checkbox" id="c-42202498" checked=""/><div class="controls bullet"><span class="by">gwd</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202472">parent</a><span>|</span><a href="#42205775">next</a><span>|</span><label class="collapse" for="c-42202498">[-]</label><label class="expand" for="c-42202498">[2 more]</label></div><br/><div class="children"><div class="content">Good catch.  So in a sense this isn&#x27;t really Hyrum&#x27;s Law (which would be more appropriate to things like the Sim City &#x2F; Windows 3.x UAF bug described in a sibling comment); it&#x27;s more like, if people need to do something, and you don&#x27;t give people an explicit way to do it, they&#x27;ll find an implicit way, and then you&#x27;re stuck supporting whatever that happened to be.</div><br/><div id="42204598" class="c"><input type="checkbox" id="c-42204598" checked=""/><div class="controls bullet"><span class="by">ekidd</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202498">parent</a><span>|</span><a href="#42205775">next</a><span>|</span><label class="collapse" for="c-42204598">[-]</label><label class="expand" for="c-42204598">[1 more]</label></div><br/><div class="children"><div class="content">There was a well-known trick in MacOS development in the 90s. You couldn&#x27;t always avoid relying on undocumented behavior. The docs were incomplete and occasionally vague.<p>What you <i>could</i> do was try to rely on the <i>same</i> undocumented behavior as everyone else. This way, if Apple broke you, they&#x27;d break half their ecosystem at the same time.</div><br/></div></div></div></div><div id="42205775" class="c"><input type="checkbox" id="c-42205775" checked=""/><div class="controls bullet"><span class="by">lokar</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202472">parent</a><span>|</span><a href="#42202498">prev</a><span>|</span><a href="#42202475">next</a><span>|</span><label class="collapse" for="c-42205775">[-]</label><label class="expand" for="c-42205775">[1 more]</label></div><br/><div class="children"><div class="content">Or they could have fixed the error (adding the type) instead of matching the string.</div><br/></div></div></div></div><div id="42202475" class="c"><input type="checkbox" id="c-42202475" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202260">parent</a><span>|</span><a href="#42202472">prev</a><span>|</span><a href="#42202257">next</a><span>|</span><label class="collapse" for="c-42202475">[-]</label><label class="expand" for="c-42202475">[1 more]</label></div><br/><div class="children"><div class="content">Early Go lacked lots of features such as errors.As. It was and still is sometimes idiomatic to generate Go because it is so featureless and writing it is often a chore. So it is very much about how well you design your API.</div><br/></div></div></div></div><div id="42202257" class="c"><input type="checkbox" id="c-42202257" checked=""/><div class="controls bullet"><span class="by">Svip</span><span>|</span><a href="#42202204">parent</a><span>|</span><a href="#42202260">prev</a><span>|</span><a href="#42202608">next</a><span>|</span><label class="collapse" for="c-42202257">[-]</label><label class="expand" for="c-42202257">[13 more]</label></div><br/><div class="children"><div class="content">In your example, the onus is on the consumer not the provider.  I could still be writing code that checks if `err.String() == &quot;no more tea available.&quot;`.  I agree, I shouldn&#x27;t do that, but nothing is preventing me from doing that.  Additionally, errors.Is is a relatively recent addition to Go, so by the time people would check for errors like this, it was just easier to check the literal string.  But as an API provider in Go, you cannot prevent your consumers from checking the return values of .String().</div><br/><div id="42202284" class="c"><input type="checkbox" id="c-42202284" checked=""/><div class="controls bullet"><span class="by">hambes</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202257">parent</a><span>|</span><a href="#42202608">next</a><span>|</span><label class="collapse" for="c-42202284">[-]</label><label class="expand" for="c-42202284">[12 more]</label></div><br/><div class="children"><div class="content">Unfortunately true. The Go maintainers might not agree with me on this, but I think in this case consumers have to learn the hard way. Go tries to always be backwards compatible, but I don&#x27;t think that trying to be backwards compatible with incorrect usage is ever the right choice.</div><br/><div id="42202783" class="c"><input type="checkbox" id="c-42202783" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202284">parent</a><span>|</span><a href="#42202608">next</a><span>|</span><label class="collapse" for="c-42202783">[-]</label><label class="expand" for="c-42202783">[11 more]</label></div><br/><div class="children"><div class="content">So the people who decided to make a stringly type error with `errors.New(&quot;http: request body too large&quot;)` and make you suffer, now can remove a stringly typed error and make you suffer even more? What would the lesson be? What would consumers learn?</div><br/><div id="42203648" class="c"><input type="checkbox" id="c-42203648" checked=""/><div class="controls bullet"><span class="by">hambes</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202783">parent</a><span>|</span><a href="#42211202">next</a><span>|</span><label class="collapse" for="c-42203648">[-]</label><label class="expand" for="c-42203648">[9 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand your point. The lesson is &quot;don&#x27;t rely on magic strings, instead rely on exported and documented constants, otherwise your code might break&quot;.</div><br/><div id="42203983" class="c"><input type="checkbox" id="c-42203983" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42203648">parent</a><span>|</span><a href="#42211202">next</a><span>|</span><label class="collapse" for="c-42203983">[-]</label><label class="expand" for="c-42203983">[8 more]</label></div><br/><div class="children"><div class="content">My point is that a few years ago there was no exported and document constant. The lesson should be &quot;provide sensible tools, otherwise your consumers will have to rely on implementation details for the most basic expected stuff&quot;.</div><br/><div id="42205117" class="c"><input type="checkbox" id="c-42205117" checked=""/><div class="controls bullet"><span class="by">stonemetal12</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42203983">parent</a><span>|</span><a href="#42204421">next</a><span>|</span><label class="collapse" for="c-42205117">[-]</label><label class="expand" for="c-42205117">[5 more]</label></div><br/><div class="children"><div class="content">&gt;My point is that a few years ago there was no exported and document constant.<p>Then the feature didn&#x27;t exist.  Figuring out undocumented implementation details to &quot;make it work&quot; is asking for it to be broken in the future.  So if you are unwilling or unable to support fixing it in the future then don&#x27;t do that.<p>If it is &quot;the most basic expected stuff&quot; then quite literally make the determination that it isn&#x27;t ready for use.  A lot of Go was and maybe still be half baked and not ready for production. It is ok to recognize that and not use it.</div><br/><div id="42206288" class="c"><input type="checkbox" id="c-42206288" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42205117">parent</a><span>|</span><a href="#42204421">next</a><span>|</span><label class="collapse" for="c-42206288">[-]</label><label class="expand" for="c-42206288">[4 more]</label></div><br/><div class="children"><div class="content">I am glad that your circumstances are such that you can just stop working on a project when the tooling it uses turns out to be inadequate, wait five years, and then come back when it improves.<p>Unfortunately, many people can&#x27;t really do that: when the ecosystem turns out to be somewhat inadequate in a project that&#x27;s already been in use for couple of years, their options are either &quot;just make it work one way or another, who cares if it&#x27;s a hardcoded string, we have to ship the fix ASAP&quot; or &quot;rewrite it all in Rust&#x2F;X, allegedly their ecosystem is production-ready&quot;.</div><br/><div id="42210792" class="c"><input type="checkbox" id="c-42210792" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42206288">parent</a><span>|</span><a href="#42209077">next</a><span>|</span><label class="collapse" for="c-42210792">[-]</label><label class="expand" for="c-42210792">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I am glad that your circumstances are such that you can just stop working on a project when the tooling it uses turns out to be inadequate, wait five years, and then come back when it improves.<p>Is it that terrible to just handle an error as an error, without having to know exactly what the error was? If you see some of the codebases which rely on the error, they are trying to be too clever and doing things like returning a 400 instead of 500 if that&#x27;s the specific error message returned. Is that really necessary?<p>Unless the codebase can take corrective actions (and it could still attempt to do it regardless if that&#x27;s the case), there&#x27;s really no point trying to be cute. An error is returned, and that&#x27;s that.</div><br/></div></div><div id="42209077" class="c"><input type="checkbox" id="c-42209077" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42206288">parent</a><span>|</span><a href="#42210792">prev</a><span>|</span><a href="#42204421">next</a><span>|</span><label class="collapse" for="c-42209077">[-]</label><label class="expand" for="c-42209077">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;just make it work one way or another, who cares if it&#x27;s a hardcoded string, we have to ship the fix ASAP&quot;<p>Sure, but now that there&#x27;s a &quot;correct&quot; way to do this, you don&#x27;t get to complain that the hacky thing you did needs to keep being supported. You fix the hacky thing you did, or you make peace that you&#x27;re still doing the hacky thing, problems it causes and all.</div><br/><div id="42212001" class="c"><input type="checkbox" id="c-42212001" checked=""/><div class="controls bullet"><span class="by">beautron</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42209077">parent</a><span>|</span><a href="#42204421">next</a><span>|</span><label class="collapse" for="c-42212001">[-]</label><label class="expand" for="c-42212001">[1 more]</label></div><br/><div class="children"><div class="content">I love that the Go project takes compatibility so seriously. And I think taking Hyrum&#x27;s Law into account is necessary, if what you&#x27;re serious about is compatibility itself.<p>Being serious about compatibility allows the concept of a piece of software being finished. If I finished writing a book twelve years ago, you could still read it today. But if I finished writing a piece of software twelve years ago, could you still build and run it today? Without having to fix anything? Without having to fix <i>lots</i> of things?<p>&gt; Sure, but now that there&#x27;s a &quot;correct&quot; way to do this, you don&#x27;t get to complain that the hacky thing you did needs to keep being supported.<p>But that&#x27;s the whole point and beauty of Go&#x27;s compatibility promise. Once you finish getting something working, you finished getting it working. It works.<p>What I don&#x27;t want, is for my programming platform to suddenly say that the way I got the thing working is no longer supported. I am no longer finished getting it working. I will never be finished getting it working.<p>Go is proving that a world with permanently working software is possible (vs a world with software that breaks over time).</div><br/></div></div></div></div></div></div></div></div><div id="42207854" class="c"><input type="checkbox" id="c-42207854" checked=""/><div class="controls bullet"><span class="by">estebarb</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42203983">parent</a><span>|</span><a href="#42204421">prev</a><span>|</span><a href="#42211202">next</a><span>|</span><label class="collapse" for="c-42207854">[-]</label><label class="expand" for="c-42207854">[1 more]</label></div><br/><div class="children"><div class="content">That is the kind of stuff I would have expected `go vet` to fix.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42202608" class="c"><input type="checkbox" id="c-42202608" checked=""/><div class="controls bullet"><span class="by">karel-3d</span><span>|</span><a href="#42202204">parent</a><span>|</span><a href="#42202257">prev</a><span>|</span><a href="#42202551">next</a><span>|</span><label class="collapse" for="c-42202608">[-]</label><label class="expand" for="c-42202608">[3 more]</label></div><br/><div class="children"><div class="content">Using string error comparisons was the only way to do this few years ago; and Go has a backwards compatibility promise.</div><br/></div></div><div id="42202551" class="c"><input type="checkbox" id="c-42202551" checked=""/><div class="controls bullet"><span class="by">cedws</span><span>|</span><a href="#42202204">parent</a><span>|</span><a href="#42202608">prev</a><span>|</span><a href="#42202464">next</a><span>|</span><label class="collapse" for="c-42202551">[-]</label><label class="expand" for="c-42202551">[1 more]</label></div><br/><div class="children"><div class="content">Code that checks raw error strings is just plain bad and should be exempt from Go’s backwards compatibility guarantees. There is almost never an excuse for it, especially in stdlib.</div><br/></div></div><div id="42202261" class="c"><input type="checkbox" id="c-42202261" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#42202204">parent</a><span>|</span><a href="#42202464">prev</a><span>|</span><a href="#42211889">next</a><span>|</span><label class="collapse" for="c-42202261">[-]</label><label class="expand" for="c-42202261">[8 more]</label></div><br/><div class="children"><div class="content">Honestly, this is so much worse than &quot;catch&quot;. It&#x27;s what a &quot;catch&quot; would look like in &quot;C&quot;.</div><br/><div id="42202287" class="c"><input type="checkbox" id="c-42202287" checked=""/><div class="controls bullet"><span class="by">hambes</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202261">parent</a><span>|</span><a href="#42204960">next</a><span>|</span><label class="collapse" for="c-42202287">[-]</label><label class="expand" for="c-42202287">[6 more]</label></div><br/><div class="children"><div class="content">It might look worse than catch, but it&#x27;s much more predictable and less goto-y.</div><br/><div id="42202393" class="c"><input type="checkbox" id="c-42202393" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202287">parent</a><span>|</span><a href="#42208858">next</a><span>|</span><label class="collapse" for="c-42202393">[-]</label><label class="expand" for="c-42202393">[4 more]</label></div><br/><div class="children"><div class="content">goto was only bad when used to save code and jump indiscriminately. To handle errors is no problem at all.</div><br/><div id="42202435" class="c"><input type="checkbox" id="c-42202435" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202393">parent</a><span>|</span><a href="#42204372">next</a><span>|</span><label class="collapse" for="c-42202435">[-]</label><label class="expand" for="c-42202435">[1 more]</label></div><br/><div class="children"><div class="content">yes, yes, yes!  see the Linux Kernel for plenty of such good and readable uses of go-to, considered useful:  &quot;on error, jump there in the cleanup sequence ...&quot;</div><br/></div></div><div id="42204372" class="c"><input type="checkbox" id="c-42204372" checked=""/><div class="controls bullet"><span class="by">_flux</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202393">parent</a><span>|</span><a href="#42202435">prev</a><span>|</span><a href="#42208858">next</a><span>|</span><label class="collapse" for="c-42204372">[-]</label><label class="expand" for="c-42204372">[2 more]</label></div><br/><div class="children"><div class="content">..as long as you don&#x27;t make mistakes. I fixed enough goto bugs in Xorg when I was fixing Coverity-issues in Xorg that I can see the downsides of this <i>easy</i> way of error handling.</div><br/><div id="42211831" class="c"><input type="checkbox" id="c-42211831" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42204372">parent</a><span>|</span><a href="#42208858">next</a><span>|</span><label class="collapse" for="c-42211831">[-]</label><label class="expand" for="c-42211831">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re comparing to go here, not with a language with proper error handling.</div><br/></div></div></div></div></div></div><div id="42208858" class="c"><input type="checkbox" id="c-42208858" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202287">parent</a><span>|</span><a href="#42202393">prev</a><span>|</span><a href="#42204960">next</a><span>|</span><label class="collapse" for="c-42208858">[-]</label><label class="expand" for="c-42208858">[1 more]</label></div><br/><div class="children"><div class="content">If &quot;catch&quot; is goto-y (and it kinda is), then so is &quot;defer&quot;.</div><br/></div></div></div></div><div id="42204960" class="c"><input type="checkbox" id="c-42204960" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42202204">root</a><span>|</span><a href="#42202261">parent</a><span>|</span><a href="#42202287">prev</a><span>|</span><a href="#42211889">next</a><span>|</span><label class="collapse" for="c-42204960">[-]</label><label class="expand" for="c-42204960">[1 more]</label></div><br/><div class="children"><div class="content">The biggest difference between try-catch and error values syntactically IMO is that the former allows you to handle a specific type of error from an unspecified place and the latter allows you to handle an unspecified type of error from a specific place. So the type checking is more cumbersome with error values whereas enclosing every individual source of exceptions in its own try-catch block is more cumbersome than error values. You usually don&#x27;t do that, but you usually don&#x27;t type-check error values either.</div><br/></div></div></div></div></div></div><div id="42211889" class="c"><input type="checkbox" id="c-42211889" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#42202204">prev</a><span>|</span><a href="#42202586">next</a><span>|</span><label class="collapse" for="c-42211889">[-]</label><label class="expand" for="c-42211889">[1 more]</label></div><br/><div class="children"><div class="content">IME, one of the places hyrums law shows up the most is in tests.<p>I&#x27;ve seen tests of various types (unit, integration end-to-end) break because they made assumptions about behaviors that weren&#x27;t garanteed, and supposedly backwards compatible updates broke them. Here are some examples of things that have broken tests:<p>- an update resulted in a change in the order of elements in a Hashmap or set.<p>- a change in an error message (or other user-facing message), changed<p>- a change in how leap days are handled for datetime arithmetic<p>- change in the format of locale-specific datetimes<p>- the timezone offset for a given area<p>- removal of internal-only APIs that were accessed using reflection<p>- something performed faster, which revealed race conditions in the testing code<p>- changing the precise representation of some data format. To give a specific example, changing a single byte when gzip compressing a file, that has no impact on the compressed content.</div><br/></div></div><div id="42202586" class="c"><input type="checkbox" id="c-42202586" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#42211889">prev</a><span>|</span><a href="#42202248">next</a><span>|</span><label class="collapse" for="c-42202586">[-]</label><label class="expand" for="c-42202586">[4 more]</label></div><br/><div class="children"><div class="content">An interesting topic is how to fight Hyrum&#x27;s law.
A possibility is to add randomness in things you don&#x27;t want people to rely on.
If I remember well, this is what the QUIC protocol does. Some fields are unused in the current version, but required by the specification to be set to random values, not null bytes, so that routers don&#x27;t start relying on them to identify the packets.<p>EDIT.<p>I think I found the source: <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9000#section-17.2.1" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc9000#section-17.2.1</a><p>&gt; The value in the Unused field is set to an arbitrary value by the server. Clients MUST ignore the value of this field. [...] Note that other versions of QUIC might not make a similar recommendation.<p>I think they call it &quot;greasing&quot;, to prevent &quot;ossification&quot;.</div><br/><div id="42203994" class="c"><input type="checkbox" id="c-42203994" checked=""/><div class="controls bullet"><span class="by">vitus</span><span>|</span><a href="#42202586">parent</a><span>|</span><a href="#42204140">next</a><span>|</span><label class="collapse" for="c-42203994">[-]</label><label class="expand" for="c-42203994">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think they call it &quot;greasing&quot;<p>This is a reference to RFC 8701, which coined the acronym GREASE (&quot;Generate Random Extensions And Sustain Extensibility&quot;), first in the context of TLS.<p><a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8701.html" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc8701.html</a><p>(The earliest draft of the RFC dates back to mid-2016, which is likely the first public mention of the term: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-davidben-tls-grease-00" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-davidben-tls-gre...</a>)</div><br/></div></div><div id="42204140" class="c"><input type="checkbox" id="c-42204140" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#42202586">parent</a><span>|</span><a href="#42203994">prev</a><span>|</span><a href="#42202840">next</a><span>|</span><label class="collapse" for="c-42204140">[-]</label><label class="expand" for="c-42204140">[1 more]</label></div><br/><div class="children"><div class="content">This is wonderful. I’m quite familiar with QUIC but hadn’t heard about this.<p>Nothing like waking up after 10 years, realize you now really need those bits, and 20 different routers from 10 brands have decided that those bits must be a certain way.<p>Bonus points for checksums&#x2F;crypto that breaks on the other end if the bits have been messed with. Curse those middle-boxes and their “clever hacks”.</div><br/></div></div><div id="42202840" class="c"><input type="checkbox" id="c-42202840" checked=""/><div class="controls bullet"><span class="by">rho4</span><span>|</span><a href="#42202586">parent</a><span>|</span><a href="#42204140">prev</a><span>|</span><a href="#42202248">next</a><span>|</span><label class="collapse" for="c-42202840">[-]</label><label class="expand" for="c-42202840">[1 more]</label></div><br/><div class="children"><div class="content">Interesting thanks! Might indeed be valuable to add to one&#x27;s toolbox.</div><br/></div></div></div></div><div id="42202248" class="c"><input type="checkbox" id="c-42202248" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#42202586">prev</a><span>|</span><a href="#42205647">next</a><span>|</span><label class="collapse" for="c-42202248">[-]</label><label class="expand" for="c-42202248">[23 more]</label></div><br/><div class="children"><div class="content">This is a good example of &quot;stringly typed&quot; software. Golang designers did not want exceptions (still have them with panic&#x2F;recover), but untyped errors are evil. On the other hand, how would one process typed errors without pattern matching? Because &quot;catch&quot; in most languages is a [rudimentary] pattern matching.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-reference&#x2F;statements&#x2F;exception-handling-statements#a-when-exception-filter" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-ref...</a></div><br/><div id="42202266" class="c"><input type="checkbox" id="c-42202266" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#42202248">parent</a><span>|</span><a href="#42205647">next</a><span>|</span><label class="collapse" for="c-42202266">[-]</label><label class="expand" for="c-42202266">[22 more]</label></div><br/><div class="children"><div class="content">Go has typed errors, it just didn&#x27;t use it in this case.</div><br/><div id="42203319" class="c"><input type="checkbox" id="c-42203319" checked=""/><div class="controls bullet"><span class="by">simiones</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42205600">next</a><span>|</span><label class="collapse" for="c-42203319">[-]</label><label class="expand" for="c-42203319">[5 more]</label></div><br/><div class="children"><div class="content">In principle. In practice, most Go code, and even significant parts of the Go standard library, return arbitrary error strings. And error returning functions <i>never</i> return anything more specific than `error` (you could count the exceptions in the top 20 Go codebases on your fingers, most likely).<p>Returning non-specific exceptions is virtually encouraged by the standard library (if you return an error struct, you run into major issues with the ubiquitous `if err != nil` &quot;error handling&quot; logic). You have both errors.New() and fmt.Errorf() for returning stringly-typed errors. errors.Is and errors.As only work easily if you return error constants, not error types (they can support error types, but then you have to do more work to manually implement Is() and As() in your custom error type) - so you can&#x27;t easily both have a specific error, but also include extra information with that error.<p>For the example in the OP, you have to do a lot of extra work to return an error that can be checked without string comparisons, but also tells you what was the actual limit. So much work that this was only introduced in Go 1.19, despite MaxBytesReader existing since go 1.0 . Before that, it simply returned errors.New(&quot;http: request body too large&quot;) [0].<p>And this is true throughout the standard library. Despite all of their talk about the importance of handling errors, Go&#x27;s standard library was full of stringly-typed errors for most of its lifetime, and while it&#x27;s getting better, it&#x27;s still a common occurrence. And even when they were at least using sentinel errors, they rarely included any kind of machine-readable context you could use for taking a decision based on the error value.<p>[0] <a href="https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;refs&#x2F;tags&#x2F;go1:src&#x2F;pkg&#x2F;net&#x2F;http&#x2F;request.go;l=583" rel="nofollow">https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;refs&#x2F;tags&#x2F;go1:src&#x2F;pkg&#x2F;n...</a></div><br/><div id="42205440" class="c"><input type="checkbox" id="c-42205440" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42203319">parent</a><span>|</span><a href="#42205600">next</a><span>|</span><label class="collapse" for="c-42205440">[-]</label><label class="expand" for="c-42205440">[4 more]</label></div><br/><div class="children"><div class="content">You do not have to do more work to use errors.Is or errors.As. They work out of the box in most cases just fine. For example:<p><pre><code>    package example

    var ErrValue = errors.New(&quot;stringly&quot;)

    type ErrType struct {
        Code    int
        Message string
    }
    func (e ErrType) Error() string {
        return fmt.Sprintf(&quot;%s (%d)&quot;, e.Message, e.Code)
    }
</code></pre>
You can now use errors.Is with a target of ErrValue and errors.As with a target of *ErrType. No extra methods are needed.<p>However, you can&#x27;t compare ErrValue to another errors.New(&quot;stringly&quot;) by design (under the hood, errors.New returns a pointer, and errors.Is uses simple equality). If you want pure value semantics, use your own type instead.<p>There <i>are</i> Is and As interfaces that you <i>can</i> implement, but you rarely <i>need</i> to implement them. You can use the type system (subtyping, value vs. pointer method receivers) to control comparability in most cases instead. The only time to break out custom implementations of Is or As is when you want semantic equality to differ from ==, such as making two ErrType values match if just their Code fields match.<p>The one special case that the average developer should be aware of is unwrapping the cause of custom errors. If you do your own error wrapping (which is itself rarely necessary, thanks to the %w specifier on fmt.Errorf), then you need to provide an Unwrap method (returning either an error or a slice of errors).</div><br/><div id="42211985" class="c"><input type="checkbox" id="c-42211985" checked=""/><div class="controls bullet"><span class="by">simiones</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42205440">parent</a><span>|</span><a href="#42209237">next</a><span>|</span><label class="collapse" for="c-42211985">[-]</label><label class="expand" for="c-42211985">[1 more]</label></div><br/><div class="children"><div class="content">Your example is half right, I had misread the documentation of errors.As [0].<p>errors.As does work as you describe, but errors.Is doesn&#x27;t: that only compares the error argument for equality, unless it implements Is() itself to do something different. So `var e error ErrType{Code: 1, Message: &quot;Good&quot;} = errors.Is(e, ErrType{})` will return false. But indeed Errors.As will work for this case and allow you to check if an error is an instance of ErrType.<p>[0] <a href="https:&#x2F;&#x2F;play.golang.com&#x2F;p&#x2F;qXj3SMiBE2K" rel="nofollow">https:&#x2F;&#x2F;play.golang.com&#x2F;p&#x2F;qXj3SMiBE2K</a></div><br/></div></div><div id="42209237" class="c"><input type="checkbox" id="c-42209237" checked=""/><div class="controls bullet"><span class="by">dgunay</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42205440">parent</a><span>|</span><a href="#42211985">prev</a><span>|</span><a href="#42208565">next</a><span>|</span><label class="collapse" for="c-42209237">[-]</label><label class="expand" for="c-42209237">[1 more]</label></div><br/><div class="children"><div class="content">If you want errors to behave more like value types, you can also implement `Is`. For example, you could have your `ErrType`&#x27;s `Is` implementation return true if the other error `As` an `ErrType` also has the same code.</div><br/></div></div><div id="42208565" class="c"><input type="checkbox" id="c-42208565" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42205440">parent</a><span>|</span><a href="#42209237">prev</a><span>|</span><a href="#42205600">next</a><span>|</span><label class="collapse" for="c-42208565">[-]</label><label class="expand" for="c-42208565">[1 more]</label></div><br/><div class="children"><div class="content">Probably worth noting that errors.As uses assignability to match errors, while errors.Is is what uses simple equality. Either way, both work well without custom implementations in the usual cases.</div><br/></div></div></div></div></div></div><div id="42205600" class="c"><input type="checkbox" id="c-42205600" checked=""/><div class="controls bullet"><span class="by">unscaled</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42203319">prev</a><span>|</span><a href="#42206561">next</a><span>|</span><label class="collapse" for="c-42205600">[-]</label><label class="expand" for="c-42205600">[1 more]</label></div><br/><div class="children"><div class="content">Go errors cannot be string-typed, since they need to implement the error interface. The reason testing error types sometimes won&#x27;t work is that the error types themselves may be private to the package where they are defined or that the error is just a generic error created by errors.New().<p>In this case the Error has an easy-to-check public type (*MaxBytesError) and the documentation clearly indicates that. But that has not always been the case. The original sin is that the API returned a generic error and the only way to test that error was to use a string comparison.<p>This is an important context to have when you need to make balanced decisions about Hyrum&#x27;s law. As some commentators already mentioned, you should be wary of taking the extreme version of the law, which suggest that every single observable behavior of the API becomes part of the API itself and needs to be preserved. If you follow this extreme version, every error or exception message in every language must be left be left unchanged forever. But most client code doesn&#x27;t just go around happily comparing exception messages to strings if there is another method to detect the exception.</div><br/></div></div><div id="42206561" class="c"><input type="checkbox" id="c-42206561" checked=""/><div class="controls bullet"><span class="by">karel-3d</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42205600">prev</a><span>|</span><a href="#42202378">next</a><span>|</span><label class="collapse" for="c-42206561">[-]</label><label class="expand" for="c-42206561">[1 more]</label></div><br/><div class="children"><div class="content">They didn&#x27;t have them when they implemented this code.<p>Back then, error was a glorified string. Then it started having more smart errors, mostly due to a popular third party packages, and then the logic of those popular packages was more or less* put back to go.<p>* except for stacktraces in native errors. I understand that they are not there for speed reasons but dang it would be nice to have them sometimes</div><br/></div></div><div id="42202378" class="c"><input type="checkbox" id="c-42202378" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42206561">prev</a><span>|</span><a href="#42208318">next</a><span>|</span><label class="collapse" for="c-42202378">[-]</label><label class="expand" for="c-42202378">[9 more]</label></div><br/><div class="children"><div class="content">It has typed errors, except every function that returns an error returns the &#x27;error&#x27; interface, which gives you no information on the set of errors you might have.<p>In other statically typed languages, you can do things like &#x27;match err&#x27; and have the compiler tell you if you handled all the variants. In java you can `try { x } catch (SomeTypedException)` and have the compiler tell you if you missed any checked exceptions.<p>In go, you have to read the recursive call stack of the entire function you called to know if a certain error type is returned.<p>Can &#x27;pgx.Connect&#x27; return an `io.EOF` error? Can it return a &quot;tls: unknown certificate authority&quot; (unexported string only error)?<p>The only way to know is to recursively read every line of code `pgx.Connect` calls and take note of every returned error.<p>In other languages, it&#x27;s part of the type-signature.<p>Go doesn&#x27;t have _useful_ typed errors since idiomatically they&#x27;re type-erased into &#x27;error&#x27; the second they&#x27;re returned up from any method.</div><br/><div id="42206005" class="c"><input type="checkbox" id="c-42206005" checked=""/><div class="controls bullet"><span class="by">inlined</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202378">parent</a><span>|</span><a href="#42202445">next</a><span>|</span><label class="collapse" for="c-42206005">[-]</label><label class="expand" for="c-42206005">[3 more]</label></div><br/><div class="children"><div class="content">You actually should never return a specific error pointer because you can eventually break nil checks. I caused a production outage because interfaces are tuples of type and pointer and the literal nil turns to [nil, nil] when getting passed to a comparator whereas your struct return value will be [nil, *Type]</div><br/><div id="42208350" class="c"><input type="checkbox" id="c-42208350" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42206005">parent</a><span>|</span><a href="#42202445">next</a><span>|</span><label class="collapse" for="c-42208350">[-]</label><label class="expand" for="c-42208350">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really hard to reconcile behavior like this with people&#x27;s seemingly unshakeable love for golang&#x27;s error handling.</div><br/><div id="42210600" class="c"><input type="checkbox" id="c-42210600" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42208350">parent</a><span>|</span><a href="#42202445">next</a><span>|</span><label class="collapse" for="c-42210600">[-]</label><label class="expand" for="c-42210600">[1 more]</label></div><br/><div class="children"><div class="content">People who rave about Go&#x27;s error handling, in my experience, are people who haven&#x27;t used rust or haskell, and instead have experience with javascript, python, and&#x2F;or C.<p><a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;avg.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;avg.html</a></div><br/></div></div></div></div></div></div><div id="42202445" class="c"><input type="checkbox" id="c-42202445" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202378">parent</a><span>|</span><a href="#42206005">prev</a><span>|</span><a href="#42208318">next</a><span>|</span><label class="collapse" for="c-42202445">[-]</label><label class="expand" for="c-42202445">[5 more]</label></div><br/><div class="children"><div class="content">Exceptions in Python and C are the same. The idea with these is, either you know exactly what error to expect to handle and recover it, or you just treat it as a general error and retry, drop the result, propagate the error up, or log and abort. None of those require understanding the error.<p>Should an unexpected error propagate from deep down in your call stack to your current call site, do you really think that error should be handled at this specific call-site?</div><br/><div id="42202610" class="c"><input type="checkbox" id="c-42202610" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202445">parent</a><span>|</span><a href="#42204406">next</a><span>|</span><label class="collapse" for="c-42202610">[-]</label><label class="expand" for="c-42202610">[3 more]</label></div><br/><div class="children"><div class="content">Nope, exceptions in Python are not the same. There are a lot of standard exceptions<p><a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;exceptions.html#concrete-exceptions" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;exceptions.html#concrete-e...</a><p>and standard about exception type hierarchy<p><a href="https:&#x2F;&#x2F;github.com&#x2F;psycopg&#x2F;psycopg&#x2F;blob&#x2F;d38cf7798b0c602ff43dac9f20bbab96237a9c38&#x2F;psycopg&#x2F;psycopg&#x2F;errors.py">https:&#x2F;&#x2F;github.com&#x2F;psycopg&#x2F;psycopg&#x2F;blob&#x2F;d38cf7798b0c602ff43d...</a><p><a href="https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0249&#x2F;#exceptions" rel="nofollow">https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0249&#x2F;#exceptions</a><p>Also in most languages &quot;catch Exception:&quot; (or similar expression) is considered a bad style. People are taught to catch specific exceptions. Nothing like that happens in Go.</div><br/><div id="42206411" class="c"><input type="checkbox" id="c-42206411" checked=""/><div class="controls bullet"><span class="by">rocqua</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202610">parent</a><span>|</span><a href="#42203226">next</a><span>|</span><label class="collapse" for="c-42206411">[-]</label><label class="expand" for="c-42206411">[1 more]</label></div><br/><div class="children"><div class="content">Sure, there is a hierarchy. But the hierarchy is open. You still need to recurse down the entire call stack to figure out which exceptions might be raised.</div><br/></div></div><div id="42203226" class="c"><input type="checkbox" id="c-42203226" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202610">parent</a><span>|</span><a href="#42206411">prev</a><span>|</span><a href="#42204406">next</a><span>|</span><label class="collapse" for="c-42203226">[-]</label><label class="expand" for="c-42203226">[1 more]</label></div><br/><div class="children"><div class="content">C also doesn’t have exceptions and C++ similarly can distinguish between exception types (unless you just throws a generic std::exception everywhere).</div><br/></div></div></div></div><div id="42204406" class="c"><input type="checkbox" id="c-42204406" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202445">parent</a><span>|</span><a href="#42202610">prev</a><span>|</span><a href="#42208318">next</a><span>|</span><label class="collapse" for="c-42204406">[-]</label><label class="expand" for="c-42204406">[1 more]</label></div><br/><div class="children"><div class="content">Yes, python and C also do not have properly statically typed errors.<p>In python, well, python&#x27;s a dynamically typed language so of course it doesn&#x27;t have statically typed exceptions.<p>&quot;a better type system than C&quot; is a really low bar.<p>Go should be held to a higher bar than that.</div><br/></div></div></div></div></div></div><div id="42208318" class="c"><input type="checkbox" id="c-42208318" checked=""/><div class="controls bullet"><span class="by">stouset</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42202378">prev</a><span>|</span><a href="#42202617">next</a><span>|</span><label class="collapse" for="c-42208318">[-]</label><label class="expand" for="c-42208318">[1 more]</label></div><br/><div class="children"><div class="content">Go didn&#x27;t have them at the time.<p>Pessimistically this is yet another example of the language&#x27;s authors relearning why other languages have the features they do one problem at a time.</div><br/></div></div><div id="42202617" class="c"><input type="checkbox" id="c-42202617" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42208318">prev</a><span>|</span><a href="#42202277">next</a><span>|</span><label class="collapse" for="c-42202617">[-]</label><label class="expand" for="c-42202617">[1 more]</label></div><br/><div class="children"><div class="content">Nobody teaches people to use them. There is no analog to &quot;catch most specific exceptions&quot; culture in other languages.</div><br/></div></div><div id="42202277" class="c"><input type="checkbox" id="c-42202277" checked=""/><div class="controls bullet"><span class="by">Svip</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202266">parent</a><span>|</span><a href="#42202617">prev</a><span>|</span><a href="#42205647">next</a><span>|</span><label class="collapse" for="c-42202277">[-]</label><label class="expand" for="c-42202277">[3 more]</label></div><br/><div class="children"><div class="content">The consumer didn&#x27;t, but the error in the example is typed, it&#x27;s called `MaxBytesError`.</div><br/><div id="42202292" class="c"><input type="checkbox" id="c-42202292" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202277">parent</a><span>|</span><a href="#42203341">next</a><span>|</span><label class="collapse" for="c-42202292">[-]</label><label class="expand" for="c-42202292">[1 more]</label></div><br/><div class="children"><div class="content">Matching the underlying type when using an interface never feels natural and is definitely the more foreign part of Go&#x27;s syntax to people who are not super proficient with it. Thus, they fall back on what they know - string comparison.</div><br/></div></div><div id="42203341" class="c"><input type="checkbox" id="c-42203341" checked=""/><div class="controls bullet"><span class="by">simiones</span><span>|</span><a href="#42202248">root</a><span>|</span><a href="#42202277">parent</a><span>|</span><a href="#42202292">prev</a><span>|</span><a href="#42205647">next</a><span>|</span><label class="collapse" for="c-42203341">[-]</label><label class="expand" for="c-42203341">[1 more]</label></div><br/><div class="children"><div class="content">Only since go 1.19. It was a stringy error since go 1.0 until then.</div><br/></div></div></div></div></div></div></div></div><div id="42205647" class="c"><input type="checkbox" id="c-42205647" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#42202248">prev</a><span>|</span><a href="#42208866">next</a><span>|</span><label class="collapse" for="c-42205647">[-]</label><label class="expand" for="c-42205647">[3 more]</label></div><br/><div class="children"><div class="content">At one job, I found a misspelling in an error message and fixing it only to discover that the web of dependencies on that misspelled text was so deep that it was impractical to fix and had to return to the misspelled text. It still bugs me.</div><br/><div id="42205763" class="c"><input type="checkbox" id="c-42205763" checked=""/><div class="controls bullet"><span class="by">forbiddenlake</span><span>|</span><a href="#42205647">parent</a><span>|</span><a href="#42207841">next</a><span>|</span><label class="collapse" for="c-42205763">[-]</label><label class="expand" for="c-42205763">[1 more]</label></div><br/><div class="children"><div class="content">Are you Phillip Hallam-Baker? :)<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HTTP_referer" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HTTP_referer</a></div><br/></div></div><div id="42207841" class="c"><input type="checkbox" id="c-42207841" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42205647">parent</a><span>|</span><a href="#42205763">prev</a><span>|</span><a href="#42208866">next</a><span>|</span><label class="collapse" for="c-42207841">[-]</label><label class="expand" for="c-42207841">[1 more]</label></div><br/><div class="children"><div class="content">At least in the post context there&#x27;s still time to fix &quot;Golang&quot;.</div><br/></div></div></div></div><div id="42208866" class="c"><input type="checkbox" id="c-42208866" checked=""/><div class="controls bullet"><span class="by">zaptheimpaler</span><span>|</span><a href="#42205647">prev</a><span>|</span><a href="#42206616">next</a><span>|</span><label class="collapse" for="c-42208866">[-]</label><label class="expand" for="c-42208866">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s sort of Hyrum&#x27;s Law but it&#x27;s really just Go being Go. The error could&#x27;ve been an enum type that could be changed with only a string replace for consumers. Instead they are using strings as types, so now you have no idea how consumers might rely on it. They could check the middle 6 chars of the error and break if you change it. It&#x27;s another terrible anachronistic design decision when better alternatives have been in use in other languages for decades. Early mistakes + inability to change things means you&#x27;re stuck forever.</div><br/><div id="42210992" class="c"><input type="checkbox" id="c-42210992" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#42208866">parent</a><span>|</span><a href="#42206616">next</a><span>|</span><label class="collapse" for="c-42210992">[-]</label><label class="expand" for="c-42210992">[1 more]</label></div><br/><div class="children"><div class="content">Yes, sadly, the comment is essentially incorrect. The strings were their official API in many cases.</div><br/></div></div></div></div><div id="42206616" class="c"><input type="checkbox" id="c-42206616" checked=""/><div class="controls bullet"><span class="by">adrianmsmith</span><span>|</span><a href="#42208866">prev</a><span>|</span><a href="#42206875">next</a><span>|</span><label class="collapse" for="c-42206616">[-]</label><label class="expand" for="c-42206616">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting that this law is the exact opposite of the Robustness Principle &#x2F; Postel&#x27;s Law.<p>&gt; be conservative in what you send, be liberal in what you accept<p>If you are liberal in what you accept, you&#x27;d better understand the ways in which you&#x27;ve been liberal, and document them (at least) internally, because you&#x27;re going to have to support all those ways forever, even after huge codebase changes, due to Hyrum&#x27;s Law.<p>I try to avoid creating APIs which are &quot;liberal in what they accept&quot; for exactly that reason.</div><br/><div id="42207433" class="c"><input type="checkbox" id="c-42207433" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#42206616">parent</a><span>|</span><a href="#42206875">next</a><span>|</span><label class="collapse" for="c-42207433">[-]</label><label class="expand" for="c-42207433">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I try to avoid creating APIs which are &quot;liberal in what they accept&quot; for exactly that reason.<p>That&#x27;s my preference too. When you have relaxed criteria about what kind of data you accept via an API I find you inevitably end up having to make decisions about how to massage that data in to some sort of canonical format, and those decisions almost always seem to end up leading to behaviour that&#x27;s surprising to users in one way or another.</div><br/></div></div></div></div><div id="42206875" class="c"><input type="checkbox" id="c-42206875" checked=""/><div class="controls bullet"><span class="by">jameson</span><span>|</span><a href="#42206616">prev</a><span>|</span><a href="#42205162">next</a><span>|</span><label class="collapse" for="c-42206875">[-]</label><label class="expand" for="c-42206875">[1 more]</label></div><br/><div class="children"><div class="content">what I learned from shipping APIs:<p>1. Clients will do whatever they need to do get their job done, even if it&#x27;s not the publisher&#x27;s intended way<p>2. Clients don&#x27;t read documentation<p>3. Bugs will become part of API once enough clients rely on their behavior<p>4. The number of API calls does not necessarily equate to importance.<p>---<p>As such, I aim for the following when developing an API<p>1. Ship the beta API early and see how they use it to minimize the surprise. (This may not always be possible)<p>2. In most cases, bump up the major version while supporting the previous version. This means you&#x27;ll need to define SLA for your API<p>3. Most clients are OK with breakages as long as they are given enough time to migrate, or the API provider gives them a tool to auto-migrate the code (if that&#x27;s possible in your product)</div><br/></div></div><div id="42205162" class="c"><input type="checkbox" id="c-42205162" checked=""/><div class="controls bullet"><span class="by">mox111</span><span>|</span><a href="#42206875">prev</a><span>|</span><a href="#42206474">next</a><span>|</span><label class="collapse" for="c-42205162">[-]</label><label class="expand" for="c-42205162">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps some package authors are more accepting of this than others. I stumbled upon this comment in the `json` package the other day:<p>&#x2F;&#x2F; isValidNumber reports whether s is a valid JSON number literal.
&#x2F;&#x2F;
&#x2F;&#x2F; isValidNumber should be an internal detail,
&#x2F;&#x2F; but widely used packages access it using linkname.
&#x2F;&#x2F; Notable members of the hall of shame include:
&#x2F;&#x2F;   - github.com&#x2F;bytedance&#x2F;sonic</div><br/></div></div><div id="42206474" class="c"><input type="checkbox" id="c-42206474" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#42205162">prev</a><span>|</span><a href="#42205424">next</a><span>|</span><label class="collapse" for="c-42206474">[-]</label><label class="expand" for="c-42206474">[1 more]</label></div><br/><div class="children"><div class="content">Many occurrences of Hyrum&#x27;s are &quot;desire paths[1]&quot; of APIs.  For many people, the most obvious way to determine if the error was a MaxBytesError was to check the string.  I&#x27;m not familiar with Go, but assuming it has RTTI, I&#x27;m guessing the intended path for people to take was to check the type of the error against MaxBytesError, and occurrences of this were people who either didn&#x27;t know that, or found the error string to be immediately available in their tooling, but the type not immediately available.<p>[edit]<p>Per [2], this looks desire paths is even more an apt analogy than I thought; until 3 years ago, this code returned a generic Error type.<p>1: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Desire_path" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Desire_path</a><p>2: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42202472">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42202472</a></div><br/></div></div><div id="42205424" class="c"><input type="checkbox" id="c-42205424" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#42206474">prev</a><span>|</span><a href="#42202267">next</a><span>|</span><label class="collapse" for="c-42205424">[-]</label><label class="expand" for="c-42205424">[1 more]</label></div><br/><div class="children"><div class="content">Another related effect of this is Protocol Ossification [0] which happens when implementers of a public API&#x2F;Protocol surface area take implicit dependencies on common but not standardized behaviors of the API&#x2F;Protocol implementation.<p>That being said, you can take proactive steps to defeat this. For example, the default Hash for strings in .NET is randomly seeded each time a process starts[1] in order to strongly dissuade folks from taking an implicit dependency on the underlying algorithm which is not guaranteed to be stable<p>[0] : <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Protocol_ossification" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Protocol_ossification</a><p>[1] : <a href="https:&#x2F;&#x2F;andrewlock.net&#x2F;why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core&#x2F;" rel="nofollow">https:&#x2F;&#x2F;andrewlock.net&#x2F;why-is-string-gethashcode-different-e...</a></div><br/></div></div><div id="42202267" class="c"><input type="checkbox" id="c-42202267" checked=""/><div class="controls bullet"><span class="by">turtleyacht</span><span>|</span><a href="#42205424">prev</a><span>|</span><a href="#42202259">next</a><span>|</span><label class="collapse" for="c-42202267">[-]</label><label class="expand" for="c-42202267">[1 more]</label></div><br/><div class="children"><div class="content">In Docker&#x27;s error response for `docker rmi&#x27;; the fifteenth word is &quot;container&quot; and the sixteenth is the container ID.</div><br/></div></div><div id="42202259" class="c"><input type="checkbox" id="c-42202259" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42202267">prev</a><span>|</span><a href="#42209775">next</a><span>|</span><label class="collapse" for="c-42202259">[-]</label><label class="expand" for="c-42202259">[6 more]</label></div><br/><div class="children"><div class="content">When I clicked on the link to codebases relying on the specific error string, I was expecting to see random side projects. Wasn&#x27;t expecting to see Grafana and Caddy on the list.</div><br/><div id="42203232" class="c"><input type="checkbox" id="c-42203232" checked=""/><div class="controls bullet"><span class="by">gwd</span><span>|</span><a href="#42202259">parent</a><span>|</span><a href="#42208907">next</a><span>|</span><label class="collapse" for="c-42203232">[-]</label><label class="expand" for="c-42203232">[2 more]</label></div><br/><div class="children"><div class="content">To be fair to those projects, the type was introduced only three years ago:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;pull&#x2F;49359&#x2F;files">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;pull&#x2F;49359&#x2F;files</a><p>Before that, doing a string compare was basically the only way to detect that specific error.  That was definitely an omission on the part of the original authors of the stdlib code; I don&#x27;t it should be classified as &quot;Hyrum&#x27;s Law&quot;.</div><br/><div id="42205108" class="c"><input type="checkbox" id="c-42205108" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42202259">root</a><span>|</span><a href="#42203232">parent</a><span>|</span><a href="#42208907">next</a><span>|</span><label class="collapse" for="c-42205108">[-]</label><label class="expand" for="c-42205108">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I don&#x27;t doubt it was the best option. Just a bit surprised.</div><br/></div></div></div></div><div id="42208907" class="c"><input type="checkbox" id="c-42208907" checked=""/><div class="controls bullet"><span class="by">mholt</span><span>|</span><a href="#42202259">parent</a><span>|</span><a href="#42203232">prev</a><span>|</span><a href="#42202363">next</a><span>|</span><label class="collapse" for="c-42208907">[-]</label><label class="expand" for="c-42208907">[1 more]</label></div><br/><div class="children"><div class="content">Hey Anders; Francis notified us of this today. I didn&#x27;t realize a proper type had been created. We&#x27;ll update our code.</div><br/></div></div><div id="42202363" class="c"><input type="checkbox" id="c-42202363" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#42202259">parent</a><span>|</span><a href="#42208907">prev</a><span>|</span><a href="#42209775">next</a><span>|</span><label class="collapse" for="c-42202363">[-]</label><label class="expand" for="c-42202363">[2 more]</label></div><br/><div class="children"><div class="content">Never underestimate the mediocrity of known large codebases, lol.<p>(just kidding, they&#x27;re not mediocre, but they&#x27;re not infallible or perfect either)</div><br/><div id="42205120" class="c"><input type="checkbox" id="c-42205120" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#42202259">root</a><span>|</span><a href="#42202363">parent</a><span>|</span><a href="#42209775">next</a><span>|</span><label class="collapse" for="c-42205120">[-]</label><label class="expand" for="c-42205120">[1 more]</label></div><br/><div class="children"><div class="content">This instance doesn&#x27;t necessarily indicate they did anything wrong. See sibling.</div><br/></div></div></div></div></div></div><div id="42209775" class="c"><input type="checkbox" id="c-42209775" checked=""/><div class="controls bullet"><span class="by">earthboundkid</span><span>|</span><a href="#42202259">prev</a><span>|</span><a href="#42209978">next</a><span>|</span><label class="collapse" for="c-42209775">[-]</label><label class="expand" for="c-42209775">[1 more]</label></div><br/><div class="children"><div class="content">I wrote &quot;&#x2F;&#x2F; Due to Hyrum&#x27;s law, this text cannot be changed.&quot; AMA.</div><br/></div></div><div id="42209978" class="c"><input type="checkbox" id="c-42209978" checked=""/><div class="controls bullet"><span class="by">rotbart</span><span>|</span><a href="#42209775">prev</a><span>|</span><a href="#42202147">next</a><span>|</span><label class="collapse" for="c-42209978">[-]</label><label class="expand" for="c-42209978">[1 more]</label></div><br/><div class="children"><div class="content">Hyrum&#x27;s Law especially applies when you have consumers of your APIs that violate Postel&#x27;s Law. To minimise those in the past, we&#x27;ve introduced intentional jitter in our API responses that while didn&#x27;t violate the schema prevented unintentional reliance on behaviour that wasn&#x27;t intentional[1].<p>[1]: &lt;<a href="https:&#x2F;&#x2F;medium.com&#x2F;pageup-tech&#x2F;update-on-driving-client-resiliency-how-we-enforced-postels-law-by-violating-postel-s-law-7cd51bf15baa" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;pageup-tech&#x2F;update-on-driving-client-resi...</a>&gt;</div><br/></div></div><div id="42202147" class="c"><input type="checkbox" id="c-42202147" checked=""/><div class="controls bullet"><span class="by">sudhirj</span><span>|</span><a href="#42209978">prev</a><span>|</span><a href="#42202600">next</a><span>|</span><label class="collapse" for="c-42202147">[-]</label><label class="expand" for="c-42202147">[9 more]</label></div><br/><div class="children"><div class="content">Weren’t there a couple of anecdotes where Windows couldn’t fix a bug because some popular game (maybe SimCity?) depended on it, so the devs hardcoded a SimCity check inside Windows and made the bug happen if it was running?</div><br/><div id="42202200" class="c"><input type="checkbox" id="c-42202200" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42202147">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42202200">[-]</label><label class="expand" for="c-42202200">[7 more]</label></div><br/><div class="children"><div class="content">It was not a bug in windows, it was a bug in SimCity: it would UAF some memory, but the Windows 3.x allocator did not unmap &#x2F; clear that memory so it worked.<p>Windows 95 changed that, and so one of the compatibility shims it got is that the allocator had a 3.x adjacent mode, which would be turned on when running SimCity (and probably other similarly misbehaving software as well).<p>Nowadays this is formalised in the <i>compatibility engine</i> (dating back to windows do), which can enable special modes or compatibility shims for applications (windows admins trying to run legacy or unmaintained applications can manage the application of compatibility modes via the “compatibility administrator”).</div><br/><div id="42202236" class="c"><input type="checkbox" id="c-42202236" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#42202147">root</a><span>|</span><a href="#42202200">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42202236">[-]</label><label class="expand" for="c-42202236">[6 more]</label></div><br/><div class="children"><div class="content">Still a pretty good example of having to support something which is definitely not part of the official spec.</div><br/><div id="42202413" class="c"><input type="checkbox" id="c-42202413" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42202147">root</a><span>|</span><a href="#42202236">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42202413">[-]</label><label class="expand" for="c-42202413">[5 more]</label></div><br/><div class="children"><div class="content">Had it been open source, they could have just fixed the software instead</div><br/><div id="42202453" class="c"><input type="checkbox" id="c-42202453" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42202147">root</a><span>|</span><a href="#42202413">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42202453">[-]</label><label class="expand" for="c-42202453">[4 more]</label></div><br/><div class="children"><div class="content">Fixing the upstream would not have updated it on the millions of machines running it, which is what they wanted to not break.</div><br/><div id="42205835" class="c"><input type="checkbox" id="c-42205835" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#42202147">root</a><span>|</span><a href="#42202453">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42205835">[-]</label><label class="expand" for="c-42205835">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Fixing the upstream would not have updated it on the millions of machines running it,<p>It was a very different world back then. You couldn&#x27;t even assume a dial-up connection.<p>Nowadays, the software would have been automatically updated for 99% of the machines running it, whether they wanted that update or not.</div><br/><div id="42205920" class="c"><input type="checkbox" id="c-42205920" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42202147">root</a><span>|</span><a href="#42205835">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42205920">[-]</label><label class="expand" for="c-42205920">[2 more]</label></div><br/><div class="children"><div class="content">Hah. Debian will happily keep shipping libraries years out of date. Then complain that you’re holding them back when they finally wake up and update sid to a bleeding edge release.</div><br/><div id="42211819" class="c"><input type="checkbox" id="c-42211819" checked=""/><div class="controls bullet"><span class="by">guappa</span><span>|</span><a href="#42202147">root</a><span>|</span><a href="#42205920">parent</a><span>|</span><a href="#42202221">next</a><span>|</span><label class="collapse" for="c-42211819">[-]</label><label class="expand" for="c-42211819">[1 more]</label></div><br/><div class="children"><div class="content">I feel like you have no idea on how debian works, but have read an article 25 years ago and are angry about that ever since.<p>The proof is this totally OT comment that doesn&#x27;t even make any sense :)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42202221" class="c"><input type="checkbox" id="c-42202221" checked=""/><div class="controls bullet"><span class="by">adontz</span><span>|</span><a href="#42202147">parent</a><span>|</span><a href="#42202200">prev</a><span>|</span><a href="#42202600">next</a><span>|</span><label class="collapse" for="c-42202221">[-]</label><label class="expand" for="c-42202221">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;05&#x2F;24&#x2F;strategy-letter-ii-chicken-and-egg-problems&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;05&#x2F;24&#x2F;strategy-letter-ii...</a><p>Jon Ross, who wrote the original version of SimCity for Windows 3.x, told me that he accidentally left a bug in SimCity where he read memory that he had just freed. Yep. It worked fine on Windows 3.x, because the memory never went anywhere. Here’s the amazing part: On beta versions of Windows 95, SimCity wasn’t working in testing. Microsoft tracked down the bug and added specific code to Windows 95 that looks for SimCity. If it finds SimCity running, it runs the memory allocator in a special mode that doesn’t free memory right away. That’s the kind of obsession with backward compatibility that made people willing to upgrade to Windows 95.</div><br/></div></div></div></div><div id="42205765" class="c"><input type="checkbox" id="c-42205765" checked=""/><div class="controls bullet"><span class="by">jgeada</span><span>|</span><a href="#42202600">prev</a><span>|</span><a href="#42202159">next</a><span>|</span><label class="collapse" for="c-42205765">[-]</label><label class="expand" for="c-42205765">[1 more]</label></div><br/><div class="children"><div class="content">I think Hyrum&#x27;s law really depends on APIs not applying consequences to people that depend on non-guaranteed behavior. The world needs more consequences for poor behavior.<p>Just randomly change the non-guaranteed stuff in every release and this behavior likely would stop and&#x2F;or you&#x27;d lose the users that don&#x27;t know any better. Both sides of that sound like a win to me.</div><br/></div></div><div id="42202159" class="c"><input type="checkbox" id="c-42202159" checked=""/><div class="controls bullet"><span class="by">praptak</span><span>|</span><a href="#42205765">prev</a><span>|</span><a href="#42207516">next</a><span>|</span><label class="collapse" for="c-42202159">[-]</label><label class="expand" for="c-42202159">[3 more]</label></div><br/><div class="children"><div class="content">Corollary: uptime is part of the defacto spec being relied on.<p>One of the SRE practices is breaking your service on purpose to bring the actual service level closer to what is promised and supported.</div><br/><div id="42202395" class="c"><input type="checkbox" id="c-42202395" checked=""/><div class="controls bullet"><span class="by">Cthulhu_</span><span>|</span><a href="#42202159">parent</a><span>|</span><a href="#42202376">next</a><span>|</span><label class="collapse" for="c-42202395">[-]</label><label class="expand" for="c-42202395">[1 more]</label></div><br/><div class="children"><div class="content">As another commenter pointed out, this is to a point what Go does as well; for example, map iteration is randomised so no implementation will rely on insertion order.</div><br/></div></div><div id="42202376" class="c"><input type="checkbox" id="c-42202376" checked=""/><div class="controls bullet"><span class="by">dangfault</span><span>|</span><a href="#42202159">parent</a><span>|</span><a href="#42202395">prev</a><span>|</span><a href="#42207516">next</a><span>|</span><label class="collapse" for="c-42202376">[-]</label><label class="expand" for="c-42202376">[1 more]</label></div><br/><div class="children"><div class="content">another one, you pay me below market rate and you get below market rate code</div><br/></div></div></div></div><div id="42207516" class="c"><input type="checkbox" id="c-42207516" checked=""/><div class="controls bullet"><span class="by">sublimefire</span><span>|</span><a href="#42202159">prev</a><span>|</span><a href="#42205921">next</a><span>|</span><label class="collapse" for="c-42207516">[-]</label><label class="expand" for="c-42207516">[1 more]</label></div><br/><div class="children"><div class="content">There are cases when you need to make a choice if you want to fix the bug as it might break many people who rely on it. There is no real good answer but to be able to look forward and anticipate the misuse.</div><br/></div></div><div id="42205921" class="c"><input type="checkbox" id="c-42205921" checked=""/><div class="controls bullet"><span class="by">souenzzo</span><span>|</span><a href="#42207516">prev</a><span>|</span><a href="#42205813">next</a><span>|</span><label class="collapse" for="c-42205921">[-]</label><label class="expand" for="c-42205921">[1 more]</label></div><br/><div class="children"><div class="content">Clojure manages to do improvement to the language, without breaking the users.<p>Most of improvements are &quot;additions&quot;, it is never a &quot;change&quot; or &quot;re-do something better&quot;<p>It is an awesome experience be able to upgrade the language anytime with no fear or pain.</div><br/></div></div><div id="42205813" class="c"><input type="checkbox" id="c-42205813" checked=""/><div class="controls bullet"><span class="by">inlined</span><span>|</span><a href="#42205921">prev</a><span>|</span><a href="#42206383">next</a><span>|</span><label class="collapse" for="c-42205813">[-]</label><label class="expand" for="c-42205813">[2 more]</label></div><br/><div class="children"><div class="content">Go seems really sensitive to this subject. Maps iterate in order, but one day they said “this is incidental and we said not to rely on it. You do, so we’re breaking it in a minor release” and now maps iterate in order… from a random offset</div><br/><div id="42209083" class="c"><input type="checkbox" id="c-42209083" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42205813">parent</a><span>|</span><a href="#42206383">next</a><span>|</span><label class="collapse" for="c-42209083">[-]</label><label class="expand" for="c-42209083">[1 more]</label></div><br/><div class="children"><div class="content">On the one hand, I never realized that map iteration order was consistent, but it&#x27;s just the starting point that changes. On the other hand, I guess there&#x27;s no other way to do it, since a proper shuffle would require O(n) bookkeeping. I suppose you could also flip a coin for going backwards too.</div><br/></div></div></div></div><div id="42206383" class="c"><input type="checkbox" id="c-42206383" checked=""/><div class="controls bullet"><span class="by">jnordwick</span><span>|</span><a href="#42205813">prev</a><span>|</span><a href="#42208903">next</a><span>|</span><label class="collapse" for="c-42206383">[-]</label><label class="expand" for="c-42206383">[1 more]</label></div><br/><div class="children"><div class="content">Does anybody else always read this as Hyrule&#x27;s Law?</div><br/></div></div><div id="42208903" class="c"><input type="checkbox" id="c-42208903" checked=""/><div class="controls bullet"><span class="by">andrewfromx</span><span>|</span><a href="#42206383">prev</a><span>|</span><a href="#42204177">next</a><span>|</span><label class="collapse" for="c-42208903">[-]</label><label class="expand" for="c-42208903">[1 more]</label></div><br/><div class="children"><div class="content">like <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HTTP_referer" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HTTP_referer</a> can&#x27;t be referrer ever</div><br/></div></div><div id="42204177" class="c"><input type="checkbox" id="c-42204177" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#42208903">prev</a><span>|</span><a href="#42207183">next</a><span>|</span><label class="collapse" for="c-42204177">[-]</label><label class="expand" for="c-42204177">[1 more]</label></div><br/><div class="children"><div class="content">At work we have a data providers whose API always returns 200, often with the text content “ERROR: …”<p>And that’s how put Hyrums law into effect.</div><br/></div></div><div id="42207183" class="c"><input type="checkbox" id="c-42207183" checked=""/><div class="controls bullet"><span class="by">evanfarrar</span><span>|</span><a href="#42204177">prev</a><span>|</span><a href="#42202977">next</a><span>|</span><label class="collapse" for="c-42207183">[-]</label><label class="expand" for="c-42207183">[2 more]</label></div><br/><div class="children"><div class="content">What do they call the law that says they can’t increase the major version?</div><br/><div id="42207452" class="c"><input type="checkbox" id="c-42207452" checked=""/><div class="controls bullet"><span class="by">remus</span><span>|</span><a href="#42207183">parent</a><span>|</span><a href="#42202977">next</a><span>|</span><label class="collapse" for="c-42207452">[-]</label><label class="expand" for="c-42207452">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Guido&#x27;s Law&quot; perhaps?</div><br/></div></div></div></div><div id="42202977" class="c"><input type="checkbox" id="c-42202977" checked=""/><div class="controls bullet"><span class="by">sixfiveotwo</span><span>|</span><a href="#42207183">prev</a><span>|</span><a href="#42202494">next</a><span>|</span><label class="collapse" for="c-42202977">[-]</label><label class="expand" for="c-42202977">[2 more]</label></div><br/><div class="children"><div class="content">Quite interesting, thank you.<p>However, in this specific instance, even if the text cannot be changed, couldn&#x27;t the error itself in the server be processed and signaled differently, eg. by returning a Status Code 413[1], since clients ought to recognize that status code anyway?<p>[1]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Status&#x2F;413" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTTP&#x2F;Status&#x2F;413</a></div><br/><div id="42203665" class="c"><input type="checkbox" id="c-42203665" checked=""/><div class="controls bullet"><span class="by">majewsky</span><span>|</span><a href="#42202977">parent</a><span>|</span><a href="#42202494">next</a><span>|</span><label class="collapse" for="c-42203665">[-]</label><label class="expand" for="c-42203665">[1 more]</label></div><br/><div class="children"><div class="content">Since the caller gets this as an error object, instead of as a plain string, it seems likely that this is within the same process, i.e. a library function returns the MaxBytesError to a level higher in the business logic, without a network transmission inbetween.</div><br/></div></div></div></div><div id="42202494" class="c"><input type="checkbox" id="c-42202494" checked=""/><div class="controls bullet"><span class="by">voiper1</span><span>|</span><a href="#42202977">prev</a><span>|</span><label class="collapse" for="c-42202494">[-]</label><label class="expand" for="c-42202494">[1 more]</label></div><br/><div class="children"><div class="content">Related XKCD: <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>