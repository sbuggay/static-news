<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706691660760" as="style"/><link rel="stylesheet" href="styles.css?v=1706691660760"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.kravchyk.com/adding-type-safety-to-object-ids-typescript/">Adding type safety to object IDs in TypeScript</a> <span class="domain">(<a href="https://www.kravchyk.com">www.kravchyk.com</a>)</span></div><div class="subtext"><span>mckravchyk</span> | <span>43 comments</span></div><br/><div><div id="39195608" class="c"><input type="checkbox" id="c-39195608" checked=""/><div class="controls bullet"><span class="by">headbee</span><span>|</span><a href="#39199814">next</a><span>|</span><label class="collapse" for="c-39195608">[-]</label><label class="expand" for="c-39195608">[14 more]</label></div><br/><div class="children"><div class="content">This is pretty close to type branding (newtype wrapping for the Haskell-inclined), though using template literal types is pretty novel. Normal brands look something like this:<p><pre><code>    type Brand&lt;BaseType, Brand&gt; = BaseType &amp; { readonly __brand__: Brand };
    type FooId = Brand&lt;string, &#x27;FooId&#x27;&gt;;
    function fooBar(asdf: FooId | &#x27;foobar&#x27;): void { }
</code></pre>
fooBar will only accept the literal string &#x27;foobar&#x27; or a true FooId, but not any arbitrary string. FooId would then come from a function that validates strings as FooIds, or some other part of the app that is an authoritative source for them. Brands extend their BaseType so they can be used anywhere their BaseType is used, but not the inverse</div><br/><div id="39195959" class="c"><input type="checkbox" id="c-39195959" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#39195608">parent</a><span>|</span><a href="#39196607">next</a><span>|</span><label class="collapse" for="c-39195959">[-]</label><label class="expand" for="c-39195959">[3 more]</label></div><br/><div class="children"><div class="content">If you want to make this easier to keep private between encapsulation boundaries the additional suggestion is make sure the Brand type extends symbol:<p><pre><code>    type Brand&lt;BaseType, Brand extends symbol&gt; = BaseType &amp; { readonly __brand__: Brand };
    const FooIdBrand = Symbol(&#x27;FooId&#x27;);
    type FooId = Brand&lt;string, typeof FooIdBrand&gt;;
    function fooBar(asdf: FooId | &#x27;foobar&#x27;): void { }
</code></pre>
Using a private shared symbol your authoritative validation&#x2F;sources can share your brand symbol and no one else can create one without using your validation. Private symbol brands in this way become the closest Typescript gets to &quot;nominal types&quot;.</div><br/><div id="39200117" class="c"><input type="checkbox" id="c-39200117" checked=""/><div class="controls bullet"><span class="by">jwalton</span><span>|</span><a href="#39195608">root</a><span>|</span><a href="#39195959">parent</a><span>|</span><a href="#39196607">next</a><span>|</span><label class="collapse" for="c-39200117">[-]</label><label class="expand" for="c-39200117">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately this doesn’t work, at least not from a type safety perspective, because even without access to the symbol, nothing stops anyone from doing `let myFooId = &#x27;foo&#x27; as any as FooId;`. You could detect this at runtime, but type safety is compile time.</div><br/><div id="39200598" class="c"><input type="checkbox" id="c-39200598" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#39195608">root</a><span>|</span><a href="#39200117">parent</a><span>|</span><a href="#39196607">next</a><span>|</span><label class="collapse" for="c-39200598">[-]</label><label class="expand" for="c-39200598">[1 more]</label></div><br/><div class="children"><div class="content">Sure, the TS type system is not sound but the idea is not to stop &quot;bad guys&quot;, it&#x27;s to help you realize you are doing something unintended.</div><br/></div></div></div></div></div></div><div id="39196607" class="c"><input type="checkbox" id="c-39196607" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#39195608">parent</a><span>|</span><a href="#39195959">prev</a><span>|</span><a href="#39196673">next</a><span>|</span><label class="collapse" for="c-39196607">[-]</label><label class="expand" for="c-39196607">[3 more]</label></div><br/><div class="children"><div class="content">The easiest way I know of is<p><pre><code>    declare const isMyID: unique symbol;
    export type MyID = string &amp; { [isMyID]: true };</code></pre></div><br/><div id="39201511" class="c"><input type="checkbox" id="c-39201511" checked=""/><div class="controls bullet"><span class="by">bassdigit</span><span>|</span><a href="#39195608">root</a><span>|</span><a href="#39196607">parent</a><span>|</span><a href="#39197523">next</a><span>|</span><label class="collapse" for="c-39201511">[-]</label><label class="expand" for="c-39201511">[1 more]</label></div><br/><div class="children"><div class="content">nice!</div><br/></div></div></div></div><div id="39196673" class="c"><input type="checkbox" id="c-39196673" checked=""/><div class="controls bullet"><span class="by">lf-non</span><span>|</span><a href="#39195608">parent</a><span>|</span><a href="#39196607">prev</a><span>|</span><a href="#39199711">next</a><span>|</span><label class="collapse" for="c-39196673">[-]</label><label class="expand" for="c-39196673">[1 more]</label></div><br/><div class="children"><div class="content">It is also convenient to use a unique symbol for the brand (declare const brand: unique symbol). Then we can combine multiple brands in the same type and if we don&#x27;t export that symbol type, we simply dont have a way to access the brand property at runtime.</div><br/></div></div><div id="39199711" class="c"><input type="checkbox" id="c-39199711" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39195608">parent</a><span>|</span><a href="#39196673">prev</a><span>|</span><a href="#39195888">next</a><span>|</span><label class="collapse" for="c-39199711">[-]</label><label class="expand" for="c-39199711">[3 more]</label></div><br/><div class="children"><div class="content">In my experience branded types are relatively more fragile than normal types though. IIRC they badly behaved with infer types in particular, and it was quite hard to work around. This solution seems more versatile. (Of course, I want to see a built-in branded type support in TS as well.)</div><br/><div id="39199870" class="c"><input type="checkbox" id="c-39199870" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#39195608">root</a><span>|</span><a href="#39199711">parent</a><span>|</span><a href="#39195888">next</a><span>|</span><label class="collapse" for="c-39199870">[-]</label><label class="expand" for="c-39199870">[2 more]</label></div><br/><div class="children"><div class="content">This solution only works with strings, whereas branded types can be used with numbers as well, or any kind of object that you want to add stricter types to without modifying the runtime value.<p>I haven&#x27;t observed any issues with branded types and infer—is there documentation somewhere about the problem?</div><br/><div id="39200383" class="c"><input type="checkbox" id="c-39200383" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#39195608">root</a><span>|</span><a href="#39199870">parent</a><span>|</span><a href="#39195888">next</a><span>|</span><label class="collapse" for="c-39200383">[-]</label><label class="expand" for="c-39200383">[1 more]</label></div><br/><div class="children"><div class="content">As others pointed out, TypeScript <i>sometimes</i> reasons `string &amp; object` or similar as an impossible type and can turn it into `never` at any time. I don&#x27;t exactly recall whether `infer` triggered that or it was a separate issue, but that was a major problem in my experience.</div><br/></div></div></div></div></div></div><div id="39195888" class="c"><input type="checkbox" id="c-39195888" checked=""/><div class="controls bullet"><span class="by">blue_pants</span><span>|</span><a href="#39195608">parent</a><span>|</span><a href="#39199711">prev</a><span>|</span><a href="#39195732">next</a><span>|</span><label class="collapse" for="c-39195888">[-]</label><label class="expand" for="c-39195888">[1 more]</label></div><br/><div class="children"><div class="content">The meaning is different though. Brands convey intent, UserId brand would allow only other UserId brands, but with string literal types &quot;any&quot; type that matches &#x27;user_${string}&#x27; will do</div><br/></div></div><div id="39195732" class="c"><input type="checkbox" id="c-39195732" checked=""/><div class="controls bullet"><span class="by">ssalka</span><span>|</span><a href="#39195608">parent</a><span>|</span><a href="#39195888">prev</a><span>|</span><a href="#39199814">next</a><span>|</span><label class="collapse" for="c-39195732">[-]</label><label class="expand" for="c-39195732">[2 more]</label></div><br/><div class="children"><div class="content">I prefer the Brand solution, it works well for existing ID sets that you can&#x27;t easily migrate to have an actual string prefix</div><br/><div id="39196681" class="c"><input type="checkbox" id="c-39196681" checked=""/><div class="controls bullet"><span class="by">throwanem</span><span>|</span><a href="#39195608">root</a><span>|</span><a href="#39195732">parent</a><span>|</span><a href="#39199814">next</a><span>|</span><label class="collapse" for="c-39196681">[-]</label><label class="expand" for="c-39196681">[1 more]</label></div><br/><div class="children"><div class="content">Also for values that aren&#x27;t strings at all.</div><br/></div></div></div></div></div></div><div id="39199814" class="c"><input type="checkbox" id="c-39199814" checked=""/><div class="controls bullet"><span class="by">DanHulton</span><span>|</span><a href="#39195608">prev</a><span>|</span><a href="#39196903">next</a><span>|</span><label class="collapse" for="c-39199814">[-]</label><label class="expand" for="c-39199814">[1 more]</label></div><br/><div class="children"><div class="content">If you want a type-prefixed UUIDv7 type, I can wholeheartedly recommend TypeID-JS: <a href="https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;typeid-js">https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;typeid-js</a><p>Also available for a whole bunch of other languages: <a href="https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;typeid">https:&#x2F;&#x2F;github.com&#x2F;jetpack-io&#x2F;typeid</a><p>UUIDv7 is UUIDv4-compatible (i.e. you can put a v7 UUID anywhere a v4 UUID would go, like in Postgres&#x27;s UUID datatype) and is time-series sortable, so you don&#x27;t lose that nice lil&#x27; benefit of auto-incrementing IDs.<p>And if you use something like TypeORM to define your entities, you can use a Transformer to save as plain UUIDv7 in the DB (so you can use UUID datatypes, not strings), but deal with them as type-prefixed strings everywhere else:<p><pre><code>    export const TYPEID_USER = &#x27;user&#x27;;

    export type UserTypeID = TypeID&lt;&#x27;user&#x27;&gt;;
    
    export type UserTypeString = `user_${string}`;
    
    export class UserIdTransformer implements ValueTransformer {
      from(uuid: string): UserTypeID {
        return TypeID.fromUUID(TYPEID_USER, uuid);
      }
    
      to(tid: UserTypeID): string {
        assert.equal(
          tid.getType(),
          TYPEID_USER,
          `Invalid user ID: &#x27;${tid.toString()}&#x27;.`,
        );
    
        return tid.toUUID();
      }
    }
    
    @Entity()
    export class User {
      @PrimaryColumn({
        type: &#x27;uuid&#x27;,
        primaryKeyConstraintName: &#x27;user_pkey&#x27;,
        transformer: new UserIdTransformer(),
      })
      id: UserTypeID;
    
      @BeforeInsert()
      createNewPrimaryKey() {
        this.id = typeid(TYPEID_USER);
      }
    }</code></pre></div><br/></div></div><div id="39196903" class="c"><input type="checkbox" id="c-39196903" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39199814">prev</a><span>|</span><a href="#39195145">next</a><span>|</span><label class="collapse" for="c-39196903">[-]</label><label class="expand" for="c-39196903">[5 more]</label></div><br/><div class="children"><div class="content">Its bit sad that startsWith doesn&#x27;t narrow the type, making this pattern slightly less convenient. The GH issue: <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;46958">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;46958</a></div><br/><div id="39198335" class="c"><input type="checkbox" id="c-39198335" checked=""/><div class="controls bullet"><span class="by">DylanSp</span><span>|</span><a href="#39196903">parent</a><span>|</span><a href="#39196995">next</a><span>|</span><label class="collapse" for="c-39198335">[-]</label><label class="expand" for="c-39198335">[1 more]</label></div><br/><div class="children"><div class="content">I wish that TS had better type narrowing for the JS standard library, though there&#x27;s a lot of constraints and design limitations that make it impractical. I ran into a similar issue with the some() method on Array not narrowing types a while back [1]; that issue links to the same sort of issue with filter(), as well as issues where the TS team has discussed what they can and can&#x27;t do in control flow analysis.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;40844">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;issues&#x2F;40844</a></div><br/></div></div><div id="39196995" class="c"><input type="checkbox" id="c-39196995" checked=""/><div class="controls bullet"><span class="by">mattigames</span><span>|</span><a href="#39196903">parent</a><span>|</span><a href="#39198335">prev</a><span>|</span><a href="#39195145">next</a><span>|</span><label class="collapse" for="c-39196995">[-]</label><label class="expand" for="c-39196995">[3 more]</label></div><br/><div class="children"><div class="content">What is the problem with the workaround suggested in the last comment there?</div><br/><div id="39198701" class="c"><input type="checkbox" id="c-39198701" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#39196903">root</a><span>|</span><a href="#39196995">parent</a><span>|</span><a href="#39197355">next</a><span>|</span><label class="collapse" for="c-39198701">[-]</label><label class="expand" for="c-39198701">[1 more]</label></div><br/><div class="children"><div class="content">Define a type guard using a &quot;type predicate&quot;[1].<p>For example:<p><pre><code>    type UserId = `user_${string}`;
    type GroupId = `group_${string}`;

    const addUserId = (id: UserId) =&gt; {
      &#x2F;&#x2F; do something
    }

    const processId = (id: string) =&gt; {
      if (id.startsWith(&#x27;user_&#x27;) {
        &#x2F;&#x2F; type error here:
        addUserId(id);
      } else if (otherCondition)
        &#x2F;&#x2F; do other things
      }
    }
</code></pre>
Instead you define a function:<p><pre><code>    const isUserId = (some: string): some is UserId =&gt; some.startsWith(&#x27;user_&#x27;);
</code></pre>
Now you can use it as follows:<p><pre><code>    const processId = (id: string) =&gt; {
      if (isUserId(id)) {
        &#x2F;&#x2F; no more error:
        addUserId(id);
      } else if (otherCondition)
        &#x2F;&#x2F; do other things
      }
    }
</code></pre>
[1]: <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.html#using-type-predicates" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;docs&#x2F;handbook&#x2F;2&#x2F;narrowing.htm...</a></div><br/></div></div><div id="39197355" class="c"><input type="checkbox" id="c-39197355" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#39196903">root</a><span>|</span><a href="#39196995">parent</a><span>|</span><a href="#39198701">prev</a><span>|</span><a href="#39195145">next</a><span>|</span><label class="collapse" for="c-39197355">[-]</label><label class="expand" for="c-39197355">[1 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t need to write this kind of thing manually for every such type.</div><br/></div></div></div></div></div></div><div id="39195145" class="c"><input type="checkbox" id="c-39195145" checked=""/><div class="controls bullet"><span class="by">sisve</span><span>|</span><a href="#39196903">prev</a><span>|</span><a href="#39197232">next</a><span>|</span><label class="collapse" for="c-39195145">[-]</label><label class="expand" for="c-39195145">[1 more]</label></div><br/><div class="children"><div class="content">Stripe does this (prefix ids with object type). Its smart. Makes it much easier to work with the ids.</div><br/></div></div><div id="39197232" class="c"><input type="checkbox" id="c-39197232" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#39195145">prev</a><span>|</span><a href="#39195456">next</a><span>|</span><label class="collapse" for="c-39197232">[-]</label><label class="expand" for="c-39197232">[2 more]</label></div><br/><div class="children"><div class="content">I’ve done this in multiple languages.  I dislike libraries that return string ids.<p>The proliferation of string identifiers is a pet peeve of mine. It’s what I call “stringly typed” code (not my coinage but I use it all the time).</div><br/><div id="39200649" class="c"><input type="checkbox" id="c-39200649" checked=""/><div class="controls bullet"><span class="by">kristiandupont</span><span>|</span><a href="#39197232">parent</a><span>|</span><a href="#39195456">next</a><span>|</span><label class="collapse" for="c-39200649">[-]</label><label class="expand" for="c-39200649">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Stringly typed&quot;, the way I&#x27;ve heard it, is a valid criticism when people replace type safety with magic strings which may or may not be checked at runtime but certainly not at compile time.<p>However, that&#x27;s not the case when it comes to Typescript, because literal and union string types are actually checked at compile time. So what is the problem?</div><br/></div></div></div></div><div id="39195456" class="c"><input type="checkbox" id="c-39195456" checked=""/><div class="controls bullet"><span class="by">matthewfcarlson</span><span>|</span><a href="#39197232">prev</a><span>|</span><a href="#39197613">next</a><span>|</span><label class="collapse" for="c-39195456">[-]</label><label class="expand" for="c-39195456">[1 more]</label></div><br/><div class="children"><div class="content">I love this approach but I augment it with Zod branded types. IDs have a known start to their identifier and anything coming in and out of the database is verified match a schema</div><br/></div></div><div id="39197613" class="c"><input type="checkbox" id="c-39197613" checked=""/><div class="controls bullet"><span class="by">sophiabits</span><span>|</span><a href="#39195456">prev</a><span>|</span><a href="#39198250">next</a><span>|</span><label class="collapse" for="c-39197613">[-]</label><label class="expand" for="c-39197613">[3 more]</label></div><br/><div class="children"><div class="content">Type-prefixed IDs are the way to go. For completeness it&#x27;s worth noting that the first example using the `string | &#x27;currentNode&#x27;` type can be slightly improved  in cases where you _do_ want autocomplete for known-good values but are still OK with accepting arbitrary string values:<p><pre><code>  type Target = &#x27;currentNode&#x27; | (string &amp; {});
  const targets: Target[] = [
    &#x27;currentNode&#x27;, &#x2F;&#x2F; you get autocomplete hints for this!
    &#x27;somethingElse&#x27;, &#x2F;&#x2F; no autocomplete here, but it typechecks
  ];</code></pre></div><br/><div id="39197657" class="c"><input type="checkbox" id="c-39197657" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#39197613">parent</a><span>|</span><a href="#39198250">next</a><span>|</span><label class="collapse" for="c-39197657">[-]</label><label class="expand" for="c-39197657">[2 more]</label></div><br/><div class="children"><div class="content">Is (string &amp; {}) semantically intuitive or is it kind of a hack? I don’t understand what it’s supposed to mean.</div><br/><div id="39198062" class="c"><input type="checkbox" id="c-39198062" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39197613">root</a><span>|</span><a href="#39197657">parent</a><span>|</span><a href="#39198250">next</a><span>|</span><label class="collapse" for="c-39198062">[-]</label><label class="expand" for="c-39198062">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a useful hack. In JavaScript, there is no value that&#x27;s both a string and an object. At runtime, it will just be a string. You can use it like a string and it will type-check, because it&#x27;s a string plus some extra compile-time baggage, sort of like you subclassed the string type. (&#x27;&amp;&#x27; is a subtype operation.)<p>When converting something to this type, it will fail unless you cast it, but it&#x27;s a compile-time cast. At runtime, there&#x27;s no conversion.<p>This is essentially &quot;lying&quot; to the type checker in order to extend it.</div><br/></div></div></div></div></div></div><div id="39198250" class="c"><input type="checkbox" id="c-39198250" checked=""/><div class="controls bullet"><span class="by">tinrab</span><span>|</span><a href="#39197613">prev</a><span>|</span><a href="#39199194">next</a><span>|</span><label class="collapse" for="c-39198250">[-]</label><label class="expand" for="c-39198250">[1 more]</label></div><br/><div class="children"><div class="content">I like using &quot;resource names&quot; defined by Google&#x27;s AIP (<a href="https:&#x2F;&#x2F;google.aip.dev&#x2F;122" rel="nofollow">https:&#x2F;&#x2F;google.aip.dev&#x2F;122</a>). For example, the name &quot;users&#x2F;1&#x2F;projects&#x2F;42&quot; is a nested project resource of a user &quot;users&#x2F;1&quot;. TypeScript type could be &quot;users&#x2F;${number}&quot;.</div><br/></div></div><div id="39199194" class="c"><input type="checkbox" id="c-39199194" checked=""/><div class="controls bullet"><span class="by">hallman76</span><span>|</span><a href="#39198250">prev</a><span>|</span><a href="#39199919">next</a><span>|</span><label class="collapse" for="c-39199194">[-]</label><label class="expand" for="c-39199194">[4 more]</label></div><br/><div class="children"><div class="content">Has anyone tried using custom types for ids in java?<p>I considered doing it on a recent project, but it doesn&#x27;t seem very common so I was reluctant to introduce it.</div><br/><div id="39199906" class="c"><input type="checkbox" id="c-39199906" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#39199194">parent</a><span>|</span><a href="#39199229">next</a><span>|</span><label class="collapse" for="c-39199906">[-]</label><label class="expand" for="c-39199906">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done it in Kotlin, and I suspect that modern Java should be quite amenable to it with records.<p>It was really nice in my Kotlin project because we were dealing with legacy data structures with very confusing names—being able to guarantee that a UserID doesn&#x27;t accidentally get passed where a UserDataID was expected helped prevent a lot of the bugs that plagued the legacy apps.</div><br/><div id="39201476" class="c"><input type="checkbox" id="c-39201476" checked=""/><div class="controls bullet"><span class="by">diarrhea</span><span>|</span><a href="#39199194">root</a><span>|</span><a href="#39199906">parent</a><span>|</span><a href="#39199229">next</a><span>|</span><label class="collapse" for="c-39201476">[-]</label><label class="expand" for="c-39201476">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s great to hear. We did the same, but in C#, using its records. The codebase didn&#x27;t exactly suffer from errors from ID misuse (all of which were the same type beforehand), but it&#x27;s great for future-proofing as well.<p>Added benefit, as always when leaning into the type system more, is a reduction in the number of unit tests required. The need to test that `update_user(group_id)` fails (because a non-user ID was passed) simply disappears.</div><br/></div></div></div></div><div id="39199229" class="c"><input type="checkbox" id="c-39199229" checked=""/><div class="controls bullet"><span class="by">sd9</span><span>|</span><a href="#39199194">parent</a><span>|</span><a href="#39199906">prev</a><span>|</span><a href="#39199919">next</a><span>|</span><label class="collapse" for="c-39199229">[-]</label><label class="expand" for="c-39199229">[1 more]</label></div><br/><div class="children"><div class="content">I’ve done it. There’s little cost, but it does feel unidiomatic in Java for some reason.<p>Not sure whether I’d do it again or not. It’s hard to say how much benefit that I’m getting out of them.</div><br/></div></div></div></div><div id="39199919" class="c"><input type="checkbox" id="c-39199919" checked=""/><div class="controls bullet"><span class="by">ken47</span><span>|</span><a href="#39199194">prev</a><span>|</span><a href="#39197035">next</a><span>|</span><label class="collapse" for="c-39199919">[-]</label><label class="expand" for="c-39199919">[1 more]</label></div><br/><div class="children"><div class="content">Typescript is a work of art created on a barren canvas. Kudos to the team behind this language.</div><br/></div></div><div id="39197035" class="c"><input type="checkbox" id="c-39197035" checked=""/><div class="controls bullet"><span class="by">rckt</span><span>|</span><a href="#39199919">prev</a><span>|</span><a href="#39196157">next</a><span>|</span><label class="collapse" for="c-39197035">[-]</label><label class="expand" for="c-39197035">[2 more]</label></div><br/><div class="children"><div class="content">Not sure if it’s a valid point, but what I would like to have - kind of a regex or a template for strings or numbers. Otherwise, it’s still just a sting or a specific value. It’s not like you are free to update backend to prefix ids to your liking. Most of the time you have to work with set schemas.</div><br/><div id="39197244" class="c"><input type="checkbox" id="c-39197244" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#39197035">parent</a><span>|</span><a href="#39196157">next</a><span>|</span><label class="collapse" for="c-39197244">[-]</label><label class="expand" for="c-39197244">[1 more]</label></div><br/><div class="children"><div class="content">API models like Smithy can do that.</div><br/></div></div></div></div><div id="39196157" class="c"><input type="checkbox" id="c-39196157" checked=""/><div class="controls bullet"><span class="by">jakubmazanec</span><span>|</span><a href="#39197035">prev</a><span>|</span><a href="#39195232">next</a><span>|</span><label class="collapse" for="c-39196157">[-]</label><label class="expand" for="c-39196157">[1 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;type-fest&#x2F;blob&#x2F;main&#x2F;source&#x2F;opaque.d.ts">https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;type-fest&#x2F;blob&#x2F;main&#x2F;source&#x2F;o...</a></div><br/></div></div><div id="39195232" class="c"><input type="checkbox" id="c-39195232" checked=""/><div class="controls bullet"><span class="by">sagia</span><span>|</span><a href="#39196157">prev</a><span>|</span><a href="#39196126">next</a><span>|</span><label class="collapse" for="c-39195232">[-]</label><label class="expand" for="c-39195232">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if a similar (but maybe more bloated) implementation using interfaces (and probably generics too?) will work in this case.</div><br/><div id="39196654" class="c"><input type="checkbox" id="c-39196654" checked=""/><div class="controls bullet"><span class="by">jeroenhd</span><span>|</span><a href="#39195232">parent</a><span>|</span><a href="#39196126">next</a><span>|</span><label class="collapse" for="c-39196654">[-]</label><label class="expand" for="c-39196654">[1 more]</label></div><br/><div class="children"><div class="content">Something like this, maybe?<p><a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play?#code&#x2F;C4TwDgpgBAkgIlAvFAcgVwLYCMICcDcAUIQJYB2weAZgIYDG0AqgM57xQDehUUokAXFADkaVriEAablBIATQfEIBfYuUq5aDKAHFcAezRh2XHnwiChAc32HJ0uQrjLiVNGTrASeslEOyalCx4ABSieIJBuPAAlJzSdN7MegA2EAB0shBYaJahYmly0UQqhKnAUNYGYEhxpuDmwpW2UjwOUACMAEwAzAAsAKzOhH4BEJHBTWBFQA" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play?#code&#x2F;C4TwDgpgBAkgIlAvFA...</a><p>Alternatively, with generics: <a href="https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play?#code&#x2F;JYOwLgpgTgZghgYwgAgKoGdoEkAiAeXAFQE8AHCAPmQG8AoZZMMiALmQHIBXTKdgGnrJgAEzZFmtAL61aoSLEQoA4lAD2nUrgI4S5KnQZNybdgHM1G-oJFidE6bRicQCMMFUhkG4XEgZoeIQUABTc0Gz+UFpBAJQ0ggge6KoANhAAdMIQAEacpqE86SIxANxSMmlgyObqpMgAvPGGzCY1lgIMNsgAjABMAMwALACs5bTevhCRwW2kpUA" rel="nofollow">https:&#x2F;&#x2F;www.typescriptlang.org&#x2F;play?#code&#x2F;JYOwLgpgTgZghgYwgA...</a><p>I don&#x27;t think these are better, to be honest. The string types suffice and are easier to exchange with servers and other APIs.</div><br/></div></div></div></div><div id="39196126" class="c"><input type="checkbox" id="c-39196126" checked=""/><div class="controls bullet"><span class="by">jannes</span><span>|</span><a href="#39195232">prev</a><span>|</span><a href="#39198060">next</a><span>|</span><label class="collapse" for="c-39196126">[-]</label><label class="expand" for="c-39196126">[2 more]</label></div><br/><div class="children"><div class="content">Reminds me of Slack IDs:<p>- Channel IDs always start with C<p>- User IDs always start with U</div><br/><div id="39200046" class="c"><input type="checkbox" id="c-39200046" checked=""/><div class="controls bullet"><span class="by">vvpan</span><span>|</span><a href="#39196126">parent</a><span>|</span><a href="#39198060">next</a><span>|</span><label class="collapse" for="c-39200046">[-]</label><label class="expand" for="c-39200046">[1 more]</label></div><br/><div class="children"><div class="content">Stripe also follows similar conventions - very convenient.</div><br/></div></div></div></div><div id="39195650" class="c"><input type="checkbox" id="c-39195650" checked=""/><div class="controls bullet"><span class="by">snowstormsun</span><span>|</span><a href="#39198060">prev</a><span>|</span><label class="collapse" for="c-39195650">[-]</label><label class="expand" for="c-39195650">[1 more]</label></div><br/><div class="children"><div class="content">Nice!</div><br/></div></div></div></div></div></div></div></body></html>