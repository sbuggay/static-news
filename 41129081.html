<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722934862187" as="style"/><link rel="stylesheet" href="styles.css?v=1722934862187"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://djharper.dev/post/2019/05/21/i-dont-know-how-cpus-work-so-i-simulated-one-in-code/">I don&#x27;t know how CPUs work so I simulated one in code (2019)</a> <span class="domain">(<a href="https://djharper.dev">djharper.dev</a>)</span></div><div class="subtext"><span>azefiel</span> | <span>31 comments</span></div><br/><div><div id="41166006" class="c"><input type="checkbox" id="c-41166006" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41168861">next</a><span>|</span><label class="collapse" for="c-41166006">[-]</label><label class="expand" for="c-41166006">[11 more]</label></div><br/><div class="children"><div class="content">So, what this project misses, which is quite hard to capture if you think of gates being just on off switches, is the fact that signals are not instantaneous, and everything runs in parallel.<p>As the AND gate 4 gates up the chain switches the NOT gate 4 gates down the chain starts to send different and unstable signals which may or may not be interpreted as a 1 or 0 in the downstream gate.<p>That&#x27;s the reason computers have a clock, to make sure all transistors in a given stage of a CPU reach a steady state before moving on to the next instruction.<p>This is why it&#x27;s probably a good idea to work with a HDL instead of just trying to wing it.</div><br/><div id="41166468" class="c"><input type="checkbox" id="c-41166468" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#41166006">parent</a><span>|</span><a href="#41166524">next</a><span>|</span><label class="collapse" for="c-41166468">[-]</label><label class="expand" for="c-41166468">[2 more]</label></div><br/><div class="children"><div class="content">The game Silicon Zeroes ( <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;684270&#x2F;Silicon_Zeroes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;684270&#x2F;Silicon_Zeroes&#x2F;</a> ) teaches this. It starts out with components computing their outputs instantaneously, but then introduces the concept of microticks such that the output of a component is unstable until its inputs are stable enough for some time, so the clock speed must be adjusted according to the largest delay in all circuit paths. The game starts off with simple circuits but very quickly becomes about making a CPU, although the ISA is hard-coded into the game and very small.<p>Another game Turing Complete ( <a href="https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1444480&#x2F;Turing_Complete&#x2F;" rel="nofollow">https:&#x2F;&#x2F;store.steampowered.com&#x2F;app&#x2F;1444480&#x2F;Turing_Complete&#x2F;</a> , <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38925307">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38925307</a> ) lets you build a CPU from basic gates and a much larger (and customizable) instruction set. It also has the concept of gate delays, thopugh it doesn&#x27;t visually show the unstable output as Silicon Zeroes does.</div><br/><div id="41166612" class="c"><input type="checkbox" id="c-41166612" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#41166006">root</a><span>|</span><a href="#41166468">parent</a><span>|</span><a href="#41166524">next</a><span>|</span><label class="collapse" for="c-41166612">[-]</label><label class="expand" for="c-41166612">[1 more]</label></div><br/><div class="children"><div class="content">Turing Complete is fantastic! It&#x27;s a very much one of those games I&#x27;d say is like Kerbal Space Program, in the sense that you can be technical and have encountered all the concepts before, but bridging the gap where you actually <i>grok</i> what&#x27;s happening intuitively isn&#x27;t quite a leap you can make.</div><br/></div></div></div></div><div id="41166524" class="c"><input type="checkbox" id="c-41166524" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#41166006">parent</a><span>|</span><a href="#41166468">prev</a><span>|</span><a href="#41166758">next</a><span>|</span><label class="collapse" for="c-41166524">[-]</label><label class="expand" for="c-41166524">[1 more]</label></div><br/><div class="children"><div class="content">Propagation delay, besides being physically unavoidable, is actually <i>necessary</i> for things like latches (and thus memory) to work, since they rely on feedback loops. The <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ring_oscillator" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ring_oscillator</a> is another example.</div><br/></div></div><div id="41166758" class="c"><input type="checkbox" id="c-41166758" checked=""/><div class="controls bullet"><span class="by">e63f67dd-065b</span><span>|</span><a href="#41166006">parent</a><span>|</span><a href="#41166524">prev</a><span>|</span><a href="#41168821">next</a><span>|</span><label class="collapse" for="c-41166758">[-]</label><label class="expand" for="c-41166758">[1 more]</label></div><br/><div class="children"><div class="content">The thing that got me into CS was building a CPU in Minecraft redstone, which is surprisingly good at being a logic simulator.<p>You only got (back in my day) NOT (the torch) and OR gates (wiring next to each other), and everything was built out of them. Signal repeaters had delay, the gates had delay, so you naturally had to build a clock to synchronise it all.<p>The main benefit that I enjoyed was that you could see the signals physically propagating from one end of your cpu to the other in real time (clock cycles were in the range of 1-4 seconds), flowing from the instructing fetching, decoding, dispatch, logic, writing to back memory, etc. Seeing signals slowly crawl from one end to the other naturally introduced you to pipelining (it even happens naturally if you increase the clock without thinking about what will actually happen: the next instruction starts decoding before the previous one is done, more parts of your cpu start lighting up at once, and oops now you have a pipelined cpu).<p>Even the scales match; many learners are surprised that the actual ALU is the tiny thing in the corner that you can barely see, and all the giant stacks of rows you actually saw is memory and cache. Even in minecraft, most of your CPU is not logic :)<p>Also really taught me how asics are much faster: you could build a tiny compact multiplier that multiplied hundreds of times faster than your giant cpu running a multiplication algorithm.<p>Looks like they community I learnt from is still around actually <a href="https:&#x2F;&#x2F;openredstone.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;openredstone.org&#x2F;</a>, even if all the old forum posts seems to be gone now. There were some geniuses on that place building computers with multi-tier caches, full pipelining, out-of-order (albeit primitive) execution, SIMD-capable CPUs, all in redstone.</div><br/></div></div><div id="41168821" class="c"><input type="checkbox" id="c-41168821" checked=""/><div class="controls bullet"><span class="by">pyinstallwoes</span><span>|</span><a href="#41166006">parent</a><span>|</span><a href="#41166758">prev</a><span>|</span><a href="#41167549">next</a><span>|</span><label class="collapse" for="c-41168821">[-]</label><label class="expand" for="c-41168821">[3 more]</label></div><br/><div class="children"><div class="content">But there exists clockless architectures.</div><br/><div id="41168920" class="c"><input type="checkbox" id="c-41168920" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#41166006">root</a><span>|</span><a href="#41168821">parent</a><span>|</span><a href="#41168909">next</a><span>|</span><label class="collapse" for="c-41168920">[-]</label><label class="expand" for="c-41168920">[1 more]</label></div><br/><div class="children"><div class="content">Is clockless useful in the face of modern ASIC tools? Not that you were suggesting in either direction, but it&#x27;s been something in the back of my head for a while now.<p>Sure, there&#x27;s a slight power and latency advantage in avoiding flip flops themselves but every tool has slack stealing and so the core advantage everyone seems to claim clockless (that is, the ability to have different latencies for all your different pipelines) isn&#x27;t that unique anymore and hasn&#x27;t been for a long time. Is it dead, can I stop worrying about the async demons :)</div><br/></div></div><div id="41168909" class="c"><input type="checkbox" id="c-41168909" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#41166006">root</a><span>|</span><a href="#41168821">parent</a><span>|</span><a href="#41168920">prev</a><span>|</span><a href="#41167549">next</a><span>|</span><label class="collapse" for="c-41168909">[-]</label><label class="expand" for="c-41168909">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also things like a CMOS Z80 coupled with static ram.  Where you still deal with propagation delay, but you can single step the clock and everything works like you expect.  Mentioned, as it would fit pretty well in the code model the linked project implements.</div><br/></div></div></div></div><div id="41167549" class="c"><input type="checkbox" id="c-41167549" checked=""/><div class="controls bullet"><span class="by">metaphor</span><span>|</span><a href="#41166006">parent</a><span>|</span><a href="#41168821">prev</a><span>|</span><a href="#41168861">next</a><span>|</span><label class="collapse" for="c-41167549">[-]</label><label class="expand" for="c-41167549">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>That&#x27;s the reason computers have a clock, to make sure all transistors in a given stage of a CPU reach a steady state before moving on to the next instruction.</i><p>Here I was thinking[1][2] the reason computers had clocks was merely a consequence of the synchronous architectures that characterize them.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metastability_(electronics)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Metastability_(electronics)</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Quasi-delay-insensitive_circuit" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Quasi-delay-insensitive_circui...</a></div><br/><div id="41167840" class="c"><input type="checkbox" id="c-41167840" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41166006">root</a><span>|</span><a href="#41167549">parent</a><span>|</span><a href="#41168861">next</a><span>|</span><label class="collapse" for="c-41167840">[-]</label><label class="expand" for="c-41167840">[2 more]</label></div><br/><div class="children"><div class="content">What point are you trying to make?<p>You are correct that clock free designs exist.  But calling it a mere consequence of sync design seems to be a misunderstanding of why sync design has a clock in the first place.</div><br/><div id="41168765" class="c"><input type="checkbox" id="c-41168765" checked=""/><div class="controls bullet"><span class="by">metaphor</span><span>|</span><a href="#41166006">root</a><span>|</span><a href="#41167840">parent</a><span>|</span><a href="#41168861">next</a><span>|</span><label class="collapse" for="c-41168765">[-]</label><label class="expand" for="c-41168765">[1 more]</label></div><br/><div class="children"><div class="content">In the case of synchronous design patterns that handle metastability, it was to point out that the clock clearly isn&#x27;t there &quot;to make sure all transistors in a given stage of a CPU reach a steady state&quot;. The clock is there to invoke state transition, whereas achieving steady state is a function of satisfying setup&#x2F;hold times; the former is fundamentally constrained by the latter.<p>In the case of QDI circuits, it was to point out that there exists CPUs which do not contain clocks, again challenging the assertion that the reason computers have clocks is &quot;to make sure all transistors in a given stage of a CPU reach a steady state&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="41168861" class="c"><input type="checkbox" id="c-41168861" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#41166006">prev</a><span>|</span><a href="#41168917">next</a><span>|</span><label class="collapse" for="c-41168861">[-]</label><label class="expand" for="c-41168861">[1 more]</label></div><br/><div class="children"><div class="content">Articles like this remind me of that one time I wrote a 6502 simulator in Turbo Pascal (complete with a primitive text mode disassembler where you could view and edit the machine code stored in memory) as a semester break project. It&#x27;s of course very far from the complexity of today&#x27;s CPUs, but <i>basically</i> they still work the same, and all of the optimizations of modern CPUs (pipelining, various cache levels, parallel execution, prefetch, branch prediction etc. etc. etc.) should be transparent to the user - of course, if you want to eke out the last bit of performance (targeting a specific CPU), it helps to be aware of all of that, but you don&#x27;t need it for understanding how a CPU works.</div><br/></div></div><div id="41168917" class="c"><input type="checkbox" id="c-41168917" checked=""/><div class="controls bullet"><span class="by">JR1427</span><span>|</span><a href="#41168861">prev</a><span>|</span><a href="#41167144">next</a><span>|</span><label class="collapse" for="c-41168917">[-]</label><label class="expand" for="c-41168917">[1 more]</label></div><br/><div class="children"><div class="content">I really love projects like this, where you learn a lot by just getting stuck in.<p>I built a simple 8-bit computer using a Z80 chip. You can read about it a bit more here <a href="https:&#x2F;&#x2F;www.jake-reich.co.uk&#x2F;zx-jakey" rel="nofollow">https:&#x2F;&#x2F;www.jake-reich.co.uk&#x2F;zx-jakey</a></div><br/></div></div><div id="41167144" class="c"><input type="checkbox" id="c-41167144" checked=""/><div class="controls bullet"><span class="by">henrikschroder</span><span>|</span><a href="#41168917">prev</a><span>|</span><a href="#41165904">next</a><span>|</span><label class="collapse" for="c-41167144">[-]</label><label class="expand" for="c-41167144">[2 more]</label></div><br/><div class="children"><div class="content">One of the most enlightening courses I took in university back in the day was digital electronics. Not because I ever wanted to muck about with it, but because we actually got to build our own super-simple physical 8-bit CPU. We had registers and an ALU and RAM and eight output leds, and we got to write the microcode for the fetch-execute cycle. Clock? There was a physical switch you would toggle on and off to make it step through the cycles to slowly execute the program we wrote in our own machine code. Realizing that instructions are just a bit-pattern saying which unit should write to the bus and which unit should read from the bus was quite eye-opening.</div><br/><div id="41167980" class="c"><input type="checkbox" id="c-41167980" checked=""/><div class="controls bullet"><span class="by">SoftTalker</span><span>|</span><a href="#41167144">parent</a><span>|</span><a href="#41165904">next</a><span>|</span><label class="collapse" for="c-41167980">[-]</label><label class="expand" for="c-41167980">[1 more]</label></div><br/><div class="children"><div class="content">Old minicomputers had toggle switches on the front panel where you could set the program counter, enter machine code instructions, and other things, as well as step the clock.<p><a href="https:&#x2F;&#x2F;thumbs.worthpoint.com&#x2F;zoom&#x2F;images2&#x2F;1&#x2F;0619&#x2F;05&#x2F;vintage-ti-980-ttl-based-minicomputer_1_1db4cde377bc5377243b34cf2e91f4f4.jpg" rel="nofollow">https:&#x2F;&#x2F;thumbs.worthpoint.com&#x2F;zoom&#x2F;images2&#x2F;1&#x2F;0619&#x2F;05&#x2F;vintage...</a></div><br/></div></div></div></div><div id="41165904" class="c"><input type="checkbox" id="c-41165904" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41167144">prev</a><span>|</span><a href="#41167581">next</a><span>|</span><label class="collapse" for="c-41165904">[-]</label><label class="expand" for="c-41165904">[1 more]</label></div><br/><div class="children"><div class="content">Discussed at the time:<p><i>I don&#x27;t know how CPUs work so I simulated one in code</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19969321">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19969321</a> - May 2019 (172 comments)</div><br/></div></div><div id="41167581" class="c"><input type="checkbox" id="c-41167581" checked=""/><div class="controls bullet"><span class="by">vismit2000</span><span>|</span><a href="#41165904">prev</a><span>|</span><a href="#41129133">next</a><span>|</span><label class="collapse" for="c-41167581">[-]</label><label class="expand" for="c-41167581">[2 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;cpu.land&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cpu.land&#x2F;</a></div><br/><div id="41168532" class="c"><input type="checkbox" id="c-41168532" checked=""/><div class="controls bullet"><span class="by">devopsian</span><span>|</span><a href="#41167581">parent</a><span>|</span><a href="#41129133">next</a><span>|</span><label class="collapse" for="c-41168532">[-]</label><label class="expand" for="c-41168532">[1 more]</label></div><br/><div class="children"><div class="content">This looks super cool. Thank you for the link</div><br/></div></div></div></div><div id="41129133" class="c"><input type="checkbox" id="c-41129133" checked=""/><div class="controls bullet"><span class="by">vhodges</span><span>|</span><a href="#41167581">prev</a><span>|</span><a href="#41166561">next</a><span>|</span><label class="collapse" for="c-41129133">[-]</label><label class="expand" for="c-41129133">[1 more]</label></div><br/><div class="children"><div class="content">Neat, I&#x27;ve seen a few logsim systems.  After watching Ben Eaters videos (and not having enough time to tinker with hardware) I built<p><a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~vhodges&#x2F;cputhing" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~vhodges&#x2F;cputhing</a></div><br/></div></div><div id="41166561" class="c"><input type="checkbox" id="c-41166561" checked=""/><div class="controls bullet"><span class="by">paranoidrobot</span><span>|</span><a href="#41129133">prev</a><span>|</span><a href="#41167613">next</a><span>|</span><label class="collapse" for="c-41166561">[-]</label><label class="expand" for="c-41166561">[3 more]</label></div><br/><div class="children"><div class="content">I was once shown a dos-based CPU simulator back in the mid&#x2F;late 90s.<p>From memory it showed instruction decode, execution, cache and memory.<p>Unfortunately I&#x27;ve never been able to find it, because all the google results are about running DOS games and&#x2F;or DOSBox.</div><br/><div id="41168528" class="c"><input type="checkbox" id="c-41168528" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#41166561">parent</a><span>|</span><a href="#41166627">next</a><span>|</span><label class="collapse" for="c-41168528">[-]</label><label class="expand" for="c-41168528">[1 more]</label></div><br/><div class="children"><div class="content">Mikrosim maybe? The name is because it simulates microcode. That was a huge a-ha moment for me in school.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MikroSim" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MikroSim</a><p><a href="http:&#x2F;&#x2F;www.mikrocodesimulator.de&#x2F;index_eng.php" rel="nofollow">http:&#x2F;&#x2F;www.mikrocodesimulator.de&#x2F;index_eng.php</a></div><br/></div></div><div id="41166627" class="c"><input type="checkbox" id="c-41166627" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#41166561">parent</a><span>|</span><a href="#41168528">prev</a><span>|</span><a href="#41167613">next</a><span>|</span><label class="collapse" for="c-41166627">[-]</label><label class="expand" for="c-41166627">[1 more]</label></div><br/><div class="children"><div class="content">It is probably on one of the SIMTEL shovelware cdroms. <a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;SIMTEL_0692" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;SIMTEL_0692</a><p>A search engine won&#x27;t help you, but a local llm might.</div><br/></div></div></div></div><div id="41167613" class="c"><input type="checkbox" id="c-41167613" checked=""/><div class="controls bullet"><span class="by">donw</span><span>|</span><a href="#41166561">prev</a><span>|</span><a href="#41166007">next</a><span>|</span><label class="collapse" for="c-41167613">[-]</label><label class="expand" for="c-41167613">[2 more]</label></div><br/><div class="children"><div class="content">Ben eater did an excellent series on YouTube where he built a CPU from scratch on breadboards: <a href="https:&#x2F;&#x2F;m.youtube.com&#x2F;playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU" rel="nofollow">https:&#x2F;&#x2F;m.youtube.com&#x2F;playlist?list=PLowKtXNTBypGqImE405J256...</a><p>His channel has a lot of other really great stuff on general electronics as well.</div><br/></div></div><div id="41166007" class="c"><input type="checkbox" id="c-41166007" checked=""/><div class="controls bullet"><span class="by">leoh</span><span>|</span><a href="#41167613">prev</a><span>|</span><a href="#41166246">next</a><span>|</span><label class="collapse" for="c-41166007">[-]</label><label class="expand" for="c-41166007">[3 more]</label></div><br/><div class="children"><div class="content">If, for fun, I wanted to train an ML model on a ton of CPU instructions (which each predicted state&#x2F;label being the state of the registers), does anyone have any clue how to gather that kind of data?</div><br/><div id="41166873" class="c"><input type="checkbox" id="c-41166873" checked=""/><div class="controls bullet"><span class="by">jakeinspace</span><span>|</span><a href="#41166007">parent</a><span>|</span><a href="#41166057">next</a><span>|</span><label class="collapse" for="c-41166873">[-]</label><label class="expand" for="c-41166873">[1 more]</label></div><br/><div class="children"><div class="content">QEMU isn’t cycle-accurate, but would be a good start (and probably good enough). Just run some benchmarks and whatnot there, and use a tracing tool like Cannoli to capture instructions.<p>If you need real instructions (without an emulator like qemu doing its own translation and messing up timing), you could use a simulator like Gem5. That’s a bit more work and a lot more compute per simulated instruction.</div><br/></div></div><div id="41166057" class="c"><input type="checkbox" id="c-41166057" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41166007">parent</a><span>|</span><a href="#41166873">prev</a><span>|</span><a href="#41166246">next</a><span>|</span><label class="collapse" for="c-41166057">[-]</label><label class="expand" for="c-41166057">[1 more]</label></div><br/><div class="children"><div class="content">Maybe a game console emulator?</div><br/></div></div></div></div><div id="41166246" class="c"><input type="checkbox" id="c-41166246" checked=""/><div class="controls bullet"><span class="by">sam_perez</span><span>|</span><a href="#41166007">prev</a><span>|</span><a href="#41166647">next</a><span>|</span><label class="collapse" for="c-41166246">[-]</label><label class="expand" for="c-41166246">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of some scenes from the first book of the three body problem.</div><br/></div></div><div id="41166647" class="c"><input type="checkbox" id="c-41166647" checked=""/><div class="controls bullet"><span class="by">russellbeattie</span><span>|</span><a href="#41166246">prev</a><span>|</span><a href="#41167438">next</a><span>|</span><label class="collapse" for="c-41166647">[-]</label><label class="expand" for="c-41166647">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;The only cheat bit is to get the keyboard input and display output working I had to hook up go channels to speak to the outside world via GLFW...&quot;</i><p>What I learned from Ben Eater is that a non-cheaty solution would have been to write a simple UART serial &quot;device&quot; and then interacted with the CPU via serial communication with a terminal.</div><br/></div></div><div id="41167438" class="c"><input type="checkbox" id="c-41167438" checked=""/><div class="controls bullet"><span class="by">luxuryballs</span><span>|</span><a href="#41166647">prev</a><span>|</span><label class="collapse" for="c-41167438">[-]</label><label class="expand" for="c-41167438">[1 more]</label></div><br/><div class="children"><div class="content">I also don’t know and thinking about this makes me claustrophobic because I enjoy programming.</div><br/></div></div></div></div></div></div></div></body></html>