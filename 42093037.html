<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731229252712" as="style"/><link rel="stylesheet" href="styles.css?v=1731229252712"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://poniesandlight.co.uk/reflect/debug_print_text/">Texture-Less Text Rendering</a> <span class="domain">(<a href="https://poniesandlight.co.uk">poniesandlight.co.uk</a>)</span></div><div class="subtext"><span>PaulHoule</span> | <span>47 comments</span></div><br/><div><div id="42095247" class="c"><input type="checkbox" id="c-42095247" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42093320">next</a><span>|</span><label class="collapse" for="c-42095247">[-]</label><label class="expand" for="c-42095247">[4 more]</label></div><br/><div class="children"><div class="content">If anyone wants to try this, work through the artithmetic, it’s incredibly easy (and a fun Saturday morning exercise if you’re into this kind of thing) to code up on ShaderToy. From scratch is fun, but if you need a hint to get started I just made one <a href="https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;Mc3cW2" rel="nofollow">https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;Mc3cW2</a> and there are a bunch of super clever text hacks other people have done like this Matrix in less than 300 characters <a href="https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;llXSzj" rel="nofollow">https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;llXSzj</a> or green CRT display effect <a href="https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;XtfSD8" rel="nofollow">https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;XtfSD8</a>. Loads of other examples abound if you look around.</div><br/><div id="42095533" class="c"><input type="checkbox" id="c-42095533" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#42095247">parent</a><span>|</span><a href="#42095536">next</a><span>|</span><label class="collapse" for="c-42095533">[-]</label><label class="expand" for="c-42095533">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never been able to make text look good at small sizes whenever I&#x27;ve tried immediate mode text rendering. Even in the first shadertoy, in vec2(30, -30), if you change 30 to 300, you&#x27;ll see some artifacts. Is there a trick to getting that right? For me, multisampling the texture inside fragment shader appears to work the best, although it still isn&#x27;t as good as the state of the art.</div><br/><div id="42096847" class="c"><input type="checkbox" id="c-42096847" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42095247">root</a><span>|</span><a href="#42095533">parent</a><span>|</span><a href="#42095536">next</a><span>|</span><label class="collapse" for="c-42096847">[-]</label><label class="expand" for="c-42096847">[1 more]</label></div><br/><div class="children"><div class="content">Yeah for that you want to do something better than the nearest neighbor sampling I did there. Multisampling can help but there are definitely some other alternatives. This is where the texture&#x2F;atlas method the author avoided comes in very handy, because it typically comes with mip-mapping which will help small text look good. There are also analytic stroke drawing methods, though even that isn’t perfect (it always depends on your choice of filter and what actual display you use, and what your goals are, etc.)<p>ShaderToy comes with a texture atlas built in. I have one or two examples of that, for example <a href="https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;ltBfDD" rel="nofollow">https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;ltBfDD</a> In addition to mipmap textures, there are other pseudo antialiasing methods people use on ShaderToy, for example when doing 2d stuff you can use the pixel derivative to make 1 pixel wide blending functions, and use it to antialias hard edges. Example <a href="https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;MtyyRc" rel="nofollow">https:&#x2F;&#x2F;www.shadertoy.com&#x2F;view&#x2F;MtyyRc</a></div><br/></div></div></div></div><div id="42095536" class="c"><input type="checkbox" id="c-42095536" checked=""/><div class="controls bullet"><span class="by">hnisoss</span><span>|</span><a href="#42095247">parent</a><span>|</span><a href="#42095533">prev</a><span>|</span><a href="#42093320">next</a><span>|</span><label class="collapse" for="c-42095536">[-]</label><label class="expand" for="c-42095536">[1 more]</label></div><br/><div class="children"><div class="content">offtopic but interesting, matrix effect in HTML&#x2F;CSS&#x2F;JS, 1024 bytes,<p>```
&lt;head&gt;&lt;style&gt;<i>{margin:0;padding:0;line-height:1;overflow:hidden;}div{width:1em;position:absolute;}&lt;&#x2F;style&gt;&lt;script&gt;
w=window;n=w.innerWidth;m=w.innerHeight;d=document;q=&quot;px&quot;;function z(a,b){return Math.floor(Math.random()</i>(b-a)+a)}f=&quot; 0123456789&quot;;for(i=0;i&lt;45;i++)f+=String.fromCharCode(i+65393);function g(){for(i=0;i&lt;90;i++){r=d.createElement(&quot;div&quot;);for(j=z(20,50);j;j--){x=d.createElement(&quot;pre&quot;);y=d.createTextNode(f[z(0,56)]);x.appendChild(y);x.style.opacity=0;r.appendChild(x)}r.id=&quot;r&quot;+i;r.t=z(-99,0);with(r.style){left=z(0,n)+q;top=z(-m,0)+q;fontSize=z(10,25)+q}d.body.appendChild(r);setInterval(&quot;u(&quot;+i+&quot;)&quot;,z(60,120))}}function u(j){e=d.getElementById(&quot;r&quot;+j);c=e.childNodes;t=e.t+1;if((v=t-c.length-50)&gt;0){if((e.style.opacity=1-v&#x2F;32)==0){for(f in c)if(c[f].style)c[f].style.opacity=0;with(e.style){left=z(0,n)+q;top=z(-m&#x2F;2,m&#x2F;2)+q;opacity=1}t=-50}}e.t=t;if(t&lt;0||t&gt;c.length+12)return;for(f=t;f&amp;&amp;f&gt;t-12;f--){s=1-(t-f)&#x2F;16;if(f&lt;c.length&amp;&amp;c[f].style){c[f].style.opacity=s;}}}
&lt;&#x2F;script&gt;&lt;body text=#0f0 bgcolor=#000 onload=g()&gt;
```<p><a href="https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;a&#x2F;17414" rel="nofollow">https:&#x2F;&#x2F;codegolf.stackexchange.com&#x2F;a&#x2F;17414</a></div><br/></div></div></div></div><div id="42093320" class="c"><input type="checkbox" id="c-42093320" checked=""/><div class="controls bullet"><span class="by">esperent</span><span>|</span><a href="#42095247">prev</a><span>|</span><a href="#42093423">next</a><span>|</span><label class="collapse" for="c-42093320">[-]</label><label class="expand" for="c-42093320">[3 more]</label></div><br/><div class="children"><div class="content">This is delightfully clever and hacky (so basically like every 3d rendering technique ever) but the end result isn&#x27;t exactly beautiful unless you&#x27;re trying to recreate an old school electronic billboard. You could improve it by adding more bits, but long before it starts to look good you&#x27;d be searching for an easier way to handle setting all the bits... And there&#x27;s almost certainly no more efficient solution than using black and white pixels in a drawing program then saving the results in a texture. So, full circle.<p>If anyone is interested in the a more common way that modern 3d rendering engines draw text, look up SDF text (and related techniques like MSDF etc.). This uses a traditional texture atlas in a preprossing step to create an atlas of signed distance fields.</div><br/><div id="42093405" class="c"><input type="checkbox" id="c-42093405" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#42093320">parent</a><span>|</span><a href="#42094471">next</a><span>|</span><label class="collapse" for="c-42093405">[-]</label><label class="expand" for="c-42093405">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>So, full circle</i><p>In case anyone hasn&#x27;t yet seen the 1968 full circle paper, &quot;On the Design of Display Processors&quot;: <a href="http:&#x2F;&#x2F;cva.stanford.edu&#x2F;classes&#x2F;cs99s&#x2F;papers&#x2F;myer-sutherland-design-of-display-processors.pdf" rel="nofollow">http:&#x2F;&#x2F;cva.stanford.edu&#x2F;classes&#x2F;cs99s&#x2F;papers&#x2F;myer-sutherland...</a><p>Hardware in their case, but we also have software saṃsāra.</div><br/></div></div><div id="42094471" class="c"><input type="checkbox" id="c-42094471" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#42093320">parent</a><span>|</span><a href="#42093405">prev</a><span>|</span><a href="#42093423">next</a><span>|</span><label class="collapse" for="c-42094471">[-]</label><label class="expand" for="c-42094471">[1 more]</label></div><br/><div class="children"><div class="content">It is pretty clever for debug text if, for instance, textures aren&#x27;t uploading properly. But uh... while it&#x27;s cute that the OP compares sprite sheets to 16th century manual typesetting, the reality is that it took a printer&#x27;s assistant an hour to layout a broadsheet of tiny metal slugs on a press, and it takes oh &lt; 10ms to upload a spritesheet to a GPU, which is then infinitely configurable.<p>Not saying it&#x27;s not a neat trick, it is.</div><br/></div></div></div></div><div id="42093423" class="c"><input type="checkbox" id="c-42093423" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#42093320">prev</a><span>|</span><a href="#42093856">next</a><span>|</span><label class="collapse" for="c-42093423">[-]</label><label class="expand" for="c-42093423">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the option of rendering text as meshes.<p>TextMeshPro goes one step further and uses signed distance fields to handle arbitrary scale.<p><a href="https:&#x2F;&#x2F;docs.unity3d.com&#x2F;Packages&#x2F;com.unity.textmeshpro@4.0&#x2F;manual&#x2F;FontAssetsSDF.html" rel="nofollow">https:&#x2F;&#x2F;docs.unity3d.com&#x2F;Packages&#x2F;com.unity.textmeshpro@4.0&#x2F;...</a></div><br/><div id="42093531" class="c"><input type="checkbox" id="c-42093531" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#42093423">parent</a><span>|</span><a href="#42093856">next</a><span>|</span><label class="collapse" for="c-42093531">[-]</label><label class="expand" for="c-42093531">[2 more]</label></div><br/><div class="children"><div class="content">Going one step further still there&#x27;s the option of evaluating font curves directly on the GPU, which can be high quality regardless of scale or perspective. That turns out to be very difficult to do efficiently but it can be done.<p>e.g. <a href="https:&#x2F;&#x2F;sluglibrary.com" rel="nofollow">https:&#x2F;&#x2F;sluglibrary.com</a><p>Meshes and SDFs are much simpler on the GPU side but scaling them up too much can compromise accuracy, and scaling meshes down too much can introduce aliasing.</div><br/><div id="42093708" class="c"><input type="checkbox" id="c-42093708" checked=""/><div class="controls bullet"><span class="by">ath92</span><span>|</span><a href="#42093423">root</a><span>|</span><a href="#42093531">parent</a><span>|</span><a href="#42093856">next</a><span>|</span><label class="collapse" for="c-42093708">[-]</label><label class="expand" for="c-42093708">[1 more]</label></div><br/><div class="children"><div class="content">Another example of this by Evan Wallace (founder of Figma): <a href="https:&#x2F;&#x2F;medium.com&#x2F;@evanwallace&#x2F;easy-scalable-text-rendering-on-the-gpu-c3f4d782c5ac" rel="nofollow">https:&#x2F;&#x2F;medium.com&#x2F;@evanwallace&#x2F;easy-scalable-text-rendering...</a> (code: <a href="https:&#x2F;&#x2F;github.com&#x2F;evanw&#x2F;theta">https:&#x2F;&#x2F;github.com&#x2F;evanw&#x2F;theta</a>)</div><br/></div></div></div></div></div></div><div id="42093856" class="c"><input type="checkbox" id="c-42093856" checked=""/><div class="controls bullet"><span class="by">unwind</span><span>|</span><a href="#42093423">prev</a><span>|</span><a href="#42095550">next</a><span>|</span><label class="collapse" for="c-42093856">[-]</label><label class="expand" for="c-42093856">[2 more]</label></div><br/><div class="children"><div class="content">Very cool! It would be fun with some kind of performance comparison against the &quot;traditional&quot; textured method.<p>As usual with modern gpu stuff for (semi-, not knocking the OP) simple stuff like this I guess the answer to &quot;how does it perform?&quot; is &quot;yes&quot;. :&#x2F;</div><br/><div id="42093890" class="c"><input type="checkbox" id="c-42093890" checked=""/><div class="controls bullet"><span class="by">HappMacDonald</span><span>|</span><a href="#42093856">parent</a><span>|</span><a href="#42095550">next</a><span>|</span><label class="collapse" for="c-42093890">[-]</label><label class="expand" for="c-42093890">[1 more]</label></div><br/><div class="children"><div class="content">The answer I look for in &quot;how does it perform?&quot; is &quot;VSCode stops eating hundreds to thousands of MB of my VRAM&quot;.</div><br/></div></div></div></div><div id="42095550" class="c"><input type="checkbox" id="c-42095550" checked=""/><div class="controls bullet"><span class="by">variadix</span><span>|</span><a href="#42093856">prev</a><span>|</span><a href="#42097023">next</a><span>|</span><label class="collapse" for="c-42095550">[-]</label><label class="expand" for="c-42095550">[1 more]</label></div><br/><div class="children"><div class="content">Sebastian Lague has a good video covering many different font rendering techniques.<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;SO83KQuuZvg" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;SO83KQuuZvg</a></div><br/></div></div><div id="42097023" class="c"><input type="checkbox" id="c-42097023" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#42095550">prev</a><span>|</span><a href="#42093501">next</a><span>|</span><label class="collapse" for="c-42097023">[-]</label><label class="expand" for="c-42097023">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve thought about doing something like this before, but my understanding was that GPUs are especially efficient at rendering from textures, while being relatively slow at bit twiddling. So although you&#x27;re saving a little bit of memory here, is it <i>actually</i> faster than having an atlas?<p>Maybe you could get the best of both worlds by bitpacking into a regular texture, with a fragment shader doing the decoding.</div><br/><div id="42097456" class="c"><input type="checkbox" id="c-42097456" checked=""/><div class="controls bullet"><span class="by">BBOC</span><span>|</span><a href="#42097023">parent</a><span>|</span><a href="#42093501">next</a><span>|</span><label class="collapse" for="c-42097456">[-]</label><label class="expand" for="c-42097456">[1 more]</label></div><br/><div class="children"><div class="content">&gt; understanding was that GPUs are especially efficient at rendering from textures, while being relatively slow at bit twiddling.<p>That understanding is very out of date. For GPU&#x27;s made in the last 15 or so years a texture lookup is roughly 100 times as slow as a bitwise operation.</div><br/></div></div></div></div><div id="42093501" class="c"><input type="checkbox" id="c-42093501" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#42097023">prev</a><span>|</span><a href="#42097080">next</a><span>|</span><label class="collapse" for="c-42093501">[-]</label><label class="expand" for="c-42093501">[6 more]</label></div><br/><div class="children"><div class="content">I have a similar technique before, embedding the entire font data in the fragment shader source code. Then you can use `snprintf` to directly print into a GPU buffer mapped to the CPU (this is a footgun, I know). Instead of drawing individual characters with a vertex shader, I&#x27;ve just drawn one full screen triangle and use `gl_FragCoord` instead of UV coordinates. Not the most efficient way of doing things but it&#x27;s a debug feature and it&#x27;s fast enough to be practical.<p>Despite what the filename says, this is using the font from the IBM PC ROM, not the NES. You can find the &quot;NES font&quot; and other 8x8 pixel fonts around the web.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rikusalminen&#x2F;triangles&#x2F;blob&#x2F;nesfont&#x2F;shaders&#x2F;nesfont&#x2F;nesfont.glslf">https:&#x2F;&#x2F;github.com&#x2F;rikusalminen&#x2F;triangles&#x2F;blob&#x2F;nesfont&#x2F;shade...</a></div><br/><div id="42093966" class="c"><input type="checkbox" id="c-42093966" checked=""/><div class="controls bullet"><span class="by">RiverCrochet</span><span>|</span><a href="#42093501">parent</a><span>|</span><a href="#42093669">next</a><span>|</span><label class="collapse" for="c-42093966">[-]</label><label class="expand" for="c-42093966">[2 more]</label></div><br/><div class="children"><div class="content">Incoming trivia:<p>I finally found out recently that the &quot;NES&quot; font is from the 1976 arcade game Quiz Show. The font was used in other black-and-white Kee&#x2F;Atari games. The font data is available in the quizshow MAME ROM set - split into nybbles for some reason.<p>This game was interesting - it stored question and answer data on a 8-track tape.</div><br/><div id="42095289" class="c"><input type="checkbox" id="c-42095289" checked=""/><div class="controls bullet"><span class="by">LocalH</span><span>|</span><a href="#42093501">root</a><span>|</span><a href="#42093966">parent</a><span>|</span><a href="#42093669">next</a><span>|</span><label class="collapse" for="c-42095289">[-]</label><label class="expand" for="c-42095289">[1 more]</label></div><br/><div class="children"><div class="content">The font has slightly changed over the years. Notably, the &quot;E&quot; glyph originally had a longer lower arm, and the &quot;!&quot; and &quot;?&quot; glyphs are often different between variants of the font. Super Mario Bros also notably modifies the 8 to have a straight crossbar instead of intersecting spines.</div><br/></div></div></div></div><div id="42093669" class="c"><input type="checkbox" id="c-42093669" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#42093501">parent</a><span>|</span><a href="#42093966">prev</a><span>|</span><a href="#42097080">next</a><span>|</span><label class="collapse" for="c-42093669">[-]</label><label class="expand" for="c-42093669">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You can find the &quot;NES font&quot; and other 8x8 pixel fonts around the web.<p>This is my favorite pixel font pack:<p><a href="https:&#x2F;&#x2F;int10h.org&#x2F;oldschool-pc-fonts&#x2F;" rel="nofollow">https:&#x2F;&#x2F;int10h.org&#x2F;oldschool-pc-fonts&#x2F;</a></div><br/><div id="42094006" class="c"><input type="checkbox" id="c-42094006" checked=""/><div class="controls bullet"><span class="by">shikaan</span><span>|</span><a href="#42093501">root</a><span>|</span><a href="#42093669">parent</a><span>|</span><a href="#42097080">next</a><span>|</span><label class="collapse" for="c-42094006">[-]</label><label class="expand" for="c-42094006">[2 more]</label></div><br/><div class="children"><div class="content">Thanks so much! I am doing something similar to OP in my game engine, but I hand-rolled a font, which is readable but ugly af.<p>This is going to be such a source of inspiration! Do people have favorites from the list?</div><br/><div id="42094795" class="c"><input type="checkbox" id="c-42094795" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#42093501">root</a><span>|</span><a href="#42094006">parent</a><span>|</span><a href="#42097080">next</a><span>|</span><label class="collapse" for="c-42094795">[-]</label><label class="expand" for="c-42094795">[1 more]</label></div><br/><div class="children"><div class="content">Mine is IBM XGA-AI 12x20 for sure</div><br/></div></div></div></div></div></div></div></div><div id="42097080" class="c"><input type="checkbox" id="c-42097080" checked=""/><div class="controls bullet"><span class="by">z3t4</span><span>|</span><a href="#42093501">prev</a><span>|</span><a href="#42093986">next</a><span>|</span><label class="collapse" for="c-42097080">[-]</label><label class="expand" for="c-42097080">[1 more]</label></div><br/><div class="children"><div class="content">It would be interesting to compare this technique with native text rendering. How many FPS can you get when rendering a full screen of text?</div><br/></div></div><div id="42093986" class="c"><input type="checkbox" id="c-42093986" checked=""/><div class="controls bullet"><span class="by">janci</span><span>|</span><a href="#42097080">prev</a><span>|</span><a href="#42093550">next</a><span>|</span><label class="collapse" for="c-42093986">[-]</label><label class="expand" for="c-42093986">[7 more]</label></div><br/><div class="children"><div class="content">Honest question as I don&#x27;t know almost anything about modern computer graphics: Is it so much performance penalty to upload a small texture to GPU so you can&#x27;t render the whole string to the texture in 2D and just display the texture onto two triangles?</div><br/><div id="42095429" class="c"><input type="checkbox" id="c-42095429" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#42093986">parent</a><span>|</span><a href="#42094872">next</a><span>|</span><label class="collapse" for="c-42095429">[-]</label><label class="expand" for="c-42095429">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Is it so much performance penalty to upload a small texture to GPU so you can&#x27;t render the whole string to the texture in 2D and just display the texture onto two triangles?<p>It&#x27;s not. This technique is more about getting text on the screen in the easiest way possible for debugging. You just add some data to your shader and poof, you get text.<p>The converse is, you write code to generate a font atlas (so more work), or go find and existing one and need to load it (so need to write loading code so more work). And&#x2F;Or draw a full message into a texture (more work) and you&#x27;ll need to cache that result until the message changes (more work)<p>On top of all of that, you need to manage resources and bind them into the system where as here no resources are needed.<p>but again, it&#x27;s a technique for getting &quot;debugging text&quot; on the screen. It is not a solution for text in general.<p>Note that drawing text to textures is how most browsers and OSes work. They draw fonts into texture atlases dynamically (since a atlas for all of Unicode per font per size would take too much time and memory). They then use the texture atlas glyphs to make more textures of portions of the app&#x27;s window. In the browser you can turn on show texture edges to see all textures. Rendering-&gt;Layer borders will outline each texture in cyan</div><br/></div></div><div id="42094872" class="c"><input type="checkbox" id="c-42094872" checked=""/><div class="controls bullet"><span class="by">ferbivore</span><span>|</span><a href="#42093986">parent</a><span>|</span><a href="#42095429">prev</a><span>|</span><a href="#42094131">next</a><span>|</span><label class="collapse" for="c-42094872">[-]</label><label class="expand" for="c-42094872">[1 more]</label></div><br/><div class="children"><div class="content">Drawing one quad to cover N characters and picking out a glyph in the shader is going to be faster than drawing individual quads for each character (for monospace fonts, anyway). But there are only so many characters you can fill the screen with, so it&#x27;s probably not a huge difference in practice.<p>Regarding the upload part: at the end of the day, you have X bytes of glyphs and they need to get into GPU memory somehow. Whether you get them there as textures, as uniform data or as shader constants doesn&#x27;t really matter performance-wise. If anything, doing it through shader constants as described in TFA is more expensive on the CPU side, since all those constant declarations need to be processed by the shader compiler.<p>What does matter on the GPU side is which memory hierarchy you hit when reading glyph data (texture fetches have a dedicated L1 cache on most GPUs, larger than the &quot;normal&quot; L1 cache I think) and what order the data is in (textures are usually stored in some version of Morton order to avoid cache misses when you&#x27;re shading blocks of pixels). For a production atlas-based text renderer you <i>probably</i> want to use textures.<p>Edit: I misread the question; you were asking about drawing individual glyphs on the GPU vs. drawing an entire block of text on the CPU, right? This is a speed&#x2F;space tradeoff, the answer is going to depend on how much memory you want to blow on text, whether your text changes, whether it needs to have per-character effects applied, and so on.</div><br/></div></div><div id="42094131" class="c"><input type="checkbox" id="c-42094131" checked=""/><div class="controls bullet"><span class="by">jamesu</span><span>|</span><a href="#42093986">parent</a><span>|</span><a href="#42094872">prev</a><span>|</span><a href="#42094635">next</a><span>|</span><label class="collapse" for="c-42094131">[-]</label><label class="expand" for="c-42094131">[1 more]</label></div><br/><div class="children"><div class="content">Generally you want to avoid wasting too much memory on a GPU, even today. That large text box texture also has to go over the PCI bus which can cause stalls depending on when its uploaded and if the GPU ends up having to evict resources. If you end up having a lot of independent texture text boxes being rendered by the comparatively slower CPU, that could add up quickly and cut into your budget.<p>Drawing using a glyph atlas is still a way better use of resources. Modern text rendering pipelines will also often use either SDF or encoded bezier curves to improve glyph legibility when scaling which is also a great way of saving more memory.</div><br/></div></div><div id="42094635" class="c"><input type="checkbox" id="c-42094635" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#42093986">parent</a><span>|</span><a href="#42094131">prev</a><span>|</span><a href="#42094026">next</a><span>|</span><label class="collapse" for="c-42094635">[-]</label><label class="expand" for="c-42094635">[1 more]</label></div><br/><div class="children"><div class="content">You can render the entire string before upload, but then you are essentially using a CPU render, which will be slower than having the GPU do the same thing.<p>FWIW, this method is also a texture despite being called “texture-less”; the texture is just stored in a different format and a different place. True textureless font rendering evaluates the vector curves on the fly.</div><br/></div></div><div id="42094026" class="c"><input type="checkbox" id="c-42094026" checked=""/><div class="controls bullet"><span class="by">superjan</span><span>|</span><a href="#42093986">parent</a><span>|</span><a href="#42094635">prev</a><span>|</span><a href="#42094823">next</a><span>|</span><label class="collapse" for="c-42094026">[-]</label><label class="expand" for="c-42094026">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the application. It’s the easiest way especially if you might encounter right to left script, CJK or emoji. It is worthwhile to cache the textures, most text does not change every frame. It is good enough for us.</div><br/></div></div><div id="42094823" class="c"><input type="checkbox" id="c-42094823" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#42093986">parent</a><span>|</span><a href="#42094026">prev</a><span>|</span><a href="#42093550">next</a><span>|</span><label class="collapse" for="c-42094823">[-]</label><label class="expand" for="c-42094823">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s huge. Passing data from CPU to GPU is most likely, 90% of time, the biggest bottleneck.</div><br/></div></div></div></div><div id="42093550" class="c"><input type="checkbox" id="c-42093550" checked=""/><div class="controls bullet"><span class="by">bazzargh</span><span>|</span><a href="#42093986">prev</a><span>|</span><a href="#42093912">next</a><span>|</span><label class="collapse" for="c-42093550">[-]</label><label class="expand" for="c-42093550">[1 more]</label></div><br/><div class="children"><div class="content">Previously <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41993084">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41993084</a><p>(tho mine was the only comment last time)</div><br/></div></div><div id="42093912" class="c"><input type="checkbox" id="c-42093912" checked=""/><div class="controls bullet"><span class="by">kardianos</span><span>|</span><a href="#42093550">prev</a><span>|</span><a href="#42093322">next</a><span>|</span><label class="collapse" for="c-42093912">[-]</label><label class="expand" for="c-42093912">[1 more]</label></div><br/><div class="children"><div class="content">I think SLUG does this, but professionally:<p><a href="https:&#x2F;&#x2F;sluglibrary.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sluglibrary.com&#x2F;</a></div><br/></div></div><div id="42093322" class="c"><input type="checkbox" id="c-42093322" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#42093912">prev</a><span>|</span><a href="#42094065">next</a><span>|</span><label class="collapse" for="c-42093322">[-]</label><label class="expand" for="c-42093322">[1 more]</label></div><br/><div class="children"><div class="content">Fun, I really wish I had the ability to reason around shaders and draw calls to do things like this :-).</div><br/></div></div><div id="42094065" class="c"><input type="checkbox" id="c-42094065" checked=""/><div class="controls bullet"><span class="by">somat</span><span>|</span><a href="#42093322">prev</a><span>|</span><a href="#42093288">next</a><span>|</span><label class="collapse" for="c-42094065">[-]</label><label class="expand" for="c-42094065">[2 more]</label></div><br/><div class="children"><div class="content">I find it interesting how much effort was put into getting high quality scalable vector fonts and how useless these techniques were once we got our accelerated vector graphics co-processors.<p>I mean, there are some very interesting projects to try and do font rendering on the graphics card, but by and large I find it funny how in general they are terrible at it.<p>What would a native gfx-card friendly scalable font format look like? would it just be a triangle mesh?</div><br/><div id="42096532" class="c"><input type="checkbox" id="c-42096532" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42094065">parent</a><span>|</span><a href="#42093288">next</a><span>|</span><label class="collapse" for="c-42096532">[-]</label><label class="expand" for="c-42096532">[1 more]</label></div><br/><div class="children"><div class="content">IIRC every possible quadratic bezier curve (the kind used in truetype) can be rendered as one triangle and the equation in barycentric coordinates is identical for all possible curves, so you can just evaluate it in the shader with no extra vertex data.</div><br/></div></div></div></div><div id="42093288" class="c"><input type="checkbox" id="c-42093288" checked=""/><div class="controls bullet"><span class="by">sklivvz1971</span><span>|</span><a href="#42094065">prev</a><span>|</span><a href="#42093341">next</a><span>|</span><label class="collapse" for="c-42093288">[-]</label><label class="expand" for="c-42093288">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure we&#x27;ve done this before... lol!</div><br/></div></div><div id="42093341" class="c"><input type="checkbox" id="c-42093341" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42093288">prev</a><span>|</span><a href="#42093818">next</a><span>|</span><label class="collapse" for="c-42093341">[-]</label><label class="expand" for="c-42093341">[9 more]</label></div><br/><div class="children"><div class="content">Pretty confusing to say you&#x27;re not going to store a bitmap in the shader... and then explain exactly how you stored a bitmap in the shader!<p>(TL;DR, he embeds a bitmap font in the shader.)</div><br/><div id="42093376" class="c"><input type="checkbox" id="c-42093376" checked=""/><div class="controls bullet"><span class="by">naavis</span><span>|</span><a href="#42093341">parent</a><span>|</span><a href="#42093818">next</a><span>|</span><label class="collapse" for="c-42093376">[-]</label><label class="expand" for="c-42093376">[8 more]</label></div><br/><div class="children"><div class="content">No, they say they are not going to store a bitmap in a texture, which is not the same thing as embedding directly in the shader code.<p>You could compare that to storing some data in a separate file which needs to be read during runtime versus embedding the data directly in the source code.</div><br/><div id="42094922" class="c"><input type="checkbox" id="c-42094922" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093376">parent</a><span>|</span><a href="#42093422">next</a><span>|</span><label class="collapse" for="c-42094922">[-]</label><label class="expand" for="c-42094922">[1 more]</label></div><br/><div class="children"><div class="content">The bitmap absolutely <i>is</i> a texture in the broad sense of the word. It’s not a Vulkan texture in the sense that it doesn’t use the Vulkan texture API, but it is a texture nonetheless.<p>Moreover, parent’s point is double valid because of the example “Look Ma, No Font Atlas!!!” that uses a font atlas baked into shader code. I totally expected this article, based on the title, to talk about stroked font rendering, and instead it’s an article about “texture-less” textured rendering that uses a “no font atlas” font atlas.</div><br/></div></div><div id="42093422" class="c"><input type="checkbox" id="c-42093422" checked=""/><div class="controls bullet"><span class="by">Galanwe</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093376">parent</a><span>|</span><a href="#42094922">prev</a><span>|</span><a href="#42095763">next</a><span>|</span><label class="collapse" for="c-42093422">[-]</label><label class="expand" for="c-42093422">[1 more]</label></div><br/><div class="children"><div class="content">While not technically misleading, I also find it a bit misleading.<p>When told it&#x27;s going to be a &quot;texture less text rendering&quot;, I was thinking of procedural drawing of glyphs, not embedding bitmaps in a shader instead of a texture.</div><br/></div></div><div id="42095763" class="c"><input type="checkbox" id="c-42095763" checked=""/><div class="controls bullet"><span class="by">glimshe</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093376">parent</a><span>|</span><a href="#42093422">prev</a><span>|</span><a href="#42093528">next</a><span>|</span><label class="collapse" for="c-42095763">[-]</label><label class="expand" for="c-42095763">[1 more]</label></div><br/><div class="children"><div class="content">Memory is memory, irrespective of whether it&#x27;s &quot;code memory&quot; or &quot;data memory&quot;.<p>Back in the bad old days you could just use precompiled textures which are basically a set of memory write CPU instructions using immediate mode operands (no texture&#x2F;bitmap lookup of any kind)</div><br/></div></div><div id="42093528" class="c"><input type="checkbox" id="c-42093528" checked=""/><div class="controls bullet"><span class="by">ginko</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093376">parent</a><span>|</span><a href="#42095763">prev</a><span>|</span><a href="#42093496">next</a><span>|</span><label class="collapse" for="c-42093528">[-]</label><label class="expand" for="c-42093528">[2 more]</label></div><br/><div class="children"><div class="content">The effect of that is that you&#x27;re circumventing using hardware specialized for efficient pixel lookup in favor of using general data lookup inside the shader binary. You&#x27;re saving yourself some memory due to using 1 bit per pixel rather than at least 8 (none of the major APIs expose a 1-bit texture format AFAIK so R8 would be the next best thing), but you&#x27;re bound to use some extra cycles for the lookup and decoding of your embedded font.</div><br/><div id="42093758" class="c"><input type="checkbox" id="c-42093758" checked=""/><div class="controls bullet"><span class="by">Const-me</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093528">parent</a><span>|</span><a href="#42093496">next</a><span>|</span><label class="collapse" for="c-42093758">[-]</label><label class="expand" for="c-42093758">[1 more]</label></div><br/><div class="children"><div class="content">&gt; none of the major APIs expose a 1-bit texture format AFAIK so R8 would be the next best thing<p>I think the next best thing is BC4. The compressed format stores 8 bits&#x2F;pixels grayscale texture compressed into 8 bytes &#x2F; 4x4 pixels i.e. 4 bits&#x2F;pixel, twice smaller compared to R8.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;direct3d10&#x2F;d3d10-graphics-programming-guide-resources-block-compression#bc4" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;direct3d10&#x2F;d...</a></div><br/></div></div></div></div><div id="42093496" class="c"><input type="checkbox" id="c-42093496" checked=""/><div class="controls bullet"><span class="by">itronitron</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093376">parent</a><span>|</span><a href="#42093528">prev</a><span>|</span><a href="#42096550">next</a><span>|</span><label class="collapse" for="c-42093496">[-]</label><label class="expand" for="c-42093496">[1 more]</label></div><br/><div class="children"><div class="content">I suppose you could call this approach &quot;texture as code&quot;</div><br/></div></div><div id="42096550" class="c"><input type="checkbox" id="c-42096550" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42093341">root</a><span>|</span><a href="#42093376">parent</a><span>|</span><a href="#42093496">prev</a><span>|</span><a href="#42093818">next</a><span>|</span><label class="collapse" for="c-42096550">[-]</label><label class="expand" for="c-42096550">[1 more]</label></div><br/><div class="children"><div class="content">He doesn&#x27;t:<p>&gt; Obviously, we can’t store bitmaps inside our shaders, but we can store integer constants, which, if you squint hard enough, are nothing but maps of bits. Can we pretend that an integer is a bitmap?<p>He seems a bit confused about what a bitmap is. There&#x27;s no squinting or pretending involved here.</div><br/></div></div></div></div></div></div><div id="42093818" class="c"><input type="checkbox" id="c-42093818" checked=""/><div class="controls bullet"><span class="by">styczen</span><span>|</span><a href="#42093341">prev</a><span>|</span><a href="#42095063">next</a><span>|</span><label class="collapse" for="c-42093818">[-]</label><label class="expand" for="c-42093818">[1 more]</label></div><br/><div class="children"><div class="content">Please make similar in SDL</div><br/></div></div><div id="42095063" class="c"><input type="checkbox" id="c-42095063" checked=""/><div class="controls bullet"><span class="by">stonethrowaway</span><span>|</span><a href="#42093818">prev</a><span>|</span><label class="collapse" for="c-42095063">[-]</label><label class="expand" for="c-42095063">[1 more]</label></div><br/><div class="children"><div class="content">As an aside I’ve yet to come across anything more technically complete than ClearType. Bitmaps&#x2F;Textures done via some janky early-2000 NeHe  tutorial inspired thing aren’t even on the table. Yeah people will hate on Microsoft and Windows and bicker and whatever, I don’t care because of all the shit I’ve dealt with trying to use freetype and additional libraries, ClearType has never let me down. I’ve used D2D with D3D in conjunction with shared surfaces and other hacks to join the two, and it’s pleasant enough that the final product is well worth the programming agony.</div><br/></div></div></div></div></div></div></div></body></html>