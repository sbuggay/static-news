<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734080459057" as="style"/><link rel="stylesheet" href="styles.css?v=1734080459057"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kennyballou.com/blog/2016/12/elixir-hot-swapping/index.html">Elixir/Erlang Hot Swapping Code (2016)</a> <span class="domain">(<a href="https://kennyballou.com">kennyballou.com</a>)</span></div><div class="subtext"><span>justinludwig</span> | <span>70 comments</span></div><br/><div><div id="42405105" class="c"><input type="checkbox" id="c-42405105" checked=""/><div class="controls bullet"><span class="by">Volundr</span><span>|</span><a href="#42405168">next</a><span>|</span><label class="collapse" for="c-42405105">[-]</label><label class="expand" for="c-42405105">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s worth noting that distillery is deprecated in favor of mix releases, which don&#x27;t support relups out of the box, and specifically warn against them due to the complexity involved in writing code to support them correctly.<p>It&#x27;s a cool feature that&#x27;s no doubt amazing for applications that need it, but it brings a fair amount of complexity vs other deployment strategies.</div><br/><div id="42406034" class="c"><input type="checkbox" id="c-42406034" checked=""/><div class="controls bullet"><span class="by">superdisk</span><span>|</span><a href="#42405105">parent</a><span>|</span><a href="#42405168">next</a><span>|</span><label class="collapse" for="c-42406034">[-]</label><label class="expand" for="c-42406034">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, note that this article is from 2016. I distinctly remember during that time that these hot-swap deployments were all the rage in the Elixir community, and then fell out of fashion with time.</div><br/></div></div></div></div><div id="42405168" class="c"><input type="checkbox" id="c-42405168" checked=""/><div class="controls bullet"><span class="by">hauxir</span><span>|</span><a href="#42405105">prev</a><span>|</span><a href="#42405648">next</a><span>|</span><label class="collapse" for="c-42405168">[-]</label><label class="expand" for="c-42405168">[2 more]</label></div><br/><div class="children"><div class="content">At kosmi.io we use elixir hot swapping for every small patch&#x2F;bugfix on the backend. This allows us to deploy updates multiple times a day with 0 disruption.<p>Allows the clients to remain connected and be none the wiser that there was an update at all.<p>For larger updates we just do hard restarts when in-memory data structures or supervision tree are changed.</div><br/><div id="42406722" class="c"><input type="checkbox" id="c-42406722" checked=""/><div class="controls bullet"><span class="by">deathtrader666</span><span>|</span><a href="#42405168">parent</a><span>|</span><a href="#42405648">next</a><span>|</span><label class="collapse" for="c-42406722">[-]</label><label class="expand" for="c-42406722">[1 more]</label></div><br/><div class="children"><div class="content">Would love to know more how you go about it.</div><br/></div></div></div></div><div id="42405648" class="c"><input type="checkbox" id="c-42405648" checked=""/><div class="controls bullet"><span class="by">GCUMstlyHarmls</span><span>|</span><a href="#42405168">prev</a><span>|</span><a href="#42406677">next</a><span>|</span><label class="collapse" for="c-42405648">[-]</label><label class="expand" for="c-42405648">[1 more]</label></div><br/><div class="children"><div class="content">This is a talk about a large scale, resilient elixir&#x2F;erlang deployment in healthcare.<p>Specifically they talk about running with no down time using hot code reloading here: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;pQ0CvjAJXz4?t=2667" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;pQ0CvjAJXz4?t=2667</a> but the whole talk is quite interesting regarding availability.<p>Warning: the video is quite quiet.</div><br/></div></div><div id="42406677" class="c"><input type="checkbox" id="c-42406677" checked=""/><div class="controls bullet"><span class="by">benzible</span><span>|</span><a href="#42405648">prev</a><span>|</span><a href="#42404837">next</a><span>|</span><label class="collapse" for="c-42406677">[-]</label><label class="expand" for="c-42406677">[1 more]</label></div><br/><div class="children"><div class="content">&quot;hot deploys on fly.io to a planet-wide cluster, in 3 seconds.&quot;:  <a href="https:&#x2F;&#x2F;x.com&#x2F;chris_mccord&#x2F;status&#x2F;1785678249424461897" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;chris_mccord&#x2F;status&#x2F;1785678249424461897</a></div><br/></div></div><div id="42404837" class="c"><input type="checkbox" id="c-42404837" checked=""/><div class="controls bullet"><span class="by">anonymousDan</span><span>|</span><a href="#42406677">prev</a><span>|</span><a href="#42404939">next</a><span>|</span><label class="collapse" for="c-42404837">[-]</label><label class="expand" for="c-42404837">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a distributed setup I imagine there could be cases where you want to atomically hot upgrade multiple VMs at the same time. Is this common in practice and if so are there recommended patterns&#x2F;techniques for doing it?</div><br/><div id="42405010" class="c"><input type="checkbox" id="c-42405010" checked=""/><div class="controls bullet"><span class="by">AlphaWeaver</span><span>|</span><a href="#42404837">parent</a><span>|</span><a href="#42406975">next</a><span>|</span><label class="collapse" for="c-42405010">[-]</label><label class="expand" for="c-42405010">[1 more]</label></div><br/><div class="children"><div class="content">Erlang does have a mechanism that allows a module to control when it moves from the &quot;old version&quot; to the &quot;new version&quot; of its own code. Calls to the module with the fully qualified name (e.g. `module:function()`) will invoke the &quot;new code&quot; once it&#x27;s loaded, but calls within that module using only function names (just `function()`) will continue to invoke the &quot;old code&quot;.<p>If the portion of the app you were hot upgrading was an OTP process like a GenServer, you could theoretically wait for some sort of atomic coordination mechanism to make that fully qualified function call after the new code has loaded, at least in theory.<p>We use hot code reloading at my work, but haven&#x27;t had a reason to atomically sync the reload. Most of the time it&#x27;s a tmux session with `synchronize-panes` and that suffices. If your application can handle upgrades within a module smoothly, it&#x27;s rare to have a need for some sort of cluster-level coordination of a code change, at least one that&#x27;s atomic.</div><br/></div></div><div id="42406975" class="c"><input type="checkbox" id="c-42406975" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42404837">parent</a><span>|</span><a href="#42405010">prev</a><span>|</span><a href="#42404968">next</a><span>|</span><label class="collapse" for="c-42406975">[-]</label><label class="expand" for="c-42406975">[1 more]</label></div><br/><div class="children"><div class="content">I mean, yes, there&#x27;s cases where you want that. But there&#x27;s no mechanism for it, because you would have to stop the world, do the load, and then resume.<p>Even within a single VM, hot loading doesn&#x27;t stop the world, during the load some schedulers will switch before others. Although there are guarantees that mean when a process runs new code and sends a message to another local process, that process will have the new code available when it reads the message. (It <i>may</i> still be running the old code, depending on how it&#x27;s called though)<p>Dealing with multiple versions active is part of life in most distributed systems though. You can architect it away in some systems, but that usually involves having downtime in maintenance windows.<p>A typical pattern is making progressive updates, where if you want to change a request, first you deploy a server that can handle old and new requests, then you deploy the client that sends the new request, then you can deploy a server that no longer accepts old requests.<p>For new replies, if the new reply comes with a new request, that works like above... a client that sent a new request must handle the new reply. Otherwise, update the client to handle either type of reply, then update the server to send the new reply, finally remove handling of the old reply in the clients.<p>It gets a bit harder if your team dynamics mean one person&#x2F;group doesn&#x27;t control both sides... Then you need stats to tell you when all the clients have switched.<p>Sometimes you do need more of a point in time switch. If it needs to be pretty good, you can just set a config through a dist &#x27;broadcast&#x27;. If it needs to be better than that, you can have the servers and clients change behavior after a specific time... but make sure you understand the realities of clock synchronization and think about what to do for requests in flight. If that&#x27;s not good enough, you can drop or buffer requests for a little bit before your targer time, make sure there are no in progress requests, then resume processing requests with the new version.</div><br/></div></div><div id="42404968" class="c"><input type="checkbox" id="c-42404968" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404837">parent</a><span>|</span><a href="#42406975">prev</a><span>|</span><a href="#42404939">next</a><span>|</span><label class="collapse" for="c-42404968">[-]</label><label class="expand" for="c-42404968">[1 more]</label></div><br/><div class="children"><div class="content">There can&#x27;t be anything atomic in a distributed system. You can&#x27;t even atomically hot upgrade it on a single VM anyway -- you instead load the new version of the module and let dispatcher know to route new calls into it, the same as you would do with a load balancer and a bunch of load bearing docker hosts, just <i>inside</i> your app.</div><br/></div></div></div></div><div id="42404939" class="c"><input type="checkbox" id="c-42404939" checked=""/><div class="controls bullet"><span class="by">behnamoh</span><span>|</span><a href="#42404837">prev</a><span>|</span><a href="#42404727">next</a><span>|</span><label class="collapse" for="c-42404939">[-]</label><label class="expand" for="c-42404939">[6 more]</label></div><br/><div class="children"><div class="content">Lisp has had this features since day 1. But Lisp-like langs like Clojure, Racket, etc. don&#x27;t have it. This is one of the fundamental features of Common Lisp and I don&#x27;t know why most other Lisp-wanna-be&#x27;s don&#x27;t implement it.</div><br/><div id="42405621" class="c"><input type="checkbox" id="c-42405621" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#42404939">parent</a><span>|</span><a href="#42405127">next</a><span>|</span><label class="collapse" for="c-42405621">[-]</label><label class="expand" for="c-42405621">[1 more]</label></div><br/><div class="children"><div class="content">Clojure has it for a large percentage of functionality: things like <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure-emacs&#x2F;cider">https:&#x2F;&#x2F;github.com&#x2F;clojure-emacs&#x2F;cider</a> depend on it.  However, this mostly stays in dev-time and isn&#x27;t used much for releases.  Which I find a bit funny because Clojure&#x27;s functional, data-driven philosophy is great for enabling painless hot-code updates</div><br/></div></div><div id="42405127" class="c"><input type="checkbox" id="c-42405127" checked=""/><div class="controls bullet"><span class="by">lamuswawir</span><span>|</span><a href="#42404939">parent</a><span>|</span><a href="#42405621">prev</a><span>|</span><a href="#42404727">next</a><span>|</span><label class="collapse" for="c-42405127">[-]</label><label class="expand" for="c-42405127">[4 more]</label></div><br/><div class="children"><div class="content">Came here to say this. In Lisp, you can just compile a function, or load a file and it just works. It&#x27;s not even sold as a hot feature, not the way Erlang sells it. It&#x27;s just a feature.<p>I manage a few websites written in Lisp, and updating them is as simple as push code, recompile and it works.</div><br/><div id="42405533" class="c"><input type="checkbox" id="c-42405533" checked=""/><div class="controls bullet"><span class="by">davidw</span><span>|</span><a href="#42404939">root</a><span>|</span><a href="#42405127">parent</a><span>|</span><a href="#42404727">next</a><span>|</span><label class="collapse" for="c-42405533">[-]</label><label class="expand" for="c-42405533">[3 more]</label></div><br/><div class="children"><div class="content">But what if the system is running and the new function takes different arguments or something? What if there is data loaded in the system, what happens to it?<p>Simply loading new code is easy, ensuring the whole system works seems to require a bit more effort.</div><br/><div id="42405615" class="c"><input type="checkbox" id="c-42405615" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#42404939">root</a><span>|</span><a href="#42405533">parent</a><span>|</span><a href="#42405735">next</a><span>|</span><label class="collapse" for="c-42405615">[-]</label><label class="expand" for="c-42405615">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp has a bunch of features designed to enable migrating the system.  e.g. update-instance-for-redefined-class ( <a href="https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;f_upda_1.htm" rel="nofollow">https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;HyperSpec&#x2F;Body&#x2F;f_upd...</a> ) lets you write code to update instance data between class versions when a class definition is reloaded.<p>It turns out, though, that making hot-code reloading work well is mainly a question of how you design your system: designing for hot code reloading isn&#x27;t all that hard for 90% of cases once you figure out the relevant techniques.</div><br/></div></div></div></div></div></div></div></div><div id="42404727" class="c"><input type="checkbox" id="c-42404727" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42404939">prev</a><span>|</span><a href="#42404784">next</a><span>|</span><label class="collapse" for="c-42404727">[-]</label><label class="expand" for="c-42404727">[5 more]</label></div><br/><div class="children"><div class="content">Does this hot swapping also work for closures?</div><br/><div id="42404870" class="c"><input type="checkbox" id="c-42404870" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404727">parent</a><span>|</span><a href="#42404784">next</a><span>|</span><label class="collapse" for="c-42404870">[-]</label><label class="expand" for="c-42404870">[4 more]</label></div><br/><div class="children"><div class="content">Erlang doesn&#x27;t have closures, because erlang doesn&#x27;t have variables. The compiler simply desugars it to partially applied function referenced by it&#x27;s name (yes, those inline functions in fact have names).<p>If you have something_function, then first inline function used in it will be -something_function&#x2F;1-fun-0- with zero being the index and captured variable being another argument. Now if you will change the host function to have more inlines <i>before</i> it, the indexing will drift.<p>So I would expect the body of inline function will still be resolved from the old version of the module, but I didn&#x27;t actually try.<p>Source: I did run erlc -S at least once.<p>Add: now thinking of it, will the call to a local function from the old version of the module ever escape into the new one without first returning back to gen_server and letting it call the new version? Another comment says that calls withing the module never do, so the assumption was correct.</div><br/><div id="42405520" class="c"><input type="checkbox" id="c-42405520" checked=""/><div class="controls bullet"><span class="by">bitwalker</span><span>|</span><a href="#42404727">root</a><span>|</span><a href="#42404870">parent</a><span>|</span><a href="#42404784">next</a><span>|</span><label class="collapse" for="c-42405520">[-]</label><label class="expand" for="c-42405520">[3 more]</label></div><br/><div class="children"><div class="content">Erlang absolutely has closures, you are mistaken. What you are referring to are &quot;function captures&quot;, which bind a function reference as a value, and there is no environment to close over with those. However, you can define closures which as you&#x27;d expect, can close over bindings in the environment in which the closure is defined.<p>The interaction between hot reloads and function captures in general is a bit subtle, particularly when it comes to how a function is captured. A fully qualified function capture is reloaded normally, but a capture using just a local name refers to the version of the module at the time it was captured, but is force upgraded after two consecutive hot upgrades, as only two versions of a module are allowed to exist at the same time. For this reason, you have to be careful about how you capture functions, depending on the semantics you want.</div><br/><div id="42406547" class="c"><input type="checkbox" id="c-42406547" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404727">root</a><span>|</span><a href="#42405520">parent</a><span>|</span><a href="#42406072">next</a><span>|</span><label class="collapse" for="c-42406547">[-]</label><label class="expand" for="c-42406547">[1 more]</label></div><br/><div class="children"><div class="content">What does is it look like? I was talking about this thing:<p><pre><code>   Val = 1, SumFun = fun(X) -&gt; X + Val end, SumFun(2).
</code></pre>
It looks like you define arity 1 function that captures Val, while in fact you define arity 2 function and bind 1 as a first argument. Since you can&#x27;t redefine Val anyway, it&#x27;s as good as a closure, but technically it doesn&#x27;t capture the environment.<p>Maybe I&#x27;m mistaken and there is another way to express it?</div><br/></div></div><div id="42406072" class="c"><input type="checkbox" id="c-42406072" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42404727">root</a><span>|</span><a href="#42405520">parent</a><span>|</span><a href="#42406547">prev</a><span>|</span><a href="#42404784">next</a><span>|</span><label class="collapse" for="c-42406072">[-]</label><label class="expand" for="c-42406072">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but is force upgraded after two consecutive hot upgrades, as only two versions of a module are allowed to exist at the same time.<p>Force upgraded is maybe misleading. When a module is loaded for the 3rd time, any processes that still have the first version in their stack are killed. That may result in a supervisor restarting them with new code, if they&#x27;re supervised.</div><br/></div></div></div></div></div></div></div></div><div id="42404784" class="c"><input type="checkbox" id="c-42404784" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#42404727">prev</a><span>|</span><a href="#42405112">next</a><span>|</span><label class="collapse" for="c-42404784">[-]</label><label class="expand" for="c-42404784">[26 more]</label></div><br/><div class="children"><div class="content">hot reload of code is nothing new nowadays, but people use it only locally during development for REPL like development style.<p>in actual production, people prefer to operate at the container level + traffic management, and dont touch anything deeper than the container</div><br/><div id="42407016" class="c"><input type="checkbox" id="c-42407016" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#42404784">parent</a><span>|</span><a href="#42404961">next</a><span>|</span><label class="collapse" for="c-42407016">[-]</label><label class="expand" for="c-42407016">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in actual production, people prefer to operate at the container level + traffic management, and dont touch anything deeper than the container<p>I mean, this seems to be &quot;best practices&quot; these days, but I certainly don&#x27;t prefer it. At least the orchestration I use is amazingly slow. And cold loading changes is terrible for long running processes... this makes deployment a major chore.<p>It&#x27;s less terrible if you&#x27;re just doing mostly stateless web stuff, but that&#x27;s not my world.<p>In the time it takes to run terraform plan, I could have pushed erlang code to all my machines, loaded it, and (usually) confirm I fixed what I wanted to fix.<p>Low cost of deploy means you can do more updates which means they can be smaller which makes them easier to review.</div><br/></div></div><div id="42404961" class="c"><input type="checkbox" id="c-42404961" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42404784">parent</a><span>|</span><a href="#42407016">prev</a><span>|</span><a href="#42405395">next</a><span>|</span><label class="collapse" for="c-42404961">[-]</label><label class="expand" for="c-42404961">[15 more]</label></div><br/><div class="children"><div class="content">&gt; in actual production, people prefer to operate at the container level + traffic management, and dont touch anything deeper than the container<p>How do you think video games like World of Warcraft or Path of Exile deploy restartless hotfixes to millions of concurrent players without killing instances? I don&#x27;t think it&#x27;s a matter of &quot;prefer to&quot;, it&#x27;s a matter of &quot;can we completely disrupt the service for users and potentially lose some of the state&quot;? Even if that disruption lasts a mere millisecond, in some context it&#x27;s not acceptable.</div><br/><div id="42405076" class="c"><input type="checkbox" id="c-42405076" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404961">parent</a><span>|</span><a href="#42405411">next</a><span>|</span><label class="collapse" for="c-42405076">[-]</label><label class="expand" for="c-42405076">[7 more]</label></div><br/><div class="children"><div class="content">Most of those hot fixes are data driven as in database updates. Gameserver just reload the data, the binary itself 
 is not touch.<p>I&#x27;ve never seen a game where they hot reload code inside the gameserver itself, it&#x27;s usually a downtime or rolling updates.</div><br/><div id="42406182" class="c"><input type="checkbox" id="c-42406182" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405076">parent</a><span>|</span><a href="#42405096">next</a><span>|</span><label class="collapse" for="c-42406182">[-]</label><label class="expand" for="c-42406182">[1 more]</label></div><br/><div class="children"><div class="content">LPMUDs ran almost entirely on hot reloadable code written in a quirky language called LPC, which later inspired the Pike language.<p>I believe that only the &quot;driver&quot; code, which handles system calls and hosts the LPC interpreter and is written in C, couldn&#x27;t be hot reloaded; everything else running in the game could be reloaded without restarting the server.<p>I&#x27;d guess in the modern day, there would be some games where Lua scripts can be hot-reloaded like any other data, from a database or object store.</div><br/></div></div><div id="42405096" class="c"><input type="checkbox" id="c-42405096" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405076">parent</a><span>|</span><a href="#42406182">prev</a><span>|</span><a href="#42405411">next</a><span>|</span><label class="collapse" for="c-42405096">[-]</label><label class="expand" for="c-42405096">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Most of those hot fixes are data driven as in database updates. Gameserver just reload the data, the binary itself is not touch.<p>And since the data from the disk&#x2F;database (whether it&#x27;s a Lua table, XML structure, JSON object, or a query) is then representend as a low-level data structure, that&#x27;s essentially what hot reloading is - you deserialize the new data and hot-swap the pointers in the simplest terms.<p>&gt;I&#x27;ve never seen a game where they hot reload code inside the gameserver itself, it&#x27;s usually a downtime or rolling updates.<p>In World of Warcraft, you will literally have bosses despawn mid-fight and spawn again with new stats or you will see their health values update mid-fight, all without the players getting interrupted, their spell state getting desynced, or spawned items in the instance disappearing. This can be observed with the release of every single new raid on live streams as Blizzard employees are watching the world first attempts and tweaking&#x2F;tuning the fights as they happen.<p>EDIT: Here&#x27;s such an example, for the majority of the fight the extra tank could keep a spawned monster away from the boss, then mid-fight, the monster suddenly started one-shotting the tank, without the disruption of the instance, this was Blizzard&#x27;s way of addressing a cheese strat to force the players to do the right as designed: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7gMm60BXAjU" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7gMm60BXAjU</a></div><br/><div id="42405140" class="c"><input type="checkbox" id="c-42405140" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405096">parent</a><span>|</span><a href="#42405411">next</a><span>|</span><label class="collapse" for="c-42405140">[-]</label><label class="expand" for="c-42405140">[4 more]</label></div><br/><div class="children"><div class="content">Yes but again it&#x27;s not hot swapping code as in Erlang, the C++ code is unchanged, they just change some xml somewhere.<p>By your definition every CRUD app have hot reloading capabilities.</div><br/><div id="42405152" class="c"><input type="checkbox" id="c-42405152" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405140">parent</a><span>|</span><a href="#42405293">next</a><span>|</span><label class="collapse" for="c-42405152">[-]</label><label class="expand" for="c-42405152">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yes but again it&#x27;s not hot swapping code as in Erlang, the C++ code is unchanged, they just change some xml somewhere.<p>Right, not on the C++ side, but on the Lua side that WoW uses - you load the new gameplay code that pulls the new data, and override the globals with new functions.</div><br/></div></div><div id="42405293" class="c"><input type="checkbox" id="c-42405293" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405140">parent</a><span>|</span><a href="#42405152">prev</a><span>|</span><a href="#42405411">next</a><span>|</span><label class="collapse" for="c-42405293">[-]</label><label class="expand" for="c-42405293">[2 more]</label></div><br/><div class="children"><div class="content">Why does it matter the language? C++ built in the tooling to allow hot swapping, no?</div><br/><div id="42405355" class="c"><input type="checkbox" id="c-42405355" checked=""/><div class="controls bullet"><span class="by">Thaxll</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405293">parent</a><span>|</span><a href="#42405411">next</a><span>|</span><label class="collapse" for="c-42405355">[-]</label><label class="expand" for="c-42405355">[1 more]</label></div><br/><div class="children"><div class="content">C++ because 99% of the major games are built in that language.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42405411" class="c"><input type="checkbox" id="c-42405411" checked=""/><div class="controls bullet"><span class="by">swat535</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404961">parent</a><span>|</span><a href="#42405076">prev</a><span>|</span><a href="#42405017">next</a><span>|</span><label class="collapse" for="c-42405411">[-]</label><label class="expand" for="c-42405411">[1 more]</label></div><br/><div class="children"><div class="content">In addition to what most people said, many other game servers just simply announce upcoming maintenance work and take the services offline until the patches are deployed.<p>This way they can properly test everything and rollback any potential fixes if required.. even banking systems regularly goes down for maintenance.</div><br/></div></div><div id="42405017" class="c"><input type="checkbox" id="c-42405017" checked=""/><div class="controls bullet"><span class="by">AnotherGoodName</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404961">parent</a><span>|</span><a href="#42405411">prev</a><span>|</span><a href="#42404996">next</a><span>|</span><label class="collapse" for="c-42405017">[-]</label><label class="expand" for="c-42405017">[2 more]</label></div><br/><div class="children"><div class="content">That’s a very big assumption that they do code hotpatching.<p>It would seem far more likely they seperate the stateful (database) and stateless layers (game logic) and they just spin up a new instance of the stateless server layer behind a reverse proxy and spin down the old instance. It’s basically how all websites update without down time.</div><br/><div id="42405059" class="c"><input type="checkbox" id="c-42405059" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405017">parent</a><span>|</span><a href="#42404996">next</a><span>|</span><label class="collapse" for="c-42405059">[-]</label><label class="expand" for="c-42405059">[1 more]</label></div><br/><div class="children"><div class="content">A website that just proxies to another server does not need to do much to restore the previous state to make it look seamless to a user, the client will just perform another GET request that triggers a few SELECT queries, it&#x27;s far more complex in the context of a video game.</div><br/></div></div></div></div><div id="42404996" class="c"><input type="checkbox" id="c-42404996" checked=""/><div class="controls bullet"><span class="by">qudat</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404961">parent</a><span>|</span><a href="#42405017">prev</a><span>|</span><a href="#42404986">next</a><span>|</span><label class="collapse" for="c-42404996">[-]</label><label class="expand" for="c-42404996">[2 more]</label></div><br/><div class="children"><div class="content">WoW restarts every week. Not sure that’s better than zero downtime deployments</div><br/><div id="42405028" class="c"><input type="checkbox" id="c-42405028" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404996">parent</a><span>|</span><a href="#42404986">next</a><span>|</span><label class="collapse" for="c-42405028">[-]</label><label class="expand" for="c-42405028">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s just how it works when your backend is a hybrid software that utilizes a low-level compiled programming language and a high-level language that runs in its own VM. You can use the latter for gameplay features, and can hotfix on the go, and then for core changes you have to restart, which is also why WoW will hotfix the latter on the go, usually every day on an expansion launch, whereas they defer the bulk of backend changes for the next weekly restart without continuously disrupting the game for players.</div><br/></div></div></div></div><div id="42404986" class="c"><input type="checkbox" id="c-42404986" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404961">parent</a><span>|</span><a href="#42404996">prev</a><span>|</span><a href="#42405395">next</a><span>|</span><label class="collapse" for="c-42404986">[-]</label><label class="expand" for="c-42404986">[2 more]</label></div><br/><div class="children"><div class="content">Games do in fact have downtimes on major releases and you have to restart the client too before connecting.</div><br/><div id="42404987" class="c"><input type="checkbox" id="c-42404987" checked=""/><div class="controls bullet"><span class="by">diath</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42404986">parent</a><span>|</span><a href="#42405395">next</a><span>|</span><label class="collapse" for="c-42404987">[-]</label><label class="expand" for="c-42404987">[1 more]</label></div><br/><div class="children"><div class="content">For major patches&#x2F;backend changes that require recompiling - yes, for gameplay tweaks&#x2F;hotfixes - no, hot reloading is preferable where possible.</div><br/></div></div></div></div></div></div><div id="42405395" class="c"><input type="checkbox" id="c-42405395" checked=""/><div class="controls bullet"><span class="by">aeturnum</span><span>|</span><a href="#42404784">parent</a><span>|</span><a href="#42404961">prev</a><span>|</span><a href="#42405024">next</a><span>|</span><label class="collapse" for="c-42405395">[-]</label><label class="expand" for="c-42405395">[1 more]</label></div><br/><div class="children"><div class="content">I work at a company that deploys Elixir&#x2F;Erlang and while we do &#x2F;prefer&#x2F; to push a fully tested build in a new container, sometimes things get nasty and we need to console in and re-define a module in production. It&#x27;s not a &quot;best practice&quot; but it stems the bleeding while the best practice is going though its test suite.</div><br/></div></div><div id="42405024" class="c"><input type="checkbox" id="c-42405024" checked=""/><div class="controls bullet"><span class="by">AlphaWeaver</span><span>|</span><a href="#42404784">parent</a><span>|</span><a href="#42405395">prev</a><span>|</span><a href="#42404916">next</a><span>|</span><label class="collapse" for="c-42405024">[-]</label><label class="expand" for="c-42405024">[5 more]</label></div><br/><div class="children"><div class="content">People may &quot;prefer&quot; simply replacing containers, but as some siblings mention, some applications might require more reliability guarantees.<p>Erlang was originally designed for implementing telephony protocols, where interrupted phone calls were not an acceptable side effect of application updates.</div><br/><div id="42405043" class="c"><input type="checkbox" id="c-42405043" checked=""/><div class="controls bullet"><span class="by">AnotherGoodName</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405024">parent</a><span>|</span><a href="#42404916">next</a><span>|</span><label class="collapse" for="c-42405043">[-]</label><label class="expand" for="c-42405043">[4 more]</label></div><br/><div class="children"><div class="content">FWIW as soon as you start using containers you should be able to handle those containers spinning up&#x2F;down. Pretty much the whole point of containers. At which point you don’t need to bother with code hot swapping since you already have a mechanism for newer containers to spin up while older ones spin down.<p>The sibling post “that’s how they update without downtime” is super naive. It is absolutely not how they do it.</div><br/><div id="42405100" class="c"><input type="checkbox" id="c-42405100" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405043">parent</a><span>|</span><a href="#42404916">next</a><span>|</span><label class="collapse" for="c-42405100">[-]</label><label class="expand" for="c-42405100">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s kinda what erlang does, just on a different level. Your docker and your load balancer are both inside your app.</div><br/><div id="42405508" class="c"><input type="checkbox" id="c-42405508" checked=""/><div class="controls bullet"><span class="by">simoncion</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405100">parent</a><span>|</span><a href="#42404916">next</a><span>|</span><label class="collapse" for="c-42405508">[-]</label><label class="expand" for="c-42405508">[2 more]</label></div><br/><div class="children"><div class="content">If we to wedge how Erlang does hot code swapping into a container metaphor, then to get what Erlang does, you&#x27;d need to have a container per function call.<p>Given that it would be absurdly wasteful to use OS processes in containers to clone Erlang&#x27;s code reload system, AnotherGoodName might take ten minute to watch Erlang: The Movie to get a better sense of the capabilities of that system. The movie is available from many places, including archive.org.</div><br/><div id="42406596" class="c"><input type="checkbox" id="c-42406596" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404784">root</a><span>|</span><a href="#42405508">parent</a><span>|</span><a href="#42404916">next</a><span>|</span><label class="collapse" for="c-42406596">[-]</label><label class="expand" for="c-42406596">[1 more]</label></div><br/><div class="children"><div class="content">&gt;If we to wedge how Erlang does hot code swapping into a container metaphor, then to get what Erlang does, you&#x27;d need to have a container per function call.<p>You have a container that responds to HTPP requests sitting behind a load balancer, then you spawn a new container and tell load balancer to redirect calls to the new one. From the point of view of whoever is calling the load balancer you have hot swapping. You may even separate containers into logical groups and call it microservices architecture. Or you can define a process as something having qualified name and a mailbox and is sending messages to other processes.<p>Now reasonable people may disagree about what&#x27;s wasteful, but the market seems to tolerate places where adding a checkbox to a form is a half a year process involving five different departments and the market can&#x27;t be wrong.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42404916" class="c"><input type="checkbox" id="c-42404916" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42404784">parent</a><span>|</span><a href="#42405024">prev</a><span>|</span><a href="#42405650">next</a><span>|</span><label class="collapse" for="c-42404916">[-]</label><label class="expand" for="c-42404916">[1 more]</label></div><br/><div class="children"><div class="content">Amusingly, this reminds me sort of about the story of a person who joins a new company only to discover that their programming framework is intricately linked to their version control system.</div><br/></div></div><div id="42405650" class="c"><input type="checkbox" id="c-42405650" checked=""/><div class="controls bullet"><span class="by">simoncion</span><span>|</span><a href="#42404784">parent</a><span>|</span><a href="#42404916">prev</a><span>|</span><a href="#42404925">next</a><span>|</span><label class="collapse" for="c-42405650">[-]</label><label class="expand" for="c-42405650">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in actual production, people prefer to operate at the container level + traffic management, and dont touch anything deeper than the container<p>Fred Hebert (and many of the folks he has worked with) do not operate that way: &lt;<a href="https:&#x2F;&#x2F;ferd.ca&#x2F;a-pipeline-made-of-airbags.html" rel="nofollow">https:&#x2F;&#x2F;ferd.ca&#x2F;a-pipeline-made-of-airbags.html</a>&gt;<p>One nice quote (out of many) from the article:<p>&gt; The thing that stateless containers and kubernetes do is handle that base case of &quot;when a thing is wrong, replace it and get back to a good state.&quot; The thing it does not easily let you do is &quot;and then start iterating to get better and better at not losing all your state and recuperating fast&quot;.<p>(And if one wants to argue with that quote, please read the entire essay first. There&#x27;s important context that&#x27;s relevant to fully understanding Hebert&#x27;s opinion here.)</div><br/></div></div></div></div><div id="42405112" class="c"><input type="checkbox" id="c-42405112" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#42404784">prev</a><span>|</span><a href="#42404718">next</a><span>|</span><label class="collapse" for="c-42405112">[-]</label><label class="expand" for="c-42405112">[4 more]</label></div><br/><div class="children"><div class="content">(2016)</div><br/><div id="42405480" class="c"><input type="checkbox" id="c-42405480" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42405112">parent</a><span>|</span><a href="#42404718">next</a><span>|</span><label class="collapse" for="c-42405480">[-]</label><label class="expand" for="c-42405480">[3 more]</label></div><br/><div class="children"><div class="content">Where do you see that? I couldn&#x27;t find it.</div><br/><div id="42405512" class="c"><input type="checkbox" id="c-42405512" checked=""/><div class="controls bullet"><span class="by">gnabgib</span><span>|</span><a href="#42405112">root</a><span>|</span><a href="#42405480">parent</a><span>|</span><a href="#42404718">next</a><span>|</span><label class="collapse" for="c-42405512">[-]</label><label class="expand" for="c-42405512">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s in the URL :D  But yeah, the page doesn&#x27;t make it clear (and some of the embedded JS has a 2020 date suggesting it&#x27;s received updates).<p>In the RSS feed too: Wed, 07 Dec 2016 <a href="https:&#x2F;&#x2F;kennyballou.com&#x2F;index.xml" rel="nofollow">https:&#x2F;&#x2F;kennyballou.com&#x2F;index.xml</a></div><br/><div id="42406089" class="c"><input type="checkbox" id="c-42406089" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42405112">root</a><span>|</span><a href="#42405512">parent</a><span>|</span><a href="#42404718">next</a><span>|</span><label class="collapse" for="c-42406089">[-]</label><label class="expand" for="c-42406089">[1 more]</label></div><br/><div class="children"><div class="content">Hidden in plain view! Ok, let&#x27;s put 2016 above, on the assumption that the edits since then haven&#x27;t been too major.</div><br/></div></div></div></div></div></div></div></div><div id="42404718" class="c"><input type="checkbox" id="c-42404718" checked=""/><div class="controls bullet"><span class="by">omertoast</span><span>|</span><a href="#42405112">prev</a><span>|</span><label class="collapse" for="c-42404718">[-]</label><label class="expand" for="c-42404718">[18 more]</label></div><br/><div class="children"><div class="content">i&#x27;m so sick of this DevOps bullshit i wonder if there is an alternative language that you can hot swap code and do all the black magic stuff while keeping the reliability and performance like Rust.</div><br/><div id="42404737" class="c"><input type="checkbox" id="c-42404737" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42404718">parent</a><span>|</span><a href="#42405144">next</a><span>|</span><label class="collapse" for="c-42404737">[-]</label><label class="expand" for="c-42404737">[9 more]</label></div><br/><div class="children"><div class="content">I am shocked at the idea of anyone implying that Erlang is &quot;unreliable&quot;... it&#x27;s entire reason for existence was to step up the game on reliability.</div><br/><div id="42405640" class="c"><input type="checkbox" id="c-42405640" checked=""/><div class="controls bullet"><span class="by">dcsommer</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404737">parent</a><span>|</span><a href="#42405160">next</a><span>|</span><label class="collapse" for="c-42405640">[-]</label><label class="expand" for="c-42405640">[1 more]</label></div><br/><div class="children"><div class="content">GP seems to be implying hot swapping, not Erlang, is unreliable. To which, from my experience using it in Erlang, I heartily agree is fraught. Inconsistent state across nodes is much harder to reason about. When you _must_ ensure consistency, hot swapping is reckless, especially as org size and product complexity increases.<p>Leave hot loading to local&#x2F;development environments, not production deploys.<p>Loading configs on the fly can also have some of this risk, but it is much easier to reason about typically.</div><br/></div></div><div id="42405160" class="c"><input type="checkbox" id="c-42405160" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404737">parent</a><span>|</span><a href="#42405640">prev</a><span>|</span><a href="#42405011">next</a><span>|</span><label class="collapse" for="c-42405160">[-]</label><label class="expand" for="c-42405160">[2 more]</label></div><br/><div class="children"><div class="content">I heard the quote that some 50% of the mobile traffic is handled by erlang. Somehow the other 50% seems to be doing just fine (except the usual shitshow on the inside that sofware is everywhere all the time).</div><br/><div id="42405646" class="c"><input type="checkbox" id="c-42405646" checked=""/><div class="controls bullet"><span class="by">simoncion</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42405160">parent</a><span>|</span><a href="#42405011">next</a><span>|</span><label class="collapse" for="c-42405646">[-]</label><label class="expand" for="c-42405646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I heard the quote that some 50% of the mobile traffic is handled by erlang.<p>Given that you can implement OTP in any language (albeit with varying degrees of difficulty), that&#x27;s not surprising.<p>The thing to remember is that Erlang was first used in production in like <i>1986</i>. nearly forty years is more than enough time for the biggest good ideas in Erlang to percolate out into non-BEAM systems.</div><br/></div></div></div></div><div id="42405011" class="c"><input type="checkbox" id="c-42405011" checked=""/><div class="controls bullet"><span class="by">zanderwohl</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404737">parent</a><span>|</span><a href="#42405160">prev</a><span>|</span><a href="#42405473">next</a><span>|</span><label class="collapse" for="c-42405011">[-]</label><label class="expand" for="c-42405011">[2 more]</label></div><br/><div class="children"><div class="content">I agree. I don&#x27;t know much about Erlang but what I&#x27;ve heard seems to indicate it&#x27;s used for high-uptime systems that handle errors well.</div><br/><div id="42405171" class="c"><input type="checkbox" id="c-42405171" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42405011">parent</a><span>|</span><a href="#42405473">next</a><span>|</span><label class="collapse" for="c-42405171">[-]</label><label class="expand" for="c-42405171">[1 more]</label></div><br/><div class="children"><div class="content">I suspect the causality is reversed. When you have a good designed telecom system, then spmething shaped as erlang happens to be a good tool to create to implement it. The tool than keeps you committed to the design choices you made by being restrictive enough.</div><br/></div></div></div></div><div id="42405473" class="c"><input type="checkbox" id="c-42405473" checked=""/><div class="controls bullet"><span class="by">LAC-Tech</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404737">parent</a><span>|</span><a href="#42405011">prev</a><span>|</span><a href="#42404808">next</a><span>|</span><label class="collapse" for="c-42405473">[-]</label><label class="expand" for="c-42405473">[1 more]</label></div><br/><div class="children"><div class="content">As someone who is now in the rust world and very very sympathetic to the Erlang world... you both probably mean completely different things when you say &quot;reliable&quot;. The contexts are just world apart.</div><br/></div></div></div></div><div id="42405144" class="c"><input type="checkbox" id="c-42405144" checked=""/><div class="controls bullet"><span class="by">lamuswawir</span><span>|</span><a href="#42404718">parent</a><span>|</span><a href="#42404737">prev</a><span>|</span><a href="#42404942">next</a><span>|</span><label class="collapse" for="c-42405144">[-]</label><label class="expand" for="c-42405144">[3 more]</label></div><br/><div class="children"><div class="content">Erlang is built for reliability. They&#x27;re chasing nine nines. Everything about the BEAM is built to emphasize that, the design choices, the documentation, the recommended practices.<p>Erlang is not very fast, but that&#x27;s not what it was built for.</div><br/><div id="42405241" class="c"><input type="checkbox" id="c-42405241" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42405144">parent</a><span>|</span><a href="#42404942">next</a><span>|</span><label class="collapse" for="c-42405241">[-]</label><label class="expand" for="c-42405241">[2 more]</label></div><br/><div class="children"><div class="content">Is it really beam or just otp? Sure, beam gives you processes, network-transparent send, immutable structures and linking-monitoring thingy on top, but is what makes it good to shoot for nines?<p>I suspect the aura of mistycism around yet another jit vm is not that warranted</div><br/><div id="42405349" class="c"><input type="checkbox" id="c-42405349" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42405241">parent</a><span>|</span><a href="#42404942">next</a><span>|</span><label class="collapse" for="c-42405349">[-]</label><label class="expand" for="c-42405349">[1 more]</label></div><br/><div class="children"><div class="content">It is reasonable to conceive of Erlang as encompassing OTP. Perhaps somewhere in the world there is some developer out there hot on Erlang but just hates OTP and doesn&#x27;t use it, but they must be fairly frustrated at how hard it is to keep OTP out of their code base if they ever need any libraries.<p>Restarting is arguably the definitive thing that makes Erlang stack the 9s out past what most languages and runtimes can achieve... the thing is, it&#x27;s more complicated to use in practice than a web page like this makes it look,  and it&#x27;s beyond what most products need. Few applications <i>need</i> the fifth or sixth or seventh nine, and it gets to the point that you can&#x27;t have it anyhow because your Erlang cluster, no matter how well distributed, itself probably doesn&#x27;t have 99.99999 availability, and your users probably don&#x27;t have 99.99999 availability on their own network connection.<p>It&#x27;s not impossibly complicated, but it is the sort of thing where you if you want to use the feature you need to have it sort of constantly in mind as you write the rest of your system, and it&#x27;s a lot easier even in Erlang to just design the system to take entire nodes down and bring them back up, if not the entire cluster down, rather than fuss with hot reloads. I wish Erlang advocates would be more upfront about pitching this as an interesting niche feature, but not really a reason to consider Erlang. Unless you <i>absolutely need it</i>, in which case it can indeed be the thing that puts it on the short list of choices... but as evidenced by the vast, vast majority of software and systems not being on Erlang and managing to get along, there aren&#x27;t really that many things that <i>need</i> it.</div><br/></div></div></div></div></div></div><div id="42404942" class="c"><input type="checkbox" id="c-42404942" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404718">parent</a><span>|</span><a href="#42405144">prev</a><span>|</span><a href="#42404829">next</a><span>|</span><label class="collapse" for="c-42404942">[-]</label><label class="expand" for="c-42404942">[1 more]</label></div><br/><div class="children"><div class="content">The black magic comes at the cost of not having one streamlined procedure to release stuff.<p>And to make the black magic work you have to engage with it. Most of the time people don&#x27;t even bother write to a proper import.meta.hot.accept thingy in javascript. Developers simply hate chores, which is evident by not willing to write proper unit tests (despite knowing that tests work) or writing just enough to let the coverage cop pass ship the build.<p>A dedicated small team running something like whatsup? Sure, look into the arcane and let it look back at you (although high insight makes one more susceptible to madness you know). But most of the time you will do better job with PHP in a stupid restartable box behind seven load balancing proxies.</div><br/></div></div><div id="42404829" class="c"><input type="checkbox" id="c-42404829" checked=""/><div class="controls bullet"><span class="by">sergiotapia</span><span>|</span><a href="#42404718">parent</a><span>|</span><a href="#42404942">prev</a><span>|</span><label class="collapse" for="c-42404829">[-]</label><label class="expand" for="c-42404829">[4 more]</label></div><br/><div class="children"><div class="content">we had this wonderful thing in PHP where you would just save a .php file and bada bing it was LIVE.<p>what happened? :D</div><br/><div id="42404957" class="c"><input type="checkbox" id="c-42404957" checked=""/><div class="controls bullet"><span class="by">thanksgiving</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404829">parent</a><span>|</span><a href="#42405259">next</a><span>|</span><label class="collapse" for="c-42404957">[-]</label><label class="expand" for="c-42404957">[2 more]</label></div><br/><div class="children"><div class="content">They took away our access after one too many outages :yay:</div><br/><div id="42405108" class="c"><input type="checkbox" id="c-42405108" checked=""/><div class="controls bullet"><span class="by">Muromec</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404957">parent</a><span>|</span><a href="#42405259">next</a><span>|</span><label class="collapse" for="c-42405108">[-]</label><label class="expand" for="c-42405108">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like what happened with hot upgrade privileges in some erlang shops too.</div><br/></div></div></div></div><div id="42405259" class="c"><input type="checkbox" id="c-42405259" checked=""/><div class="controls bullet"><span class="by">cardanome</span><span>|</span><a href="#42404718">root</a><span>|</span><a href="#42404829">parent</a><span>|</span><a href="#42404957">prev</a><span>|</span><label class="collapse" for="c-42405259">[-]</label><label class="expand" for="c-42405259">[1 more]</label></div><br/><div class="children"><div class="content">We still have that and it is awesome. PHP is better than ever.<p>In serious emergencies I even sometimes end up quickly SSH-en to a prod server and changing the file directly. Which is kind of horrifying but hey customer is happy it got fixed immediately and I get to relax and take my time to write a proper fix. Beats sweating and watching the pipeline build and asking around for people to approve my merge request.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>