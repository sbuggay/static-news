<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720170065432" as="style"/><link rel="stylesheet" href="styles.css?v=1720170065432"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html">The sad state of property-based testing libraries</a> <span class="domain">(<a href="https://stevana.github.io">stevana.github.io</a>)</span></div><div class="subtext"><span>nequo</span> | <span>88 comments</span></div><br/><div><div id="40879291" class="c"><input type="checkbox" id="c-40879291" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40880819">next</a><span>|</span><label class="collapse" for="c-40879291">[-]</label><label class="expand" for="c-40879291">[3 more]</label></div><br/><div class="children"><div class="content">Anecdotally, I had a fantastic experience with `clojure.spec.alpha` (with or without `test.check`), and when I went to use python&#x27;s `hypothesis` it was just... abysmal.<p>It seems like Hypothesis is <i>unable</i> to handle simple but &quot;large&quot; data sets &gt;&gt;by design&lt;&lt;, where &quot;large&quot; is really not so large. [0] It was such a pain that we ripped out Hypothesis (and generative testing altogether, sadly) completely from our python test suite at work.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis&#x2F;issues&#x2F;3493">https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis&#x2F;issues&#x2F;3493</a></div><br/><div id="40879952" class="c"><input type="checkbox" id="c-40879952" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40879291">parent</a><span>|</span><a href="#40879950">next</a><span>|</span><label class="collapse" for="c-40879952">[-]</label><label class="expand" for="c-40879952">[1 more]</label></div><br/><div class="children"><div class="content">it doesn&#x27;t sound like hypothesis that unable to handles large data sets in this case, though that is indeed not its forte; it sounds like you were rejecting a large proportion of the shrunk instances, so hypothesis would try shrinking by setting a generated integer to zero, in order to see if the bug still existed for zero, and your test would reject it because it had a zero in it.  not fail, but reject. for small instances this was just inefficient, but for larger ones it got to the point that hypothesis gave up<p>someone in that thread suggested that you use a different instance generation strategy that can&#x27;t generate zeroes, instead of rejecting the instances hypothesis&#x27;s shrinker most loves to generate, once they are generated.  did you try that?<p>how does clojure.spec.alpha handle this differently?<p>in mjaniczek&#x27;s comment at <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40876437">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40876437</a>, they call out your case as a disadvantage of hypothesis&#x27;s approach:<p>&gt; <i>The disadvantage is that the generators are now parsers from the lists of bytes that can fail (introducing some inefficiency) and user can make a crazy generator that the internal shrinker will not be able to shrink perfectly. Nevertheless, it&#x27;s the best DX of the three approaches, ...</i><p>though presumably you wouldn&#x27;t agree that your test was written in a &#x27;crazy&#x27; way</div><br/></div></div><div id="40879950" class="c"><input type="checkbox" id="c-40879950" checked=""/><div class="controls bullet"><span class="by">ilikehurdles</span><span>|</span><a href="#40879291">parent</a><span>|</span><a href="#40879952">prev</a><span>|</span><a href="#40880819">next</a><span>|</span><label class="collapse" for="c-40879950">[-]</label><label class="expand" for="c-40879950">[1 more]</label></div><br/><div class="children"><div class="content">Yep. I loved clojure’s spec as it was really easy to build around and then I moved to elixir and found that I have to… drop down to an old erlang library (propEr) to write tests like that. Pretty disappointing.</div><br/></div></div></div></div><div id="40880819" class="c"><input type="checkbox" id="c-40880819" checked=""/><div class="controls bullet"><span class="by">arohner</span><span>|</span><a href="#40879291">prev</a><span>|</span><a href="#40877616">next</a><span>|</span><label class="collapse" for="c-40880819">[-]</label><label class="expand" for="c-40880819">[1 more]</label></div><br/><div class="children"><div class="content">Clojure does have stateful quickcheck library now: <a href="https:&#x2F;&#x2F;github.com&#x2F;griffinbank&#x2F;test.contract">https:&#x2F;&#x2F;github.com&#x2F;griffinbank&#x2F;test.contract</a><p>Parallel testing is interesting, but hasn&#x27;t been a large source of pain yet.</div><br/></div></div><div id="40877616" class="c"><input type="checkbox" id="c-40877616" checked=""/><div class="controls bullet"><span class="by">PeterisP</span><span>|</span><a href="#40880819">prev</a><span>|</span><a href="#40876822">next</a><span>|</span><label class="collapse" for="c-40877616">[-]</label><label class="expand" for="c-40877616">[9 more]</label></div><br/><div class="children"><div class="content">The simple answer to a question posed in the article &quot;On the other hand one could ask why there isn’t a requirement that published research should be reproducible using open source tools (or at least tools that are freely available to the public and other researchers)?&quot; is that the obvious immediate outcome of such a requirement is that papers failing that requirement - like the  Quviq QuickCheck papers, which seem to have been useful to the author and others - simply would not get published, and the community would lose out on that gift of information.</div><br/><div id="40877687" class="c"><input type="checkbox" id="c-40877687" checked=""/><div class="controls bullet"><span class="by">spencerchubb</span><span>|</span><a href="#40877616">parent</a><span>|</span><a href="#40879644">next</a><span>|</span><label class="collapse" for="c-40877687">[-]</label><label class="expand" for="c-40877687">[3 more]</label></div><br/><div class="children"><div class="content">I think it would be good to have some publishers require reproducibility, and some publishers that don&#x27;t. Every requirement is exclusionary, and there are always edge cases where a paper can be useful even if it doesn&#x27;t fulfill a requirement.</div><br/><div id="40878073" class="c"><input type="checkbox" id="c-40878073" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#40877616">root</a><span>|</span><a href="#40877687">parent</a><span>|</span><a href="#40877933">next</a><span>|</span><label class="collapse" for="c-40878073">[-]</label><label class="expand" for="c-40878073">[1 more]</label></div><br/><div class="children"><div class="content">As an intermediate point in the Require Reproducibility ↔ No Requirement spectrum, strong encouragement to have reproducible artifacts is attractive as well. I just got a paper accepted to ECOOP (European Conference on OO Programming; has lost it&#x27;s OO-focus and is now a general PL conference) and it&#x27;s trying something relatively new: artifact evaluations are considered as part of the submission process. Our paper had a reproducible <i>and</i> reusable artifact, and I think that helped our case with the reviewers.</div><br/></div></div><div id="40877933" class="c"><input type="checkbox" id="c-40877933" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40877616">root</a><span>|</span><a href="#40877687">parent</a><span>|</span><a href="#40878073">prev</a><span>|</span><a href="#40879644">next</a><span>|</span><label class="collapse" for="c-40877933">[-]</label><label class="expand" for="c-40877933">[1 more]</label></div><br/><div class="children"><div class="content">That’s already the case. Eurosys includes an Artifact Evaluation for submitted papers - which typically includes code and data to allow reviewers to reproduce the work described in the paper. It’s optional, but encouraged.<p>This page lists the artifact evaluation criteria for a handful of conferences:<p><a href="https:&#x2F;&#x2F;sysartifacts.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sysartifacts.github.io&#x2F;</a></div><br/></div></div></div></div><div id="40879644" class="c"><input type="checkbox" id="c-40879644" checked=""/><div class="controls bullet"><span class="by">krick</span><span>|</span><a href="#40877616">parent</a><span>|</span><a href="#40877687">prev</a><span>|</span><a href="#40880428">next</a><span>|</span><label class="collapse" for="c-40879644">[-]</label><label class="expand" for="c-40879644">[2 more]</label></div><br/><div class="children"><div class="content">Obviously this is not a clear-cut question (one might even call it a political question, and those are notoriously no clear-cut), but this is hardly a valid defence. Because if you consider it valid, you can go however far you like using this statement as a shield. If you abandon reproducibility as a requirement, you don&#x27;t have to explain anything you don&#x27;t want to explain. You don&#x27;t have to provide any data about your samples, no statistical significance tests. A vague abstract claiming such and such result has been achieved would be enough. Heck, the famous Fermat&#x27;s margin-note on his private copy of Arithmetica is a totally valid research paper then: after all, we wouldn&#x27;t want to lose out on the precious gift of information that a particular famous mathematician <i>thought</i> he has a concise and elegant proof of a theorem (even though he probably hadn&#x27;t)!<p>FWIW, my own opinion on that political question is that current standards are way to loose. After all, nobody is forced to publish anything. There is a lot of research happening in the world, that is never published anywhere (e.g. because of proprietary value). It will never go away (unless the world reaches some communist-utopia, but even then it will be doubtful for other reasons). But if one works in academia (and, God forbid, receives grants for his work!) and his stated goal is to move world&#x27;s scientific knowledge further, it&#x27;s only fair to ask for him to actually follow that goal, and not just simply <i>pretend</i> following that goal in order to move up that twisted ladder of his academic career.</div><br/><div id="40880379" class="c"><input type="checkbox" id="c-40880379" checked=""/><div class="controls bullet"><span class="by">vasco</span><span>|</span><a href="#40877616">root</a><span>|</span><a href="#40879644">parent</a><span>|</span><a href="#40880428">next</a><span>|</span><label class="collapse" for="c-40880379">[-]</label><label class="expand" for="c-40880379">[1 more]</label></div><br/><div class="children"><div class="content">I wholly agree with you, and on the other hand have seen enough researcher code that I know why they don&#x27;t share it. Usually it&#x27;s such bad quality, hammered by multiple students to get to some goal, that by the end I was surprised they even trust the output. Publishing would at least make them know from the start this will have to be open sourced and probably even increase the success rate of research by improving coding standards.</div><br/></div></div></div></div><div id="40880428" class="c"><input type="checkbox" id="c-40880428" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#40877616">parent</a><span>|</span><a href="#40879644">prev</a><span>|</span><a href="#40878247">next</a><span>|</span><label class="collapse" for="c-40880428">[-]</label><label class="expand" for="c-40880428">[1 more]</label></div><br/><div class="children"><div class="content">Because reproducibility is the cornerstone of the scientific method.</div><br/></div></div><div id="40878247" class="c"><input type="checkbox" id="c-40878247" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#40877616">parent</a><span>|</span><a href="#40880428">prev</a><span>|</span><a href="#40880880">next</a><span>|</span><label class="collapse" for="c-40878247">[-]</label><label class="expand" for="c-40878247">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t it be possible to make the source available for the reviewers only? With whatever is needed to make the code run too.<p>Maybe that&#x27;s already being done though!</div><br/></div></div><div id="40880880" class="c"><input type="checkbox" id="c-40880880" checked=""/><div class="controls bullet"><span class="by">crabbone</span><span>|</span><a href="#40877616">parent</a><span>|</span><a href="#40878247">prev</a><span>|</span><a href="#40876822">next</a><span>|</span><label class="collapse" for="c-40880880">[-]</label><label class="expand" for="c-40880880">[1 more]</label></div><br/><div class="children"><div class="content">Papers get published because authors want to increase their &quot;importance index&quot;, which is in very direct correlation with how much they will get paid and whether they&#x27;ll be making a career in academia.<p>Having more requirements towards that end is unlikely to impact the number of papers published.<p>The more severe problem with published papers is mistakes often deliberately overlooked in order to publish as much and as fast as possible.  Having papers being easier to verify has a chance of improving this situation... but I wouldn&#x27;t hold my breath.  People are very good at cutting corners.</div><br/></div></div></div></div><div id="40876822" class="c"><input type="checkbox" id="c-40876822" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40877616">prev</a><span>|</span><a href="#40876523">next</a><span>|</span><label class="collapse" for="c-40876822">[-]</label><label class="expand" for="c-40876822">[20 more]</label></div><br/><div class="children"><div class="content">With the advent of coverage based fuzzing, and how well supported it is in Go, what am I missing from not using one of the property based testing libraries?<p><a href="https:&#x2F;&#x2F;www.tedinski.com&#x2F;2018&#x2F;12&#x2F;11&#x2F;fuzzing-and-property-testing.html" rel="nofollow">https:&#x2F;&#x2F;www.tedinski.com&#x2F;2018&#x2F;12&#x2F;11&#x2F;fuzzing-and-property-tes...</a><p>Like, with the below fuzz test, and the corresponding invariant checks, isn&#x27;t this all but equivalent to property tests?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;aa&#x2F;blob&#x2F;505cbbf94973042cc7af4d6be6266454bb2d864e&#x2F;aa_test.go#L374-L403">https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;aa&#x2F;blob&#x2F;505cbbf94973042cc7af4d6be...</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;aa&#x2F;blob&#x2F;505cbbf94973042cc7af4d6be6266454bb2d864e&#x2F;util_test.go#L5-L28">https:&#x2F;&#x2F;github.com&#x2F;ncruces&#x2F;aa&#x2F;blob&#x2F;505cbbf94973042cc7af4d6be...</a></div><br/><div id="40878620" class="c"><input type="checkbox" id="c-40878620" checked=""/><div class="controls bullet"><span class="by">hyperpape</span><span>|</span><a href="#40876822">parent</a><span>|</span><a href="#40878340">next</a><span>|</span><label class="collapse" for="c-40878620">[-]</label><label class="expand" for="c-40878620">[6 more]</label></div><br/><div class="children"><div class="content">The distinction between property based testing and fuzzing is basically just a rough cluster of vibes. It describes a real difference, but the borders are pretty vague and precisely deciding which things are fuzzing and which are PBT isn’t really that critical.<p>- Quick running tests, detailed assertions —&gt; PBT<p>- Longer tests, just looking for a crash —&gt; fuzzing.<p>- In between, who knows?<p><a href="https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;what-is-property-based-testing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hypothesis.works&#x2F;articles&#x2F;what-is-property-based-tes...</a></div><br/><div id="40878966" class="c"><input type="checkbox" id="c-40878966" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40878620">parent</a><span>|</span><a href="#40879059">next</a><span>|</span><label class="collapse" for="c-40878966">[-]</label><label class="expand" for="c-40878966">[4 more]</label></div><br/><div class="children"><div class="content">Interesting read. I guess I&#x27;m mostly interested in on number 2 here:<p><pre><code>    Under this point of view, a property-based testing library is really two parts:
    1. A fuzzer.
    2. A library of tools for making it easy to construct property-based tests using that fuzzer.
</code></pre>
What should I (we?) be building on top of Go&#x27;s fuzzer to make it easier to construct property-based tests?<p>My current strategy is to interpret a byte stream as a sequence of &quot;commands&quot;, let those be transitions that drive my &quot;state machine&quot;, then test all invariants I can think of at every step.</div><br/><div id="40879848" class="c"><input type="checkbox" id="c-40879848" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40878966">parent</a><span>|</span><a href="#40879703">prev</a><span>|</span><a href="#40879059">next</a><span>|</span><label class="collapse" for="c-40879848">[-]</label><label class="expand" for="c-40879848">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; What should I (we?) be building on top of Go&#x27;s fuzzer to make it easier to construct property-based tests?</i><p>What&#x27;s the intent behind building on top of Go&#x27;s fuzzer as opposed to an approach like testing&#x2F;quick takes?</div><br/><div id="40880553" class="c"><input type="checkbox" id="c-40880553" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40879848">parent</a><span>|</span><a href="#40879059">next</a><span>|</span><label class="collapse" for="c-40880553">[-]</label><label class="expand" for="c-40880553">[1 more]</label></div><br/><div class="children"><div class="content"><i>The testing&#x2F;quick package is frozen and is not accepting new features.</i><p>Also:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30385195">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30385195</a><p>But, it occurs to me I could try and build on the same API, and compare them for effectiveness.</div><br/></div></div></div></div></div></div><div id="40879059" class="c"><input type="checkbox" id="c-40879059" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40878620">parent</a><span>|</span><a href="#40878966">prev</a><span>|</span><a href="#40878340">next</a><span>|</span><label class="collapse" for="c-40879059">[-]</label><label class="expand" for="c-40879059">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests are fuzzers if your system is chaotic enough</div><br/></div></div></div></div><div id="40878340" class="c"><input type="checkbox" id="c-40878340" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40876822">parent</a><span>|</span><a href="#40878620">prev</a><span>|</span><a href="#40877514">next</a><span>|</span><label class="collapse" for="c-40878340">[-]</label><label class="expand" for="c-40878340">[1 more]</label></div><br/><div class="children"><div class="content">You can totally combine coverage based fuzzing with property based tests. When I was at Google, I really enjoyed their internal tooling for combining both. You simply write a property based test as usual, but when it comes to execution, the testing framework compiles your test in a special way to get coverage and then adjust the random input to hit increased coverage. Of course they run the test across a cluster of machines completely automatically.<p>Traditional property based testing is implemented simply as a library, so they don&#x27;t necessarily have coverage information to guide their random input generation.</div><br/></div></div><div id="40877514" class="c"><input type="checkbox" id="c-40877514" checked=""/><div class="controls bullet"><span class="by">AlexErrant</span><span>|</span><a href="#40876822">parent</a><span>|</span><a href="#40878340">prev</a><span>|</span><a href="#40876884">next</a><span>|</span><label class="collapse" for="c-40877514">[-]</label><label class="expand" for="c-40877514">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;re asserting properties, so IMO this meets the definition of PBTs (&quot;every node of level greater than one has two children&quot;).<p>However, depending on the lib, you can get some nice quality of life improvements. One &quot;nice to have&quot; is shrinking. See the &quot;Shrinking&quot; section here <a href="https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;quickcheck-hedgehog-validity&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;quickcheck-hedgehog-validit...</a><p>Having combinators to compose generators is also great.<p>Libs may also have a known set of &quot;bad&quot; values that cause exceptional behavior.</div><br/><div id="40878385" class="c"><input type="checkbox" id="c-40878385" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40877514">parent</a><span>|</span><a href="#40877558">next</a><span>|</span><label class="collapse" for="c-40878385">[-]</label><label class="expand" for="c-40878385">[1 more]</label></div><br/><div class="children"><div class="content">The Go fuzzer, when it finds a failure, will also walk back and try to shrink inputs (and still trigger the same failure).<p>Not sure how effective it is compared to other options, but I&#x27;m not totally missing out there.<p>It also builds a corpus of interesting inputs over time (those that cause new branches to be taken, since that&#x27;s its goal: improve coverage).<p>I&#x27;m less sure about combinators.</div><br/></div></div><div id="40877558" class="c"><input type="checkbox" id="c-40877558" checked=""/><div class="controls bullet"><span class="by">gavinhoward</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40877514">parent</a><span>|</span><a href="#40878385">prev</a><span>|</span><a href="#40878265">next</a><span>|</span><label class="collapse" for="c-40877558">[-]</label><label class="expand" for="c-40877558">[1 more]</label></div><br/><div class="children"><div class="content">AFL++, a fuzzer, has a tool to minimize (shrink) test cases.</div><br/></div></div><div id="40878265" class="c"><input type="checkbox" id="c-40878265" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40877514">parent</a><span>|</span><a href="#40877558">prev</a><span>|</span><a href="#40876884">next</a><span>|</span><label class="collapse" for="c-40878265">[-]</label><label class="expand" for="c-40878265">[1 more]</label></div><br/><div class="children"><div class="content">“Properties” in the Property-based Testing sense refers to mathematical properties such as equality, associativity, commutivity, etc</div><br/></div></div></div></div><div id="40876884" class="c"><input type="checkbox" id="c-40876884" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40876822">parent</a><span>|</span><a href="#40877514">prev</a><span>|</span><a href="#40878871">next</a><span>|</span><label class="collapse" for="c-40876884">[-]</label><label class="expand" for="c-40876884">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure how Go&#x27;s fuzz tests differ from what you linked in your article, but you article said proper fuzzers need to run for days or weeks, and that PBT should approximately always chosen over fuzz testing.<p>But I&#x27;d take one step back, and ask a more meta question about testing: does a successful test mean successful code, and vice-versa? Is there anything in Go&#x27;s contract that specifies that the same inputs to the same code will yield the same output?</div><br/><div id="40879942" class="c"><input type="checkbox" id="c-40879942" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40876884">parent</a><span>|</span><a href="#40878871">next</a><span>|</span><label class="collapse" for="c-40879942">[-]</label><label class="expand" for="c-40879942">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; does a successful test mean successful code</i><p>A successful test implies that the documentation is true. That is, after all, why you are writing tests: Documentation – To explain to future developers the intent and usage behind the code you wrote. You could just as well write the documentation in Word instead, but then you&#x27;d lose the ability to perform machine verification of the documentation, which is a huge boon to moving codebases where the documentation and code are likely to fall out of sync if one is not incredibly careful (although perhaps LLMs will some day bridge that gap?).<p>The documentation being true does not imply that the documentation is useful, of course. Writing useful documentation is still an art.</div><br/><div id="40880994" class="c"><input type="checkbox" id="c-40880994" checked=""/><div class="controls bullet"><span class="by">tennis_80</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40879942">parent</a><span>|</span><a href="#40878871">next</a><span>|</span><label class="collapse" for="c-40880994">[-]</label><label class="expand" for="c-40880994">[1 more]</label></div><br/><div class="children"><div class="content">This is a reason I’m very keen on making sure tests are focused on requirements rather than code.<p>A few jobs ago I would often be in a team where the entire team had turned over several times, we would be asked to do large updates to a legacy application or bump lots of dependencies and just not break anything. When pushed the product owner wouldn’t be able to describe what the app was supposed to do, particularly for unusual types of users (the account &#x2F; user modelling was chaotic so say, several billing accounts per user, each with different products and access levels). At that point “foo calls bar” doesn’t clarify much intent.</div><br/></div></div></div></div></div></div><div id="40878871" class="c"><input type="checkbox" id="c-40878871" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40876822">parent</a><span>|</span><a href="#40876884">prev</a><span>|</span><a href="#40876970">next</a><span>|</span><label class="collapse" for="c-40878871">[-]</label><label class="expand" for="c-40878871">[1 more]</label></div><br/><div class="children"><div class="content">As far as the API is concerned, the main thing you get is a combinator library for generating whatever random data structures you want to use. Working with Arbitrary types (which represent sets of random objects) makes it easy to write reusable functions for generating your test inputs. A library like that could probably be used along with Go’s fuzzing framework fairly easily?<p>I still think the usual combinators (map, filter, chain, and oneOf, to use fast-check’s names) can be a bit awkward, so I’m writing a new property testing library for JavaScript that hopefully works a bit nicer. (Experimental and not published yet.)</div><br/></div></div><div id="40876970" class="c"><input type="checkbox" id="c-40876970" checked=""/><div class="controls bullet"><span class="by">bananapub</span><span>|</span><a href="#40876822">parent</a><span>|</span><a href="#40878871">prev</a><span>|</span><a href="#40876523">next</a><span>|</span><label class="collapse" for="c-40876970">[-]</label><label class="expand" for="c-40876970">[4 more]</label></div><br/><div class="children"><div class="content">fuzzing is clearly not a replacement for tests?</div><br/><div id="40877965" class="c"><input type="checkbox" id="c-40877965" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40876970">parent</a><span>|</span><a href="#40877163">next</a><span>|</span><label class="collapse" for="c-40877965">[-]</label><label class="expand" for="c-40877965">[2 more]</label></div><br/><div class="children"><div class="content">It kind of is. I often use randomised tests (fuzzing) for data structures and algorithm implementations. Throw a lot of asserts in and see if an hour of random input can find any edge cases I’ve missed. Usually the first time I run something like this it finds problems instantly. It’s very humbling.<p>I find when I do this I don’t need to write by hand anywhere near as many tests to get my software working well. I also usually turn any failures found by the fuzzer into standalone unit tests, to make any regressions easier to find later.</div><br/><div id="40878460" class="c"><input type="checkbox" id="c-40878460" checked=""/><div class="controls bullet"><span class="by">ncruces</span><span>|</span><a href="#40876822">root</a><span>|</span><a href="#40877965">parent</a><span>|</span><a href="#40877163">next</a><span>|</span><label class="collapse" for="c-40878460">[-]</label><label class="expand" for="c-40878460">[1 more]</label></div><br/><div class="children"><div class="content">I agree, it can be. My example above matches yours (fuzzing a data structure).<p>I coded some tests that ensure the data structure is useful, many of them test examples from papers describing the data structure, but that don&#x27;t necessarily cover all the corner cases.<p>Then I fuzzed it. I used Go&#x27;s fuzzer, which is geared towards parsers and stuff. It can generate a stream of bytes and use that for fuzzing. The data structure is a set&#x2F;map. So I interpret the stream of bytes as commands to add&#x2F;remove random elements from the set&#x2F;map. After I add an element, contains needs to return true; after I remove one, contains need to return false; if I put in a mapping, finding it must return what I just put there, etc. And at every step all the data structure invariants (that ensure logarithmic search, etc) need to hold.<p>That was stupidly effective at finding a few bugs, all within seconds, all with sequences of less than a dozen operations. Then it stops. And you get 100% coverage.<p>I&#x27;m assuming that, apart from ergonomics, where I kinda build my own state machine transitions out of a stream of bytes, the tooling actually seems more effective than property testing libraries.<p>Still curious to understand what I&#x27;m missing out.</div><br/></div></div></div></div></div></div></div></div><div id="40876523" class="c"><input type="checkbox" id="c-40876523" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40876822">prev</a><span>|</span><a href="#40876143">next</a><span>|</span><label class="collapse" for="c-40876523">[-]</label><label class="expand" for="c-40876523">[7 more]</label></div><br/><div class="children"><div class="content">I write stateful property tests with Rust&#x27;s proptest quite regularly, I just tend to handcode them which is quite straightforward. See <a href="https:&#x2F;&#x2F;github.com&#x2F;sunshowers-code&#x2F;buf-list&#x2F;blob&#x2F;main&#x2F;src&#x2F;cursor&#x2F;tests.rs">https:&#x2F;&#x2F;github.com&#x2F;sunshowers-code&#x2F;buf-list&#x2F;blob&#x2F;main&#x2F;src&#x2F;cu...</a> for a nontrivial example which found 6 bugs.<p>For parallel testing I guess it can be useful at times, but often it&#x27;s easier to just run a bunch of tests in parallel instead.</div><br/><div id="40876726" class="c"><input type="checkbox" id="c-40876726" checked=""/><div class="controls bullet"><span class="by">gamegoblin</span><span>|</span><a href="#40876523">parent</a><span>|</span><a href="#40876143">next</a><span>|</span><label class="collapse" for="c-40876726">[-]</label><label class="expand" for="c-40876726">[6 more]</label></div><br/><div class="children"><div class="content">I do a lot of manual proptesting in Rust that all look something like:<p><pre><code>    let mut rng = rand::thread_rng();
    for action_count in 1..4 {
        for _ in 0..10_000 {
            let seed = rng.gen::&lt;u64&gt;();
            eprintln!(&quot;let seed = {seed};&quot;);
            let mut rng = ChaChaRng::seed_from_u64(seed);
</code></pre>
i.e. top level true randomness, then a bunch of nested loops (only 2 here, but some tests have more) to go from low-complexity cases to high-complexity<p>then generate a seed to seed a deterministic PRNG, and print it out so if the test fails, I just copy and paste the error seed to replay the error case<p>I have found doing this manual proptesting to be faster, more flexible, and generally less fuss than using any frameworks or libraries<p>That said, for really robust concurrency testing, I cannot recommend enough the AWS Shuttle library (<a href="https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;shuttle">https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;shuttle</a>) which can find insanely complicated race conditions. I wrote a little tutorial on it here: <a href="https:&#x2F;&#x2F;grantslatton.com&#x2F;shuttle" rel="nofollow">https:&#x2F;&#x2F;grantslatton.com&#x2F;shuttle</a><p>We used it at AWS to verify the custom filesystem we wrote to power AWS S3.</div><br/><div id="40877551" class="c"><input type="checkbox" id="c-40877551" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#40876523">root</a><span>|</span><a href="#40876726">parent</a><span>|</span><a href="#40876143">next</a><span>|</span><label class="collapse" for="c-40877551">[-]</label><label class="expand" for="c-40877551">[5 more]</label></div><br/><div class="children"><div class="content">How do you do shrinking? IMO that&#x27;s the property testing killer feature</div><br/><div id="40878022" class="c"><input type="checkbox" id="c-40878022" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40876523">root</a><span>|</span><a href="#40877551">parent</a><span>|</span><a href="#40877928">next</a><span>|</span><label class="collapse" for="c-40878022">[-]</label><label class="expand" for="c-40878022">[1 more]</label></div><br/><div class="children"><div class="content">I do this sort of thing too. I don’t have an automated way to shrink my input - but that’s usually fine in practice.<p>For example, say I’m testing a data structure. I’ll have an outer loop that picks a seed and an inner loop that does ~100 mutations of a data structure instance, testing assertions each time. If there’s a failure, I’ll try a bunch of seeds to look for one that fails the fastest. (In the fewest possible inner loop iterations).<p>It’s not a perfect system, but for most bugs I can usually get a test case that only needs 5-10 steps before a crash occurs. And if the reduction step finds a different bug? That’s no problem at all. I fix what I found and go back to trying more seeds.</div><br/></div></div><div id="40877928" class="c"><input type="checkbox" id="c-40877928" checked=""/><div class="controls bullet"><span class="by">gamegoblin</span><span>|</span><a href="#40876523">root</a><span>|</span><a href="#40877551">parent</a><span>|</span><a href="#40878022">prev</a><span>|</span><a href="#40876143">next</a><span>|</span><label class="collapse" for="c-40877928">[-]</label><label class="expand" for="c-40877928">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why my outer loop goes from low-complexity cases to high-complexity cases, it has basically the same effect as shrinking (without actually having to do any work)</div><br/><div id="40878741" class="c"><input type="checkbox" id="c-40878741" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#40876523">root</a><span>|</span><a href="#40877928">parent</a><span>|</span><a href="#40876143">next</a><span>|</span><label class="collapse" for="c-40878741">[-]</label><label class="expand" for="c-40878741">[2 more]</label></div><br/><div class="children"><div class="content">Like a breath-first search instead of depth-first so you hit the shorter path first?</div><br/><div id="40879189" class="c"><input type="checkbox" id="c-40879189" checked=""/><div class="controls bullet"><span class="by">gamegoblin</span><span>|</span><a href="#40876523">root</a><span>|</span><a href="#40878741">parent</a><span>|</span><a href="#40876143">next</a><span>|</span><label class="collapse" for="c-40879189">[-]</label><label class="expand" for="c-40879189">[1 more]</label></div><br/><div class="children"><div class="content">Yes exactly, though not exhaustive, so more like beam search actually</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40876143" class="c"><input type="checkbox" id="c-40876143" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40876523">prev</a><span>|</span><a href="#40880574">next</a><span>|</span><label class="collapse" for="c-40876143">[-]</label><label class="expand" for="c-40876143">[10 more]</label></div><br/><div class="children"><div class="content">I had a quick look through the linked &quot;Testing Telecoms Software with Quviq QuickCheck&quot; paper, but couldn&#x27;t immediately see anything to answer my question: &quot;why is this stateful stuff not better rolled by hand?&quot;. The OP gestures at this with the key-value pair model of a key-value store, but why would one not just write a state machine; why does it require a framework? I literally did this last week at work to test a filesystem interaction; it boiled down to:<p>type Instruction = | Read of stuff | Write of stuff | Seek of stuff | …<p>And then the property is &quot;given this list of instructions, blah&quot;. The `StateModel` formalism requires doing basically the same work! I really don&#x27;t see that `StateModel` is pulling its weight: it&#x27;s adding a bunch more framework code to understand, and the benefit is that it&#x27;s getting rid of what is in my experience a very small amount of test code.</div><br/><div id="40876725" class="c"><input type="checkbox" id="c-40876725" checked=""/><div class="controls bullet"><span class="by">NickM</span><span>|</span><a href="#40876143">parent</a><span>|</span><a href="#40876319">next</a><span>|</span><label class="collapse" for="c-40876725">[-]</label><label class="expand" for="c-40876725">[1 more]</label></div><br/><div class="children"><div class="content">There are some tests where you’re right, but often the tricky part is shrinking failing cases. If you only want to generate sequences of state transitions that are considered “valid” then you typically have to have some sort of model state that dictates which test steps are valid for a given state, and you need to make sure that you don’t remove test steps during shrinking in a way that triggers a spurious failure by violating the preconditions that you followed to generate each step originally.<p>If any operation is valid in any state and you just want a totally random sequence of arbitrary operations, then yeah a stateful proptest framework may be overkill. But if you need to maintain a model state and specify preconditions for different operations, having a dedicated framework saves a lot of work.<p>I wrote a blog post about this stuff last year, if you’re interested in some more in-depth examples: <a href="https:&#x2F;&#x2F;readyset.io&#x2F;blog&#x2F;stateful-property-testing-in-rust" rel="nofollow">https:&#x2F;&#x2F;readyset.io&#x2F;blog&#x2F;stateful-property-testing-in-rust</a><p>Also, as others have mentioned, parallel state machine testing is another really cool benefit you can get from having a dedicated framework, but it’s not the only benefit.</div><br/></div></div><div id="40876319" class="c"><input type="checkbox" id="c-40876319" checked=""/><div class="controls bullet"><span class="by">two_handfuls</span><span>|</span><a href="#40876143">parent</a><span>|</span><a href="#40876725">prev</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40876319">[-]</label><label class="expand" for="c-40876319">[7 more]</label></div><br/><div class="children"><div class="content">My understanding is that the parallel QuickCheck will check that in your multithreaded program, all possible interleavings result in a final state that can also be reached by a sequential invocation of the commands.<p>That would be the benefit.</div><br/><div id="40876961" class="c"><input type="checkbox" id="c-40876961" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40876143">root</a><span>|</span><a href="#40876319">parent</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40876961">[-]</label><label class="expand" for="c-40876961">[6 more]</label></div><br/><div class="children"><div class="content">Is it <i>common</i> to work in a runtime that lets the test harness control the order in which threads race to access mutable state? I wouldn&#x27;t be surprised if Haskell could do it, but I think I&#x27;d have to write a custom interpreter of .NET or JVM bytecode, for example.</div><br/><div id="40877363" class="c"><input type="checkbox" id="c-40877363" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40876143">root</a><span>|</span><a href="#40876961">parent</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40877363">[-]</label><label class="expand" for="c-40877363">[5 more]</label></div><br/><div class="children"><div class="content">I believe Java has exactly that, but I couldn&#x27;t recall the project name.<p>In the case of .NET, there is <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote</a> which works by rewriting IL to inject hooks that control concurrent execution state.<p>It would have been much more expensive to have a custom interpreter specifically for this task (CoreCLR never interprets IL).<p>This approach somewhat reminds me of precise release-mode debugging and tracing framework for C++ a friend of mine was talking about, which relies on either manually adding the hooks to source files or doing so automatically with a tool.</div><br/><div id="40877533" class="c"><input type="checkbox" id="c-40877533" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40876143">root</a><span>|</span><a href="#40877363">parent</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40877533">[-]</label><label class="expand" for="c-40877533">[4 more]</label></div><br/><div class="children"><div class="content">Ah, now you mention it I did try Coyote once; it crashed out instantly on F#, which is why I forgot about it.</div><br/><div id="40877618" class="c"><input type="checkbox" id="c-40877618" checked=""/><div class="controls bullet"><span class="by">AlexErrant</span><span>|</span><a href="#40876143">root</a><span>|</span><a href="#40877533">parent</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40877618">[-]</label><label class="expand" for="c-40877618">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just here to commiserate with F# being the red-headed stepchild of dotnet. Everytime people say &quot;dotnet&quot; they <i>really</i> mean &quot;C#&quot;.</div><br/><div id="40878479" class="c"><input type="checkbox" id="c-40878479" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40876143">root</a><span>|</span><a href="#40877618">parent</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40878479">[-]</label><label class="expand" for="c-40878479">[2 more]</label></div><br/><div class="children"><div class="content">Given F# compiler outputs legal IL that is expected to execute in a particular way, and CoreCLR doesn&#x27;t fail on importing it, and then executing it, it has probably more to do with either Coyote or other tooling that interacts with this setup.<p>That is, if the issue persists. There&#x27;s one that mentions F# submitted in 2020, but nothing else since: <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote&#x2F;issues&#x2F;39">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;coyote&#x2F;issues&#x2F;39</a><p>Edit: Whoops, meant to reference this one: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;61694051&#x2F;how-to-use-microsoft-coyote-in-f-code-protected-nested-attribute-type-in-pare" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;61694051&#x2F;how-to-use-micr...</a><p>I don&#x27;t understand why there is less tolerance for having to make accommodations or take extra steps when working with F# than, let&#x27;s say, when using Kotlin or Scala. Both follow a similar pattern where they <i>can</i> use pretty much every Java library by virtue of targeting JVM but can&#x27;t use a huge amount of Java-only tooling that does meta-programming or instrumentation beyond what is provided by JVM bytecode specification, and yet it&#x27;s not seen as such a huge ordeal from my surface impressions.</div><br/><div id="40878545" class="c"><input type="checkbox" id="c-40878545" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40876143">root</a><span>|</span><a href="#40878479">parent</a><span>|</span><a href="#40876591">next</a><span>|</span><label class="collapse" for="c-40878545">[-]</label><label class="expand" for="c-40878545">[1 more]</label></div><br/><div class="children"><div class="content"><i>Does</i> that issue mention F#? I may be blind but I see no evidence that it does.<p>In general the F# way is to write completely different stuff, right, either hiding away the underlying C# or completely replacing it. Witness the existence of the SAFE stack, Giraffe to hide the egregious ASP.NET, the totally different approaches with statically resolved type parameters in F# vs enormous hierarchies of interface types in C#, Myriad AST generation vs Roslyn stamping out strings, etc. I have no opinion on the languages hosted on the JVM, but there is a really nontrivial impedence mismatch between idiomatic C# and F#!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40876591" class="c"><input type="checkbox" id="c-40876591" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#40876143">parent</a><span>|</span><a href="#40876319">prev</a><span>|</span><a href="#40880574">next</a><span>|</span><label class="collapse" for="c-40876591">[-]</label><label class="expand" for="c-40876591">[1 more]</label></div><br/><div class="children"><div class="content">I would say that stateful stuff is better covered by model-based testing. Feel free to mix test styles - it&#x27;s your code!</div><br/></div></div></div></div><div id="40880574" class="c"><input type="checkbox" id="c-40880574" checked=""/><div class="controls bullet"><span class="by">throw156754228</span><span>|</span><a href="#40876143">prev</a><span>|</span><a href="#40876437">next</a><span>|</span><label class="collapse" for="c-40880574">[-]</label><label class="expand" for="c-40880574">[1 more]</label></div><br/><div class="children"><div class="content">In JS I often want to test a parameter value does what is expected in the positive case: foo(&quot;A&quot;), but also in the negative case, i.e foo([not &quot;A&quot;]). Where [not &quot;A&quot;] some is some arbitrary string(s) representing the negative condition like say &quot;ZZ&quot;. Can the js property based testing library help me generate an arbitrary not &quot;A&quot; elegantly?</div><br/></div></div><div id="40876437" class="c"><input type="checkbox" id="c-40876437" checked=""/><div class="controls bullet"><span class="by">mjaniczek</span><span>|</span><a href="#40880574">prev</a><span>|</span><a href="#40878351">next</a><span>|</span><label class="collapse" for="c-40876437">[-]</label><label class="expand" for="c-40876437">[13 more]</label></div><br/><div class="children"><div class="content">The author focuses on the state machine and parallel aspect of PBT, but there are other aspects that might have larger effect.<p>One of these is coverage guided PBT, check eg. Dan Luu&#x27;s article: <a href="https:&#x2F;&#x2F;danluu.com&#x2F;testing&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;testing&#x2F;</a><p>Another one, which I&#x27;m biased towards, is making shrinking automatic while keeping all the invariants you created while generating the values. I have a talk on this but the TL;DR is that<p>- derived QuickCheck-like shrinker functions that work on values (shrink : a -&gt; [a]) have issues with the constraints, making people turn off shrinking instead of dealing with the issues<p>- rose tree &quot;integrated shrinking&quot; (eg. Hedgehog) follows the constraints of the generators, but has issues with monadic bind (using results of generators to dispatch to another generator)<p>- the only approach that seems to magically &quot;just work&quot; is Hypothesis&#x27; &quot;internal shrinking&quot;, which uses a layer of indirection to shrink lists of random choices instead of the values themselves. The disadvantage is that the generators are now parsers from the lists of bytes that can fail (introducing some inefficiency) and user can make a crazy generator that the internal shrinker will not be able to shrink perfectly. Nevertheless, it&#x27;s the best DX of the three approaches, and given it&#x27;s a small miracle people are testing at all, feels to me like the approach most worth building on as a testing library author.</div><br/><div id="40876676" class="c"><input type="checkbox" id="c-40876676" checked=""/><div class="controls bullet"><span class="by">AlexErrant</span><span>|</span><a href="#40876437">parent</a><span>|</span><a href="#40879305">next</a><span>|</span><label class="collapse" for="c-40876676">[-]</label><label class="expand" for="c-40876676">[10 more]</label></div><br/><div class="children"><div class="content">&gt; - rose tree &quot;integrated shrinking&quot; (eg. Hedgehog) follows the constraints of the generators, but has issues with monadic bind.<p>We&#x27;re at the limits of my amateur knowledge, but I believe this is a fundamental limitation of monadic bind&#x2F;generators. Instead, you should prefer applicative generators for optimal shrinking. <a href="https:&#x2F;&#x2F;github.com&#x2F;hedgehogqa&#x2F;haskell-hedgehog&#x2F;issues&#x2F;473#issuecomment-1407709563">https:&#x2F;&#x2F;github.com&#x2F;hedgehogqa&#x2F;haskell-hedgehog&#x2F;issues&#x2F;473#is...</a><p>In other words, applicative generators do not use &quot;results of generators to dispatch to another generator&quot;, but instead shrinking is optimal due to the &quot;parallel&quot; nature of applicatives (I&#x27;m using &quot;parallel&quot; in the monadic sense, and not the sense of article&#x27;s &quot;threading&quot; sense). Since applicatives are &quot;parallel&quot;, they can shrink the generators independently. (Whereas monadic generators are in &quot;series&quot; and therefore shrinking one necessarily changes the behavior of the subsequent generator, as you noted.)<p>Please feel free to link your talk if it&#x27;s public!</div><br/><div id="40880476" class="c"><input type="checkbox" id="c-40880476" checked=""/><div class="controls bullet"><span class="by">mjaniczek</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40876676">parent</a><span>|</span><a href="#40876949">next</a><span>|</span><label class="collapse" for="c-40880476">[-]</label><label class="expand" for="c-40880476">[1 more]</label></div><br/><div class="children"><div class="content">Re the talk: it&#x27;s unfortunately one of the Haskell Exchange talks that got pulled from the internet when the organizer, SkillsMatter, imploded. The Haskell Foundation is trying to revive and reupload those recordings, but my particular one isn&#x27;t back on YouTube yet. But here&#x27;s at least the slide deck: <a href="https:&#x2F;&#x2F;drive.google.com&#x2F;drive&#x2F;folders&#x2F;1DjfhdeFW-qCCSlJUv_XwYA0swZCuoLS1" rel="nofollow">https:&#x2F;&#x2F;drive.google.com&#x2F;drive&#x2F;folders&#x2F;1DjfhdeFW-qCCSlJUv_Xw...</a><p>I agree using applicatives helps somewhat, it basically minimizes your usage of bind.<p>Hypothesis works around this (and gets a bind that shrinks nicely) by recording those choices into (in principle) a flat list, and shrinking that. So your shrinker can work on both &quot;before the bound fn&quot; and &quot;after it&quot; at the same time, but the result might be something that the generator can&#x27;t parse back into a value.</div><br/></div></div><div id="40876949" class="c"><input type="checkbox" id="c-40876949" checked=""/><div class="controls bullet"><span class="by">ctxc</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40876676">parent</a><span>|</span><a href="#40880476">prev</a><span>|</span><a href="#40879305">next</a><span>|</span><label class="collapse" for="c-40876949">[-]</label><label class="expand" for="c-40876949">[8 more]</label></div><br/><div class="children"><div class="content">I now realize how far I am from amateur knowledge, I don&#x27;t understand any of this.<p>But always interesting to discover an avenue I haven&#x27;t explored before :)</div><br/><div id="40879181" class="c"><input type="checkbox" id="c-40879181" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40876949">parent</a><span>|</span><a href="#40877453">next</a><span>|</span><label class="collapse" for="c-40879181">[-]</label><label class="expand" for="c-40879181">[1 more]</label></div><br/><div class="children"><div class="content">Let’s say your test data is a record with two fields that can be generated independently. After the property test framework finds a bug, it can independently shrink each field to find a simpler failing test.<p>Contrast with a test data generator that randomly chooses the first field, and then calculates the second field based on the first field’s value. The framework can’t directly mutate the second field because there’s a data dependency. If it just changes the second field, it will get a record that couldn’t have been generated.<p>The Hypothesis test framework took a different approach. Instead of mutating the test data directly, it mutates the “random” input and reruns the generator. If you do shrinking that way, you always get valid test data, though it might not be very similar to the original.<p>This is similar to what fuzzers do - you start with unstructured binary data and build data structures out of it. Your “random” test data generator is really a parser of random (or maybe not so random) input.</div><br/></div></div><div id="40877453" class="c"><input type="checkbox" id="c-40877453" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40876949">parent</a><span>|</span><a href="#40879181">prev</a><span>|</span><a href="#40877443">next</a><span>|</span><label class="collapse" for="c-40877453">[-]</label><label class="expand" for="c-40877453">[2 more]</label></div><br/><div class="children"><div class="content">Sequence points in C and CPS&#x2F;ANF compilation in Lisp are kind of related to this. Both monads and applicatives enable you to define f(g(), h()), where f, g, and h are stateful computations of some sort, but monads force you to specify which of g and h is invoked first [so it’s more like x = g(), y = h(), f(x, y)] while with applicatives the implementor of the stateful model can decide what happens in such cases.<p>[Disclaimer: I don’t know how QuickCheck actually works, so I’d appreciate a sanity check (hah) of the following from somebody with actual knowledge on the matter.]<p>GP’s point, if I understood it correctly, is as follows. If you’re doing randomized testing, then g and h could perhaps be defined as { for (i=0; i&lt;n; i++) { int x = rand(); if (!fork()) return x; } } (and yes, in monad-land the moral equivalent of fork() is admissible as what I vaguely called a “stateful computation”). You see how strict ordering of side effects enforced by monads essentially forces you into a depth-first search of the state space (although I guess you could do iterative deepening?), while applicatives can allow for different exploration strategies (ones more interesting than C’s official behaviour of “that’s UB, you fool”).</div><br/><div id="40879577" class="c"><input type="checkbox" id="c-40879577" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40877453">parent</a><span>|</span><a href="#40877443">next</a><span>|</span><label class="collapse" for="c-40879577">[-]</label><label class="expand" for="c-40879577">[1 more]</label></div><br/><div class="children"><div class="content">C sequence points are arbitrarily imposed by imperial decree in the standard; they are not linked to any evaluation causality.<p>Dependency-driven de facto evaluation orders have always existed in C though: things that you can figure out must be ordered even though there isn&#x27;t a sequence point.<p>The standard spells out that expressions like i = i + i are okay, but actually it&#x27;s not necessary to do so. The assignment cannot take place until the assigned value is known. The assigned value is not known until the + is evaluated and the + cannot be evaluated until the operand values are retrieved. Therefore, the retrieval of the prior value of i necessarily precedes the movement of the new value into i.<p>This, rather than sequence points, is rather a bit like monadic sequencing.</div><br/></div></div></div></div><div id="40877443" class="c"><input type="checkbox" id="c-40877443" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40876949">parent</a><span>|</span><a href="#40877453">prev</a><span>|</span><a href="#40877069">next</a><span>|</span><label class="collapse" for="c-40877443">[-]</label><label class="expand" for="c-40877443">[1 more]</label></div><br/><div class="children"><div class="content">To have an idea of monads being sequential, think about a JS Promise:<p><pre><code>  promise.then(...).then(...).then(...)...
</code></pre>
Promises are (almost) monadic, and the chain is sequential. You can&#x27;t make it parallel, and that&#x27;s the point: monadic binding represents sequential computation, aka &quot;the semicolon operator&quot;.<p>To have an idea about applicatives being parallel, think about a list of functions, and a list of values; each function would be applied to a corresponding value, resulting in a list of results:<p><pre><code>  results = []
  for ix in range(functions):
    f = functions[ix]
    x = values[ix]
    results.append(f(x))
</code></pre>
It&#x27;s pretty obvious that you can do each <i>f(x)</i> in parallel and in any order, instead of the sequential code above.<p>(Why would one care about this all? Because many daily things are functors, applicatives, and monads, e.g. a list is usually all three.)</div><br/></div></div><div id="40877069" class="c"><input type="checkbox" id="c-40877069" checked=""/><div class="controls bullet"><span class="by">AlexErrant</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40876949">parent</a><span>|</span><a href="#40877443">prev</a><span>|</span><a href="#40879305">next</a><span>|</span><label class="collapse" for="c-40877069">[-]</label><label class="expand" for="c-40877069">[3 more]</label></div><br/><div class="children"><div class="content">Haha yeah I kinda went off the deep end with applicatives. Here&#x27;s a short primer on applicative vs monadic shrinking behavior using F# syntax <a href="https:&#x2F;&#x2F;github.com&#x2F;hedgehogqa&#x2F;fsharp-hedgehog&#x2F;issues&#x2F;419#issuecomment-1637154561">https:&#x2F;&#x2F;github.com&#x2F;hedgehogqa&#x2F;fsharp-hedgehog&#x2F;issues&#x2F;419#iss...</a><p>You can think of `let!` as `let + await`, and `let! x ... and! y` as `await Parallel([x, y])`.<p>Please feel free to ask any questions if it&#x27;s still confusing!</div><br/><div id="40877125" class="c"><input type="checkbox" id="c-40877125" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40877069">parent</a><span>|</span><a href="#40879305">next</a><span>|</span><label class="collapse" for="c-40877125">[-]</label><label class="expand" for="c-40877125">[2 more]</label></div><br/><div class="children"><div class="content">Not <i>quite</i> accurate with the Parallel example, if I understand you correctly. Don Syme is explicit that applicative `async` should not implicitly start work in the thread pool (<a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;fsharp&#x2F;issues&#x2F;10301#issuecomment-734280586">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;fsharp&#x2F;issues&#x2F;10301#issuecomment-7...</a>).</div><br/><div id="40877292" class="c"><input type="checkbox" id="c-40877292" checked=""/><div class="controls bullet"><span class="by">AlexErrant</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40877125">parent</a><span>|</span><a href="#40879305">next</a><span>|</span><label class="collapse" for="c-40877292">[-]</label><label class="expand" for="c-40877292">[1 more]</label></div><br/><div class="children"><div class="content">My usage of &quot;parallel&#x2F;await&quot; is entirely metaphorical; I was kinda going for a Javascript-esque syntax with &quot;await Parallel&quot; - I&#x27;m assuming most people aren&#x27;t familiar with F#&#x27;s `and!`. It doesn&#x27;t make sense for applicative generators to (necessarily) use the thread pool.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40879305" class="c"><input type="checkbox" id="c-40879305" checked=""/><div class="controls bullet"><span class="by">epgui</span><span>|</span><a href="#40876437">parent</a><span>|</span><a href="#40876676">prev</a><span>|</span><a href="#40878351">next</a><span>|</span><label class="collapse" for="c-40879305">[-]</label><label class="expand" for="c-40879305">[2 more]</label></div><br/><div class="children"><div class="content">Anecdotally, Hypothesis was <i>very far</i> from &quot;just working&quot; for me. I don&#x27;t think it&#x27;s really production-ready, and that seems to be by design.[0]<p>I did have quite a bit of prior experience with clojure.spec.alpha (with or without test.check), so despite some differences it&#x27;s not like I was completely alien to the general ideas.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis&#x2F;issues&#x2F;3493">https:&#x2F;&#x2F;github.com&#x2F;HypothesisWorks&#x2F;hypothesis&#x2F;issues&#x2F;3493</a></div><br/><div id="40879700" class="c"><input type="checkbox" id="c-40879700" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40876437">root</a><span>|</span><a href="#40879305">parent</a><span>|</span><a href="#40878351">next</a><span>|</span><label class="collapse" for="c-40879700">[-]</label><label class="expand" for="c-40879700">[1 more]</label></div><br/><div class="children"><div class="content">The issue seemed to be based on a misunderstanding of the implied probability distribution hypothesis uses to draw examples from?</div><br/></div></div></div></div></div></div><div id="40878351" class="c"><input type="checkbox" id="c-40878351" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40876437">prev</a><span>|</span><a href="#40879636">next</a><span>|</span><label class="collapse" for="c-40878351">[-]</label><label class="expand" for="c-40878351">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried to use property based testing but always found it falls between two stools. If I understand a property well enough to write a strict test of it, I can generally push it into the type system and make it true by construction. And if I just want a &quot;smoke test&quot; then a single arbitrary input is easier.</div><br/><div id="40879725" class="c"><input type="checkbox" id="c-40879725" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40878351">parent</a><span>|</span><a href="#40879967">next</a><span>|</span><label class="collapse" for="c-40879725">[-]</label><label class="expand" for="c-40879725">[1 more]</label></div><br/><div class="children"><div class="content">What kinds of properties you have in mind?<p>For example, a lot of times I might have two implementations, a naive one that&#x27;s slow and simple, and an optimized one.  I can compare the output of both against each other on arbitrary input.  That&#x27;s a simple property that easy to understand, but hard to put in the type system in general.<p>Similarly, I often have properties that eg the order that input is presented in shouldn&#x27;t matter, or sometimes you have ways to partition your data &#x27;max(maximum over A, maximum over B)) = maximum(A union B)&#x27;.  How do you encode that in the type system?<p>Or you have something like &#x27;for any A and B: (find some optimal solution over A) is worse than (find some optimal solution over (A union B))&#x27;.  Or you have idempotency like &#x27;f(f(A)) = f(A)&#x27;.<p>These are all easy to understand properties, but not trivial to describe in most type systems.</div><br/></div></div><div id="40879967" class="c"><input type="checkbox" id="c-40879967" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40878351">parent</a><span>|</span><a href="#40879725">prev</a><span>|</span><a href="#40879636">next</a><span>|</span><label class="collapse" for="c-40879967">[-]</label><label class="expand" for="c-40879967">[1 more]</label></div><br/><div class="children"><div class="content">Clearly it&#x27;s better to enforce constraints at compile-time, if possible. However, there are many kinds of constraints that mainstream type checkers just can&#x27;t handle. (Dependent types would help a lot, but still seem limited to niches, such as theorem provers.)</div><br/></div></div></div></div><div id="40879636" class="c"><input type="checkbox" id="c-40879636" checked=""/><div class="controls bullet"><span class="by">algorithmsRcool</span><span>|</span><a href="#40878351">prev</a><span>|</span><a href="#40878301">next</a><span>|</span><label class="collapse" for="c-40879636">[-]</label><label class="expand" for="c-40879636">[2 more]</label></div><br/><div class="children"><div class="content">For my C#&#x2F;.NET testing I&#x27;ve been using CsCheck[0] and I&#x27;ve enjoyed it quite a bit. It was a lot more approachable compared to Hedgehog and FsCheck and is also quite fast.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;AnthonyLloyd&#x2F;CsCheck">https:&#x2F;&#x2F;github.com&#x2F;AnthonyLloyd&#x2F;CsCheck</a></div><br/><div id="40879958" class="c"><input type="checkbox" id="c-40879958" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40879636">parent</a><span>|</span><a href="#40878301">next</a><span>|</span><label class="collapse" for="c-40879958">[-]</label><label class="expand" for="c-40879958">[1 more]</label></div><br/><div class="children"><div class="content">FsCheck is great, but very specific to F# (hence the name). Having a separate C# variant makes sense to me.</div><br/></div></div></div></div><div id="40878301" class="c"><input type="checkbox" id="c-40878301" checked=""/><div class="controls bullet"><span class="by">rdtsc</span><span>|</span><a href="#40879636">prev</a><span>|</span><a href="#40877415">next</a><span>|</span><label class="collapse" for="c-40878301">[-]</label><label class="expand" for="c-40878301">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if it&#x27;s missing the original QuviQ Erlang QuickCheck in the list? The full product is proprietary, but there is a freeware version QuickCheck Mini available as well: <a href="http:&#x2F;&#x2F;www.quviq.com&#x2F;downloads&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.quviq.com&#x2F;downloads&#x2F;</a></div><br/></div></div><div id="40877415" class="c"><input type="checkbox" id="c-40877415" checked=""/><div class="controls bullet"><span class="by">choeger</span><span>|</span><a href="#40878301">prev</a><span>|</span><a href="#40876543">next</a><span>|</span><label class="collapse" for="c-40877415">[-]</label><label class="expand" for="c-40877415">[1 more]</label></div><br/><div class="children"><div class="content">The obvious downside is the number of examples computed. A simple unit test can easily take 100 times as long when property-tested.<p>Besides, it would be really cool to have property-based integration or hybrid unit&#x2F;integration tests. Or even property-based E2E tests. Unfortunately, the setup of the example will almost always take too long for a relevant set of runs.<p>For instance: If you have a basic data model (say in sqlalchemy) and want to write property-based tests (say in hypothesis), you can relatively quickly derive strategies for the models (but beware of recursion and primary keys). But writing that model instance into the DB for running an example just takes too long for swift testing.</div><br/></div></div><div id="40876543" class="c"><input type="checkbox" id="c-40876543" checked=""/><div class="controls bullet"><span class="by">sshine</span><span>|</span><a href="#40877415">prev</a><span>|</span><a href="#40877028">next</a><span>|</span><label class="collapse" for="c-40876543">[-]</label><label class="expand" for="c-40876543">[2 more]</label></div><br/><div class="children"><div class="content">Amazing survey.<p>Big fan of property testing.<p>A particularly big fan of Hedgehog.<p>I tried writing a Hedgehog-inspired library in Rust and realized how complex the underlying domain is.<p>For example, the RNG is &quot;splittable&quot; [1][2] which means you can take a deterministic seed and split it in two, e.g. for parallel generators to work independently but still deterministically. The effort that has gone into this feature level is a little numbing. I have an awe similar to that of the &quot;fast inverse square root&quot; hack when I see code like this:<p><pre><code>  -- | A predefined gamma value&#x27;s needed for initializing the &quot;root&quot; instances of
  --   &#x27;Seed&#x27;. That is, instances not produced by splitting an already existing
  --   instance.
  --
  --   We choose: the odd integer closest to @2^64&#x2F;φ@, where @φ = (1 + √5)&#x2F;2@ is
  --   the golden ratio.
  --
  goldenGamma :: Word64
  goldenGamma =
    0x9e3779b97f4a7c15
</code></pre>
when realizing that those numbers don&#x27;t come easily. [3]<p>[1]: <a href="https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;hedgehog-1.4&#x2F;docs&#x2F;src&#x2F;Hedgehog.Internal.Seed.html#Seed" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;hedgehog-1.4&#x2F;docs&#x2F;src&#x2F;He...</a><p>[2]: <a href="https:&#x2F;&#x2F;gee.cs.oswego.edu&#x2F;dl&#x2F;papers&#x2F;oopsla14.pdf" rel="nofollow">https:&#x2F;&#x2F;gee.cs.oswego.edu&#x2F;dl&#x2F;papers&#x2F;oopsla14.pdf</a><p>[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;hedgehogqa&#x2F;haskell-hedgehog&#x2F;issues&#x2F;191">https:&#x2F;&#x2F;github.com&#x2F;hedgehogqa&#x2F;haskell-hedgehog&#x2F;issues&#x2F;191</a><p>Wonder why most property-testing libaries don&#x27;t have features like this?<p>The libraries require training to use. And they&#x27;re not that easy to write.<p>&gt; <i>the current state-of-the-art when it comes to property-based testing is stateful testing via a state machine model and reusing the same sequential state machine model combined with linearisability to achieve parallel testing</i><p>Okay, okay. I admit I&#x27;ve never performed property-based stateful testing, nor in parallel. So that may be the coolest feature out there, because it addresses one of the hardest problems in testing.<p>But I think that yet other things have happened with modern property-testing libraries (e.g. Hypothesis, PropEr, Hedgehog, Validity):<p>Shrinking for free [4], generators for free [5], defining the probability distribution of your sub-generators in a composable way.<p>Maybe those features are not as significant, but they&#x27;re equally missing from almost all property-test libaries.<p>[4]: Gens N’ Roses: Appetite for Reduction • Jacob Stanley • YOW! 2017 <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=LfD0DHqpeVQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=LfD0DHqpeVQ</a><p>[5]: <a href="https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;quickcheck-hedgehog-validity&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;quickcheck-hedgehog-validit...</a></div><br/><div id="40876662" class="c"><input type="checkbox" id="c-40876662" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#40876543">parent</a><span>|</span><a href="#40877028">next</a><span>|</span><label class="collapse" for="c-40876662">[-]</label><label class="expand" for="c-40876662">[1 more]</label></div><br/><div class="children"><div class="content">Huh. I wonder why they don&#x27;t use one of those random-access PRNGs like PRNS, which is basically a hash of a counter. Maybe not good enough in the speed-quality space?</div><br/></div></div></div></div><div id="40877028" class="c"><input type="checkbox" id="c-40877028" checked=""/><div class="controls bullet"><span class="by">ruuda</span><span>|</span><a href="#40876543">prev</a><span>|</span><a href="#40879136">next</a><span>|</span><label class="collapse" for="c-40877028">[-]</label><label class="expand" for="c-40877028">[4 more]</label></div><br/><div class="children"><div class="content">The major omission in this article is fuzzing. Not only is it practical and in wide (and growing use), it’s also far more advanced than QuickCheck’s approach of generating random inputs, because fuzzing can be _coverage-driven_. Property-based testing came out of academia and fuzzing came out of security research, initially they were not connected. But with the advent of in-process fuzzing (through libFuzzer), which encourages writing small fuzz tests rather than testing entire programs; and structure-aware fuzzing, which enables testing more than just functions that take a bytestring as input, in my view the two techniques have converged. It’s just that the two separate communities haven’t fully realized this yet.<p>One pitfall with non-coverage-driven randomized testing like QuickCheck, is that how good your tests are depends a lot on the generator. It may be very rarely generating interesting inputs because you biased the generator in the wrong way, and depending on how you do the generation, you need to be careful to ensure the generator halts. With coverage-driven fuzzing all of these problems go away; you don’t have to be smart to choose distributions so that interesting cases are more common, coverage instrumentation will automatically discover new paths in your program and drill down on them.<p>But isn’t fuzzing about feeding a large program or function random bytestrings as inputs, whereas property-based testing is about testing properties about data structures? It is true that fuzzers operate on bytestrings, but there is no rule that says we can’t use that bytestring to generate a data structure (in a sense, replacing the role of the random seed). And indeed this is what the Arbitrary crate [1] in Rust does, it gives tools and even derive macros to automatically generate values of your data types in the same way that QuickCheck can. The fuzzing community calls this Structure-Aware Fuzzing and there is a chapter about it in the Rust fuzzing book [2]. There are also tools like libprotobuf-mutator [3] that substitute fuzzers’ naive mutation strategies, but even with naive strategies fuzzers can usually get to 100% coverage with appropriate measures (e.g. recomputing checksums after mutation, if the data structure contains checksums).<p>I am using this extensively in my own projects. For example, RCL (a configuration language that is a superset of json) contains multiple fuzzers that test various properties [4], such as idempotency of the formatter. In the beginning it used the raw source files as inputs but I also added a more advanced generator that wastes less cycles on inputs that get rejected by the parser. The fuzzer has caught serveral bugs, and most of them would have had no hope of being found with naive randomized testing, because they required a cascade of unlikely events.<p>Structure-aware fuzzing is not limited to generating data structures either, you can use it to generate reified commands to test a stateful API, as you describe in the _Stateful property-based testing_ section. The Rust fuzzing book has an example of this [5], and I use this approach to fuzz a tree implementation in Noblit [6].<p>[1]: <a href="https:&#x2F;&#x2F;docs.rs&#x2F;arbitrary&#x2F;latest&#x2F;arbitrary&#x2F;" rel="nofollow">https:&#x2F;&#x2F;docs.rs&#x2F;arbitrary&#x2F;latest&#x2F;arbitrary&#x2F;</a>
[2]: <a href="https:&#x2F;&#x2F;rust-fuzz.github.io&#x2F;book&#x2F;cargo-fuzz&#x2F;structure-aware-fuzzing.html" rel="nofollow">https:&#x2F;&#x2F;rust-fuzz.github.io&#x2F;book&#x2F;cargo-fuzz&#x2F;structure-aware-...</a>
[3]: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;libprotobuf-mutator">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;libprotobuf-mutator</a>
[4]: <a href="https:&#x2F;&#x2F;docs.ruuda.nl&#x2F;rcl&#x2F;testing&#x2F;#fuzz-tests" rel="nofollow">https:&#x2F;&#x2F;docs.ruuda.nl&#x2F;rcl&#x2F;testing&#x2F;#fuzz-tests</a>
[5]: <a href="https:&#x2F;&#x2F;rust-fuzz.github.io&#x2F;book&#x2F;cargo-fuzz&#x2F;structure-aware-fuzzing.html#example-2-fuzzing-allocator-api-calls" rel="nofollow">https:&#x2F;&#x2F;rust-fuzz.github.io&#x2F;book&#x2F;cargo-fuzz&#x2F;structure-aware-...</a>
[6]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ruuda&#x2F;noblit&#x2F;blob&#x2F;a0fd1342c4aa6e05f2b1c4e2929804c82e348ae2&#x2F;fuzz&#x2F;fuzz_targets&#x2F;htree_insert.rs">https:&#x2F;&#x2F;github.com&#x2F;ruuda&#x2F;noblit&#x2F;blob&#x2F;a0fd1342c4aa6e05f2b1c4e...</a></div><br/><div id="40879317" class="c"><input type="checkbox" id="c-40879317" checked=""/><div class="controls bullet"><span class="by">phlip9</span><span>|</span><a href="#40877028">parent</a><span>|</span><a href="#40877204">next</a><span>|</span><label class="collapse" for="c-40879317">[-]</label><label class="expand" for="c-40879317">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. A while back I played around with fuzzcheck [1], which let&#x27;s you write coverage-guided, structure-aware property tests, but the generation is smarter than just slamming a fuzzer&#x27;s `&amp;[u8]` input into `Arbitrary`. It also supports shrinking, which is nice. Don&#x27;t know that I would recommend it though. It seemed difficult to write your own `Mutator`s. It also looks somewhat unmaintained nowadays, but I think the direction is worth exploring.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;loiclec&#x2F;fuzzcheck-rs&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;loiclec&#x2F;fuzzcheck-rs&#x2F;</a></div><br/></div></div><div id="40877204" class="c"><input type="checkbox" id="c-40877204" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40877028">parent</a><span>|</span><a href="#40879317">prev</a><span>|</span><a href="#40879136">next</a><span>|</span><label class="collapse" for="c-40877204">[-]</label><label class="expand" for="c-40877204">[2 more]</label></div><br/><div class="children"><div class="content">I spent some time looking at the arbitrary crate in Rust and was left unsatisfied at the shrinking story, which I think is 90% of the value of PBT.</div><br/><div id="40878171" class="c"><input type="checkbox" id="c-40878171" checked=""/><div class="controls bullet"><span class="by">matklad</span><span>|</span><a href="#40877028">root</a><span>|</span><a href="#40877204">parent</a><span>|</span><a href="#40879136">next</a><span>|</span><label class="collapse" for="c-40878171">[-]</label><label class="expand" for="c-40878171">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a model problem which is tricky to shrink?<p>I implemented a stupid simple shrinker for arbitrary, and I’d love to know a specific example where it fails to shrink in a good way:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;matklad&#x2F;arbtest&#x2F;blob&#x2F;0191f93846e9f7e382543bc1ca8526ed04d85795&#x2F;src&#x2F;lib.rs#L458">https:&#x2F;&#x2F;github.com&#x2F;matklad&#x2F;arbtest&#x2F;blob&#x2F;0191f93846e9f7e38254...</a><p>I know at lest two interesting approaches for making that way smarter, but I don’t yet have a problem where my dumb approach isn’t sufficient.</div><br/></div></div></div></div></div></div><div id="40879136" class="c"><input type="checkbox" id="c-40879136" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#40877028">prev</a><span>|</span><a href="#40879639">next</a><span>|</span><label class="collapse" for="c-40879136">[-]</label><label class="expand" for="c-40879136">[1 more]</label></div><br/><div class="children"><div class="content">Oh man, talk about a walk down memory lane: a polite disagreement about the intersection of the public and private sectors in which commercial control of source code written by a founder who is also a researcher is being sold because the researcher found that to be more effective than opening the code (which he tried and didn’t get much attention as a result). Both reasonable arguments, I can see both sides. I remember when the software business wasn’t a dystopian nightmare.<p>Today a weird, scary splinter faction of the already terrifying Effective Altruism religion&#x2F;cult is talking about building digital gods they can’t control and saying with a straight face that this is imminent (absurdly extravagant claim with no evidence more convincing than a logarithmic scale and a ruler) and using this as an argument to redefine everything from the definition of science to the very epistemology of factuality and getting the public to directly or indirectly subsidize it into the bargain.<p>People who make Ray Kurzweil’s Singularity magical thinking look flat fucking normal and frankly sound like L Ron Hubbard more every day are unilaterally deciding that all research into, ya know, what they claim is the most important event in human history is totally black box propriety because, ya know, for our own good.<p>I’ll take the polite Swiss functional programming folks over Anthropic’s Mechanical Interpretability people seven days a week and twice on Sunday.<p>Can we go back to this please? The new thing sucks.</div><br/></div></div><div id="40879639" class="c"><input type="checkbox" id="c-40879639" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#40879136">prev</a><span>|</span><a href="#40876699">next</a><span>|</span><label class="collapse" for="c-40879639">[-]</label><label class="expand" for="c-40879639">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the problem is primarily a lack of good OSS implementations or UX lacking polish. To me, it&#x27;s more that there is a mismatch between what programming language&#x2F;CS enthusiasts find interesting and useful, and what industry software developers find useful.<p>First off, the &quot;training&quot; problem is a very real and fundamental blocker. I think academics or less experienced engineers see it as a problem of education, but I believe it&#x27;s actually an engineering&#x2F;organizational problem: for a company or even OSS project, when you use niche&#x2F;unadopted tools like this you either need to provide training for it or you massively shrink the set of people able to work on your project by requiring or expecting them to learn it on their own. This introduces a practical headache bigger than the ones a tool like this solves (since these are just incrementally better ways to test software) - you get less contributions or need to spend more on getting people onboarded. Note that even if &quot;training&quot; people is free in the sense that there is no paid training material, you still pay a cost in lower productivty for new people and the time spent training.<p>Even once people are trained, you now have a process&#x2F;institutional need to support the property based tests you wrote. That may mean paying for licenses for software, or maintenance of whatever infrastructure&#x2F;integrations you write to get property based testing working in your developer workflow. And you also now need to rely on people using these tools correctly - the problem with formal verification is that it doesn&#x27;t verify that you&#x27;re actually solving the real problem correctly, just that your program operates as expected (ie it only verifies that your software is Working As Implemented, not Working as Intended). The more you rely on average joes to wield complex things like this well, the more headaches you introduce - if the bottom 10% of people you hire use it sloppily or wrongly, once you&#x27;re past a few dozen regular contributors you&#x27;re basically going to have constant issues. You see this all the time with even just regular unit and integration tests - less capable developers constantly introduce flakes or write tests so bad&#x2F;basic that it&#x27;d be better for them to not even be writing tests at all.<p>Even if after considering all that it still seems a worthy tradeoff, there&#x27;s the question of whether property based testing solves the problem you think it does. As I mentioned, it can moreso verify software is Working as Implemented rather than Working as Intended. But there is the bigger problem of major software projects not conforming to the simpler use cases that sell people on using this tool. In my experience stateless functions almost never have bugs, and when they do, it&#x27;s mostly a &quot;requirements discovery&quot; problem you wouldn&#x27;t catch with any kind of verification tooling.<p>Stateful verification becomes a problem in the kinds of <i>real</i> systems programming projects like the Linux Kernel or Qemu which stand to benefit most from verification. If you&#x27;re verifying things at the level of a &quot;higher level&quot; abstraction like a scheduler, you almost always have really high dimensionality&#x2F;a lot of state, perhaps deceptively more than you think, because of composition. And you tend to also have a devloop that is already very slow - builds take a long time, and running tests of higher level components can be &quot;expensive&quot; because it may take 100ms-1s for something like a kernel to finish starting in a test environment. For a single test that&#x27;s nothing, but multiplied across all tests makes testing painful enough already; adding 3x or 100x by doing property based testing with new tests, even if pruned before submitting, could be either hugely expensive or way too slow. And similarly, the increased resource requirements to maintain state machines can be very expensive. TSAN does essentially parallel property-based testing and introduces 128-512 bytes of overhead for every 8 bytes of memory under test: <a href="https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers&#x2F;wiki&#x2F;ThreadSanitizerAlgorithm">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;sanitizers&#x2F;wiki&#x2F;ThreadSanitizerAlg...</a>.<p>Is it cool and underrated? Definitely. But it&#x27;s not a silver bullet and honestly just isn&#x27;t worth it for most software. Even when it is worth it, it has its drawbacks.</div><br/></div></div><div id="40876699" class="c"><input type="checkbox" id="c-40876699" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#40879639">prev</a><span>|</span><label class="collapse" for="c-40876699">[-]</label><label class="expand" for="c-40876699">[8 more]</label></div><br/><div class="children"><div class="content">Lack of parallelization really doesnt make me feel that sad. I&#x27;m constrained by many things while coding but CPU horsepower isnt one of them.</div><br/><div id="40877156" class="c"><input type="checkbox" id="c-40877156" checked=""/><div class="controls bullet"><span class="by">meindnoch</span><span>|</span><a href="#40876699">parent</a><span>|</span><a href="#40876833">next</a><span>|</span><label class="collapse" for="c-40877156">[-]</label><label class="expand" for="c-40877156">[4 more]</label></div><br/><div class="children"><div class="content">You realize that by &quot;parallelism&quot; the author is referring to the detection of concurrency issues, and not the parallel running of tests, right?</div><br/><div id="40877801" class="c"><input type="checkbox" id="c-40877801" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#40876699">root</a><span>|</span><a href="#40877156">parent</a><span>|</span><a href="#40876833">next</a><span>|</span><label class="collapse" for="c-40877801">[-]</label><label class="expand" for="c-40877801">[3 more]</label></div><br/><div class="children"><div class="content">Typescript&#x2F;JavaScript libraries are in the list, but JS it&#x27;s single threaded, so I don&#x27;t know if there is really something missing here.</div><br/><div id="40878553" class="c"><input type="checkbox" id="c-40878553" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#40876699">root</a><span>|</span><a href="#40877801">parent</a><span>|</span><a href="#40878085">next</a><span>|</span><label class="collapse" for="c-40878553">[-]</label><label class="expand" for="c-40878553">[1 more]</label></div><br/><div class="children"><div class="content">JS is single threaded, but the process lives in an event loop.<p>You can easily write a JS function that can have a race condition by launching two asynchronous processes (such as writing to local storage in a browser or the file system both operating on the same data).<p>I had this happen just today while scraping different websites writing to the same files and overwriting each other.</div><br/></div></div><div id="40878085" class="c"><input type="checkbox" id="c-40878085" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40876699">root</a><span>|</span><a href="#40877801">parent</a><span>|</span><a href="#40878553">prev</a><span>|</span><a href="#40876833">next</a><span>|</span><label class="collapse" for="c-40878085">[-]</label><label class="expand" for="c-40878085">[1 more]</label></div><br/><div class="children"><div class="content">Concurrency is not the same as parallelism. I’ve understood TFA to mean concurrency when it mentions parallelism. This would explain the presence of JS libraries which could test for concurrency problems in asynchronous code.</div><br/></div></div></div></div></div></div><div id="40876833" class="c"><input type="checkbox" id="c-40876833" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40876699">parent</a><span>|</span><a href="#40877156">prev</a><span>|</span><label class="collapse" for="c-40876833">[-]</label><label class="expand" for="c-40876833">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s stopping your test suite from running instantly?</div><br/><div id="40876971" class="c"><input type="checkbox" id="c-40876971" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#40876699">root</a><span>|</span><a href="#40876833">parent</a><span>|</span><label class="collapse" for="c-40876971">[-]</label><label class="expand" for="c-40876971">[2 more]</label></div><br/><div class="children"><div class="content">Typically a desire to have tests that are somewhat realistic.</div><br/><div id="40877153" class="c"><input type="checkbox" id="c-40877153" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#40876699">root</a><span>|</span><a href="#40876971">parent</a><span>|</span><label class="collapse" for="c-40877153">[-]</label><label class="expand" for="c-40877153">[1 more]</label></div><br/><div class="children"><div class="content">What does that mean?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>