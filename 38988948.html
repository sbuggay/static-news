<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705309267003" as="style"/><link rel="stylesheet" href="styles.css?v=1705309267003"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://qsantos.fr/2024/01/04/dynamic-programming-is-not-black-magic/">Dynamic programming is not black magic</a> <span class="domain">(<a href="https://qsantos.fr">qsantos.fr</a>)</span></div><div class="subtext"><span>qsantos</span> | <span>163 comments</span></div><br/><div><div id="38989889" class="c"><input type="checkbox" id="c-38989889" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38997311">next</a><span>|</span><label class="collapse" for="c-38989889">[-]</label><label class="expand" for="c-38989889">[19 more]</label></div><br/><div class="children"><div class="content">It&#x27;s good that the article points out that DP algorithms are &quot;just&quot; clever ways to cache a recursion. Looking for a recursive solution is certainly the best way to start out looking for a DP solution, in my experience -- if you can find one, memoising it is trivial and may give a big speedup (and may even be faster than a &quot;bottom-up&quot; DP, since it only ever computes solutions that we definitely need).<p>With enough practice, it&#x27;s usually possible to come up with a (correct but slow) recursive solution. When turning this into a DP, it doesn&#x27;t matter if there are large numbers of subproblems in the call tree -- what&#x27;s important is that there are a relatively small number of <i>distinct</i> subproblems. (Since there&#x27;s no point caching a result that&#x27;s only ever needed one time.) And that&#x27;s where the difficulty tends to lie: Figuring out how to partition the original problem into <i>few enough distinct subproblems</i>.</div><br/><div id="38998435" class="c"><input type="checkbox" id="c-38998435" checked=""/><div class="controls bullet"><span class="by">dsego</span><span>|</span><a href="#38989889">parent</a><span>|</span><a href="#38997874">next</a><span>|</span><label class="collapse" for="c-38998435">[-]</label><label class="expand" for="c-38998435">[1 more]</label></div><br/><div class="children"><div class="content">I remember learning about the knapsack problem and trying out recursive ways to solve it as well.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dsego&#x2F;codility&#x2F;blob&#x2F;main&#x2F;knapsack.js">https:&#x2F;&#x2F;github.com&#x2F;dsego&#x2F;codility&#x2F;blob&#x2F;main&#x2F;knapsack.js</a></div><br/></div></div><div id="38997874" class="c"><input type="checkbox" id="c-38997874" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38989889">parent</a><span>|</span><a href="#38998435">prev</a><span>|</span><a href="#38996926">next</a><span>|</span><label class="collapse" for="c-38997874">[-]</label><label class="expand" for="c-38997874">[9 more]</label></div><br/><div class="children"><div class="content">The best analogy I have here is that saying &quot;DP is just caching&#x2F;memoization&quot; is like saying &quot;investment is just buying stuff and selling them later.&quot; Regardless of how technically accurate it might be, it misses such massive complexities and difficulties in the topic that it just makes you look silly rather than insightful.</div><br/><div id="38997949" class="c"><input type="checkbox" id="c-38997949" checked=""/><div class="controls bullet"><span class="by">natpalmer1776</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38997874">parent</a><span>|</span><a href="#38996926">next</a><span>|</span><label class="collapse" for="c-38997949">[-]</label><label class="expand" for="c-38997949">[8 more]</label></div><br/><div class="children"><div class="content">Would you prefer someone start learning the principles of investing from an initial premise of “investment is just spending money to make money” or “investment is just buying something for less than it will be worth in the future”<p>Both are technically correct and both statements are vast oversimplifications of a complex subject, however the second statement leads into more advanced topics naturally, creating a smoother progression of knowledge that builds on itself.<p>Every complex topic generally starts with a few foundational bits of knowledge that support the whole house of cards. Pick the wrong foundational bits and you won’t get as far.</div><br/><div id="38998102" class="c"><input type="checkbox" id="c-38998102" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38997949">parent</a><span>|</span><a href="#38996926">next</a><span>|</span><label class="collapse" for="c-38998102">[-]</label><label class="expand" for="c-38998102">[7 more]</label></div><br/><div class="children"><div class="content">I certainly don&#x27;t disagree that there should be <i>a</i> solid foundation here; I just think this is the wrong foundation, for what I believe to be good reasons (some of which I&#x27;ll get to below) - mainly, it confuses the concept with the implementation mechanics.<p>Instead... I find it much more productive to start teaching this with the fundamentals of problem-solving techniques, as follows:<p>- One method for solving complex problems is to divide them into separate subproblems that are simpler to solve. We call this &quot;divide-and-conquer&quot;, as you&#x27;ve seen in [blah, e.g. mergesort]. Observe that this technique decomposes your subproblem structure into a <i>tree</i>. (Draw a picture.)<p>- Another (more advanced) method for solving complex problems is to find subproblems that might potentially <i>overlap</i>, and then find a clever way to combine their solutions into the final answer. An example here is finding the shortest N-hop path by finding the shortest (N-1)-hop paths, and picking out the shortest of those to find the shortest N-hop path. Observe that this technique decomposes your subproblem structure into a <i>DAG</i> form. (Draw a picture.)<p>Take a moment to read the above... notice the lack of any mention of caching&#x2F;memoization&#x2F;tables, etc.? That&#x27;s not an accident. It&#x27;s because those are <i>optimizations</i> to DP, not the core idea! Before you can even start talking about &quot;how do I solve this <i>quickly</i>&quot;, the question you need to answer is &quot;what systematic method can I use to solve this <i>at all</i>?&quot; The central idea there is the decomposition of the problem into a tree vs. DAG structure. Once that sinks in, the question of how to make it faster (or whether to use recursion vs. iteration) is secondary, and also far more obvious to figure out on your own.<p>Moreover, this also lets the student realize that you can (sometimes) speed up divide-and-conquer with memoization, too. Which also hammers home the point that such an optimization is very much <i>distinct</i> from the technique itself!</div><br/><div id="38998141" class="c"><input type="checkbox" id="c-38998141" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38998102">parent</a><span>|</span><a href="#38998178">next</a><span>|</span><label class="collapse" for="c-38998141">[-]</label><label class="expand" for="c-38998141">[4 more]</label></div><br/><div class="children"><div class="content">I think the point of GP is that saying it&#x27;s basically “smart caching”, or “filling the cache in the correct order” helps connect with a concept many people are already very familiar with, which grounds the concept immediately. In contrast, going through each step you have outlined introduces several new concepts that are generally new and counter-intuitive to most people, so many will just give up.</div><br/><div id="38998181" class="c"><input type="checkbox" id="c-38998181" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38998141">parent</a><span>|</span><a href="#38998178">next</a><span>|</span><label class="collapse" for="c-38998181">[-]</label><label class="expand" for="c-38998181">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In contrast, going through each step you have outlined introduces several new concepts that are generally new and counter-intuitive to most people<p>What&#x27;s new there? The concept of a DAG? I dare say it&#x27;s important to learn DAGs before learning DP. Trying to teach them in the opposite order is like trying to teach multiplication before addition.<p>(I also have no idea what you find <i>counter-intuitive</i> here. How is solving complex problems by solving simpler problems counter-intuitive? Do you normally solve hard problems by solving harder problems?!)</div><br/><div id="38998336" class="c"><input type="checkbox" id="c-38998336" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38998181">parent</a><span>|</span><a href="#38998178">next</a><span>|</span><label class="collapse" for="c-38998336">[-]</label><label class="expand" for="c-38998336">[2 more]</label></div><br/><div class="children"><div class="content">Please, take the perspective of an average computer science student, who might have had some interest in computers, but maybe did not look too deep in the theory. In the past few years, they just had to learn graphs, automata and Turing machines, complexity classes, computer architecture, compilation theory, and possibly a programming language they never used before, maybe two. And they might prefer having social life than doing all-nighters on computer-assisted proof assignments :-) .<p>In short, I am not saying you <i>cannot</i> learn dynamic programming straight away from the theory, just that you are going to lose many people with this approach.<p>In fact, it makes me think of “New Math” [1], an effort to teach math from the ground-up starting in junior high. I am not familiar with how it worked in the US, but at least in France, it was definitely not a success. I would definitely have had a lot of fun, but many more did not, and failed to get a basic mathematical education at all as a result.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;New_Math" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;New_Math</a></div><br/><div id="38998574" class="c"><input type="checkbox" id="c-38998574" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38998336">parent</a><span>|</span><a href="#38998178">next</a><span>|</span><label class="collapse" for="c-38998574">[-]</label><label class="expand" for="c-38998574">[1 more]</label></div><br/><div class="children"><div class="content">Would you mind pinpointing <i>where exactly</i> you feel I would lose students in the above approach? Would I lose people at the mention of &quot;DAG&quot;? in which case... isn&#x27;t it easy enough to jog their memory in a few seconds (&quot;it&#x27;s like a tree, except a node can have multiple parents&quot; &lt;drawing&gt;) if they&#x27;ve forgotten what that is? Or is it with the N-hop example? In which case, aren&#x27;t there plenty of simpler ones (like Fibonacci) you can use instead? Or do you see somewhere else where people would get overwhelmed, and if so, where?<p>Like, I would understand where you&#x27;re coming from if I&#x27;d used the pumping lemma or something like you&#x27;re imagining, but that&#x27;s not what&#x27;s happening here? All I did was merely <i>mention</i> the words &quot;subproblems&quot;, &quot;trees&quot;, and &quot;DAGs&quot;... that&#x27;s it. No theorems, no proofs, not even any need to remember what caching is... just descriptions with vivid examples and diagrams. All of which you can re-explain in a few minutes if they&#x27;ve forgotten them. I have a hard time seeing why that should scare someone away who&#x27;s otherwise in a position to learn DP.<p>Also, isn&#x27;t the audience kinda important here? It&#x27;s not like this was intended for 10-year-olds like New Math. It was intended for college-level CS students and above. They can and should be expected to have a greater understanding (and attention span) than elementary school students.</div><br/></div></div></div></div></div></div></div></div><div id="38998178" class="c"><input type="checkbox" id="c-38998178" checked=""/><div class="controls bullet"><span class="by">bluecalm</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38998102">parent</a><span>|</span><a href="#38998141">prev</a><span>|</span><a href="#38996926">next</a><span>|</span><label class="collapse" for="c-38998178">[-]</label><label class="expand" for="c-38998178">[2 more]</label></div><br/><div class="children"><div class="content">And how do you find &quot;subproblems that  might potentially overlap&quot;? You go through the space and cache results of your calculations.<p>I don&#x27;t think there was a DP problem in my university days that couldn&#x27;t be solved this way. Are there problems that can&#x27;t? Maybe, I don&#x27;t know. From what I&#x27;ve seen you sometimes need a more clever caching but that&#x27;s about it. The question is why do we teach a very simple, intuitive concept in a way that makes a lot of people who grasp all the pre-requisites struggle with it.</div><br/><div id="38998211" class="c"><input type="checkbox" id="c-38998211" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38998178">parent</a><span>|</span><a href="#38996926">next</a><span>|</span><label class="collapse" for="c-38998211">[-]</label><label class="expand" for="c-38998211">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And how do you find &quot;subproblems that might potentially overlap&quot;? You go through the space and cache results of your calculations.<p>I addressed this directly in my comment? At the risk of repeating it: you don&#x27;t have to even <i>think</i> about caching anything in order to <i>find</i> &quot;subproblems that might potentially overlap&quot;. The example I gave directly in my comment illustrated this vividly: the shortest N-hop path from A to B is the shortest of all (N-1)-hop paths after all the first hops you can possibly traverse from A. Is it clear what the subproblems are? Yes, they&#x27;re the (N-1)-hop subproblems. Is it clear why they might overlap? Yes, because after a couple hops you might end up in the same location. Was caching relevant to understanding the aforementioned? No, it didn&#x27;t even need to cross your mind - the point was the problem decomposition. Caching is just a generic optimization you can apply later to DP, just like you can to divide-and-conquer (and to other stuff).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38996926" class="c"><input type="checkbox" id="c-38996926" checked=""/><div class="controls bullet"><span class="by">nsonha</span><span>|</span><a href="#38989889">parent</a><span>|</span><a href="#38997874">prev</a><span>|</span><a href="#38996814">next</a><span>|</span><label class="collapse" for="c-38996926">[-]</label><label class="expand" for="c-38996926">[1 more]</label></div><br/><div class="children"><div class="content">&gt; DP algorithms are &quot;just&quot; clever ways to cache a recursion<p>This is what made it click to me. When I was in university, perhaps because of the prevalence of procedural programming at the time 
(as opposed to FP), DP looked magic to me with the bottom-up tabularization examples in the textbook.<p>Practically that is the way to do it because tail-call elimination isn&#x27;t always applicable, but I wish they&#x27;s taught us the more intuitive way to look at it first (top-down, cache a recursion)</div><br/></div></div><div id="38996814" class="c"><input type="checkbox" id="c-38996814" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#38989889">parent</a><span>|</span><a href="#38996926">prev</a><span>|</span><a href="#38997311">next</a><span>|</span><label class="collapse" for="c-38996814">[-]</label><label class="expand" for="c-38996814">[7 more]</label></div><br/><div class="children"><div class="content">This is a widespread misconception: thinking of dynamic programming as just a form of memoized recursion is not the way to learn DP because it makes it extremely difficult to understand how to do the style of DP problems that involve filling out a 2D array.<p>For example, look at the &quot;best time to buy and sell stock&quot; series on leetcode: <a href="https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iii&#x2F;" rel="nofollow">https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stoc...</a>.<p>These are much more naturally done by filling out an array, right? I&#x27;ve never done them with a recursion; I can&#x27;t say I&#x27;ve thought hard about it -- is there a natural recursive solution?<p>(I linked to iii above but for anyone who hasn&#x27;t tried them they are a great intro to DP problems; start with the first one: <a href="https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock&#x2F;" rel="nofollow">https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stoc...</a>)</div><br/><div id="38996914" class="c"><input type="checkbox" id="c-38996914" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38996814">parent</a><span>|</span><a href="#38997216">next</a><span>|</span><label class="collapse" for="c-38996914">[-]</label><label class="expand" for="c-38996914">[3 more]</label></div><br/><div class="children"><div class="content">The point is that you don&#x27;t have to exactly fill the 2D array to solve the problem in that way. The 2D array is an optimization in this view, and can be safely replaced with a cache without breaking the correctness. Of course there is also some learned techniques specific to dynamic programming, and that makes it worthy to learn at some point because otherwise you will never think of them, but at its core dynamic programming is just a specific way of doing recursion.</div><br/><div id="38997018" class="c"><input type="checkbox" id="c-38997018" checked=""/><div class="controls bullet"><span class="by">da39a3ee</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38996914">parent</a><span>|</span><a href="#38997216">next</a><span>|</span><label class="collapse" for="c-38997018">[-]</label><label class="expand" for="c-38997018">[2 more]</label></div><br/><div class="children"><div class="content">OK, but, those are solved in just a few lines of code with 2D arrays. I&#x27;m not convinced it&#x27;s helpful to approach them as recursions.<p>Also, anyone who thinks they understand how to solve DP problems on leetcode because they understand how to memoize a fibonacci recursion is in for a rather large disappintment.</div><br/><div id="38997232" class="c"><input type="checkbox" id="c-38997232" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38997018">parent</a><span>|</span><a href="#38997216">next</a><span>|</span><label class="collapse" for="c-38997232">[-]</label><label class="expand" for="c-38997232">[1 more]</label></div><br/><div class="children"><div class="content">Fibonacci recursion is a bad example for DP because it is obvious how to do that. You need to teach a generative recursion, as pointed out by Shriram Krishnamurthi [1]. Once you&#x27;ve got a hang about a generative recursion DP <i>is</i> a space optimization on top of that.<p>[1] <a href="https:&#x2F;&#x2F;parentheticallyspeaking.org&#x2F;articles&#x2F;how-not-to-teach-recursion&#x2F;" rel="nofollow">https:&#x2F;&#x2F;parentheticallyspeaking.org&#x2F;articles&#x2F;how-not-to-teac...</a></div><br/></div></div></div></div></div></div><div id="38997216" class="c"><input type="checkbox" id="c-38997216" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38996814">parent</a><span>|</span><a href="#38996914">prev</a><span>|</span><a href="#38998165">next</a><span>|</span><label class="collapse" for="c-38997216">[-]</label><label class="expand" for="c-38997216">[1 more]</label></div><br/><div class="children"><div class="content">Yes, there is a natural way to solve these recursively. Here is an example: <a href="https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iii&#x2F;submissions&#x2F;1146512107" rel="nofollow">https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stoc...</a><p>Not the best runtime (I could use a multidimensional array instead of an hash map for the cache, and recursion is &quot;slow&quot; in Python), but it&#x27;s a clear solution.<p>Given a recursive solution, it is also &quot;trivial&quot; to convert it into filling an array by visiting the recursive states in reverse topological order. So here is a submission that fills in the array: <a href="https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock-iii&#x2F;submissions&#x2F;1146519236" rel="nofollow">https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stoc...</a></div><br/></div></div><div id="38998165" class="c"><input type="checkbox" id="c-38998165" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38989889">root</a><span>|</span><a href="#38996814">parent</a><span>|</span><a href="#38997216">prev</a><span>|</span><a href="#38996885">next</a><span>|</span><label class="collapse" for="c-38998165">[-]</label><label class="expand" for="c-38998165">[1 more]</label></div><br/><div class="children"><div class="content">The issue I have with not connecting dynamic programming with caching is that it becomes an exercise in cleverness, and many people just give up. It was pretty fun in school, but if I need colleagues to ramp up on it, I need a more effective approach. Sure, they might not grok the full theory right away, but they won&#x27;t use it at all, and definitely won&#x27;t get to the theory, if they think it&#x27;s too abstract for them.</div><br/></div></div></div></div></div></div><div id="38997311" class="c"><input type="checkbox" id="c-38997311" checked=""/><div class="controls bullet"><span class="by">toomanyrichies</span><span>|</span><a href="#38989889">prev</a><span>|</span><a href="#38998705">next</a><span>|</span><label class="collapse" for="c-38997311">[-]</label><label class="expand" for="c-38997311">[1 more]</label></div><br/><div class="children"><div class="content">Origin of the name &quot;dynamic programming&quot;, from its inventor, Richard Bellman:<p>&quot;I spent the Fall quarter (of 1950) at RAND. My first task was to find a name for multistage decision processes. An interesting question is, ‘Where did the name, dynamic programming, come from?’<p>The 1950s were not good years for mathematical research. We had a very interesting gentleman in Washington named Wilson. He was Secretary of Defense, and he actually had a pathological fear and hatred of the word, research. I’m not using the term lightly; I’m using it precisely. His face would suffuse, he would turn red, and he would get violent if people used the term, research, in his presence.<p>You can imagine how he felt, then, about the term, mathematical. The RAND Corporation was employed by the Air Force, and the Air Force had Wilson as its boss, essentially. Hence, I felt I had to do something to shield Wilson and the Air Force from the fact that I was really doing mathematics inside the RAND Corporation. What title, what name, could I choose?<p>In the first place I was interested in planning, in decision making, in thinking. But planning, is not a good word for various reasons. I decided therefore to use the word, ‘programming.’ I wanted to get across the idea that this was dynamic, this was multistage, this was time-varying—I thought, let’s kill two birds with one stone. Let’s take a word that has an absolutely precise meaning, namely dynamic, in the classical physical sense. It also has a very interesting property as an adjective, and that is it’s impossible to use the word, dynamic, in a pejorative sense.<p>Try thinking of some combination that will possibly give it a pejorative meaning. It’s impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to. So I used it as an umbrella for my activities”.<p>Source:<p><a href="https:&#x2F;&#x2F;alliance.seas.upenn.edu&#x2F;~cis520&#x2F;dynamic&#x2F;2021&#x2F;wiki&#x2F;index.php?n=Notes.DP" rel="nofollow">https:&#x2F;&#x2F;alliance.seas.upenn.edu&#x2F;~cis520&#x2F;dynamic&#x2F;2021&#x2F;wiki&#x2F;in...</a></div><br/></div></div><div id="38998705" class="c"><input type="checkbox" id="c-38998705" checked=""/><div class="controls bullet"><span class="by">mbwgh</span><span>|</span><a href="#38997311">prev</a><span>|</span><a href="#38989717">next</a><span>|</span><label class="collapse" for="c-38998705">[-]</label><label class="expand" for="c-38998705">[1 more]</label></div><br/><div class="children"><div class="content">I find it disappointing that the &quot;coming up with a recurrence formula&quot; part is always glanced over, which to me is very much the hard part.</div><br/></div></div><div id="38989717" class="c"><input type="checkbox" id="c-38989717" checked=""/><div class="controls bullet"><span class="by">bombela</span><span>|</span><a href="#38998705">prev</a><span>|</span><a href="#38998600">next</a><span>|</span><label class="collapse" for="c-38989717">[-]</label><label class="expand" for="c-38989717">[2 more]</label></div><br/><div class="children"><div class="content">I really like how this article exposes the problem recursively first then progressively adds caching, and finally reduces the size of the cache to only what is necessary.<p>I have often made the mistake of trying to get to the dynamic programming solution directly, and either got stuck or had to go through heroic efforts to get it working. I think from now on, I will force myself to go through the steps in order.</div><br/><div id="38990654" class="c"><input type="checkbox" id="c-38990654" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38989717">parent</a><span>|</span><a href="#38998600">next</a><span>|</span><label class="collapse" for="c-38990654">[-]</label><label class="expand" for="c-38990654">[1 more]</label></div><br/><div class="children"><div class="content">From my own experience, being taught dynamic programming straight way makes it more of a puzzle. By going through the steps and explaining _why_ we are using a table, and connecting the concept to caching, I feel like it makes much more sense.</div><br/></div></div></div></div><div id="38998600" class="c"><input type="checkbox" id="c-38998600" checked=""/><div class="controls bullet"><span class="by">deely3</span><span>|</span><a href="#38989717">prev</a><span>|</span><a href="#38994414">next</a><span>|</span><label class="collapse" for="c-38998600">[-]</label><label class="expand" for="c-38998600">[1 more]</label></div><br/><div class="children"><div class="content">What bothers me a bit, is that in example where we trying to find Levenstein distance between two string are we 100% sure that calculated distance from end of string to the start will result in the same value as when we calculate distance from start to end?</div><br/></div></div><div id="38994414" class="c"><input type="checkbox" id="c-38994414" checked=""/><div class="controls bullet"><span class="by">flobosg</span><span>|</span><a href="#38998600">prev</a><span>|</span><a href="#38992214">next</a><span>|</span><label class="collapse" for="c-38994414">[-]</label><label class="expand" for="c-38994414">[2 more]</label></div><br/><div class="children"><div class="content">One cool application of dynamic programming is the pairwise alignment of nucleotide&#x2F;protein sequences:<p>* <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequence_alignment" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequence_alignment</a><p>* <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Needleman%E2%80%93Wunsch_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Needleman%E2%80%93Wunsch_algor...</a><p>* <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Smith%E2%80%93Waterman_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Smith%E2%80%93Waterman_algorit...</a></div><br/><div id="38996403" class="c"><input type="checkbox" id="c-38996403" checked=""/><div class="controls bullet"><span class="by">gww</span><span>|</span><a href="#38994414">parent</a><span>|</span><a href="#38992214">next</a><span>|</span><label class="collapse" for="c-38996403">[-]</label><label class="expand" for="c-38996403">[1 more]</label></div><br/><div class="children"><div class="content">I would argue that these are some of the most important algorithms in bioinformatics&#x2F;biology. They have a wide range of applications.</div><br/></div></div></div></div><div id="38992214" class="c"><input type="checkbox" id="c-38992214" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#38994414">prev</a><span>|</span><a href="#38997572">next</a><span>|</span><label class="collapse" for="c-38992214">[-]</label><label class="expand" for="c-38992214">[10 more]</label></div><br/><div class="children"><div class="content">I had a very good algorithms professor. He studied at UCLA. His classes about dynamic programming were superb. He started with a problem for which the naive solution was simple and had exponential complexity. Then he broke the problem into smaller problems and reduced the complexity to something polynomial. Then he applied memoisation and the complexity dropped to linear.<p>I really would like to remember the problems he used.</div><br/><div id="38992248" class="c"><input type="checkbox" id="c-38992248" checked=""/><div class="controls bullet"><span class="by">Horffupolde</span><span>|</span><a href="#38992214">parent</a><span>|</span><a href="#38992252">next</a><span>|</span><label class="collapse" for="c-38992248">[-]</label><label class="expand" for="c-38992248">[3 more]</label></div><br/><div class="children"><div class="content">1. *Fibonacci Sequence*: The classic example where the naive recursive solution has exponential complexity. By storing previously computed values (memoization), the complexity can be reduced to linear.<p>2. *Coin Change Problem*: Given different denominations of coins and a total amount, finding the number of ways to make the change. The naive approach is exponential, but dynamic programming reduces it to polynomial complexity.<p>3. *Knapsack Problem*: Particularly the 0&#x2F;1 Knapsack problem, where items with given weights and values must be placed in a knapsack of a fixed capacity to maximize total value. The naive exponential solution can be optimized using dynamic programming.<p>4. *Matrix Chain Multiplication*: Determining the most efficient way to multiply a chain of matrices. The problem can be solved in exponential time using a naive approach but becomes much more efficient with dynamic programming.<p>5. *Longest Common Subsequence*: Finding the longest subsequence common to two sequences. A classic dynamic programming problem that can be solved in polynomial time.<p>6. *Longest Increasing Subsequence*: Finding the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order.<p>7. *Shortest Path Problems*: Like the Floyd-Warshall algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights.<p>8. *Edit Distance (Levenshtein Distance)*: Finding the minimum number of edits (insertions, deletions, substitutions) needed to change one word into another.</div><br/><div id="38992674" class="c"><input type="checkbox" id="c-38992674" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#38992214">root</a><span>|</span><a href="#38992248">parent</a><span>|</span><a href="#38993459">next</a><span>|</span><label class="collapse" for="c-38992674">[-]</label><label class="expand" for="c-38992674">[1 more]</label></div><br/><div class="children"><div class="content">I just want to add<p>9. <i>Longest Path in DAGs</i>: Find a longest path in a directed acyclic graph.<p>10. <i>Weighted Independent Set on a Path</i>: Given an array of integers, compute the maximum sum of numbers provided that you may not take two consecutive cells.</div><br/></div></div><div id="38993459" class="c"><input type="checkbox" id="c-38993459" checked=""/><div class="controls bullet"><span class="by">manvillej</span><span>|</span><a href="#38992214">root</a><span>|</span><a href="#38992248">parent</a><span>|</span><a href="#38992674">prev</a><span>|</span><a href="#38992252">next</a><span>|</span><label class="collapse" for="c-38993459">[-]</label><label class="expand" for="c-38993459">[1 more]</label></div><br/><div class="children"><div class="content">I am a big fan of the Knight Dialer. I wrote an article on it and how you can actually use graph theory to reduce it to an incredibly efficient 4x4 matrix. was super fun.</div><br/></div></div></div></div><div id="38992252" class="c"><input type="checkbox" id="c-38992252" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38992214">parent</a><span>|</span><a href="#38992248">prev</a><span>|</span><a href="#38992336">next</a><span>|</span><label class="collapse" for="c-38992252">[-]</label><label class="expand" for="c-38992252">[1 more]</label></div><br/><div class="children"><div class="content">I have listed a few in the article. It&#x27;s pretty common to see them in lectures and practical exercices.<p>- longest common subsequence<p>- longest common substring<p>- line warp<p>- subset sum<p>- partition<p>- knapsack<p>You can also have a look at [1] for more ideas.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming#Algorithms_that_use_dynamic_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming#Algorithms...</a></div><br/></div></div><div id="38992336" class="c"><input type="checkbox" id="c-38992336" checked=""/><div class="controls bullet"><span class="by">jakeinspace</span><span>|</span><a href="#38992214">parent</a><span>|</span><a href="#38992252">prev</a><span>|</span><a href="#38992350">next</a><span>|</span><label class="collapse" for="c-38992336">[-]</label><label class="expand" for="c-38992336">[1 more]</label></div><br/><div class="children"><div class="content">In addition to the suggested problems others posted, perhaps it was a scheduling problem? Like, for example, scheduling N overlapping events in time, like course schedules or processes for a CPU. Generally this would be done to optimize something like throughput - I believe that when you start adding special requirements, like &quot;These 2 courses must be taken together&quot;, then things get much more complicated and intractable compared to plain-old dynamic programming.</div><br/></div></div><div id="38992350" class="c"><input type="checkbox" id="c-38992350" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#38992214">parent</a><span>|</span><a href="#38992336">prev</a><span>|</span><a href="#38997572">next</a><span>|</span><label class="collapse" for="c-38992350">[-]</label><label class="expand" for="c-38992350">[4 more]</label></div><br/><div class="children"><div class="content">Did he study under Kang at UCLA?</div><br/><div id="38996141" class="c"><input type="checkbox" id="c-38996141" checked=""/><div class="controls bullet"><span class="by">LargeTomato</span><span>|</span><a href="#38992214">root</a><span>|</span><a href="#38992350">parent</a><span>|</span><a href="#38993955">next</a><span>|</span><label class="collapse" for="c-38996141">[-]</label><label class="expand" for="c-38996141">[1 more]</label></div><br/><div class="children"><div class="content">Maybe Eggert? He&#x27;s also the chief maintainer of emacs and Linux tzdata.</div><br/></div></div><div id="38993955" class="c"><input type="checkbox" id="c-38993955" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#38992214">root</a><span>|</span><a href="#38992350">parent</a><span>|</span><a href="#38996141">prev</a><span>|</span><a href="#38997572">next</a><span>|</span><label class="collapse" for="c-38993955">[-]</label><label class="expand" for="c-38993955">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, but I know he studied there in late 90&#x27;s or early 2000&#x27;s.</div><br/><div id="38995832" class="c"><input type="checkbox" id="c-38995832" checked=""/><div class="controls bullet"><span class="by">colordrops</span><span>|</span><a href="#38992214">root</a><span>|</span><a href="#38993955">parent</a><span>|</span><a href="#38997572">next</a><span>|</span><label class="collapse" for="c-38995832">[-]</label><label class="expand" for="c-38995832">[1 more]</label></div><br/><div class="children"><div class="content">I did as well in the 90s - I studied algorithms, which included dynamic programming, with Kang, who was recognized as an amazing algorithms teacher.</div><br/></div></div></div></div></div></div></div></div><div id="38997572" class="c"><input type="checkbox" id="c-38997572" checked=""/><div class="controls bullet"><span class="by">dps</span><span>|</span><a href="#38992214">prev</a><span>|</span><a href="#38989730">next</a><span>|</span><label class="collapse" for="c-38997572">[-]</label><label class="expand" for="c-38997572">[4 more]</label></div><br/><div class="children"><div class="content">&gt;This year’s Advent of Code has been brutal (compare the stats of 2023 with that of 2022, especially day 1 part 1 vs. day 1 part 2).<p>I enjoyed completing AoC this year. While it was very clear that day 1 (esp. part 2) was significantly harder than previous years (I wrote about this among other things [0]), OP&#x27;s claim seemed not obviously self evident when comparing _current_ 2022 stats to _current_ 2023 stats, as folks have had an additional full year to complete the 2022 puzzles.<p>I grabbed the 2022 stats from Jan 14th 2023 [1] and, indeed, the difference is quite stark. Graphing the part two completion stats[2] for both years, there was a relatively similar starting cohort size on day 1, but 2023 looks clearly harder than 2022 up until day 15. As OP observes, the ratio[3] of folks completing pt1 but not going on to complete pt 2 is way higher for a lot of days in 2023 and suggests the day 5, 10, 12 and especially day 22 part 2s were particularly difficult.<p>[0] <a href="https:&#x2F;&#x2F;blog.singleton.io&#x2F;posts&#x2F;2024-01-02-advent-of-code-2023&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.singleton.io&#x2F;posts&#x2F;2024-01-02-advent-of-code-20...</a><p>[1] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230114172513&#x2F;https:&#x2F;&#x2F;adventofcode.com&#x2F;2022&#x2F;stats" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20230114172513&#x2F;https:&#x2F;&#x2F;adventofc...</a><p>[2] <a href="https:&#x2F;&#x2F;blog.singleton.io&#x2F;static&#x2F;imgs-aoc23&#x2F;completion.png" rel="nofollow">https:&#x2F;&#x2F;blog.singleton.io&#x2F;static&#x2F;imgs-aoc23&#x2F;completion.png</a><p>[3] <a href="https:&#x2F;&#x2F;blog.singleton.io&#x2F;static&#x2F;imgs-aoc23&#x2F;ratios.png" rel="nofollow">https:&#x2F;&#x2F;blog.singleton.io&#x2F;static&#x2F;imgs-aoc23&#x2F;ratios.png</a></div><br/><div id="38998582" class="c"><input type="checkbox" id="c-38998582" checked=""/><div class="controls bullet"><span class="by">benrow</span><span>|</span><a href="#38997572">parent</a><span>|</span><a href="#38998024">next</a><span>|</span><label class="collapse" for="c-38998582">[-]</label><label class="expand" for="c-38998582">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t get very far into AoC this year as I ran out of time. Maybe I&#x27;ll pick it up again later.<p>But my point is, I was surprised at how hard day 5, part 2 was. I didn&#x27;t give up and solved it, but went away wondering whey I&#x27;d missed something obvious and overcomplicated it. So it brings some relief to know it was &#x27;supposed&quot; to be a bit challenging!</div><br/></div></div><div id="38998024" class="c"><input type="checkbox" id="c-38998024" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#38997572">parent</a><span>|</span><a href="#38998582">prev</a><span>|</span><a href="#38998199">next</a><span>|</span><label class="collapse" for="c-38998024">[-]</label><label class="expand" for="c-38998024">[1 more]</label></div><br/><div class="children"><div class="content">Early AoC was fun, you could get away without anything fancy until late in the game. Then it got harder, not fun, so I gave up and stopped touching it.</div><br/></div></div><div id="38998199" class="c"><input type="checkbox" id="c-38998199" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38997572">parent</a><span>|</span><a href="#38998024">prev</a><span>|</span><a href="#38989730">next</a><span>|</span><label class="collapse" for="c-38998199">[-]</label><label class="expand" for="c-38998199">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the details. To add to this discussion, I have a script to see the progression over the days.<p>Looking at the last two columns, you can see how brutal 2023 was compared to 2022. Especially in the beginning. The first few days, most people keep playing, with a retention higher than 80% most days, and virtually everyone people solve both parts. In contrast, only 76% of people solved part 2 after solving part 1. And many people gave up on days 3 and 5.<p>Interestingly, the last few days are not that much lower. And that can be explained by the fact that AoC 2023 is more recent than AoC 2022, like you said. My interpretation is that this group of people will get over all the challenges regardless of the difficulty (to an extent, of course), while many other people will give up when they realize it will take too much of their time.<p><pre><code>    Stats for year 2022 of Advent of Code
    -------------------------------------
    
    Day   Both puzzles   One puzzle       Total   Rel. puzzle 1&#x2F;2   Rel. day before
      1        280,838       15,047     295,885              95 %             100 %
      2        232,752       12,403     245,155              95 %              83 %
      3        200,016       11,392     211,408              95 %              86 %
      4        184,435        3,734     188,169              98 %              92 %
      5        157,392        3,116     160,508              98 %              85 %
      6        155,921        1,602     157,523              99 %              99 %
      7        113,241        2,592     115,833              98 %              73 %
      8        107,224        7,659     114,883              93 %              95 %
      9         82,414       11,449      93,863              88 %              77 %
     10         85,075        5,511      90,586              94 %             103 %
     11         68,838        9,258      78,096              88 %              81 %
     12         59,253        1,061      60,314              98 %              86 %
     13         51,512        1,220      52,732              98 %              87 %
     14         49,051          991      50,042              98 %              95 %
     15         39,677        5,773      45,450              87 %              81 %
     16         23,298        5,650      28,948              80 %              59 %
     17         21,525        6,237      27,762              78 %              92 %
     18         25,420        4,927      30,347              84 %             118 %
     19         17,516          928      18,444              95 %              69 %
     20         22,141        1,003      23,144              96 %             126 %
     21         23,022        3,060      26,082              88 %             104 %
     22         15,393        5,083      20,476              75 %              67 %
     23         18,531          254      18,785              99 %             120 %
     24         16,419          252      16,671              98 %              89 %
     25         13,192        7,473      20,665              64 %              80 %
    ~&#x2F;src&#x2F;advent-of-code% .&#x2F;stats.py 2023
    Stats for year 2023 of Advent of Code
    -------------------------------------
    
    Day   Both puzzles   One puzzle       Total   Rel. puzzle 1&#x2F;2   Rel. day before
      1        230,737       73,941     304,678              76 %             100 %
      2        196,352        9,256     205,608              95 %              85 %
      3        130,406       19,913     150,319              87 %              66 %
      4        130,271       17,691     147,962              88 %             100 %
      5         80,255       31,029     111,284              72 %              62 %
      6        103,358        1,918     105,276              98 %             129 %
      7         81,905        7,308      89,213              92 %              79 %
      8         74,034       14,707      88,741              83 %              90 %
      9         76,438        1,229      77,667              98 %             103 %
     10         48,313       17,054      65,367              74 %              63 %
     11         57,339        2,386      59,725              96 %             119 %
     12         30,985       14,440      45,425              68 %              54 %
     13         38,217        5,223      43,440              88 %             123 %
     14         36,500        7,457      43,957              83 %              96 %
     15         40,881        4,156      45,037              91 %             112 %
     16         35,347        1,023      36,370              97 %              86 %
     17         24,014        1,097      25,111              96 %              68 %
     18         24,799        4,937      29,736              83 %             103 %
     19         22,525        7,197      29,722              76 %              91 %
     20         18,287        4,398      22,685              81 %              81 %
     21         14,311       10,149      24,460              59 %              78 %
     22         15,830          988      16,818              94 %             111 %
     23         14,562        2,964      17,526              83 %              92 %
     24         11,864        4,918      16,782              71 %              81 %
     25         10,522        3,048      13,570              78 %              89 %</code></pre></div><br/></div></div></div></div><div id="38989730" class="c"><input type="checkbox" id="c-38989730" checked=""/><div class="controls bullet"><span class="by">gligorot</span><span>|</span><a href="#38997572">prev</a><span>|</span><a href="#38989529">next</a><span>|</span><label class="collapse" for="c-38989730">[-]</label><label class="expand" for="c-38989730">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240114111200&#x2F;https:&#x2F;&#x2F;qsantos.fr&#x2F;2024&#x2F;01&#x2F;04&#x2F;dynamic-programming-is-not-black-magic&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20240114111200&#x2F;https:&#x2F;&#x2F;qsantos.f...</a><p>Since it got the hug of death</div><br/><div id="38989984" class="c"><input type="checkbox" id="c-38989984" checked=""/><div class="controls bullet"><span class="by">wmil</span><span>|</span><a href="#38989730">parent</a><span>|</span><a href="#38990684">next</a><span>|</span><label class="collapse" for="c-38989984">[-]</label><label class="expand" for="c-38989984">[1 more]</label></div><br/><div class="children"><div class="content">Effective web caching is black magic.</div><br/></div></div><div id="38990684" class="c"><input type="checkbox" id="c-38990684" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38989730">parent</a><span>|</span><a href="#38989984">prev</a><span>|</span><a href="#38989529">next</a><span>|</span><label class="collapse" for="c-38990684">[-]</label><label class="expand" for="c-38990684">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I should have planned better for that before posting.</div><br/></div></div></div></div><div id="38989529" class="c"><input type="checkbox" id="c-38989529" checked=""/><div class="controls bullet"><span class="by">ulucs</span><span>|</span><a href="#38989730">prev</a><span>|</span><a href="#38989734">next</a><span>|</span><label class="collapse" for="c-38989529">[-]</label><label class="expand" for="c-38989529">[42 more]</label></div><br/><div class="children"><div class="content">The name &quot;Dynamic Programming&quot; might seem out of place because it doesn&#x27;t come from programming as a discipline. In this case, it actually refers to something like optimization, similar to linear programming. Dynamic programming is basically a method you can use to solve decision problems with discrete time, i.e picking the optimal sequence {a_t} in order to maximize \sum_t u_t(a_t) (plus constraints). The &quot;dynamic programming&quot; is defining a value function V* where V*(t) = max_{a_t}{ u_t(a_t) + V*(t-1) } which greatly reduces the dimensionality of the optimization problem.</div><br/><div id="38989723" class="c"><input type="checkbox" id="c-38989723" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38989627">next</a><span>|</span><label class="collapse" for="c-38989723">[-]</label><label class="expand" for="c-38989723">[24 more]</label></div><br/><div class="children"><div class="content">In fact, the official line [0] on where the name comes from is quite funny. I shall quote my favourite part:<p>&gt; [Dynamic] also has a very interesting property as an adjective, and that is it&#x27;s impossible to use the word dynamic in a pejorative sense. Try thinking of some combination that will possibly give it a pejorative meaning. It&#x27;s impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to.<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming#History" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming#History</a></div><br/><div id="38990180" class="c"><input type="checkbox" id="c-38990180" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989723">parent</a><span>|</span><a href="#38989878">next</a><span>|</span><label class="collapse" for="c-38990180">[-]</label><label class="expand" for="c-38990180">[17 more]</label></div><br/><div class="children"><div class="content">My dad told me a joke&#x2F;story once about one of his old psychologist colleagues(call him Dave) arguing with a psychoanalyst* about some psychology thing.<p>After a while of the discussion going nowhere, the psychoanalyst said something like this. &quot;Not to worry, Dave, I know you&#x27;re dynamically minded enough that you&#x27;ll eventually learn to agree with me.&quot;<p>Dave was not pleased.<p>I guess that was more condescending than pejorative, but oh well.<p>(Most modern clinical psychologists consider psychoanalysis to be a pseduoscience. A small minority still practice it even clinically. They don&#x27;t like eachother very much)</div><br/><div id="38994479" class="c"><input type="checkbox" id="c-38994479" checked=""/><div class="controls bullet"><span class="by">ordu</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990180">parent</a><span>|</span><a href="#38991961">next</a><span>|</span><label class="collapse" for="c-38994479">[-]</label><label class="expand" for="c-38994479">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; After a while of the discussion going nowhere, the psychoanalyst said something like this. &quot;Not to worry, Dave, I know you&#x27;re dynamically minded enough that you&#x27;ll eventually learn to agree with me.&quot;</i><p>It looks like psychoanalyst suffered from a professional deformation. Not enough evidence to be sure, but it is the main premise of psychoanalysis that psychoanalyst knows better then his &quot;patient&quot;. A psychoanalyst knows what his patient feels, thinks, wishes, and so on. If patient doesn&#x27;t agree then it is a &quot;resistance&quot; and overcoming it is the first priority task for a psychoanalyst.<p><i>&gt; I guess that was more condescending than pejorative, but oh well.</i><p>The whole statement is condescending, but not because of &quot;dynamically minded&quot;. It is &quot;you&#x27;ll learn to agree with me&quot; that does the trick.</div><br/><div id="38996451" class="c"><input type="checkbox" id="c-38996451" checked=""/><div class="controls bullet"><span class="by">slumberdisrupt</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38994479">parent</a><span>|</span><a href="#38991961">next</a><span>|</span><label class="collapse" for="c-38996451">[-]</label><label class="expand" for="c-38996451">[1 more]</label></div><br/><div class="children"><div class="content">This is a caricature of clinical psychoanalysis and is more applicable to other therapies. For example, the initial moments of CBT are &quot;psychoeducation&quot;, where the therapist sketches out with magic markers a bunch of categories (feelings, thoughts, behaviors, emotions) and their subcategories, and the patient learns to see themselves in these ontological terms. Suggestibility is the cornerstone of these interventions.<p>Every psychoanalyst of course has their theoretical meta-psychology, but every clinical psychoanalyst knows that they must fight to abandon it at the door as they confront every analysand anew. Psychoanalysis is not a matter of instructing the patient of the death drive, of resistance, of the Oedipus complex, and so on. (Freud was wrong about why his intervention with Little Hans &quot;succeeded&quot;.) Freud himself searched for something beyond hypnosis because the hypnotic technique required a susceptibility of the patient to suggestion, and furthermore required a constant relationship with the patient, otherwise the patient would invariably suffer a symptom relapse. Relate this to the dismal long-term rates of regression of CBT patients. (And this is the forbidden evidence of this &quot;evidence based therapy&quot;.)<p>The analysand enters the analytical relationship supposing (as you have supposed) that the analyst knows something crucial that the analysand does not. So what happens as the analysand comes to realize that the analyst does not, in fact, possess this knowledge? The analyst indeed knows they don&#x27;t know, but this is presumably nothing like what you assume the analyst supposes themselves to know.<p>The analyst is, in their role as an analyst (and not a therapist), merely the secretary of the analysand. They &quot;take notes&quot; on what the analyst says, in order to help show the analyst what they&#x27;ve said.</div><br/></div></div></div></div><div id="38990632" class="c"><input type="checkbox" id="c-38990632" checked=""/><div class="controls bullet"><span class="by">savolai</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990180">parent</a><span>|</span><a href="#38991961">prev</a><span>|</span><a href="#38989878">next</a><span>|</span><label class="collapse" for="c-38990632">[-]</label><label class="expand" for="c-38990632">[13 more]</label></div><br/><div class="children"><div class="content">Care to offer evidence of pseudoscience status? All I could find was debunkings of this claim as myth and outdated, and to my understanding research in the field has caught wind in past decades. I’d love to learn more about the debate, so any pointers are welcome.<p><a href="https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;pmc&#x2F;articles&#x2F;PMC6020924&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;pmc&#x2F;articles&#x2F;PMC6020924&#x2F;</a><p><a href="https:&#x2F;&#x2F;cosmonautmag.com&#x2F;2021&#x2F;10&#x2F;on-the-scientific-status-of-psychoanalysis&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cosmonautmag.com&#x2F;2021&#x2F;10&#x2F;on-the-scientific-status-of...</a><p>” Depending on where your philosophical allegiances lie, Karl Popper might be a friend or an enemy to whatever version of philosophy of science you accept. Falsificationist approaches to science imply that psychoanalysis makes untestable and unfalsifiable claims! Popper made the very same claims about Marxist social theory as well. There are two issues with this approach. One, if falsificationism is true, then all social sciences, and even some natural sciences, are pseudo-scientific. This is an unacceptable conclusion since much of social science is clearly science. Lots of cutting-edge physics whose models do not lend themselves to controlled experimental testing would also lose their status as science. That is also an absurd conclusion. Newtonian mechanics, for example, would never have been accepted as a theory if we use Popper’s standards of theory corroboration and falsifiability. The theory offered better ways of explaining phenomenon that previous theories were already decent at predicting reliably. The process of legitimizing Newtonian physics had nothing to do with testability.4 A good theory of science does not rule out obvious cases of scientific rigor.5”</div><br/><div id="38991144" class="c"><input type="checkbox" id="c-38991144" checked=""/><div class="controls bullet"><span class="by">mtlmtlmtlmtl</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38991948">next</a><span>|</span><label class="collapse" for="c-38991144">[-]</label><label class="expand" for="c-38991144">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a psychologist myself, and I know nothing about modern <i>academic</i> psychoanalysis. I&#x27;ve tried to read some but it was indecipherable to me.<p>Modern clinical psychoanalysis is a strange field. It went out of vogue with the advent of behavioral and later cognitive psychology in the latter half of the 20th century, as well as psychiatry. Psychoanalysts tend to believe their way is the only way, while more modern psychologists are much more eclectic. They&#x27;re often extremely critical of the use of medication even in cases where the evidence supporting their use is overwhelming, like stimulants for ADHD.<p>Psychoanalysts have their own strange nomenclature that&#x27;s often incompatible with modern developments. So it&#x27;s hard for other psychologists to even talk to them at all.<p>Those are some of the reasons psychoanalysis is viewed as pseudoscientific by modern clinical psychologists.</div><br/></div></div><div id="38991948" class="c"><input type="checkbox" id="c-38991948" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38991144">prev</a><span>|</span><a href="#38993038">next</a><span>|</span><label class="collapse" for="c-38991948">[-]</label><label class="expand" for="c-38991948">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Psychoanalysis#Debate_over_status_as_scientific" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Psychoanalysis#Debate_over_sta...</a><p><a href="https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;pmc&#x2F;articles&#x2F;PMC5459228&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.ncbi.nlm.nih.gov&#x2F;pmc&#x2F;articles&#x2F;PMC5459228&#x2F;</a><p><a href="https:&#x2F;&#x2F;www.bbvaopenmind.com&#x2F;en&#x2F;science&#x2F;research&#x2F;psychoanalysis-science-or-pseudoscience&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bbvaopenmind.com&#x2F;en&#x2F;science&#x2F;research&#x2F;psychoanaly...</a><p><a href="https:&#x2F;&#x2F;link.springer.com&#x2F;referenceworkentry&#x2F;10.1007&#x2F;978-94-017-8706-2_41-1" rel="nofollow">https:&#x2F;&#x2F;link.springer.com&#x2F;referenceworkentry&#x2F;10.1007&#x2F;978-94-...</a><p><a href="https:&#x2F;&#x2F;www.skeptic.org.uk&#x2F;2021&#x2F;07&#x2F;psychoanalysis-science-or-pseudoscience-examining-the-status-of-freudian-theory&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.skeptic.org.uk&#x2F;2021&#x2F;07&#x2F;psychoanalysis-science-or...</a><p><a href="https:&#x2F;&#x2F;philarchive.org&#x2F;archive&#x2F;FERIPA-6" rel="nofollow">https:&#x2F;&#x2F;philarchive.org&#x2F;archive&#x2F;FERIPA-6</a><p>That quote you included seems a little funny. It’s not making any direct or compelling argument in favor of psychoanalysis being science, it’s just saying well if psychoanalysis isn’t science then other disciplines aren’t science either, and since that’s sometimes not true, then Popper is wrong. It’s a slippery argument with some assumptions and big holes, and perhaps most glaringly it is intentionally ignoring the magnitude or degree of scientific experimentation, and attempting to frame the issue as only binary: science or not science.<p>I’m sure there is some modern psychoanalysis that is scientific, but OTOH it seems like the foundations of psychoanalysis, especially Freud, are certainly problematic from the perspective of science, right? Psychoanalysis has a valid, earned reputation that may take a very long time to fix, even if today’s practitioners are being careful and scientific. This could be compared to chiropractic medicine - some of it is valid medicine today, but it definitely came from non-medical, non-scientific origins.<p>There appear to be at least 2 separate arguments going. One is whether psychoanalysis <i>can</i> be a science, and the other is whether it actually was a science historically. This is why both sides are somewhat right: proponents of psychoanalysis argue that it can be scientific, which is true, and opponents argue that it wasn’t scientific in origin and has a troubled past, which is also true.</div><br/><div id="38994020" class="c"><input type="checkbox" id="c-38994020" checked=""/><div class="controls bullet"><span class="by">savolai</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38991948">parent</a><span>|</span><a href="#38993038">next</a><span>|</span><label class="collapse" for="c-38994020">[-]</label><label class="expand" for="c-38994020">[1 more]</label></div><br/><div class="children"><div class="content">The issue for me is that the popular claim against psychoanalysis seems to be exactly that, binary.<p>Thanks for bringing nuance and providing quotes!<p>I’ve personally benefited tremendously from work with the ego structure and from realizing I can strenghen my will&#x2F;ego capacities and learn to more and more discern and deny excessive power from my superego - from past learnt protective and restrictive impulses that no longer serve a purpose. This understanding alone seems like a treasure trove  that keeps on giving year after year while doing introspective work and self inquiry with others interested in the work.<p>However I have little understanding how this fits in a modern understanding of psychoanalysis or psychodynamic psychotherapy.<p>What I do know is that CBT I did younger didn’t seem to have nearly sufficient explanatory powers to help me personally. Most of the skills I was offered seemed more or less trivial or perhaps were taught ineffectively.<p>Another thing that I would have needed was tapping into the resources of my body in the context of therapy and how that links to having capacity to work with myself. CBT seemed obsessed with, umh, overly just cognition.</div><br/></div></div></div></div><div id="38993038" class="c"><input type="checkbox" id="c-38993038" checked=""/><div class="controls bullet"><span class="by">raincom</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38991948">prev</a><span>|</span><a href="#38992065">next</a><span>|</span><label class="collapse" for="c-38993038">[-]</label><label class="expand" for="c-38993038">[1 more]</label></div><br/><div class="children"><div class="content">Demarcation problem is unique to Popper&#x27;s philosophy of science. That problem doesn&#x27;t exist in other philosophies of science. The best attack on psychoanalysis comes from the late philosopher of science Adolf Grunbaum&#x27;s &quot;The Foundations of Psychoanalysis: A philosophical critique&quot;</div><br/></div></div><div id="38992065" class="c"><input type="checkbox" id="c-38992065" checked=""/><div class="controls bullet"><span class="by">bakuninsbart</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38993038">prev</a><span>|</span><a href="#38992623">next</a><span>|</span><label class="collapse" for="c-38992065">[-]</label><label class="expand" for="c-38992065">[2 more]</label></div><br/><div class="children"><div class="content">Interesting quote, since my mind immediately went to Critical theory, one of the schools of philosophy probably targetted by Popper.<p>Over the last 200 years, the definition of science has been deliberately narrowed down a lot, mainly to combat pseudo-science and misinformation, but I think partially also to create an in-circle of academics. There are few good definitions of science, and usually they are a bit self-contradictory or insufficient to capture the underlying <i>goal</i> of science; the building of a corpus of verified knowledge. Falsification is a very high standard, that cannot always be applied, but it is still a good first test to filter out possible bullshit.<p>In deductive studies (formal sciences but also often in other fields) we need to have acceptable axioms, and rigorous deductions from these axioms. In inductive studies,  you need  good data and valid methods to derive meaning from that data. A lot of research actually falls somewhere in-between, and we wouldn&#x27;t want to outright dismiss it, as many subjects would be too elusive to study at all, but we still have a vested interest in understanding them.<p>A lot of research, and I would count psycho-analysis in there for the most part, kind of walks the line between pseudo-science and proper deductive or inductive studies. These fields definetely build a corpus of knowledge, which often turns out to be true, but there are fewer good measures of filtering the bullshit from the nuggets of truth, and that substantially devalues the field. The risk, not exclusive but especially pronounced, is that acceptance of research becomes more a measure of eloquence than depth of enquiry.<p>And fields can be collectively wrong, even in the more rigorous fields that lend themselves to proper testing or deductive reasoning: You mention Newtonian Physics, but there are too many examples to enumerate: Quantum superposition was extremely controversial when first proposed, and poor Lobachevsky was ruthlessly mocked for his perfectly valid development of hyperbolic geometry.</div><br/><div id="38994507" class="c"><input type="checkbox" id="c-38994507" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38992065">parent</a><span>|</span><a href="#38992623">next</a><span>|</span><label class="collapse" for="c-38994507">[-]</label><label class="expand" for="c-38994507">[1 more]</label></div><br/><div class="children"><div class="content">IMO, modern psychology “walks the line between pseudo-science and proper deductive or inductive studies”. Psychoanalysis at best sometimes stumbles in the right direction.</div><br/></div></div></div></div><div id="38992623" class="c"><input type="checkbox" id="c-38992623" checked=""/><div class="controls bullet"><span class="by">patrick451</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38992065">prev</a><span>|</span><a href="#38992600">next</a><span>|</span><label class="collapse" for="c-38992623">[-]</label><label class="expand" for="c-38992623">[2 more]</label></div><br/><div class="children"><div class="content">Rejecting an assertion because you don&#x27;t like it&#x27;s conclusion is pretty specious. I fully endorse the notion that any practice which makes unfalsifiable claims is not science. But that doesn&#x27;t necessarily make such a practice pseudo science -- this is a false dichotomy. There are disciplines which are neither scientific nor pseudo-scientific.</div><br/><div id="38992788" class="c"><input type="checkbox" id="c-38992788" checked=""/><div class="controls bullet"><span class="by">mp05</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38992623">parent</a><span>|</span><a href="#38992600">next</a><span>|</span><label class="collapse" for="c-38992788">[-]</label><label class="expand" for="c-38992788">[1 more]</label></div><br/><div class="children"><div class="content">Well hang on, let me go find my logic book from college to decipher...</div><br/></div></div></div></div><div id="38992600" class="c"><input type="checkbox" id="c-38992600" checked=""/><div class="controls bullet"><span class="by">CamperBob2</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38992623">prev</a><span>|</span><a href="#38990850">next</a><span>|</span><label class="collapse" for="c-38992600">[-]</label><label class="expand" for="c-38992600">[1 more]</label></div><br/><div class="children"><div class="content">As I understand it, the notion of falsifiability is really more like, &quot;Theory X is acceptable if it can be shown to be false by the use of tools whose principles meet the same standard of falsifiability, even if those tools aren&#x27;t currently available.&quot;<p>So a theory that can be tested only with later scientific refinements -- say, by increasing measurement precision beyond what&#x27;s currently available -- is indeed eligible to be classified as science. That criterion would allow for Newtonian mechanics to be accepted in its time, and for things like string theory to be accepted provisionally in ours.<p>Basically, the ultimate failure of the Newtonian model can&#x27;t be used as an argument that it should never have been considered valid science.</div><br/></div></div><div id="38990850" class="c"><input type="checkbox" id="c-38990850" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990632">parent</a><span>|</span><a href="#38992600">prev</a><span>|</span><a href="#38989878">next</a><span>|</span><label class="collapse" for="c-38990850">[-]</label><label class="expand" for="c-38990850">[3 more]</label></div><br/><div class="children"><div class="content">The burden of proof lies on them that claim it’s a “real” science.</div><br/><div id="38991889" class="c"><input type="checkbox" id="c-38991889" checked=""/><div class="controls bullet"><span class="by">savolai</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990850">parent</a><span>|</span><a href="#38992800">next</a><span>|</span><label class="collapse" for="c-38991889">[-]</label><label class="expand" for="c-38991889">[1 more]</label></div><br/><div class="children"><div class="content">It appears to me the burden of proof lies on whoever wants to draw the line on what ”real” science is. Only natural sciences, then?</div><br/></div></div><div id="38992800" class="c"><input type="checkbox" id="c-38992800" checked=""/><div class="controls bullet"><span class="by">mp05</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990850">parent</a><span>|</span><a href="#38991889">prev</a><span>|</span><a href="#38989878">next</a><span>|</span><label class="collapse" for="c-38992800">[-]</label><label class="expand" for="c-38992800">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;No_true_Scotsman" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;No_true_Scotsman</a></div><br/></div></div></div></div></div></div></div></div><div id="38989878" class="c"><input type="checkbox" id="c-38989878" checked=""/><div class="controls bullet"><span class="by">smokel</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989723">parent</a><span>|</span><a href="#38990180">prev</a><span>|</span><a href="#38990676">next</a><span>|</span><label class="collapse" for="c-38989878">[-]</label><label class="expand" for="c-38989878">[4 more]</label></div><br/><div class="children"><div class="content">Dynamic typing comes to mind ;)</div><br/><div id="38990015" class="c"><input type="checkbox" id="c-38990015" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989878">parent</a><span>|</span><a href="#38990676">next</a><span>|</span><label class="collapse" for="c-38990015">[-]</label><label class="expand" for="c-38990015">[3 more]</label></div><br/><div class="children"><div class="content">Dynamic scoping ;)</div><br/><div id="38990352" class="c"><input type="checkbox" id="c-38990352" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990015">parent</a><span>|</span><a href="#38996376">next</a><span>|</span><label class="collapse" for="c-38990352">[-]</label><label class="expand" for="c-38990352">[1 more]</label></div><br/><div class="children"><div class="content">You cannot get any more pejorative.  Mission accomplished!</div><br/></div></div><div id="38996376" class="c"><input type="checkbox" id="c-38996376" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990015">parent</a><span>|</span><a href="#38990352">prev</a><span>|</span><a href="#38990676">next</a><span>|</span><label class="collapse" for="c-38996376">[-]</label><label class="expand" for="c-38996376">[1 more]</label></div><br/><div class="children"><div class="content">Dynamic ethics.</div><br/></div></div></div></div></div></div><div id="38990676" class="c"><input type="checkbox" id="c-38990676" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989723">parent</a><span>|</span><a href="#38989878">prev</a><span>|</span><a href="#38992340">next</a><span>|</span><label class="collapse" for="c-38990676">[-]</label><label class="expand" for="c-38990676">[1 more]</label></div><br/><div class="children"><div class="content">It _is_ a funny quote.<p>But I would still point out that this is the exact reason “dynamic” does not help if you do not know about the history. Since it can be applied to anything, it does not help you trim down what it can refer to.</div><br/></div></div><div id="38992340" class="c"><input type="checkbox" id="c-38992340" checked=""/><div class="controls bullet"><span class="by">karmakaze</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989723">parent</a><span>|</span><a href="#38990676">prev</a><span>|</span><a href="#38989627">next</a><span>|</span><label class="collapse" for="c-38992340">[-]</label><label class="expand" for="c-38992340">[1 more]</label></div><br/><div class="children"><div class="content">Scripting languages are called &#x27;dynamic&#x27; sometimes pejoratively. Dynamic microphones are also inferior in studio recording situations. I could see a poor DP implementation wasting memory being described negatively.</div><br/></div></div></div></div><div id="38989627" class="c"><input type="checkbox" id="c-38989627" checked=""/><div class="controls bullet"><span class="by">glimshe</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38989723">prev</a><span>|</span><a href="#38994048">next</a><span>|</span><label class="collapse" for="c-38989627">[-]</label><label class="expand" for="c-38989627">[5 more]</label></div><br/><div class="children"><div class="content">Most of the time I hear the term being used by other people (not you :) ), I feel it&#x27;s for showing off and look smarter than everybody else - &quot;Look, I used dynamic programming to solve that problem&quot;, when in fact they were just employing what I&#x27;d consider the natural and intuitive approach for solving the problem. There was nothing they actually &quot;used&quot;, besides happening to identify that the problem could be broken into progressively smaller subproblems.</div><br/><div id="38990163" class="c"><input type="checkbox" id="c-38990163" checked=""/><div class="controls bullet"><span class="by">mk89</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989627">parent</a><span>|</span><a href="#38991554">next</a><span>|</span><label class="collapse" for="c-38990163">[-]</label><label class="expand" for="c-38990163">[1 more]</label></div><br/><div class="children"><div class="content">&gt; happening to identify that the problem could be broken into progressively smaller subproblems.<p>Which is what dynamic programming is about. And no, not everyone is capable to do that, especially since not all problems solved at work are Leetcode.<p>Sometimes people really have to  spend hours or days to understand how to split a problem. Only then optimizations can be applied or become &quot;obvious&quot;.<p>Like usual, solutions are &quot;so obvious&quot; when someone has done a lot of heavy lifting to simplify the problem, improve the context, etc.</div><br/></div></div><div id="38991554" class="c"><input type="checkbox" id="c-38991554" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989627">parent</a><span>|</span><a href="#38990163">prev</a><span>|</span><a href="#38989693">next</a><span>|</span><label class="collapse" for="c-38991554">[-]</label><label class="expand" for="c-38991554">[2 more]</label></div><br/><div class="children"><div class="content">Do you feel similarly if someone says they used an iterative, recursive, or greedy algorithm?<p>Dynamic programming is a whole chapter in most algorithms books.  It&#x27;s not about showing off, it&#x27;s the name of the technique.</div><br/><div id="38997127" class="c"><input type="checkbox" id="c-38997127" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38991554">parent</a><span>|</span><a href="#38989693">next</a><span>|</span><label class="collapse" for="c-38997127">[-]</label><label class="expand" for="c-38997127">[1 more]</label></div><br/><div class="children"><div class="content">As I interpret the GP, the person is peacocking or gate-keeping by (humble)bragging about using dynamic programming to solve a problem.  For all we know, they Googled for an efficient algorithm and copied the result.  I have done it before, and I have no shame about it.  If a teammate asks me how I knew about that dynamic programming algorithm, I would reply: &quot;Are you joking?  I could never program that myself.  Thank you Google.&quot;  Except for a few algorithms, most are solved using iterative or recursive.</div><br/></div></div></div></div><div id="38989693" class="c"><input type="checkbox" id="c-38989693" checked=""/><div class="controls bullet"><span class="by">valval</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38989627">parent</a><span>|</span><a href="#38991554">prev</a><span>|</span><a href="#38994048">next</a><span>|</span><label class="collapse" for="c-38989693">[-]</label><label class="expand" for="c-38989693">[1 more]</label></div><br/><div class="children"><div class="content">Well aren’t you cynical.</div><br/></div></div></div></div><div id="38994048" class="c"><input type="checkbox" id="c-38994048" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38989627">prev</a><span>|</span><a href="#38991884">next</a><span>|</span><label class="collapse" for="c-38994048">[-]</label><label class="expand" for="c-38994048">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting how <i>computing things</i> - like optimization problems - used to be much more dominant in terms of what people thought about and did with computers. It feels like most of the time we are just doing data storage and retrieval combined with networking... some computations are embedded within those things, but usually well encapsulated.</div><br/></div></div><div id="38991884" class="c"><input type="checkbox" id="c-38991884" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38994048">prev</a><span>|</span><a href="#38990202">next</a><span>|</span><label class="collapse" for="c-38991884">[-]</label><label class="expand" for="c-38991884">[4 more]</label></div><br/><div class="children"><div class="content">“Optimization” is similarly misleading (as someone who once took a CS class on “optimization” expecting something very different ;)).</div><br/><div id="38994538" class="c"><input type="checkbox" id="c-38994538" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38991884">parent</a><span>|</span><a href="#38990202">next</a><span>|</span><label class="collapse" for="c-38994538">[-]</label><label class="expand" for="c-38994538">[3 more]</label></div><br/><div class="children"><div class="content">Optimisation is just function minimisation&#x2F;maximisation. What did you expect and how was it different?</div><br/><div id="38994585" class="c"><input type="checkbox" id="c-38994585" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38994538">parent</a><span>|</span><a href="#38990202">next</a><span>|</span><label class="collapse" for="c-38994585">[-]</label><label class="expand" for="c-38994585">[2 more]</label></div><br/><div class="children"><div class="content">Not speaking for the GP but I&#x27;d imagine &quot;optimizing&quot; for performance. I had a professor who would get very irritated when anyone mentioned &quot;optimizing&quot; a program for just this reason, since you weren&#x27;t finding the <i>best possible</i> runtime.</div><br/><div id="38994735" class="c"><input type="checkbox" id="c-38994735" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38994585">parent</a><span>|</span><a href="#38990202">next</a><span>|</span><label class="collapse" for="c-38994735">[-]</label><label class="expand" for="c-38994735">[1 more]</label></div><br/><div class="children"><div class="content">Oh, makes sense, performance optimisation didn’t cross my mind for some reason.</div><br/></div></div></div></div></div></div></div></div><div id="38990202" class="c"><input type="checkbox" id="c-38990202" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38991884">prev</a><span>|</span><a href="#38989756">next</a><span>|</span><label class="collapse" for="c-38990202">[-]</label><label class="expand" for="c-38990202">[3 more]</label></div><br/><div class="children"><div class="content">Compare also &#x27;Linear Programming&#x27;.  Or the usage of a &#x27;TV programme&#x27; or a &#x27;musical programme&#x27;.</div><br/><div id="38997332" class="c"><input type="checkbox" id="c-38997332" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990202">parent</a><span>|</span><a href="#38995891">next</a><span>|</span><label class="collapse" for="c-38997332">[-]</label><label class="expand" for="c-38997332">[1 more]</label></div><br/><div class="children"><div class="content">Yeah the &quot;programming&quot; part has always thrown me off when I started my first Engineering job one of the guys was always talking about an &quot;LP&quot; model I thought it was some deep piece of black magic until I realized it was essentially brute searching for a solution to a series of simultaneous equations.<p>I think &quot;Linear Optimization&quot; might be a better term, or maybe &quot;Linear Solving&quot;.</div><br/></div></div><div id="38995891" class="c"><input type="checkbox" id="c-38995891" checked=""/><div class="controls bullet"><span class="by">tnecniv</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990202">parent</a><span>|</span><a href="#38997332">prev</a><span>|</span><a href="#38989756">next</a><span>|</span><label class="collapse" for="c-38995891">[-]</label><label class="expand" for="c-38995891">[1 more]</label></div><br/><div class="children"><div class="content">That’s the programming part. As others have shared, the “Dynamic” part was made up by Bellman so it sounded important and politicians wouldn’t try to cut his funding. It’s often applied to dynamical systems, but that’s a coincidence.</div><br/></div></div></div></div><div id="38989756" class="c"><input type="checkbox" id="c-38989756" checked=""/><div class="controls bullet"><span class="by">asimpletune</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38990202">prev</a><span>|</span><a href="#38990956">next</a><span>|</span><label class="collapse" for="c-38989756">[-]</label><label class="expand" for="c-38989756">[1 more]</label></div><br/><div class="children"><div class="content">This is the correct definition of dp.</div><br/></div></div><div id="38990956" class="c"><input type="checkbox" id="c-38990956" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38989756">prev</a><span>|</span><a href="#38989710">next</a><span>|</span><label class="collapse" for="c-38990956">[-]</label><label class="expand" for="c-38990956">[2 more]</label></div><br/><div class="children"><div class="content">You forgot to define u and t.</div><br/><div id="38997796" class="c"><input type="checkbox" id="c-38997796" checked=""/><div class="controls bullet"><span class="by">tnecniv</span><span>|</span><a href="#38989529">root</a><span>|</span><a href="#38990956">parent</a><span>|</span><a href="#38989710">next</a><span>|</span><label class="collapse" for="c-38997796">[-]</label><label class="expand" for="c-38997796">[1 more]</label></div><br/><div class="children"><div class="content">Here, u is presumably utility and t is time</div><br/></div></div></div></div><div id="38989710" class="c"><input type="checkbox" id="c-38989710" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#38989529">parent</a><span>|</span><a href="#38990956">prev</a><span>|</span><a href="#38989734">next</a><span>|</span><label class="collapse" for="c-38989710">[-]</label><label class="expand" for="c-38989710">[1 more]</label></div><br/><div class="children"><div class="content">If you go further back, &quot;programming&quot; describes it precisely, and what we call &quot;programming&quot; today is &quot;writing code&quot; which can be subdivided into different kinds of &quot;programming&quot; such as functional, declarative, procedural, etc. But there&#x27;s a lot more that fits under that umbrella.</div><br/></div></div></div></div><div id="38989734" class="c"><input type="checkbox" id="c-38989734" checked=""/><div class="controls bullet"><span class="by">sethammons</span><span>|</span><a href="#38989529">prev</a><span>|</span><a href="#38996005">next</a><span>|</span><label class="collapse" for="c-38989734">[-]</label><label class="expand" for="c-38989734">[31 more]</label></div><br/><div class="children"><div class="content">Would it be wrong to just think &quot;memoization&quot; when you hear &quot;dynamic programming&quot;? The missing part may be intelligently breaking up the problem to use memoization?</div><br/><div id="38989931" class="c"><input type="checkbox" id="c-38989931" checked=""/><div class="controls bullet"><span class="by">jltsiren</span><span>|</span><a href="#38989734">parent</a><span>|</span><a href="#38989898">next</a><span>|</span><label class="collapse" for="c-38989931">[-]</label><label class="expand" for="c-38989931">[9 more]</label></div><br/><div class="children"><div class="content">Memoization is a more general technique. It&#x27;s often little more than caching the results you happened to compute, in case you need them again in the future.<p>Dynamic programming is systematic memoization. You solve subproblems of increasing size, until you reach a solution to the full problem. &quot;Inductive algorithm&quot; would be kind of appropriate term, as the typical dynamic programming algorithm is effectively a proof by induction. Unfortunately that term already has other meanings.</div><br/><div id="38990318" class="c"><input type="checkbox" id="c-38990318" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38989931">parent</a><span>|</span><a href="#38992787">next</a><span>|</span><label class="collapse" for="c-38990318">[-]</label><label class="expand" for="c-38990318">[7 more]</label></div><br/><div class="children"><div class="content">And &quot;dynamic programming&quot; is an insanely general term that leetcode enthusiasts have pigeonholed into meaning memoized reduction. It can describe dynamic dispatch, code morphing&#x2F;rewriting, dynamic loading, etc.<p>I would argue &quot;memoization&quot;, while still a bad term, is far more specific and descriptive of what&#x27;s happening than &quot;dynamic programming&quot;.</div><br/><div id="38991674" class="c"><input type="checkbox" id="c-38991674" checked=""/><div class="controls bullet"><span class="by">greyw</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38990318">parent</a><span>|</span><a href="#38992787">next</a><span>|</span><label class="collapse" for="c-38991674">[-]</label><label class="expand" for="c-38991674">[6 more]</label></div><br/><div class="children"><div class="content">The term &quot;Dynamic programming&quot; comes from mathematics of the 1940s before modern programming languages even existed. It&#x27;s about a certain way to do optimization. This is also how it is used by &quot;leetcode enthusiasts&quot; so imo they are using it correctly.<p>Nowadays, you could naturally confuse dynamic programming with the things you have listed.</div><br/><div id="38991858" class="c"><input type="checkbox" id="c-38991858" checked=""/><div class="controls bullet"><span class="by">nihzm</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38991674">parent</a><span>|</span><a href="#38992418">next</a><span>|</span><label class="collapse" for="c-38991858">[-]</label><label class="expand" for="c-38991858">[1 more]</label></div><br/><div class="children"><div class="content">Exactly! I have already linked it in another thread but see this link below for the mathematical definition of dynamic programming:<p><a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;dimitrib&#x2F;www&#x2F;DP_Slides.pdf" rel="nofollow">https:&#x2F;&#x2F;web.mit.edu&#x2F;dimitrib&#x2F;www&#x2F;DP_Slides.pdf</a></div><br/></div></div><div id="38992418" class="c"><input type="checkbox" id="c-38992418" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38991674">parent</a><span>|</span><a href="#38991858">prev</a><span>|</span><a href="#38992787">next</a><span>|</span><label class="collapse" for="c-38992418">[-]</label><label class="expand" for="c-38992418">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This is also how it is used by &quot;leetcode enthusiasts&quot; so imo they are using it correctly.<p>I never said they used it incorrectly. In fact, inversely, I tacitly acknowledged the fact that it was used <i>correctly</i>. I said they <i>pigeonholed</i> a <i>generalized phrase</i> into a specific use case. E.g. a word&#x2F;phrase that can be used to describe many similar but distinct concepts in the same field, as you yourself acknowledge.<p>If you&#x27;re going to take umbrage with someone&#x27;s words, it&#x27;s better not to misunderstand them or misphrase them.</div><br/><div id="38992847" class="c"><input type="checkbox" id="c-38992847" checked=""/><div class="controls bullet"><span class="by">greyw</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38992418">parent</a><span>|</span><a href="#38992787">next</a><span>|</span><label class="collapse" for="c-38992847">[-]</label><label class="expand" for="c-38992847">[3 more]</label></div><br/><div class="children"><div class="content">Sorry I was not clear enough here. I wanted to just add some historical context.<p>My point is that dynamic programming was not &quot;pigeonholed&quot; because of &quot;leetcode enthusiasts&quot; but rather they are just using the original meaning. Modern programming languages refering to &quot;dynamic&quot; things in various circumstances made the term confusing so you would have to blame modern programming languages rather than &quot;leecode enthusiasts&quot;.</div><br/><div id="38993176" class="c"><input type="checkbox" id="c-38993176" checked=""/><div class="controls bullet"><span class="by">deaddodo</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38992847">parent</a><span>|</span><a href="#38992787">next</a><span>|</span><label class="collapse" for="c-38993176">[-]</label><label class="expand" for="c-38993176">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, <i>I</i> wasn&#x27;t clear enough. The term is perfectly fine, it&#x27;s simply too generalized. So if other&#x27;s want to use other terms to better describe it, I support that; no matter who was first. Otherwise we end up in another &quot;systems programming&quot; situation.<p>My offhanded remark about &quot;leetcode enthusiasts&quot; is about people trying to <i>strongarm&#x2F;gatekeep</i> a, frankly, <i>way too generalized phrase</i> to mean a very specific thing. They can call it that all they want. It&#x27;s a correct phrase for that. Just don&#x27;t get mad when someone else refers to &quot;code morphing&quot; as &quot;dynamic programming&quot;.<p>&gt; Modern programming languages refering to &quot;dynamic&quot; things in various circumstances made the term confusing so you would have to blame modern programming languages rather than &quot;leecode enthusiasts&quot;.<p>Modern programmers and engineers used <i>the word dictated for the functionality by the language they communicate in</i>. You&#x27;re just further reinforcing my point that the phrase is too generalized.<p>Or, to give you an analogy that might finally make it click. It would be like if I called all &quot;string metric&quot; problems &quot;string programming&quot;.</div><br/><div id="38997744" class="c"><input type="checkbox" id="c-38997744" checked=""/><div class="controls bullet"><span class="by">FabHK</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38993176">parent</a><span>|</span><a href="#38992787">next</a><span>|</span><label class="collapse" for="c-38997744">[-]</label><label class="expand" for="c-38997744">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re just wrong when you say 
&gt; &quot;dynamic programming&quot; is an insanely general term<p>It is not. It is a specific technique to solve a number of problems having a certain structure. In the continuous case it leads to the Hamilton-Jacobi-Bellman partial differential equation, in the discrete case it leads to the Bellman equation discussed above. The latter, in turn, gives rise to a specific and efficient algorithm.<p>Code morphing has nothing to do with dynamic programming (even though it might well be programming, and might well be dynamic).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38992787" class="c"><input type="checkbox" id="c-38992787" checked=""/><div class="controls bullet"><span class="by">owlstuffing</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38989931">parent</a><span>|</span><a href="#38990318">prev</a><span>|</span><a href="#38989898">next</a><span>|</span><label class="collapse" for="c-38992787">[-]</label><label class="expand" for="c-38992787">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Dynamic programming is systematic memoization.<p>Exactly! This should have been clarified in the op.</div><br/></div></div></div></div><div id="38989898" class="c"><input type="checkbox" id="c-38989898" checked=""/><div class="controls bullet"><span class="by">JohnKemeny</span><span>|</span><a href="#38989734">parent</a><span>|</span><a href="#38989931">prev</a><span>|</span><a href="#38989981">next</a><span>|</span><label class="collapse" for="c-38989898">[-]</label><label class="expand" for="c-38989898">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly how I teach dynamic programming. First solve it recursively, then add memoization (I call that top-down).<p>Then notice that recursion and memoization has some overhead, and construct the table from bottom-up, remove the recursive call, and voila, dynamic programming.</div><br/><div id="38997147" class="c"><input type="checkbox" id="c-38997147" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38989898">parent</a><span>|</span><a href="#38989981">next</a><span>|</span><label class="collapse" for="c-38997147">[-]</label><label class="expand" for="c-38997147">[1 more]</label></div><br/><div class="children"><div class="content">This sounds like a promising teaching technique.  Do you have a slide deck to share?  I am sure HN crowd would be interested to read.</div><br/></div></div></div></div><div id="38989981" class="c"><input type="checkbox" id="c-38989981" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38989734">parent</a><span>|</span><a href="#38989898">prev</a><span>|</span><a href="#38990842">next</a><span>|</span><label class="collapse" for="c-38989981">[-]</label><label class="expand" for="c-38989981">[10 more]</label></div><br/><div class="children"><div class="content">There are dynamic programming solutions not based on memoization.  See for example finding the longest common substring between two strings.  Memoization will not help as much because you only need the table&#x27;s left and up cells once.<p>In general, if the problem&#x27;s sub-problems have a lot of overlap and the optimal subproblem must be part of the optimal overall solution, you&#x27;ve got an opportunity for dynamic programming.  Saying memoization is the only kind of dynamic programming is like saying hash tables are the only abstract data type.</div><br/><div id="38992160" class="c"><input type="checkbox" id="c-38992160" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38989981">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38992160">[-]</label><label class="expand" for="c-38992160">[8 more]</label></div><br/><div class="children"><div class="content">The left of the up is the up of the left.</div><br/><div id="38992478" class="c"><input type="checkbox" id="c-38992478" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38992160">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38992478">[-]</label><label class="expand" for="c-38992478">[7 more]</label></div><br/><div class="children"><div class="content">Yeah, I had a momentary misgiving when I hit send and thought (_well, the cell <i>is</i> used twice_) but in practice it is still very different than what would be considered memoization.  You can make it work with just two rows at a time, forgetting all the calculated values of the earlier rows.  You can also do it in one row if you work backwards in each row.  If anything, it&#x27;s a cache with a very specific eviction policy.<p>I had a whole other paragraph where I nearly convinced myself it&#x27;s the same here for LCS so I&#x27;m just going to stop myself here.  If you look up any texts that describe LCS they don&#x27;t refer to it as using memoization.  Let&#x27;s not confuse things.</div><br/><div id="38995048" class="c"><input type="checkbox" id="c-38995048" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38992478">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38995048">[-]</label><label class="expand" for="c-38995048">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>If you look up any texts that describe LCS they don&#x27;t refer to it as using memoization.</i><p>I challenge that actually, several resources online consider it memoization (I would too): <a href="https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;longest-common-subsequence-dp-using-memoization&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;longest-common-subsequence-dp-...</a></div><br/><div id="38995278" class="c"><input type="checkbox" id="c-38995278" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38995048">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38995278">[-]</label><label class="expand" for="c-38995278">[5 more]</label></div><br/><div class="children"><div class="content">I had in mind a Data Structures and Algorithms text like what is used to teach comp sci courses with.  But I&#x27;m not here to denigrate the credibility of Geeks for Geeks.  If we&#x27;re going to cite arbitrary web sites as sources, let&#x27;s refer to Wikipedia&#x27;s definition:<p>&quot;&quot;&quot;
An optimization technique used primarily to speed up computer programs by storing the results of expensive function calls to pure functions and returning the cached result when the same inputs occur again.
&quot;&quot;&quot;<p>In LCS you are not saving the result of calling a substring method for (str1, str2, i, j) or any similar recursive method.  You&#x27;re keeping a constant-sized association of index pairs and their accumulated score.<p>If we&#x27;re getting technical, I would say that what LCS uses is referred to as tabulation.</div><br/><div id="38995450" class="c"><input type="checkbox" id="c-38995450" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38995278">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38995450">[-]</label><label class="expand" for="c-38995450">[4 more]</label></div><br/><div class="children"><div class="content">It is though, it&#x27;s just a matter of perspective. The recursive method would look like this:<p><pre><code>    str1 = ...
    str2 = ...
    def lcs(i, j):
      if i &lt;= 0 or j &lt;= 0:
        return 0
      res = max(score(i-1, j), score(i, j-1))
      if (str1[i] == str2[j]):
        res = max(res, score(i-1, j-1) + 1)
      return res
</code></pre>
Now if you memoize this and make it iterative, you end up with your DP solution.</div><br/><div id="38995558" class="c"><input type="checkbox" id="c-38995558" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38995450">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38995558">[-]</label><label class="expand" for="c-38995558">[3 more]</label></div><br/><div class="children"><div class="content">Except you&#x27;ve reformulated LCS as a top-down function in order to be convenient for your argument.  The implementation is bottom-up not top-down.</div><br/><div id="38995708" class="c"><input type="checkbox" id="c-38995708" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38995558">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38995708">[-]</label><label class="expand" for="c-38995708">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what DP is, every DP formulation of a recursive function is bottom up vs. top down (eg. think of the steps you need to do to get from recursive Fibonacci to DP, or knapsack). LCS is not special in that regard</div><br/><div id="38996459" class="c"><input type="checkbox" id="c-38996459" checked=""/><div class="controls bullet"><span class="by">kevindamm</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38995708">parent</a><span>|</span><a href="#38990381">next</a><span>|</span><label class="collapse" for="c-38996459">[-]</label><label class="expand" for="c-38996459">[1 more]</label></div><br/><div class="children"><div class="content">My point is that the naive approach to the problem doesn&#x27;t even need to use recursion, nor does the final solution, even if the path towards reasoning about the complexity calls on recursion.  I prefer a narrower scope in definition for memoization, but I accept that there are many who would prefer the broader definition.  I think perhaps there is even a grey area around the term, and cache, and working memory, and more.  Is it no longer memoising if you&#x27;re using it to build an index table?  Is a cache implementation of an @memoize function decorator still memoising?  IDK, it&#x27;s not my intention to split hairs here.<p>For what it&#x27;s worth, I reread the 1975 paper about the linear-space version of LCS, they do not mention memoization, even though recursion is used in both the algorithm pseudocode and in the complexity analysis.  The term memoisation was coined in 1968.<p><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;360825.360861" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;360825.360861</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38990842" class="c"><input type="checkbox" id="c-38990842" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#38989734">parent</a><span>|</span><a href="#38989981">prev</a><span>|</span><a href="#38989838">next</a><span>|</span><label class="collapse" for="c-38990842">[-]</label><label class="expand" for="c-38990842">[6 more]</label></div><br/><div class="children"><div class="content">To my approach to dynamic programming, memoization is step 2 of 3.<p>1- find a recursive algorithm<p>2- memoization<p>3- make it iterative &#x2F; bottom-up<p>3b- if possible, optimize for space<p>Step 3 is the most characteristic part of dynamic programming, but if you stopped at step 2, it would still qualify, I think, but it would not be as efficient as it could be.<p>Another way to think of step 3 would be: memoization is about caching, is there a way to pre-fill the cache?</div><br/><div id="38991170" class="c"><input type="checkbox" id="c-38991170" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38990842">parent</a><span>|</span><a href="#38991065">next</a><span>|</span><label class="collapse" for="c-38991170">[-]</label><label class="expand" for="c-38991170">[4 more]</label></div><br/><div class="children"><div class="content">This makes it clear why dynamic programming is not easy. The problem occurs already in step 1 -- we naturally tend to think in loops, not recursions. So before you find a recursive algorithm, you probably come up with a loop algorithm first. Then you have to try to convert the loop into recursion, then go back to loops that use caching. And hope that the result is more efficient than the loop algorithm you started with.</div><br/><div id="38992005" class="c"><input type="checkbox" id="c-38992005" checked=""/><div class="controls bullet"><span class="by">WJW</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38991170">parent</a><span>|</span><a href="#38995933">next</a><span>|</span><label class="collapse" for="c-38992005">[-]</label><label class="expand" for="c-38992005">[2 more]</label></div><br/><div class="children"><div class="content">Speak for yourself, there are dozens (dozens!) of us for which recursion is the more natural way to think about most algorithms. Joking aside, DP is very straightforward in more functional languages like Haskell where recursion is the default way to do iteration anyway.</div><br/><div id="38993287" class="c"><input type="checkbox" id="c-38993287" checked=""/><div class="controls bullet"><span class="by">cubefox</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38992005">parent</a><span>|</span><a href="#38995933">next</a><span>|</span><label class="collapse" for="c-38993287">[-]</label><label class="expand" for="c-38993287">[1 more]</label></div><br/><div class="children"><div class="content">And I think people don&#x27;t like functional programming languages because they don&#x27;t like recursion. Even cookbooks use loops!</div><br/></div></div></div></div><div id="38995933" class="c"><input type="checkbox" id="c-38995933" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38991170">parent</a><span>|</span><a href="#38992005">prev</a><span>|</span><a href="#38991065">next</a><span>|</span><label class="collapse" for="c-38995933">[-]</label><label class="expand" for="c-38995933">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, to me, step 1 is the hardest. Not only you need a recursive algorithm, but you also need an algorithm where memoization is possible.<p>Step 2 and 3 are more systematic. That is, if you understand the Fibonacci sequence example in the article, you can probably do all of the problems. It still requires training, especially if you are doing competitive programming, but it is always essentially the same thing.<p>Finding the algorithm is the tricky part as there is no set formula.<p>That&#x27;s why the Fibonacci sequence is a good introduction. You know where you are starting from: part 1 is trivial as the formula is given to you. And you know where you are going, as you probably already have a good idea on how you are going to implement it iteratively. So you won&#x27;t get lost in the problem solving part, which may be hard and requires a lot of attention, instead focusing on the basic technique. Once well understood, it is time to solve the actual problems, where step 1 is not trivial and where intuition is not enough for finding the final solution.</div><br/></div></div></div></div><div id="38991065" class="c"><input type="checkbox" id="c-38991065" checked=""/><div class="controls bullet"><span class="by">naet</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38990842">parent</a><span>|</span><a href="#38991170">prev</a><span>|</span><a href="#38989838">next</a><span>|</span><label class="collapse" for="c-38991065">[-]</label><label class="expand" for="c-38991065">[1 more]</label></div><br/><div class="children"><div class="content">Where I have the most trouble is usually going from recursive to iterative.  It&#x27;s pretty easy for me to understand the recursive + memoization, but when that ends up being taken off the table due to various inefficiencies of recursion I often get a little stuck.</div><br/></div></div></div></div><div id="38989838" class="c"><input type="checkbox" id="c-38989838" checked=""/><div class="controls bullet"><span class="by">ecshafer</span><span>|</span><a href="#38989734">parent</a><span>|</span><a href="#38990842">prev</a><span>|</span><a href="#38996005">next</a><span>|</span><label class="collapse" for="c-38989838">[-]</label><label class="expand" for="c-38989838">[3 more]</label></div><br/><div class="children"><div class="content">Yes it would be wrong in my  book. First i think a  obvious counter example of memoization can be used outside of dynamic programing. Otherwise you can do most dynamic programming algorithms with storing the results in a table, and searching the table afterwards for the best answer. Memoization is basically a strategy to speed up algorithms.</div><br/><div id="38989874" class="c"><input type="checkbox" id="c-38989874" checked=""/><div class="controls bullet"><span class="by">sk11001</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38989838">parent</a><span>|</span><a href="#38996005">next</a><span>|</span><label class="collapse" for="c-38989874">[-]</label><label class="expand" for="c-38989874">[2 more]</label></div><br/><div class="children"><div class="content">&gt; First i think a obvious counter example of memoization can be used outside of dynamic programing<p>This isn&#x27;t relevant, the quesion is whether there are dynamic programming solutions which do not involve memoization.</div><br/><div id="38990208" class="c"><input type="checkbox" id="c-38990208" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#38989734">root</a><span>|</span><a href="#38989874">parent</a><span>|</span><a href="#38996005">next</a><span>|</span><label class="collapse" for="c-38990208">[-]</label><label class="expand" for="c-38990208">[1 more]</label></div><br/><div class="children"><div class="content">Well, dynamic programming also tells you when you can drop your &#x27;memoization&#x27; caches.</div><br/></div></div></div></div></div></div></div></div><div id="38996005" class="c"><input type="checkbox" id="c-38996005" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38989734">prev</a><span>|</span><a href="#38989515">next</a><span>|</span><label class="collapse" for="c-38996005">[-]</label><label class="expand" for="c-38996005">[1 more]</label></div><br/><div class="children"><div class="content">As a primarily self-taught programmer, when I was first looking for a job, after college if I had been asked on an interview to use dynamic programming I would have had no idea what that was. Thankfully that never happened to me. But I was familiar with the technique, and used it in multiple interviews.</div><br/></div></div><div id="38989515" class="c"><input type="checkbox" id="c-38989515" checked=""/><div class="controls bullet"><span class="by">ctk_25</span><span>|</span><a href="#38996005">prev</a><span>|</span><a href="#38995536">next</a><span>|</span><label class="collapse" for="c-38989515">[-]</label><label class="expand" for="c-38989515">[2 more]</label></div><br/><div class="children"><div class="content">Would recommend DPV Algorithms book and Georgia Techs lectures on udacity for graduate algorithms. The way to master dynamic programming is - practice practice practice solving problems…</div><br/><div id="38993964" class="c"><input type="checkbox" id="c-38993964" checked=""/><div class="controls bullet"><span class="by">62951413</span><span>|</span><a href="#38989515">parent</a><span>|</span><a href="#38995536">next</a><span>|</span><label class="collapse" for="c-38993964">[-]</label><label class="expand" for="c-38993964">[1 more]</label></div><br/><div class="children"><div class="content">Consider <a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;Dynamic-Programming-Coding-Interviews-Bottom-Up&#x2F;dp&#x2F;1946556696" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;Dynamic-Programming-Coding-Interviews...</a> for the most pedagogical approach I have seen.</div><br/></div></div></div></div><div id="38995536" class="c"><input type="checkbox" id="c-38995536" checked=""/><div class="controls bullet"><span class="by">tnecniv</span><span>|</span><a href="#38989515">prev</a><span>|</span><a href="#38995740">next</a><span>|</span><label class="collapse" for="c-38995536">[-]</label><label class="expand" for="c-38995536">[1 more]</label></div><br/><div class="children"><div class="content">I think that CS classes also teach it really poorly. I did not understand it at all until I took an optimal control class and it instantly made sense</div><br/></div></div><div id="38995740" class="c"><input type="checkbox" id="c-38995740" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#38995536">prev</a><span>|</span><a href="#38991277">next</a><span>|</span><label class="collapse" for="c-38995740">[-]</label><label class="expand" for="c-38995740">[1 more]</label></div><br/><div class="children"><div class="content">Dynamic programming is not a black magic, _proving it can be dynamically programmed and their correctness_ is. You need to use mathematical induction to formally proof  it just like with greedy algorithms which are very counterintuitive (take for example, greedy coloring) when I learned them both in uni.</div><br/></div></div><div id="38991277" class="c"><input type="checkbox" id="c-38991277" checked=""/><div class="controls bullet"><span class="by">rav</span><span>|</span><a href="#38995740">prev</a><span>|</span><a href="#38995491">next</a><span>|</span><label class="collapse" for="c-38991277">[-]</label><label class="expand" for="c-38991277">[7 more]</label></div><br/><div class="children"><div class="content">&gt; And many common algorithms are actually just the application of dynamic programming to specific problems, including omnipresent path-finding algorithms such as Dijkstra’s algorithm.<p>Dijkstra&#x27;s algorithm is an application of dynamic programming? I disagree. In dynamic programming, you tabulate the subproblems to solve, with static interdependencies between them leading to straightforward orders in which to solve the subproblems. In Dijkstra&#x27;s algorithm, you need to compute the shortest path from s to each vertex, but the order in which you have to visit the vertices is only discovered along the way using a priority queue, so the subproblem interdependencies are not known ahead of time until you have actually solved the problem.</div><br/><div id="38991916" class="c"><input type="checkbox" id="c-38991916" checked=""/><div class="controls bullet"><span class="by">vladimirralev</span><span>|</span><a href="#38991277">parent</a><span>|</span><a href="#38991744">next</a><span>|</span><label class="collapse" for="c-38991916">[-]</label><label class="expand" for="c-38991916">[2 more]</label></div><br/><div class="children"><div class="content">Dijkstra is definitely dynamic programming, no doubt about it, you are still computing a new state from neighbouring state nodes while ignoring substantial number of non-neighbouring states.<p>You just have to accept the more abstract definition of &quot;state&quot; where the state encodes subsets of the graph. The states in Dijkstra are represented by subgraphs and distances that incrementally include more nodes leaving us with a path of states to follow in some order.<p>It&#x27;s not much different from the traveling salesman or viterbi in that sense. You come up with some topological order of states in abstract state-space and then follow that topological order to compute the new state based on the adjacent previously computed states and never look back to update already finalised states.<p>With this more abstract point of view, it&#x27;s clear Dijsktra is dynamic programming.<p>There is a whole field of graph dynamic programming problems. And the closely related Markov chain problems.</div><br/><div id="38994825" class="c"><input type="checkbox" id="c-38994825" checked=""/><div class="controls bullet"><span class="by">rav</span><span>|</span><a href="#38991277">root</a><span>|</span><a href="#38991916">parent</a><span>|</span><a href="#38991744">next</a><span>|</span><label class="collapse" for="c-38994825">[-]</label><label class="expand" for="c-38994825">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You come up with some topological order of states in abstract state-space<p>If the state space is &quot;subsets of V&quot;, then it&#x27;s exponentially larger than the set of states actually visited in Dijkstra&#x27;s algorithm. Dijkstra&#x27;s algorithm has an invariant that the vertices visited have a smaller distance than the vertices not visited. For vertex sets that adhere to this invariant, there&#x27;s clearly a topological order, but for arbitrary subsets of V I don&#x27;t see how this topological order would be defined.<p>I guess my gripe is that in my view, the framework of dynamic programming is not a useful way to analyze algorithms that explore a small set of states in an exponentially larger state space.</div><br/></div></div></div></div><div id="38991744" class="c"><input type="checkbox" id="c-38991744" checked=""/><div class="controls bullet"><span class="by">nihzm</span><span>|</span><a href="#38991277">parent</a><span>|</span><a href="#38991916">prev</a><span>|</span><a href="#38991319">next</a><span>|</span><label class="collapse" for="c-38991744">[-]</label><label class="expand" for="c-38991744">[1 more]</label></div><br/><div class="children"><div class="content">Not quite, actually Dijkstra is a special case of what are called label correcting methods &#x2F; algorithms (LCA) [1], which come directly from applying dynamic programming to the shortest path problem. LCA apply to all finite graphs with non-negative cycles and to be specific Dijkstra&#x27;s algorithm is a LCA where in step one the node to be removed is choosen according to min_{i \in OPEN} d_i, see [1] for more.<p>[1]: <a href="https:&#x2F;&#x2F;web.mit.edu&#x2F;dimitrib&#x2F;www&#x2F;DP_Slides.pdf" rel="nofollow">https:&#x2F;&#x2F;web.mit.edu&#x2F;dimitrib&#x2F;www&#x2F;DP_Slides.pdf</a> (see lecture 3)</div><br/></div></div><div id="38991319" class="c"><input type="checkbox" id="c-38991319" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38991277">parent</a><span>|</span><a href="#38991744">prev</a><span>|</span><a href="#38995491">next</a><span>|</span><label class="collapse" for="c-38991319">[-]</label><label class="expand" for="c-38991319">[3 more]</label></div><br/><div class="children"><div class="content">I totally agree in that I use the same mental model. But, if you look at it as “the shortest path must be the shortest path through one of its neighbors”, it can actually be classified as a dynamic programming algorithm!<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm#Dynamic_programming_perspective" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm#Dynamic...</a></div><br/><div id="38991560" class="c"><input type="checkbox" id="c-38991560" checked=""/><div class="controls bullet"><span class="by">rav</span><span>|</span><a href="#38991277">root</a><span>|</span><a href="#38991319">parent</a><span>|</span><a href="#38995491">next</a><span>|</span><label class="collapse" for="c-38991560">[-]</label><label class="expand" for="c-38991560">[2 more]</label></div><br/><div class="children"><div class="content">In dynamic programming, the problem can be solved by solving subproblems, and those subproblems are solved by solving subsubproblems, and there is overlap between these subproblems. This allows us to solve DP problems in two ways, either by recursion with memoization or by iterative table filling.<p>Although the shortest path problem has some kind of &quot;optimal substructure&quot;, the recursive memoized approach doesn&#x27;t work because there&#x27;s no set order in which the subproblems can be solved. Instead, you need to compute the shortest paths in order of shortest path length, and the shortest path lengths aren&#x27;t given ahead of time - those are exactly what Dijkstra&#x27;s algorithm computes!<p>It&#x27;s not enough to call it dynamic programming that &quot;the shortest path must be the shortest path through one of its neighbors&quot;, because this fact doesn&#x27;t immediately lead to an acyclic subproblem dependency graph.<p>Shortest path on an acyclic graph, and longest path on an acyclic graph, are two problems that can be solved with dynamic programming - but Dijkstra&#x27;s algorithms solves shortest paths on a different class of graphs that doesn&#x27;t lend itself to DP.</div><br/><div id="38992024" class="c"><input type="checkbox" id="c-38992024" checked=""/><div class="controls bullet"><span class="by">kj4211cash</span><span>|</span><a href="#38991277">root</a><span>|</span><a href="#38991560">parent</a><span>|</span><a href="#38995491">next</a><span>|</span><label class="collapse" for="c-38992024">[-]</label><label class="expand" for="c-38992024">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a bit lost in this terminology.  But coming from the Operations Research perspective that gave Dynamic Programming its name, Dijkstra&#x27;s Algorithm is very clearly Dynamic Programming.  It&#x27;s Forward Dynamic Programming as opposed to the much more common Backward Dynamic Programming, if that helps any.</div><br/></div></div></div></div></div></div></div></div><div id="38995491" class="c"><input type="checkbox" id="c-38995491" checked=""/><div class="controls bullet"><span class="by">thefaux</span><span>|</span><a href="#38991277">prev</a><span>|</span><a href="#38992147">next</a><span>|</span><label class="collapse" for="c-38995491">[-]</label><label class="expand" for="c-38995491">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why you would use memoization for fibonacci ever and hence its relevance for dynamic programming. It can be solved with a tail recursive function with three input parameters. Solution left to the reader as an exercise.</div><br/><div id="38998287" class="c"><input type="checkbox" id="c-38998287" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38995491">parent</a><span>|</span><a href="#38995556">next</a><span>|</span><label class="collapse" for="c-38998287">[-]</label><label class="expand" for="c-38998287">[1 more]</label></div><br/><div class="children"><div class="content">But how to you systematically deduce the tail recursion version?<p>I feel like, in this case, the recursivity in definition of Fibonacci and the recursivity in the tail recursion is just a coincidence, with the second just being a contrived way to write the loop you get after applying dynamic programming and trimming the table to only the last two elements.</div><br/></div></div><div id="38995556" class="c"><input type="checkbox" id="c-38995556" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#38995491">parent</a><span>|</span><a href="#38998287">prev</a><span>|</span><a href="#38996512">next</a><span>|</span><label class="collapse" for="c-38995556">[-]</label><label class="expand" for="c-38995556">[1 more]</label></div><br/><div class="children"><div class="content">Memoization generalizes much better than accumulator parameters.</div><br/></div></div><div id="38995505" class="c"><input type="checkbox" id="c-38995505" checked=""/><div class="controls bullet"><span class="by">TotoHorner</span><span>|</span><a href="#38995491">parent</a><span>|</span><a href="#38996512">prev</a><span>|</span><a href="#38992147">next</a><span>|</span><label class="collapse" for="c-38995505">[-]</label><label class="expand" for="c-38995505">[1 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s a good example to teach dynamic programming?</div><br/></div></div></div></div><div id="38992147" class="c"><input type="checkbox" id="c-38992147" checked=""/><div class="controls bullet"><span class="by">hxypqr</span><span>|</span><a href="#38995491">prev</a><span>|</span><a href="#38991651">next</a><span>|</span><label class="collapse" for="c-38992147">[-]</label><label class="expand" for="c-38992147">[1 more]</label></div><br/><div class="children"><div class="content">Most of Dynamic programming is just a method of reducing computational complexity by changing the noun objects in first-order logic (or second-order logic, advanced version) to walk through the answers of unfinished tasks using completed tasks. Only in very few cases is it necessary to extract and match the completed parts from the unfinished objects in the above process, which often involves optimizing a function f(A,B). However, most of the time, this process is futile.</div><br/></div></div><div id="38991651" class="c"><input type="checkbox" id="c-38991651" checked=""/><div class="controls bullet"><span class="by">charlieyu1</span><span>|</span><a href="#38992147">prev</a><span>|</span><a href="#38997675">next</a><span>|</span><label class="collapse" for="c-38991651">[-]</label><label class="expand" for="c-38991651">[7 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t find DP that difficult to be called Black Magic. Tree algorithms on the other hand, is much harder</div><br/><div id="38991940" class="c"><input type="checkbox" id="c-38991940" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38991651">parent</a><span>|</span><a href="#38997675">next</a><span>|</span><label class="collapse" for="c-38991940">[-]</label><label class="expand" for="c-38991940">[6 more]</label></div><br/><div class="children"><div class="content">Do you mean tree rebalancing algorithms? I have to agree with this. AVL tree insertion is fine enough, but it gets hairy when you get to deletion. And Red-Black trees…</div><br/><div id="38996483" class="c"><input type="checkbox" id="c-38996483" checked=""/><div class="controls bullet"><span class="by">peterfirefly</span><span>|</span><a href="#38991651">root</a><span>|</span><a href="#38991940">parent</a><span>|</span><a href="#38992046">next</a><span>|</span><label class="collapse" for="c-38996483">[-]</label><label class="expand" for="c-38996483">[1 more]</label></div><br/><div class="children"><div class="content">Once you relax the invariants a bit, it becomes much easier to delete from your reddish-blackish trees :)<p>If you don&#x27;t have to implement deletion, things are already a lot easier.  And if you decide to implement a persistent red-black tree then they can be downright easy, even without relaxed invariants.<p>Relaxed invariants:<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;AA_tree" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;AA_tree</a><p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Left-leaning_red%E2%80%93black_tree" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Left-leaning_red%E2%80%93black...</a><p>---<p>Years ago, I played around with red-black trees and I figured that I could relax the invariants and make the code a lot simpler -- and maybe get slightly worse theoretical performance and quite likely slightly better practical performance for small trees.  I looked around for other people&#x27;s ideas along the same lines and found AA trees, which didn&#x27;t quite please me.  A few years later, Sedgewick&#x27;s left-leaning red-black trees came out.<p>I would probably have found them myself (+ some other related ideas) if I had continued to play around + systematically tried different relaxations.  But I didn&#x27;t, so I didn&#x27;t.</div><br/></div></div><div id="38992046" class="c"><input type="checkbox" id="c-38992046" checked=""/><div class="controls bullet"><span class="by">charlieyu1</span><span>|</span><a href="#38991651">root</a><span>|</span><a href="#38991940">parent</a><span>|</span><a href="#38996483">prev</a><span>|</span><a href="#38997675">next</a><span>|</span><label class="collapse" for="c-38992046">[-]</label><label class="expand" for="c-38992046">[4 more]</label></div><br/><div class="children"><div class="content">There are more than that, even finding diameter of a tree is pretty nasty</div><br/><div id="38995188" class="c"><input type="checkbox" id="c-38995188" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#38991651">root</a><span>|</span><a href="#38992046">parent</a><span>|</span><a href="#38992079">next</a><span>|</span><label class="collapse" for="c-38995188">[-]</label><label class="expand" for="c-38995188">[1 more]</label></div><br/><div class="children"><div class="content">Only nasty to find diameter of general graphs, right? If you know you have a tree, just root it at a random vertex and recursively compute `max(largest diameter of children, sum of the two biggest heights of children)`</div><br/></div></div><div id="38992079" class="c"><input type="checkbox" id="c-38992079" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38991651">root</a><span>|</span><a href="#38992046">parent</a><span>|</span><a href="#38995188">prev</a><span>|</span><a href="#38997675">next</a><span>|</span><label class="collapse" for="c-38992079">[-]</label><label class="expand" for="c-38992079">[2 more]</label></div><br/><div class="children"><div class="content">Ah yes, but I use Rust, I cannot go back up a tree (-:</div><br/><div id="38992801" class="c"><input type="checkbox" id="c-38992801" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#38991651">root</a><span>|</span><a href="#38992079">parent</a><span>|</span><a href="#38997675">next</a><span>|</span><label class="collapse" for="c-38992801">[-]</label><label class="expand" for="c-38992801">[1 more]</label></div><br/><div class="children"><div class="content">No graphs either :(</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38997675" class="c"><input type="checkbox" id="c-38997675" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38991651">prev</a><span>|</span><a href="#38992333">next</a><span>|</span><label class="collapse" for="c-38997675">[-]</label><label class="expand" for="c-38997675">[1 more]</label></div><br/><div class="children"><div class="content">memoize is not &quot;terrible academic vernacular&quot;</div><br/></div></div><div id="38992333" class="c"><input type="checkbox" id="c-38992333" checked=""/><div class="controls bullet"><span class="by">Futurebot</span><span>|</span><a href="#38997675">prev</a><span>|</span><a href="#38990067">next</a><span>|</span><label class="collapse" for="c-38992333">[-]</label><label class="expand" for="c-38992333">[1 more]</label></div><br/><div class="children"><div class="content">I like the short forumlation to explain it: &quot;Dynamic Programming is approximately recursion + memoization + guessing&quot;</div><br/></div></div><div id="38990067" class="c"><input type="checkbox" id="c-38990067" checked=""/><div class="controls bullet"><span class="by">ris58h</span><span>|</span><a href="#38992333">prev</a><span>|</span><a href="#38990246">next</a><span>|</span><label class="collapse" for="c-38990067">[-]</label><label class="expand" for="c-38990067">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Dynamic Programming is not Black Magic<p>But who said otherwise?</div><br/><div id="38990339" class="c"><input type="checkbox" id="c-38990339" checked=""/><div class="controls bullet"><span class="by">mikhailfranco</span><span>|</span><a href="#38990067">parent</a><span>|</span><a href="#38990246">next</a><span>|</span><label class="collapse" for="c-38990339">[-]</label><label class="expand" for="c-38990339">[1 more]</label></div><br/><div class="children"><div class="content">The No True Scots Straw Man?</div><br/></div></div></div></div><div id="38990246" class="c"><input type="checkbox" id="c-38990246" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#38990067">prev</a><span>|</span><a href="#38996713">next</a><span>|</span><label class="collapse" for="c-38990246">[-]</label><label class="expand" for="c-38990246">[1 more]</label></div><br/><div class="children"><div class="content">If you are seeking black magic, dynamic optimality might be more your speed.</div><br/></div></div><div id="38996713" class="c"><input type="checkbox" id="c-38996713" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#38990246">prev</a><span>|</span><a href="#38992423">next</a><span>|</span><label class="collapse" for="c-38996713">[-]</label><label class="expand" for="c-38996713">[1 more]</label></div><br/><div class="children"><div class="content">Emacs&#x27;s infamous &quot;Ultra-hot screen management package&quot; with its &quot;Skull and Crossbones&quot; warning was definitely black magic:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33450034">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33450034</a><p>&gt;James Gosling&#x27;s Emacs screen redisplay algorithm also used similar &quot;dynamic programming techniques&quot; to compute the minimal cost path through a cost matrix of string edit operations (the costs depended i.e. on the number of characters to draw, length of the escape codes to insert&#x2F;delete lines&#x2F;characters, padding for slow terminals, etc).<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gosling_Emacs" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Gosling_Emacs</a><p>A redisplay algorithm, by James Gosling (ACM SIGPLAN Notices, April 1981):<p><a href="https:&#x2F;&#x2F;donhopkins.com&#x2F;home&#x2F;documents&#x2F;EmacsRedisplayAlgorithm.pdf" rel="nofollow">https:&#x2F;&#x2F;donhopkins.com&#x2F;home&#x2F;documents&#x2F;EmacsRedisplayAlgorith...</a><p><a href="https:&#x2F;&#x2F;donhopkins.com&#x2F;home&#x2F;archive&#x2F;emacs&#x2F;mw&#x2F;display.c" rel="nofollow">https:&#x2F;&#x2F;donhopkins.com&#x2F;home&#x2F;archive&#x2F;emacs&#x2F;mw&#x2F;display.c</a><p><a href="https:&#x2F;&#x2F;donhopkins.com&#x2F;home&#x2F;archive&#x2F;emacs&#x2F;skull-and-crossbones.txt" rel="nofollow">https:&#x2F;&#x2F;donhopkins.com&#x2F;home&#x2F;archive&#x2F;emacs&#x2F;skull-and-crossbon...</a><p><pre><code>                         &#x2F;-------------\ 
                        &#x2F;               \ 
                       &#x2F;                 \ 
                      &#x2F;                   \ 
                      |   XXXX     XXXX   | 
                      |   XXXX     XXXX   | 
                      |   XXX       XXX   | 
                      \         X         &#x2F; 
                       --\     XXX     &#x2F;-- 
                        | |    XXX    | | 
                        | |           | | 
                        | I I I I I I I | 
                        |  I I I I I I  | 
                         \             &#x2F; 
                          --         -- 
                            \-------&#x2F; 
                    XXX                    XXX 
                   XXXXX                  XXXXX 
                   XXXXXXXXX         XXXXXXXXXX 
                          XXXXX   XXXXX 
                             XXXXXXX 
                          XXXXX   XXXXX 
                   XXXXXXXXX         XXXXXXXXXX 
                   XXXXX                  XXXXX 
                    XXX                    XXX 

                          ************** 
                          *  BEWARE!!  * 
                          ************** 

                        All ye who enter here: 
                    Most of the code in this module 
                       is twisted beyond belief! 

                           Tread carefully. 

                    If you think you understand it, 
                              You Don&#x27;t, 
                            So Look Again.</code></pre></div><br/></div></div><div id="38992423" class="c"><input type="checkbox" id="c-38992423" checked=""/><div class="controls bullet"><span class="by">coolThingsFirst</span><span>|</span><a href="#38996713">prev</a><span>|</span><a href="#38990044">next</a><span>|</span><label class="collapse" for="c-38992423">[-]</label><label class="expand" for="c-38992423">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s black magic bcs ppl don&#x27;t want to admit they don&#x27;t understand recursion lol. Fibonacci has always been a bad example to teach recursion. That and towers of hanoi are the greatest failure in teaching CS</div><br/></div></div><div id="38990044" class="c"><input type="checkbox" id="c-38990044" checked=""/><div class="controls bullet"><span class="by">hit8run</span><span>|</span><a href="#38992423">prev</a><span>|</span><a href="#38992217">next</a><span>|</span><label class="collapse" for="c-38990044">[-]</label><label class="expand" for="c-38990044">[1 more]</label></div><br/><div class="children"><div class="content">Cannot establish database connection… It probably is…</div><br/></div></div><div id="38992217" class="c"><input type="checkbox" id="c-38992217" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#38990044">prev</a><span>|</span><a href="#38995216">next</a><span>|</span><label class="collapse" for="c-38992217">[-]</label><label class="expand" for="c-38992217">[2 more]</label></div><br/><div class="children"><div class="content">&gt; “Bootstrap” is an imaged expression to point to the absurdity and impossibility of a task<p>This is an archaic definition that I didn’t know, and it’s fairly interesting. At the bottom of the opening section on the history of “bootstrap” is this comment:<p>“Critics have observed that the phrase is used to portray unfair situations as far more meritocratic than they really are.[8][9][7] A 2009 study found that 77% of Americans believe that wealth is often the result of hard work.[10] Various studies have found that the main predictor of future wealth is not IQ or hard work, but initial wealth.[7][11]”<p>Interesting (to me, anyway) because it used “meritocratic” which itself is a word that was coined with a somewhat different meaning than it has today. Meritocracy was originally used to point out that merit itself is an outcome of social advantages, not inherent skill.<p><a href="https:&#x2F;&#x2F;reagle.org&#x2F;joseph&#x2F;pelican&#x2F;social&#x2F;the-surprising-socialist-origins-of-meritocracy.html" rel="nofollow">https:&#x2F;&#x2F;reagle.org&#x2F;joseph&#x2F;pelican&#x2F;social&#x2F;the-surprising-soci...</a></div><br/><div id="38993182" class="c"><input type="checkbox" id="c-38993182" checked=""/><div class="controls bullet"><span class="by">wibblewobble125</span><span>|</span><a href="#38992217">parent</a><span>|</span><a href="#38995216">next</a><span>|</span><label class="collapse" for="c-38993182">[-]</label><label class="expand" for="c-38993182">[1 more]</label></div><br/><div class="children"><div class="content">Amusingly, merit’s other meaning is the verb “to be worthy.”</div><br/></div></div></div></div><div id="38995216" class="c"><input type="checkbox" id="c-38995216" checked=""/><div class="controls bullet"><span class="by">RespectYourself</span><span>|</span><a href="#38992217">prev</a><span>|</span><a href="#38990130">next</a><span>|</span><label class="collapse" for="c-38995216">[-]</label><label class="expand" for="c-38995216">[1 more]</label></div><br/><div class="children"><div class="content">Good rant about BS terminology. He should&#x27;ve included &quot;responsive&quot; Web pages.</div><br/></div></div><div id="38992029" class="c"><input type="checkbox" id="c-38992029" checked=""/><div class="controls bullet"><span class="by">Der_Einzige</span><span>|</span><a href="#38990130">prev</a><span>|</span><label class="collapse" for="c-38992029">[-]</label><label class="expand" for="c-38992029">[4 more]</label></div><br/><div class="children"><div class="content">All problems solved using DP can also be solved using global optimization techniques. A much easier one to implement in an interview than most DP solutions are simple genetic algorithms. Yes, DPs really do solve any silly interview problem and even have several advantages to boot (i.e. partial solutions if stopped before they&#x27;re finished).<p>Anyone interviewing you who won&#x27;t give you a pass for solving the leetcode problem the &quot;wrong way&quot; without strong very strong justifications is a fool who themselves shouldn&#x27;t be working in tech.</div><br/><div id="38992089" class="c"><input type="checkbox" id="c-38992089" checked=""/><div class="controls bullet"><span class="by">qsantos</span><span>|</span><a href="#38992029">parent</a><span>|</span><a href="#38993299">prev</a><span>|</span><a href="#38992430">next</a><span>|</span><label class="collapse" for="c-38992089">[-]</label><label class="expand" for="c-38992089">[1 more]</label></div><br/><div class="children"><div class="content">Did you encounter practical problems where genetic algorithms work well? So far, the only serious usage I did was for CodinGame&#x27;s Mars Lander optimization problem (and it works pretty well there!).</div><br/></div></div><div id="38992430" class="c"><input type="checkbox" id="c-38992430" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#38992029">parent</a><span>|</span><a href="#38992089">prev</a><span>|</span><label class="collapse" for="c-38992430">[-]</label><label class="expand" for="c-38992430">[1 more]</label></div><br/><div class="children"><div class="content">Genetic algorithms are not deterministic, whereas a DP solution is going to be deterministic with very easily calculable bounds on execution time. Comparing the two as you do, in my opinion, shows a fundamental gap in algorithms understanding.</div><br/></div></div></div></div></div></div></div></div></div></body></html>