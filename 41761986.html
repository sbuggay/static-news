<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728291677326" as="style"/><link rel="stylesheet" href="styles.css?v=1728291677326"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.scattered-thoughts.net/writing/smolderingly-fast-btrees/">Fast B-Trees</a> <span class="domain">(<a href="https://www.scattered-thoughts.net">www.scattered-thoughts.net</a>)</span></div><div class="subtext"><span>surprisetalk</span> | <span>20 comments</span></div><br/><div><div id="41762868" class="c"><input type="checkbox" id="c-41762868" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#41763044">next</a><span>|</span><label class="collapse" for="c-41762868">[-]</label><label class="expand" for="c-41762868">[5 more]</label></div><br/><div class="children"><div class="content">To answer a question implied in the article, per-lookup timing with rdtscp hurts the hash more than the btree for the same reason the hash is hurt by the data-depending chaining: rdtscp is an execution barrier which prevents successive lookups from overlapping. rdtsc (no p) isn&#x27;t, and would probably produce quite different timings.<p>That the btree doesn&#x27;t benefit from overlapping adjacent lookup&#x2F;inserts is intereting.<p>I suppose it is because btree access (here) involves data-dependent branches, and so with random access you&#x27;ll get about L mispredicts per lookup in an L-deep tree, so adjacent lookups are separated by at least one mispredict: so adjacent lookup can overlap execution, but the overlapping is useless since everything beyond the next mispredict is useless as it is on the bad path.<p>That&#x27;s probably at least true for the small map regime. For the larger maps, the next iteration is actually very useful, even if on a mispredicted path, because the date accesses are at the right location so it serves to bring in all the nodes for the next iteration. This matters a lot outside of L2. At 5 instructions per comparison and 32-element nodes, however,  there are just so many instructions in the window for 1 lookup it&#x27;s hard to make it to the next iteration.<p>So b-trees benefit a lot from a tight linear seach (e.g. 2 instructions per check, macro-fused to 1 op), or a branch-free linear search, or far better than those for big nodes, a vectorized branch-free search.</div><br/><div id="41762992" class="c"><input type="checkbox" id="c-41762992" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41762868">parent</a><span>|</span><a href="#41763044">next</a><span>|</span><label class="collapse" for="c-41762992">[-]</label><label class="expand" for="c-41762992">[4 more]</label></div><br/><div class="children"><div class="content">&gt; the overlapping is useless since everything beyond the next mispredict is useless as it is on the bad path<p>Is this a consequence of Spectre et al mitigations?</div><br/><div id="41763025" class="c"><input type="checkbox" id="c-41763025" checked=""/><div class="controls bullet"><span class="by">BeeOnRope</span><span>|</span><a href="#41762868">root</a><span>|</span><a href="#41762992">parent</a><span>|</span><a href="#41763044">next</a><span>|</span><label class="collapse" for="c-41763025">[-]</label><label class="expand" for="c-41763025">[3 more]</label></div><br/><div class="children"><div class="content">No, just a consequence of how mispredicts work: all execution after a mispredict is thrown away: though some traces remain in the cache, which can be very important for performance (and also, of course, Spectre).</div><br/><div id="41763080" class="c"><input type="checkbox" id="c-41763080" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#41762868">root</a><span>|</span><a href="#41763025">parent</a><span>|</span><a href="#41763044">next</a><span>|</span><label class="collapse" for="c-41763080">[-]</label><label class="expand" for="c-41763080">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the part I was curious about; whether there would&#x27;ve been a helpful cache impact, if not for modern Spectre prevention.</div><br/><div id="41763454" class="c"><input type="checkbox" id="c-41763454" checked=""/><div class="controls bullet"><span class="by">starspangled</span><span>|</span><a href="#41762868">root</a><span>|</span><a href="#41763080">parent</a><span>|</span><a href="#41763044">next</a><span>|</span><label class="collapse" for="c-41763454">[-]</label><label class="expand" for="c-41763454">[1 more]</label></div><br/><div class="children"><div class="content">Spectre mitigations don&#x27;t change that, some of them do require adding speculation barriers or otherwise turn off branch prediction for cases where unprivileged state can be used to direct mis-predicted privileged branches into gadgets which can create a side-band to privileged data with speculative state.<p>But in general execution (i.e., no privilege domain crossings), this mechanism is not required.<p>Performance effects of executing mispredicted branches (called something like &quot;wrong-path execution&quot; or &quot;mispredicted path ...&quot; in literature) is interesting and it has been studied. I don&#x27;t know what the state of the art is, although I&#x27;ve seen results showing both speedups and slowdowns (as you would expect with any cache &#x2F; BP kind of topic :P).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41763044" class="c"><input type="checkbox" id="c-41763044" checked=""/><div class="controls bullet"><span class="by">aidenn0</span><span>|</span><a href="#41762868">prev</a><span>|</span><a href="#41763814">next</a><span>|</span><label class="collapse" for="c-41763044">[-]</label><label class="expand" for="c-41763044">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s been a while since I last tried things, but I found crit-bit trees[1] to be much faster than b-trees.  Hash array-mapped tries are also good if you don&#x27;t need the things that trees give you (e.g. in-order traversal, get all values in a certain range).<p>1: <a href="https:&#x2F;&#x2F;cr.yp.to&#x2F;critbit.html" rel="nofollow">https:&#x2F;&#x2F;cr.yp.to&#x2F;critbit.html</a></div><br/></div></div><div id="41763814" class="c"><input type="checkbox" id="c-41763814" checked=""/><div class="controls bullet"><span class="by">orlp</span><span>|</span><a href="#41763044">prev</a><span>|</span><a href="#41763807">next</a><span>|</span><label class="collapse" for="c-41763814">[-]</label><label class="expand" for="c-41763814">[1 more]</label></div><br/><div class="children"><div class="content">Why was Rust&#x27;s hashmap only tested with SipHash? It&#x27;s known to be pretty bad for performance.<p>I&#x27;m biased as the author of course, but try adding a benchmark with the Rust hasher + foldhash as well: <a href="https:&#x2F;&#x2F;github.com&#x2F;orlp&#x2F;foldhash">https:&#x2F;&#x2F;github.com&#x2F;orlp&#x2F;foldhash</a>.</div><br/></div></div><div id="41763807" class="c"><input type="checkbox" id="c-41763807" checked=""/><div class="controls bullet"><span class="by">kibo_money</span><span>|</span><a href="#41763814">prev</a><span>|</span><a href="#41763693">next</a><span>|</span><label class="collapse" for="c-41763807">[-]</label><label class="expand" for="c-41763807">[1 more]</label></div><br/><div class="children"><div class="content">Very interesting ! You mentioned the memory usage at the end, BTreeMaps are actually better than HashMaps most of the time, at least for Rust<p>Here&#x27;s a good break down: <a href="https:&#x2F;&#x2F;ntietz.com&#x2F;blog&#x2F;rust-hashmap-overhead&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ntietz.com&#x2F;blog&#x2F;rust-hashmap-overhead&#x2F;</a></div><br/></div></div><div id="41763693" class="c"><input type="checkbox" id="c-41763693" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#41763807">prev</a><span>|</span><a href="#41763105">next</a><span>|</span><label class="collapse" for="c-41763693">[-]</label><label class="expand" for="c-41763693">[1 more]</label></div><br/><div class="children"><div class="content">Adaptive radix tree is pretty good as well, with support for in order listing and range query. It can beat b-tree and come closely behind hashmap.</div><br/></div></div><div id="41763105" class="c"><input type="checkbox" id="c-41763105" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#41763693">prev</a><span>|</span><a href="#41762477">next</a><span>|</span><label class="collapse" for="c-41763105">[-]</label><label class="expand" for="c-41763105">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be curious to see how performance would change from storing b-tree entries in a semi-sorted array, and applying various other optimizations from here:<p><a href="https:&#x2F;&#x2F;en.algorithmica.org&#x2F;hpc&#x2F;data-structures&#x2F;b-tree&#x2F;" rel="nofollow">https:&#x2F;&#x2F;en.algorithmica.org&#x2F;hpc&#x2F;data-structures&#x2F;b-tree&#x2F;</a><p>The aggregate performance improvements Sergey Slotin gets from applying various &quot;tricks&quot; is insane.</div><br/><div id="41763920" class="c"><input type="checkbox" id="c-41763920" checked=""/><div class="controls bullet"><span class="by">rebanevapustus</span><span>|</span><a href="#41763105">parent</a><span>|</span><a href="#41763530">next</a><span>|</span><label class="collapse" for="c-41763920">[-]</label><label class="expand" for="c-41763920">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how it&#x27;s done in the rust stdlib alternative  <a href="https:&#x2F;&#x2F;github.com&#x2F;brurucy&#x2F;indexset">https:&#x2F;&#x2F;github.com&#x2F;brurucy&#x2F;indexset</a><p>Faster reads, slower inserts, but then you get the capability of indexing by position in (almost) O(1). In regular B-Trees this can only happen in O(n).</div><br/></div></div><div id="41763530" class="c"><input type="checkbox" id="c-41763530" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41763105">parent</a><span>|</span><a href="#41763920">prev</a><span>|</span><a href="#41762477">next</a><span>|</span><label class="collapse" for="c-41763530">[-]</label><label class="expand" for="c-41763530">[1 more]</label></div><br/><div class="children"><div class="content">Notably I believe his data structures tend to ignore string keys because it’s less amenable to SIMD. Would be interesting to see if his ideas about layout still show improvements to strings.</div><br/></div></div></div></div><div id="41762477" class="c"><input type="checkbox" id="c-41762477" checked=""/><div class="controls bullet"><span class="by">tekknolagi</span><span>|</span><a href="#41763105">prev</a><span>|</span><a href="#41763006">next</a><span>|</span><label class="collapse" for="c-41762477">[-]</label><label class="expand" for="c-41762477">[4 more]</label></div><br/><div class="children"><div class="content">I thought a lot of b(+)tree advantage was in bigger-than-RAM something or other for large databases and these benchmarks seem relatively small in comparison</div><br/><div id="41762641" class="c"><input type="checkbox" id="c-41762641" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#41762477">parent</a><span>|</span><a href="#41762862">next</a><span>|</span><label class="collapse" for="c-41762641">[-]</label><label class="expand" for="c-41762641">[1 more]</label></div><br/><div class="children"><div class="content">B-Trees are good for in memory data too because they have fairly good cache behavior.</div><br/></div></div><div id="41762862" class="c"><input type="checkbox" id="c-41762862" checked=""/><div class="controls bullet"><span class="by">robertclaus</span><span>|</span><a href="#41762477">parent</a><span>|</span><a href="#41762641">prev</a><span>|</span><a href="#41763006">next</a><span>|</span><label class="collapse" for="c-41762862">[-]</label><label class="expand" for="c-41762862">[2 more]</label></div><br/><div class="children"><div class="content">Ya, I would be curious to see how this performs on out-of-cache data on an SSD and actual hard drive. On the other hand, the findings are definitely still relevant since RAM has gotten fairly cheap and most applications probably fit in it just fine.<p>Regarding databases - Btrees also have a natural sort order, which hash tables don&#x27;t. This means a btree as your main data structure helps with sort, range, or list operations in a way a hash tables can&#x27;t. That being said, even traditional databases obviously still use hash tables extensively (ex. Hash joins).</div><br/><div id="41762882" class="c"><input type="checkbox" id="c-41762882" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41762477">root</a><span>|</span><a href="#41762862">parent</a><span>|</span><a href="#41763006">next</a><span>|</span><label class="collapse" for="c-41762882">[-]</label><label class="expand" for="c-41762882">[1 more]</label></div><br/><div class="children"><div class="content">In Rust thanks to it you can have BTreeSet of BTreeSet-s.</div><br/></div></div></div></div></div></div><div id="41763006" class="c"><input type="checkbox" id="c-41763006" checked=""/><div class="controls bullet"><span class="by">ur-whale</span><span>|</span><a href="#41762477">prev</a><span>|</span><a href="#41762773">next</a><span>|</span><label class="collapse" for="c-41763006">[-]</label><label class="expand" for="c-41763006">[1 more]</label></div><br/><div class="children"><div class="content">Unless I&#x27;m missing something, title of the article doesn&#x27;t really correlate with its conclusion.</div><br/></div></div><div id="41762773" class="c"><input type="checkbox" id="c-41762773" checked=""/><div class="controls bullet"><span class="by">lsb</span><span>|</span><a href="#41763006">prev</a><span>|</span><a href="#41763256">next</a><span>|</span><label class="collapse" for="c-41762773">[-]</label><label class="expand" for="c-41762773">[1 more]</label></div><br/><div class="children"><div class="content">Clojure, for example, uses Hash Array Mapped Tries as its associative data structure, and those work well</div><br/></div></div><div id="41763256" class="c"><input type="checkbox" id="c-41763256" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#41762773">prev</a><span>|</span><label class="collapse" for="c-41763256">[-]</label><label class="expand" for="c-41763256">[1 more]</label></div><br/><div class="children"><div class="content">I feel I missed point of this article. I thought the author is trying to prove that b-tren isn&#x27;t that bad compared to hashmaps. But taking 2~3x longer looks pretty bad.<p>If I need predictable ordering (but not actually sorting the keys) I will use something like indexmap, not b-tree.</div><br/></div></div></div></div></div></div></div></body></html>