<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700038872302" as="style"/><link rel="stylesheet" href="styles.css?v=1700038872302"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lock.cmpxchg8b.com/reptar.html">Reptar</a>Â <span class="domain">(<a href="https://lock.cmpxchg8b.com">lock.cmpxchg8b.com</a>)</span></div><div class="subtext"><span>abhi9u</span> | <span>142 comments</span></div><br/><div><div id="38274685" class="c"><input type="checkbox" id="c-38274685" checked=""/><div class="controls bullet"><span class="by">Borg3</span><span>|</span><a href="#38274594">next</a><span>|</span><label class="collapse" for="c-38274685">[-]</label><label class="expand" for="c-38274685">[1 more]</label></div><br/><div class="children"><div class="content">Uhm.. Why not padding using NOP ? Looks much more safer that slapping around
random prefixes.</div><br/></div></div><div id="38274594" class="c"><input type="checkbox" id="c-38274594" checked=""/><div class="controls bullet"><span class="by">tazjin</span><span>|</span><a href="#38274685">prev</a><span>|</span><a href="#38274183">next</a><span>|</span><label class="collapse" for="c-38274594">[-]</label><label class="expand" for="c-38274594">[1 more]</label></div><br/><div class="children"><div class="content">Can we get a better title for this? &quot;Reptar - new CPU vulnerability&quot; or something. I thought it was some random startup ad until I picked up the name somewhere else.</div><br/></div></div><div id="38274183" class="c"><input type="checkbox" id="c-38274183" checked=""/><div class="controls bullet"><span class="by">atesti</span><span>|</span><a href="#38274594">prev</a><span>|</span><a href="#38268181">next</a><span>|</span><label class="collapse" for="c-38274183">[-]</label><label class="expand" for="c-38274183">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand &quot;ERMS&quot; and &quot;FSRM&quot; and there seems to be nothing good on google about it.<p>Are these just CPUID flags that tell you that you can use a rep movsb for maximum performance instead of optimized SSE memcpy implementations? Or is it a special encoding&#x2F;prefix for rep movsb to make it faster? In case of the later, why would that be necessary? How does one make use of fsrm?</div><br/><div id="38274293" class="c"><input type="checkbox" id="c-38274293" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#38274183">parent</a><span>|</span><a href="#38274315">next</a><span>|</span><label class="collapse" for="c-38274293">[-]</label><label class="expand" for="c-38274293">[1 more]</label></div><br/><div class="children"><div class="content">Found this [1], which also links to the Intel Optimization Manual [2].<p>Seems like ERMS was a cheaper replacement for AVX and FSRM was a better version, for shorter blocks.<p>&gt; Cheapest versions of later processors - Kaby Lake Celeron and Pentium, released in 2017, don&#x27;t have AVX that could have been used for fast memory copy, but still have the Enhanced REP MOVSB. And some of Intel&#x27;s mobile and low-power architectures released in 2018 and onwards, which were not based on SkyLake, copy about twice more bytes per CPU cycle with REP MOVSB than previous generations of microarchitectures.<p>&gt; Enhanced REP MOVSB (ERMSB) before the Ice Lake microarchitecture with Fast Short REP MOV (FSRM) was only faster than AVX copy or general-use register copy if the block size is at least 256 bytes. For the blocks below 64 bytes, it was much slower, because there is a high internal startup in ERMSB - about 35 cycles. The FSRM feature intended blocks before 128 bytes also be quick.<p>[1] <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;43837564" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;43837564</a><p>[2] <a href="http:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-optimization-manual.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;...</a></div><br/></div></div><div id="38274315" class="c"><input type="checkbox" id="c-38274315" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38274183">parent</a><span>|</span><a href="#38274293">prev</a><span>|</span><a href="#38268181">next</a><span>|</span><label class="collapse" for="c-38274315">[-]</label><label class="expand" for="c-38274315">[1 more]</label></div><br/><div class="children"><div class="content">FSRM is just the name of a cpu optimization that affects existing code.<p>Choosing an optimal instruction choice and scheduling can be done statically during compile time or dynamically (via chosing one of several library functions at runtime, or jitting).<p>In order to be able to detect which is the optimal instruction scheduling at runtime you need to know the actual CPU. You could have a table of all cpu models or you could just ask your OS whether the CPU you run on has that optimization implemented.<p>Linux had to be patched so that it can _report_ that a CPU does implement that optimization.<p><a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Intel-5.6-FSRM-Memmove" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Intel-5.6-FSRM-Memmove</a></div><br/></div></div></div></div><div id="38268181" class="c"><input type="checkbox" id="c-38268181" checked=""/><div class="controls bullet"><span class="by">Lammy</span><span>|</span><a href="#38274183">prev</a><span>|</span><a href="#38271333">next</a><span>|</span><label class="collapse" for="c-38268181">[-]</label><label class="expand" for="c-38268181">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the processor would begin to report machine check exceptions and halt.<p>I get it <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dXekDCcw2FE">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dXekDCcw2FE</a></div><br/><div id="38272249" class="c"><input type="checkbox" id="c-38272249" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#38268181">parent</a><span>|</span><a href="#38271333">next</a><span>|</span><label class="collapse" for="c-38272249">[-]</label><label class="expand" for="c-38272249">[1 more]</label></div><br/><div class="children"><div class="content">... it literally took me all Goddamn day. Well done.<p>Credit where credit is due: Google has some of the best codenames.</div><br/></div></div></div></div><div id="38271333" class="c"><input type="checkbox" id="c-38271333" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#38268181">prev</a><span>|</span><a href="#38269981">next</a><span>|</span><label class="collapse" for="c-38271333">[-]</label><label class="expand" for="c-38271333">[5 more]</label></div><br/><div class="children"><div class="content">Konrad Magnusson from Paradox Interactive (Victoria 3) team found something related to that and mimalloc -&gt; <a href="https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;mimalloc&#x2F;issues&#x2F;807">https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;mimalloc&#x2F;issues&#x2F;807</a><p>Not sure if fully related, but possibly.</div><br/><div id="38273306" class="c"><input type="checkbox" id="c-38273306" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38271333">parent</a><span>|</span><a href="#38269981">next</a><span>|</span><label class="collapse" for="c-38273306">[-]</label><label class="expand" for="c-38273306">[4 more]</label></div><br/><div class="children"><div class="content">Seems unlikely unless they somehow emitted redundant prefixes</div><br/><div id="38273329" class="c"><input type="checkbox" id="c-38273329" checked=""/><div class="controls bullet"><span class="by">lights0123</span><span>|</span><a href="#38271333">root</a><span>|</span><a href="#38273306">parent</a><span>|</span><a href="#38269981">next</a><span>|</span><label class="collapse" for="c-38273329">[-]</label><label class="expand" for="c-38273329">[3 more]</label></div><br/><div class="children"><div class="content">The article mentions<p>&gt; This fact is sometimes useful; compilers can use redundant prefixes to pad a single instruction to a desirable alignment boundary.<p>so I imagine that could happen under the right optimization mode.</div><br/><div id="38274318" class="c"><input type="checkbox" id="c-38274318" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#38271333">root</a><span>|</span><a href="#38273329">parent</a><span>|</span><a href="#38269981">next</a><span>|</span><label class="collapse" for="c-38274318">[-]</label><label class="expand" for="c-38274318">[2 more]</label></div><br/><div class="children"><div class="content">Why would a compiler prefer a redundant prefix over a nop for alignment?</div><br/><div id="38274629" class="c"><input type="checkbox" id="c-38274629" checked=""/><div class="controls bullet"><span class="by">Vecr</span><span>|</span><a href="#38271333">root</a><span>|</span><a href="#38274318">parent</a><span>|</span><a href="#38269981">next</a><span>|</span><label class="collapse" for="c-38274629">[-]</label><label class="expand" for="c-38274629">[1 more]</label></div><br/><div class="children"><div class="content">It can be faster (at runtime).</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38269981" class="c"><input type="checkbox" id="c-38269981" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38271333">prev</a><span>|</span><a href="#38269293">next</a><span>|</span><label class="collapse" for="c-38269981">[-]</label><label class="expand" for="c-38269981">[2 more]</label></div><br/><div class="children"><div class="content">Related: <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;identity-security&#x2F;google-researchers-discover-reptar-a-new-cpu-vulnerability" rel="nofollow noreferrer">https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;identity-security&#x2F;goo...</a><p>(via <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38268043">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38268043</a>, but we merged the comments hither)</div><br/></div></div><div id="38269293" class="c"><input type="checkbox" id="c-38269293" checked=""/><div class="controls bullet"><span class="by">mike_d</span><span>|</span><a href="#38269981">prev</a><span>|</span><a href="#38268603">next</a><span>|</span><label class="collapse" for="c-38269293">[-]</label><label class="expand" for="c-38269293">[1 more]</label></div><br/><div class="children"><div class="content">The most awesome part:<p>&gt; This bug was independently discovered by multiple research teams within Google, including the silifuzz team and Google Information Security Engineering.</div><br/></div></div><div id="38268603" class="c"><input type="checkbox" id="c-38268603" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#38269293">prev</a><span>|</span><a href="#38274375">next</a><span>|</span><label class="collapse" for="c-38268603">[-]</label><label class="expand" for="c-38268603">[16 more]</label></div><br/><div class="children"><div class="content">Reading this makes me realize how little I know of the hardware that runs my software<p>&gt; Prefixes allow you to change how instructions behave by enabling or disabling features<p>Why do we need âprefixesâ to disable or enable features? Is this for dynamically toggling feature so you donât have to go into BIOS?</div><br/><div id="38269057" class="c"><input type="checkbox" id="c-38269057" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38268799">next</a><span>|</span><label class="collapse" for="c-38269057">[-]</label><label class="expand" for="c-38269057">[6 more]</label></div><br/><div class="children"><div class="content">Read <a href="https:&#x2F;&#x2F;wiki.osdev.org&#x2F;X86-64_Instruction_Encoding#Legacy_Prefixes" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.osdev.org&#x2F;X86-64_Instruction_Encoding#Legacy_Pr...</a><p>The REP prefixes are the most common; they just let you perform the same instruction a variable number of times. It looks in the CX register for the count. This makes many common loops really, really short, especially for moving objects around in memory. The memcpy function is often inlined as a single REP MOVS instruction, possibly with an instruction to copy the count into CX if it isnât already there.<p>I suppose the REX (operand size) prefix is pretty common too, since 64âbit programs will want to operate on 64âbit values and addresses pretty frequently.<p>None of the prefixes toggle things that can be set globally, by the BIOS or otherwise. They all just specify things that the next instruction needs to do.</div><br/><div id="38269241" class="c"><input type="checkbox" id="c-38269241" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269057">parent</a><span>|</span><a href="#38268799">next</a><span>|</span><label class="collapse" for="c-38269241">[-]</label><label class="expand" for="c-38269241">[5 more]</label></div><br/><div class="children"><div class="content">The ModR&#x2F;M and SIB prefixes are probably the most common prefixes in instructions.  They are so common that assemblers elide their existence when you read code.  REX is in the same boat: so common that it&#x27;s usually elided.  The VEX prefix is also really common (all of the V* AVX instructions, like VMOVDQ), and then the LOCK prefix (all atomics).<p>After all of those, REP is not that uncommon of a prefix to run into, although many people prefer SIMD memcpy&#x2F;memset to REP MOVSB&#x2F;REP STOSB.  It is slightly unusual.</div><br/><div id="38273874" class="c"><input type="checkbox" id="c-38273874" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269241">parent</a><span>|</span><a href="#38270006">next</a><span>|</span><label class="collapse" for="c-38273874">[-]</label><label class="expand" for="c-38273874">[1 more]</label></div><br/><div class="children"><div class="content">This isn&#x27;t correct.
ModR&#x2F;M and SIB are <i>not</i> prefixes. They are suffixes and essentially part of the core instruction encoding for certain memory and register access instruction. they are the primary means of encoding the myriad addressing modes of the x86. And their existence is not elided in any meaningful way, their value is explicitly derived from the instruction operands (SIB is scale, index, base), so when you see an instruction like:<p>mov    BYTE PTR [rdi+rbx*4],0x4<p>SIB is determined by the register indices of rdi, rbx, and 4, all right there in the instruction. Likewise, Mod R&#x2F;M encodes the addressing mode, which is clear from the operands in the assembler listing. Though x86 is such as mess that there are cases where you can encode the same instruction in either a Mod R&#x2F;M form or a shorter form, eg PUSH&#x2F;POP.<p>REX is a prefix, but it is a bit special as it must be the last one, and repeats are undefined. It is not elided because of commonality but because its presence and value is usually implied from the operands, it is therefore redundant to list it.<p>For instance, PUSH R12 must use a REX prefix (REX.B with the one byte encoding).</div><br/></div></div><div id="38270006" class="c"><input type="checkbox" id="c-38270006" checked=""/><div class="controls bullet"><span class="by">EarlKing</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269241">parent</a><span>|</span><a href="#38273874">prev</a><span>|</span><a href="#38269611">next</a><span>|</span><label class="collapse" for="c-38270006">[-]</label><label class="expand" for="c-38270006">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a good reason for using vector instructions over REP: Until relatively recently that was how you got maximum performance in small, tight loops. REP is making a comeback precisely because of ERMS and FSRM, so unfortunately this will become a bigger problem going forward.</div><br/></div></div><div id="38269611" class="c"><input type="checkbox" id="c-38269611" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269241">parent</a><span>|</span><a href="#38270006">prev</a><span>|</span><a href="#38268799">next</a><span>|</span><label class="collapse" for="c-38269611">[-]</label><label class="expand" for="c-38269611">[2 more]</label></div><br/><div class="children"><div class="content">ModRM and SIB are not a prefix, they&#x27;re part of the opcode (second and third byte after all the prefixes and the 0Fh&#x2F;0F38h&#x2F;0F3Ah opcode map selectors)</div><br/><div id="38270207" class="c"><input type="checkbox" id="c-38270207" checked=""/><div class="controls bullet"><span class="by">EarlKing</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269611">parent</a><span>|</span><a href="#38268799">next</a><span>|</span><label class="collapse" for="c-38270207">[-]</label><label class="expand" for="c-38270207">[1 more]</label></div><br/><div class="children"><div class="content">More specifically, they&#x27;re affixed to <i>certain</i> opcodes that require them. There are a number of byte-sized opcodes that do not require a ModRM or SIB byte (although a number of those got gobbled up to make the REX prefix, but that&#x27;s another story).<p>TL;DR Weeee! Intel machine language is crazy!</div><br/></div></div></div></div></div></div></div></div><div id="38268799" class="c"><input type="checkbox" id="c-38268799" checked=""/><div class="controls bullet"><span class="by">shenberg</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38269057">prev</a><span>|</span><a href="#38269024">next</a><span>|</span><label class="collapse" for="c-38268799">[-]</label><label class="expand" for="c-38268799">[1 more]</label></div><br/><div class="children"><div class="content">Prefixes are modifiers to specific instructions executed by the processor, e.g. to control the size of the operands or enable locking for concurrency.</div><br/></div></div><div id="38269024" class="c"><input type="checkbox" id="c-38269024" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38268799">prev</a><span>|</span><a href="#38272654">next</a><span>|</span><label class="collapse" for="c-38269024">[-]</label><label class="expand" for="c-38269024">[4 more]</label></div><br/><div class="children"><div class="content">x86 was designed in 78, basically for the purpose of running a primitive laser printer (or other similar workloads). The big problem with this is that the encoding space for instructions was &quot;efficiently utilized&quot;. When new instructions, or worse, additional registers were later added, you had to fit the new instruction variants in somehow, and you did this by tacking on prefixes.</div><br/><div id="38269328" class="c"><input type="checkbox" id="c-38269328" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269024">parent</a><span>|</span><a href="#38272654">next</a><span>|</span><label class="collapse" for="c-38269328">[-]</label><label class="expand" for="c-38269328">[3 more]</label></div><br/><div class="children"><div class="content">Nah, x86 goes even earlier in its heritage - it was, effectively, a bolt-on on Intel&#x27;s way older designs, as a huge part of the 8086 was being ASM source-compatible with the older 8xxx chips, even as the instruction set itself changed [1]. What utterly amazes me is that the original 8086 was mostly designed <i>by hand</i> by a team of not even two dozen people - and today, we got hundreds if not thousands of people working on designing ASICs...<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_8086#The_first_x86_design" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_8086#The_first_x86_desig...</a></div><br/><div id="38274542" class="c"><input type="checkbox" id="c-38274542" checked=""/><div class="controls bullet"><span class="by">irdc</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269328">parent</a><span>|</span><a href="#38273806">next</a><span>|</span><label class="collapse" for="c-38274542">[-]</label><label class="expand" for="c-38274542">[1 more]</label></div><br/><div class="children"><div class="content">Acckkghtually, if you go back far enough you end up at the Datapoint 2200. If you want to understand where some of the crazier parts of the 8086 originate from, Ken Shirriff has a nice read: <a href="http:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;08&#x2F;datapoint-to-8086.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;08&#x2F;datapoint-to-8086.html</a></div><br/></div></div><div id="38273806" class="c"><input type="checkbox" id="c-38273806" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#38268603">root</a><span>|</span><a href="#38269328">parent</a><span>|</span><a href="#38274542">prev</a><span>|</span><a href="#38272654">next</a><span>|</span><label class="collapse" for="c-38273806">[-]</label><label class="expand" for="c-38273806">[1 more]</label></div><br/><div class="children"><div class="content">It is because testing plays a bigger part today than back then. The complexity has also increased (people do not design at transistor level anymore).</div><br/></div></div></div></div></div></div><div id="38272654" class="c"><input type="checkbox" id="c-38272654" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38269024">prev</a><span>|</span><a href="#38269498">next</a><span>|</span><label class="collapse" for="c-38272654">[-]</label><label class="expand" for="c-38272654">[1 more]</label></div><br/><div class="children"><div class="content">You got some great answers already, but to your first point check out Hennessey and Patterson&#x27;s books, namely Computer Architecture and Computer Organization and Design.<p>The latter is probably more suited to you unless you wanna go on a dive into computer architecture itself. There&#x27;s older editions available for free (authorized by the authors) on the web.<p>I first read the 3rd edition of Computer Architecture and besides being one of the most clear textbooks I&#x27;ve ever read it vastly improved my understanding of what&#x27;s going on in there in relation to OoO speculative execution, etc.</div><br/></div></div><div id="38269498" class="c"><input type="checkbox" id="c-38269498" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38272654">prev</a><span>|</span><a href="#38268724">next</a><span>|</span><label class="collapse" for="c-38269498">[-]</label><label class="expand" for="c-38269498">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a very poor summary of what prefixes are. My advice, just skip the original article which isn&#x27;t very good or interesting and read taviso&#x27;s blog that is linked in the top comment (it gives a few concrete examples of these prefixes). They are modifiers that are part of the CPU instruction.</div><br/></div></div><div id="38268724" class="c"><input type="checkbox" id="c-38268724" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38269498">prev</a><span>|</span><a href="#38270421">next</a><span>|</span><label class="collapse" for="c-38268724">[-]</label><label class="expand" for="c-38268724">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just because x86 as an ISA has accreted over the course of 40+ years, and has variable-length instructions. Every time they extend the ISA they carve out part of the opcode space to squeeze in a new prefix. This will only continue, considering that Intel has proposed another new scheme this year.</div><br/></div></div><div id="38270421" class="c"><input type="checkbox" id="c-38270421" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38268603">parent</a><span>|</span><a href="#38268724">prev</a><span>|</span><a href="#38274375">next</a><span>|</span><label class="collapse" for="c-38270421">[-]</label><label class="expand" for="c-38270421">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Prefixes&quot; in this case mostly expand the instruction encoding space.<p>So rarely-used addressing modes get a &quot;segment prefix&quot; that causes them to use a segment other than DS.  Or x86_64 added a &quot;REX&quot; prefix that added more bits to the register fields allowing for 16 GPRs.  Likewise the &quot;LOCK&quot; prefix (though poorly specified originally) causes (some!) memory operations to be atomic with respect to the rest of the system (c.f. &quot;LOCK CMPXCHG&quot; to effect a compare-and-set).<p>All these things are operations other CPU architectures represent too, though they tend to pack them into the existing instruction space, requiring more bits to represent every instruction.<p>Notably the &quot;REP&quot; prefix in question turns out to be the one exception.  This is a microcoded repeat prefix left over from the ancient days.  But it represents operations (c.f. memset&#x2F;memmove) that are performance-sensitive even today, so it&#x27;s worthwhile for CPU vendors to continue to optimize them.  Which is how the bug in question seems to have happened.</div><br/></div></div></div></div><div id="38274375" class="c"><input type="checkbox" id="c-38274375" checked=""/><div class="controls bullet"><span class="by">tommiegannert</span><span>|</span><a href="#38268603">prev</a><span>|</span><a href="#38267962">next</a><span>|</span><label class="collapse" for="c-38274375">[-]</label><label class="expand" for="c-38274375">[1 more]</label></div><br/><div class="children"><div class="content">Nice find. That indeed sounds terrible for anyone executing external code in what they believe to be sandboxes. Good thing it can be patched (and AFAICT, it seems to be a good fix, rather than a performance-affecting workaround.)</div><br/></div></div><div id="38267962" class="c"><input type="checkbox" id="c-38267962" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38274375">prev</a><span>|</span><a href="#38269038">next</a><span>|</span><label class="collapse" for="c-38267962">[-]</label><label class="expand" for="c-38267962">[1 more]</label></div><br/><div class="children"><div class="content">Their diagnosis reminds me of what happened when qemu ran into repz ret. <a href="https:&#x2F;&#x2F;repzret.org&#x2F;p&#x2F;repzret&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;repzret.org&#x2F;p&#x2F;repzret&#x2F;</a></div><br/></div></div><div id="38269038" class="c"><input type="checkbox" id="c-38269038" checked=""/><div class="controls bullet"><span class="by">writeslowly</span><span>|</span><a href="#38267962">prev</a><span>|</span><a href="#38267802">next</a><span>|</span><label class="collapse" for="c-38269038">[-]</label><label class="expand" for="c-38269038">[24 more]</label></div><br/><div class="children"><div class="content">I noticed the Intel advisory [1] says the following<p>Intel would like to thank Intel employees:[...] for finding this issue internally.<p>Intel would like to thank Google Employees: [...] for also reporting this issue.<p>[1] <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;security-center&#x2F;advisory&#x2F;intel-sa-00950.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;security-center&#x2F;advi...</a></div><br/><div id="38269282" class="c"><input type="checkbox" id="c-38269282" checked=""/><div class="controls bullet"><span class="by">narinxas</span><span>|</span><a href="#38269038">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38269282">[-]</label><label class="expand" for="c-38269282">[22 more]</label></div><br/><div class="children"><div class="content">I wonder how much sooner than google did intel employees found this issue</div><br/><div id="38269913" class="c"><input type="checkbox" id="c-38269913" checked=""/><div class="controls bullet"><span class="by">narinxas</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38269282">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38269913">[-]</label><label class="expand" for="c-38269913">[21 more]</label></div><br/><div class="children"><div class="content">but what I am really wondering about is how much money (if any) was the vulnerability worth up the moment when google also discovered this?</div><br/><div id="38270349" class="c"><input type="checkbox" id="c-38270349" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38269913">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38270349">[-]</label><label class="expand" for="c-38270349">[20 more]</label></div><br/><div class="children"><div class="content">As described it&#x27;s just a CPU crash exploit that requires local binary execution.  Getting to a vulnerability would require understanding exactly how the corrupted microcode state works, and that seems extremely difficult outside of Intel.<p>So as described, this isn&#x27;t a &quot;valuable&quot; bug.</div><br/><div id="38274424" class="c"><input type="checkbox" id="c-38274424" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38270349">parent</a><span>|</span><a href="#38270877">next</a><span>|</span><label class="collapse" for="c-38274424">[-]</label><label class="expand" for="c-38274424">[1 more]</label></div><br/><div class="children"><div class="content">The blogpost describes that unrelated sibling SMT threads can become corrupted and branch erratically. If you can get a hypervisor thread executing as your SMT sibling and you can figure out how to control it (this is not an if so much as a when), that&#x27;s a VM escape. The Intel advisory acknowledges this too when they say it can lead to privilege escalation. This is hardly a useless bug, in fact it&#x27;s awfully powerful!</div><br/></div></div><div id="38270877" class="c"><input type="checkbox" id="c-38270877" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38270349">parent</a><span>|</span><a href="#38274424">prev</a><span>|</span><a href="#38270729">next</a><span>|</span><label class="collapse" for="c-38270877">[-]</label><label class="expand" for="c-38270877">[12 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not super-valuable yet, but it would keep you mount a really nasty DoS on cloud providers by triggering hard resets of the physical machines. Some people would probably pay for that, though it&#x27;s obviously more interesting to push on privilege or exfiltration.<p>Particularly since the MCEs triggered could prevent an automatic reboot. Would depend what the hardware management system did - do machines presenting MCEs get pulled?</div><br/><div id="38270927" class="c"><input type="checkbox" id="c-38270927" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38270877">parent</a><span>|</span><a href="#38271143">next</a><span>|</span><label class="collapse" for="c-38270927">[-]</label><label class="expand" for="c-38270927">[10 more]</label></div><br/><div class="children"><div class="content">If I&#x27;m a cloud provider and somebody&#x27;s workflow is hard resetting lots of my physical machines, I&#x27;m going to give them free access to single tenant machines at the very minimum. If they keep crashing the machines that only they run on, I guess that&#x27;s ok.</div><br/><div id="38271104" class="c"><input type="checkbox" id="c-38271104" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38270927">parent</a><span>|</span><a href="#38271143">next</a><span>|</span><label class="collapse" for="c-38271104">[-]</label><label class="expand" for="c-38271104">[9 more]</label></div><br/><div class="children"><div class="content">You can exploit this from a single core shared instance.<p>So you go and find yourself a thousand cheap &#x2F; free tier accounts, spin up an instance in a few regions each, and boom, you&#x27;ve taken out 10k physical hosts. And run it in a lambda at the same time, and see how well the security mechanisms identify and isolate you.<p>Causing a near simultaneous reboot of enough hosts is likely to take other parts of the infrastructure down.</div><br/><div id="38271158" class="c"><input type="checkbox" id="c-38271158" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271104">parent</a><span>|</span><a href="#38271143">next</a><span>|</span><label class="collapse" for="c-38271158">[-]</label><label class="expand" for="c-38271158">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what part of this scheme involves &quot;not ending up in jail&quot;?  Needless to say you can&#x27;t do this without identifying yourself.  To make this an exploitable DoS attack you need to be able to run arbitrary binaries on a few thousand cloud hosts <i>that you didn&#x27;t lease yourself</i>.</div><br/><div id="38274242" class="c"><input type="checkbox" id="c-38274242" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271158">parent</a><span>|</span><a href="#38271556">next</a><span>|</span><label class="collapse" for="c-38274242">[-]</label><label class="expand" for="c-38274242">[1 more]</label></div><br/><div class="children"><div class="content">I mean, you kinda can. There&#x27;s a depressingly thriving market for stolen cards and things like compromised accounts. A card is a couple of dollars. There are many jurisdictions that turn a blind eye to hacking us companies. Look at how hard it&#x27;s been to rein in the ransomware gangs and even &#x27;booter&#x27; (ddos-for-rent) services.<p>DoS isn&#x27;t as lucrative as other things; I assume that most state actors would far prefer to find a way to turn this into a privilege escalation. But being able to possibly take out a cloud provider for a while is still monetizable.</div><br/></div></div><div id="38271556" class="c"><input type="checkbox" id="c-38271556" checked=""/><div class="controls bullet"><span class="by">blibble</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271158">parent</a><span>|</span><a href="#38274242">prev</a><span>|</span><a href="#38271674">next</a><span>|</span><label class="collapse" for="c-38271556">[-]</label><label class="expand" for="c-38271556">[1 more]</label></div><br/><div class="children"><div class="content">there exist people outside of your jurisdiction<p>e.g. the GRU</div><br/></div></div><div id="38271674" class="c"><input type="checkbox" id="c-38271674" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271158">parent</a><span>|</span><a href="#38271556">prev</a><span>|</span><a href="#38271661">next</a><span>|</span><label class="collapse" for="c-38271674">[-]</label><label class="expand" for="c-38271674">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m curious what part of this scheme involves &quot;not ending up in jail&quot;? Needless to say you can&#x27;t do this without identifying yourself.<p>Stolen credit cards are a dime a dozen, and nation state actors can just use their domestic banks or agents in the banks of other countries in a pinch to deflect blame or lay false trails.<p>If I were Russia or China, I&#x27;d invest <i>a lot</i> of money into researching all kinds of avenues on how to take out the large three public cloud providers if need be: take out AWS, Google, Microsoft and on the CDN side Cloudflare and Akamai and suddenly the entire Western economy grinds to a halt.<p>The only ones who will not be affected are the US government cloud services in AWS, as this runs separate from other AWS regions - that is, unless the attacker gets access to credentials that allow them executions on the GovCloud regions...</div><br/><div id="38272328" class="c"><input type="checkbox" id="c-38272328" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271674">parent</a><span>|</span><a href="#38272405">next</a><span>|</span><label class="collapse" for="c-38272328">[-]</label><label class="expand" for="c-38272328">[1 more]</label></div><br/><div class="children"><div class="content">If clouds use shared servers to run their management workloads and if very important companies use shared servers to run their workloads, they would deserve it.<p>But I don&#x27;t believe it. People are not that stupid.</div><br/></div></div><div id="38272405" class="c"><input type="checkbox" id="c-38272405" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271674">parent</a><span>|</span><a href="#38272328">prev</a><span>|</span><a href="#38271661">next</a><span>|</span><label class="collapse" for="c-38272405">[-]</label><label class="expand" for="c-38272405">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If I were Russia or China, I&#x27;d invest a lot of money into researching all kinds of avenues on how to take out the large three public cloud providers<p>This subthread started with &quot;is this issue a valuable exploit&quot;.  Needless to say, if you need to invoke superpower-scale cyber warfare to find an application, the answer is &quot;no&quot;.  Russia and China have plenty of options to &quot;take out&quot; western infrastructure if they&#x27;re willing to blow things up[1] at that scale.<p>[1] Figuratively and literally</div><br/><div id="38274300" class="c"><input type="checkbox" id="c-38274300" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38272405">parent</a><span>|</span><a href="#38271661">next</a><span>|</span><label class="collapse" for="c-38274300">[-]</label><label class="expand" for="c-38274300">[1 more]</label></div><br/><div class="children"><div class="content">Countries have proven far more reticent to use kinetic options vs. cyberattacks. Or, put differently, we&#x27;re all hacking each other left and right and the responses have thus far mostly remained in the digital realm.<p>See, e.g., <a href="https:&#x2F;&#x2F;madsciblog.tradoc.army.mil&#x2F;156-what-is-the-threshold-assessing-kinetic-responses-to-cyber-attacks&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;madsciblog.tradoc.army.mil&#x2F;156-what-is-the-threshold...</a><p>&gt; responses are usually proportional to and in the same domain as the provocation</div><br/></div></div></div></div></div></div><div id="38271661" class="c"><input type="checkbox" id="c-38271661" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271158">parent</a><span>|</span><a href="#38271674">prev</a><span>|</span><a href="#38271143">next</a><span>|</span><label class="collapse" for="c-38271661">[-]</label><label class="expand" for="c-38271661">[1 more]</label></div><br/><div class="children"><div class="content">So Replit, Godbolt, and whatever other cloud-hosted compilers are there?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38270729" class="c"><input type="checkbox" id="c-38270729" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38270349">parent</a><span>|</span><a href="#38270877">prev</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38270729">[-]</label><label class="expand" for="c-38270729">[6 more]</label></div><br/><div class="children"><div class="content">This assumes that either 1. partners and interested sponsor-state state actors aren&#x27;t kept abreast Intel&#x27;s microcode backend architecture, or 2. that there hasn&#x27;t been at least one leak of this information from one of these partners into the hands of interested APT developers. I wouldn&#x27;t put strong faith in either of these assumptions.</div><br/><div id="38271173" class="c"><input type="checkbox" id="c-38271173" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38270729">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38271173">[-]</label><label class="expand" for="c-38271173">[5 more]</label></div><br/><div class="children"><div class="content">It does, but the same is true for virtually any such crash vulnerability.  The question was whether this was a &quot;valuable exploit&quot;, not whether it might theoretically be worse.<p>The space of theoretically-very-bad attacks is much larger than practical ones people will pay for, c.f. rowhammer.</div><br/><div id="38272208" class="c"><input type="checkbox" id="c-38272208" checked=""/><div class="controls bullet"><span class="by">ethbr1</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38271173">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38272208">[-]</label><label class="expand" for="c-38272208">[4 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; <i>Getting to a vulnerability would require understanding exactly how the corrupted microcode state works, and that seems extremely difficult outside of Intel.</i><p>Intel knows exactly how their ROB works.<p>Therefore Intel knows the possible consequences of this bug and how to trigger them.<p><i>If</i> there is a privilege execution path from this, Intel knows. And anyone Intel chose to share it with knew.<p>Thankfully, since it&#x27;s public now, the value of that decreases and customers can begin to mitigate.</div><br/><div id="38272416" class="c"><input type="checkbox" id="c-38272416" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38272208">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38272416">[-]</label><label class="expand" for="c-38272416">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If there is a privilege execution path from this, Intel knows. And anyone Intel chose to share it with knew.<p>No, or at least not yet.  I mean, I&#x27;ve written plenty of bugs.  More than I can count.  How many of them were genuine security vulnerabilities if properly exploited?  Probably not zero.  But... I don&#x27;t know.  And I wrote the code!</div><br/><div id="38273334" class="c"><input type="checkbox" id="c-38273334" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38272416">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38273334">[-]</label><label class="expand" for="c-38273334">[2 more]</label></div><br/><div class="children"><div class="content">Intel said it can be used for escalation if that answers your question.</div><br/><div id="38273637" class="c"><input type="checkbox" id="c-38273637" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38269038">root</a><span>|</span><a href="#38273334">parent</a><span>|</span><a href="#38269129">next</a><span>|</span><label class="collapse" for="c-38273637">[-]</label><label class="expand" for="c-38273637">[1 more]</label></div><br/><div class="children"><div class="content">Did they confirm that it can definitely be used for escalation? The description I saw was &quot;may allow an authenticated user to potentially enable escalation of privilege and&#x2F;or information disclosure and&#x2F;or denial of service via local access&quot; which sounds like they&#x27;re covering all their bases and may not actually know what is and isn&#x27;t possible.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38267802" class="c"><input type="checkbox" id="c-38267802" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38269038">prev</a><span>|</span><a href="#38269093">next</a><span>|</span><label class="collapse" for="c-38267802">[-]</label><label class="expand" for="c-38267802">[2 more]</label></div><br/><div class="children"><div class="content">See also Intelâs advisory, which has a description of impact: <a href="https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;security-center&#x2F;advisory&#x2F;intel-sa-00950.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.intel.com&#x2F;content&#x2F;www&#x2F;us&#x2F;en&#x2F;security-center&#x2F;advi...</a><p>&gt; Sequence of processor instructions leads to unexpected behavior for some Intel(R) Processors may allow an authenticated user to potentially enable escalation of privilege and&#x2F;or information disclosure and&#x2F;or denial of service via local access.</div><br/><div id="38273862" class="c"><input type="checkbox" id="c-38273862" checked=""/><div class="controls bullet"><span class="by">yborg</span><span>|</span><a href="#38267802">parent</a><span>|</span><a href="#38269093">next</a><span>|</span><label class="collapse" for="c-38273862">[-]</label><label class="expand" for="c-38273862">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;Some&#x27; appears to be almost any Intel x86 CPU made in the last 6 years.</div><br/></div></div></div></div><div id="38269093" class="c"><input type="checkbox" id="c-38269093" checked=""/><div class="controls bullet"><span class="by">jefc1111</span><span>|</span><a href="#38267802">prev</a><span>|</span><a href="#38268787">next</a><span>|</span><label class="collapse" for="c-38269093">[-]</label><label class="expand" for="c-38269093">[1 more]</label></div><br/><div class="children"><div class="content">This was a lot more fun than the Google puff piece.</div><br/></div></div><div id="38268787" class="c"><input type="checkbox" id="c-38268787" checked=""/><div class="controls bullet"><span class="by">bobim</span><span>|</span><a href="#38269093">prev</a><span>|</span><a href="#38269799">next</a><span>|</span><label class="collapse" for="c-38268787">[-]</label><label class="expand" for="c-38268787">[37 more]</label></div><br/><div class="children"><div class="content">Is it even possible to design a cpu with out-of-order and speculative execution that would have no security issue? Is the future leads to a swarm of disconnected A55 cores each running a single application?</div><br/><div id="38268986" class="c"><input type="checkbox" id="c-38268986" checked=""/><div class="controls bullet"><span class="by">Tuna-Fish</span><span>|</span><a href="#38268787">parent</a><span>|</span><a href="#38269214">next</a><span>|</span><label class="collapse" for="c-38268986">[-]</label><label class="expand" for="c-38268986">[19 more]</label></div><br/><div class="children"><div class="content">This vulnerability was not caused by OoO or speculative execution. It was caused by the fact that x86 was designed 45 years ago, and has had feature after feature piled on the same base, which has never been adequately rebuilt.<p>The more proximate cause is that some instructions with multiple redundant prefixes (which is legal, but pointless) have their length miscalculated by some Intel CPUs, which results in wrong outcomes.</div><br/><div id="38270623" class="c"><input type="checkbox" id="c-38270623" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38268986">parent</a><span>|</span><a href="#38269456">next</a><span>|</span><label class="collapse" for="c-38270623">[-]</label><label class="expand" for="c-38270623">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It was caused by the fact that x86 was designed 45 years ago, and has had feature after feature piled on the same base, <i>which has never been adequately rebuilt</i>.<p>Itanic would like to object!  Unfortunately it canât get through the door.</div><br/></div></div><div id="38269456" class="c"><input type="checkbox" id="c-38269456" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38268986">parent</a><span>|</span><a href="#38270623">prev</a><span>|</span><a href="#38269214">next</a><span>|</span><label class="collapse" for="c-38269456">[-]</label><label class="expand" for="c-38269456">[17 more]</label></div><br/><div class="children"><div class="content">Not entirely pointless, redundant prefixes are occasionally the useful method for alignment.</div><br/><div id="38269562" class="c"><input type="checkbox" id="c-38269562" checked=""/><div class="controls bullet"><span class="by">TheCoreh</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269456">parent</a><span>|</span><a href="#38269857">next</a><span>|</span><label class="collapse" for="c-38269562">[-]</label><label class="expand" for="c-38269562">[14 more]</label></div><br/><div class="children"><div class="content">A more sensible approach for that use-case would be IMO to have well-defined specialized prefixes for padding, instead of relying on the case-by-case behavior of redundant prefixes. (However I understand that there&#x27;s almost certainly a good historical reason why this was not the way it was done)</div><br/><div id="38270282" class="c"><input type="checkbox" id="c-38270282" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269562">parent</a><span>|</span><a href="#38270290">next</a><span>|</span><label class="collapse" for="c-38270282">[-]</label><label class="expand" for="c-38270282">[3 more]</label></div><br/><div class="children"><div class="content">The easiest way of doing padding is to add a bunch of `nop` instructions which are one byte each.<p>If you read the manual, Intel encourages minor variations of the `nop` instructions that can be lengthened into different number of bytes (like `nop dword ptr [eax]` or `nop dword ptr [eax + eax*1 + 00000000h]`).<p>It is never recommended anywhere in my knowledge to rely on redundant prefixes of random non-nop instructions.</div><br/><div id="38270531" class="c"><input type="checkbox" id="c-38270531" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38270282">parent</a><span>|</span><a href="#38270348">next</a><span>|</span><label class="collapse" for="c-38270531">[-]</label><label class="expand" for="c-38270531">[1 more]</label></div><br/><div class="children"><div class="content">NOPs are not generally free.<p>It&#x27;s a pretty old and well known technique:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;48046814&#x2F;what-methods-can-be-used-to-efficiently-extend-instruction-length-on-modern-x86" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;48046814&#x2F;what-methods-ca...</a><p>Note that this technique is really only legitimate where the used prefix already has defined behavior with the given instruction (&quot;Use of repeat prefixes and&#x2F;or undefined opcodes with other Intel 64 or IA-32 instructions is reserved; such use may cause unpredictable behavior.&quot;), and of course the REX prefix has special limitations. The key is redundant, not spurious. It is not a good idea to be doing rep add for example. But otherwise, there is no issue.</div><br/></div></div></div></div><div id="38270290" class="c"><input type="checkbox" id="c-38270290" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269562">parent</a><span>|</span><a href="#38270282">prev</a><span>|</span><a href="#38269684">next</a><span>|</span><label class="collapse" for="c-38270290">[-]</label><label class="expand" for="c-38270290">[5 more]</label></div><br/><div class="children"><div class="content">The prefixes are <i>redundant</i> so it&#x27;s not really case-by-case behavior. You&#x27;re just repeating the prefix you would be using anyway in that location.<p>Using specialized prefixes wastes encoding space for no real gain.
You realize on most common processors NOP itself is a pseudo-instruction? Even the apparently meme-worthy (see sibling comment) RISC-V, it&#x27;s ADDI x0, x0, 0.</div><br/><div id="38270544" class="c"><input type="checkbox" id="c-38270544" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38270290">parent</a><span>|</span><a href="#38269684">next</a><span>|</span><label class="collapse" for="c-38270544">[-]</label><label class="expand" for="c-38270544">[4 more]</label></div><br/><div class="children"><div class="content">And then there are CPUs that retcon behavioral changes onto nops.<p>&gt; Moving a register to itself is functionally a nop, but the processor overloads it to signal information about priority.<p><a href="https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20180809-00&#x2F;?p=99455" rel="nofollow noreferrer">https:&#x2F;&#x2F;devblogs.microsoft.com&#x2F;oldnewthing&#x2F;20180809-00&#x2F;?p=99...</a></div><br/><div id="38271171" class="c"><input type="checkbox" id="c-38271171" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38270544">parent</a><span>|</span><a href="#38269684">next</a><span>|</span><label class="collapse" for="c-38271171">[-]</label><label class="expand" for="c-38271171">[3 more]</label></div><br/><div class="children"><div class="content">&gt; A program can voluntarily set itself to low priority if it is waiting for a spin lock<p>What does this even mean? How can a program do this when thread priority is an OS thing? It&#x27;s seems just weird.</div><br/><div id="38271670" class="c"><input type="checkbox" id="c-38271670" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38271171">parent</a><span>|</span><a href="#38271685">next</a><span>|</span><label class="collapse" for="c-38271670">[-]</label><label class="expand" for="c-38271670">[1 more]</label></div><br/><div class="children"><div class="content">Hardware threads as in SMT means thread priority is also a hardware thing.</div><br/></div></div><div id="38271685" class="c"><input type="checkbox" id="c-38271685" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38271171">parent</a><span>|</span><a href="#38271670">prev</a><span>|</span><a href="#38269684">next</a><span>|</span><label class="collapse" for="c-38271685">[-]</label><label class="expand" for="c-38271685">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an SMT CPU that dynamically assigns decode, registers, etc. <a href="https:&#x2F;&#x2F;course.ece.cmu.edu&#x2F;~ece740&#x2F;f13&#x2F;lib&#x2F;exe&#x2F;fetch.php?media=kalla04_power5.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;course.ece.cmu.edu&#x2F;~ece740&#x2F;f13&#x2F;lib&#x2F;exe&#x2F;fetch.php?med...</a></div><br/></div></div></div></div></div></div></div></div><div id="38269684" class="c"><input type="checkbox" id="c-38269684" checked=""/><div class="controls bullet"><span class="by">bobim</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269562">parent</a><span>|</span><a href="#38270290">prev</a><span>|</span><a href="#38271878">next</a><span>|</span><label class="collapse" for="c-38269684">[-]</label><label class="expand" for="c-38269684">[4 more]</label></div><br/><div class="children"><div class="content">Are new ISA solving this? Time to move to Risc V?</div><br/><div id="38270944" class="c"><input type="checkbox" id="c-38270944" checked=""/><div class="controls bullet"><span class="by">dontlaugh</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269684">parent</a><span>|</span><a href="#38270609">next</a><span>|</span><label class="collapse" for="c-38270944">[-]</label><label class="expand" for="c-38270944">[2 more]</label></div><br/><div class="children"><div class="content">RISC V is not great at this either, with the compression extension being common and variable length.<p>ARM 64 gets this right, with fixed length 32 bit instructions.</div><br/><div id="38273486" class="c"><input type="checkbox" id="c-38273486" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38270944">parent</a><span>|</span><a href="#38270609">next</a><span>|</span><label class="collapse" for="c-38273486">[-]</label><label class="expand" for="c-38273486">[1 more]</label></div><br/><div class="children"><div class="content">&gt;ARM 64 gets this right, with fixed length 32 bit instructions.<p>At the expense of code density, yet RISC-V is easy to decode, with implementations going up to 12-way decode (Veyron V2) despite variable length.<p>ARM64 hardly &quot;gets it right&quot;.</div><br/></div></div></div></div><div id="38270609" class="c"><input type="checkbox" id="c-38270609" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269684">parent</a><span>|</span><a href="#38270944">prev</a><span>|</span><a href="#38271878">next</a><span>|</span><label class="collapse" for="c-38270609">[-]</label><label class="expand" for="c-38270609">[1 more]</label></div><br/><div class="children"><div class="content">N&#x2F;A and No.</div><br/></div></div></div></div><div id="38271878" class="c"><input type="checkbox" id="c-38271878" checked=""/><div class="controls bullet"><span class="by">shadowgovt</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269562">parent</a><span>|</span><a href="#38269684">prev</a><span>|</span><a href="#38269857">next</a><span>|</span><label class="collapse" for="c-38271878">[-]</label><label class="expand" for="c-38271878">[1 more]</label></div><br/><div class="children"><div class="content">Usually, the historical reason is that adding the logic to do something well-defined when unexpected prefixes are used is going to cost ten more transistors per chip, which is going to add to cost to handle a corner case that almost nobody will try to be in anyway. Far better to let whatever the implementation does happen as long as what happens doesn&#x27;t break the system.<p>The issue here is their verification of possible internal CPU states didn&#x27;t account for this one.<p>(There is, perhaps, an argument to be made that the x86 architecture has become <i>so</i> complex that the emulator between its embarrassingly stupid PDP-11-style single-thread codeflow and the embarrassingly parallel computation it does under the hood to give the user more performance than a really fast PDP-11 <i>cannot</i> be reliably tested to exhaustion, so perhaps something needs to give on the design or the cost of the chips).</div><br/></div></div></div></div><div id="38269857" class="c"><input type="checkbox" id="c-38269857" checked=""/><div class="controls bullet"><span class="by">iforgotpassword</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269456">parent</a><span>|</span><a href="#38269562">prev</a><span>|</span><a href="#38269214">next</a><span>|</span><label class="collapse" for="c-38269857">[-]</label><label class="expand" for="c-38269857">[2 more]</label></div><br/><div class="children"><div class="content">Because they cost no&#x2F;less cycles compared to NOPs?</div><br/><div id="38270107" class="c"><input type="checkbox" id="c-38270107" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269857">parent</a><span>|</span><a href="#38269214">next</a><span>|</span><label class="collapse" for="c-38270107">[-]</label><label class="expand" for="c-38270107">[1 more]</label></div><br/><div class="children"><div class="content">See <a href="http:&#x2F;&#x2F;repzret.org&#x2F;p&#x2F;repzret&#x2F;" rel="nofollow noreferrer">http:&#x2F;&#x2F;repzret.org&#x2F;p&#x2F;repzret&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="38269214" class="c"><input type="checkbox" id="c-38269214" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38268787">parent</a><span>|</span><a href="#38268986">prev</a><span>|</span><a href="#38273653">next</a><span>|</span><label class="collapse" for="c-38269214">[-]</label><label class="expand" for="c-38269214">[2 more]</label></div><br/><div class="children"><div class="content">Well, the bug in this specific case (based on the article by Tavis O. linked elsewhere in comments) looks to be the regular kind -- probably an off-by-one in a microcode edge case. That is, here it&#x27;s <i>not</i> the case that the CPU functions correctly but leaves behind traces of things that should be private in timing side channels, as was the case for Spectre.</div><br/><div id="38270209" class="c"><input type="checkbox" id="c-38270209" checked=""/><div class="controls bullet"><span class="by">trebligdivad</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269214">parent</a><span>|</span><a href="#38273653">next</a><span>|</span><label class="collapse" for="c-38270209">[-]</label><label class="expand" for="c-38270209">[1 more]</label></div><br/><div class="children"><div class="content">Yeh just a fun bug rather than anything too fundamental.
Still, it is a fun bug.</div><br/></div></div></div></div><div id="38273653" class="c"><input type="checkbox" id="c-38273653" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38268787">parent</a><span>|</span><a href="#38269214">prev</a><span>|</span><a href="#38269017">next</a><span>|</span><label class="collapse" for="c-38273653">[-]</label><label class="expand" for="c-38273653">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is it even possible to design a cpu with out-of-order and speculative execution that would have no security issue?<p>Yes, of course. But we&#x27;d have to put actual effort in, and realistically people wouldn&#x27;t pay enough extra to make it worthwhile.</div><br/></div></div><div id="38269017" class="c"><input type="checkbox" id="c-38269017" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38268787">parent</a><span>|</span><a href="#38273653">prev</a><span>|</span><a href="#38268974">next</a><span>|</span><label class="collapse" for="c-38269017">[-]</label><label class="expand" for="c-38269017">[8 more]</label></div><br/><div class="children"><div class="content">I think formal methods could help designing of such machine, if you can write a mathematical statement that amounts to &quot;there is no side channel between A and B&quot;<p>Or at least put a practical bound on how many bits per second at most you can from any such side channel (the reasoning being, if you can get at most a bit for each million years, you probably don&#x27;t have an attack)<p>Then you verify if a given design meets this constraint</div><br/><div id="38269772" class="c"><input type="checkbox" id="c-38269772" checked=""/><div class="controls bullet"><span class="by">tsimionescu</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269017">parent</a><span>|</span><a href="#38269486">next</a><span>|</span><label class="collapse" for="c-38269772">[-]</label><label class="expand" for="c-38269772">[4 more]</label></div><br/><div class="children"><div class="content">Formal methods are widely used in processor design. It is hard to formalize specs to assert behaviors that bugs we haven&#x27;t thought about don&#x27;t exist. At least hard while also preserving the property of being a Turing machine.</div><br/><div id="38270269" class="c"><input type="checkbox" id="c-38270269" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269772">parent</a><span>|</span><a href="#38269486">next</a><span>|</span><label class="collapse" for="c-38270269">[-]</label><label class="expand" for="c-38270269">[3 more]</label></div><br/><div class="children"><div class="content">I know. I mean applying formal methods to this specific problem of proving side channels don&#x27;t exist (which seems a very hard thing to do and might even require to modify the whole design to be amenable to this analysis)</div><br/><div id="38270499" class="c"><input type="checkbox" id="c-38270499" checked=""/><div class="controls bullet"><span class="by">less_less</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38270269">parent</a><span>|</span><a href="#38269486">next</a><span>|</span><label class="collapse" for="c-38270499">[-]</label><label class="expand" for="c-38270499">[2 more]</label></div><br/><div class="children"><div class="content">As a tidbit, this was part of how one of the teams involved in the original Spectre paper found some of the vulnerabilities.  Basically the idea was to design a small CPU that could be formally shown to be free of certain timing attacks.  In the process they found a bunch of things that would have to change for the analysis to work... maybe in a small system those wouldn&#x27;t <i>actually</i> lead to vulnerabilities, but they couldn&#x27;t prove it (or it would require lots of careful analysis).  And in big systems, those features do lead to vulnerabilities.</div><br/><div id="38272332" class="c"><input type="checkbox" id="c-38272332" checked=""/><div class="controls bullet"><span class="by">nextaccountic</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38270499">parent</a><span>|</span><a href="#38269486">next</a><span>|</span><label class="collapse" for="c-38272332">[-]</label><label class="expand" for="c-38272332">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s amazing!<p>Do you have some link about the designed CPU?</div><br/></div></div></div></div></div></div></div></div><div id="38269486" class="c"><input type="checkbox" id="c-38269486" checked=""/><div class="controls bullet"><span class="by">bobim</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269017">parent</a><span>|</span><a href="#38269772">prev</a><span>|</span><a href="#38269452">next</a><span>|</span><label class="collapse" for="c-38269486">[-]</label><label class="expand" for="c-38269486">[2 more]</label></div><br/><div class="children"><div class="content">What would be the typical size of such a constraint-based problem, and do we have the compute power to translate the rules into an implementation? And what if one forgot a rule somewhereâ¦ Deeply interesting subject.</div><br/><div id="38270379" class="c"><input type="checkbox" id="c-38270379" checked=""/><div class="controls bullet"><span class="by">less_less</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269486">parent</a><span>|</span><a href="#38269452">next</a><span>|</span><label class="collapse" for="c-38270379">[-]</label><label class="expand" for="c-38270379">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;d want it to be a theorem (in Lean, Coq, Isabelle&#x2F;HOL or whatever) instead of a constraint problem.  So it would be more limited by developer effort than by computational power.<p>Theoretically you can do this from software down to (idealized) gates, but in practice the effort is so great that it&#x27;s only been done in extremely limited systems.</div><br/></div></div></div></div><div id="38269452" class="c"><input type="checkbox" id="c-38269452" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269017">parent</a><span>|</span><a href="#38269486">prev</a><span>|</span><a href="#38268974">next</a><span>|</span><label class="collapse" for="c-38269452">[-]</label><label class="expand" for="c-38269452">[1 more]</label></div><br/><div class="children"><div class="content">A program is itself a formal specification of what an algorithm does.</div><br/></div></div></div></div><div id="38268974" class="c"><input type="checkbox" id="c-38268974" checked=""/><div class="controls bullet"><span class="by">SmoothBrain12</span><span>|</span><a href="#38268787">parent</a><span>|</span><a href="#38269017">prev</a><span>|</span><a href="#38269673">next</a><span>|</span><label class="collapse" for="c-38268974">[-]</label><label class="expand" for="c-38268974">[4 more]</label></div><br/><div class="children"><div class="content">Yes, but they won&#x27;t clock as fast because they&#x27;ll be waiting for RAM.</div><br/><div id="38269536" class="c"><input type="checkbox" id="c-38269536" checked=""/><div class="controls bullet"><span class="by">bobim</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38268974">parent</a><span>|</span><a href="#38269673">next</a><span>|</span><label class="collapse" for="c-38269536">[-]</label><label class="expand" for="c-38269536">[3 more]</label></div><br/><div class="children"><div class="content">We need to keep programs small so they fit in the cache.</div><br/><div id="38269962" class="c"><input type="checkbox" id="c-38269962" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269536">parent</a><span>|</span><a href="#38269673">next</a><span>|</span><label class="collapse" for="c-38269962">[-]</label><label class="expand" for="c-38269962">[2 more]</label></div><br/><div class="children"><div class="content">We need 2 GBs of L1 cache, thus solving the cache miss problem once and for all.</div><br/><div id="38270016" class="c"><input type="checkbox" id="c-38270016" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269962">parent</a><span>|</span><a href="#38269673">next</a><span>|</span><label class="collapse" for="c-38270016">[-]</label><label class="expand" for="c-38270016">[1 more]</label></div><br/><div class="children"><div class="content">640K should be enough for anyone ;)</div><br/></div></div></div></div></div></div></div></div><div id="38269673" class="c"><input type="checkbox" id="c-38269673" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#38268787">parent</a><span>|</span><a href="#38268974">prev</a><span>|</span><a href="#38269799">next</a><span>|</span><label class="collapse" for="c-38269673">[-]</label><label class="expand" for="c-38269673">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Is the future leads to a swarm of disconnected A55 
    cores each running a single application?
</code></pre>
don&#x27;t you dare tease me like that</div><br/><div id="38270850" class="c"><input type="checkbox" id="c-38270850" checked=""/><div class="controls bullet"><span class="by">bobim</span><span>|</span><a href="#38268787">root</a><span>|</span><a href="#38269673">parent</a><span>|</span><a href="#38269799">next</a><span>|</span><label class="collapse" for="c-38270850">[-]</label><label class="expand" for="c-38270850">[1 more]</label></div><br/><div class="children"><div class="content">And programmed inâ¦ Forth!</div><br/></div></div></div></div></div></div><div id="38269799" class="c"><input type="checkbox" id="c-38269799" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#38268787">prev</a><span>|</span><a href="#38271474">next</a><span>|</span><label class="collapse" for="c-38269799">[-]</label><label class="expand" for="c-38269799">[1 more]</label></div><br/><div class="children"><div class="content">The REX prefix is redundant for &#x27;movsb&#x27;, but not &#x27;movsd&#x27;&#x2F;&#x27;movsq&#x27; (moving either 32- or 64-bit words, depending on the prefix). That may have something to do with the bug, if there is any shared microcode between those instructions?</div><br/></div></div><div id="38271474" class="c"><input type="checkbox" id="c-38271474" checked=""/><div class="controls bullet"><span class="by">farhanhubble</span><span>|</span><a href="#38269799">prev</a><span>|</span><a href="#38273375">next</a><span>|</span><label class="collapse" for="c-38271474">[-]</label><label class="expand" for="c-38271474">[2 more]</label></div><br/><div class="children"><div class="content">This is such an interesting read, right in the league of &quot;Smashing the stack&quot; and &quot;row hammer&quot;. As someone with very little knowledge of security I wonder if CPU designers do any kind of formal verification of the microcode architecture?</div><br/><div id="38273327" class="c"><input type="checkbox" id="c-38273327" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38271474">parent</a><span>|</span><a href="#38273375">next</a><span>|</span><label class="collapse" for="c-38273327">[-]</label><label class="expand" for="c-38273327">[1 more]</label></div><br/><div class="children"><div class="content">Yes.</div><br/></div></div></div></div><div id="38273375" class="c"><input type="checkbox" id="c-38273375" checked=""/><div class="controls bullet"><span class="by">asylteltine</span><span>|</span><a href="#38271474">prev</a><span>|</span><a href="#38268945">next</a><span>|</span><label class="collapse" for="c-38273375">[-]</label><label class="expand" for="c-38273375">[1 more]</label></div><br/><div class="children"><div class="content">Interesting write up. The submission needs a better and more accurate title though</div><br/></div></div><div id="38268945" class="c"><input type="checkbox" id="c-38268945" checked=""/><div class="controls bullet"><span class="by">tasty_freeze</span><span>|</span><a href="#38273375">prev</a><span>|</span><a href="#38269260">next</a><span>|</span><label class="collapse" for="c-38268945">[-]</label><label class="expand" for="c-38268945">[3 more]</label></div><br/><div class="children"><div class="content">Benchmarking is always problematic -- what is a good representative workload? All the same, I&#x27;d be curious if the ucode update that plugs this bug has affected CPU performance, eg, it diverts the &quot;fast short rep move&quot; path to just use the &quot;bad for short moves but great for long moves&quot; version.</div><br/><div id="38269277" class="c"><input type="checkbox" id="c-38269277" checked=""/><div class="controls bullet"><span class="by">akoboldfrying</span><span>|</span><a href="#38268945">parent</a><span>|</span><a href="#38270142">next</a><span>|</span><label class="collapse" for="c-38269277">[-]</label><label class="expand" for="c-38269277">[1 more]</label></div><br/><div class="children"><div class="content">In the article by Tavis O. linked elsewhere in comments, he suggests disabling the FSRM CPU feature <i>only as an expensive workaround</i> to be taken only if the microcode can&#x27;t be updated for some reason. That suggests to me that he, at least, expects the update to do better.</div><br/></div></div><div id="38270142" class="c"><input type="checkbox" id="c-38270142" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#38268945">parent</a><span>|</span><a href="#38269277">prev</a><span>|</span><a href="#38269260">next</a><span>|</span><label class="collapse" for="c-38270142">[-]</label><label class="expand" for="c-38270142">[1 more]</label></div><br/><div class="children"><div class="content">That would be the conservative thing to do. If there&#x27;s no limit on microcode updates, if I was Intel, I&#x27;d consider doing that first and then speeding it up again later. Based on the 5-second guess that people who update everything regularly will care that we did the right thing for security, and people who hate updates won&#x27;t be happy anyway, so at least the first update will be secure if they never get the next one.<p>(I think there is a limit on microcode, they seem conservative to release new ones - I don&#x27;t remember the details)</div><br/></div></div></div></div><div id="38269260" class="c"><input type="checkbox" id="c-38269260" checked=""/><div class="controls bullet"><span class="by">quietpain</span><span>|</span><a href="#38268945">prev</a><span>|</span><a href="#38271274">next</a><span>|</span><label class="collapse" for="c-38269260">[-]</label><label class="expand" for="c-38269260">[7 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    ...our validation pipeline produced an interesting assertion...
</code></pre>
What is a validation pipeline?</div><br/><div id="38269379" class="c"><input type="checkbox" id="c-38269379" checked=""/><div class="controls bullet"><span class="by">ForkMeOnTinder</span><span>|</span><a href="#38269260">parent</a><span>|</span><a href="#38269376">next</a><span>|</span><label class="collapse" for="c-38269379">[-]</label><label class="expand" for="c-38269379">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s described one paragraph earlier.<p>&gt; Iâve written previously about a processor validation technique called Oracle Serialization that weâve been using. The idea is to generate two forms of the same randomly generated program and verify their final state is identical.</div><br/><div id="38269576" class="c"><input type="checkbox" id="c-38269576" checked=""/><div class="controls bullet"><span class="by">1f60c</span><span>|</span><a href="#38269260">root</a><span>|</span><a href="#38269379">parent</a><span>|</span><a href="#38269376">next</a><span>|</span><label class="collapse" for="c-38269576">[-]</label><label class="expand" for="c-38269576">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like the real story should be that Google solved the halting problem. :-P</div><br/><div id="38269763" class="c"><input type="checkbox" id="c-38269763" checked=""/><div class="controls bullet"><span class="by">kadoban</span><span>|</span><a href="#38269260">root</a><span>|</span><a href="#38269576">parent</a><span>|</span><a href="#38269376">next</a><span>|</span><label class="collapse" for="c-38269763">[-]</label><label class="expand" for="c-38269763">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re free to solve the halting problem for restricted sets of programs, that doesn&#x27;t break any rules of the universe.<p>They also could be just discarding any where it runs for longer than X time, or a bunch of other possibilities.</div><br/></div></div></div></div></div></div><div id="38269376" class="c"><input type="checkbox" id="c-38269376" checked=""/><div class="controls bullet"><span class="by">tonfa</span><span>|</span><a href="#38269260">parent</a><span>|</span><a href="#38269379">prev</a><span>|</span><a href="#38269367">next</a><span>|</span><label class="collapse" for="c-38269376">[-]</label><label class="expand" for="c-38269376">[1 more]</label></div><br/><div class="children"><div class="content">The blog has a link to <a href="https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html#discovery" rel="nofollow noreferrer">https:&#x2F;&#x2F;lock.cmpxchg8b.com&#x2F;zenbleed.html#discovery</a> which presents the concept.</div><br/></div></div></div></div><div id="38271274" class="c"><input type="checkbox" id="c-38271274" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#38269260">prev</a><span>|</span><a href="#38269316">next</a><span>|</span><label class="collapse" for="c-38271274">[-]</label><label class="expand" for="c-38271274">[1 more]</label></div><br/><div class="children"><div class="content">I wonder which MCEs are being taken when this is triggered?</div><br/></div></div><div id="38270061" class="c"><input type="checkbox" id="c-38270061" checked=""/><div class="controls bullet"><span class="by">quotemstr</span><span>|</span><a href="#38269316">prev</a><span>|</span><a href="#38269512">next</a><span>|</span><label class="collapse" for="c-38270061">[-]</label><label class="expand" for="c-38270061">[1 more]</label></div><br/><div class="children"><div class="content">If the problem really is that the processor is confused about instruction length, I&#x27;m impressed that this problem can be fixed in microcode without a huge performance hit: my intuition (which could be totally wrong) is that computing the length of an instruction would be something synthesized directly to logic gates.<p>Actually, come to think of it, my hunch is that the uOP decoder (presumably in hardware) is actually fine and that the microcoded optimized copy routine is trying to infer things about the uOP stream that just aren&#x27;t true --- &quot;Oh, this is a rep mov, so of course I need to go backward two uOPs to loop&quot; or something.<p>I expect Intel&#x27;s CPU team isn&#x27;t going to divulge the details though. :-)</div><br/></div></div><div id="38269512" class="c"><input type="checkbox" id="c-38269512" checked=""/><div class="controls bullet"><span class="by">blauditore</span><span>|</span><a href="#38270061">prev</a><span>|</span><a href="#38268672">next</a><span>|</span><label class="collapse" for="c-38269512">[-]</label><label class="expand" for="c-38269512">[5 more]</label></div><br/><div class="children"><div class="content">Can someone give a TL;DR for non-CPU experts? All technical articles seem pretty long and&#x2F;or complex.</div><br/><div id="38269827" class="c"><input type="checkbox" id="c-38269827" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#38269512">parent</a><span>|</span><a href="#38269565">next</a><span>|</span><label class="collapse" for="c-38269827">[-]</label><label class="expand" for="c-38269827">[3 more]</label></div><br/><div class="children"><div class="content">x86 has a builtin memory copy instruction, provided by the combination of the movsb instruction and a rep <i>prefix byte</i>, that says you want the instruction to run in a loop until it runs out data to copy. This is &quot;rep movsb&quot;. This instruction is fairly old, meaning a lot of code still has it, even though there&#x27;s faster ways to copy memory in x86.<p>Intel added two features to modern x86 chips that detects rep movsb and accelerates it to be as fast as those other ways. However, those features have a bug. You see, because rep is a prefix byte, you can just keep adding more prefix bytes to the instruction (up to a maximum of 16 AFAIK). x86 has other prefix bytes too, such as rex (used to access registers 8-16), vex, evex, etc. The part of the processor that recognizes a rep movsb does NOT account for these other prefix bytes, which makes the processor get confused in ways that are difficult to understand. The processor can start executing garbage, take the wrong branch in if statements, and so on.<p>Most disturbingly, when multiple physical cores are executing these &quot;rep rep rep rep movsb&quot; instructions at the same time, they will start generating machine check exceptions, which can at worst force a physical machine reboot. This is very bad for Google because they rent out compute time to different companies and they all need to be able to share the same machine. They don&#x27;t want some prankster running these instructions and killing someone else&#x27;s compute jobs. We call this a &quot;Denial of Service&quot; vulnerability because, while I can&#x27;t read someone else&#x27;s computations or change them, I <i>can</i> keep them from completing, which is just as bad.</div><br/><div id="38270116" class="c"><input type="checkbox" id="c-38270116" checked=""/><div class="controls bullet"><span class="by">BlueTemplar</span><span>|</span><a href="#38269512">root</a><span>|</span><a href="#38269827">parent</a><span>|</span><a href="#38269565">next</a><span>|</span><label class="collapse" for="c-38270116">[-]</label><label class="expand" for="c-38270116">[2 more]</label></div><br/><div class="children"><div class="content">&gt; they all need to be able to share the same machine<p>Do they ? As these issues keep piling up, it just seems that it&#x27;s not worth the hassle, and they should instead never do sharing like this...</div><br/><div id="38270217" class="c"><input type="checkbox" id="c-38270217" checked=""/><div class="controls bullet"><span class="by">jrockway</span><span>|</span><a href="#38269512">root</a><span>|</span><a href="#38270116">parent</a><span>|</span><a href="#38269565">next</a><span>|</span><label class="collapse" for="c-38270217">[-]</label><label class="expand" for="c-38270217">[1 more]</label></div><br/><div class="children"><div class="content">To some extent, anyone with a web browser is sharing their machine with other people.  That&#x27;s Javascript.<p>If you ever download untrustworthy code and run it in a VM to protect your main set of data, that&#x27;s another case.<p>The success of cloud computing is from the idea that multiple people can share the same computer.  You only need one core, but CPUs come with 128, but with the cloud you can buy just that one core and share 1&#x2F;128th of the power supply, rack space, motherboard, ethernet cable, sysadmin time, etc. and that reduces your costs.  That assumption is all based on virtualization working, though; nobody wants 1&#x2F;128th of someone else&#x27;s computer, they want their own computer that&#x27;s 1&#x2F;128th as fast.  Bugs like these demonstrate that you&#x27;re just sharing a computer with someone, which is bad for the business of cloud providers.</div><br/></div></div></div></div></div></div><div id="38269565" class="c"><input type="checkbox" id="c-38269565" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#38269512">parent</a><span>|</span><a href="#38269827">prev</a><span>|</span><a href="#38268672">next</a><span>|</span><label class="collapse" for="c-38269565">[-]</label><label class="expand" for="c-38269565">[1 more]</label></div><br/><div class="children"><div class="content">Some x86 instructions can have prefixes that modify their behavior in a meaningful way. Such a prefix can be applied generally to any instruction, but it&#x27;s expected to have no effect when applied to an instruction it doesn&#x27;t make sense with. But it turns out the CPU actually misbehaves in some cases when this is done. Intel released a CPU firmware update to fix it.</div><br/></div></div></div></div><div id="38268672" class="c"><input type="checkbox" id="c-38268672" checked=""/><div class="controls bullet"><span class="by">Flow</span><span>|</span><a href="#38269512">prev</a><span>|</span><a href="#38268638">next</a><span>|</span><label class="collapse" for="c-38268672">[-]</label><label class="expand" for="c-38268672">[6 more]</label></div><br/><div class="children"><div class="content">Would be possible to describe a modern CPU in something like TLA+ to find all non-electrical problems like these?</div><br/><div id="38268921" class="c"><input type="checkbox" id="c-38268921" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#38268672">parent</a><span>|</span><a href="#38269323">next</a><span>|</span><label class="collapse" for="c-38268921">[-]</label><label class="expand" for="c-38268921">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard Intel does use TLA+ extensively for specifying their designs and verifying their specs. But TLA+ specs are extremely high-level, so they don&#x27;t capture implementation details that can lead to bugs. And model checking isn&#x27;t a formal proof, only (tractably small) finite state spaces can be checked with TLC. And even there, you&#x27;re only checking the invariants you specified.<p>That said, I&#x27;m sure there&#x27;s some verification framework like SPARK for VHDL, and this feels like exactly the kind of thing it should catch.</div><br/></div></div><div id="38269323" class="c"><input type="checkbox" id="c-38269323" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38268672">parent</a><span>|</span><a href="#38268921">prev</a><span>|</span><a href="#38271897">next</a><span>|</span><label class="collapse" for="c-38269323">[-]</label><label class="expand" for="c-38269323">[1 more]</label></div><br/><div class="children"><div class="content">Formal methods have been used in CPU design for nearly 40 years [1] but not yet for everything, and the methods tend to not have &quot;round-trip-engineering&quot; properties (e.g. TLA+ is not actually proving validity of the code you will run in production, just your description of its behavior and your idea of exhaustive test cases).<p>[1] <a href="https:&#x2F;&#x2F;www.academia.edu&#x2F;60937699&#x2F;The_IMS_T_800_Transputer" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.academia.edu&#x2F;60937699&#x2F;The_IMS_T_800_Transputer</a></div><br/></div></div><div id="38271897" class="c"><input type="checkbox" id="c-38271897" checked=""/><div class="controls bullet"><span class="by">foobiekr</span><span>|</span><a href="#38268672">parent</a><span>|</span><a href="#38269323">prev</a><span>|</span><a href="#38268746">next</a><span>|</span><label class="collapse" for="c-38271897">[-]</label><label class="expand" for="c-38271897">[1 more]</label></div><br/><div class="children"><div class="content">CPU designers are so professional about verification and specification that they _dwarf_ software. There&#x27;s just no comparison.</div><br/></div></div><div id="38268746" class="c"><input type="checkbox" id="c-38268746" checked=""/><div class="controls bullet"><span class="by">boxfire</span><span>|</span><a href="#38268672">parent</a><span>|</span><a href="#38271897">prev</a><span>|</span><a href="#38268638">next</a><span>|</span><label class="collapse" for="c-38268746">[-]</label><label class="expand" for="c-38268746">[2 more]</label></div><br/><div class="children"><div class="content">There are still bit flipping tricks like rowhammer for RAM, I wouldn&#x27;t be surprised if there are such vulnerabilities in some CPUs.</div><br/><div id="38268927" class="c"><input type="checkbox" id="c-38268927" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#38268672">root</a><span>|</span><a href="#38268746">parent</a><span>|</span><a href="#38268638">next</a><span>|</span><label class="collapse" for="c-38268927">[-]</label><label class="expand" for="c-38268927">[1 more]</label></div><br/><div class="children"><div class="content">Rowhammer is an electrical vulnerability though. PP specified non-electrical vulns.</div><br/></div></div></div></div></div></div><div id="38268638" class="c"><input type="checkbox" id="c-38268638" checked=""/><div class="controls bullet"><span class="by">varispeed</span><span>|</span><a href="#38268672">prev</a><span>|</span><a href="#38268566">next</a><span>|</span><label class="collapse" for="c-38268638">[-]</label><label class="expand" for="c-38268638">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s going to be a pain for cloud and shared hosting.<p>Most likely dedicated resources on demand will be the future. Some companies already offer it.</div><br/></div></div><div id="38268566" class="c"><input type="checkbox" id="c-38268566" checked=""/><div class="controls bullet"><span class="by">doublerabbit</span><span>|</span><a href="#38268638">prev</a><span>|</span><a href="#38269147">next</a><span>|</span><label class="collapse" for="c-38268566">[-]</label><label class="expand" for="c-38268566">[4 more]</label></div><br/><div class="children"><div class="content">Any reason to why its named after the dinosaur from the cartoon Rugrats? Or was that what was on TV at the time?<p>Maybe I should start hacking while watching Teenage Mutant Ninja Turtles.</div><br/><div id="38269588" class="c"><input type="checkbox" id="c-38269588" checked=""/><div class="controls bullet"><span class="by">AdmiralAsshat</span><span>|</span><a href="#38268566">parent</a><span>|</span><a href="#38268730">next</a><span>|</span><label class="collapse" for="c-38269588">[-]</label><label class="expand" for="c-38269588">[1 more]</label></div><br/><div class="children"><div class="content">If you discover a major processor vulnerability and wanna name it Shredder&#x2F;Krang&#x2F;Bebop&#x2F;Rocksteady, I feel like you will have earned that right!</div><br/></div></div><div id="38268730" class="c"><input type="checkbox" id="c-38268730" checked=""/><div class="controls bullet"><span class="by">Blackthorn</span><span>|</span><a href="#38268566">parent</a><span>|</span><a href="#38269588">prev</a><span>|</span><a href="#38268663">next</a><span>|</span><label class="collapse" for="c-38268730">[-]</label><label class="expand" for="c-38268730">[1 more]</label></div><br/><div class="children"><div class="content">I think from the memey line &quot;Halt! I am Reptar!&quot; Plus the rep prefix</div><br/></div></div><div id="38268663" class="c"><input type="checkbox" id="c-38268663" checked=""/><div class="controls bullet"><span class="by">2OEH8eoCRo0</span><span>|</span><a href="#38268566">parent</a><span>|</span><a href="#38268730">prev</a><span>|</span><a href="#38269147">next</a><span>|</span><label class="collapse" for="c-38268663">[-]</label><label class="expand" for="c-38268663">[1 more]</label></div><br/><div class="children"><div class="content">rep is an assembly instruction prefix</div><br/></div></div></div></div><div id="38269147" class="c"><input type="checkbox" id="c-38269147" checked=""/><div class="controls bullet"><span class="by">frontalier</span><span>|</span><a href="#38268566">prev</a><span>|</span><a href="#38269309">next</a><span>|</span><label class="collapse" for="c-38269147">[-]</label><label class="expand" for="c-38269147">[2 more]</label></div><br/><div class="children"><div class="content">The date on the article is for tomorrow?</div><br/><div id="38269664" class="c"><input type="checkbox" id="c-38269664" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#38269147">parent</a><span>|</span><a href="#38269309">next</a><span>|</span><label class="collapse" for="c-38269664">[-]</label><label class="expand" for="c-38269664">[1 more]</label></div><br/><div class="children"><div class="content">Cereal Killer: Check this out, it&#x27;s a memo about how they&#x27;re gonna deal with those oil spills on the 14th.<p>Acid Burn: What oil spills?<p>Lord Nikon: Yo, brain dead, today&#x27;s the 13th.<p>Cereal Killer: Whoa, this hasn&#x27;t happened yet!</div><br/></div></div></div></div><div id="38269309" class="c"><input type="checkbox" id="c-38269309" checked=""/><div class="controls bullet"><span class="by">yodon</span><span>|</span><a href="#38269147">prev</a><span>|</span><a href="#38269261">next</a><span>|</span><label class="collapse" for="c-38269309">[-]</label><label class="expand" for="c-38269309">[2 more]</label></div><br/><div class="children"><div class="content">Dupe: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38268043">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38268043</a><p>(As of this writing, this post has more votes, the other has more comments)</div><br/><div id="38269941" class="c"><input type="checkbox" id="c-38269941" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38269309">parent</a><span>|</span><a href="#38269261">next</a><span>|</span><label class="collapse" for="c-38269941">[-]</label><label class="expand" for="c-38269941">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ll merge that one hither. Please stand by!</div><br/></div></div></div></div><div id="38269803" class="c"><input type="checkbox" id="c-38269803" checked=""/><div class="controls bullet"><span class="by">ZoomerCretin</span><span>|</span><a href="#38269261">prev</a><span>|</span><label class="collapse" for="c-38269803">[-]</label><label class="expand" for="c-38269803">[6 more]</label></div><br/><div class="children"><div class="content">Intel is a known partner of the NSA. If Intel was intentionally creating backdoors at the behest of the NSA, how would they look different from this vulnerability and the many other discovered vulnerabilities before it?</div><br/><div id="38269990" class="c"><input type="checkbox" id="c-38269990" checked=""/><div class="controls bullet"><span class="by">thelittleone</span><span>|</span><a href="#38269803">parent</a><span>|</span><a href="#38269948">next</a><span>|</span><label class="collapse" for="c-38269990">[-]</label><label class="expand" for="c-38269990">[2 more]</label></div><br/><div class="children"><div class="content">But so is Google. It would be some very crafty theatrics if it&#x27;s all coordinated.</div><br/><div id="38272923" class="c"><input type="checkbox" id="c-38272923" checked=""/><div class="controls bullet"><span class="by">ZoomerCretin</span><span>|</span><a href="#38269803">root</a><span>|</span><a href="#38269990">parent</a><span>|</span><a href="#38269948">next</a><span>|</span><label class="collapse" for="c-38272923">[-]</label><label class="expand" for="c-38272923">[1 more]</label></div><br/><div class="children"><div class="content">Only the people inserting the backdoor or using it would need to be bound by a National Security Letter&#x27;s gag order. I doubt anyone at Google (including those subject to NSL gag orders) was made aware of this specific vulnerability.<p># Googleâs commitment to collaboration and hardware security<p>## As Reptar, Zenbleed, and Downfall suggest, computing hardware and processors remain susceptible to these types of vulnerabilities. This trend will only continue as hardware becomes increasingly complex. This is why Google continues to invest heavily in CPU and vulnerability research. Work like this, done in close collaboration with our industry partners, allows us to keep users safe and is critical to finding and mitigating vulnerabilities before they can be exploited.<p>There&#x27;s a tension between the NSA wanting backdoors and service providers (CPU designers + Cloud hosting) wanting secure platforms. It&#x27;s possible that by employing CPU and security researchers, Google can tip the scales a bit further in their favor.</div><br/></div></div></div></div><div id="38269948" class="c"><input type="checkbox" id="c-38269948" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#38269803">parent</a><span>|</span><a href="#38269990">prev</a><span>|</span><a href="#38270138">next</a><span>|</span><label class="collapse" for="c-38269948">[-]</label><label class="expand" for="c-38269948">[1 more]</label></div><br/><div class="children"><div class="content">My guess is that it would be something that could be exploited via JavaScript. And no JIT would emit an instruction like the one that causes this bug.</div><br/></div></div><div id="38270138" class="c"><input type="checkbox" id="c-38270138" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38269803">parent</a><span>|</span><a href="#38269948">prev</a><span>|</span><a href="#38270078">next</a><span>|</span><label class="collapse" for="c-38270138">[-]</label><label class="expand" for="c-38270138">[1 more]</label></div><br/><div class="children"><div class="content">How would you distinguish this backdoor from one inserted by an unknown partner of the NSA?</div><br/></div></div><div id="38270078" class="c"><input type="checkbox" id="c-38270078" checked=""/><div class="controls bullet"><span class="by">gosub100</span><span>|</span><a href="#38269803">parent</a><span>|</span><a href="#38270138">prev</a><span>|</span><label class="collapse" for="c-38270078">[-]</label><label class="expand" for="c-38270078">[1 more]</label></div><br/><div class="children"><div class="content">the backdoor would just be an encrypted stream of &quot;random&quot; data flowing right out the RNG. there&#x27;s some maxim of crypto that encrypted data is indistinguishable from random bytes.</div><br/></div></div></div></div></div></div></div></div></div></body></html>