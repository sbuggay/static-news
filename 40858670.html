<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719997253630" as="style"/><link rel="stylesheet" href="styles.css?v=1719997253630"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rybicki.io/blog/2024/06/30/biphasic-programming.html">Exploring biphasic programming: a new approach in language design</a> <span class="domain">(<a href="https://rybicki.io">rybicki.io</a>)</span></div><div class="subtext"><span>chriscbr</span> | <span>50 comments</span></div><br/><div><div id="40861801" class="c"><input type="checkbox" id="c-40861801" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#40863027">next</a><span>|</span><label class="collapse" for="c-40861801">[-]</label><label class="expand" for="c-40861801">[1 more]</label></div><br/><div class="children"><div class="content">This is already known as &quot;multi-stage programming&quot; or &quot;staged programming&quot; -- I don&#x27;t see a need for a new term<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multi-stage_programming" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multi-stage_programming</a><p><a href="https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;meta-programming&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;okmij.org&#x2F;ftp&#x2F;meta-programming&#x2F;index.html</a><p>Comment from 2019 about it, which mentions Zig, Terra&#x2F;Lua, Scala LMS, etc.:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19013437">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19013437</a><p>We should also mention big data frameworks and ML frameworks like TensorFlow &#x2F; Pytorch.<p>The &quot;eager mode&quot; that Chris Lattner wanted in Swift for ML and Mojo is to actually to get rid of the separation between the stage of creating a graph of operators (in Python, serially) and then evaluating the graph (on GPUs, in parallel).<p>And also CMake&#x2F;Make and even autoconf&#x2F;make and Bazel have stages -- &quot;programming&quot; a graph, and then executing it in parallel:<p><i>Language Design: Staged Execution Models</i> - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2021&#x2F;04&#x2F;build-ci-comments.html#language-design-staged-execution-models" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2021&#x2F;04&#x2F;build-ci-comments.html...</a></div><br/></div></div><div id="40863027" class="c"><input type="checkbox" id="c-40863027" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#40861801">prev</a><span>|</span><a href="#40860692">next</a><span>|</span><label class="collapse" for="c-40863027">[-]</label><label class="expand" for="c-40863027">[4 more]</label></div><br/><div class="children"><div class="content">Like the other comment mentioned, this is staging.<p>&gt; And compared to Lisps like Scheme and Racket which support hygenic macros, well, Zig doesn’t require everything to be a list.<p>This comment is a bit ignorant. Racket has the most advanced staging system of any language that I&#x27;m aware of. You can build languages in Racket with conventional yet extensible syntax: <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;rhombus&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;rhombus&#x2F;index.html</a> Zig&#x27;s metaprogramming facilities are very simple in comparison.<p>I think staging could be extremely useful in many application, and I wish it was better supported in mainstream langauges.</div><br/><div id="40863455" class="c"><input type="checkbox" id="c-40863455" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40863027">parent</a><span>|</span><a href="#40860692">next</a><span>|</span><label class="collapse" for="c-40863455">[-]</label><label class="expand" for="c-40863455">[3 more]</label></div><br/><div class="children"><div class="content">I guess accusing Lisps of only supporting lists as their data structures has the pedigree of a long established tradition by now?  (Though I wish they would at least accuse them of everything having to be cons-pairs.)</div><br/><div id="40863851" class="c"><input type="checkbox" id="c-40863851" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#40863027">root</a><span>|</span><a href="#40863455">parent</a><span>|</span><a href="#40860692">next</a><span>|</span><label class="collapse" for="c-40863851">[-]</label><label class="expand" for="c-40863851">[2 more]</label></div><br/><div class="children"><div class="content">My programs are single atoms</div><br/><div id="40863879" class="c"><input type="checkbox" id="c-40863879" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#40863027">root</a><span>|</span><a href="#40863851">parent</a><span>|</span><a href="#40860692">next</a><span>|</span><label class="collapse" for="c-40863879">[-]</label><label class="expand" for="c-40863879">[1 more]</label></div><br/><div class="children"><div class="content">I thought the whole point of Lisp was that it allows you to compose bigger programs out of smaller pieces?</div><br/></div></div></div></div></div></div></div></div><div id="40860692" class="c"><input type="checkbox" id="c-40860692" checked=""/><div class="controls bullet"><span class="by">taliesinb</span><span>|</span><a href="#40863027">prev</a><span>|</span><a href="#40862463">next</a><span>|</span><label class="collapse" for="c-40860692">[-]</label><label class="expand" for="c-40860692">[5 more]</label></div><br/><div class="children"><div class="content">The end-game is just dissolving any distinction between compile-time and run-time. Other examples of dichotomies that could be partially dissolved by similar kinds of universal acid:<p>* dynamic typing vs static typing, a continuum that JIT-ing and compiling attack from either end -- in some sense dynamically typed programs are ALSO statically typed -- with all function types are being dependent function types and all value types being sum types. After all, a term of a dependent sum, a dependent pair, <i>is</i> just a boxed value.<p>* monomorphisation vs polymorphism-via-vtables&#x2F;interfaces&#x2F;protocols, which trade roughly speaking instruction cache density for data cache density<p>* RC vs GC vs heap allocation via compiler-assisted proof of memory ownership relationships of how this is supposed to happen<p>* privileging the stack and instruction pointer rather than making this kind of transient program state a first-class data structure like any other, to enable implementing your own co-routines and whatever else. an analogous situation: Zig deciding that memory allocation should NOT be so privileged as to be an &quot;invisible facility&quot; one assumes is global.<p>* privileging <i>pointers</i> themselves as a global type constructor rather than as typeclasses. we could have pointer-using functions that transparently monomorphize in more efficient ways when you happen to know how many items you need and how they can be accessed, owned, allocated, and de-allocated. global heap pointers waste <i>so</i> much space.<p>Instead, one would have code for which it makes more or less sense to spend time optimizing in ways that privilege memory usage, execution efficiency, instruction density, clarity of denotational semantics, etc, etc, etc.<p>Currently, we have these weird siloed ways of doing <i>certain</i> kinds of privileging in <i>certain</i> languages with rather arbitrary boundaries for how far you can go. I hope one day we have languages that just dissolve all of this decision making and engineering into universal facilities in which the language can be anything you need it to be -- it&#x27;s just a neutral substrate for expressing computation and how you want to produce machine artifacts that can be run in various ways.<p>Presumably a future language like this, if it ever exists, would descend from one of today&#x27;s proof assistants.</div><br/><div id="40861409" class="c"><input type="checkbox" id="c-40861409" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#40860692">parent</a><span>|</span><a href="#40863076">next</a><span>|</span><label class="collapse" for="c-40861409">[-]</label><label class="expand" for="c-40861409">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The end-game is just dissolving any distinction between compile-time and run-time<p>This was done in the 60s&#x2F;70s with FORTH and LISP to some degree, with the former being closer to what you&#x27;re referring to. FORTH programs are typically <i>images</i> of partial applications state that can be thought of as a pile of expanded macros and defined values&#x2F;constants (though there&#x27;s virtually no guardrails).<p>That being said, I largely agree with you on several of these and think would like to take it one step further: I would like a language with 99% bounded execution time and memory usage. The last 1% is to allow for daemon-like processes that handle external events in an &quot;endless&quot; loop and that&#x27;s it. I don&#x27;t really care how restricted the language is to achieve that, I&#x27;m confident the ergonomics <i>can</i> be made to be pleasant to work with.</div><br/><div id="40862536" class="c"><input type="checkbox" id="c-40862536" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#40860692">root</a><span>|</span><a href="#40861409">parent</a><span>|</span><a href="#40863076">next</a><span>|</span><label class="collapse" for="c-40862536">[-]</label><label class="expand" for="c-40862536">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that would be cool. For bounded execution, you should look at “total functional programming” (which always terminates).<p>They have this concept of codata for the other 1% to make practical, interactive apps - codata represents things like event streams.</div><br/></div></div></div></div><div id="40863076" class="c"><input type="checkbox" id="c-40863076" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#40860692">parent</a><span>|</span><a href="#40861409">prev</a><span>|</span><a href="#40862463">next</a><span>|</span><label class="collapse" for="c-40863076">[-]</label><label class="expand" for="c-40863076">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The end-game is just dissolving any distinction between compile-time and run-time.<p>I don&#x27;t think this is actually desireable. This is what Smalltalk did, and the problem is it&#x27;s very hard to understand what a program does when any part of it can change at any time. This is problem for both compilers and programmers.<p>It&#x27;s better, IMO, to be able to explicitly state the stages of the program, rather than have two (compile-time and run-time) or one (interpreted languages). As a simple example, I want to be able to say &quot;the configuration loads before the main program runs&quot;, so that the configuration values can be inlined into the main program as they are constant at that point.</div><br/><div id="40863598" class="c"><input type="checkbox" id="c-40863598" checked=""/><div class="controls bullet"><span class="by">larsrc</span><span>|</span><a href="#40860692">root</a><span>|</span><a href="#40863076">parent</a><span>|</span><a href="#40862463">next</a><span>|</span><label class="collapse" for="c-40863598">[-]</label><label class="expand" for="c-40863598">[1 more]</label></div><br/><div class="children"><div class="content">There are pretty important reasons to have this distinction. You want to be able to reason about what code actually gets executed and where. Supply-chain attacks will only get easier if this line gets blurred, and build systems work better when the compile stage is well-defined.</div><br/></div></div></div></div></div></div><div id="40862463" class="c"><input type="checkbox" id="c-40862463" checked=""/><div class="controls bullet"><span class="by">thelittlenag</span><span>|</span><a href="#40860692">prev</a><span>|</span><a href="#40862642">next</a><span>|</span><label class="collapse" for="c-40862463">[-]</label><label class="expand" for="c-40862463">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been thinking similar thoughts recently since I&#x27;ve been exploring metaprogramming in Scala and how it can be extended to beyond the simplistic hygenic model it currently supports.<p>What I recently realized is that while compilers in the standard perspective process a language into an AST, do some transformations, and then output some kind of executable, from another perspective they are really no different than interpreters for a DSL.<p>There tends to be this big divide between what we call a compiler and what we call an interpreter. And we classify languages as being either interpreted or compiled.<p>But what I realized, as I&#x27;m sure many others have before me, is that that distinction is very thin.<p>What I mean is this: from a certain perspective a compiler is really just an interpreter for the meta language that encodes and hosts the compiled language. The meta-language directs the compiler, generally via statements, to synthesize blocks of code, create classes with particular shapes, and eventually write out certain files. These meta-languages don&#x27;t support functions, or control flow, or variables, in fact they are entirely declarative languages. And yet they are the same as the normal language being compiled.<p>To a certain degree I think the biphasic model captures this distinction well. Our execution&#x2F;compilation models for languages don&#x27;t tend to capture and differentiate interpreter+script from os+compiled-binary very well. Or where they do they tend to make metaprogramming very difficult. I think finding a way to unify those notions will help languages if and when they add support for metaprogramming.</div><br/><div id="40863032" class="c"><input type="checkbox" id="c-40863032" checked=""/><div class="controls bullet"><span class="by">webnrrd2k</span><span>|</span><a href="#40862463">parent</a><span>|</span><a href="#40862642">next</a><span>|</span><label class="collapse" for="c-40863032">[-]</label><label class="expand" for="c-40863032">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d really enjoy The Structure and Interpretation of Computer Programs. One of the big lessons is that it&#x27;s basically interpreters all the way down.<p>Even hardware is, at some point, &quot;programmed&quot; by someone to behave a certain way.</div><br/></div></div></div></div><div id="40862642" class="c"><input type="checkbox" id="c-40862642" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#40862463">prev</a><span>|</span><a href="#40860823">next</a><span>|</span><label class="collapse" for="c-40862642">[-]</label><label class="expand" for="c-40862642">[1 more]</label></div><br/><div class="children"><div class="content">A question to the author, about a choice in language design.<p><pre><code>  &#x2F;&#x2F; Import some libraries.
  bring s3;
</code></pre>
If the keyword was the usual &quot;import&quot; there would be no need to explain what &quot;bring&quot; is. Or, if &quot;bring&quot; is so good, why not<p><pre><code>  &#x2F;&#x2F; Bring some libraries.

?</code></pre></div><br/></div></div><div id="40860823" class="c"><input type="checkbox" id="c-40860823" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#40862642">prev</a><span>|</span><a href="#40860263">next</a><span>|</span><label class="collapse" for="c-40860823">[-]</label><label class="expand" for="c-40860823">[1 more]</label></div><br/><div class="children"><div class="content">This is also a special case of what MetaOCaml calls multi-stage programming. It does not only support two phases but arbitrary many. Some similar prototype also exists for some older Scala version. And Lisp and Forth obviously also support n-phases of computation.</div><br/></div></div><div id="40860263" class="c"><input type="checkbox" id="c-40860263" checked=""/><div class="controls bullet"><span class="by">cobbal</span><span>|</span><a href="#40860823">prev</a><span>|</span><a href="#40860171">next</a><span>|</span><label class="collapse" for="c-40860263">[-]</label><label class="expand" for="c-40860263">[1 more]</label></div><br/><div class="children"><div class="content">Racket has a sophisticated system for dealing with phases in its macro system: <a href="https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;phases.html" rel="nofollow">https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;guide&#x2F;phases.html</a> I don&#x27;t know if other schemes use a similar system.</div><br/></div></div><div id="40860171" class="c"><input type="checkbox" id="c-40860171" checked=""/><div class="controls bullet"><span class="by">warpspin</span><span>|</span><a href="#40860263">prev</a><span>|</span><a href="#40861248">next</a><span>|</span><label class="collapse" for="c-40860171">[-]</label><label class="expand" for="c-40860171">[9 more]</label></div><br/><div class="children"><div class="content">He missed one of the earliest examples of &quot;languages and frameworks that enable identical syntax to express computations executed in two distinct phases&quot; - immediate words in Forth: <a href="https:&#x2F;&#x2F;www.forth.com&#x2F;starting-forth&#x2F;11-forth-compiler-defining-words&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.forth.com&#x2F;starting-forth&#x2F;11-forth-compiler-defin...</a></div><br/><div id="40860565" class="c"><input type="checkbox" id="c-40860565" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#40860171">parent</a><span>|</span><a href="#40860198">next</a><span>|</span><label class="collapse" for="c-40860565">[-]</label><label class="expand" for="c-40860565">[2 more]</label></div><br/><div class="children"><div class="content">Immediate words don’t cover the <i>“while maintaining consistent behavior (i.e., semantics) across phases”</i> of the definition given, do they?<p>I think normal forth words are way closer to that. They (1) normally just do whatever their definition implies, but inside a colon definition, they (1) compile code that does whatever their definition implies.<p>They do miss C++ <i>constexpr</i> (<a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;constexpr" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;constexpr</a>). I haven’t read Zig docs, but that seems highly similar to Zig’s <i>comptime</i> to me.<p>(1) technically, it’s not “they” doing that themselves but whatever code processes them.</div><br/><div id="40860785" class="c"><input type="checkbox" id="c-40860785" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40860171">root</a><span>|</span><a href="#40860565">parent</a><span>|</span><a href="#40860198">next</a><span>|</span><label class="collapse" for="c-40860785">[-]</label><label class="expand" for="c-40860785">[1 more]</label></div><br/><div class="children"><div class="content">yeah, the forth feature that actually does this is not immediate words in general, but the two immediate words [ and ], which allow you to do arbitrary ad hoc computations at compile time instead of at run time<p>but also you can just put the code you would have put between the [ ] delimiter words into an immediate word, and call it where you would have put the [ ] block.  the effect is not <i>exactly</i> the same but it has semantics slightly more consistent with the usual semantics because your immediate word is in fact compiled just like non-immediate words are</div><br/></div></div></div></div><div id="40860198" class="c"><input type="checkbox" id="c-40860198" checked=""/><div class="controls bullet"><span class="by">Munksgaard</span><span>|</span><a href="#40860171">parent</a><span>|</span><a href="#40860565">prev</a><span>|</span><a href="#40861248">next</a><span>|</span><label class="collapse" for="c-40860198">[-]</label><label class="expand" for="c-40860198">[6 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m missing something, but isn&#x27;t Lisp the original version of this?</div><br/><div id="40860532" class="c"><input type="checkbox" id="c-40860532" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#40860171">root</a><span>|</span><a href="#40860198">parent</a><span>|</span><a href="#40860257">next</a><span>|</span><label class="collapse" for="c-40860532">[-]</label><label class="expand" for="c-40860532">[1 more]</label></div><br/><div class="children"><div class="content">Pretty much. And not just via macros.<p>Lisp languages tend to blend together &quot;runtime&quot; with &quot;load time&quot;, and in case of compiled languages, also &quot;compile time&quot;. You can write code executing during any one, or any combination of, these phases. You can reuse code between those phases. You can interleave them at will - e.g. by loading more code at runtime, or invoking a compiler, etc.</div><br/></div></div><div id="40860257" class="c"><input type="checkbox" id="c-40860257" checked=""/><div class="controls bullet"><span class="by">warpspin</span><span>|</span><a href="#40860171">root</a><span>|</span><a href="#40860198">parent</a><span>|</span><a href="#40860532">prev</a><span>|</span><a href="#40860792">next</a><span>|</span><label class="collapse" for="c-40860257">[-]</label><label class="expand" for="c-40860257">[3 more]</label></div><br/><div class="children"><div class="content">Well, Lisp macros are mentioned in a footnote at least, and yes, maybe even the oldest version of this idea.</div><br/><div id="40860802" class="c"><input type="checkbox" id="c-40860802" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40860171">root</a><span>|</span><a href="#40860257">parent</a><span>|</span><a href="#40860792">next</a><span>|</span><label class="collapse" for="c-40860802">[-]</label><label class="expand" for="c-40860802">[2 more]</label></div><br/><div class="children"><div class="content">lisp macros are probably newer than forth, but i don&#x27;t know that they&#x27;re newer than the words [ and ] in forth.  but lisp did permit arbitrary compile-time computation from the beginning, i believe</div><br/><div id="40862911" class="c"><input type="checkbox" id="c-40862911" checked=""/><div class="controls bullet"><span class="by">lispm</span><span>|</span><a href="#40860171">root</a><span>|</span><a href="#40860802">parent</a><span>|</span><a href="#40860792">next</a><span>|</span><label class="collapse" for="c-40862911">[-]</label><label class="expand" for="c-40862911">[1 more]</label></div><br/><div class="children"><div class="content">FEXPRs existed around 1960. Macros slightly later.<p>MIT AI Memo 57, Timothy P. Hart, MACRO Definitions for LISP, October 1963<p><a href="http:&#x2F;&#x2F;bitsavers.informatik.uni-stuttgart.de&#x2F;pdf&#x2F;mit&#x2F;ai&#x2F;aim&#x2F;AIM-057.pdf" rel="nofollow">http:&#x2F;&#x2F;bitsavers.informatik.uni-stuttgart.de&#x2F;pdf&#x2F;mit&#x2F;ai&#x2F;aim&#x2F;...</a></div><br/></div></div></div></div></div></div><div id="40860792" class="c"><input type="checkbox" id="c-40860792" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40860171">root</a><span>|</span><a href="#40860198">parent</a><span>|</span><a href="#40860257">prev</a><span>|</span><a href="#40861248">next</a><span>|</span><label class="collapse" for="c-40860792">[-]</label><label class="expand" for="c-40860792">[1 more]</label></div><br/><div class="children"><div class="content">probably so, yes, but forth would be #2</div><br/></div></div></div></div></div></div><div id="40861248" class="c"><input type="checkbox" id="c-40861248" checked=""/><div class="controls bullet"><span class="by">StiffFreeze9</span><span>|</span><a href="#40860171">prev</a><span>|</span><a href="#40860524">next</a><span>|</span><label class="collapse" for="c-40861248">[-]</label><label class="expand" for="c-40861248">[1 more]</label></div><br/><div class="children"><div class="content">Other &quot;biphasic&quot;-like aspects of programming languages and code:<p>- Documentation generated from inline code comments (Knuth&#x27;s literate programming)<p>- Test code<p>We could expand to<p>- security (beyond perl taint)<p>- O(n) runtime and memory analysis<p>- parallelism or clustering<p>- latency budgets<p>And for those academically inclined, formal language semantics like <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Denotational_semantics" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Denotational_semantics</a> versus operational and others..</div><br/></div></div><div id="40860524" class="c"><input type="checkbox" id="c-40860524" checked=""/><div class="controls bullet"><span class="by">graypegg</span><span>|</span><a href="#40861248">prev</a><span>|</span><a href="#40863378">next</a><span>|</span><label class="collapse" for="c-40860524">[-]</label><label class="expand" for="c-40860524">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if something like Ruby could fit into this category too, even though there isn’t a clean line between the two phases. (I’m stretching the concept a bit heh)<p>The block inside of a class or module definition is executed first, and then the application can work on the resulting structure generated after that pass. Sorbet (a Ruby static typing library) uses this first-pass to generate its type metadata, without running application code. (I think by stubbing the class and module classes themselves?)</div><br/></div></div><div id="40863378" class="c"><input type="checkbox" id="c-40863378" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40860524">prev</a><span>|</span><a href="#40860631">next</a><span>|</span><label class="collapse" for="c-40863378">[-]</label><label class="expand" for="c-40863378">[1 more]</label></div><br/><div class="children"><div class="content">For what its worth I like the function coloring Rust has, I don&#x27;t believe compilation results should vary across separate runs. It&#x27;s the same spirit as the rest of the language: highly predictable. The likes of diesel are very cool, but still amount to a big fat &quot;yikes&quot; from me.<p>I think the actual problem is the glacial pace of applying it, and the lack of support in trait impls (e.g. i32.min) and syntax. If it were applied to every pure fn+syntax it would probably cover a great deal of what Zig is doing.</div><br/></div></div><div id="40860631" class="c"><input type="checkbox" id="c-40860631" checked=""/><div class="controls bullet"><span class="by">cb321</span><span>|</span><a href="#40863378">prev</a><span>|</span><a href="#40863657">next</a><span>|</span><label class="collapse" for="c-40860631">[-]</label><label class="expand" for="c-40860631">[1 more]</label></div><br/><div class="children"><div class="content">Nim &amp; D also have the compile-time function evaluation he mentions for Zig.  Nim also has a full macro system wherein macros are written in Nim - just taking &amp; producing ASTs.  I&#x27;ve known people to refer to this&#x2F;Julia macro systems as &quot;homoiconic&quot;.  Nim also has a javascript backend to enable similar same-syntax on client&amp;server like his React &amp; clojure examples.</div><br/></div></div><div id="40863657" class="c"><input type="checkbox" id="c-40863657" checked=""/><div class="controls bullet"><span class="by">indyjo</span><span>|</span><a href="#40860631">prev</a><span>|</span><a href="#40860771">next</a><span>|</span><label class="collapse" for="c-40863657">[-]</label><label class="expand" for="c-40863657">[1 more]</label></div><br/><div class="children"><div class="content">Would embedding code (which is executed by some other runtime, like SQL, shaders, compute kernels etc.) also be considered &quot;biphasic&quot; or &quot;multi-stage&quot; programming?</div><br/></div></div><div id="40860771" class="c"><input type="checkbox" id="c-40860771" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#40863657">prev</a><span>|</span><a href="#40861388">next</a><span>|</span><label class="collapse" for="c-40860771">[-]</label><label class="expand" for="c-40860771">[2 more]</label></div><br/><div class="children"><div class="content">this &#x27;biphasic programming&#x27; thing is item #9 in pg&#x27;s list of &#x27;what made lisp different&#x27; from 02001: <a href="https:&#x2F;&#x2F;paulgraham.com&#x2F;diff.html" rel="nofollow">https:&#x2F;&#x2F;paulgraham.com&#x2F;diff.html</a><p>it&#x27;s interesting to read this biphasic programming article in the context of pg&#x27;s tendentious reading of programming language history<p>&gt; <i>Over time, the default language, embodied in a succession of popular languages, has gradually evolved toward Lisp. 1-5 are now widespread. 6 is starting to appear in the mainstream. Python has a form of 7, though there doesn&#x27;t seem to be any syntax for it. 8, which (with 9) is what makes Lisp macros possible, is so far still unique to Lisp, perhaps because (a) it requires those parens, or something just as bad, and (b) if you add that final increment of power, you can no longer claim to have invented a new language, but only to have designed a new dialect of Lisp ; -)</i><p>it of course isn&#x27;t <i>absolutely</i> unique to lisp; forth also has it<p>i think the academic concept of &#x27;staged programming&#x27; <a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?cites=2747410401001453059&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=es" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?cites=2747410401001453059...</a> is a generalization of this, and partial evaluation is a very general way to blur the lines between compile time and run time</div><br/><div id="40862424" class="c"><input type="checkbox" id="c-40862424" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40860771">parent</a><span>|</span><a href="#40861388">next</a><span>|</span><label class="collapse" for="c-40862424">[-]</label><label class="expand" for="c-40862424">[1 more]</label></div><br/><div class="children"><div class="content">I <i>suspect</i> what we don&#x27;t have is the ability for Forth words to act as symbols that can be given a completely different meaning.<p>Can we have:<p><pre><code>  oof dup rot swap foo
</code></pre>
where <i>oof</i> is a delimiter pairing with <i>foo</i>, both of which we developed? It causes <i>dup</i>, <i>rot</i> and <i>swap</i> not to execute but somehow be accumulated as just symbols; then <i>foo</i> interprets them in such a way that they are unrelated to duplicating, rotating and swapping stack elements.<p>Word definitions do something like this. There is a : (colon) word which causes the next word to be interpreted as a name for a new definition and then subsequent words until a semicolon are shored up into the definition.
But that&#x27;s a fixed thing, built into the language. It&#x27;s not defined in the Forth standard as a symbolic quoting mechanism.</div><br/></div></div></div></div><div id="40861388" class="c"><input type="checkbox" id="c-40861388" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#40860771">prev</a><span>|</span><a href="#40862949">next</a><span>|</span><label class="collapse" for="c-40861388">[-]</label><label class="expand" for="c-40861388">[1 more]</label></div><br/><div class="children"><div class="content">Since we&#x27;re going down the road of interesting ideas, let&#x27;s add declarative programming to the mix<p>The Metamine language allowed for a <i>magic equals   := if I recall correctly</i>, which had the effect of always updating the result anytime the assigned value changed for the rest of the life of the program.   Mixing it with normal assignments and code made for some interesting capabilities.</div><br/></div></div><div id="40862949" class="c"><input type="checkbox" id="c-40862949" checked=""/><div class="controls bullet"><span class="by">ceving</span><span>|</span><a href="#40861388">prev</a><span>|</span><a href="#40861038">next</a><span>|</span><label class="collapse" for="c-40862949">[-]</label><label class="expand" for="c-40862949">[1 more]</label></div><br/><div class="children"><div class="content">&gt; macro systems like those in C, C++, and Rust<p>Suggesting that the macros of C and Rust may be the same is an insane failure.<p>BTW: meta-programming means &quot;code which generates code&quot; and not &quot;code which runs earlier than other code&quot;.</div><br/></div></div><div id="40861038" class="c"><input type="checkbox" id="c-40861038" checked=""/><div class="controls bullet"><span class="by">jalk</span><span>|</span><a href="#40862949">prev</a><span>|</span><a href="#40861481">next</a><span>|</span><label class="collapse" for="c-40861038">[-]</label><label class="expand" for="c-40861038">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Biphasic programming&quot; is also present in frameworks like Apache Spark, Tensorflow, build tools like Gradle and code-first workflow engines. Execution of the first phase generates a DAG of code to be executed later. IMO the hardest thing for newcomers is when phase 1 and phase 2 code is interleaved with no immediate clear boundaries, (phase 1 code resembles an internal DSL). The docs need to teach this early on to avoid confusion. A prime offender of this is SBT, with its (perhaps no longer true) 3 stage rocket, which is not really described in the docs (see <a href="https:&#x2F;&#x2F;www.lihaoyi.com&#x2F;post&#x2F;SowhatswrongwithSBT.html#too-many-layers-of-interpretation" rel="nofollow">https:&#x2F;&#x2F;www.lihaoyi.com&#x2F;post&#x2F;SowhatswrongwithSBT.html#too-ma...</a>)</div><br/></div></div><div id="40861481" class="c"><input type="checkbox" id="c-40861481" checked=""/><div class="controls bullet"><span class="by">a1o</span><span>|</span><a href="#40861038">prev</a><span>|</span><a href="#40862058">next</a><span>|</span><label class="collapse" for="c-40861481">[-]</label><label class="expand" for="c-40861481">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the dismissal of C++, to me constexpr is exactly that! And now if we get reflection in C++26 it will be possible to do even more incredible things using it, but constexpr is already pretty good.</div><br/><div id="40861505" class="c"><input type="checkbox" id="c-40861505" checked=""/><div class="controls bullet"><span class="by">joatmon-snoo</span><span>|</span><a href="#40861481">parent</a><span>|</span><a href="#40862058">next</a><span>|</span><label class="collapse" for="c-40861505">[-]</label><label class="expand" for="c-40861505">[1 more]</label></div><br/><div class="children"><div class="content">Er- kinda? Maybe? Not really?<p>constexpr does not mean that you can evaluate arbitrary C++ code at compile time. It allows you to evaluate a _very specific subset_ of C++ at compile time that is not at all easy to wrap your head around: look no further than <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;constexpr" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;constexpr</a> to understand the limitations.</div><br/></div></div></div></div><div id="40862058" class="c"><input type="checkbox" id="c-40862058" checked=""/><div class="controls bullet"><span class="by">EricRiese</span><span>|</span><a href="#40861481">prev</a><span>|</span><a href="#40861099">next</a><span>|</span><label class="collapse" for="c-40862058">[-]</label><label class="expand" for="c-40862058">[1 more]</label></div><br/><div class="children"><div class="content">Raku has this<p><a href="https:&#x2F;&#x2F;docs.raku.org&#x2F;language&#x2F;phasers" rel="nofollow">https:&#x2F;&#x2F;docs.raku.org&#x2F;language&#x2F;phasers</a><p>It has many more than 2 phases.<p>Phasers is one of the ideas Raku takes as pretty core and really runs with it. So in addition to compile time programming, it has phasers for run time events like catching exceptions and one that&#x27;s equivalent to the defer keyboard in several languages.</div><br/></div></div><div id="40861099" class="c"><input type="checkbox" id="c-40861099" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#40862058">prev</a><span>|</span><a href="#40862151">next</a><span>|</span><label class="collapse" for="c-40861099">[-]</label><label class="expand" for="c-40861099">[1 more]</label></div><br/><div class="children"><div class="content">Also interesting is the singeli language <a href="https:&#x2F;&#x2F;github.com&#x2F;mlochbaum&#x2F;Singeli&#x2F;tree&#x2F;master">https:&#x2F;&#x2F;github.com&#x2F;mlochbaum&#x2F;Singeli&#x2F;tree&#x2F;master</a></div><br/></div></div><div id="40862151" class="c"><input type="checkbox" id="c-40862151" checked=""/><div class="controls bullet"><span class="by">hbbio</span><span>|</span><a href="#40861099">prev</a><span>|</span><a href="#40863596">next</a><span>|</span><label class="collapse" for="c-40862151">[-]</label><label class="expand" for="c-40862151">[1 more]</label></div><br/><div class="children"><div class="content">Funny to see the example of RSC in that context!<p>Multi-stage programming and distribution with the same syntax between clients and servers has been _the_ key feature of Opa (opalang.org) 15 years back. Funny because Opa was a key inspiration for React and its JSX syntax but it took a lot of time to match the rest of the features.</div><br/></div></div><div id="40863596" class="c"><input type="checkbox" id="c-40863596" checked=""/><div class="controls bullet"><span class="by">JamesBarney</span><span>|</span><a href="#40862151">prev</a><span>|</span><a href="#40861092">next</a><span>|</span><label class="collapse" for="c-40863596">[-]</label><label class="expand" for="c-40863596">[1 more]</label></div><br/><div class="children"><div class="content">As a Microsoft fanboy I have to list our their biphasic additions.<p>Linq. Have a a set of collection manipulation methods that could be run in c# or transformed in SQL.<p>Blazor. Have components that can run on the server, or in the browser, or several other rendering tactics.</div><br/></div></div><div id="40861092" class="c"><input type="checkbox" id="c-40861092" checked=""/><div class="controls bullet"><span class="by">AlexErrant</span><span>|</span><a href="#40863596">prev</a><span>|</span><a href="#40862498">next</a><span>|</span><label class="collapse" for="c-40861092">[-]</label><label class="expand" for="c-40861092">[1 more]</label></div><br/><div class="children"><div class="content">Another example of biphasic programming is parser generators with DSLs for generating parsers, e.g. Tree Sitter or Lezer.</div><br/></div></div><div id="40862498" class="c"><input type="checkbox" id="c-40862498" checked=""/><div class="controls bullet"><span class="by">z5h</span><span>|</span><a href="#40861092">prev</a><span>|</span><a href="#40861127">next</a><span>|</span><label class="collapse" for="c-40862498">[-]</label><label class="expand" for="c-40862498">[1 more]</label></div><br/><div class="children"><div class="content">Take a look at term_expansion and goal_expansion in the Prologs that support them.</div><br/></div></div><div id="40861127" class="c"><input type="checkbox" id="c-40861127" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40862498">prev</a><span>|</span><a href="#40860569">next</a><span>|</span><label class="collapse" for="c-40861127">[-]</label><label class="expand" for="c-40861127">[1 more]</label></div><br/><div class="children"><div class="content">&gt; And compared to Lisps like Scheme and Racket which support hygenic macros, well, Zig doesn’t require everything to be a list.<p>Found the smug anti-Lisp weenie. Not everything is a list in Lisp. In fact Lisp and Forth are among the most powerful &quot;biphasic&quot; languages, as in both expressions in the full language can be evaluated at compile time. Pre-Scheme, a GC-less, statically typed, &quot;systems&quot; subset of Scheme, lets you use the full Scheme language for any expression that can be provably evaluated at compile time (for example, using DEFINE to introduce a variable at top level).</div><br/></div></div><div id="40860569" class="c"><input type="checkbox" id="c-40860569" checked=""/><div class="controls bullet"><span class="by">Svoka</span><span>|</span><a href="#40861127">prev</a><span>|</span><a href="#40861556">next</a><span>|</span><label class="collapse" for="c-40860569">[-]</label><label class="expand" for="c-40860569">[5 more]</label></div><br/><div class="children"><div class="content">To be honest `comptime` seems excessive. Like, if something can be calculated at compile time, it should be. Why the extra keywords for that?
Rust is mostly doing it already.</div><br/><div id="40860634" class="c"><input type="checkbox" id="c-40860634" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#40860569">parent</a><span>|</span><a href="#40860676">next</a><span>|</span><label class="collapse" for="c-40860634">[-]</label><label class="expand" for="c-40860634">[2 more]</label></div><br/><div class="children"><div class="content">&gt; if something can be calculated at compile time, it should be<p>Often you don&#x27;t actually want some things done at compile time although they could be done. It can lead to, e.g., excessive executable sizes, excessive compile times. If you&#x27;ve ever considered using `-ftemplate-depth` in C++, you&#x27;ve probably encountered such a case.<p>Maybe it sounds like I&#x27;m splitting hairs and you would say &quot;of course in <i>such crazy cases</i> it&#x27;s not true&quot;, but if you look at C++ projects and what <i>can</i> be done at compile time with modern C++, you would find it&#x27;s not rare at all.</div><br/><div id="40861182" class="c"><input type="checkbox" id="c-40861182" checked=""/><div class="controls bullet"><span class="by">tomjakubowski</span><span>|</span><a href="#40860569">root</a><span>|</span><a href="#40860634">parent</a><span>|</span><a href="#40860676">next</a><span>|</span><label class="collapse" for="c-40861182">[-]</label><label class="expand" for="c-40861182">[1 more]</label></div><br/><div class="children"><div class="content">Yes. My attitude earlier in my life as a programmer was that moving as much as possible to &quot;compile time&quot; was a universal good. The truth is of course, like everything, there are trade offs.<p>I once worked on an Elixir application whose configuration was accessed almost exclusively at compile time. This was done with the well-intended notion that saving runtime cycles was a good thing. It meant that changing any config (e.g.: &quot;name of s3 bucket&quot;) meant recompiling the entire application. It also meant we had to wait for a full application rebuild in CI to deploy fixes for simple configuration errors. Not so super.</div><br/></div></div></div></div><div id="40860676" class="c"><input type="checkbox" id="c-40860676" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40860569">parent</a><span>|</span><a href="#40860634">prev</a><span>|</span><a href="#40861556">next</a><span>|</span><label class="collapse" for="c-40860676">[-]</label><label class="expand" for="c-40860676">[2 more]</label></div><br/><div class="children"><div class="content">One reason you might want an explicit keyword is so that it fails to compile if it can&#x27;t be calculated at compile time, which is what was intended, rather than fall back to calculating it at runtime. It also seems useful as an ad-hoc method of annotating pure functions; those functions are guaranteed not to modify global variables at runtime or do I&#x2F;O.</div><br/><div id="40860734" class="c"><input type="checkbox" id="c-40860734" checked=""/><div class="controls bullet"><span class="by">Svoka</span><span>|</span><a href="#40860569">root</a><span>|</span><a href="#40860676">parent</a><span>|</span><a href="#40861556">next</a><span>|</span><label class="collapse" for="c-40860734">[-]</label><label class="expand" for="c-40860734">[1 more]</label></div><br/><div class="children"><div class="content">I guess so... This is reason for `consteval` and such.</div><br/></div></div></div></div></div></div><div id="40861556" class="c"><input type="checkbox" id="c-40861556" checked=""/><div class="controls bullet"><span class="by">williamcotton</span><span>|</span><a href="#40860569">prev</a><span>|</span><label class="collapse" for="c-40861556">[-]</label><label class="expand" for="c-40861556">[1 more]</label></div><br/><div class="children"><div class="content">I like the term biphasic! The prior terms for this with Javascript web development were &quot;isomorphic&quot; or &quot;universal&quot;. I don&#x27;t think these ever really caught on.<p>I&#x27;ve been rendering the same React components on the server and browser side for close to decade and I&#x27;ve come across some really good patterns that I don&#x27;t really see anywhere else.<p>Here&#x27;s the architectural pattern that I use for my own personal projects. For fun I&#x27;ve starting writing it in F# and using Fable to compile to JS:<p><a href="https:&#x2F;&#x2F;fex-template.fly.dev" rel="nofollow">https:&#x2F;&#x2F;fex-template.fly.dev</a><p>A foundational element is a port of express to the browser, aptly named browser express:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;williamcotton&#x2F;browser-express">https:&#x2F;&#x2F;github.com&#x2F;williamcotton&#x2F;browser-express</a><p>With this you write not only biphasic UI components but also route handlers. In my opinion and through lots of experience with other React frameworks this is far superior to approaches taken by the mainstream frameworks and even how the React developers expect their tool to be used. One great side effect is that the site works the same with Javascript enabled. This also means the time to interaction is immediate.<p>It keeps a focus on the request itself with a mock HTTP request created from click and form post events in the browser. It properly architects around middleware that processes an incoming request and outgoing response, with parallel middleware for either the browser or server runtime. It uses web and browser native concepts like links and forms to handle user input instead of doubling the state handling of the browser with controlled forms in React. I can&#x27;t help but notice that React is starting to move away from controlled forms. They have finally realized that this design was a mistake.<p>Because the code is written in this biphasic manner and the runtime context is injected it avoids any sort of conditionals around browser or server runtime. In my opinion it is a leaky abstraction to mark a file as &quot;use client&quot; or &quot;use server&quot;.<p>Anyways, I enjoyed the article and I plan on using this term in practice!</div><br/></div></div></div></div></div></div></div></body></html>