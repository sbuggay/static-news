<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737882065672" as="style"/><link rel="stylesheet" href="styles.css?v=1737882065672"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.downtowndougbrown.com/2025/01/the-invalid-68030-instruction-that-accidentally-allowed-the-mac-classic-ii-to-successfully-boot-up/">An invalid 68030 instruction accidentally allowed the Mac Classic II to boot</a> <span class="domain">(<a href="https://www.downtowndougbrown.com">www.downtowndougbrown.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>36 comments</span></div><br/><div><div id="42827953" class="c"><input type="checkbox" id="c-42827953" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#42827935">next</a><span>|</span><label class="collapse" for="c-42827953">[-]</label><label class="expand" for="c-42827953">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I’ve discovered an undocumented MC68030 instruction that performs a read-modify-write bus cycle and also changes the value of the A1 register.</i><p>Rather than a &quot;real&quot; instruction that CPU designers consciously created and which was meant to do something useful but wasn&#x27;t documented, it could just be that this is an illegal instruction and the logic in the CPU is doing whatever it happens to do when given don&#x27;t-care inputs. (Maybe this is what the author meant, and I&#x27;m just catching up.)<p>Normally the CPU would detect illegal instructions and cause an exception. This would mean there are certain situations where it doesn&#x27;t.<p>I found a manual at <a href="https:&#x2F;&#x2F;www.nxp.com&#x2F;docs&#x2F;en&#x2F;reference-manual&#x2F;MC68030UM.pdf" rel="nofollow">https:&#x2F;&#x2F;www.nxp.com&#x2F;docs&#x2F;en&#x2F;reference-manual&#x2F;MC68030UM.pdf</a>. On page 8-9 of the manual (which is page 276 in the PDF file), it says:<p>&gt; <i>An illegal instruction is an instruction that contains any bit pattern in its first word that does not correspond to the bit pattern of the first word of a valid MC68030 instruction or is a MOVEC instruction with an undefined register specification field in the first extension word.</i><p>Note &quot;in its first word&quot;. According to the write-up, the instruction is 3 words long. The first word is normal, and the weird bits occur in the second word. So quite possibly the 68030 doesn&#x27;t validate this second word, just plows forward with the logic that implements the CAS instruction, and lets whatever happens happen.<p>(Great write-up and amazing dedication, by the way!)</div><br/></div></div><div id="42827935" class="c"><input type="checkbox" id="c-42827935" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42827953">prev</a><span>|</span><a href="#42827091">next</a><span>|</span><label class="collapse" for="c-42827935">[-]</label><label class="expand" for="c-42827935">[7 more]</label></div><br/><div class="children"><div class="content">Nearly all CPUs have undocumented instructions, and the 68k is no exception; it&#x27;s just that the vast majority of people with enough interest and low-level knowledge at the time were focused on the x86&#x2F;PC instead, which was arguably a far more open and stable architecture than Apple&#x27;s. The 8088 and 8086 microcode was disassembled and studied extensively a few years ago, and I believe there&#x27;s been some attempts at simulating it at the transistor level already. Even before that, the structure of the x86 opcode space was also explored in detail by many, with documents like these resulting from such effort:<p><a href="http:&#x2F;&#x2F;ref.x86asm.net&#x2F;geek.html" rel="nofollow">http:&#x2F;&#x2F;ref.x86asm.net&#x2F;geek.html</a><p><a href="https:&#x2F;&#x2F;gist.github.com&#x2F;seanjensengrey&#x2F;f971c20d05d4d0efc0781f2f3c0353da" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;seanjensengrey&#x2F;f971c20d05d4d0efc0781...</a><p><i>We don’t really know the exact details of what this instruction does. With some limited testing, I believe I’ve observed that the resulting value of A1 depends on the original A1 value, the value of A7, and the program counter. But I’m not sure. Maybe someone can make a program that tries out a bunch of different register values and memory contents, and attempt to deduce what exactly the instruction does so that it can be emulated accurately. Until someone decides that it’s worth trying to figure out, MAME is patching this bug out of the ROM in order to allow the Classic II to boot.</i><p>IMHO this is definitely worth figuring out for accurate emulation. I&#x27;m not familiar with 68k but the bits in the instruction offer a good clue - my theory is that bits 5:3 of the 2nd word seem like another mode field, and instead of selecting one of the Dn registers via mode 000, 101 is selecting (d16, An) again and the Dc field, containing 001, is being interpreted as A1.</div><br/><div id="42828369" class="c"><input type="checkbox" id="c-42828369" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42827935">parent</a><span>|</span><a href="#42828627">next</a><span>|</span><label class="collapse" for="c-42828369">[-]</label><label class="expand" for="c-42828369">[5 more]</label></div><br/><div class="children"><div class="content">At the time Mac Classic was relevant, PC still wasn&#x27;t thar great in home computing, no one was bothering with this stuff in x86&#x2F;PC.<p>We were still bothering with demoscene stuff in 8 bit home computers, and those of us busy with 16 bit home systems were focused on Atari and Amiga systems.<p>PC and x86 at home only took off, meany really taking off among demoscene and other home users, was when VGA and sound cards became part of a standard PC.</div><br/><div id="42828592" class="c"><input type="checkbox" id="c-42828592" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42827935">root</a><span>|</span><a href="#42828369">parent</a><span>|</span><a href="#42828626">next</a><span>|</span><label class="collapse" for="c-42828592">[-]</label><label class="expand" for="c-42828592">[2 more]</label></div><br/><div class="children"><div class="content">The Mac Classic was released in 1990, the Mac Classic II that is the subject of this article was released in 1991. At that time PCs with 286s and 386s were already common, and the 486 was just starting to gain marketshare at the high end. Most of the undocumented 8086 instructions had already been known for almost a decade; and the majority of those who knew were not demosceners. Many developers used Asm exclusively, and the &quot;classic hacker mindset&quot; was very much alive among them.</div><br/><div id="42828735" class="c"><input type="checkbox" id="c-42828735" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42827935">root</a><span>|</span><a href="#42828592">parent</a><span>|</span><a href="#42828626">next</a><span>|</span><label class="collapse" for="c-42828735">[-]</label><label class="expand" for="c-42828735">[1 more]</label></div><br/><div class="children"><div class="content">Depends on where in the globe one were and in my demoscene circles PCs only took off as interesting after Windows 95, folks using MS-DOS or Windows 3.x were mostly due to their parents family computer.</div><br/></div></div></div></div><div id="42828626" class="c"><input type="checkbox" id="c-42828626" checked=""/><div class="controls bullet"><span class="by">zargon</span><span>|</span><a href="#42827935">root</a><span>|</span><a href="#42828369">parent</a><span>|</span><a href="#42828592">prev</a><span>|</span><a href="#42828627">next</a><span>|</span><label class="collapse" for="c-42828626">[-]</label><label class="expand" for="c-42828626">[2 more]</label></div><br/><div class="children"><div class="content">This is 1992 we&#x27;re talking about. You might be confusing the Mac Classic II with mid-80s Macs due to the form factor.</div><br/><div id="42828737" class="c"><input type="checkbox" id="c-42828737" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42827935">root</a><span>|</span><a href="#42828626">parent</a><span>|</span><a href="#42828627">next</a><span>|</span><label class="collapse" for="c-42828737">[-]</label><label class="expand" for="c-42828737">[1 more]</label></div><br/><div class="children"><div class="content">Where Amiga and Atari were still calling the shots among European demoscene.</div><br/></div></div></div></div></div></div><div id="42828627" class="c"><input type="checkbox" id="c-42828627" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#42827935">parent</a><span>|</span><a href="#42828369">prev</a><span>|</span><a href="#42827091">next</a><span>|</span><label class="collapse" for="c-42828627">[-]</label><label class="expand" for="c-42828627">[1 more]</label></div><br/><div class="children"><div class="content">nitpick: 68k of course wasn&#x27;t Apple&#x27;s architecture, it was used in Amiga, Atari, Sun, NeXT etc.</div><br/></div></div></div></div><div id="42827091" class="c"><input type="checkbox" id="c-42827091" checked=""/><div class="controls bullet"><span class="by">kstenerud</span><span>|</span><a href="#42827935">prev</a><span>|</span><a href="#42825077">next</a><span>|</span><label class="collapse" for="c-42827091">[-]</label><label class="expand" for="c-42827091">[1 more]</label></div><br/><div class="children"><div class="content">CAS has always been a bitch. I think I&#x27;ve received more bug reports about that instruction&#x27;s emulation than any other instruction.<p>Incidentally, I remember another old &quot;bug&quot; in King of Fighters that &quot;incorrectly&quot; checked the carry flag of the SBCD instruction, which it used to decrement the round timer and end the current round. Completely undocumented of course, but if you don&#x27;t emulate the arithmetic status flags when doing binary coded decimal operations, the round timer in KOF will just keep on going forever, cycling from 00 to 99 :P<p>SNK were really the gods of the 68000 chip.</div><br/></div></div><div id="42825077" class="c"><input type="checkbox" id="c-42825077" checked=""/><div class="controls bullet"><span class="by">ChuckMcM</span><span>|</span><a href="#42827091">prev</a><span>|</span><a href="#42825949">next</a><span>|</span><label class="collapse" for="c-42825077">[-]</label><label class="expand" for="c-42825077">[5 more]</label></div><br/><div class="children"><div class="content">That is quite the journey. I find I don&#x27;t have the patience these days to go quite so far down the rabbit hole as the author does, but I resonate with that feeling of accomplishment in <i>knowing</i> something versus just thinking you know something.</div><br/><div id="42825348" class="c"><input type="checkbox" id="c-42825348" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42825077">parent</a><span>|</span><a href="#42825949">next</a><span>|</span><label class="collapse" for="c-42825348">[-]</label><label class="expand" for="c-42825348">[4 more]</label></div><br/><div class="children"><div class="content">Author here. Yeah, I have a tendency to go into pretty big deep dives when I find stuff like this. It&#x27;s so rewarding at the end, even if it does take a lot of time!</div><br/><div id="42825788" class="c"><input type="checkbox" id="c-42825788" checked=""/><div class="controls bullet"><span class="by">mrandish</span><span>|</span><a href="#42825077">root</a><span>|</span><a href="#42825348">parent</a><span>|</span><a href="#42825949">next</a><span>|</span><label class="collapse" for="c-42825788">[-]</label><label class="expand" for="c-42825788">[3 more]</label></div><br/><div class="children"><div class="content">Finding a previously unknown undocumented instruction at this late date in a line of processors as prevalent and historically significant as the 68k is surprising. Congrats on your achievement! If someone  does dive into fully characterizing the undocumented instruction so it can be properly supported in emulators (as you suggested), please post about it on HN. I suspect, like many undocumented CPU instructions, it was probably to help the original designers test or verify something during development but it would be interesting to know.<p>While obviously a subjective judgement, a lot of people who hand coded assembler on 68k processors regard the ISA as especially elegant, powerful and fun to develop for. In many ways I think of it as peak CISC, thanks to its orthogonal instruction set and wildly flexible addressing modes. And of course the platforms which used it are legendary, from consumer (Mac&#x2F;Lisa, Amiga, Atari ST, Sinclair QL) to workstations (SUN, Apollo, Quantel) to gaming (Sega Genesis, Neo Geo, Capcom, Atari, Namco, Sega, Taito, Konami) to embedded (automation, print&#x2F;network controllers, synthesizers, appliances). I&#x27;m certainly biased but to this day the 68k (and its 8-bit little brother the 6809) are the only CPUs I still enjoy writing assembler on.</div><br/><div id="42827945" class="c"><input type="checkbox" id="c-42827945" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42825077">root</a><span>|</span><a href="#42825788">parent</a><span>|</span><a href="#42827294">next</a><span>|</span><label class="collapse" for="c-42827945">[-]</label><label class="expand" for="c-42827945">[1 more]</label></div><br/><div class="children"><div class="content"><i>I suspect, like many undocumented CPU instructions, it was probably to help the original designers test or verify something during development but it would be interesting to know.</i><p>Or simply be an emergent but unintended behaviour of the implementation, as is the case for most of the undocumented 6502, Z80, and x86 instructions I know of.</div><br/></div></div><div id="42827294" class="c"><input type="checkbox" id="c-42827294" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42825077">root</a><span>|</span><a href="#42825788">parent</a><span>|</span><a href="#42827945">prev</a><span>|</span><a href="#42825949">next</a><span>|</span><label class="collapse" for="c-42827294">[-]</label><label class="expand" for="c-42827294">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! Yes, I will definitely make another post if and when someone figures out what the instruction does.</div><br/></div></div></div></div></div></div></div></div><div id="42825949" class="c"><input type="checkbox" id="c-42825949" checked=""/><div class="controls bullet"><span class="by">khazhoux</span><span>|</span><a href="#42825077">prev</a><span>|</span><a href="#42826949">next</a><span>|</span><label class="collapse" for="c-42825949">[-]</label><label class="expand" for="c-42825949">[1 more]</label></div><br/><div class="children"><div class="content">30+ years later, I&#x27;m still always amazed at how effective the Mac debugger UI could be with such a tiny screen resolution.  It&#x27;s really quite masterful.</div><br/></div></div><div id="42826949" class="c"><input type="checkbox" id="c-42826949" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#42825949">prev</a><span>|</span><a href="#42825829">next</a><span>|</span><label class="collapse" for="c-42826949">[-]</label><label class="expand" for="c-42826949">[2 more]</label></div><br/><div class="children"><div class="content">Was this copy protection to keep it from running on systems or does this happen on all 68030?</div><br/><div id="42827045" class="c"><input type="checkbox" id="c-42827045" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#42826949">parent</a><span>|</span><a href="#42825829">next</a><span>|</span><label class="collapse" for="c-42827045">[-]</label><label class="expand" for="c-42827045">[1 more]</label></div><br/><div class="children"><div class="content">The contents of the post make me pretty confident that this wasn&#x27;t copy protection, the jump table involved here is just missing an entry for the machine because (most likely) everyone involved in working on the ROM forgot to add a new entry to the jump table and it happened to work without a table entry by pure chance.</div><br/></div></div></div></div><div id="42825829" class="c"><input type="checkbox" id="c-42825829" checked=""/><div class="controls bullet"><span class="by">cluckindan</span><span>|</span><a href="#42826949">prev</a><span>|</span><a href="#42825192">next</a><span>|</span><label class="collapse" for="c-42825829">[-]</label><label class="expand" for="c-42825829">[1 more]</label></div><br/><div class="children"><div class="content">Time to fuzz the rest of the processor.</div><br/></div></div><div id="42825192" class="c"><input type="checkbox" id="c-42825192" checked=""/><div class="controls bullet"><span class="by">basementcat</span><span>|</span><a href="#42825829">prev</a><span>|</span><a href="#42826112">next</a><span>|</span><label class="collapse" for="c-42825192">[-]</label><label class="expand" for="c-42825192">[6 more]</label></div><br/><div class="children"><div class="content">Do the &#x27;040&#x2F;060 also support this &quot;undocumented instruction&quot;?</div><br/><div id="42825436" class="c"><input type="checkbox" id="c-42825436" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42825192">parent</a><span>|</span><a href="#42826184">next</a><span>|</span><label class="collapse" for="c-42825436">[-]</label><label class="expand" for="c-42825436">[1 more]</label></div><br/><div class="children"><div class="content">On the 040, it seems to do something that actually involves D1. Definitely doesn&#x27;t touch A1 at all. I didn&#x27;t test further, but it&#x27;s possible it just handles the instruction as a normal CAS.<p>It did cause a system error the first time I stepped through the instruction with MacsBug on my LC 475, but then it was fine after that.</div><br/></div></div><div id="42826184" class="c"><input type="checkbox" id="c-42826184" checked=""/><div class="controls bullet"><span class="by">mras0</span><span>|</span><a href="#42825192">parent</a><span>|</span><a href="#42825436">prev</a><span>|</span><a href="#42826112">next</a><span>|</span><label class="collapse" for="c-42826184">[-]</label><label class="expand" for="c-42826184">[4 more]</label></div><br/><div class="children"><div class="content">Have an Amiga w&#x2F; 060, and that instruction doesn&#x27;t seem to modify any A registers. (Only did a very quick test of those exact instruction words)</div><br/><div id="42826517" class="c"><input type="checkbox" id="c-42826517" checked=""/><div class="controls bullet"><span class="by">basementcat</span><span>|</span><a href="#42825192">root</a><span>|</span><a href="#42826184">parent</a><span>|</span><a href="#42826112">next</a><span>|</span><label class="collapse" for="c-42826517">[-]</label><label class="expand" for="c-42826517">[3 more]</label></div><br/><div class="children"><div class="content">I appreciate that I can ask an esoteric question about the behavior of a 30 year old microprocessor and multiple people respond with test results on actual hardware within a few hours. Can y&#x27;all also post the mask revision (if known) and whether it is an EC or LC device? (In case it impacts behavior)</div><br/><div id="42826671" class="c"><input type="checkbox" id="c-42826671" checked=""/><div class="controls bullet"><span class="by">mras0</span><span>|</span><a href="#42825192">root</a><span>|</span><a href="#42826517">parent</a><span>|</span><a href="#42828114">next</a><span>|</span><label class="collapse" for="c-42826671">[-]</label><label class="expand" for="c-42826671">[1 more]</label></div><br/><div class="children"><div class="content">Rev5 &quot;full&quot; 060 (not EC&#x2F;LC). Quick capture of crappy methodology: <a href="https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;XwQ1Tnp" rel="nofollow">https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;XwQ1Tnp</a> (PCR with revision number is in d0)</div><br/></div></div><div id="42828114" class="c"><input type="checkbox" id="c-42828114" checked=""/><div class="controls bullet"><span class="by">dougg3</span><span>|</span><a href="#42825192">root</a><span>|</span><a href="#42826517">parent</a><span>|</span><a href="#42826671">prev</a><span>|</span><a href="#42826112">next</a><span>|</span><label class="collapse" for="c-42828114">[-]</label><label class="expand" for="c-42828114">[1 more]</label></div><br/><div class="children"><div class="content">My test of an 040 (no A1 change, D1 changed) was on a chip with the following markings:<p>XC68LC040RC25B<p>02E23G
QEDP9348D
MALAYSIA</div><br/></div></div></div></div></div></div></div></div><div id="42826112" class="c"><input type="checkbox" id="c-42826112" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#42825192">prev</a><span>|</span><a href="#42825933">next</a><span>|</span><label class="collapse" for="c-42826112">[-]</label><label class="expand" for="c-42826112">[5 more]</label></div><br/><div class="children"><div class="content">This seems like it will be impossible in the future with today’s Macs. Apple’s technical documentation is rubbish these days.</div><br/><div id="42828329" class="c"><input type="checkbox" id="c-42828329" checked=""/><div class="controls bullet"><span class="by">grishka</span><span>|</span><a href="#42826112">parent</a><span>|</span><a href="#42827062">next</a><span>|</span><label class="collapse" for="c-42828329">[-]</label><label class="expand" for="c-42828329">[1 more]</label></div><br/><div class="children"><div class="content">IMO the reason Apple doesn&#x27;t provide this level of hardware documentation is because modern Macs don&#x27;t have comparable expansion capabilities. The kind that expose system buses on connectors that users are supposed to plug cards into, and third-party developers to interact directly with hardware to make those cards work. On a modern Mac, you&#x27;ve got USB and Thunderbolt that you can interact with from a userspace program.<p>Though I&#x27;m not denying that some of the newer macOS APIs are very poorly documented. As in, you know you&#x27;ve stumbled upon <i>the cool shit</i> when you end up on one of those old pages with a blue gradient in the header that says &quot;Apple documentation archive&quot;.</div><br/></div></div><div id="42827062" class="c"><input type="checkbox" id="c-42827062" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#42826112">parent</a><span>|</span><a href="#42828329">prev</a><span>|</span><a href="#42825933">next</a><span>|</span><label class="collapse" for="c-42827062">[-]</label><label class="expand" for="c-42827062">[3 more]</label></div><br/><div class="children"><div class="content">I think in modern environments the odds of this sort of bug slipping into released firmware&#x2F;software are much lower. Address spaces are much bigger and the vast majority of addresses aren&#x27;t mapped so doing a memory operation on a garbage address is going to fail most of the time, and invalid instructions will probably fail too.<p>Reading from a jump table with an index that&#x27;s too big is a realistic sort of bug to have, so I could see that part making it into modern shipped software. But I would expect the process to fall over when it happens, not keep on trucking like it did here.<p>FWIW, WebAssembly is an environment where bugs of this sort are more possible, since it has a single linear address space where every address is both readable and writable. So if your garbage address is within range you can do an erroneous read, write or CAS and get away with it. But then invalid instructions like in the post will cause the WASM module to fail to load, so it&#x27;s still not 1:1 comparable with this issue in the mac&#x27;s ROM.</div><br/><div id="42827088" class="c"><input type="checkbox" id="c-42827088" checked=""/><div class="controls bullet"><span class="by">1over137</span><span>|</span><a href="#42826112">root</a><span>|</span><a href="#42827062">parent</a><span>|</span><a href="#42825933">next</a><span>|</span><label class="collapse" for="c-42827088">[-]</label><label class="expand" for="c-42827088">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, the “this” I was referring to was the ability to consult docs, reverse engineer to this extent, etc.</div><br/><div id="42828223" class="c"><input type="checkbox" id="c-42828223" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42826112">root</a><span>|</span><a href="#42827088">parent</a><span>|</span><a href="#42825933">next</a><span>|</span><label class="collapse" for="c-42828223">[-]</label><label class="expand" for="c-42828223">[1 more]</label></div><br/><div class="children"><div class="content">I think you’re underestimating people who do this.</div><br/></div></div></div></div></div></div></div></div><div id="42825933" class="c"><input type="checkbox" id="c-42825933" checked=""/><div class="controls bullet"><span class="by">TapamN</span><span>|</span><a href="#42826112">prev</a><span>|</span><a href="#42825932">next</a><span>|</span><label class="collapse" for="c-42825933">[-]</label><label class="expand" for="c-42825933">[2 more]</label></div><br/><div class="children"><div class="content">Does Ken Shirriff have time to look at a 68030?</div><br/><div id="42827994" class="c"><input type="checkbox" id="c-42827994" checked=""/><div class="controls bullet"><span class="by">kens</span><span>|</span><a href="#42825933">parent</a><span>|</span><a href="#42825932">next</a><span>|</span><label class="collapse" for="c-42827994">[-]</label><label class="expand" for="c-42827994">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately, not any time soon.</div><br/></div></div></div></div><div id="42825932" class="c"><input type="checkbox" id="c-42825932" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#42825933">prev</a><span>|</span><a href="#42825940">next</a><span>|</span><label class="collapse" for="c-42825932">[-]</label><label class="expand" for="c-42825932">[1 more]</label></div><br/><div class="children"><div class="content">WOW.<p><i>Amazing</i> work.  Thanks for the exposition.<p>(I miss the 68000 line.  Those were such great chips...)</div><br/></div></div><div id="42825940" class="c"><input type="checkbox" id="c-42825940" checked=""/><div class="controls bullet"><span class="by">Waterluvian</span><span>|</span><a href="#42825932">prev</a><span>|</span><label class="collapse" for="c-42825940">[-]</label><label class="expand" for="c-42825940">[3 more]</label></div><br/><div class="children"><div class="content">We’re confident this wasn’t some ROM DRM type feature?</div><br/><div id="42827951" class="c"><input type="checkbox" id="c-42827951" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42825940">parent</a><span>|</span><a href="#42827413">next</a><span>|</span><label class="collapse" for="c-42827951">[-]</label><label class="expand" for="c-42827951">[1 more]</label></div><br/><div class="children"><div class="content">An &quot;unintentional emulator trap&quot; is how I would characterise it.</div><br/></div></div><div id="42827413" class="c"><input type="checkbox" id="c-42827413" checked=""/><div class="controls bullet"><span class="by">the-rc</span><span>|</span><a href="#42825940">parent</a><span>|</span><a href="#42827951">prev</a><span>|</span><label class="collapse" for="c-42827413">[-]</label><label class="expand" for="c-42827413">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking maybe it&#x27;s a way to save some bytes, like people used to do with undocumented opcodes in 6502 programs.</div><br/></div></div></div></div></div></div></div></div></div></body></html>