<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712134865344" as="style"/><link rel="stylesheet" href="styles.css?v=1712134865344"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>3D + 2D: Testing out my cross-platform WASM graphics engine</a> </div><div class="subtext"><span>seanisom</span> | <span>129 comments</span></div><br/><div><div id="39913820" class="c"><input type="checkbox" id="c-39913820" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#39914758">next</a><span>|</span><label class="collapse" for="c-39913820">[-]</label><label class="expand" for="c-39913820">[2 more]</label></div><br/><div class="children"><div class="content">Skip the PAL step and just go right into SetupRuntime with the arguments. Non-gfx devs don’t know about these things and adding extra steps in your API is unnecessary. Since PAL isn’t used anywhere else. Other than that, I would highly recommend getting on the WebGPU train using wgpu-native or dawn. (IPal should be a member of IRuntime and is ripe for removal for WebGPU context).<p>Keep it up! Bookmarked.</div><br/><div id="39913838" class="c"><input type="checkbox" id="c-39913838" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39913820">parent</a><span>|</span><a href="#39914758">next</a><span>|</span><label class="collapse" for="c-39913838">[-]</label><label class="expand" for="c-39913838">[1 more]</label></div><br/><div class="children"><div class="content">Great suggestion, appreciate it. wgpu is coming!</div><br/></div></div></div></div><div id="39914758" class="c"><input type="checkbox" id="c-39914758" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#39913820">prev</a><span>|</span><a href="#39910298">next</a><span>|</span><label class="collapse" for="c-39914758">[-]</label><label class="expand" for="c-39914758">[2 more]</label></div><br/><div class="children"><div class="content">A talk given by OP which is a fantastic intro with 2 successful demos across 2 platforms :)<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CkV-nWFXvbs" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=CkV-nWFXvbs</a><p>Disclaimer: I currently work at a company in the WebAssembly space that was involved with this conference</div><br/><div id="39914986" class="c"><input type="checkbox" id="c-39914986" checked=""/><div class="controls bullet"><span class="by">boomskats</span><span>|</span><a href="#39914758">parent</a><span>|</span><a href="#39910298">next</a><span>|</span><label class="collapse" for="c-39914986">[-]</label><label class="expand" for="c-39914986">[1 more]</label></div><br/><div class="children"><div class="content">Great talk! Same one I was referring to in my comment below.</div><br/></div></div></div></div><div id="39910298" class="c"><input type="checkbox" id="c-39910298" checked=""/><div class="controls bullet"><span class="by">ronyeh</span><span>|</span><a href="#39914758">prev</a><span>|</span><a href="#39911269">next</a><span>|</span><label class="collapse" for="c-39910298">[-]</label><label class="expand" for="c-39910298">[4 more]</label></div><br/><div class="children"><div class="content">Awesome project. What are you planning for text and font support? Some graphics engines don’t support all the ways you might want to display text. Will we be able to load OTF or WOFF2 files and display arbitrary strings? :-)</div><br/><div id="39910543" class="c"><input type="checkbox" id="c-39910543" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910298">parent</a><span>|</span><a href="#39911269">next</a><span>|</span><label class="collapse" for="c-39910543">[-]</label><label class="expand" for="c-39910543">[3 more]</label></div><br/><div class="children"><div class="content">Thanks! I haven&#x27;t looked deeply into font yet, but I&#x27;ve always been partial to HarfBuzz for shaping, so will probably build on top of that. It also has an experimental Wasm shaper which certainly served as a bit of inspiration for the design of this.</div><br/><div id="39914961" class="c"><input type="checkbox" id="c-39914961" checked=""/><div class="controls bullet"><span class="by">spuzvabob</span><span>|</span><a href="#39910298">root</a><span>|</span><a href="#39910543">parent</a><span>|</span><a href="#39910583">next</a><span>|</span><label class="collapse" for="c-39914961">[-]</label><label class="expand" for="c-39914961">[1 more]</label></div><br/><div class="children"><div class="content">There is a well maintained Wasm build of harfbuzz: &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;harfbuzz&#x2F;harfbuzzjs">https:&#x2F;&#x2F;github.com&#x2F;harfbuzz&#x2F;harfbuzzjs</a>&gt; with both OpenType and AAT shapers support, which should be enough but you can also provide your own shaper implementation in Wasm yes.<p>We&#x27;re successfully using Wasm harfbuzz to render text in a web-based design tool with relatively high usage so there should be no issues integrating it :)</div><br/></div></div><div id="39910583" class="c"><input type="checkbox" id="c-39910583" checked=""/><div class="controls bullet"><span class="by">ronyeh</span><span>|</span><a href="#39910298">root</a><span>|</span><a href="#39910543">parent</a><span>|</span><a href="#39914961">prev</a><span>|</span><a href="#39911269">next</a><span>|</span><label class="collapse" for="c-39910583">[-]</label><label class="expand" for="c-39910583">[1 more]</label></div><br/><div class="children"><div class="content">Nice! Looking forward to your alpha release. (And eventual HarfBuzz integration.)</div><br/></div></div></div></div></div></div><div id="39911269" class="c"><input type="checkbox" id="c-39911269" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#39910298">prev</a><span>|</span><a href="#39914677">next</a><span>|</span><label class="collapse" for="c-39911269">[-]</label><label class="expand" for="c-39911269">[6 more]</label></div><br/><div class="children"><div class="content">This is super neat and I am very interested!<p>I&#x27;m in a rush so I can&#x27;t look to closely now but I have a few questions (and please forgive any stupid questions, I&#x27;m not a graphics dev, just a hobbyist):<p>What&#x27;s the runtime like? 
Is there an event loop driving the rendering? (who calls the `render` on each frame? are there hooks into that? ) 
FFI story? 
Who owns the window pointer?<p>I&#x27;m interested in audio plugins, and VSTs (etc) have a lot of constrains on what can be done around event loops and window management. JUCE is pretty much the de-facto solution there, but it&#x27;s pretty old and feels crufty.</div><br/><div id="39911899" class="c"><input type="checkbox" id="c-39911899" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#39911269">parent</a><span>|</span><a href="#39911396">next</a><span>|</span><label class="collapse" for="c-39911899">[-]</label><label class="expand" for="c-39911899">[2 more]</label></div><br/><div class="children"><div class="content">The limits on what audio plugins can do is not a function of the drawing toolkit, but the fact that they do not own the event loop if the GUI is run in-process with the host. And as long as they do, they will <i>never</i> own the evelop loop. In addition (and mostly related to this) the top level window they appear in is owned by the host, which also inherently limits the plugin&#x27;s role in window management.<p>If you want more, use the capability built into LV2, AU and VST3 for out-of-process GUIs for a plugin (LV2 has had this for more than a decade). CLAP has, I think, abandoned plans to support this based on lack of uptake elsewhere.<p>I&#x27;d hardly call JUCE &quot;pretty old&quot;, but then I&#x27;m a lot older than JUCE. And it&#x27;s likely only crufty if you&#x27;re more used to other styles of GUI toolkits; in terms of the &quot;regular&quot; desktop GUI toolkits, it&#x27;s really bad at all.</div><br/><div id="39913718" class="c"><input type="checkbox" id="c-39913718" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#39911269">root</a><span>|</span><a href="#39911899">parent</a><span>|</span><a href="#39911396">next</a><span>|</span><label class="collapse" for="c-39913718">[-]</label><label class="expand" for="c-39913718">[1 more]</label></div><br/><div class="children"><div class="content">Hey Paul, thanks for sharing!<p>Yes I think JUCE is great, It&#x27;s very well made, but it drives you into a very narrow path of either using everything in the library, or leaving you to fend for yourself (which I admit may be a normal experience for C++ devs). For instance, the ValueTrees frequently used for UI state are very powerful, but they&#x27;re not very type safe (or thread safe), and they feel clunky compared to more contemporary reactive state management patterns like signals.<p>I&#x27;m sure folks who use ValueTrees are happy, but I don&#x27;t see much advancement to that pattern being shared in the JUCE forums. If y&#x27;all have some better tricks over in the Ardour project I&#x27;d love to know! (BTW, I&#x27;m a fan of y&#x27;all&#x27;s work. I really enjoyed reading some of the development resources, like the essay on handling time [0]).<p>[0] <a href="https:&#x2F;&#x2F;ardour.org&#x2F;timing.html" rel="nofollow">https:&#x2F;&#x2F;ardour.org&#x2F;timing.html</a></div><br/></div></div></div></div><div id="39911396" class="c"><input type="checkbox" id="c-39911396" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39911269">parent</a><span>|</span><a href="#39911899">prev</a><span>|</span><a href="#39913843">next</a><span>|</span><label class="collapse" for="c-39911396">[-]</label><label class="expand" for="c-39911396">[2 more]</label></div><br/><div class="children"><div class="content">Great questions!<p>The host app owns the event loop. I don&#x27;t foresee that changing even once we re-architect around WebGPU (allowing the Wasm guest to control shaders), as the host app is responsible for &quot;driving&quot; the render tree, including passing in state (like a timer used for animations). The host app owns the window pointer, as renderlets are always designed to be hosted in an environment (either an app or a browser). Open to feedback on this, though.<p>FFI is coming with the C API soon!<p>I don&#x27;t know much about audio but I see a ton of parallels - well-defined data flow across a set of components running real-time, arbitrary code. Simulations also come to mind.</div><br/><div id="39913662" class="c"><input type="checkbox" id="c-39913662" checked=""/><div class="controls bullet"><span class="by">zengid</span><span>|</span><a href="#39911269">root</a><span>|</span><a href="#39911396">parent</a><span>|</span><a href="#39913843">next</a><span>|</span><label class="collapse" for="c-39913662">[-]</label><label class="expand" for="c-39913662">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the reply! I&#x27;m excited to watch as this project progresses, and I wish you the best of luck!</div><br/></div></div></div></div><div id="39913843" class="c"><input type="checkbox" id="c-39913843" checked=""/><div class="controls bullet"><span class="by">pdntspa</span><span>|</span><a href="#39911269">parent</a><span>|</span><a href="#39911396">prev</a><span>|</span><a href="#39914677">next</a><span>|</span><label class="collapse" for="c-39913843">[-]</label><label class="expand" for="c-39913843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; JUCE is pretty much the de-facto solution there,<p>Is it though? iPlug nee wdl-ol nee iPlug2 seems pretty good too. JUCE stuff has a pretty distinct and slightly obnoxious look and feel that takes a fair bit of effort to strip out</div><br/></div></div></div></div><div id="39914677" class="c"><input type="checkbox" id="c-39914677" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#39911269">prev</a><span>|</span><a href="#39911786">next</a><span>|</span><label class="collapse" for="c-39914677">[-]</label><label class="expand" for="c-39914677">[4 more]</label></div><br/><div class="children"><div class="content">Could this be the foundation of an Electron replacement?</div><br/><div id="39914786" class="c"><input type="checkbox" id="c-39914786" checked=""/><div class="controls bullet"><span class="by">hardwaresofton</span><span>|</span><a href="#39914677">parent</a><span>|</span><a href="#39914896">next</a><span>|</span><label class="collapse" for="c-39914786">[-]</label><label class="expand" for="c-39914786">[2 more]</label></div><br/><div class="children"><div class="content">This is a natural next step of this kind of tech (and WebAssembly tech in general) --  but that seems to not be the direction that renderlet is going... No reason they couldn&#x27;t do it, but actually rendering 2D&#x2F;3D and specializing in making GUI application development easier are similar but not quite the same.<p>Someone could definitely build another &quot;last&quot; cross platform application development toolkit with WebAssembly right now, and have it actually work reasonably well, and be slightly more desirable than flutter (and it could absolute use flutter&#x2F;skia underneath) since you could build without the Dart (for those who don&#x27;t necessarily prefer Dart).</div><br/><div id="39914965" class="c"><input type="checkbox" id="c-39914965" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#39914677">root</a><span>|</span><a href="#39914786">parent</a><span>|</span><a href="#39914896">next</a><span>|</span><label class="collapse" for="c-39914965">[-]</label><label class="expand" for="c-39914965">[1 more]</label></div><br/><div class="children"><div class="content">Or port QT  to WASM.</div><br/></div></div></div></div><div id="39914896" class="c"><input type="checkbox" id="c-39914896" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39914677">parent</a><span>|</span><a href="#39914786">prev</a><span>|</span><a href="#39911786">next</a><span>|</span><label class="collapse" for="c-39914896">[-]</label><label class="expand" for="c-39914896">[1 more]</label></div><br/><div class="children"><div class="content">Electron replacements have existed for decades since Active Desktop and XUL were a thing, either use the system browser with a daemon&#x2F;service, or make use of Webwidgets.</div><br/></div></div></div></div><div id="39911786" class="c"><input type="checkbox" id="c-39911786" checked=""/><div class="controls bullet"><span class="by">nasso_dev</span><span>|</span><a href="#39914677">prev</a><span>|</span><a href="#39910485">next</a><span>|</span><label class="collapse" for="c-39911786">[-]</label><label class="expand" for="c-39911786">[1 more]</label></div><br/><div class="children"><div class="content">oh my god this is awesome! that&#x27;s exactly what ive been dreaming about for the past few years... wasm has a lot of potential as a portable unit of graphics&#x2F;audio&#x2F;multimedia computation! im glad you were able to take the time to build it!</div><br/></div></div><div id="39910485" class="c"><input type="checkbox" id="c-39910485" checked=""/><div class="controls bullet"><span class="by">iFire</span><span>|</span><a href="#39911786">prev</a><span>|</span><a href="#39909113">next</a><span>|</span><label class="collapse" for="c-39910485">[-]</label><label class="expand" for="c-39910485">[18 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve been doing work in Godot Engine trying to get wasm working.<p>How did you overcome the shared array buffer accessibility problem on safari vs access to ad networks which is important for online games?<p>I called it single threads vs regular builds.<p>Hope to help make sure there&#x27;s a diverse set of rendering kernels for everyone.<p>Edited: Link to our work at making portable 3d graphics on the web with an editor. <a href="https:&#x2F;&#x2F;editor.godotengine.org&#x2F;releases&#x2F;latest&#x2F;" rel="nofollow">https:&#x2F;&#x2F;editor.godotengine.org&#x2F;releases&#x2F;latest&#x2F;</a></div><br/><div id="39910769" class="c"><input type="checkbox" id="c-39910769" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910485">parent</a><span>|</span><a href="#39910550">next</a><span>|</span><label class="collapse" for="c-39910769">[-]</label><label class="expand" for="c-39910769">[1 more]</label></div><br/><div class="children"><div class="content">Big fan of Godot! I think it has done wonders to make graphics more accessible.<p>From an Adobe perspective - it doesn&#x27;t. If you go to photoshop.adobe.com in Safari, you will see the answer. Things can work in a single-threaded build, but that is not production code.<p>I can&#x27;t speak for the Safari team, but I do see this getting traction soon with the current priorities for Wasm. Seems like now the most common answer is just to use Chrome.</div><br/></div></div><div id="39910550" class="c"><input type="checkbox" id="c-39910550" checked=""/><div class="controls bullet"><span class="by">iFire</span><span>|</span><a href="#39910485">parent</a><span>|</span><a href="#39910769">prev</a><span>|</span><a href="#39911706">next</a><span>|</span><label class="collapse" for="c-39910550">[-]</label><label class="expand" for="c-39910550">[3 more]</label></div><br/><div class="children"><div class="content">We also collaborate with <a href="https:&#x2F;&#x2F;github.com&#x2F;thorvg&#x2F;thorvg">https:&#x2F;&#x2F;github.com&#x2F;thorvg&#x2F;thorvg</a>.<p>We were impressed by your work, <a href="https:&#x2F;&#x2F;github.com&#x2F;rive-app">https:&#x2F;&#x2F;github.com&#x2F;rive-app</a> and <a href="https:&#x2F;&#x2F;graphite.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;graphite.rs&#x2F;</a></div><br/><div id="39910891" class="c"><input type="checkbox" id="c-39910891" checked=""/><div class="controls bullet"><span class="by">Keavon</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39910550">parent</a><span>|</span><a href="#39911706">next</a><span>|</span><label class="collapse" for="c-39910891">[-]</label><label class="expand" for="c-39910891">[2 more]</label></div><br/><div class="children"><div class="content">Thanks! If perhaps we spoke at GDC (taking a guess given the context), it was nice meeting you! (Keavon from Graphite here.)</div><br/><div id="39911420" class="c"><input type="checkbox" id="c-39911420" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39910891">parent</a><span>|</span><a href="#39911706">next</a><span>|</span><label class="collapse" for="c-39911420">[-]</label><label class="expand" for="c-39911420">[1 more]</label></div><br/><div class="children"><div class="content">Hey Keavon, I&#x27;m also a big fan, been lurking in your Discord for years! The design of the render tree of Wasm nodes certainly took inspiration from Graphite&#x27;s node system.</div><br/></div></div></div></div></div></div><div id="39911706" class="c"><input type="checkbox" id="c-39911706" checked=""/><div class="controls bullet"><span class="by">spxneo</span><span>|</span><a href="#39910485">parent</a><span>|</span><a href="#39910550">prev</a><span>|</span><a href="#39909113">next</a><span>|</span><label class="collapse" for="c-39911706">[-]</label><label class="expand" for="c-39911706">[13 more]</label></div><br/><div class="children"><div class="content">whew game engine running on WASM + WebGPU would finally be what it takes to power browser based AAA titles. We shouldn&#x27;t have to download executables via garden walled ecosystems that take a huge chunk of devs revenues</div><br/><div id="39912416" class="c"><input type="checkbox" id="c-39912416" checked=""/><div class="controls bullet"><span class="by">jms55</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39911706">parent</a><span>|</span><a href="#39911826">next</a><span>|</span><label class="collapse" for="c-39912416">[-]</label><label class="expand" for="c-39912416">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t see WASM&#x2F;WebGPU changing anything when it comes to gaming, as an industry, personally. 3d visualizations and interactive websites? Yeah definitely a nice improvement over WebGL 2, if years late. The OP&#x27;s experience with Adobe is a great example of this.<p>WebGPU is pretty far behind what AAA games are using even as of 6 years ago. There&#x27;s extra overhead and security in the WebGPU spec that AAA games do not want. Browsers do not lend themselves to downloading 300gb of assets.<p>Additionally, indie devs aren&#x27;t using Steam for the technical capabilities. It&#x27;s purely about marketshare. Video games are a highly saturated market. The users are all on Steam, getting their recommendations from Steam, and buying games in Steam sales. Hence all the indie developers publish to Steam. I don&#x27;t see a web browser being appealing as a platform, because there&#x27;s no way for developers to advertise to users.<p>That&#x27;s also only indie games. AAA games use their own launchers, because they don&#x27;t _need_ the discoverability from being on Steam. So they don&#x27;t, and avoid the fees. If anything users _want_ the Steam monopoly, because they like the platform, and hate the walled garden launchers from AAA companies.<p>EDIT: As a concrete example of the type of problem&#x27;s WASM for games face, see this issue we discovered (can&#x27;t unload memory after you&#x27;ve loaded it, meaning you can never save memory by dropping the asset data after uploading assets to the GPU, unless you load your assets in a very specific, otherwise suboptimal sequence): <a href="https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&#x2F;issues&#x2F;12057#issuecomment-1960810877">https:&#x2F;&#x2F;github.com&#x2F;bevyengine&#x2F;bevy&#x2F;issues&#x2F;12057#issuecomment...</a><p>(I work on high end rendering features for the Bevy game engine <a href="https:&#x2F;&#x2F;bevyengine.org" rel="nofollow">https:&#x2F;&#x2F;bevyengine.org</a>, and have extensive experience with WebGPU)</div><br/><div id="39914919" class="c"><input type="checkbox" id="c-39914919" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39912416">parent</a><span>|</span><a href="#39912832">next</a><span>|</span><label class="collapse" for="c-39914919">[-]</label><label class="expand" for="c-39914919">[1 more]</label></div><br/><div class="children"><div class="content">I fully agree with you, hence why most game studios on the Web rather use streaming from hardware where those GPU capabilities are fully available than with constrained browser APIs.<p>WebGL and WebGPU are mostly fine for visualization and ecommerce, and that is about it.<p>Ah, and shadertoy like demos as well, probably their biggest use case.</div><br/></div></div><div id="39912832" class="c"><input type="checkbox" id="c-39912832" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39912416">parent</a><span>|</span><a href="#39914919">prev</a><span>|</span><a href="#39913531">next</a><span>|</span><label class="collapse" for="c-39912832">[-]</label><label class="expand" for="c-39912832">[2 more]</label></div><br/><div class="children"><div class="content">Lots of interesting points in there, and working on Bevy I&#x27;m sure you have much more extensive WebGPU expertise than me.<p>I agree that the feature set around WebGPU is constrained and becoming outdated tech compared to native platforms. It shouldn&#x27;t have taken this long just to get compute shaders into a browser, but here we are. The lack of programmable mesh pipelines is a barrier for a lot of games, and I know that&#x27;s just the beginning.<p>For memory, architecturally, that&#x27;s why I&#x27;m treating wander as a tree of nodes, each containing Wasm functions - everything gets its own stack, and there is a strategy to manage Store sizes in wasmtime. Deleting that is the only way to free memory vs a singular application compiled to Wasm with one stack&#x2F;heap&#x2F;etc. More of a data-driven visualization framework than a full engine like Bevy, which I still think is one of the most elegant ways to build browser based games and 3d environments.</div><br/><div id="39914956" class="c"><input type="checkbox" id="c-39914956" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39912832">parent</a><span>|</span><a href="#39913531">next</a><span>|</span><label class="collapse" for="c-39914956">[-]</label><label class="expand" for="c-39914956">[1 more]</label></div><br/><div class="children"><div class="content">It should be noted that the reason we don&#x27;t have compute shaders on WebGL was Chrome team dropping the ball on them.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;9ballsyndrome&#x2F;WebGL_Compute_shader&#x2F;issues&#x2F;9">https:&#x2F;&#x2F;github.com&#x2F;9ballsyndrome&#x2F;WebGL_Compute_shader&#x2F;issues...</a><p><a href="https:&#x2F;&#x2F;www.khronos.org&#x2F;webgl&#x2F;public-mailing-list&#x2F;public_webgl&#x2F;2009&#x2F;msg00000.php" rel="nofollow">https:&#x2F;&#x2F;www.khronos.org&#x2F;webgl&#x2F;public-mailing-list&#x2F;public_web...</a><p><a href="https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40150444" rel="nofollow">https:&#x2F;&#x2F;issues.chromium.org&#x2F;issues&#x2F;40150444</a></div><br/></div></div></div></div><div id="39913531" class="c"><input type="checkbox" id="c-39913531" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39912416">parent</a><span>|</span><a href="#39912832">prev</a><span>|</span><a href="#39911826">next</a><span>|</span><label class="collapse" for="c-39913531">[-]</label><label class="expand" for="c-39913531">[1 more]</label></div><br/><div class="children"><div class="content">Consider also the dramatic ... ahem ... success of the attempt to launch zero-day test versions of games via essentially VNC-via-java-in-the-browser.<p>AFAICT (I was peripherally involved with one of the companies that did this work), this really went nowhere, even though it offered &quot;play this new game from any java-equipped browser&quot;.</div><br/></div></div></div></div><div id="39911826" class="c"><input type="checkbox" id="c-39911826" checked=""/><div class="controls bullet"><span class="by">jasonjmcghee</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39911706">parent</a><span>|</span><a href="#39912416">prev</a><span>|</span><a href="#39911763">next</a><span>|</span><label class="collapse" for="c-39911826">[-]</label><label class="expand" for="c-39911826">[4 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t <a href="https:&#x2F;&#x2F;bevyengine.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bevyengine.org&#x2F;</a> do this?<p>AFAIK <a href="https:&#x2F;&#x2F;wgpu.rs&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wgpu.rs&#x2F;</a> makes this possible with Rust.<p>---<p>But this is very different than what was demonstrated in the vimeo video.</div><br/><div id="39913264" class="c"><input type="checkbox" id="c-39913264" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39911826">parent</a><span>|</span><a href="#39911763">next</a><span>|</span><label class="collapse" for="c-39913264">[-]</label><label class="expand" for="c-39913264">[3 more]</label></div><br/><div class="children"><div class="content">Not all that different. See these WGPU demos.[1]<p>As someone who&#x27;s been using the Rend3&#x2F;WGPU&#x2F;Vulkan stack for over three years, I&#x27;d like to see some of these renderer projects ship something close to a finished product. We have too many half-finished back ends.
I encourage people who want to write engines to get behind one of the existing projects and <i>push</i>.<p>[1] <a href="https:&#x2F;&#x2F;wgpu.rs&#x2F;examples&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wgpu.rs&#x2F;examples&#x2F;</a></div><br/><div id="39913426" class="c"><input type="checkbox" id="c-39913426" checked=""/><div class="controls bullet"><span class="by">jasonjmcghee</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39913264">parent</a><span>|</span><a href="#39911763">next</a><span>|</span><label class="collapse" for="c-39913426">[-]</label><label class="expand" for="c-39913426">[2 more]</label></div><br/><div class="children"><div class="content">My understanding of the project here (Renderlet) was it allowed direct embedding in other non-wasm projects, which I didn&#x27;t fully wrap my head around, allowing for injecting this engine inside of others? Or something to that effect?<p>Which is quite different than a renderer that targets wasm&#x2F;webgpu. I think super highly of, and have used wgpu a fair amount.<p>I just interpreted Renderlet to have different goals.</div><br/><div id="39913463" class="c"><input type="checkbox" id="c-39913463" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39913426">parent</a><span>|</span><a href="#39911763">next</a><span>|</span><label class="collapse" for="c-39913463">[-]</label><label class="expand" for="c-39913463">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly it. With renderlet, the goal is to compile the &quot;frontend&quot; code that&#x27;s driving the rendering pipeline to WebAssembly, and provide a runtime that embeds that in any app, with the host app providing any configuration necessary to connect renderlet modules and use its canvas.<p>On the &quot;backend&quot;, we will switch fully to wgpu as we retool around wasi-webgpu. I explicitly don&#x27;t want to rebuild a project like wgpu, and everybody should commit upstream to that - we will likely have stuff to upstream as well.</div><br/></div></div></div></div></div></div></div></div><div id="39911763" class="c"><input type="checkbox" id="c-39911763" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39911706">parent</a><span>|</span><a href="#39911826">prev</a><span>|</span><a href="#39909113">next</a><span>|</span><label class="collapse" for="c-39911763">[-]</label><label class="expand" for="c-39911763">[3 more]</label></div><br/><div class="children"><div class="content">This right here. The web is the OS of the future - the standards are getting there, the tools are just starting to catch up.</div><br/><div id="39913537" class="c"><input type="checkbox" id="c-39913537" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39911763">parent</a><span>|</span><a href="#39909113">next</a><span>|</span><label class="collapse" for="c-39913537">[-]</label><label class="expand" for="c-39913537">[2 more]</label></div><br/><div class="children"><div class="content">What platform(s) do you think browsers will run on?</div><br/><div id="39913756" class="c"><input type="checkbox" id="c-39913756" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910485">root</a><span>|</span><a href="#39913537">parent</a><span>|</span><a href="#39909113">next</a><span>|</span><label class="collapse" for="c-39913756">[-]</label><label class="expand" for="c-39913756">[1 more]</label></div><br/><div class="children"><div class="content">More of a comment on how apps are being built in the future - web-first is becoming the default.<p>I already see web even taking over in things like embedded UIs where native toolkits like QT historically were popular.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39909113" class="c"><input type="checkbox" id="c-39909113" checked=""/><div class="controls bullet"><span class="by">boomskats</span><span>|</span><a href="#39910485">prev</a><span>|</span><a href="#39910986">next</a><span>|</span><label class="collapse" for="c-39909113">[-]</label><label class="expand" for="c-39909113">[3 more]</label></div><br/><div class="children"><div class="content">Not much to add, just wanted to say I thought your presentation at wasm I&#x2F;O in Barca a couple of weeks ago was amazing and it&#x27;s great to see this work getting some attention!</div><br/><div id="39910190" class="c"><input type="checkbox" id="c-39910190" checked=""/><div class="controls bullet"><span class="by">mambru</span><span>|</span><a href="#39909113">parent</a><span>|</span><a href="#39910986">next</a><span>|</span><label class="collapse" for="c-39910190">[-]</label><label class="expand" for="c-39910190">[2 more]</label></div><br/><div class="children"><div class="content">Barca -&gt; rowing boat<p>Barça -&gt; the football club<p>Barna -&gt; cute form of Barcelona</div><br/><div id="39910362" class="c"><input type="checkbox" id="c-39910362" checked=""/><div class="controls bullet"><span class="by">boomskats</span><span>|</span><a href="#39909113">root</a><span>|</span><a href="#39910190">parent</a><span>|</span><a href="#39910986">next</a><span>|</span><label class="collapse" for="c-39910362">[-]</label><label class="expand" for="c-39910362">[1 more]</label></div><br/><div class="children"><div class="content">I guess a lot of the English-speaking world has (mis)appropriated the anglicised name of the football club?<p>Still, for what it&#x27;s worth, b7a is my favourite city so far.</div><br/></div></div></div></div></div></div><div id="39910986" class="c"><input type="checkbox" id="c-39910986" checked=""/><div class="controls bullet"><span class="by">astlouis44</span><span>|</span><a href="#39909113">prev</a><span>|</span><a href="#39911893">next</a><span>|</span><label class="collapse" for="c-39910986">[-]</label><label class="expand" for="c-39910986">[4 more]</label></div><br/><div class="children"><div class="content">Great to see more projects in the 3D graphics&#x2F;WASM space! Any tips for getting into YC?<p>For context, my team has spent the past few years porting Unreal Engine 5 to WebGPU and WebAssembly - we have a multi-threaded renderer as well as an asset streaming system that fetches in at runtime asynchronously (as needed) so users don&#x27;t need to download an entire game&#x2F;app upfront. This also frees up needing to have the whole application in memory at once. We&#x27;ve also built out a whole hosting platform and backend for developers to deploy their projects to online.<p>You can learn more about SimplyStream here:<p>Website: <a href="https:&#x2F;&#x2F;simplystream.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;simplystream.com&#x2F;</a><p>Blog post: <a href="https:&#x2F;&#x2F;simplystream.com&#x2F;create&#x2F;blog&#x2F;latest" rel="nofollow">https:&#x2F;&#x2F;simplystream.com&#x2F;create&#x2F;blog&#x2F;latest</a><p>Demos: <a href="https:&#x2F;&#x2F;simplystream.com&#x2F;demos" rel="nofollow">https:&#x2F;&#x2F;simplystream.com&#x2F;demos</a></div><br/><div id="39914974" class="c"><input type="checkbox" id="c-39914974" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39910986">parent</a><span>|</span><a href="#39913240">next</a><span>|</span><label class="collapse" for="c-39914974">[-]</label><label class="expand" for="c-39914974">[1 more]</label></div><br/><div class="children"><div class="content">Most of the demos just kill Chrome, on latest version, running on NVidia Quadro T1000.</div><br/></div></div><div id="39913240" class="c"><input type="checkbox" id="c-39913240" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39910986">parent</a><span>|</span><a href="#39914974">prev</a><span>|</span><a href="#39911748">next</a><span>|</span><label class="collapse" for="c-39913240">[-]</label><label class="expand" for="c-39913240">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been trying to run the demos in Firefox on Linux, with an NVidia 3070. For the ones that will start, I see &quot;WONDER&quot;, then a &quot;loading&quot; screen, with about 100Mb&#x2F;s download traffic for about 10 seconds. Then RAM usage increases over about two minutes to 24GB or so. Then I get &quot;Gah. Your tab just crashed&quot; in Firefox.</div><br/></div></div><div id="39911748" class="c"><input type="checkbox" id="c-39911748" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910986">parent</a><span>|</span><a href="#39913240">prev</a><span>|</span><a href="#39911893">next</a><span>|</span><label class="collapse" for="c-39911748">[-]</label><label class="expand" for="c-39911748">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m probably the worst person to ask for advice about applying to YC - it just kind of happened.<p>I was sad when UE4 sunset HTML5 support, and glad to see a spiritual successor! There are a lot of parallels to other large in-browser apps in terms of load time for games - not just for the content but the size of game code itself. Are you able to use streaming compilation or some sort of plugin model?</div><br/></div></div></div></div><div id="39911893" class="c"><input type="checkbox" id="c-39911893" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#39910986">prev</a><span>|</span><a href="#39910497">next</a><span>|</span><label class="collapse" for="c-39911893">[-]</label><label class="expand" for="c-39911893">[9 more]</label></div><br/><div class="children"><div class="content">Have you read this article by the lead developer of Flutter, Ian Hickson [0]? It describes using WASM just as you describe to have a fully cross platform UI framework, which is a concept that Flutter uses.<p>[0] <a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;1peUSMsvFGvqD5yKh3GprskLC3KVdAlLGOsK6gFoEOD0&#x2F;edit?resourcekey=0-bPajpoo9IBZpG__-uCBE6w" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;1peUSMsvFGvqD5yKh3GprskLC...</a></div><br/><div id="39912068" class="c"><input type="checkbox" id="c-39912068" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39911893">parent</a><span>|</span><a href="#39912927">next</a><span>|</span><label class="collapse" for="c-39912068">[-]</label><label class="expand" for="c-39912068">[3 more]</label></div><br/><div class="children"><div class="content">Thanks - that link does not appear to be open access, anyways I don&#x27;t think I&#x27;ve seen it. I&#x27;m familiar with Flutter at a high-level (Kevin Moore gave a great talk on it at Wasm I&#x2F;O), and I think other than requiring users to work in Dart, it is probably one of the most powerful ways to do cross-platform UI today.<p>Worth noting that their original GPU backend was Skia, and now they are retooling around Flutter GPU (Impeller)[0], which is kind of designed similarly as an abstract rendering interface over platform-specific GPU APIs.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter&#x2F;wiki&#x2F;Flutter-GPU">https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter&#x2F;wiki&#x2F;Flutter-GPU</a></div><br/><div id="39912351" class="c"><input type="checkbox" id="c-39912351" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#39911893">root</a><span>|</span><a href="#39912068">parent</a><span>|</span><a href="#39912927">next</a><span>|</span><label class="collapse" for="c-39912351">[-]</label><label class="expand" for="c-39912351">[2 more]</label></div><br/><div class="children"><div class="content">I edited the link to be public, let me know if that still works.<p>I think the ideal in that article is that people can write components in whatever languages they want, and when they compile to WASM, they can all interoperate. It reminds me of all of those compile-to-Javascript languages for writing micro-frontends, although there is not as much interoperability from a React boundary to say, a ClojureScript boundary.<p>By the way, what are you building as a solo founder for YC? Is it related to this project? For this project, I&#x27;m curious to see how exactly WASM interoperates with the GPU directly, bypassing the platform specific APIs. Do you still have to write GPU-specific parts for each of the GPU manufacturers? I wonder if there would be an open standard called WASM-GPU in the future that abstracts over these but doesn&#x27;t necessarily touch any of the OS directly.</div><br/><div id="39912696" class="c"><input type="checkbox" id="c-39912696" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39911893">root</a><span>|</span><a href="#39912351">parent</a><span>|</span><a href="#39912927">next</a><span>|</span><label class="collapse" for="c-39912696">[-]</label><label class="expand" for="c-39912696">[1 more]</label></div><br/><div class="children"><div class="content">Got it, thanks. Not what I was expecting.<p>To me, this reads like the intersection of &quot;Web Components as Wasm&quot; and &quot;The Browser as an OS&quot; - almost something analogous to WASI as browser APIs that are delivered via Wasm ABI instead of JS&#x2F;WebIDL. It&#x27;s an interesting take, and as long as it can operate alongside existing code, I&#x27;m all for that.<p>There are strong parallels to what we&#x27;re building - small modules of Wasm graphics code that can interoperate across a common interface.<p>Check the repo for the GPU integration - it&#x27;s like a super trimmed down version of wgpu, where graphics data is copied out of Wasm linear memory and a host specific API (WebGPU&#x2F;OpenGL&#x2F;DirectX) takes care of the upload to the GPU. There is a wasi-webgpu WebAssembly L1 proposal that I am involved with in the works, driven by Mendy Berger, and at some point all of this will be tooled on top of that with wgpu as a backend.<p>For renderlet the company, the goal is to build developer tools that make it easy to build renderlets and these kinds of applications without having to write raw Wasm code. The meta-compiler in the video is the first step in that direction! The runtime itself will always be open-source.</div><br/></div></div></div></div></div></div><div id="39912927" class="c"><input type="checkbox" id="c-39912927" checked=""/><div class="controls bullet"><span class="by">nmfisher</span><span>|</span><a href="#39911893">parent</a><span>|</span><a href="#39912068">prev</a><span>|</span><a href="#39912102">next</a><span>|</span><label class="collapse" for="c-39912927">[-]</label><label class="expand" for="c-39912927">[2 more]</label></div><br/><div class="children"><div class="content">Related - I’ve written a Flutter package to wrap the Filament PBR rendering package and I hacked together a WASM implementation so I could build 3D apps in Flutter for web.<p>It’s still just experimental (I’m waiting for some upstream Dart fixes to land around WASM FFI, and shared memory support would be nice in Flutter too) but I think it’s promising. Bundle size is a bit of an issue at the moment too.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;nmfisher&#x2F;flutter_filament">https:&#x2F;&#x2F;github.com&#x2F;nmfisher&#x2F;flutter_filament</a></div><br/><div id="39913137" class="c"><input type="checkbox" id="c-39913137" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39911893">root</a><span>|</span><a href="#39912927">parent</a><span>|</span><a href="#39912102">next</a><span>|</span><label class="collapse" for="c-39913137">[-]</label><label class="expand" for="c-39913137">[1 more]</label></div><br/><div class="children"><div class="content">This is awesome! I&#x27;m not fluent with Flutter&#x2F;Dart but would like to dig in to how the build &#x2F; Wasm packaging works.<p>The state of shared memory for Wasm is not great, although raw SharedArrayBuffers work ok in a browser for running multiple guests. Getting multi-memory properly working through llvm is likely a better solution.<p>We&#x27;ve got a bundle size issue as well even with -O3. I thought it was due to the amount of templated glm simd code we run, but now am convinced its deeper than that into Emscripten. Haven&#x27;t been able to look into deeply yet.</div><br/></div></div></div></div><div id="39912102" class="c"><input type="checkbox" id="c-39912102" checked=""/><div class="controls bullet"><span class="by">sheepscreek</span><span>|</span><a href="#39911893">parent</a><span>|</span><a href="#39912927">prev</a><span>|</span><a href="#39912306">next</a><span>|</span><label class="collapse" for="c-39912102">[-]</label><label class="expand" for="c-39912102">[2 more]</label></div><br/><div class="children"><div class="content">Might be this article:<p><a href="https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;u&#x2F;0&#x2F;d&#x2F;1peUSMsvFGvqD5yKh3GprskLC3KVdAlLGOsK6gFoEOD0" rel="nofollow">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;u&#x2F;0&#x2F;d&#x2F;1peUSMsvFGvqD5yKh3Gpr...</a></div><br/><div id="39912286" class="c"><input type="checkbox" id="c-39912286" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#39911893">root</a><span>|</span><a href="#39912102">parent</a><span>|</span><a href="#39912306">next</a><span>|</span><label class="collapse" for="c-39912286">[-]</label><label class="expand" for="c-39912286">[1 more]</label></div><br/><div class="children"><div class="content">nope</div><br/></div></div></div></div><div id="39912306" class="c"><input type="checkbox" id="c-39912306" checked=""/><div class="controls bullet"><span class="by">mendyberger</span><span>|</span><a href="#39911893">parent</a><span>|</span><a href="#39912102">prev</a><span>|</span><a href="#39910497">next</a><span>|</span><label class="collapse" for="c-39912306">[-]</label><label class="expand" for="c-39912306">[1 more]</label></div><br/><div class="children"><div class="content">This is the public link <a href="https:&#x2F;&#x2F;t.co&#x2F;3xeGnKhwYr" rel="nofollow">https:&#x2F;&#x2F;t.co&#x2F;3xeGnKhwYr</a></div><br/></div></div></div></div><div id="39910497" class="c"><input type="checkbox" id="c-39910497" checked=""/><div class="controls bullet"><span class="by">iFire</span><span>|</span><a href="#39911893">prev</a><span>|</span><a href="#39914590">next</a><span>|</span><label class="collapse" for="c-39910497">[-]</label><label class="expand" for="c-39910497">[2 more]</label></div><br/><div class="children"><div class="content">For cad kernels I highly recommend manifold <a href="https:&#x2F;&#x2F;github.com&#x2F;elalish&#x2F;manifold">https:&#x2F;&#x2F;github.com&#x2F;elalish&#x2F;manifold</a> to embed in your app.</div><br/><div id="39910553" class="c"><input type="checkbox" id="c-39910553" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910497">parent</a><span>|</span><a href="#39914590">next</a><span>|</span><label class="collapse" for="c-39910553">[-]</label><label class="expand" for="c-39910553">[1 more]</label></div><br/><div class="children"><div class="content">Manifold is awesome! Would love to get that integration going. I&#x27;ve implemented a lot of procedural geometry functions, but that is a long way from an actual CAD kernel.</div><br/></div></div></div></div><div id="39914590" class="c"><input type="checkbox" id="c-39914590" checked=""/><div class="controls bullet"><span class="by">baudaux</span><span>|</span><a href="#39910497">prev</a><span>|</span><a href="#39908647">next</a><span>|</span><label class="collapse" for="c-39914590">[-]</label><label class="expand" for="c-39914590">[1 more]</label></div><br/><div class="children"><div class="content">Is it limited to wasmtime or can it run in a web browser ?</div><br/></div></div><div id="39908647" class="c"><input type="checkbox" id="c-39908647" checked=""/><div class="controls bullet"><span class="by">mendyberger</span><span>|</span><a href="#39914590">prev</a><span>|</span><a href="#39908679">next</a><span>|</span><label class="collapse" for="c-39908647">[-]</label><label class="expand" for="c-39908647">[2 more]</label></div><br/><div class="children"><div class="content">Cool project!<p>Looks like it supports geometry and textures now, any plans to support shaders?</div><br/><div id="39909440" class="c"><input type="checkbox" id="c-39909440" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908647">parent</a><span>|</span><a href="#39908679">next</a><span>|</span><label class="collapse" for="c-39909440">[-]</label><label class="expand" for="c-39909440">[1 more]</label></div><br/><div class="children"><div class="content">Yes! There are a few different approaches to making that work - one would be to have an intermediate shader representation generated from Wasm compile to native platform shaders on the host graphics API. Longer-term, will likely expose WebGPU WGSL shaders to Wasm directly.</div><br/></div></div></div></div><div id="39908679" class="c"><input type="checkbox" id="c-39908679" checked=""/><div class="controls bullet"><span class="by">mendyberger</span><span>|</span><a href="#39908647">prev</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39908679">[-]</label><label class="expand" for="c-39908679">[7 more]</label></div><br/><div class="children"><div class="content">Readme says it&#x27;s a C++ library. Any plans to support higher level languages such as Go or even Python?</div><br/><div id="39908725" class="c"><input type="checkbox" id="c-39908725" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908679">parent</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39908725">[-]</label><label class="expand" for="c-39908725">[6 more]</label></div><br/><div class="children"><div class="content">Yes! It&#x27;s kind of a pain to build now, so will probably shift to shipping as a .so&#x2F;dll with a raw C api in a future version. With that, should be easy to generate bindings for any language - the host API footprint is minimal.</div><br/><div id="39908775" class="c"><input type="checkbox" id="c-39908775" checked=""/><div class="controls bullet"><span class="by">billconan</span><span>|</span><a href="#39908679">root</a><span>|</span><a href="#39908725">parent</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39908775">[-]</label><label class="expand" for="c-39908775">[5 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t follow this part. if the lib is shipped as .so&#x2F;dll, how can it be compiled into wasm?</div><br/><div id="39908880" class="c"><input type="checkbox" id="c-39908880" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908679">root</a><span>|</span><a href="#39908775">parent</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39908880">[-]</label><label class="expand" for="c-39908880">[4 more]</label></div><br/><div class="children"><div class="content">There is the host API - wander, which contains the Wasm runtime and interfaces with the GPU. The actual graphics code is always compiled to Wasm.</div><br/><div id="39910429" class="c"><input type="checkbox" id="c-39910429" checked=""/><div class="controls bullet"><span class="by">nerpderp82</span><span>|</span><a href="#39908679">root</a><span>|</span><a href="#39908880">parent</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39910429">[-]</label><label class="expand" for="c-39910429">[3 more]</label></div><br/><div class="children"><div class="content">Can one use with WebGPU in the browser? I see you answer that here <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39909440">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39909440</a><p>The primary issue with things that include their own Wasm env, that then moving that system to the web doesn&#x27;t work because you can&#x27;t run wasm in wasm.</div><br/><div id="39910471" class="c"><input type="checkbox" id="c-39910471" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908679">root</a><span>|</span><a href="#39910429">parent</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39910471">[-]</label><label class="expand" for="c-39910471">[2 more]</label></div><br/><div class="children"><div class="content">Yes! Not in the open-source repo yet (because it&#x27;s currently broken :) ) but you can see it in the video, and will have it working again soon.<p>That&#x27;s exactly the goal - one wasm binary with defined input&#x2F;outputs that can be loaded either in a browser or running in any app outside of a browser.</div><br/><div id="39911307" class="c"><input type="checkbox" id="c-39911307" checked=""/><div class="controls bullet"><span class="by">nerpderp82</span><span>|</span><a href="#39908679">root</a><span>|</span><a href="#39910471">parent</a><span>|</span><a href="#39910205">next</a><span>|</span><label class="collapse" for="c-39911307">[-]</label><label class="expand" for="c-39911307">[1 more]</label></div><br/><div class="children"><div class="content">Then effectively your non-browser container is a browser subset just for your application.<p>You could run a browser and record all the page faults, then remove all the code you didn&#x27;t run.<p><a href="https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2012&#x2F;04&#x2F;08&#x2F;metaprogramming-for-madmen&#x2F;" rel="nofollow">https:&#x2F;&#x2F;fgiesen.wordpress.com&#x2F;2012&#x2F;04&#x2F;08&#x2F;metaprogramming-for...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39910205" class="c"><input type="checkbox" id="c-39910205" checked=""/><div class="controls bullet"><span class="by">speps</span><span>|</span><a href="#39908679">prev</a><span>|</span><a href="#39911082">next</a><span>|</span><label class="collapse" for="c-39910205">[-]</label><label class="expand" for="c-39910205">[7 more]</label></div><br/><div class="children"><div class="content">I understand the appeal of Rive. However, even if their renderer is open source now, their editor isn&#x27;t and their free tier is quite limited.<p>Have a look into supporting Ruffle&#x2F;SWF content, Lottie, etc.<p>Also, for a renderer there is one by Mozilla called Pathfinder: <a href="https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;pathfinder">https:&#x2F;&#x2F;github.com&#x2F;servo&#x2F;pathfinder</a></div><br/><div id="39911412" class="c"><input type="checkbox" id="c-39911412" checked=""/><div class="controls bullet"><span class="by">neurowave</span><span>|</span><a href="#39910205">parent</a><span>|</span><a href="#39910568">next</a><span>|</span><label class="collapse" for="c-39911412">[-]</label><label class="expand" for="c-39911412">[5 more]</label></div><br/><div class="children"><div class="content">Can you share what you find limiting in the free tier? Would love to know more! I&#x27;m one of the founders btw</div><br/><div id="39912579" class="c"><input type="checkbox" id="c-39912579" checked=""/><div class="controls bullet"><span class="by">speps</span><span>|</span><a href="#39910205">root</a><span>|</span><a href="#39911412">parent</a><span>|</span><a href="#39911476">next</a><span>|</span><label class="collapse" for="c-39912579">[-]</label><label class="expand" for="c-39912579">[3 more]</label></div><br/><div class="children"><div class="content">Sure, I think it&#x27;s probably generous from the user count point of view but incredibly limited from the number of files. And it seems you have to use provided fonts in the free tier... I think Rive should offer the Editor free like Unity and then charge for additional services like console support, dedicated support, troubleshooting, etc. as that&#x27;s much more common business model for game middleware. The same applies to Unreal Engine where Switch&#x2F;PS5&#x2F;Xbox support is gated behind the respective access to the official dev portal and Epic&#x27;s own Perforce rather than GitHub. And Perforce support for example should be promoted for pro tiers.<p>I see a banner mentioning &quot;Rive for Game UI&quot; which is great to see but really the whole platform should be a Flash replacement. It shouldn&#x27;t just be for doing UIs in games or animated content, it could be used to make full 2D games. Flash was so popular because of its versatility. There were middleware taking Flash content directly into game UIs (ScaleForm) and there is middleware supporting WebKit for game UIs (Coherent labs). Both of these have extensive scripting support (respectively ActionScript and JavaScript) allowing UI designers and coders to create reactive and flexible content, even procedural content like lists of things etc.<p>By the way, the only way from mobile to get to the downloads link on the main site is only behind the online editor login. I get why but I thought at first that the Editor was online only because of that.</div><br/><div id="39912970" class="c"><input type="checkbox" id="c-39912970" checked=""/><div class="controls bullet"><span class="by">neurowave</span><span>|</span><a href="#39910205">root</a><span>|</span><a href="#39912579">parent</a><span>|</span><a href="#39912925">next</a><span>|</span><label class="collapse" for="c-39912970">[-]</label><label class="expand" for="c-39912970">[1 more]</label></div><br/><div class="children"><div class="content">I think that perhaps what you’re missing is that most of those tools charge for the runtime in some capacity. We took a different approach. The Rive Runtime and file format is free and open source, the editor is how we monetize. Users can have confidence that they will forever have access to the runtime and their files. Anybody can build an editor.<p>Regarding file limits, stay tuned for some announcements there.<p>Regarding Flash, yep that’s where we’re headed (and most of the use cases on the site should support that). We have some big features launching this year like audio, fluid layouts, and scripting. The banner was added because we’ve been attending game conferences and the game ui market segment is something we’re highlighting right now. Game UI is in dire need of better tools and it’s a market segment we can quickly lead with our current feature set.</div><br/></div></div></div></div><div id="39911476" class="c"><input type="checkbox" id="c-39911476" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910205">root</a><span>|</span><a href="#39911412">parent</a><span>|</span><a href="#39912579">prev</a><span>|</span><a href="#39910568">next</a><span>|</span><label class="collapse" for="c-39911476">[-]</label><label class="expand" for="c-39911476">[1 more]</label></div><br/><div class="children"><div class="content">Interested as well - I think you&#x27;ve built an incredibly productive editor with Rive - a spiritual successor to Flash!</div><br/></div></div></div></div><div id="39910568" class="c"><input type="checkbox" id="c-39910568" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39910205">parent</a><span>|</span><a href="#39911412">prev</a><span>|</span><a href="#39911082">next</a><span>|</span><label class="collapse" for="c-39910568">[-]</label><label class="expand" for="c-39910568">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! Lottie should be straightforward. SWF is a much higher bar, but would be useful.</div><br/></div></div></div></div><div id="39911082" class="c"><input type="checkbox" id="c-39911082" checked=""/><div class="controls bullet"><span class="by">astlouis44</span><span>|</span><a href="#39910205">prev</a><span>|</span><a href="#39914761">next</a><span>|</span><label class="collapse" for="c-39911082">[-]</label><label class="expand" for="c-39911082">[1 more]</label></div><br/><div class="children"><div class="content">Unreal Engine 5 just got a WebGPU&#x2F;WASM port:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39911041">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39911041</a></div><br/></div></div><div id="39914761" class="c"><input type="checkbox" id="c-39914761" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39911082">prev</a><span>|</span><a href="#39909391">next</a><span>|</span><label class="collapse" for="c-39914761">[-]</label><label class="expand" for="c-39914761">[2 more]</label></div><br/><div class="children"><div class="content">Listen to some of the others in this thread. Don&#x27;t waste your time with kid stuff. Stick to Unreal or Unity:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33452920">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33452920</a><p>You can get your game&#x2F;app ideas across far faster by building skills in Unreal&#x2F;Unity than by using some bespoke little engine. Collaborate with more people, too.</div><br/><div id="39914927" class="c"><input type="checkbox" id="c-39914927" checked=""/><div class="controls bullet"><span class="by">moopoo</span><span>|</span><a href="#39914761">parent</a><span>|</span><a href="#39909391">next</a><span>|</span><label class="collapse" for="c-39914927">[-]</label><label class="expand" for="c-39914927">[1 more]</label></div><br/><div class="children"><div class="content">Dismissing someone&#x27;s well thought out hard work as &quot;kid stuff&quot; is really quite rude. Do better please.</div><br/></div></div></div></div><div id="39909391" class="c"><input type="checkbox" id="c-39909391" checked=""/><div class="controls bullet"><span class="by">virtualritz</span><span>|</span><a href="#39914761">prev</a><span>|</span><a href="#39909857">next</a><span>|</span><label class="collapse" for="c-39909391">[-]</label><label class="expand" for="c-39909391">[3 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that what <a href="https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu">https:&#x2F;&#x2F;github.com&#x2F;gfx-rs&#x2F;wgpu</a> is providing?</div><br/><div id="39909542" class="c"><input type="checkbox" id="c-39909542" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39909391">parent</a><span>|</span><a href="#39909857">next</a><span>|</span><label class="collapse" for="c-39909542">[-]</label><label class="expand" for="c-39909542">[2 more]</label></div><br/><div class="children"><div class="content">Partially. wgpu can translate graphics api calls like WebGPU to platform specific APIs - this is something I had to implement on the backend. In the future, will likely tool on top of wgpu on the backend as wasi-gfx (WebGPU) becomes a reality.<p>What we do on top of that is compile the graphics code to wasm and provide a well-defined interface around it, so it can run&#x2F;work inside any application.</div><br/><div id="39913768" class="c"><input type="checkbox" id="c-39913768" checked=""/><div class="controls bullet"><span class="by">efnx</span><span>|</span><a href="#39909391">root</a><span>|</span><a href="#39909542">parent</a><span>|</span><a href="#39909857">next</a><span>|</span><label class="collapse" for="c-39913768">[-]</label><label class="expand" for="c-39913768">[1 more]</label></div><br/><div class="children"><div class="content">First off, congrats!<p>Can you elaborate on what the “graphics code” might be in this case? Many Rust graphics engines seem to cover the same ground by having asset loading cfg’d on the target (wasm vs native). What does your project provide that a dev wouldn’t get with Rust + a wasm compatible engine?</div><br/></div></div></div></div></div></div><div id="39909857" class="c"><input type="checkbox" id="c-39909857" checked=""/><div class="controls bullet"><span class="by">et1337</span><span>|</span><a href="#39909391">prev</a><span>|</span><a href="#39908453">next</a><span>|</span><label class="collapse" for="c-39909857">[-]</label><label class="expand" for="c-39909857">[4 more]</label></div><br/><div class="children"><div class="content">What’s the story with threading on the web these days? My impression was that the browsers have purposely and permanently handicapped some things necessary for performance in order to prevent things like rowhammer and speculative execution exploits. But I haven’t paid super close attention.</div><br/><div id="39910438" class="c"><input type="checkbox" id="c-39910438" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39909857">parent</a><span>|</span><a href="#39908453">next</a><span>|</span><label class="collapse" for="c-39910438">[-]</label><label class="expand" for="c-39910438">[3 more]</label></div><br/><div class="children"><div class="content">It works well now! You use a SharedArrayBuffer to communicate between Web Workers. Was indeed a dark couple of years where the meltdown stuff disabled that, but there are now specific cross-origin headers that are used to isolate the SharedArrayBuffer from outside access.</div><br/><div id="39911968" class="c"><input type="checkbox" id="c-39911968" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#39909857">root</a><span>|</span><a href="#39910438">parent</a><span>|</span><a href="#39910535">next</a><span>|</span><label class="collapse" for="c-39911968">[-]</label><label class="expand" for="c-39911968">[1 more]</label></div><br/><div class="children"><div class="content">Classic inner platform effect.<p>WASM has taken 7 years ago to get where desktop C++ was 20 years ago.  Or rather, within approximate psuedo-spitting-distance to desktop.</div><br/></div></div></div></div></div></div><div id="39908453" class="c"><input type="checkbox" id="c-39908453" checked=""/><div class="controls bullet"><span class="by">dsp_person</span><span>|</span><a href="#39909857">prev</a><span>|</span><a href="#39909740">next</a><span>|</span><label class="collapse" for="c-39908453">[-]</label><label class="expand" for="c-39908453">[11 more]</label></div><br/><div class="children"><div class="content">What do you think of sokol in comparison?</div><br/><div id="39908795" class="c"><input type="checkbox" id="c-39908795" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908453">parent</a><span>|</span><a href="#39909740">next</a><span>|</span><label class="collapse" for="c-39908795">[-]</label><label class="expand" for="c-39908795">[10 more]</label></div><br/><div class="children"><div class="content">sokol is great - I think of it as more of an &quot;STB for apps&quot;. With renderlet&#x2F;wander the goal is more to express graphics using higher level constructs and automatically generate the runtime code behind it. For example, with the Wasm build of sokol you could build a canvas-style app that directly runs in a browser, whereas with renderlet you can build a function that can parametrically render grids that can be run in (any) app like that.</div><br/><div id="39909448" class="c"><input type="checkbox" id="c-39909448" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39908795">parent</a><span>|</span><a href="#39910171">next</a><span>|</span><label class="collapse" for="c-39909448">[-]</label><label class="expand" for="c-39909448">[7 more]</label></div><br/><div class="children"><div class="content">TBH I would love an extended WASI standard with &#x27;media apis&#x27; (window, 3D, audio, input) to run sokol code compiled to WASM in without having to compile&#x2F;distribute per-platform native apps.<p>Deno seems to work on that idea [0], but having a WASI like standard would be better of course.<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;deno-windowing">https:&#x2F;&#x2F;github.com&#x2F;deno-windowing</a><p>PS: How much work was it to &quot;port&quot; the Rive renderer? Would be great to see a blog post or similar about how you approached that and about any difficulties on the way :)</div><br/><div id="39909572" class="c"><input type="checkbox" id="c-39909572" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39909448">parent</a><span>|</span><a href="#39909503">next</a><span>|</span><label class="collapse" for="c-39909572">[-]</label><label class="expand" for="c-39909572">[1 more]</label></div><br/><div class="children"><div class="content">Yes! wasi-webgpu is coming, as well as more APIs with wasi-gfx.<p>Getting rive-renderer working was not hard because in the demo its running on the host side, and not in Wasm yet, although compiling for Windows&#x2F;DX11 took some minor changes. Getting it fully working in Wasm outside of the browser looks to be non-trivial, but doable, but will likely require upstream changes.</div><br/></div></div><div id="39909503" class="c"><input type="checkbox" id="c-39909503" checked=""/><div class="controls bullet"><span class="by">mendyberger</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39909448">parent</a><span>|</span><a href="#39909572">prev</a><span>|</span><a href="#39910171">next</a><span>|</span><label class="collapse" for="c-39909503">[-]</label><label class="expand" for="c-39909503">[5 more]</label></div><br/><div class="children"><div class="content">This? <a href="https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;wasi-webgpu">https:&#x2F;&#x2F;github.com&#x2F;WebAssembly&#x2F;wasi-webgpu</a></div><br/><div id="39909548" class="c"><input type="checkbox" id="c-39909548" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39909503">parent</a><span>|</span><a href="#39910171">next</a><span>|</span><label class="collapse" for="c-39909548">[-]</label><label class="expand" for="c-39909548">[4 more]</label></div><br/><div class="children"><div class="content">Yeah, but the &#x27;wasi-canvas&#x27; part is really important to get something on screen (as opposed to &quot;just&quot; using WebGPU for compute-tasks).<p>Also a simple wasi-audio API is needed (preferrably something less overengineered than WebAudio, just a simple sample-streaming API would be perfect).</div><br/><div id="39909786" class="c"><input type="checkbox" id="c-39909786" checked=""/><div class="controls bullet"><span class="by">boomskats</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39909548">parent</a><span>|</span><a href="#39909727">next</a><span>|</span><label class="collapse" for="c-39909786">[-]</label><label class="expand" for="c-39909786">[1 more]</label></div><br/><div class="children"><div class="content">Are you involved at all with the Bytecode Alliance or the decisions around the WASI proposals&#x2F;standards? It feels like your take on these things would be super valuable given all the work you&#x27;ve done. They&#x27;re a very open minded group.</div><br/></div></div><div id="39909727" class="c"><input type="checkbox" id="c-39909727" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39909548">parent</a><span>|</span><a href="#39909786">prev</a><span>|</span><a href="#39909583">next</a><span>|</span><label class="collapse" for="c-39909727">[-]</label><label class="expand" for="c-39909727">[1 more]</label></div><br/><div class="children"><div class="content">Also, with the solid foundation and simple API footprint you&#x27;ve built for APIs like sokol_audio, would be interesting to see if they could be expressed in WIT and used as a basis for something like a wasi-audio.</div><br/></div></div><div id="39909583" class="c"><input type="checkbox" id="c-39909583" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39909548">parent</a><span>|</span><a href="#39909727">prev</a><span>|</span><a href="#39910171">next</a><span>|</span><label class="collapse" for="c-39909583">[-]</label><label class="expand" for="c-39909583">[1 more]</label></div><br/><div class="children"><div class="content">+1 for Audio and lots of other APIs necessary to make WASI more like a true OS. With Preview 2 &#x2F; Component model, hoping the pace of contributions rapidly increases.</div><br/></div></div></div></div></div></div></div></div><div id="39910171" class="c"><input type="checkbox" id="c-39910171" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39908795">parent</a><span>|</span><a href="#39909448">prev</a><span>|</span><a href="#39909740">next</a><span>|</span><label class="collapse" for="c-39910171">[-]</label><label class="expand" for="c-39910171">[2 more]</label></div><br/><div class="children"><div class="content">So kind of like a graphics transpiler?</div><br/><div id="39910363" class="c"><input type="checkbox" id="c-39910363" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908453">root</a><span>|</span><a href="#39910171">parent</a><span>|</span><a href="#39909740">next</a><span>|</span><label class="collapse" for="c-39910363">[-]</label><label class="expand" for="c-39910363">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s a good mental model. Input - high-level description of graphics, output low-level graphics code running in Wasm.</div><br/></div></div></div></div></div></div></div></div><div id="39909740" class="c"><input type="checkbox" id="c-39909740" checked=""/><div class="controls bullet"><span class="by">password4321</span><span>|</span><a href="#39908453">prev</a><span>|</span><a href="#39909710">next</a><span>|</span><label class="collapse" for="c-39909740">[-]</label><label class="expand" for="c-39909740">[2 more]</label></div><br/><div class="children"><div class="content">When you launch include WASM in the title for more traction.</div><br/><div id="39909942" class="c"><input type="checkbox" id="c-39909942" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39909740">parent</a><span>|</span><a href="#39909710">next</a><span>|</span><label class="collapse" for="c-39909942">[-]</label><label class="expand" for="c-39909942">[1 more]</label></div><br/><div class="children"><div class="content">I put it in this one too. Thanks!</div><br/></div></div></div></div><div id="39909710" class="c"><input type="checkbox" id="c-39909710" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39909740">prev</a><span>|</span><a href="#39911175">next</a><span>|</span><label class="collapse" for="c-39909710">[-]</label><label class="expand" for="c-39909710">[13 more]</label></div><br/><div class="children"><div class="content">&gt; If you think of how Unity made it easy for devs to build cross-platform games, the idea is to do the same thing for all visual applications.<p>But why wouldn&#x27;t I &quot;just&quot; use Unity?<p>I agree with you. Nobody cares about the platform specific details anymore, and people are willing to pay a little bit of money for an end-all-be-all middleware. I have gone my whole life not paying attention to a single Apple-specific API, and every single time, someone has written a better, more robust, cross-platform abstraction.<p>But Unity is already this middleware. I already can make a whole art application on top of Unity (or Unreal). People do. Sometimes people build whole platforms on top of Unity and are successful (Niantic) and some are not (Improbable). You&#x27;re one guy. You are promising creating a whole game engine - you&#x27;re going to get hung up on not using the word game engine, but that is intellectually honest, it is a game engine - which a lot of people 1,000x better capitalized than you have promised, and those people have been unable to reach parity with Unity after years of product development. So while I want you to succeed, I feel like a lot of Y Combinator guys have this, &quot;We make no mistakes, especially we do not make strategic mistakes.&quot; It&#x27;s going to be a long 3 years!</div><br/><div id="39909921" class="c"><input type="checkbox" id="c-39909921" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39909710">parent</a><span>|</span><a href="#39909846">next</a><span>|</span><label class="collapse" for="c-39909921">[-]</label><label class="expand" for="c-39909921">[3 more]</label></div><br/><div class="children"><div class="content">Without going into the motivations for building a startup and doing Y Combinator, I do agree with many of your points.<p>People can use Unity to build games and non-games. I personally don&#x27;t think it fits a lot of different use-cases or application models and that it tends to be most successful in specific gaming verticals, but if it works well for you, by all means use it!<p>I&#x27;m strategically betting both on the lines between what is viewed as a game and not blurring, as well as developers needing a friendlier, more flexible way of building this kind of interactive content. I&#x27;m by no means under the illusion that strategic mistakes won&#x27;t be made, or that this won&#x27;t be a 10-year+ journey - realistically many (most?) successful companies have a very nonlinear path, including Unity themselves.</div><br/><div id="39910523" class="c"><input type="checkbox" id="c-39910523" checked=""/><div class="controls bullet"><span class="by">mentos</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39909921">parent</a><span>|</span><a href="#39909846">next</a><span>|</span><label class="collapse" for="c-39910523">[-]</label><label class="expand" for="c-39910523">[2 more]</label></div><br/><div class="children"><div class="content">I agree Unreal and Unity are not appropriate but I do wonder about Godot. Its early enough where it doesn&#x27;t have the strong connotations of being a game engine yet. I&#x27;ve seen some cool applications made in it too (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=9kKp0oguzr8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=9kKp0oguzr8</a>). So I wonder if you could apply your energy to making it more cross platform using WASM (if that&#x27;s even necessary) and extend it with your own UI language instead of rolling your own?</div><br/><div id="39911825" class="c"><input type="checkbox" id="c-39911825" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39910523">parent</a><span>|</span><a href="#39909846">next</a><span>|</span><label class="collapse" for="c-39911825">[-]</label><label class="expand" for="c-39911825">[1 more]</label></div><br/><div class="children"><div class="content">I think Godot is the closest thing to this today, and I agree, would love to work with them! Particularly on the Wasm and packaging side of things.</div><br/></div></div></div></div></div></div><div id="39909846" class="c"><input type="checkbox" id="c-39909846" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#39909710">parent</a><span>|</span><a href="#39909921">prev</a><span>|</span><a href="#39912541">next</a><span>|</span><label class="collapse" for="c-39909846">[-]</label><label class="expand" for="c-39909846">[3 more]</label></div><br/><div class="children"><div class="content">Unity is so much larger and more complex than a graphics middleware.<p>It comes with physics engines, telemetry, networking, a c# runtime and probably even more.<p>I don’t think that any of the adobe suite would ever be built in unity bc why do they need to ship a physics engine with their photo editor.<p>Not to mention that unity is backed by an, imo, untrustworthy company who’s obviously willing to change pricing structure on a dime and retroactively.</div><br/><div id="39910228" class="c"><input type="checkbox" id="c-39910228" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39909846">parent</a><span>|</span><a href="#39909992">next</a><span>|</span><label class="collapse" for="c-39910228">[-]</label><label class="expand" for="c-39910228">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ever be built in unity bc why do they need to ship a physics engine with their photo editor.<p>I know you narrowly mean &quot;rigidbody physics for the purpose of videogames.&quot; But Adobe did ship a physics engine with their photo editor! They discontinued their &quot;3D&quot; support, and raytracing is most definitely physics with a capital P, but they were shipping it for a long time. If you have an even more normal definition of physics, to include optical physics, well they have a CV solution for many features like camera RAW processing, removing distortion, etc.<p>&gt; It comes with physics engines, telemetry, networking, a c# runtime and probably even more.<p>Because that is what people need to make multimedia applications.</div><br/></div></div><div id="39909992" class="c"><input type="checkbox" id="c-39909992" checked=""/><div class="controls bullet"><span class="by">pphysch</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39909846">parent</a><span>|</span><a href="#39910228">prev</a><span>|</span><a href="#39912541">next</a><span>|</span><label class="collapse" for="c-39909992">[-]</label><label class="expand" for="c-39909992">[1 more]</label></div><br/><div class="children"><div class="content">I agree, I think &quot;game engine&quot; is a misnomer for what are better termed &quot;game (dev) studio&quot;, like Unity. They include a sophisticated game engine but also a lot of supporting tools and GUIs.</div><br/></div></div></div></div><div id="39912541" class="c"><input type="checkbox" id="c-39912541" checked=""/><div class="controls bullet"><span class="by">joeyjojo</span><span>|</span><a href="#39909710">parent</a><span>|</span><a href="#39909846">prev</a><span>|</span><a href="#39911175">next</a><span>|</span><label class="collapse" for="c-39912541">[-]</label><label class="expand" for="c-39912541">[6 more]</label></div><br/><div class="children"><div class="content">There absolutely is a need for a robust cross-platform rendering&#x2F;multimedia solution, more in a similar vein to SDL than Unity or Unreal. The offering of Unity, Unreal, and perhaps Godot is just abysmal when considering that for all of the man hours put into the game development space, that is basically all we got. There should be hundreds of viable cross platform game engines catering to a wide variety niches that continually stretch the bounds of what a game actually is and how it can be represented. Game libraries such as Monogame, Heaps, Raylib, Love2D, etc just wouldn&#x27;t be that popular if Unity and Unreal are the be all and end all. Adobe Air was once a popular choice (a very large number of top 50 app store games were built with Adobe Air) and I&#x27;d wager still would be if it didn&#x27;t collapse under its technical weight.<p>Currently it is the low level, cross platform layer that is the most complex and the biggest hurdle towards making a game engine viable. If it wasn&#x27;t so insanely complex, and the technical barrier towards making your own engine is reduced, the tired cliche of &quot;don&#x27;t build an engine&quot; wouldn&#x27;t hold as much weight, and it opens the doors to building a bespoke, fit for purpose engine for every game you create. Don&#x27;t underestimate what an individual or small teams can produce if they are operating on a solid platform that facilitates a rich ecosystem of tools.</div><br/><div id="39914550" class="c"><input type="checkbox" id="c-39914550" checked=""/><div class="controls bullet"><span class="by">doctorpangloss</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39912541">parent</a><span>|</span><a href="#39912740">next</a><span>|</span><label class="collapse" for="c-39914550">[-]</label><label class="expand" for="c-39914550">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Game libraries such as Monogame, Heaps, Raylib, Love2D, etc just wouldn&#x27;t be that popular if Unity and Unreal are the be all and end all.<p>Just because it happens, doesn&#x27;t mean it makes sense.<p>Anyway, people write their own game engines, and programming languages for game engines, because it is intellectually stimulating to do so, and something you spend 100h&#x2F;wk to yield 1h of gameplay is still giving you more gameplay than something boring you spend 0h&#x2F;wk on.<p>Then, the people who use those engines you are naming, they end up porting to Unity anyway. If you want to deploy on iOS and Switch with one codebase, it is the only game in town. And that&#x27;s sometimes 60% of revenue.<p>&gt; Don&#x27;t underestimate what an individual or small teams can produce if they are operating on a solid platform that facilitates a rich ecosystem of tools.<p>Unity fits this bill exactly. I too want more competition. But in the real world I live in, if someone were to ask me, &quot;what solid platform should I choose to make my multimedia application, as a small team, that also has a rich ecosystem of tools, and will enable me to make pretty much anything I can think of?&quot; I would say, use Unity. Because I want them to succeed.</div><br/></div></div><div id="39912740" class="c"><input type="checkbox" id="c-39912740" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39912541">parent</a><span>|</span><a href="#39914550">prev</a><span>|</span><a href="#39911175">next</a><span>|</span><label class="collapse" for="c-39912740">[-]</label><label class="expand" for="c-39912740">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Currently it is the low level, cross platform layer that is the most complex and the biggest hurdle towards making a game engine viable<p>I couldn&#x27;t agree more. My goal is not to simply build &quot;a better game engine&quot;, but to make this kind of low-level tech accessible at a higher level and with much better dev tools to a broader class of developers and applications<p>&gt; Don&#x27;t underestimate what an individual or small teams can produce if they are operating on a solid platform<p>This gets into my motivations for building a company - larger companies have the resources to build moats, but often can&#x27;t quickly realign themselves to go after novel technical opportunities. It&#x27;s not either &#x2F; or - both models exist for very valid reasons.</div><br/><div id="39912863" class="c"><input type="checkbox" id="c-39912863" checked=""/><div class="controls bullet"><span class="by">joeyjojo</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39912740">parent</a><span>|</span><a href="#39911175">next</a><span>|</span><label class="collapse" for="c-39912863">[-]</label><label class="expand" for="c-39912863">[3 more]</label></div><br/><div class="children"><div class="content">I am glad people are working on it!!<p>Have you seen Kha by any chance? It has similar goals. I find it quite awesome, but it won&#x27;t gain mass adoption for a bunch of reasons. <a href="https:&#x2F;&#x2F;github.com&#x2F;Kode&#x2F;Kha">https:&#x2F;&#x2F;github.com&#x2F;Kode&#x2F;Kha</a><p>Someone built an immediate mode renderer on top <a href="https:&#x2F;&#x2F;github.com&#x2F;armory3d&#x2F;zui">https:&#x2F;&#x2F;github.com&#x2F;armory3d&#x2F;zui</a>, which is utilised by ArmorPaint <a href="https:&#x2F;&#x2F;armorpaint.org" rel="nofollow">https:&#x2F;&#x2F;armorpaint.org</a>. I also use Zui for my own bespoke 2D game engine.<p>I find this tech and tooling really quite amazing (just look at how little source code Zui has) given just how small the ecosystem around it is. I think Kha really illustrates what can be achievable if the lower levels have robust but simple APIs, just exposing the bare minimum as a standard for others to build upon. It really suggest taking a look at the graphics2 (2d canvas like) api.<p>For the kind of project I work on (mostly 2d games), I think it would really awesome if your framework also supported low level audio, and a variety of inputs such as keyboard, mice, and gamepads. If it also had decent text rendering support it would basically be my dream library&#x2F;framework.</div><br/><div id="39913581" class="c"><input type="checkbox" id="c-39913581" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39912863">parent</a><span>|</span><a href="#39911175">next</a><span>|</span><label class="collapse" for="c-39913581">[-]</label><label class="expand" for="c-39913581">[2 more]</label></div><br/><div class="children"><div class="content">Interesting! Had never heard of it before, will check it out. The point of Haxe seems to be as a meta-compiler to generate code for a bunch of different languages&#x2F;compilers? The same spirit of the Wasm dev experience but without the runtime.<p>Text &#x2F; fonts is very much on the roadmap! For input and audio I would have to think through the scope.</div><br/><div id="39913624" class="c"><input type="checkbox" id="c-39913624" checked=""/><div class="controls bullet"><span class="by">joeyjojo</span><span>|</span><a href="#39909710">root</a><span>|</span><a href="#39913581">parent</a><span>|</span><a href="#39911175">next</a><span>|</span><label class="collapse" for="c-39913624">[-]</label><label class="expand" for="c-39913624">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The point of Haxe seems to be as a meta-compiler to generate code for a bunch of different languages&#x2F;compilers?<p>That&#x27;s basically correct, although there is also a cross platform runtime called Hashlink but is unsupported by Kha.<p><a href="https:&#x2F;&#x2F;hashlink.haxe.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hashlink.haxe.org&#x2F;</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39911175" class="c"><input type="checkbox" id="c-39911175" checked=""/><div class="controls bullet"><span class="by">yacine_</span><span>|</span><a href="#39909710">prev</a><span>|</span><a href="#39908458">next</a><span>|</span><label class="collapse" for="c-39911175">[-]</label><label class="expand" for="c-39911175">[1 more]</label></div><br/><div class="children"><div class="content">i&#x27;ve been using sokol.h and it just works :)</div><br/></div></div><div id="39908458" class="c"><input type="checkbox" id="c-39908458" checked=""/><div class="controls bullet"><span class="by">billconan</span><span>|</span><a href="#39911175">prev</a><span>|</span><a href="#39913693">next</a><span>|</span><label class="collapse" for="c-39908458">[-]</label><label class="expand" for="c-39908458">[4 more]</label></div><br/><div class="children"><div class="content">do I still need to write platform specific shaders using this library?</div><br/><div id="39908698" class="c"><input type="checkbox" id="c-39908698" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908458">parent</a><span>|</span><a href="#39913693">next</a><span>|</span><label class="collapse" for="c-39908698">[-]</label><label class="expand" for="c-39908698">[3 more]</label></div><br/><div class="children"><div class="content">The long-term goal is no - wander should handle shader compilation automatically. In the current version, the host app has to attach a shader using the host&#x27;s shader API to render arbitrary geometry and textures.<p>Was looking at several different approaches to this, one of which would be cross-compiling wasm to spir-v. Most likely will expose a higher-level shader API (think shadertoy) and have wander compile to the platform backend. Also will be able to run WGSL shaders directly through Wasm with wasi-gfx support.</div><br/><div id="39908793" class="c"><input type="checkbox" id="c-39908793" checked=""/><div class="controls bullet"><span class="by">billconan</span><span>|</span><a href="#39908458">root</a><span>|</span><a href="#39908698">parent</a><span>|</span><a href="#39913693">next</a><span>|</span><label class="collapse" for="c-39908793">[-]</label><label class="expand" for="c-39908793">[2 more]</label></div><br/><div class="children"><div class="content">or maybe support <a href="https:&#x2F;&#x2F;github.com&#x2F;shader-slang&#x2F;slang">https:&#x2F;&#x2F;github.com&#x2F;shader-slang&#x2F;slang</a></div><br/><div id="39908894" class="c"><input type="checkbox" id="c-39908894" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39908458">root</a><span>|</span><a href="#39908793">parent</a><span>|</span><a href="#39913693">next</a><span>|</span><label class="collapse" for="c-39908894">[-]</label><label class="expand" for="c-39908894">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Will look into that</div><br/></div></div></div></div></div></div></div></div><div id="39913693" class="c"><input type="checkbox" id="c-39913693" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#39908458">prev</a><span>|</span><a href="#39912091">next</a><span>|</span><label class="collapse" for="c-39913693">[-]</label><label class="expand" for="c-39913693">[2 more]</label></div><br/><div class="children"><div class="content">Deserves a &quot;Show HN&quot;.</div><br/><div id="39913742" class="c"><input type="checkbox" id="c-39913742" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39913693">parent</a><span>|</span><a href="#39912091">next</a><span>|</span><label class="collapse" for="c-39913742">[-]</label><label class="expand" for="c-39913742">[1 more]</label></div><br/><div class="children"><div class="content">Appreciate it. It&#x27;s coming! I want to get the compiler working and generally available and everything working seamlessly for Web first. Stay tuned!</div><br/></div></div></div></div><div id="39912091" class="c"><input type="checkbox" id="c-39912091" checked=""/><div class="controls bullet"><span class="by">adfm</span><span>|</span><a href="#39913693">prev</a><span>|</span><a href="#39912774">next</a><span>|</span><label class="collapse" for="c-39912091">[-]</label><label class="expand" for="c-39912091">[2 more]</label></div><br/><div class="children"><div class="content">Is there much of a performance hit with a stereo view?</div><br/><div id="39912894" class="c"><input type="checkbox" id="c-39912894" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39912091">parent</a><span>|</span><a href="#39912774">next</a><span>|</span><label class="collapse" for="c-39912894">[-]</label><label class="expand" for="c-39912894">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t worked with stereo setups with this codebase yet, but as it is just wrapping underlying platform-specific GPU APIs, it should be a similar performance profile.<p>On average, running the Wasm guest code is about 80% of the speed of a native build I use. That is both dependent on what is running in Wasm and not a very scientific measurement - wander needs better benchmarks. We think that performance profile is sufficient for anything that needs a GPU except the highest-performance 3D games.</div><br/></div></div></div></div><div id="39912774" class="c"><input type="checkbox" id="c-39912774" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#39912091">prev</a><span>|</span><a href="#39911556">next</a><span>|</span><label class="collapse" for="c-39912774">[-]</label><label class="expand" for="c-39912774">[2 more]</label></div><br/><div class="children"><div class="content">What exactly is in a renderlet, or what assumptions does a renderlet make?<p>For example, if I wanted to LoadFromFile() + Render() the building renderlet into a deferred rendering pipeline, would I be able to do that?</div><br/><div id="39913008" class="c"><input type="checkbox" id="c-39913008" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39912774">parent</a><span>|</span><a href="#39911556">next</a><span>|</span><label class="collapse" for="c-39913008">[-]</label><label class="expand" for="c-39913008">[1 more]</label></div><br/><div class="children"><div class="content">Not much yet! :)<p>The renderlet is a bundle of WebAssembly code that handles data flow for graphics objects. Input is just function parameters, output writes serialized data to a specific place in Wasm linear memory. With the Wasm Component Model, in the future can use much more complex types as input and output.<p>LoadFromFile() - Instantiates the Wasm module<p>Render() - runs the code in the module, wander uploads the output data to the GPU<p>Functions on the render tree - do things with the uploaded GPU data - like bind a texture to a slot, or ID3D11DeviceContext::Draw, for example.<p>There&#x27;s some nuance about shading. In the current version, the host app is still responsible for attaching a shader, so should be no issue using the data in a deferred shading pipeline. In the future, the renderlet needs to be able to attach its own shaders, in which case it would have to be configured to use a host app&#x27;s deferred shading pipeline. I think it is possible, but complicated, to build an API for this, where the host and then the renderlet are both involved in a lighting pass.<p>Of course, if all shading is handled within the renderlet, it entirely the concept of deferred shading, and this becomes an easier problem to solve.</div><br/></div></div></div></div><div id="39911556" class="c"><input type="checkbox" id="c-39911556" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#39912774">prev</a><span>|</span><a href="#39913917">next</a><span>|</span><label class="collapse" for="c-39911556">[-]</label><label class="expand" for="c-39911556">[4 more]</label></div><br/><div class="children"><div class="content">Totally off-topic, but in that video you have some preview view on the right-side of your code window in VS where you can scroll visually through a large file. How the hell do you switch that on? I&#x27;ve been using VS for 30 years and never seen that, but it would be really helpful for the shitty apps that I write for my own use which are single-file monsters.</div><br/><div id="39911604" class="c"><input type="checkbox" id="c-39911604" checked=""/><div class="controls bullet"><span class="by">morder</span><span>|</span><a href="#39911556">parent</a><span>|</span><a href="#39913917">next</a><span>|</span><label class="collapse" for="c-39911604">[-]</label><label class="expand" for="c-39911604">[3 more]</label></div><br/><div class="children"><div class="content">Right click the scroll bar and choose &quot;scroll bar options&quot; then under &quot;behavoior&quot; select the 2nd option with the source overview set to &quot;wide&quot;</div><br/><div id="39911868" class="c"><input type="checkbox" id="c-39911868" checked=""/><div class="controls bullet"><span class="by">qingcharles</span><span>|</span><a href="#39911556">root</a><span>|</span><a href="#39911604">parent</a><span>|</span><a href="#39911679">next</a><span>|</span><label class="collapse" for="c-39911868">[-]</label><label class="expand" for="c-39911868">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! :) I&#x27;d gone through every menu and right-clicked everywhere except the scroll-bar.<p>For anyone else that ends up here, I also had to click the radio button for &quot;Map mode&quot; too.</div><br/></div></div><div id="39911679" class="c"><input type="checkbox" id="c-39911679" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39911556">root</a><span>|</span><a href="#39911604">parent</a><span>|</span><a href="#39911868">prev</a><span>|</span><a href="#39913917">next</a><span>|</span><label class="collapse" for="c-39911679">[-]</label><label class="expand" for="c-39911679">[1 more]</label></div><br/><div class="children"><div class="content">This. I think it used to be a productivity power tool that they since incorporated into the core editor.</div><br/></div></div></div></div></div></div><div id="39913917" class="c"><input type="checkbox" id="c-39913917" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#39911556">prev</a><span>|</span><a href="#39909480">next</a><span>|</span><label class="collapse" for="c-39913917">[-]</label><label class="expand" for="c-39913917">[3 more]</label></div><br/><div class="children"><div class="content">There is (surprisingly) no high level commentary on what this actually is, but people banging on about how nice it would be to have a high level cross platform GPU accelerated  library.<p>...but this..?<p>&gt; Graphics data and code can be developed together in the same environment, packaged together into a WebAssembly module called a renderlet, and rendered onto any canvas. With WebAssembly, we compile graphics code to portable bytecode that allows it to safely run on any processor and GPU<p>So what is a renderlet?<p>&gt; The renderlet compiler is currently in closed preview - please contact us for more information.<p>Hm... what this seems to be is a <i>C++ library</i> that lets you take <i>compiled WASM</i> and run it to generate and render graphics.<p>Which, I think it is fair to say, it&#x27;s surprising, because you can already render graphics using C++.<p>Only here, you can render graphics using an external WASM binary.<p>So, why?<p>Specifically, if you&#x27;re <i>already using C++</i>:<p>1) Why use WASM?<p>2) Why use renderlet instead of webGPU, which is already a high level cross platform abstraction <i>including</i> shader definitions?<p>What is this even for?<p>&gt; wander is designed to be a rendering engine for any high-performance application. It primarily is designed as the runtime to run renderlet bundles<p>...but, why would I use a renderlet, if I already need to be writing C++?<p>I. Get. It. A cross platform GPU accelerated rendering library you can use from any platform &#x2F; browser &#x2F; app would be great. ...but that is <i>not</i> what this is.<p>This is a C++ library <i>runtime</i> that you can use to run graphics in any circumstance where you you <i>can currently use C++</i>.<p>...but, in circumstances where I can use C++, I have many other options for rendering graphics.<p>Look at the workflow:<p><pre><code>    Rendering code -&gt; Renderlet compiler -&gt; renderlet binary
    App -&gt; load renderlet binary -&gt; start renderlet runtime -&gt; execute binary on runtime -&gt; rendered
</code></pre>
vs.<p><pre><code>    App -&gt; rendering code (WebGPU) -&gt; rendered
</code></pre>
or, if you writing a new cross platform API over the top of webGPU<p><pre><code>    App -&gt; Fancy api -&gt; WebGPU -&gt; rendered
    </code></pre>
I had a good read of the docs, but I honestly fail to see how this is more useful than just having a C++ library that renders graphics cross platform like SDL.<p>Shaders? Well, we also already have a good cross platform rendering library in webGPU; it already runs on desktop and browsers (maybe even some mobile devices); it already has a cross platform shader pipeline; it&#x27;s already usable from C++.<p>I&#x27;m not going to deny the webGPU API is kind of frustrating to use, and the tooling for building WASM binaries is too, but... it does actually exist.<p>Is this like a &#x27;alternative to webGPU&#x27; with a different API &#x2F; easy mode tooling?<p>...or, have I missed it completely and there&#x27;s something more to this?</div><br/><div id="39914122" class="c"><input type="checkbox" id="c-39914122" checked=""/><div class="controls bullet"><span class="by">seanisom</span><span>|</span><a href="#39913917">parent</a><span>|</span><a href="#39909480">next</a><span>|</span><label class="collapse" for="c-39914122">[-]</label><label class="expand" for="c-39914122">[2 more]</label></div><br/><div class="children"><div class="content">Keeping it high level -<p>No, the goal is not to create a C++ API to give you GPU functions.<p>The C++ API for wander is used to embed the WebAssembly module of graphics code into the application. The API footprint is very small - load a file, pass parameters to it, iterate through the tree it produces.<p>This could be viewed as logically equivalent to programmatically loading a flash&#x2F;swf file. Or similar to what Rive has built with a .riv, although this is static content, not code.<p>&gt; 1) Why use WASM?<p>You&#x27;re loading arbitrary, third-party code into an app - that is the renderlet. The benefit is to have a sandboxed environment to run code to put data on the GPU.<p>2) Why use renderlet instead of webGPU, which is already a high level cross platform abstraction including shader definitions?<p>WebGPU is a low-level API. If you are a graphics programmer, and want to build an app around WebGPU, go for it! A renderlet is more of a graphics plugin system than an entire first-party app.<p>&gt; The renderlet compiler is currently in closed preview - please contact us for more information.<p>This is the system to build the renderlet. This is not writing raw C++ code to talk to WebGPU, this can be higher-level functions (build a grid, perform a geometric extrusion, generate a gradient) - you can see in the video it is a yaml specification. The compiler generate the necessary commands, vertex buffers, textures, etc, and soon, shaders to do this, and builds a Wasm module out of it.<p>&gt; Is this like a &#x27;alternative to webGPU&#x27; with a different API &#x2F; easy mode tooling?<p>I certainly wouldn&#x27;t describe it as an alternative to WebGPU, but easy(er) tooling to build graphics, yes.<p>&gt; What is the use-case for &#x27;I&#x27;ve compiled a part of my application only into a cross platform binary renderlet and I can now run that cross platform ... after I&#x27;ve compiled the rest of my application into a platform specific binary for the platform I&#x27;m running it on?&#x27;<p>Let&#x27;s take an example - Temporal Anti-Aliasing. There are libraries that exist to implement this, or you can implement it through raw code. This requires changes structural changes to your pipeline - to your render targets, additional outputs to your shaders, running additional shaders, etc. Wouldn&#x27;t it be nice to easy connect a module to your graphics pipeline that contains the code for this, and the shader stages, and works across platforms and graphics APIs, with data-driven configuration? That is the vision.<p>&gt; ... rest of your application into WASM&#x2F;platform native code... is that not strange? It seems strange to me<p>There is not really such a thing as a standalone Wasm application. It has seen great success as a data-driven plugin model. In a browser, it is hosted with &#x2F; interacts with JavaScript. Even built for pure WASI, as a standalone app where everything is compiled into a single module, there is stil a runtime&#x2F;host environment.<p>Does that help clarify?</div><br/><div id="39914637" class="c"><input type="checkbox" id="c-39914637" checked=""/><div class="controls bullet"><span class="by">wokwokwok</span><span>|</span><a href="#39913917">root</a><span>|</span><a href="#39914122">parent</a><span>|</span><a href="#39909480">next</a><span>|</span><label class="collapse" for="c-39914637">[-]</label><label class="expand" for="c-39914637">[1 more]</label></div><br/><div class="children"><div class="content">&gt; A renderlet is more of a graphics plugin system than an entire first-party app.<p>I see.<p>So this is basically flash?<p>A high level API to build binary application bundles (aka .swf files, ie. renderlets) and a runtime that lets you execute arbitrary applications in a sandbox.<p>renderlet = .swf file<p>wander = flash runtime<p>renderlet compiler = magic sauce, macromedia flash editor<p>yeah?<p>&gt; Let&#x27;s take an example - Temporal Anti-Aliasing. There are libraries that exist to implement this, or you can implement it through raw code.<p>Mhm. You can certainly do it in a cross platform way using webGPU, but I suppose I can see the vision of &#x27;just download this random binary and it&#x27;ll add SMAA&#x27; but it <i>sounds</i> a lot like &quot;and then we&#x27;ll have a marketplace where people can buy and sell GPU plugins&quot; or &quot;if you&#x27;re building a web browser&quot; rather than &quot;and this is something that is useful to someone developing a visualization application from scratch&quot;.<p>The majority of these features <i>could</i> exist with just a C++ library and no requirement to &#x27;pre-compile&#x27; some of your code into a renderlet... hosting external arbitrary 3rd party binaries in your application seems... niche.<p>Really, the only reason you would normally ever not just do it from source as a monolithic part of your application was if you didn&#x27;t have the source code for some reason (eg. because you bought it as a WASM binary from someone).<p>Smells like Flash, and I&#x27;m not sure I like that, but I guess I can see the vision now, thanks for explaining.</div><br/></div></div></div></div></div></div><div id="39909480" class="c"><input type="checkbox" id="c-39909480" checked=""/><div class="controls bullet"><span class="by">netbioserror</span><span>|</span><a href="#39913917">prev</a><span>|</span><label class="collapse" for="c-39909480">[-]</label><label class="expand" for="c-39909480">[2 more]</label></div><br/><div class="children"><div class="content">Saved. This is the sort of project that would be an amazing canvas for a nice widget kit and interaction model to make cross-platform GUIs with. The C&#x2F;C++ backend and WASM target means people could build FFIs in almost any language. I&#x27;m sure I&#x27;m saying nothing new, but this is promising.</div><br/></div></div></div></div></div></div></div></body></html>