<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725699671405" as="style"/><link rel="stylesheet" href="styles.css?v=1725699671405"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kmcd.dev/posts/grpc-the-ugly-parts/">gRPC: The Ugly Parts</a> <span class="domain">(<a href="https://kmcd.dev">kmcd.dev</a>)</span></div><div class="subtext"><span>ingve</span> | <span>51 comments</span></div><br/><div><div id="41471267" class="c"><input type="checkbox" id="c-41471267" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#41472098">next</a><span>|</span><label class="collapse" for="c-41471267">[-]</label><label class="expand" for="c-41471267">[9 more]</label></div><br/><div class="children"><div class="content">&gt; There’s always a lingering question about Google’s long-term commitment to gRPC and protobuf. Will they continue to invest in these open-source projects, or could they pull the plug if priorities shift?<p>Google could not function as a company without protobuf. It is ingrained deeply into every inch of their stack.<p>Likewise, gRPC is the main public-facing interface for GCP. It&#x27;s not going anywhere.</div><br/><div id="41471484" class="c"><input type="checkbox" id="c-41471484" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#41471267">parent</a><span>|</span><a href="#41471290">next</a><span>|</span><label class="collapse" for="c-41471484">[-]</label><label class="expand" for="c-41471484">[3 more]</label></div><br/><div class="children"><div class="content">Google continuing to use gRPC and protobuf internally and Google continuing to invest in the open-source projects are not the same thing. It being so central to Google isn&#x27;t necessarily even a good thing for people outside Google; it means there&#x27;s a lot of potential for changes which are very good for Google but very pain for everone else.</div><br/><div id="41471697" class="c"><input type="checkbox" id="c-41471697" checked=""/><div class="controls bullet"><span class="by">rougka</span><span>|</span><a href="#41471267">root</a><span>|</span><a href="#41471484">parent</a><span>|</span><a href="#41471290">next</a><span>|</span><label class="collapse" for="c-41471697">[-]</label><label class="expand" for="c-41471697">[2 more]</label></div><br/><div class="children"><div class="content">protobuf might as well never disappear as it is so central to Google. gRPC however is hardly used internally compared to stubby which is the actual essential version</div><br/><div id="41471917" class="c"><input type="checkbox" id="c-41471917" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#41471267">root</a><span>|</span><a href="#41471697">parent</a><span>|</span><a href="#41471290">next</a><span>|</span><label class="collapse" for="c-41471917">[-]</label><label class="expand" for="c-41471917">[1 more]</label></div><br/><div class="children"><div class="content">Depends whether you consider Google Cloud <i>internal</i> to Google.</div><br/></div></div></div></div></div></div><div id="41471290" class="c"><input type="checkbox" id="c-41471290" checked=""/><div class="controls bullet"><span class="by">shaldengeki</span><span>|</span><a href="#41471267">parent</a><span>|</span><a href="#41471484">prev</a><span>|</span><a href="#41471446">next</a><span>|</span><label class="collapse" for="c-41471290">[-]</label><label class="expand" for="c-41471290">[2 more]</label></div><br/><div class="children"><div class="content">Their commitment to open source, however, might go.<p>Quite recently Google quietly unshipped an effort to make their protobuf build rules more useful to OSS users of Bazel (see the rules_proto repository). This wasted a huge amount of planning and work that&#x27;d gone into the migration.<p>And the fact that these tools are designed first and foremost for Google use shows up everywhere. Stuff that Google fundamentally doesn&#x27;t care about but is widely used (eg Ruby) is stagnant.<p>In this state, it&#x27;s totally reasonable to reconsider whether these tools are worth building on top of. I personally still believe! But I don&#x27;t blame people who are skeptical.</div><br/><div id="41471631" class="c"><input type="checkbox" id="c-41471631" checked=""/><div class="controls bullet"><span class="by">jatins</span><span>|</span><a href="#41471267">root</a><span>|</span><a href="#41471290">parent</a><span>|</span><a href="#41471446">next</a><span>|</span><label class="collapse" for="c-41471631">[-]</label><label class="expand" for="c-41471631">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Their commitment to open source, however, might go<p>Google&#x27;s OSS contributions are largely correlated to the fact that they could _afford_ to do OSS. When you have the best business model in the world, you can afford X% of your engineering hours focused on OSS. Of course, it&#x27;s purely not altruistic they also get back a lot in return<p>However, if due to AI or other advancements, Google&#x27;s business model takes a hit I wouldn&#x27;t be surprised that their OSS contributions are the first to go off. Like we saw Google codejam being discontinued in 2022 layoffs<p>Though if your business outlives Google, gRPC going away might be least of your problems</div><br/></div></div></div></div><div id="41471446" class="c"><input type="checkbox" id="c-41471446" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#41471267">parent</a><span>|</span><a href="#41471290">prev</a><span>|</span><a href="#41472098">next</a><span>|</span><label class="collapse" for="c-41471446">[-]</label><label class="expand" for="c-41471446">[3 more]</label></div><br/><div class="children"><div class="content">(disclosure: ex-grpc-team here)<p>Indeed. I&#x27;m quite confident there&#x27;s never been an RPC library with so many man-years invested in it. Last month was gRPConf and it appeared it was as staffed as ever, if not more, and Rust is being adopted as a new first class language too.</div><br/><div id="41471485" class="c"><input type="checkbox" id="c-41471485" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#41471267">root</a><span>|</span><a href="#41471446">parent</a><span>|</span><a href="#41472098">next</a><span>|</span><label class="collapse" for="c-41471485">[-]</label><label class="expand" for="c-41471485">[2 more]</label></div><br/><div class="children"><div class="content">any videos from the event? I saw bunch of slides (pdf, ppt), but that&#x27;s about it...</div><br/><div id="41471649" class="c"><input type="checkbox" id="c-41471649" checked=""/><div class="controls bullet"><span class="by">tgma</span><span>|</span><a href="#41471267">root</a><span>|</span><a href="#41471485">parent</a><span>|</span><a href="#41472098">next</a><span>|</span><label class="collapse" for="c-41471649">[-]</label><label class="expand" for="c-41471649">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure videos are recorded for YouTube. I know my own talk was. I expect them to be posted this week or next.</div><br/></div></div></div></div></div></div></div></div><div id="41472098" class="c"><input type="checkbox" id="c-41472098" checked=""/><div class="controls bullet"><span class="by">zigzag312</span><span>|</span><a href="#41471267">prev</a><span>|</span><a href="#41471952">next</a><span>|</span><label class="collapse" for="c-41472098">[-]</label><label class="expand" for="c-41472098">[1 more]</label></div><br/><div class="children"><div class="content">Some more bad parts related to protobuf:<p>- While nearly all fields are forced to be optional&#x2F;nullable, lists and maps can only be empty, not null.<p>- No generics (leads to more repetition in some cases).<p>- Custom existing types are not supported. WKT thus require hardcoded codegen (this is a mistake IMO). It limits flexibility or requires much more manual code writing. For example, if I have codebase that uses Instant type (instead of DateTime from standard library) to represent UTC time, there is no build-in way to automate this mapping, even though it could equally well map to the same over-the-wire format as DateTime (which has a hardcoded support). If that kind of extensions would be supported, even specific cases like mapping a collection of timestamps to double delta encoded byte array over-the-wire could be supported. This wouldn&#x27;t require any changes to the underlying over-the-wire format (just more flexible codegen).</div><br/></div></div><div id="41471952" class="c"><input type="checkbox" id="c-41471952" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41472098">prev</a><span>|</span><a href="#41471246">next</a><span>|</span><label class="collapse" for="c-41471952">[-]</label><label class="expand" for="c-41471952">[1 more]</label></div><br/><div class="children"><div class="content">I 100% agree with the enum rules, the frustrating lack of required, but I do disagree with the “oh no FE couldn’t use it out of the box”.<p>It’s actually ok that not everything need accomodate every single environment and situation. I’d personally like to see some _more_ RPC mechanisms for service-to-service that don’t need to accommodate the lowest-common-denominator-browser-http-requirements, there’s plenty of situations where there’s no browser involved.</div><br/></div></div><div id="41471246" class="c"><input type="checkbox" id="c-41471246" checked=""/><div class="controls bullet"><span class="by">kyle787</span><span>|</span><a href="#41471952">prev</a><span>|</span><a href="#41471368">next</a><span>|</span><label class="collapse" for="c-41471246">[-]</label><label class="expand" for="c-41471246">[6 more]</label></div><br/><div class="children"><div class="content">Originally, I was going to complain that this is more of a critique of the grpc ecosystem rather than protocol.<p>IMO, readability of generated code, is largely a non concern for the vast majority use cases. Additionally, if anything it&#x27;s more so a criticism of the codegen tool. Same with the complaints around the http server used with go.<p>However, I totally agree with criticisms of the enum naming conventions. It&#x27;s an abomination and super leaky. Made worse by the fact it&#x27;s part of the official(?) style guide <a href="https:&#x2F;&#x2F;protobuf.dev&#x2F;programming-guides&#x2F;style&#x2F;#enums" rel="nofollow">https:&#x2F;&#x2F;protobuf.dev&#x2F;programming-guides&#x2F;style&#x2F;#enums</a></div><br/><div id="41471634" class="c"><input type="checkbox" id="c-41471634" checked=""/><div class="controls bullet"><span class="by">enneff</span><span>|</span><a href="#41471246">parent</a><span>|</span><a href="#41471388">next</a><span>|</span><label class="collapse" for="c-41471634">[-]</label><label class="expand" for="c-41471634">[2 more]</label></div><br/><div class="children"><div class="content">To be fair, the ecosystem is kind of inextricably tied to the protocol. I’m not aware of any other production grade Go gRPC implementations besides the official one.</div><br/><div id="41471822" class="c"><input type="checkbox" id="c-41471822" checked=""/><div class="controls bullet"><span class="by">kyle787</span><span>|</span><a href="#41471246">root</a><span>|</span><a href="#41471634">parent</a><span>|</span><a href="#41471388">next</a><span>|</span><label class="collapse" for="c-41471822">[-]</label><label class="expand" for="c-41471822">[1 more]</label></div><br/><div class="children"><div class="content">But grpc isn&#x27;t limited to go. Criticizing gprc, as a whole, for the http library used with go isn&#x27;t valid. However, it&#x27;s fair to take issue with the choice of http library used by the most popular go codegen tool.</div><br/></div></div></div></div><div id="41471388" class="c"><input type="checkbox" id="c-41471388" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41471246">parent</a><span>|</span><a href="#41471634">prev</a><span>|</span><a href="#41471368">next</a><span>|</span><label class="collapse" for="c-41471388">[-]</label><label class="expand" for="c-41471388">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>IMO, readability of generated code, is largely a non concern for the vast majority use cases</i><p>Completely disagree.  More often than I&#x27;d like to, I&#x27;ve had to read generated code from various codegen tools in order to figure out what it was doing (in order to fix my usage of that code where I was making bad assumptions about the generated interface) or figure out why the generated code wasn&#x27;t doing what it was supposed to (because it was was buggy).  All code eventually needs to be read by someone, even code that&#x27;s generated on the fly during the build process.</div><br/><div id="41471770" class="c"><input type="checkbox" id="c-41471770" checked=""/><div class="controls bullet"><span class="by">kyle787</span><span>|</span><a href="#41471246">root</a><span>|</span><a href="#41471388">parent</a><span>|</span><a href="#41471526">next</a><span>|</span><label class="collapse" for="c-41471770">[-]</label><label class="expand" for="c-41471770">[1 more]</label></div><br/><div class="children"><div class="content">In that case, I would imagine you would struggle with any clients generated via an IDL. The same &quot;issue&quot; occurs with openapi&#x2F;swagger generated clients.<p>If you&#x27;re not working on whatever is responsible for generating the code, you&#x27;re not supposed to have to look under the hood.  The whole purpose is to abstract away the implementation details, it&#x27;s contract driven development. If you find yourself frequently needing to read the underlying code to figure out what&#x27;s going on, the problem isn&#x27;t with the tool, it&#x27;s elsewhere.</div><br/></div></div><div id="41471526" class="c"><input type="checkbox" id="c-41471526" checked=""/><div class="controls bullet"><span class="by">marvin-hansen</span><span>|</span><a href="#41471246">root</a><span>|</span><a href="#41471388">parent</a><span>|</span><a href="#41471770">prev</a><span>|</span><a href="#41471368">next</a><span>|</span><label class="collapse" for="c-41471526">[-]</label><label class="expand" for="c-41471526">[1 more]</label></div><br/><div class="children"><div class="content">I read the generated code quite often and each time it boggles my mind who in the world came up with that crap. The readability and code quality is seriously awful and it is a valid criticism. When the generated code indeed is buggy, this a double whammer.<p>However, it is also true that a lot of devs don&#x27;t read it or simply don&#x27;t care so I would argue it is mostly a non-issue in practice contrary to what the author of the article suggest. My life is certainly not affected by ugly generated code.<p>Also, worth mentioning, when I wrote code generators in the past, albeit less complex, it&#x27;s rarely the common case that makes the generated code ugly, but rather the coverage of a gazillion corner cases.<p>Can the generatee code be 2-4% faster? Sure. Is anyone updating the code generator for that? Well, if you feel the small gain is worth the pain of touching a fairly complicated generator that produces already monstrous code, patch it, test it, and fill a PR. Point is, none of the proto maintainer is moving a finger for 2% better.</div><br/></div></div></div></div></div></div><div id="41471368" class="c"><input type="checkbox" id="c-41471368" checked=""/><div class="controls bullet"><span class="by">danans</span><span>|</span><a href="#41471246">prev</a><span>|</span><a href="#41472082">next</a><span>|</span><label class="collapse" for="c-41471368">[-]</label><label class="expand" for="c-41471368">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Even though it’s not meant to be hand-edited, this can impact code readability and maintainability<p>This kind of implies that the generated code is being checked into a repo.<p>While that works, it&#x27;s not the way things are done at Google, where protobuf codegen happens at build time, and generated code is placed in a temporary build&#x2F;dist directory.<p>Either way , you shouldn&#x27;t need to do any maintenance on protobuf generated code, whether you add it to a repo or use it as a temporary build artifact.</div><br/><div id="41471790" class="c"><input type="checkbox" id="c-41471790" checked=""/><div class="controls bullet"><span class="by">jeeyoungk</span><span>|</span><a href="#41471368">parent</a><span>|</span><a href="#41471376">next</a><span>|</span><label class="collapse" for="c-41471790">[-]</label><label class="expand" for="c-41471790">[2 more]</label></div><br/><div class="children"><div class="content">The Go ecosystem (at least in the public) heavily encourages committing all generated code as go code is meant to be functional via a simple `go get`. Even a popular project like Kubernetes is full of generated protobufs committed in the codebase.</div><br/><div id="41471980" class="c"><input type="checkbox" id="c-41471980" checked=""/><div class="controls bullet"><span class="by">febusravenga</span><span>|</span><a href="#41471368">root</a><span>|</span><a href="#41471790">parent</a><span>|</span><a href="#41471376">next</a><span>|</span><label class="collapse" for="c-41471980">[-]</label><label class="expand" for="c-41471980">[1 more]</label></div><br/><div class="children"><div class="content">Next ecosystem totally forgot what proper makefile is... And they arguing it is innovative and pragmatic. Sad.</div><br/></div></div></div></div><div id="41471376" class="c"><input type="checkbox" id="c-41471376" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41471368">parent</a><span>|</span><a href="#41471790">prev</a><span>|</span><a href="#41471404">next</a><span>|</span><label class="collapse" for="c-41471376">[-]</label><label class="expand" for="c-41471376">[1 more]</label></div><br/><div class="children"><div class="content">I agree, and that&#x27;s how I do things, but I still think the readability of generated code is important.  I want to know what generated code is doing, and more often than I&#x27;d like, I run into problems with it, and need to trace through it to find out what&#x27;s going on.  Sometimes this just makes it easier to submit a thorough bug report (or even a patch) to the maintainer of the codegen tool, but often by tracing through what&#x27;s going wrong I can find a way to work around the problem.  Readability is definitely something I look for in generated code.</div><br/></div></div><div id="41471404" class="c"><input type="checkbox" id="c-41471404" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41471368">parent</a><span>|</span><a href="#41471376">prev</a><span>|</span><a href="#41472082">next</a><span>|</span><label class="collapse" for="c-41471404">[-]</label><label class="expand" for="c-41471404">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This kind of implies that the generated code is being checked into a repo.<p>I wouldn’t say that. I observe uncommitted generated code all the time. Sometimes I want to read the code just to understand how the heck something works. Or I step into it in a debugger.<p>I definitely believe that generated code should be pleasant to read.</div><br/></div></div></div></div><div id="41472082" class="c"><input type="checkbox" id="c-41472082" checked=""/><div class="controls bullet"><span class="by">bboreham</span><span>|</span><a href="#41471368">prev</a><span>|</span><a href="#41472349">next</a><span>|</span><label class="collapse" for="c-41472082">[-]</label><label class="expand" for="c-41472082">[3 more]</label></div><br/><div class="children"><div class="content">Whilst gRPC is nearly always used together with protobuf, I think it’s important to note they are different projects. 
gRPC is a CNCF project with open governance. gRPC people show up at industry conferences like KubeCon and run their own conference.<p>Protobuf is a Google-internal project, with opaque governance and no conference.<p>I find it striking that the one has such tight dependencies on the other. Indeed the article is mostly about protobuf.</div><br/><div id="41472156" class="c"><input type="checkbox" id="c-41472156" checked=""/><div class="controls bullet"><span class="by">Scaevolus</span><span>|</span><a href="#41472082">parent</a><span>|</span><a href="#41472349">next</a><span>|</span><label class="collapse" for="c-41472156">[-]</label><label class="expand" for="c-41472156">[2 more]</label></div><br/><div class="children"><div class="content">gRPC actually doesn&#x27;t care that much about the serialization method. It&#x27;s straightforward to use JSON, MsgPack, BSON, CapnProto, and so on with gRPC instead of protobuf.</div><br/><div id="41472240" class="c"><input type="checkbox" id="c-41472240" checked=""/><div class="controls bullet"><span class="by">bboreham</span><span>|</span><a href="#41472082">root</a><span>|</span><a href="#41472156">parent</a><span>|</span><a href="#41472349">next</a><span>|</span><label class="collapse" for="c-41472240">[-]</label><label class="expand" for="c-41472240">[1 more]</label></div><br/><div class="children"><div class="content">Right. Any examples of popular programs doing this?</div><br/></div></div></div></div></div></div><div id="41472349" class="c"><input type="checkbox" id="c-41472349" checked=""/><div class="controls bullet"><span class="by">rollulus</span><span>|</span><a href="#41472082">prev</a><span>|</span><a href="#41440095">next</a><span>|</span><label class="collapse" for="c-41472349">[-]</label><label class="expand" for="c-41472349">[1 more]</label></div><br/><div class="children"><div class="content">The remark about reflection for the Go implementation surprised me. I always treated the generated code as a black box, but occasionally saw their diffs, and assumed the byte blobs to be for clever generated marshalling. If not, what are they used for?</div><br/></div></div><div id="41440095" class="c"><input type="checkbox" id="c-41440095" checked=""/><div class="controls bullet"><span class="by">denysvitali</span><span>|</span><a href="#41472349">prev</a><span>|</span><a href="#41471275">next</a><span>|</span><label class="collapse" for="c-41440095">[-]</label><label class="expand" for="c-41440095">[1 more]</label></div><br/><div class="children"><div class="content">Wow, what a nice article! Every point of it matches my experience (mostly positive) and buffrs [1] is a tool I wasn&#x27;t aware of.
Thanks for sharing this article!<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;helsing-ai&#x2F;buffrs?tab=readme-ov-file">https:&#x2F;&#x2F;github.com&#x2F;helsing-ai&#x2F;buffrs?tab=readme-ov-file</a></div><br/></div></div><div id="41471275" class="c"><input type="checkbox" id="c-41471275" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#41440095">prev</a><span>|</span><a href="#41471335">next</a><span>|</span><label class="collapse" for="c-41471275">[-]</label><label class="expand" for="c-41471275">[13 more]</label></div><br/><div class="children"><div class="content">The criticisms the author levies against Protobuf are unfair. Inside Google, all source code is in a monorepo, and depending on other Protobuf files is a matter of code-sharing it as a Bazel library; it is trivial. There is no need for a package management system because its existence would be irrelevant.</div><br/><div id="41471277" class="c"><input type="checkbox" id="c-41471277" checked=""/><div class="controls bullet"><span class="by">ronsor</span><span>|</span><a href="#41471275">parent</a><span>|</span><a href="#41471380">next</a><span>|</span><label class="collapse" for="c-41471277">[-]</label><label class="expand" for="c-41471277">[6 more]</label></div><br/><div class="children"><div class="content">&gt;  Inside Google, all source code is in a monorepo<p>And outside Google, it isn&#x27;t. It&#x27;s fair to judge something that&#x27;s been released to the public based on what the public can reasonably do.</div><br/><div id="41471286" class="c"><input type="checkbox" id="c-41471286" checked=""/><div class="controls bullet"><span class="by">Narhem</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471277">parent</a><span>|</span><a href="#41471380">next</a><span>|</span><label class="collapse" for="c-41471286">[-]</label><label class="expand" for="c-41471286">[5 more]</label></div><br/><div class="children"><div class="content">Yea, but from the complexities of managing external facing libraries they do an extremely well job. As a former Googler I can jump into bazel, grpc projects or start my own relatively easily.<p>I tried making a few guides on a personal blog explaining how to use these tools but to be honest without seeing how they get used within Google it&#x27;s relatively difficult to understand why they have some of the design decisions which may seem as clunky initially.</div><br/><div id="41471383" class="c"><input type="checkbox" id="c-41471383" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471286">parent</a><span>|</span><a href="#41471474">next</a><span>|</span><label class="collapse" for="c-41471383">[-]</label><label class="expand" for="c-41471383">[1 more]</label></div><br/><div class="children"><div class="content">As a not-former-Googler, the last time I looked into Bazel I was confused and had no idea what I was looking at.<p>The world is much much much bigger than Google&#x27;s internal tooling.  Even Google&#x27;s internal tooling that they&#x27;ve made public.</div><br/></div></div><div id="41471474" class="c"><input type="checkbox" id="c-41471474" checked=""/><div class="controls bullet"><span class="by">marvin-hansen</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471286">parent</a><span>|</span><a href="#41471383">prev</a><span>|</span><a href="#41471380">next</a><span>|</span><label class="collapse" for="c-41471474">[-]</label><label class="expand" for="c-41471474">[3 more]</label></div><br/><div class="children"><div class="content">That is true. I am using Bazel daily with all deps vendored and proto defined as targets so there is really no need for these tools the author mentioned because with Bazel the underlying problems simply don&#x27;t exist in the first place.<p>It&#x27;s worth pointing out that it takes a bit of time and pain to gronk the underlying rational for some of the less obvious design decisions.<p>For example, Protos aren&#x27;t versioned because you already version them with git.
Releases usually some kind of hash, so you already have reliable dependencies with checksums.
No point in versioning protos again. It&#x27;s a mono repo, so why bother with distribution? 
Composition? Use proto lib target...<p>Without Bazel, though, your basically totally lost and then these tools kinda make sense as a way out of the pain caused the lacking tool support you will face.<p>That said, a lot of orgs have less then ideal IT for historical or whatever reasons so these problems are 100% real and these solutions exist for a reason.</div><br/><div id="41471498" class="c"><input type="checkbox" id="c-41471498" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471474">parent</a><span>|</span><a href="#41471380">next</a><span>|</span><label class="collapse" for="c-41471498">[-]</label><label class="expand" for="c-41471498">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For example, Protos aren&#x27;t versioned because you already version them with git. Releases usually some kind of hash, so you already have reliable dependencies with checksums.<p>Sorry, but this is such a stupid statement. You external service or client doesn&#x27;t have access to your internal git hash<p>&gt; That said, a lot of orgs have less then ideal IT for historical or whatever reasons<p>No. A lot of orgs don&#x27;t require setting up Bazel to make simple things like generating code from protobufs work</div><br/><div id="41472217" class="c"><input type="checkbox" id="c-41472217" checked=""/><div class="controls bullet"><span class="by">crustycoder</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471498">parent</a><span>|</span><a href="#41471380">next</a><span>|</span><label class="collapse" for="c-41472217">[-]</label><label class="expand" for="c-41472217">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a stupid statement internally as well. Unless you can freeze time itself, deploying new versions of stuff isn&#x27;t instantaneous. And what happens if you need to do a rollback of a component?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41471380" class="c"><input type="checkbox" id="c-41471380" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41471275">parent</a><span>|</span><a href="#41471277">prev</a><span>|</span><a href="#41471685">next</a><span>|</span><label class="collapse" for="c-41471380">[-]</label><label class="expand" for="c-41471380">[3 more]</label></div><br/><div class="children"><div class="content">If Google wants to push gRPC as a general, open, standardized solution -- which they most certainly want, and have done -- then they need to cater to how everyone does things, not to how Google does things.</div><br/><div id="41471470" class="c"><input type="checkbox" id="c-41471470" checked=""/><div class="controls bullet"><span class="by">ai_slurp_bot</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471380">parent</a><span>|</span><a href="#41471685">next</a><span>|</span><label class="collapse" for="c-41471470">[-]</label><label class="expand" for="c-41471470">[2 more]</label></div><br/><div class="children"><div class="content">In a sense, everyone does things because of how google does things. How does one decide whether the chicken or the egg should follow?</div><br/><div id="41471964" class="c"><input type="checkbox" id="c-41471964" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41471275">root</a><span>|</span><a href="#41471470">parent</a><span>|</span><a href="#41471685">next</a><span>|</span><label class="collapse" for="c-41471964">[-]</label><label class="expand" for="c-41471964">[1 more]</label></div><br/><div class="children"><div class="content">In what sense does &quot;everyone do things because of how google does things&quot;?</div><br/></div></div></div></div></div></div><div id="41471685" class="c"><input type="checkbox" id="c-41471685" checked=""/><div class="controls bullet"><span class="by">laidoffamazon</span><span>|</span><a href="#41471275">parent</a><span>|</span><a href="#41471380">prev</a><span>|</span><a href="#41471416">next</a><span>|</span><label class="collapse" for="c-41471685">[-]</label><label class="expand" for="c-41471685">[1 more]</label></div><br/><div class="children"><div class="content">How is it unfair? Is protobuf an externally available tool or not?</div><br/></div></div><div id="41471416" class="c"><input type="checkbox" id="c-41471416" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#41471275">parent</a><span>|</span><a href="#41471685">prev</a><span>|</span><a href="#41471335">next</a><span>|</span><label class="collapse" for="c-41471416">[-]</label><label class="expand" for="c-41471416">[2 more]</label></div><br/><div class="children"><div class="content">Nonsense. The criticism are perfectly fair and realistic.<p>Bazel is virtually unusable outside of Google. If protobuf is only usable inside Google infra then the response would be “don’t use it if you aren’t Google”. And yet I somehow doubt that’s what you’d argue!</div><br/></div></div></div></div><div id="41471335" class="c"><input type="checkbox" id="c-41471335" checked=""/><div class="controls bullet"><span class="by">zer0-c00l</span><span>|</span><a href="#41471275">prev</a><span>|</span><a href="#41471401">next</a><span>|</span><label class="collapse" for="c-41471335">[-]</label><label class="expand" for="c-41471335">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a definite UX problem imo with having to manage protobuf synchronization  between repos.<p>But the majority of these criticisms seem really superficial to me. Who cares that the API is inconsistent between languages? Some languages may be better suited for certain implementation styles to begin with.<p>Also regarding the reflection API I was under the impression that the codegenned protobuf code directly serializes and didn&#x27;t reflect? Thrift worked that way so maybe I&#x27;m confused.</div><br/><div id="41471421" class="c"><input type="checkbox" id="c-41471421" checked=""/><div class="controls bullet"><span class="by">SPascareli13</span><span>|</span><a href="#41471335">parent</a><span>|</span><a href="#41471401">next</a><span>|</span><label class="collapse" for="c-41471421">[-]</label><label class="expand" for="c-41471421">[2 more]</label></div><br/><div class="children"><div class="content">You need a separate package to actually serialize protobuf from a congen&#x27;d struct, so it uses reflection.</div><br/><div id="41471905" class="c"><input type="checkbox" id="c-41471905" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#41471335">root</a><span>|</span><a href="#41471421">parent</a><span>|</span><a href="#41471401">next</a><span>|</span><label class="collapse" for="c-41471905">[-]</label><label class="expand" for="c-41471905">[1 more]</label></div><br/><div class="children"><div class="content">Haha the good old circular dependency problem. I am still surprised there are people in the industry that can’t recognise and solve these problems. It is such a classic pattern and its use arises in the wild all the time.</div><br/></div></div></div></div></div></div><div id="41471401" class="c"><input type="checkbox" id="c-41471401" checked=""/><div class="controls bullet"><span class="by">beders</span><span>|</span><a href="#41471335">prev</a><span>|</span><a href="#41471329">next</a><span>|</span><label class="collapse" for="c-41471401">[-]</label><label class="expand" for="c-41471401">[2 more]</label></div><br/><div class="children"><div class="content">One of the reasons I&#x27;d disregard gRPC for front-end development is my belief that data exchange between front and back-ends should be driven by the front-end.<p>The UX drives the shape of data it needs from back-ends.<p>Any UI work I do is interactive and fast. Anything that hinders that, like code generation, is a drag.
Adding a suitable new endpoint or evolving data shapes coming from existing endpoints happens instantaneously in my dev environment.<p>I value that flexibility over tightly controlled specs.
I might eventually add types when I&#x27;m reasonably sure I got the data shapes right.</div><br/><div id="41471757" class="c"><input type="checkbox" id="c-41471757" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41471401">parent</a><span>|</span><a href="#41471329">next</a><span>|</span><label class="collapse" for="c-41471757">[-]</label><label class="expand" for="c-41471757">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; my belief that data exchange between front and back-ends should be driven by the front-end.</i><p>Why, then, are you trying to design the &#x27;data shapes&#x27; before the UX is old enough to drive? It seems you don&#x27;t live by what you preach.<p>For what it is worth, I happen to share in your belief. gRPC couldn&#x27;t possibly get in the way as you&#x27;re not going anywhere near that layer of abstraction while the UX is being developed. By the time you&#x27;re at the point of making network calls the data model is fully solidified. There is no need for continued iteration once you&#x27;ve gone that far.<p>The biggest reason to disregard gRPC on the frontend, though, is that frontends are often found on slow, high latency networks where call overhead starts to bite you. Moving beyond simple applications, you really need some kind batching system rather than the RPC model in order to diminish the overhead cost. Of course, you can bend gRPC into some kind of batching system if you try hard enough – it is all just 1s and 0s at the end of the day, but there are other solutions more in tune to that particular problem.</div><br/></div></div></div></div><div id="41471329" class="c"><input type="checkbox" id="c-41471329" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#41471401">prev</a><span>|</span><a href="#41472089">next</a><span>|</span><label class="collapse" for="c-41471329">[-]</label><label class="expand" for="c-41471329">[2 more]</label></div><br/><div class="children"><div class="content">&gt;They eventually added a ServeHTTP() interface to grpc-go as an experimental way to use the HTTP server from the Go standard library but using that method results in a significant loss of performance.<p>I don&#x27;t quite see how that is possible. ServeHTTP() seems like a most general HTTP interface. How could implementing that interface for a protocol built on top of HTTP result in a performance degradation!? If that is indeed the case, that seems like it would imply a flaw in go&#x27;s standard http library, not grpc.</div><br/><div id="41471515" class="c"><input type="checkbox" id="c-41471515" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#41471329">parent</a><span>|</span><a href="#41472089">next</a><span>|</span><label class="collapse" for="c-41471515">[-]</label><label class="expand" for="c-41471515">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I don&#x27;t quite see how that is possible.</i><p>1. gRPC brings its own HTTP implementation. There was no other implementation to lean on when the project started. It may be optimized in ways that the standard library&#x27;s implementation is not.<p>2. gRPC&#x27;s implementation has features not available in the standard library&#x27;s implementation. These features can improve performance under certain conditions.<p>Keep in mind that &quot;significant&quot; often gets overstated in computing. Many will tell you that cgo call overhead is significant, and relatively speaking it is, but we&#x27;re only talking mere nanoseconds. With extremely precise measuring tools you can, indeed, observe it, but it&#x27;s so small that it is impossible for a human to notice and thus doesn&#x27;t actually matter in practice. It is not like your gRPC endpoint is suddenly going to start taking minutes to respond if you switch to using ServeHTTP.<p><i>&gt; that seems like it would imply a flaw in go&#x27;s standard http library, not grpc</i><p>If a pickup truck not being able to drive as fast as a race car implies a flaw with pickup trucks, sure. Most would simply consider them different tools for different jobs, though. The standard library&#x27;s HTTP implementation tries to be reasonably suitable for a wide range of tasks, while gRPC&#x27;s implementation only has to serve gRPC. As such gRPC can carefully tune its package to the needs of gRPC without concern for how it might affect someone serving, say, HTML. The standard library doesn&#x27;t have the same luxury.</div><br/></div></div></div></div><div id="41472089" class="c"><input type="checkbox" id="c-41472089" checked=""/><div class="controls bullet"><span class="by">nprateem</span><span>|</span><a href="#41471329">prev</a><span>|</span><a href="#41471534">next</a><span>|</span><label class="collapse" for="c-41472089">[-]</label><label class="expand" for="c-41472089">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried to use gRPC several times over the years, but the lack of front-end support just always kills it for me. It&#x27;d be such a killer feature to have all that gRPC offers plus support for JS (or an easy way to deploy grpc-web that doesn&#x27;t have loads of gotchas), but every time I look I realise it&#x27;s not going to work. I&#x27;ve been surprised how little that situation changed over the 5 years or so I was tracking the project. I don&#x27;t even consider it any more.<p>Who wants to use one tech stack for microservices and an entirely different one for frontend. Better to just use the same one everywhere.</div><br/></div></div><div id="41471534" class="c"><input type="checkbox" id="c-41471534" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#41472089">prev</a><span>|</span><label class="collapse" for="c-41471534">[-]</label><label class="expand" for="c-41471534">[2 more]</label></div><br/><div class="children"><div class="content">The one useful purpose protobuf serves: if you run across someone who is enthusiastic about it, then you know to never trust anything that person says.</div><br/><div id="41472254" class="c"><input type="checkbox" id="c-41472254" checked=""/><div class="controls bullet"><span class="by">crustycoder</span><span>|</span><a href="#41471534">parent</a><span>|</span><label class="collapse" for="c-41472254">[-]</label><label class="expand" for="c-41472254">[1 more]</label></div><br/><div class="children"><div class="content">Experienced people use complex solutions because they know it&#x27;s the only way they can get stuff to work at the scale they need.<p>Inexperienced people use complex solutions because they think if the experienced people use it, it must be the right thing to do, no matter what the scale is.<p>Always use the simplest thing that will work.</div><br/></div></div></div></div></div></div></div></div></div></body></html>