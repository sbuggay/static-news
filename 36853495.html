<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1690275648550" as="style"/><link rel="stylesheet" href="styles.css?v=1690275648550"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://erikvandeven.medium.com/python-uncovering-the-overlooked-core-functionalities-54590420c225">Python: Overlooked core functionalities</a> <span class="domain">(<a href="https://erikvandeven.medium.com">erikvandeven.medium.com</a>)</span></div><div class="subtext"><span>erikvdven</span> | <span>119 comments</span></div><br/><div><div id="36855539" class="c"><input type="checkbox" id="c-36855539" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#36854001">next</a><span>|</span><label class="collapse" for="c-36855539">[-]</label><label class="expand" for="c-36855539">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;m annoyed at the reason that any&#x2F;all have to be on this list. If they (and map, filter, …) were methods, you could just write `foo.` and your IDE could show you what methods are available. Postfix would make things easier to read too:<p><pre><code>    bar.baz()\
       .filter(some_filter)\
       .map(some_op)\
       .min()\
       .foo()
</code></pre>
Data&#x2F;control flows from top to bottom. One operation per line. But with freestanding functions:<p><pre><code>    min(map(some_op, filter(some_filter, bar.baz()))).foo()
</code></pre>
To follow the flow of data&#x2F;control, you start in the middle, go right, then skip left to filter, read rightwards to see which filter, skip left to map, read rightwards to see what map, go left to min, then skip all the way to the right. Just splitting it into multiple lines doesn&#x27;t help, you need to introduce intermediate variables (and make sure they don&#x27;t clobber any existing ones) and repeat yourself whether they clarify things or not. The same issue exists for list&#x2F;dict&#x2F;set comprehensions.</div><br/><div id="36859719" class="c"><input type="checkbox" id="c-36859719" checked=""/><div class="controls bullet"><span class="by">movpasd</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36857695">next</a><span>|</span><label class="collapse" for="c-36859719">[-]</label><label class="expand" for="c-36859719">[1 more]</label></div><br/><div class="children"><div class="content">In my mind this is a holdover from when Python was much more procedural&#x2F;C-like and as a Python developer it&#x27;s one of my pet peeves. (I can&#x27;t count how many times I&#x27;ve started writing the name of a list, had to backtrack to stick a `len` in front, and then tap tap tap arrow keys to get back to the front.)<p>I suppose we really ought to blame Euler for introducing the f(x) notation 300 years ago... Very practical when the function is the entity you want to focus on, often less useful in (procedural) programming, where we typically start with the data and think in terms of a series of steps.<p>Some languages like D and Nim have &quot;UFCS&quot;, uniform function call syntax, where all functions can be called as methods on any variable. Basically, it decouples the implicit association between method dispatch and namespacing&#x2F;scoping semantics. Rust also has something they call UFCS, but it only goes one way (you can desugar methods as normal functions, but you can&#x27;t ... resugar? arbitrary functions as methods). Python couldn&#x27;t implement this without breaking a lot of stuff due to its semantics, but it is definitely a feature I&#x27;d like to see more of.</div><br/></div></div><div id="36857695" class="c"><input type="checkbox" id="c-36857695" checked=""/><div class="controls bullet"><span class="by">JoshuaDavid</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36859719">prev</a><span>|</span><a href="#36856432">next</a><span>|</span><label class="collapse" for="c-36857695">[-]</label><label class="expand" for="c-36857695">[1 more]</label></div><br/><div class="children"><div class="content">Here you go:<p><pre><code>    class WrappedList:
        _fns = [map, filter, min, max, all, any, len, list]

        def __init__(self, it):
            self.it = it

        def __getattr__(self, name):
            for fn in self._fns:
                if name == fn.__name__:
                    def m(*args, **kwargs):
                        result = fn(*args, self.it, **kwargs)
                        if hasattr(result, &#x27;__iter__&#x27;):
                            return self.__class__(result)
                        else:
                            return result
                    return m

        def unwrap(self):
            return self.it

</code></pre>
This allows you to do stuff like<p><pre><code>    WrappedList([1, 2, 3, 4]).filter(lambda x: x % 2 == 0).map(lambda x: x * 3).list().unwrap() # [6, 12]
    WrappedList([1, 2, 3, 4]).map(lambda x: x &gt;= 5).any() # False
</code></pre>
Deciding whether or not this is something you <i>should</i> do, rather than just something you <i>can</i> do, is left as an exercise for the reader.</div><br/></div></div><div id="36856432" class="c"><input type="checkbox" id="c-36856432" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36857695">prev</a><span>|</span><a href="#36857594">next</a><span>|</span><label class="collapse" for="c-36856432">[-]</label><label class="expand" for="c-36856432">[4 more]</label></div><br/><div class="children"><div class="content">any, all, map, filter, min, max, for loops, zip, list, tuple, reduce, list comprehensions, cycle, repeat, islice, and so on in python work on iterables, and iterable is a protocol, not a class.  it would certainly be interesting to program in a language where conforming to a protocol (perhaps one that nobody had thought up yet when you wrote your class) would give your class new methods, or where all iterables had to derive from a common base class,  but it would be a very different language from python<p>incidentally in your example, though data does flow from top to bottom, control does not, assuming the filter and map methods are lazy as they are in python; it ping-pongs back and forth up and down the sequence in a somewhat irregular manner, sometimes reaching as far as .min() before going back up, and other times turning around at .filter(...)<p>i wonder if you could implement the ide functionality you want with a &#x27;wrap&#x27; menu of popular functions that are applicable to the thing to the left of your cursor, so when you had<p><pre><code>    filter(some_filter, bar.baz())|
</code></pre>
(with | representing your cursor) you could select `map` or `min` or whatever from the wrap dropdown and get<p><pre><code>    min(filter(some_filter, bar.baz()))|
</code></pre>
for any given cursor position in python there are potentially multiple expressions ending there, in cases like<p><pre><code>    &quot;y: %s&quot; % y|
</code></pre>
but maybe that&#x27;s not such a hard problem to solve</div><br/><div id="36856604" class="c"><input type="checkbox" id="c-36856604" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#36855539">root</a><span>|</span><a href="#36856432">parent</a><span>|</span><a href="#36857594">next</a><span>|</span><label class="collapse" for="c-36856604">[-]</label><label class="expand" for="c-36856604">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  it would certainly be interesting to program in a language ... where all iterables had to derive from a common base class, but it would be a very different language from python<p>You mean Ruby? :P<p>(All Ruby iteratables mixin Enumerable, which is baaaaaaaasically inheritance.)</div><br/><div id="36857691" class="c"><input type="checkbox" id="c-36857691" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#36855539">root</a><span>|</span><a href="#36856604">parent</a><span>|</span><a href="#36858758">next</a><span>|</span><label class="collapse" for="c-36857691">[-]</label><label class="expand" for="c-36857691">[1 more]</label></div><br/><div class="children"><div class="content">Or Rust! Everything that implements the Iterator trait gets access to all of Iterator’s goodies, like map, filter, reduce, etc. Implementing iterator just requires adding a single next(&amp;mut self) -&gt; Option&lt;Item&gt; method on your type.<p>Lifetimes and async are a massive pain in rust. But the trait system is a work of art.</div><br/></div></div><div id="36858758" class="c"><input type="checkbox" id="c-36858758" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#36855539">root</a><span>|</span><a href="#36856604">parent</a><span>|</span><a href="#36857691">prev</a><span>|</span><a href="#36857594">next</a><span>|</span><label class="collapse" for="c-36858758">[-]</label><label class="expand" for="c-36858758">[1 more]</label></div><br/><div class="children"><div class="content">Or its inspiration, Smalltalk.</div><br/></div></div></div></div></div></div><div id="36857594" class="c"><input type="checkbox" id="c-36857594" checked=""/><div class="controls bullet"><span class="by">ajb117</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36856432">prev</a><span>|</span><a href="#36857522">next</a><span>|</span><label class="collapse" for="c-36857594">[-]</label><label class="expand" for="c-36857594">[1 more]</label></div><br/><div class="children"><div class="content">Makes me wish python had a pipe operator like Julia&#x27;s |&gt; and R&#x27;s %&gt;%</div><br/></div></div><div id="36857522" class="c"><input type="checkbox" id="c-36857522" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36857594">prev</a><span>|</span><a href="#36856282">next</a><span>|</span><label class="collapse" for="c-36857522">[-]</label><label class="expand" for="c-36857522">[1 more]</label></div><br/><div class="children"><div class="content">Your point about ordering and readability really rang true for me.  My way around this in Python is to separate the map and the reduce: do the map in one part with a list comprehension and the reduce in a second part on a new line.<p>I’ll wrap the whole thing in a named function as a way of describing what I’m doing and make it a closure if it’s used only once:<p><pre><code>  def f(bar):
    def smallest_baz():
      bazs = (
        some_op(b)
        for b in bar.baz()
        if some_filter(b)
      )
      return min(bazs)

    return smallest_baz().foo()</code></pre></div><br/></div></div><div id="36856282" class="c"><input type="checkbox" id="c-36856282" checked=""/><div class="controls bullet"><span class="by">llwu</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36857522">prev</a><span>|</span><a href="#36856203">next</a><span>|</span><label class="collapse" for="c-36856282">[-]</label><label class="expand" for="c-36856282">[1 more]</label></div><br/><div class="children"><div class="content">There is a niche use-case for the reverse order `(foo min map filter baz bar)`, which is, solving typed holes (you could refine the hole as like `_.foo()` although that wouldn&#x27;t be interoperable with things like next token prediction).<p>But that&#x27;s more of a math thing than an everyday coding thing, where dot chaining usually reads nicer.<p>Mixed is definitely the worst, like you said.</div><br/></div></div><div id="36856203" class="c"><input type="checkbox" id="c-36856203" checked=""/><div class="controls bullet"><span class="by">KMnO4</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36856282">prev</a><span>|</span><a href="#36857155">next</a><span>|</span><label class="collapse" for="c-36856203">[-]</label><label class="expand" for="c-36856203">[1 more]</label></div><br/><div class="children"><div class="content">Would that really work? You can chain those functions because they return the same type. For example, filtering a list returns a subset of the list.<p>Any&#x2F;all return a Boolean, so the chain would stop there.<p>I also personally think<p><pre><code>    any(x % 5 in range(y))
</code></pre>
Is more clear than<p><pre><code>    range(y).any(lambda x: x % 5)</code></pre></div><br/></div></div><div id="36857155" class="c"><input type="checkbox" id="c-36857155" checked=""/><div class="controls bullet"><span class="by">di456</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36856203">prev</a><span>|</span><a href="#36856207">next</a><span>|</span><label class="collapse" for="c-36857155">[-]</label><label class="expand" for="c-36857155">[2 more]</label></div><br/><div class="children"><div class="content">With python I&#x27;d decompose that one-liner into several variables for readability.  That probably ends up using more memory than it would otherwise but I generally don&#x27;t work on systems where that matters much.<p>Scala was really nice for this syntax when I used it for Spark.</div><br/><div id="36857350" class="c"><input type="checkbox" id="c-36857350" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36855539">root</a><span>|</span><a href="#36857155">parent</a><span>|</span><a href="#36856207">next</a><span>|</span><label class="collapse" for="c-36857350">[-]</label><label class="expand" for="c-36857350">[1 more]</label></div><br/><div class="children"><div class="content">Map and filter don&#x27;t actually consume anything until they&#x27;re used later, they produce iterables. So if you pulled them into their own lines they wouldn&#x27;t consume (much) extra memory. Taking the original:<p><pre><code>  min(map(some_op, filter(some_filter, bar.baz()))).foo()
</code></pre>
An alternative is also to use a generator comprehension that&#x27;s identical to the inner part (in effect):<p><pre><code>  min(some_op(item) for item in bar.baz() if some_filter(item)).foo()
</code></pre>
Which could still be pulled out to a pair of lines for clarity:<p><pre><code>  items = (some_op(item) for item in bar.baz() if some_filter(item)) # or some better name given a context
  min(items).foo()</code></pre></div><br/></div></div></div></div><div id="36856207" class="c"><input type="checkbox" id="c-36856207" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36857155">prev</a><span>|</span><a href="#36857733">next</a><span>|</span><label class="collapse" for="c-36856207">[-]</label><label class="expand" for="c-36856207">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s interesting I completely agree with you and it&#x27;s a big reason I find Python irritating to write (compared to Groovy, Kotlin, Ruby, etc). However there do seem to be a lot of people that dislike this method chaining style and will assert that functional style is better in every way. But I just can&#x27;t fundamentally agree that writing these as functions is as readable.<p>Even if you go far out of your way to format it similarly, it still forces
you to do a lot of mental work to see the inner most starting point and then
deduce what the sequence of operations that happens is backwards, eg:<p><pre><code>   foo(
      min(
           map(lambda x: ...,
               filter(lambda: y: ....,
                     baz(bar)
              )
          )
       )
</code></pre>
(and of course, the python linters are typically configured to hate this so you can&#x27;t realistically write it this way even if you want to)</div><br/></div></div><div id="36857733" class="c"><input type="checkbox" id="c-36857733" checked=""/><div class="controls bullet"><span class="by">_ZeD_</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36856207">prev</a><span>|</span><a href="#36858236">next</a><span>|</span><label class="collapse" for="c-36857733">[-]</label><label class="expand" for="c-36857733">[1 more]</label></div><br/><div class="children"><div class="content">Or, you know, you could write good&#x27;ol for loop and use multiple statements, instead of having a gigantic expression</div><br/></div></div><div id="36858236" class="c"><input type="checkbox" id="c-36858236" checked=""/><div class="controls bullet"><span class="by">za3faran</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36857733">prev</a><span>|</span><a href="#36857823">next</a><span>|</span><label class="collapse" for="c-36858236">[-]</label><label class="expand" for="c-36858236">[1 more]</label></div><br/><div class="children"><div class="content">This is the same mistake that golang did.</div><br/></div></div><div id="36857823" class="c"><input type="checkbox" id="c-36857823" checked=""/><div class="controls bullet"><span class="by">saulpw</span><span>|</span><a href="#36855539">parent</a><span>|</span><a href="#36858236">prev</a><span>|</span><a href="#36854001">next</a><span>|</span><label class="collapse" for="c-36857823">[-]</label><label class="expand" for="c-36857823">[1 more]</label></div><br/><div class="children"><div class="content">those \ are super ugly though</div><br/></div></div></div></div><div id="36854001" class="c"><input type="checkbox" id="c-36854001" checked=""/><div class="controls bullet"><span class="by">m4r71n</span><span>|</span><a href="#36855539">prev</a><span>|</span><a href="#36853786">next</a><span>|</span><label class="collapse" for="c-36854001">[-]</label><label class="expand" for="c-36854001">[27 more]</label></div><br/><div class="children"><div class="content">I would not recommend the default arguments hack. Any decent linter or IDE will flag that as an error and complain about the default argument being mutable (in fact, mutable default arguments are the target of many beginner-level interview questions). It&#x27;s much easier to decorate a function with `functools.cache` to achieve the same result.</div><br/><div id="36854372" class="c"><input type="checkbox" id="c-36854372" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#36854001">parent</a><span>|</span><a href="#36854088">next</a><span>|</span><label class="collapse" for="c-36854372">[-]</label><label class="expand" for="c-36854372">[12 more]</label></div><br/><div class="children"><div class="content">Or, if you need a &quot;static&quot; variable for other purposes, the usual alternative is to just use a global variable, but if for some reason you can&#x27;t (or you don&#x27;t want to) you can use the function itself!<p><pre><code>    def f():
        if not hasattr(f, &quot;counter&quot;): 
            f.counter = 0
    
        f.counter += 1
        return f.counter

    print(f(),f(),f())

    &gt; 1 2 3</code></pre></div><br/><div id="36855317" class="c"><input type="checkbox" id="c-36855317" checked=""/><div class="controls bullet"><span class="by">data-ottawa</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36854372">parent</a><span>|</span><a href="#36854088">next</a><span>|</span><label class="collapse" for="c-36855317">[-]</label><label class="expand" for="c-36855317">[11 more]</label></div><br/><div class="children"><div class="content">I didn’t realize that the function was available in its own scope. This information is going to help me do horrible things with pandas.</div><br/><div id="36855399" class="c"><input type="checkbox" id="c-36855399" checked=""/><div class="controls bullet"><span class="by">kevincox</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855317">parent</a><span>|</span><a href="#36854088">next</a><span>|</span><label class="collapse" for="c-36855399">[-]</label><label class="expand" for="c-36855399">[10 more]</label></div><br/><div class="children"><div class="content">This is very important for self-recursion.</div><br/><div id="36855506" class="c"><input type="checkbox" id="c-36855506" checked=""/><div class="controls bullet"><span class="by">capableweb</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855399">parent</a><span>|</span><a href="#36856072">next</a><span>|</span><label class="collapse" for="c-36855506">[-]</label><label class="expand" for="c-36855506">[4 more]</label></div><br/><div class="children"><div class="content">Is there something that isn&#x27;t &quot;self-recursion&quot;?</div><br/><div id="36855542" class="c"><input type="checkbox" id="c-36855542" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855506">parent</a><span>|</span><a href="#36856072">next</a><span>|</span><label class="collapse" for="c-36855542">[-]</label><label class="expand" for="c-36855542">[3 more]</label></div><br/><div class="children"><div class="content">Mutual recursion. Horrible example, don’t use this:<p><pre><code>  even 0 = true
  even n = not (odd n-1)
  odd 0 = false
  odd n = not (even n-1)</code></pre></div><br/><div id="36857299" class="c"><input type="checkbox" id="c-36857299" checked=""/><div class="controls bullet"><span class="by">bewaretheirs</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855542">parent</a><span>|</span><a href="#36856072">next</a><span>|</span><label class="collapse" for="c-36857299">[-]</label><label class="expand" for="c-36857299">[2 more]</label></div><br/><div class="children"><div class="content">That should be<p><pre><code>  even 0 = true
  even n = odd n-1

  odd 0 = false
  odd n = even n-1
</code></pre>
I fed a C version of this (with unsigned n to keep the nasal daemons at bay) to clang and observed that it somehow manages to see through the mutual recursion, generating code that doesn&#x27;t recurse or loop.</div><br/><div id="36857366" class="c"><input type="checkbox" id="c-36857366" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36857299">parent</a><span>|</span><a href="#36856072">next</a><span>|</span><label class="collapse" for="c-36857366">[-]</label><label class="expand" for="c-36857366">[1 more]</label></div><br/><div class="children"><div class="content">You are correct, I don&#x27;t know why I put the nots in there. Either way, demonstrates mutual recursion.</div><br/></div></div></div></div></div></div></div></div><div id="36856072" class="c"><input type="checkbox" id="c-36856072" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855399">parent</a><span>|</span><a href="#36855506">prev</a><span>|</span><a href="#36854088">next</a><span>|</span><label class="collapse" for="c-36856072">[-]</label><label class="expand" for="c-36856072">[5 more]</label></div><br/><div class="children"><div class="content">This is very important for self-recursion.</div><br/><div id="36856128" class="c"><input type="checkbox" id="c-36856128" checked=""/><div class="controls bullet"><span class="by">pjot</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36856072">parent</a><span>|</span><a href="#36854088">next</a><span>|</span><label class="collapse" for="c-36856128">[-]</label><label class="expand" for="c-36856128">[4 more]</label></div><br/><div class="children"><div class="content">This is very important for self-recursion.</div><br/><div id="36856298" class="c"><input type="checkbox" id="c-36856298" checked=""/><div class="controls bullet"><span class="by">ctoth</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36856128">parent</a><span>|</span><a href="#36856234">next</a><span>|</span><label class="collapse" for="c-36856298">[-]</label><label class="expand" for="c-36856298">[1 more]</label></div><br/><div class="children"><div class="content">RecursionError: maximum recursion depth exceeded</div><br/></div></div><div id="36856234" class="c"><input type="checkbox" id="c-36856234" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36856128">parent</a><span>|</span><a href="#36856298">prev</a><span>|</span><a href="#36857428">next</a><span>|</span><label class="collapse" for="c-36856234">[-]</label><label class="expand" for="c-36856234">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.google.com&#x2F;search?q=recursion" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.google.com&#x2F;search?q=recursion</a></div><br/></div></div><div id="36857428" class="c"><input type="checkbox" id="c-36857428" checked=""/><div class="controls bullet"><span class="by">dijksterhuis</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36856128">parent</a><span>|</span><a href="#36856234">prev</a><span>|</span><a href="#36854088">next</a><span>|</span><label class="collapse" for="c-36857428">[-]</label><label class="expand" for="c-36857428">[1 more]</label></div><br/><div class="children"><div class="content">This is very important for self-recursion.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="36854088" class="c"><input type="checkbox" id="c-36854088" checked=""/><div class="controls bullet"><span class="by">Smaug123</span><span>|</span><a href="#36854001">parent</a><span>|</span><a href="#36854372">prev</a><span>|</span><a href="#36854996">next</a><span>|</span><label class="collapse" for="c-36854088">[-]</label><label class="expand" for="c-36854088">[6 more]</label></div><br/><div class="children"><div class="content">More concretely, one of the classic Python bugs is to use `[]` as a default argument and then mutate what &quot;is obviously&quot; a local variable.</div><br/><div id="36855007" class="c"><input type="checkbox" id="c-36855007" checked=""/><div class="controls bullet"><span class="by">nighthawk454</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36854088">parent</a><span>|</span><a href="#36857474">next</a><span>|</span><label class="collapse" for="c-36855007">[-]</label><label class="expand" for="c-36855007">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s even more safe&#x2F;preferable to use non-mutable `None`s as a default and do:<p>```
def myfunc(x=None):
    x = x if x is not None else []
    ...
```</div><br/><div id="36856139" class="c"><input type="checkbox" id="c-36856139" checked=""/><div class="controls bullet"><span class="by">memco</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855007">parent</a><span>|</span><a href="#36857474">next</a><span>|</span><label class="collapse" for="c-36856139">[-]</label><label class="expand" for="c-36856139">[1 more]</label></div><br/><div class="children"><div class="content">In some cases you can also  do:<p><pre><code>  x = x or []
</code></pre>
Your method is best when you might get falsy values but if that’s not an issue the `or` method is handy.</div><br/></div></div></div></div><div id="36857474" class="c"><input type="checkbox" id="c-36857474" checked=""/><div class="controls bullet"><span class="by">gcanyon</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36854088">parent</a><span>|</span><a href="#36855007">prev</a><span>|</span><a href="#36857849">next</a><span>|</span><label class="collapse" for="c-36857474">[-]</label><label class="expand" for="c-36857474">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m learning python, and I hit this milestone about a week ago!</div><br/></div></div><div id="36857849" class="c"><input type="checkbox" id="c-36857849" checked=""/><div class="controls bullet"><span class="by">at_compile_time</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36854088">parent</a><span>|</span><a href="#36857474">prev</a><span>|</span><a href="#36854996">next</a><span>|</span><label class="collapse" for="c-36857849">[-]</label><label class="expand" for="c-36857849">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s it do?</div><br/><div id="36859367" class="c"><input type="checkbox" id="c-36859367" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36857849">parent</a><span>|</span><a href="#36854996">next</a><span>|</span><label class="collapse" for="c-36859367">[-]</label><label class="expand" for="c-36859367">[1 more]</label></div><br/><div class="children"><div class="content">When you set an object as a default that object is the default for all calls to that function&#x2F;method. This also holds true if you create the object, like that empty list. So in this case, every call that uses the default argument is using the same list.<p><pre><code>    def listify(item, li=[]):
        li.append(item)
        return li

    listify(1) # [1]
    listify(2) # [1, 2]</code></pre></div><br/></div></div></div></div></div></div><div id="36854996" class="c"><input type="checkbox" id="c-36854996" checked=""/><div class="controls bullet"><span class="by">sanderjd</span><span>|</span><a href="#36854001">parent</a><span>|</span><a href="#36854088">prev</a><span>|</span><a href="#36855514">next</a><span>|</span><label class="collapse" for="c-36854996">[-]</label><label class="expand" for="c-36854996">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I found that example very confusing.</div><br/></div></div><div id="36855514" class="c"><input type="checkbox" id="c-36855514" checked=""/><div class="controls bullet"><span class="by">bilsbie</span><span>|</span><a href="#36854001">parent</a><span>|</span><a href="#36854996">prev</a><span>|</span><a href="#36855264">next</a><span>|</span><label class="collapse" for="c-36855514">[-]</label><label class="expand" for="c-36855514">[2 more]</label></div><br/><div class="children"><div class="content">Why does that issue only come up with default arguments?<p>Why not other places?</div><br/><div id="36856113" class="c"><input type="checkbox" id="c-36856113" checked=""/><div class="controls bullet"><span class="by">ironSkillet</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855514">parent</a><span>|</span><a href="#36855264">next</a><span>|</span><label class="collapse" for="c-36856113">[-]</label><label class="expand" for="c-36856113">[1 more]</label></div><br/><div class="children"><div class="content">Default arguments are evaluated and created when the function <i>definition</i> is evaluated, not when the function <i>itself</i> is evaluated. This means that the scope of the default argument is actually the entire module, not just a single invocation of the method. This is what throws people off.</div><br/></div></div></div></div><div id="36855264" class="c"><input type="checkbox" id="c-36855264" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#36854001">parent</a><span>|</span><a href="#36855514">prev</a><span>|</span><a href="#36854160">next</a><span>|</span><label class="collapse" for="c-36855264">[-]</label><label class="expand" for="c-36855264">[3 more]</label></div><br/><div class="children"><div class="content">functools.cache is pretty new; py3.8 is still supported for another year and a bit.</div><br/><div id="36855897" class="c"><input type="checkbox" id="c-36855897" checked=""/><div class="controls bullet"><span class="by">xavdid</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36855264">parent</a><span>|</span><a href="#36856118">next</a><span>|</span><label class="collapse" for="c-36855897">[-]</label><label class="expand" for="c-36855897">[1 more]</label></div><br/><div class="children"><div class="content">functools.cache is basically `functools.lru_cache(maxsize=None)`. `lru_cache` was added in py3.3, which is widely available.</div><br/></div></div></div></div><div id="36854160" class="c"><input type="checkbox" id="c-36854160" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#36854001">parent</a><span>|</span><a href="#36855264">prev</a><span>|</span><a href="#36853786">next</a><span>|</span><label class="collapse" for="c-36854160">[-]</label><label class="expand" for="c-36854160">[2 more]</label></div><br/><div class="children"><div class="content">I would hate to get an interview question where the very premise of it is wrong. Python does have mutable arguments, but so does Ruby.<p><pre><code>    def func(arr=[])
      # Look ma we mutated it.
      arr.append 1
      puts arr
    end
</code></pre>
Why calling this function a few times outputs [1], [1],... instead of [1], [1, 1],... isn&#x27;t because Ruby somehow made the array immutable and hid it with copy-on-write or anything like that. It&#x27;s because Ruby, unlike Python, has default <i>expressions</i> instead of default <i>values</i>. Whenever the default it needed Ruby reevaluates the expression in the scope of the function definition and assigns the result to the argument. If your default expression always returned the same object you would fall
into the same trap as Python.<p>The sibling comment is wrong too -- it <i>is</i> a local variable, or as much one as Python can have since all variables, local or not, are names.</div><br/><div id="36856521" class="c"><input type="checkbox" id="c-36856521" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36854001">root</a><span>|</span><a href="#36854160">parent</a><span>|</span><a href="#36853786">next</a><span>|</span><label class="collapse" for="c-36856521">[-]</label><label class="expand" for="c-36856521">[1 more]</label></div><br/><div class="children"><div class="content">Just as a demo of what you&#x27;re saying:<p>If you were to do (the following is from memory, probably has typos):<p><pre><code>  def func(arr=[]):
    print(locals)
</code></pre>
You&#x27;d see `arr` there. The `[]` value lives in `func.__defaults__`:<p><pre><code>  def func(arr=[]):
    print(locals)
    print(func.__defaults__) # will print: ([],)
</code></pre>
If you assign to `arr` nothing changes with defaults:<p><pre><code>  def func(arr=[]):
    print(locals)
    arr = 10
    print(func.__defaults__) # will still print: ([],)
</code></pre>
But since lists are mutable, calling a mutating function on the list referenced by `arr` will cause a mutation of the list stored in defaults:<p><pre><code>  def func(arr=[]):
    print(locals)
    arr.append(10)
    print(func.__defaults__) # will print: ([10],)
</code></pre>
But only when `func` is called without something to assign to `arr`:<p><pre><code>  # if pristine and it has not been run before
  def func(arr=[]):
    print(locals)
    arr.append(10)
    print(func.__defaults__) # will print: ([],)
  func([])</code></pre></div><br/></div></div></div></div></div></div><div id="36853786" class="c"><input type="checkbox" id="c-36853786" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#36854001">prev</a><span>|</span><a href="#36853975">next</a><span>|</span><label class="collapse" for="c-36853786">[-]</label><label class="expand" for="c-36853786">[24 more]</label></div><br/><div class="children"><div class="content">The big missing item from the list: generators!<p>Using &quot;yield&quot; instead of &quot;return&quot; turns the function into a coroutine. This is useful in all sorts of cases and works <i>very</i> well with the itertools module of the standard library.<p>One of my favorite examples: a very concise snippet of code that generates all primes:<p><pre><code>  def primes():
      ps = defaultdict(list)
      for i in count(2):
          if i not in ps:
              yield i
              ps[i**2].append(i)
          else:
              for n in ps[i]:
                  ps[i + (n if n == 2 else 2*n)].append(n)
              del ps[i]</code></pre></div><br/><div id="36854082" class="c"><input type="checkbox" id="c-36854082" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#36853786">parent</a><span>|</span><a href="#36854640">next</a><span>|</span><label class="collapse" for="c-36854082">[-]</label><label class="expand" for="c-36854082">[2 more]</label></div><br/><div class="children"><div class="content">And this is a presentation explaining <i>why</i> generators may be extremely useful for all kind of data pipelines: <a href="https:&#x2F;&#x2F;www.dabeaz.com&#x2F;generators&#x2F;Generators.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.dabeaz.com&#x2F;generators&#x2F;Generators.pdf</a><p>If you don&#x27;t know it already, it is really worth looking into. I am a python dev with nearly a decade of experience and I knew generators, and yet this was still an eye opener.</div><br/><div id="36854891" class="c"><input type="checkbox" id="c-36854891" checked=""/><div class="controls bullet"><span class="by">thenberlin</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854082">parent</a><span>|</span><a href="#36854640">next</a><span>|</span><label class="collapse" for="c-36854891">[-]</label><label class="expand" for="c-36854891">[1 more]</label></div><br/><div class="children"><div class="content">Wow, thanks for that -- that&#x27;s an excellent slide deck.</div><br/></div></div></div></div><div id="36854640" class="c"><input type="checkbox" id="c-36854640" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#36853786">parent</a><span>|</span><a href="#36854082">prev</a><span>|</span><a href="#36855149">next</a><span>|</span><label class="collapse" for="c-36854640">[-]</label><label class="expand" for="c-36854640">[7 more]</label></div><br/><div class="children"><div class="content">But wait, there&#x27;s more, you can send data back to the function! (Will be returned as the yield output)<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;20579756&#x2F;passing-value-to-yield-using-send#20579767" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;20579756&#x2F;passing-value-t...</a><p>And don&#x27;t forget &quot;yield from&quot; (same as yielding all values in a list, but keeps the original generator! You can send data back to the list if it is itself another generator!)</div><br/><div id="36856931" class="c"><input type="checkbox" id="c-36856931" checked=""/><div class="controls bullet"><span class="by">noitpmeder</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854640">parent</a><span>|</span><a href="#36858045">next</a><span>|</span><label class="collapse" for="c-36856931">[-]</label><label class="expand" for="c-36856931">[5 more]</label></div><br/><div class="children"><div class="content">Anyone have good examples of how&#x2F;when to actually use this? I&#x27;ve personally never interacted with or written a generator that expects to receive values.</div><br/><div id="36857984" class="c"><input type="checkbox" id="c-36857984" checked=""/><div class="controls bullet"><span class="by">strunz</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36856931">parent</a><span>|</span><a href="#36857633">next</a><span>|</span><label class="collapse" for="c-36857984">[-]</label><label class="expand" for="c-36857984">[2 more]</label></div><br/><div class="children"><div class="content">I actually had a great use case for this last week. Needed to flatten a list of nested dicts, e.g.:<p><pre><code>  [
    {&quot;name&quot;: &quot;&#x2F;dev&#x2F;loop0&quot;},
    {&quot;name&quot;: &quot;&#x2F;dev&#x2F;loop1&quot;},
    {&quot;name&quot;: &quot;&#x2F;dev&#x2F;loop2&quot;},
    {
      &quot;name&quot;: &quot;&#x2F;dev&#x2F;sda&quot;,
      &quot;children&quot;:
        [
          {
            &quot;name&quot;: &quot;&#x2F;dev&#x2F;sda1&quot;,
            &quot;children&quot;:
              [{&quot;name&quot;: &quot;&#x2F;dev&#x2F;mapper&#x2F;lubuntu--vg-root&quot;}, {&quot;name&quot;: &quot;&#x2F;dev&#x2F;mapper&#x2F;lubuntu--vg-swap_1&quot;}],
          },
        ],
    },
    {&quot;name&quot;: &quot;&#x2F;dev&#x2F;sdb&quot;, &quot;children&quot;: [{&quot;name&quot;: &quot;&#x2F;dev&#x2F;sdb1&quot;}, {&quot;name&quot;: &quot;&#x2F;dev&#x2F;sdb2&quot;}]},
    {&quot;name&quot;: &quot;&#x2F;dev&#x2F;sdc&quot;, &quot;children&quot;: [{&quot;name&quot;: &quot;&#x2F;dev&#x2F;sdc1&quot;}, {&quot;name&quot;: &quot;&#x2F;dev&#x2F;sdc9&quot;}]},
  ]
</code></pre>
Wound up writing a recursive generator (with some help from #python on IRC):<p><pre><code>  def flatten(items):
      for item in items:
          yield {k:v for k,v in item.items() if k != &#x27;children&#x27;}
          if &#x27;children&#x27; in item:
              yield from flatten(item[&#x27;children&#x27;])
</code></pre>
which results in:<p><pre><code>  [{&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;loop0&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;loop1&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;loop2&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sda&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sda1&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;mapper&#x2F;lubuntu--vg-root&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;mapper&#x2F;lubuntu--vg-swap_1&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sdb&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sdb1&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sdb2&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sdc&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sdc1&#x27;},
   {&#x27;name&#x27;: &#x27;&#x2F;dev&#x2F;sdc9&#x27;}]</code></pre></div><br/><div id="36858847" class="c"><input type="checkbox" id="c-36858847" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36857984">parent</a><span>|</span><a href="#36857633">next</a><span>|</span><label class="collapse" for="c-36858847">[-]</label><label class="expand" for="c-36858847">[1 more]</label></div><br/><div class="children"><div class="content">I see your function and &quot;yield&quot; (pun definitely intended) the following:<p><pre><code>    def flatten(children=[], **other):
        if other: yield other
        for child in children: yield from flatten(**child)</code></pre></div><br/></div></div></div></div><div id="36857633" class="c"><input type="checkbox" id="c-36857633" checked=""/><div class="controls bullet"><span class="by">luckycharms810</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36856931">parent</a><span>|</span><a href="#36857984">prev</a><span>|</span><a href="#36857174">next</a><span>|</span><label class="collapse" for="c-36857633">[-]</label><label class="expand" for="c-36857633">[1 more]</label></div><br/><div class="children"><div class="content">This is the basis of most older async frameworks (see: Tornado, Twisted). A while ago I put together a short talk on how to go from this feature -&gt; a very basic version of Twisted&#x27;s @inline_callback decorator.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ltavag&#x2F;async_presentation&#x2F;tree&#x2F;master">https:&#x2F;&#x2F;github.com&#x2F;ltavag&#x2F;async_presentation&#x2F;tree&#x2F;master</a></div><br/></div></div><div id="36857174" class="c"><input type="checkbox" id="c-36857174" checked=""/><div class="controls bullet"><span class="by">pizza</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36856931">parent</a><span>|</span><a href="#36857633">prev</a><span>|</span><a href="#36858045">next</a><span>|</span><label class="collapse" for="c-36857174">[-]</label><label class="expand" for="c-36857174">[1 more]</label></div><br/><div class="children"><div class="content">Anything with feedback control. Updating a priority queue&#x27;s weights, adaptive caching, adaptive request limiting, etc. Ironically it looks like HN itself rate limited me the first time I tried to reply lol</div><br/></div></div></div></div><div id="36858045" class="c"><input type="checkbox" id="c-36858045" checked=""/><div class="controls bullet"><span class="by">noman-land</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854640">parent</a><span>|</span><a href="#36856931">prev</a><span>|</span><a href="#36855149">next</a><span>|</span><label class="collapse" for="c-36858045">[-]</label><label class="expand" for="c-36858045">[1 more]</label></div><br/><div class="children"><div class="content">I am a python noob and this is going to take me some time to process.</div><br/></div></div></div></div><div id="36855149" class="c"><input type="checkbox" id="c-36855149" checked=""/><div class="controls bullet"><span class="by">gurchik</span><span>|</span><a href="#36853786">parent</a><span>|</span><a href="#36854640">prev</a><span>|</span><a href="#36858649">next</a><span>|</span><label class="collapse" for="c-36855149">[-]</label><label class="expand" for="c-36855149">[1 more]</label></div><br/><div class="children"><div class="content">I like using generators when querying APIs that paginate results. It&#x27;s an easy way to abstract away the pagination for your caller.<p><pre><code>  def get_api_results(query):
    params = { &quot;next_token&quot;: None }
    while True:
      response = requests.get(URL, params=params)
      json = response.json()
      yield from json[&quot;results&quot;]
      if json[&quot;next_token&quot;] is None:
        return
      params[&quot;next_token&quot;] = json[&quot;next_token&quot;]
  
  for result in get_api_results(QUERY):
    process_result(result)  # No need to worry about pagination</code></pre></div><br/></div></div><div id="36858649" class="c"><input type="checkbox" id="c-36858649" checked=""/><div class="controls bullet"><span class="by">gcanyon</span><span>|</span><a href="#36853786">parent</a><span>|</span><a href="#36855149">prev</a><span>|</span><a href="#36853886">next</a><span>|</span><label class="collapse" for="c-36858649">[-]</label><label class="expand" for="c-36858649">[2 more]</label></div><br/><div class="children"><div class="content">I think I figured out that count(2) is from itertools? I&#x27;m new to python.<p>I think you could simplify the rest like so:<p><pre><code>    def primesHN():
        from collections import defaultdict
        from itertools import count
        yield(2)
        ps = defaultdict(list)
        for i in count(3,2):
            if i not in ps:
                yield(i)
                ps[i**2].append(2*i)
            else:
                for n in ps.pop(i):
                    ps[i + n].append(n)</code></pre></div><br/><div id="36859068" class="c"><input type="checkbox" id="c-36859068" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36858649">parent</a><span>|</span><a href="#36853886">next</a><span>|</span><label class="collapse" for="c-36859068">[-]</label><label class="expand" for="c-36859068">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think I figured out that count(2) is from itertools?<p>It is. Itertools is a masterpiece of a module. It has a lot of functions that operate on iterators and will work both on standard iterables (lists, tuples, dicts, range(), count() etc.) and on <i>your own</i> generators. It forms a sort of &quot;iterator algebra&quot; that makes working with them very easy.<p>&gt; I think you could simplify the rest like so:<p>Sounds good, but with a caveat: you do need to call &quot;del&quot; at the end for memory deallocation purposes. The garbage collector isn&#x27;t smart enough to know you won&#x27;t be using those dictionary entries any longer. Technically the code still works, but keeping everything in memory defeats the purpose of writing a generator.</div><br/></div></div></div></div><div id="36853886" class="c"><input type="checkbox" id="c-36853886" checked=""/><div class="controls bullet"><span class="by">erikvdven</span><span>|</span><a href="#36853786">parent</a><span>|</span><a href="#36858649">prev</a><span>|</span><a href="#36854425">next</a><span>|</span><label class="collapse" for="c-36853886">[-]</label><label class="expand" for="c-36853886">[6 more]</label></div><br/><div class="children"><div class="content">Thanks! I tried to add mostly the stuff I don&#x27;t encounter that often in blogs&#x2F;tutorials etc. But guess you are right. Generators, or at least the &#x27;yield&#x27; keyword, is often misunderstood, and we can&#x27;t emphasize them enough</div><br/><div id="36854064" class="c"><input type="checkbox" id="c-36854064" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36853886">parent</a><span>|</span><a href="#36854425">next</a><span>|</span><label class="collapse" for="c-36854064">[-]</label><label class="expand" for="c-36854064">[5 more]</label></div><br/><div class="children"><div class="content">Just to clarify, I don&#x27;t mean your article is bad or incomplete -- quite the contrary, I enjoyed it a lot. Generators are one of my favorite Python features and they&#x27;re kind of underused, mostly because people simply don&#x27;t know about them.<p>A couple more along the same lines:<p>- Metaclasses and type. (This is admittedly dark magic, but useful in library code, less so in application code)<p>- Magic methods! Everyone knows about __init__, but you can override all sorts of behaviors (see: <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;reference&#x2F;datamodel.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;reference&#x2F;datamodel.html</a>)<p>My favorite example (I have a lot of favorite examples :)) is __call__, which emulates function calling and is the equivalent of C++&#x27;s operator().<p>Why is it my favorite? Because as the old adage goes, &quot;a class is a poor man&#x27;s closure, a closure is a poor man&#x27;s class&quot;:<p><pre><code>  class C:
      def __init__(self, x):
          self.x = x
      def __call__(self, y):
          return self.x + y
 
  &gt;&gt;&gt; a = C(2)
  &gt;&gt;&gt; a(3)
  5</code></pre></div><br/><div id="36854303" class="c"><input type="checkbox" id="c-36854303" checked=""/><div class="controls bullet"><span class="by">erikvdven</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854064">parent</a><span>|</span><a href="#36856340">next</a><span>|</span><label class="collapse" for="c-36854303">[-]</label><label class="expand" for="c-36854303">[1 more]</label></div><br/><div class="children"><div class="content">Thanks a lot! Really appreciate it. Love the example! Haven&#x27;t used the dunder __call__ yet (like many magic methods I guess), but that&#x27;s a nice one!<p>I didn&#x27;t have to use Metaclasses, either, though I have read about them, especially in Fluent Python. But I guess I belong to the 99% who haven&#x27;t had to worry about them, yet :P</div><br/></div></div><div id="36856340" class="c"><input type="checkbox" id="c-36856340" checked=""/><div class="controls bullet"><span class="by">learplant</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854064">parent</a><span>|</span><a href="#36854303">prev</a><span>|</span><a href="#36854425">next</a><span>|</span><label class="collapse" for="c-36856340">[-]</label><label class="expand" for="c-36856340">[3 more]</label></div><br/><div class="children"><div class="content">I find that __call__ is very confusing, but maybe because I&#x27;m not used to seeing if often.<p>What is the benefit compared to having a method named &quot;add&quot; that also explains the behavior?</div><br/><div id="36857078" class="c"><input type="checkbox" id="c-36857078" checked=""/><div class="controls bullet"><span class="by">claytonjy</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36856340">parent</a><span>|</span><a href="#36856408">next</a><span>|</span><label class="collapse" for="c-36857078">[-]</label><label class="expand" for="c-36857078">[1 more]</label></div><br/><div class="children"><div class="content">I see it a lot in HuggingFace, and use it myself for classes that are used like a function, especially when the obvious method name is the verb form of the class name<p><pre><code>    processor = SomeProcessor.load(&quot;path&#x2F;to&#x2F;config&quot;)

    # with __call__
    processed_inputs = processor(inputs)

    # less awkward than
    processes_inputs = processor.process(inputs)
</code></pre>
The only benefit is to the human, same as @property or even @dataclass.</div><br/></div></div><div id="36856408" class="c"><input type="checkbox" id="c-36856408" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36856340">parent</a><span>|</span><a href="#36857078">prev</a><span>|</span><a href="#36854425">next</a><span>|</span><label class="collapse" for="c-36856408">[-]</label><label class="expand" for="c-36856408">[1 more]</label></div><br/><div class="children"><div class="content">If an object is callable you can use it in places that might conventionally expect functions. The utility of that is very situational, though. I&#x27;ve only used it a handful of times myself over the years I&#x27;ve known and used Python.<p>It may also give you a &quot;clearer&quot; (in quotes because subjective) presentation for something you&#x27;re trying to do.</div><br/></div></div></div></div></div></div></div></div><div id="36854425" class="c"><input type="checkbox" id="c-36854425" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36853786">parent</a><span>|</span><a href="#36853886">prev</a><span>|</span><a href="#36853975">next</a><span>|</span><label class="collapse" for="c-36854425">[-]</label><label class="expand" for="c-36854425">[5 more]</label></div><br/><div class="children"><div class="content">can you explain how generators work with multiprocess (Thread based pool) ?<p>is <i>ps</i> internal variable unique for each Thread or same?<p>is it safe to execute your primes() from different threads?</div><br/><div id="36854681" class="c"><input type="checkbox" id="c-36854681" checked=""/><div class="controls bullet"><span class="by">qsort</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854425">parent</a><span>|</span><a href="#36854561">next</a><span>|</span><label class="collapse" for="c-36854681">[-]</label><label class="expand" for="c-36854681">[1 more]</label></div><br/><div class="children"><div class="content">&gt; can you explain how generators work with multiprocess<p>The best way to think of a generator is as an object implementing the iteration protocol. They don&#x27;t really interact with concurrency, as far as multiprocess is concerned, they&#x27;re just regular objects. So the answer is that it depends on how you plan to share memory between the processes.<p>&gt; is ps internal variable unique for each Thread or same?<p>ps is local to the generator <i>instance</i>.<p><pre><code>  def f():
      x = 0
      while True:
          yield (x := x + 1)
 
  &gt;&gt;&gt; f()
  &lt;generator object f at 0x10412e500&gt;
  &gt;&gt;&gt; x = f()
  &gt;&gt;&gt; y = f()
  &gt;&gt;&gt; next(x)
  1
  &gt;&gt;&gt; next(x)
  2
  &gt;&gt;&gt; next(y)
  1
</code></pre>
&gt; is it safe to execute your primes() from different threads?<p>For this specific generator, you would run into the GIL. More generally, if you&#x27;re talking about non CPU-bound operations, you need to synchronize the threads. It&#x27;s worth looking into asyncio for those use cases.</div><br/></div></div><div id="36854561" class="c"><input type="checkbox" id="c-36854561" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854425">parent</a><span>|</span><a href="#36854681">prev</a><span>|</span><a href="#36853975">next</a><span>|</span><label class="collapse" for="c-36854561">[-]</label><label class="expand" for="c-36854561">[3 more]</label></div><br/><div class="children"><div class="content">A yield will simply return a generator object, which contains information about the next value to use, and how to continue the function execution. That&#x27;s why you need to use functions that yield things inside loops or list(...).<p>If you run it from different threads I guess it will be the same as calling the function multiple times, it will return a new started-from-the-top generator.<p><pre><code>    def sum():
        yield 1
        yield 2
    print(repr(sum()))
    print(next(sum()))
    print(next(sum()))
</code></pre>
Prints<p><pre><code>    &lt;generator object sum at 0x7fc6f14823c0&gt;
    1
    1</code></pre></div><br/><div id="36854595" class="c"><input type="checkbox" id="c-36854595" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854561">parent</a><span>|</span><a href="#36853975">next</a><span>|</span><label class="collapse" for="c-36854595">[-]</label><label class="expand" for="c-36854595">[2 more]</label></div><br/><div class="children"><div class="content">so Thread based based pool will have same instance of generator, while Process based pool with have unique instance of generator?</div><br/><div id="36854775" class="c"><input type="checkbox" id="c-36854775" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#36853786">root</a><span>|</span><a href="#36854595">parent</a><span>|</span><a href="#36853975">next</a><span>|</span><label class="collapse" for="c-36854775">[-]</label><label class="expand" for="c-36854775">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if a generator can be shared across threads, but in that case ... I have no idea :&#x2F;<p>You&#x27;ll need to search, or try!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="36853975" class="c"><input type="checkbox" id="c-36853975" checked=""/><div class="controls bullet"><span class="by">rowanseymour</span><span>|</span><a href="#36853786">prev</a><span>|</span><a href="#36856607">next</a><span>|</span><label class="collapse" for="c-36853975">[-]</label><label class="expand" for="c-36853975">[4 more]</label></div><br/><div class="children"><div class="content">Since Python 3.7<p><pre><code>  import pdb
  pdb.set_trace()
</code></pre>
can be written as just<p><pre><code>  breakpoint()</code></pre></div><br/><div id="36854025" class="c"><input type="checkbox" id="c-36854025" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36853975">parent</a><span>|</span><a href="#36854079">next</a><span>|</span><label class="collapse" for="c-36854025">[-]</label><label class="expand" for="c-36854025">[1 more]</label></div><br/><div class="children"><div class="content">I was told that at my job, but my fingers are so used to type `pdb` and emacs template-replacing it that I can&#x27;t change.</div><br/></div></div><div id="36854079" class="c"><input type="checkbox" id="c-36854079" checked=""/><div class="controls bullet"><span class="by">erikvdven</span><span>|</span><a href="#36853975">parent</a><span>|</span><a href="#36854025">prev</a><span>|</span><a href="#36854438">next</a><span>|</span><label class="collapse" for="c-36854079">[-]</label><label class="expand" for="c-36854079">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the tip! :)</div><br/></div></div><div id="36854438" class="c"><input type="checkbox" id="c-36854438" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36853975">parent</a><span>|</span><a href="#36854079">prev</a><span>|</span><a href="#36856607">next</a><span>|</span><label class="collapse" for="c-36854438">[-]</label><label class="expand" for="c-36854438">[1 more]</label></div><br/><div class="children"><div class="content">And this also works with Debugpy so you can actually use a proper debugger and not pdb which is frankly terrible.</div><br/></div></div></div></div><div id="36856607" class="c"><input type="checkbox" id="c-36856607" checked=""/><div class="controls bullet"><span class="by">ks2048</span><span>|</span><a href="#36853975">prev</a><span>|</span><a href="#36854288">next</a><span>|</span><label class="collapse" for="c-36856607">[-]</label><label class="expand" for="c-36856607">[1 more]</label></div><br/><div class="children"><div class="content">I know it&#x27;s a really minor point, but in a blog post about Python (rather than just one that is using Python), it kind of bothers me to see &quot;non-Pythonic&quot; code style,<p><pre><code>    if(x &gt; 0): ...
</code></pre>
vs<p><pre><code>    if x &gt; 0: ...
</code></pre>
but probably just OCD kicking in.</div><br/></div></div><div id="36854288" class="c"><input type="checkbox" id="c-36854288" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#36856607">prev</a><span>|</span><a href="#36855543">next</a><span>|</span><label class="collapse" for="c-36854288">[-]</label><label class="expand" for="c-36854288">[4 more]</label></div><br/><div class="children"><div class="content">This is a bit of bikeshedding, but I think<p><pre><code>  if not n in memo:
</code></pre>
is more naturally written as<p><pre><code>  if n not in memo:</code></pre></div><br/><div id="36854966" class="c"><input type="checkbox" id="c-36854966" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#36854288">parent</a><span>|</span><a href="#36857127">next</a><span>|</span><label class="collapse" for="c-36854966">[-]</label><label class="expand" for="c-36854966">[1 more]</label></div><br/><div class="children"><div class="content">As someone learning Python, but having worked with other languages, I think your second example is better as it reads more like English. I think that simplicity actually ends up much more rewarding when it comes to reading code.</div><br/></div></div><div id="36857127" class="c"><input type="checkbox" id="c-36857127" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36854288">parent</a><span>|</span><a href="#36854966">prev</a><span>|</span><a href="#36856754">next</a><span>|</span><label class="collapse" for="c-36857127">[-]</label><label class="expand" for="c-36857127">[1 more]</label></div><br/><div class="children"><div class="content">I agree. The first is order of operations dependent. Without looking, is that `(not n) in memo` or `not (n in memo)`?<p>The sent can only be interpreted one way.</div><br/></div></div><div id="36856754" class="c"><input type="checkbox" id="c-36856754" checked=""/><div class="controls bullet"><span class="by">alfalfasprout</span><span>|</span><a href="#36854288">parent</a><span>|</span><a href="#36857127">prev</a><span>|</span><a href="#36855543">next</a><span>|</span><label class="collapse" for="c-36856754">[-]</label><label class="expand" for="c-36856754">[1 more]</label></div><br/><div class="children"><div class="content">I would absolutely point this out in a code review. It&#x27;s not even that pedantic, it&#x27;s the kind of code that causes a double take b&#x2F;c.</div><br/></div></div></div></div><div id="36855543" class="c"><input type="checkbox" id="c-36855543" checked=""/><div class="controls bullet"><span class="by">aorist</span><span>|</span><a href="#36854288">prev</a><span>|</span><a href="#36853850">next</a><span>|</span><label class="collapse" for="c-36855543">[-]</label><label class="expand" for="c-36855543">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The underscore _ can be used as a throwaway variable to discard unwanted values:<p>So can any other variable, using underscore is just a convention to make it obvious that you&#x27;re not planning to re-use it (it doesn&#x27;t get GCed more aggressively or anything).<p>Similarly, private methods being prefixed with an underscore is also just a convention, you can access them from anywhere.<p>However, <i>double</i> underscores are used for magic attributes and name mangling for class attributes, which are interpreted differently! (See: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;1301369" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;1301369</a>)</div><br/><div id="36856996" class="c"><input type="checkbox" id="c-36856996" checked=""/><div class="controls bullet"><span class="by">noitpmeder</span><span>|</span><a href="#36855543">parent</a><span>|</span><a href="#36853850">next</a><span>|</span><label class="collapse" for="c-36856996">[-]</label><label class="expand" for="c-36856996">[1 more]</label></div><br/><div class="children"><div class="content">Many linters are also configured to ignore &#x27;_&#x27; for many tests (such as any &#x27;unused variable&#x27; warnings)</div><br/></div></div></div></div><div id="36853850" class="c"><input type="checkbox" id="c-36853850" checked=""/><div class="controls bullet"><span class="by">atxbcp</span><span>|</span><a href="#36855543">prev</a><span>|</span><a href="#36854764">next</a><span>|</span><label class="collapse" for="c-36853850">[-]</label><label class="expand" for="c-36853850">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  - none of these functionalities are &quot;overlooked&quot;, this is pretty basic python
  - for fibonacci you have a decorator for memoization (functools cache &#x2F; lru_cache)
  - you don&#x27;t need to use parenthesis for a single line &quot;if&quot;</code></pre></div><br/><div id="36854071" class="c"><input type="checkbox" id="c-36854071" checked=""/><div class="controls bullet"><span class="by">erikvdven</span><span>|</span><a href="#36853850">parent</a><span>|</span><a href="#36854036">next</a><span>|</span><label class="collapse" for="c-36854071">[-]</label><label class="expand" for="c-36854071">[1 more]</label></div><br/><div class="children"><div class="content">You are very much right a lot of it is pretty basic knowledge. From my experience though, a lot of python developers don&#x27;t take the python docs or tutorial as first resource, and quite some developers I met did lack quite some knowledge I mentioned in the article.<p>You are right about the fibonacci operator, I thought I did refer to another article where I mention the lru_cache as well :) But I&#x27;ll double check.<p>Good one about the parenthesis! I&#x27;ll post an update soon</div><br/></div></div><div id="36854036" class="c"><input type="checkbox" id="c-36854036" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#36853850">parent</a><span>|</span><a href="#36854071">prev</a><span>|</span><a href="#36854764">next</a><span>|</span><label class="collapse" for="c-36854036">[-]</label><label class="expand" for="c-36854036">[2 more]</label></div><br/><div class="children"><div class="content">You consider these &#x27;basic&#x27; python ? just curious, I&#x27;d say it&#x27;s a bit below intermediate.</div><br/><div id="36855158" class="c"><input type="checkbox" id="c-36855158" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#36853850">root</a><span>|</span><a href="#36854036">parent</a><span>|</span><a href="#36854764">next</a><span>|</span><label class="collapse" for="c-36855158">[-]</label><label class="expand" for="c-36855158">[1 more]</label></div><br/><div class="children"><div class="content">At the point we&#x27;re disagreeing about &#x27;basic&#x27; vs. &#x27;bit below intermediate&#x27;.. idk we at least have to agree how many levels the model has.<p>Fwiw I also thought it was pretty regular stuff, and then arcane library functions you&#x27;ve either needed or you haven&#x27;t. Also, that&#x27;s a generator, not a list comprehension.</div><br/></div></div></div></div></div></div><div id="36854764" class="c"><input type="checkbox" id="c-36854764" checked=""/><div class="controls bullet"><span class="by">BoppreH</span><span>|</span><a href="#36853850">prev</a><span>|</span><a href="#36854229">next</a><span>|</span><label class="collapse" for="c-36854764">[-]</label><label class="expand" for="c-36854764">[3 more]</label></div><br/><div class="children"><div class="content">Pretty good list. Two corrections:<p>The `first, *middle, last` trick doesn&#x27;t work if your list only has one element:<p><pre><code>  first, *middle, last = [1]
  ValueError: not enough values to unpack (expected at least 2, got 1)
</code></pre>
And the last title has a typo:<p>&gt; Separater for Large Numbers</div><br/><div id="36856248" class="c"><input type="checkbox" id="c-36856248" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#36854764">parent</a><span>|</span><a href="#36854229">next</a><span>|</span><label class="collapse" for="c-36856248">[-]</label><label class="expand" for="c-36856248">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the point about splat unpacking really is a correction. Unpacking always requires that the iterable has enough values to assign to the specified variables, this has nothing to do with the use of *middle.</div><br/><div id="36859501" class="c"><input type="checkbox" id="c-36859501" checked=""/><div class="controls bullet"><span class="by">BoppreH</span><span>|</span><a href="#36854764">root</a><span>|</span><a href="#36856248">parent</a><span>|</span><a href="#36854229">next</a><span>|</span><label class="collapse" for="c-36859501">[-]</label><label class="expand" for="c-36859501">[1 more]</label></div><br/><div class="children"><div class="content">To be clear, this is only a problem if your array can ever have less than two values, or if you require that `first` and `last` be different values.<p>The mistake is suggesting the unpacking <i>without caveats</i>, because it&#x27;ll fail in situations that the naive solution doesn&#x27;t:<p><pre><code>    items = [1]
    first = items[0]
    middle = items[1:-1]
    last = items[-1]
</code></pre>
This will still work as long as you have any elements.</div><br/></div></div></div></div></div></div><div id="36854229" class="c"><input type="checkbox" id="c-36854229" checked=""/><div class="controls bullet"><span class="by">TrianguloY</span><span>|</span><a href="#36854764">prev</a><span>|</span><a href="#36856543">next</a><span>|</span><label class="collapse" for="c-36854229">[-]</label><label class="expand" for="c-36854229">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    first, _, last = [1, 2, 3, 4, 5]
</code></pre>
I guess this is a typo, it should be<p><pre><code>    first, *_, last = [1, 2, 3, 4, 5]
</code></pre>
(As explained above!)<p>Other than that, nice list of python tricks, I love not-so-known features because it can make code shorter and prettier!</div><br/><div id="36854391" class="c"><input type="checkbox" id="c-36854391" checked=""/><div class="controls bullet"><span class="by">erikvdven</span><span>|</span><a href="#36854229">parent</a><span>|</span><a href="#36856543">next</a><span>|</span><label class="collapse" for="c-36854391">[-]</label><label class="expand" for="c-36854391">[1 more]</label></div><br/><div class="children"><div class="content">Sharp! Updated that line. And thank you for the compliment :)</div><br/></div></div></div></div><div id="36856543" class="c"><input type="checkbox" id="c-36856543" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#36854229">prev</a><span>|</span><a href="#36858396">next</a><span>|</span><label class="collapse" for="c-36856543">[-]</label><label class="expand" for="c-36856543">[2 more]</label></div><br/><div class="children"><div class="content">A couple people already pointed out that you can write `breakpoint()` instead of using `pdb.set_trace()`.<p>Here&#x27;s one more trick: you can use `pdb` to run scripts! `python -m pdb foo.py` will run `foo.py` but trigger a breakpoint on the first error.</div><br/><div id="36858762" class="c"><input type="checkbox" id="c-36858762" checked=""/><div class="controls bullet"><span class="by">tomtom1337</span><span>|</span><a href="#36856543">parent</a><span>|</span><a href="#36858396">next</a><span>|</span><label class="collapse" for="c-36858762">[-]</label><label class="expand" for="c-36858762">[1 more]</label></div><br/><div class="children"><div class="content">Oh! Thats a really nice one!</div><br/></div></div></div></div><div id="36858396" class="c"><input type="checkbox" id="c-36858396" checked=""/><div class="controls bullet"><span class="by">physicsguy</span><span>|</span><a href="#36856543">prev</a><span>|</span><a href="#36854161">next</a><span>|</span><label class="collapse" for="c-36858396">[-]</label><label class="expand" for="c-36858396">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because the language is so easy to learn, many practitioners only scratch the surface of its full potential, neglecting to delve into the more advanced and powerful aspects of the language which makes it so truly unique and powerful<p>We have definitely found this to be true in hiring. Many people’s Python knowledge seems to just be surface deep.</div><br/></div></div><div id="36854161" class="c"><input type="checkbox" id="c-36854161" checked=""/><div class="controls bullet"><span class="by">ivalm</span><span>|</span><a href="#36858396">prev</a><span>|</span><a href="#36854645">next</a><span>|</span><label class="collapse" for="c-36854161">[-]</label><label class="expand" for="c-36854161">[1 more]</label></div><br/><div class="children"><div class="content">Multiple context managers in a single with statement is something I didn’t know!</div><br/></div></div><div id="36854645" class="c"><input type="checkbox" id="c-36854645" checked=""/><div class="controls bullet"><span class="by">carabiner</span><span>|</span><a href="#36854161">prev</a><span>|</span><a href="#36854199">next</a><span>|</span><label class="collapse" for="c-36854645">[-]</label><label class="expand" for="c-36854645">[1 more]</label></div><br/><div class="children"><div class="content">Would add:<p>* For dicts, learn .setdefault() vs. .get() vs. defaultdict()<p>* .sort(key=sortingkey)<p>* itertools groupby, chain<p>* map, filter, reduce</div><br/></div></div><div id="36854199" class="c"><input type="checkbox" id="c-36854199" checked=""/><div class="controls bullet"><span class="by">stabbles</span><span>|</span><a href="#36854645">prev</a><span>|</span><a href="#36854598">next</a><span>|</span><label class="collapse" for="c-36854199">[-]</label><label class="expand" for="c-36854199">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Python arguments are evaluated when the function definition is encountered<p>This is a giant pain. Easy to miss. Sometimes forces you to deal with Optional[Something] instead of just Something.<p>Compare with Julia where default arguments are evaluated ... very late:<p><pre><code>    julia&gt; f(a, b, c, d = a * b * c) = d
    f (generic function with 2 methods)
    
    julia&gt; f(&quot;hello&quot;, &quot; &quot;, &quot;world&quot;)
    &quot;hello world&quot;
</code></pre>
that&#x27;s really neat.</div><br/><div id="36855033" class="c"><input type="checkbox" id="c-36855033" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#36854199">parent</a><span>|</span><a href="#36854598">next</a><span>|</span><label class="collapse" for="c-36855033">[-]</label><label class="expand" for="c-36855033">[1 more]</label></div><br/><div class="children"><div class="content">Probably one of the benefits I gained from writing JavaScript before ES5 (although have worked with many languages, I&#x27;ve only used a few that were dynamic - PHP, JS, and old VB). I write my functions as early as possible, having remembered hoisting rules from JavaScript (and trying to only rely on OOP with Python where it naturally makes sense).<p>Looking at your Julia example, this seems much more friendly and less surprise and error-prone.</div><br/></div></div></div></div><div id="36854598" class="c"><input type="checkbox" id="c-36854598" checked=""/><div class="controls bullet"><span class="by">ziedaniel1</span><span>|</span><a href="#36854199">prev</a><span>|</span><a href="#36855098">next</a><span>|</span><label class="collapse" for="c-36854598">[-]</label><label class="expand" for="c-36854598">[1 more]</label></div><br/><div class="children"><div class="content">A couple details worth noting:<p>- `repr` often outputs valid source code that evaluates to the object, including in the post&#x27;s example: running `datetime.datetime(2023, 7, 20, 15, 30, 0, 123456)` would give you a `datetime.datetime` object equivalent to `today`.<p>- Using `_` for throwaway variables is merely a convention and not built into the language in any way (unlike in Haskell, say).</div><br/></div></div><div id="36855098" class="c"><input type="checkbox" id="c-36855098" checked=""/><div class="controls bullet"><span class="by">version_five</span><span>|</span><a href="#36854598">prev</a><span>|</span><a href="#36854312">next</a><span>|</span><label class="collapse" for="c-36855098">[-]</label><label class="expand" for="c-36855098">[5 more]</label></div><br/><div class="children"><div class="content">Re unpacking with * one I use often is when you have a list of types of coordinates you want to plot, i.e.<p><pre><code>  # z = [(x0,y0), (x1,y1) ...]
</code></pre>
You can do<p><pre><code>  import matplotlib.pyplot as plt
  plt.plot(*zip(*z))
</code></pre>
I spent years doing<p><pre><code>  x = [t[0] for t in z] # etc
</code></pre>
before I realized this.</div><br/><div id="36855215" class="c"><input type="checkbox" id="c-36855215" checked=""/><div class="controls bullet"><span class="by">jacurtis</span><span>|</span><a href="#36855098">parent</a><span>|</span><a href="#36854312">next</a><span>|</span><label class="collapse" for="c-36855215">[-]</label><label class="expand" for="c-36855215">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d argue that your original approach is actually better than your new approach.<p>Using a list comprehension, such as your original approach, is pretty easily understood by anyone writing python and is easy to follow, it is also quite terse.<p>Your recursive unpacking zip thing is much harder to understand and read. This reminds me of the type of stuff you find in the codebase years later when the person who wrote it is long gone and you find a comment next to it that says:<p># No idea why this works, but don&#x27;t touch it<p>One of the problems I have with python is that there are a million super creative ways to do stuff, especially using less known parts of the language. People love to get super creative with it, but usually the simplest solution is actually the best one, especially when working on a team.<p>In your example above, you aren&#x27;t even saving any real space. Both approaches can be done inline, the list comprehension is maybe a few extra characters. You&#x27;re not really saving anything, just making it harder to read and maintain by others.<p>When I moved from a company that wrote in Python to one that wrote in Golang, I found that the restrictions that Golang offers is a huge benefit in a team. Because you don&#x27;t have access to all these crazy language components that python has, the code written in Go would be almost identical regardless of who wrote it. Of course everything in Golang is far far more verbose than Python, but I actually found it 100x more maintainable.<p>In the python codebase it was very easy to tell who wrote different parts of a codebase without looking at the git blame, because there was almost a &quot;voice&quot; with the style of writing python. But in Golang it was more restrictive which meant that the entire codebase was more cohesive and easily to jump around.</div><br/><div id="36855969" class="c"><input type="checkbox" id="c-36855969" checked=""/><div class="controls bullet"><span class="by">abecedarius</span><span>|</span><a href="#36855098">root</a><span>|</span><a href="#36855215">parent</a><span>|</span><a href="#36856091">next</a><span>|</span><label class="collapse" for="c-36855969">[-]</label><label class="expand" for="c-36855969">[1 more]</label></div><br/><div class="children"><div class="content">The need actually comes up a lot to transpose a list of lists. That zip can do it is not hard to visualize and it&#x27;s an idiom worth learning. If it still seems unclear, you can name things to help:<p><pre><code>    columns = zip(*rows)
</code></pre>
or<p><pre><code>    def transpose(list_of_lists): return zip(*list_of_lists)
</code></pre>
But anyway, yeah, tastes differ, it&#x27;s fine if we disagree. I do agree that Python has gotten uncomfortably complex. But this is a very old feature from simpler times and does not add any syntax or metaprogramming features, it&#x27;s just an already needed function.</div><br/></div></div><div id="36856091" class="c"><input type="checkbox" id="c-36856091" checked=""/><div class="controls bullet"><span class="by">andelink</span><span>|</span><a href="#36855098">root</a><span>|</span><a href="#36855215">parent</a><span>|</span><a href="#36855969">prev</a><span>|</span><a href="#36855295">next</a><span>|</span><label class="collapse" for="c-36856091">[-]</label><label class="expand" for="c-36856091">[1 more]</label></div><br/><div class="children"><div class="content">Not saying I disagree with you, but I do want to note that the specific example of unzipping a list using `zip` has been in the official zip docs [1] as long as I can remember, and as such, should be commonly understood by Python developers.<p>[1] <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functions.html#zip" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functions.html#zip</a></div><br/></div></div></div></div></div></div><div id="36854312" class="c"><input type="checkbox" id="c-36854312" checked=""/><div class="controls bullet"><span class="by">MayeulC</span><span>|</span><a href="#36855098">prev</a><span>|</span><a href="#36854344">next</a><span>|</span><label class="collapse" for="c-36854312">[-]</label><label class="expand" for="c-36854312">[3 more]</label></div><br/><div class="children"><div class="content">Hmm, I encountered or used all of these somewhere, but 4 days ago I learned something else: python natively supports complex numbers.<p><pre><code>    a=1+3j
    b=a+4j
</code></pre>
I encountered this when a friend noticed some weird syntax for a numpy meshgrid (via mgrid):<p><pre><code>    np.mgrid[-1:1:5j]</code></pre></div><br/><div id="36857158" class="c"><input type="checkbox" id="c-36857158" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#36854312">parent</a><span>|</span><a href="#36856982">next</a><span>|</span><label class="collapse" for="c-36857158">[-]</label><label class="expand" for="c-36857158">[1 more]</label></div><br/><div class="children"><div class="content">That parses to me as &quot;given the list np.mgrid, return indexes -1 through 1, step by 5j&quot;. I know it&#x27;s not, but that&#x27;s what it looks like to me.</div><br/></div></div><div id="36856982" class="c"><input type="checkbox" id="c-36856982" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#36854312">parent</a><span>|</span><a href="#36857158">prev</a><span>|</span><a href="#36854344">next</a><span>|</span><label class="collapse" for="c-36856982">[-]</label><label class="expand" for="c-36856982">[1 more]</label></div><br/><div class="children"><div class="content">Repr prints source code that will (often) give you an equivalent object. I would be highly surprised if it got you
The same object instance. == but not ===</div><br/></div></div></div></div><div id="36854344" class="c"><input type="checkbox" id="c-36854344" checked=""/><div class="controls bullet"><span class="by">zwieback</span><span>|</span><a href="#36854312">prev</a><span>|</span><a href="#36854780">next</a><span>|</span><label class="collapse" for="c-36854344">[-]</label><label class="expand" for="c-36854344">[1 more]</label></div><br/><div class="children"><div class="content">Great list, thanks, I&#x27;ll be sure to use some of these.<p>Here&#x27;s the obvious question: how many more unknown-but-useful features are hidden away in other similar articles.</div><br/></div></div><div id="36854780" class="c"><input type="checkbox" id="c-36854780" checked=""/><div class="controls bullet"><span class="by">mkl95</span><span>|</span><a href="#36854344">prev</a><span>|</span><a href="#36857814">next</a><span>|</span><label class="collapse" for="c-36854780">[-]</label><label class="expand" for="c-36854780">[2 more]</label></div><br/><div class="children"><div class="content">Some of these features lie in the border of the uncanny valley where languages like Ruby and &quot;vanilla Javascript&quot; live, and are not compatible with the principle of least surprise or even the Zen of Python. I don&#x27;t write too much Python anymore, but when I do I keep it simple and explicit.</div><br/><div id="36855597" class="c"><input type="checkbox" id="c-36855597" checked=""/><div class="controls bullet"><span class="by">dajt</span><span>|</span><a href="#36854780">parent</a><span>|</span><a href="#36857814">next</a><span>|</span><label class="collapse" for="c-36855597">[-]</label><label class="expand" for="c-36855597">[1 more]</label></div><br/><div class="children"><div class="content">I find a lot of python like that. It&#x27;s a simple language to get started in but an incredibly complex language to try and get across more than skin deep. Maybe not C++ complex but more than I expected.<p>It has some wild features and crazy syntax and if you know it, it&#x27;s probably awesome, but I too like to keep it mostly simple and obvious.</div><br/></div></div></div></div><div id="36857814" class="c"><input type="checkbox" id="c-36857814" checked=""/><div class="controls bullet"><span class="by">andreareina</span><span>|</span><a href="#36854780">prev</a><span>|</span><a href="#36855779">next</a><span>|</span><label class="collapse" for="c-36857814">[-]</label><label class="expand" for="c-36857814">[1 more]</label></div><br/><div class="children"><div class="content">Mutable default arguments is widely regarded to be a footgun. I agree.</div><br/></div></div><div id="36855779" class="c"><input type="checkbox" id="c-36855779" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#36857814">prev</a><span>|</span><a href="#36854665">next</a><span>|</span><label class="collapse" for="c-36855779">[-]</label><label class="expand" for="c-36855779">[1 more]</label></div><br/><div class="children"><div class="content">In newer versions of Python, pdb.set_trace() is automatically aliased to the top level breakpoint() function. Your no longer need to import pdb.</div><br/></div></div><div id="36854665" class="c"><input type="checkbox" id="c-36854665" checked=""/><div class="controls bullet"><span class="by">was_a_dev</span><span>|</span><a href="#36855779">prev</a><span>|</span><a href="#36853990">next</a><span>|</span><label class="collapse" for="c-36854665">[-]</label><label class="expand" for="c-36854665">[2 more]</label></div><br/><div class="children"><div class="content">The walrus operator isn&#x27;t overlooked imo. It&#x27;s more that many still haven&#x27;t updated to &gt;3.8</div><br/><div id="36857963" class="c"><input type="checkbox" id="c-36857963" checked=""/><div class="controls bullet"><span class="by">amethyst</span><span>|</span><a href="#36854665">parent</a><span>|</span><a href="#36853990">next</a><span>|</span><label class="collapse" for="c-36857963">[-]</label><label class="expand" for="c-36857963">[1 more]</label></div><br/><div class="children"><div class="content">3.7 was released in 2018 and is already EOL. Those folks should probably start considering an upgrade...</div><br/></div></div></div></div><div id="36853990" class="c"><input type="checkbox" id="c-36853990" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#36854665">prev</a><span>|</span><a href="#36856579">next</a><span>|</span><label class="collapse" for="c-36853990">[-]</label><label class="expand" for="c-36853990">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Python arguments are evaluated when the function definition is encountered. Good to remember that!<p>I would never try to exploit this behavior to achieve some kind of benefit (avoiding max recursion).  Any tricks you try to do with this is almost definitely going to to cause bugs that are very difficult to track down.  So don&#x27;t be too clever here.</div><br/><div id="36854232" class="c"><input type="checkbox" id="c-36854232" checked=""/><div class="controls bullet"><span class="by">hangonhn</span><span>|</span><a href="#36853990">parent</a><span>|</span><a href="#36855145">next</a><span>|</span><label class="collapse" for="c-36854232">[-]</label><label class="expand" for="c-36854232">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. I was really surprised to see this as a feature to be used rather than a gotcha. I&#x27;ve seen it more as gotchas, as in actual bugs introduced because of this behavior, and never as a feature until now. I can see why he thinks it&#x27;s useful though and, maybe within his specific context, it is. That said, even for his example, I think he would have been better off using <a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functools.html#functools.cache" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;functools.html#functools.c...</a></div><br/></div></div><div id="36855145" class="c"><input type="checkbox" id="c-36855145" checked=""/><div class="controls bullet"><span class="by">progmetaldev</span><span>|</span><a href="#36853990">parent</a><span>|</span><a href="#36854232">prev</a><span>|</span><a href="#36856579">next</a><span>|</span><label class="collapse" for="c-36855145">[-]</label><label class="expand" for="c-36855145">[1 more]</label></div><br/><div class="children"><div class="content">Before I saw your comment, I had &quot;overlooked&quot; that these were presented as beneficial features, rather than just curiosities. As someone just learning Python, but familiar with other languages, I can only hope that if I start using Python in production with other developers they take the most obvious route (or use a comment as to why they would be relying on this type of behavior).<p>I chose to learn Python because it seemed to be the easiest to read, which to my mind meant working in a team would lead to easier discovery and understanding. Then I see articles like this, and wonder if I&#x27;ll have a lot of footguns to watch out for where the code isn&#x27;t as clear as it seems.</div><br/></div></div></div></div><div id="36856579" class="c"><input type="checkbox" id="c-36856579" checked=""/><div class="controls bullet"><span class="by">carapace</span><span>|</span><a href="#36853990">prev</a><span>|</span><a href="#36854457">next</a><span>|</span><label class="collapse" for="c-36856579">[-]</label><label class="expand" for="c-36856579">[1 more]</label></div><br/><div class="children"><div class="content">Slice notation can be used on the left-hand side of assignment.</div><br/></div></div><div id="36854457" class="c"><input type="checkbox" id="c-36854457" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#36856579">prev</a><span>|</span><a href="#36854121">next</a><span>|</span><label class="collapse" for="c-36854457">[-]</label><label class="expand" for="c-36854457">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Overlooked core functionality&quot; is an interesting way to spell &quot;massive footgun&quot;.</div><br/><div id="36857204" class="c"><input type="checkbox" id="c-36857204" checked=""/><div class="controls bullet"><span class="by">QuiDortDine</span><span>|</span><a href="#36854457">parent</a><span>|</span><a href="#36854121">next</a><span>|</span><label class="collapse" for="c-36857204">[-]</label><label class="expand" for="c-36857204">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been coding for most of my life and I can&#x27;t believe some people would choose some of these tricks when python has much simpler syntax for most of these.<p>The first, *_, last trick for example would be particularly obnoxious to encounter. The first element is my_list[0], last is my_list[-1]. Dead simple, way easier to understand at a glance.</div><br/></div></div></div></div><div id="36854121" class="c"><input type="checkbox" id="c-36854121" checked=""/><div class="controls bullet"><span class="by">barrenko</span><span>|</span><a href="#36854457">prev</a><span>|</span><label class="collapse" for="c-36854121">[-]</label><label class="expand" for="c-36854121">[1 more]</label></div><br/><div class="children"><div class="content">Use all this and you&#x27;ve got yourself a poor man&#x27;s Ruby.</div><br/></div></div></div></div></div></div></div></body></html>