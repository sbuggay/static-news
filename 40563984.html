<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717491672767" as="style"/><link rel="stylesheet" href="styles.css?v=1717491672767"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brioche.dev/blog/announcing-brioche/">Show HN: Brioche – A new Nix-like package manager</a> <span class="domain">(<a href="https://brioche.dev">brioche.dev</a>)</span></div><div class="subtext"><span>kylewlacy</span> | <span>46 comments</span></div><br/><div><div id="40571462" class="c"><input type="checkbox" id="c-40571462" checked=""/><div class="controls bullet"><span class="by">raffraffraff</span><span>|</span><a href="#40566621">next</a><span>|</span><label class="collapse" for="c-40571462">[-]</label><label class="expand" for="c-40571462">[3 more]</label></div><br/><div class="children"><div class="content">Reading the comments makes me think I&#x27;m turning into my dad. He was a simple man in terms of education and career. He was a fire man on a stream train in 1950, a farmer, barman, handyman. Out in the sticks, he was everyone&#x27;s go-to guy when a vet couldn&#x27;t be found, because he kept a &quot;livestock first aid kit&quot; including penicillin &amp; syringes. He talked to vets and read books and knew about the most common ailments and how to treat them. He serviced his own car and tractor, including stripping the tractor engine down in his yard without proper tools, and getting cylinders bored and pistons sleeved, and putting it back together. He ran electric cable in farm building and sheds (after chatting to an electrician) and he did a ton of building work around the house. But at a certain age, maybe around 50, all new technology was out. Electricity was fine but electronics were out. Mechanical problems were fine because you could look straight at a thing and figure out how it clicked together, but once it had a microcontroller and a panel that abstracted away the actual working of the machine it just became some weird arbitrary &quot;thing&quot; that blocked his view of the machine. I&#x27;m sure if he was in his 20s when this stuff appeared he&#x27;d be all over it, but he was born in 1926, so I think the mighty micro was too late for him. He flatly refused to use the VCR, alarm systems, any type of computer. Show him a rubis cube, he&#x27;s interested. Show him a microwave oven with more than 5 buttons and he&#x27;ll make a sandwich instead.<p>This is me with nix. I&#x27;m ok with all the stuff that&#x27;s emerged in my field (infra&#x2F;sysadmin) since the 90s. But nix makes me instantly glaze over. Several times I tried, but it&#x27;s like my brain unplugs itself. I&#x27;m sure it does some wonderful stuff at an extremely high price that I&#x27;m not willing to pay.<p>Nix has a huge mindshare, which I don&#x27;t think you can win back if Nix keeps fixing the core issues mentored in these comments. Best of luck with this, though.</div><br/><div id="40571477" class="c"><input type="checkbox" id="c-40571477" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#40571462">parent</a><span>|</span><a href="#40566621">next</a><span>|</span><label class="collapse" for="c-40571477">[-]</label><label class="expand" for="c-40571477">[2 more]</label></div><br/><div class="children"><div class="content">Nix solves the same problem we used to solve back in the day (before Docker taught us to run everything as root and disable firewalls, #yolo) ad-hoc with random poorly maintained scripts.<p>If you never had to solve this problem then it probably isn&#x27;t for you. If you did, then being able to finally replace the old contraptions with something properly engineered is a breath of fresh air.</div><br/><div id="40572025" class="c"><input type="checkbox" id="c-40572025" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#40571462">root</a><span>|</span><a href="#40571477">parent</a><span>|</span><a href="#40566621">next</a><span>|</span><label class="collapse" for="c-40572025">[-]</label><label class="expand" for="c-40572025">[1 more]</label></div><br/><div class="children"><div class="content">&gt;before Docker taught us to run everything as root<p>Windows called, it wants its Administrators back.</div><br/></div></div></div></div></div></div><div id="40566621" class="c"><input type="checkbox" id="c-40566621" checked=""/><div class="controls bullet"><span class="by">phlip9</span><span>|</span><a href="#40571462">prev</a><span>|</span><a href="#40566572">next</a><span>|</span><label class="collapse" for="c-40566621">[-]</label><label class="expand" for="c-40566621">[2 more]</label></div><br/><div class="children"><div class="content">Congrats on the release! I love the focus on devex w&#x2F; typescript and autocomplete. That&#x27;s probably one of my biggest pain points with Nix -- writing any non-trivial package always requires a ripgrep adventure through nixpkgs. Finding the right poorly documented and poorly discoverable derivation attributes is always such a chore.<p>What are your plans for cross-compilation or heavy package customization? One of nixpkgs coolest party tricks imo is that you can just change the stdenv and get a musl static binary or cross-compiled binary.</div><br/><div id="40566902" class="c"><input type="checkbox" id="c-40566902" checked=""/><div class="controls bullet"><span class="by">kylewlacy</span><span>|</span><a href="#40566621">parent</a><span>|</span><a href="#40566572">next</a><span>|</span><label class="collapse" for="c-40566902">[-]</label><label class="expand" for="c-40566902">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What are your plans for cross-compilation or heavy package customization? One of nixpkgs coolest party tricks imo is that you can just change the stdenv and get a musl static binary or cross-compiled binary.<p>So in general, I don&#x27;t think I&#x27;m going to have anything quite as powerful as Nix&#x27;s overrides. But I&#x27;m hoping most of the use-cases for it will be covered by some simpler options:<p>- Since build definitions are functions, package authors can just take arguments for the things they want downstream users to be able to customize (e.g. `configure` flags, optional features and plugins, etc.)<p>- I haven&#x27;t built it yet, but I think adding support for dependency overrides would be fairly easy, a la Cargo. Basically, you&#x27;d just fork or clone the package you want to tweak, make your tweaks, then set an &quot;overrides&quot; option to use it instead. I know that&#x27;s not a super satisfying answer, but that should help cover a lot of use cases<p>- For toolchains specifically, I have an idea in mind for this as well (also not implemented at all). At a high level, the idea is that packages could use &quot;dynamic bindings&quot;, which you can then override for downstream recipes (this would require some new runtime features in Brioche itself). The toolchain itself would effectively be a dynamic binding, letting you pick a different recipe (so you could swap glibc for musl, or gcc for clang, etc). Cross-compilation would also be built on this same feature</div><br/></div></div></div></div><div id="40566572" class="c"><input type="checkbox" id="c-40566572" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40566621">prev</a><span>|</span><a href="#40568937">next</a><span>|</span><label class="collapse" for="c-40566572">[-]</label><label class="expand" for="c-40566572">[8 more]</label></div><br/><div class="children"><div class="content">Flakes definitely help with the giant megarepo annoyances of NixOS, though they&#x27;re still a little irritating.  If you are writing in a languages that doesn&#x27;t hasn&#x27;t had its packages directly integrated into the build system (like Python&#x27;s has), it can be really irritating to do anything with them, since the `nix build` command disables network access and you therefore cannot use regular package manager.<p>I&#x27;m doing a project in Julia, and I&#x27;m using Nix Flakes to do it, but it&#x27;s been immensely annoying to actually get that working [1].  As a result, I&#x27;ve had avoid using the `nix build` command entirely (though the flakes are still useful for the `nix develop` command).<p>All that said, do you plan on having Brioche work with reproducible builds, and if so do you have a plan to make what I mentioned a bit less irritating?<p>[1] I know Julia2Nix exists, and I have never managed to actually get that working on any platform.</div><br/><div id="40566774" class="c"><input type="checkbox" id="c-40566774" checked=""/><div class="controls bullet"><span class="by">kylewlacy</span><span>|</span><a href="#40566572">parent</a><span>|</span><a href="#40567568">next</a><span>|</span><label class="collapse" for="c-40566774">[-]</label><label class="expand" for="c-40566774">[4 more]</label></div><br/><div class="children"><div class="content">This was one of my bigger pain points with Nix as well: there was a lot of &quot;reinventing the world&quot; just to avoid network access. With Brioche, I stuck with disabling network access by default, but there&#x27;s an escape hatch to specifically opt-in to networking (by calling `.unsafe({ networking: true })` on a process recipe). My thoughts are that Cargo, NPM, Poetry, etc. have all done a great job building amazing tooling to download and verify resources from the network against a lockfile, and I wanted to be able to leverage as much of that as possible. So, for example, `npm clean-install` will give you more-or-less the same guarantees that Nix does, so my thought was as long as it&#x27;s encapsulated properly, I&#x27;d rather lean on existing tooling (that&#x27;s also why I used the term &quot;unsafe&quot;, you need to make sure you only access the network with tools that do sufficient verification!)<p>I&#x27;ve generally stayed away from using the term &quot;reproducible build&quot; when talking about Brioche, because I don&#x27;t feel like it fits the reproducible-builds.org definition (though I don&#x27;t think Nix does either). But, if a build is cached locally or in the registry, then you&#x27;re guaranteed to get the same result, since it&#x27;ll just re-use the cache<p>The sandboxing also gives pretty strong guarantees around hermetic builds[1]. So I think you could do reproducible builds _within_ Brioche (and I&#x27;d like to add tools to make this even easier), but I&#x27;d say Brioche itself doesn&#x27;t give you reproducible builds out of the box<p>[1]: <a href="https:&#x2F;&#x2F;bazel.build&#x2F;basics&#x2F;hermeticity" rel="nofollow">https:&#x2F;&#x2F;bazel.build&#x2F;basics&#x2F;hermeticity</a></div><br/><div id="40566874" class="c"><input type="checkbox" id="c-40566874" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40566572">root</a><span>|</span><a href="#40566774">parent</a><span>|</span><a href="#40571476">next</a><span>|</span><label class="collapse" for="c-40566874">[-]</label><label class="expand" for="c-40566874">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s actually really great to hear! I might need to play with this tonight then.<p>It looks like the project files aren&#x27;t radically dissimilar to Flakes, so I think you&#x27;re really on the right track for making something that could be really useful for a lot of people. Great work!</div><br/></div></div><div id="40571476" class="c"><input type="checkbox" id="c-40571476" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40566572">root</a><span>|</span><a href="#40566774">parent</a><span>|</span><a href="#40566874">prev</a><span>|</span><a href="#40567568">next</a><span>|</span><label class="collapse" for="c-40571476">[-]</label><label class="expand" for="c-40571476">[2 more]</label></div><br/><div class="children"><div class="content">&gt; have all done a great job building amazing tooling to download and verify resources from the network against a lockfile<p>This is a bad assumption</div><br/><div id="40571873" class="c"><input type="checkbox" id="c-40571873" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40566572">root</a><span>|</span><a href="#40571476">parent</a><span>|</span><a href="#40567568">next</a><span>|</span><label class="collapse" for="c-40571873">[-]</label><label class="expand" for="c-40571873">[1 more]</label></div><br/><div class="children"><div class="content">Why? Are you referring to the fact that it&#x27;s opt-in; you have to use `cargo build --locked` or `npm ci`?</div><br/></div></div></div></div></div></div><div id="40567568" class="c"><input type="checkbox" id="c-40567568" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#40566572">parent</a><span>|</span><a href="#40566774">prev</a><span>|</span><a href="#40571224">next</a><span>|</span><label class="collapse" for="c-40567568">[-]</label><label class="expand" for="c-40567568">[2 more]</label></div><br/><div class="children"><div class="content">&gt;`nix build` command disables network access<p>Only if building with sandbox enabled. Can disable it if network access is required. Seems someone opened an issue asking[1] for granular permissions (explicit network restriction) but has been marked as stale. In same issue someone else has made comment providing an hybrid approach.<p>Since you mentioned Julia, it&#x27;s possible to build Julia environments (with arbitrary packages) using the `.withPackages` function. E.g. `julia.withPackages [&quot;Plots&quot;]`.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;issues&#x2F;4584">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nix&#x2F;issues&#x2F;4584</a></div><br/><div id="40567739" class="c"><input type="checkbox" id="c-40567739" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40566572">root</a><span>|</span><a href="#40567568">parent</a><span>|</span><a href="#40571224">next</a><span>|</span><label class="collapse" for="c-40567739">[-]</label><label class="expand" for="c-40567739">[1 more]</label></div><br/><div class="children"><div class="content">I didn’t realize that.  I will give that a look.</div><br/></div></div></div></div><div id="40571224" class="c"><input type="checkbox" id="c-40571224" checked=""/><div class="controls bullet"><span class="by">Rucadi</span><span>|</span><a href="#40566572">parent</a><span>|</span><a href="#40567568">prev</a><span>|</span><a href="#40568937">next</a><span>|</span><label class="collapse" for="c-40571224">[-]</label><label class="expand" for="c-40571224">[1 more]</label></div><br/><div class="children"><div class="content">If you mark a derivation as impure with __impure=true;
and activate &quot;ca-derivations flakes nix-command&quot; as experimental features,
you can access the internet.<p>I agree sometimes is a pain tho.<p>But most of the time, If you need internet access, if you can specify the &quot;hash&quot; of the result file, anything that you do to achieve that file can have internet access.</div><br/></div></div></div></div><div id="40568937" class="c"><input type="checkbox" id="c-40568937" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40566572">prev</a><span>|</span><a href="#40566649">next</a><span>|</span><label class="collapse" for="c-40568937">[-]</label><label class="expand" for="c-40568937">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really happy to see more work on package managers in this space. I used Nix for a little bit, but I shared the frustration expressed by other commenters on the language itself. I have found my zen on GNU Guix, but more options are better :)</div><br/></div></div><div id="40566649" class="c"><input type="checkbox" id="c-40566649" checked=""/><div class="controls bullet"><span class="by">charlotte-fyi</span><span>|</span><a href="#40568937">prev</a><span>|</span><a href="#40566812">next</a><span>|</span><label class="collapse" for="c-40566649">[-]</label><label class="expand" for="c-40566649">[3 more]</label></div><br/><div class="children"><div class="content">Very exciting. The ideas behind Nix are so good and everything else so bad. It seems like a lot of people are trying to solve this by building abstractions on top of Nix, but I&#x27;m really skeptical that is the solution. As crazy as a full rewrite is, I hope someone succeeds!</div><br/><div id="40566858" class="c"><input type="checkbox" id="c-40566858" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40566649">parent</a><span>|</span><a href="#40569156">next</a><span>|</span><label class="collapse" for="c-40566858">[-]</label><label class="expand" for="c-40566858">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.  NixOS is a marvel of engineering to me, and kind of hard to go back from once you get used to it. Automatic snapshotting on every configuration change, the entire system state being configurable through text files and therefore never being ambiguous, being able to temporarily install stuff without it polluting your path for forever by using nix-shells, clearly being able to see and define stuff like boot parameters and kernel modules are just insanely wonderful things, all while still using (I think) a vanilla kernel and really no runtime overhead, allowing you to make an insanely lean system without ever being unsure if you&#x27;re missing something or having to worry about extra crap that you installed by accident lingering forever. In my mind about as close to an &quot;objectively better&quot; way to handle an OS (at least for people who are technical) as one can ask for. I have no desire to go back to any other distro for my server.<p>But the Nix language itself is really quite annoying.  I mean, I&#x27;ve more or less gotten used to its annoyances, and I do think that some of the DSLs it has are excellent (I <i>really</i> like the Nginx and systemd configuration stuff, for example), and a lot of the configs are just `services.myservice.enable = true` which is fine, but a lot of the time I&#x27;m kind of confused about what syntax is allowed and how loops work and the like. It&#x27;s not horrible or anything, just a bit annoying because I&#x27;ll occasionally have to do a nixos-rebuild like three or four times because I messed up some subtle syntax, and it&#x27;s <i>especially</i> annoying if I have to go dig at the root Nix package to find out what I did wrong [1].<p>I think decentralizing stuff in the form of flakes might be able to help with this, if for no other reason the area in which you&#x27;d be forced to look for configuration stuff could be reduced, but I do think NixOS would benefit from some rearchitecture.<p>[1] Which happened yesterday with an ethernet card configuration: <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;nixos-24.05&#x2F;nixos&#x2F;modules&#x2F;system&#x2F;boot&#x2F;networkd.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;nixos-24.05&#x2F;nixos&#x2F;modu...</a></div><br/></div></div><div id="40569156" class="c"><input type="checkbox" id="c-40569156" checked=""/><div class="controls bullet"><span class="by">whateveracct</span><span>|</span><a href="#40566649">parent</a><span>|</span><a href="#40566858">prev</a><span>|</span><a href="#40566812">next</a><span>|</span><label class="collapse" for="c-40569156">[-]</label><label class="expand" for="c-40569156">[1 more]</label></div><br/><div class="children"><div class="content">ever use nix repl? i found my complaints about grokkability disappeared once i realized i could easily introspect my build (and all my dependencies&#x27; builds) at any level.<p>that + learning the like 5 or so idioms that pervade nixpkgs and you can use Nix quite successfully imo.</div><br/></div></div></div></div><div id="40566812" class="c"><input type="checkbox" id="c-40566812" checked=""/><div class="controls bullet"><span class="by">andrewla</span><span>|</span><a href="#40566649">prev</a><span>|</span><a href="#40567410">next</a><span>|</span><label class="collapse" for="c-40566812">[-]</label><label class="expand" for="c-40566812">[13 more]</label></div><br/><div class="children"><div class="content">I&#x27;m very excited by all the attempts to replace Nix, but I don&#x27;t think I&#x27;ll be exploring this much deeper.<p>In my opinion the issue with Nix is that the data model is not crisply defined -- it&#x27;s there, but hidden under a lot of goop that is the Nix language itself and the various assumptions and baggage that goes with it.<p>What I want is a primarily declarative syntax supporting a rich set of data structures, ideally a non-Turing set of primitives, with a much more intuitive way of gluing things together. So basically bash (or even sh) with a well-defined way of transmitting environment variables and setting up the environment.<p>The idea of importing a language that has broader support (typescript) as an alternative to the Nix language seems appealing at first, but typescript is such a high-dependency system that it&#x27;s hard to get excited about it.</div><br/><div id="40567948" class="c"><input type="checkbox" id="c-40567948" checked=""/><div class="controls bullet"><span class="by">charlotte-fyi</span><span>|</span><a href="#40566812">parent</a><span>|</span><a href="#40567489">next</a><span>|</span><label class="collapse" for="c-40567948">[-]</label><label class="expand" for="c-40567948">[4 more]</label></div><br/><div class="children"><div class="content">I think that declarative configuration languages scratch the itch of a lot of developer brains, but in practice it doesn’t really matter and using more familiar languages is a huge benefit to devex that shouldn’t be overlooked if the goal is to be mainstream. Yes, it requires more discipline on the reviewer front not to create abstractions that are too powerful&#x2F;footgun-y, but it’s totally possible to write clear, declarative code in a “real” programming language without artificial constraints.</div><br/><div id="40568197" class="c"><input type="checkbox" id="c-40568197" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40567948">parent</a><span>|</span><a href="#40567489">next</a><span>|</span><label class="collapse" for="c-40568197">[-]</label><label class="expand" for="c-40568197">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not so worried about my disciplined coworker who just wants to help. If we were all reviewing his code I&#x27;d agree with you.<p>The people I want to help are those who are unknowingly reviewing malicious commits, and I think that declarative configuration languages have a part to play there.</div><br/><div id="40568407" class="c"><input type="checkbox" id="c-40568407" checked=""/><div class="controls bullet"><span class="by">charlotte-fyi</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40568197">parent</a><span>|</span><a href="#40567489">next</a><span>|</span><label class="collapse" for="c-40568407">[-]</label><label class="expand" for="c-40568407">[2 more]</label></div><br/><div class="children"><div class="content">This is solved in tools like Pulumi by having a declarative and auditable build artifact as an intermediate step that can be diffed. This seems to solve a lot of the security issues (and is generally a good idea anyway).</div><br/><div id="40568491" class="c"><input type="checkbox" id="c-40568491" checked=""/><div class="controls bullet"><span class="by">NegativeLatency</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40568407">parent</a><span>|</span><a href="#40567489">next</a><span>|</span><label class="collapse" for="c-40568491">[-]</label><label class="expand" for="c-40568491">[1 more]</label></div><br/><div class="children"><div class="content">I would still prefer to debug terraform (which is a fair bit more declarative) rather than pulumi</div><br/></div></div></div></div></div></div></div></div><div id="40567489" class="c"><input type="checkbox" id="c-40567489" checked=""/><div class="controls bullet"><span class="by">likium</span><span>|</span><a href="#40566812">parent</a><span>|</span><a href="#40567948">prev</a><span>|</span><a href="#40567202">next</a><span>|</span><label class="collapse" for="c-40567489">[-]</label><label class="expand" for="c-40567489">[2 more]</label></div><br/><div class="children"><div class="content">Starlark is widely used by Bazel and Buck. That would fulfill similar properties and build system folks have one fewer thing to learn.</div><br/><div id="40569387" class="c"><input type="checkbox" id="c-40569387" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40567489">parent</a><span>|</span><a href="#40567202">next</a><span>|</span><label class="collapse" for="c-40569387">[-]</label><label class="expand" for="c-40569387">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and Bazel makes some very serious trade-offs in order to make starlark work. Notably, dependencies are referenced as stringly labels as a poor substitute for lazy evaluation (starlark itself has strict evaluation semantics).<p>This in turn requires additional tooling to catch errors early, and also means that a starlark-repl for Bazel will never really be all that useful, since the build graph doesn&#x27;t exist in starlark alone.<p>In my experience, this makes Bazel a significantly harder build system to truly grok, tho perhaps easier to use it without understanding it.<p>Contrast with nix, where the entire build graph exists as a nix expression. In my experience, you can gain a surprisingly deep understanding of nix armed only with knowledge of nix-the-language (and without knowing any implementation details of nix-the-binary-that-builds-derivations).</div><br/></div></div></div></div><div id="40567202" class="c"><input type="checkbox" id="c-40567202" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40566812">parent</a><span>|</span><a href="#40567489">prev</a><span>|</span><a href="#40567763">next</a><span>|</span><label class="collapse" for="c-40567202">[-]</label><label class="expand" for="c-40567202">[4 more]</label></div><br/><div class="children"><div class="content">Agreed on all counts, especially the central issue with nix and the properties that I&#x27;d want out of a replacement. I think CUE ( <a href="https:&#x2F;&#x2F;cuelang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cuelang.org&#x2F;</a> ) is a perfect language for this.</div><br/><div id="40567558" class="c"><input type="checkbox" id="c-40567558" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40567202">parent</a><span>|</span><a href="#40567763">next</a><span>|</span><label class="collapse" for="c-40567558">[-]</label><label class="expand" for="c-40567558">[3 more]</label></div><br/><div class="children"><div class="content">Cue is fun, but already the unification example (<a href="https:&#x2F;&#x2F;cuelang.org&#x2F;docs&#x2F;tour&#x2F;basics&#x2F;duplicate-fields&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cuelang.org&#x2F;docs&#x2F;tour&#x2F;basics&#x2F;duplicate-fields&#x2F;</a>) shouts &quot;footguns&quot; to me :(<p>TS is certainly excessively powerful though.</div><br/><div id="40567855" class="c"><input type="checkbox" id="c-40567855" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40567558">parent</a><span>|</span><a href="#40567895">next</a><span>|</span><label class="collapse" for="c-40567855">[-]</label><label class="expand" for="c-40567855">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this would be a problem in practice. By default structs are &quot;open&quot; in cue, i.e. as long as matching fields unify, disparate fields just merge. There are also &quot;closed&quot; structs that allow creating a definition that fails to unify with fields not explicitly listed. <a href="https:&#x2F;&#x2F;cuelang.org&#x2F;docs&#x2F;tour&#x2F;types&#x2F;closed&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cuelang.org&#x2F;docs&#x2F;tour&#x2F;types&#x2F;closed&#x2F;</a></div><br/></div></div><div id="40567895" class="c"><input type="checkbox" id="c-40567895" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40567558">parent</a><span>|</span><a href="#40567855">prev</a><span>|</span><a href="#40567763">next</a><span>|</span><label class="collapse" for="c-40567895">[-]</label><label class="expand" for="c-40567895">[1 more]</label></div><br/><div class="children"><div class="content">What foot guns are you seeing specifically?</div><br/></div></div></div></div></div></div><div id="40567763" class="c"><input type="checkbox" id="c-40567763" checked=""/><div class="controls bullet"><span class="by">leoh</span><span>|</span><a href="#40566812">parent</a><span>|</span><a href="#40567202">prev</a><span>|</span><a href="#40567410">next</a><span>|</span><label class="collapse" for="c-40567763">[-]</label><label class="expand" for="c-40567763">[2 more]</label></div><br/><div class="children"><div class="content">flox is the best thing I know of for articulating binary dependencies (language runtimes, etc.), which is probably the sweet spot for nix anyways at the moment (i.e. as opposed to trying to build everything &quot;With the One [Tool] to [Replace] Them All&quot;). flox uses nix for its backend, but has a simple TOML syntax and is properly humble about what it can do -- but killer at it -- as opposed to promising the world.<p><a href="https:&#x2F;&#x2F;flox.dev" rel="nofollow">https:&#x2F;&#x2F;flox.dev</a></div><br/><div id="40568883" class="c"><input type="checkbox" id="c-40568883" checked=""/><div class="controls bullet"><span class="by">mmgutz</span><span>|</span><a href="#40566812">root</a><span>|</span><a href="#40567763">parent</a><span>|</span><a href="#40567410">next</a><span>|</span><label class="collapse" for="c-40568883">[-]</label><label class="expand" for="c-40568883">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also [devbox](<a href="https:&#x2F;&#x2F;github.com&#x2F;jetify-com&#x2F;devbox">https:&#x2F;&#x2F;github.com&#x2F;jetify-com&#x2F;devbox</a>).<p>Tried a lot of them, and after a while I found the nix the package manager on non NixOS requires too many workarounds. Things don&#x27;t just work. For example, installing alacritty requires an OpenGL wrapper. Neovim can&#x27;t find libraries to build some plugins. Basically, anything GUI had issues.<p>In the end, `cargo install`, `go install` and download a release archive from github are simpler to script for most of the tools I use.</div><br/></div></div></div></div></div></div><div id="40567410" class="c"><input type="checkbox" id="c-40567410" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#40566812">prev</a><span>|</span><a href="#40566958">next</a><span>|</span><label class="collapse" for="c-40567410">[-]</label><label class="expand" for="c-40567410">[6 more]</label></div><br/><div class="children"><div class="content">Some of the oddities of the nix language are pretty useful for its domain.  Recursive attribute sets, for instance, save a lot of headaches if you&#x27;re trying to have only a single source of truth.  Do you feel like these translate to typescript nicely?<p>As somebody who knows nix but doesn&#x27;t know typescript, I found myself looking for a rosetta stone page where I could look at two chunks of code that do the same thing, but in separate languages.  This would let me use the familiar language to scrutinize the other.<p>I wouldn&#x27;t normally ask for such a thing, but if you&#x27;re putting &quot;Nix-like&quot; in the title then maybe it might be worth adding a comparison page to the docs.</div><br/><div id="40569417" class="c"><input type="checkbox" id="c-40569417" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#40567410">parent</a><span>|</span><a href="#40568571">next</a><span>|</span><label class="collapse" for="c-40569417">[-]</label><label class="expand" for="c-40569417">[3 more]</label></div><br/><div class="children"><div class="content">I think the lack of true laziness will be a big performance problem for a large build graph.<p>On the other hand the monolithic nature of the nixpkgs package set is one of the authors gripes with nix, so performance at that scale may be a non-goal.</div><br/><div id="40569651" class="c"><input type="checkbox" id="c-40569651" checked=""/><div class="controls bullet"><span class="by">kylewlacy</span><span>|</span><a href="#40567410">root</a><span>|</span><a href="#40569417">parent</a><span>|</span><a href="#40568571">next</a><span>|</span><label class="collapse" for="c-40569651">[-]</label><label class="expand" for="c-40569651">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d definitely like to have good performance even for large build graphs! I&#x27;m hoping the laziness exists &quot;where it counts&quot;. To walk through an example, if you build your backend, and your backend calls the function `postgres()`, and that calls `openssl()`, and THAT calls `gcc()`, etc., etc., each function is basically building an object to represent its chunk of the build graph (each function returns a &quot;recipe&quot;). Nothing gets built until that object gets returned from the top-level function and the runtime does something with it<p>In other words, the eager part is basically constructing the build graph. Maybe I&#x27;m wrong but I don&#x27;t that this would necessarily be slower than the lazy version. In practice the most complex build graph I&#x27;ve made is basically the full chain of Linux From Scratch builds (that&#x27;s the basis for my toolchain currently), and I think that takes about 400-500ms to evaluate. It&#x27;s about 160 build steps, so it&#x27;s not _simple_ but I know build graphs can also get a lot more complex, so I&#x27;ll just have to keep an eye on performance as I start to get into more and more complex builds<p>Maybe I&#x27;m missing something but intuitively I&#x27;d expect this approach to be fairly efficient-- as long as build scripts only call these functions when they&#x27;re used as part of the build graph</div><br/><div id="40569703" class="c"><input type="checkbox" id="c-40569703" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#40567410">root</a><span>|</span><a href="#40569651">parent</a><span>|</span><a href="#40568571">next</a><span>|</span><label class="collapse" for="c-40569703">[-]</label><label class="expand" for="c-40569703">[1 more]</label></div><br/><div class="children"><div class="content">I think it really depends on your definition of &quot;large&quot;. I don&#x27;t think strict eval + full build graph can scale to something the size of nixpkgs, for example.<p>I mentioned in another comment that this is why Bazel uses simple strings to form dependencies on other targets. That way Bazel can manage the laziness and only evaluate what is needed without needing to use or invent a language with lazy evaluation.<p>But that is also the big downside (in my opinion) - the full build graph necessarily can&#x27;t exist purely in starlark (at least for Google-scale projects) which increases complexity of the tool overall.<p>Edit: I&#x27;d like to add, though, that I think it&#x27;s perfectly fine to not scale to Google scale or nixpkgs scale! Many many projects could still benefit from a great build tool.</div><br/></div></div></div></div></div></div><div id="40568571" class="c"><input type="checkbox" id="c-40568571" checked=""/><div class="controls bullet"><span class="by">kylewlacy</span><span>|</span><a href="#40567410">parent</a><span>|</span><a href="#40569417">prev</a><span>|</span><a href="#40567876">next</a><span>|</span><label class="collapse" for="c-40568571">[-]</label><label class="expand" for="c-40568571">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been asked about overrides and attributes a lot! That was one of the sacrifices I had to make to go with a more traditional language, so it&#x27;s definitely a negative point compared to Nix. That said, I&#x27;m hoping to have some conventions and features that will cover _most_ of the use-cases that overrides give you, but that&#x27;s definitely still future work at this point and I probably won&#x27;t be able to cover everything overrides do<p>And yep, I think having a &quot;Brioche for Nix users&quot; guide makes a lot of sense, although it&#x27;s not the first time that question so I&#x27;ll probably stand up a first-pass version of it sooner rather than later (my Nix skills are also pretty rusty-- I&#x27;ll need to brush up a bit first before I write it!)</div><br/></div></div><div id="40567876" class="c"><input type="checkbox" id="c-40567876" checked=""/><div class="controls bullet"><span class="by">charlotte-fyi</span><span>|</span><a href="#40567410">parent</a><span>|</span><a href="#40568571">prev</a><span>|</span><a href="#40566958">next</a><span>|</span><label class="collapse" for="c-40567876">[-]</label><label class="expand" for="c-40567876">[1 more]</label></div><br/><div class="children"><div class="content">The syntax isn’t as clean but you can add property accessors to objects in JavaScript that accomplishes the same thing.</div><br/></div></div></div></div><div id="40566958" class="c"><input type="checkbox" id="c-40566958" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#40567410">prev</a><span>|</span><a href="#40566585">next</a><span>|</span><label class="collapse" for="c-40566958">[-]</label><label class="expand" for="c-40566958">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also exploring a post-Nix package manager, wip: <a href="https:&#x2F;&#x2F;github.com&#x2F;porkg&#x2F;porkg">https:&#x2F;&#x2F;github.com&#x2F;porkg&#x2F;porkg</a><p>My mantra has been to avoid &quot;getting bored&quot; and inventing DSLs for the longest time. I initially sought to use Nickel-lang, but it was missing some features that would make it an ideal candidate for this. I started writing my own (you may find this in the history) before realizing &quot;WTF are you doing writing another shitty DSL?&quot; I have subsequently decided that shell scripts (or anything you can shebang) are good enough, i.e. pkgbuild inspiration.<p>I also plan to avoid making a derivation the source of reproducibility. Instead, a lockfile will offer that. This should alleviate the issue whereby updating the like of glibc cascades into an entire rebuild.<p>Any *OS and home-manager would need to bring in a configuration language. I think Cue really makes the most sense, but that&#x27;s still a long way off.<p>Nice to see you used JS instead of yet another DSL :)</div><br/><div id="40570758" class="c"><input type="checkbox" id="c-40570758" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#40566958">parent</a><span>|</span><a href="#40567712">next</a><span>|</span><label class="collapse" for="c-40570758">[-]</label><label class="expand" for="c-40570758">[1 more]</label></div><br/><div class="children"><div class="content"><i>I have subsequently decided that shell scripts (or anything you can shebang) are good enough, i.e. pkgbuild inspiration.</i><p>If you run out of steam with shell, keep Hay in mind -- which is part of Oils.<p>It upgrades shell with declarative data, like YAML but not YAML syntax :)<p><a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;release&#x2F;0.22.0&#x2F;doc&#x2F;hay.html" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;release&#x2F;0.22.0&#x2F;doc&#x2F;hay.html</a><p>Discussion - <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;phqsxk&#x2F;hay_ain_t_yaml_custom_languages_for_unix" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;phqsxk&#x2F;hay_ain_t_yaml_custom_languages_f...</a><p>It&#x27;s not set in stone yet -- I&#x27;m planning an overhaul based on some feedback, so I welcome any more (e.g. on Github or Zulip)</div><br/></div></div><div id="40567712" class="c"><input type="checkbox" id="c-40567712" checked=""/><div class="controls bullet"><span class="by">kylewlacy</span><span>|</span><a href="#40566958">parent</a><span>|</span><a href="#40570758">prev</a><span>|</span><a href="#40567187">next</a><span>|</span><label class="collapse" for="c-40567712">[-]</label><label class="expand" for="c-40567712">[1 more]</label></div><br/><div class="children"><div class="content">ooh, porkg looks pretty interesting, will definitely keep an eye on the project!<p>Definitely agreed about the lockfile ideas! I went with a fairly similar design, although I haven&#x27;t really escaped the &quot;rebuild the world&quot; situation yet and I&#x27;ve rebuilt a _lot_ of copies of gcc from source by now! (that&#x27;s also partially because I set up the packages repo as a workspace[1], which I felt was easier to iterate on in the early days... I might eventually split each package into their own projects or separate repos so they can keep lockfiles independent of each other)<p>and yeah, I definitely felt the temptation to write my own DSL but I stayed strong! I just knew that it&#x27;d be a huge uphill battle, especially because I wanted to provide good editor support (IMO implementing a language is (relatively) easy, but implementing a language with good error messages and LSP support is crazy hard)<p>[^1]: <a href="https:&#x2F;&#x2F;brioche.dev&#x2F;docs&#x2F;core-concepts&#x2F;workspaces&#x2F;" rel="nofollow">https:&#x2F;&#x2F;brioche.dev&#x2F;docs&#x2F;core-concepts&#x2F;workspaces&#x2F;</a></div><br/></div></div><div id="40567187" class="c"><input type="checkbox" id="c-40567187" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#40566958">parent</a><span>|</span><a href="#40567712">prev</a><span>|</span><a href="#40566585">next</a><span>|</span><label class="collapse" for="c-40567187">[-]</label><label class="expand" for="c-40567187">[2 more]</label></div><br/><div class="children"><div class="content">I suggest the post author and you look into nu as the package build language. It&#x27;s uniquely suited for this task, being a cross-platform shell[1] with real programming language features, data types, and using built-in uutils instead of relying on platform-dependent coreutils. It also limits mutability[2], favoring a more functional than imperative approach, which would at least theoretically help with reproducibility. A guy from Determinate Systems recently made an experiment on integrating nushell to nix and the results were positive. Take a look: <a href="https:&#x2F;&#x2F;determinate.systems&#x2F;posts&#x2F;nuenv&#x2F;" rel="nofollow">https:&#x2F;&#x2F;determinate.systems&#x2F;posts&#x2F;nuenv&#x2F;</a><p>1: <a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.nushell.sh&#x2F;</a><p>2: <a href="https:&#x2F;&#x2F;www.nushell.sh&#x2F;book&#x2F;thinking_in_nu.html#variables-are-immutable" rel="nofollow">https:&#x2F;&#x2F;www.nushell.sh&#x2F;book&#x2F;thinking_in_nu.html#variables-ar...</a></div><br/><div id="40568674" class="c"><input type="checkbox" id="c-40568674" checked=""/><div class="controls bullet"><span class="by">kylewlacy</span><span>|</span><a href="#40566958">root</a><span>|</span><a href="#40567187">parent</a><span>|</span><a href="#40566585">next</a><span>|</span><label class="collapse" for="c-40568674">[-]</label><label class="expand" for="c-40568674">[1 more]</label></div><br/><div class="children"><div class="content">Nushell has definitely been on my radar for a while! but I missed DetSys was playing around with it, I&#x27;ll have to give that a look<p>One neat thing about Brioche is that Bash isn&#x27;t really baked into it the same way as the Nix ecosystem. In a lot of the docs and examples, I used the `std.runBash` Brioche function for running scripts, but that&#x27;s a fairly simple 11-line function[^1]. I wanted to make it just as easy to add `runZsh`, `runFish`, `runNushell`, etc. functions that work just as well as Bash (and they could either be put in the std library or in their own packages). So hopefully, there will be a Brioche `runNushell` function in the near future :)<p>[^1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;brioche-dev&#x2F;brioche-packages&#x2F;blob&#x2F;9fd51090a56cf83f4aa9c5002b78f2b2054ad3ad&#x2F;packages&#x2F;std&#x2F;extra&#x2F;run_bash.bri#L37-L47">https:&#x2F;&#x2F;github.com&#x2F;brioche-dev&#x2F;brioche-packages&#x2F;blob&#x2F;9fd5109...</a></div><br/></div></div></div></div></div></div><div id="40566585" class="c"><input type="checkbox" id="c-40566585" checked=""/><div class="controls bullet"><span class="by">Aerbil313</span><span>|</span><a href="#40566958">prev</a><span>|</span><a href="#40567498">next</a><span>|</span><label class="collapse" for="c-40566585">[-]</label><label class="expand" for="c-40566585">[2 more]</label></div><br/><div class="children"><div class="content">Beat me to it! It&#x27;s my dream to write a Nix replacement in a more approachable language. I can&#x27;t state enough how the choice of a bespoke DSL <i>that doesn&#x27;t immediately make sense to most developers</i> keeps Nix&#x2F;Nixos community from growing. And Nix is 18 years old now, it&#x27;s long overdue for a rewrite[1]. Don&#x27;t implement channels to start with. Focus on full reproducibility. (...getting into sci-fi territory...) Build in QEMU and KVM virtualization to be able to build and <i>run</i> most pieces of software ever published. No, Docker is a horribly leaky abstraction. Run a torrent network by default as cache.nixos.org equivalent, because you can&#x27;t keep up with the demand with centralized solutions, even nixpkgs gave up on it despite their free credits on AWS.<p>1: I believe all software without exception needs a full rewrite <i>at least</i> every 10 years.</div><br/><div id="40566970" class="c"><input type="checkbox" id="c-40566970" checked=""/><div class="controls bullet"><span class="by">tombert</span><span>|</span><a href="#40566585">parent</a><span>|</span><a href="#40567498">next</a><span>|</span><label class="collapse" for="c-40566970">[-]</label><label class="expand" for="c-40566970">[1 more]</label></div><br/><div class="children"><div class="content">I think Flakes kind of help with the centralized problems.  At least individual flakes can be run or installed separately, they don&#x27;t have to be merged into the core nixpkgs repo, and they (at least in theory) should be giving the same build reproducibility as you&#x27;d get from installing directly from nixpkgs.<p>I agree with the torrent idea though.</div><br/></div></div></div></div><div id="40567498" class="c"><input type="checkbox" id="c-40567498" checked=""/><div class="controls bullet"><span class="by">leoh</span><span>|</span><a href="#40566585">prev</a><span>|</span><a href="#40569770">next</a><span>|</span><label class="collapse" for="c-40567498">[-]</label><label class="expand" for="c-40567498">[1 more]</label></div><br/><div class="children"><div class="content">I am not writing typescript -- heaven forbid -- so I can manage cargo, so I can write Rust.<p>Dropping the snark, though -- most times I have seen folks attempt to fold other build systems into some polyglot common one, it seems to create a lot of problems -- for at the end of the day, build tools (whether npm, cargo, gradle, docker, etc.) each have their issues. When these issues arise, they require understanding the original build tool. Bazel, for example, is a &quot;polyglot&quot; system which many try to use to manage npm. In my experience, when folks use bazel but have never used npm directly, they often get lost, because they now have to deal with two abstractions (bazel, npm) simultaneously neither have a way for bazel to do the thing they need, nor an understanding of how to get bazel to do that thing (nor npm itself to do the thing), also because they have never worked with npm directly.<p>Same goes for cargo, incidentally. Switching over to that build tool -- like any major build tool, it has an insane amount of well-honed documentation and thousands of answered questions online (not to mention LLMs trained somewhat well on it). Users when they need to do something with brioche or have an issue with it will not necessarily have the benefit of the massive collaborative support available for cargo.<p>Incidentally, I don&#x27;t think that nix is free of this problem, though it does attempt to manage these issues -- sometimes reasonably successfully -- by virtue of keeping interfaces to other build tools in simple, direct ways.<p>Even then, however, the best way I have seen nix used is as a system for declaring all binary dependencies or other dependencies that are either not manageable or especially competently managed by other build tools -- which nix allows for in a virtual environment by shipping a shell.nix or flake.<p>In other words -- bringing in the right version of java, gradle, node, etc. But then just directing users to the specific, native build tools that often have a massive number of contributors.<p>The closest thing to a tool that does this (guides developers to other build tools) is flox, which uses TOML, but uses nix for its backend via C API. I haven&#x27;t had a chance to use it much yet, but it looks very promising <a href="https:&#x2F;&#x2F;flox.dev" rel="nofollow">https:&#x2F;&#x2F;flox.dev</a>.<p>===<p>Okay, all this rambling aside -- building a tool like this for yourself or a small team, especially when you have the time to do it, it works well, and you&#x27;re having fun... well, there&#x27;s an insane amount to be said for that; and it will doubtlessly lead you to learning a ton about other build tools and likely offer you deep insights that are only possible when attempting to build something like brioche. So, on that count, major kudos to you.</div><br/></div></div><div id="40569770" class="c"><input type="checkbox" id="c-40569770" checked=""/><div class="controls bullet"><span class="by">zarathustreal</span><span>|</span><a href="#40567498">prev</a><span>|</span><label class="collapse" for="c-40569770">[-]</label><label class="expand" for="c-40569770">[1 more]</label></div><br/><div class="children"><div class="content">I’ve generally found the most interesting things are the ones that don’t feel intuitive at first. Familiarity bias can really hold you back. The language semantics of Nix are basically Haskell’s which.. is probably the One True Way to write correct code if we’re honest with ourselves.</div><br/></div></div></div></div></div></div></div></body></html>