<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722934862187" as="style"/><link rel="stylesheet" href="styles.css?v=1722934862187"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.codethink.co.uk/articles/2024/secure_bootloader/">A cryptographically secure bootloader for RISC-V in Rust</a>Â <span class="domain">(<a href="https://www.codethink.co.uk">www.codethink.co.uk</a>)</span></div><div class="subtext"><span>fork-bomber</span> | <span>72 comments</span></div><br/><div><div id="41163365" class="c"><input type="checkbox" id="c-41163365" checked=""/><div class="controls bullet"><span class="by">Vogtinator</span><span>|</span><a href="#41164439">next</a><span>|</span><label class="collapse" for="c-41163365">[-]</label><label class="expand" for="c-41163365">[8 more]</label></div><br/><div class="children"><div class="content">Measured boot &gt; trust chain through signature verification:<p>With measured boot, components in the boot chain tell some trusted component (e.g. a TPM, possibly in FW) about all of their input and only if the hashes at the end match, $something is accessible (in most cases a secret key for data decryption).<p>1. More flexibility (with TPM e.g. you can &quot;seal&quot; a secret against different parts independently)<p>2. No need for PKI, which gets very complex once revocations are involved (have fun looking at the &quot;Secure Boot&quot; DBX lists and the shim SBAT mechanism)<p>3. More freedom: The system still boots if the measurements don&#x27;t match, you just don&#x27;t get access to secrets. You&#x27;re free to seal your own secrets against your new measurements and whoever did the last sealing has no access anymore. (Unlike on PCs where the Microsoft trust is in most cases not removable).</div><br/><div id="41163580" class="c"><input type="checkbox" id="c-41163580" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41163365">parent</a><span>|</span><a href="#41163937">next</a><span>|</span><label class="collapse" for="c-41163580">[-]</label><label class="expand" for="c-41163580">[3 more]</label></div><br/><div class="children"><div class="content">1. This is interesting. So in a measured boot scenario, you wouldn&#x27;t be able to boot the main OS, but it would give you access to sort of a minimal initramfs environment for debugging? It&#x27;s a good idea for personal computers, like a tamper-proofing approach.<p>I assume the TPM in this case would only have a partial decryption key? I think something similar could be accomplished with SSS, no?<p>2. As for this, I can say i&#x27;ve never used DBX with UEFI Secure boot. Instead of revoking keys, I just remake the entire PKI from the top. The PKI is only there to support independent use by OS Vendor&#x2F;OEM hence the separation of PK&#x2F;KEK&#x2F;db.<p>3. Counterpoint: over-reliance on TPMs and such. Whereas the ordinary trust chain only requires signature verification at the start of boot (presumably on-chip), measured boot requires more complex trusted computing hardware (presumably off-chip).<p>Personally, I find that systems that are overly-reliant on complex trusted computing hardware tend to lack in other areas. For example, iphones or google-pixel devices encourage the user to use a low-entropy password like a 4-digit PIN. These systems try often to reconcile &quot;analog&quot; passkeys like Biometrics (FaceID, fingerprints) by using trusted computing. Of course, if the trusted computing systems are breached (<a href="https:&#x2F;&#x2F;www.404media.co&#x2F;leaked-docs-show-what-phones-cellebrite-can-and-cant-unlock&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.404media.co&#x2F;leaked-docs-show-what-phones-cellebr...</a>), then security is very weak.<p>I suppose the advantage of the measured-boot method is that it is optional. So you can still boot whatever OS you want, just without some TC features.</div><br/><div id="41166002" class="c"><input type="checkbox" id="c-41166002" checked=""/><div class="controls bullet"><span class="by">thewanderer1983</span><span>|</span><a href="#41163365">root</a><span>|</span><a href="#41163580">parent</a><span>|</span><a href="#41164138">next</a><span>|</span><label class="collapse" for="c-41166002">[-]</label><label class="expand" for="c-41166002">[1 more]</label></div><br/><div class="children"><div class="content">&gt;1. This is interesting. So in a measured boot scenario, you wouldn&#x27;t be able to boot the main OS, but it would give you access to sort of a minimal initramfs environment for debugging? It&#x27;s a good idea for personal computers, like a tamper-proofing approach.<p>If you would like to play around with measured boot and similar functionality of TCG DICE. Thats on a USB stick that open, and have a good team behind it.<p><a href="https:&#x2F;&#x2F;tillitis.se&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tillitis.se&#x2F;</a></div><br/></div></div><div id="41164138" class="c"><input type="checkbox" id="c-41164138" checked=""/><div class="controls bullet"><span class="by">Vogtinator</span><span>|</span><a href="#41163365">root</a><span>|</span><a href="#41163580">parent</a><span>|</span><a href="#41166002">prev</a><span>|</span><a href="#41163937">next</a><span>|</span><label class="collapse" for="c-41164138">[-]</label><label class="expand" for="c-41164138">[1 more]</label></div><br/><div class="children"><div class="content">&gt; 1. This is interesting. So in a measured boot scenario, you wouldn&#x27;t be able to boot the main OS, but it would give you access to sort of a minimal initramfs environment for debugging? It&#x27;s a good idea for personal computers, like a tamper-proofing approach.<p>Depends on how it&#x27;s set up. Currently most setups that use measured boot (systemd-pcrlock, partially BitLocker) ask for a recovery key if unsealing fails due to measurement mismatches and offer other options.<p>&gt; I assume the TPM in this case would only have a partial decryption key?<p>That&#x27;s also possible, but so far I haven&#x27;t seen that. The sealed secret is sent to the TPM which then uses its hidden internal seed to derive the master key for volume decryption and sends it back. (In the case of bitlocker with TPM &lt; 2 that could trivially be sniffed on the LPC bus...)<p>&gt; I think something similar could be accomplished with SSS, no?<p>If you mean Shamir&#x27;s secret sharing, possibly. Question is what to do with the shares.<p>2. Yeah, for your local machine this is a working approach, if you make sure that really only your own key works. Another reason against PKI is also that the trusted authority can&#x27;t retroactively sign a backdoored executable to gain access to devices, as the measurements are independent from authority and ideally device specific.<p>3. Signature verification isn&#x27;t just needed at the start of boot, it&#x27;s ideally from start of booting until user authentication, which is the part that can be tampered with. I&#x27;d argue that the software side for measured boot is simpler, while the hardware side may be more complex.<p>&gt; For example, iphones or google-pixel devices encourage the user to use a low-entropy password like a 4-digit PIN.<p>Using TPM+PIN is actually not that bad: Only if measurements match it&#x27;s possible to unlock with a PIN and the TPM uses a counter in nonvolatile memory to prevent brute force attacks. It&#x27;s not unfathomable that some manufacturer screws that up, but it&#x27;s IMO stronger than relying on multiple parties (CPU, BIOS, OEMs, OS) developing an actually secure trust chain.</div><br/></div></div></div></div><div id="41163937" class="c"><input type="checkbox" id="c-41163937" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#41163365">parent</a><span>|</span><a href="#41163580">prev</a><span>|</span><a href="#41164716">next</a><span>|</span><label class="collapse" for="c-41163937">[-]</label><label class="expand" for="c-41163937">[3 more]</label></div><br/><div class="children"><div class="content">That said, it does require more care when you do OS updates or UEFI updates to remember to update the TPM sealed secret with the new measurements. Windows and Linux both have the former automated so it should generally be fine.<p>UEFI updates can also be a problem if they wipe the TPM as part of the update and thus destroy the sealed secret entirely (as my PC mobo does).</div><br/><div id="41164187" class="c"><input type="checkbox" id="c-41164187" checked=""/><div class="controls bullet"><span class="by">Vogtinator</span><span>|</span><a href="#41163365">root</a><span>|</span><a href="#41163937">parent</a><span>|</span><a href="#41164716">next</a><span>|</span><label class="collapse" for="c-41164187">[-]</label><label class="expand" for="c-41164187">[2 more]</label></div><br/><div class="children"><div class="content">&gt; That said, it does require more care when you do OS updates or UEFI updates to remember to update the TPM sealed secret with the new measurements. Windows and Linux both have the former automated so it should generally be fine.<p>Yep, this can be a pain also in regards to firmware bugs (broken TCG event log anyone?). In the worst case you need to enter the recovery key or if you know in advance, exclude some component from measurement temporarily while supervising the next boot. If something goes wrong with the trust chain like a key got revoked but the bootloader didn&#x27;t update correctly, you end up with an unbootable device and can&#x27;t even go back easily.<p>&gt; UEFI updates can also be a problem if they wipe the TPM as part of the update and thus destroy the sealed secret entirely (as my PC mobo does).<p>Ouch, that&#x27;s bad design. The firmware is measured into the TPM on boot so there&#x27;s no reason to do that..</div><br/><div id="41165928" class="c"><input type="checkbox" id="c-41165928" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#41163365">root</a><span>|</span><a href="#41164187">parent</a><span>|</span><a href="#41164716">next</a><span>|</span><label class="collapse" for="c-41165928">[-]</label><label class="expand" for="c-41165928">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, every time I update the UEFI it pops up a warning that the TPM will be cleared and I better have disabled Windows Bootlocker before I did this. The warning also goes away within a fraction of a second because the PC reboots which is not nearly enough time to read it, and I only know what it says because I&#x27;ve updated the UEFI enough times to be able to piece it together. Weird.<p>It might just be a warning to cover their asses; ie it doesn&#x27;t actually clear the TPM but they don&#x27;t want to be responsible for your un-unlockable drive in case it does. I don&#x27;t actually use the TPM for measured boot or anything else so I haven&#x27;t checked.<p>In any case, UEFI updates are relatively common right now (once every couple of months or so) because it&#x27;s a relatively new mobo (AM5), and because AMD is about to release new CPUs that requires corresponding AGESA etc updates. It&#x27;ll probably become less frequent in a few years.</div><br/></div></div></div></div></div></div><div id="41164716" class="c"><input type="checkbox" id="c-41164716" checked=""/><div class="controls bullet"><span class="by">evanjrowley</span><span>|</span><a href="#41163365">parent</a><span>|</span><a href="#41163937">prev</a><span>|</span><a href="#41164439">next</a><span>|</span><label class="collapse" for="c-41164716">[-]</label><label class="expand" for="c-41164716">[1 more]</label></div><br/><div class="children"><div class="content">It appears Apple Silicon uses a combination of measured boot and trusted boot concepts: <a href="https:&#x2F;&#x2F;support.apple.com&#x2F;guide&#x2F;security&#x2F;boot-process-secac71d5623&#x2F;web" rel="nofollow">https:&#x2F;&#x2F;support.apple.com&#x2F;guide&#x2F;security&#x2F;boot-process-secac7...</a></div><br/></div></div></div></div><div id="41164439" class="c"><input type="checkbox" id="c-41164439" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#41163365">prev</a><span>|</span><a href="#41163323">next</a><span>|</span><label class="collapse" for="c-41164439">[-]</label><label class="expand" for="c-41164439">[1 more]</label></div><br/><div class="children"><div class="content">tbh I feel bad for the kid, his thesis supervisor should have helped him more here to scope and direct the work in some sensible way. now it is bit of a mess :(<p>like just doing a review and comparison of existing boot verification mechanisms would have been already good scope for a thesis. Instead they are barely even mentioned as a side-note, which puts this in a awkward position.<p>or if crypto was focus, then putting more work on designing and implementing the crypto scheme would have been relevant. Now they got so tangled with the nitty gritty boot details that the crypto ended up also as questionable side-note.<p>or if rust was focus, then just implementing clean pure-rust bootloader could have been already enough for the thesis, avoiding the stumbling over on misguided crypto bits.<p>or many other ways this could have been more successful. overall it now feels the author ended up biting far more than what they can chew. also they should have imho spent less time coding and more time on editing the actual thesis. the text is all over the place.</div><br/></div></div><div id="41163323" class="c"><input type="checkbox" id="c-41163323" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41164439">prev</a><span>|</span><a href="#41163173">next</a><span>|</span><label class="collapse" for="c-41163323">[-]</label><label class="expand" for="c-41163323">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get the &quot;1&#x2F;10 size of U-Boot&quot; argument. As it can only boot 3 RISC-V64 boards via TFTP, it also has less than 1&#x2F;10 of the features and supported hardware of U-Boot. <a href="https:&#x2F;&#x2F;github.com&#x2F;u-boot&#x2F;u-boot">https:&#x2F;&#x2F;github.com&#x2F;u-boot&#x2F;u-boot</a></div><br/><div id="41163883" class="c"><input type="checkbox" id="c-41163883" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#41163323">parent</a><span>|</span><a href="#41163819">next</a><span>|</span><label class="collapse" for="c-41163883">[-]</label><label class="expand" for="c-41163883">[1 more]</label></div><br/><div class="children"><div class="content">Supported hardware doesn&#x27;t matter because they&#x27;re comparing the compiled binary size, not source code size. The u-boot binary you&#x27;d compile would also only have the stuff relevant to that particular hardware compiled-in.<p>If you don&#x27;t need the other features of u-boot that this doesn&#x27;t have, it makes sense to count the lower binary size and runtime memory usage as an advantage.<p>That said, they compared it to &quot;an example U-boot binary&quot;, which sounds like they probably didn&#x27;t tweak the bajillion config options u-boot has to produce one with an equivalent feature set to theirs, which would&#x27;ve been a fairer comparison for sure.</div><br/></div></div></div></div><div id="41163173" class="c"><input type="checkbox" id="c-41163173" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#41163323">prev</a><span>|</span><a href="#41163866">next</a><span>|</span><label class="collapse" for="c-41163173">[-]</label><label class="expand" for="c-41163173">[5 more]</label></div><br/><div class="children"><div class="content">The problem with Rust in the boot process is that it&#x27;s going to become much harder to find vulnerabilities for roots&#x2F;jailbreaks. Still, this is great work!</div><br/><div id="41163667" class="c"><input type="checkbox" id="c-41163667" checked=""/><div class="controls bullet"><span class="by">quohort</span><span>|</span><a href="#41163173">parent</a><span>|</span><a href="#41163287">next</a><span>|</span><label class="collapse" for="c-41163667">[-]</label><label class="expand" for="c-41163667">[1 more]</label></div><br/><div class="children"><div class="content">Yes, ironically increased transparency and more secure systems will lead to less freedom for the user, because trusted computing is most often securing the interests of manufacturers against users (what RMS refereed to as &quot;Treacherous Computing&quot;)<p>I think that we have been able to thwart &quot;treachery&quot; in the meantime by exploiting side-channels in trusted computing implementations. Ultimately it may be necessary to amend the constitution to prevent manufacturers from distributing locked-down hardware for the good of free society (competition, democracy, etc.) at large. Otherwise, computer giants will have ultimate control over the distribution of information (given that the economics of manufacturing are driven by economies of scale).</div><br/></div></div><div id="41163287" class="c"><input type="checkbox" id="c-41163287" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#41163173">parent</a><span>|</span><a href="#41163667">prev</a><span>|</span><a href="#41164493">next</a><span>|</span><label class="collapse" for="c-41163287">[-]</label><label class="expand" for="c-41163287">[2 more]</label></div><br/><div class="children"><div class="content">Could you elaborate on this?  I&#x27;m not sure what you mean; are you saying that there will still be vulnerabilities that are of similar difficulty to exploit as would be found in a C bootloader, but will be harder to find by security researchers?  Or are you just saying that there will be fewer vulnerabilities, but the ones that do exist will be more &quot;obscure&quot; than would be the case if it were written in C, because Rust eliminates some of the more &quot;obvious&quot; vectors?<p>Either way, do you consider this a bad thing?</div><br/><div id="41163361" class="c"><input type="checkbox" id="c-41163361" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41163173">root</a><span>|</span><a href="#41163287">parent</a><span>|</span><a href="#41164493">next</a><span>|</span><label class="collapse" for="c-41163361">[-]</label><label class="expand" for="c-41163361">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s neither of those. The trade-off is that features like this are often used against users, preventing them from actually controlling their own machines. Under those circumstances, bugs in the &quot;security&quot; of the machine are a mixed bag: malware can exploit them to break out, but users can exploit them to get full control over the machine that they own. This has happened with Android phones, for instance, allowing people to root phones and&#x2F;or replace the ROM with a community version that gets security patches not available in the stock ROM, which is probably a net security improvement even with the bootloader left vulnerable.<p>So it&#x27;s really hard to call it a good thing or a bad thing; it&#x27;s a trade.</div><br/></div></div></div></div></div></div><div id="41163866" class="c"><input type="checkbox" id="c-41163866" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#41163173">prev</a><span>|</span><a href="#41162647">next</a><span>|</span><label class="collapse" for="c-41163866">[-]</label><label class="expand" for="c-41163866">[2 more]</label></div><br/><div class="children"><div class="content">That is I&#x27;ve impressive final year project, nice work!<p>Vector crypto is very cutting edge too. I guess there isn&#x27;t any hardware that has it yet...</div><br/><div id="41164248" class="c"><input type="checkbox" id="c-41164248" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41163866">parent</a><span>|</span><a href="#41162647">next</a><span>|</span><label class="collapse" for="c-41164248">[-]</label><label class="expand" for="c-41164248">[1 more]</label></div><br/><div class="children"><div class="content">SiFive&#x27;s P670 Cores do: <a href="https:&#x2F;&#x2F;www.sifive.com&#x2F;cores&#x2F;performance-p650-670" rel="nofollow">https:&#x2F;&#x2F;www.sifive.com&#x2F;cores&#x2F;performance-p650-670</a>
If and when they are available, I don&#x27;t know, Sophgo licensed them: <a href="https:&#x2F;&#x2F;www.cnx-software.com&#x2F;2023&#x2F;10&#x2F;21&#x2F;sophgo-sg2380-16-core-sifive-p670-risc-v-processor-20-tops-ai-accelerator&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cnx-software.com&#x2F;2023&#x2F;10&#x2F;21&#x2F;sophgo-sg2380-16-cor...</a> preorder is here: <a href="https:&#x2F;&#x2F;arace.tech&#x2F;products&#x2F;pre-order-milk-v-oasis-16-core-risc-v-desktop-coupon" rel="nofollow">https:&#x2F;&#x2F;arace.tech&#x2F;products&#x2F;pre-order-milk-v-oasis-16-core-r...</a></div><br/></div></div></div></div><div id="41162647" class="c"><input type="checkbox" id="c-41162647" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41163866">prev</a><span>|</span><a href="#41162299">next</a><span>|</span><label class="collapse" for="c-41162647">[-]</label><label class="expand" for="c-41162647">[2 more]</label></div><br/><div class="children"><div class="content">This is a very specific type of bootloader for devices that get their code over the internet:<p>&gt; SentinelBoot&#x27;s threat model focuses on thin client devices which do not store their own OS and over-the-air updates (e.g. how phones are updated): both of these cases involve executable code being sent over a network, usually the internet. We ignore the risk of direct hardware modification, as an attacker can just swap out the bootloader (making any potential defence implemented by SentinelBoot in vain).<p>The author readily acknowledges that it does not defend against hardware modification. The other comments here trying to vilify this project don&#x27;t understand what it is supposed to do.</div><br/></div></div><div id="41162299" class="c"><input type="checkbox" id="c-41162299" checked=""/><div class="controls bullet"><span class="by">greenavocado</span><span>|</span><a href="#41162647">prev</a><span>|</span><a href="#41161956">next</a><span>|</span><label class="collapse" for="c-41162299">[-]</label><label class="expand" for="c-41162299">[21 more]</label></div><br/><div class="children"><div class="content">Congratulations on the development. Part of me is concerned that this will be used to push devices that cannot be unlocked and tinkered with by end users, reducing their technological freedom.</div><br/><div id="41162659" class="c"><input type="checkbox" id="c-41162659" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41162299">parent</a><span>|</span><a href="#41162804">next</a><span>|</span><label class="collapse" for="c-41162659">[-]</label><label class="expand" for="c-41162659">[1 more]</label></div><br/><div class="children"><div class="content">The purpose of this bootloader is to avoid executing malicious code sent over the internet, such as by a MITM attack.<p>The author explains that it does not attempt to defend against hardware attacks or attempts to replace the bootloader:<p>&gt; SentinelBoot&#x27;s threat model focuses on thin client devices which do not store their own OS and over-the-air updates (e.g. how phones are updated): both of these cases involve executable code being sent over a network, usually the internet. We ignore the risk of direct hardware modification, as an attacker can just swap out the bootloader (making any potential defence implemented by SentinelBoot in vain).</div><br/></div></div><div id="41162804" class="c"><input type="checkbox" id="c-41162804" checked=""/><div class="controls bullet"><span class="by">almatabata</span><span>|</span><a href="#41162299">parent</a><span>|</span><a href="#41162659">prev</a><span>|</span><a href="#41163186">next</a><span>|</span><label class="collapse" for="c-41162804">[-]</label><label class="expand" for="c-41162804">[1 more]</label></div><br/><div class="children"><div class="content">That shift has already started in various areas.<p>You see it with phones but also with cars where OEMs require Secure Boot enabled devices when possible. This ranges from the central unit to all small ECUs.<p>You can kind of see it pushed for desktops as the default mode but at least there for now you usually have a way to disable it.<p>For embedded devices though they never really provide a way to disable it. I think you could find a compromise where you could provide a physical method to disable it. If you disable it you clear all the DRM keys and other secrets. This way you can still protect against malicious updates for most users and tinkerers can do what they want once the company stops supporting it.</div><br/></div></div><div id="41163186" class="c"><input type="checkbox" id="c-41163186" checked=""/><div class="controls bullet"><span class="by">talldayo</span><span>|</span><a href="#41162299">parent</a><span>|</span><a href="#41162804">prev</a><span>|</span><a href="#41162640">next</a><span>|</span><label class="collapse" for="c-41163186">[-]</label><label class="expand" for="c-41163186">[3 more]</label></div><br/><div class="children"><div class="content">This was going to happen regardless. I believe Nvidia&#x27;s RISC-V coprocessor ships with hardware fuses that serve more-or-less the same purpose.<p>If anything, it just makes me glad that RISC-V also has specs for UEFI-like interfaces.</div><br/><div id="41163247" class="c"><input type="checkbox" id="c-41163247" checked=""/><div class="controls bullet"><span class="by">bri3d</span><span>|</span><a href="#41162299">root</a><span>|</span><a href="#41163186">parent</a><span>|</span><a href="#41162640">next</a><span>|</span><label class="collapse" for="c-41163247">[-]</label><label class="expand" for="c-41163247">[2 more]</label></div><br/><div class="children"><div class="content">Many (most) devices with secure boot have hardware fuses, but the software that reads them is usually broken. Rust and an eye towards sound cryptographic primitives (especially against side channels) will definitely go a distance towards protecting against this, although logic bugs are also quite common.<p>This bootloader doesnât actually seem to be a real secure &#x2F; trusted boot implementation anyway, just a thing that verifies updates.</div><br/><div id="41163511" class="c"><input type="checkbox" id="c-41163511" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#41162299">root</a><span>|</span><a href="#41163247">parent</a><span>|</span><a href="#41162640">next</a><span>|</span><label class="collapse" for="c-41163511">[-]</label><label class="expand" for="c-41163511">[1 more]</label></div><br/><div class="children"><div class="content">What is the story with rust and cryptographic side channels?  I imagine the layers of abstraction (e.g. an iterator may have arbitrary O) would make it harder to see those?</div><br/></div></div></div></div></div></div><div id="41162640" class="c"><input type="checkbox" id="c-41162640" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#41162299">parent</a><span>|</span><a href="#41163186">prev</a><span>|</span><a href="#41162580">next</a><span>|</span><label class="collapse" for="c-41162640">[-]</label><label class="expand" for="c-41162640">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sure that&#x27;s part of the story, but there&#x27;s tons of boring old company&#x2F;government equipment out there in the world that wants secure boot too.</div><br/></div></div><div id="41162580" class="c"><input type="checkbox" id="c-41162580" checked=""/><div class="controls bullet"><span class="by">RsmFz</span><span>|</span><a href="#41162299">parent</a><span>|</span><a href="#41162640">prev</a><span>|</span><a href="#41163546">next</a><span>|</span><label class="collapse" for="c-41162580">[-]</label><label class="expand" for="c-41162580">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;ll happen with permissive licenses</div><br/></div></div><div id="41162408" class="c"><input type="checkbox" id="c-41162408" checked=""/><div class="controls bullet"><span class="by">mouse_</span><span>|</span><a href="#41162299">parent</a><span>|</span><a href="#41162534">prev</a><span>|</span><a href="#41161956">next</a><span>|</span><label class="collapse" for="c-41162408">[-]</label><label class="expand" for="c-41162408">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what it&#x27;s for, make no mistake.<p>Those who sacrifice liberty for safety will receive and deserve neither.</div><br/><div id="41162559" class="c"><input type="checkbox" id="c-41162559" checked=""/><div class="controls bullet"><span class="by">gjsman-1000</span><span>|</span><a href="#41162299">root</a><span>|</span><a href="#41162408">parent</a><span>|</span><a href="#41161956">next</a><span>|</span><label class="collapse" for="c-41162559">[-]</label><label class="expand" for="c-41162559">[3 more]</label></div><br/><div class="children"><div class="content">Reminder that quote is so out of context that the actual meaning, as it was intended, is wildly different.<p><a href="https:&#x2F;&#x2F;techcrunch.com&#x2F;2014&#x2F;02&#x2F;14&#x2F;how-the-world-butchered-benjamin-franklins-quote-on-liberty-vs-security&#x2F;" rel="nofollow">https:&#x2F;&#x2F;techcrunch.com&#x2F;2014&#x2F;02&#x2F;14&#x2F;how-the-world-butchered-be...</a><p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5268899">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5268899</a><p><a href="https:&#x2F;&#x2F;www.npr.org&#x2F;2015&#x2F;03&#x2F;02&#x2F;390245038&#x2F;ben-franklins-famous-liberty-safety-quote-lost-its-context-in-21st-century" rel="nofollow">https:&#x2F;&#x2F;www.npr.org&#x2F;2015&#x2F;03&#x2F;02&#x2F;390245038&#x2F;ben-franklins-famou...</a></div><br/><div id="41162699" class="c"><input type="checkbox" id="c-41162699" checked=""/><div class="controls bullet"><span class="by">mouse_</span><span>|</span><a href="#41162299">root</a><span>|</span><a href="#41162559">parent</a><span>|</span><a href="#41163808">next</a><span>|</span><label class="collapse" for="c-41162699">[-]</label><label class="expand" for="c-41162699">[1 more]</label></div><br/><div class="children"><div class="content">I am sorry if I have caused any misunderstanding; the point I was trying to make is that, as ownership is a nebulous concept, yet one that must be protected, one with physical access to a device ought to be able to do whatever they want to it. To imply that bootloader locking is not primarily used to restrict what the owner of a device is able to do with it is disingenuous at best. I fundamentally disagree with the concept of bootloader locks in general under the idea that the evil that corporations are able to enact with them has historically far outweighed the real life security concerns that they actually protect users against. I understand this may be a controversial viewpoint but personally I feel (opinion) that the erosion of ownership is one of the most important issues we face today.</div><br/></div></div></div></div></div></div></div></div><div id="41162541" class="c"><input type="checkbox" id="c-41162541" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#41161956">prev</a><span>|</span><label class="collapse" for="c-41162541">[-]</label><label class="expand" for="c-41162541">[18 more]</label></div><br/><div class="children"><div class="content">&quot;cryptographically secure bootloader&quot; is a meaningless phrase.<p>They mean a boot loader that validates cryptographic public key signatures of the loaded component. That would be a secure cryptographic bootloader. AFTER they have proven that it is, in fact, secure.<p>You can&#x27;t just write some code and then say it must be secure because Rust was involved.</div><br/><div id="41162698" class="c"><input type="checkbox" id="c-41162698" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41162541">parent</a><span>|</span><a href="#41162597">next</a><span>|</span><label class="collapse" for="c-41162698">[-]</label><label class="expand" for="c-41162698">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t just write some code and then say it must be secure because Rust was involved.<p>The article doesn&#x27;t claim that at all.<p>The cryptographically secure part comes from doing cryptographic verification of the code before running it.<p>The article talks about using Rust to improve memory safety.</div><br/></div></div><div id="41162597" class="c"><input type="checkbox" id="c-41162597" checked=""/><div class="controls bullet"><span class="by">RsmFz</span><span>|</span><a href="#41162541">parent</a><span>|</span><a href="#41162698">prev</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41162597">[-]</label><label class="expand" for="c-41162597">[13 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t just write some code and then say it must be secure because Rust was involved<p>Did they say that?</div><br/><div id="41162653" class="c"><input type="checkbox" id="c-41162653" checked=""/><div class="controls bullet"><span class="by">fefe23</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41162597">parent</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41162653">[-]</label><label class="expand" for="c-41162653">[12 more]</label></div><br/><div class="children"><div class="content">Yes. They call it &quot;secure&quot; and have zero arguments to back up that claim except Rust&#x27;s memory safety guarantees.<p>Which, by the way, do not apply, since the SHA256-Code is marked unsafe.</div><br/><div id="41162925" class="c"><input type="checkbox" id="c-41162925" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41162653">parent</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41162925">[-]</label><label class="expand" for="c-41162925">[11 more]</label></div><br/><div class="children"><div class="content">Unsafe blocks do <i>not</i> imply equivalence with C. They imply that <i>if</i> there are memory safety issues, the issue originates in one of the unsafe blocks. Usually there are few enough lines of code in unsafe blocks doing small enough tasks that you can feasibly to rule out issues by thinking hard enough.<p>Contrast that with C, where every line may be a source of safety issues. It&#x27;s a meaningful difference.</div><br/><div id="41166660" class="c"><input type="checkbox" id="c-41166660" checked=""/><div class="controls bullet"><span class="by">bangaladore</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41162925">parent</a><span>|</span><a href="#41163344">next</a><span>|</span><label class="collapse" for="c-41166660">[-]</label><label class="expand" for="c-41166660">[2 more]</label></div><br/><div class="children"><div class="content">The original commenter is correct, though.<p>Any &quot;unsafe&quot; block within a rust source code potentially corrupts the entire application as undefined behavior has no bound and will&#x2F;may leak right out of the unsafe block.<p>You are arguing something else. Enumerating all unsafe code is a good feature, but when one of the fundamental building blocks of your security is marked unsafe, it raises questions about its overall benefit.</div><br/><div id="41167565" class="c"><input type="checkbox" id="c-41167565" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41166660">parent</a><span>|</span><a href="#41163344">next</a><span>|</span><label class="collapse" for="c-41167565">[-]</label><label class="expand" for="c-41167565">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not addressing that because I don&#x27;t think it&#x27;s an interesting discussion. There&#x27;s excellent tooling for validating crypto code.<p>I&#x27;m emphasizing the difference between rust and C here because unlike Martin, I don&#x27;t agree that it&#x27;s meaningfully possible to eliminate UB in C by careful analysis. You&#x27;re able to do this in Rust in large part <i>because</i> those issues are all concentrated in a few tightly scoped blocks with clear responsibilities.<p>Unsafe also gives you a massive hint where to look when you&#x27;re debugging.</div><br/></div></div></div></div><div id="41163344" class="c"><input type="checkbox" id="c-41163344" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41162925">parent</a><span>|</span><a href="#41166660">prev</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41163344">[-]</label><label class="expand" for="c-41163344">[8 more]</label></div><br/><div class="children"><div class="content">Well, not every construct in C can have safety issue. Saying that every line in C may be the source of memory safety issues is as accurate as saying that every line of Rust may be a source of memory safety issues, because it could make use of unsafe.<p>There is another issue: Unsafe code in Rust could violate assumptions that could cause other code in Rust to be unsafe. So it needs more care to write than regular C.<p>But I agree that it still a huge net benefit with respect to memory safety, but let&#x27;s not exaggerate.</div><br/><div id="41163421" class="c"><input type="checkbox" id="c-41163421" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41163344">parent</a><span>|</span><a href="#41164141">next</a><span>|</span><label class="collapse" for="c-41163421">[-]</label><label class="expand" for="c-41163421">[1 more]</label></div><br/><div class="children"><div class="content">Those unsafe lines in C could be anywhere in your program. In Rust they cannot exist outside of unsafe blocks. This is not a trivial distinction! For all intents and purposes, each and every line of C must be treated as potentially unsafe.</div><br/></div></div><div id="41164141" class="c"><input type="checkbox" id="c-41164141" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41163344">parent</a><span>|</span><a href="#41163421">prev</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41164141">[-]</label><label class="expand" for="c-41164141">[6 more]</label></div><br/><div class="children"><div class="content">The really big difference is the searchability and frequency of possibly unsafe operations. If you want to audit all possible unsafe lines of code in a Rust project, you can grep for &quot;unsafe&quot; and find all of them (and in most projects there will be very few if any). In C, on the other hand, you need to look at literally every indexing operation, every pointer dereference, every use of a variable (to make sure it isn&#x27;t potentially used after free or before initialization), every cast, and probably some extras that I&#x27;ve forgotten. As such, rather than having a low double digit number of cases to look at, you have to look at the vast majority of lines of code.</div><br/><div id="41164767" class="c"><input type="checkbox" id="c-41164767" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41164141">parent</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41164767">[-]</label><label class="expand" for="c-41164767">[5 more]</label></div><br/><div class="children"><div class="content">While true, my point is that you can write C in a way that many functions are also obviously free of UB, and you only need to carefully vet the pointer arithmetic in some low-level functions.<p>So I agree with the point in principle, I just do not like the &quot;spin&quot; of &quot;every line of C is time bomb nobody can understand&quot; while in Rust you just have to look at some lines of &quot;unsafe&quot; and all is good.</div><br/><div id="41165279" class="c"><input type="checkbox" id="c-41165279" checked=""/><div class="controls bullet"><span class="by">AlotOfReading</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41164767">parent</a><span>|</span><a href="#41166047">next</a><span>|</span><label class="collapse" for="c-41165279">[-]</label><label class="expand" for="c-41165279">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not my experience that C can be obviously free of UB and I&#x27;m curious to know how you approach that. I&#x27;m not aware of any methods or tools that claim to achieve it and there&#x27;s a long history of &quot;correct&quot; programs written by experts were discovered to contain subtle UB with improvements in automated analysis. Here&#x27;s one example, from Runtime Verification: 
<a href="https:&#x2F;&#x2F;runtimeverification.com&#x2F;blog&#x2F;mare-than-14-of-sv-comps-correct-programs-are-undefined" rel="nofollow">https:&#x2F;&#x2F;runtimeverification.com&#x2F;blog&#x2F;mare-than-14-of-sv-comp...</a></div><br/><div id="41168660" class="c"><input type="checkbox" id="c-41168660" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41165279">parent</a><span>|</span><a href="#41166047">next</a><span>|</span><label class="collapse" for="c-41168660">[-]</label><label class="expand" for="c-41168660">[1 more]</label></div><br/><div class="children"><div class="content">For example, the following function has obviously no UB:<p>unsigned int mul(unsigned int x, unsigned int y)
{
  return x * y;
}<p>Or there are many high level function structures as, which also has no UB (with some assumption on the called functions):<p>void bar()
{
  struct foo *p = foo_alloc();
  foo_do1(p);
  foo_do2(p);
  foo_delete(p);
}<p>Such code can be easily screened and also this can be done automatically. There is a lack of open-source which can do this, but I have an experimental GCC branch which starts to do this and looks promising.</div><br/></div></div></div></div><div id="41166047" class="c"><input type="checkbox" id="c-41166047" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41164767">parent</a><span>|</span><a href="#41165279">prev</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41166047">[-]</label><label class="expand" for="c-41166047">[2 more]</label></div><br/><div class="children"><div class="content">The key point is that no matter how you write your C code, for anyone else that wants to verify a lack of memory safety problems, they need to read every single line to determine which ones do the low level unsafe bits.</div><br/><div id="41168688" class="c"><input type="checkbox" id="c-41168688" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41162541">root</a><span>|</span><a href="#41166047">parent</a><span>|</span><a href="#41162651">next</a><span>|</span><label class="collapse" for="c-41168688">[-]</label><label class="expand" for="c-41168688">[1 more]</label></div><br/><div class="children"><div class="content">I understand this, but the importance of this is highly exaggerated.  How in the world does it make sense to only audit for memory safety?  There plenty of other safety and security issues.  Only if you pretend that memory safety is all that matters, you can then claim a fundamental example that you only need to look at &quot;unsafe blocks&quot; and nothing else.  Now, you can say that with limited time we can at least more easily ensure memory safety by reviewing &quot;unsafe blocks&quot; carefully and neglecting other problems. And this is true and I agree that this is an advantage, but the overall improvement for safety and security is incremental in reducing risk and not fundamental.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41162651" class="c"><input type="checkbox" id="c-41162651" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#41162541">parent</a><span>|</span><a href="#41162597">prev</a><span>|</span><a href="#41162562">next</a><span>|</span><label class="collapse" for="c-41162651">[-]</label><label class="expand" for="c-41162651">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can&#x27;t just write some code and then say it must be secure because Rust was involved.<p>I have a feeling that the qualifier is there in the headline to distinguish from the potential security improvements that come from replacing a C bootloader implementation with a feature -parity Rust one.</div><br/></div></div><div id="41162562" class="c"><input type="checkbox" id="c-41162562" checked=""/><div class="controls bullet"><span class="by">creshal</span><span>|</span><a href="#41162541">parent</a><span>|</span><a href="#41162651">prev</a><span>|</span><a href="#41163003">next</a><span>|</span><label class="collapse" for="c-41162562">[-]</label><label class="expand" for="c-41162562">[1 more]</label></div><br/><div class="children"><div class="content">How does it know what keys to trust? TPM?</div><br/></div></div></div></div></div></div></div></div></div></body></html>