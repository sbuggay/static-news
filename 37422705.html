<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694250058644" as="style"/><link rel="stylesheet" href="styles.css?v=1694250058644"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://railsatscale.com/2023-08-29-ruby-outperforms-c/">JIT-optimized Ruby can outperform a C extension</a> <span class="domain">(<a href="https://railsatscale.com">railsatscale.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>59 comments</span></div><br/><div><div id="37443186" class="c"><input type="checkbox" id="c-37443186" checked=""/><div class="controls bullet"><span class="by">rolae</span><span>|</span><a href="#37443213">next</a><span>|</span><label class="collapse" for="c-37443186">[-]</label><label class="expand" for="c-37443186">[2 more]</label></div><br/><div class="children"><div class="content">People say the title is misleading, which is true, this is about Ruby code optimized by JIT outperforming a extension written in C.<p>But to give some context: the author Aaron Patterson is a Ruby and a Rails core team member. The article and headline is clearly targeting the ruby community, where this article has been very well received. I think it&#x27;s a good title for the intended audience.<p>The post clarifies in the first section:<p>&gt; In this post I’d like to present one data point in favor of maintaining a pure Ruby codebase, and then discuss some challenges and downsides of writing native extensions. Finally we’ll look at YJIT optimizations and why they don’t work as well with native code in the mix.</div><br/><div id="37443283" class="c"><input type="checkbox" id="c-37443283" checked=""/><div class="controls bullet"><span class="by">wonnage</span><span>|</span><a href="#37443186">parent</a><span>|</span><a href="#37443213">next</a><span>|</span><label class="collapse" for="c-37443283">[-]</label><label class="expand" for="c-37443283">[1 more]</label></div><br/><div class="children"><div class="content">This is specifically about breaking the myth that performing expensive self-contained operations (e.g, parsing GraphQL) in a native extension (C, Rust, etc.) is always faster than the interpreted language.<p>The JS ecosystem has the same problem, people think rewriting everything in Rust will be a magic fix. In practice, there&#x27;s always the problem highlighted in the post (transitioning is expensive, causes optimization bailouts), as well as the cost of actually getting the results back into Node-land. This is why SWC abandoned the JS API for writing plugins - constantly bouncing back and forth while traversing AST nodes was even slower than Babel (e.g <a href="https:&#x2F;&#x2F;github.com&#x2F;swc-project&#x2F;swc&#x2F;issues&#x2F;1392#issuecomment-877628316">https:&#x2F;&#x2F;github.com&#x2F;swc-project&#x2F;swc&#x2F;issues&#x2F;1392#issuecomment-...</a>)</div><br/></div></div></div></div><div id="37443213" class="c"><input type="checkbox" id="c-37443213" checked=""/><div class="controls bullet"><span class="by">chucke</span><span>|</span><a href="#37443186">prev</a><span>|</span><a href="#37443238">next</a><span>|</span><label class="collapse" for="c-37443213">[-]</label><label class="expand" for="c-37443213">[1 more]</label></div><br/><div class="children"><div class="content">This article outlines well the paradox that JITs require to be truly more efficient: if more of the target language is available to optimize, it&#x27;ll get waaay more optimized, compared to dropping down to the layer below and try to hand-stitch it.<p>Of course, there is massive overhead in doing so. Just look at go, which had to rewrite practically everything already available in go, and must always require a native implementation (protobuf for example shares the underlying interface across ruby, python, php... but then has a full separate implementation in go, and java I think). And they have the budget for it at least, Google won&#x27;t let go die under the overhead it created for itself.<p>So definitely, write more ruby, enough of those &quot;fast-C gem - rewritten as C extension&quot;, but still keep using low level libraries like libpq.</div><br/></div></div><div id="37443238" class="c"><input type="checkbox" id="c-37443238" checked=""/><div class="controls bullet"><span class="by">iamgopal</span><span>|</span><a href="#37443213">prev</a><span>|</span><a href="#37442752">next</a><span>|</span><label class="collapse" for="c-37443238">[-]</label><label class="expand" for="c-37443238">[1 more]</label></div><br/><div class="children"><div class="content">can numba and typed python will have similar effect ?</div><br/></div></div><div id="37442752" class="c"><input type="checkbox" id="c-37442752" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#37443238">prev</a><span>|</span><a href="#37442782">next</a><span>|</span><label class="collapse" for="c-37442752">[-]</label><label class="expand" for="c-37442752">[1 more]</label></div><br/><div class="children"><div class="content">Ruby outperforms C <i>that is a Ruby extension, solving a problem by wrangling with Ruby types</i>.<p>When you write a run-time for a dynamic, high level language, and then library functions in C which use the API&#x27;s and objects of that run time, the resulting code is reasonably fast, but never as fast as solving the problem using direct C idioms.<p>There are ways to make improvements in that type of code, but they tend to be tedious to code. For instance, you can use split the code into cases by type, and then use faster, more type-specific routines.<p>Sometimes it&#x27;s possible to get all the inputs out of the objects, work with lower, less encapsulated level C representations to do the bulk of the problem, and then put results back into the run time&#x27;s objects again. Or do that partially at certain steps.<p>In the TXR Lisp mapcar implementation, alloca is used to create a native C array of stack-allocated iterator objects. (For the parallel iteration over multiple sequences: mapcar is an N-ary function!). The element values are pulled from all these iterators and stuffed into a stack allocated args structure destructively; that same structure is re-used for each call to the projection function.<p>That&#x27;s not as fast as it could be. Beyond that it would be possible to separately handle the case when there is only one sequence argument, and to split that by type, and other such approaches.<p>It&#x27;s faster, though, than if it allocated a dynamic vector of dynamic iterators, and&#x2F;or if it built a dynamic list of arguments in each iteration which were applied to the function as a list.</div><br/></div></div><div id="37442782" class="c"><input type="checkbox" id="c-37442782" checked=""/><div class="controls bullet"><span class="by">VeejayRampay</span><span>|</span><a href="#37442752">prev</a><span>|</span><a href="#37442699">next</a><span>|</span><label class="collapse" for="c-37442782">[-]</label><label class="expand" for="c-37442782">[12 more]</label></div><br/><div class="children"><div class="content">Hacker News is going to nitpick at the bold claim of the title instead of focusing on the fact that it&#x27;s a well written technical article that underlines some neat tricks that allow a rather slow, highly dynamic language such as ruby to provide great performance under some circumstances, which is all that engineers should care about</div><br/><div id="37442836" class="c"><input type="checkbox" id="c-37442836" checked=""/><div class="controls bullet"><span class="by">starbugs</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37442806">next</a><span>|</span><label class="collapse" for="c-37442836">[-]</label><label class="expand" for="c-37442836">[1 more]</label></div><br/><div class="children"><div class="content">Critizising the title is not exactly nitpicking. The title is important. And it’s misleading.<p>I disagree that this article is well written. It is hard to identify what is compared exactly, at least as someone not deeply familiar with the ruby ecosystem. The article doesn’t do a great job of explaining the caveats and limitations of the comparison either.</div><br/></div></div><div id="37442806" class="c"><input type="checkbox" id="c-37442806" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37442836">prev</a><span>|</span><a href="#37443061">next</a><span>|</span><label class="collapse" for="c-37442806">[-]</label><label class="expand" for="c-37442806">[1 more]</label></div><br/><div class="children"><div class="content">The fastest parser in the post works at 35MB&#x2F;s which is ~100x slower than necessary, improved from a baseline of ~1000x slower than necessary.</div><br/></div></div><div id="37443061" class="c"><input type="checkbox" id="c-37443061" checked=""/><div class="controls bullet"><span class="by">dig1</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37442806">prev</a><span>|</span><a href="#37443135">next</a><span>|</span><label class="collapse" for="c-37443061">[-]</label><label class="expand" for="c-37443061">[2 more]</label></div><br/><div class="children"><div class="content">The title is misleading, just like other commenters mentioned. Just check how much indirection &quot;rb_iv_get()&quot; has to make (at the end, it will call [1], which isn&#x27;t &quot;a light&quot; call). Now, check generated JIT code (in a blog post) for the same action where JIT knows how to shave off unnecessary indirection.<p>We are comparing apples and oranges here.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;blob&#x2F;b635a66e957e4dd3fed83ef1d72ce8c9b57e0430&#x2F;variable.c#L1218">https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;ruby&#x2F;blob&#x2F;b635a66e957e4dd3fed83ef1d7...</a></div><br/><div id="37443108" class="c"><input type="checkbox" id="c-37443108" checked=""/><div class="controls bullet"><span class="by">vidarh</span><span>|</span><a href="#37442782">root</a><span>|</span><a href="#37443061">parent</a><span>|</span><a href="#37443135">next</a><span>|</span><label class="collapse" for="c-37443108">[-]</label><label class="expand" for="c-37443108">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it may well be misleading, yet you&#x27;re making the point of the commenter you replied to <i>while pointing out</i> why the article is interesting. If you&#x27;re a position where you&#x27;re using Ruby and considering whether writing a C extension will speed things up, it has valuable advice on what other things to also try. That is a lot more interesting to me than the title.</div><br/></div></div></div></div><div id="37443135" class="c"><input type="checkbox" id="c-37443135" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37443061">prev</a><span>|</span><a href="#37442959">next</a><span>|</span><label class="collapse" for="c-37443135">[-]</label><label class="expand" for="c-37443135">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hacker News is going to nitpick at the bold claim of the title instead of focusing on the fact that it&#x27;s a well written technical article t<p>I think that&#x27;s an unfair characterisation of HN readers.<p>They aren&#x27;t criticising the article after all, they&#x27;re criticising a clickbait and misleading title.</div><br/></div></div><div id="37442959" class="c"><input type="checkbox" id="c-37442959" checked=""/><div class="controls bullet"><span class="by">wodenokoto</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37443135">prev</a><span>|</span><a href="#37442862">next</a><span>|</span><label class="collapse" for="c-37442959">[-]</label><label class="expand" for="c-37442959">[1 more]</label></div><br/><div class="children"><div class="content">If we are keeping the nitpickings to this thread, I think adding a “when” to the beginning would keep it just as interesting a title and be good enough in terms of correctness</div><br/></div></div><div id="37442862" class="c"><input type="checkbox" id="c-37442862" checked=""/><div class="controls bullet"><span class="by">thepostman0</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37442959">prev</a><span>|</span><a href="#37443076">next</a><span>|</span><label class="collapse" for="c-37442862">[-]</label><label class="expand" for="c-37442862">[1 more]</label></div><br/><div class="children"><div class="content">Clickbait titles gets criticism because some people won&#x27;t read beyond the title</div><br/></div></div><div id="37443076" class="c"><input type="checkbox" id="c-37443076" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37442862">prev</a><span>|</span><a href="#37442838">next</a><span>|</span><label class="collapse" for="c-37443076">[-]</label><label class="expand" for="c-37443076">[1 more]</label></div><br/><div class="children"><div class="content">Talking about technically well written:<p>When showing microbenchmarks - show the exact hardware used, make sure the CPU does run at fixed frequency (no boost, most laptops can&#x27;t control the freq. esp Macs)</div><br/></div></div><div id="37442838" class="c"><input type="checkbox" id="c-37442838" checked=""/><div class="controls bullet"><span class="by">bakugo</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37443076">prev</a><span>|</span><a href="#37442889">next</a><span>|</span><label class="collapse" for="c-37442838">[-]</label><label class="expand" for="c-37442838">[1 more]</label></div><br/><div class="children"><div class="content">If the writer of the article wanted people to actually read the article and judge it by its overall quality, they wouldn&#x27;t have used such a blatantly clickbait-y title.</div><br/></div></div><div id="37442889" class="c"><input type="checkbox" id="c-37442889" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37442782">parent</a><span>|</span><a href="#37442838">prev</a><span>|</span><a href="#37443071">next</a><span>|</span><label class="collapse" for="c-37442889">[-]</label><label class="expand" for="c-37442889">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Hacker News is going to nitpick at the bold claim of the title instead of focusing on the fact that (...)<p>...that the claims are somewhere between false and cherry-picked?</div><br/></div></div></div></div><div id="37442699" class="c"><input type="checkbox" id="c-37442699" checked=""/><div class="controls bullet"><span class="by">starbugs</span><span>|</span><a href="#37442782">prev</a><span>|</span><a href="#37442697">next</a><span>|</span><label class="collapse" for="c-37442699">[-]</label><label class="expand" for="c-37442699">[3 more]</label></div><br/><div class="children"><div class="content">I think this is a somewhat misleading title.<p>It does not outperform C.<p>This article appears to compare a suboptimal native C implementation to a JIT optimized version of some similar Ruby code. The JIT only outperforms that particular hand written C implementation in this case.<p>Still, great that the Riby JIT can do this now, but the title would be better phrased as ‘Ruby JIT in some cases outperforms suboptimal hand written C code‘. That wouldn’t be good clickbait though.</div><br/><div id="37442833" class="c"><input type="checkbox" id="c-37442833" checked=""/><div class="controls bullet"><span class="by">fasterik</span><span>|</span><a href="#37442699">parent</a><span>|</span><a href="#37442763">next</a><span>|</span><label class="collapse" for="c-37442833">[-]</label><label class="expand" for="c-37442833">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it appears that in the original benchmark an off the shelf C parser outperformed an off the shelf Ruby parser. Then they wrote their own parser in Ruby, which was faster. But for a fair comparison, you should also write the same parser in C and compare it to that.<p>It&#x27;s possible that writing it in Ruby is preferable if it avoids FFI overhead and can do more aggressive inlining. But this doesn&#x27;t seem like an apples to apples comparison.</div><br/></div></div></div></div><div id="37442697" class="c"><input type="checkbox" id="c-37442697" checked=""/><div class="controls bullet"><span class="by">andrewstuart</span><span>|</span><a href="#37442699">prev</a><span>|</span><a href="#37442684">next</a><span>|</span><label class="collapse" for="c-37442697">[-]</label><label class="expand" for="c-37442697">[25 more]</label></div><br/><div class="children"><div class="content">&quot;X outperforms C&#x2F;C++&#x2F;Rust&#x2F;Golang&quot;.<p>Only if the code design in C&#x2F;C++&#x2F;Rust&#x2F;Golang is bad.</div><br/><div id="37442783" class="c"><input type="checkbox" id="c-37442783" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37442697">parent</a><span>|</span><a href="#37442776">next</a><span>|</span><label class="collapse" for="c-37442783">[-]</label><label class="expand" for="c-37442783">[8 more]</label></div><br/><div class="children"><div class="content">Golang&#x27;s compiler is not great. The main way to achieve acceptable performance in golang is to use their weird asm dialect.</div><br/><div id="37443152" class="c"><input type="checkbox" id="c-37443152" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442783">parent</a><span>|</span><a href="#37442921">next</a><span>|</span><label class="collapse" for="c-37443152">[-]</label><label class="expand" for="c-37443152">[1 more]</label></div><br/><div class="children"><div class="content">As well as differences in code gen, as I understand it Go also has worse tail latencies than servers written in C&#x2F;C++&#x2F;Rust because of the GC.</div><br/></div></div><div id="37442921" class="c"><input type="checkbox" id="c-37442921" checked=""/><div class="controls bullet"><span class="by">umvi</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442783">parent</a><span>|</span><a href="#37443152">prev</a><span>|</span><a href="#37442926">next</a><span>|</span><label class="collapse" for="c-37442921">[-]</label><label class="expand" for="c-37442921">[3 more]</label></div><br/><div class="children"><div class="content">Golang&#x27;s compiler is so fast though that I can iterate much faster so I&#x27;m willing to accept slightly worse performance than C++. C++ I waste so much time just waiting (esp. if I&#x27;m using a lot of templatized header only libraries)</div><br/><div id="37442953" class="c"><input type="checkbox" id="c-37442953" checked=""/><div class="controls bullet"><span class="by">john_the_writer</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442921">parent</a><span>|</span><a href="#37442926">next</a><span>|</span><label class="collapse" for="c-37442953">[-]</label><label class="expand" for="c-37442953">[2 more]</label></div><br/><div class="children"><div class="content">But by that logic ruby is faster still since the compile time is 0. Less than zero really because it can be modified in flight.</div><br/><div id="37443053" class="c"><input type="checkbox" id="c-37443053" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442953">parent</a><span>|</span><a href="#37442926">next</a><span>|</span><label class="collapse" for="c-37443053">[-]</label><label class="expand" for="c-37443053">[1 more]</label></div><br/><div class="children"><div class="content">The trade offs between the two are huge.<p>Go programs compile in less than a second, or several seconds for huge projects, where idiomatic Go gets you within the same order of magnitude to that of C(++), with some memory overhead. Concurrency is first class, GC pauses exist but are seldom an issue.<p>Idiomatic Ruby runs several orders of magnitude slower, with a huge memory overhead, and is rife with runtime gymnastics. Concurrency is an expensive hack, with stop-the-world GC.</div><br/></div></div></div></div></div></div><div id="37442926" class="c"><input type="checkbox" id="c-37442926" checked=""/><div class="controls bullet"><span class="by">Kiuhrly1</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442783">parent</a><span>|</span><a href="#37442921">prev</a><span>|</span><a href="#37442979">next</a><span>|</span><label class="collapse" for="c-37442926">[-]</label><label class="expand" for="c-37442926">[2 more]</label></div><br/><div class="children"><div class="content">Somehow I can&#x27;t find a source for this but it&#x27;s well known that Go prefers compilation speed over runtime performance. Doesn&#x27;t help that they implement the entire compiler stack themselves so it definitely misses optimisations that other compilers can already do.<p>Also, I&#x27;ve never heard of anyone using assembly for performance optimisations. It would never happen where Go in commonly used (server programming), maybe if you&#x27;re doing graphics or something nonstandard?</div><br/><div id="37443002" class="c"><input type="checkbox" id="c-37443002" checked=""/><div class="controls bullet"><span class="by">john_the_writer</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442926">parent</a><span>|</span><a href="#37442979">next</a><span>|</span><label class="collapse" for="c-37443002">[-]</label><label class="expand" for="c-37443002">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done it for a c++ parser.  I grabbed the compiled c++ and disassembled it into assembly, then reworked it.  Got a massive increase in speed when I tweeked the registry use.</div><br/></div></div></div></div><div id="37442979" class="c"><input type="checkbox" id="c-37442979" checked=""/><div class="controls bullet"><span class="by">anta40</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442783">parent</a><span>|</span><a href="#37442926">prev</a><span>|</span><a href="#37442776">next</a><span>|</span><label class="collapse" for="c-37442979">[-]</label><label class="expand" for="c-37442979">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps gcc-go is better?</div><br/></div></div></div></div><div id="37442776" class="c"><input type="checkbox" id="c-37442776" checked=""/><div class="controls bullet"><span class="by">nvy</span><span>|</span><a href="#37442697">parent</a><span>|</span><a href="#37442783">prev</a><span>|</span><a href="#37443073">next</a><span>|</span><label class="collapse" for="c-37442776">[-]</label><label class="expand" for="c-37442776">[11 more]</label></div><br/><div class="children"><div class="content">For the time being. But C on x86 hasn&#x27;t been a good model of what the CPU is <i>actually doing</i> for a while now and eventually we&#x27;ll have a better way to harness the computing power available to us.</div><br/><div id="37442858" class="c"><input type="checkbox" id="c-37442858" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442776">parent</a><span>|</span><a href="#37443138">next</a><span>|</span><label class="collapse" for="c-37442858">[-]</label><label class="expand" for="c-37442858">[7 more]</label></div><br/><div class="children"><div class="content">I want to be optimistic and agree that ‘we’ll have a better way to harness the computing power available to us’, but at this point it’s been years or maybe decades of propping up the x86 ISA while actual operation of the computing device drifts further away. I certainly understand the desires of processor manufacturers to want to be able to maintain an ISA and then be able to implement a machine that can change underneath it to realize performance gains. However, this has left the status quo utterly entrenched and I can not see what would make them change this behavior.<p>I really would get onboard with an alternative ISA that was more in line with actual architectural features of modern processors and I often wonder why we could not have an extra compilation (jit or aot) step from x86 to some other format. But the trend seems to be going the opposite direction for all the large scale processor manufacturer&#x2F;designers toward a more abstracted interface at the lowest level.<p>I’ve seen various comments that basically boil down to “you can’t change the ISA because then C&#x2F;C++&#x2F;Rust programs would loose performance in benchmarks in the short term”, and this resistance only reinforces maintaining current trends. So… what are you assuming happens that prompts the shift toward a better way to harness computing power?</div><br/><div id="37442869" class="c"><input type="checkbox" id="c-37442869" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442858">parent</a><span>|</span><a href="#37442893">next</a><span>|</span><label class="collapse" for="c-37442869">[-]</label><label class="expand" for="c-37442869">[3 more]</label></div><br/><div class="children"><div class="content">What architectural features would you like to surface that are currently papered over in x86?</div><br/><div id="37443017" class="c"><input type="checkbox" id="c-37443017" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442869">parent</a><span>|</span><a href="#37442893">next</a><span>|</span><label class="collapse" for="c-37443017">[-]</label><label class="expand" for="c-37443017">[2 more]</label></div><br/><div class="children"><div class="content">My particular interests would see me appreciating access to cache structure, cache behavior, prefetching, cache coherency, memory management unit control, instruction pipelining, and maybe register renaming control.<p>I am not particularly qualified to try and design a better ISA, I just know there are some things I would like the option to control at some times (or at least I imagine I would). A lot of the list above is about exposing more of the architecture to user control as a general principle. However, I’d rather see some areas of hardware design change to facilitate something other than coding paradigms and practices that stretch back nearly 40 years. Chisnall’s ‘C is not a Low Level Language’ article discusses several architectural directions I would like to see happen, but also talks about how as long as the ISA remains the same moving to new programming styles&#x2F;philosophies continues to be a difficult proposition.</div><br/><div id="37443233" class="c"><input type="checkbox" id="c-37443233" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37443017">parent</a><span>|</span><a href="#37442893">next</a><span>|</span><label class="collapse" for="c-37443233">[-]</label><label class="expand" for="c-37443233">[1 more]</label></div><br/><div class="children"><div class="content">I see. These things sound swell, though for stuff like controlling register renaming it sounds hard for the instruction decode overhead to be worth it. Currently you can use prefetch intrinsics for prefetching and the level of cache management available is mostly non-temporal stores and explicit allocation of L3 space to specific cores (which ends up meaning specific processes if you are careful).<p>The world has mostly not adopted existing tools for writing 10-100x faster software (simd, huge pages, computing both branches then using a blend or cmov when this is sufficiently cheap, software prefetching, collection APIs that support bulk updates so that they can use all of these things instead of adding totally unnecessary dependency chains to the resulting program, etc.) so i&#x27;m not optimistic about things getting better if CPUs grow a thousand times more memory bandwidth and cores and begin to support very wide scatter&#x2F;gather like GPUs.</div><br/></div></div></div></div></div></div><div id="37442893" class="c"><input type="checkbox" id="c-37442893" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442858">parent</a><span>|</span><a href="#37442869">prev</a><span>|</span><a href="#37443138">next</a><span>|</span><label class="collapse" for="c-37442893">[-]</label><label class="expand" for="c-37442893">[3 more]</label></div><br/><div class="children"><div class="content">ARM seems like it&#x27;s destined to only grow in importance.</div><br/><div id="37442948" class="c"><input type="checkbox" id="c-37442948" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442893">parent</a><span>|</span><a href="#37443138">next</a><span>|</span><label class="collapse" for="c-37442948">[-]</label><label class="expand" for="c-37442948">[2 more]</label></div><br/><div class="children"><div class="content">I don’t know for certain, or in any great specificity, but in this context (i.e. ISA representing a more accurate or concrete mapping to hardware functionality&#x2F;capabilities) I don’t know that ARM is particularly different to x86. The both present a relatively single core, flat memory architecture to programmers; while the actual processor is absolutely not that.</div><br/><div id="37443166" class="c"><input type="checkbox" id="c-37443166" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442948">parent</a><span>|</span><a href="#37443138">next</a><span>|</span><label class="collapse" for="c-37443166">[-]</label><label class="expand" for="c-37443166">[1 more]</label></div><br/><div class="children"><div class="content">The memory model is a bit different on arm64, but it is not Alpha.<p>Other than that they are very similar</div><br/></div></div></div></div></div></div></div></div><div id="37443138" class="c"><input type="checkbox" id="c-37443138" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442776">parent</a><span>|</span><a href="#37442858">prev</a><span>|</span><a href="#37442789">next</a><span>|</span><label class="collapse" for="c-37443138">[-]</label><label class="expand" for="c-37443138">[1 more]</label></div><br/><div class="children"><div class="content">C is a pretty good model in part because all ISAs were designed with C in mind.</div><br/></div></div><div id="37442789" class="c"><input type="checkbox" id="c-37442789" checked=""/><div class="controls bullet"><span class="by">starbugs</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442776">parent</a><span>|</span><a href="#37443138">prev</a><span>|</span><a href="#37442863">next</a><span>|</span><label class="collapse" for="c-37442789">[-]</label><label class="expand" for="c-37442789">[1 more]</label></div><br/><div class="children"><div class="content">C was never intended to be a model of what the CPU is actually doing.<p>This is purely an optimization issue and the article compares apples to oranges for clicks.</div><br/></div></div><div id="37442863" class="c"><input type="checkbox" id="c-37442863" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442776">parent</a><span>|</span><a href="#37442789">prev</a><span>|</span><a href="#37443073">next</a><span>|</span><label class="collapse" for="c-37442863">[-]</label><label class="expand" for="c-37442863">[1 more]</label></div><br/><div class="children"><div class="content">immintrin.h seems tough to beat.</div><br/></div></div></div></div><div id="37442880" class="c"><input type="checkbox" id="c-37442880" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37442697">parent</a><span>|</span><a href="#37443073">prev</a><span>|</span><a href="#37442684">next</a><span>|</span><label class="collapse" for="c-37442880">[-]</label><label class="expand" for="c-37442880">[4 more]</label></div><br/><div class="children"><div class="content">(Edit: my mistake, I misread the comment I was replying to assuming it claimed these languages themselves were equivalent.)<p>Why would the performance of these languages be identical? These languages aren’t the same in lots of ways.<p>Golang has a GC and gives you much less control over memory layout than any of the other languages you mentioned. It also has a very different concurrency model, which will vastly change the performance characteristics of multithreaded code.<p>Rust is limited to llvm, while C can be compiled with many other compilers - some of which produce better code in many cases. (Eg icc)<p>Rust has much better noalias analysis - which allows the compiler to make optimizations that aren’t available in general purpose C or C++ code. (Since nobody adds noalias to all their variables in C, for a variety of reasons).<p>Unlike the others, C doesn’t support monomorphization (without disgusting macro tricks). Monomorphization cuts both ways with performance - since it bloats executables (and thus hurts the branch predictor and cache) while generating more efficient code.<p>These languages aren’t the same. There’s lots of reasons they will perform differently both at the limits of what we can optimize and in the average case of everyday code. It’s wild that you would consider them to all be the same.</div><br/><div id="37442903" class="c"><input type="checkbox" id="c-37442903" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442880">parent</a><span>|</span><a href="#37442684">next</a><span>|</span><label class="collapse" for="c-37442903">[-]</label><label class="expand" for="c-37442903">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is limited to llvm, while C can be compiled with many other compilers - some of which produce better code in many cases. (Eg icc)<p>There&#x27;s a rust front-end for gcc as well.</div><br/><div id="37443136" class="c"><input type="checkbox" id="c-37443136" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37442903">parent</a><span>|</span><a href="#37442684">next</a><span>|</span><label class="collapse" for="c-37443136">[-]</label><label class="expand" for="c-37443136">[2 more]</label></div><br/><div class="children"><div class="content">Is it ready for use? Last I saw it was far from feature complete.</div><br/><div id="37443378" class="c"><input type="checkbox" id="c-37443378" checked=""/><div class="controls bullet"><span class="by">PartiallyTyped</span><span>|</span><a href="#37442697">root</a><span>|</span><a href="#37443136">parent</a><span>|</span><a href="#37442684">next</a><span>|</span><label class="collapse" for="c-37443378">[-]</label><label class="expand" for="c-37443378">[1 more]</label></div><br/><div class="children"><div class="content">Afaik the borrow-checker is missing - please correct me if I am wrong - but that doesn&#x27;t stop you from using it. You could very well use `rustc` for the borrow-checker and compile with GCC on any other backend. The borrow-checker only expresses that your code is sound according the rust spec.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37442684" class="c"><input type="checkbox" id="c-37442684" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#37442697">prev</a><span>|</span><a href="#37443030">next</a><span>|</span><label class="collapse" for="c-37442684">[-]</label><label class="expand" for="c-37442684">[3 more]</label></div><br/><div class="children"><div class="content">TL;DR<p>This is about pure Ruby code optimized by JIT vs manual optimization by writing C extensions (native code). There is Ruby code around those extensions but<p>&gt; The JIT cannot know what the native code will do to parameters (possibly mutate them), it cannot know what type of Ruby object will be returned, if the native code will look at the stack, or if it will raise an exception, etc. Thus the JIT is forced to have a conservative approach when dealing with native code, essentially forgetting much of what it had learned, and falling back to the most conservative implementation possible.<p>Hence the JIT often makes pure Ruby code run faster than the code with C extensions.<p>I think I heard the same argument many times with other JITed languages, interpreted or compiled.</div><br/><div id="37443115" class="c"><input type="checkbox" id="c-37443115" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#37442684">parent</a><span>|</span><a href="#37443084">next</a><span>|</span><label class="collapse" for="c-37443115">[-]</label><label class="expand" for="c-37443115">[1 more]</label></div><br/><div class="children"><div class="content">Any managed language - java and go included, pays for trips to external, non-intrinsics calls. The standard way to deal is large portions&#x2F;buffers to amortize the costs. This has been the case since the late &#x27;90s</div><br/></div></div></div></div><div id="37443030" class="c"><input type="checkbox" id="c-37443030" checked=""/><div class="controls bullet"><span class="by">john_the_writer</span><span>|</span><a href="#37442684">prev</a><span>|</span><a href="#37443005">next</a><span>|</span><label class="collapse" for="c-37443030">[-]</label><label class="expand" for="c-37443030">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand why we have to pretend Ruby could ever be as fast as C.  Or faster.  That&#x27;s like saying a jockey is faster than their horse.  Ruby is riding on C, so it cannot be faster.<p>Also why even bother.  Ruby is fast enough for the job it does. It&#x27;s higher level and makes things that are &quot;harder&quot; in C, easier.  Dev time is less, and thats where we win.  We take the win, and accept what it is.</div><br/></div></div><div id="37443005" class="c"><input type="checkbox" id="c-37443005" checked=""/><div class="controls bullet"><span class="by">asah</span><span>|</span><a href="#37443030">prev</a><span>|</span><label class="collapse" for="c-37443005">[-]</label><label class="expand" for="c-37443005">[8 more]</label></div><br/><div class="children"><div class="content">&quot;faster than C&quot; - TBH, I kinda dread these clickbait posts because faster than C doesn&#x27;t matter in 2023, where speed is dictated by multi-core and GPU.<p>Python is abysmally slow, but provides access to GPU and (soon) multi-core.</div><br/><div id="37443156" class="c"><input type="checkbox" id="c-37443156" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37443005">parent</a><span>|</span><a href="#37443228">next</a><span>|</span><label class="collapse" for="c-37443156">[-]</label><label class="expand" for="c-37443156">[3 more]</label></div><br/><div class="children"><div class="content">Did you see the post yesterday about the people who deployed a kubernetes cluster because it took 24 hours to parse a few GB of CSVs in JavaScript?</div><br/><div id="37443278" class="c"><input type="checkbox" id="c-37443278" checked=""/><div class="controls bullet"><span class="by">nottheengineer</span><span>|</span><a href="#37443005">root</a><span>|</span><a href="#37443156">parent</a><span>|</span><a href="#37443228">next</a><span>|</span><label class="collapse" for="c-37443278">[-]</label><label class="expand" for="c-37443278">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to read that but can&#x27;t seem to find it. Do you remember the title or have a link?</div><br/><div id="37443308" class="c"><input type="checkbox" id="c-37443308" checked=""/><div class="controls bullet"><span class="by">maccard</span><span>|</span><a href="#37443005">root</a><span>|</span><a href="#37443278">parent</a><span>|</span><a href="#37443228">next</a><span>|</span><label class="collapse" for="c-37443308">[-]</label><label class="expand" for="c-37443308">[1 more]</label></div><br/><div class="children"><div class="content">Yep! I wish I was joking, but <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37415812">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37415812</a></div><br/></div></div></div></div></div></div><div id="37443228" class="c"><input type="checkbox" id="c-37443228" checked=""/><div class="controls bullet"><span class="by">astrobe_</span><span>|</span><a href="#37443005">parent</a><span>|</span><a href="#37443156">prev</a><span>|</span><a href="#37443219">next</a><span>|</span><label class="collapse" for="c-37443228">[-]</label><label class="expand" for="c-37443228">[1 more]</label></div><br/><div class="children"><div class="content">One should remember that not all problems can be solve faster with concurrency - not all problems are &quot;embarrassingly parallel&quot;. Besides, even when they are, one gets diminishing returns by adding more cores. Raw performance on single core is still relevant.<p>That said, support for concurrency is relevant but more for &quot;masking&quot; I&#x2F;O latency than for MIPS, a problem which is apparently more common. For a language created after 2010, it is nearly a fault not to have something less primitive than threads to handle concurrency. It is like still manually managing memory manually like C also does.<p>I agree that &quot;faster than C&quot; claims too often hides some kind of cheating. But we have HN &quot;reviewers&quot; for that ;-).</div><br/></div></div><div id="37443219" class="c"><input type="checkbox" id="c-37443219" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#37443005">parent</a><span>|</span><a href="#37443228">prev</a><span>|</span><a href="#37443116">next</a><span>|</span><label class="collapse" for="c-37443219">[-]</label><label class="expand" for="c-37443219">[1 more]</label></div><br/><div class="children"><div class="content">uhm, isn&#x27;t the CPU access in python written in C (mostly)?</div><br/></div></div><div id="37443116" class="c"><input type="checkbox" id="c-37443116" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#37443005">parent</a><span>|</span><a href="#37443219">prev</a><span>|</span><a href="#37443077">next</a><span>|</span><label class="collapse" for="c-37443116">[-]</label><label class="expand" for="c-37443116">[1 more]</label></div><br/><div class="children"><div class="content">Without control, power is nothing.<p>C gives you control.</div><br/></div></div></div></div></div></div></div></div></div></body></html>