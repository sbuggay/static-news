<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725354074872" as="style"/><link rel="stylesheet" href="styles.css?v=1725354074872"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/">Notes on Distributed Systems for Young Bloods</a> <span class="domain">(<a href="https://www.somethingsimilar.com">www.somethingsimilar.com</a>)</span></div><div class="subtext"><span>doesntmeananyth</span> | <span>26 comments</span></div><br/><div><div id="41432035" class="c"><input type="checkbox" id="c-41432035" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#41429261">next</a><span>|</span><label class="collapse" for="c-41432035">[-]</label><label class="expand" for="c-41432035">[1 more]</label></div><br/><div class="children"><div class="content">The article should really mention CALM (Consistency as Logical Monotonicity)[1], it&#x27;s much easier to understand and a more fundamental result than CAP. It is also much more applicable and enables people with little experience to build extremely robust distributed systems.<p>Idempotence, CRDTs, WALs, Raft, they are all special cases of the CALM principle.<p>[1]: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1901.01930" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1901.01930</a></div><br/></div></div><div id="41429261" class="c"><input type="checkbox" id="c-41429261" checked=""/><div class="controls bullet"><span class="by">sulam</span><span>|</span><a href="#41432035">prev</a><span>|</span><a href="#41427779">next</a><span>|</span><label class="collapse" for="c-41429261">[-]</label><label class="expand" for="c-41429261">[14 more]</label></div><br/><div class="children"><div class="content">One that is not mentioned here but that I like as a general principle is that you cannot have exactly once delivery. At most once or at least once are both possible, but you have to pick your failure poison and architect for it.</div><br/><div id="41432011" class="c"><input type="checkbox" id="c-41432011" checked=""/><div class="controls bullet"><span class="by">j-pb</span><span>|</span><a href="#41429261">parent</a><span>|</span><a href="#41430974">next</a><span>|</span><label class="collapse" for="c-41432011">[-]</label><label class="expand" for="c-41432011">[2 more]</label></div><br/><div class="children"><div class="content">*Between two distributed systems that don&#x27;t share the same transactionality domain or are not logically monotone.<p>It&#x27;s easy to see that moving data from one row to another is doable in a clustered database, and could be interpreted as a message being delivered.<p>The point is that you can get exactly once delivery, if your whole system is either idempotent, or you can treat the distributed system as one single unit that can be rolled back together (i.e. side effect free wrt. some other system outside the domain).<p>Both are cases of some form of logical monotonicity, idempotence is easier to see, but transactionality is also based on monotonicity through the used WALs and algorithms like Raft.<p>The article should really mention CALM (Consistency as logical monotnicity), it&#x27;s much easier to understand and a more fundamental result than CAP.
<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1901.01930" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;1901.01930</a></div><br/><div id="41432132" class="c"><input type="checkbox" id="c-41432132" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41432011">parent</a><span>|</span><a href="#41430974">next</a><span>|</span><label class="collapse" for="c-41432132">[-]</label><label class="expand" for="c-41432132">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The point is that you can get exactly once delivery, if your whole system is either idempotent<p>If you have exactly-once delivery, there&#x27;s no difference between being idempotent or not. The only effect of idempotence is to ignore extra deliveries.<p>If idempotence is a requirement, you don&#x27;t have exactly-once delivery.</div><br/></div></div></div></div><div id="41430974" class="c"><input type="checkbox" id="c-41430974" checked=""/><div class="controls bullet"><span class="by">yamrzou</span><span>|</span><a href="#41429261">parent</a><span>|</span><a href="#41432011">prev</a><span>|</span><a href="#41432280">next</a><span>|</span><label class="collapse" for="c-41430974">[-]</label><label class="expand" for="c-41430974">[2 more]</label></div><br/><div class="children"><div class="content">Apache Flink does provide end-to-end exactly-once guarantees when coupled with data sources and data sinks that participate in its checkpointing mechanism. See:<p>- <i>An Overview of End-to-End Exactly-Once Processing in Apache Flink (with Apache Kafka, too!)</i> — <a href="https:&#x2F;&#x2F;flink.apache.org&#x2F;2018&#x2F;02&#x2F;28&#x2F;an-overview-of-end-to-end-exactly-once-processing-in-apache-flink-with-apache-kafka-too&#x2F;" rel="nofollow">https:&#x2F;&#x2F;flink.apache.org&#x2F;2018&#x2F;02&#x2F;28&#x2F;an-overview-of-end-to-en...</a><p>- <i>Flink&#x27;s Fault Tolerance Guarantees</i> — <a href="https:&#x2F;&#x2F;nightlies.apache.org&#x2F;flink&#x2F;flink-docs-release-1.20&#x2F;docs&#x2F;connectors&#x2F;datastream&#x2F;guarantees&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nightlies.apache.org&#x2F;flink&#x2F;flink-docs-release-1.20&#x2F;d...</a></div><br/><div id="41431688" class="c"><input type="checkbox" id="c-41431688" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41430974">parent</a><span>|</span><a href="#41432280">next</a><span>|</span><label class="collapse" for="c-41431688">[-]</label><label class="expand" for="c-41431688">[1 more]</label></div><br/><div class="children"><div class="content">Exactly once processing != exactly once delivery</div><br/></div></div></div></div><div id="41432280" class="c"><input type="checkbox" id="c-41432280" checked=""/><div class="controls bullet"><span class="by">dmurray</span><span>|</span><a href="#41429261">parent</a><span>|</span><a href="#41430974">prev</a><span>|</span><a href="#41430840">next</a><span>|</span><label class="collapse" for="c-41432280">[-]</label><label class="expand" for="c-41432280">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s impossible to have at least once delivery in an environment with an arbitrary level of network failure.</div><br/></div></div><div id="41430840" class="c"><input type="checkbox" id="c-41430840" checked=""/><div class="controls bullet"><span class="by">exogenousdata</span><span>|</span><a href="#41429261">parent</a><span>|</span><a href="#41432280">prev</a><span>|</span><a href="#41430013">next</a><span>|</span><label class="collapse" for="c-41430840">[-]</label><label class="expand" for="c-41430840">[1 more]</label></div><br/><div class="children"><div class="content">Can’t stress this enough.  Thank you for mentioning it!!   In my career I’ve encountered many engineers unfamiliar with this concept when designing a distributed system.</div><br/></div></div><div id="41430013" class="c"><input type="checkbox" id="c-41430013" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41429261">parent</a><span>|</span><a href="#41430840">prev</a><span>|</span><a href="#41429348">next</a><span>|</span><label class="collapse" for="c-41430013">[-]</label><label class="expand" for="c-41430013">[1 more]</label></div><br/><div class="children"><div class="content">The important part of this lesson is &quot;and you don&#x27;t need it&quot;.</div><br/></div></div><div id="41429348" class="c"><input type="checkbox" id="c-41429348" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#41429261">parent</a><span>|</span><a href="#41430013">prev</a><span>|</span><a href="#41427779">next</a><span>|</span><label class="collapse" for="c-41429348">[-]</label><label class="expand" for="c-41429348">[6 more]</label></div><br/><div class="children"><div class="content">Yes but in practice this is not a problem because the bits that are impossible are so narrow that turning at-least-once into exactly-once is so easy it&#x27;s a service offered by cloud vendors <a href="https:&#x2F;&#x2F;cloud.google.com&#x2F;pubsub&#x2F;docs&#x2F;exactly-once-delivery" rel="nofollow">https:&#x2F;&#x2F;cloud.google.com&#x2F;pubsub&#x2F;docs&#x2F;exactly-once-delivery</a></div><br/><div id="41429369" class="c"><input type="checkbox" id="c-41429369" checked=""/><div class="controls bullet"><span class="by">sulam</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41429348">parent</a><span>|</span><a href="#41429858">next</a><span>|</span><label class="collapse" for="c-41429369">[-]</label><label class="expand" for="c-41429369">[2 more]</label></div><br/><div class="children"><div class="content">Those only work because they have retries built in at a layer that runs inside your service. You should understand this because it can have implications for the performance of your system during failures.</div><br/><div id="41431575" class="c"><input type="checkbox" id="c-41431575" checked=""/><div class="controls bullet"><span class="by">devoutsalsa</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41429369">parent</a><span>|</span><a href="#41429858">next</a><span>|</span><label class="collapse" for="c-41431575">[-]</label><label class="expand" for="c-41431575">[1 more]</label></div><br/><div class="children"><div class="content">For example, you can have an exactly once implementation that is essentially implemented as at least once with repeated idempotent calls until a confirmation is received.  Idempotency handling has a cost, confirmation reply has a cost, retry on call that didn’t have confirmation has a cost, etc.</div><br/></div></div></div></div><div id="41429858" class="c"><input type="checkbox" id="c-41429858" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41429348">parent</a><span>|</span><a href="#41429369">prev</a><span>|</span><a href="#41429487">next</a><span>|</span><label class="collapse" for="c-41429858">[-]</label><label class="expand" for="c-41429858">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s often not a problem because it&#x27;s often easy to make a call idempotent. Consider the case where you attach an ID to every event and the subscriber stores data in postgres. You stick everything in a transaction, persist each event&#x27;s ID, add a unique index to that column, handle failure, and bang, it&#x27;s now idempotent.</div><br/></div></div><div id="41429487" class="c"><input type="checkbox" id="c-41429487" checked=""/><div class="controls bullet"><span class="by">fiddlerwoaroof</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41429348">parent</a><span>|</span><a href="#41429858">prev</a><span>|</span><a href="#41429382">next</a><span>|</span><label class="collapse" for="c-41429487">[-]</label><label class="expand" for="c-41429487">[1 more]</label></div><br/><div class="children"><div class="content">My experience is building streaming systems using “exactly-once delivery” primitives is much more awkward than designing your system around at least once primitives and explicitly de-duplicating using last-write wins.  For one thing, LWW gives you an obvious recovery strategy if you have outages of the primitive your system is built on: a lot of the exactly once modes for tools make failure recovery harder than necessary</div><br/></div></div><div id="41429382" class="c"><input type="checkbox" id="c-41429382" checked=""/><div class="controls bullet"><span class="by">jclulow</span><span>|</span><a href="#41429261">root</a><span>|</span><a href="#41429348">parent</a><span>|</span><a href="#41429487">prev</a><span>|</span><a href="#41427779">next</a><span>|</span><label class="collapse" for="c-41429382">[-]</label><label class="expand" for="c-41429382">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Redelivery versus duplicate&quot; is doing quite a lot of work in there.  This is an &quot;at least once&quot; delivery system providing building blocks that you can use to cope with the fact that it&#x27;s physically impossible to prevent redelivery under some circumstances, which are not actually that rare because some of those circumstances are your fault, not Google&#x27;s, etc.</div><br/></div></div></div></div></div></div><div id="41427779" class="c"><input type="checkbox" id="c-41427779" checked=""/><div class="controls bullet"><span class="by">sillywalk</span><span>|</span><a href="#41429261">prev</a><span>|</span><a href="#41429013">next</a><span>|</span><label class="collapse" for="c-41427779">[-]</label><label class="expand" for="c-41427779">[1 more]</label></div><br/><div class="children"><div class="content">Previous discussions from way back:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5055371">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=5055371</a><p>346 points|jcdavis|12 years ago|42 comments<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12245909">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=12245909</a><p>386 points|kiyanwang|8 years ago|133 comments</div><br/></div></div><div id="41429013" class="c"><input type="checkbox" id="c-41429013" checked=""/><div class="controls bullet"><span class="by">turtledragonfly</span><span>|</span><a href="#41427779">prev</a><span>|</span><a href="#41429333">next</a><span>|</span><label class="collapse" for="c-41429013">[-]</label><label class="expand" for="c-41429013">[2 more]</label></div><br/><div class="children"><div class="content">Excellent list; I like the pragmatic and down-to-earth explanations. No buzzwords, no &quot;microservices&quot; (:<p>I&#x27;d say that a good amount of this advice <i>also</i> applies to one-box systems. There can be lots of kinda&#x2F;sorta distributed sub-components to consider — could be IPC between programs, or even coordination amongst threads in one process. Even the notion of unified memory on one box is a bit of a lie, but at least the hardware can provide some better guarantees than you get in &quot;real&quot; distributed cases.<p>A lot of the advice where they compare &quot;distributed&quot; to &quot;single-machine&quot; could pretty well apply to &quot;multi-threaded&quot; vs &quot;single-threaded,&quot; too.<p>And on another axis, once you make a program and give it to various people to run, it becomes sort of a &quot;distributed&quot; situation, too — now you have to worry about different versions of that program existing in the wild, compatibility between them and upgrade issues, etc. So things like feature flags, mentioned in the article, can be relevant there, as well.<p>It&#x27;s perhaps more of a spectrum of distributedness: from single-CPU to multi-CPU, to multi-computer-tightly-connected, to multi-computer-globally-distributed, with various points in between. And multiple dimensions.</div><br/><div id="41431706" class="c"><input type="checkbox" id="c-41431706" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41429013">parent</a><span>|</span><a href="#41429333">next</a><span>|</span><label class="collapse" for="c-41431706">[-]</label><label class="expand" for="c-41431706">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d say that a good amount of this advice also applies to one-box systems.<p>Nothing in &quot;distributed systems&quot; implies any constraint on deployment. The only trait that&#x27;s critical to the definition is having different flows of control communicating over a network through message-passing. One very famous example of distributed systems is multiple processes running on the same box communicating over localhost, which happens to be where some people cut their distributed system&#x27;s teeth.</div><br/></div></div></div></div><div id="41429333" class="c"><input type="checkbox" id="c-41429333" checked=""/><div class="controls bullet"><span class="by">languagehacker</span><span>|</span><a href="#41429013">prev</a><span>|</span><a href="#41429387">next</a><span>|</span><label class="collapse" for="c-41429333">[-]</label><label class="expand" for="c-41429333">[2 more]</label></div><br/><div class="children"><div class="content">I share this doc with the most promising people I get to work with.<p>When I worked at Lookout, Jeff Hodges shared this essay as a presentation, and ended it with a corollary: don&#x27;t pretend that engineering isn&#x27;t political. People that think that the code speaks for itself are missing out on important aspects of how to influence the way things are built and how to truly get results.<p>Ten years later, and there are few people who still so concisely understand the intersection of engineering leadership and those table-stakes capabilities we normally associate with SRE &#x2F; DevOps.</div><br/><div id="41430062" class="c"><input type="checkbox" id="c-41430062" checked=""/><div class="controls bullet"><span class="by">decasia</span><span>|</span><a href="#41429333">parent</a><span>|</span><a href="#41429387">next</a><span>|</span><label class="collapse" for="c-41430062">[-]</label><label class="expand" for="c-41430062">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there are few people who still so concisely understand the intersection of engineering leadership and those table-stakes capabilities we normally associate with SRE &#x2F; DevOps.<p>I&#x27;m curious what else is good to read about this topic, if anything comes to your mind?</div><br/></div></div></div></div><div id="41429387" class="c"><input type="checkbox" id="c-41429387" checked=""/><div class="controls bullet"><span class="by">abatilo</span><span>|</span><a href="#41429333">prev</a><span>|</span><a href="#41431376">next</a><span>|</span><label class="collapse" for="c-41429387">[-]</label><label class="expand" for="c-41429387">[1 more]</label></div><br/><div class="children"><div class="content">I had the pleasure to briefly work with the author of this post within the last few years. Jeff was one of the most enlightening and positive people I&#x27;ve ever learned from. He was refreshingly honest about what challenges he was having, and delightfully accessible for mentorship and advice.</div><br/></div></div><div id="41431376" class="c"><input type="checkbox" id="c-41431376" checked=""/><div class="controls bullet"><span class="by">Maro</span><span>|</span><a href="#41429387">prev</a><span>|</span><a href="#41432093">next</a><span>|</span><label class="collapse" for="c-41431376">[-]</label><label class="expand" for="c-41431376">[3 more]</label></div><br/><div class="children"><div class="content">I think a lot has changed since 2013 when this article was written. Back then cloud services were less mature and there were more legitimate cases when you had to care about the <i>theoretical</i> distributed aspects of your backend architecture.. although even then these were quickly disappearing, unless you worked at a few select bigtech companies like the FAANGs.<p>But today, in 2024, if you just standardize on AWS, you can pretty much use one of the AWS services for pretty much anything. And that AWS service will be already distributed  in the backend, for free, in terms of you not having to worry about it. Additionaly, it will be run by AWS engineers for you, with all sorts of failovers, monitoring, alerting, etc, behind the scenes that will be much better than what you can build.<p>So these days, for 99% of people it doesn&#x27;t really make sense to worry too much about this theoretical stuff, like Paxos, Raft, consistency, vector clocks, byzantine failures, CAP, distributed locks, distributed transactions, etc. And that&#x27;s good progress, it has been abstracted away behind API calls.  I think it&#x27;s pretty rational to just build on top of AWS (or similar) services, and accept that it&#x27;s a black box distributed system that may still go down sometimes, but it&#x27;ll still be 10-100x more reliable then if you try to build your own distributed system.<p>Of course, even for the 99%, there are still important <i>practical</i> things to keep in mind, like logging, debugging, backpressure, etc.<p>Another thing I learned is that some concepts, such as availability, are less important, and less achievable, then they seem on paper. On paper it sounds like a worthy exercise to design systems that will fail over and come back automatically if a component fails, with only a few seconds downtime. Magically, with everything working like a well oiled machine. In practice this is pretty much never works out, because there are componenets of the system that the designed didn&#x27;t think of, and it&#x27;s those that will fail and bring the system down. Eg. see the recent Crowdstrike incident.<p>And, with respect to importance of availability, of the ~10 companies I worked at in the past ~20 years there&#x27;s wasn&#x27;t a single one that couldn&#x27;t tolerate a few hours of downtime with zero to minimal business and PR impact (people are used to things going down a couple of times a year). I remember having outages at a SaaS company I worked for 10 years ago, no revenue was coming in for a few days, but then people would just spend more in the following day. Durability is more important, but even that is less important in practice then we&#x27;d like to think [1].<p>The remaining 1% of engineers, who get to worry about the beuatiful theoretical AND practical aspects of distributed computing [because they work at Google or Facebook or AWS] should count themselves lucky! I think it&#x27;s one of the most interesting fields in Computer Science.<p>I say this as somebody who deeply cares&#x2F;cared about theoretical distributed computing, I wrote distributed databases [2] and papers in the past [3]. But working in industry (also managing a Platform Eng team), I cannot recall the last time I had to worry about such things.<p>[1] PostgreSQL used fsync incorrectly for 20 years - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19119991">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19119991</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;scalien&#x2F;scaliendb">https:&#x2F;&#x2F;github.com&#x2F;scalien&#x2F;scaliendb</a><p>[3] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1209.4187" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1209.4187</a></div><br/><div id="41431868" class="c"><input type="checkbox" id="c-41431868" checked=""/><div class="controls bullet"><span class="by">truckerbill</span><span>|</span><a href="#41431376">parent</a><span>|</span><a href="#41432093">next</a><span>|</span><label class="collapse" for="c-41431868">[-]</label><label class="expand" for="c-41431868">[2 more]</label></div><br/><div class="children"><div class="content">The downside is you are walking into an inviting mono&#x2F;duopoly. 
Things like this and cloudflare are amazing until the wind changes and the entire internet has a failure mode</div><br/><div id="41431938" class="c"><input type="checkbox" id="c-41431938" checked=""/><div class="controls bullet"><span class="by">Maro</span><span>|</span><a href="#41431376">root</a><span>|</span><a href="#41431868">parent</a><span>|</span><a href="#41432093">next</a><span>|</span><label class="collapse" for="c-41431938">[-]</label><label class="expand" for="c-41431938">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, the biggest risk with AWS and similar is not the dependence itself, it&#x27;s the cost. With AWS you pay a lot more for the compute then if you just rent the hardware for $25&#x2F;server with Linux, and then go from there. It does make sense for some shops, where you have scale and can make calculated trade-offs between 100s of engineers&#x27; salaries and cloud costs (like Netflix).<p>But I think a lot of small startups end up overpaying for their cloud costs even though they don&#x27;t take advantage of the elasticity&#x2F;scaling&#x2F;replication&#x2F;etc.<p>Also, a lot of BigCos are just on public clouds because that&#x27;s the thing now, but their stacks, software and teams are so broken, they don&#x27;t actually take advantage of the cloud. Their engineering teams are mediocre, and so is the software, so it breaks all the time. So they end up paying for something they can&#x27;t take advantage of, because they don&#x27;t need to scale, they don&#x27;t need high uptime and&#x2F;or can&#x27;t achieve it because their stuff running on top of the cloud is a horrible unreliable spaghetti anyway.<p>If I was to do a SaaS-y startup today, I&#x27;d just rent cheap dedicated hardware, I&#x27;d use OVH [1]. I&#x27;d start with 1 reasonably beefy server for like $25-50&#x2F;mo and see how far it gets me. I <i>would</i> use S3 for unlimited, reliable storage, (maybe even RDS for DB), but everything else I&#x27;d keep out of AWS, running on my cheap server. Ie. I&#x27;d keep my data in AWS, because that&#x27;s super cheap and worth it.<p>Later, if the thing is super successful, I&#x27;d go to $250-500&#x2F;mo and get 5-10 reasonably beefy servers, and start to move things apart. I&#x27;d still not worry too much about replication and such, I&#x27;d just to backups, and take the hit if there&#x27;s a problem and restore at the last backup point. I think this would get me pretty far, all the way to when I want to bring BigCo customers aboard who need all sorts of ISO standards and such. At that point the whole thing will stop being fun anyway and it&#x27;s time to let other people worry about it..<p>And in terms of hiring, I&#x27;d make it clear at interview time that this is the stack, and we&#x27;re not going to do microservices and Kubernetes and all that crap just because others are doing it, and I&#x27;d hire from the remaining pool.<p>[1] I&#x27;ve been on it for my personal devboxes for ~7 years, it just works</div><br/></div></div></div></div></div></div><div id="41432093" class="c"><input type="checkbox" id="c-41432093" checked=""/><div class="controls bullet"><span class="by">tapanjk</span><span>|</span><a href="#41431376">prev</a><span>|</span><label class="collapse" for="c-41432093">[-]</label><label class="expand" for="c-41432093">[1 more]</label></div><br/><div class="children"><div class="content">(2013)</div><br/></div></div></div></div></div></div></div></body></html>