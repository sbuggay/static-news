<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699261260895" as="style"/><link rel="stylesheet" href="styles.css?v=1699261260895"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.xtof.info/intel80386.html">Intel 80386, a Revolutionary CPU</a> <span class="domain">(<a href="https://www.xtof.info">www.xtof.info</a>)</span></div><div class="subtext"><span>blakespot</span> | <span>117 comments</span></div><br/><div><div id="38157651" class="c"><input type="checkbox" id="c-38157651" checked=""/><div class="controls bullet"><span class="by">johnklos</span><span>|</span><a href="#38156812">next</a><span>|</span><label class="collapse" for="c-38157651">[-]</label><label class="expand" for="c-38157651">[9 more]</label></div><br/><div class="children"><div class="content">I think the 80386&#x27;s final design benefitted tremendously from the Motorola 68000, then the m68020. Had Motorola not released a proper 32 bit CPU without compromises, it could be argued that Intel would&#x27;ve had yet another stop-gap after the 80286, which itself wasn&#x27;t intended to be a proper successor to the 8086&#x2F;8088.<p>As it is, the 80386 came with a number of compromises. For instance, there was no cache at all beyond a 16 byte instruction prefetch queue, whereas the m68020 had 256 bytes of instruction cache. There were no atomic instructions (LOCK wasn&#x27;t useful for this), which is why many modern OSes support the 80486 but not the 80386. The fact that compatibility with the 8086 required real mode or VM86 meant that it took quite a long time before software started taking advantage of the 80386&#x27;s new features.<p>It was an important chip, but it showed us early signs of what we&#x27;ve come to expect from Intel: attempts to create other markets at the expense of, or with the express desire to not compete with, the x86 (the iAPX 432 then, the Itanic twenty years later), the slapdash addition of &quot;features&quot;, such as the additions to the 80286, which then were required to be included forevermore as legacy support, the rushing-to-catch-up when other vendors had features that everyone wanted (real, flat 32 bit support then, 64 bit support twenty years later).<p>Still, it&#x27;s interesting history!</div><br/><div id="38159001" class="c"><input type="checkbox" id="c-38159001" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#38157651">parent</a><span>|</span><a href="#38157693">next</a><span>|</span><label class="collapse" for="c-38159001">[-]</label><label class="expand" for="c-38159001">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There were no atomic instructions (&#x2F;LOCK wasn&#x27;t useful for this), which is why many modern OSes support the 80486 but not the 80386.<p>Does the lack of atomics really matter, given that there was (AIUI) no SMP on the 386? You can always disable interrupts to make your operation &#x27;atomic&#x27; in a uniprocessor context.</div><br/><div id="38159917" class="c"><input type="checkbox" id="c-38159917" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#38157651">root</a><span>|</span><a href="#38159001">parent</a><span>|</span><a href="#38159727">next</a><span>|</span><label class="collapse" for="c-38159917">[-]</label><label class="expand" for="c-38159917">[1 more]</label></div><br/><div class="children"><div class="content">Already starting with 8086 all Intel x86 CPUs have been intended to be usable in SMP systems.<p>Nevertheless, there have been very few SMP systems using early Intel CPUs, before 80486, mainly because those CPUs were still too weak in comparison with the contemporaneous mini-computers, and not even SMP would have made them competitive in performance, while the high price of SMP would have been incompatible with personal computers.<p>Intel 80486 has been much more frequently used in SMP systems, not only because it had added the more convenient atomic fetch-and-add and compare-and-swap instructions, but because Intel had also provided for 80486 an APIC integrated circuit, i.e. a multi-processor interrupt controller, and also because 80486 was very fast and a SMP system using it was competitive with much more expensive computers.<p>Intel 8086 was intended to be used in SMP systems by using the atomic swap instruction proposed by Dijkstra, i.e. LOCK XCHG with the Intel mnemonics.<p>The atomic swap is good enough to implement any kind of concurrent programs, albeit at a lower performance and higher complexity than when the atomic instructions added by 80486 (LOCK XADD and LOCK CMPXCHG) and Pentium (LOCK CMPXCHG8B) are available.<p>The 80386 has added atomic fetch-and-modify-bit instructions, which remain useful even today in wait-for-multiple-event scenarios (together with LZCNT, which can be used to get the highest-priority event that must be serviced).</div><br/></div></div><div id="38159727" class="c"><input type="checkbox" id="c-38159727" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38157651">root</a><span>|</span><a href="#38159001">parent</a><span>|</span><a href="#38159917">prev</a><span>|</span><a href="#38157693">next</a><span>|</span><label class="collapse" for="c-38159727">[-]</label><label class="expand" for="c-38159727">[1 more]</label></div><br/><div class="children"><div class="content">Disabling interrupts is a privileged operation (you need IOPL for the ability to execute the cli or sti instructions). Atomics can work even outside of privileged code.<p>Otherwise you could from any user program disable interrupts and give the operating system no chance to take back control. Xadd, cmpxchg, bts, btr and btc are all prefixable with lock to make them atomic.</div><br/></div></div></div></div><div id="38157693" class="c"><input type="checkbox" id="c-38157693" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#38157651">parent</a><span>|</span><a href="#38159001">prev</a><span>|</span><a href="#38156812">next</a><span>|</span><label class="collapse" for="c-38157693">[-]</label><label class="expand" for="c-38157693">[5 more]</label></div><br/><div class="children"><div class="content">It was a 386 that Linus Torvalds wrote the first Linux kernel on, and support for the new features of the 386 from the start was one of the reasons Linux took off instantly.</div><br/><div id="38158636" class="c"><input type="checkbox" id="c-38158636" checked=""/><div class="controls bullet"><span class="by">flashback2199</span><span>|</span><a href="#38157651">root</a><span>|</span><a href="#38157693">parent</a><span>|</span><a href="#38159617">next</a><span>|</span><label class="collapse" for="c-38158636">[-]</label><label class="expand" for="c-38158636">[1 more]</label></div><br/><div class="children"><div class="content">More info:<p>&quot;It uses every conceivable feature of the 386 I could find, as it was also a project to teach me about the 386&quot;<p><a href="https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~awb&#x2F;linux.history.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~awb&#x2F;linux.history.html</a></div><br/></div></div><div id="38159617" class="c"><input type="checkbox" id="c-38159617" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#38157651">root</a><span>|</span><a href="#38157693">parent</a><span>|</span><a href="#38158636">prev</a><span>|</span><a href="#38159555">next</a><span>|</span><label class="collapse" for="c-38159617">[-]</label><label class="expand" for="c-38159617">[1 more]</label></div><br/><div class="children"><div class="content">Not only Linux, all the current BSDs share a lot of “DNA” with 386BSD.</div><br/></div></div><div id="38159555" class="c"><input type="checkbox" id="c-38159555" checked=""/><div class="controls bullet"><span class="by">rob74</span><span>|</span><a href="#38157651">root</a><span>|</span><a href="#38157693">parent</a><span>|</span><a href="#38159617">prev</a><span>|</span><a href="#38157710">next</a><span>|</span><label class="collapse" for="c-38159555">[-]</label><label class="expand" for="c-38159555">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, a free (as in freedom, but also as in beer) OS running on hardware that was, by then, commoditized, what&#x27;s there not to like? No wonder Google and others jumped on it...</div><br/></div></div><div id="38157710" class="c"><input type="checkbox" id="c-38157710" checked=""/><div class="controls bullet"><span class="by">sertsa</span><span>|</span><a href="#38157651">root</a><span>|</span><a href="#38157693">parent</a><span>|</span><a href="#38159555">prev</a><span>|</span><a href="#38156812">next</a><span>|</span><label class="collapse" for="c-38157710">[-]</label><label class="expand" for="c-38157710">[1 more]</label></div><br/><div class="children"><div class="content">Indeed!  My first taste of Linux was Slackware on a 386</div><br/></div></div></div></div></div></div><div id="38156812" class="c"><input type="checkbox" id="c-38156812" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#38157651">prev</a><span>|</span><a href="#38158592">next</a><span>|</span><label class="collapse" for="c-38156812">[-]</label><label class="expand" for="c-38156812">[63 more]</label></div><br/><div class="children"><div class="content">They were in big trouble then. The entire company was riding on it being great.<p>It could have easily gone awry as it did for Data General, Honeywell, CDC, AST, Tandy, Olivetti, Xerox, DEC Rainbow, AT&amp;T Hobbit, Wang 2200 and Unisys. Strong survivorship bias on this one. Most of the once Titans are in or near the dustbin now, such as SDS, SDC and Fairchild.<p>Intel&#x27;s history was primarily as a memory manufacturer. They&#x27;re arguably near a similar fucked position now - effectively 0% of the mobile and home appliance market and getting slaughtered in their only remaining stronghold by NVIDIA, AMD and ARM pillaging their castle. Hopefully they&#x27;ll squeeze out of this one.</div><br/><div id="38156942" class="c"><input type="checkbox" id="c-38156942" checked=""/><div class="controls bullet"><span class="by">scrlk</span><span>|</span><a href="#38156812">parent</a><span>|</span><a href="#38157393">next</a><span>|</span><label class="collapse" for="c-38156942">[-]</label><label class="expand" for="c-38156942">[2 more]</label></div><br/><div class="children"><div class="content">Andy Grove moving Intel from memory to microprocessors was an excellent strategic move.<p>&gt; &quot;Business success contains the seeds of its own destruction. Success breeds complacency. Complacency breeds failure. Only the paranoid survive.&quot;<p>Something that Intel&#x27;s leaders didn&#x27;t pay attention to during the 2010s.</div><br/><div id="38159136" class="c"><input type="checkbox" id="c-38159136" checked=""/><div class="controls bullet"><span class="by">ngcc_hk</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38156942">parent</a><span>|</span><a href="#38157393">next</a><span>|</span><label class="collapse" for="c-38159136">[-]</label><label class="expand" for="c-38159136">[1 more]</label></div><br/><div class="children"><div class="content">There is even a story plus a term for it.<p>The story is about what if we all go out off this room and come back like a new guy.  What would we do?<p>&quot;strategic inflection point&quot; ...<p>They decide to move from a memory company to a CPU company.<p>No access to Nikon but being just a Leica len maker for Canon (and famously found by DDD and used in Korea War), then move to nikon rangefinder (but strangely follow Zeiss approach more).  Then jump ship to SLR by inventing Nikon F (and used in Vietnam War).  It is just crazy move, but at least it is related.  And &quot;survive&quot; and move on.<p>Or just like Fujifilm move to cosmetic in one stage as making film has some knowledge that can be re-used there.  And survive and move on.</div><br/></div></div></div></div><div id="38157393" class="c"><input type="checkbox" id="c-38157393" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38156812">parent</a><span>|</span><a href="#38156942">prev</a><span>|</span><a href="#38156886">next</a><span>|</span><label class="collapse" for="c-38157393">[-]</label><label class="expand" for="c-38157393">[26 more]</label></div><br/><div class="children"><div class="content">The DEC Rainbow would have been fine if they didn&#x27;t do things like require special floppy disks that cost $5 each.<p>DEC should have packaged the LSI-11 into a consumer machine. They had all the software, which was top shelf.<p>I had an H-11, it was a great machine.</div><br/><div id="38159289" class="c"><input type="checkbox" id="c-38159289" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157393">parent</a><span>|</span><a href="#38157904">next</a><span>|</span><label class="collapse" for="c-38159289">[-]</label><label class="expand" for="c-38159289">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a big pdp-11 fan but this wouldn&#x27;t have worked because 128K address space isn&#x27;t enough even in 1975. Listen to Dave Cutler talk about this in the 3h long interview.</div><br/></div></div><div id="38157904" class="c"><input type="checkbox" id="c-38157904" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157393">parent</a><span>|</span><a href="#38159289">prev</a><span>|</span><a href="#38156886">next</a><span>|</span><label class="collapse" for="c-38157904">[-]</label><label class="expand" for="c-38157904">[24 more]</label></div><br/><div class="children"><div class="content">Thats an interesting alternative history thought experiment.<p>I wonder how early one could capture the complexity of the full PDP-11 microarchitecture on a single chip? Would it have been affordable? What about the support hardware?</div><br/><div id="38158084" class="c"><input type="checkbox" id="c-38158084" checked=""/><div class="controls bullet"><span class="by">nxobject</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157904">parent</a><span>|</span><a href="#38157977">next</a><span>|</span><label class="collapse" for="c-38158084">[-]</label><label class="expand" for="c-38158084">[13 more]</label></div><br/><div class="children"><div class="content">Hmm – the smallest, most highly-integrated PDP-11 (-compatible) package ever made was the QFP 1806VM2, with around ~135k transistors; it integrated MMU, UART, parallel interface, keyboard controller, etc, but did floating-point instructions in interpretive microcode.<p>I think that same transistor count was reached by Motorola on the 68020, which would&#x27;ve been around 1984, but would have needed the peripheral controllers mentioned here.</div><br/><div id="38158506" class="c"><input type="checkbox" id="c-38158506" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158084">parent</a><span>|</span><a href="#38159892">next</a><span>|</span><label class="collapse" for="c-38158506">[-]</label><label class="expand" for="c-38158506">[7 more]</label></div><br/><div class="children"><div class="content">The FPU for the 8086 was a separate chip, and the IBM PC still required a board full of chips to make a working computer.<p>(If I recall correctly, it wasn&#x27;t until the 486 that the FPU was incorporated.)</div><br/><div id="38159210" class="c"><input type="checkbox" id="c-38159210" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158506">parent</a><span>|</span><a href="#38159573">next</a><span>|</span><label class="collapse" for="c-38159210">[-]</label><label class="expand" for="c-38159210">[5 more]</label></div><br/><div class="children"><div class="content">The IBM PC had an advantage in that most of the support parts were IIRC largely jellybean 74 series logic - could a PC-PDP have used similar COTS parts?<p>The larger issue with DEC was a strong NIH trend (almost as strong as IBM), I dont know if they could have bucked that trend to successfully launch a market winning PC. It probably would have looked like the DEC Professional, which I think looks like market failure.<p>So the dreams of a 64 bit extension to the PDP-11 might be stillborn ;-)</div><br/><div id="38159340" class="c"><input type="checkbox" id="c-38159340" checked=""/><div class="controls bullet"><span class="by">Gibbon1</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159210">parent</a><span>|</span><a href="#38159573">next</a><span>|</span><label class="collapse" for="c-38159340">[-]</label><label class="expand" for="c-38159340">[4 more]</label></div><br/><div class="children"><div class="content">I read an essay by a guy that worked on project to produce a DEC minicomputer using ECL logic. And there was yet another group working on the DEC Alpha. At the time the main group was using most of the companies resources betting the company on dethroning IBM in the main frame arena. And was trying to stab the Alpha and Minicomputer group in the back.<p>So probably not.<p>Suspect IBM&#x27;s skunk work project was done as a hedge and anti-trust reasons. Personal Computers were going to take some business away from them they wanted it to be their product not someone else. Anti-trust also meant it needed to use off the shelf stuff.</div><br/><div id="38159824" class="c"><input type="checkbox" id="c-38159824" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159340">parent</a><span>|</span><a href="#38159860">next</a><span>|</span><label class="collapse" for="c-38159824">[-]</label><label class="expand" for="c-38159824">[1 more]</label></div><br/><div class="children"><div class="content">Between x86 and the Alpha I much preferred the Alpha. Unfortunately it was wickedly expensive <i>and</i> it was hard to get. But for 64 bit work it was immediately usable and rock solid. It also beat Intel&#x2F;AMD by about a decade to the market and I&#x27;m still kind of surprised that DEC managed to squander that lead.</div><br/></div></div><div id="38159860" class="c"><input type="checkbox" id="c-38159860" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159340">parent</a><span>|</span><a href="#38159824">prev</a><span>|</span><a href="#38159573">next</a><span>|</span><label class="collapse" for="c-38159860">[-]</label><label class="expand" for="c-38159860">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t imagine Alpha and ECL based designs being done anywhere within the same decade.</div><br/><div id="38160020" class="c"><input type="checkbox" id="c-38160020" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159860">parent</a><span>|</span><a href="#38159573">next</a><span>|</span><label class="collapse" for="c-38160020">[-]</label><label class="expand" for="c-38160020">[1 more]</label></div><br/><div class="children"><div class="content">Alpha and VAX 9000<p>DEC also did a &quot;300 MHz 125 W ECL microprocessor&quot; in the 90s, though that seemed to be mostly about developing cooling.</div><br/></div></div></div></div></div></div></div></div><div id="38159573" class="c"><input type="checkbox" id="c-38159573" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158506">parent</a><span>|</span><a href="#38159210">prev</a><span>|</span><a href="#38159892">next</a><span>|</span><label class="collapse" for="c-38159573">[-]</label><label class="expand" for="c-38159573">[1 more]</label></div><br/><div class="children"><div class="content">&gt;it wasn&#x27;t until the 486 that the FPU was incorporated<p>Indeed and 486SX had the FPU disabled. I think that was the 1st time the binning&#x2F;SKUs became a marketing strategy.</div><br/></div></div></div></div><div id="38159892" class="c"><input type="checkbox" id="c-38159892" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158084">parent</a><span>|</span><a href="#38158506">prev</a><span>|</span><a href="#38159299">next</a><span>|</span><label class="collapse" for="c-38159892">[-]</label><label class="expand" for="c-38159892">[1 more]</label></div><br/><div class="children"><div class="content">1806VM2 wasn&#x27;t released until late 1980s when there were numerous superior options, even if your yardstick is transistor count (but naturally not in USSR).</div><br/></div></div><div id="38159299" class="c"><input type="checkbox" id="c-38159299" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158084">parent</a><span>|</span><a href="#38159892">prev</a><span>|</span><a href="#38159228">next</a><span>|</span><label class="collapse" for="c-38159299">[-]</label><label class="expand" for="c-38159299">[1 more]</label></div><br/><div class="children"><div class="content">68020 is much more complex than any pdp-11.</div><br/></div></div><div id="38159228" class="c"><input type="checkbox" id="c-38159228" checked=""/><div class="controls bullet"><span class="by">Aloha</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158084">parent</a><span>|</span><a href="#38159299">prev</a><span>|</span><a href="#38157977">next</a><span>|</span><label class="collapse" for="c-38159228">[-]</label><label class="expand" for="c-38159228">[3 more]</label></div><br/><div class="children"><div class="content">I think DEC&#x27;s strong trend line of NIH (almost as strong as IBM) almost certainly dooms a PC-PDP - IBM only made the PC by effectively creating a skunkworks within the company that was focused solely on &#x27;go to market&#x27; compared to the normal IBM development process. I dont know if DEC could or would have done that.</div><br/><div id="38159304" class="c"><input type="checkbox" id="c-38159304" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159228">parent</a><span>|</span><a href="#38157977">next</a><span>|</span><label class="collapse" for="c-38159304">[-]</label><label class="expand" for="c-38159304">[2 more]</label></div><br/><div class="children"><div class="content">I was a DEC-head in the 70&#x27;s and 80&#x27;s, and along with my fellow DEC-heads anxiously awaited DEC&#x27;s entry into the PC arena. Everyone was excited to see the rollout of the Rainbow, sure it would be a killer machine like other DEC machines. After the presentation, we were all in shock. It did not play to any of DEC&#x27;s strengths, and was just a crummy, proprietary x86 insult.<p>That was the end of our love affair with DEC. Very sad.</div><br/><div id="38159830" class="c"><input type="checkbox" id="c-38159830" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159304">parent</a><span>|</span><a href="#38157977">next</a><span>|</span><label class="collapse" for="c-38159830">[-]</label><label class="expand" for="c-38159830">[1 more]</label></div><br/><div class="children"><div class="content">One of the worst own goals in the history of computing imnsho.</div><br/></div></div></div></div></div></div></div></div><div id="38157977" class="c"><input type="checkbox" id="c-38157977" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157904">parent</a><span>|</span><a href="#38158084">prev</a><span>|</span><a href="#38156886">next</a><span>|</span><label class="collapse" for="c-38157977">[-]</label><label class="expand" for="c-38157977">[10 more]</label></div><br/><div class="children"><div class="content">If Intel could do it, DEC could do it.</div><br/><div id="38159579" class="c"><input type="checkbox" id="c-38159579" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157977">parent</a><span>|</span><a href="#38159578">next</a><span>|</span><label class="collapse" for="c-38159579">[-]</label><label class="expand" for="c-38159579">[8 more]</label></div><br/><div class="children"><div class="content">DEC Alpha had the weakest memory model, which while cool to write for with its all memory barriers&#x2F;concurrency - it&#x27;s quite annoying to work with in the real world, a major reason while DEC failed.</div><br/><div id="38159854" class="c"><input type="checkbox" id="c-38159854" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159579">parent</a><span>|</span><a href="#38159578">next</a><span>|</span><label class="collapse" for="c-38159854">[-]</label><label class="expand" for="c-38159854">[7 more]</label></div><br/><div class="children"><div class="content">Compared to the madness that was x86 memory models the Alpha was quite sane. I&#x27;m not sure what you base your &#x27;weakest&#x27; on (it suggests a comparison with others) but when Alpha was released there wasn&#x27;t much to compare it to besides the R4000 and that just as hard if not harder to source than the Alpha machines were. I had a bunch of them (SGI boxes of various plumage) and the OS hardly took advantage of the chip, but on the Alpha it all just worked at 64 bits out of the box.</div><br/><div id="38159904" class="c"><input type="checkbox" id="c-38159904" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159854">parent</a><span>|</span><a href="#38159578">next</a><span>|</span><label class="collapse" for="c-38159904">[-]</label><label class="expand" for="c-38159904">[6 more]</label></div><br/><div class="children"><div class="content">&gt;I&#x27;m not sure what you base your &#x27;weakest&#x27;<p>Linux kernel has memory barriers, Alpha makes an exception with needing virtually all of them - with other architectures (esp. the total store order ones) some (most) of the barriers are nop.<p>Yet, overall Alpha is famous for how crazy the memory model is. There is nothing like any longer (personally I am happy with Java Memory Model). Just to make sure it&#x27;s understood &quot;weak&quot; attributed to :memory model: just means how concurrent with regards to reads and writes it is.<p>A quote[0]:<p><pre><code>  AND THEN THERE&#x27;S THE ALPHA
  --------------------------

  The DEC Alpha CPU is one of the most relaxed CPUs there is.  Not only that, some versions of the Alpha CPU have a split data cache, permitting them to have two semantically-related cache lines updated at separate times.  
  This is where the address-dependency barrier really becomes necessary as this synchronises both caches with the memory coherence system, thus making it seem like pointer changes vs new data occur in the right order.
</code></pre>
[0]: <a href="https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;memory-barriers.txt" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;memory-barriers.txt</a></div><br/><div id="38159933" class="c"><input type="checkbox" id="c-38159933" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159904">parent</a><span>|</span><a href="#38159578">next</a><span>|</span><label class="collapse" for="c-38159933">[-]</label><label class="expand" for="c-38159933">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what allows the Alpha to be multi-processor.<p>And if you like the &#x27;Java Memory Model&#x27; I&#x27;m not sure what your point really is, you&#x27;re comparing a virtual machine with actual hardware.</div><br/><div id="38159959" class="c"><input type="checkbox" id="c-38159959" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159933">parent</a><span>|</span><a href="#38160042">next</a><span>|</span><label class="collapse" for="c-38159959">[-]</label><label class="expand" for="c-38159959">[2 more]</label></div><br/><div class="children"><div class="content">&gt;you&#x27;re comparing a virtual machine with actual hardware.<p>The memory model is meant for developers - and how many&amp;different memory barriers they have to issue.</div><br/><div id="38160145" class="c"><input type="checkbox" id="c-38160145" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159959">parent</a><span>|</span><a href="#38160042">next</a><span>|</span><label class="collapse" for="c-38160145">[-]</label><label class="expand" for="c-38160145">[1 more]</label></div><br/><div class="children"><div class="content">Your typical Java developer has zero knowledge about this and on the UNIX versions that shipped with the Alpha (for me, at the time that was RedHat) fairly elegantly hid that complexity to the point that you could just forget about it unless you cared about extreme performance. In my case the ability to address large amounts of memory and a filesystem that wasn&#x27;t limited by the 32 bit limitation was the key factor and while it took another <i>decade</i> for x86 to catch up I was happily shipping.</div><br/></div></div></div></div><div id="38160042" class="c"><input type="checkbox" id="c-38160042" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159933">parent</a><span>|</span><a href="#38159959">prev</a><span>|</span><a href="#38159578">next</a><span>|</span><label class="collapse" for="c-38160042">[-]</label><label class="expand" for="c-38160042">[2 more]</label></div><br/><div class="children"><div class="content">The &quot;oh we can&#x27;t make the cache as big as we&#x27;d like so we just make it two fully independent banks and bake the lack of synchronization of them into the ISA&quot; in DEC Alpha very clearly falls into the &quot;baking restrictions of today into the ISA&quot;, which virtually always turns out to be a bad idea.</div><br/><div id="38160128" class="c"><input type="checkbox" id="c-38160128" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38160042">parent</a><span>|</span><a href="#38159578">next</a><span>|</span><label class="collapse" for="c-38160128">[-]</label><label class="expand" for="c-38160128">[1 more]</label></div><br/><div class="children"><div class="content">That I&#x27;ll be happy to agree with but compared to the 640 k limit it&#x27;s clearly a manageable one, and one that end users of the system normally do not have to concern themselves with.<p>I&#x27;ve written a (small) OS for x86&#x2F;32 just prior to getting my hands on an Alpha and compared to that the Alpha looked (and still looks) like a model of sanity to me (as does 68xxx). Just the number of tricks required to get an x86 system properly booted up is off the scale, you have to deal with a whole pile of memory insanity including repeated switches between modes (and memory models) in order to get your stuff even loaded. I spent weeks debugging that loader, to the point that I had a reset switch connected to a musical instrument foot pedal so I didn&#x27;t have dive under the desk 10 times per hour to reset the box I was writing this on. If not for DJGPP to validate the 32 bit code ahead of time I doubt I would have been able to bring it up at all (note this was well before VMs became a thing on consumer hardware).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38159578" class="c"><input type="checkbox" id="c-38159578" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157977">parent</a><span>|</span><a href="#38159579">prev</a><span>|</span><a href="#38156886">next</a><span>|</span><label class="collapse" for="c-38159578">[-]</label><label class="expand" for="c-38159578">[1 more]</label></div><br/><div class="children"><div class="content">DEC Alpha had the weakest memory model, which while cool to write for with its all memory barriers&#x2F;concurrency - it&#x27;s quite annoying in the real world, a major reason while DEC failed.</div><br/></div></div></div></div></div></div></div></div><div id="38156886" class="c"><input type="checkbox" id="c-38156886" checked=""/><div class="controls bullet"><span class="by">xattt</span><span>|</span><a href="#38156812">parent</a><span>|</span><a href="#38157393">prev</a><span>|</span><a href="#38157138">next</a><span>|</span><label class="collapse" for="c-38156886">[-]</label><label class="expand" for="c-38156886">[12 more]</label></div><br/><div class="children"><div class="content">What’s their hope right now? Some sort of Quark-derived desktop CPU à la Dothan?</div><br/><div id="38157032" class="c"><input type="checkbox" id="c-38157032" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38156886">parent</a><span>|</span><a href="#38156983">next</a><span>|</span><label class="collapse" for="c-38157032">[-]</label><label class="expand" for="c-38157032">[6 more]</label></div><br/><div class="children"><div class="content">Coming out with better chips at lower prices. I know how obvious that sounds but it&#x27;s true.<p>The difficulty is they need to make nearly decade-long bets that are the size of small countries economies due to the complexity of manufacturing and Intel&#x27;s made a few bad ones recently.<p>I don&#x27;t know who to listen to on what chip design will be a market win in 2030 either. AI applications are extremely resource intensive so that will be driving things for a while but how to solve that in an affordable chip created by a reliable efficient manufacturing process is beyond me. This stuff is phenomenally hard.<p>I&#x27;d say the winner is something like an NVIDIA graphics pipeline that is separated into a pile called &quot;graphics&quot; and &quot;ai&quot; and then has the graphics part gutted for a cheaper AI pipeline which can use system memory as opposed to preciously expensive graphics memory and then gets integrated into their next gen CPUs taking Nvidia out of the loop and dealing a blow to AMD at the same time. They&#x27;d mop the floors with something like that especially if you could just drop it into pytorch and have it work automagically.  They could probably then just turn around and license it to ARM.<p>AMD and Nvidia wouldn&#x27;t work together to mount a unified defense because of ATI and this would allow Intel to weasel their way back into the Apple money stream.<p>But I&#x27;m just some unemployed dude typing this on a 4 year old android. Don&#x27;t listen to me.</div><br/><div id="38157688" class="c"><input type="checkbox" id="c-38157688" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157032">parent</a><span>|</span><a href="#38157290">next</a><span>|</span><label class="collapse" for="c-38157688">[-]</label><label class="expand" for="c-38157688">[2 more]</label></div><br/><div class="children"><div class="content">Isn’t AI usually highly memory-bandwidth constrained?  Designing a new powerful AI chip to rely on slow memory probably isn’t the best strategy.</div><br/><div id="38158060" class="c"><input type="checkbox" id="c-38158060" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157688">parent</a><span>|</span><a href="#38157290">next</a><span>|</span><label class="collapse" for="c-38158060">[-]</label><label class="expand" for="c-38158060">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d imagine when the AI dust clears there&#x27;s going to be consumer and producer sides of AI and the consumer requirements will be a carveout of the producer.<p>This just appears to be the case with everything else. Making a video game, movie, song, computer program, etc, requires more resources than using one and there was a significant price delta between them for a long time.</div><br/></div></div></div></div><div id="38157290" class="c"><input type="checkbox" id="c-38157290" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157032">parent</a><span>|</span><a href="#38157688">prev</a><span>|</span><a href="#38156983">next</a><span>|</span><label class="collapse" for="c-38157290">[-]</label><label class="expand" for="c-38157290">[3 more]</label></div><br/><div class="children"><div class="content">wouldn’t graphics and AI both pretty much reduce to mad matrix operations?</div><br/><div id="38157414" class="c"><input type="checkbox" id="c-38157414" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157290">parent</a><span>|</span><a href="#38157375">next</a><span>|</span><label class="collapse" for="c-38157414">[-]</label><label class="expand" for="c-38157414">[1 more]</label></div><br/><div class="children"><div class="content">Things like hardware raytracing probably aren&#x27;t needed and there&#x27;s shading units, texture mapping, and ROPs. I&#x27;m not a hardware engineer but there&#x27;s probably some way Intel can rejigger its IGT (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_Graphics_Technology" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_Graphics_Technology</a>) to have the equivalent of Nvidia&#x27;s &quot;tensor cores&quot;.<p>They have an NVIDIA mainline competitor in their A770 but I think they should be exiting the direct nvidia assault strategy. I really don&#x27;t know how that&#x27;s going to work. They&#x27;re basically a nonplayer <a href="https:&#x2F;&#x2F;www.videocardbenchmark.net&#x2F;high_end_gpus.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.videocardbenchmark.net&#x2F;high_end_gpus.html</a><p>What&#x27;s their winning move in that approach? It&#x27;s just money in a volcano.</div><br/></div></div><div id="38157375" class="c"><input type="checkbox" id="c-38157375" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157290">parent</a><span>|</span><a href="#38157414">prev</a><span>|</span><a href="#38156983">next</a><span>|</span><label class="collapse" for="c-38157375">[-]</label><label class="expand" for="c-38157375">[1 more]</label></div><br/><div class="children"><div class="content">Graphics has more than that between texture pipelines, ROPs, more complex compute dispatch than needed for AI, etc.  All of that comes with area and power costs even if you clock gate the blocks you can.</div><br/></div></div></div></div></div></div><div id="38156983" class="c"><input type="checkbox" id="c-38156983" checked=""/><div class="controls bullet"><span class="by">scrlk</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38156886">parent</a><span>|</span><a href="#38157032">prev</a><span>|</span><a href="#38157844">next</a><span>|</span><label class="collapse" for="c-38156983">[-]</label><label class="expand" for="c-38156983">[2 more]</label></div><br/><div class="children"><div class="content">Doubling down on becoming a competitive foundry and becoming the western equivalent to TSMC. If their 18A process ships on time (2025), there&#x27;s a chance that they could regain process leadership.</div><br/><div id="38159580" class="c"><input type="checkbox" id="c-38159580" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38156983">parent</a><span>|</span><a href="#38157844">next</a><span>|</span><label class="collapse" for="c-38159580">[-]</label><label class="expand" for="c-38159580">[1 more]</label></div><br/><div class="children"><div class="content">Fingers crossed but they don’t have a good track record in the last 10 years. The world needs at least two good processes.</div><br/></div></div></div></div><div id="38157844" class="c"><input type="checkbox" id="c-38157844" checked=""/><div class="controls bullet"><span class="by">cmrdporcupine</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38156886">parent</a><span>|</span><a href="#38156983">prev</a><span>|</span><a href="#38157138">next</a><span>|</span><label class="collapse" for="c-38157844">[-]</label><label class="expand" for="c-38157844">[3 more]</label></div><br/><div class="children"><div class="content">Imagine they got into making an ARM CPU competitive with Apple&#x27;s? Or a server chip that is better than Ampera&#x27;s, and sold at scale? I think they have the expertise and ability to do it.</div><br/><div id="38158155" class="c"><input type="checkbox" id="c-38158155" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157844">parent</a><span>|</span><a href="#38157138">next</a><span>|</span><label class="collapse" for="c-38158155">[-]</label><label class="expand" for="c-38158155">[2 more]</label></div><br/><div class="children"><div class="content">A dual-mode ARM-x86 core would be an interesting CPU that they certainly have the skill to create. Thanks to the protected mode descriptor model, imagine having ARM64, ARM32, x86-32, and x86-64 code segments all coexisting in the same system, with no emulation nor virtualisation. There wouldn&#x27;t be any overhead, because all instructions regardless of ISA get translated to uops anyway. They could add a RISC-V front-end too, just for completeness sake.</div><br/><div id="38159810" class="c"><input type="checkbox" id="c-38159810" checked=""/><div class="controls bullet"><span class="by">mratsim</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158155">parent</a><span>|</span><a href="#38157138">next</a><span>|</span><label class="collapse" for="c-38159810">[-]</label><label class="expand" for="c-38159810">[1 more]</label></div><br/><div class="children"><div class="content">That sounds like dev and user experience nightmare.</div><br/></div></div></div></div></div></div></div></div><div id="38157138" class="c"><input type="checkbox" id="c-38157138" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38156812">parent</a><span>|</span><a href="#38156886">prev</a><span>|</span><a href="#38158592">next</a><span>|</span><label class="collapse" for="c-38157138">[-]</label><label class="expand" for="c-38157138">[22 more]</label></div><br/><div class="children"><div class="content">&gt; and getting slaughtered in their only remaining stronghold by NVIDIA, AMD and ARM pillaging their castle<p>NVIDIA doesn&#x27;t make good CPUs, even their SoCs are ... not exactly state of the art. No mass market adoption besides automotive who don&#x27;t care about anything but long availability of (spare) parts and the Nintendo Switch which likely only still uses the same 2015-era Tegra chipset because even someone as big as Nintendo couldn&#x27;t kick enough arses at NVIDIA to bring up a new design. ARM doesn&#x27;t make generally available server CPUs (the ones that do exist all get gobbled up by cloud providers), and there are outside of the Mac world no viable ARM desktop or laptop CPUs because Qualcomm completely fucked up that market for likely years to come - I don&#x27;t see <i>any</i> way of ARM adoption in that market unless ARM comes up with a competing solution to Rosetta <i>and</i> Qualcomm comes out of the mindset &quot;if it works just barely, ship it&quot; that may be acceptable to smartphone vendors but not the PC&#x2F;desktop market.<p>That leaves AMD as the sole remaining threat to Intel, and AMD doesn&#x27;t have the fab space to be enough of a threat to Intel&#x27;s moat.<p>Yes, I may or may not be extremely frustrated at the state of competition in general computing.</div><br/><div id="38157618" class="c"><input type="checkbox" id="c-38157618" checked=""/><div class="controls bullet"><span class="by">flykespice</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157138">parent</a><span>|</span><a href="#38157222">next</a><span>|</span><label class="collapse" for="c-38157618">[-]</label><label class="expand" for="c-38157618">[1 more]</label></div><br/><div class="children"><div class="content">&gt; there are outside of the Mac world no viable ARM desktop or laptop CPUs because Qualcomm completely fucked up that market for likely years to come<p>Huh citation needed? I would like to know more context on that</div><br/></div></div><div id="38157222" class="c"><input type="checkbox" id="c-38157222" checked=""/><div class="controls bullet"><span class="by">kristopolous</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157138">parent</a><span>|</span><a href="#38157618">prev</a><span>|</span><a href="#38158592">next</a><span>|</span><label class="collapse" for="c-38157222">[-]</label><label class="expand" for="c-38157222">[20 more]</label></div><br/><div class="children"><div class="content">Arm snatched Intel&#x27;s hold on the Apple market and we can invoke any Clayton Christensen book on the Raspberry PI series. Maybe not the Raspberry PI 5, but what about say, the imaginary 8 or the 9 a few years hence?<p>The Pi 400 isn&#x27;t their final attempt into the PC market, only their first. Surely a slew of decent ARM based laptops from one of these SBC manufacturers is coming along eventually - and I don&#x27;t mean chromebooks.</div><br/><div id="38159870" class="c"><input type="checkbox" id="c-38159870" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157222">parent</a><span>|</span><a href="#38157270">next</a><span>|</span><label class="collapse" for="c-38159870">[-]</label><label class="expand" for="c-38159870">[1 more]</label></div><br/><div class="children"><div class="content">I have a Pi 400 here and for the money it&#x27;s most impressive. It runs pretty much the whole house in terms of heating and power management, with full autonomy using HA and a very limited bit of custom stuff. You can stick in anything at all and it &#x27;just works&#x27; the only things that have given me a headache are Zigbee dongles, everything else worked without issue.</div><br/></div></div><div id="38157270" class="c"><input type="checkbox" id="c-38157270" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157222">parent</a><span>|</span><a href="#38159870">prev</a><span>|</span><a href="#38158592">next</a><span>|</span><label class="collapse" for="c-38157270">[-]</label><label class="expand" for="c-38157270">[18 more]</label></div><br/><div class="children"><div class="content">Yeah but that was only made possible by Apple&#x27;s unique circumstances: their close control over the <i>entire</i> tech stack, their experience with architecture transitions (PPC-&gt;x86-32-&gt;x86-64-&gt;ARM) and the required tooling (Rosetta, fat binaries, compilers), their relatively small market size, their expertise in developing with&#x2F;for ARM from iOS, and enough cash in hand to buy out the entire fab capacity of TSMC.<p>In the Windows world, <i>no one</i> holds even closely to the capabilities required for a transition to ARM: Microsoft doesn&#x27;t have a fat binary standard or the toolchains needed (that all went down the drain with the end of Microsoft Windows CE &#x2F; Windows Phone and even then, it was a nightmare to develop for these), the third party developers - especially the enterprise tailor-made application market - have zero experience with ARM and a lot of stuff used in enterprise was made by companies that went defunct long ago, Microsoft doesn&#x27;t have any hold over what the device vendors do in terms of drivers (unlike Apple, who famously cut ties with NVIDIA because NV didn&#x27;t want Apple to write drivers for their GPUs), and neither Microsoft itself nor the conglomerate of hardware OEMs has the cash in hand to take all the stuff people use on x86 Windows and make it work on ARM Windows (as they infamously discovered with the early Windows Qualcomm stuff). Oh, and the ARM vendors can&#x27;t be bothered to get something as basic as PCIe working on a fundamental level beyond &quot;if it works in my very specific use case, ship it&quot; - just look at the RPi 4&#x27;s issues where people developed breakout boards for PCIe only to discover that crucial functionality was flat out broken [1]. And even with people complaining for years about PCIe issues on the Pi 4, turns out the Pi 5 <i>still</i> managed to fuck things up [2].<p>The only player in town able to make ARM work on anything but smartphones and servers is Apple, and they don&#x27;t (and never will, assuming regulators don&#x27;t finally wake up and force them) sell to third parties.<p>&gt; The Pi 400 isn&#x27;t their final attempt into the PC market, only their first. Surely a slew of decent ARM based laptops from one of these SBC manufacturers is coming along eventually - and I don&#x27;t mean chromebooks.<p>These things are and will be <i>toys</i>. The money is in getting corporate to switch over to ARM and until the problems above (especially backwards compatibility and standards conformance) are worked out, which I don&#x27;t see happen any time soon because it&#x27;s so hard to break through the chicken-egg scenario, there will be no threat to Intel. Especially not if even many years of development and complaining are not enough to arse Broadcom into fixing PCIe.<p>[1] <a href="https:&#x2F;&#x2F;www.jeffgeerling.com&#x2F;blog&#x2F;2023&#x2F;i-built-special-pcie-card-test-gpus-on-pi" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jeffgeerling.com&#x2F;blog&#x2F;2023&#x2F;i-built-special-pcie-...</a><p>[2] <a href="https:&#x2F;&#x2F;www.jeffgeerling.com&#x2F;blog&#x2F;2023&#x2F;testing-pcie-on-raspberry-pi-5" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.jeffgeerling.com&#x2F;blog&#x2F;2023&#x2F;testing-pcie-on-raspb...</a></div><br/><div id="38159716" class="c"><input type="checkbox" id="c-38159716" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157270">parent</a><span>|</span><a href="#38157439">next</a><span>|</span><label class="collapse" for="c-38159716">[-]</label><label class="expand" for="c-38159716">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft has a now an hybrid format for ARM&#x2F;x64, Arm64EC.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;arm&#x2F;arm64ec" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;arm&#x2F;arm64ec</a><p>Besides Windows NT has been designed and used for multiple architectures for years, Windows CE and Pocket PC were not the only ones with ARM support, Windows IoT and the original Windows 8 WinRT tablets did as well.<p>The biggest issue is lack of incentives, for most business there is no ROI to install ARM compilers alongside x64 for .NET and C++ toolchains, and yet another set of architectures to debug on, and take into consideration.<p>It is as you say, unless they behave like Apple or Google, imposing a transition, most of those companies won&#x27;t care.<p>They have recently putted out a kind of ARM porting help center, but I doubt it will make any impact.<p><a href="https:&#x2F;&#x2F;blogs.windows.com&#x2F;windowsdeveloper&#x2F;2023&#x2F;10&#x2F;16&#x2F;windows-launching-arm-advisory-service-for-developers&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blogs.windows.com&#x2F;windowsdeveloper&#x2F;2023&#x2F;10&#x2F;16&#x2F;window...</a></div><br/></div></div><div id="38157439" class="c"><input type="checkbox" id="c-38157439" checked=""/><div class="controls bullet"><span class="by">FirmwareBurner</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157270">parent</a><span>|</span><a href="#38159716">prev</a><span>|</span><a href="#38157502">next</a><span>|</span><label class="collapse" for="c-38157439">[-]</label><label class="expand" for="c-38157439">[14 more]</label></div><br/><div class="children"><div class="content">You&#x27;re wrong about Microsoft here. They too have loads of experience developing their SW for multiple architectures, even moreso than Apple.<p>Windows NT shipped on about 7 or so architectures including PowerPC for the Xbox360. And they also have experience with emulation, that&#x27;s how they got Xbox 360 emulation on the newer X86 models. Just read their papers on arch emulation.<p>What they don&#x27;t have and Apple has is 10+ experience in shipping tailor made ARM chips fit to their needs, because they always left chip design to their partners, as they were always a SW company first not a HW product company like Apple, and this isn&#x27;t something they can start and catch up with in the snap of a finger.</div><br/><div id="38157540" class="c"><input type="checkbox" id="c-38157540" checked=""/><div class="controls bullet"><span class="by">hakfoo</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157439">parent</a><span>|</span><a href="#38159724">next</a><span>|</span><label class="collapse" for="c-38157540">[-]</label><label class="expand" for="c-38157540">[6 more]</label></div><br/><div class="children"><div class="content">The problem isn&#x27;t even building NT for ARM&#x2F;RISC-V&#x2F;SH-4 or whatever, it&#x27;s being able to reproduce enough of the surrounding universe that Windows on x86-64 has.<p>Apple has more leverage over devs; they can say &quot;No more x86-64 in N years&quot; and the developers basically have to move to ARM or abandon MacOS.  This bootstraps the market; people who want MacOS have to suck it in and buy ARM because it&#x27;s the only new hardware we&#x27;ll be seeing in the future.<p>Microsoft doesn&#x27;t control the hardware sector to put a hard deadline on new x86-64 products, and it would be suicidal to cut off the x86-64 software support at any time in the near future.<p>This means we&#x27;ll see new x86-64 Windows machines in the store, and all the third-party apps supporting x86-64 Windows, for years to come.  So as a consumer, why would I want an ARM-Windows machine?  It has little exclusive software, is likely buggier and less mature, and probably runs the vast majority of x86-64 software in an emulation penalty box.</div><br/><div id="38159722" class="c"><input type="checkbox" id="c-38159722" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157540">parent</a><span>|</span><a href="#38158118">next</a><span>|</span><label class="collapse" for="c-38159722">[-]</label><label class="expand" for="c-38159722">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using an ARM Windows machine as a daily driver (when I&#x27;m traveling) for a year. I do that because it has much better battery life than any similar Intel machine, and it has integrated 4G.</div><br/><div id="38159878" class="c"><input type="checkbox" id="c-38159878" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159722">parent</a><span>|</span><a href="#38158118">next</a><span>|</span><label class="collapse" for="c-38159878">[-]</label><label class="expand" for="c-38159878">[1 more]</label></div><br/><div class="children"><div class="content">How is the software support for that? What kind of machine do you have?</div><br/></div></div></div></div><div id="38158118" class="c"><input type="checkbox" id="c-38158118" checked=""/><div class="controls bullet"><span class="by">bigstrat2003</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157540">parent</a><span>|</span><a href="#38159722">prev</a><span>|</span><a href="#38157758">next</a><span>|</span><label class="collapse" for="c-38158118">[-]</label><label class="expand" for="c-38158118">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Apple has more leverage over devs; they can say &quot;No more x86-64 in N years&quot; and the developers basically have to move to ARM or abandon MacOS.<p>I think Microsoft could do the same thing as far as devs go. If Apple can exert that influence over devs with their extreme minority market share, I think MS could too. The problem for MS is their customers. Apple customers will buy whatever Apple puts out, because they&#x27;re extremely loyal to the brand. The same isn&#x27;t true for Microsoft, and I imagine that pressure would cause them to fold on any major changes.</div><br/><div id="38159610" class="c"><input type="checkbox" id="c-38159610" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158118">parent</a><span>|</span><a href="#38157758">next</a><span>|</span><label class="collapse" for="c-38159610">[-]</label><label class="expand" for="c-38159610">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I think Microsoft could do the same thing as far as devs go<p>That&#x27;s absolutely unrealistic. The main Windows part is the backward compatibility + the corporates. Nowadays Microsoft develops stuff written in Javascript, not their own frameworks, even.</div><br/></div></div></div></div><div id="38157758" class="c"><input type="checkbox" id="c-38157758" checked=""/><div class="controls bullet"><span class="by">dzonga</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157540">parent</a><span>|</span><a href="#38158118">prev</a><span>|</span><a href="#38159724">next</a><span>|</span><label class="collapse" for="c-38157758">[-]</label><label class="expand" for="c-38157758">[1 more]</label></div><br/><div class="children"><div class="content">yeah, I wouldn&#x27;t count microsoft or intel out.<p>arm cpu performance advantages at low power are great. i&#x27;m typing this on an m2.<p>but i&#x27;m sure intel will figure out how to have great cpu&#x27;s at low power draws that perform well. amd already did. so i&#x27;m sure intel will.</div><br/></div></div></div></div><div id="38159724" class="c"><input type="checkbox" id="c-38159724" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157439">parent</a><span>|</span><a href="#38157540">prev</a><span>|</span><a href="#38158387">next</a><span>|</span><label class="collapse" for="c-38159724">[-]</label><label class="expand" for="c-38159724">[1 more]</label></div><br/><div class="children"><div class="content">That is not the issue, rather convincing the Windows developer community to actually care about ARM.<p>Traditionally Microsoft isn&#x27;t like the others (Apple&#x2F;Google), &quot;take this or go away&quot;, which is why they became so big for enterprises in first place.</div><br/></div></div><div id="38158387" class="c"><input type="checkbox" id="c-38158387" checked=""/><div class="controls bullet"><span class="by">ack_complete</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157439">parent</a><span>|</span><a href="#38159724">prev</a><span>|</span><a href="#38157496">next</a><span>|</span><label class="collapse" for="c-38158387">[-]</label><label class="expand" for="c-38158387">[2 more]</label></div><br/><div class="children"><div class="content">They do have lots of experience porting Windows to multiple platforms. They don&#x27;t have very good experience managing the user experience of Windows transitioning between platforms.<p>I was one of the early adopters of Windows on ARM, the Windows 10 native port to ARM64 (ARMv8). At release, practically the only native development tool was WinDbg -- neither Visual Studio nor Windows Performance Analyzer had been ported. You could install Visual Studio in x86 emulation mode but it wouldn&#x27;t run reliably as the toolchain would keep throwing heap errors, so cross-compilation was required and debugging was harder. There was basically zero information about what was and wasn&#x27;t supported -- you&#x27;d just start porting and run into something like there being no OpenGL acceleration support. Or even more fun, that there was no ARM64 version of the Visual C++ Redistributable published, so you couldn&#x27;t distribute a program that was dynamically linked to the CRT -- and the Visual Studio support staff didn&#x27;t even know what ARM64 was and pointed to the x64 redist. This didn&#x27;t start getting ironed out until around three months after Windows on ARM machines had started shipping.<p>And assuming you got past these problems, Windows has no universal binary system, so it&#x27;s your job to figure out how to properly get the right platform executable installed and launched without any support from the OS. This was really bad in the early days of x64, where XP would just say &quot;invalid executable&quot; when trying to launch a x64 program on x86; these days it displays a slightly less cryptic &quot;Machine Type Mismatch&quot; error dialog with no further help.<p>Microsoft is trying to fix these problems now, but they&#x27;re years late and the amount of software available as native ARM64 is still very low. Oh, and they already dropped support for the early gen Snapdragon 835 and 850 devices in Windows 11, which means no x64 emulation or ARM64EC support, and an even tinier effective market. In contrast, Apple managed the ARM transition much, much better -- they had native tooling, documentation, and development systems lined up in advance and a much more polished user experience on day one.</div><br/><div id="38159755" class="c"><input type="checkbox" id="c-38159755" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38158387">parent</a><span>|</span><a href="#38157496">next</a><span>|</span><label class="collapse" for="c-38159755">[-]</label><label class="expand" for="c-38159755">[1 more]</label></div><br/><div class="children"><div class="content">Are you sure regarding ARM64EC? I doubt that they are dropping it any time soon, specially when they just announced the Arm Advisory Service.</div><br/></div></div></div></div><div id="38157496" class="c"><input type="checkbox" id="c-38157496" checked=""/><div class="controls bullet"><span class="by">mschuster91</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157439">parent</a><span>|</span><a href="#38158387">prev</a><span>|</span><a href="#38157502">next</a><span>|</span><label class="collapse" for="c-38157496">[-]</label><label class="expand" for="c-38157496">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Windows NT shipped on about 7 or so architectures including PowerPC for the Xbox360. And they also have experience with emulation, that&#x27;s how they got Xbox 360 emulation on the newer X86 models.<p>The entire NT stuff has gone down the drain. The last non-x86 platforms were dropped around 2000 [1] until ARM entered the picture in 2012, but the latter was mostly used for Windows Phone for many years which itself got discontinued around 2017.<p>All these many thousand human-years of experience have long ago retired or went to other companies, their institutional knowledge is effectively lost for Microsoft. And <i>that</i> is the problem.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_NT#Supported_platforms" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Windows_NT#Supported_platforms</a></div><br/><div id="38159811" class="c"><input type="checkbox" id="c-38159811" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157496">parent</a><span>|</span><a href="#38159729">next</a><span>|</span><label class="collapse" for="c-38159811">[-]</label><label class="expand" for="c-38159811">[1 more]</label></div><br/><div class="children"><div class="content">Windows 2000 shipped with x86 support only. But just one year later, Windows XP had an Itanic port at launch.</div><br/></div></div><div id="38159729" class="c"><input type="checkbox" id="c-38159729" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157496">parent</a><span>|</span><a href="#38159811">prev</a><span>|</span><a href="#38157502">next</a><span>|</span><label class="collapse" for="c-38159729">[-]</label><label class="expand" for="c-38159729">[2 more]</label></div><br/><div class="children"><div class="content">Cutler is still there :)</div><br/><div id="38159780" class="c"><input type="checkbox" id="c-38159780" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38159729">parent</a><span>|</span><a href="#38157502">next</a><span>|</span><label class="collapse" for="c-38159780">[-]</label><label class="expand" for="c-38159780">[1 more]</label></div><br/><div class="children"><div class="content">As per his last interview, nowadays busy porting GNU&#x2F;Linux into XBox running on Azure, for AI workloads when they are idle.<p>Somehow there is a certain irony on that.</div><br/></div></div></div></div></div></div></div></div><div id="38157502" class="c"><input type="checkbox" id="c-38157502" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157270">parent</a><span>|</span><a href="#38157439">prev</a><span>|</span><a href="#38158592">next</a><span>|</span><label class="collapse" for="c-38157502">[-]</label><label class="expand" for="c-38157502">[2 more]</label></div><br/><div class="children"><div class="content">&gt; These things are and will be <i>toys</i>.<p>Heh, <a href="https:&#x2F;&#x2F;cdixon.org&#x2F;2010&#x2F;01&#x2F;03&#x2F;the-next-big-thing-will-start-out-looking-like-a-toy" rel="nofollow noreferrer">https:&#x2F;&#x2F;cdixon.org&#x2F;2010&#x2F;01&#x2F;03&#x2F;the-next-big-thing-will-start-...</a><p>«The reason big new things sneak by incumbents is that the next big thing always starts out being dismissed as a “toy.”  This is one of the main insights of Clay Christensen’s “disruptive technology” theory.»<p>Tho Raspberry Pi computers are designed to a low price point, so they are aiming for the low end not the high end. But the 5 is about as powerful as the last-generation Intel MacBooks, despite using fairly old Arm cores. I don’t think they can be casually dismissed.</div><br/><div id="38158438" class="c"><input type="checkbox" id="c-38158438" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#38156812">root</a><span>|</span><a href="#38157502">parent</a><span>|</span><a href="#38158592">next</a><span>|</span><label class="collapse" for="c-38158438">[-]</label><label class="expand" for="c-38158438">[1 more]</label></div><br/><div class="children"><div class="content">I still have an original RPi model B serving as a PiHole for my home network. It never was a toy.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38158592" class="c"><input type="checkbox" id="c-38158592" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#38156812">prev</a><span>|</span><a href="#38158599">next</a><span>|</span><label class="collapse" for="c-38158592">[-]</label><label class="expand" for="c-38158592">[3 more]</label></div><br/><div class="children"><div class="content">I really wish people would stop applying the &quot;flat 32-bit&quot; revisionist history to the 386. That wasn&#x27;t its obvious target, but rather picking up the important &quot;capability&quot; arch features which were seen as the future before unix&#x2F;c&#x2F;risc&#x2F;single supervisor&#x2F;ideas destroyed the previous 30 years of mainframe&#x2F;minicomputer OS research in things like security.<p>So, what this article fails to really clarify is that the segment registers were now basically &quot;selector&quot; indexes into tables with base+length (in either pages or bytes) fields, execution permission controls. And these selectors and the GDT&#x2F;LDT&#x2F;IDT&#x2F;TSS&#x2F;call gates&#x2F;task gates&#x2F;etc were all designed to support OSs with a 4 level permissions hierarchy, user&#x2F;library&#x2F;driver&#x2F;kernel (or similar), passing around access selectors which could do things like enforce the size of data structures, etc. And to support this, they added FS&#x2F;GS so that all the general purpose registers could have their own permissions masks.<p>Pause for a moment and consider that again, Pointers (capabilities, aka selectors) can have not only a base address, but a hardware enforced limit, along with a permissions model that means a function like strcpy() would be incapable of writing to any memory that wasn&#x27;t the target buffer or part of its own scratch space. Languages&#x2F;os&#x27;s could have enforced that called functions were unable to write to the callers stack, or even possibly run in their own completely separate stack. And that is just the beginning.<p>So, here nearly 40 years later the industry is still trying to recover from the mistakes of designing OS&#x27;s and programming languages around flat memory models and simplistic user&#x2F;supervisor permissions models. The 386 provided hardware assistance for writing OS&#x27;s features that to this day aren&#x27;t common.<p>ex: see CHERI.</div><br/><div id="38159422" class="c"><input type="checkbox" id="c-38159422" checked=""/><div class="controls bullet"><span class="by">bonzini</span><span>|</span><a href="#38158592">parent</a><span>|</span><a href="#38159738">next</a><span>|</span><label class="collapse" for="c-38159422">[-]</label><label class="expand" for="c-38159422">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Pointers (capabilities, aka selectors) can have not only a base address, but a hardware enforced limit<p>There are only 8k possible pointers in the LDT, plus 8k in the GDT. The x86 segmented model isn&#x27;t really suitable for implementing capabilities.</div><br/></div></div><div id="38159738" class="c"><input type="checkbox" id="c-38159738" checked=""/><div class="controls bullet"><span class="by">nezirus</span><span>|</span><a href="#38158592">parent</a><span>|</span><a href="#38159422">prev</a><span>|</span><a href="#38158599">next</a><span>|</span><label class="collapse" for="c-38159738">[-]</label><label class="expand" for="c-38159738">[1 more]</label></div><br/><div class="children"><div class="content">It been long since I have stopped following grsecurity, but I would not be surprised if segment registers are still used (e.g. Pax UDEREF)<p><a href="https:&#x2F;&#x2F;forums.grsecurity.net&#x2F;viewtopic.php?f=7&amp;t=3046" rel="nofollow noreferrer">https:&#x2F;&#x2F;forums.grsecurity.net&#x2F;viewtopic.php?f=7&amp;t=3046</a><p><a href="https:&#x2F;&#x2F;pax.grsecurity.net&#x2F;docs&#x2F;PaXTeam-H2HC12-PaX-kernel-self-protection.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;pax.grsecurity.net&#x2F;docs&#x2F;PaXTeam-H2HC12-PaX-kernel-se...</a></div><br/></div></div></div></div><div id="38158599" class="c"><input type="checkbox" id="c-38158599" checked=""/><div class="controls bullet"><span class="by">StillBored</span><span>|</span><a href="#38158592">prev</a><span>|</span><a href="#38158540">next</a><span>|</span><label class="collapse" for="c-38158599">[-]</label><label class="expand" for="c-38158599">[1 more]</label></div><br/><div class="children"><div class="content">Its nice that the 286 gets some love here too, that chip was really underrated considering how much better its IPC was vs its predecessors, which is largely the main ding against the 386. Running existing 16 bit code its IPC was basically the same as the 286, and given its initial 12Mhz clock rate, was pretty underwhelming. It wasn&#x27;t until the clock really started to scale and people started using the 32-bit capabilities that it was anything more than an expensive dos&#x2F;286 competitor.</div><br/></div></div><div id="38158540" class="c"><input type="checkbox" id="c-38158540" checked=""/><div class="controls bullet"><span class="by">sombragris</span><span>|</span><a href="#38158599">prev</a><span>|</span><a href="#38160002">next</a><span>|</span><label class="collapse" for="c-38158540">[-]</label><label class="expand" for="c-38158540">[1 more]</label></div><br/><div class="children"><div class="content">I want to stress how important the 386SX was. My dad wanted a PC for me and asked a friend to build a 286 clone. My friend gave us instead a 386SX. &quot;It&#x27;s about the same price as an 286 but what you&#x27;re getting now is a 32-bit CPU, make no mistake about it&quot;, he said, and he was right. I was able to run Win 3.11 with it. A 32-bit CPU for the price of a 286 and thus quite affordable? That was genius.</div><br/></div></div><div id="38160002" class="c"><input type="checkbox" id="c-38160002" checked=""/><div class="controls bullet"><span class="by">hulitu</span><span>|</span><a href="#38158540">prev</a><span>|</span><a href="#38157495">next</a><span>|</span><label class="collapse" for="c-38160002">[-]</label><label class="expand" for="c-38160002">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m shocked nobody mentions it: 386 added the turbo button.</div><br/></div></div><div id="38157495" class="c"><input type="checkbox" id="c-38157495" checked=""/><div class="controls bullet"><span class="by">HankB99</span><span>|</span><a href="#38160002">prev</a><span>|</span><a href="#38157550">next</a><span>|</span><label class="collapse" for="c-38157495">[-]</label><label class="expand" for="c-38157495">[1 more]</label></div><br/><div class="children"><div class="content">The &#x27;386 was the first in that line to support demand paged virtual memory which opened up a lot of things an OS could do. IMO that&#x27;s the most important thing the &#x27;386 provided. My second PC was a &#x27;386 that ran SCO UNIX. (First was an 8080 based Heathkit H-8 that ran CP&#x2F;M.)</div><br/></div></div><div id="38157550" class="c"><input type="checkbox" id="c-38157550" checked=""/><div class="controls bullet"><span class="by">blakespot</span><span>|</span><a href="#38157495">prev</a><span>|</span><a href="#38157219">next</a><span>|</span><label class="collapse" for="c-38157550">[-]</label><label class="expand" for="c-38157550">[3 more]</label></div><br/><div class="children"><div class="content">Interestingly, I&#x27;ve never owned a 386. I was not much of a DOS&#x2F;Win PC person until 1994, when I got a 486 to run NEXTSTEP. I&#x27;ve had an i8088, NEC V20, i80286, i80486, AMD 5x86, P4, and then on with the Mac starting in 2006 with (well, just before) Intel Core microarch. In those early days I was more Amiga, ST, etc. ( <a href="https:&#x2F;&#x2F;bytecellar.com&#x2F;the-list&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;bytecellar.com&#x2F;the-list&#x2F;</a> )<p>I felt more spiritually connected to the MC68K line back when, for lack of a better term.<p>Amusingly the i386 system I spent the most time with was in college in 1993&#x2F;4 on a Sun 386 tower running SunOS or Solaris in the APCS lab.</div><br/><div id="38157695" class="c"><input type="checkbox" id="c-38157695" checked=""/><div class="controls bullet"><span class="by">TristanBall</span><span>|</span><a href="#38157550">parent</a><span>|</span><a href="#38157219">next</a><span>|</span><label class="collapse" for="c-38157695">[-]</label><label class="expand" for="c-38157695">[2 more]</label></div><br/><div class="children"><div class="content">While I got the 80386 programmers manual as one of my teen birthday presents.. I only ever actually did a little ASM programming but I loved that book anyway and read it a lot.<p>Really annoyed at myself that I got rid of in some fit of &quot;well, I&#x27;ll never use that again&quot; cleaning some time.. especially given somehow still have &quot;Sendmail, edition 2&quot;.<p>I might read the 386 book for nostalgia.. the Sendmail one..well, PTSD isn&#x27;t something you get nostalgic about!</div><br/><div id="38159556" class="c"><input type="checkbox" id="c-38159556" checked=""/><div class="controls bullet"><span class="by">steve1977</span><span>|</span><a href="#38157550">root</a><span>|</span><a href="#38157695">parent</a><span>|</span><a href="#38157219">next</a><span>|</span><label class="collapse" for="c-38159556">[-]</label><label class="expand" for="c-38159556">[1 more]</label></div><br/><div class="children"><div class="content">I’ll dream in M4 tonight, thank you…</div><br/></div></div></div></div></div></div><div id="38157219" class="c"><input type="checkbox" id="c-38157219" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#38157550">prev</a><span>|</span><a href="#38157621">next</a><span>|</span><label class="collapse" for="c-38157219">[-]</label><label class="expand" for="c-38157219">[1 more]</label></div><br/><div class="children"><div class="content">The 386 was released shortly before I bought my first computer as a teen. At the time, I saw both 286 and 386 PC&#x27;s on the market, but the latter with a large price premium. I wasn&#x27;t sure what the difference was at the time, so I bought the 286 system. Within a couple of years I had learned the difference and had large regret I didn&#x27;t save my money and buy a 386. Shortly after that, I started writing low level assembler including the system bootstrap for a toy OS, which now could not use 32-bit protected mode. In addition, 386-only games started to be released at some point, and so I very much felt left out until I bought my first 486, but that wasn&#x27;t until years later.</div><br/></div></div><div id="38157621" class="c"><input type="checkbox" id="c-38157621" checked=""/><div class="controls bullet"><span class="by">selimnairb</span><span>|</span><a href="#38157219">prev</a><span>|</span><a href="#38158678">next</a><span>|</span><label class="collapse" for="c-38157621">[-]</label><label class="expand" for="c-38157621">[2 more]</label></div><br/><div class="children"><div class="content">Nice write-up. Re-reading about the evolution and complexity of x86 makes me wonder about attempts to modernize x86. Does anyone know how Intel’s x86-S proposal to do a cleaned-up 64-bit architecture has been received? I looked for updates in the media but haven’t been able to find anything.</div><br/><div id="38158836" class="c"><input type="checkbox" id="c-38158836" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#38157621">parent</a><span>|</span><a href="#38158678">next</a><span>|</span><label class="collapse" for="c-38158836">[-]</label><label class="expand" for="c-38158836">[1 more]</label></div><br/><div class="children"><div class="content">I seem to remember I didn’t think it was radical enough but a good start.</div><br/></div></div></div></div><div id="38158678" class="c"><input type="checkbox" id="c-38158678" checked=""/><div class="controls bullet"><span class="by">doubloon</span><span>|</span><a href="#38157621">prev</a><span>|</span><a href="#38157279">next</a><span>|</span><label class="collapse" for="c-38158678">[-]</label><label class="expand" for="c-38158678">[1 more]</label></div><br/><div class="children"><div class="content">So many times it is some small   team working on a unknown disregarded project, from fallout to the mac intel transition, that a company is saved by. The best companies surely must know this and knowing it, allow these tiny disregarded projects to exist on purpose.</div><br/></div></div><div id="38157279" class="c"><input type="checkbox" id="c-38157279" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#38158678">prev</a><span>|</span><a href="#38157210">next</a><span>|</span><label class="collapse" for="c-38157279">[-]</label><label class="expand" for="c-38157279">[6 more]</label></div><br/><div class="children"><div class="content">The 80386 DX was a revolutionary CPU. It certainly foreshadowed the  486 and ultimately the Pentium. Most people I know only had a 80386 SX which was still revolutionary but it hid it well by being essentially a glorified (but slower) 80286 on the outside.</div><br/><div id="38157356" class="c"><input type="checkbox" id="c-38157356" checked=""/><div class="controls bullet"><span class="by">nu11ptr</span><span>|</span><a href="#38157279">parent</a><span>|</span><a href="#38158068">next</a><span>|</span><label class="collapse" for="c-38157356">[-]</label><label class="expand" for="c-38157356">[1 more]</label></div><br/><div class="children"><div class="content">The SX may have been slower, but it could still run all 386 software which was a huge advantage over the 286. I had a 16MHz 286 and I so badly wanted a 386SX 16Mhz so I could run 32-bit software.</div><br/></div></div><div id="38158068" class="c"><input type="checkbox" id="c-38158068" checked=""/><div class="controls bullet"><span class="by">icedchai</span><span>|</span><a href="#38157279">parent</a><span>|</span><a href="#38157356">prev</a><span>|</span><a href="#38157210">next</a><span>|</span><label class="collapse" for="c-38158068">[-]</label><label class="expand" for="c-38158068">[4 more]</label></div><br/><div class="children"><div class="content">The 386SX could do everything the 386DX did, just slower. My first Linux box was a 386SX machine. Before Linux, I ran Coherent on it: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coherent_(operating_system)" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coherent_(operating_system)</a></div><br/><div id="38159980" class="c"><input type="checkbox" id="c-38159980" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#38157279">root</a><span>|</span><a href="#38158068">parent</a><span>|</span><a href="#38159889">next</a><span>|</span><label class="collapse" for="c-38159980">[-]</label><label class="expand" for="c-38159980">[1 more]</label></div><br/><div class="children"><div class="content">Coherent sounds really cool, I&#x27;ve never heard of it before. I wish I had known about it back in the day.<p>I had a 386DX, 25 MHz with 4MB and ran Slackware 3.0 with kernel 1.2.13 on it. It worked pretty nicely for me, but I have to say that I spent most of my time on the console. X11 did run but it was too slow to be fun.</div><br/></div></div><div id="38159889" class="c"><input type="checkbox" id="c-38159889" checked=""/><div class="controls bullet"><span class="by">jacquesm</span><span>|</span><a href="#38157279">root</a><span>|</span><a href="#38158068">parent</a><span>|</span><a href="#38159980">prev</a><span>|</span><a href="#38159654">next</a><span>|</span><label class="collapse" for="c-38159889">[-]</label><label class="expand" for="c-38159889">[1 more]</label></div><br/><div class="children"><div class="content">Another Coherent fan here. That was an awesome system. And for once: awesome documentation. The Coherent book <i>long</i> outlived the Coherent system for me.</div><br/></div></div><div id="38159654" class="c"><input type="checkbox" id="c-38159654" checked=""/><div class="controls bullet"><span class="by">ianmcgowan</span><span>|</span><a href="#38157279">root</a><span>|</span><a href="#38158068">parent</a><span>|</span><a href="#38159889">prev</a><span>|</span><a href="#38157210">next</a><span>|</span><label class="collapse" for="c-38159654">[-]</label><label class="expand" for="c-38159654">[1 more]</label></div><br/><div class="children"><div class="content">There are dozens of us!  Dozens!<p>I paid $99 for Coherent because Linux didn&#x27;t support the fancy RLL hard drive in my work computer.  Eventually Linux caught up (or I got a new computer) and Slackware replaced Coherent (for little things like X11, better networking etc.).  Those were the days :)</div><br/></div></div></div></div></div></div><div id="38157210" class="c"><input type="checkbox" id="c-38157210" checked=""/><div class="controls bullet"><span class="by">phendrenad2</span><span>|</span><a href="#38157279">prev</a><span>|</span><a href="#38157106">next</a><span>|</span><label class="collapse" for="c-38157210">[-]</label><label class="expand" for="c-38157210">[1 more]</label></div><br/><div class="children"><div class="content">The 386 (and actually, the 286) were great designs because they kept backward compatibility. 386 assembly isn&#x27;t fun to write, and memory management with segment registers is gross. But backward compat is worth it.</div><br/></div></div><div id="38157106" class="c"><input type="checkbox" id="c-38157106" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#38157210">prev</a><span>|</span><a href="#38159226">next</a><span>|</span><label class="collapse" for="c-38157106">[-]</label><label class="expand" for="c-38157106">[1 more]</label></div><br/><div class="children"><div class="content">Maybe just me, but this sounds pretty revisionist wrt &#x27;most important&#x27;.  If the 8086&#x2F;8088 hadn&#x27;t stumbled into ubiquity via the IBM PC, there probably never would have been an 80286 much less an 80386. YMMV.<p>That said...the 386 was a world-changing engineering achievement, and as much as I think in a just and fair timeline the 68030 would have taken over the world ( :-) ), you can&#x27;t discount what Intel did.</div><br/></div></div><div id="38159226" class="c"><input type="checkbox" id="c-38159226" checked=""/><div class="controls bullet"><span class="by">atan2</span><span>|</span><a href="#38157106">prev</a><span>|</span><a href="#38157022">next</a><span>|</span><label class="collapse" for="c-38159226">[-]</label><label class="expand" for="c-38159226">[1 more]</label></div><br/><div class="children"><div class="content">I just found some other great articles on this website as well.</div><br/></div></div><div id="38157022" class="c"><input type="checkbox" id="c-38157022" checked=""/><div class="controls bullet"><span class="by">outside1234</span><span>|</span><a href="#38159226">prev</a><span>|</span><a href="#38156702">next</a><span>|</span><label class="collapse" for="c-38157022">[-]</label><label class="expand" for="c-38157022">[4 more]</label></div><br/><div class="children"><div class="content">I forgot how powerful the i960 was - and how this demonstrated that despite that - that compatibility was king.</div><br/><div id="38157133" class="c"><input type="checkbox" id="c-38157133" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#38157022">parent</a><span>|</span><a href="#38158342">next</a><span>|</span><label class="collapse" for="c-38157133">[-]</label><label class="expand" for="c-38157133">[1 more]</label></div><br/><div class="children"><div class="content">The i960 apparently had enough embedded use, e.g. in printers, switches, terminals. That is, where binary compatibility did not matter much.<p>We under-appreciate how little binary compatibility matters now, so that you can even develop something on an ARM-based machine and then rebuild and safely deploy to an x64-based machine (usually because it&#x27;s Node, JVM, Python, etc).</div><br/></div></div><div id="38158342" class="c"><input type="checkbox" id="c-38158342" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#38157022">parent</a><span>|</span><a href="#38157133">prev</a><span>|</span><a href="#38157126">next</a><span>|</span><label class="collapse" for="c-38158342">[-]</label><label class="expand" for="c-38158342">[1 more]</label></div><br/><div class="children"><div class="content">The problem with the i960 was that (according to the last comment on <a href="https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;07&#x2F;the-complex-history-of-intel-i960-risc.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.righto.com&#x2F;2023&#x2F;07&#x2F;the-complex-history-of-intel-...</a> ) the 386 team got more resources and a better process node than the i960, which was produced on a 1.0-micron process, which was already old at that time.</div><br/></div></div><div id="38157126" class="c"><input type="checkbox" id="c-38157126" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#38157022">parent</a><span>|</span><a href="#38158342">prev</a><span>|</span><a href="#38156702">next</a><span>|</span><label class="collapse" for="c-38157126">[-]</label><label class="expand" for="c-38157126">[1 more]</label></div><br/><div class="children"><div class="content">See also: Itanium.  Volume customers care about software, not hardware.</div><br/></div></div></div></div><div id="38156702" class="c"><input type="checkbox" id="c-38156702" checked=""/><div class="controls bullet"><span class="by">TMWNN</span><span>|</span><a href="#38157022">prev</a><span>|</span><a href="#38157208">next</a><span>|</span><label class="collapse" for="c-38156702">[-]</label><label class="expand" for="c-38156702">[16 more]</label></div><br/><div class="children"><div class="content">How different are the instruction sets of the 80486 and Pentium from the 386? Put another way, had the instruction set been frozen as of the 386 (barring any required changes for 64-bit), would we notice any difference in performance today?</div><br/><div id="38156852" class="c"><input type="checkbox" id="c-38156852" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38157151">next</a><span>|</span><label class="collapse" for="c-38156852">[-]</label><label class="expand" for="c-38156852">[3 more]</label></div><br/><div class="children"><div class="content">80486 and Pentium added relatively few instructions to the core instruction set, but there are a couple of pretty important tools which got added. The ones you&#x27;d miss the most would probably be:<p>* CMPXCHG (486). Central to multiprocessor synchronization and locking.<p>* CPUID (P6). Admittedly, if the instruction set were frozen you wouldn&#x27;t need this... but if not, it&#x27;s how you detect what CPU you&#x27;re running on and what it supports.<p>* RDMSR&#x2F;WRMSR (P6, kernel only). A general-purpose mechanism for adding extra special-purpose registers to the CPU without having to allocate an instruction to each one.<p>* INVD&#x2F;WBINVD&#x2F;INVLPG (486, kernel only). This was the first Intel CPU to support cache; these instructions were used to manage it.</div><br/><div id="38156891" class="c"><input type="checkbox" id="c-38156891" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38156702">root</a><span>|</span><a href="#38156852">parent</a><span>|</span><a href="#38157689">next</a><span>|</span><label class="collapse" for="c-38156891">[-]</label><label class="expand" for="c-38156891">[1 more]</label></div><br/><div class="children"><div class="content">CPUID was available on late-model 486s too.</div><br/></div></div></div></div><div id="38157151" class="c"><input type="checkbox" id="c-38157151" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38156852">prev</a><span>|</span><a href="#38156888">next</a><span>|</span><label class="collapse" for="c-38157151">[-]</label><label class="expand" for="c-38157151">[4 more]</label></div><br/><div class="children"><div class="content">Yes.<p>For one no one has mentioned that the 386 itself had no on die hardware floating point. That seems like a huge one.<p>Even if only a few instructions were added to the “core” some are huge like CMPXCHG, CMOV and although not an instruction itself the LOCK prefix.<p>But the extensions are huge. We don’t even still use the floating point instructions of the 386&#x2F;387 era. MMX was pretty lame but SSE and AVX are critical. AES-NI is now necessary for most people with FDE commonplace.</div><br/><div id="38157311" class="c"><input type="checkbox" id="c-38157311" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#38156702">root</a><span>|</span><a href="#38157151">parent</a><span>|</span><a href="#38156888">next</a><span>|</span><label class="collapse" for="c-38157311">[-]</label><label class="expand" for="c-38157311">[3 more]</label></div><br/><div class="children"><div class="content">&gt; although not an instruction itself the LOCK prefix.<p>From what I can tell, the 386 had the LOCK prefix. Pin 26 (bottom left) is LOCK# driven by the LOCK prefix [1]. But CMPXCHG is very useful and wasn&#x27;t available until 486, and Pentium added some other stuff that&#x27;s important.<p>[1] <a href="https:&#x2F;&#x2F;www.eeeguide.com&#x2F;intel-80386-pin-diagram-description&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.eeeguide.com&#x2F;intel-80386-pin-diagram-description...</a></div><br/><div id="38158188" class="c"><input type="checkbox" id="c-38158188" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#38156702">root</a><span>|</span><a href="#38157311">parent</a><span>|</span><a href="#38157384">next</a><span>|</span><label class="collapse" for="c-38158188">[-]</label><label class="expand" for="c-38158188">[1 more]</label></div><br/><div class="children"><div class="content">The 8086 had the LOCK prefix. Intel was thinking of multiprocessing from the beginning.</div><br/></div></div><div id="38157384" class="c"><input type="checkbox" id="c-38157384" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#38156702">root</a><span>|</span><a href="#38157311">parent</a><span>|</span><a href="#38158188">prev</a><span>|</span><a href="#38156888">next</a><span>|</span><label class="collapse" for="c-38157384">[-]</label><label class="expand" for="c-38157384">[1 more]</label></div><br/><div class="children"><div class="content">My mistake.</div><br/></div></div></div></div></div></div><div id="38156888" class="c"><input type="checkbox" id="c-38156888" checked=""/><div class="controls bullet"><span class="by">tssva</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38157151">prev</a><span>|</span><a href="#38156927">next</a><span>|</span><label class="collapse" for="c-38156888">[-]</label><label class="expand" for="c-38156888">[1 more]</label></div><br/><div class="children"><div class="content">The 486 added XADD, BSWAP, CMPXCHG, INVD, WBINVD, INVLPG to the instruction set.<p>The original Pentiums added CPUID, CMPXCHG8B, RDTSC, RDMSR, WRMSR, RSM to the instruction set.<p>Later Pentiums added the MMX instruction set.</div><br/></div></div><div id="38156847" class="c"><input type="checkbox" id="c-38156847" checked=""/><div class="controls bullet"><span class="by">pkaye</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38156927">prev</a><span>|</span><a href="#38156798">next</a><span>|</span><label class="collapse" for="c-38156847">[-]</label><label class="expand" for="c-38156847">[1 more]</label></div><br/><div class="children"><div class="content">I think the early Pentiums are pretty close to the instruction set of the 80386. However there were many iterations to the Pentium that added new instruction like the MMX.</div><br/></div></div><div id="38156798" class="c"><input type="checkbox" id="c-38156798" checked=""/><div class="controls bullet"><span class="by">jstanley</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38156847">prev</a><span>|</span><a href="#38157096">next</a><span>|</span><label class="collapse" for="c-38156798">[-]</label><label class="expand" for="c-38156798">[1 more]</label></div><br/><div class="children"><div class="content">In specialised applications, you&#x27;d definitely miss AVX and SSE. Beyond that, I&#x27;m not sure.</div><br/></div></div><div id="38157096" class="c"><input type="checkbox" id="c-38157096" checked=""/><div class="controls bullet"><span class="by">giantrobot</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38156798">prev</a><span>|</span><a href="#38156816">next</a><span>|</span><label class="collapse" for="c-38157096">[-]</label><label class="expand" for="c-38157096">[2 more]</label></div><br/><div class="children"><div class="content">Even besides new instructions the 486 and then Pentium ran existing x86 code faster than the 386 clock for clock. Various new instructions did add capability but just running existing code faster was a huge win on subsequent chips.</div><br/><div id="38157754" class="c"><input type="checkbox" id="c-38157754" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#38156702">root</a><span>|</span><a href="#38157096">parent</a><span>|</span><a href="#38156816">next</a><span>|</span><label class="collapse" for="c-38157754">[-]</label><label class="expand" for="c-38157754">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Not many new instructions but many instructions required less cycles per instruction and the 486 also got <i>way</i> bigger caches. And the integrated FPU (IIRC the FPU was an add-on for the 386).<p>Switching from a 386 to a 486 was bringing a huge speedup back then.</div><br/></div></div></div></div><div id="38156816" class="c"><input type="checkbox" id="c-38156816" checked=""/><div class="controls bullet"><span class="by">api</span><span>|</span><a href="#38156702">parent</a><span>|</span><a href="#38157096">prev</a><span>|</span><a href="#38157208">next</a><span>|</span><label class="collapse" for="c-38156816">[-]</label><label class="expand" for="c-38156816">[2 more]</label></div><br/><div class="children"><div class="content">Vector instructions are the obvious thing and being massive gains to media, cryptography, math, AI, graphics, and signal processing.<p>Beyond that there have been a few additions like CMOV (conditional move) that would be missed, though instruction fusion in pipelines can sometimes achieve the same speed up.<p>Lastly you would have to add some atomic instructions to support SMP.</div><br/><div id="38157005" class="c"><input type="checkbox" id="c-38157005" checked=""/><div class="controls bullet"><span class="by">clausecker</span><span>|</span><a href="#38156702">root</a><span>|</span><a href="#38156816">parent</a><span>|</span><a href="#38157208">next</a><span>|</span><label class="collapse" for="c-38157005">[-]</label><label class="expand" for="c-38157005">[1 more]</label></div><br/><div class="children"><div class="content">CMOV is very important for high-performance programming as it greatly simplifies the design of branchless code.  There are workarounds, but they either involve conditional branches (you don&#x27;t want these) or increase the critical path latency significantly (the simplest workaround is to materialise the carry flag using SBB, then use that as a mask).</div><br/></div></div></div></div></div></div><div id="38157208" class="c"><input type="checkbox" id="c-38157208" checked=""/><div class="controls bullet"><span class="by">exstential</span><span>|</span><a href="#38156702">prev</a><span>|</span><label class="collapse" for="c-38157208">[-]</label><label class="expand" for="c-38157208">[1 more]</label></div><br/><div class="children"><div class="content">crazy stuff</div><br/></div></div></div></div></div></div></div></body></html>