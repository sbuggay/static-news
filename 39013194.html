<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705482060084" as="style"/><link rel="stylesheet" href="styles.css?v=1705482060084"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://davidben.net/2024/01/15/empty-slices.html">Passing nothing is surprisingly difficult</a> <span class="domain">(<a href="https://davidben.net">davidben.net</a>)</span></div><div class="subtext"><span>kingkilr</span> | <span>46 comments</span></div><br/><div><div id="39025067" class="c"><input type="checkbox" id="c-39025067" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#39020913">next</a><span>|</span><label class="collapse" for="c-39025067">[-]</label><label class="expand" for="c-39025067">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s obviously too late to change this in Rust&#x27;s case, but I wonder whether being able to differentiate between None and the empty slice is actually a necessary property in general?<p>There are a bunch of languages where empty arrays are &quot;falsy&quot;, and in those it&#x27;s not recommendable to use the two to differentiate valid states. Feels like the same could apply here</div><br/></div></div><div id="39020913" class="c"><input type="checkbox" id="c-39020913" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39025067">prev</a><span>|</span><a href="#39016540">next</a><span>|</span><label class="collapse" for="c-39020913">[-]</label><label class="expand" for="c-39020913">[20 more]</label></div><br/><div class="children"><div class="content">There is no problem with memcpy other than that you can&#x27;t use a null pointer. You can memcpy zero bytes as long as the pointer is valid. This works in a good many circumstances; just not circumstances where the empty array is represented by not having an address at all.<p>For instance, say we write a function that rotates an array: it moves the low M bytes to the top of the array, and shuffles the remaining M - N bytes down to the bottom. This function will work fine with the zero byte memmove or memcpy operations in the special case when N == 0, because the pointer will be valid.<p>Now say we have something like this:<p><pre><code>  struct buf {
    char *ptr;
    size_t size;
  };
</code></pre>
we would like it so that when the size is zero, we don&#x27;t have an allocated buffer there. But we&#x27;d like to support a zero sized memcpy in that case: memcpy(buf-&gt;ptr, whatever, 0) or in the other direction likewise.<p>We now have to check for buf-&gt;ptr being buf in the code that deals with resizing.<p>Here is a snag in the C language related to zero sized arrays. The call malloc(0) is allowed to return a null pointer, or a non-null pointer that can be passed to free.<p>oops! In the one case, the pointer may not be used with a zero-sized memcpy; in the other case it can.<p>This also goes for realloc(NULL, 0) which is equivalent to malloc(0).<p>And, OMG I just noticed ...<p>In C99, this was valid realloc(ptr, 0) where ptr is a valid, allocated pointer. You could realloc an object to zero.<p>I&#x27;m looking at the April 2023 draft (N3096). It states that realloc(ptr, 0) is undefined behavior.<p>When did that happen?</div><br/><div id="39022268" class="c"><input type="checkbox" id="c-39022268" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#39020913">parent</a><span>|</span><a href="#39022311">next</a><span>|</span><label class="collapse" for="c-39022268">[-]</label><label class="expand" for="c-39022268">[11 more]</label></div><br/><div class="children"><div class="content">N2464 [0]: there was lots of implementation divergence on what realloc(ptr, 0) did (especially with BSD, which allegedly doesn&#x27;t free the memory at all?), so they just declared it UB.<p>[0] <a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2464.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg14&#x2F;www&#x2F;docs&#x2F;n2464.pdf</a></div><br/><div id="39022507" class="c"><input type="checkbox" id="c-39022507" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022268">parent</a><span>|</span><a href="#39022311">next</a><span>|</span><label class="collapse" for="c-39022507">[-]</label><label class="expand" for="c-39022507">[10 more]</label></div><br/><div class="children"><div class="content">The BSD people don&#x27;t understand what little standards they do read. It&#x27;s unfortunate that we have to spoil the language for their sake.<p>The requirements in C99 and before are perfectly clear. realloc is described as liberating the old pointer, and then allocates a new one as if by malloc. (Except that it magically has access to both objects so it can transfer the necessary bytes that must be transferred from the old to the new.)<p>It is perfectly clear what happens when size is zero. No byte can be copied from the old object, if any. The behavior is like free(oldptr) followed by return malloc(newsize).<p>Your IQ would have to be well below 85 to misunderstand the requirements.<p>And those requirements are still there; there is still the description of realloc in terms of freeing the old pointer and allocating a new object with malloc.<p>There was no need to insert a gratuitous removal of definedness for the size zero case, given that malloc handles it.<p>Applications now have to do this:<p><pre><code>  void *sane_realloc(void *ptr, size_t size)
  {
    if (size == 0) {
      &#x2F;&#x2F; behave literally as required in C99
      free(ptr);
      return malloc(0);
    }

    return realloc(ptr, size);
  }
</code></pre>
Supposedly because a few vendors were not able to code this logic in their realloc functions?</div><br/><div id="39023807" class="c"><input type="checkbox" id="c-39023807" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022507">parent</a><span>|</span><a href="#39022923">next</a><span>|</span><label class="collapse" for="c-39023807">[-]</label><label class="expand" for="c-39023807">[1 more]</label></div><br/><div class="children"><div class="content">Just a reminder to myself how happy I am to leave this academic level of snobbery behind and migrate to languages that help getting things done and save you from  nonsense like this. I did C for about ten years. Hope I’ll never have to do a single line of it again.</div><br/></div></div><div id="39022923" class="c"><input type="checkbox" id="c-39022923" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022507">parent</a><span>|</span><a href="#39023807">prev</a><span>|</span><a href="#39023266">next</a><span>|</span><label class="collapse" for="c-39022923">[-]</label><label class="expand" for="c-39022923">[5 more]</label></div><br/><div class="children"><div class="content">C99 and C11 have no special treatment for a size of zero. Since &quot;memory for the new object [of size zero] cannot be allocated, the old object <i>is not deallocated and its value is unchanged.</i>&quot; (emphasis added). This is exactly what BSD does.<p>C17 says &quot;If size is zero and memory for the new object is not allocated, <i>it is implementation-defined</i> whether the old object is deallocated&quot; (emphasis added).<p>What standard, exactly, is BSD violating?</div><br/><div id="39023824" class="c"><input type="checkbox" id="c-39023824" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022923">parent</a><span>|</span><a href="#39023180">next</a><span>|</span><label class="collapse" for="c-39023824">[-]</label><label class="expand" for="c-39023824">[2 more]</label></div><br/><div class="children"><div class="content">Such behavior violates C89 (they later made it unspecified, likely to match the divergence):<p>&gt; If size is zero and ptr is not a null pointer, the object it points to is freed.<p>It also violates every version of the SUS and POSIX up to Issue 6 (they made it unspecified in Issue 7):<p>&gt; If <i>size</i> is 0 and <i>ptr</i> is not a null pointer, the object pointed to is freed.<p>Going down to at least the 3rd edition of SVID:<p>&gt; If <i>size</i> is zero and <i>ptr</i> is not a null pointer, the object pointed to is
freed.</div><br/><div id="39024109" class="c"><input type="checkbox" id="c-39024109" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39023824">parent</a><span>|</span><a href="#39023180">next</a><span>|</span><label class="collapse" for="c-39024109">[-]</label><label class="expand" for="c-39024109">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s obvious about all those Unix-related specifications is that they are not of BSD lineage.</div><br/></div></div></div></div><div id="39023180" class="c"><input type="checkbox" id="c-39023180" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022923">parent</a><span>|</span><a href="#39023824">prev</a><span>|</span><a href="#39023266">next</a><span>|</span><label class="collapse" for="c-39023180">[-]</label><label class="expand" for="c-39023180">[2 more]</label></div><br/><div class="children"><div class="content">That all refers to a failing allocation, obviously. If realloc cannot allocate the new object, the old one stays valid.<p>In the case of size zero, malloc(0) can return null (always). That is ambiguous; it looks like a failure. If realloc literally were to call malloc(0) and then treats the null as a failure, it will return the old object. However, on an implementation where malloc(0) always returns null by design, that would be obviously be poor behavior for its own realloc.<p>If malloc(0) returns null by design that is not a case where allocating an object failed.<p>We basically now need this in every program that might resize to zero:<p><pre><code>  void *sane_realloc(void *ptr, size_t size)
  {
     if (size == 0) {
       free(ptr);
       return malloc(0);
     }
     return realloc(ptr, size);
  }
</code></pre>
The only problem is that if malloc(0) returns null on an implementation where it normally returns an allocated pointer (and thus the call has failed) we don&#x27;t detect the failure and don&#x27;t preserve the original object. The application which relies on sane_realloc has to understand that when size is zero, the deallocation always works, whether or not the subsequent malloc does, and so it may get a null pointer on any platform.</div><br/></div></div></div></div><div id="39023266" class="c"><input type="checkbox" id="c-39023266" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022507">parent</a><span>|</span><a href="#39022923">prev</a><span>|</span><a href="#39022311">next</a><span>|</span><label class="collapse" for="c-39023266">[-]</label><label class="expand" for="c-39023266">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think insulting the BSD folks is very nice. They probably had good reasons for their decisions.</div><br/><div id="39024067" class="c"><input type="checkbox" id="c-39024067" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39023266">parent</a><span>|</span><a href="#39023860">next</a><span>|</span><label class="collapse" for="c-39024067">[-]</label><label class="expand" for="c-39024067">[1 more]</label></div><br/><div class="children"><div class="content">Mostly, the BSD people think that POSIX and ISO C are just forks of Unix documentation, that are mainly used for making non-Unix systems look Unix-like. BSD comes from real Unix DNA and so following those is optional; whatever direction BSD takes is Unix by definition, as if it&#x27;s forever 1983.</div><br/></div></div></div></div></div></div></div></div><div id="39022311" class="c"><input type="checkbox" id="c-39022311" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39020913">parent</a><span>|</span><a href="#39022268">prev</a><span>|</span><a href="#39016540">next</a><span>|</span><label class="collapse" for="c-39022311">[-]</label><label class="expand" for="c-39022311">[8 more]</label></div><br/><div class="children"><div class="content">Is there a rationale for a memory allocator to support zero sized allocations? Is this really just about providing a &quot;technically&quot; valid pointer for the pointer&#x2F;size pair structure? To me it seems <i>any</i> address is a potentially valid pointer to a zero-sized object. Do allocators really keep track of these null allocations? That would require keeping state for every single address in the worst case...<p>It&#x27;s very strange. I wrote my own memory allocator and I can&#x27;t figure out the right way to handle this. Eliminating the need for these &quot;technically&quot; valid pointers that can&#x27;t actually be accessed because they&#x27;re zero sized seems like the better solution.<p>&gt; When did that happen?<p>More importantly, <i>why</i> did that happen? People have told me that I should care about the C standards committee because they take backwards compatibility very seriously. Then they come out with breaking changes like these.</div><br/><div id="39022527" class="c"><input type="checkbox" id="c-39022527" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022311">parent</a><span>|</span><a href="#39022670">next</a><span>|</span><label class="collapse" for="c-39022527">[-]</label><label class="expand" for="c-39022527">[6 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Is there a rationale for a memory allocator to support zero sized allocations?</i><p>Mainly, that it has supported that before and programs rely on it.<p>Programs written to the C99 standard can resize a dynamic vector down to empty with a resize(ptr, 0). The pointer coming from that will be the same as if malloc(0) has been called.<p>So now, that has been taken away; those programs can now make demons fly out of your nose.<p>Thank you, ISO C!<p>&gt; <i>Do allocators really keep track of these null allocations? That would require keeping state for every single address in the worst case...</i><p>Implementations of malloc(0) that don&#x27;t return null are required to return a unique object. To do that, all they have to do is pretend that the size is some nonzero value like 1 byte. (The application must not assume that there is any byte there that can be accessed).</div><br/><div id="39022936" class="c"><input type="checkbox" id="c-39022936" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022527">parent</a><span>|</span><a href="#39022670">next</a><span>|</span><label class="collapse" for="c-39022936">[-]</label><label class="expand" for="c-39022936">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Programs written to the C99 standard can resize a dynamic vector down to empty with a resize(ptr, 0).</i><p>C99 has no resize() function. Assuming you mean realloc(), C99 does not guarantee you can use realloc() in this manner.<p>See also:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38850575">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38850575</a><p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;16759849&#x2F;using-realloc-x-0-instead-of-free-and-using-malloc-with-length-of-a-string#comment24143811_16759849" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;16759849&#x2F;using-realloc-x...</a><p><a href="https:&#x2F;&#x2F;wiki.sei.cmu.edu&#x2F;confluence&#x2F;plugins&#x2F;servlet&#x2F;mobile?contentId=87152091#content&#x2F;view&#x2F;87152091" rel="nofollow">https:&#x2F;&#x2F;wiki.sei.cmu.edu&#x2F;confluence&#x2F;plugins&#x2F;servlet&#x2F;mobile?c...</a><p><a href="https:&#x2F;&#x2F;developers.redhat.com&#x2F;articles&#x2F;2023&#x2F;07&#x2F;26&#x2F;checking-usage-realloc-valgrind#size_zero" rel="nofollow">https:&#x2F;&#x2F;developers.redhat.com&#x2F;articles&#x2F;2023&#x2F;07&#x2F;26&#x2F;checking-u...</a></div><br/><div id="39024166" class="c"><input type="checkbox" id="c-39024166" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022936">parent</a><span>|</span><a href="#39023909">next</a><span>|</span><label class="collapse" for="c-39024166">[-]</label><label class="expand" for="c-39024166">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>C99 does not guarantee you can use realloc() in this manner</i><p>Yes it does. It requires support for reallocing down to zero, which results in an object that is like one that comes from malloc(0).<p>(What some people think is that realloc(x, 0) is equivalent to free(x). It isn&#x27;t. Resizing down to zero isn&#x27;t freeing. It might be, if malloc(0) doesn&#x27;t allocate anything and just returns null. Why some people think realloc(x, 0) is free(x) is that they read realloc man page from the Linux man-pages project which says such a thing.)<p>realloc(ptr, 0) could fail to free ptr, in the situation that allocating the zero-sized replacement object fails. In that case, null could be returned, leaving the old object valid. This is ambiguous, because null could also be the happy case return value when the old object was freed and the zero-sized allocation deliberately produced null. Under those conditions, the cases in which there is a memory leak are indistinguishable from the ones in which there isn&#x27;t.<p>(I&#x27;d rather suffer a memory leak in the OOM condition, than have previously defined behavior gratuitously flip to undefined.)</div><br/></div></div><div id="39023909" class="c"><input type="checkbox" id="c-39023909" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022936">parent</a><span>|</span><a href="#39024166">prev</a><span>|</span><a href="#39022670">next</a><span>|</span><label class="collapse" for="c-39023909">[-]</label><label class="expand" for="c-39023909">[3 more]</label></div><br/><div class="children"><div class="content">Indeed, you couldn&#x27;t reliably free() the old pointer if the realloc(ptr, 0) failed.<p>But xrealloc(ptr, 0) (or equivalent) would still be perfectly consistent, assuming you trust your implementation to support non-null 0-size allocations in the first place. It&#x27;s very common to just &quot;leak it all and abort&quot; on a critical error like memory exhaustion. There&#x27;s a reason most non-C languages expose an infallible allocation API as the default option.<p>I do think that UB is an overly heavy hammer for realloc(ptr, 0), since the xrealloc(ptr, 0) use case works just as well regardless of how unspecified the values of the old pointer or errno are on failure.</div><br/><div id="39024305" class="c"><input type="checkbox" id="c-39024305" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39023909">parent</a><span>|</span><a href="#39024184">next</a><span>|</span><label class="collapse" for="c-39024305">[-]</label><label class="expand" for="c-39024305">[1 more]</label></div><br/><div class="children"><div class="content">Yes. If realloc(ptr, 0) returns a null pointer, you don&#x27;t know whether that&#x27;s due to a failure (in which case ptr is still valid) or whether it&#x27;s the happy case (ptr was freed, and the zero-sized request for replacing it produced a null). Thus you don&#x27;t know whether ptr is still a valid pointer. If it&#x27;s valid and you treat it as invalid (hands off), that&#x27;s a leak. If it&#x27;s invalid and you treat it as valid (free it), that&#x27;s a double free.</div><br/></div></div></div></div></div></div></div></div><div id="39022670" class="c"><input type="checkbox" id="c-39022670" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#39020913">root</a><span>|</span><a href="#39022311">parent</a><span>|</span><a href="#39022527">prev</a><span>|</span><a href="#39016540">next</a><span>|</span><label class="collapse" for="c-39022670">[-]</label><label class="expand" for="c-39022670">[1 more]</label></div><br/><div class="children"><div class="content">If storing the metadata in the heap, 0 bytes often doesn&#x27;t even end up a special case. You need to have a case for allocations of some arbitrary number of bytes, and 0 is an arbitrary number of bytes.<p>Another option is to treat them as being of size 1.<p>(In theory you could do endless allocations of size 0, and eventually you&#x27;d run out of space, even though you&#x27;ve allocated 0 bytes in total. But you end up in exactly that situation, whatever the allocation size, if you don&#x27;t take bookkeeping overhead into account!)</div><br/></div></div></div></div></div></div><div id="39016540" class="c"><input type="checkbox" id="c-39016540" checked=""/><div class="controls bullet"><span class="by">cbarrick</span><span>|</span><a href="#39020913">prev</a><span>|</span><a href="#39020904">next</a><span>|</span><label class="collapse" for="c-39016540">[-]</label><label class="expand" for="c-39016540">[3 more]</label></div><br/><div class="children"><div class="content">Useful context on the Rust side is this issue [1]. It sounds like some of the author&#x27;s concerns are addressed already.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;unsafe-code-guidelines&#x2F;issues&#x2F;472">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;unsafe-code-guidelines&#x2F;issues&#x2F;4...</a></div><br/><div id="39016654" class="c"><input type="checkbox" id="c-39016654" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#39016540">parent</a><span>|</span><a href="#39022490">next</a><span>|</span><label class="collapse" for="c-39016654">[-]</label><label class="expand" for="c-39016654">[1 more]</label></div><br/><div class="children"><div class="content">see also <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;19871c5&#x2F;passing_nothing_is_surprisingly_difficult&#x2F;ki5fu0i&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;comments&#x2F;19871c5&#x2F;passing_nothi...</a></div><br/></div></div><div id="39022490" class="c"><input type="checkbox" id="c-39022490" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#39016540">parent</a><span>|</span><a href="#39016654">prev</a><span>|</span><a href="#39020904">next</a><span>|</span><label class="collapse" for="c-39022490">[-]</label><label class="expand" for="c-39022490">[1 more]</label></div><br/><div class="children"><div class="content">This is basically the &quot;define pointer arithmetic for invalid pointers&quot;. Which as pointed out in that section, doesn&#x27;t solve completely the FFI problem.</div><br/></div></div></div></div><div id="39023309" class="c"><input type="checkbox" id="c-39023309" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#39020904">prev</a><span>|</span><a href="#39024670">next</a><span>|</span><label class="collapse" for="c-39023309">[-]</label><label class="expand" for="c-39023309">[4 more]</label></div><br/><div class="children"><div class="content">How does zig handle this? Does it just have its own slice representation that gets compiled away? Or does it disallow zero length slices?</div><br/><div id="39024671" class="c"><input type="checkbox" id="c-39024671" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#39023309">parent</a><span>|</span><a href="#39024546">next</a><span>|</span><label class="collapse" for="c-39024671">[-]</label><label class="expand" for="c-39024671">[2 more]</label></div><br/><div class="children"><div class="content">I am not entirely sure, but it seems they chose to return a null pointer:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;commit&#x2F;32e0dfd4f0dab351a024e7680280343db5d7c43e">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;commit&#x2F;32e0dfd4f0dab351a024e7...</a></div><br/><div id="39025055" class="c"><input type="checkbox" id="c-39025055" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39023309">root</a><span>|</span><a href="#39024671">parent</a><span>|</span><a href="#39024546">next</a><span>|</span><label class="collapse" for="c-39025055">[-]</label><label class="expand" for="c-39025055">[1 more]</label></div><br/><div class="children"><div class="content">This is a commit that changes the now-defunct Zig compiler written in C++ to be careful when it calls malloc. So it has nothing to do with the semantics of the Zig language or the compatibility of zero-sized Zig slices with Rust, C, or C++ APIs.</div><br/></div></div></div></div><div id="39024546" class="c"><input type="checkbox" id="c-39024546" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39023309">parent</a><span>|</span><a href="#39024671">prev</a><span>|</span><a href="#39024670">next</a><span>|</span><label class="collapse" for="c-39024546">[-]</label><label class="expand" for="c-39024546">[1 more]</label></div><br/><div class="children"><div class="content">Zig slices are (start, count) where start&#x27;s type is non-nullable pointer.<p>My impression is that Zig doesn&#x27;t have a documented memory model that cares about things like whether an address corresponds to an allocation or not, so problems relating to this sort of thing cannot come up yet :)</div><br/></div></div></div></div><div id="39024670" class="c"><input type="checkbox" id="c-39024670" checked=""/><div class="controls bullet"><span class="by">bhakunikaran</span><span>|</span><a href="#39023309">prev</a><span>|</span><a href="#39020118">next</a><span>|</span><label class="collapse" for="c-39024670">[-]</label><label class="expand" for="c-39024670">[1 more]</label></div><br/><div class="children"><div class="content">Quite intriguing</div><br/></div></div><div id="39020118" class="c"><input type="checkbox" id="c-39020118" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#39024670">prev</a><span>|</span><a href="#39017895">next</a><span>|</span><label class="collapse" for="c-39020118">[-]</label><label class="expand" for="c-39020118">[10 more]</label></div><br/><div class="children"><div class="content">A fun additional twist to this is that dereferencing nullptr is valid in WebAssembly, and actual data can in fact end up there, though ideally it never will.<p>If you ensure that the &#x27;zero page&#x27; (so to speak) is empty you can also exploit this property for optimizations, and in some cases the emscripten toolchain will do so.<p>i.e. if you have<p><pre><code>  struct MyArray&lt;T&gt; {
    uint length;
    T items[0];
  }
</code></pre>
you can elide null pointer checks and just do a single direct bounds check before dereferencing an element, because for a nullptr, (&amp;ptr-&gt;length) == nullptr, and if you reserve the zero page and keep it empty, (nullptr)-&gt;length == 0.<p>this complicates the idea of &#x27;passing nothing&#x27; because now it is realistically possible for your code to get passed nullptr on purpose and it might be expected to behave correctly when that happens, instead of asserting or panicking like it would on other (sensible) targets</div><br/><div id="39022099" class="c"><input type="checkbox" id="c-39022099" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39020118">parent</a><span>|</span><a href="#39020940">next</a><span>|</span><label class="collapse" for="c-39022099">[-]</label><label class="expand" for="c-39022099">[3 more]</label></div><br/><div class="children"><div class="content">Because WASM is not C and there is no &quot;nullptr&quot; in WASM. In WASM, zero is just an address, as valid as any other. And C actually doesn&#x27;t require the null pointer value to have bit pattern &quot;all zeros&quot;, precisely to allow for architectures where treating zero address as invalid would be way too cumbersome. And some implementations actually took that option.</div><br/><div id="39023340" class="c"><input type="checkbox" id="c-39023340" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#39020118">root</a><span>|</span><a href="#39022099">parent</a><span>|</span><a href="#39020940">next</a><span>|</span><label class="collapse" for="c-39023340">[-]</label><label class="expand" for="c-39023340">[2 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t aware the spec allowed for nullptr to not be 0, that&#x27;s fascinating! In that case you could probably use 0xFFFFFFFF as long as you limit the size of the WASM heap to below 4GB, then. You&#x27;d risk having addresses wrap-around though.</div><br/><div id="39023678" class="c"><input type="checkbox" id="c-39023678" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39020118">root</a><span>|</span><a href="#39023340">parent</a><span>|</span><a href="#39020940">next</a><span>|</span><label class="collapse" for="c-39023678">[-]</label><label class="expand" for="c-39023678">[1 more]</label></div><br/><div class="children"><div class="content">Nothing stops you from having your null pointer in the middle of the address space. Some C compiler for DOS or early Windows did that IIRC (it was 0xB800 or something?.. so that it wouldn&#x27;t accidentally corrupt the interrupt table). Also, C explicitly prohibits address wrap-around problems for pointers:<p><pre><code>    Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.
</code></pre>
But this is fine, since pointer comparisons (as in, less&#x2F;greater comparisons) are actually both pretty restricted <i>and</i> required to have reasonable semantics when comparing pointers that point into the same object&#x2F;array:<p><pre><code>    When two pointers are compared, the result depends on the relative locations in the address space of the objects pointed to. If two pointers to object types both point to the same object, or both point one past the last element of the same array object, they compare equal. If the objects pointed to are members of the same aggregate object, pointers to structure members declared later compare greater than pointers to members declared earlier in the structure, and pointers to array elements with larger subscript values compare greater than pointers to elements of the same array with lower subscript values. All pointers to members of the same union object compare equal. If the expression P points to an element of an array object and the expression Q points to the last element of the same array object, the pointer expression Q+1 compares greater than P. In all other cases, the behavior is undefined.
</code></pre>
By the way, this means that, among other things, if you use number N to represent a null pointer then number N-1 can not ever be a valid pointer to anything: adding 1 to a valid pointer is always allowed, and this addition should produce a non-null pointer — because the resulting pointer is required to be well-behaved in comparisons, and comparisons with null pointer are UB.</div><br/></div></div></div></div></div></div><div id="39020940" class="c"><input type="checkbox" id="c-39020940" checked=""/><div class="controls bullet"><span class="by">nmilo</span><span>|</span><a href="#39020118">parent</a><span>|</span><a href="#39022099">prev</a><span>|</span><a href="#39021635">next</a><span>|</span><label class="collapse" for="c-39020940">[-]</label><label class="expand" for="c-39020940">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure... wasm is an assembly, not a C implementation. It can define what happens if you load from 0 but it doesn&#x27;t get to define if the C code `*nullptr` actually loads from 0. Whether or not it does is defined by your compiler, which is probably the clang frontend if you&#x27;re on emscripten. But then again I think there&#x27;s a clang flag to disable optimizing away reads&#x2F;writes to nullptr.</div><br/></div></div><div id="39021635" class="c"><input type="checkbox" id="c-39021635" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#39020118">parent</a><span>|</span><a href="#39020940">prev</a><span>|</span><a href="#39020553">next</a><span>|</span><label class="collapse" for="c-39021635">[-]</label><label class="expand" for="c-39021635">[1 more]</label></div><br/><div class="children"><div class="content">HPUX must have had something similar, as when AOL backend code was ported to Solaris, which does segv on null dereference, we found all kinds of places where code that had been running without notable incident on HPUX started dropping core.</div><br/></div></div><div id="39020553" class="c"><input type="checkbox" id="c-39020553" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39020118">parent</a><span>|</span><a href="#39021635">prev</a><span>|</span><a href="#39017895">next</a><span>|</span><label class="collapse" for="c-39020553">[-]</label><label class="expand" for="c-39020553">[4 more]</label></div><br/><div class="children"><div class="content">I’m kind of surprised it’s not defined that the first page must be 0-mapped read only… this sounds like a security vulnerability because it’s not like any other machine code would be written against and thus violate all sorts of safety assumptions.</div><br/><div id="39020873" class="c"><input type="checkbox" id="c-39020873" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#39020118">root</a><span>|</span><a href="#39020553">parent</a><span>|</span><a href="#39021319">next</a><span>|</span><label class="collapse" for="c-39020873">[-]</label><label class="expand" for="c-39020873">[2 more]</label></div><br/><div class="children"><div class="content">Do you mean that as written? I&#x27;d find that extremely surprising, and would in my mind, violate all sorts of safety assumptions, primarily that deref&#x27;ing NULL traps¹.<p>E.g., I am pretty sure Go relies on some of the behavior described here: that the 0 page is unmapped, and that accesses will trap. This is why Go code will sometimes SIGSEGV despite being an almost memory-safe language: Go is explicitly depending on that trap (and it permits Go, in those cases, to elide a validity check). (Vs. some memory accesses will incur a bounds check &amp; panic, if Go cannot determine that they will definitely land in the first page; Go there must emit the validity check, and failing it is a panic, instead of a SIGSEGV.)<p>IIRC, Linux doesn&#x27;t permit at least unprivileged processes to map address 0, I believe. (Although I can&#x27;t find a source right now for that.)<p>¹Yes, in most languages this is UB … but what I&#x27;m saying is that having it <i>trap</i> makes errors — usually security errors — obvious &amp; fail, instead of really letting the UB just do <i>whatever</i> and really going off into &quot;it&#x27;s really undefined <i>now</i>&quot; territory.</div><br/><div id="39022002" class="c"><input type="checkbox" id="c-39022002" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#39020118">root</a><span>|</span><a href="#39020873">parent</a><span>|</span><a href="#39021319">next</a><span>|</span><label class="collapse" for="c-39022002">[-]</label><label class="expand" for="c-39022002">[1 more]</label></div><br/><div class="children"><div class="content">Ideally it would be an unmapped trap considering it’s literally how every other runtime works. The next best option is to make it read only. The dumbest option is to make it read&#x2F;write as that’s going to be a vector for security vulnerabilities.</div><br/></div></div></div></div></div></div></div></div><div id="39017895" class="c"><input type="checkbox" id="c-39017895" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#39020118">prev</a><span>|</span><a href="#39020918">next</a><span>|</span><label class="collapse" for="c-39017895">[-]</label><label class="expand" for="c-39017895">[1 more]</label></div><br/><div class="children"><div class="content">What a wonderfully subtle issue.</div><br/></div></div><div id="39020918" class="c"><input type="checkbox" id="c-39020918" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39017895">prev</a><span>|</span><a href="#39020977">next</a><span>|</span><label class="collapse" for="c-39020918">[-]</label><label class="expand" for="c-39020918">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m dealing with the exact same issues right now in my project, this post is very enlightening.<p>&gt; But suppose we want an empty (length zero) slice.<p>So is there an actual rationale for this? I&#x27;ve written the memory allocator and am in the process of developing the foreign interface. I&#x27;ve been wondering if I should explicitly support zero length allocations. Even asked this a few times here on HN but never got an answer. It seems to be a thing people sort of want but for unknown reasons.</div><br/><div id="39021139" class="c"><input type="checkbox" id="c-39021139" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#39020918">parent</a><span>|</span><a href="#39020977">next</a><span>|</span><label class="collapse" for="c-39021139">[-]</label><label class="expand" for="c-39021139">[1 more]</label></div><br/><div class="children"><div class="content">It is extremely common to have a collection that might or might not be empty at runtime, and we don’t want to force every programmer who allocates a slice to manually write an alternate code path for the empty case.</div><br/></div></div></div></div><div id="39020977" class="c"><input type="checkbox" id="c-39020977" checked=""/><div class="controls bullet"><span class="by">hackyhacky</span><span>|</span><a href="#39020918">prev</a><span>|</span><label class="collapse" for="c-39020977">[-]</label><label class="expand" for="c-39020977">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Passing nothing is surprisingly difficult<p>From the title, I assumed that this article was going to be about either (a) permissive grading standards at university or (b) chronic constipation.</div><br/><div id="39021025" class="c"><input type="checkbox" id="c-39021025" checked=""/><div class="controls bullet"><span class="by">dmvdoug</span><span>|</span><a href="#39020977">parent</a><span>|</span><label class="collapse" for="c-39021025">[-]</label><label class="expand" for="c-39021025">[1 more]</label></div><br/><div class="children"><div class="content">In fairness, both of those are also surprisingly difficult.</div><br/></div></div></div></div></div></div></div></div></div></body></html>