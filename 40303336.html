<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715245271374" as="style"/><link rel="stylesheet" href="styles.css?v=1715245271374"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://simbricks.github.io/">Show HN: SimBricks – Modular Full-System Simulation for HW-SW Systems</a> <span class="domain">(<a href="https://simbricks.github.io">simbricks.github.io</a>)</span></div><div class="subtext"><span>antoine-kaufm</span> | <span>4 comments</span></div><br/><div><div id="40305037" class="c"><input type="checkbox" id="c-40305037" checked=""/><div class="controls bullet"><span class="by">ooterness</span><span>|</span><a href="#40304048">next</a><span>|</span><label class="collapse" for="c-40305037">[-]</label><label class="expand" for="c-40305037">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m interested in this concept, but how does this work?<p>With FPGA or ASIC designs at scale, it can take hours to run gate-level simulations spanning just a few milliseconds of operation. How can this be integrated into a networked system-of-systems as shown in the demo?  Or are the simulations shown running at a lower level of fidelity?</div><br/><div id="40305902" class="c"><input type="checkbox" id="c-40305902" checked=""/><div class="controls bullet"><span class="by">antoine-kaufm</span><span>|</span><a href="#40305037">parent</a><span>|</span><a href="#40304048">next</a><span>|</span><label class="collapse" for="c-40305902">[-]</label><label class="expand" for="c-40305902">[1 more]</label></div><br/><div class="children"><div class="content">First off, there is no magic here. SimBricks simulations (when synchronization is enabled) are going to run as slow as the fastest piece and scale up through parallelism (so if you have N instances of an FPGA&#x2F;ASIC design, you need N times the compute). There are, of course, the usual tricks like fast forwarding&#x2F;checkpointing etc. so you don&#x27;t have to spend forever just booting your Linux because the HW design is sitting there going at a snails pace.<p>So nothing stops you from including a gate-level simulation, other simulators will just slow down accordingly (with very slow simulators the synchronization overheads are generally negligible). That said, GLS might not be the most common use-case here. Would a full-system simulation with GLS actually gets you additional insights relative to just simulating the RTL? (genuine question)<p>For our internal use-cases so far, we have primarily done TLM and RTL simulations. Depending on the level of fidelity (e.g. fast functional with Qemu, or slow detailed OoO CPU in gem5) here we are talking seconds to hours for simulating a few seconds.<p>One interesting bit that the modularity gets you, is that you can mix fidelities of components. So if you do want to test a GLS component as part of a large system with multiple instances of your design, you could consider only doing GLS for one instance and using just the RTL simulation or even a TLM for the others. This does not speed up the simulation, but drastically reduces the compute needed.<p>But curious on what your take is for when you think the full-system perspective would be useful.</div><br/></div></div></div></div></div></div></div></div></div></body></html>