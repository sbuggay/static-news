<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735808452641" as="style"/><link rel="stylesheet" href="styles.css?v=1735808452641"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/dunglas/mercure">Mercure: A WebSocket alternative for server-sent events</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>porjo</span> | <span>21 comments</span></div><br/><div><div id="42572509" class="c"><input type="checkbox" id="c-42572509" checked=""/><div class="controls bullet"><span class="by">weitendorf</span><span>|</span><a href="#42572594">next</a><span>|</span><label class="collapse" for="c-42572509">[-]</label><label class="expand" for="c-42572509">[2 more]</label></div><br/><div class="children"><div class="content">It took a decent amount of digging, but it seems like this is trying to be a browser-compatible pubsub system more than a direct websocket replacement. The main thing they&#x27;re doing is introducing a &quot;mercure hub&quot; between event producers and consumers (browsers) that handles delivery through SSE in a way that tracks subscribers and handles sporadic or interrupted connection.<p>However what confuses me is that they seem to focus mostly on the protocol, hub, and publish implementation. At least based on a quick glance at <a href="https:&#x2F;&#x2F;mercure.rocks&#x2F;docs&#x2F;ecosystem&#x2F;awesome" rel="nofollow">https:&#x2F;&#x2F;mercure.rocks&#x2F;docs&#x2F;ecosystem&#x2F;awesome</a> and elsewhere it seems they expect you to use raw SSE clientside according to their protocol described in eg <a href="https:&#x2F;&#x2F;mercure.rocks&#x2F;spec#active-subscriptions" rel="nofollow">https:&#x2F;&#x2F;mercure.rocks&#x2F;spec#active-subscriptions</a>.<p>Most of their clientside examples look pretty simple but they don&#x27;t seem like they&#x27;re fully implementing the logic described in &quot;Reconnection, State Reconciliation and Event Sourcing&quot; which seems rather complex. Maybe I&#x27;m missing something but it seems like that logic is the entire reason to use this over SSE alone.</div><br/><div id="42572587" class="c"><input type="checkbox" id="c-42572587" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#42572509">parent</a><span>|</span><a href="#42572594">next</a><span>|</span><label class="collapse" for="c-42572587">[-]</label><label class="expand" for="c-42572587">[1 more]</label></div><br/><div class="children"><div class="content">Hi, Mercure author here.<p>Indeed that&#x27;s how it works. One of the key point of the solution is that you don&#x27;t need anything client-side. The native EventSource class is all you need (but you can use more advanced SSE client libraries if wanted).<p>Reconnection and state reconciliation are achieved automatically. The hub implements all the needed features: it stores sent events and automatically resend them at reconnection time if they have been lost. It&#x27;s possible to do this transparently because browsers will automatically send the ID of the last received message in a Last-Event-ID header when reconnecting. This feature is just often not implemented by SSE servers (because it’s not trivial to do).<p>It&#x27;s also possible to ask events received since a specific ID, matching one or several topics just  by passing the query parameters defined in the protocol section.<p>By the way, we are working on a new website that will make these things more clear.</div><br/></div></div></div></div><div id="42572594" class="c"><input type="checkbox" id="c-42572594" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#42572509">prev</a><span>|</span><a href="#42572074">next</a><span>|</span><label class="collapse" for="c-42572594">[-]</label><label class="expand" for="c-42572594">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of WAMP (Web Application Messaging Protocol) [0], which is a WebSocket subprotocol.<p>I find the title odd, because, why would you want to replace server-sent events with WebSocket, if the great thing about SSE is the simplicity, both client- and server-side?<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Web_Application_Messaging_Protocol#Comparison" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Web_Application_Messaging_Prot...</a></div><br/></div></div><div id="42572074" class="c"><input type="checkbox" id="c-42572074" checked=""/><div class="controls bullet"><span class="by">panarky</span><span>|</span><a href="#42572594">prev</a><span>|</span><a href="#42572712">next</a><span>|</span><label class="collapse" for="c-42572074">[-]</label><label class="expand" for="c-42572074">[13 more]</label></div><br/><div class="children"><div class="content">Please explain why this is better than websockets.<p>I read the Github readme, but it doesn&#x27;t say what&#x27;s better.</div><br/><div id="42572529" class="c"><input type="checkbox" id="c-42572529" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#42572074">parent</a><span>|</span><a href="#42572201">next</a><span>|</span><label class="collapse" for="c-42572529">[-]</label><label class="expand" for="c-42572529">[5 more]</label></div><br/><div class="children"><div class="content">Hi, Mercure author here.<p>WebSockets are hard to secure (they totally bypass CORS as well as other browser built-in protections), don&#x27;t work (yet) with HTTP&#x2F;3 and for most use cases require to implement many features by yourself: reconnection in case of network failure, refetch of lost messages, authorization, topic mechanism…<p>Mercure, which is built on top of SSE (it&#x27;s more an extension to SSE than an alternative to it) fix these issues.<p>However, SSE (as well as WebSockets) can be hard to use with stacks not designed to handle persistent connections such as PHP, serverless, most web servers proxying Ruby, Python etc apps. Even for languages designed to handle persistent connections, it&#x27;s often more efficient and easier to manage persistent connections with ah-hoc software running on dedicated hardware.<p>That&#x27;s what Mercure allows. Mercure provides a &quot;hub&quot;, a server that will maintain the persistent connections with the browsers, store events, and re-send them in case of network issues (or if asked for old messages by a client). To broadcast a message to all connected users, the server app (or even a client) can just send a single POST request to the hub. The hub will also check that clients are authorized to subscribe or publish to a given topic (that&#x27;s why JWT is used).<p>The reference implementation is written in Go, as a module for the Caddy web server, and his very efficient&#x2F;optimized (it can handle thousands of persistent connections on very small machines).<p>Install a Mercure hub and you have all these features available without having to write any code. Client-side, no SDK is required, you can embrace the built-in EventSource JavaScript class.</div><br/><div id="42572838" class="c"><input type="checkbox" id="c-42572838" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42572074">root</a><span>|</span><a href="#42572529">parent</a><span>|</span><a href="#42572650">next</a><span>|</span><label class="collapse" for="c-42572838">[-]</label><label class="expand" for="c-42572838">[1 more]</label></div><br/><div class="children"><div class="content">It might be worth mentioning to the parent poster that SSEs (and Mercure) are unidirectional only (server -&gt; client), whereas WebSockets are bidirectional.</div><br/></div></div><div id="42572650" class="c"><input type="checkbox" id="c-42572650" checked=""/><div class="controls bullet"><span class="by">Thorrez</span><span>|</span><a href="#42572074">root</a><span>|</span><a href="#42572529">parent</a><span>|</span><a href="#42572838">prev</a><span>|</span><a href="#42572201">next</a><span>|</span><label class="collapse" for="c-42572650">[-]</label><label class="expand" for="c-42572650">[3 more]</label></div><br/><div class="children"><div class="content">&gt; they totally bypass CORS<p>You can reimplement the Same Origin Policy serverside by checking that the Origin header equals the Host header. Even more secure would be to check both against an allowlist (this protects against DNS rebinding, which the Same Origin Policy doesn&#x27;t protect against).<p>&gt;as well as other browser built-in protections<p>I&#x27;m curious what those are.<p>&gt;for most use cases require to implement many features by yourself: [...] authorization<p>Isn&#x27;t auth of websockets generally the same as auth of any Javascript-initiated HTTP request (e.g. fetch())? Check that the cookie looks good? Now, in the cause of OAuth tokens, websockets are more difficult than fetch(), because you cannot attach an Authorization: Bearer header to a websocket. But OAuth is less common than cookies for websites.</div><br/><div id="42572721" class="c"><input type="checkbox" id="c-42572721" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#42572074">root</a><span>|</span><a href="#42572650">parent</a><span>|</span><a href="#42572201">next</a><span>|</span><label class="collapse" for="c-42572721">[-]</label><label class="expand" for="c-42572721">[2 more]</label></div><br/><div class="children"><div class="content">Once the connection is upgraded, you loose all metadata included in the HTTP headers (because it’s not HTTP) and all protections relying on it.
Also CORS and SOP can be bypassed:  <a href="https:&#x2F;&#x2F;dev.to&#x2F;pssingh21&#x2F;websockets-bypassing-sop-cors-5ajm" rel="nofollow">https:&#x2F;&#x2F;dev.to&#x2F;pssingh21&#x2F;websockets-bypassing-sop-cors-5ajm</a><p>Even very experienced teams make mistake with this kind of things. See for instance, this Kubernetes vulnerability: <a href="https:&#x2F;&#x2F;goteleport.com&#x2F;blog&#x2F;kubernetes-websocket-upgrade-security-vulnerability&#x2F;" rel="nofollow">https:&#x2F;&#x2F;goteleport.com&#x2F;blog&#x2F;kubernetes-websocket-upgrade-sec...</a><p>Of course you can reimplement everything by hand (and you must if you use WebSockets), but with SSE&#x2F;Mercure you don&#x27;t have to because it&#x27;s plain old HTTP.</div><br/><div id="42572815" class="c"><input type="checkbox" id="c-42572815" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42572074">root</a><span>|</span><a href="#42572721">parent</a><span>|</span><a href="#42572201">next</a><span>|</span><label class="collapse" for="c-42572815">[-]</label><label class="expand" for="c-42572815">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Once the connection is upgraded, you loose all metadata included in the HTTP headers (because it’s not HTTP) and all protections relying on it.<p>The Upgrade request is HTTP and you can extract all needed metadata from there and store it server side as needed. Those metadata wouldn&#x27;t change during an active WebSocket session anyway, would they?</div><br/></div></div></div></div></div></div></div></div><div id="42572201" class="c"><input type="checkbox" id="c-42572201" checked=""/><div class="controls bullet"><span class="by">upghost</span><span>|</span><a href="#42572074">parent</a><span>|</span><a href="#42572529">prev</a><span>|</span><a href="#42572113">next</a><span>|</span><label class="collapse" for="c-42572201">[-]</label><label class="expand" for="c-42572201">[1 more]</label></div><br/><div class="children"><div class="content">They seem to handle a lot of nontrivial issues I have to deal with frequently like synchronization, but weirdly enough they do it with JWTs. For me the entire point of SSEs is that I can avoid using JWTs and use standard session logic which is very easy to reason about.<p>By the way I&#x27;m sure JWTs are fine not trying to step on any toes I&#x27;m just not an expert with them and I know there are footguns so with security stuff I stick to the most boring technology I have access to.</div><br/></div></div><div id="42572113" class="c"><input type="checkbox" id="c-42572113" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#42572074">parent</a><span>|</span><a href="#42572201">prev</a><span>|</span><a href="#42572096">next</a><span>|</span><label class="collapse" for="c-42572113">[-]</label><label class="expand" for="c-42572113">[1 more]</label></div><br/><div class="children"><div class="content">The site offers a little more detail:<p><a href="https:&#x2F;&#x2F;mercure.rocks&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mercure.rocks&#x2F;</a><p>Basically its server sent events with some stuff on top:<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent_events&#x2F;Using_server-sent_events" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Server-sent...</a><p>One big benefit of SSE is that you can put them behind a CDN, making scaling a lot easier. No idea about what Mercure brings there, though.</div><br/></div></div><div id="42572096" class="c"><input type="checkbox" id="c-42572096" checked=""/><div class="controls bullet"><span class="by">gorjusborg</span><span>|</span><a href="#42572074">parent</a><span>|</span><a href="#42572113">prev</a><span>|</span><a href="#42572198">next</a><span>|</span><label class="collapse" for="c-42572096">[-]</label><label class="expand" for="c-42572096">[1 more]</label></div><br/><div class="children"><div class="content">Along the same lines, what is the need for an alternative to SSE?<p>There are some issues with SSE in HTTP&#x2F;1.1, but HTTP&#x2F;2 pretty much fixes those.<p>I am curious what problem(s) are being targeted with this solution.</div><br/></div></div><div id="42572198" class="c"><input type="checkbox" id="c-42572198" checked=""/><div class="controls bullet"><span class="by">conradfr</span><span>|</span><a href="#42572074">parent</a><span>|</span><a href="#42572096">prev</a><span>|</span><a href="#42572461">next</a><span>|</span><label class="collapse" for="c-42572198">[-]</label><label class="expand" for="c-42572198">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s targeted at PHP apps.<p>You can use it with Symfony&#x27;s copy of Phoenix LiveView for example.</div><br/><div id="42572518" class="c"><input type="checkbox" id="c-42572518" checked=""/><div class="controls bullet"><span class="by">rbrtdrmpc-</span><span>|</span><a href="#42572074">root</a><span>|</span><a href="#42572198">parent</a><span>|</span><a href="#42572461">next</a><span>|</span><label class="collapse" for="c-42572518">[-]</label><label class="expand" for="c-42572518">[1 more]</label></div><br/><div class="children"><div class="content">It is targeted to the PHP community, not the language, it has no dependency on that, it is written in go and is based on caddy. (I’ve contributed with one PR in my former job)</div><br/></div></div></div></div><div id="42572461" class="c"><input type="checkbox" id="c-42572461" checked=""/><div class="controls bullet"><span class="by">Timber-6539</span><span>|</span><a href="#42572074">parent</a><span>|</span><a href="#42572198">prev</a><span>|</span><a href="#42572712">next</a><span>|</span><label class="collapse" for="c-42572461">[-]</label><label class="expand" for="c-42572461">[2 more]</label></div><br/><div class="children"><div class="content">SSE fixes some of the cargo cult practices formed around Websockets.</div><br/><div id="42572846" class="c"><input type="checkbox" id="c-42572846" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42572074">root</a><span>|</span><a href="#42572461">parent</a><span>|</span><a href="#42572712">next</a><span>|</span><label class="collapse" for="c-42572846">[-]</label><label class="expand" for="c-42572846">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div></div></div></div></div><div id="42572712" class="c"><input type="checkbox" id="c-42572712" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#42572074">prev</a><span>|</span><a href="#42572597">next</a><span>|</span><label class="collapse" for="c-42572712">[-]</label><label class="expand" for="c-42572712">[1 more]</label></div><br/><div class="children"><div class="content">I like it; too much stuff to write yourself with websockets.</div><br/></div></div><div id="42572597" class="c"><input type="checkbox" id="c-42572597" checked=""/><div class="controls bullet"><span class="by">h4ch1</span><span>|</span><a href="#42572712">prev</a><span>|</span><a href="#42572553">next</a><span>|</span><label class="collapse" for="c-42572597">[-]</label><label class="expand" for="c-42572597">[2 more]</label></div><br/><div class="children"><div class="content">Does it still have the limitation of SSE ie; it&#x27;ll stop working after you open 6 tabs?</div><br/><div id="42572628" class="c"><input type="checkbox" id="c-42572628" checked=""/><div class="controls bullet"><span class="by">kdunglas</span><span>|</span><a href="#42572597">parent</a><span>|</span><a href="#42572553">next</a><span>|</span><label class="collapse" for="c-42572628">[-]</label><label class="expand" for="c-42572628">[1 more]</label></div><br/><div class="children"><div class="content">This limitation is gone with HTTP&#x2F;2 and HTTP&#x2F;3 and the Mercure hub automatically use the most recent protocol supported by the browser.</div><br/></div></div></div></div></div></div></div></div></div></body></html>