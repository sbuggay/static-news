<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1710234066489" as="style"/><link rel="stylesheet" href="styles.css?v=1710234066489"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jsoncanvas.org/">JSON Canvas – An open file format for infinite canvas data</a> <span class="domain">(<a href="https://jsoncanvas.org">jsoncanvas.org</a>)</span></div><div class="subtext"><span>nickmain</span> | <span>126 comments</span></div><br/><div><div id="39671574" class="c"><input type="checkbox" id="c-39671574" checked=""/><div class="controls bullet"><span class="by">kepano</span><span>|</span><a href="#39672438">next</a><span>|</span><label class="collapse" for="c-39671574">[-]</label><label class="expand" for="c-39671574">[33 more]</label></div><br/><div class="children"><div class="content">Whoa! Didn&#x27;t expect this to bubble up to the top of HN. Some context about why we created JSON Canvas:<p><a href="https:&#x2F;&#x2F;obsidian.md&#x2F;blog&#x2F;json-canvas&#x2F;" rel="nofollow">https:&#x2F;&#x2F;obsidian.md&#x2F;blog&#x2F;json-canvas&#x2F;</a><p>We just released it today, so this is still a very nascent project. A little over a year ago we released Obsidian Canvas. The .canvas file format has felt stable enough to give it a name and resources that other apps can freely use. See the original Show HN:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34066824">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34066824</a><p>The spec is conservative, and definitely does not support many features canvas apps will want to implement (yet).<p>The purpose of giving JSON Canvas a name and site is to encourage an interoperable ecosystem to grow around this format. We&#x27;re definitely looking for feedback of all kinds!<p>It&#x27;s great to see all the suggestions already shared in this thread because it starts to provide a roadmap for how this could become a more useful format for other apps.</div><br/><div id="39672161" class="c"><input type="checkbox" id="c-39672161" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#39671574">parent</a><span>|</span><a href="#39677027">next</a><span>|</span><label class="collapse" for="c-39672161">[-]</label><label class="expand" for="c-39672161">[17 more]</label></div><br/><div class="children"><div class="content">Who was involved in this open spec? Or was it built by Obsidian with a hope that it works for everyone else?<p>Which existing formats were considered before building your own, e.g. SVG&#x2F;Excalidraw&#x2F;draw.io&#x2F;...?</div><br/><div id="39673178" class="c"><input type="checkbox" id="c-39673178" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39672161">parent</a><span>|</span><a href="#39674525">next</a><span>|</span><label class="collapse" for="c-39673178">[-]</label><label class="expand" for="c-39673178">[14 more]</label></div><br/><div class="children"><div class="content">Yeah, didn&#x27;t see any discussion in the other thread, do you have any notes on why this isn&#x27;t SVG?</div><br/><div id="39673705" class="c"><input type="checkbox" id="c-39673705" checked=""/><div class="controls bullet"><span class="by">npunt</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673178">parent</a><span>|</span><a href="#39674027">next</a><span>|</span><label class="collapse" for="c-39673705">[-]</label><label class="expand" for="c-39673705">[9 more]</label></div><br/><div class="children"><div class="content">It makes sense if you see Obsidian as the starting point - it&#x27;s a document store. While other canvas products may be more graphics-oriented, Obsidian&#x27;s is about laying out documents and objects and providing simple relationships between them. For this purpose, JSON&#x27;s probably a lot easier to work with than XML&#x2F;SVG.</div><br/><div id="39674983" class="c"><input type="checkbox" id="c-39674983" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673705">parent</a><span>|</span><a href="#39674027">next</a><span>|</span><label class="collapse" for="c-39674983">[-]</label><label class="expand" for="c-39674983">[8 more]</label></div><br/><div class="children"><div class="content">Obsidian&#x27;s own file format might have merit, but posting it as an &quot;open file format&quot;, &quot;created to provide (...) interoperability, and extensibility to data created with infinite canvas apps&quot;... and then publishing 1.0 without consulting with anybody else... is rather egregious, I think.<p>I agree with you that posting Obsidian&#x27;s spec to start the conversation would have been welcome, but this is not what they did.</div><br/><div id="39675437" class="c"><input type="checkbox" id="c-39675437" checked=""/><div class="controls bullet"><span class="by">npunt</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39674983">parent</a><span>|</span><a href="#39675081">next</a><span>|</span><label class="collapse" for="c-39675437">[-]</label><label class="expand" for="c-39675437">[4 more]</label></div><br/><div class="children"><div class="content">Obsidian&#x27;s philosophy is <i>file over app</i> [1] and releasing a spec for their Canvas feature is fulfilling that promise. It&#x27;s a strictly positive &#x27;today is better than yesterday&#x27; thing for them to have done so.<p>You shouldn&#x27;t need to ask permission or consult anyone to do this. That&#x27;s a silly bar, &#x27;egregious&#x27; even. When markdown was created, Gruber wasn&#x27;t asking all his friends making text editors whether they&#x27;d support it. He just released it, and others chose to adopt it on its merits.<p>I don&#x27;t meant this to sound harsh, but just to call it as I see it - your comment is basically creating a &#x27;damned if you do, damned if you don&#x27;t&#x27; scenario and an example of why people building things shouldn&#x27;t worry much about comments in forums.<p>[1]: <a href="https:&#x2F;&#x2F;stephango.com&#x2F;file-over-app" rel="nofollow">https:&#x2F;&#x2F;stephango.com&#x2F;file-over-app</a></div><br/><div id="39675571" class="c"><input type="checkbox" id="c-39675571" checked=""/><div class="controls bullet"><span class="by">gcr</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39675437">parent</a><span>|</span><a href="#39675081">next</a><span>|</span><label class="collapse" for="c-39675571">[-]</label><label class="expand" for="c-39675571">[3 more]</label></div><br/><div class="children"><div class="content">I’m glad Obsidian is publishing this, even though the spec clearly isn’t ready yet.<p>If I had the final say for how this format were to be publicized, I would probably just include the JSON schema “as-is” in the Obsidian developer docs. Then, it’s just as usable by third parties without making promises about interoperability.<p>But Obsidian is thinking ahead here. They’ve intentionally given us a duck to poke at[1], knowing we’d offer feedback and critique. If the goal is to get people to imagine a better implementation, preying on HN’s “I could implement this so much better” sense is one hecking smart way to get the community to pitch in.<p>1: <a href="https:&#x2F;&#x2F;bwiggs.com&#x2F;notebook&#x2F;queens-duck&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bwiggs.com&#x2F;notebook&#x2F;queens-duck&#x2F;</a></div><br/><div id="39677340" class="c"><input type="checkbox" id="c-39677340" checked=""/><div class="controls bullet"><span class="by">rahoulb</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39675571">parent</a><span>|</span><a href="#39675762">next</a><span>|</span><label class="collapse" for="c-39677340">[-]</label><label class="expand" for="c-39677340">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Then, it’s just as usable by third parties without making promises about interoperability.<p>I&#x27;d say this is the point.<p>If it&#x27;s &quot;published as part of Obsidian&quot; it implies Obsidian can break it at any time and the interop anyone else has built will need updating.  But &quot;published as a standalone spec&quot; means Obsidian is saying &quot;we won&#x27;t change this without warning&quot; (at the very least).</div><br/></div></div><div id="39675762" class="c"><input type="checkbox" id="c-39675762" checked=""/><div class="controls bullet"><span class="by">npunt</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39675571">parent</a><span>|</span><a href="#39677340">prev</a><span>|</span><a href="#39675081">next</a><span>|</span><label class="collapse" for="c-39675762">[-]</label><label class="expand" for="c-39675762">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, whether or not it&#x27;s intentional, the approach taken is one that will generate a lot of feedback.<p>I haven&#x27;t seen anyone mention it in this thread, but my immediate reaction to seeing JSON Canvas was that it looks like a spiritual sibling to Markdown, a famously (and intentionally) informal spec.<p>There&#x27;s a real wisdom to this informal spec approach, and it&#x27;s worked incredibly well for Markdown despite grumblings about its lack of standardization.<p>I imagine this is the Obsidian team&#x27;s intention with JSON Canvas. Obsidian has really benefitted from the informality of Markdown, which meant they were free to extend it in ways that made sense to the product (with things like cross-page ^ references, yaml frontmatter, etc), without triggering the Spec Police. The same perhaps applies here to Canvas products.</div><br/></div></div></div></div></div></div><div id="39675081" class="c"><input type="checkbox" id="c-39675081" checked=""/><div class="controls bullet"><span class="by">rat9988</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39674983">parent</a><span>|</span><a href="#39675437">prev</a><span>|</span><a href="#39675546">next</a><span>|</span><label class="collapse" for="c-39675081">[-]</label><label class="expand" for="c-39675081">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure I agree with you here at all. They can start a format that serves their own purpose, and make it open for interoperability and extensibility sake. Nothing wrong with it.</div><br/></div></div><div id="39675546" class="c"><input type="checkbox" id="c-39675546" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39674983">parent</a><span>|</span><a href="#39675081">prev</a><span>|</span><a href="#39674027">next</a><span>|</span><label class="collapse" for="c-39675546">[-]</label><label class="expand" for="c-39675546">[2 more]</label></div><br/><div class="children"><div class="content">This is an odd bit of gatekeeping  and I really don’t understand your position here. Calling this egregious seems odder still. It suggests that companies that choose to publish how they do things have some obligation to do so under a specific framework or shouldn’t do so unless they’re willing to get public buyin.<p>Many of the best projects that become defacto standards start as a solution to a very specific and real problem that had no public input.<p>If JSON canvas isn’t a good solution for broad adoption&#x2F;interoperability, it won’t become one. The world is not harmed by its release, and at worst, it’s now far easier for people building software to understand and make tools that can interact with Obsidian. At best, it becomes a solid foundation and option for tools going forward.<p>Obsidian didn’t have to do anything here. I’m glad they did.</div><br/><div id="39676557" class="c"><input type="checkbox" id="c-39676557" checked=""/><div class="controls bullet"><span class="by">blowski</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39675546">parent</a><span>|</span><a href="#39674027">next</a><span>|</span><label class="collapse" for="c-39676557">[-]</label><label class="expand" for="c-39676557">[1 more]</label></div><br/><div class="children"><div class="content">And indeed, there are many projects that spend so long trying to gather and process feedback that it becomes a talking shop with no useful output. Better to share something early and then iterate.</div><br/></div></div></div></div></div></div></div></div><div id="39674027" class="c"><input type="checkbox" id="c-39674027" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673178">parent</a><span>|</span><a href="#39673705">prev</a><span>|</span><a href="#39676841">next</a><span>|</span><label class="collapse" for="c-39674027">[-]</label><label class="expand" for="c-39674027">[3 more]</label></div><br/><div class="children"><div class="content">SVG is great and you are the first person I have ever seen who would (and did) imply that SVG might be or would be better than JSON for this kind of thing.<p>SVG <i>really</i> stretches the “human readable” thing to its limit, and I personally would not adopt an SVG-like format for anything that isn’t SVG.</div><br/><div id="39674927" class="c"><input type="checkbox" id="c-39674927" checked=""/><div class="controls bullet"><span class="by">eichin</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39674027">parent</a><span>|</span><a href="#39674851">next</a><span>|</span><label class="collapse" for="c-39674927">[-]</label><label class="expand" for="c-39674927">[1 more]</label></div><br/><div class="children"><div class="content">Looking at the samples, this isn&#x27;t human readable either (long opaque id strings for linking dominate the syntax) and both syntaxes have vast amounts of punctuation and whitespace. And neither of them are particularly human writable.  But something svg-based would have lots of existing options for additional processing in consistent ways, that would be ad-hoc for a json-based syntax.<p>(Given that this is coming from obsidian, I kind of expected something actually  markdown-like - which would certainly be a challenge, but not an impossible one.)<p>Granted, this notation is a little higher level than SVG, so the model mismatch might be a bigger problem anyway?</div><br/></div></div></div></div><div id="39676841" class="c"><input type="checkbox" id="c-39676841" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673178">parent</a><span>|</span><a href="#39674027">prev</a><span>|</span><a href="#39674525">next</a><span>|</span><label class="collapse" for="c-39676841">[-]</label><label class="expand" for="c-39676841">[1 more]</label></div><br/><div class="children"><div class="content">SVG is a very poor format by all measures so if you can start from scratch for your use case you should definitely avoid it. I&#x27;m still glad SVG exists because it&#x27;s available on the web for free, but this file format is really a mess (very hard to parse, the feature set is so broad it&#x27;s never entirely implemented and the implantations diverge making it surprisingly hard to support multiple browsers).</div><br/></div></div></div></div><div id="39674525" class="c"><input type="checkbox" id="c-39674525" checked=""/><div class="controls bullet"><span class="by">Idiot211</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39672161">parent</a><span>|</span><a href="#39673178">prev</a><span>|</span><a href="#39677027">next</a><span>|</span><label class="collapse" for="c-39674525">[-]</label><label class="expand" for="c-39674525">[2 more]</label></div><br/><div class="children"><div class="content">Relevant XKCD:<p><a href="https:&#x2F;&#x2F;xkcd.com&#x2F;927" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;927</a></div><br/><div id="39674558" class="c"><input type="checkbox" id="c-39674558" checked=""/><div class="controls bullet"><span class="by">kepano</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39674525">parent</a><span>|</span><a href="#39677027">next</a><span>|</span><label class="collapse" for="c-39674558">[-]</label><label class="expand" for="c-39674558">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t believe it took this long for someone to post this haha</div><br/></div></div></div></div></div></div><div id="39677027" class="c"><input type="checkbox" id="c-39677027" checked=""/><div class="controls bullet"><span class="by">tylerdurden91</span><span>|</span><a href="#39671574">parent</a><span>|</span><a href="#39672161">prev</a><span>|</span><a href="#39672204">next</a><span>|</span><label class="collapse" for="c-39677027">[-]</label><label class="expand" for="c-39677027">[1 more]</label></div><br/><div class="children"><div class="content">Great work &amp; thanks for doing this.<p>I built a library at AWS for a general canvas editor called Diagram Maker. It recently got archived so I stood up a fork here: <a href="https:&#x2F;&#x2F;github.com&#x2F;sameergoyal&#x2F;diagrammer">https:&#x2F;&#x2F;github.com&#x2F;sameergoyal&#x2F;diagrammer</a> and the data format we use is strikingly similar. Check it out here: <a href="https:&#x2F;&#x2F;sameergoyal.github.io&#x2F;diagrammer&#x2F;?path=&#x2F;docs&#x2F;docs-usage-state--docs" rel="nofollow">https:&#x2F;&#x2F;sameergoyal.github.io&#x2F;diagrammer&#x2F;?path=&#x2F;docs&#x2F;docs-us...</a>. The key differences are panels, workspace &amp; editor.<p>I dont actively work on the project outside of bugs, but maybe there are ways to collaborate here, like moving my project to use &amp; extend the JSON canvas spec.</div><br/></div></div><div id="39672204" class="c"><input type="checkbox" id="c-39672204" checked=""/><div class="controls bullet"><span class="by">altairprime</span><span>|</span><a href="#39671574">parent</a><span>|</span><a href="#39677027">prev</a><span>|</span><a href="#39672401">next</a><span>|</span><label class="collapse" for="c-39672204">[-]</label><label class="expand" for="c-39672204">[2 more]</label></div><br/><div class="children"><div class="content">For those having difficulty viewing the spec at the linked jsoncanvas.org site, the spec&#x2F;1.0 pane on the right has the scrollbar hidden; there&#x27;s more content if you scroll that pane down.</div><br/><div id="39674116" class="c"><input type="checkbox" id="c-39674116" checked=""/><div class="controls bullet"><span class="by">hiccuphippo</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39672204">parent</a><span>|</span><a href="#39672401">next</a><span>|</span><label class="collapse" for="c-39674116">[-]</label><label class="expand" for="c-39674116">[1 more]</label></div><br/><div class="children"><div class="content">Click the spec link, it shows the same content in a full page.</div><br/></div></div></div></div><div id="39672401" class="c"><input type="checkbox" id="c-39672401" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671574">parent</a><span>|</span><a href="#39672204">prev</a><span>|</span><a href="#39672438">next</a><span>|</span><label class="collapse" for="c-39672401">[-]</label><label class="expand" for="c-39672401">[12 more]</label></div><br/><div class="children"><div class="content">I agree with a lot of comments that it&#x27;s minimal, but in my opinion that is a good thing. I&#x27;m a big fan of Obsidian, and of the things I like about it is the data source is all markdown files. Markdown is meant to be very lightweight and portable, and overcomplicating it will limit adoption and extensibility (imagine markdown vs pdf).<p>JSON Canvas seems to follow in that spirit by being very lightweight, so a lot of implementation details (i.e. how are files rendered, what file formats are supported, etc), edit tags, etc) are left open to implementation.<p>Markdown and JSON are meant to be non-opague file formats that prioritizes portability and human readability over other features. An application format like Sqlite has a lot of benefits over markdown, but it loses the benefits of text based formats like being compatible with git and is less portable.<p>What I would like to see is a convention for extending the node and edge definitions, similar to frontmatter in markdown files- something that is not <i>required</i> for basic rendering but is a nice-to-have for applications to consume) - that way portability between apps of varying complexity can be maximized while still allowing for more complex features that some apps might implement. Markdown has the benefit of supporting extensions (for example like tables in GFM) - apps that are not compatible can still render the unsupported markup. But there should be an explicit way to extend open JSON formats.<p>Some feedback off the top of my head and from reading the comments:<p>1. *Specifying node ordering*. Obsidian seems to just send whatever is last touched to the top, but this makes a common feature in many apps (move up&#x2F;down&#x2F;back&#x2F;front) more difficult to impement<p>2.*More explicit definition for line shape*. Adding a way to &quot;bend&quot; a line in a specific way. Useful for creating more complex diagrams.<p>3. *Relations between nodes*. Group nodes contain child nodes, but the spec doesn&#x27;t specify how the child nodes are defined. I would expect it to have a `children` property to nest nodes. Obsidian seems to implicitly link nodes to groups based on whether their bounds intersect. This makes it difficult to implement some common features:<p>a. nodes that exist outside of the bounds of its group, for example a node that &quot;floats&quot; just outside of the edge of the group&#x27;s borders.<p>b. nodes that are not part of a group even though it exists within the bounds of that group.<p>There are many different ways for a canvas app to extend the spec to implement those features, but it seems like something that should be defined in the spec to maximize portability<p>4. *Extensibility.* Either explicitly support or provide a standard for defining more styles for nodes and edges, such as stroke width, stroke style, rotation, etc. It seems like &quot;color&quot; should be a part of this as well, rather than being an explicit property of a node.<p>5. *Embeds.* Supporting &quot;embeds&quot; as a node type. I even think the &quot;file&quot; node should be redefined as `embed` with a `uri` property to support different schemes (`file:&#x2F;&#x2F;`, `oembed:&#x2F;&#x2F;`, `<a href="https:&#x2F;&#x2F;" rel="nofollow">https:&#x2F;&#x2F;</a>`) and maybe a `mime-type` (`text&#x2F;markdown`, `image&#x2F;webp`). The file node&#x27;s &quot;subpath&quot; property seems to be only relevant for markdown files, so I think that should be an extension rather than an explicitly defined.<p>6.*YAML* :) (Should just seemlessly convert from json, but yaml is more readable than json)<p>Being able to design standards that evolve over time and making tough decisions about what what to make explicit and what to leave implicit is a skill I want to improve on as a developer this year. Does anyone have any resource recommendations or best practices to recommend for me to research?</div><br/><div id="39673011" class="c"><input type="checkbox" id="c-39673011" checked=""/><div class="controls bullet"><span class="by">exceptione</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39672401">parent</a><span>|</span><a href="#39673085">next</a><span>|</span><label class="collapse" for="c-39673011">[-]</label><label class="expand" for="c-39673011">[7 more]</label></div><br/><div class="children"><div class="content">&gt; 6. YAML<p>Please don&#x27;t, it has one of the most confusing syntax out there with lists and maps, and it won&#x27;t do well for parsing.</div><br/><div id="39673081" class="c"><input type="checkbox" id="c-39673081" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673011">parent</a><span>|</span><a href="#39673085">next</a><span>|</span><label class="collapse" for="c-39673081">[-]</label><label class="expand" for="c-39673081">[6 more]</label></div><br/><div class="children"><div class="content">I haven’t had any issues with yaml in markdown frontmatter or openapi specs. What kind of issues do you see with list and maps that make you against yaml? I agree that for computers and consistency json is preferred. I already use a linter for my markdown files so I would do the same with yaml to keep lists and maps consistent</div><br/><div id="39673264" class="c"><input type="checkbox" id="c-39673264" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673081">parent</a><span>|</span><a href="#39673414">next</a><span>|</span><label class="collapse" for="c-39673264">[-]</label><label class="expand" for="c-39673264">[4 more]</label></div><br/><div class="children"><div class="content">YAML is kind of like C++:<p>&gt; You like C++ because you&#x27;re only using 20% of it. And that&#x27;s fine, everyone only uses 20% of C++, the problem is that everyone uses a different 20% :)<p><a href="https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2009&#x2F;10&#x2F;17&#x2F;the-c-bashing-season-is-back" rel="nofollow">https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2009&#x2F;10&#x2F;17&#x2F;the-c-bashing-seaso...</a><p>The YAML footguns are too numerous to reproduce here, so here are some sources:<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;3790454&#x2F;how-do-i-break-a-string-in-yaml-over-multiple-lines&#x2F;21699210#21699210" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;3790454&#x2F;how-do-i-break-a...</a><p><a href="https:&#x2F;&#x2F;www.arp242.net&#x2F;yaml-config.html" rel="nofollow">https:&#x2F;&#x2F;www.arp242.net&#x2F;yaml-config.html</a><p><a href="https:&#x2F;&#x2F;noyaml.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;noyaml.com&#x2F;</a><p>YAML isn&#x27;t terrible if you only ever have to read what <i>you</i> wrote. Now consider that there are 63 different ways to write multi-line strings in YAML -- how many of those have you committed to memory? Yeah... now throw 10-100 developers into the mix, each with their own favorite alternative syntaxes -- good luck making sense of your YAML.</div><br/><div id="39673318" class="c"><input type="checkbox" id="c-39673318" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673264">parent</a><span>|</span><a href="#39673606">next</a><span>|</span><label class="collapse" for="c-39673318">[-]</label><label class="expand" for="c-39673318">[1 more]</label></div><br/><div class="children"><div class="content">Yeah true, I&#x27;m starting to remember the headaches with yaml when I was using kubernetes or cloudformation....</div><br/></div></div><div id="39673606" class="c"><input type="checkbox" id="c-39673606" checked=""/><div class="controls bullet"><span class="by">bbkane</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673264">parent</a><span>|</span><a href="#39673318">prev</a><span>|</span><a href="#39673414">next</a><span>|</span><label class="collapse" for="c-39673606">[-]</label><label class="expand" for="c-39673606">[2 more]</label></div><br/><div class="children"><div class="content">Point taken, but you can mitigate a lot of this with yamllint.</div><br/><div id="39676724" class="c"><input type="checkbox" id="c-39676724" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673606">parent</a><span>|</span><a href="#39673414">next</a><span>|</span><label class="collapse" for="c-39676724">[-]</label><label class="expand" for="c-39676724">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty sad that you need to lint your config lang.</div><br/></div></div></div></div></div></div><div id="39673414" class="c"><input type="checkbox" id="c-39673414" checked=""/><div class="controls bullet"><span class="by">exceptione</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673081">parent</a><span>|</span><a href="#39673264">prev</a><span>|</span><a href="#39673085">next</a><span>|</span><label class="collapse" for="c-39673414">[-]</label><label class="expand" for="c-39673414">[1 more]</label></div><br/><div class="children"><div class="content">In the past I had to craft yaml files. Sometimes I needed quotes for a string, sometimes I had to put in a dash in front of a key, or just not. You basically needed to have the whole schema in your head.<p>There can only be so much nesting before you lose track of what item belong to which parent. 
Copying some yaml structures over to another level requires care, as the result might look correct, but the white space parser thinks otherwise.<p>I have lost hours of debugging yaml files when a dash was missing somewhere or when I needed one more leading space. The parser accepts it happily, but half of the typical javascript programs will only detect things are wrong when it has already executed on half of your spec. The other half will just run with input that wasn&#x27;t intended that way.<p>I remember writing artillery.io test specs where all those problems pop up.<p><i>Now the good thing from JSON is JSON Schema</i>. The latest spec allows you to specify quite advanced validations. 
Yaml has no such thing.<p>As to your remark: Yaml for front matter is defensible, as you dont have deeply nested structures. Though, as an obsidian user you want to make sure your front-matter is conforming to your own schema. That would require writing a json spec and then have your yaml internally converted to json before handing it over to the validator.<p>A spec is worthless if you cannot validate against it. Json and xml have a good story there. 
I concede that yaml is more human-readable than json without an editor. Correctness is the holy grail though.</div><br/></div></div></div></div></div></div><div id="39673085" class="c"><input type="checkbox" id="c-39673085" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39672401">parent</a><span>|</span><a href="#39673011">prev</a><span>|</span><a href="#39673608">next</a><span>|</span><label class="collapse" for="c-39673085">[-]</label><label class="expand" for="c-39673085">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Markdown and JSON are meant to be non-opague file formats that prioritizes portability and human readability over other features<p>I don&#x27;t think human readability is a critical feature of JSON at this point. If that&#x27;s your priority, you can use YAML. Readable JSON is nice because for small files you can read or edit small sections of it, and it&#x27;s easy to debug when manipulating it with machine code. But there are plenty of cases where a huge JSON file is still useful even if it&#x27;s barely human readable.<p>My heuristic has always been: use YAML if you expect humans to create the file (or maintain large chunks of it), otherwise use JSON. For example, Kubernetes config is YAML because humans create it from scratch, and it would suck to do that with JSON. Whereas package.json is JSON because machine code initializes it and humans only make minor edits to specific fields.<p>In the case of this canvas format, I wouldn&#x27;t expect humans to create the file from scratch, so use JSON over YAML. Then the question is, will humans even care about <i>reading</i> the raw JSON? Probably not. So why not use something like SQLite or Protobuf? The most compelling reason would be that humans writing code to interface with the format can use parsing tools from their language&#x27;s standard library.</div><br/><div id="39673139" class="c"><input type="checkbox" id="c-39673139" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673085">parent</a><span>|</span><a href="#39674083">next</a><span>|</span><label class="collapse" for="c-39673139">[-]</label><label class="expand" for="c-39673139">[1 more]</label></div><br/><div class="children"><div class="content">Yep, I think the compelling reason of humans writing code is key here. SQLite would make it less accessible for people to write external tooling to integrate with an obsidian vault. There are lots of existing and open that support diffing&#x2F;parsing&#x2F;syncing&#x2F;manipulating json, while with sqlite you have to not only know sql but support another application’s database schema, which third party developers are less likely to do</div><br/></div></div><div id="39674083" class="c"><input type="checkbox" id="c-39674083" checked=""/><div class="controls bullet"><span class="by">naikrovek</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39673085">parent</a><span>|</span><a href="#39673139">prev</a><span>|</span><a href="#39673608">next</a><span>|</span><label class="collapse" for="c-39674083">[-]</label><label class="expand" for="c-39674083">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think human readability is a critical feature of JSON at this point. If that&#x27;s your priority, you can use YAML.<p>Wow you have kinda lost the plot on a few things.<p>JSON was designed to be human readable and writable.  YAML was designed to be a human readable format for the automated interchange of data between automated systems.  Human writability was neither a goal for YAML nor its intended use.  Like everyone else on the frakking planet, you’ve misunderstood what YAML was intended and designed for.  YAML was never intended for human-written configuration storage, which is what everyone used it for the instant after they became aware of it.<p>YAML can bite you very hard if you misunderstand it.  JSON is simply invalid if you misunderstand it when writing it.<p>If you don’t need human readability, use a binary format.  Binary formats are <i>so freaking fast</i> compared to literally any structured text format, past, present, or future.  High speed and low latency matter and binary formats make both of those easier.<p>If you need to inspect the binary data, write a viewer using the code you use to read it.  It’s a lot simpler than people believe it to be.  I find Protobuf to be more of a hassle than writing the code myself, and protobuf is very easy to use, and I’m quite a moron.  Binary stuff is not hard.</div><br/></div></div></div></div><div id="39673608" class="c"><input type="checkbox" id="c-39673608" checked=""/><div class="controls bullet"><span class="by">louthy</span><span>|</span><a href="#39671574">root</a><span>|</span><a href="#39672401">parent</a><span>|</span><a href="#39673085">prev</a><span>|</span><a href="#39672438">next</a><span>|</span><label class="collapse" for="c-39673608">[-]</label><label class="expand" for="c-39673608">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I agree with a lot of comments that it&#x27;s minimal, but in my opinion that is a good thing<p>The purpose of a spec is to specify, and if you don’t specify and leave things open to interpretation, then that completely defeats the purpose.<p>Anybody who’s worked with a poorly defined spec knows exactly how bad this can be. A good example would be the shambles that is the HL7 spec used in healthcare.<p>A former colleague had a phrase for this: “once you’ve seen one HL7 message… you’ve seen one HL7 message”. Which really highlights the issue of a standard that’s open to interpretation.<p>The issues raised (in the comments here) seem to hint at a lack of specificity. That is something that they should really look at improving.<p>I think overall any group that tries to come up with a standard that can unify a field should be lauded and supported. But perhaps calling this a 0.1 release, and taking the feedback on board, would be the best way forward.</div><br/></div></div></div></div></div></div><div id="39672438" class="c"><input type="checkbox" id="c-39672438" checked=""/><div class="controls bullet"><span class="by">gcr</span><span>|</span><a href="#39671574">prev</a><span>|</span><a href="#39672023">next</a><span>|</span><label class="collapse" for="c-39672438">[-]</label><label class="expand" for="c-39672438">[5 more]</label></div><br/><div class="children"><div class="content">This is a great idea. For now though, the spec is under-specified and ambiguously terse. A few points that could be clarified:<p>- How do coordinates work? Does +Y point up (OpenGL) or down (web)? Is the origin meaningful? What are the units - how does this interact with font sizes? High-DPI displays?<p>- What’s the difference between a file node and a URL node linking to file:&#x2F;&#x2F;.&#x2F;? Are files supposed to be transcluded? What filetypes are allowed? The home page seems to have an image — was this done using a file node or a markdown node with an &lt;img &#x2F;&gt; element?<p>- What HTML tags are allowable in markdown? Is JavaScript allowed?<p>- Why does the group node allow a background image? If both image and color are specified, which takes precedence? How are children of the group specified?<p>A couple feature requests for extensibility or interoperability with Excalidraw and TLDRaw and friends: drawings &#x2F; scribbles, predefined shapes like circle or rectangles, ability to specify fill style, edge width, transparency, ability to embed images, more detailed placement for connector start&#x2F;end points, etc.</div><br/><div id="39674678" class="c"><input type="checkbox" id="c-39674678" checked=""/><div class="controls bullet"><span class="by">SpaghettiCthulu</span><span>|</span><a href="#39672438">parent</a><span>|</span><a href="#39676380">next</a><span>|</span><label class="collapse" for="c-39674678">[-]</label><label class="expand" for="c-39674678">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Is the origin meaningful?<p>I assume no.<p>&gt; What are the units<p>Arbitrary. The website says pixels, but the demo lets you zoom in and out, so I think defining the unit as pixels is pretty meaningless, except as a <i>hint</i> to the viewer of the initial scale for the canvas. Even then I can see good reasons for a viewer program to just ignore that and use whatever initial scale allows everything to fit on screen.<p>&gt; how does this interact with font sizes?<p>Seems like the font size can&#x27;t be changed, but I&#x27;d imagine it&#x27;s a specific number of units.<p>&gt; High-DPI displays?<p>Not sure what kind of answer you&#x27;re looking for here. You can just scale everything, so support for High-DPI displays would be up to the viewer program.</div><br/><div id="39675510" class="c"><input type="checkbox" id="c-39675510" checked=""/><div class="controls bullet"><span class="by">gcr</span><span>|</span><a href="#39672438">root</a><span>|</span><a href="#39674678">parent</a><span>|</span><a href="#39676380">next</a><span>|</span><label class="collapse" for="c-39675510">[-]</label><label class="expand" for="c-39675510">[1 more]</label></div><br/><div class="children"><div class="content">I know this isn’t intended as a document presentation format, but for a consistent layout, it would be a good idea to specify the ratio between pixels (for layout) and font size (in pt). Otherwise, viewers would render text inconsistently-each node would be some ratio too big or too small for its contents.</div><br/></div></div></div></div><div id="39676380" class="c"><input type="checkbox" id="c-39676380" checked=""/><div class="controls bullet"><span class="by">gitgud</span><span>|</span><a href="#39672438">parent</a><span>|</span><a href="#39674678">prev</a><span>|</span><a href="#39672023">next</a><span>|</span><label class="collapse" for="c-39676380">[-]</label><label class="expand" for="c-39676380">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Is the origin meaningful?<p>I assume yes, as it makes placement of things much easier if they&#x27;re all relative to a known origin. The limits of the canvas would be &quot;<i>realistically infinite</i>&quot; in all directions though I assume...</div><br/><div id="39676760" class="c"><input type="checkbox" id="c-39676760" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#39672438">root</a><span>|</span><a href="#39676380">parent</a><span>|</span><a href="#39672023">next</a><span>|</span><label class="collapse" for="c-39676760">[-]</label><label class="expand" for="c-39676760">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know if &quot;realistically infinite&quot; does or doesn&#x27;t work here. A lot of video games with huge worlds start to break down with big coordinates due to loss of precision in the floats I presume.<p>If using integers, I&#x27;d cap it at 2^53 to align with js&#x27;s max safe integer which I think is just a double.</div><br/></div></div></div></div></div></div><div id="39672023" class="c"><input type="checkbox" id="c-39672023" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672438">prev</a><span>|</span><a href="#39672972">next</a><span>|</span><label class="collapse" for="c-39672023">[-]</label><label class="expand" for="c-39672023">[23 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked a few jobs now where application data was stored in text files of various kinds (homegrown as well as well-defined formats, JSON included) and it pretty quickly becomes a mess when you start talking about modifying it over time, evolving its schema, validating it in the face of end-user edits, ensuring threads don&#x27;t write to it concurrently, etc.<p>This strikes me as <i>exactly</i> the type of application data that would benefit from being represented in SQLite. Of course, JSON is a `JSON.parse` away, but now you&#x27;re building your own...everything else. Storage&#x2F;retrieval, validation, querying&#x2F;filtering&#x2F;indexing, graph traversal, etc. It&#x27;s all yours.<p>There&#x27;s so many benefits to building this kind of thing in SQLite. You get data validation, atomic transactions in memory and on disk, a high-level query interface, lazy loading (i.e., only load nodes at most 2 edges away), triggers (when I delete this node, automatically delete edges that point to it), and a stable on-disk format, to say nothing of the fact that SQLite itself is just about the most stable software there is.<p>By the way, no disrespect to JSON Canvas, it looks like good work, just trying to offer the perspective of someone who has done stuff like this in the past.</div><br/><div id="39672071" class="c"><input type="checkbox" id="c-39672071" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39672023">parent</a><span>|</span><a href="#39672909">next</a><span>|</span><label class="collapse" for="c-39672071">[-]</label><label class="expand" for="c-39672071">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;m usually the first person to suggest SQLite for just about anything, but in this particular case I do feel like JSON is a better default format.<p>Interacting with SQLite from different programming languages is easier than most other formats, but you still need a SQLite binding. They&#x27;re available for every language but that&#x27;s still a not-completely-trivial dependency.<p>I expect most tools that people build against JSON Canvas will run in a web browser. Adding SQLite as a dependency means you need SQLite running in WebAssembly - totally possible, and even officially supported these days (the SQLite team run their own WASM builds now) but still a sizable piece of extra complexity over just using JSON.parse(...)<p>Also: SQLite files aren&#x27;t very easy to diff, so they&#x27;re not great for collaboration in version control. JSON is better for that.<p>I&#x27;m 100% with you on the schema changes and versioning challenge. The best way to address this IMO would be for the spec to include a top-level &quot;version&quot;: key which indicates the version of the spec that a file was created against.<p>Handled carefully and introduced right at the start of the project this could ensure an ecosystem grows up around the standard such that older spec versions can always be opened by newer implementations, and any implementation can fail-fast if it is given a file that it doesn&#x27;t yet know how to handle.</div><br/><div id="39672446" class="c"><input type="checkbox" id="c-39672446" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672071">parent</a><span>|</span><a href="#39672909">next</a><span>|</span><label class="collapse" for="c-39672446">[-]</label><label class="expand" for="c-39672446">[4 more]</label></div><br/><div class="children"><div class="content">Valid points and I generally agree! I think you&#x27;re probably right that the SQLite dependency is possibly too much for some applications to pull in, though I will ask why we&#x27;re so often willing to pull in more or less anything else regardless of weight (DOM manipulation, state management, animation, etc.) but a robust data layer is often a bridge too far. I wish I knew why this is, as it seems to be one of the larger cultural differences between folks who work mainly &quot;on the backend&quot; and &quot;on the frontend&quot;.<p>&gt; Also: SQLite files aren&#x27;t very easy to diff, so they&#x27;re not great for collaboration in version control. JSON is better for that.<p>Yeah, if we&#x27;re talking about diffing the literal file itself, then that changes things. At that point, we&#x27;re not just talking about a storage format, we&#x27;re talking about interchange as well. In that case I&#x27;d ask - of course this is application specific, not general - what data are we putting on the wire? Where does that data live?<p>For example, if the main state state lives in a your browser instance, and you ship updates (i.e., &quot;CREATE&quot;, &quot;EDIT&quot;, &quot;DELETE&quot; or some such) back and forth between collaborators, then diffing the state of whatever you have is fairly easy, SQLite or JSON or whatever else. But if we&#x27;re shipping the actual file itself over the wire or attempting to version control it, then you&#x27;re absolutely right and diffing the SQLite file is inferior.<p>There are some interesting tradeoffs in this space. This is a fun discussion!</div><br/><div id="39672851" class="c"><input type="checkbox" id="c-39672851" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672446">parent</a><span>|</span><a href="#39672909">next</a><span>|</span><label class="collapse" for="c-39672851">[-]</label><label class="expand" for="c-39672851">[3 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re talking about the trade offs between supporting features like &quot;DOM manipulation, state management, animation, etc.&quot; and &quot;shipping updates&quot; out of the box, versus only storing the data as simple files and leaving everything else to the implementation.<p>Sqlite as an application file format is great [1], but for a knowledge base &#x2F; note taking app the benefits are not worth the tradeoffs in my opinion.<p>Sqlite is more performant more performant and provides lots of built-in features. However, most note taking users do not have enough notes or files to benefit from that performance. Sqlite will also lock the user into the application, whereas a &quot;pack of files&quot; can be used in the shell as a text editor. Using markdown files + a open json format has the benefit of being supported by multiple applications (e.g. sometimes i open my obsidian vault in vscode), while a sqlite database would need a proprietary schema coupled with a single application<p>I prefer an open file format that isn&#x27;t tied to a vendor. A &quot;data bridge&quot; might handle syncing and diffing more efficiently than plain files, but it is still tied to the vendor. For example, I prefer not to pay for Obsidian Sync, and I&#x27;m able to use a git plugin and storing my files on nextcloud to sync between my devices. This leverages existing tech without having to implement features from the ground up<p>[1] <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;appfileformat.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;appfileformat.html</a></div><br/><div id="39676164" class="c"><input type="checkbox" id="c-39676164" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672851">parent</a><span>|</span><a href="#39673176">next</a><span>|</span><label class="collapse" for="c-39676164">[-]</label><label class="expand" for="c-39676164">[1 more]</label></div><br/><div class="children"><div class="content">Except the markdown files are tied to a vendor outside of trivial formatting since it&#x27;s a simplistic underpecified format without extensions, so all these obsidians specify their own extensions to add complexity, which your vscode does not support (and neither would git diff help to see data change in a sea of formatting changes)<p>And this spec is for complicated layouts, not trivial notes you&#x27;re comparing it to, so your intuition from simple notes doesn&#x27;t translate to this use case</div><br/></div></div><div id="39673176" class="c"><input type="checkbox" id="c-39673176" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672851">parent</a><span>|</span><a href="#39676164">prev</a><span>|</span><a href="#39672909">next</a><span>|</span><label class="collapse" for="c-39673176">[-]</label><label class="expand" for="c-39673176">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think you&#x27;re talking about the trade offs between supporting features like &quot;DOM manipulation, state management, animation, etc.&quot; and &quot;shipping updates&quot; out of the box, versus only storing the data as simple files and leaving everything else to the implementation.<p>I&#x27;m not sure I understand. Can you clarify?<p>&gt; Sqlite is more performant more performant and provides lots of built-in features. However, most note taking users do not have enough notes or files to benefit from that performance.<p>For a graph with lots (thousands+) of nodes&#x2F;edges, SQLite is probably capable of being more performant than a JSON file, depending on whatever specific kind of performance we&#x27;re measuring. That said, to me, the most interesting thing that SQLite gives for applications when compared to flat files is data integrity, via transactions and schemas&#x2F;constraints. Performance is nice but not even close to the most interesting thing about SQLite in most applications. Performance has never been the reason I&#x27;ve chosen SQLite over flat files for my applications.<p>&gt; Sqlite will also lock the user into the application, whereas a &quot;pack of files&quot; can be used in the shell as a text editor. Using markdown files + a open json format has the benefit of being supported by multiple applications (e.g. sometimes i open my obsidian vault in vscode), while a sqlite database would need a proprietary schema coupled with a single application<p>In a sense you&#x27;re right about this! I&#x27;ll grant it&#x27;s easier to open a JSON file in vscode and edit it if you already know vscode and JSON. That said, SQLite is in the public domain with a well-defined, stable format and there are countless free and open source database editors&#x2F;viewers out there.<p>SQLite is self-describing, also. You open `sqlite3` and type `.schema` and it shows you the database schema. You enter a query and get some results. It&#x27;s all right there. So, while a database might have a schema that was designed for a particular application, that doesn&#x27;t mean you as the end user can&#x27;t tinker with it, and the number of people who know SQL is rather large.</div><br/></div></div></div></div></div></div></div></div><div id="39672909" class="c"><input type="checkbox" id="c-39672909" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39672023">parent</a><span>|</span><a href="#39672071">prev</a><span>|</span><a href="#39672224">next</a><span>|</span><label class="collapse" for="c-39672909">[-]</label><label class="expand" for="c-39672909">[2 more]</label></div><br/><div class="children"><div class="content">SQLite is awesome, but it&#x27;s still an order of magnitude more complex than JSON. If it wants to be the one file format to rule them all, we&#x27;re going to need high quality and heavily used implementations in most languages.<p>Adding C sqlite to a golang project adds a significant hit to build times and cross-compilation&#x2F;static linking complexity[0]. When I looked into the native Go implementations of sqlite I came away with the feeling it wasn&#x27;t worth the tradeoffs compared to using the C version, but now I still have to deal with the issues above.<p>I haven&#x27;t looked deeply into how sqlite works, but my instincts tell me the reason we don&#x27;t have high quality implementations in every language is because it&#x27;s actually too complex to treat as a protocol.<p>I would love to see something fill the void between plain text and sqlite.<p>[0]: <a href="https:&#x2F;&#x2F;www.arp242.net&#x2F;static-go.html" rel="nofollow">https:&#x2F;&#x2F;www.arp242.net&#x2F;static-go.html</a></div><br/><div id="39674510" class="c"><input type="checkbox" id="c-39674510" checked=""/><div class="controls bullet"><span class="by">mlunar</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672909">parent</a><span>|</span><a href="#39672224">next</a><span>|</span><label class="collapse" for="c-39674510">[-]</label><label class="expand" for="c-39674510">[1 more]</label></div><br/><div class="children"><div class="content">Check out <a href="https:&#x2F;&#x2F;github.com&#x2F;zombiezen&#x2F;go-sqlite">https:&#x2F;&#x2F;github.com&#x2F;zombiezen&#x2F;go-sqlite</a> if you&#x27;re interested in trying out Sqlite in Go again. Nice interface, negligible compile time impact, fast, compiles without CGO. It&#x27;s very comfortable.<p>I agree that going from text to sqlite is a bit of a hurdle, especially if you&#x27;re not writing C :)</div><br/></div></div></div></div><div id="39672224" class="c"><input type="checkbox" id="c-39672224" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#39672023">parent</a><span>|</span><a href="#39672909">prev</a><span>|</span><a href="#39673123">next</a><span>|</span><label class="collapse" for="c-39672224">[-]</label><label class="expand" for="c-39672224">[4 more]</label></div><br/><div class="children"><div class="content">Crucial context: its provenance is embedded infinite canvas in Obsidian (amazing markdown-based notes app++), which supports JS but has no external datastore per se. SQLite is fantastic, but inappropriate for this use case.</div><br/><div id="39672511" class="c"><input type="checkbox" id="c-39672511" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672224">parent</a><span>|</span><a href="#39673123">next</a><span>|</span><label class="collapse" for="c-39672511">[-]</label><label class="expand" for="c-39672511">[3 more]</label></div><br/><div class="children"><div class="content">Oh I read the post and a few of the other linked posts so I&#x27;m aware. If we&#x27;re storing a file, we&#x27;re already storing a file of some kind, so we&#x27;re just talking about what kind of file it is. I&#x27;m just talking about a different set of tradeoffs one can make if that file is something other than JSON.</div><br/><div id="39673072" class="c"><input type="checkbox" id="c-39673072" checked=""/><div class="controls bullet"><span class="by">LordDragonfang</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39672511">parent</a><span>|</span><a href="#39673123">next</a><span>|</span><label class="collapse" for="c-39673072">[-]</label><label class="expand" for="c-39673072">[2 more]</label></div><br/><div class="children"><div class="content">&gt;If we&#x27;re storing a file, we&#x27;re already storing a file of some kind<p>It&#x27;s not just a file &quot;of some kind&quot;, it&#x27;s a <i>text</i> file. That&#x27;s one of Obsidian&#x27;s key selling points - that a vault is simply a collection of <i>text</i> files. The &quot;text&quot; part is important to both Obsidian&#x27;s philosophy and the majority of its users.</div><br/><div id="39673259" class="c"><input type="checkbox" id="c-39673259" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39673072">parent</a><span>|</span><a href="#39673123">next</a><span>|</span><label class="collapse" for="c-39673259">[-]</label><label class="expand" for="c-39673259">[1 more]</label></div><br/><div class="children"><div class="content">Sure! And in a lot of ways this is about values more than technology.</div><br/></div></div></div></div></div></div></div></div><div id="39673123" class="c"><input type="checkbox" id="c-39673123" checked=""/><div class="controls bullet"><span class="by">exceptione</span><span>|</span><a href="#39672023">parent</a><span>|</span><a href="#39672224">prev</a><span>|</span><a href="#39672808">next</a><span>|</span><label class="collapse" for="c-39673123">[-]</label><label class="expand" for="c-39673123">[8 more]</label></div><br/><div class="children"><div class="content">SQLite has no real types. Use SQLite if data quality is of no concern. The applicability domain of SQLite is far smaller than people think.<p>If you want to improve on JSON, you would have to go into an other direction. Maybe something like postgis would be helpful for extremely large canvasses.<p>JSON Schema is pretty powerful by the way. Checkout the documentation. SQLite is absolutely no match there. What Sqlite could bring is speed, but I dont see how in the contxt of canvas it would be of any help here.</div><br/><div id="39673212" class="c"><input type="checkbox" id="c-39673212" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39673123">parent</a><span>|</span><a href="#39673239">next</a><span>|</span><label class="collapse" for="c-39673212">[-]</label><label class="expand" for="c-39673212">[6 more]</label></div><br/><div class="children"><div class="content">SQLite&#x27;s types are quite loose by default, no doubt.<p>There is a somewhat recent STRICT mode that strengthens them: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;stricttables.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;stricttables.html</a></div><br/><div id="39673511" class="c"><input type="checkbox" id="c-39673511" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39673212">parent</a><span>|</span><a href="#39673239">next</a><span>|</span><label class="collapse" for="c-39673511">[-]</label><label class="expand" for="c-39673511">[5 more]</label></div><br/><div class="children"><div class="content">Exactly so. SQLite also has a rich collection of CHECK constraints which can raise errors if data is not to your liking in some fashion, this includes validating JSON. Not a JSON schema, admittedly, although (just like for Postgres) this is available as an extension. <a href="https:&#x2F;&#x2F;github.com&#x2F;asg017&#x2F;sqlite-jsonschema">https:&#x2F;&#x2F;github.com&#x2F;asg017&#x2F;sqlite-jsonschema</a><p>Saying that SQLite doesn&#x27;t have &quot;real types&quot; is simply false. If one doesn&#x27;t want to learn how to use a tool, blaming it for that failure is poor form.</div><br/><div id="39673759" class="c"><input type="checkbox" id="c-39673759" checked=""/><div class="controls bullet"><span class="by">exceptione</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39673511">parent</a><span>|</span><a href="#39673239">next</a><span>|</span><label class="collapse" for="c-39673759">[-]</label><label class="expand" for="c-39673759">[4 more]</label></div><br/><div class="children"><div class="content">The author of SQLite is quite open about it. The lack of typing has been part of the design from the beginning. Sqlite has hardly any types:<p><pre><code>    INT
    INTEGER
    REAL
    TEXT
    BLOB
    ANY 

</code></pre>
Of course one can program all kind of check constraints, like one can program all kinds of value validations in javascript.<p>Unfortunately, that is not the same as typing. Sqlite lacks typing because, as the sqlite author explains in the docs, flexibility is the goal. He continues with &quot;But other developers are aghast&quot;, and so strict tables where born, but you can clearly see this cannot overcome real concerns. Try to look for the DATETIME datetype in that list.<p>Deep bow to sqlite, its design goal was to be the ini file replacement and it has outperformed itself on that one.<p>Thanks for the extension link. Although constraints are not reuable type definitions, they would still be helpful in this context. Pity that json doesn&#x27;t have a type for dates, one has to rely on string formats: <a href="https:&#x2F;&#x2F;json-schema.org&#x2F;understanding-json-schema&#x2F;reference&#x2F;string#dates-and-times" rel="nofollow">https:&#x2F;&#x2F;json-schema.org&#x2F;understanding-json-schema&#x2F;reference&#x2F;...</a></div><br/><div id="39675987" class="c"><input type="checkbox" id="c-39675987" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39673759">parent</a><span>|</span><a href="#39675281">next</a><span>|</span><label class="collapse" for="c-39675987">[-]</label><label class="expand" for="c-39675987">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Of course one can program all kind of check constraints, like one can program all kinds of value validations in javascript.</i><p>I don&#x27;t consider this a valid distinction where databases are concerned.<p>If you define a datatype in an ordinary SQL database, and try to pass it invalid data, it will fail at runtime. How else could it work? There&#x27;s no compile-time interaction between the value and the database.<p>If you define a field as BOOLEAN in Postgres, then the value must be 0 or 1, or the database will refuse to write it and return an error. In SQLite this is spelled INTEGER NOT NULL CHECK (col_name = 0 or col_name = 1). More verbose? Yes. Identical semantics? Also yes.<p>It would certainly be nice if SQLite had a datetime validator that could be used as a check constraint! Hold, up, I got you fam: CHECK(date IS strftime(&#x27;%Y-%m-%d&#x27;, date)). If you need a different format, those are,, available.<p>I guess it has a date type after all! Learn something new every day.</div><br/><div id="39676183" class="c"><input type="checkbox" id="c-39676183" checked=""/><div class="controls bullet"><span class="by">asa400</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39675987">parent</a><span>|</span><a href="#39675281">next</a><span>|</span><label class="collapse" for="c-39676183">[-]</label><label class="expand" for="c-39676183">[1 more]</label></div><br/><div class="children"><div class="content">Heh, I haven&#x27;t seen that particular datetime constraint before, thanks for that!</div><br/></div></div></div></div><div id="39675281" class="c"><input type="checkbox" id="c-39675281" checked=""/><div class="controls bullet"><span class="by">wizzwizz4</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39673759">parent</a><span>|</span><a href="#39675987">prev</a><span>|</span><a href="#39673239">next</a><span>|</span><label class="collapse" for="c-39675281">[-]</label><label class="expand" for="c-39675281">[1 more]</label></div><br/><div class="children"><div class="content">Aren&#x27;t these the types?<p><pre><code>  NULL
  INT(EGER)
  REAL
  TEXT
  BLOB
  (INTEGER PRIMARY KEY)</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="39672808" class="c"><input type="checkbox" id="c-39672808" checked=""/><div class="controls bullet"><span class="by">toddmorey</span><span>|</span><a href="#39672023">parent</a><span>|</span><a href="#39673123">prev</a><span>|</span><a href="#39674596">next</a><span>|</span><label class="collapse" for="c-39672808">[-]</label><label class="expand" for="c-39672808">[1 more]</label></div><br/><div class="children"><div class="content">Agree that SQLite is a great local format for this sort of thing, but seems to get tricky when trying to sync across clients without conflicts. I&#x27;ve seen most CDRT schemes working with json documents rather than SQLite, but curious if there&#x27;s solid conflict-free syncing out there for SQLite files being used inside applications?</div><br/></div></div><div id="39674596" class="c"><input type="checkbox" id="c-39674596" checked=""/><div class="controls bullet"><span class="by">mch82</span><span>|</span><a href="#39672023">parent</a><span>|</span><a href="#39672808">prev</a><span>|</span><a href="#39672972">next</a><span>|</span><label class="collapse" for="c-39674596">[-]</label><label class="expand" for="c-39674596">[2 more]</label></div><br/><div class="children"><div class="content">The SQLite docs have a great page on the use case `asa400` describes.<p>SQLite as an Application File Format, <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;appfileformat.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;appfileformat.html</a></div><br/><div id="39676236" class="c"><input type="checkbox" id="c-39676236" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39672023">root</a><span>|</span><a href="#39674596">parent</a><span>|</span><a href="#39672972">next</a><span>|</span><label class="collapse" for="c-39676236">[-]</label><label class="expand" for="c-39676236">[1 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the best example of this format used for complex docs, has anyone implemented their OpenDocument replacement idea?</div><br/></div></div></div></div></div></div><div id="39672972" class="c"><input type="checkbox" id="c-39672972" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39672023">prev</a><span>|</span><a href="#39671492">next</a><span>|</span><label class="collapse" for="c-39672972">[-]</label><label class="expand" for="c-39672972">[6 more]</label></div><br/><div class="children"><div class="content">Obsidian is one of the few closed-source applications I would consider relying on, due to their commitment to building around simple, open file formats.<p>Sure, they could screw me over and start charging absurd amounts of money for their app, but high quality open source alternatives would pop up immediately.<p>Meanwhile, as long as they <i>don&#x27;t</i> screw me over, it&#x27;s unlikely an open source alternative is going to be able to catch up to a profitable business that keeps their users happy.<p>It&#x27;s an interesting approach, focused on incentive alignment, which is the best way to ensure quality long term.</div><br/><div id="39673143" class="c"><input type="checkbox" id="c-39673143" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#39672972">parent</a><span>|</span><a href="#39674745">next</a><span>|</span><label class="collapse" for="c-39673143">[-]</label><label class="expand" for="c-39673143">[1 more]</label></div><br/><div class="children"><div class="content">I love Obsidian. I wish they would consider open sourcing the application. It doesn&#x27;t even seem in conflict with their monetization plans, because they&#x27;re already distributing the app for free, and making money with things like &quot;Obsidian publish.&quot; They&#x27;ve got enough critical mass and a sufficiently thriving ecosystem of community plugins that they could only stand to benefit from open sourcing the core app.<p>See Mattermost for an example of a similarly positioned product that is fully open source.</div><br/></div></div><div id="39674745" class="c"><input type="checkbox" id="c-39674745" checked=""/><div class="controls bullet"><span class="by">dugite-code</span><span>|</span><a href="#39672972">parent</a><span>|</span><a href="#39673143">prev</a><span>|</span><a href="#39673037">next</a><span>|</span><label class="collapse" for="c-39674745">[-]</label><label class="expand" for="c-39674745">[3 more]</label></div><br/><div class="children"><div class="content">The big gap I would love to be solved is a, preferably selfhosted, browser based view into my notes. That way I could access my notes from computers you can&#x27;t or won&#x27;t install obsidian on.<p>If it was open source that would be more likely to happen</div><br/><div id="39675258" class="c"><input type="checkbox" id="c-39675258" checked=""/><div class="controls bullet"><span class="by">Brajeshwar</span><span>|</span><a href="#39672972">root</a><span>|</span><a href="#39674745">parent</a><span>|</span><a href="#39673037">next</a><span>|</span><label class="collapse" for="c-39675258">[-]</label><label class="expand" for="c-39675258">[2 more]</label></div><br/><div class="children"><div class="content">Do you mean how your notes are connected, and organized? Otherwise, they are plain-text Markdown files. Any app that renders Markdown should be able to do it.<p>In-fact, I don’t really like Obsidian on Mobile, so I use iA-Writer to edit&#x2F;view the Markdown files that I managed with Obsidian on the Desktop.</div><br/><div id="39676205" class="c"><input type="checkbox" id="c-39676205" checked=""/><div class="controls bullet"><span class="by">dugite-code</span><span>|</span><a href="#39672972">root</a><span>|</span><a href="#39675258">parent</a><span>|</span><a href="#39673037">next</a><span>|</span><label class="collapse" for="c-39676205">[-]</label><label class="expand" for="c-39676205">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Any app that renders Markdown should be able to do it.<p>Sure but I can&#x27;t interact with them the same way as I do in Obsidian. It&#x27;s an electron app so it&#x27;s already heavy on the web based tech.<p>Currently I export my notes as a webpage and edit using my Nextcloud instance. It works, but it&#x27;s not very nice.</div><br/></div></div></div></div></div></div><div id="39673037" class="c"><input type="checkbox" id="c-39673037" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39672972">parent</a><span>|</span><a href="#39674745">prev</a><span>|</span><a href="#39671492">next</a><span>|</span><label class="collapse" for="c-39673037">[-]</label><label class="expand" for="c-39673037">[1 more]</label></div><br/><div class="children"><div class="content">I completely agree. Even if they completely tank I can open my obsidian directory in a text editor or command line and still use it. I would still have access to features that are common in other apps like full text search or plain file sync. Attachments are just files in the filesystem that can be opened in any image viewer. Basically if i can’t use obsidian anymore i can still use my notebook and take notes without implementing or finding new software</div><br/></div></div></div></div><div id="39671492" class="c"><input type="checkbox" id="c-39671492" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#39672972">prev</a><span>|</span><a href="#39671325">next</a><span>|</span><label class="collapse" for="c-39671492">[-]</label><label class="expand" for="c-39671492">[4 more]</label></div><br/><div class="children"><div class="content">This looks a little pre-1.0, it&#x27;s quite short on detail. For example:<p><i>file (required, string) is the path to the file within the system.</i><p>What kind of path, within what system? It&#x27;s not clear that the &#x27;file&#x27; type couldn&#x27;t just be another kind of &#x27;link&#x27;. If various fields like &#x27;background&#x27; were defined to be URLs, that would offload a lot of complexity onto existing web specs.</div><br/><div id="39671728" class="c"><input type="checkbox" id="c-39671728" checked=""/><div class="controls bullet"><span class="by">gvx</span><span>|</span><a href="#39671492">parent</a><span>|</span><a href="#39671325">next</a><span>|</span><label class="collapse" for="c-39671728">[-]</label><label class="expand" for="c-39671728">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, other details are missing too. For example <i>backgroundStyle</i>:<p>&gt; <i>cover</i> fills the entire width and height of the node.<p>Does that work like the CSS <i>background-size: cover;</i> or <i>background-size: 100% 100%;</i>?<p>&gt; <i>ratio</i> maintains the aspect ratio of the background image.<p>Does that mean CSS <i>cover</i>? <i>contain</i>? Something else?</div><br/><div id="39672409" class="c"><input type="checkbox" id="c-39672409" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#39671492">root</a><span>|</span><a href="#39671728">parent</a><span>|</span><a href="#39671325">next</a><span>|</span><label class="collapse" for="c-39672409">[-]</label><label class="expand" for="c-39672409">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    Colors can be specified in hex format, e.g. &quot;#FFFFFF&quot;. Six preset colors exist, mapped to the following numbers:

    1 red
    2 orange
    3 yellow
    4 green
    5 cyan
    6 purple
</code></pre>
I&#x27;m sure everyone will infer the same color codes here.<p>Maybe the file format isn&#x27;t meant to reproduce the exact same look in different software, but merely communicate user intent. Your guess is as good as mine.</div><br/><div id="39672576" class="c"><input type="checkbox" id="c-39672576" checked=""/><div class="controls bullet"><span class="by">gcr</span><span>|</span><a href="#39671492">root</a><span>|</span><a href="#39672409">parent</a><span>|</span><a href="#39671325">next</a><span>|</span><label class="collapse" for="c-39672576">[-]</label><label class="expand" for="c-39672576">[1 more]</label></div><br/><div class="children"><div class="content">I’d almost prefer string literals for color with constants like “red”, “blue”, etc. that compatible implementations could theme as they see fit (eg terminal emulators). Perhaps that’s the intent behind the numeric constants but string literals would convey that better IMO</div><br/></div></div></div></div></div></div></div></div><div id="39671325" class="c"><input type="checkbox" id="c-39671325" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#39671492">prev</a><span>|</span><a href="#39672020">next</a><span>|</span><label class="collapse" for="c-39671325">[-]</label><label class="expand" for="c-39671325">[5 more]</label></div><br/><div class="children"><div class="content">I really like the idea of a format for interchange between infinite canvas apps, but the preset colors and list of node types makes this spec feel strangely opinionated. You could build something like Kinopio [1] but not much beyond that.<p>It looks really promising though! I&#x27;m definitely interested in seeing this grow.<p>[1] <a href="https:&#x2F;&#x2F;kinopio.club" rel="nofollow">https:&#x2F;&#x2F;kinopio.club</a></div><br/><div id="39671604" class="c"><input type="checkbox" id="c-39671604" checked=""/><div class="controls bullet"><span class="by">iainmerrick</span><span>|</span><a href="#39671325">parent</a><span>|</span><a href="#39672020">next</a><span>|</span><label class="collapse" for="c-39671604">[-]</label><label class="expand" for="c-39671604">[4 more]</label></div><br/><div class="children"><div class="content">Thinking about it, I&#x27;m not sure <i>any</i> interchange spec would leave useful room for innovation. This isn&#x27;t like EPS or PDF or something where the kind of output is well-defined (printable graphics + text) and the innovation is in the editing interface. The innovation in canvas apps is surely in the semantics of the nodes themselves; but if you add some new node type with special behavior, how can you usefully export that to other apps? You could make it a black box that can round-trip safely, but that doesn&#x27;t seem very useful. Maybe if it&#x27;s something like an HTML embed or iframe?</div><br/><div id="39672676" class="c"><input type="checkbox" id="c-39672676" checked=""/><div class="controls bullet"><span class="by">gcr</span><span>|</span><a href="#39671325">root</a><span>|</span><a href="#39671604">parent</a><span>|</span><a href="#39672295">next</a><span>|</span><label class="collapse" for="c-39672676">[-]</label><label class="expand" for="c-39672676">[1 more]</label></div><br/><div class="children"><div class="content">It would be fun to go the postscript route and have the nodes be specified by some bytecode on some VM that lays the objects out on the canvas while specifying their editable properties.<p>Then, conforming implementations could render any document just by following the instructions, while editors that actually understand them can provide their own high-level control.<p>The trick is keeping it editable, which postscript doesn’t do well.<p>Example: if the language is strong enough to, say, implement force-directed node layout, an editor that doesn’t understand it could still add nodes and they would move around according to the document author’s wishes whereas perhaps the original editor might have more powerful editing capabilities.</div><br/></div></div><div id="39672295" class="c"><input type="checkbox" id="c-39672295" checked=""/><div class="controls bullet"><span class="by">cmgriffing</span><span>|</span><a href="#39671325">root</a><span>|</span><a href="#39671604">parent</a><span>|</span><a href="#39672676">prev</a><span>|</span><a href="#39671834">next</a><span>|</span><label class="collapse" for="c-39672295">[-]</label><label class="expand" for="c-39672295">[1 more]</label></div><br/><div class="children"><div class="content">I think a baseline spec would be really useful.<p>I like to think of it like the unist ecosystem for ASTs. Unist provides a baseline spec that compatible tools can use to comb an AST. Then, specific AST tools like hast for HTML or sast for CSS&#x2F;SCSS can add their own metadata on top.<p>I&#x27;m imagining an ecosystem of &quot;adapters&quot; that would help you translate some of the metadata across providers.</div><br/></div></div><div id="39671834" class="c"><input type="checkbox" id="c-39671834" checked=""/><div class="controls bullet"><span class="by">heleninboodler</span><span>|</span><a href="#39671325">root</a><span>|</span><a href="#39671604">parent</a><span>|</span><a href="#39672295">prev</a><span>|</span><a href="#39672020">next</a><span>|</span><label class="collapse" for="c-39671834">[-]</label><label class="expand" for="c-39671834">[1 more]</label></div><br/><div class="children"><div class="content">My very first thought about this format was that someone is definitely going to pervert it to be used as a graphics format, and for that it&#x27;s woefully inadequate.  I decided to hold my tongue since it&#x27;s not the creators&#x27; fault that someone will misuse it, but I can totally see people adding optional ad hoc fields to nodes to allow for example all sorts of fancy line styles.</div><br/></div></div></div></div></div></div><div id="39672020" class="c"><input type="checkbox" id="c-39672020" checked=""/><div class="controls bullet"><span class="by">treflop</span><span>|</span><a href="#39671325">prev</a><span>|</span><a href="#39671656">next</a><span>|</span><label class="collapse" for="c-39672020">[-]</label><label class="expand" for="c-39672020">[2 more]</label></div><br/><div class="children"><div class="content">Since a whiteboard is much more a visual thing, I imagine the spec should spend a lot of space defining the visual elements like specifying the control points of the Beizer curves because where a line is drawn and what it overlaps matters a lot on a whiteboard.<p>But to be a total downer, this spec looks like an extremely rudimentary graph file format, of which there are already like a hundred and all define more visual aspects than this spec.</div><br/><div id="39672362" class="c"><input type="checkbox" id="c-39672362" checked=""/><div class="controls bullet"><span class="by">xamde</span><span>|</span><a href="#39672020">parent</a><span>|</span><a href="#39671656">next</a><span>|</span><label class="collapse" for="c-39672362">[-]</label><label class="expand" for="c-39672362">[1 more]</label></div><br/><div class="children"><div class="content">From my Analysis, GraphML, although specified in XML, seems to be one of the most widely used exchange formats, especially with the yWorks extensions for yEd.</div><br/></div></div></div></div><div id="39671656" class="c"><input type="checkbox" id="c-39671656" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#39672020">prev</a><span>|</span><a href="#39671466">next</a><span>|</span><label class="collapse" for="c-39671656">[-]</label><label class="expand" for="c-39671656">[3 more]</label></div><br/><div class="children"><div class="content">As a maintainer of an open source JavaScript infinite canvas application [1], I was very interested, and now I am a little disappointed. The set of supported objects on the canvas is quite minimal.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;lovasoa&#x2F;whitebophir">https:&#x2F;&#x2F;github.com&#x2F;lovasoa&#x2F;whitebophir</a></div><br/><div id="39672925" class="c"><input type="checkbox" id="c-39672925" checked=""/><div class="controls bullet"><span class="by">apitman</span><span>|</span><a href="#39671656">parent</a><span>|</span><a href="#39671466">next</a><span>|</span><label class="collapse" for="c-39672925">[-]</label><label class="expand" for="c-39672925">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an early revision. Now sounds like the perfect time for you to share your experience and suggestions to improve it.</div><br/><div id="39676270" class="c"><input type="checkbox" id="c-39676270" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#39671656">root</a><span>|</span><a href="#39672925">parent</a><span>|</span><a href="#39671466">next</a><span>|</span><label class="collapse" for="c-39676270">[-]</label><label class="expand" for="c-39676270">[1 more]</label></div><br/><div class="children"><div class="content">0.1 is early revision, 1.0 is long past that prefect improvement time</div><br/></div></div></div></div></div></div><div id="39671466" class="c"><input type="checkbox" id="c-39671466" checked=""/><div class="controls bullet"><span class="by">heleninboodler</span><span>|</span><a href="#39671656">prev</a><span>|</span><a href="#39675530">next</a><span>|</span><label class="collapse" for="c-39671466">[-]</label><label class="expand" for="c-39671466">[2 more]</label></div><br/><div class="children"><div class="content">Suggestion: add some metadata at the top level, including a bounding box that includes all nodes so that you can encapsulate a canvas and include it within another context before having created all the elements within it.  It&#x27;s redundant information and it needs to be kept in sync with the nodes and edges, but it&#x27;s very useful for applications working with your data.<p>Also, this is not very json-ish, but optimizing your serializer so your metadata is always written first is pretty handy for embedding, since it allows you to use a pull parser and do useful things before the entire doc is parsed.  (e.g. picture a huge doc being embedded and starting out as just a box and having its elements filled in async.  You can&#x27;t do that well if you don&#x27;t know the bounding box ahead of time)</div><br/><div id="39675854" class="c"><input type="checkbox" id="c-39675854" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#39671466">parent</a><span>|</span><a href="#39675530">next</a><span>|</span><label class="collapse" for="c-39675854">[-]</label><label class="expand" for="c-39675854">[1 more]</label></div><br/><div class="children"><div class="content">+1 for bounding box. It would save a lot of computation when trying to determine the initial scale for the canvas, especially if text is involved. It would also make the format useful for fixed-size canvases, not only infinite ones.</div><br/></div></div></div></div><div id="39675530" class="c"><input type="checkbox" id="c-39675530" checked=""/><div class="controls bullet"><span class="by">dleeftink</span><span>|</span><a href="#39671466">prev</a><span>|</span><a href="#39671255">next</a><span>|</span><label class="collapse" for="c-39675530">[-]</label><label class="expand" for="c-39675530">[1 more]</label></div><br/><div class="children"><div class="content">Good to see this moving ahead, but doesn&#x27;t a well-defined graph format already exist in Argdown? [0] While its renderer uses auto layouting instead of user defined coordinates, the principle of using Markdown files instead of JSON seems more appealing to me considering the Obsidian&#x2F;git workflow.<p>Besides Argdown, Markdown itself provides some built-in features that can be utilised to construct graphs. Coordinates for instance, can be stored as HTML comments or link alt texts, e.g. `[node](# (&quot;x:25,y:50&quot;))`. Edge, shape types and other data could similarly be stored in alt text fields as serialised JSON or in separate blocks using link reference definitions. [1]<p>One step further, Markdown lists could be used to store subtrees while cycles as Obsidian block links. This also allows you to encode ancestral, sibling and descendant relations:<p><pre><code>  - [root](# (&quot;x:25,y:50&quot;))  
    - leaf  
      - [link](#^id)  
    - another leaf^id  
</code></pre>
You&#x27;d then be able to interleave prose and graph structures in a single file rather than dealing with two separate parsing structures. Even better, the end result would still be Markdown compliant.<p>[0]: <a href="https:&#x2F;&#x2F;argdown.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;argdown.org&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;github.github.com&#x2F;gfm&#x2F;#link-reference-definition" rel="nofollow">https:&#x2F;&#x2F;github.github.com&#x2F;gfm&#x2F;#link-reference-definition</a></div><br/></div></div><div id="39671255" class="c"><input type="checkbox" id="c-39671255" checked=""/><div class="controls bullet"><span class="by">ramses0</span><span>|</span><a href="#39675530">prev</a><span>|</span><a href="#39671335">next</a><span>|</span><label class="collapse" for="c-39671255">[-]</label><label class="expand" for="c-39671255">[1 more]</label></div><br/><div class="children"><div class="content">The spec basically fits on a page: <a href="https:&#x2F;&#x2F;jsoncanvas.org&#x2F;spec&#x2F;1.0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jsoncanvas.org&#x2F;spec&#x2F;1.0&#x2F;</a><p>Summary: &quot;node: { type: ..., x&#x2F;y&#x2F;color }; edge: { from&#x2F;to: ..., color&#x2F;label&#x2F;... }&quot;<p>Refreshingly simple, especially paired with their &quot;gif of usage&quot;: <a href="https:&#x2F;&#x2F;obsidian.md&#x2F;canvas" rel="nofollow">https:&#x2F;&#x2F;obsidian.md&#x2F;canvas</a></div><br/></div></div><div id="39671335" class="c"><input type="checkbox" id="c-39671335" checked=""/><div class="controls bullet"><span class="by">Caddickbrown</span><span>|</span><a href="#39671255">prev</a><span>|</span><a href="#39672025">next</a><span>|</span><label class="collapse" for="c-39671335">[-]</label><label class="expand" for="c-39671335">[1 more]</label></div><br/><div class="children"><div class="content">Just realised this is by the Obsidian guys! Good on them!</div><br/></div></div><div id="39672025" class="c"><input type="checkbox" id="c-39672025" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39671335">prev</a><span>|</span><a href="#39672347">next</a><span>|</span><label class="collapse" for="c-39672025">[-]</label><label class="expand" for="c-39672025">[4 more]</label></div><br/><div class="children"><div class="content">It would be neat if the README or spec included links to some real-world examples of files - would be easier to start playing with building simple tools on top of this if there was already an example file to start experimenting with, without me having to learn Obsidian first.<p>UPDATE: Figured out how to create one:<p>1. Install and then open Obsidian<p>2. Click the &quot;Create new canvas&quot; icon - third down of the icons on the left<p>3. Add some stuff to the canvas - I double clicked to create a few boxes, put some text in them and then dragged lines between them<p>4. In the ... menu on the top right click &quot;Reveal in Finder&quot;<p>You can then open the file it reveals in a text editor to see the JSON Canvas format.</div><br/><div id="39672443" class="c"><input type="checkbox" id="c-39672443" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#39672025">parent</a><span>|</span><a href="#39672347">next</a><span>|</span><label class="collapse" for="c-39672443">[-]</label><label class="expand" for="c-39672443">[3 more]</label></div><br/><div class="children"><div class="content">If you hit &quot;toggle output&quot; on the bottom right, it shows a JSON Canvas representation of the page&#x27;s content.</div><br/><div id="39672659" class="c"><input type="checkbox" id="c-39672659" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39672025">root</a><span>|</span><a href="#39672443">parent</a><span>|</span><a href="#39672347">next</a><span>|</span><label class="collapse" for="c-39672659">[-]</label><label class="expand" for="c-39672659">[2 more]</label></div><br/><div class="children"><div class="content">Is that an icon? I can&#x27;t seem to find it (Obsidian 1.4.16 on macOS)</div><br/><div id="39672692" class="c"><input type="checkbox" id="c-39672692" checked=""/><div class="controls bullet"><span class="by">jakelazaroff</span><span>|</span><a href="#39672025">root</a><span>|</span><a href="#39672659">parent</a><span>|</span><a href="#39672347">next</a><span>|</span><label class="collapse" for="c-39672692">[-]</label><label class="expand" for="c-39672692">[1 more]</label></div><br/><div class="children"><div class="content">Sorry — I mean on the bottom right of <a href="https:&#x2F;&#x2F;jsoncanvas.org" rel="nofollow">https:&#x2F;&#x2F;jsoncanvas.org</a>!</div><br/></div></div></div></div></div></div></div></div><div id="39672347" class="c"><input type="checkbox" id="c-39672347" checked=""/><div class="controls bullet"><span class="by">catapart</span><span>|</span><a href="#39672025">prev</a><span>|</span><a href="#39672325">next</a><span>|</span><label class="collapse" for="c-39672347">[-]</label><label class="expand" for="c-39672347">[1 more]</label></div><br/><div class="children"><div class="content">Oh sweet! I was in the middle of building my own version of a node-graph component (ref: <a href="https:&#x2F;&#x2F;github.com&#x2F;catapart&#x2F;Magnit.NodeGraph">https:&#x2F;&#x2F;github.com&#x2F;catapart&#x2F;Magnit.NodeGraph</a>), but the `canvas.js` implementation from this JsonCanvas repo is exactly what I was trying to build. I really, really like how elegantly uncomplex it is. Could not have been more exactly what I was looking for. So thanks for this!<p>As far as the spec, I don&#x27;t really like the idea of forcing well-known types for the nodes. A generic spec should allow for entirely generic nodes that can represent themselves to consuming functions with a &#x27;type&#x27; property as a key, as well as arbitrary data types linked to arbitrary nodes. For instance: one of my use cases is an &#x27;addition&#x27; node, which would take two number values and produce a number value. This node would also use an entrance execution pin as well as an exit execution pin.<p>If the spec were to include a &#x27;pin&#x27; data type and capture the type keys and labels for pins, those pins could be stored as a list on the node. Then, the type property could just tell the executing context how to route the node data and the pin properties would bring type safety to the functional inputs passed to the mapped function.<p>Anyway, I assume all of that is out of scope for initial offerings, but that&#x27;s my two cents on a generalized node spec. Regardless, thanks again for the sweet, simplistic node graph implementation!</div><br/></div></div><div id="39672325" class="c"><input type="checkbox" id="c-39672325" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#39672347">prev</a><span>|</span><a href="#39674887">next</a><span>|</span><label class="collapse" for="c-39672325">[-]</label><label class="expand" for="c-39672325">[1 more]</label></div><br/><div class="children"><div class="content">Based on the title I would have expected this to be about describing images on an infinite canvas, where different parts have different zoom levels.<p>This is instead about whiteboard-style graphs. Which is useful, but I find the branding &quot;An open file format for infinite canvas data&quot; to be confusing. Nothing in it implies whiteboards or graphs to me. The fact that the canvas is infinite doesn&#x27;t even have an obvious influence on the file format, apart from the absence of a canvas size property.</div><br/></div></div><div id="39674887" class="c"><input type="checkbox" id="c-39674887" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#39672325">prev</a><span>|</span><a href="#39674836">next</a><span>|</span><label class="collapse" for="c-39674887">[-]</label><label class="expand" for="c-39674887">[1 more]</label></div><br/><div class="children"><div class="content">Why make so many fields required?<p>Node: only id, x, y would be necessary. This would allow for point nodes. We could even imagine letting go of x and y to signify that the position of the node is not fixed and could be recomputed in real time by the program.<p>Even ids could be optional, why require them if they are not referenced?<p>An added bonus of having point nodes is that you get freehand drawings for free: every stroke is a series of connected dots. Maybe it is an anti-feature though, depending on your vision.</div><br/></div></div><div id="39674836" class="c"><input type="checkbox" id="c-39674836" checked=""/><div class="controls bullet"><span class="by">mcqueenjordan</span><span>|</span><a href="#39674887">prev</a><span>|</span><a href="#39671431">next</a><span>|</span><label class="collapse" for="c-39674836">[-]</label><label class="expand" for="c-39674836">[1 more]</label></div><br/><div class="children"><div class="content">Exploring the concept of files &gt; app deeper, it would be interesting if we were able to foster a culture of website apps writing to local storage with files (in a similar manner to Obsidian), and if we had a common format for doing so, with an open-source daemon that sync&#x27;d writes to and from that directory to e.g. some other folder. That would unlock ownership of data even in web apps. The daemon could be app-agnostic and just dutifully sync all the things.</div><br/></div></div><div id="39671431" class="c"><input type="checkbox" id="c-39671431" checked=""/><div class="controls bullet"><span class="by">theogravity</span><span>|</span><a href="#39674836">prev</a><span>|</span><a href="#39671544">next</a><span>|</span><label class="collapse" for="c-39671431">[-]</label><label class="expand" for="c-39671431">[3 more]</label></div><br/><div class="children"><div class="content">It would be nice to see actual examples. We use an infinite canvas (<a href="https:&#x2F;&#x2F;switchboard.app" rel="nofollow">https:&#x2F;&#x2F;switchboard.app</a>), but it&#x27;s hard for me to map the objects we have on our virtual-desktop-like-canvas with the file format described here.<p>The items on our infinite canvas are more akin to a desktop app, where most objects are application windows.</div><br/><div id="39671471" class="c"><input type="checkbox" id="c-39671471" checked=""/><div class="controls bullet"><span class="by">m12k</span><span>|</span><a href="#39671431">parent</a><span>|</span><a href="#39671544">next</a><span>|</span><label class="collapse" for="c-39671471">[-]</label><label class="expand" for="c-39671471">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It would be nice to see actual examples<p>If you click &quot;Toggle output&quot; on the linked page, you can see the code for the page itself</div><br/><div id="39671527" class="c"><input type="checkbox" id="c-39671527" checked=""/><div class="controls bullet"><span class="by">theogravity</span><span>|</span><a href="#39671431">root</a><span>|</span><a href="#39671471">parent</a><span>|</span><a href="#39671544">next</a><span>|</span><label class="collapse" for="c-39671527">[-]</label><label class="expand" for="c-39671527">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. The available types definitely do not map to what we do. It seems the format is more suited for displaying DAGs.</div><br/></div></div></div></div></div></div><div id="39671544" class="c"><input type="checkbox" id="c-39671544" checked=""/><div class="controls bullet"><span class="by">adamfeldman</span><span>|</span><a href="#39671431">prev</a><span>|</span><a href="#39671812">next</a><span>|</span><label class="collapse" for="c-39671544">[-]</label><label class="expand" for="c-39671544">[2 more]</label></div><br/><div class="children"><div class="content">This was released (and originally implemented) by Obsidian: <a href="https:&#x2F;&#x2F;obsidian.md&#x2F;blog&#x2F;json-canvas" rel="nofollow">https:&#x2F;&#x2F;obsidian.md&#x2F;blog&#x2F;json-canvas</a> (see also <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39670684">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39670684</a>)</div><br/><div id="39671624" class="c"><input type="checkbox" id="c-39671624" checked=""/><div class="controls bullet"><span class="by">mstipetic</span><span>|</span><a href="#39671544">parent</a><span>|</span><a href="#39671812">next</a><span>|</span><label class="collapse" for="c-39671624">[-]</label><label class="expand" for="c-39671624">[1 more]</label></div><br/><div class="children"><div class="content">I would highly recommend using this plugin with it - <a href="https:&#x2F;&#x2F;github.com&#x2F;rpggio&#x2F;obsidian-chat-stream">https:&#x2F;&#x2F;github.com&#x2F;rpggio&#x2F;obsidian-chat-stream</a><p>It has basically changed the way I interact with LLMs and research and plan things</div><br/></div></div></div></div><div id="39671812" class="c"><input type="checkbox" id="c-39671812" checked=""/><div class="controls bullet"><span class="by">tiborsaas</span><span>|</span><a href="#39671544">prev</a><span>|</span><a href="#39672378">next</a><span>|</span><label class="collapse" for="c-39671812">[-]</label><label class="expand" for="c-39671812">[2 more]</label></div><br/><div class="children"><div class="content">I really like that you commit to keep this stable and open.<p>Do you plan to make the TypeScript definition part of this new site?<p><a href="https:&#x2F;&#x2F;github.com&#x2F;obsidianmd&#x2F;obsidian-api&#x2F;blob&#x2F;master&#x2F;canvas.d.ts">https:&#x2F;&#x2F;github.com&#x2F;obsidianmd&#x2F;obsidian-api&#x2F;blob&#x2F;master&#x2F;canva...</a><p>For me it&#x27;s easier to read TS format.</div><br/><div id="39672099" class="c"><input type="checkbox" id="c-39672099" checked=""/><div class="controls bullet"><span class="by">egeozcan</span><span>|</span><a href="#39671812">parent</a><span>|</span><a href="#39672378">next</a><span>|</span><label class="collapse" for="c-39672099">[-]</label><label class="expand" for="c-39672099">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know about this and made ChatGPT prepare me a typescript definition form the markdown: <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;egeozcan&#x2F;27db06f6771dcf214f0f92bce8c4fe79" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;egeozcan&#x2F;27db06f6771dcf214f0f92bce8c...</a> :) Perhaps I shouldn&#x27;t be too lazy to google things.</div><br/></div></div></div></div><div id="39672378" class="c"><input type="checkbox" id="c-39672378" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#39671812">prev</a><span>|</span><a href="#39673725">next</a><span>|</span><label class="collapse" for="c-39672378">[-]</label><label class="expand" for="c-39672378">[2 more]</label></div><br/><div class="children"><div class="content">One of the big reasons I use Obsidian is the data portability - while it provides some nice enhancements, if Obsidian went evil tomorrow and I had to use my notes in VS Code tomorrow, then even reduced to just &quot;a folder full of markdown&quot;, I&#x27;d get 90% of the value without relying on any convoluted importers&#x2F;exporters.<p>I&#x27;ve stayed away from their Canvas feature largely because it is.. not that. Not because the Obsidian developers have kept it locked down in some crazy proprietary format, but like a JSON file representing the canvas is pretty useless without something to interpret it and these days Obsidian is still the only implementation.<p>So I kind of hope this takes off. Having a second source available would make me feel a lot more comfortable trying out the canvas feature.</div><br/><div id="39673197" class="c"><input type="checkbox" id="c-39673197" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#39672378">parent</a><span>|</span><a href="#39673725">next</a><span>|</span><label class="collapse" for="c-39673197">[-]</label><label class="expand" for="c-39673197">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve stayed away from their Canvas feature because the Excalidraw plugin for Obsidian is unbelievably good. I love it.</div><br/></div></div></div></div><div id="39673725" class="c"><input type="checkbox" id="c-39673725" checked=""/><div class="controls bullet"><span class="by">darkteflon</span><span>|</span><a href="#39672378">prev</a><span>|</span><a href="#39671734">next</a><span>|</span><label class="collapse" for="c-39673725">[-]</label><label class="expand" for="c-39673725">[1 more]</label></div><br/><div class="children"><div class="content">How interesting. I was just this weekend looking to implement a DAG&#x2F;multitree-based tasks app as a side project, and my first thought was to do it as an obsidian plugin with D3 for rendering. I ended up canning that idea because it felt like a bridge too far to cram nodes and links into a human-readable format like markdown.  I went with SQLite and a TUI instead. Seeing this spec emerge makes me think that Obsidian might be a good place for that kind of plugin after all. It’s becoming something of an emacs, Obsidian is!</div><br/></div></div><div id="39671734" class="c"><input type="checkbox" id="c-39671734" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39673725">prev</a><span>|</span><a href="#39671428">next</a><span>|</span><label class="collapse" for="c-39671734">[-]</label><label class="expand" for="c-39671734">[9 more]</label></div><br/><div class="children"><div class="content">If ids are unique strings, then why are `nodes` and `edges` arrays, as opposed to id-string-keyed maps?</div><br/><div id="39672193" class="c"><input type="checkbox" id="c-39672193" checked=""/><div class="controls bullet"><span class="by">eropple</span><span>|</span><a href="#39671734">parent</a><span>|</span><a href="#39672686">next</a><span>|</span><label class="collapse" for="c-39672193">[-]</label><label class="expand" for="c-39672193">[3 more]</label></div><br/><div class="children"><div class="content">This is always a tough spot in JSON, I think. You want the `id` in the node or edge object, but you also want uniqueness. I don&#x27;t think there&#x27;s a great way to get this <i>any</i> be able to just `JSON.parse()` and go without further fixup.</div><br/><div id="39672389" class="c"><input type="checkbox" id="c-39672389" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39671734">root</a><span>|</span><a href="#39672193">parent</a><span>|</span><a href="#39672686">next</a><span>|</span><label class="collapse" for="c-39672389">[-]</label><label class="expand" for="c-39672389">[2 more]</label></div><br/><div class="children"><div class="content">What do you concretely gain from embedding the id within the object?</div><br/><div id="39672601" class="c"><input type="checkbox" id="c-39672601" checked=""/><div class="controls bullet"><span class="by">Macha</span><span>|</span><a href="#39671734">root</a><span>|</span><a href="#39672389">parent</a><span>|</span><a href="#39672686">next</a><span>|</span><label class="collapse" for="c-39672601">[-]</label><label class="expand" for="c-39672601">[1 more]</label></div><br/><div class="children"><div class="content">You have a reference to an object, maybe found by filtering the list based on co-ordinate intersection, and you need its ID to put somewhere else (e.g. in the &quot;to&quot; field of an edge). Sure, all your find&#x2F;filter methods could return (ID, object) or just return an ID and make you do a second lookup to find the object, but at the kind of object counts we&#x27;re talking about for this implementation, a small amount of extra memory to have the ID as a field in exchange for a nicer API is a reasonable tradeoff.</div><br/></div></div></div></div></div></div><div id="39672686" class="c"><input type="checkbox" id="c-39672686" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671734">parent</a><span>|</span><a href="#39672193">prev</a><span>|</span><a href="#39671776">next</a><span>|</span><label class="collapse" for="c-39672686">[-]</label><label class="expand" for="c-39672686">[4 more]</label></div><br/><div class="children"><div class="content">An object in JSON is meant to be unordered [1], so arrays are better if you want order to be preserved.<p>[1] <a href="https:&#x2F;&#x2F;www.json.org&#x2F;json-en.html" rel="nofollow">https:&#x2F;&#x2F;www.json.org&#x2F;json-en.html</a></div><br/><div id="39672713" class="c"><input type="checkbox" id="c-39672713" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39671734">root</a><span>|</span><a href="#39672686">parent</a><span>|</span><a href="#39671776">next</a><span>|</span><label class="collapse" for="c-39672713">[-]</label><label class="expand" for="c-39672713">[3 more]</label></div><br/><div class="children"><div class="content">Sure, but why do you want order to be preserved? The spec never says the order of nodes is pertinent. Is there undocumented z-index behavior?</div><br/><div id="39672945" class="c"><input type="checkbox" id="c-39672945" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671734">root</a><span>|</span><a href="#39672713">parent</a><span>|</span><a href="#39672778">next</a><span>|</span><label class="collapse" for="c-39672945">[-]</label><label class="expand" for="c-39672945">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes you have nodes that overlap each other, so you want to control whether or not a node is in front of or behind another node.<p>Though yes, they could have explicitly defined a z-index or defined a convention on how the ordering should work (first nodes top and last nodes bottom or vice versa?). It&#x27;s interesting to think about the trade offs between explicitly defining these things vs. leaving the application to implicitly make the choice. JSON Canvas seems to be designed to use in tandem with markdown files in a note taking app, so it makes sense why they opted for the more implicit design to be similar to markdown</div><br/></div></div><div id="39672778" class="c"><input type="checkbox" id="c-39672778" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39671734">root</a><span>|</span><a href="#39672713">parent</a><span>|</span><a href="#39672945">prev</a><span>|</span><a href="#39671776">next</a><span>|</span><label class="collapse" for="c-39672778">[-]</label><label class="expand" for="c-39672778">[1 more]</label></div><br/><div class="children"><div class="content">Looking at their reference impl, it does seem that array index implies z-index, in which case fair enough, I suppose an array does make the most sense - they should probably document the z-indexing though!</div><br/></div></div></div></div></div></div><div id="39671776" class="c"><input type="checkbox" id="c-39671776" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#39671734">parent</a><span>|</span><a href="#39672686">prev</a><span>|</span><a href="#39671428">next</a><span>|</span><label class="collapse" for="c-39671776">[-]</label><label class="expand" for="c-39671776">[1 more]</label></div><br/><div class="children"><div class="content">A couple of other nit-picks:<p>- I&#x27;d like to see the `file` node have a mime type field.<p>- Why limit links to URLs, as opposed to URIs?<p>- You might want to put a version field in the top level!</div><br/></div></div></div></div><div id="39671428" class="c"><input type="checkbox" id="c-39671428" checked=""/><div class="controls bullet"><span class="by">regus</span><span>|</span><a href="#39671734">prev</a><span>|</span><a href="#39672166">next</a><span>|</span><label class="collapse" for="c-39671428">[-]</label><label class="expand" for="c-39671428">[4 more]</label></div><br/><div class="children"><div class="content">What is the upside of using an infinite canvas? I tried playing around with them in the past but I think my brain&#x27;s mental model of how to parse data is incompatible with &quot;clutter&quot; (for lack of a better term) of an infinite canvas.</div><br/><div id="39671731" class="c"><input type="checkbox" id="c-39671731" checked=""/><div class="controls bullet"><span class="by">aragonite</span><span>|</span><a href="#39671428">parent</a><span>|</span><a href="#39672304">next</a><span>|</span><label class="collapse" for="c-39671731">[-]</label><label class="expand" for="c-39671731">[2 more]</label></div><br/><div class="children"><div class="content">Check out this video from one of my favoriate infinite canvas softwares, especially beginning around 1:25 (which I&#x27;m deep-linking to):<p><a href="https:&#x2F;&#x2F;youtu.be&#x2F;GblI7GI0jQ4?t=85" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;GblI7GI0jQ4?t=85</a><p>(Alas, the original desktop app (iMapping, in Java) as shown in the video is no longer being developed, and now they are only developing the web app (Infinitymaps) only run in the browser, which imo is not the best fit for infinite canvas apps which can be <i>very</i> resource-intensive)<p>Also see the app author&#x27;s own all-purpose mega-map that he used to organize everything: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;bTQWL5wmdZY?si=6VrnPIErOzasisEe" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;bTQWL5wmdZY?si=6VrnPIErOzasisEe</a></div><br/><div id="39673156" class="c"><input type="checkbox" id="c-39673156" checked=""/><div class="controls bullet"><span class="by">DrDeadCrash</span><span>|</span><a href="#39671428">root</a><span>|</span><a href="#39671731">parent</a><span>|</span><a href="#39672304">next</a><span>|</span><label class="collapse" for="c-39673156">[-]</label><label class="expand" for="c-39673156">[1 more]</label></div><br/><div class="children"><div class="content">Imo it would need to show varying levels of information density depending on scale.  Otherwise, as another commenter stated it&#x27;s overwhelming....</div><br/></div></div></div></div><div id="39672304" class="c"><input type="checkbox" id="c-39672304" checked=""/><div class="controls bullet"><span class="by">allenu</span><span>|</span><a href="#39671428">parent</a><span>|</span><a href="#39671731">prev</a><span>|</span><a href="#39672166">next</a><span>|</span><label class="collapse" for="c-39672304">[-]</label><label class="expand" for="c-39672304">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wanted to build an infinite canvas idea to try it out, but whenever I&#x27;ve used implementations of it (such as in the Muse app), it just feels wrong. It feels like a beautiful way to interact with essentially fractal information, but in practice it doesn&#x27;t quite work to me.<p>I agree with you that I don&#x27;t think it maps well to the mental model of the brain. Seeing the youtube video link in the sibling comment, when the user is completely zoomed out and can see everything, I just feel overwhelmed looking at it all. Maybe it&#x27;s the nature of the boxes having different scales that you can&#x27;t compare them as easily to each other compared to just a regular canvas where things just place in two dimensions. Each time you zoom into a canvas, the transition causes a lost sense of place and space, akin to walking into a doorway to a room and wondering why you walked there to begin with.</div><br/></div></div></div></div><div id="39672166" class="c"><input type="checkbox" id="c-39672166" checked=""/><div class="controls bullet"><span class="by">politelemon</span><span>|</span><a href="#39671428">prev</a><span>|</span><a href="#39673047">next</a><span>|</span><label class="collapse" for="c-39672166">[-]</label><label class="expand" for="c-39672166">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The JSON Canvas format was created in hopes of providing longevity, readability, interoperability, and extensibility to data created with infinite canvas apps.<p>If I&#x27;m reading between the lines, this is only supported by Obsidian (as it&#x27;s by Obsidian)? Considering the complexities and &#x27;malleability&#x27; of infinite canvas tools, it would have been prudent to have involved or approached some of the major players in this space, like Excalidraw, Draw.io, Microsoft, Figma.  Or at least started at version 0.1 and once it gained a wider consensus, release 1.0.</div><br/></div></div><div id="39673047" class="c"><input type="checkbox" id="c-39673047" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#39672166">prev</a><span>|</span><a href="#39672011">next</a><span>|</span><label class="collapse" for="c-39673047">[-]</label><label class="expand" for="c-39673047">[1 more]</label></div><br/><div class="children"><div class="content">Actual spec: <a href="https:&#x2F;&#x2F;jsoncanvas.org&#x2F;spec&#x2F;1.0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jsoncanvas.org&#x2F;spec&#x2F;1.0&#x2F;</a></div><br/></div></div><div id="39672011" class="c"><input type="checkbox" id="c-39672011" checked=""/><div class="controls bullet"><span class="by">ianbicking</span><span>|</span><a href="#39673047">prev</a><span>|</span><a href="#39672379">next</a><span>|</span><label class="collapse" for="c-39672011">[-]</label><label class="expand" for="c-39672011">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s some questions about interoperability, which I imagine to be hard since any canvas app involves viewing and editing and probably has unique entities and approaches which other apps wouldn&#x27;t be able to handle.<p>BUT, I imagine this being more useful for creating non-frontend tools. For instance a server that returns subsets of nodes for a particular viewport. Or something that may index nodes, or produce search results. Or tools that simply generates canvases from other data as a one-way operation.</div><br/></div></div><div id="39672379" class="c"><input type="checkbox" id="c-39672379" checked=""/><div class="controls bullet"><span class="by">skadamat</span><span>|</span><a href="#39672011">prev</a><span>|</span><a href="#39671855">next</a><span>|</span><label class="collapse" for="c-39672379">[-]</label><label class="expand" for="c-39672379">[1 more]</label></div><br/><div class="children"><div class="content">Curious to know which projects &amp; companies were involved in creating this. Ideally an open standard has a bunch of folks involved &amp; informed of the design process so we get a design that lasts!<p>Braintree payments did this well when they were still a startup. They had to collaborate <i>with</i> their direct competitors to create a standard for the entire POS induustry.<p>What prevents us from doing this here as well?</div><br/></div></div><div id="39671855" class="c"><input type="checkbox" id="c-39671855" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#39672379">prev</a><span>|</span><a href="#39671819">next</a><span>|</span><label class="collapse" for="c-39671855">[-]</label><label class="expand" for="c-39671855">[2 more]</label></div><br/><div class="children"><div class="content">Is this infinite canvas similar to QGraphicsView?<p>I&#x27;ve been looking for a good equivalent to QGraphicsView and HTML Canvas is not it (HTML Canvas is a raster image, QGraphicsView is a size-independent fixed-sized, scrollable canvas with indexed objects).</div><br/><div id="39673579" class="c"><input type="checkbox" id="c-39673579" checked=""/><div class="controls bullet"><span class="by">tonyarkles</span><span>|</span><a href="#39671855">parent</a><span>|</span><a href="#39671819">next</a><span>|</span><label class="collapse" for="c-39673579">[-]</label><label class="expand" for="c-39673579">[1 more]</label></div><br/><div class="children"><div class="content">Would it be possible to bang SVG into what you’re looking for? It’s a little bit quirky but I’ve used it to draw some pretty wild diagrams with a small amount of JS for pan and zoom.</div><br/></div></div></div></div><div id="39671819" class="c"><input type="checkbox" id="c-39671819" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#39671855">prev</a><span>|</span><label class="collapse" for="c-39671819">[-]</label><label class="expand" for="c-39671819">[2 more]</label></div><br/><div class="children"><div class="content">I would love to see this and excalidraw converge feature &amp; spec wise.</div><br/><div id="39672983" class="c"><input type="checkbox" id="c-39672983" checked=""/><div class="controls bullet"><span class="by">desmondl</span><span>|</span><a href="#39671819">parent</a><span>|</span><label class="collapse" for="c-39672983">[-]</label><label class="expand" for="c-39672983">[1 more]</label></div><br/><div class="children"><div class="content">Any reference for obsidian&#x27;s specs? The closest thing I could find is this: <a href="https:&#x2F;&#x2F;docs.excalidraw.com&#x2F;docs&#x2F;codebase&#x2F;json-schema" rel="nofollow">https:&#x2F;&#x2F;docs.excalidraw.com&#x2F;docs&#x2F;codebase&#x2F;json-schema</a> but it seems to be really minimal and doesn&#x27;t go into detail on what properties belong in elements</div><br/></div></div></div></div></div></div></div></div></div></body></html>