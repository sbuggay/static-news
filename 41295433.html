<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1724144466050" as="style"/><link rel="stylesheet" href="styles.css?v=1724144466050"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html">On the cruelty of really teaching computing science (1988)</a> <span class="domain">(<a href="https://www.cs.utexas.edu">www.cs.utexas.edu</a>)</span></div><div class="subtext"><span>torstenvl</span> | <span>63 comments</span></div><br/><div><div id="41298170" class="c"><input type="checkbox" id="c-41298170" checked=""/><div class="controls bullet"><span class="by">mapcars</span><span>|</span><a href="#41295603">next</a><span>|</span><label class="collapse" for="c-41298170">[-]</label><label class="expand" for="c-41298170">[1 more]</label></div><br/><div class="children"><div class="content">I just went to read a random part of the text<p>&gt; In what we denote as &quot;primitive societies&quot;, the superstition that knowing someone&#x27;s true name gives you magic power over him is not unusual<p>Thats funny, because its not about magic powers but a psychological trick that makes someone seem more trusted when they say your name. Its not about superstition but being able to understand things in more than a direct blunt way.</div><br/></div></div><div id="41295603" class="c"><input type="checkbox" id="c-41295603" checked=""/><div class="controls bullet"><span class="by">firesteelrain</span><span>|</span><a href="#41298170">prev</a><span>|</span><a href="#41295857">next</a><span>|</span><label class="collapse" for="c-41295603">[-]</label><label class="expand" for="c-41295603">[13 more]</label></div><br/><div class="children"><div class="content">This is obviously a snapshot in time (title includes 1988). I can’t attest to the State of Computer Science Education in the late 1980s. He laments the term software engineering because software engineering does not fit the traditional, more mechanical engineering terms.<p>The more mathematical proof style that he is advocating for is used sometimes in aerospace (in particular Airworthiness) and medical.<p>Some might say that his proposed methods only apply to software requiring that level of rigor. It is also really expensive.</div><br/><div id="41295701" class="c"><input type="checkbox" id="c-41295701" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41295603">parent</a><span>|</span><a href="#41297368">next</a><span>|</span><label class="collapse" for="c-41295701">[-]</label><label class="expand" for="c-41295701">[8 more]</label></div><br/><div class="children"><div class="content">We are slowly getting there, SE is just a bit over 50 years old. For example, Dafny (by MSR) is relatively easy to use and scales nicely to build systems of 20-30 KLOC with some formal guarantees. It&#x27;s a nice imperative language where specifications are encoded as contracts, so quite familiar to developers. Costs are still relatively high obviously, and it won&#x27;t scale to bigger systems.<p>I think LLMs could help a lot to lower cost by providing some automation to turn specifications into code. DeepMind has already shown a proof of concept for mathematical theorems using Lean. I have a toy implementation for Isabelle oriented towards SE that works quite well.</div><br/><div id="41297986" class="c"><input type="checkbox" id="c-41297986" checked=""/><div class="controls bullet"><span class="by">amw-zero</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41295701">parent</a><span>|</span><a href="#41295952">next</a><span>|</span><label class="collapse" for="c-41297986">[-]</label><label class="expand" for="c-41297986">[1 more]</label></div><br/><div class="children"><div class="content">LLMs are really, really bad at proofs so far in my experience. Especially proofs in proof assistant since those are machine checked and unable to be faked.</div><br/></div></div><div id="41295952" class="c"><input type="checkbox" id="c-41295952" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41295701">parent</a><span>|</span><a href="#41297986">prev</a><span>|</span><a href="#41295766">next</a><span>|</span><label class="collapse" for="c-41295952">[-]</label><label class="expand" for="c-41295952">[4 more]</label></div><br/><div class="children"><div class="content">that&#x27;s exciting news!  what does your toy implementation do?</div><br/><div id="41295978" class="c"><input type="checkbox" id="c-41295978" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41295952">parent</a><span>|</span><a href="#41295766">next</a><span>|</span><label class="collapse" for="c-41295978">[-]</label><label class="expand" for="c-41295978">[3 more]</label></div><br/><div class="children"><div class="content">It translates natural language into Isabelle&#x2F;HOL specifications, and then tries to fill these up to prove things. One can then use Isabelle code generation facilities to extract Scala, OCaml, etc. I think the trick is to have a programmer to guide the whole process, especially decomposition into different modules and abstractions.</div><br/><div id="41296372" class="c"><input type="checkbox" id="c-41296372" checked=""/><div class="controls bullet"><span class="by">versteegen</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41295978">parent</a><span>|</span><a href="#41296283">next</a><span>|</span><label class="collapse" for="c-41296372">[-]</label><label class="expand" for="c-41296372">[1 more]</label></div><br/><div class="children"><div class="content">Nice. I agree that LLMs will be game-changing for easing the writing of specifications&#x2F;contracts for verified code; it could become the standard. Interesting that you&#x27;re using Isabelle&#x2F;HOL for code generation. I&#x27;m working towards auto-formalization of maths using LLM translation to an intermediate language between English and the proof assistant (for which I&#x27;m leaning towards Isabelle&#x2F;HOL) and then a toolbox of techniques (i.e. ATP) for the remaining translation. Formalization is too painful at the moment. It&#x27;s nearly the same problem as yours. But I&#x27;m starting out on simpler problems.<p>So I&#x27;m really interested in the &quot;filling up&quot; part, if you have anything to say about it.</div><br/></div></div><div id="41296283" class="c"><input type="checkbox" id="c-41296283" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41295978">parent</a><span>|</span><a href="#41296372">prev</a><span>|</span><a href="#41295766">next</a><span>|</span><label class="collapse" for="c-41296283">[-]</label><label class="expand" for="c-41296283">[1 more]</label></div><br/><div class="children"><div class="content">what have you been able to get it to write so far?</div><br/></div></div></div></div></div></div><div id="41295745" class="c"><input type="checkbox" id="c-41295745" checked=""/><div class="controls bullet"><span class="by">abelcha</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41295701">parent</a><span>|</span><a href="#41295766">prev</a><span>|</span><a href="#41297368">next</a><span>|</span><label class="collapse" for="c-41295745">[-]</label><label class="expand" for="c-41295745">[1 more]</label></div><br/><div class="children"><div class="content">Thats what the ai would say</div><br/></div></div></div></div><div id="41297368" class="c"><input type="checkbox" id="c-41297368" checked=""/><div class="controls bullet"><span class="by">devjab</span><span>|</span><a href="#41295603">parent</a><span>|</span><a href="#41295701">prev</a><span>|</span><a href="#41298162">next</a><span>|</span><label class="collapse" for="c-41297368">[-]</label><label class="expand" for="c-41297368">[3 more]</label></div><br/><div class="children"><div class="content">It depends on which parts of software engineering you work in. If you work anywhere where performance matters people tend to know how computers work. If you work in 90% of software engineering you’re likely actively writing code which is terrible from an engineering perspective. Look at how popular things like SOLID and Clean Code in general are. When they are a direct path to horrible performance as you enter the area of L1 cache misses and vtavles on even an extremely simple function. It’s so weird to switch between working close to the hardware and working high above. Especially because Clean Code doesn’t actually seem easier to read or indeed maintain.<p>As an external examiner for CS students I can’t say I’m surprised. They aren’t taught science anymore, they’re taught practices and patterns, and since nobody knows how a computer actually works or how to write performant code it’s easy for various grifters to sell them nonsense.<p>I mean, how well would Clean Code, SOLID and to some degree Agile really sell if people knew the key people behind these things haven’t worked in software engineering since 20 years before Python was even invented? Probably not so well.</div><br/><div id="41297425" class="c"><input type="checkbox" id="c-41297425" checked=""/><div class="controls bullet"><span class="by">jimbob45</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41297368">parent</a><span>|</span><a href="#41298162">next</a><span>|</span><label class="collapse" for="c-41297425">[-]</label><label class="expand" for="c-41297425">[2 more]</label></div><br/><div class="children"><div class="content"><i>When they are a direct path to horrible performance as you enter the area of L1 cache misses and vtavles on even an extremely simple function. It’s so weird to switch between working close to the hardware and working high above. Especially because Clean Code doesn’t actually seem easier to read or indeed maintain.</i><p>If it&#x27;s not on the critical path, what difference does it make? Code outside the critical path should be optimizing for <i>something</i> and maintainability is as good as anything.</div><br/><div id="41297439" class="c"><input type="checkbox" id="c-41297439" checked=""/><div class="controls bullet"><span class="by">funcDropShadow</span><span>|</span><a href="#41295603">root</a><span>|</span><a href="#41297425">parent</a><span>|</span><a href="#41298162">next</a><span>|</span><label class="collapse" for="c-41297439">[-]</label><label class="expand" for="c-41297439">[1 more]</label></div><br/><div class="children"><div class="content">GP said<p>&gt; Especially because Clean Code doesn’t actually seem easier to read or indeed maintain<p>If that is true, then there is indeed no point in applying Clean Code. But I disagree with GP that Clean Code leads automatically to bad performing code. That depends on your language and execution environment. A JVM is very good at effectively removing vtable indirection if they are not needed at runtime.</div><br/></div></div></div></div></div></div><div id="41298162" class="c"><input type="checkbox" id="c-41298162" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#41295603">parent</a><span>|</span><a href="#41297368">prev</a><span>|</span><a href="#41295857">next</a><span>|</span><label class="collapse" for="c-41298162">[-]</label><label class="expand" for="c-41298162">[1 more]</label></div><br/><div class="children"><div class="content">Very few domains where software is used now make sense for that level of rigor, in practice.<p>At least with current levels of available staffing.  The vast majority of software is being developed more akin to ‘residential construction’ type levels of investment rather than even ‘commercial construction’ or ‘major engineering projects’.<p>Which makes sense. Rules of thumb work well enough most of the time, and when it’s actually important (say a structure member, ahem, crypto library) then it makes sense to get it looked at more carefully by someone who more deeply understands what is going on.<p>Though I don’t think we have a solid idea of what those areas are yet, let alone have codified them. So YOLO.</div><br/></div></div></div></div><div id="41295857" class="c"><input type="checkbox" id="c-41295857" checked=""/><div class="controls bullet"><span class="by">Gregaros</span><span>|</span><a href="#41295603">prev</a><span>|</span><a href="#41295630">next</a><span>|</span><label class="collapse" for="c-41295857">[-]</label><label class="expand" for="c-41295857">[18 more]</label></div><br/><div class="children"><div class="content">&gt; The programmer is in the unique position that his is the only discipline and profession in which such a gigantic ratio, which totally baffles our imagination, has to be bridged by a single technology. He has to be able to think in terms of conceptual hierarchies that are much deeper than a single mind ever needed to face before. Compared to that number of semantic levels, the average mathematical theory is almost flat. By evoking the need for deep conceptual hierarchies, the automatic computer confronts us with a radically new intellectual challenge that has no precedent in our history.<p>I am no biographer of Djisktra’s, so is he being unrealistic about programmers here, or does he not have exposure to what a mathematician would consider Mathematics (Wikipedia entry claiming him a mathematician or no)?</div><br/><div id="41296323" class="c"><input type="checkbox" id="c-41296323" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41295857">parent</a><span>|</span><a href="#41295933">next</a><span>|</span><label class="collapse" for="c-41296323">[-]</label><label class="expand" for="c-41296323">[7 more]</label></div><br/><div class="children"><div class="content">&gt; He has to be able to think in terms of conceptual hierarchies that are much deeper than a single mind ever needed to face before.<p>This is not really true. There were complex multilayered systems before computers. 
In large systems, Western Electric #5 Crossbar was comparable to a large real-time program. General Railway Signal&#x27;s NX system had the first &quot;intelligent&quot; user interface. But that level of complexity was very rare.<p>Both mechanical design and electronic design are harder than program design. The number of people who did really good mechanism design is tiny. There were only two good typesetting machines, over most of a century - Merganthaler&#x27;s Linotype and Lanston&#x27;s Monotype. Everybody else&#x27;s machine was a dud. In the printing telegraph&#x2F;Teletype business, Howard Krum and Ed Klienschmidt designed the good ones, and the other twenty or so designs over many decades were much inferior. There were been lathes for centuries, but all modern manual lathes strongly resemble Maudsley&#x27;s design from 1800.<p>There are far more good programmers than there were good mechanism designers or electronics engineers. Programming is not really that hard by the standards of other complex engineering.</div><br/><div id="41297032" class="c"><input type="checkbox" id="c-41297032" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41296323">parent</a><span>|</span><a href="#41297100">next</a><span>|</span><label class="collapse" for="c-41297032">[-]</label><label class="expand" for="c-41297032">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There are far more good programmers than there were good mechanism designers or electronics engineers.<p>But that doesn&#x27;t mean a thing.  The barrier to entry is much smaller.</div><br/><div id="41297659" class="c"><input type="checkbox" id="c-41297659" checked=""/><div class="controls bullet"><span class="by">mock-possum</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41297032">parent</a><span>|</span><a href="#41297100">next</a><span>|</span><label class="collapse" for="c-41297659">[-]</label><label class="expand" for="c-41297659">[1 more]</label></div><br/><div class="children"><div class="content">Yeah if I wanted to just get started with electronics engineering, the easiest cheapest way would be… to use software. Programming &#x2F; digital engineer bf is lower-stakes than physical stuff.</div><br/></div></div></div></div><div id="41297100" class="c"><input type="checkbox" id="c-41297100" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41296323">parent</a><span>|</span><a href="#41297032">prev</a><span>|</span><a href="#41295933">next</a><span>|</span><label class="collapse" for="c-41297100">[-]</label><label class="expand" for="c-41297100">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Both mechanical design and electronic design are harder than program design. The number of people who did really good mechanism design is tiny. There were only two good typesetting machines, over most of a century - Merganthaler&#x27;s Linotype and Lanston&#x27;s Monotype.<p>That’s a good example and of course it immediately brings to mind TeX, which is an equally monumental if not greater achievement. Certainly there’s no denying that TeX has considerably higher dimensionality than the pre-computerized hot type setting machines. Especially when you include all the ancillary stuff like Metafont.<p>Also recall that Dijkstra was a systems programmer in his industry career. He was well aware of the complexity of the computing hardware of the day—which was cutting edge electronic design. The semaphore wasn’t invented as a cute mathematical trick; he needed it to get hardware interrupts to work properly. Something which THE managed and Unix, among others, never quite did (although it did get to mostly good enough if you don’t mind minefields).<p>&gt; There are far more good programmers than there were good mechanism designers or electronics engineers. Programming is not really that hard by the standards of other complex engineering.<p>Most programmers are incapable of writing a correct binary search, let alone something the size and complexity of TeX with only a handful of relatively minor errors. Programmers capable of that level of intellectual feat are indeed few and far between. I suspect they’re more rare than competent EEs or MEs.<p>Most programmers are more comparable to the guys cleaning the typesetters, not the ones designing them.</div><br/><div id="41297257" class="c"><input type="checkbox" id="c-41297257" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41297100">parent</a><span>|</span><a href="#41295933">next</a><span>|</span><label class="collapse" for="c-41297257">[-]</label><label class="expand" for="c-41297257">[3 more]</label></div><br/><div class="children"><div class="content">&gt; TeX, which is an equally monumental if not greater achievement.<p>TeX didn&#x27;t come out of nowhere. It&#x27;s a successor to the macro-based document formatting system which began with RUNOFF and went through roff, nroff, tbl, eqn, MM, troff, ditroff, and groff. The last remaining usage of those tools seems to be UNIX-type manual pages. There was so much cruft a restart was required.</div><br/><div id="41297317" class="c"><input type="checkbox" id="c-41297317" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41297257">parent</a><span>|</span><a href="#41295933">next</a><span>|</span><label class="collapse" for="c-41297317">[-]</label><label class="expand" for="c-41297317">[2 more]</label></div><br/><div class="children"><div class="content">Linotype didn’t come out of nowhere either. Printers used to cast type manually.<p>And don’t just gloss over TeX’s astounding correctness. It’s a truly remarkable feat of the human intellect to design something so large with so few errors.</div><br/><div id="41297752" class="c"><input type="checkbox" id="c-41297752" checked=""/><div class="controls bullet"><span class="by">stevesimmons</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41297317">parent</a><span>|</span><a href="#41295933">next</a><span>|</span><label class="collapse" for="c-41297752">[-]</label><label class="expand" for="c-41297752">[1 more]</label></div><br/><div class="children"><div class="content">For those who haven&#x27;t seen Knuth&#x27;s own analysis of his errors while writing TeX, it&#x27;s well worth reading his 1989 article &quot;The Errors of TeX&quot; [1] and glancing through the full chronological list of errors [2].<p>[1] <a href="https:&#x2F;&#x2F;yurichev.com&#x2F;mirrors&#x2F;knuth1989.pdf" rel="nofollow">https:&#x2F;&#x2F;yurichev.com&#x2F;mirrors&#x2F;knuth1989.pdf</a><p>[2] <a href="https:&#x2F;&#x2F;ctan.math.utah.edu&#x2F;ctan&#x2F;tex-archive&#x2F;info&#x2F;knuth-pdf&#x2F;errata&#x2F;errorlog.pdf" rel="nofollow">https:&#x2F;&#x2F;ctan.math.utah.edu&#x2F;ctan&#x2F;tex-archive&#x2F;info&#x2F;knuth-pdf&#x2F;e...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41295933" class="c"><input type="checkbox" id="c-41295933" checked=""/><div class="controls bullet"><span class="by">AdieuToLogic</span><span>|</span><a href="#41295857">parent</a><span>|</span><a href="#41296323">prev</a><span>|</span><a href="#41297424">next</a><span>|</span><label class="collapse" for="c-41295933">[-]</label><label class="expand" for="c-41295933">[3 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; He has to be able to think in terms of conceptual hierarchies that are much deeper than a single mind ever needed to face before. Compared to that number of semantic levels, the average mathematical theory is almost flat.<p>&gt; ... is he being unrealistic about programmers here, or does he not have exposure to what a mathematician would consider Mathematics?<p>As with any sweeping statement, Dijkstra&#x27;s assertion is not universally applicable to all programmers.  However, for some definition of sufficiently skilled programmer, it is correct if one considers the subset of mathematics applicable to provably correct programs.  To wit:<p><a href="https:&#x2F;&#x2F;bartoszmilewski.com&#x2F;2014&#x2F;10&#x2F;28&#x2F;category-theory-for-programmers-the-preface&#x2F;" rel="nofollow">https:&#x2F;&#x2F;bartoszmilewski.com&#x2F;2014&#x2F;10&#x2F;28&#x2F;category-theory-for-p...</a></div><br/><div id="41296705" class="c"><input type="checkbox" id="c-41296705" checked=""/><div class="controls bullet"><span class="by">chongli</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41295933">parent</a><span>|</span><a href="#41297424">next</a><span>|</span><label class="collapse" for="c-41296705">[-]</label><label class="expand" for="c-41296705">[2 more]</label></div><br/><div class="children"><div class="content">You’ve given a hint of the complexity on the programmer’s side of things but for Dijkstra’s claim to hold we also need to take a look at the mathematician’s. I think most people who are not mathematicians have no idea what they’re working on.<p>Take for example a single theorem: Classification of Finite Simple Groups [1]. This one proof, the work of a hundred mathematicians or so, is tens of thousands of pages long and took half a century to complete.<p>Fermat’s Last Theorem [2] took 358 years to prove and required the development of vast amounts of theory that Fermat himself could scarcely have imagined.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Classification_of_finite_simple_groups" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Classification_of_finite_simpl...</a><p>[2] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fermat%27s_Last_Theorem" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fermat%27s_Last_Theorem</a></div><br/><div id="41297076" class="c"><input type="checkbox" id="c-41297076" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41296705">parent</a><span>|</span><a href="#41297424">next</a><span>|</span><label class="collapse" for="c-41297076">[-]</label><label class="expand" for="c-41297076">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This one proof, the work of a hundred mathematicians or so, is tens of thousands of pages long and took half a century to complete.<p>Now compare that to google3 or any other large software. It’s absolutely tiny. A paltry edifice in comparison both in pages and man hours as well as mathematical complexity. Boolean structures get monstrously huge.<p>On the subject of proofs and the verbosity of traditional mathematical methods, this note[1] is interesting. It provides two fun little examples of shorter than normal proofs.<p>It amuses me that just as mathematicians persisted in writing out “is equal to” for decades after Recorde gave us =, there will probably continue to be holdouts who write out “if and only if” instead of using ≡ for many years to come.<p>[1] <a href="https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;transcriptions&#x2F;EWD10xx&#x2F;EWD1073.html" rel="nofollow">https:&#x2F;&#x2F;www.cs.utexas.edu&#x2F;~EWD&#x2F;transcriptions&#x2F;EWD10xx&#x2F;EWD107...</a></div><br/></div></div></div></div></div></div><div id="41297424" class="c"><input type="checkbox" id="c-41297424" checked=""/><div class="controls bullet"><span class="by">myworkinisgood</span><span>|</span><a href="#41295857">parent</a><span>|</span><a href="#41295933">prev</a><span>|</span><a href="#41296035">next</a><span>|</span><label class="collapse" for="c-41297424">[-]</label><label class="expand" for="c-41297424">[2 more]</label></div><br/><div class="children"><div class="content">Maths has also evolved to be complex now, with the proof of four-color theorem being a computer proof. So, the statement is not as true anymore. But there was a short era when proving that your &quot;static&quot; program was correct was impossible because the number  of possible combinations of input approached the size of earth (in terms of how many bits we need to represent). At the same time, almost any single mathematical theorem could be verified by a person to be correct over the course of a couple of years.</div><br/><div id="41297890" class="c"><input type="checkbox" id="c-41297890" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41297424">parent</a><span>|</span><a href="#41296035">next</a><span>|</span><label class="collapse" for="c-41297890">[-]</label><label class="expand" for="c-41297890">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;celebratio.org&#x2F;Haken_W&#x2F;article&#x2F;794&#x2F;" rel="nofollow">https:&#x2F;&#x2F;celebratio.org&#x2F;Haken_W&#x2F;article&#x2F;794&#x2F;</a><p>It was first published in 1976. It is _highly_ unlikely Dijkstra didn&#x27;t know about it.</div><br/></div></div></div></div><div id="41296035" class="c"><input type="checkbox" id="c-41296035" checked=""/><div class="controls bullet"><span class="by">csb6</span><span>|</span><a href="#41295857">parent</a><span>|</span><a href="#41297424">prev</a><span>|</span><a href="#41297050">next</a><span>|</span><label class="collapse" for="c-41296035">[-]</label><label class="expand" for="c-41296035">[3 more]</label></div><br/><div class="children"><div class="content">I think he was arguing that if programming consists of symbol manipulation and proofs, the task of writing proofs for large programs consists of a lot more symbol manipulation (although probably a lot more tedious in nature) than many proofs written by mathematicians in the past, something made worse by the need to precisely describe each step so that a machine could conceivably execute it instead of being able to skip over proof steps considered “obvious” to a human mathematician.<p>I think he was especially thinking of mathematical logic - he referred to programming as Very Large Scale Application of Logic several times in his writing.</div><br/><div id="41296383" class="c"><input type="checkbox" id="c-41296383" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41296035">parent</a><span>|</span><a href="#41297050">next</a><span>|</span><label class="collapse" for="c-41296383">[-]</label><label class="expand" for="c-41296383">[2 more]</label></div><br/><div class="children"><div class="content">For the peanut gallery:<p>If you ever want to see what it&#x27;s like for a mathematician to not hand wave anything away, look at excerpts from Bertrand &amp; Russel in principia mathematics (no, not the newton book).<p>It takes 362 pages (depending on edition) to get to 1+1=2<p><a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;principia-mathematica_202307&#x2F;page&#x2F;362&#x2F;mode&#x2F;1up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;principia-mathematica_202307&#x2F;pag...</a><p>Of course, just like real mathematicians, in our everyday work we stand on the shoulders of giants, reuse prior foundational work (I&#x27;ve yet to personally write a bootloader, os, or language+compiler, and include 3p libraries), and then hope that any bugs in our proofs are caught during peer review.  Like in math, sometimes peer review for our code ends up being a rubber stamp, or our code&#x2F;proofs aren&#x27;t that elegant, or they work for the domain we&#x27;re using them in but there&#x27;s latent bugs&#x2F;logic errors which may cause inconsistencies or require a restriction of domain to properly work (ex code only works with ASCII, or your theorm only works for compact sets).<p>And of course, the similarities aren&#x27;t a coincidence<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Curry%E2%80%93Howard_correspondence" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Curry%E2%80%93Howard_corresp...</a></div><br/><div id="41297299" class="c"><input type="checkbox" id="c-41297299" checked=""/><div class="controls bullet"><span class="by">black_knight</span><span>|</span><a href="#41295857">root</a><span>|</span><a href="#41296383">parent</a><span>|</span><a href="#41297050">next</a><span>|</span><label class="collapse" for="c-41297299">[-]</label><label class="expand" for="c-41297299">[1 more]</label></div><br/><div class="children"><div class="content">Note: There are today completely formal systems of proofs which are much more concise than what Russel had. You can now prove 1+1=2 after a few pages of rules (say of Martin-Löf type theory), a couple of definitions (+, 1 and 2) and a very short proof by calculation.<p>In practice, one would use a proof assistant, which is like a programming language, such as Agda. Then it is just the definitions and the proof is just a call to the proof checker to compute and check the result.</div><br/></div></div></div></div></div></div><div id="41297050" class="c"><input type="checkbox" id="c-41297050" checked=""/><div class="controls bullet"><span class="by">User23</span><span>|</span><a href="#41295857">parent</a><span>|</span><a href="#41296035">prev</a><span>|</span><a href="#41295882">next</a><span>|</span><label class="collapse" for="c-41297050">[-]</label><label class="expand" for="c-41297050">[1 more]</label></div><br/><div class="children"><div class="content">Dijkstra’s degree was in mathematics.<p>And yes the average mathematical theory is indeed flat compared to a large monolith like google3.</div><br/></div></div></div></div><div id="41295630" class="c"><input type="checkbox" id="c-41295630" checked=""/><div class="controls bullet"><span class="by">austin-cheney</span><span>|</span><a href="#41295857">prev</a><span>|</span><a href="#41297654">next</a><span>|</span><label class="collapse" for="c-41295630">[-]</label><label class="expand" for="c-41295630">[10 more]</label></div><br/><div class="children"><div class="content">I have met some developers in my career that can communicate as effectively as this with equally brutal criticality, but those people are astonishingly rare. Maybe 2% of the developer population, if I am being gracious, can be described this way.<p>Most developers I have worked with are cowards exactly as he used that word. Now in all fairness my career is largely limited to large corporate employers that only hire Java developers and, god forbid, JavaScript developers. It’s frameworks, Maven, and NPM for absolutely everything.<p>The hiring managers always claim to look for innovators, but then you get in and everyone is just the same. Thousands of developers just retaining their employment doing the same shit day after day, fearing any changes coming down the pike.</div><br/><div id="41296217" class="c"><input type="checkbox" id="c-41296217" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#41295630">parent</a><span>|</span><a href="#41295980">next</a><span>|</span><label class="collapse" for="c-41296217">[-]</label><label class="expand" for="c-41296217">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The hiring managers always claim to look for innovators,<p>I can&#x27;t recall the last time I saw a hiring manager looking for an innovator.<p>Most hiring managers want people who can just get the job done with as little supervision and involvement as possible.<p>Most of the time when I see a coworker going off and innovating, it&#x27;s a questionable exercise designed for fun and entertainment rather than getting the job done.<p>My last job had someone spend months &quot;innovating&quot; an all new custom CI&#x2F;CD system. It brought no benefits to the team and was a huge waste of time. They had fun and used it as a major accomplishment their resume and LinkedIn. You could say it was &quot;innovative&quot;, but the rest of use really wished they would have helped us out with the work that had to be done instead of &quot;innovating&quot; off in the weeds.</div><br/><div id="41296410" class="c"><input type="checkbox" id="c-41296410" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#41295630">root</a><span>|</span><a href="#41296217">parent</a><span>|</span><a href="#41295980">next</a><span>|</span><label class="collapse" for="c-41296410">[-]</label><label class="expand" for="c-41296410">[1 more]</label></div><br/><div class="children"><div class="content">Given that it brought no benefits to the team, I would probably not say it was innovative.</div><br/></div></div></div></div><div id="41295980" class="c"><input type="checkbox" id="c-41295980" checked=""/><div class="controls bullet"><span class="by">lallysingh</span><span>|</span><a href="#41295630">parent</a><span>|</span><a href="#41296217">prev</a><span>|</span><a href="#41295746">next</a><span>|</span><label class="collapse" for="c-41295980">[-]</label><label class="expand" for="c-41295980">[1 more]</label></div><br/><div class="children"><div class="content">Industry use of &quot;innovation&quot; is using 3 year old tech instead of 10 year old tech.</div><br/></div></div><div id="41295746" class="c"><input type="checkbox" id="c-41295746" checked=""/><div class="controls bullet"><span class="by">alephnerd</span><span>|</span><a href="#41295630">parent</a><span>|</span><a href="#41295980">prev</a><span>|</span><a href="#41297654">next</a><span>|</span><label class="collapse" for="c-41295746">[-]</label><label class="expand" for="c-41295746">[6 more]</label></div><br/><div class="children"><div class="content">Frameworks aren&#x27;t necessarily a bad thing if you can critical think - why reinvent the wheel from scratch everytime when you&#x27;re trying to make a newer version of a car? But if you&#x27;re only a framework monkey who cannot communicate design decisions, architecture, and&#x2F;or design you&#x27;re definetly screwed in the job market.<p>A lot of people (especially newer profiles I&#x27;ve seen on HN) think just being able to glue libraries together is enough to justify being a developer with a 6 fig salary, when in reality the actual value add is the architecture, design, and other critical thinking actions.<p>Hiring managers do try to hire the archetype developer who is both eloquent and a critical thinker, but it&#x27;s hard and those who can do both know their value.</div><br/><div id="41295818" class="c"><input type="checkbox" id="c-41295818" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41295630">root</a><span>|</span><a href="#41295746">parent</a><span>|</span><a href="#41295811">next</a><span>|</span><label class="collapse" for="c-41295818">[-]</label><label class="expand" for="c-41295818">[4 more]</label></div><br/><div class="children"><div class="content">Then again, just being able to glue libraries together ought to be enough to justify a 6 fig salary, because inflation adjusted that&#x27;s potentially less than the 5 fig salaries I was offered last century, fresh out of school and still wet behind the ears.</div><br/><div id="41295935" class="c"><input type="checkbox" id="c-41295935" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#41295630">root</a><span>|</span><a href="#41295818">parent</a><span>|</span><a href="#41295836">next</a><span>|</span><label class="collapse" for="c-41295935">[-]</label><label class="expand" for="c-41295935">[1 more]</label></div><br/><div class="children"><div class="content">by any measure you contributed a lot more value than that, though</div><br/></div></div><div id="41295836" class="c"><input type="checkbox" id="c-41295836" checked=""/><div class="controls bullet"><span class="by">alephnerd</span><span>|</span><a href="#41295630">root</a><span>|</span><a href="#41295818">parent</a><span>|</span><a href="#41295935">prev</a><span>|</span><a href="#41295811">next</a><span>|</span><label class="collapse" for="c-41295836">[-]</label><label class="expand" for="c-41295836">[2 more]</label></div><br/><div class="children"><div class="content">And the only reason (I assume) you&#x27;re still in the tech industry despite the dot com bust and the Great Recession is because you can at least show value to employers, and you most likely have some communication and critical thinking skills, not just gluing stuff together.<p>Plenty of code monkey types flamed out or remained underemployed.<p>&gt; the 5 fig salaries I was offered last century, fresh out of school and still wet behind the ears<p>And there were also fewer developers in the 1990s&#x2F;2000s than in the 2020s, and the hiring market was not yet fully globalized and async compared to the post-COVID WFH&#x2F;Remote market.</div><br/><div id="41297408" class="c"><input type="checkbox" id="c-41297408" checked=""/><div class="controls bullet"><span class="by">formerly_proven</span><span>|</span><a href="#41295630">root</a><span>|</span><a href="#41295836">parent</a><span>|</span><a href="#41295811">next</a><span>|</span><label class="collapse" for="c-41297408">[-]</label><label class="expand" for="c-41297408">[1 more]</label></div><br/><div class="children"><div class="content">Most companies don&#x27;t offer WFH&#x2F;remote though.</div><br/></div></div></div></div></div></div><div id="41295811" class="c"><input type="checkbox" id="c-41295811" checked=""/><div class="controls bullet"><span class="by">bulatb</span><span>|</span><a href="#41295630">root</a><span>|</span><a href="#41295746">parent</a><span>|</span><a href="#41295818">prev</a><span>|</span><a href="#41297654">next</a><span>|</span><label class="collapse" for="c-41295811">[-]</label><label class="expand" for="c-41295811">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always heard that tech employers value all the things you&#x27;d expect them to value, but I&#x27;ve only ever seen them value LeetCode.</div><br/></div></div></div></div></div></div><div id="41297654" class="c"><input type="checkbox" id="c-41297654" checked=""/><div class="controls bullet"><span class="by">shric</span><span>|</span><a href="#41295630">prev</a><span>|</span><a href="#41296049">next</a><span>|</span><label class="collapse" for="c-41297654">[-]</label><label class="expand" for="c-41297654">[1 more]</label></div><br/><div class="children"><div class="content">Somehow I guessed it was Dijkstra just from the title.</div><br/></div></div><div id="41296049" class="c"><input type="checkbox" id="c-41296049" checked=""/><div class="controls bullet"><span class="by">xianshou</span><span>|</span><a href="#41297654">prev</a><span>|</span><a href="#41295634">next</a><span>|</span><label class="collapse" for="c-41296049">[-]</label><label class="expand" for="c-41296049">[1 more]</label></div><br/><div class="children"><div class="content">From the article: &#x27;In the discrete world of computing, there is no meaningful metric in which &quot;small&quot; changes and &quot;small&quot; effects go hand in hand, and there never will be.&#x27;<p>As brilliantly composed as the piece may be, it exhibits the same resistance to radical novelty that it condemns. Here we are not 40 years later, and small changes to big networks produce small effects. At sufficient scale, the digital reapproximates the analog.</div><br/></div></div><div id="41295634" class="c"><input type="checkbox" id="c-41295634" checked=""/><div class="controls bullet"><span class="by">sneed_chucker</span><span>|</span><a href="#41296049">prev</a><span>|</span><a href="#41296362">next</a><span>|</span><label class="collapse" for="c-41295634">[-]</label><label class="expand" for="c-41295634">[7 more]</label></div><br/><div class="children"><div class="content">For those who don&#x27;t know, the author is Edsger W. Dijkstra</div><br/><div id="41295769" class="c"><input type="checkbox" id="c-41295769" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#41295634">parent</a><span>|</span><a href="#41295695">next</a><span>|</span><label class="collapse" for="c-41295769">[-]</label><label class="expand" for="c-41295769">[1 more]</label></div><br/><div class="children"><div class="content">He of all people should have been able to find a shorter way to get to the point!</div><br/></div></div><div id="41295695" class="c"><input type="checkbox" id="c-41295695" checked=""/><div class="controls bullet"><span class="by">skemper911</span><span>|</span><a href="#41295634">parent</a><span>|</span><a href="#41295769">prev</a><span>|</span><a href="#41296362">next</a><span>|</span><label class="collapse" for="c-41295695">[-]</label><label class="expand" for="c-41295695">[5 more]</label></div><br/><div class="children"><div class="content">Took 2 paragraphs for me to guess the author ;)</div><br/><div id="41297330" class="c"><input type="checkbox" id="c-41297330" checked=""/><div class="controls bullet"><span class="by">awanderingmind</span><span>|</span><a href="#41295634">root</a><span>|</span><a href="#41295695">parent</a><span>|</span><a href="#41295790">next</a><span>|</span><label class="collapse" for="c-41297330">[-]</label><label class="expand" for="c-41297330">[1 more]</label></div><br/><div class="children"><div class="content">Me too! I think it&#x27;s the pontification presented in a self-aware, humorous way.<p>I strongly agree with about half of the essay, while I want to agree with the other half in principle, but instead I think it is indeed &quot;...so ridiculous that [he is] obviously out of touch with the real world&quot;.</div><br/></div></div><div id="41295790" class="c"><input type="checkbox" id="c-41295790" checked=""/><div class="controls bullet"><span class="by">082349872349872</span><span>|</span><a href="#41295634">root</a><span>|</span><a href="#41295695">parent</a><span>|</span><a href="#41297330">prev</a><span>|</span><a href="#41295968">next</a><span>|</span><label class="collapse" for="c-41295790">[-]</label><label class="expand" for="c-41295790">[1 more]</label></div><br/><div class="children"><div class="content">~1300 EWDs and this one is ~70 paras, so say 100K paras worth of EWDs (+ a similar amount for his published work?) suggesting that 2 paras are still better measured in microdijkstras than in nanodijkstras...</div><br/></div></div><div id="41295968" class="c"><input type="checkbox" id="c-41295968" checked=""/><div class="controls bullet"><span class="by">d13</span><span>|</span><a href="#41295634">root</a><span>|</span><a href="#41295695">parent</a><span>|</span><a href="#41295790">prev</a><span>|</span><a href="#41295739">next</a><span>|</span><label class="collapse" for="c-41295968">[-]</label><label class="expand" for="c-41295968">[1 more]</label></div><br/><div class="children"><div class="content">2 sentences for me. The enigmatic humorous dirge was a dead giveaway.</div><br/></div></div><div id="41295739" class="c"><input type="checkbox" id="c-41295739" checked=""/><div class="controls bullet"><span class="by">copperx</span><span>|</span><a href="#41295634">root</a><span>|</span><a href="#41295695">parent</a><span>|</span><a href="#41295968">prev</a><span>|</span><a href="#41296362">next</a><span>|</span><label class="collapse" for="c-41295739">[-]</label><label class="expand" for="c-41295739">[1 more]</label></div><br/><div class="children"><div class="content">The handwriting was a split second giveaway.</div><br/></div></div></div></div></div></div><div id="41296362" class="c"><input type="checkbox" id="c-41296362" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#41295634">prev</a><span>|</span><a href="#41297092">next</a><span>|</span><label class="collapse" for="c-41296362">[-]</label><label class="expand" for="c-41296362">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always torn on this.  As someone that thinks they are decent at programming, it can be tempting to think that all of the sloppy ways of programming that I learned on the way were bad habits that need to be shed.<p>However, I also think that anyone that taught math by jumping straight to the advanced maths would almost certainly find that they lose more than they gain as far as student progress.<p>Note that this is not to say that you should avoid the advanced stuff.  Attempts at hiding complexity never seem to pan out to results.  Instead, honesty with the students goes a long long way.<p>I would also be interested in knowing about all of the things that were a bit more normal in the early days that people today have likely never seen.  Call semantics that are not stack based, as an easy example.</div><br/></div></div><div id="41297092" class="c"><input type="checkbox" id="c-41297092" checked=""/><div class="controls bullet"><span class="by">zahlman</span><span>|</span><a href="#41296362">prev</a><span>|</span><a href="#41296108">next</a><span>|</span><label class="collapse" for="c-41297092">[-]</label><label class="expand" for="c-41297092">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The programmer is in the unique position that his is the only discipline and profession in which such a gigantic ratio, which totally baffles our imagination, has to be bridged by a single technology.<p>I think that for example environmentalists, who coined the phrase &quot;think locally, act globally&quot; and contemplated an already existing world population on the order of 10^9, might beg to differ. Or, say, astronomers. Or physicists. Yes, people often have poor intuition about large numbers. No, the resulting problem isn&#x27;t remotely unique to CS.<p>&gt; The second radical novelty is that the automatic computer is our first large-scale digital device.<p>Yet small-scale digital devices such as mechanical relays - or, for that matter, light switches and push buttons - were well established by Dijkstra&#x27;s time. The scale isn&#x27;t relevant to that concept; experience is, and students in the 1980s had plenty of reasonable mental models for a bit of data as an abstraction (or the hardware storing it, or a boolean value in a program).<p>&gt; To do so, however, is highly dangerous: the analogy is too shallow because a program is, as a mechanism, totally different from all the familiar analogue devices we grew up with.<p>As if students would never encounter stepwise functions in math class (or much stranger beasts for that matter)... ?<p>Metaphor and analogy are simply at the core of how people naturally learn. We are not machines that can be deliberately and directly programmed with an understanding of novel systems. The imperfections of the metaphors we use, are no more a problem than the leaks in the abstractions we create in our programs.<p>&gt; Unfathomed misunderstanding is further revealed by the term &quot;software maintenance&quot;, as a result of which many people continue to believe that programs —and even programming languages themselves— are subject to wear and tear.<p>I can only imagine what Dijkstra would think of today&#x27;s &quot;ecosystems&quot;.</div><br/></div></div><div id="41296108" class="c"><input type="checkbox" id="c-41296108" checked=""/><div class="controls bullet"><span class="by">an-allen</span><span>|</span><a href="#41297092">prev</a><span>|</span><a href="#41296467">next</a><span>|</span><label class="collapse" for="c-41296108">[-]</label><label class="expand" for="c-41296108">[3 more]</label></div><br/><div class="children"><div class="content">I mean, I’m actually somewhat curious how starting tertiary computer science curriculum with formal methods would impact the students. I mean I felt my intro undergrad 101 course was essentially functional programming and lambda calculus (with Scheme)- and I felt that helped establish a fundamentally different way of thinking about computer science than a more basic procedural type introduction would have. When they moved the intro course to be OOP instead I felt it was a travesty.</div><br/><div id="41296933" class="c"><input type="checkbox" id="c-41296933" checked=""/><div class="controls bullet"><span class="by">ht_th</span><span>|</span><a href="#41296108">parent</a><span>|</span><a href="#41296467">next</a><span>|</span><label class="collapse" for="c-41296933">[-]</label><label class="expand" for="c-41296933">[2 more]</label></div><br/><div class="children"><div class="content">I did follow a curriculum set by Dijkstra&#x27;s students. In the first trimester, we learned to program in Pascal, so we knew what programming was. The next two programming courses, in the second and fourth trimester, &quot;programming&quot; meant proving programs correct. Using pen and paper. Often in one-on-one sessions with our teachers where we&#x27;d to demonstrate our proofs. Or the teacher would state a problem and then continue to derive a correct progam by construction, writing slowly on the blackboard. These programming courses were supplemented with logic, discrete mathematics, and other formal methods. And we had continuous mathematics courses as well, practical labs, electronics, databases, and whatever you&#x27;d expect in a computer science and engineering curriculum.<p>For most students this wasn&#x27;t easy, particularly compared to the way most of them were comfortable programming on their own by trial-and-error hacking away at a problem. Proving programs correct by construction takes a different skill. At the same time, it wasn&#x27;t particularly hard either once you got going.<p>I don&#x27;t think this way of teaching and learning programming was very useful or practical. With Dijkstra&#x27;s students leaving the university, or otherwise losing primacy at the computer science faculty, Dijsktra&#x27;s ideas faded away from the curriculum. Since then—I returned twenty years later to teach at this university—, the curriculum is very like any other computer science &#x2F; engineering curriculum. And students seemed to have as much trouble with it as before.<p>What I missed about the curriculum when it was gone, was the consistency it brought into the curriculum. The curriculum felt as one continuous track to some clear idea of what it meant to be a programmer in Dijkstra&#x27;s style. If you liked that idea, the curriculum was a great guide. If you didn&#x27;t, it felt as a waste of time.</div><br/><div id="41297473" class="c"><input type="checkbox" id="c-41297473" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#41296108">root</a><span>|</span><a href="#41296933">parent</a><span>|</span><a href="#41296467">next</a><span>|</span><label class="collapse" for="c-41297473">[-]</label><label class="expand" for="c-41297473">[1 more]</label></div><br/><div class="children"><div class="content">&gt; compared to the way most of them were comfortable programming on their own by trial-and-error hacking away at a problem.<p>This is only a viable strategy insofar as the tool which lets them hack away is itself correct.  You need computer scientists producing these tools.</div><br/></div></div></div></div></div></div><div id="41296467" class="c"><input type="checkbox" id="c-41296467" checked=""/><div class="controls bullet"><span class="by">initramfs</span><span>|</span><a href="#41296108">prev</a><span>|</span><a href="#41296087">next</a><span>|</span><label class="collapse" for="c-41296467">[-]</label><label class="expand" for="c-41296467">[1 more]</label></div><br/><div class="children"><div class="content">fantastic.</div><br/></div></div><div id="41296087" class="c"><input type="checkbox" id="c-41296087" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#41296467">prev</a><span>|</span><a href="#41295912">next</a><span>|</span><label class="collapse" for="c-41296087">[-]</label><label class="expand" for="c-41296087">[4 more]</label></div><br/><div class="children"><div class="content">Mathematics is inferior to programming, in a way, because the entire hierarchy of mathematics relies on human beliefs at every stage, all the way down to its axioms. The beliefs of many highly intelligent humans, but beliefs of biased individuals nonetheless. Humans simply can&#x27;t match the accuracy of a compiler when it comes to finding flaws.<p>On the other hand, a program&#x27;s correctness doesn&#x27;t depend on human beliefs. It can be proven to work perfectly on certain ranges of inputs by actually executing it on those inputs. Human subjectivity can be factored out to an increasing degree by way of automated tests. This level of concrete proof exceeds the level of social proof which mathematics relies on. The electronics upon which programs execute do not have biases as humans do. Evaluating a complex mathematical proof is as prone to errors as humans evaluating a complex computer program with their own minds. The compiler will always beat the human when determining correctness of a program for a well defined range of inputs.<p>Although automated tests can rarely prove universal truths, they rarely need to, as the logic they test only needs to handle a limited number of inputs and requires a limited number of guarantees. For many programs, the degree of proof that a well written automated test can provide far exceeds the degree of proof that a mathematical proof (based on human consensus) can provide.<p>This is why programming can accumulate complexity at a rate which is unfathomable in mathematics. With AI, programming may exceed the capabilities of mathematics to such extent that the entire field of mathematics will become a historical relic; showcasing the desperation of feeble human minds to grasp truths that are well outside of their reach.<p>The &#x27;importance&#x27; of the field of knowledge comes down to the scale of the information and growth speed of the field. For all practical purposes, it seems that the programmatic, exhaustive approach will beat out the mathematical approach of trying to solve problems by uncovering universal truths.</div><br/><div id="41296980" class="c"><input type="checkbox" id="c-41296980" checked=""/><div class="controls bullet"><span class="by">meroes</span><span>|</span><a href="#41296087">parent</a><span>|</span><a href="#41296155">next</a><span>|</span><label class="collapse" for="c-41296980">[-]</label><label class="expand" for="c-41296980">[1 more]</label></div><br/><div class="children"><div class="content">If mathematics is so vast the human mind is feeble to it, then it’s also too vast for exhaustive search. Axioms aren’t even beliefs. They are first principles at the service of solving mathematical problems. If we want to solve other problems, we can change the axioms. That goes all the way back to Plato. We treat them as if they were true to solve the problems at hand. (It’s called as-ifism if you want to google it). Since logical and mathematical space is infinite; exhaustive search is the wrong approach.</div><br/></div></div><div id="41296155" class="c"><input type="checkbox" id="c-41296155" checked=""/><div class="controls bullet"><span class="by">fsmv</span><span>|</span><a href="#41296087">parent</a><span>|</span><a href="#41296980">prev</a><span>|</span><a href="#41295912">next</a><span>|</span><label class="collapse" for="c-41296155">[-]</label><label class="expand" for="c-41296155">[2 more]</label></div><br/><div class="children"><div class="content">To be fair we do have computer verified proofs now although it doesn&#x27;t encompass everything.<p>Also programming is based on mathematical ideas. I don&#x27;t think you can do away with mathematics just because of AI.</div><br/><div id="41296342" class="c"><input type="checkbox" id="c-41296342" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#41296087">root</a><span>|</span><a href="#41296155">parent</a><span>|</span><a href="#41295912">next</a><span>|</span><label class="collapse" for="c-41296342">[-]</label><label class="expand" for="c-41296342">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, though mathematics and programming as we understand them are both ways for humans to express logic. As much as mathematicians want to believe it, math is not the same as logic. The former serves to express logic to other humans while the latter serves to express logic to both other humans and computers. It&#x27;s not like in the business world; mathematics doesn&#x27;t get to have a monopoly over logic just because it came first.<p>Math and computer science just happen to be two fields which concern themselves with different aspects of logic. Math being slow-moving and focused on solving universal problems and computer science being fast-moving and focused on solving concrete problems.<p>Once in a while, advancements like cryptography and LLMs show us that focusing on solving concrete problems can also expand our knowledge and capabilities in a radical (and useful) way.<p>I resent articles which try to present one as more important than the other. What does that even mean? Appeal to academic authority? Utility value? Difficulty? Degree of abstraction? They&#x27;re both just languages which solve problems in different ways and which have different target audiences and have different scalability constraints.</div><br/></div></div></div></div></div></div><div id="41295912" class="c"><input type="checkbox" id="c-41295912" checked=""/><div class="controls bullet"><span class="by">djaouen</span><span>|</span><a href="#41296087">prev</a><span>|</span><label class="collapse" for="c-41295912">[-]</label><label class="expand" for="c-41295912">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like projection to me.<p>- DJ<p>Edit: &quot;Then reduce the use of the brain and calculate!&quot;  This is literally the worst advice I have ever read.<p>- DJ</div><br/></div></div></div></div></div></div></div></body></html>