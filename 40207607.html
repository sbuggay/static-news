<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1714640483936" as="style"/><link rel="stylesheet" href="styles.css?v=1714640483936"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://buttondown.email/jaffray/archive/not-all-graphs-are-trees/">Not all graphs are trees</a> <span class="domain">(<a href="https://buttondown.email">buttondown.email</a>)</span></div><div class="subtext"><span>g0xA52A2A</span> | <span>32 comments</span></div><br/><div><div id="40233236" class="c"><input type="checkbox" id="c-40233236" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#40233918">next</a><span>|</span><label class="collapse" for="c-40233236">[-]</label><label class="expand" for="c-40233236">[3 more]</label></div><br/><div class="children"><div class="content">This made me scratch my head:<p>&gt; Even in a language like Rust, which has not yet implemented mutable aliasing (an oft-requested feature stuck at the RFC stage)<p>Disallowing mutable aliasing is in fact the whole point of Rust. Perhaps it’s “requested” by people still learning the language? Is the “not yet implemented” part meant as irony? Does the author mean something else?</div><br/><div id="40233474" class="c"><input type="checkbox" id="c-40233474" checked=""/><div class="controls bullet"><span class="by">ChrisSD</span><span>|</span><a href="#40233236">parent</a><span>|</span><a href="#40233469">next</a><span>|</span><label class="collapse" for="c-40233474">[-]</label><label class="expand" for="c-40233474">[1 more]</label></div><br/><div class="children"><div class="content">And it has mutable aliasing via `UnsafeCell`[0] which, as the name says, is unsafe. But safe wrappers can be built around it, such as `Cell`[1]. Or you can just use raw pointers and take safety into your own hands.<p>[0]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;struct.UnsafeCell.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;struct.UnsafeCell.html</a><p>[1]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;struct.Cell.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;struct.Cell.html</a></div><br/></div></div><div id="40233469" class="c"><input type="checkbox" id="c-40233469" checked=""/><div class="controls bullet"><span class="by">sondr3</span><span>|</span><a href="#40233236">parent</a><span>|</span><a href="#40233474">prev</a><span>|</span><a href="#40233918">next</a><span>|</span><label class="collapse" for="c-40233469">[-]</label><label class="expand" for="c-40233469">[1 more]</label></div><br/><div class="children"><div class="content">This also made me scratch my beard, but I think he maybe means allowing multiple mutable references to a variable when the compiler can prove that nothing bad happens. It&#x27;s something a bunch of people have been trying to solve with different models, the most recent I know of is Tree Borrows [1].<p>[1]: <a href="https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2023&#x2F;06&#x2F;02&#x2F;tree-borrows.html" rel="nofollow">https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;2023&#x2F;06&#x2F;02&#x2F;tree-borrows.html</a></div><br/></div></div></div></div><div id="40233918" class="c"><input type="checkbox" id="c-40233918" checked=""/><div class="controls bullet"><span class="by">koolala</span><span>|</span><a href="#40233236">prev</a><span>|</span><a href="#40232167">next</a><span>|</span><label class="collapse" for="c-40233918">[-]</label><label class="expand" for="c-40233918">[1 more]</label></div><br/><div class="children"><div class="content">1960: Arrays (Lisp)<p>2001: Arrays &amp; Trees (Json)<p>2042: Graphs, Trees, Arrays (XML final era)</div><br/></div></div><div id="40232167" class="c"><input type="checkbox" id="c-40232167" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#40233918">prev</a><span>|</span><a href="#40232141">next</a><span>|</span><label class="collapse" for="c-40232167">[-]</label><label class="expand" for="c-40232167">[2 more]</label></div><br/><div class="children"><div class="content">Can someone explain the relationship between implementing WITH (…) AS X … and integer linear programs?<p>I wish this post had more examples of concrete non-tree queries. Is cross-joining a CTE to itself realistic?<p>Imo this discussion seems to assume multiple references of a CTE contain many of the same rows with different transforms which are later joined.. what’s an actual example of this? I don’t think I’ve ever seen it<p>Usually CTEs are shorthand for doing a few joins. And when you reference them multiple times, it’s almost always with different rows in the CTE table. AKA little-no reuse potential. Postgres WITH AS NOT MATERIALIZED of course</div><br/><div id="40232257" class="c"><input type="checkbox" id="c-40232257" checked=""/><div class="controls bullet"><span class="by">foldU</span><span>|</span><a href="#40232167">parent</a><span>|</span><a href="#40232141">next</a><span>|</span><label class="collapse" for="c-40232257">[-]</label><label class="expand" for="c-40232257">[1 more]</label></div><br/><div class="children"><div class="content">More deserves to be written on the ILP idea, I haven&#x27;t actually tried to make it work but it seems to me like the only real direction to optimize (&quot;optimize&quot; used in the mathematical sense, rather than the programming sense) queries that you can&#x27;t just exploit the principle of optimality on (see this earlier article I wrote [1] for a bit more exposition). I think maybe some of the egg [2] people have experimented with this.<p>Speaking from experience, there&#x27;s lots of rewrites you&#x27;d want to do in a query optimizer that having access to efficient DAG-shaped query plans would make tenable, but as a specific example they are an important part of doing full subquery decorrelation [3].<p>[1] <a href="https:&#x2F;&#x2F;buttondown.email&#x2F;jaffray&#x2F;archive&#x2F;why-are-query-plans-trees&#x2F;" rel="nofollow">https:&#x2F;&#x2F;buttondown.email&#x2F;jaffray&#x2F;archive&#x2F;why-are-query-plans...</a><p>[2] <a href="https:&#x2F;&#x2F;egraphs-good.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;egraphs-good.github.io&#x2F;</a><p>[3] <a href="https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;materialize-decorrelation" rel="nofollow">https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;materialize-decor...</a></div><br/></div></div></div></div><div id="40232141" class="c"><input type="checkbox" id="c-40232141" checked=""/><div class="controls bullet"><span class="by">MrLeap</span><span>|</span><a href="#40232167">prev</a><span>|</span><a href="#40232269">next</a><span>|</span><label class="collapse" for="c-40232141">[-]</label><label class="expand" for="c-40232141">[3 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t know about datalog before reading this! I became kind of smitten with prolog in college but never found an opportunity to use it.<p>Now that I&#x27;m a gamedev, if there&#x27;s a permissively licensed C&#x2F;C++ or a DLL, or something in .net land that would let me store facts and rules and run some queries, I could put it to work.<p>If anyone that reads this has cooked with deductive databases &#x2F; theorem proving &#x2F; logic programming languages things I&#x27;d love to hear your guidepost opinions.</div><br/><div id="40232342" class="c"><input type="checkbox" id="c-40232342" checked=""/><div class="controls bullet"><span class="by">chaosite</span><span>|</span><a href="#40232141">parent</a><span>|</span><a href="#40233453">next</a><span>|</span><label class="collapse" for="c-40232342">[-]</label><label class="expand" for="c-40232342">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s Souffle[1] that can synthesize C++ for you that you then compile with the rest of your C++.<p>[1]: <a href="https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;</a></div><br/></div></div><div id="40233453" class="c"><input type="checkbox" id="c-40233453" checked=""/><div class="controls bullet"><span class="by">truckerbill</span><span>|</span><a href="#40232141">parent</a><span>|</span><a href="#40232342">prev</a><span>|</span><a href="#40232269">next</a><span>|</span><label class="collapse" for="c-40233453">[-]</label><label class="expand" for="c-40233453">[1 more]</label></div><br/><div class="children"><div class="content">CozoDB</div><br/></div></div></div></div><div id="40232269" class="c"><input type="checkbox" id="c-40232269" checked=""/><div class="controls bullet"><span class="by">GrantMoyer</span><span>|</span><a href="#40232141">prev</a><span>|</span><a href="#40233171">next</a><span>|</span><label class="collapse" for="c-40232269">[-]</label><label class="expand" for="c-40232269">[1 more]</label></div><br/><div class="children"><div class="content">For anyone getting caught up in the notation, note that the actual example expressions are immaterial; you might as well replace the strange looking relational algebra operators with &quot;=&quot;s or &quot;+&quot;s. At it&#x27;s core the article is covering different ways to represent graphs, and demonstrating that one particular method allows concise representation of graphs that aren&#x27;t easily represented by linear  expressions (linear in the graph sense, not the linear algebra sense).<p>In order, the representations are:<p>1. &quot;Inlining&quot;, a direct tree structure, in C++-like syntax something like `struct Node {vector&lt;Node&gt;;}`. The insight here is that if you&#x27;re not storing a tree, some of the nodes need to be duplicated.<p>2. &quot;Let Bindings&quot;, An indirect tree structure, like `struct Node {vector&lt;Node*&gt;;}`. Here, the insight is that instead of storing nodes, you store <i>names of</i> nodes (in this case pointers), so that the nodes can be re-used. Note that the nodes themselves may be stored somewhere else in the same expressions.<p>3. &quot;Self-Reference&quot;, same as above, but a node can store the name of itself, or one of its ancestors.<p>4. &quot;Fixpoint Operator&quot;, Instead of explicitly storing a graph, we store a transformation from one graph to another, then say the graph we want equals that transformation repeatedly applied to some starting graph, until the transformation&#x27;s output equals its input (a.k.a. a fixed point is found). Something like `struct ImplicitGraph {Graph initial; Graph (*)(Graph) transform;}`. If you&#x27;re unfamiliar with C++ function pointers, transform is a function from Graph to Graph. The &quot;hole&quot; the author talks about refers to the fact that the output graph of the transformation can contain copies of the input graph, so the &quot;hole&quot; is the transform parameter; there&#x27;s a &quot;hole&quot; in the output graph until the parameter is known. Since the transformation can be arbitrarily complex, any graph can be represented, although typically, you&#x27;d want as simple a transform as possible.<p>5. &quot;Explicit Listing of Edges&quot;, this method is actually more straightforward than the previous, but it requires thinking about the graph a little differently. It&#x27;s exactly what it says on the tin; instead of the graph being implicit in the structure of the data, the edges (a.k.a. links or lines) are explicitly listed. There&#x27;s more than one way to do this, for example a straightforward way might look like `struct Graph {set&lt;Node&gt;; set&lt;pair&lt;Node*, Node*&gt;&gt;;}`. From the example in the article, it looks like Datalog is closer to something like `struct Graph {set&lt;Node&gt; initial_nodes; set&lt;optional&lt;Node&gt; (*)(Node)&gt; generators;}`. Kind of like in 4., you start with a set of nodes, then repeatedly apply each generator to each node until you stop getting new nodes. The edges in this case are between each node and the nodes it generates.<p>Finally, all of these types of representations also exist syntactically, not just structurally. After all, an expression in a given syntax is just a way of representing some structure, the same way a bunch of bytes in memory can be a way of representing some structure. And each of these representations has strengths syntactically and structurally.</div><br/></div></div><div id="40233171" class="c"><input type="checkbox" id="c-40233171" checked=""/><div class="controls bullet"><span class="by">Vt71fcAqt7</span><span>|</span><a href="#40232269">prev</a><span>|</span><a href="#40231038">next</a><span>|</span><label class="collapse" for="c-40233171">[-]</label><label class="expand" for="c-40233171">[1 more]</label></div><br/><div class="children"><div class="content">A tree is a type of graph. Is the headline meant to reveal the fact that not all graphs are trees (which is obvious) or is it meant like &quot;not all graphs are trees, and here&#x27;s how you deal with those non-tree graphs?&quot; Even then I&#x27;m confused about the title of the article.</div><br/></div></div><div id="40231038" class="c"><input type="checkbox" id="c-40231038" checked=""/><div class="controls bullet"><span class="by">smitty1e</span><span>|</span><a href="#40233171">prev</a><span>|</span><a href="#40231294">next</a><span>|</span><label class="collapse" for="c-40231038">[-]</label><label class="expand" for="c-40231038">[12 more]</label></div><br/><div class="children"><div class="content">When I hear &#x27;tree&#x27; I think <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Directed_acyclic_graph" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Directed_acyclic_graph</a></div><br/><div id="40231393" class="c"><input type="checkbox" id="c-40231393" checked=""/><div class="controls bullet"><span class="by">kjeetgill</span><span>|</span><a href="#40231038">parent</a><span>|</span><a href="#40231291">next</a><span>|</span><label class="collapse" for="c-40231393">[-]</label><label class="expand" for="c-40231393">[10 more]</label></div><br/><div class="children"><div class="content">Tree&#x27;s are subsets of DAGs — A DAG where each node has a single parent except for a specific root element which has none.</div><br/><div id="40233845" class="c"><input type="checkbox" id="c-40233845" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40231393">parent</a><span>|</span><a href="#40231483">next</a><span>|</span><label class="collapse" for="c-40233845">[-]</label><label class="expand" for="c-40233845">[1 more]</label></div><br/><div class="children"><div class="content">&gt; where each node has a single parent except for a specific root element which has none.<p>Slight nitpick: in mathematics, a tree need not have a root.<p><a href="https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;FreeTree.html" rel="nofollow">https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;FreeTree.html</a>: <i>“a normal tree with no node singled out for special treatment”</i><p><a href="https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;RootedTree.html" rel="nofollow">https:&#x2F;&#x2F;mathworld.wolfram.com&#x2F;RootedTree.html</a>: <i>“A rooted tree is a tree in which a special (&quot;labeled&quot;) node is singled out. This node is called the &quot;root&quot; or (less commonly) &quot;eve&quot; of the tree. Rooted trees are equivalent to oriented trees (Knuth 1997, pp. 385-399). A tree which is not rooted is sometimes called a free tree, although the unqualified term &quot;tree&quot; generally refers to a free tree.”</i></div><br/></div></div><div id="40231483" class="c"><input type="checkbox" id="c-40231483" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40231393">parent</a><span>|</span><a href="#40233845">prev</a><span>|</span><a href="#40231291">next</a><span>|</span><label class="collapse" for="c-40231483">[-]</label><label class="expand" for="c-40231483">[8 more]</label></div><br/><div class="children"><div class="content">Technically a tree doesn’t need to be directed.<p>A tree is (also) any loop-free graph.</div><br/><div id="40232154" class="c"><input type="checkbox" id="c-40232154" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40231483">parent</a><span>|</span><a href="#40233331">next</a><span>|</span><label class="collapse" for="c-40232154">[-]</label><label class="expand" for="c-40232154">[6 more]</label></div><br/><div class="children"><div class="content">A forest is an acyclic graph.  A tree is a connected forest.</div><br/><div id="40232241" class="c"><input type="checkbox" id="c-40232241" checked=""/><div class="controls bullet"><span class="by">holden_nelson</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40232154">parent</a><span>|</span><a href="#40233331">next</a><span>|</span><label class="collapse" for="c-40232241">[-]</label><label class="expand" for="c-40232241">[5 more]</label></div><br/><div class="children"><div class="content">Exactly one path between any two nodes is how I best visualize it.</div><br/><div id="40232522" class="c"><input type="checkbox" id="c-40232522" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40232241">parent</a><span>|</span><a href="#40232528">next</a><span>|</span><label class="collapse" for="c-40232522">[-]</label><label class="expand" for="c-40232522">[3 more]</label></div><br/><div class="children"><div class="content">You gotta be careful -- a path does not exist between two leaf nodes, unless your edges are non-directional, in which case you&#x27;re right.  Oh and restrict it to &#x27;only visit each node once&#x27; given undirected.<p>Sorry my inner edge case fairy beckoned.</div><br/><div id="40232656" class="c"><input type="checkbox" id="c-40232656" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40232522">parent</a><span>|</span><a href="#40232528">next</a><span>|</span><label class="collapse" for="c-40232656">[-]</label><label class="expand" for="c-40232656">[2 more]</label></div><br/><div class="children"><div class="content">Visiting a node twice implies a loop, which implies two paths between your original nodes.<p>Let’s say we want to get from A to B, but we visit Y twice. That means there’s a segment of A~B that is Y~Y (a loop). However, since we’re talking about undirected edges, we can reverse that segment. Then both our original A~B and the A~B with Y~Y reversed are paths from A to B.<p>So if there’s a single path from A to B, there cannot be a Y we visit twice along that path.<p>(Please don’t take this as criticism; my pedantic nature got the better of me.)</div><br/><div id="40233473" class="c"><input type="checkbox" id="c-40233473" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40232656">parent</a><span>|</span><a href="#40232528">next</a><span>|</span><label class="collapse" for="c-40233473">[-]</label><label class="expand" for="c-40233473">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but in an UndirectedGraph you can do loops easy peasy.  A-&gt;b-&gt;a-&gt;b etc. if you have a tree with a parent node, then the tree (A{children:[b], parent: null}, B{children:[], parent: A}) still may allow for this behavior (graph representation unions parent and children since a parent in tree parlence is basically &#x27;incoming-edges&#x27; in graph parlence while children is &#x27;outgoing-edges&#x27;)<p>I was trying to find terminology for something 
Like &#x27;all possible paths between these two nodes contain exactly one Hamiltonian sub-path&#x27; but I think that&#x27;s a bit of a circular definition<p>All that said I&#x27;m running off 3 hours of sleep and about to recoup so that probably explains my non constructive comments here</div><br/></div></div></div></div></div></div><div id="40232528" class="c"><input type="checkbox" id="c-40232528" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40232241">parent</a><span>|</span><a href="#40232522">prev</a><span>|</span><a href="#40233331">next</a><span>|</span><label class="collapse" for="c-40232528">[-]</label><label class="expand" for="c-40232528">[1 more]</label></div><br/><div class="children"><div class="content">A forest is where all nodes are connected by at most one path. 0 or 1. And a single tree is a forest. And a single node is a tree.</div><br/></div></div></div></div></div></div><div id="40233331" class="c"><input type="checkbox" id="c-40233331" checked=""/><div class="controls bullet"><span class="by">contingencies</span><span>|</span><a href="#40231038">root</a><span>|</span><a href="#40231483">parent</a><span>|</span><a href="#40232154">prev</a><span>|</span><a href="#40231291">next</a><span>|</span><label class="collapse" for="c-40233331">[-]</label><label class="expand" for="c-40233331">[1 more]</label></div><br/><div class="children"><div class="content"><i>I think that I shall never see; A graph more lovely than a tree. A tree whose crucial property; Is loop-free connectivity.</i> - Radia Perlman, inventor of spanning tree<p>... via <a href="https:&#x2F;&#x2F;github.com&#x2F;globalcitizen&#x2F;taoup">https:&#x2F;&#x2F;github.com&#x2F;globalcitizen&#x2F;taoup</a></div><br/></div></div></div></div></div></div><div id="40231291" class="c"><input type="checkbox" id="c-40231291" checked=""/><div class="controls bullet"><span class="by">tupshin</span><span>|</span><a href="#40231038">parent</a><span>|</span><a href="#40231393">prev</a><span>|</span><a href="#40231294">next</a><span>|</span><label class="collapse" for="c-40231291">[-]</label><label class="expand" for="c-40231291">[1 more]</label></div><br/><div class="children"><div class="content">The article talks about them on the progressive journey to generalized graphs.</div><br/></div></div></div></div><div id="40232007" class="c"><input type="checkbox" id="c-40232007" checked=""/><div class="controls bullet"><span class="by">EricRiese</span><span>|</span><a href="#40231470">prev</a><span>|</span><a href="#40233221">next</a><span>|</span><label class="collapse" for="c-40232007">[-]</label><label class="expand" for="c-40232007">[1 more]</label></div><br/><div class="children"><div class="content">#NotAllGraphs</div><br/></div></div><div id="40233221" class="c"><input type="checkbox" id="c-40233221" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#40232007">prev</a><span>|</span><label class="collapse" for="c-40233221">[-]</label><label class="expand" for="c-40233221">[2 more]</label></div><br/><div class="children"><div class="content">Not all graphs are trees, but all the graphs in this article are trees.<p>They are DAGs, which are a deduplicated representation of trees.</div><br/><div id="40233335" class="c"><input type="checkbox" id="c-40233335" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40233221">parent</a><span>|</span><label class="collapse" for="c-40233335">[-]</label><label class="expand" for="c-40233335">[1 more]</label></div><br/><div class="children"><div class="content">A DAG is not a tree. It literally has graph in the name. In a tree each node has exactly one parent &#x2F; incoming edge. Not the case for DAGs.</div><br/></div></div></div></div></div></div></div></div></div></body></html>