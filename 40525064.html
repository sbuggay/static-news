<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1717146073707" as="style"/><link rel="stylesheet" href="styles.css?v=1717146073707"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://testing.googleblog.com/2024/05/dont-dry-your-code-prematurely.html">Don&#x27;t DRY Your Code Prematurely</a> <span class="domain">(<a href="https://testing.googleblog.com">testing.googleblog.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>255 comments</span></div><br/><div><div id="40528193" class="c"><input type="checkbox" id="c-40528193" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#40525690">next</a><span>|</span><label class="collapse" for="c-40528193">[-]</label><label class="expand" for="c-40528193">[37 more]</label></div><br/><div class="children"><div class="content">Sometimes it&#x27;s best to be DRY right from the start.<p>Several years ago, I did some contract work for a company that needed importers for airspace data and various other kinds of data relevant to flying.<p>In the US, the Federal Aviation Administration (FAA) publishes datasets for several kinds of airspace data. Two of them are called &quot;Class Airspace&quot; and &quot;Special Use Airspace&quot;.<p>The guy who wrote the original importers for these treated them as completely separate and unrelated data. He used an internal generic tool to convert the FAA data for each kind of airspace into a format used within the company, and then wrote separate C++ code, thousands of lines of code each.<p>Thing is, the data for these two kinds of airspace is mostly identical. You could process it all with one common codebase, with separate code for only the 10% of the data that is different between the two formats.<p>When I asked him about this, he said, &quot;I have this philosophy that says if you only have two similar things, it&#x27;s best to write separate code for each. Once you get to a third, then you can think about refactoring and making some common code.&quot;<p>That is a good philosophy! I have often followed it myself.<p>But in this case, it was obvious that the two data formats were mostly the same, and there was never going to be a <i>third</i> kind of almost-identical airspace, only the two. So we had twice the code we needed.</div><br/><div id="40528380" class="c"><input type="checkbox" id="c-40528380" checked=""/><div class="controls bullet"><span class="by">ebolyen</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40530244">next</a><span>|</span><label class="collapse" for="c-40528380">[-]</label><label class="expand" for="c-40528380">[22 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know, that sounds like a complex kind of ingest which could be arbitrarily subtle and diverge over time for legal and bureaucratic reasons.<p>I would kind of appreciate having two formats, since what are the odds they would change together? While there may never be a 3rd format, a DRY importer would imply that the source generating the data is also DRY.</div><br/><div id="40528756" class="c"><input type="checkbox" id="c-40528756" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528380">parent</a><span>|</span><a href="#40528531">next</a><span>|</span><label class="collapse" for="c-40528756">[-]</label><label class="expand" for="c-40528756">[6 more]</label></div><br/><div class="children"><div class="content">Good point. This may be a case where domain knowledge is helpful.<p>One of the reasons they brought me in on this project is that besides knowing how to wrangle data, I&#x27;m also an experienced pilot. So I had a good intuitive sense of the meaning and purpose of the data.<p>The part of the data that was identical is the description of the airspace boundaries. Pilots will recognize this as the famous &quot;upside down wedding cake&quot;. But it&#x27;s not just simple circles like a wedding cake. There are all kinds of cutouts and special cases.<p>Stuff like &quot;From point A, draw an arc to point B with its center at point C. Then track the centerline of the San Seriffe River using the following list of points. Finally, from point D draw a straight line back to point A.&quot;<p>The FAA would be very reluctant to change this, for at least two reasons:<p>1. Who will provide us the budget to make these changes?<p>2. Who will take the heat when we break every client of this data?</div><br/><div id="40529060" class="c"><input type="checkbox" id="c-40529060" checked=""/><div class="controls bullet"><span class="by">ebolyen</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528756">parent</a><span>|</span><a href="#40530802">next</a><span>|</span><label class="collapse" for="c-40529060">[-]</label><label class="expand" for="c-40529060">[4 more]</label></div><br/><div class="children"><div class="content">I see, so it&#x27;s a procedural language that is well understood by those who fly (not just some semi-structured data or ontology). This is a great example of the advantage of domain experience. Thanks for sharing!</div><br/><div id="40529469" class="c"><input type="checkbox" id="c-40529469" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529060">parent</a><span>|</span><a href="#40530802">next</a><span>|</span><label class="collapse" for="c-40529469">[-]</label><label class="expand" for="c-40529469">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>a procedural language that is well understood by those who fly</i><p>That is a great way to describe it!<p>Of course it is all just rows in a CSV file, but yes, it is a set of instructions for how to generate a map.<p>In fact the pilot&#x27;s maps were being drawn long before the computer era. Apparently the first FAA sectional chart was published in 1930! So the data format was derived from what must have been human-readable descriptions of what to plot on the map using a compass and straightedge.<p>I just remembered a quirk of the Australian airspace data. Sometimes they want you to draw a direct line from point F to point G, but there were two different kinds of straight lines. They may ask for a great circle, a straight path on the surface of the Earth. Or a rhumb line, which looks straight on a Mercator projection but is a curved path on the Earth.<p>You would often have some of each in the very same boundary description!<p>For anyone curious about this stuff, I recommend a visit to your local municipal airport and stop by the pilot shop to buy a sectional chart of your area.</div><br/><div id="40529678" class="c"><input type="checkbox" id="c-40529678" checked=""/><div class="controls bullet"><span class="by">tass</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529469">parent</a><span>|</span><a href="#40530802">next</a><span>|</span><label class="collapse" for="c-40529678">[-]</label><label class="expand" for="c-40529678">[2 more]</label></div><br/><div class="children"><div class="content">Paper charts are great (they&#x27;re fairly cheap and printed quite nicely in the USA at least) but you can get a good look at these boundaries through online charts.<p><a href="https:&#x2F;&#x2F;skyvector.com" rel="nofollow">https:&#x2F;&#x2F;skyvector.com</a> is a good way to view these.</div><br/><div id="40529723" class="c"><input type="checkbox" id="c-40529723" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529678">parent</a><span>|</span><a href="#40530802">next</a><span>|</span><label class="collapse" for="c-40529723">[-]</label><label class="expand" for="c-40529723">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! I was trying to remember the name of that site and it slipped my mind. Yes, SkyVector is great.</div><br/></div></div></div></div></div></div></div></div><div id="40530802" class="c"><input type="checkbox" id="c-40530802" checked=""/><div class="controls bullet"><span class="by">hamasho</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528756">parent</a><span>|</span><a href="#40529060">prev</a><span>|</span><a href="#40528531">next</a><span>|</span><label class="collapse" for="c-40530802">[-]</label><label class="expand" for="c-40530802">[1 more]</label></div><br/><div class="children"><div class="content">I think if you know the domain well, it&#x27;s not &quot;premature&quot; at all.</div><br/></div></div></div></div><div id="40528531" class="c"><input type="checkbox" id="c-40528531" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528380">parent</a><span>|</span><a href="#40528756">prev</a><span>|</span><a href="#40529088">next</a><span>|</span><label class="collapse" for="c-40528531">[-]</label><label class="expand" for="c-40528531">[9 more]</label></div><br/><div class="children"><div class="content">In such case I think I&#x27;d go for an internal-DRYing + copy-on-write approach. That is, two identical classes or entry points, one for each format; internally, they&#x27;d share all the common code. Over time, if something changes in one format but not the other, that piece of code gets duplicated and then changed, so the other format retains the original code, which it now owns.</div><br/><div id="40530709" class="c"><input type="checkbox" id="c-40530709" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528531">parent</a><span>|</span><a href="#40531273">next</a><span>|</span><label class="collapse" for="c-40530709">[-]</label><label class="expand" for="c-40530709">[1 more]</label></div><br/><div class="children"><div class="content">I believe this very method is very common in games - you have similar logic for entities, but some have divergences that could occur in unknown ways after playtesting or future development.<p>Tho if done haphazardly by someone inexperienced, you might end up with subtle divergences that might look like they&#x27;re meant to be copies, and debugging them in the future by another developer (without the history or knowledge) can get hard.<p>Then someone would wonder why there are these two very similar pieces of code, and mistakenly try to DRY it in the hopes of improving it, causing subtle mistakes to get introduced...</div><br/></div></div><div id="40531273" class="c"><input type="checkbox" id="c-40531273" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528531">parent</a><span>|</span><a href="#40530709">prev</a><span>|</span><a href="#40529343">next</a><span>|</span><label class="collapse" for="c-40531273">[-]</label><label class="expand" for="c-40531273">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In such case I think I&#x27;d go for an internal-DRYing + copy-on-write approach.<p>I agree. The primary risk of presented by DRY is tight coupling code which only bears similarities at a surface level. Starting off by explicitly keeping the externa bits separate sounds like a good way to avoid the worst tradeoff.<p>Nevertheless I still prefer the Write Everything Twice (WET) principle, which means mostly the same thing, but following a clear guideline: postpone all de-duplication efforts until it&#x27;s either obvious there&#x27;s shared code (semantics and implementation) in &gt;2 occurrences, and always start by treating separate cases as independent cases.</div><br/></div></div><div id="40529343" class="c"><input type="checkbox" id="c-40529343" checked=""/><div class="controls bullet"><span class="by">jeremyjh</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528531">parent</a><span>|</span><a href="#40531273">prev</a><span>|</span><a href="#40528568">next</a><span>|</span><label class="collapse" for="c-40529343">[-]</label><label class="expand" for="c-40529343">[1 more]</label></div><br/><div class="children"><div class="content">This is really good advice and a great way to think about it.</div><br/></div></div><div id="40528568" class="c"><input type="checkbox" id="c-40528568" checked=""/><div class="controls bullet"><span class="by">ebolyen</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528531">parent</a><span>|</span><a href="#40529343">prev</a><span>|</span><a href="#40529088">next</a><span>|</span><label class="collapse" for="c-40528568">[-]</label><label class="expand" for="c-40528568">[5 more]</label></div><br/><div class="children"><div class="content">I like that approach.</div><br/><div id="40529161" class="c"><input type="checkbox" id="c-40529161" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528568">parent</a><span>|</span><a href="#40529088">next</a><span>|</span><label class="collapse" for="c-40529161">[-]</label><label class="expand" for="c-40529161">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had the mantra &quot;inheritance is only for code reuse&quot; and it&#x27;s never steered me wrong.</div><br/><div id="40529625" class="c"><input type="checkbox" id="c-40529625" checked=""/><div class="controls bullet"><span class="by">jameshart</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529161">parent</a><span>|</span><a href="#40530303">next</a><span>|</span><label class="collapse" for="c-40529625">[-]</label><label class="expand" for="c-40529625">[2 more]</label></div><br/><div class="children"><div class="content">Inheritance is only good for code reuse, and it’s a trick you only get to use once for each piece of code, so if you use it you need to be absolutely certain that the taxonomy you’re using it to leverage code across is the right one.<p>All ‘is-a so it gets this code’ models can be trivially modeled as ‘has-a so it gets this code’ patterns, which <i>don’t</i> have that single-use constraint… so the corollary to this rule tends towards ‘never use inheritance’.</div><br/><div id="40531395" class="c"><input type="checkbox" id="c-40531395" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529625">parent</a><span>|</span><a href="#40530303">next</a><span>|</span><label class="collapse" for="c-40531395">[-]</label><label class="expand" for="c-40531395">[1 more]</label></div><br/><div class="children"><div class="content">Single use? No way that&#x27;s what multiple inheritance and mixins are for. Inheritance being only for code reuse is explicitly about <i>not</i> creating a taxonomy. No more is-a just, &quot;I need this code here.&quot; Hey this thing behaves like a mapping inherit from the MutipleMapping and get all the usual mapping methods for free. Hey this model needs created&#x2F;updated_at, inherit from ChangeTracking and get those fields and helper methods for free.<p>Has-a doesn&#x27;t make sense for <i>code</i> like the literal text reuse. It makes sense for composition and encapsulation.<p>Edit: I&#x27;m now realizing that Python has one of the only sane multiple inheritance implementations. It&#x27;s no wonder the rest of y&#x27;all hate it.</div><br/></div></div></div></div><div id="40530303" class="c"><input type="checkbox" id="c-40530303" checked=""/><div class="controls bullet"><span class="by">zeroCalories</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529161">parent</a><span>|</span><a href="#40529625">prev</a><span>|</span><a href="#40529088">next</a><span>|</span><label class="collapse" for="c-40530303">[-]</label><label class="expand" for="c-40530303">[1 more]</label></div><br/><div class="children"><div class="content">It seems like OP is describing a shared interface, not necessarily inheritance.</div><br/></div></div></div></div></div></div></div></div><div id="40529088" class="c"><input type="checkbox" id="c-40529088" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528380">parent</a><span>|</span><a href="#40528531">prev</a><span>|</span><a href="#40530244">next</a><span>|</span><label class="collapse" for="c-40529088">[-]</label><label class="expand" for="c-40529088">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know.  I&#x27;ve seen this approach for projects before go bad - people didn&#x27;t want to DRY because they might diverge.  Except they never did.  Our 3rd+ scenarios we abstracted.<p>But what basically ended up happening was we had 2 codebases: 1 for that non-DRY version, and then 1 for everything else.  The non-DRY version limped along and no one ever wanted to work on it.  The ways it did things were never updated.  It was rarely improved.  It was kinda left to rot.</div><br/><div id="40531324" class="c"><input type="checkbox" id="c-40531324" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529088">parent</a><span>|</span><a href="#40529155">next</a><span>|</span><label class="collapse" for="c-40531324">[-]</label><label class="expand" for="c-40531324">[2 more]</label></div><br/><div class="children"><div class="content">&gt; But what basically ended up happening was we had 2 codebases: 1 for that non-DRY version, and then 1 for everything else. The non-DRY version limped along and no one ever wanted to work on it. The ways it did things were never updated. It was rarely improved. It was kinda left to rot.<p>It sounds to me that you&#x27;re trying to pin the blame of failing to maintain software on not following DRY, which makes no sense to me.<p>Advocating against mindlessly following DRY is not the same as advocating for not maintaining your software. Also, DRY does not magically earn you extra maintenance credits. In fact, it sounds to me that the bit of the code you called DRY ended up being easier to maintain because it wasn&#x27;t forced to pile on abstractions needed to support the non-DRY code. If it was easy, you&#x27;d already have done it and you wouldn&#x27;t be complaining about the special-purpose code you kept separated.</div><br/></div></div><div id="40529155" class="c"><input type="checkbox" id="c-40529155" checked=""/><div class="controls bullet"><span class="by">jononor</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529088">parent</a><span>|</span><a href="#40531324">prev</a><span>|</span><a href="#40530244">next</a><span>|</span><label class="collapse" for="c-40529155">[-]</label><label class="expand" for="c-40529155">[3 more]</label></div><br/><div class="children"><div class="content">Why wasn&#x27;t the original implementation swapped for the new one? The unwillingness&#x2F;inability to do that seems to be most likely the core of the issues here?</div><br/><div id="40529256" class="c"><input type="checkbox" id="c-40529256" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529155">parent</a><span>|</span><a href="#40530244">next</a><span>|</span><label class="collapse" for="c-40529256">[-]</label><label class="expand" for="c-40529256">[2 more]</label></div><br/><div class="children"><div class="content">The majority of our business was through the 1st implementation.  Because of that it was the base we used to refactor into a more abstract solution for further scenarios.  It was never deemed &quot;worth it&quot; to transition the 2nd non-DRY version.  Why refactor an existing implementation if its working well enough and we could expand to new markets instead?</div><br/><div id="40532378" class="c"><input type="checkbox" id="c-40532378" checked=""/><div class="controls bullet"><span class="by">jononor</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529256">parent</a><span>|</span><a href="#40530244">next</a><span>|</span><label class="collapse" for="c-40532378">[-]</label><label class="expand" for="c-40532378">[1 more]</label></div><br/><div class="children"><div class="content">Yes, why do it? :p I mean, there are pros and cons - costs and benefits. And I can see both scenarios where it is better to spend the time on something else (that has better chance of bringing in money), and cases where it would be the right thing to do the cleanup (maybe original is just about to fall apart, or the new has straight up benefits to the business, or the act of doing it will greatly improve testing&#x2F;QA in a critical area, etc).<p>Writing it DRY in the first place would also have costs, including the alternative costs. Would it have been better to take those there and then?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40530244" class="c"><input type="checkbox" id="c-40530244" checked=""/><div class="controls bullet"><span class="by">PaulStatezny</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40528380">prev</a><span>|</span><a href="#40532333">next</a><span>|</span><label class="collapse" for="c-40530244">[-]</label><label class="expand" for="c-40530244">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Sometimes it&#x27;s best to be DRY right from the start.<p>3 things matter most in real estate: Location, location, location!<p>3 things matter most in programming: Context, context, context!<p>DRY – like almost every other programming tool&#x2F;paradigm&#x2F;principle – are very often misused by a lack of the programmer&#x27;s ability to discern correctly whether the tool&#x2F;paradigm&#x2F;principle fits <i>in the specific context</i>.<p>It&#x27;s not just a science. It&#x27;s an art, too.</div><br/></div></div><div id="40532333" class="c"><input type="checkbox" id="c-40532333" checked=""/><div class="controls bullet"><span class="by">cjfd</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40530244">prev</a><span>|</span><a href="#40528298">next</a><span>|</span><label class="collapse" for="c-40532333">[-]</label><label class="expand" for="c-40532333">[1 more]</label></div><br/><div class="children"><div class="content">This happens when people follow rules mindlessly. 3 is an arbitrary number anyway. Even if 3 is the right number in most cases there will be cases where abstracting after 2 cases is best and others where abstracting after 4 cases is best, or any other number, really.</div><br/></div></div><div id="40528298" class="c"><input type="checkbox" id="c-40528298" checked=""/><div class="controls bullet"><span class="by">wnevets</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40532333">prev</a><span>|</span><a href="#40529059">next</a><span>|</span><label class="collapse" for="c-40528298">[-]</label><label class="expand" for="c-40528298">[4 more]</label></div><br/><div class="children"><div class="content">&gt; So we had twice the code we needed.<p>Was that necessarily a bad thing and something that must be corrected for that code base?<p>I usually follow the same rule of thumb until I find myself repeatedly
updating both at the same time. If I can&#x27;t update one without updating the other then they must be the same thing and its time to DRY.<p>Don&#x27;t Repeat Yourself when updating code.</div><br/><div id="40528462" class="c"><input type="checkbox" id="c-40528462" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528298">parent</a><span>|</span><a href="#40529059">next</a><span>|</span><label class="collapse" for="c-40528462">[-]</label><label class="expand" for="c-40528462">[3 more]</label></div><br/><div class="children"><div class="content">Good points, thanks for bringing them up.<p>Yes, there was some ongoing maintenance of this code where both versions had to be updated. The original author was not a pilot and was unfamiliar with some of the nuances of FAA airspace. One of the reasons they brought me in was that I am a pilot and knew how the FAA&#x27;s data should be interpreted.<p>In the end, not a huge deal, but it was annoying when I had to make the same changes in two places.</div><br/><div id="40528648" class="c"><input type="checkbox" id="c-40528648" checked=""/><div class="controls bullet"><span class="by">thdc</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528462">parent</a><span>|</span><a href="#40529059">next</a><span>|</span><label class="collapse" for="c-40528648">[-]</label><label class="expand" for="c-40528648">[2 more]</label></div><br/><div class="children"><div class="content">Knowing to DRY there depended on business knowledge that the original author did not have.<p>While they were wrong in this case, I would say it was a reasonable move to not DRY based on the code pattern itself at the time. And that&#x27;s the big difference imo - DRYing based strictly on the structure of code vs business processes.</div><br/><div id="40530718" class="c"><input type="checkbox" id="c-40530718" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40528648">parent</a><span>|</span><a href="#40529059">next</a><span>|</span><label class="collapse" for="c-40530718">[-]</label><label class="expand" for="c-40530718">[1 more]</label></div><br/><div class="children"><div class="content">But this implies that you have to guess when and where to DRY, which basically implies that there&#x27;s no good way but via experience and domain knowledge!<p>That&#x27;s not what people want to hear - they want a silver bullet; a set of criteria for which DRY&#x27;ing could be determined from the onset!</div><br/></div></div></div></div></div></div></div></div><div id="40529059" class="c"><input type="checkbox" id="c-40529059" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40528298">prev</a><span>|</span><a href="#40529195">next</a><span>|</span><label class="collapse" for="c-40529059">[-]</label><label class="expand" for="c-40529059">[2 more]</label></div><br/><div class="children"><div class="content">I find this is a case where different pipelines utilizing common functions in different compositions can be a great strategy. If something diverges and a function no longer makes sense in a pipeline, that’s not a big deal. Just pull it out and replace it with something bespoke that does the right thing.<p>I’ve had a lot of success with this in embedded settings where data is piped into storage or OTA, and I want to format and pack it&#x2F;send it up consistently but I might want to treat the data itself slightly differently.</div><br/><div id="40529648" class="c"><input type="checkbox" id="c-40529648" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40529059">parent</a><span>|</span><a href="#40529195">next</a><span>|</span><label class="collapse" for="c-40529648">[-]</label><label class="expand" for="c-40529648">[1 more]</label></div><br/><div class="children"><div class="content">A related concept that IMO still aligns with DRY is that you should only avoid seeming code duplication when things are _semantically_ the same. No matter the mechanism (codegen, generics, macros, inheritance, ...), if you can&#x27;t give a concept a meaningful [0] name then you usually shouldn&#x27;t DRY it up with any mechanism. Your example is a technique I also use a lot, but the critical point is that you&#x27;re choosing to break out functionality which _is_ easy to name.<p>[0a] More generally, I like a concept of &quot;total&quot; functions -- those which have sensible outputs for all their inputs. It&#x27;s a bit of a tomayto&#x2F;tomahto situation defining &quot;all their inputs&quot; (e.g., I&#x27;m personally okay using a function name like `unsafe_foo` and expecting a person to read the docs, and on the other extreme some people want sensible answers to anything the type system allows you to input), but the desired end-state is that when the project&#x27;s requirements change you don&#x27;t muck around with the ABI and implementation of `count_or_maybe_sort_for_these_three_special_customers_or_else_hit_the_db(...)`, or whatever much more generic and very wrong name the method actually has; the individual components are already correct, so you make the changes at the few methods which are actually wrong given the new requirements.<p>[0b] Another way of thinking about it is whether the two things should always change in tandem. For two largely overlapping beaucratic data formats? Maybe; there&#x27;s a comment somewhere in this chain suggesting that they&#x27;ll never go out of sync, but I&#x27;m a bit paranoid of that sort of thing. For the particular data structures that are currently shared by those formats? Absolutely not; if one diverges then you can build the new structure and link it in. The old structure is still valid in its own right.</div><br/></div></div></div></div><div id="40529195" class="c"><input type="checkbox" id="c-40529195" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40529059">prev</a><span>|</span><a href="#40530091">next</a><span>|</span><label class="collapse" for="c-40529195">[-]</label><label class="expand" for="c-40529195">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve got a large number of customer-specific file integrations, and a lot of them are indeed very similar as the customers have the same system on the other side. However almost all the time there&#x27;s some tweaking needed. Customer A used field X for this but customer B used the field for that.<p>So if a new customer comes and need an integration to a system we already support, even if we think they&#x27;ll start out being identical, we just copy the code.<p>Thing is, these things evolve. Suddenly we have to patch over some process-related issues in the other system for customer A, while customer B does not have that issue. Now we can fix A&#x27;s integration without worrying at all about affecting B.<p>Of course we write library and helper functions, and use those actively throughout, so we only repeat the &quot;top level&quot; stuff.</div><br/></div></div><div id="40530091" class="c"><input type="checkbox" id="c-40530091" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40529195">prev</a><span>|</span><a href="#40530506">next</a><span>|</span><label class="collapse" for="c-40530091">[-]</label><label class="expand" for="c-40530091">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Sometimes it&#x27;s best to be DRY right from the start.<p>Never zealously adopt a programming practice that can be summarized in a headline!</div><br/><div id="40530147" class="c"><input type="checkbox" id="c-40530147" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40530091">parent</a><span>|</span><a href="#40530506">next</a><span>|</span><label class="collapse" for="c-40530147">[-]</label><label class="expand" for="c-40530147">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, don&#x27;t be DRY from the start, YAGNI.</div><br/></div></div></div></div><div id="40530506" class="c"><input type="checkbox" id="c-40530506" checked=""/><div class="controls bullet"><span class="by">hakunin</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40530091">prev</a><span>|</span><a href="#40530939">next</a><span>|</span><label class="collapse" for="c-40530506">[-]</label><label class="expand" for="c-40530506">[2 more]</label></div><br/><div class="children"><div class="content">Did the repetition become obvious before or after you saw both implementations? It’s possible that if you dried it up right away, you would’ve abstracted the wrong thing, and it’s way more obvious only in hindsight.</div><br/><div id="40531038" class="c"><input type="checkbox" id="c-40531038" checked=""/><div class="controls bullet"><span class="by">Stratoscope</span><span>|</span><a href="#40528193">root</a><span>|</span><a href="#40530506">parent</a><span>|</span><a href="#40530939">next</a><span>|</span><label class="collapse" for="c-40531038">[-]</label><label class="expand" for="c-40531038">[1 more]</label></div><br/><div class="children"><div class="content">This was some years ago, so my memory may be foggy - and I&#x27;m not instrument rated!<p>As I recall, it was after I saw the two implementations. I got curious and looked at the original FAA data and specifications and saw how much the two kinds of airspace have in common.</div><br/></div></div></div></div><div id="40530939" class="c"><input type="checkbox" id="c-40530939" checked=""/><div class="controls bullet"><span class="by">BurningFrog</span><span>|</span><a href="#40528193">parent</a><span>|</span><a href="#40530506">prev</a><span>|</span><a href="#40525690">next</a><span>|</span><label class="collapse" for="c-40530939">[-]</label><label class="expand" for="c-40530939">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a fan of the &quot;Rule of Three&quot;, but another great rule is to not mindlessly follow rules.</div><br/></div></div></div></div><div id="40525690" class="c"><input type="checkbox" id="c-40525690" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#40528193">prev</a><span>|</span><a href="#40525596">next</a><span>|</span><label class="collapse" for="c-40525690">[-]</label><label class="expand" for="c-40525690">[35 more]</label></div><br/><div class="children"><div class="content">One of the #1 issues I’ve seen with DRY over the years seems to stem from a misunderstanding of what it means.<p>DRY is not just about <i>code</i> duplication, it’s about <i>information</i>&#x2F;<i>knowledge</i> duplication, and code happens to be one representation of information.<p>Hyper focusing on code duplication quickly gets into premature optimization territory, and can result in DRYing things that don’t make sense. Focusing on information duplication leaves some leeway for the code and helps identify which parts of the code actually need DRY.<p>The difference is important, and later editions of the Pragmatic Programmer call this out specifically. But the concept of DRY often gets a bit twisted in my experience.</div><br/><div id="40526549" class="c"><input type="checkbox" id="c-40526549" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40526681">next</a><span>|</span><label class="collapse" for="c-40526549">[-]</label><label class="expand" for="c-40526549">[17 more]</label></div><br/><div class="children"><div class="content">This is why some advice from Sandy Metz really stuck with me.<p>It is not a problem to &#x2F;have&#x2F; the same code 2, 3 or even 4 times in a code base. In fact, sometimes just straight up copy-paste driven development can be a valid development technique. Initially that statement horrified me, but by now I understand that just straight up copy-pasting some existing code can be one of these techniques that require some discipline to not overdo, but it&#x27;s legit.<p>And in quite a few cases, these same pieces of code just start developing in different directions and then they aren&#x27;t the same code anymore.<p>However, if you have to &#x2F;change&#x2F; the same code in the same way in multiple places, then you have a problem. If you have to fix the same bug in multiple places in similar or same ways, or have to introduce a feature in multiple places in similar way - then you have a problem.<p>Once that happens, you should try to extract the common thing into a central thing and fix that central thing once.<p>It feels weird to work like that at first, but I&#x27;ve found that often it results in simpler code and pretty effective abstractions, because it reacts to the actual change a code base experiences.</div><br/><div id="40526701" class="c"><input type="checkbox" id="c-40526701" checked=""/><div class="controls bullet"><span class="by">nostrademons</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526549">parent</a><span>|</span><a href="#40527285">next</a><span>|</span><label class="collapse" for="c-40526701">[-]</label><label class="expand" for="c-40526701">[13 more]</label></div><br/><div class="children"><div class="content">The challenge is that if you&#x27;re not careful, you can end up copy-pasting the same bit of code hundreds of time before realizing it has to be changed.<p>I once worked in a year-old startup of ~5 developers that found it had written the same line of code (not even copy-pasted, it was only one line of code so the devs had just written it out) 110 times.  A bug was then discovered in that line of code, and it had to be fixed in 110 places, with no guarantee that we&#x27;d even found all of them.  This was a very non-obvious instance of DRY, too, because it was only one line of code and the devs believed it was so simple that it couldn&#x27;t possibly be wrong.  But that&#x27;s why you sometimes need to be aware of what you&#x27;re writing even on the token level.<p>That&#x27;s why we have principles like &quot;3 strikes and then you refactor&quot;.  3 times fixing a bug isn&#x27;t too onerous; even 4-6 is pretty manageable.  Once you get to 20+, there starts to be a strong disincentive to fixing the bug, and even if you want to, you aren&#x27;t sure you got every instance.</div><br/><div id="40526999" class="c"><input type="checkbox" id="c-40526999" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526701">parent</a><span>|</span><a href="#40531814">next</a><span>|</span><label class="collapse" for="c-40526999">[-]</label><label class="expand" for="c-40526999">[7 more]</label></div><br/><div class="children"><div class="content">This really makes me think we should be focusing on cost&#x2F;benefit, risk&#x2F;reward, pros&#x2F;cons at all times. If we have a bug in these 5 copies, will it be too hard to fix in all of them? No? What about these 10 copies? If that sounds like its starting to get difficult, maybe now is the time.</div><br/><div id="40527742" class="c"><input type="checkbox" id="c-40527742" checked=""/><div class="controls bullet"><span class="by">laserlight</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526999">parent</a><span>|</span><a href="#40528720">next</a><span>|</span><label class="collapse" for="c-40527742">[-]</label><label class="expand" for="c-40527742">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If we have a bug in these 5 copies, will it be too hard to fix in all of them?<p>Yes, it will be, because copy-pasted code is never the same verbatim. First and foremost, name changes make it almost impossible to identify different copies. Then, there are different tweaks for each copy to make it suitable for the context. I always DRY early, because it&#x27;s always free to copy-paste later.</div><br/><div id="40530584" class="c"><input type="checkbox" id="c-40530584" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40527742">parent</a><span>|</span><a href="#40528720">next</a><span>|</span><label class="collapse" for="c-40530584">[-]</label><label class="expand" for="c-40530584">[1 more]</label></div><br/><div class="children"><div class="content">I could make the same argument for not using DRY. The DRY-ed code is hard to change, programmers feel honour-bound to keep using it and tweaking it by adding a variety of parameters to more and more cases, and at the end becomes impossible to understand or update, slowing down development.<p>Now, what probably should&#x27;ve been 3 abstractions is one incredibly convoluted &quot;abstraction&quot; that makes no sense, and its 3x harder than 3 individual abstractions to deduplicate and inline. It further pulls and invites complexity, as its current size is implicit invitation to include additional cases and places.<p>Furthermore, while without DRY fixing bugs may&#x27;ve been tedious, now with DRY it may be almost impossible due to high risk of breaking a lot of things that depend on that code. (You might be lucky enough to be able to and have written extensive tests with 100% edge case coverage for it - if that&#x27;s the case then you&#x27;ve postponed the moment of pain somewhat)<p>Both can be true. It depends on the context whether benefits exceed costs. Decisions should be made based on a specific context and with thinking applied, not generic rules.</div><br/></div></div></div></div><div id="40530221" class="c"><input type="checkbox" id="c-40530221" checked=""/><div class="controls bullet"><span class="by">kitkat_new</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526999">parent</a><span>|</span><a href="#40528720">prev</a><span>|</span><a href="#40527168">next</a><span>|</span><label class="collapse" for="c-40530221">[-]</label><label class="expand" for="c-40530221">[2 more]</label></div><br/><div class="children"><div class="content">5 copies are already extremely difficult.<p>It&#x27;s not like they just jump into your eye when you edit some code.</div><br/><div id="40530602" class="c"><input type="checkbox" id="c-40530602" checked=""/><div class="controls bullet"><span class="by">spion</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40530221">parent</a><span>|</span><a href="#40527168">next</a><span>|</span><label class="collapse" for="c-40530602">[-]</label><label class="expand" for="c-40530602">[1 more]</label></div><br/><div class="children"><div class="content">It depends on the context. In some context, they might actually jump out. In some context, even if they don&#x27;t, it might be fine, because the larger modules containing the code already have excellent tests and are solid and stable</div><br/></div></div></div></div><div id="40527168" class="c"><input type="checkbox" id="c-40527168" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526999">parent</a><span>|</span><a href="#40530221">prev</a><span>|</span><a href="#40531814">next</a><span>|</span><label class="collapse" for="c-40527168">[-]</label><label class="expand" for="c-40527168">[1 more]</label></div><br/><div class="children"><div class="content">That means you have to think. Most people hate thinking. Seriously.</div><br/></div></div></div></div><div id="40531814" class="c"><input type="checkbox" id="c-40531814" checked=""/><div class="controls bullet"><span class="by">bigger_cheese</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526701">parent</a><span>|</span><a href="#40526999">prev</a><span>|</span><a href="#40527390">next</a><span>|</span><label class="collapse" for="c-40531814">[-]</label><label class="expand" for="c-40531814">[1 more]</label></div><br/><div class="children"><div class="content">This happens with SQL a lot where people copy and paste queries all over the place. Especially for reports, there&#x27;s always the case where some quick and dirty report was thrown together in 20 mins ends up as something managers can&#x27;t live without.<p>Making changes quickly get onerous when the query (or slight variation on it) is pasted into multiple places. Nowadays my org has started to use Power BI so there is also multiple dashboards that all need to be updated.</div><br/></div></div><div id="40527390" class="c"><input type="checkbox" id="c-40527390" checked=""/><div class="controls bullet"><span class="by">sodapopcan</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526701">parent</a><span>|</span><a href="#40531814">prev</a><span>|</span><a href="#40526998">next</a><span>|</span><label class="collapse" for="c-40527390">[-]</label><label class="expand" for="c-40527390">[1 more]</label></div><br/><div class="children"><div class="content">Metz says she adds TODOs and comments that it has been duped.  It&#x27;s one of those things that requires thought, and she even says it&#x27;s an advanced technique.  How many times is too many?  I&#x27;m not sure, but I can safely say over 100 is WAY too many.  Probably 10 is too many.  Heck, if you find yourself updating the same code in four different places over and over and over, it&#x27;s time to abstract.  The idea is to let the code sit and let the abstraction reveal itself <i>if there isn&#x27;t already an OBVIOUS one</i>.  As mentioned by the parent poster, you&#x27;re looking out for these copies to diverge.  If four or five copied codepaths haven&#x27;t diverged after some time, there&#x27;s a good chance that just from working on it every day you will have realized the proper way to abstract it.<p>You absolutely do have to be careful.  But even so, it&#x27;s arguable that having to update something in 100 different places is better than updating in one place and having it affect 100 different paths where you only want 99 of them (this is some hyperbole, of course).</div><br/></div></div><div id="40526998" class="c"><input type="checkbox" id="c-40526998" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526701">parent</a><span>|</span><a href="#40527390">prev</a><span>|</span><a href="#40527109">next</a><span>|</span><label class="collapse" for="c-40526998">[-]</label><label class="expand" for="c-40526998">[1 more]</label></div><br/><div class="children"><div class="content">Oh yeah we&#x27;ve had those as well. I kinda feel two things about these at the same time.<p>At a practical level, these situations sucked. Someone had to search for the common expression, look at each instance, decide to change it to the central place or not. They spent 2-3 days on that. And then you realize that some people were smart and employed DRY - if they needed that one expression 2-3 times, they&#x27;d extracted one sub-expression into a variable and suddenly there was no pattern to find those anymore. Those were 2-4 fun weeks for the whole team.<p>But at the same time, I think people learned an important concept there: To see if you are writing the same code, or if you&#x27;re referring to the same concept and need the same source of truth, like the GP comment says. I&#x27;m pretty happy with that development. Which is also why my described way is just one tool in the toolbox.<p>Like, one of our code bases is an orchestration system and it defines the name of oidc-clients used in the infrastructure. These need to be the same across the endpoints for the authentication provider, as well as the endpoints consumed by the clients of the oidc provider - the oauth flows won&#x27;t work otherwise.<p>And suddenly it clicked for a bunch of the dudes on the team why we should put the pedestrian act of jamming some strings together to get that client-id into some function. That way, we can refer to the concept or naming pattern and ensure the client will be identical across all necessary endpoints, over hoping that a million different string joins all over the place result in the same string.<p>In such a case, early or eager DRY is the correct choice, because this needs to be defined once and exactly once.</div><br/></div></div><div id="40527109" class="c"><input type="checkbox" id="c-40527109" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526701">parent</a><span>|</span><a href="#40526998">prev</a><span>|</span><a href="#40527285">next</a><span>|</span><label class="collapse" for="c-40527109">[-]</label><label class="expand" for="c-40527109">[2 more]</label></div><br/><div class="children"><div class="content">This is why you shouldn&#x27;t write one line of code, ever again. &#x2F;s<p>We&#x27;ve all been there though, at some point in our careers. Possibly multiples of times (try changing thousands of &quot;echo&quot; statements to call a logger because it was initially meant to be a simple script that just kept growing).<p>It sucks but I&#x27;ve also been on the other side, where it was DRY but 20% of the calls to the function now needed different behavior. Finding all of those usages was just as hard.</div><br/><div id="40530488" class="c"><input type="checkbox" id="c-40530488" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40527109">parent</a><span>|</span><a href="#40527285">next</a><span>|</span><label class="collapse" for="c-40530488">[-]</label><label class="expand" for="c-40530488">[1 more]</label></div><br/><div class="children"><div class="content">&gt; We&#x27;ve all been there though, at some point in our careers. Possibly multiples of times (try changing thousands of &quot;echo&quot; statements to call a logger because it was initially meant to be a simple script that just kept growing).<p>Been there - now unless it is a very simple &#x2F; throwaway code, I always start with logging setup from the start. It also helps with print based debugging because you can tune the output.</div><br/></div></div></div></div></div></div><div id="40527285" class="c"><input type="checkbox" id="c-40527285" checked=""/><div class="controls bullet"><span class="by">wging</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526549">parent</a><span>|</span><a href="#40526701">prev</a><span>|</span><a href="#40527842">next</a><span>|</span><label class="collapse" for="c-40527285">[-]</label><label class="expand" for="c-40527285">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re thinking of Sandi Metz: <a href="https:&#x2F;&#x2F;sandimetz.com&#x2F;blog&#x2F;2016&#x2F;1&#x2F;20&#x2F;the-wrong-abstraction" rel="nofollow">https:&#x2F;&#x2F;sandimetz.com&#x2F;blog&#x2F;2016&#x2F;1&#x2F;20&#x2F;the-wrong-abstraction</a></div><br/></div></div><div id="40527028" class="c"><input type="checkbox" id="c-40527028" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526549">parent</a><span>|</span><a href="#40527842">prev</a><span>|</span><a href="#40526681">next</a><span>|</span><label class="collapse" for="c-40527028">[-]</label><label class="expand" for="c-40527028">[1 more]</label></div><br/><div class="children"><div class="content">Conversely, trying too hard to DRY when requirements at call sites start to diverge can lead to an unnecessary complex single implementation of something where there could be two very similar but still straightforward pieces of code.</div><br/></div></div></div></div><div id="40526681" class="c"><input type="checkbox" id="c-40526681" checked=""/><div class="controls bullet"><span class="by">bojanz</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40526549">prev</a><span>|</span><a href="#40527839">next</a><span>|</span><label class="collapse" for="c-40526681">[-]</label><label class="expand" for="c-40526681">[1 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t agree more. There&#x27;s a great decade-old blog post by Mathias Verraes which illustrates this well, I keep coming back to it: <a href="https:&#x2F;&#x2F;verraes.net&#x2F;2014&#x2F;08&#x2F;dry-is-about-knowledge&#x2F;" rel="nofollow">https:&#x2F;&#x2F;verraes.net&#x2F;2014&#x2F;08&#x2F;dry-is-about-knowledge&#x2F;</a></div><br/></div></div><div id="40527839" class="c"><input type="checkbox" id="c-40527839" checked=""/><div class="controls bullet"><span class="by">BeetleB</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40526681">prev</a><span>|</span><a href="#40526504">next</a><span>|</span><label class="collapse" for="c-40527839">[-]</label><label class="expand" for="c-40527839">[3 more]</label></div><br/><div class="children"><div class="content">Indeed - the acronym comes from <i>The Pragmatic Programmer</i>, and the author defined it in this way. Every blog post I&#x27;ve read criticizing&#x2F;cautioning against DRY were not doing DRY as originally defined.<p>DRY is almost always a good thing to do. Coupling superficially similar code is definitely not a good thing to do.</div><br/><div id="40528830" class="c"><input type="checkbox" id="c-40528830" checked=""/><div class="controls bullet"><span class="by">dllthomas</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40527839">parent</a><span>|</span><a href="#40528053">next</a><span>|</span><label class="collapse" for="c-40528830">[-]</label><label class="expand" for="c-40528830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Coupling superficially similar code is definitely not a good thing to do.<p>I&#x27;ve taken to calling that activity (removing syntactic redundancy that is only coincidental) &quot;Huffman coding&quot;.</div><br/></div></div><div id="40528053" class="c"><input type="checkbox" id="c-40528053" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40527839">parent</a><span>|</span><a href="#40528830">prev</a><span>|</span><a href="#40526504">next</a><span>|</span><label class="collapse" for="c-40528053">[-]</label><label class="expand" for="c-40528053">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, here&#x27;s the quote from the later editions addressing this:<p>&gt; <i>Let’s get something out of the way up-front. In the first edition of this book we did a poor job of explaining just what we meant by Don’t Repeat Yourself. Many people took it to refer to code only: they thought that DRY means “don’t copy-and-paste lines of source.”
That is part of DRY, but it’s a tiny and fairly trivial part.</i><p>&gt; <i>DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally different ways.</i><p>&gt; <i>Here’s the acid test: when some single facet of the code has to change, do you find yourself making that change in multiple places, and in multiple different formats? Do you have to change code and documentation, or a database schema and a structure that holds it, or...? If so, your code isn’t DRY.</i></div><br/></div></div></div></div><div id="40526504" class="c"><input type="checkbox" id="c-40526504" checked=""/><div class="controls bullet"><span class="by">schneems</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40527839">prev</a><span>|</span><a href="#40526187">next</a><span>|</span><label class="collapse" for="c-40526504">[-]</label><label class="expand" for="c-40526504">[1 more]</label></div><br/><div class="children"><div class="content">Someone “yes and”-ed a comment of mine awhile ago to teach me DRY SPOT. Don’t repeat yourself - Single Point of Truth.<p>I.e. what you said. Couple logic that needs to be coupled. Decouple logic that shouldn’t be coupled.</div><br/></div></div><div id="40526187" class="c"><input type="checkbox" id="c-40526187" checked=""/><div class="controls bullet"><span class="by">HanClinto</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40526504">prev</a><span>|</span><a href="#40527458">next</a><span>|</span><label class="collapse" for="c-40526187">[-]</label><label class="expand" for="c-40526187">[5 more]</label></div><br/><div class="children"><div class="content">I feel like I hear de-duplication of information &#x2F; knowledge often referred to as &quot;Single Source of Truth&quot;</div><br/><div id="40526355" class="c"><input type="checkbox" id="c-40526355" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526187">parent</a><span>|</span><a href="#40529389">next</a><span>|</span><label class="collapse" for="c-40526355">[-]</label><label class="expand" for="c-40526355">[2 more]</label></div><br/><div class="children"><div class="content">I think the best way to understand DRY is by thinking about the practical problem it solves: you don&#x27;t want footguns in the codebase where you could change something in one place, but forget to change the same thing in other places (or forget to change the complementary logic&#x2F;data in other components.)<p>The goal of DRY as a refactoring, is first-and-foremost to obviate such developer errors.<p>And therefore — if you want to be conservative about applying this &quot;best practice&quot; — then you could do that by just never thinking &quot;DRY&quot; until a developer <i>does in fact</i> trip over some particular duplication in your codebase and causes a problem.</div><br/><div id="40528278" class="c"><input type="checkbox" id="c-40528278" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526355">parent</a><span>|</span><a href="#40529389">next</a><span>|</span><label class="collapse" for="c-40528278">[-]</label><label class="expand" for="c-40528278">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you don&#x27;t want footguns in the codebase where you could change something in one place, but forget to change the same thing in other places<p>This. Ironically the example on TFA is vulnerable to this issue. Each of the deadline setting methods has a copy of the validation ensuring that the date is in the future. If it&#x27;s discovered that we need to ensure deadlines are set no later than the project deadline (since that wouldn&#x27;t generally make sense), it&#x27;s awfully easy to only update one and miss the others, especially after code has been added and these implementations are no longer visually near each other. I&#x27;m not saying that this means the code must be DRY&#x27;ed, but it is a risk from the beginning of the project, so one that needs to be weighed during initial implementation.</div><br/></div></div></div></div><div id="40529389" class="c"><input type="checkbox" id="c-40529389" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40526187">parent</a><span>|</span><a href="#40526355">prev</a><span>|</span><a href="#40527458">next</a><span>|</span><label class="collapse" for="c-40529389">[-]</label><label class="expand" for="c-40529389">[2 more]</label></div><br/><div class="children"><div class="content">The Two Generals Problem is mentioned a lot in databases and networking, and you can take some liberties to extend it to human orgs.</div><br/><div id="40531560" class="c"><input type="checkbox" id="c-40531560" checked=""/><div class="controls bullet"><span class="by">sham1</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40529389">parent</a><span>|</span><a href="#40527458">next</a><span>|</span><label class="collapse" for="c-40531560">[-]</label><label class="expand" for="c-40531560">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The Two Generals Problem is mentioned a lot in databases and networking, and you can take some liberties to extend it to human orgs.<p>In fact, the name probably already gives some hint as to what sorts of human orgs this sort of principle would be applicable in.<p>And, well, the vast majority of orgs require some sort of coordination.</div><br/></div></div></div></div></div></div><div id="40527458" class="c"><input type="checkbox" id="c-40527458" checked=""/><div class="controls bullet"><span class="by">pineapple_sauce</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40526187">prev</a><span>|</span><a href="#40526545">next</a><span>|</span><label class="collapse" for="c-40527458">[-]</label><label class="expand" for="c-40527458">[3 more]</label></div><br/><div class="children"><div class="content">How is applying DRY entering premature optimization territory (maybe relative to LOC?)? I argue it is instead: premature abstraction.<p>Optimization is specialization (which is the opposite of DRY): to enable DRY you likely need to generalize the problem (i.e. abstract) such that you remove duplication.</div><br/><div id="40527681" class="c"><input type="checkbox" id="c-40527681" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40527458">parent</a><span>|</span><a href="#40526545">next</a><span>|</span><label class="collapse" for="c-40527681">[-]</label><label class="expand" for="c-40527681">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always seen &quot;Premature Optimization&quot; as an umbrella that covers a variety of cross-cutting concerns, ranging from:<p>- Performance 
- Code structure &#x2F; abstraction 
- Data structure 
- Team organization &#x2F; org structure<p>I&#x27;d argue that DRY (and a focus on abstractions more generally) are optimizations of the codebase. Not all optimizations are optimizing the same thing.</div><br/><div id="40529468" class="c"><input type="checkbox" id="c-40529468" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40527681">parent</a><span>|</span><a href="#40526545">next</a><span>|</span><label class="collapse" for="c-40529468">[-]</label><label class="expand" for="c-40529468">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, it&#x27;s like reminding people that code can change, so it&#x27;s ok to have known flaws day 1. Something forgotten too often.<p>One thing that really goes against the usual programming grain is DBMSes. We&#x27;re taught to always decouple&#x2F;abstract things, but I&#x27;m convinced that it&#x27;s impossible to abstract away your DBMS in most applications. It&#x27;s just too big of an interface, and performance considerations leak right through it. It&#x27;s always one of the selling points of an ORM, &quot;you can switch databases later,&quot; and then nobody actually switches.</div><br/></div></div></div></div></div></div><div id="40526545" class="c"><input type="checkbox" id="c-40526545" checked=""/><div class="controls bullet"><span class="by">joe_fishfish</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40527458">prev</a><span>|</span><a href="#40529374">next</a><span>|</span><label class="collapse" for="c-40526545">[-]</label><label class="expand" for="c-40526545">[1 more]</label></div><br/><div class="children"><div class="content">This is a more insightful comment than the comment at the top, and also more useful than the blog post.</div><br/></div></div><div id="40529374" class="c"><input type="checkbox" id="c-40529374" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40526545">prev</a><span>|</span><a href="#40528233">next</a><span>|</span><label class="collapse" for="c-40529374">[-]</label><label class="expand" for="c-40529374">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, applies to databases and documentation especially. Databases have the ol&#x27; 3NF, you also want to avoid copying data from one source of truth to another in a multi-service environment, and sometimes I intentionally avoid writing docs because I want the code or API spec (with its comments) to be the only documentation.</div><br/></div></div><div id="40528233" class="c"><input type="checkbox" id="c-40528233" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#40525690">parent</a><span>|</span><a href="#40529374">prev</a><span>|</span><a href="#40525596">next</a><span>|</span><label class="collapse" for="c-40528233">[-]</label><label class="expand" for="c-40528233">[2 more]</label></div><br/><div class="children"><div class="content">&gt; misunderstanding of what it means<p>And in response, people will complain that they&#x27;re being dismissed with &quot;you&#x27;re doing it wrong!&quot; Because that happens with everything in programmer-land.</div><br/><div id="40528788" class="c"><input type="checkbox" id="c-40528788" checked=""/><div class="controls bullet"><span class="by">haswell</span><span>|</span><a href="#40525690">root</a><span>|</span><a href="#40528233">parent</a><span>|</span><a href="#40525596">next</a><span>|</span><label class="collapse" for="c-40528788">[-]</label><label class="expand" for="c-40528788">[1 more]</label></div><br/><div class="children"><div class="content">The easy response to someone feeling this way is to point them to the origin of DRY: <i>The Pragmatic Programmer</i>.<p>In the book, the authors explicitly call out that many people took the wrong idea from the original writing. They clarify that DRY is not about code, it&#x27;s about what they call &quot;knowledge&quot;, and that code is just one expression of it.<p>People can still disagree, but the original intent behind DRY is very well articulated.</div><br/></div></div></div></div></div></div><div id="40525596" class="c"><input type="checkbox" id="c-40525596" checked=""/><div class="controls bullet"><span class="by">hardwaregeek</span><span>|</span><a href="#40525690">prev</a><span>|</span><a href="#40529028">next</a><span>|</span><label class="collapse" for="c-40525596">[-]</label><label class="expand" for="c-40525596">[59 more]</label></div><br/><div class="children"><div class="content">It&#x27;s important to remember that all best practices are not created equal. I&#x27;d prioritize readability over DRY. I&#x27;d prioritize cohesion over extensibility. When people talk about best practices, they don&#x27;t talk about how a lot of them are incompatible, or at least at odds with each other. Writing code is about choosing the best practices you want to prioritize as much as it&#x27;s about avoiding bad practices.</div><br/><div id="40526965" class="c"><input type="checkbox" id="c-40526965" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526559">next</a><span>|</span><label class="collapse" for="c-40526965">[-]</label><label class="expand" for="c-40526965">[10 more]</label></div><br/><div class="children"><div class="content">Readability is almost always (almost only because there are some rare exceptions) the most important thing to me, even for low-level systems software. I always ask myself, “If I don’t touch this code for a year and then come back to it, how long will it take me to understand it again? How long will it take someone who’s never been exposed to this code to understand it?”<p>Luckily, our compilers and interpreters have gotten so good and advanced that, in 95%+ of cases, we need not make premature “optimizations” (or introduce hierarchies of “design patterns”) that sacrifice readability for speed or code size.</div><br/><div id="40527233" class="c"><input type="checkbox" id="c-40527233" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526965">parent</a><span>|</span><a href="#40527988">next</a><span>|</span><label class="collapse" for="c-40527233">[-]</label><label class="expand" for="c-40527233">[6 more]</label></div><br/><div class="children"><div class="content">Was reading 1978 Elements of Programming Style a while ago. It&#x27;s mostly Fortran and PL&#x2F;I. Some of it is outdated, but a lot applies today as well. See e.g. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Elements_of_Programming_Style#Lessons" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;The_Elements_of_Programming_St...</a><p>They actually have a Fortran example of &quot;optimized&quot; code that&#x27;s quite difficult to follow, but allegedly faster according to the comments. But they rewrote it to be more readable and ... turns out that&#x27;s actually faster!<p>So this already applied even on 197something hardware. Also reminds me about this quote about early development of Unix and C:<p><i>&quot;Dennis Ritchie encouraged modularity by telling all and sundry that function calls were really, really cheap in C. Everybody started writing small functions and modularizing. Years later we found out that function calls were still expensive on the PDP-11, and VAX code was often spending 50% of its time in the CALLS instruction. Dennis had lied to us! But it was too late; we were all hooked...&quot;</i><p>And Knuth&#x27;s &quot;premature optimisation is the root of all evil&quot; quote is also decades old by now.<p>Kind of interesting we&#x27;ve been fighting this battle for over 50 years now :-&#x2F;<p>(It should go without saying there are exceptions, and cases where you <i>do</i> need to optimize the shit out of things, after having proven that performance may be an issue. Also at scale &quot;5% faster&quot; can mean &quot;need 5% less servers&quot;, which can translate to millions&#x2F;dollars saved per year – &quot;programmers are more expensive than computers&quot; is another maxim that doesn&#x27;t always hold true).</div><br/><div id="40527441" class="c"><input type="checkbox" id="c-40527441" checked=""/><div class="controls bullet"><span class="by">semi-extrinsic</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527233">parent</a><span>|</span><a href="#40527988">next</a><span>|</span><label class="collapse" for="c-40527441">[-]</label><label class="expand" for="c-40527441">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Dennis Ritchie encouraged modularity by telling all and sundry that function calls were really, really cheap in C.<p>The old salty professor who taught numerical physics at my uni insisted that function calls were slow and that it was better to write everything in main. He gave all his examples in Fortran 77. This was in the 2010s...</div><br/><div id="40528965" class="c"><input type="checkbox" id="c-40528965" checked=""/><div class="controls bullet"><span class="by">coliveira</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527441">parent</a><span>|</span><a href="#40527988">next</a><span>|</span><label class="collapse" for="c-40528965">[-]</label><label class="expand" for="c-40528965">[4 more]</label></div><br/><div class="children"><div class="content">In fact he is right. The advantage of writing modular code, however, is that we can test the locations where performance is needed and optimize later. With a big main it becomes very hard to do anything complex.</div><br/><div id="40529253" class="c"><input type="checkbox" id="c-40529253" checked=""/><div class="controls bullet"><span class="by">Archelaos</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40528965">parent</a><span>|</span><a href="#40531212">next</a><span>|</span><label class="collapse" for="c-40529253">[-]</label><label class="expand" for="c-40529253">[1 more]</label></div><br/><div class="children"><div class="content">This is why I liked it when the language I was coding in supported inline expansion: I could keep my code modular but nevertheless avoid the penality of function calls in performance critical functions in the compiled code.</div><br/></div></div><div id="40531212" class="c"><input type="checkbox" id="c-40531212" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40528965">parent</a><span>|</span><a href="#40529253">prev</a><span>|</span><a href="#40529956">next</a><span>|</span><label class="collapse" for="c-40531212">[-]</label><label class="expand" for="c-40531212">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In fact he is right.<p>Was he, though? I mean, yeah having to push and pop a call stack does indeed require more work than not having to do that. However, compilers can and do inline and optimize out function calls.<p>And what&#x27;s the real performance impact of calling functions a constant number of times outside of the hot path? Is an untestable spaghetti salad of things better than a few hypothetical push and pops?<p>There&#x27;s wisdom behind Knuth&#x27;s remarks on premature optimization.</div><br/></div></div></div></div></div></div></div></div><div id="40527988" class="c"><input type="checkbox" id="c-40527988" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526965">parent</a><span>|</span><a href="#40527233">prev</a><span>|</span><a href="#40526559">next</a><span>|</span><label class="collapse" for="c-40527988">[-]</label><label class="expand" for="c-40527988">[3 more]</label></div><br/><div class="children"><div class="content">The one gotcha with optimizing for “readability” is that at least to some extent it’s a metric that is in the eye of the beholder. Over the years I’ve seen far too many wars over readability during code review when really people were arguing about what seemed readable *to them*</div><br/><div id="40529149" class="c"><input type="checkbox" id="c-40529149" checked=""/><div class="controls bullet"><span class="by">smrq</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527988">parent</a><span>|</span><a href="#40526559">next</a><span>|</span><label class="collapse" for="c-40529149">[-]</label><label class="expand" for="c-40529149">[2 more]</label></div><br/><div class="children"><div class="content">This is the reason I refuse to use the word &quot;clean&quot; to describe code anymore. It&#x27;s completely subjective, and far too many times I&#x27;ve seen two people claim that their preferred way of doing things is better because it&#x27;s &quot;clean&quot;, and the other&#x27;s way is worse because it&#x27;s &quot;less clean&quot;, no further justification added. It&#x27;s absolutely pointless.</div><br/><div id="40530038" class="c"><input type="checkbox" id="c-40530038" checked=""/><div class="controls bullet"><span class="by">jghn</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40529149">parent</a><span>|</span><a href="#40526559">next</a><span>|</span><label class="collapse" for="c-40530038">[-]</label><label class="expand" for="c-40530038">[1 more]</label></div><br/><div class="children"><div class="content">There are a lot of topics in software development where everyone can agree that X is correct. However, *defining* X gets into subjective arguments. And yep, readability and clean code are both in that category.</div><br/></div></div></div></div></div></div></div></div><div id="40526559" class="c"><input type="checkbox" id="c-40526559" checked=""/><div class="controls bullet"><span class="by">delichon</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526965">prev</a><span>|</span><a href="#40527874">next</a><span>|</span><label class="collapse" for="c-40526559">[-]</label><label class="expand" for="c-40526559">[15 more]</label></div><br/><div class="children"><div class="content">&quot;Read&quot; isn&#x27;t quite the right word for code. &quot;Decode&quot; is better. We have to read to decode, but decoding is far less linear than reading narrative text. Being DRY usually makes decoding easier, not harder, because it makes the logic more cohesive. If I know you only fromajulate blivers in one place I don&#x27;t have to decode elsewhere.</div><br/><div id="40526845" class="c"><input type="checkbox" id="c-40526845" checked=""/><div class="controls bullet"><span class="by">wwfn</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526559">parent</a><span>|</span><a href="#40527916">next</a><span>|</span><label class="collapse" for="c-40526845">[-]</label><label class="expand" for="c-40526845">[2 more]</label></div><br/><div class="children"><div class="content">I was just mulling this over today. DRY = easier-to-decode is probably true if you&#x27;re working on groking the system at large. If you just want to peak in at something specific quickly, DRY code can be painful.<p>I wanted to see what compile flags were used by guix when compiling emacs. `guix edit emacs-next` brings up a file with nested definitions on top of the base package. I had to trust my working memory to unnest the definitions and track which compile flags are being added or removed. <a href="https:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;cgit&#x2F;guix.git&#x2F;tree&#x2F;gnu&#x2F;packages&#x2F;emacs.scm#n577" rel="nofollow">https:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;cgit&#x2F;guix.git&#x2F;tree&#x2F;gnu&#x2F;packages...</a><p>It&#x27;d be more error prone to have each package using redundant base information, but I would have decoded what I was after a lot faster.<p>Separately, there was a bug in some software aggregating cifti file values into tab separated values. But because any cifti-&gt;tsv conversion was generalized, it was too opaque for me to identify and patch myself as a drive-by contributor. <a href="https:&#x2F;&#x2F;github.com&#x2F;PennLINC&#x2F;xcp_d&#x2F;issues&#x2F;1170">https:&#x2F;&#x2F;github.com&#x2F;PennLINC&#x2F;xcp_d&#x2F;issues&#x2F;1170</a> to <a href="https:&#x2F;&#x2F;github.com&#x2F;PennLINC&#x2F;xcp_d&#x2F;pull&#x2F;1175&#x2F;files#diff-76920bc632df09fee7a19d4e85d1daf3f0409419f016a94a40e2684b16b005a6">https:&#x2F;&#x2F;github.com&#x2F;PennLINC&#x2F;xcp_d&#x2F;pull&#x2F;1175&#x2F;files#diff-76920...</a></div><br/><div id="40527180" class="c"><input type="checkbox" id="c-40527180" checked=""/><div class="controls bullet"><span class="by">emidln</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526845">parent</a><span>|</span><a href="#40527916">next</a><span>|</span><label class="collapse" for="c-40527180">[-]</label><label class="expand" for="c-40527180">[1 more]</label></div><br/><div class="children"><div class="content">Bazel solves this exact problem (coming from its macrosystem) by allowing you to ask for what I term the &quot;macroexpanded&quot; BUILD definition using `bazel query --output=build &#x2F;&#x2F;some&#x2F;pkg&#x2F;or:target`.
 When bazel does this, it also comments the file, macro,and line number the expanded content came from for each block.<p>This gives us reuse without obscuring the real definition.<p>I automated this in my emacs to be able to &quot;macroexpand&quot;  the current buid file in a new buffer. It saves me a lot of time.</div><br/></div></div></div></div><div id="40527916" class="c"><input type="checkbox" id="c-40527916" checked=""/><div class="controls bullet"><span class="by">Nevolihs</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526559">parent</a><span>|</span><a href="#40526845">prev</a><span>|</span><a href="#40526975">next</a><span>|</span><label class="collapse" for="c-40527916">[-]</label><label class="expand" for="c-40527916">[2 more]</label></div><br/><div class="children"><div class="content">Does it? Every time I see DRY&#x27;d code, it usually makes the project it&#x27;s in more difficult to understand. It&#x27;s harder to understand where values come from, where values are changed, what parts of the codebase affect what. And that&#x27;s before trying to figure out where to change something in the right place, because it&#x27;s often unclear what other parts of the code are coupled to it through all the abstractions.<p>At a high level, at first glance, the code might look good and it &quot;makes sense&quot;. But once you want to understand what&#x27;s happening and why, you&#x27;re jumping through five different classes, two dozen methods and you still don&#x27;t know for sure until you run a test request against the API and see what shows up where in the debugger. And you realize your initial glimpse of understanding was just window dressing and actually nothing makes sense unless you understand every level of the abstractions being used.<p>It&#x27;s suddenly a puzzle to understand another software developer instead of software engineering.</div><br/><div id="40529803" class="c"><input type="checkbox" id="c-40529803" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527916">parent</a><span>|</span><a href="#40526975">next</a><span>|</span><label class="collapse" for="c-40529803">[-]</label><label class="expand" for="c-40529803">[1 more]</label></div><br/><div class="children"><div class="content">An IDE can help a lot. Coming from Perl, everything you said was true. I wanted everything in one file as much as possible, and breaking tasks off into functions just meant I had to jump around to try and rebuild the flow in my head. I spent so much time inside the debugger since reading the code would only go so far.<p>Now I work in C#, we have a lot of classes with a few functions, a lot of helper functions. Doesn&#x27;t matter since it&#x27;s so easy to use the tooling to build a mental picture - let alone refactor it in an instant if that variable name feels a bit off, or we think a function is not used (such things were always a risky exercise in Perl).<p>We refactored one insurance based project to use generic base classes extensively since all insurance shares some attributes and features - this really helped cut down complexity of changes and overall just reduced code on the screen to sift through. I had a lot of fun doing this, I&#x27;m a weirdo who almost likes deleting code more than writing it. Once you hit the lowest level it is a little less intuitive due to being generic but at the higher levels we mostly work at, it&#x27;s simpler, and rolling out a new product we get a lot of stuff for free. They got a long way copy-pasting the product logic (4 or 5 product lines) but at this point it made sense to revisit, and I sneak a bit more in each time I have a change to do.</div><br/></div></div></div></div><div id="40526975" class="c"><input type="checkbox" id="c-40526975" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526559">parent</a><span>|</span><a href="#40527916">prev</a><span>|</span><a href="#40526693">next</a><span>|</span><label class="collapse" for="c-40526975">[-]</label><label class="expand" for="c-40526975">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Being DRY usually makes decoding easier, not harder<p>&quot;Usually&quot; being the keyword and what the article is all about IMHO. I work in a codebase so DRY that it takes digging through dozens of files to figure out what one constant string will be composed as. It would have been simpler to simply write it out, ain&#x27;t nobody going to figure out OCM_CON_PACK + OCM_WK_MAN means at a glance.</div><br/><div id="40528139" class="c"><input type="checkbox" id="c-40528139" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526975">parent</a><span>|</span><a href="#40527133">next</a><span>|</span><label class="collapse" for="c-40528139">[-]</label><label class="expand" for="c-40528139">[1 more]</label></div><br/><div class="children"><div class="content">Function calls, the essence of DRY, are only readable if it is well known and well understood what it does.<p>When code is serial, with comment blocks to point out different sections, it is much easier to read, follow, and debug.<p>This is also a little bit of a tooling problem</div><br/></div></div><div id="40527133" class="c"><input type="checkbox" id="c-40527133" checked=""/><div class="controls bullet"><span class="by">djeastm</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526975">parent</a><span>|</span><a href="#40528139">prev</a><span>|</span><a href="#40526693">next</a><span>|</span><label class="collapse" for="c-40527133">[-]</label><label class="expand" for="c-40527133">[3 more]</label></div><br/><div class="children"><div class="content">&gt;I work in a codebase so DRY that it takes digging through dozens of files to figure out what one constant string will be composed as.<p>I don&#x27;t know the codebase, but to my mind that level of abstraction means it&#x27;s a system-critical string that justifies the work it takes to find.</div><br/><div id="40527631" class="c"><input type="checkbox" id="c-40527631" checked=""/><div class="controls bullet"><span class="by">RussianCow</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527133">parent</a><span>|</span><a href="#40528076">next</a><span>|</span><label class="collapse" for="c-40527631">[-]</label><label class="expand" for="c-40527631">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, but this doesn&#x27;t make sense. Why should system critical things be more difficult to understand? Surely you want to <i>reduce</i> room for error, not increase it?</div><br/></div></div><div id="40528076" class="c"><input type="checkbox" id="c-40528076" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527133">parent</a><span>|</span><a href="#40527631">prev</a><span>|</span><a href="#40526693">next</a><span>|</span><label class="collapse" for="c-40528076">[-]</label><label class="expand" for="c-40528076">[1 more]</label></div><br/><div class="children"><div class="content">I mean, sure, I guess API urls could be system-critical. But generally, I prefer to grep a codebase for a url pattern and find the controller immediately. Instead, you have to dig through layers of strings composed of other strings and figure it out. Then at the end, you’re probably wrong.</div><br/></div></div></div></div></div></div><div id="40526693" class="c"><input type="checkbox" id="c-40526693" checked=""/><div class="controls bullet"><span class="by">hathawsh</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526559">parent</a><span>|</span><a href="#40526975">prev</a><span>|</span><a href="#40528931">next</a><span>|</span><label class="collapse" for="c-40526693">[-]</label><label class="expand" for="c-40526693">[1 more]</label></div><br/><div class="children"><div class="content">Well, &quot;read&quot; is still the verb we use most often to describe a human interpreting code. Also, many information-dense books are not intended to be read linearly, yet we still say we&#x27;re &quot;reading&quot; (or &quot;studying&quot;) the book.</div><br/></div></div><div id="40528931" class="c"><input type="checkbox" id="c-40528931" checked=""/><div class="controls bullet"><span class="by">cloverich</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526559">parent</a><span>|</span><a href="#40526693">prev</a><span>|</span><a href="#40527716">next</a><span>|</span><label class="collapse" for="c-40528931">[-]</label><label class="expand" for="c-40528931">[3 more]</label></div><br/><div class="children"><div class="content">One area I find DRY particularly annoying is when people overly abstract Typescript types. Instead of a plain interface with a few properties, you end up with a bunch of mushed together props like { thing: boolean } &amp; Pick&lt;MyOtherObj, &#x27;bar&#x27; | &#x27;baz&#x27;} &amp; Omit&lt;BaseObj, &#x27;stuff&#x27;&gt; instead of a few duplicated but easily readable interfaces:<p>interface MyProps {
  thing: boolean;
  bar: string;
  baz: string;
  stuff: string;
}</div><br/><div id="40529455" class="c"><input type="checkbox" id="c-40529455" checked=""/><div class="controls bullet"><span class="by">jddj</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40528931">parent</a><span>|</span><a href="#40527716">next</a><span>|</span><label class="collapse" for="c-40529455">[-]</label><label class="expand" for="c-40529455">[2 more]</label></div><br/><div class="children"><div class="content">Am I crazy for almost exclusively just using <i>type</i> and sum types and no generics or interfaces and somehow being able to express everything I need to express?<p>Kind of wondering what I&#x27;m missing now.</div><br/><div id="40529586" class="c"><input type="checkbox" id="c-40529586" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40529455">parent</a><span>|</span><a href="#40527716">next</a><span>|</span><label class="collapse" for="c-40529586">[-]</label><label class="expand" for="c-40529586">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, you can do pretty nice things with generics to make some things impossible (or at least fail on compile), but I agree it’s hardly readable. In some cases you need that though.</div><br/></div></div></div></div></div></div><div id="40527716" class="c"><input type="checkbox" id="c-40527716" checked=""/><div class="controls bullet"><span class="by">dsego</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526559">parent</a><span>|</span><a href="#40528931">prev</a><span>|</span><a href="#40527874">next</a><span>|</span><label class="collapse" for="c-40527716">[-]</label><label class="expand" for="c-40527716">[1 more]</label></div><br/><div class="children"><div class="content">Visually parse.</div><br/></div></div></div></div><div id="40527874" class="c"><input type="checkbox" id="c-40527874" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526559">prev</a><span>|</span><a href="#40526164">next</a><span>|</span><label class="collapse" for="c-40527874">[-]</label><label class="expand" for="c-40527874">[3 more]</label></div><br/><div class="children"><div class="content">DRY is IMHO a maintenance thing.<p>If &quot;I don&#x27;t want to maintain three copies of this&quot; is your reaction unifying likely makes sense.<p>But that assumes the maintenance would be similar which is obviously a big assumption.</div><br/><div id="40528695" class="c"><input type="checkbox" id="c-40528695" checked=""/><div class="controls bullet"><span class="by">coffeebeqn</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527874">parent</a><span>|</span><a href="#40526164">next</a><span>|</span><label class="collapse" for="c-40528695">[-]</label><label class="expand" for="c-40528695">[2 more]</label></div><br/><div class="children"><div class="content">DRY often gives you the wrong or a leaky abstraction and creates dependencies between sometimes unrelated pieces of code. It’s got tradeoffs rather than being a silver bullet for improving codebases.<p>Having 0% DRY is probably bad, having 100% DRY is probably unhinged</div><br/><div id="40530143" class="c"><input type="checkbox" id="c-40530143" checked=""/><div class="controls bullet"><span class="by">kitkat_new</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40528695">parent</a><span>|</span><a href="#40526164">next</a><span>|</span><label class="collapse" for="c-40530143">[-]</label><label class="expand" for="c-40530143">[1 more]</label></div><br/><div class="children"><div class="content">&gt; sometimes unrelated pieces<p>you are using it wrong<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40525064#40525690">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40525064#40525690</a></div><br/></div></div></div></div></div></div><div id="40526164" class="c"><input type="checkbox" id="c-40526164" checked=""/><div class="controls bullet"><span class="by">drojas</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40527874">prev</a><span>|</span><a href="#40526232">next</a><span>|</span><label class="collapse" for="c-40526164">[-]</label><label class="expand" for="c-40526164">[1 more]</label></div><br/><div class="children"><div class="content">I agree and would add that one of the goals for technical design or architecture work is to choose the architecture that minimizes the friction between best practices. For example if you architecture makes cohesion decrease readability too much then perhaps there is a better architecture. I see this tradeoff pop up from time to time at my work for example when we deal with features that support multiple &quot;flavors&quot; of the same data model, then we have either a bunch of functions for each providing extensibility or a messy root function that provides cohesion. At the end both best practices can be supported by using an interface (or similar construct depending on the language) in which cohesion is provided by logic that only cares about the interface and extensibility is provided by having the right interface (offload details to the specific implementations)</div><br/></div></div><div id="40526232" class="c"><input type="checkbox" id="c-40526232" checked=""/><div class="controls bullet"><span class="by">englishspot</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526164">prev</a><span>|</span><a href="#40531404">next</a><span>|</span><label class="collapse" for="c-40526232">[-]</label><label class="expand" for="c-40526232">[5 more]</label></div><br/><div class="children"><div class="content">I have a pessimistic view that ultimately the only best practices that matter are the ones your boss or your tech lead likes.</div><br/><div id="40526325" class="c"><input type="checkbox" id="c-40526325" checked=""/><div class="controls bullet"><span class="by">jkaptur</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526232">parent</a><span>|</span><a href="#40531404">next</a><span>|</span><label class="collapse" for="c-40526325">[-]</label><label class="expand" for="c-40526325">[4 more]</label></div><br/><div class="children"><div class="content">What about when you are the boss or tech lead?</div><br/><div id="40526480" class="c"><input type="checkbox" id="c-40526480" checked=""/><div class="controls bullet"><span class="by">znkr</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526325">parent</a><span>|</span><a href="#40531404">next</a><span>|</span><label class="collapse" for="c-40526480">[-]</label><label class="expand" for="c-40526480">[3 more]</label></div><br/><div class="children"><div class="content">Then the only best practices that matter are the ones that your team believes are correct</div><br/><div id="40527051" class="c"><input type="checkbox" id="c-40527051" checked=""/><div class="controls bullet"><span class="by">rvnx</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526480">parent</a><span>|</span><a href="#40531404">next</a><span>|</span><label class="collapse" for="c-40527051">[-]</label><label class="expand" for="c-40527051">[2 more]</label></div><br/><div class="children"><div class="content">The best practices are the ones that allow you to do business and where the maintenance work is relatively not too painful considering the budgeted development time.<p>Your task is to deliver a good product, not necessarily good code.</div><br/><div id="40527979" class="c"><input type="checkbox" id="c-40527979" checked=""/><div class="controls bullet"><span class="by">englishspot</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527051">parent</a><span>|</span><a href="#40531404">next</a><span>|</span><label class="collapse" for="c-40527979">[-]</label><label class="expand" for="c-40527979">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The best practices are the ones that allow you to do business and where the maintenance work is relatively not too painful considering the budgeted development time.<p>the problem is even that in concrete terms can be controversial. everyone wants to minimize maintenance work; not everyone agrees on what kind of code will achieve that.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40531404" class="c"><input type="checkbox" id="c-40531404" checked=""/><div class="controls bullet"><span class="by">p1necone</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526232">prev</a><span>|</span><a href="#40528338">next</a><span>|</span><label class="collapse" for="c-40531404">[-]</label><label class="expand" for="c-40531404">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Cohesion over extensibility.<p>Imo the very best approach is a codebase that&#x27;s small enough that you can just do chunky refactors every so often rather than building in extensibility as a &quot;thing&quot;. Not applicable to all problem spaces (I&#x27;d hate to do this for UI code), but for a lot of stuff it works really nicely.<p>For me this often looks like an external DSL&#x2F;API that stays relatively constant (but improving), with guts that are always changing.</div><br/></div></div><div id="40528338" class="c"><input type="checkbox" id="c-40528338" checked=""/><div class="controls bullet"><span class="by">insane_dreamer</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40531404">prev</a><span>|</span><a href="#40526737">next</a><span>|</span><label class="collapse" for="c-40528338">[-]</label><label class="expand" for="c-40528338">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d prioritize readability over DRY.<p>Yes. Especially at the beginning when it&#x27;s critical to ensure that the logic is correct.<p>You can then go back and DRY it up while making sure your unit tests (you did write those, right?) still pass.<p>PS: same applies to &quot;fancy&quot; snippets that save you a few lines; write it the &quot;long way&quot; first and then make it fancy once you&#x27;re sure it runs the way it&#x27;s supposed to</div><br/><div id="40530189" class="c"><input type="checkbox" id="c-40530189" checked=""/><div class="controls bullet"><span class="by">kitkat_new</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40528338">parent</a><span>|</span><a href="#40526737">next</a><span>|</span><label class="collapse" for="c-40530189">[-]</label><label class="expand" for="c-40530189">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can then go back and DRY it up while making sure your unit tests (you did write those, right?) still pass.<p>not gonna happen once merged</div><br/></div></div></div></div><div id="40526737" class="c"><input type="checkbox" id="c-40526737" checked=""/><div class="controls bullet"><span class="by">blackoil</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40528338">prev</a><span>|</span><a href="#40529329">next</a><span>|</span><label class="collapse" for="c-40526737">[-]</label><label class="expand" for="c-40526737">[7 more]</label></div><br/><div class="children"><div class="content">I am of opinion, code should be written to be readable. Rest of the desirable properties are just side-effects.</div><br/><div id="40527098" class="c"><input type="checkbox" id="c-40527098" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526737">parent</a><span>|</span><a href="#40527071">next</a><span>|</span><label class="collapse" for="c-40527098">[-]</label><label class="expand" for="c-40527098">[2 more]</label></div><br/><div class="children"><div class="content">Most commonly, code should optimized into being easy to change.<p>That&#x27;s almost entirely coincidental with being easy to read. But even easiness to read is a side effect.</div><br/><div id="40529853" class="c"><input type="checkbox" id="c-40529853" checked=""/><div class="controls bullet"><span class="by">hnick</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527098">parent</a><span>|</span><a href="#40527071">next</a><span>|</span><label class="collapse" for="c-40529853">[-]</label><label class="expand" for="c-40529853">[1 more]</label></div><br/><div class="children"><div class="content">I agree with this. Easy to change often means good tests too.<p>I worked in Perl. Yes it has a reputation for being hard to read, but that was not the problem. Our scripting was pretty basic and easy to read. It&#x27;s the loose typing, the runtime evals, the lack of strict function parameters, no real IDE, “Only perl can parse Perl” - the fact you can load a module from a network share at runtime, import it, and call a function, based on a certain run flag - and so on. Refactoring was always a mine field and there was a lot I wanted to do in my old job but could not justify it due to the risk.</div><br/></div></div></div></div><div id="40527071" class="c"><input type="checkbox" id="c-40527071" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526737">parent</a><span>|</span><a href="#40527098">prev</a><span>|</span><a href="#40527003">next</a><span>|</span><label class="collapse" for="c-40527071">[-]</label><label class="expand" for="c-40527071">[2 more]</label></div><br/><div class="children"><div class="content">Fully agree. I think this is something that takes some time&#x2F;experience to appreciate though. Junior engineers will spend countless hours writing pages of code that align with the “design patterns” or “best practices” of the day when there’s a simpler implementation of the code they’re writing. (I’m not saying this condescendingly—I was once a junior engineer who did that too!)</div><br/><div id="40531396" class="c"><input type="checkbox" id="c-40531396" checked=""/><div class="controls bullet"><span class="by">coffeebeqn</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40527071">parent</a><span>|</span><a href="#40527003">next</a><span>|</span><label class="collapse" for="c-40531396">[-]</label><label class="expand" for="c-40531396">[1 more]</label></div><br/><div class="children"><div class="content">It’s impossible to know what “good” looks like when you’re new and haven’t seen a few codebases of varying quality and made some terrible mistakes</div><br/></div></div></div></div><div id="40527003" class="c"><input type="checkbox" id="c-40527003" checked=""/><div class="controls bullet"><span class="by">gavmor</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526737">parent</a><span>|</span><a href="#40527071">prev</a><span>|</span><a href="#40528190">next</a><span>|</span><label class="collapse" for="c-40527003">[-]</label><label class="expand" for="c-40527003">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fair to say that between behavior and maintainability, one is inflexible and the other hangs from it in tension.</div><br/></div></div><div id="40528190" class="c"><input type="checkbox" id="c-40528190" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526737">parent</a><span>|</span><a href="#40527003">prev</a><span>|</span><a href="#40529329">next</a><span>|</span><label class="collapse" for="c-40528190">[-]</label><label class="expand" for="c-40528190">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Side effects&quot; are not the same as &quot;less important traits.&quot;<p>Side effects are usually unrelated or unwanted.</div><br/></div></div></div></div><div id="40529329" class="c"><input type="checkbox" id="c-40529329" checked=""/><div class="controls bullet"><span class="by">hot_gril</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526737">prev</a><span>|</span><a href="#40526015">next</a><span>|</span><label class="collapse" for="c-40529329">[-]</label><label class="expand" for="c-40529329">[1 more]</label></div><br/><div class="children"><div class="content">I place copy-pastability somewhere into those priorities too :)</div><br/></div></div><div id="40526015" class="c"><input type="checkbox" id="c-40526015" checked=""/><div class="controls bullet"><span class="by">unnouinceput</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40529329">prev</a><span>|</span><a href="#40529727">next</a><span>|</span><label class="collapse" for="c-40526015">[-]</label><label class="expand" for="c-40526015">[1 more]</label></div><br/><div class="children"><div class="content">Maintenance is 90% of a project life time. Sometime those &quot;best practices&quot; rigid implemented means the project won&#x27;t live to see even it&#x27;s 1st birthday.</div><br/></div></div><div id="40529727" class="c"><input type="checkbox" id="c-40529727" checked=""/><div class="controls bullet"><span class="by">woodpanel</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40526015">prev</a><span>|</span><a href="#40527410">next</a><span>|</span><label class="collapse" for="c-40529727">[-]</label><label class="expand" for="c-40529727">[1 more]</label></div><br/><div class="children"><div class="content">Agree and would add that software projects also run through different phases in their lifespans with each phase having their own objectives [1].<p>So while - as you say - best practices can be at odds with each other - dev teams might be following both over time, just prioritizing one in some phase while completely disregarding it during another.<p>[1] E.g. the UI of the actual product might pivot multiple times at phase 1 because the product has yet to find its niche or core offering. While at a later stage the focus might be on massive scaling, either in numbers of devs or rolling out the product in new jurisdictions. Other phases might be a maintenance one, when an &quot;offshore&quot; team is given ownership or a sundown of an application.</div><br/></div></div><div id="40527410" class="c"><input type="checkbox" id="c-40527410" checked=""/><div class="controls bullet"><span class="by">zooq_ai</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40529727">prev</a><span>|</span><a href="#40526059">next</a><span>|</span><label class="collapse" for="c-40527410">[-]</label><label class="expand" for="c-40527410">[1 more]</label></div><br/><div class="children"><div class="content">aka &quot;Engineering is about trade-offs&quot;</div><br/></div></div><div id="40526059" class="c"><input type="checkbox" id="c-40526059" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#40525596">parent</a><span>|</span><a href="#40527410">prev</a><span>|</span><a href="#40529028">next</a><span>|</span><label class="collapse" for="c-40526059">[-]</label><label class="expand" for="c-40526059">[10 more]</label></div><br/><div class="children"><div class="content">Readability doesn&#x27;t matter much when you have 10,000+ lines of code. You aren&#x27;t going to read all that code, and new code introduced by other people continuously isn&#x27;t something you can keep track of, so even if you understand one tiny bit of code, you won&#x27;t know about the rest. You need a system of code management (documentation, diagram, IDE, tests, etc), to explain in a human-friendly way what the hell is going on. Small chunks of code will be readable enough, and the code management systems will help you understand how it relates to other code.</div><br/><div id="40526434" class="c"><input type="checkbox" id="c-40526434" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526059">parent</a><span>|</span><a href="#40526464">next</a><span>|</span><label class="collapse" for="c-40526434">[-]</label><label class="expand" for="c-40526434">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Readability doesn&#x27;t matter much when you have 10,000+ lines of code. You aren&#x27;t going to read all that code (...)<p>You got it entirely backwards. Readability becomes far more important with the size of your project.<p>When you get a bug report of a feature request, you need to dive into the code and update the relevant bits. With big projects, odds are you will need to change bits of the code you never knew they existed. The only way that&#x27;s possible is if the code is clear and it&#x27;s easy to sift through, understand, and follow.<p>&gt; You need a system of code management (documentation, diagram, IDE, tests, etc), to explain in a human-friendly way what the hell is going on.<p>That system of code management is the code itself. Any IDE supports searching for references, jump to definitions, see inheritance chains, etc. Readable code is code that is easy to navigate and whose changes are obvious.</div><br/></div></div><div id="40526464" class="c"><input type="checkbox" id="c-40526464" checked=""/><div class="controls bullet"><span class="by">foresto</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526059">parent</a><span>|</span><a href="#40526434">prev</a><span>|</span><a href="#40526489">next</a><span>|</span><label class="collapse" for="c-40526464">[-]</label><label class="expand" for="c-40526464">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Readability doesn&#x27;t matter much when you have 10,000+ lines of code. You aren&#x27;t going to read all that code,<p>As someone who has read 10,000+ lines in order to track down surprising behavior in other people&#x27;s code, I can say without a doubt that readability still matters at that scale.<p>Code management systems can sometimes be helpful, but they are no substitute.</div><br/></div></div><div id="40526489" class="c"><input type="checkbox" id="c-40526489" checked=""/><div class="controls bullet"><span class="by">fmbb</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526059">parent</a><span>|</span><a href="#40526464">prev</a><span>|</span><a href="#40528208">next</a><span>|</span><label class="collapse" for="c-40526489">[-]</label><label class="expand" for="c-40526489">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Small chunks of code will be readable enough<p>Ravioli code is a real problem though. Saying small chunks are readable is not enough. The blast radius of a five byte change can be fifteen code paths and five million requests per hour.</div><br/></div></div><div id="40528208" class="c"><input type="checkbox" id="c-40528208" checked=""/><div class="controls bullet"><span class="by">HumblyTossed</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526059">parent</a><span>|</span><a href="#40526489">prev</a><span>|</span><a href="#40526367">next</a><span>|</span><label class="collapse" for="c-40528208">[-]</label><label class="expand" for="c-40528208">[2 more]</label></div><br/><div class="children"><div class="content">10KLoC is a very small app.  Ours isn&#x27;t that big and it&#x27;s 140KLoC and I have read almost all of it.</div><br/><div id="40531900" class="c"><input type="checkbox" id="c-40531900" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40528208">parent</a><span>|</span><a href="#40526367">next</a><span>|</span><label class="collapse" for="c-40531900">[-]</label><label class="expand" for="c-40531900">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, not all lines of code are equal. A project with a state machine, commands, strategy patterns, etc requires an awful lot of repetitive boilerplate.<p>A number-crunching app or a data processing pipeline packed with spaghetti business logic is far harder ti read.</div><br/></div></div></div></div><div id="40526367" class="c"><input type="checkbox" id="c-40526367" checked=""/><div class="controls bullet"><span class="by">dieortin</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526059">parent</a><span>|</span><a href="#40528208">prev</a><span>|</span><a href="#40526247">next</a><span>|</span><label class="collapse" for="c-40526367">[-]</label><label class="expand" for="c-40526367">[1 more]</label></div><br/><div class="children"><div class="content">Even if you’re not going to read 10.000+ lines, if the few you read are easy to understand you’re still going to have a much better time maintaining the codebase.</div><br/></div></div><div id="40526247" class="c"><input type="checkbox" id="c-40526247" checked=""/><div class="controls bullet"><span class="by">ugh123</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526059">parent</a><span>|</span><a href="#40526367">prev</a><span>|</span><a href="#40529028">next</a><span>|</span><label class="collapse" for="c-40526247">[-]</label><label class="expand" for="c-40526247">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You need a system of code management (documentation, diagram, IDE, tests, etc), to explain in a human-friendly way what the hell is going on<p>I think this is where AI could be helpful in explaining and inspecting large codebases, as an assist to a developer.</div><br/><div id="40531915" class="c"><input type="checkbox" id="c-40531915" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526247">parent</a><span>|</span><a href="#40527751">next</a><span>|</span><label class="collapse" for="c-40531915">[-]</label><label class="expand" for="c-40531915">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think this is where AI could be helpful in explaining and inspecting large codebases, as an assist to a developer.<p>That&#x27;s a great point. Everyone lauds the benefits of chatgpt&#x2F;copilot in generating new code, but I&#x27;m starting to learn that the places they might shine is onboarding onto projects and preliminary code reviews. What LlMs excel at is context, and they should excel in activities where context-awareness is key.</div><br/></div></div><div id="40527751" class="c"><input type="checkbox" id="c-40527751" checked=""/><div class="controls bullet"><span class="by">rohansingh</span><span>|</span><a href="#40525596">root</a><span>|</span><a href="#40526247">parent</a><span>|</span><a href="#40531915">prev</a><span>|</span><a href="#40529028">next</a><span>|</span><label class="collapse" for="c-40527751">[-]</label><label class="expand" for="c-40527751">[1 more]</label></div><br/><div class="children"><div class="content">Maybe but hallucinations become a real problem here. Even with publicly available API&#x27;s that are just slightly off the beaten path, I&#x27;ve gotten full-on hallucinations that have derailed me and wasted time.</div><br/></div></div></div></div></div></div></div></div><div id="40529028" class="c"><input type="checkbox" id="c-40529028" checked=""/><div class="controls bullet"><span class="by">dkarl</span><span>|</span><a href="#40525596">prev</a><span>|</span><a href="#40528523">next</a><span>|</span><label class="collapse" for="c-40529028">[-]</label><label class="expand" for="c-40529028">[3 more]</label></div><br/><div class="children"><div class="content">Reminds me of a conversation I had with a project manager. To match the example, I&#x27;ll recast it in terms of deadlines.<p>Project manager: Sam is working on a deadline validator. You made a deadline validator last sprint right? Could Sam use yours?<p>Me: No, unfortunately not. My deadline validator enforces that deadlines are in the future and are aligned with midnight UTC, to ensure correct date calculations in the database. The deadline validator Sam is working on does not enforce those restrictions. Sam&#x27;s deadline validator will be applied to user input for an entirely different field, where deadlines don&#x27;t have to be at midnight and are just as often in the past as in the future. In fact, Sam&#x27;s validator only checks that a deadline string has the expected format and is within twenty years of the present day. My validator operates on timestamps sent as integers from another service, not string values uploaded by users.<p>Project manager: So your deadline validator is not reusable at all? That&#x27;s unfortunate. Is there something we could have done differently to avoid this redundant work?</div><br/><div id="40529675" class="c"><input type="checkbox" id="c-40529675" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40529028">parent</a><span>|</span><a href="#40529119">next</a><span>|</span><label class="collapse" for="c-40529675">[-]</label><label class="expand" for="c-40529675">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In fact, Sam&#x27;s validator only checks that a deadline string has the expected format and is within twenty years of the present day.<p>You two have been talking about this longer than it took Sam to implement by now ;)</div><br/></div></div><div id="40529119" class="c"><input type="checkbox" id="c-40529119" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40529028">parent</a><span>|</span><a href="#40529675">prev</a><span>|</span><a href="#40528523">next</a><span>|</span><label class="collapse" for="c-40529119">[-]</label><label class="expand" for="c-40529119">[1 more]</label></div><br/><div class="children"><div class="content">Developer, next time: No, I made a real-time database constraint policy enforcement engine. Totally different thing.</div><br/></div></div></div></div><div id="40528523" class="c"><input type="checkbox" id="c-40528523" checked=""/><div class="controls bullet"><span class="by">hprotagonist</span><span>|</span><a href="#40529028">prev</a><span>|</span><a href="#40526253">next</a><span>|</span><label class="collapse" for="c-40528523">[-]</label><label class="expand" for="c-40528523">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;grugbrain.dev&#x2F;#grug-on-dry" rel="nofollow">https:&#x2F;&#x2F;grugbrain.dev&#x2F;#grug-on-dry</a><p><i>grug begin feel repeat&#x2F;copy paste code with small variation is better than many callback&#x2F;closures passed arguments or elaborate object model: too hard complex for too little benefit at times<p>hard balance here, repeat code always still make grug stare and say &quot;mmm&quot; often, but experience show repeat code sometimes often better than complex DRY solution</i><p>something i have learned the hard way is that DRYing out too fast paints you into architectural corners you don&#x27;t even know are there yet.</div><br/><div id="40529078" class="c"><input type="checkbox" id="c-40529078" checked=""/><div class="controls bullet"><span class="by">localfirst</span><span>|</span><a href="#40528523">parent</a><span>|</span><a href="#40526253">next</a><span>|</span><label class="collapse" for="c-40529078">[-]</label><label class="expand" for="c-40529078">[1 more]</label></div><br/><div class="children"><div class="content">read the whole article and wow!<p>grug tell facts</div><br/></div></div></div></div><div id="40526253" class="c"><input type="checkbox" id="c-40526253" checked=""/><div class="controls bullet"><span class="by">dvh</span><span>|</span><a href="#40528523">prev</a><span>|</span><a href="#40526831">next</a><span>|</span><label class="collapse" for="c-40526253">[-]</label><label class="expand" for="c-40526253">[12 more]</label></div><br/><div class="children"><div class="content">DRY code (usually with lot of IF blocks to handle special cases, or various oop lasagna) eventually turns into unmaintainable nightmare where every trivial new feature can take hours to implement and is very difficult, full of cussing, hair-pulling kind of programming where every 5 minutes you think &quot;we need to rewrite everything from scratch, the system wasn&#x27;t designed for this&quot;. Every change breaks million different unrelated things because of the complexity of extremely dry functions.<p>In WET code (write everything twice) everything looks primitive, as if it was written by complete newbie, and every change needs to be added at multiple places, but each change is trivial and time to finish is predictable. I would go as far as calling the code boring. The most difficult thing is to resist the temptation to remove the duplicity.</div><br/><div id="40528205" class="c"><input type="checkbox" id="c-40528205" checked=""/><div class="controls bullet"><span class="by">DSMan195276</span><span>|</span><a href="#40526253">parent</a><span>|</span><a href="#40526416">next</a><span>|</span><label class="collapse" for="c-40528205">[-]</label><label class="expand" for="c-40528205">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen code like this, what eventually happens is that all your &#x27;copies&#x27; drift to be slightly different. Fixes get applied to some but not all of them, people copy from old code vs. new code, etc. And whenever you need to apply a fix you spend hours trying to figure out where each copy is, what it is supposed to be doing (since they&#x27;re all different), and how the fix can be applied to it. You inevitably don&#x27;t find them all and repeat the cycle.</div><br/><div id="40532054" class="c"><input type="checkbox" id="c-40532054" checked=""/><div class="controls bullet"><span class="by">YZF</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40528205">parent</a><span>|</span><a href="#40526416">next</a><span>|</span><label class="collapse" for="c-40532054">[-]</label><label class="expand" for="c-40532054">[1 more]</label></div><br/><div class="children"><div class="content">This is also true. Some versions can be buggy and then a fix might not get everywhere. My favorite example is C code bases with a multitude of linked list implementations.<p>Like many things in software knowing when to do something and when not to do something can be hard. Premature DRY as the article mentions can lead to difficulty when eventually the use case diverges. Re-implementing everything every time everywhere is also silly. As mentioned in other places, I like the rule of 3, if you have 3 examples the point strongly a certain direction that&#x27;s probably a good one to follow.</div><br/></div></div></div></div><div id="40526416" class="c"><input type="checkbox" id="c-40526416" checked=""/><div class="controls bullet"><span class="by">ollien</span><span>|</span><a href="#40526253">parent</a><span>|</span><a href="#40528205">prev</a><span>|</span><a href="#40531356">next</a><span>|</span><label class="collapse" for="c-40526416">[-]</label><label class="expand" for="c-40526416">[7 more]</label></div><br/><div class="children"><div class="content">&gt; In WET code (write everything twice) everything looks primitive, as if it was written by complete newbie, and every change needs to be added at multiple places, but each change is trivial and time to finish is predictable. I would go as far as calling the code boring. The most difficult thing is to resist the temptation to remove the duplicity.<p>This only scales so far. After some point, it&#x27;s very easy to run into cases where you meant to change something everywhere but forgot&#x2F;didn&#x27;t know about others. Not to say everything should be so compartmentalized as to restrict change, but there is a balance to be had.</div><br/><div id="40526749" class="c"><input type="checkbox" id="c-40526749" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40526416">parent</a><span>|</span><a href="#40526605">next</a><span>|</span><label class="collapse" for="c-40526749">[-]</label><label class="expand" for="c-40526749">[2 more]</label></div><br/><div class="children"><div class="content">Which is why you need a balance between WET and DRY. DAMP = Don&#x27;t Alter in Many Places.</div><br/><div id="40527325" class="c"><input type="checkbox" id="c-40527325" checked=""/><div class="controls bullet"><span class="by">kag0</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40526749">parent</a><span>|</span><a href="#40526605">next</a><span>|</span><label class="collapse" for="c-40527325">[-]</label><label class="expand" for="c-40527325">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never heard this one before, but I love it. Unfortunately we&#x27;ve also got &quot;Don&#x27;t Abstract Methods Prematurely&quot; and &quot;Descriptive And Meaningful Phrases&quot;.</div><br/></div></div></div></div><div id="40526605" class="c"><input type="checkbox" id="c-40526605" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40526416">parent</a><span>|</span><a href="#40526749">prev</a><span>|</span><a href="#40528161">next</a><span>|</span><label class="collapse" for="c-40526605">[-]</label><label class="expand" for="c-40526605">[3 more]</label></div><br/><div class="children"><div class="content">Yes, what actually happens is that many code changes are released half-baked because logic only got updated in 1 (or 13) of the 14 places that needed to be updated, and the cussing and hair pulling just starts later.</div><br/><div id="40529596" class="c"><input type="checkbox" id="c-40529596" checked=""/><div class="controls bullet"><span class="by">rrr_oh_man</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40526605">parent</a><span>|</span><a href="#40528161">next</a><span>|</span><label class="collapse" for="c-40529596">[-]</label><label class="expand" for="c-40529596">[2 more]</label></div><br/><div class="children"><div class="content">Tests, baby</div><br/><div id="40529736" class="c"><input type="checkbox" id="c-40529736" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40529596">parent</a><span>|</span><a href="#40528161">next</a><span>|</span><label class="collapse" for="c-40529736">[-]</label><label class="expand" for="c-40529736">[1 more]</label></div><br/><div class="children"><div class="content">Tests don&#x27;t really help you when a newly discovered bug affects logic copied in ten places and you&#x27;re only aware of two of them. You can add a regression test to the places that you update, but not the others. And then if there&#x27;s another bug discovered in the duplicated code, a different subset of the copies might get changed and have tests added. Suddenly it looks like these different versions of the repeated logic are intended to be behaving differently for some unknown reason even though the divergence is purely accidental.</div><br/></div></div></div></div></div></div><div id="40528161" class="c"><input type="checkbox" id="c-40528161" checked=""/><div class="controls bullet"><span class="by">yakshaving_jgt</span><span>|</span><a href="#40526253">root</a><span>|</span><a href="#40526416">parent</a><span>|</span><a href="#40526605">prev</a><span>|</span><a href="#40531356">next</a><span>|</span><label class="collapse" for="c-40528161">[-]</label><label class="expand" for="c-40528161">[1 more]</label></div><br/><div class="children"><div class="content">Or, use a sufficiently well designed type-checking compiler, like GHC.</div><br/></div></div></div></div><div id="40531356" class="c"><input type="checkbox" id="c-40531356" checked=""/><div class="controls bullet"><span class="by">brokencode</span><span>|</span><a href="#40526253">parent</a><span>|</span><a href="#40526416">prev</a><span>|</span><a href="#40529699">next</a><span>|</span><label class="collapse" for="c-40531356">[-]</label><label class="expand" for="c-40531356">[1 more]</label></div><br/><div class="children"><div class="content">Why does everything need to be either DRY or WET? Like most things in life, there are no absolutes in programming, only tradeoffs.<p>Those may be good principles to think about when you are starting out with programming, but the key is to gain experience trying to solve problems in different ways.<p>Over time, you get better at making the right decision about whether duplicative code should be refactored or left alone.<p>To be fair, we can’t always make the “right” decision, but we can at least try to make the best decision we can based on the knowledge we have.</div><br/></div></div><div id="40529699" class="c"><input type="checkbox" id="c-40529699" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40526253">parent</a><span>|</span><a href="#40531356">prev</a><span>|</span><a href="#40526831">next</a><span>|</span><label class="collapse" for="c-40529699">[-]</label><label class="expand" for="c-40529699">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but each change is trivial and time to finish is predictable<p>Until your ‘if’ soup reaches all the locations in your codebase, and now you have 10 different places with too many if statements instead of one. Likely all touching slightly different things, so you can’t simply copy from one file to the other any more.</div><br/></div></div></div></div><div id="40526831" class="c"><input type="checkbox" id="c-40526831" checked=""/><div class="controls bullet"><span class="by">epr</span><span>|</span><a href="#40526253">prev</a><span>|</span><a href="#40527785">next</a><span>|</span><label class="collapse" for="c-40526831">[-]</label><label class="expand" for="c-40526831">[13 more]</label></div><br/><div class="children"><div class="content">The example is hilariously terrible. Firstly, this is the currently required code:<p><pre><code>    def set_deadline(deadline):
      if deadline &lt;= datetime.now():
        raise ValueError(&quot;Date must be in the future&quot;)
    
    set_deadline(datetime(2024, 3, 12))
    set_deadline(datetime(2024, 3, 18))
</code></pre>
There simply is no trade-off to be made at this point. Perhaps there will be eventually, but right now, there is one function needed in two places. Turning two functions that already could be one into a class is absurd.<p>Now, as far as teaching best practices goes, I also dislike this post because it doesn&#x27;t explicitly explain the pros and cons of refactoring vs not refactoring in any detail. There is no guidance whatsoever (ie: Martin Fowler&#x27;s Rule of Three). This is Google we&#x27;re talking about, and newer developers could easily be led astray by nonsense like this. Addressing the two extremes, and getting into how solving this problem requires some nuance and practical experience is much more productive.</div><br/><div id="40527447" class="c"><input type="checkbox" id="c-40527447" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#40526831">parent</a><span>|</span><a href="#40529807">next</a><span>|</span><label class="collapse" for="c-40527447">[-]</label><label class="expand" for="c-40527447">[8 more]</label></div><br/><div class="children"><div class="content">Almost all programming tutorials and even books to a certain extent suffer with the problem of terrible examples. Properly motivating most design patterns requires context of a sufficiently complex codebase that tutorials and books simply do not have the space of getting into. This particular case is especially bad, probably because they had the goal of having the whole article fit in one page. (&quot;You can download a printer-friendly version to display in your office.&quot;)<p>&gt; There is no guidance whatsoever (ie: Martin Fowler&#x27;s Rule of Three).<p>That is completely unfair imo. Although not properly motivated, the advice is all there. &quot;When designing abstractions, do not prematurely couple behaviors that may evolve separately in the longer term.&quot; &quot;When in doubt, keep behaviors separate until enough common patterns emerge over time that justify the coupling.&quot;<p>Simplified maxims like &quot;Rule of Three&quot; do more harm than good. Don&#x27;t couple unrelated concerns is a much higher programming virtue than DRY.</div><br/><div id="40527554" class="c"><input type="checkbox" id="c-40527554" checked=""/><div class="controls bullet"><span class="by">LouisSayers</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40527447">parent</a><span>|</span><a href="#40529807">next</a><span>|</span><label class="collapse" for="c-40527554">[-]</label><label class="expand" for="c-40527554">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Properly motivating most design patterns requires context of a sufficiently complex codebase<p>As someone that&#x27;s made a best selling technical course, I strongly disagree.<p>It&#x27;s 100% laziness and&#x2F;or disregard for the reader.<p>The reason examples are as bad as they are is that people rush to get something published rather than put themselves in the audience&#x27;s position and make sure it&#x27;s concise and makes sense.<p>It&#x27;s not like webpage space is expensive. There&#x27;s plenty of room to walk through a good example, it just requires a little effort.</div><br/><div id="40531139" class="c"><input type="checkbox" id="c-40531139" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40527554">parent</a><span>|</span><a href="#40528634">next</a><span>|</span><label class="collapse" for="c-40531139">[-]</label><label class="expand" for="c-40531139">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s not like webpage space is expensive. There&#x27;s plenty of room to walk through a good example, it just requires a little effort.<p>Right at the top of the page:<p>&gt; A version of this post originally appeared in Google bathrooms worldwide as a Google Testing on the Toilet episode. You can download a printer-friendly version to display in your office.<p>So no, there isn&#x27;t room for a longer example.</div><br/></div></div><div id="40528634" class="c"><input type="checkbox" id="c-40528634" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40527554">parent</a><span>|</span><a href="#40531139">prev</a><span>|</span><a href="#40527976">next</a><span>|</span><label class="collapse" for="c-40528634">[-]</label><label class="expand" for="c-40528634">[1 more]</label></div><br/><div class="children"><div class="content">&gt;It&#x27;s not like webpage space is expensive.<p>It is not the webpage space. It is people&#x27;s limited attention spans and ability to focus. A complex example is needed to properly motivate certain concepts, but too complex an example also contains too many other details that the reader gets bogged down&#x2F;distracted from the main concept being discussed.<p>At least that is my hypothesis for why almost all programming books and tutorials have terrible examples. I am happy to be proven wrong.<p>Coming back to the article, I looked at some of the previous articles from the same series, and to me it feels like a very conscious decision to only include 3-4 line code examples.</div><br/></div></div><div id="40527976" class="c"><input type="checkbox" id="c-40527976" checked=""/><div class="controls bullet"><span class="by">Bjartr</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40527554">parent</a><span>|</span><a href="#40528634">prev</a><span>|</span><a href="#40529807">next</a><span>|</span><label class="collapse" for="c-40527976">[-]</label><label class="expand" for="c-40527976">[4 more]</label></div><br/><div class="children"><div class="content">What does sales have to do with what you&#x27;re claiming? Please share the course and or examples of it being done well without requiring that excessive context, so that there&#x27;s something to support your claim.</div><br/><div id="40528184" class="c"><input type="checkbox" id="c-40528184" checked=""/><div class="controls bullet"><span class="by">LouisSayers</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40527976">parent</a><span>|</span><a href="#40529807">next</a><span>|</span><label class="collapse" for="c-40528184">[-]</label><label class="expand" for="c-40528184">[3 more]</label></div><br/><div class="children"><div class="content">Well if my course and teaching was crap I wouldn&#x27;t get good reviews and therefore many sales. I&#x27;ve spent $0 on marketing.<p><a href="https:&#x2F;&#x2F;www.udemy.com&#x2F;neo4j-foundations&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.udemy.com&#x2F;neo4j-foundations&#x2F;</a><p>There are many people who do teach and explain topics well. Richard Feynman comes to mind.<p>I&#x27;ve found Abdul Bari on YouTube to also be an excellent teacher around technical topics.</div><br/><div id="40529759" class="c"><input type="checkbox" id="c-40529759" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40528184">parent</a><span>|</span><a href="#40529807">next</a><span>|</span><label class="collapse" for="c-40529759">[-]</label><label class="expand" for="c-40529759">[2 more]</label></div><br/><div class="children"><div class="content">Not related to the topic at hand, but who buys these courses? Going off the chapter titles it looks like it’s all basic ‘read the documentation’ kind of stuff (to me). I could imagine it being useful to beginners, but not anyone with a moderate amount of experience (they’d just go to the Neo4j documentation).<p>On the other hand, what beginner starts with Neo4j and Cypher? Is there really enough of them to justify a whole course? Apparently there are, it just feels weird to me.</div><br/><div id="40531964" class="c"><input type="checkbox" id="c-40531964" checked=""/><div class="controls bullet"><span class="by">LouisSayers</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40529759">parent</a><span>|</span><a href="#40529807">next</a><span>|</span><label class="collapse" for="c-40531964">[-]</label><label class="expand" for="c-40531964">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right in that if you go through the docs you can find all the info you might need.<p>It&#x27;s really catered for beginners, people that have next to no knowledge of graph databases or Neo4j and want to get up to speed in just a few hours.<p>I imagine some people may not even be super technical, but may want to learn just the basics of querying a DB at work to get some basic info out of it.<p>Apart from lessons there are also exercises for people to practice what they just learnt, and I do my best to point out gotchas and keep it mildly entertaining with a gentle progression in difficulty.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40529807" class="c"><input type="checkbox" id="c-40529807" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#40526831">parent</a><span>|</span><a href="#40527447">prev</a><span>|</span><a href="#40529034">next</a><span>|</span><label class="collapse" for="c-40529807">[-]</label><label class="expand" for="c-40529807">[1 more]</label></div><br/><div class="children"><div class="content">I was going to say you were talking nonsense, but then realized I’d replaced the original post in my mind, by this much nicer post that someone else linked in this thread:<p><a href="https:&#x2F;&#x2F;verraes.net&#x2F;2014&#x2F;08&#x2F;dry-is-about-knowledge&#x2F;" rel="nofollow">https:&#x2F;&#x2F;verraes.net&#x2F;2014&#x2F;08&#x2F;dry-is-about-knowledge&#x2F;</a><p>They essentially say the same thing, but one is better than the other.</div><br/></div></div><div id="40529034" class="c"><input type="checkbox" id="c-40529034" checked=""/><div class="controls bullet"><span class="by">re-framer</span><span>|</span><a href="#40526831">parent</a><span>|</span><a href="#40529807">prev</a><span>|</span><a href="#40527785">next</a><span>|</span><label class="collapse" for="c-40529034">[-]</label><label class="expand" for="c-40529034">[3 more]</label></div><br/><div class="children"><div class="content">Your example, deduplicating the two functions into one, illustrates an interesting point, although I&#x27;d prefer still having the two specialized functions there:<p><pre><code>    def set_deadline(deadline):
      if deadline &lt;= datetime.now():
        raise ValueError(&quot;Date must be in the future&quot;)
    
    def set_task_deadline(task_deadline):
      set_deadline(task_deadline)

    def set_payment_deadline(payment_deadline):
      set_deadline(payment_deadline)

    set_task_deadline(datetime(2024, 3, 12))
    set_payment_deadline(datetime(2024, 3, 18))
</code></pre>
You lose absolutely nothing. If you later want to handle the two cases differently, most IDEs allow you to inline the set_deadline method in a single key stroke.<p>So the argument from the article...<p>&gt; Applying DRY principles too rigidly leads to premature abstractions that make future changes more complex than necessary.<p>...does not apply to this example.<p>There clearly <i>are</i> kinds of DRY code that are less easy to reverse. Maybe we should strive for DRY code that can be easily transformed into WET (Write Everything Twice) code.<p>(Although I haven&#x27;t worked with LISPs, macros seem to provide a means of abstraction that can be easily undone without risk: just macro-expand them)<p>In my experience, it can be much harder to transform WET code into DRY code because you need to resolve all those little inconsistencies between once-perfect copies.</div><br/><div id="40530902" class="c"><input type="checkbox" id="c-40530902" checked=""/><div class="controls bullet"><span class="by">epr</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40529034">parent</a><span>|</span><a href="#40531402">next</a><span>|</span><label class="collapse" for="c-40530902">[-]</label><label class="expand" for="c-40530902">[1 more]</label></div><br/><div class="children"><div class="content">I can only assume the Google example would be part of a script&#x2F;cli program that is meant to crash with an error on a bad parameter or similar. Perhaps the point is to catch the exception for control flow?<p>My personal goal is to get things done in as few lines of code as possible, without cramming a bunch on one line. Instead of coming up with fancy names for things, I try to call it by the simplest name to describe what it&#x27;s currently doing, which can be difficult and is subjective.<p>If we wanted to define a function which crashes like the example, I would probably write this:<p><pre><code>    def throw_past_datetime(dt):
        if dt &lt;= datetime.now():
            raise ValueError(&quot;Date must be in the future&quot;)
</code></pre>
If the point is not to crash&#x2F;throw for control flow reasons, I&#x27;d write this in non-cli&#x2F;script code instead of defining a function:<p><pre><code>    dt = datetime(2024, 5, 29)
    if dt &lt; datetine.now():
        # Handle past date gracefully?
</code></pre>
If it needs to do more in the future, I can change it then.</div><br/></div></div><div id="40531402" class="c"><input type="checkbox" id="c-40531402" checked=""/><div class="controls bullet"><span class="by">alex_smart</span><span>|</span><a href="#40526831">root</a><span>|</span><a href="#40529034">parent</a><span>|</span><a href="#40530902">prev</a><span>|</span><a href="#40527785">next</a><span>|</span><label class="collapse" for="c-40531402">[-]</label><label class="expand" for="c-40531402">[1 more]</label></div><br/><div class="children"><div class="content">&gt;You lose absolutely nothing. If you later want to handle the two cases differently, most IDEs allow you to inline the set_deadline method in a single key stroke.<p>Problem with unintentional coupling isn&#x27;t that you can&#x27;t undo it. It is that someday someone from some other team is going to change the method to add behaviour they need for their own use case that is different from your own and you won&#x27;t even notice until there is a regression.</div><br/></div></div></div></div></div></div><div id="40527785" class="c"><input type="checkbox" id="c-40527785" checked=""/><div class="controls bullet"><span class="by">nevinera</span><span>|</span><a href="#40526831">prev</a><span>|</span><a href="#40532357">next</a><span>|</span><label class="collapse" for="c-40527785">[-]</label><label class="expand" for="c-40527785">[8 more]</label></div><br/><div class="children"><div class="content">DRY is _not a best practice_. Repetition is a &quot;code smell&quot; - it often suggests a missing abstraction that would allow for code reuse (what sort of abstraction depends on the language and context), but &quot;blindly-drying&quot; is in my experience the _single most frequent mistake_ made my mid-to-senior engineers.<p>My experience is mostly in Ruby though, so I&#x27;m not sure how well it generalizes here :-)</div><br/><div id="40527941" class="c"><input type="checkbox" id="c-40527941" checked=""/><div class="controls bullet"><span class="by">mmcnl</span><span>|</span><a href="#40527785">parent</a><span>|</span><a href="#40530355">next</a><span>|</span><label class="collapse" for="c-40527941">[-]</label><label class="expand" for="c-40527941">[2 more]</label></div><br/><div class="children"><div class="content">Premature DIY can lead to the wrong abstractions. Sometimes code looks similar but actually isn&#x27;t.</div><br/><div id="40528124" class="c"><input type="checkbox" id="c-40528124" checked=""/><div class="controls bullet"><span class="by">samtho</span><span>|</span><a href="#40527785">root</a><span>|</span><a href="#40527941">parent</a><span>|</span><a href="#40530355">next</a><span>|</span><label class="collapse" for="c-40528124">[-]</label><label class="expand" for="c-40528124">[1 more]</label></div><br/><div class="children"><div class="content">At my first big corporate jobs, I got to work on a codebase that was nothing but premature DRY’d code, but I didn’t know it at the time. As someone who was self taught, and suffered from imposter syndrome as many of us do&#x2F;did in that situation, I thought I was missing something huge until I was talking to a senior developer and these strange design decisions came up, to which he said something like<p>&gt; Yeah, that was written by &lt;ex-engineer&gt; and he couldn&#x27;t abstract his way out of a paper bag<p>I guess the real lessons were the crappy decisions that someone else made along the way.</div><br/></div></div></div></div><div id="40530355" class="c"><input type="checkbox" id="c-40530355" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#40527785">parent</a><span>|</span><a href="#40527941">prev</a><span>|</span><a href="#40528598">next</a><span>|</span><label class="collapse" for="c-40530355">[-]</label><label class="expand" for="c-40530355">[1 more]</label></div><br/><div class="children"><div class="content">It would be better to make a class for languages where DRY is not a best practice, then create classes of languages where it is a best practice or may be a best practice through multiple inheritance.  To keep things simple.<p>:)</div><br/></div></div><div id="40528598" class="c"><input type="checkbox" id="c-40528598" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#40527785">parent</a><span>|</span><a href="#40530355">prev</a><span>|</span><a href="#40528225">next</a><span>|</span><label class="collapse" for="c-40528598">[-]</label><label class="expand" for="c-40528598">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>&quot;blindly-drying&quot;</i><p>Right. It&#x27;s not an optimization problem!<p>Remember in school when you learned to turn a truth table into a Karnaugh map and then use it to find the smallest equivalent logic expression? Well, your code is not a Karnaugh map, is it?</div><br/></div></div><div id="40528225" class="c"><input type="checkbox" id="c-40528225" checked=""/><div class="controls bullet"><span class="by">hughesjj</span><span>|</span><a href="#40527785">parent</a><span>|</span><a href="#40528598">prev</a><span>|</span><a href="#40527850">next</a><span>|</span><label class="collapse" for="c-40528225">[-]</label><label class="expand" for="c-40528225">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I completely agree in python, Java, typescript, and golang.  I&#x27;ve seen people just parrot dogma about DRY and SOLID principals where their DRY&#x27;d code is completely not open to extension etc<p>Premature dry&#x27;ing is the same as premature engineering.  And lest someone go &#x27;oh so YAGNI is all you need&#x27;... no, sometimes you are going to need it and it&#x27;s better to at least make your code easily moldable to &#x27;it&#x27; now instead of later.  Future potential needs can absolutely drive design decisions<p>My whole point is that dogma is dumb.  If we had steadfast easy rules that applied in literally every situation, we could just hand off our work to some mechanical turks and the role of software engineer would be redundant.  Today, that&#x27;s not the case, and it&#x27;s literally our job to balance our wisdom and experience against the current situation. And yes, we will absolutely get it wrong from time to time, just hopefully a lower percentage of occasions as we gain experience.<p>The only dogma I live by for code is &#x27;boring is usually better&#x27;, and the only reason I stick by that is because it implicitly calls out that it&#x27;s not a real dogma in that it doesn&#x27;t apply in all cases.<p>(Okay, I definitely follow more principals than that, but don&#x27;t want to distract from the topic athand)</div><br/></div></div><div id="40527850" class="c"><input type="checkbox" id="c-40527850" checked=""/><div class="controls bullet"><span class="by">hfe</span><span>|</span><a href="#40527785">parent</a><span>|</span><a href="#40528225">prev</a><span>|</span><a href="#40528008">next</a><span>|</span><label class="collapse" for="c-40527850">[-]</label><label class="expand" for="c-40527850">[1 more]</label></div><br/><div class="children"><div class="content">My experiences are the same in C++ and Python. C++ in particular can get way out of hand in service of DRY.</div><br/></div></div><div id="40528008" class="c"><input type="checkbox" id="c-40528008" checked=""/><div class="controls bullet"><span class="by">colechristensen</span><span>|</span><a href="#40527785">parent</a><span>|</span><a href="#40527850">prev</a><span>|</span><a href="#40532357">next</a><span>|</span><label class="collapse" for="c-40528008">[-]</label><label class="expand" for="c-40528008">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I&#x27;ve had so many problems with understanding and working with other people&#x27;s code bases when the person was obsessed with DRY.<p>You wrote that code 4 years ago with tons of abstractions designed for some day someone not having to repeat themselves... but it&#x27;s been years and they&#x27;ve never been useful.  However I&#x27;ve had to dig through a dozen files to make the change I needed to make which by all rights should have been entirely contained in a few lines.<p>My most common reaction to a new codebase is &quot;where the hell does anything actually get done&quot; because of silly over-abstraction which aspires to, one day, save a developer five minutes or three lines of copied code.</div><br/></div></div></div></div><div id="40532357" class="c"><input type="checkbox" id="c-40532357" checked=""/><div class="controls bullet"><span class="by">Gehinnn</span><span>|</span><a href="#40527785">prev</a><span>|</span><a href="#40526603">next</a><span>|</span><label class="collapse" for="c-40532357">[-]</label><label class="expand" for="c-40532357">[2 more]</label></div><br/><div class="children"><div class="content">I think DRY should be more &quot;Don&#x27;t repeat assumptions&quot;.<p>Or rather, don&#x27;t assume the same thing in two different places, especially not implicitly.<p>Avoiding code duplication mostly follows from that.</div><br/><div id="40532398" class="c"><input type="checkbox" id="c-40532398" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40532357">parent</a><span>|</span><a href="#40526603">next</a><span>|</span><label class="collapse" for="c-40532398">[-]</label><label class="expand" for="c-40532398">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s barely possible because code has to coherently work on a shared goal. But I agree in principle -- reduce duplication of assumptions as much as possible.<p>One way that helps with that is creating abstractions. I don&#x27;t mean clever grandiose abstractions, those are extremely hard to get right. I mean precisely those abstractions that factor shared code.<p>But even before that, it&#x27;s important to get the control flow right to minimize doing the same thing multiple times in the codebase. Because even when the implementation is in a central place, calling it multiple times from different locations is what you say, duplicating assumptions.</div><br/></div></div></div></div><div id="40526603" class="c"><input type="checkbox" id="c-40526603" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#40532357">prev</a><span>|</span><a href="#40532504">next</a><span>|</span><label class="collapse" for="c-40526603">[-]</label><label class="expand" for="c-40526603">[2 more]</label></div><br/><div class="children"><div class="content">This DRY principle has ruined so many code bases merging so many facets into one giant monster of complexity that then later has to be specialised with flags and enums that I can&#x27;t count how many times I have seen such clever PRs.<p>IMHO - some of the clean code books have ruined the industry as much as the virtues of microservice preachers have.<p>The second number goes to the Javascript tooling.</div><br/><div id="40530314" class="c"><input type="checkbox" id="c-40530314" checked=""/><div class="controls bullet"><span class="by">Nuzzerino</span><span>|</span><a href="#40526603">parent</a><span>|</span><a href="#40532504">next</a><span>|</span><label class="collapse" for="c-40530314">[-]</label><label class="expand" for="c-40530314">[1 more]</label></div><br/><div class="children"><div class="content">Can you honestly say with a straight face that those same code authors would be any better if they hadn&#x27;t read those books? Sometimes the problem isn&#x27;t the book but a lack of critical thinking. Using a tool or or method because a book said to use it and not because it was the time and place, is an obvious sign of that to me.<p>And here&#x27;s the kicker: If you were aware the individual was taking inspiration from a book easily in such a way, what made it difficult for them to take inspiration from you through a dialogue? Hopefully your arguments were stronger than your HN comment.</div><br/></div></div></div></div><div id="40532504" class="c"><input type="checkbox" id="c-40532504" checked=""/><div class="controls bullet"><span class="by">DLion</span><span>|</span><a href="#40526603">prev</a><span>|</span><a href="#40525468">next</a><span>|</span><label class="collapse" for="c-40532504">[-]</label><label class="expand" for="c-40532504">[1 more]</label></div><br/><div class="children"><div class="content">I like a lot the &quot;rule of three&quot; when it comes to have to choose when to DRY.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_of_three_(computer_programming)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Rule_of_three_(computer_progra...</a></div><br/></div></div><div id="40525468" class="c"><input type="checkbox" id="c-40525468" checked=""/><div class="controls bullet"><span class="by">softwaredoug</span><span>|</span><a href="#40532504">prev</a><span>|</span><a href="#40532313">next</a><span>|</span><label class="collapse" for="c-40525468">[-]</label><label class="expand" for="c-40525468">[26 more]</label></div><br/><div class="children"><div class="content">Generality can really hurt performance. Duplicating specialized code to handle different cases can really help optimize specific code hot spots for certain data patterns or use cases.<p>So DRY isn’t an obvious default for me.</div><br/><div id="40525661" class="c"><input type="checkbox" id="c-40525661" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#40525468">parent</a><span>|</span><a href="#40525627">next</a><span>|</span><label class="collapse" for="c-40525661">[-]</label><label class="expand" for="c-40525661">[4 more]</label></div><br/><div class="children"><div class="content">I think it really depends and it&#x27;s a case where a lot of engineering judgment and taste comes to bear. For example right now I&#x27;m maintaining a Jenkins system that has two large and complicated pipelines that are about 90% overlapping but for wretched historical reasons were implemented separately and the implementations have diverged over the years in subtle ways that now make it challenging to re-unify them.<p>There is no question in my mind that this should always have been built as either a single pipeline with some parameters to cover the two use-cases, or perhaps as a toolbox of reusable components that are then used for the overlapping area. But I expect the mentality at the time the second one was being stood up was that it would be less disruptive to just build the new stuff as a parallel implementation and figure out later how to avoid the duplication.</div><br/><div id="40525852" class="c"><input type="checkbox" id="c-40525852" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525661">parent</a><span>|</span><a href="#40525627">next</a><span>|</span><label class="collapse" for="c-40525852">[-]</label><label class="expand" for="c-40525852">[3 more]</label></div><br/><div class="children"><div class="content">You are describing technical debt, not conscious decisions to be DRY or not DRY.</div><br/><div id="40526316" class="c"><input type="checkbox" id="c-40526316" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525852">parent</a><span>|</span><a href="#40530283">next</a><span>|</span><label class="collapse" for="c-40526316">[-]</label><label class="expand" for="c-40526316">[1 more]</label></div><br/><div class="children"><div class="content">Hmm. Certainly there&#x27;s no doubt that there&#x27;s technical debt (&quot;do it this way for now, we&#x27;ll clean it up later&quot;) here too, but I think there was also a conscious decision to build something parallel <i>rather</i> than generalizing the thing that already existed to accommodate expanding requirements.</div><br/></div></div><div id="40530283" class="c"><input type="checkbox" id="c-40530283" checked=""/><div class="controls bullet"><span class="by">kitkat_new</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525852">parent</a><span>|</span><a href="#40526316">prev</a><span>|</span><a href="#40525627">next</a><span>|</span><label class="collapse" for="c-40530283">[-]</label><label class="expand" for="c-40530283">[1 more]</label></div><br/><div class="children"><div class="content">not drying is technical debt</div><br/></div></div></div></div></div></div><div id="40525627" class="c"><input type="checkbox" id="c-40525627" checked=""/><div class="controls bullet"><span class="by">marcandre</span><span>|</span><a href="#40525468">parent</a><span>|</span><a href="#40525661">prev</a><span>|</span><a href="#40526405">next</a><span>|</span><label class="collapse" for="c-40525627">[-]</label><label class="expand" for="c-40525627">[18 more]</label></div><br/><div class="children"><div class="content">I&#x27;d love examples where DRY can really hurt performance. Typically what matters most in terms of performance is the algorithm used, and that won&#x27;t change.<p>More importantly, cleverer people than me said &quot;premature optimization is the root of all evil&quot;</div><br/><div id="40525880" class="c"><input type="checkbox" id="c-40525880" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525708">next</a><span>|</span><label class="collapse" for="c-40525880">[-]</label><label class="expand" for="c-40525880">[4 more]</label></div><br/><div class="children"><div class="content">This quote is often taken out of context, here&#x27;s the full quote: &quot;Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.&quot;<p>If you want a specific example look at something that needs to be performant, i.e. in those 3%, let&#x27;s say OpenSSL&#x27;s AES implementation for x86, or some optimized LLM code, you&#x27;ll see the critical performance sections include things that could be reused, but they&#x27;re not.<p>Also the point Knuth is making is don&#x27;t waste time on things that don&#x27;t matter. Overuse of DRY falls squarely into that camp as well. It takes more work and doesn&#x27;t really help. I like Go&#x27;s proverb there of &quot;A little copying is better than a little dependency.&quot;</div><br/><div id="40526431" class="c"><input type="checkbox" id="c-40526431" checked=""/><div class="controls bullet"><span class="by">rgrmrts</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525880">parent</a><span>|</span><a href="#40525708">next</a><span>|</span><label class="collapse" for="c-40526431">[-]</label><label class="expand" for="c-40526431">[3 more]</label></div><br/><div class="children"><div class="content">Knuth was talking about a very specific thing, and the generalization of that quote is a misunderstanding of his point.<p>Source: Donald Knuth on the Lex Fridman podcast, when Lex asks him about that phrase</div><br/><div id="40526466" class="c"><input type="checkbox" id="c-40526466" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40526431">parent</a><span>|</span><a href="#40525708">next</a><span>|</span><label class="collapse" for="c-40526466">[-]</label><label class="expand" for="c-40526466">[2 more]</label></div><br/><div class="children"><div class="content">I wasn&#x27;t aware this was discussed, thanks for the pointer! I&#x27;m curious now what <i>he</i> says he was talking about ;)</div><br/><div id="40531205" class="c"><input type="checkbox" id="c-40531205" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40526466">parent</a><span>|</span><a href="#40525708">next</a><span>|</span><label class="collapse" for="c-40531205">[-]</label><label class="expand" for="c-40531205">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s that segment:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=74RdET79q40" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=74RdET79q40</a></div><br/></div></div></div></div></div></div></div></div><div id="40525708" class="c"><input type="checkbox" id="c-40525708" checked=""/><div class="controls bullet"><span class="by">mikepurvis</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525880">prev</a><span>|</span><a href="#40525725">next</a><span>|</span><label class="collapse" for="c-40525708">[-]</label><label class="expand" for="c-40525708">[1 more]</label></div><br/><div class="children"><div class="content">IMO it hurts developer productivity more than performance, because it introduces indirection and potentially unhelpful abstractions that can obscure what is actually going on and make it harder to understand the code.<p>In raw performance this could manifest as issues with data duplication bloating structures and resulting in cache misses, generic structures expressed in JSON being slower then a purpose-built struct, chasing pointers because of functions buried in polymorphic hierarchies. But I doubt that any of this would really matter in 99% of applications.</div><br/></div></div><div id="40525725" class="c"><input type="checkbox" id="c-40525725" checked=""/><div class="controls bullet"><span class="by">rhdunn</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525708">prev</a><span>|</span><a href="#40525775">next</a><span>|</span><label class="collapse" for="c-40525725">[-]</label><label class="expand" for="c-40525725">[6 more]</label></div><br/><div class="children"><div class="content">Premature optimization is about not making a micro-implementation change (e.g. `++i` vs `i++`) for the sake of percieved performance. You should always measure to identify slow points in expected workloads, profile to identify the actual slow areas, make high-level changes (data structure, algorithm) first, then make more targetted optimizations if needed.<p>In some cases it makes sense, like writing SIMD&#x2F;etc. specific assembly for compression&#x2F;decompression or video&#x2F;audio codecs, but more often than not the readable version is just as good -- especially when compilers can do the optimizations for you.<p>A lot of times I&#x27;ve found performance increases have come from not duplicating work -- e.g. not fetching the same data each time within a loop if it is fixed.</div><br/><div id="40525907" class="c"><input type="checkbox" id="c-40525907" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525725">parent</a><span>|</span><a href="#40525775">next</a><span>|</span><label class="collapse" for="c-40525907">[-]</label><label class="expand" for="c-40525907">[5 more]</label></div><br/><div class="children"><div class="content">Not really. Knuth was talking about putting effort to make a non-critical portion of the software more optimized. He&#x27;s saying put effort into the smaller parts where performance is critical and don&#x27;t worry about the rest. It&#x27;s not about `++i` vs. `i++` (which is semantically different but otherwise in modern compilers not an optimization anyways but I digress).</div><br/><div id="40526152" class="c"><input type="checkbox" id="c-40526152" checked=""/><div class="controls bullet"><span class="by">rhdunn</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525907">parent</a><span>|</span><a href="#40526124">next</a><span>|</span><label class="collapse" for="c-40526152">[-]</label><label class="expand" for="c-40526152">[3 more]</label></div><br/><div class="children"><div class="content">That was my point, though. Don&#x27;t worry about minor possible changes to the code where the performance doesn&#x27;t matter. For example, if the ++i&#x2F;i++ is only ever executed at most 10 times in a loop, is on an integer (where the compiler can elide the semantic difference) and the body of the loop is 100x slower than that.<p>If you measure the code&#x27;s performance and see the ++i&#x2F;i++ is consuming a lot of the CPU time then by all means change it, but 99% of the time don&#x27;t worry about it. Even better, create a benchmark to test the code performance and choose the best variant.</div><br/><div id="40526407" class="c"><input type="checkbox" id="c-40526407" checked=""/><div class="controls bullet"><span class="by">nsguy</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40526152">parent</a><span>|</span><a href="#40526124">next</a><span>|</span><label class="collapse" for="c-40526407">[-]</label><label class="expand" for="c-40526407">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not my interpretation. If you&#x27;re profiling and benchmarking you&#x27;re already engaging in (premature) optimization. This process you&#x27;re describing of finding out whether `i++` is taking a lot of CPU time and then changing it is exactly what Knuth is saying not to worry about for 97% of your code. Knuth is saying it doesn&#x27;t matter if `i++` is slow if it&#x27;s in a non-performance critical part of your code. Any large piece of software has many parts where it doesn&#x27;t matter for any practical purpose how fast they run and certainly one loop in that piece of software doesn&#x27;t matter. For example, the software I&#x27;m working on these days has some fast C code and then a pile of slow Python code. In your analogy all the Python code is known to be much slower than the C code, we don&#x27;t need a profiler or benchmarks to tell that, but it also doesn&#x27;t matter because the core performant functionality is in that C code.</div><br/><div id="40526666" class="c"><input type="checkbox" id="c-40526666" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40526407">parent</a><span>|</span><a href="#40526124">next</a><span>|</span><label class="collapse" for="c-40526666">[-]</label><label class="expand" for="c-40526666">[1 more]</label></div><br/><div class="children"><div class="content">Knuth says forget about <i>small</i> efficiencies in 97% of your code. Indeed, the `i++` optimization isn&#x27;t apt to make more than a small difference, even with the most naive compiler, but other decisions could lead to larger chasms. It seems he is still in favour of optimizing for the big wins across the entire codebase, even if it doesn&#x27;t really matter in practice.<p>But it&#x27;s your life to live. Who cares what someone else thinks?</div><br/></div></div></div></div></div></div><div id="40526124" class="c"><input type="checkbox" id="c-40526124" checked=""/><div class="controls bullet"><span class="by">ummonk</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525907">parent</a><span>|</span><a href="#40526152">prev</a><span>|</span><a href="#40525775">next</a><span>|</span><label class="collapse" for="c-40526124">[-]</label><label class="expand" for="c-40526124">[1 more]</label></div><br/><div class="children"><div class="content">The optimizations he was talking about were things like writing in assembly or hand-unrolling loops. It was assumed that you’ve already picked an performant algorithm &#x2F; architecture and are writing in a performant low level language like C.<p>Also, your digression about modern compilers is irrelevant to the context of the quote, since Knuth talked about premature optimization at a time when compilers were much simpler than today.</div><br/></div></div></div></div></div></div><div id="40525775" class="c"><input type="checkbox" id="c-40525775" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525725">prev</a><span>|</span><a href="#40526685">next</a><span>|</span><label class="collapse" for="c-40525775">[-]</label><label class="expand" for="c-40525775">[1 more]</label></div><br/><div class="children"><div class="content">In the general case, it usually depends on the latency of what you&#x27;d DRY your code to vs the latency of keeping the implementation local and specialized.<p>If you&#x27;re talking about consolidating some code from one in-process place to another in the same language, you&#x27;re mostly right: there&#x27;s only going to be an optimization&#x2F;performance concern when you have a very specific hotspot -- at which point you can selectively break the rule, following the guidance you quoted. This need for rule-breaking can turn out to be common in high-performance projects like audio, graphics, etc but is probably not what the GP had in mind.<p>In many environments, though, DRY&#x27;ing can mean moving some implementation to some out-of-language&#x2F;runtime, out-of-process. or even out-of-instance service.<p>For many workloads, the overhead of making a bridged, IPC, or network call swamps your algorithm choice and this is often apparent immediately during design&#x2F;development time. It&#x27;s not premature optimization to say &quot;we&#x27;ll do a lot better to process these records locally using this contextually tuned approach than we will calling that service way out over there, even if the service can handle large&#x2F;different loads more efficiently&quot;. It&#x27;s just common sense. This happens <i>a lot</i> in some teams&#x2F;organizations&#x2F;projects.</div><br/></div></div><div id="40526685" class="c"><input type="checkbox" id="c-40526685" checked=""/><div class="controls bullet"><span class="by">xiasongh</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525775">prev</a><span>|</span><a href="#40525815">next</a><span>|</span><label class="collapse" for="c-40526685">[-]</label><label class="expand" for="c-40526685">[1 more]</label></div><br/><div class="children"><div class="content">This might not be a perfect example, but there&#x27;s a paper by Michael Stonebraker &quot;One size fits all&quot;: an idea whose time has come and gone<p>It might not specifically be DRY, but still related generic vs specialized code&#x2F;systems.<p><a href="https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;1410100" rel="nofollow">https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;1410100</a></div><br/></div></div><div id="40525815" class="c"><input type="checkbox" id="c-40525815" checked=""/><div class="controls bullet"><span class="by">eyelidlessness</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40526685">prev</a><span>|</span><a href="#40525805">next</a><span>|</span><label class="collapse" for="c-40525815">[-]</label><label class="expand" for="c-40525815">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d love examples where DRY can really hurt performance.<p>A really common example is overhead of polymorphism, although that overhead can vary a lot between stacks. Another is just <i>the effect</i> caused by the common complaint about premature abstraction: proliferation of options&#x2F;special cases, which add overhead to every case even when they don’t apply.</div><br/><div id="40530294" class="c"><input type="checkbox" id="c-40530294" checked=""/><div class="controls bullet"><span class="by">kitkat_new</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525815">parent</a><span>|</span><a href="#40525805">next</a><span>|</span><label class="collapse" for="c-40530294">[-]</label><label class="expand" for="c-40530294">[1 more]</label></div><br/><div class="children"><div class="content">use compile time polymorphism<p>premature abstraction -&gt; not understood dry (<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40525064#40525690">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40525064#40525690</a>)</div><br/></div></div></div></div><div id="40525805" class="c"><input type="checkbox" id="c-40525805" checked=""/><div class="controls bullet"><span class="by">laborcontract</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525815">prev</a><span>|</span><a href="#40525770">next</a><span>|</span><label class="collapse" for="c-40525805">[-]</label><label class="expand" for="c-40525805">[1 more]</label></div><br/><div class="children"><div class="content">Langchain. Helps on the initial productivity, is a nightmare on the debugging and performance improvement end.</div><br/></div></div><div id="40525770" class="c"><input type="checkbox" id="c-40525770" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40525468">root</a><span>|</span><a href="#40525627">parent</a><span>|</span><a href="#40525805">prev</a><span>|</span><a href="#40526405">next</a><span>|</span><label class="collapse" for="c-40525770">[-]</label><label class="expand" for="c-40525770">[1 more]</label></div><br/><div class="children"><div class="content">In an effort to DRY, you add a bunch of if statements to handle every use case.</div><br/></div></div></div></div><div id="40526405" class="c"><input type="checkbox" id="c-40526405" checked=""/><div class="controls bullet"><span class="by">jprete</span><span>|</span><a href="#40525468">parent</a><span>|</span><a href="#40525627">prev</a><span>|</span><a href="#40525746">next</a><span>|</span><label class="collapse" for="c-40526405">[-]</label><label class="expand" for="c-40526405">[1 more]</label></div><br/><div class="children"><div class="content">I agree for very specific situations, but compilers tend to get better at optimization over time, and it can be better to express plain intent in the code and leave low-level optimization to the compiler, rather than optimizing in code and leaving future hardware&#x2F;compiler improvements on the table.</div><br/></div></div><div id="40526089" class="c"><input type="checkbox" id="c-40526089" checked=""/><div class="controls bullet"><span class="by">sys_64738</span><span>|</span><a href="#40525468">parent</a><span>|</span><a href="#40525746">prev</a><span>|</span><a href="#40532313">next</a><span>|</span><label class="collapse" for="c-40526089">[-]</label><label class="expand" for="c-40526089">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Generality can really hurt performance.<p>Only in critical regions of code though.</div><br/></div></div></div></div><div id="40532313" class="c"><input type="checkbox" id="c-40532313" checked=""/><div class="controls bullet"><span class="by">surfingdino</span><span>|</span><a href="#40525468">prev</a><span>|</span><a href="#40531606">next</a><span>|</span><label class="collapse" for="c-40532313">[-]</label><label class="expand" for="c-40532313">[1 more]</label></div><br/><div class="children"><div class="content">It sometimes takes time to discover the best approach to writing code that handles similar inputs. I once worked on an ingestion pipeline that was supposed to clean up data sent to us by a person whose sole job was to sit in front of a Windows PC running three pieces of software:<p>a) a terminal running a text mode app extracting data from a mainframe<p>b) Excel<p>c) Outlook<p>Their sole job was to copy data from the terminal, paste it into Excel on a daily basis, save it as a CSV file, and send it as an attachment to the address monitored by a script that was responsible to running data processing pipeline. Because of the manual nature of the job and the way data was presented in the terminal there were errors, which were really unpredictable. I was not allowed to talk to the person doing this job or visit them in their office so it took me three months to find out that what was shown on the terminal screen was essentially a 80x25 version of a punchcard and that position of the fields mattered. Sometimes the user would not copy the whole screen, sometimes there would be an extra character added while pasting data into Excel (not always a stray &quot;v&quot;), sometimes a gremlin character would be added between the mainframe and the terminal (there must have been a serial connection somewhere). Forget proper encoding, JSON or XML, it was raw data, really raw. When I started working on the pipeline it would break on every incorrectly formatted record, when I finished the job and left it was only barfing on 5% bad records and those that it could not process would be neatly put aside an emailed to the support people responsible for  dealing with this client. There was a lot of repetition initially, but I then discovered patterns (random offsets, encoding errors, extra characters) and that allowed me to build a set of generic classes to quickly implement problem-specific handlers.</div><br/></div></div><div id="40531606" class="c"><input type="checkbox" id="c-40531606" checked=""/><div class="controls bullet"><span class="by">nfw2</span><span>|</span><a href="#40532313">prev</a><span>|</span><a href="#40527046">next</a><span>|</span><label class="collapse" for="c-40531606">[-]</label><label class="expand" for="c-40531606">[1 more]</label></div><br/><div class="children"><div class="content">The main benefit of abstraction isn&#x27;t to reduce keystrokes; it&#x27;s to break a program into comprehensible chunks of operation.<p>Routines that are conceptually identical should share an abstraction. A concept might benefit from an abstraction even if it is only used once. It is never too early to add more intuitive abstractions to your code.<p>On the other hand, code that is only coincidentally similar in execution should never be forced to share an abstraction.</div><br/></div></div><div id="40527046" class="c"><input type="checkbox" id="c-40527046" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#40531606">prev</a><span>|</span><a href="#40525645">next</a><span>|</span><label class="collapse" for="c-40527046">[-]</label><label class="expand" for="c-40527046">[3 more]</label></div><br/><div class="children"><div class="content">The term &quot;DRY&quot; as commonly used conflates distinct situations and objectives that should be handled differently in most cases.<p>There is the &quot;single source of truth&quot; problem where you need to compute something exactly the same way at all points in the software that need to compute that thing. In these cases you really want a single library implementation so that the meaning of that computation does not accidentally diverge over time since there is a single implementation to maintain.<p>There is the &quot;reuse behaviors in unrelated contexts&quot; problem where you want to create implementations of common useful behaviors that can be abstracted over many use cases, often in the context of data structures and algorithms. In these cases you really want generics and metaprogramming to codegen a context-specific implementation rather than sharing a single implementation with a spaghetti mess of conditionals.<p>DRY works best when it fits neatly and exclusively into one of these two categories. Cases that fit in neither category, such as the practice of decomposing every non-trivial function into a bunch of micro-functions that call each other, are virtually always a maintenance nightmare for no obvious benefit. Cases that fit into both categories, such as expansive metaprogramming libraries, become difficult to maintain by virtue of the combinatorial explosion of possible implementations that might be generated across the allowable parameter space -- the cognitive overhead grows exponentially for what is often a linear increase in value.</div><br/><div id="40527448" class="c"><input type="checkbox" id="c-40527448" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#40527046">parent</a><span>|</span><a href="#40527607">next</a><span>|</span><label class="collapse" for="c-40527448">[-]</label><label class="expand" for="c-40527448">[1 more]</label></div><br/><div class="children"><div class="content">&gt; such as the practice of decomposing every non-trivial function into a bunch of micro-functions that call each other,<p>That has approximately nothing to do with DRY. At best it might technically be a violation of DRY if (and only if) some of those micro-functions are identical, but the correct way to fix that is to recompose them into the non-trivial (and non-repeated) functions they&#x27;re more usefully expressed as. And more often it&#x27;s just a totally independent refucktoring that makes the codbase worse entirely orthogonally to &#x27;DRY-ness&#x27;.</div><br/></div></div><div id="40527607" class="c"><input type="checkbox" id="c-40527607" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40527046">parent</a><span>|</span><a href="#40527448">prev</a><span>|</span><a href="#40525645">next</a><span>|</span><label class="collapse" for="c-40527607">[-]</label><label class="expand" for="c-40527607">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp works well for the second case. But it seems that some programmers are uncomfortable with the notion of code generating code. And as you said, it does require discipline as you need to focus the language&#x27;s power. Other languages don&#x27;t let you solve the boilerplate problem so readily. Instead you have a mess of utility functions or a huge class tree.</div><br/></div></div></div></div><div id="40525645" class="c"><input type="checkbox" id="c-40525645" checked=""/><div class="controls bullet"><span class="by">renegade-otter</span><span>|</span><a href="#40527046">prev</a><span>|</span><a href="#40531053">next</a><span>|</span><label class="collapse" for="c-40525645">[-]</label><label class="expand" for="c-40525645">[3 more]</label></div><br/><div class="children"><div class="content">I think the only hard and fast rule is to DRY the code that will introduce a bug if you change it in one place and not the other. And if it will, <i>at least</i> do a fat comment in both places for posterity.<p>Whenever I have to have a &quot;mental model&quot; of the code, I know I screwed up.</div><br/><div id="40525919" class="c"><input type="checkbox" id="c-40525919" checked=""/><div class="controls bullet"><span class="by">senkora</span><span>|</span><a href="#40525645">parent</a><span>|</span><a href="#40526912">next</a><span>|</span><label class="collapse" for="c-40525919">[-]</label><label class="expand" for="c-40525919">[1 more]</label></div><br/><div class="children"><div class="content">+1. If I go with the comment option, then I&#x27;ll sometimes write a comment like &quot;If you change this here, then you must change it everywhere with this tag: UNIQUE-TAG&quot;.<p>This way, the reader can just do a global grep to find all the places to change, and you don&#x27;t have to list them in each place and keep them in sync.</div><br/></div></div><div id="40526912" class="c"><input type="checkbox" id="c-40526912" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#40525645">parent</a><span>|</span><a href="#40525919">prev</a><span>|</span><a href="#40531053">next</a><span>|</span><label class="collapse" for="c-40526912">[-]</label><label class="expand" for="c-40526912">[1 more]</label></div><br/><div class="children"><div class="content">A comment is a nice addition, but the very least is to ensure that your test suite properly covers cases where changing one and not the other will introduce a problem. This not only ensures that both are changed, but that both are changed in the way they need to be. A comment alone may prompt you to change both (if you ever read it - I bet a lot of developers don&#x27;t), but you may not notice when you fail to change them in the same way, which is no better than not changing one.</div><br/></div></div></div></div><div id="40531053" class="c"><input type="checkbox" id="c-40531053" checked=""/><div class="controls bullet"><span class="by">poikroequ</span><span>|</span><a href="#40525645">prev</a><span>|</span><a href="#40527485">next</a><span>|</span><label class="collapse" for="c-40531053">[-]</label><label class="expand" for="c-40531053">[1 more]</label></div><br/><div class="children"><div class="content">I still practice DRY, but I try to not overdo it with unnecessary abstractions. More recently I&#x27;ve been practicing SPOT (Single Point of Truth). I interpret this in two ways. One, every piece of data should have a location that reigns over all others. It&#x27;s okay to have duplicates of the data, such as caches, but any copies of that data should be treated as ephemeral and possibly inconsistent with the source of truth. Second, there is some overlap with DRY where some logic that answers a question or computes a result should not be duplicates. A specific function or class which computes something important, should probably not be duplicates, but implemented once and reused. A great example is authentication, you most likely should not duplicate code that checks whether a user is authorized to do something. In a sense, the code which computes whether a user is authorized in itself becomes a &quot;source of truth&quot;.<p>There are still good reasons to DRY early on. Actions that need to be performed synchronously, rather than acquiring the same lock in several places, consolidate your code so you&#x27;re so there&#x27;s at most a few places you acquire and release that lock. Cache invalidation, having a single class for reading and writing some piece of data makes it much easier to keep the cache consistent.</div><br/></div></div><div id="40527485" class="c"><input type="checkbox" id="c-40527485" checked=""/><div class="controls bullet"><span class="by">kag0</span><span>|</span><a href="#40531053">prev</a><span>|</span><a href="#40526195">next</a><span>|</span><label class="collapse" for="c-40527485">[-]</label><label class="expand" for="c-40527485">[1 more]</label></div><br/><div class="children"><div class="content">In my experience DRY and many (any?) other coding principles are only problematic when misused. They&#x27;re typically misused because the user doesn&#x27;t understand the motivation or underlying value of the principle in the first place.<p>I think the example in the article does a bit of that as well. The example sets a deadline on a thing (a task or payment) by validating the deadline against the current time, and then presumably doing something else that isn&#x27;t shown. The article argues that in the future a task might have different validation requirements than a payment, and they&#x27;re only coincidentally the same today; so it would be foolish to abstract the deadline setting logic today.   
BUT, the reality is that the real coincidence is that payments and tasks have the same set of validations, not that the logic to validate a deadline is coincidentally the same. In my opinion &quot;good&quot; code would be fine to have separate set_task_deadline and set_payment_deadline methods, but only one validate_deadline_is_in_future (or whatever) method, alongside other validation methods which can be called as appropriate by each set_x_deadline implementation.<p>Disclaimer: the code is so short and trivial that it doesn&#x27;t matter, I think we can all assume that this concept is extrapolated onto a bigger problem.</div><br/></div></div><div id="40526195" class="c"><input type="checkbox" id="c-40526195" checked=""/><div class="controls bullet"><span class="by">watters</span><span>|</span><a href="#40527485">prev</a><span>|</span><a href="#40526010">next</a><span>|</span><label class="collapse" for="c-40526195">[-]</label><label class="expand" for="c-40526195">[2 more]</label></div><br/><div class="children"><div class="content">This reads like a paraphrase of this widely circulated post from 8 years ago…<p><a href="https:&#x2F;&#x2F;sandimetz.com&#x2F;blog&#x2F;2016&#x2F;1&#x2F;20&#x2F;the-wrong-abstraction" rel="nofollow">https:&#x2F;&#x2F;sandimetz.com&#x2F;blog&#x2F;2016&#x2F;1&#x2F;20&#x2F;the-wrong-abstraction</a></div><br/><div id="40528246" class="c"><input type="checkbox" id="c-40528246" checked=""/><div class="controls bullet"><span class="by">dmeijboom</span><span>|</span><a href="#40526195">parent</a><span>|</span><a href="#40526010">next</a><span>|</span><label class="collapse" for="c-40528246">[-]</label><label class="expand" for="c-40528246">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I was looking for this blog post for a while now</div><br/></div></div></div></div><div id="40526010" class="c"><input type="checkbox" id="c-40526010" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#40526195">prev</a><span>|</span><a href="#40532430">next</a><span>|</span><label class="collapse" for="c-40526010">[-]</label><label class="expand" for="c-40526010">[1 more]</label></div><br/><div class="children"><div class="content">Like the article ends with, DRY goes hand in hand with YAGNI. The point isn&#x27;t to build a million abstractions; it&#x27;s to find the places where you have duplication and de-duplicate it, or where you know there&#x27;ll be duplication and abstract it, or to simply rearchitect&#x2F;redesign to avoid complexity and duplication. This applies to code, data models, interfaces, etc.<p>The duplication is typically bad because it leads to inconsistency which leads to bugs. If your code is highly cohesive and loosely coupled, this is less likely [across independent components].<p>And on this:<p>&gt; When designing abstractions, do not prematurely couple behaviors<p>Don&#x27;t <i>ever</i> couple behaviors, unless it&#x27;s within the same component. Keep your code highly cohesive and loosely coupled. Once it&#x27;s complete, wall it off from the other components with a loosely-coupled interface. Even if that means repeating yourself. But don&#x27;t let anyone make the mistake of thinking they both work the same because they have similar-looking interfaces or behaviors, or you will be stuck again in the morass of low cohesion. This is probably one of the 3 biggest problems in software design.<p>Libraries are a great help here, but libraries <i>must</i> be both backwards compatible, and not tightly coupled. Lack of backwards compatibility is probably the 4th biggest problem...</div><br/></div></div><div id="40532430" class="c"><input type="checkbox" id="c-40532430" checked=""/><div class="controls bullet"><span class="by">janaagaard</span><span>|</span><a href="#40526010">prev</a><span>|</span><a href="#40528776">next</a><span>|</span><label class="collapse" for="c-40532430">[-]</label><label class="expand" for="c-40532430">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t use DRY but WET: Write Everything Twice. :o)<p>In practice: The second time you implement something, start out by copy-pasting the first implementation. Once you&#x27;re done with the second version, figure out if and how to abstract the two implementations.</div><br/></div></div><div id="40528776" class="c"><input type="checkbox" id="c-40528776" checked=""/><div class="controls bullet"><span class="by">bbwbsb</span><span>|</span><a href="#40532430">prev</a><span>|</span><a href="#40529181">next</a><span>|</span><label class="collapse" for="c-40528776">[-]</label><label class="expand" for="c-40528776">[1 more]</label></div><br/><div class="children"><div class="content">I prefer: do the thing when doing so reduces the expected cost of (time-discounted) future outcomes by more than the expected utility of the next best thing you can do now.<p>The problem with DRY occurs when it contravenes this principal - when deduplication is too expensive and&#x2F;or unlikely to decrease the cost of future mutations enough to be worth it.<p>The proposed problem isn&#x27;t a binary - that you should or shouldn&#x27;t make the assumption yet - but rather that the assumption has a cost based on what you believe is likely to occur in the future and the value produced by making the assumption now needs to outweigh the cost.</div><br/></div></div><div id="40529181" class="c"><input type="checkbox" id="c-40529181" checked=""/><div class="controls bullet"><span class="by">TedDallas</span><span>|</span><a href="#40528776">prev</a><span>|</span><a href="#40530536">next</a><span>|</span><label class="collapse" for="c-40529181">[-]</label><label class="expand" for="c-40529181">[2 more]</label></div><br/><div class="children"><div class="content">DRY is more about support and maintenance than anything else.<p>I see a lot of attacks on DRY these days, and it boggles my mind. Maybe it is being conflated with over-engineering&#x2F;paramterization&#x2F;architecting. I don&#x27;t know.<p>But I do know that having to fix the same bug twice in the same code base is not a good look.</div><br/><div id="40529189" class="c"><input type="checkbox" id="c-40529189" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40529181">parent</a><span>|</span><a href="#40530536">next</a><span>|</span><label class="collapse" for="c-40529189">[-]</label><label class="expand" for="c-40529189">[1 more]</label></div><br/><div class="children"><div class="content">It’s not that. It’s when you need to change how the function behaves but for only one of the callers.</div><br/></div></div></div></div><div id="40530536" class="c"><input type="checkbox" id="c-40530536" checked=""/><div class="controls bullet"><span class="by">esprehn</span><span>|</span><a href="#40529181">prev</a><span>|</span><a href="#40531927">next</a><span>|</span><label class="collapse" for="c-40530536">[-]</label><label class="expand" for="c-40530536">[1 more]</label></div><br/><div class="children"><div class="content">This is one of my favorite principles, don&#x27;t try to make the codebase &quot;too DRY&quot; . I often see it cause stress and complexity in platform or infra teams trying to support large communities of developers.<p>It&#x27;s right to be concerned that a bunch of teams might be a wasting time implementing the same thing slightly differently, or that you&#x27;ll end up fixing the same bug across all these &quot;copies&quot;.<p>Often that kind of duplication is good for the business though, and the platform team doesn&#x27;t have the insight to see all the divergent requirements on the horizon. Letting the teams innovate separately without having to coordinate changes in all these DRY-ied up systems can be the best way to support them.<p>Or even more abstractly, zero codebase chaos is not the optimal amount.</div><br/></div></div><div id="40531927" class="c"><input type="checkbox" id="c-40531927" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#40530536">prev</a><span>|</span><a href="#40531626">next</a><span>|</span><label class="collapse" for="c-40531927">[-]</label><label class="expand" for="c-40531927">[1 more]</label></div><br/><div class="children"><div class="content">People focus too much on DRY and not enough on modularisation.<p>If your functions do everything, DRYing them can be awkward and ineffective. If you stop injecting your business logic into every line and attempt to create &quot;pure&quot; functions, it&#x27;s so much easier to sprinkle the occasional `if(input.type2) pow(input, 2)` in the business part.<p>If your codebase isn&#x27;t at least 20% &quot;utils&quot;, I don&#x27;t want to touch it. I regularly dip into code I wrote months&#x2F;years back and reuse it without much thought.</div><br/></div></div><div id="40531626" class="c"><input type="checkbox" id="c-40531626" checked=""/><div class="controls bullet"><span class="by">vizualbod</span><span>|</span><a href="#40531927">prev</a><span>|</span><a href="#40530439">next</a><span>|</span><label class="collapse" for="c-40531626">[-]</label><label class="expand" for="c-40531626">[1 more]</label></div><br/><div class="children"><div class="content">Domain knowledge is just as important when programming as the craft itself, this is why I  have to have a great relationship with subject matter expert and develop domain knowledge fast. So abstractions can be a better fit</div><br/></div></div><div id="40530439" class="c"><input type="checkbox" id="c-40530439" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40531626">prev</a><span>|</span><a href="#40525321">next</a><span>|</span><label class="collapse" for="c-40530439">[-]</label><label class="expand" for="c-40530439">[1 more]</label></div><br/><div class="children"><div class="content">&gt; When I asked him about this, he said, &quot;I have this philosophy that says if you only have two similar things, it&#x27;s best to write separate code for each. Once you get to a third, then you can think about refactoring and making some common code.&quot;<p>There is also the angle of when eventually the third usecase comes out, how much willingness&#x2F;buy-in is going to be there to make changes to the running code for the refactoring?<p>Quite often than not, nobody wants to take the risk for the sake of introducing DRYness and you end up with three copies.</div><br/></div></div><div id="40525321" class="c"><input type="checkbox" id="c-40525321" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40530439">prev</a><span>|</span><a href="#40527204">next</a><span>|</span><label class="collapse" for="c-40525321">[-]</label><label class="expand" for="c-40525321">[31 more]</label></div><br/><div class="children"><div class="content">Not a conclusive example.<p>In the industry code that isn&#x27;t DRY is a much bigger problem than code that is too DRY.</div><br/><div id="40525538" class="c"><input type="checkbox" id="c-40525538" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525377">next</a><span>|</span><label class="collapse" for="c-40525538">[-]</label><label class="expand" for="c-40525538">[4 more]</label></div><br/><div class="children"><div class="content">Having specialized in project rescue, touring all over &quot;the industry&quot;, you can&#x27;t possibly make that generalization.<p>For every purported best practice, there are teams&#x2F;orgs that painted themselves into a corner by getting carried away and others that really would have benefited from applying it more than they did.<p>In the case of DRY, it&#x27;s an especially accessible best practice for inexperienced developers and the project leads many of them become. Many many teams do get carried away, mistaking &quot;these two blocks of code have the same characters in the same sequence&quot; with &quot;these two delicate blocks of code are doing the same thing and will likely continue to do so&quot;<p>Having advice articles floating around on both sides of practices like this helps developers and teams find the guidance that will get them from where they are to where they need to be.<p>Context, nuance, etc, etc</div><br/><div id="40525678" class="c"><input type="checkbox" id="c-40525678" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525538">parent</a><span>|</span><a href="#40526387">next</a><span>|</span><label class="collapse" for="c-40525678">[-]</label><label class="expand" for="c-40525678">[2 more]</label></div><br/><div class="children"><div class="content">If that&#x27;s what they wanted to prove they should have shown a better example.</div><br/><div id="40525822" class="c"><input type="checkbox" id="c-40525822" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525678">parent</a><span>|</span><a href="#40526387">next</a><span>|</span><label class="collapse" for="c-40525822">[-]</label><label class="expand" for="c-40525822">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s fair. I think the insight&#x2F;concept behind the essay is sound, but I agree that the example (and writing) could be a lot better.</div><br/></div></div></div></div><div id="40526387" class="c"><input type="checkbox" id="c-40526387" checked=""/><div class="controls bullet"><span class="by">AnimalMuppet</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525538">parent</a><span>|</span><a href="#40525678">prev</a><span>|</span><a href="#40525377">next</a><span>|</span><label class="collapse" for="c-40526387">[-]</label><label class="expand" for="c-40526387">[1 more]</label></div><br/><div class="children"><div class="content">In Zion National Park, there&#x27;s a hike called Angel&#x27;s Landing.  For part of the hike, you go along this ridge, where on one side you have a cliff of 500 feet straight down, and on the other side, you have a cliff of 1000 feet straight down.  And in places, the ridge is only a couple of feet wide.<p>Best practices can be like that.  &quot;Here&#x27;s something to avoid!&quot;  &quot;OK, I&#x27;ll back far away from that.&quot;  Yeah, but there&#x27;s another cliff behind you, of the opposite error that is also waiting to wreck your code base.<p>Listen to best practices.  Don&#x27;t apply them dogmatically, or without good judgment.</div><br/></div></div></div></div><div id="40525377" class="c"><input type="checkbox" id="c-40525377" checked=""/><div class="controls bullet"><span class="by">znkr</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525538">prev</a><span>|</span><a href="#40525710">next</a><span>|</span><label class="collapse" for="c-40525377">[-]</label><label class="expand" for="c-40525377">[13 more]</label></div><br/><div class="children"><div class="content">I am the industry for over 10 years now. Whenever I have to work with a project where someone used DRY consciously, I know I am in for a world of pain. Consolidating code is easy, pulling it apart is a lot harder.</div><br/><div id="40527770" class="c"><input type="checkbox" id="c-40527770" checked=""/><div class="controls bullet"><span class="by">a1369209993</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40525516">next</a><span>|</span><label class="collapse" for="c-40527770">[-]</label><label class="expand" for="c-40527770">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Whenever I have to work with a project where someone used DRY [<i>]consciously[</i>], I know I am in for a world of pain.<p>Huh. When you put it that way, that&#x27;s actually a good point. In my experience, competent programming will try to consolidate repeated code, and then cite &quot;because DRY&quot; if asked why, but I can&#x27;t think of any case where I or anyone else competent <i>started</i> with &quot;needs more DRY&quot; as the original motivation (as opposed to &quot;this is a incomprehensibly verbose mess&quot; or the like).<p>Conversely, <i>starting</i> with &quot;don&#x27;t repeat yourself [and don&#x27;t let anything else repeat itself]&quot; as a design goal does seem to correlate well with cases where someone temporarily (newbie) or permanently (moron&#x2F;ideologue) incompentent followed that design principle off a cliff.</div><br/></div></div><div id="40525516" class="c"><input type="checkbox" id="c-40525516" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40527770">prev</a><span>|</span><a href="#40528093">next</a><span>|</span><label class="collapse" for="c-40525516">[-]</label><label class="expand" for="c-40525516">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consolidating code is easy, pulling it apart is a lot harder.<p>I absolutely agree with this, and the only thing I would add is that is difference is even more pronounced in codebases using a dynamic language.<p>Sure it&#x27;s not easy to navigate a bowl of duplicated spaghetti, but navigating opaque DRY service classes without explicit types is a <i>nightmare</i>.<p>Luckily as an industry we&#x27;ve realized the benefits of static typing, but your point still holds true there.</div><br/></div></div><div id="40528093" class="c"><input type="checkbox" id="c-40528093" checked=""/><div class="controls bullet"><span class="by">rqtwteye</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40525516">prev</a><span>|</span><a href="#40526746">next</a><span>|</span><label class="collapse" for="c-40528093">[-]</label><label class="expand" for="c-40528093">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Consolidating code is easy, pulling it apart is a lot harder.&quot;<p>My experience is the opposite. The less code, the better. I just spent a week on refactoring UI automation test code where they had copied the same 30 lines of code into almost 100 places. Every time with an ID changed and some slightly different formatting. It took me a few days to figure out that these sections do the same thing so I decided to introduce a function with ID as parameter. It was a lot of work to identify all sections and then to make sure they are really equivalent.<p>Saved us 3000 lines of code and now we can be sure that timeouts and other stuff is handled correctly everywhere. An we can respond to changes quickly.<p>that&#x27;s DRY to me. Don&#x27;t copy&#x2F;paste code. Introduce functions. Ideally in the simplest way. When you have functions, you declare the same behavior everywhere.</div><br/></div></div><div id="40526746" class="c"><input type="checkbox" id="c-40526746" checked=""/><div class="controls bullet"><span class="by">12_throw_away</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40528093">prev</a><span>|</span><a href="#40525414">next</a><span>|</span><label class="collapse" for="c-40526746">[-]</label><label class="expand" for="c-40526746">[1 more]</label></div><br/><div class="children"><div class="content">I basically agree, but doesn&#x27;t this just mean, if I&#x27;m consolidating non-DRY code, that I&#x27;m now the one using DRY consciously, and the next dev will be cursed with all of my newly introduced DRY abstractions?</div><br/></div></div><div id="40525414" class="c"><input type="checkbox" id="c-40525414" checked=""/><div class="controls bullet"><span class="by">actionfromafar</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40526746">prev</a><span>|</span><a href="#40525700">next</a><span>|</span><label class="collapse" for="c-40525414">[-]</label><label class="expand" for="c-40525414">[1 more]</label></div><br/><div class="children"><div class="content">Can concur. Mostly it was I causing the pain, earlier.</div><br/></div></div><div id="40525647" class="c"><input type="checkbox" id="c-40525647" checked=""/><div class="controls bullet"><span class="by">mytailorisrich</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40525428">prev</a><span>|</span><a href="#40526298">next</a><span>|</span><label class="collapse" for="c-40525647">[-]</label><label class="expand" for="c-40525647">[4 more]</label></div><br/><div class="children"><div class="content">How do you consolidate code?<p>Good way to go at it is to isolate the functionality that is used many times and to pull it aside in its own function (or similar). That&#x27;s just good code practice and also makes it easy to refactor and modify as needed.</div><br/><div id="40526767" class="c"><input type="checkbox" id="c-40526767" checked=""/><div class="controls bullet"><span class="by">znkr</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525647">parent</a><span>|</span><a href="#40526298">next</a><span>|</span><label class="collapse" for="c-40526767">[-]</label><label class="expand" for="c-40526767">[3 more]</label></div><br/><div class="children"><div class="content">It’s not about being used many times, but about the necessity to evolve in the same direction. When that happens, it usually manifests as toil for the team. Consolidating code means to change the structure of the code so that only one piece needs to be modified in the future. That can take many forms, but it usually involves creating a new shareable component.<p>Shareable components are more effort to maintain, so just creating them because they consolidate code is not always a good idea. You really want to have positive ROI here and you only get that if you actually reduce maintenance burden. For raw code duplication that doesn’t have a maintenance issue on it‘s own, the bar is a lot higher than most people think.</div><br/><div id="40527331" class="c"><input type="checkbox" id="c-40527331" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40526767">parent</a><span>|</span><a href="#40528055">next</a><span>|</span><label class="collapse" for="c-40527331">[-]</label><label class="expand" for="c-40527331">[1 more]</label></div><br/><div class="children"><div class="content">Well,  this morning I just fixed a case where somebody had used btoa to base64 encode something in Javascript and used methods from Buffer somewhere else because they&#x27;d been intimidated away from using btoa.  (Ok,  it is dirty to use UTF-8 codepoints if it is byte values,  you can write btoa(&quot;Á&quot;) but btoa(&quot;中&quot;) is a crash.)<p>It would have been OK if they&#x27;d used the right methods on Buffer but they didn&#x27;t.<p>These encoding&#x2F;decoding methods are a very good example of code that should be centralized, not least so you can write tests for them.  (It is a favorable case for testing because the inputs and outputs are well defined and there are no questions of whether execution is done like you might encounter testing a React component)  It is so easy to screw this kind of thing up in a gross way or an a subtle way (I&#x27;m pretty sure btoa&#x27;s weirdness doesn&#x27;t affect my application because codepoints &gt; 255 never show up...  I think)<p>There&#x27;s the meme that you should wait until something used 3 times before you copy it but here is a case where two repetitions were too many and it had a clear impact on customers.</div><br/></div></div><div id="40528055" class="c"><input type="checkbox" id="c-40528055" checked=""/><div class="controls bullet"><span class="by">mytailorisrich</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40526767">parent</a><span>|</span><a href="#40527331">prev</a><span>|</span><a href="#40526298">next</a><span>|</span><label class="collapse" for="c-40528055">[-]</label><label class="expand" for="c-40528055">[1 more]</label></div><br/><div class="children"><div class="content">Raw code duplication is always a maintenance issue when centralising it when you notice the duplication (instead of keeping copy-pasting it) costs nothing.</div><br/></div></div></div></div></div></div><div id="40526298" class="c"><input type="checkbox" id="c-40526298" checked=""/><div class="controls bullet"><span class="by">EugeneOZ</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525377">parent</a><span>|</span><a href="#40525647">prev</a><span>|</span><a href="#40525710">next</a><span>|</span><label class="collapse" for="c-40526298">[-]</label><label class="expand" for="c-40526298">[1 more]</label></div><br/><div class="children"><div class="content">I have 20 years in the industry and one of the rules I learned is: Articles justifying laziness are ALWAYS warmly welcomed and praised.<p>To get internet points easily, write something of that:<p>“Clean code is overrated”<p>“SOLID is holding you back”<p>“Tests are less important than profits”<p>“KISS is the only important principle”<p>“Declarative programming is only suitable for pet projects”<p>“Borrow checker is the plague of Rust”<p>and so on.</div><br/></div></div></div></div><div id="40525710" class="c"><input type="checkbox" id="c-40525710" checked=""/><div class="controls bullet"><span class="by">jeltz</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525377">prev</a><span>|</span><a href="#40528618">next</a><span>|</span><label class="collapse" for="c-40525710">[-]</label><label class="expand" for="c-40525710">[2 more]</label></div><br/><div class="children"><div class="content">Not from my experience. Unnecessarily duplicated code, even when there are small differences which are likely accidental, is usually much easier to fix than too DRY code. Pulling apart false sharing can be really hard.</div><br/><div id="40530320" class="c"><input type="checkbox" id="c-40530320" checked=""/><div class="controls bullet"><span class="by">kitkat_new</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525710">parent</a><span>|</span><a href="#40528618">next</a><span>|</span><label class="collapse" for="c-40530320">[-]</label><label class="expand" for="c-40530320">[1 more]</label></div><br/><div class="children"><div class="content">example?
duplicating (literally copy paste) is easier than even finding duplicated code with small differences.</div><br/></div></div></div></div><div id="40528618" class="c"><input type="checkbox" id="c-40528618" checked=""/><div class="controls bullet"><span class="by">barryrandall</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525710">prev</a><span>|</span><a href="#40525413">next</a><span>|</span><label class="collapse" for="c-40528618">[-]</label><label class="expand" for="c-40528618">[1 more]</label></div><br/><div class="children"><div class="content">The number of person-hours wasted on over-engineered products that never even made it to release could have: solved the halting problem, delivered AGI v2.0, made C memory-safe without compromising backward-compatibility, or made it easy to adjust mouse pointer speed on Linux.</div><br/></div></div><div id="40525413" class="c"><input type="checkbox" id="c-40525413" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40528618">prev</a><span>|</span><a href="#40525397">next</a><span>|</span><label class="collapse" for="c-40525413">[-]</label><label class="expand" for="c-40525413">[3 more]</label></div><br/><div class="children"><div class="content">In your part of the industry, perhaps. My experience has been the opposite.</div><br/><div id="40525640" class="c"><input type="checkbox" id="c-40525640" checked=""/><div class="controls bullet"><span class="by">ravenstine</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525413">parent</a><span>|</span><a href="#40525397">next</a><span>|</span><label class="collapse" for="c-40525640">[-]</label><label class="expand" for="c-40525640">[2 more]</label></div><br/><div class="children"><div class="content">Same.  From what I&#x27;ve seen, most code is written with abstractions and DRY as a high priority rather than writing code that is performant and doesn&#x27;t take jumping between 5 different files to make sense of it.</div><br/><div id="40526335" class="c"><input type="checkbox" id="c-40526335" checked=""/><div class="controls bullet"><span class="by">danielmarkbruce</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525640">parent</a><span>|</span><a href="#40525397">next</a><span>|</span><label class="collapse" for="c-40526335">[-]</label><label class="expand" for="c-40526335">[1 more]</label></div><br/><div class="children"><div class="content">I started writing Go around 2012 or so because of the file jumping thing. Drove me nuts. I&#x27;m sure there were many folks doing the same thing.</div><br/></div></div></div></div></div></div><div id="40525397" class="c"><input type="checkbox" id="c-40525397" checked=""/><div class="controls bullet"><span class="by">nkozyra</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525413">prev</a><span>|</span><a href="#40525528">next</a><span>|</span><label class="collapse" for="c-40525397">[-]</label><label class="expand" for="c-40525397">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In the industry code that isn&#x27;t DRY is a much bigger problem than code that is too DRY.<p>As with anything dogmatic, it truly depends. There are times when the abstraction cost isn&#x27;t worth it for a few semi-duplicate implementations you want to combine into a single every-edge-case function&#x2F;method.</div><br/><div id="40525652" class="c"><input type="checkbox" id="c-40525652" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525397">parent</a><span>|</span><a href="#40525528">next</a><span>|</span><label class="collapse" for="c-40525652">[-]</label><label class="expand" for="c-40525652">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a certain psychological attraction to messy and confused situations which people are just too comfortable with but it explains why things like GraphQL (didn&#x27;t have a definition for how it worked for years because &quot;Facebook is going to return whatever it wants to return&quot;) inevitably win out over SPARQL (which has a well-defined algebra).<p>One of my biggest gripes (related to the post) is the data structure<p><pre><code>   create table student (
      ...
      applied_date                         datetime,
      transcript_received                  datetime,
      recommendation_letter1_received      datetime,
      recommendation_letter2_received      datetime,
      rejected_date                        datetime,
      accepted_date                        datetime,
      started_classes_date                 datetime,
      suspended_date                       datetime,
      leave_of_absence_start_date          datetime,
      leave_of_absence_end_date            datetime,
      ...
      graduated_date                       datetime,
      ...
      gave_money_date                      datetime,
      died_date                            datetime
   )
</code></pre>
which is of course an academic example but that I&#x27;ve seen in many kind of e-business application.  Nobody ever seems to think of it until later but two obvious requirements are:  (1) query to see what state a user was in at a given time,  (2) show the history of a given user.  The code to do that in the above is highly complex and will change every time a new state gets added.  The customer also has experiences like &quot;we had a student who took two leaves of absence&quot; or &quot;some students apply,  get rejected,  apply again,  then get accepted&quot;  When you find data designs like this you also tend to find some of the records are corrupted and when you are recovering the history of users there will be some you&#x27;ll never get right.<p>If you think before you code you might settle on this design<p><pre><code>    create table history (
       student_id                         integer primary key,
       status                             integer not null,
       begin_date                         datetime not null,
       end_date                           datetime
    )
</code></pre>
which solves the above problems and many others in most situations.  (For one thing the obvious queries are trivial and event complex queries about times and events can be written with the better schema.)  I can&#x27;t decide if the thing I hate the most about being a programmer is having to clean up messes like the above or having to argue with other developers about why the first example is wrong.<p>If &quot;No code&quot; is to really be revolutionary it&#x27;s going to have to have built-in ontologies so that programmers get correct data structures for situations like the above that show up everyday in everyday bizaps where there is a clear right answer but it is usually ignored.</div><br/><div id="40526092" class="c"><input type="checkbox" id="c-40526092" checked=""/><div class="controls bullet"><span class="by">gls2ro</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525652">parent</a><span>|</span><a href="#40525528">next</a><span>|</span><label class="collapse" for="c-40526092">[-]</label><label class="expand" for="c-40526092">[2 more]</label></div><br/><div class="children"><div class="content">Two points here just for fine grain discussion:<p>1. The first table structure is a flat non-normalized table structure that trades normalization for easy to query and select computed properties<p>2. Second structure is a normalized table structure that trades the normalization for joins.</div><br/><div id="40527132" class="c"><input type="checkbox" id="c-40527132" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40526092">parent</a><span>|</span><a href="#40525528">next</a><span>|</span><label class="collapse" for="c-40527132">[-]</label><label class="expand" for="c-40527132">[1 more]</label></div><br/><div class="children"><div class="content">Either one is normalized so far as I know.<p>It is easy to write a query for the first that gets a list of students names and the dates they applied.  That query is harder for the second one.  On the other hand figuring out what state a user was in at time <i>t</i> could be a very hard problem with the first table.<p>My experience with the first is that you find corrupted data records,  one cause of that will be that people will cut and paste the SQL queries so maybe 10% of the time they wind up updating the wrong date.  Systems like that also seem to have problems with data entry mistakes.<p>The biggest advantage of #2 is ontological and not operational,  which is that in a business process an item is usually in exactly one state out of a certain set of possible states.  Turns out that this invariant influences the set of reasonable requirements that people could write, the subconscious expectations of what users expect, needs to be implicitly followed by an application,  etc.<p>Granted some of the dates I listed up there don&#x27;t quite correspond to a state change,  for instance the system needs to keep track of when a student started an application and when the last document (transcripts, letters, etc.) has been received.  With 5 documents you would have 32 possible states of received or not and that&#x27;s unreasonable,  particularly considering that a student with just one letter and a very strong application in every other way might get accepted despite that.  It&#x27;s fair to say the student can have an &quot;open application&quot; and a &quot;complete application&quot;.  Similarly you could say the construction of an airplane or a nuclear power plant can be defined by several major phases but that these systems have many parts installed so if the left engine is installed but the right engine is not installed these are properties of the left and right engine as opposed to the plane.</div><br/></div></div></div></div></div></div></div></div><div id="40525528" class="c"><input type="checkbox" id="c-40525528" checked=""/><div class="controls bullet"><span class="by">ldjkfkdsjnv</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525397">prev</a><span>|</span><a href="#40525488">next</a><span>|</span><label class="collapse" for="c-40525528">[-]</label><label class="expand" for="c-40525528">[1 more]</label></div><br/><div class="children"><div class="content">Abstraction too early is usually a mistake, no one is smart enough to predict all the possible edge cases. Repeated code allows someone to go in there and add an edge case easily. Its a more fool proof way of programming</div><br/></div></div><div id="40525488" class="c"><input type="checkbox" id="c-40525488" checked=""/><div class="controls bullet"><span class="by">jacknews</span><span>|</span><a href="#40525321">parent</a><span>|</span><a href="#40525528">prev</a><span>|</span><a href="#40527204">next</a><span>|</span><label class="collapse" for="c-40525488">[-]</label><label class="expand" for="c-40525488">[2 more]</label></div><br/><div class="children"><div class="content">&quot;In the industry code that isn&#x27;t DRY is a much bigger problem than code that is too DRY.&quot;<p>which industry is that?<p>in general programming, absolute nope<p>not-DRY code can be weaseled out with a good ide<p>badly abstracted code, not so much<p>in fact in a way, DRY is the responsibility of the IDE not the programmer - an advanced IDE would be able to sync all the disparate code segments, and even DRY them if necessary<p>but when I read DRYed code, the abstraction better be a complete and meaningful summary, like &#x27;make a sandwich&#x27;, and without many parameters (and no special cases), or else I&#x27;d rather read the actual code<p>i understand the impulse to try to factorize everything but it just doesn&#x27;t work beyond a certain point in the real world; it&#x27;s too difficult to read, and there&#x27;s always an &#x27;oh, can you just&#x27; requirement that upends the entire abstract tower.</div><br/><div id="40527649" class="c"><input type="checkbox" id="c-40527649" checked=""/><div class="controls bullet"><span class="by">goatlover</span><span>|</span><a href="#40525321">root</a><span>|</span><a href="#40525488">parent</a><span>|</span><a href="#40527204">next</a><span>|</span><label class="collapse" for="c-40527649">[-]</label><label class="expand" for="c-40527649">[1 more]</label></div><br/><div class="children"><div class="content">You didn’t provide any evidence for this, you just stated your coding preference. Which is usually the case in these discussions. Some anecdotes, and then people making grand claims based on personal preference. Obviously, some programmers have thought the opposite and have their own anecdotes.</div><br/></div></div></div></div></div></div><div id="40527204" class="c"><input type="checkbox" id="c-40527204" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#40525321">prev</a><span>|</span><a href="#40531090">next</a><span>|</span><label class="collapse" for="c-40527204">[-]</label><label class="expand" for="c-40527204">[1 more]</label></div><br/><div class="children"><div class="content">My maxim: is &quot;it&quot; intrinsically the same, or coincidentally the same?<p>Intrinsically the same means a rule, and so there should be 1 source of truth for it. Coincidentally the same means it has the same shape but this just happens to be the case, and they should be left separate to evolve independently.<p>Ultimately, it boils down to really thinking about the domain.</div><br/></div></div><div id="40531090" class="c"><input type="checkbox" id="c-40531090" checked=""/><div class="controls bullet"><span class="by">poikroequ</span><span>|</span><a href="#40527204">prev</a><span>|</span><label class="collapse" for="c-40531090">[-]</label><label class="expand" for="c-40531090">[1 more]</label></div><br/><div class="children"><div class="content">Anecdotal but I&#x27;ve found it much easier to start DRY and then later duplicate code that diverges a little bit from the original. What is hard is working with a large code base with lots of duplicate code.  When you need to change one thing, but there&#x27;s multiple places you need to make that one change, I&#x27;ve found it very difficult to track down all the places which need to be changed.<p>When you can&#x27;t DRY, or when it&#x27;s simply not practical, at least try to find a way of keeping track of duplicate code. Using enums and global constants can help you by finding all the references to those symbols and locate all the places in your code which need to be updated or refactored.</div><br/></div></div></div></div></div></div></div></body></html>