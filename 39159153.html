<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706432456069" as="style"/><link rel="stylesheet" href="styles.css?v=1706432456069"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Pagghiu/SaneCppLibraries">Sane C++ Libraries</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>cozis</span> | <span>82 comments</span></div><br/><div><div id="39161064" class="c"><input type="checkbox" id="c-39161064" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#39161845">next</a><span>|</span><label class="collapse" for="c-39161064">[-]</label><label class="expand" for="c-39161064">[13 more]</label></div><br/><div class="children"><div class="content">Many of the principles here align with my tastes, such as focusing on fast compile times and supporting allocation failure.  On the other hand:<p>&gt; Unplanned Features:<p>&gt; SharedPtr<p>&gt; UniquePtr<p>&gt; In Principles there is a rule that discourages allocations of large number of tiny objects and also creating systems with unclear or shared memory ownership. For this reason this library is missing Smart Pointers.<p>I don’t like that at all.  I take the common view that <i>all</i> heap objects should at least be allocated via smart pointers.  Doing so is safer and easier and usually zero-overhead.  After allocation, it may be necessary to pass those objects via raw pointers&#x2F;references, but smart pointers should be used where appropriate.<p>So while I agree that it’s undesirable to allocate “large numbers of tiny objects”, I would want smart pointers as long as there’s any dynamic allocation at all.</div><br/><div id="39163702" class="c"><input type="checkbox" id="c-39163702" checked=""/><div class="controls bullet"><span class="by">pagghiu</span><span>|</span><a href="#39161064">parent</a><span>|</span><a href="#39161614">next</a><span>|</span><label class="collapse" for="c-39163702">[-]</label><label class="expand" for="c-39163702">[1 more]</label></div><br/><div class="children"><div class="content">For me personally SharedPtr is very rarely needed as it encourages building difficult to untangle ownership hierarchies. I did use a lot of Shared Ptr in the past when creating a node.js like library in C++ but breaking the ref cycles everywhere was needed has always been a pain. 
That&#x27;s why I am currently against its use, unless there is a very special case.<p>Regarding UniquePtr&lt;T&gt; I used to have one but I later on decided to remove it.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Pagghiu&#x2F;SaneCppLibraries&#x2F;commit&#x2F;9149e28">https:&#x2F;&#x2F;github.com&#x2F;Pagghiu&#x2F;SaneCppLibraries&#x2F;commit&#x2F;9149e28</a><p>However, that being said the library is lean enough so that you can still use it with smart pointers provided by any other library (including the standard one) if that&#x27;s your preference.</div><br/></div></div><div id="39161614" class="c"><input type="checkbox" id="c-39161614" checked=""/><div class="controls bullet"><span class="by">markisus</span><span>|</span><a href="#39161064">parent</a><span>|</span><a href="#39163702">prev</a><span>|</span><a href="#39161796">next</a><span>|</span><label class="collapse" for="c-39161614">[-]</label><label class="expand" for="c-39161614">[7 more]</label></div><br/><div class="children"><div class="content">I usually like to place all dynamically heap objects of type T into an std::vector&lt;T&gt;, if possible. There is sometimes an obvious point where the entire batch should be discarded and a new batch should be built. At this point, you can call vector.clear() which avoids deallocation&#x2F;allocation cost for the new batch, as long as it is not bigger than the old batch. This is a sort of quick and dirty arena allocation.<p>This style is also more cache friendly if you are going to be looping through the elements.</div><br/><div id="39161765" class="c"><input type="checkbox" id="c-39161765" checked=""/><div class="controls bullet"><span class="by">neeeeees</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161614">parent</a><span>|</span><a href="#39161796">next</a><span>|</span><label class="collapse" for="c-39161765">[-]</label><label class="expand" for="c-39161765">[6 more]</label></div><br/><div class="children"><div class="content">Interesting - is there a type safe way to do this? vector&lt;variant&lt;&gt;&gt;? and&#x2F;or a custom “vector allocator” to hide the details?</div><br/><div id="39163664" class="c"><input type="checkbox" id="c-39163664" checked=""/><div class="controls bullet"><span class="by">pagghiu</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161765">parent</a><span>|</span><a href="#39163275">next</a><span>|</span><label class="collapse" for="c-39163664">[-]</label><label class="expand" for="c-39163664">[1 more]</label></div><br/><div class="children"><div class="content">You can do a Vector&lt;TaggedUnion&lt;Union&gt;&gt;.
<a href="https:&#x2F;&#x2F;pagghiu.github.io&#x2F;SaneCppLibraries&#x2F;library_foundation.html#autotoc_md133" rel="nofollow">https:&#x2F;&#x2F;pagghiu.github.io&#x2F;SaneCppLibraries&#x2F;library_foundatio...</a><p>I have not been working (yet) on custom allocators, but that&#x27;s on the roadmap:
<a href="https:&#x2F;&#x2F;pagghiu.github.io&#x2F;SaneCppLibraries&#x2F;library_containers.html#autotoc_md90" rel="nofollow">https:&#x2F;&#x2F;pagghiu.github.io&#x2F;SaneCppLibraries&#x2F;library_container...</a></div><br/></div></div><div id="39163275" class="c"><input type="checkbox" id="c-39163275" checked=""/><div class="controls bullet"><span class="by">noduerme</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161765">parent</a><span>|</span><a href="#39163664">prev</a><span>|</span><a href="#39162766">next</a><span>|</span><label class="collapse" for="c-39163275">[-]</label><label class="expand" for="c-39163275">[1 more]</label></div><br/><div class="children"><div class="content">If you wanted a factory that allocated vectors of a variety of known types, you&#x27;d probably declare template &lt;typename T&gt; before the generator function, so that on compilation a separate version of that function would be emitted for each type you passed to it.<p>(Not really a c++ expert, but that&#x27;s my understanding; someone more knowledgeable can correct me).</div><br/></div></div><div id="39162766" class="c"><input type="checkbox" id="c-39162766" checked=""/><div class="controls bullet"><span class="by">markisus</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161765">parent</a><span>|</span><a href="#39163275">prev</a><span>|</span><a href="#39162579">next</a><span>|</span><label class="collapse" for="c-39162766">[-]</label><label class="expand" for="c-39162766">[1 more]</label></div><br/><div class="children"><div class="content">In my example, the T is one specific type. So you could have std::vector&lt;Cat&gt;. If you also have Dogs, you just make another vector std::vector&lt;Dog&gt;. It works fine with the standard allocator. You don&#x27;t have to do anything special.</div><br/></div></div><div id="39162579" class="c"><input type="checkbox" id="c-39162579" checked=""/><div class="controls bullet"><span class="by">emi2k01</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161765">parent</a><span>|</span><a href="#39162766">prev</a><span>|</span><a href="#39161781">next</a><span>|</span><label class="collapse" for="c-39162579">[-]</label><label class="expand" for="c-39162579">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t that an arena allocator at that point?</div><br/></div></div><div id="39161781" class="c"><input type="checkbox" id="c-39161781" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161765">parent</a><span>|</span><a href="#39162579">prev</a><span>|</span><a href="#39161796">next</a><span>|</span><label class="collapse" for="c-39161781">[-]</label><label class="expand" for="c-39161781">[1 more]</label></div><br/><div class="children"><div class="content">Why would you need a variant? If you have one of something, put it on the stack. If you have a lot of the a type, put them in a vector.</div><br/></div></div></div></div></div></div><div id="39161796" class="c"><input type="checkbox" id="c-39161796" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#39161064">parent</a><span>|</span><a href="#39161614">prev</a><span>|</span><a href="#39161957">next</a><span>|</span><label class="collapse" for="c-39161796">[-]</label><label class="expand" for="c-39161796">[1 more]</label></div><br/><div class="children"><div class="content">Shared pointers are most definitely not zero overhead. The trouble is that they use atomic operations which can cause tons of problems for highly concurrent systems. You can use non-thread safe smart pointers, but at some point you have to ask whether that is really lower risk than just not using shared pointers at all (Rust gets around this with type checking).</div><br/></div></div><div id="39161957" class="c"><input type="checkbox" id="c-39161957" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39161064">parent</a><span>|</span><a href="#39161796">prev</a><span>|</span><a href="#39161777">next</a><span>|</span><label class="collapse" for="c-39161957">[-]</label><label class="expand" for="c-39161957">[2 more]</label></div><br/><div class="children"><div class="content">Adding a bunch of lines like `#pragma GCC poison new` to the last-included header of every source file is very useful. It doesn&#x27;t fully stop manual memory management from sneaking into headers (since it absolutely will break system headers, though maybe if modules work that would be avoided).<p>For the rare case of porting software with unclear ownership, I use a `dumb_ptr` template with allocation and deallocation methods. Since this is header-only it naturally avoids the poisoning.<p>In particular, the `vector` method mentioned elsewhere is completely broken since objects move and thus you can&#x27;t keep weak&#x2F;borrowed references to them. If you use indices you give up on all ownership and are probably using global variables, ick. Please just write a proper pool allocator if that&#x27;s what you want (possibly using generational references to implement weak).</div><br/><div id="39162848" class="c"><input type="checkbox" id="c-39162848" checked=""/><div class="controls bullet"><span class="by">markisus</span><span>|</span><a href="#39161064">root</a><span>|</span><a href="#39161957">parent</a><span>|</span><a href="#39161777">next</a><span>|</span><label class="collapse" for="c-39162848">[-]</label><label class="expand" for="c-39162848">[1 more]</label></div><br/><div class="children"><div class="content">Everything is a tradeoff. Even things like goto, and global variables will occasionally be the right choice.<p>Regarding the std::vector method, you may have a very loosely coupled system where a bunch of T1&#x27;s enter into a pipeline and come out as T2&#x27;s. For this use case, std::vector&lt;T1&gt; and std::vector&lt;T2&gt; are great. On the other hand, if you need to create an object and hand it off to someone else with no knowledge of how long they will need to hold onto it, then std::shared_ptr could be a good option.<p>In the in-between you have entity component systems that do the type of index tracking you mention so that identities are decoupled from memory location, allowing objects to move. I didn&#x27;t understand your point about global variables and why they are necessary to implement this type of system. I also didn&#x27;t understand how this gives up on all ownership. The owner would be the system that maintains the index to memory location mapping.</div><br/></div></div></div></div><div id="39161777" class="c"><input type="checkbox" id="c-39161777" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39161064">parent</a><span>|</span><a href="#39161957">prev</a><span>|</span><a href="#39161845">next</a><span>|</span><label class="collapse" for="c-39161777">[-]</label><label class="expand" for="c-39161777">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I prefer RAII over manual memory management. Sorry, strawman.</div><br/></div></div></div></div><div id="39161845" class="c"><input type="checkbox" id="c-39161845" checked=""/><div class="controls bullet"><span class="by">slaymaker1907</span><span>|</span><a href="#39161064">prev</a><span>|</span><a href="#39161028">next</a><span>|</span><label class="collapse" for="c-39161845">[-]</label><label class="expand" for="c-39161845">[15 more]</label></div><br/><div class="children"><div class="content">Why would you implement your own atomics? It seems very similar to std::atomic, except you need to do a bunch of platform specific hacks to get it to work. The only possible reason I could think of why you would do this is if you aren&#x27;t using at least C++11. If you aren&#x27;t using C++11, then you probably shouldn&#x27;t be using threads in the first place.</div><br/><div id="39162072" class="c"><input type="checkbox" id="c-39162072" checked=""/><div class="controls bullet"><span class="by">jbandela1</span><span>|</span><a href="#39161845">parent</a><span>|</span><a href="#39161930">next</a><span>|</span><label class="collapse" for="c-39162072">[-]</label><label class="expand" for="c-39162072">[2 more]</label></div><br/><div class="children"><div class="content">Also, std::atomic is one of those special types.<p>It is deeply integrated into the C++11 memory model. The compiler has to know about the semantics of the type to make sure it doesn’t reorder operations around it.</div><br/></div></div><div id="39161930" class="c"><input type="checkbox" id="c-39161930" checked=""/><div class="controls bullet"><span class="by">qwery</span><span>|</span><a href="#39161845">parent</a><span>|</span><a href="#39162072">prev</a><span>|</span><a href="#39161028">next</a><span>|</span><label class="collapse" for="c-39161930">[-]</label><label class="expand" for="c-39161930">[12 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t speak for the author, but using `std::atomic` would presumably break one of the project&#x27;s listed principles:<p>&gt; No C++ Standard Library &#x2F; Exceptions &#x2F; RTTI</div><br/><div id="39163718" class="c"><input type="checkbox" id="c-39163718" checked=""/><div class="controls bullet"><span class="by">pagghiu</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39161930">parent</a><span>|</span><a href="#39161972">next</a><span>|</span><label class="collapse" for="c-39163718">[-]</label><label class="expand" for="c-39163718">[1 more]</label></div><br/><div class="children"><div class="content">Exactly!<p>This is all in an effort to bring down compile times, avoiding including anything from the standard because you can never know if including &lt;atomic&gt; is bringing 10K lines of code in your header.<p>I will probably provide an optional USE_STANDARD_HEADERS flag someday to allow including a few standard things, including atomics, to avoid doing things wrong on compilerS that are not tested enough (as I clearly can&#x27;t test every compiler).</div><br/></div></div><div id="39161972" class="c"><input type="checkbox" id="c-39161972" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39161930">parent</a><span>|</span><a href="#39163718">prev</a><span>|</span><a href="#39161028">next</a><span>|</span><label class="collapse" for="c-39161972">[-]</label><label class="expand" for="c-39161972">[10 more]</label></div><br/><div class="children"><div class="content">Which is like making cookies without butter. It can be done, but why would you want to? The standard library exists for this reason. To provide these abstractions. And I laugh at the idea that C++ could ever be exception free.</div><br/><div id="39163140" class="c"><input type="checkbox" id="c-39163140" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39161972">parent</a><span>|</span><a href="#39162805">next</a><span>|</span><label class="collapse" for="c-39163140">[-]</label><label class="expand" for="c-39163140">[4 more]</label></div><br/><div class="children"><div class="content">I am always baffled by the assertion that C++ cannot be exception-free. The vast majority of C++ code bases I have worked on, at companies large and small, have been exception-free. It is completely ordinary to have no exceptions, and is largely the de facto reality for a lot of C++ development.<p>In some vanilla app code exceptions are fine, but they introduce nasty edge cases in the kinds of systems code architectures C++ is mostly used for these days. Additionally, they don’t solve an urgent problem in practice that would strongly incentive someone to use them, so it the price of admission is rather steep for minimal benefit.</div><br/><div id="39163454" class="c"><input type="checkbox" id="c-39163454" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39163140">parent</a><span>|</span><a href="#39163395">next</a><span>|</span><label class="collapse" for="c-39163454">[-]</label><label class="expand" for="c-39163454">[1 more]</label></div><br/><div class="children"><div class="content">It isn&#x27;t compliant with ISO C++ standard library for starters.<p>I really wish that everyone that plagues C++ library fragmentation with disabled this, disabled that, just stick to C and leave C++ community alone, so that we can fully enjoy the language as designed.</div><br/></div></div><div id="39163395" class="c"><input type="checkbox" id="c-39163395" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39163140">parent</a><span>|</span><a href="#39163454">prev</a><span>|</span><a href="#39162805">next</a><span>|</span><label class="collapse" for="c-39163395">[-]</label><label class="expand" for="c-39163395">[2 more]</label></div><br/><div class="children"><div class="content">You can’t guarantee the underlying memory so you can’t guarantee your app won’t blow up. You can handle errors, or expects, or however you want to call “exceptions” without the stdlib but you still have error states, you still have deterministic code branches, you may not have RTTI and non-deterministic std::exception but you still have the concept of an exception. The alternative is to segfault.</div><br/><div id="39163661" class="c"><input type="checkbox" id="c-39163661" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39163395">parent</a><span>|</span><a href="#39162805">next</a><span>|</span><label class="collapse" for="c-39163661">[-]</label><label class="expand" for="c-39163661">[1 more]</label></div><br/><div class="children"><div class="content">You are correct that there is code that solves a similar class of problems as exceptions. This code exists because it is can gracefully handle cases that exceptions handle poorly, in addition to the cases exceptions handle well. The literal C++ exceptions are an inferior tool.<p>It is trivial to “guarantee” the underlying memory and is idiomatic for a lot of software that cares about performance or reliability. That is code anyone can write if they care. There isn’t much that can go wrong with memory allocation if you are not allocating memory from the system. No one is requiring C++ developers to poorly duct tape a bunch of rubbish STL together and call it an app. That simply isn’t something you see much in the hardcore systems domains where C++ is the tool of choice.<p>Somehow, mission-critical software is routinely written in C++ without exceptions and it works just fine. Error states are a normal part of all code, no exceptions required since obviously many languages don’t have them. And no, the alternative is not a segfault. C++ is designed to work just fine without exceptions. The language allows you to bring your own error&#x2F;exception handling models with minimal overhead, same way you can import alternative ownership&#x2F;safety models.</div><br/></div></div></div></div></div></div><div id="39162805" class="c"><input type="checkbox" id="c-39162805" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39161972">parent</a><span>|</span><a href="#39163140">prev</a><span>|</span><a href="#39162211">next</a><span>|</span><label class="collapse" for="c-39162805">[-]</label><label class="expand" for="c-39162805">[4 more]</label></div><br/><div class="children"><div class="content">As a person working in a large exception-free C++ environment, I&#x27;m all ears.</div><br/><div id="39163465" class="c"><input type="checkbox" id="c-39163465" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39162805">parent</a><span>|</span><a href="#39162211">next</a><span>|</span><label class="collapse" for="c-39163465">[-]</label><label class="expand" for="c-39163465">[3 more]</label></div><br/><div class="children"><div class="content">I assume you&#x27;re making use of no-throw placement new and not touching any standard library type, whose error conditions as available only via exceptions as per ISO C++.<p>Otherwise good luck porting that exception free code across multiple OSes and C++ compilers,  not only the big three.</div><br/><div id="39163530" class="c"><input type="checkbox" id="c-39163530" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39163465">parent</a><span>|</span><a href="#39162211">next</a><span>|</span><label class="collapse" for="c-39163530">[-]</label><label class="expand" for="c-39163530">[2 more]</label></div><br/><div class="children"><div class="content">Presumably they just use -fno-exceptions, and not everyone has to have portable code. I appreciate the concept but pragmatically there are plenty of C++ server side projects that only use Clang and GCC</div><br/><div id="39163602" class="c"><input type="checkbox" id="c-39163602" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39163530">parent</a><span>|</span><a href="#39162211">next</a><span>|</span><label class="collapse" for="c-39163602">[-]</label><label class="expand" for="c-39163602">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, and then come into twitter complaining when the code fails spectacularly after a compiler upgrade.</div><br/></div></div></div></div></div></div></div></div><div id="39162211" class="c"><input type="checkbox" id="c-39162211" checked=""/><div class="controls bullet"><span class="by">qwery</span><span>|</span><a href="#39161845">root</a><span>|</span><a href="#39161972">parent</a><span>|</span><a href="#39162805">prev</a><span>|</span><a href="#39161028">next</a><span>|</span><label class="collapse" for="c-39162211">[-]</label><label class="expand" for="c-39162211">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why would you want to?<p>It seems like you know C++ pretty well, so I think you could probably come up with some reasons if you gave it a try.<p>The obvious thing that comes to my mind is because you can&#x27;t rely on an undesirable, unknown, or potentially nonexistent implementation of the STL for your target platform.<p>As for cookies: who am I to dictate what&#x2F;how someone should bake?</div><br/></div></div></div></div></div></div></div></div><div id="39161028" class="c"><input type="checkbox" id="c-39161028" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#39161845">prev</a><span>|</span><a href="#39163630">next</a><span>|</span><label class="collapse" for="c-39161028">[-]</label><label class="expand" for="c-39161028">[1 more]</label></div><br/><div class="children"><div class="content">Looks like the author likes C but would like a few of the features of C++ and wants to have some fun.  There’s noting wrong with that, but it ain’t for me.<p>The stuff he considers complex is mostly complex because it handles a lot of corner cases, or else it has back compatibility constraints he will be dealing with as well.<p>Good luck to him though.  Doing stuff for fun is the best!</div><br/></div></div><div id="39163630" class="c"><input type="checkbox" id="c-39163630" checked=""/><div class="controls bullet"><span class="by">pagghiu</span><span>|</span><a href="#39161028">prev</a><span>|</span><a href="#39163438">next</a><span>|</span><label class="collapse" for="c-39163630">[-]</label><label class="expand" for="c-39163630">[1 more]</label></div><br/><div class="children"><div class="content">Author here! Feel free to ask me any question, here or on discord&#x2F;X&#x2F;Mastodon I just saw this posted here, wow :)</div><br/></div></div><div id="39163438" class="c"><input type="checkbox" id="c-39163438" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39163630">prev</a><span>|</span><a href="#39163269">next</a><span>|</span><label class="collapse" for="c-39163438">[-]</label><label class="expand" for="c-39163438">[3 more]</label></div><br/><div class="children"><div class="content">&gt; No C++ Standard Library &#x2F; Exceptions &#x2F; RTTI<p>This alone already rules them out as sane on my book.</div><br/><div id="39163520" class="c"><input type="checkbox" id="c-39163520" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#39163438">parent</a><span>|</span><a href="#39163269">next</a><span>|</span><label class="collapse" for="c-39163520">[-]</label><label class="expand" for="c-39163520">[2 more]</label></div><br/><div class="children"><div class="content">No stdlib or no exceptions&#x2F;RAII. Because everyone at Google is on the no exceptions&#x2F;RAII train (according to the Google Style Guide), and I happen to like exceptionless C++</div><br/><div id="39163608" class="c"><input type="checkbox" id="c-39163608" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39163438">root</a><span>|</span><a href="#39163520">parent</a><span>|</span><a href="#39163269">next</a><span>|</span><label class="collapse" for="c-39163608">[-]</label><label class="expand" for="c-39163608">[1 more]</label></div><br/><div class="children"><div class="content">Just because it is Google, doesn&#x27;t mean their style guides have any quality value.<p>Any company that worships that style guide is one I am happily never going to work on.</div><br/></div></div></div></div></div></div><div id="39163269" class="c"><input type="checkbox" id="c-39163269" checked=""/><div class="controls bullet"><span class="by">countWSS</span><span>|</span><a href="#39163438">prev</a><span>|</span><a href="#39161017">next</a><span>|</span><label class="collapse" for="c-39163269">[-]</label><label class="expand" for="c-39163269">[1 more]</label></div><br/><div class="children"><div class="content">Actually this sounds useful as alternative to C++ stdlib:
i&#x27;ve often compiled C++ code via GCC
for simple stuff where C++ stdlib isn&#x27;t included by 
 default and all &#x27;nice&#x27; C++ things are not linked,
giving less overhead per file, but forced you
to rely on ancient C functions.
This would be a middle ground solution between
 unsafe C and bloated stdc++.</div><br/></div></div><div id="39161017" class="c"><input type="checkbox" id="c-39161017" checked=""/><div class="controls bullet"><span class="by">sublinear</span><span>|</span><a href="#39163269">prev</a><span>|</span><a href="#39161407">next</a><span>|</span><label class="collapse" for="c-39161017">[-]</label><label class="expand" for="c-39161017">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;nlohmann&#x2F;json">https:&#x2F;&#x2F;github.com&#x2F;nlohmann&#x2F;json</a><p>I used this for JSON last time I wrote any C++ a few years ago and it still seems popular. It seemed sane enough to me.</div><br/></div></div><div id="39161407" class="c"><input type="checkbox" id="c-39161407" checked=""/><div class="controls bullet"><span class="by">dzogchen</span><span>|</span><a href="#39161017">prev</a><span>|</span><a href="#39161821">next</a><span>|</span><label class="collapse" for="c-39161407">[-]</label><label class="expand" for="c-39161407">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;Sane&#x27; C++ is apparently still using macros all over the place. :) Not really to be taken seriously.</div><br/></div></div><div id="39161821" class="c"><input type="checkbox" id="c-39161821" checked=""/><div class="controls bullet"><span class="by">nemetroid</span><span>|</span><a href="#39161407">prev</a><span>|</span><a href="#39161860">next</a><span>|</span><label class="collapse" for="c-39161821">[-]</label><label class="expand" for="c-39161821">[1 more]</label></div><br/><div class="children"><div class="content">Looked at the first library in the list, &quot;Algorithms&quot;. The first item in that library is bubbleSort(). I&#x27;ll pass.</div><br/></div></div><div id="39161860" class="c"><input type="checkbox" id="c-39161860" checked=""/><div class="controls bullet"><span class="by">csjh</span><span>|</span><a href="#39161821">prev</a><span>|</span><a href="#39161435">next</a><span>|</span><label class="collapse" for="c-39161860">[-]</label><label class="expand" for="c-39161860">[1 more]</label></div><br/><div class="children"><div class="content">What is the point of `algorithms::bubbleSort`?</div><br/></div></div><div id="39161435" class="c"><input type="checkbox" id="c-39161435" checked=""/><div class="controls bullet"><span class="by">bsdpufferfish</span><span>|</span><a href="#39161860">prev</a><span>|</span><a href="#39161092">next</a><span>|</span><label class="collapse" for="c-39161435">[-]</label><label class="expand" for="c-39161435">[1 more]</label></div><br/><div class="children"><div class="content">Just use C and guarantee your sanity. The whole reason to adopt C++ is to support huge projects and libraries all of which are going to use the “bad” stuff.</div><br/></div></div><div id="39161092" class="c"><input type="checkbox" id="c-39161092" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#39161435">prev</a><span>|</span><a href="#39161334">next</a><span>|</span><label class="collapse" for="c-39161092">[-]</label><label class="expand" for="c-39161092">[2 more]</label></div><br/><div class="children"><div class="content">how does it compare to <a href="https:&#x2F;&#x2F;abseil.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;abseil.io&#x2F;</a></div><br/><div id="39161227" class="c"><input type="checkbox" id="c-39161227" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#39161092">parent</a><span>|</span><a href="#39161334">next</a><span>|</span><label class="collapse" for="c-39161227">[-]</label><label class="expand" for="c-39161227">[1 more]</label></div><br/><div class="children"><div class="content">Abseil is more of a complement to the STL rather than a complete replacement like the OP is, for example the only containers that Abseil provides are maps and sets since the STL ones are particularly bad, and the rest of the STL containers are good enough (for Google at least). Whether that&#x27;s the right approach depends on what your specific qualms with the STL are.</div><br/></div></div></div></div><div id="39161334" class="c"><input type="checkbox" id="c-39161334" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#39161092">prev</a><span>|</span><a href="#39160996">next</a><span>|</span><label class="collapse" for="c-39161334">[-]</label><label class="expand" for="c-39161334">[1 more]</label></div><br/><div class="children"><div class="content">The first library I checked was &quot;Reflection&quot;.
This is where I can see if their principle holds up</div><br/></div></div><div id="39160996" class="c"><input type="checkbox" id="c-39160996" checked=""/><div class="controls bullet"><span class="by">shortrounddev2</span><span>|</span><a href="#39161334">prev</a><span>|</span><a href="#39161042">next</a><span>|</span><label class="collapse" for="c-39160996">[-]</label><label class="expand" for="c-39160996">[1 more]</label></div><br/><div class="children"><div class="content">The lack of STL containers or even a fully implemented set of custom containers, to me, makes this kind of a non starter. I use C++, in part, because I don&#x27;t want to have to implement Data structures and algorithms myself</div><br/></div></div><div id="39161042" class="c"><input type="checkbox" id="c-39161042" checked=""/><div class="controls bullet"><span class="by">colejohnson66</span><span>|</span><a href="#39160996">prev</a><span>|</span><a href="#39160980">next</a><span>|</span><label class="collapse" for="c-39161042">[-]</label><label class="expand" for="c-39161042">[36 more]</label></div><br/><div class="children"><div class="content">As someone who doesn&#x27;t write C++, why does almost everyone seem to insist on ignoring the STL and writing everything themselves? Both C++ and C# take a &quot;bags included&quot; approach to the standard library, but no one is writing their own `List&lt;T&gt;` for C#.[a] Yet, everyone seems to have their own opinion about `std::vector&lt;T&gt;`.<p>[a]: Obviously, people still write their own collections&#x2F;containers in C#, but they tend to only do so for very specific&#x2F;performance-sensitive circumstances.</div><br/><div id="39161342" class="c"><input type="checkbox" id="c-39161342" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161112">next</a><span>|</span><label class="collapse" for="c-39161342">[-]</label><label class="expand" for="c-39161342">[2 more]</label></div><br/><div class="children"><div class="content">Because C#, at several points in its history, sensibly took the decision to explicitly break backward compatibility to satisfy legitimate requirements, adapting and evolving to the tenets of modern software practices. (Generics and new collections)<p>Whereas due to C++&#x27;s &quot;never break compatibility&quot; decision, the standard library has progressively decayed over time. It has become a bloated, rotting dinosaur where even the slowest of interpreted languages can comfortably beat several of its aspects. (Ex: std::regex is pathetic and pitiful, vector&lt;bool&gt; triggers laughter, substandard maps, etc). Considering that C++ thumps its chest and loudly proclaims its superb performance, this has now become a sad joke.<p>In the natural world, a species that cannot adapt to new circumstances and never discards undesirable characteristics simply <i>perishes</i>.<p>The C++ Standard Committee has firmly and unequivocally decided that the C++ language should mirror the same approach and limp down the road, carrying the full-weight of its sins for all its journey, until it falls into oblivion.</div><br/><div id="39163491" class="c"><input type="checkbox" id="c-39163491" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161342">parent</a><span>|</span><a href="#39161112">next</a><span>|</span><label class="collapse" for="c-39163491">[-]</label><label class="expand" for="c-39163491">[1 more]</label></div><br/><div class="children"><div class="content">Note that as documented in the history of F# HOPL paper, .NET already had a generics prototype before 1.0 release, Microsoft decided to go ahead without generics to avoid delaying it further until they were stable.<p>Also breaking everything a couple of times is why most corporations are nowadays stuck in a Python 2 &#x2F; 3 parallel world  in .NET Framework &#x2F; .NET Core , or in Xamarin.Forms &#x2F; MAUI, UWP &#x2F; WinUI,...</div><br/></div></div></div></div><div id="39161112" class="c"><input type="checkbox" id="c-39161112" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161342">prev</a><span>|</span><a href="#39161119">next</a><span>|</span><label class="collapse" for="c-39161112">[-]</label><label class="expand" for="c-39161112">[5 more]</label></div><br/><div class="children"><div class="content">There are so many reasons. I&#x27;m sure others will provide their own favorites.<p>One that I find particularly annoying lately: if you work on a project that makes heavy use of the STL (or, really, any heavily templated library written in a similar style, with a focus on &quot;ergonomics&quot; :-( ), you&#x27;ll quickly find that backtraces for debug builds can easily be 50-100 levels deep with most stack frames just consisting of incomprehensible layers of abstraction which get optimized away. So, debug builds are totally useless, and build times are typically long. Contrast that with something written in &quot;C style&quot; or simply making far fewer use of C++ features, written in a more straightline style, with fewer levels of abstraction: builds will be fast, stack traces will be small and can easily map directly onto the concepts relevant to the program or library, and debug builds are useful once more. Night and day difference.</div><br/><div id="39161149" class="c"><input type="checkbox" id="c-39161149" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161112">parent</a><span>|</span><a href="#39161119">next</a><span>|</span><label class="collapse" for="c-39161149">[-]</label><label class="expand" for="c-39161149">[4 more]</label></div><br/><div class="children"><div class="content">In decades of professional C++ experience I have never noted depth of backtrace as a usability issue. Give us an example of how a 100-deep backtrace arises as a consequence of the STL.</div><br/><div id="39161989" class="c"><input type="checkbox" id="c-39161989" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161149">parent</a><span>|</span><a href="#39161171">next</a><span>|</span><label class="collapse" for="c-39161989">[-]</label><label class="expand" for="c-39161989">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, at least for STL containers I didn&#x27;t really have to dig into the implementation for 99.9% of the cases. One or two specific old cases were due to memory corruption, but nowadays address sanitizer should do the job. Of course, a lengthy symbol for heavily templatized functions&#x2F;classes can sometimes be a problem, but it&#x27;s a separate issue from stack trace depth.</div><br/></div></div><div id="39161171" class="c"><input type="checkbox" id="c-39161171" checked=""/><div class="controls bullet"><span class="by">sfpotter</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161149">parent</a><span>|</span><a href="#39161989">prev</a><span>|</span><a href="#39161969">next</a><span>|</span><label class="collapse" for="c-39161171">[-]</label><label class="expand" for="c-39161171">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Functional&quot; C++ with deeply nested loops implemented using stuff from &lt;algorithm&gt; and &lt;functional&gt; and lambda.</div><br/></div></div><div id="39161969" class="c"><input type="checkbox" id="c-39161969" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161149">parent</a><span>|</span><a href="#39161171">prev</a><span>|</span><a href="#39161119">next</a><span>|</span><label class="collapse" for="c-39161969">[-]</label><label class="expand" for="c-39161969">[1 more]</label></div><br/><div class="children"><div class="content">Before concepts it was certainly <i>possible</i>, but when it happened you just had to add some extra type assertions to make it clear where the error is.</div><br/></div></div></div></div></div></div><div id="39161119" class="c"><input type="checkbox" id="c-39161119" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161112">prev</a><span>|</span><a href="#39161607">next</a><span>|</span><label class="collapse" for="c-39161119">[-]</label><label class="expand" for="c-39161119">[1 more]</label></div><br/><div class="children"><div class="content">Take your pick: undercooked functionality, lack of behavior&#x2F;performance consistency between different toolchains, bloated implementations causing long compile times, inscrutable template vomit error messages and poor performance in debug builds (a dealbreaker for realtime apps like games), and design mistakes which can&#x27;t easily be fixed, such as std::vector&lt;bool&gt; being a footgun or the way that the standard map types are defined making them impossible to implement efficiently.</div><br/></div></div><div id="39161607" class="c"><input type="checkbox" id="c-39161607" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161119">prev</a><span>|</span><a href="#39162044">next</a><span>|</span><label class="collapse" for="c-39161607">[-]</label><label class="expand" for="c-39161607">[1 more]</label></div><br/><div class="children"><div class="content">The containers in the STL have issues due to the limitations of C++ when they were designed, catering to the lowest common denominator user, and simplifying things for implementors. It is not uncommon to find cases where the STL is a poor fit or annoying to use due to its implementation and design details. In the case of modern C++, you also have the issue that the STL containers aren&#x27;t designed to be used in an advanced metaprogramming context, because they pre-date that being an intentional part of C++. Some of this is unfixable because backward compatibility. Also, C++ is commonly used in contexts where performance is critical, so the optimality of the STL for purpose matters more.<p>Some of the common issues: static allocation or lack thereof, requiring default constructible classes, initializing memory you are going to overwrite anyway, inability to be used in some metaprogramming contexts, suboptimal allocation behavior, etc. The STL is opinionated but unfortunately that opinion dates to a time when C++ was primarily used for ordinary app development, not high-performance code.<p>Like many, I maintain my own C++ &quot;standard library&quot; that is much better designed for the kinds of software I tend to work on (database kernels and data infrastructure, mostly).</div><br/></div></div><div id="39162044" class="c"><input type="checkbox" id="c-39162044" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161607">prev</a><span>|</span><a href="#39161104">next</a><span>|</span><label class="collapse" for="c-39162044">[-]</label><label class="expand" for="c-39162044">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why does almost everyone seem to insist on ignoring the STL and writing everything themselves?<p>Not really. Unless you have a very specific set of performance requirements, STL containers are usually more than enough. And we have third party libraries such as Abseil&#x2F;Boost to cover the major gaps in the rest. I do see some legitimate cases to write own container libraries. But for many cases people don&#x27;t really measure their primary workload before writing such libraries, instead they just write it because they can write (and it&#x27;s fun).</div><br/></div></div><div id="39161104" class="c"><input type="checkbox" id="c-39161104" checked=""/><div class="controls bullet"><span class="by">blovescoffee</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39162044">prev</a><span>|</span><a href="#39161661">next</a><span>|</span><label class="collapse" for="c-39161104">[-]</label><label class="expand" for="c-39161104">[19 more]</label></div><br/><div class="children"><div class="content">Because people tend to write c++ for performance reasons and the perf profiles of std::vector are not always sufficient</div><br/><div id="39161140" class="c"><input type="checkbox" id="c-39161140" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161104">parent</a><span>|</span><a href="#39161807">next</a><span>|</span><label class="collapse" for="c-39161140">[-]</label><label class="expand" for="c-39161140">[17 more]</label></div><br/><div class="children"><div class="content">The only thing you can really quibble about with std::vector is whether your library has made an optimal choice of growth strategy, which you can often hack around by reserving. Aside from that, access via `operator[]` and growth via `emplace_back` will compile down to optimal code that is going to be close to impossible to beat. After the compiler gets done with it, it looks the same as if you had hand-coded it with arrays in a C-style, but without the plethora of bugs that often results from that approach.</div><br/><div id="39162103" class="c"><input type="checkbox" id="c-39162103" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161140">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162103">[-]</label><label class="expand" for="c-39162103">[14 more]</label></div><br/><div class="children"><div class="content">&gt; The only thing you can really quibble about with std::vector is [...]<p>That&#x27;s actually not true, though I certainly don&#x27;t fault you for believing it :-) but there are definitely more things to quibble about around vector if you&#x27;re serious about performance.
As an example, try writing a can_fit(n) function, which tells you whether the vector can fit n elements without reallocating. Observe the performance difference between (a) a smart manual version, (b) a naive manual version, and (c) the only STL version: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;88sfM1sxW" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;88sfM1sxW</a><p><pre><code>  #include &lt;vector&gt;

  template&lt;class T&gt;
  struct Vec { T *b, *e, *f; };

  template&lt;class T&gt;
  bool can_fit_fast(Vec&lt;T&gt; const &amp;v, size_t n) {
    return reinterpret_cast&lt;char*&gt;(v.f) - reinterpret_cast&lt;char*&gt;(v.e) &gt;= n * sizeof(T);
  }

  template&lt;class T&gt;
  bool can_fit(Vec&lt;T&gt; const &amp;v, size_t n) {
    return v.f - v.e &gt;= n;
  }

  template&lt;class T&gt;
  bool can_fit(std::vector&lt;T&gt; const &amp;v, size_t n) {
    return v.capacity() - v.size() &gt;= n;
  }

  struct S { size_t a[3]; };

  template bool can_fit_fast(Vec&lt;S&gt; const &amp;, size_t);
  template bool can_fit(Vec&lt;S&gt; const &amp;, size_t);
  template bool can_fit(std::vector&lt;S&gt; const &amp;, size_t);</code></pre></div><br/><div id="39162867" class="c"><input type="checkbox" id="c-39162867" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162103">parent</a><span>|</span><a href="#39162342">next</a><span>|</span><label class="collapse" for="c-39162867">[-]</label><label class="expand" for="c-39162867">[4 more]</label></div><br/><div class="children"><div class="content">I was curious why the std::vector version produced so much more assembly, so I tried to dig a little. At least in libc++, the relevant code is (cleaned up):<p><pre><code>    template&lt;typename T, 
    class vector {
    private:
        pointer __begin_;
        pointer __end_;
        __compressed_pair&lt;pointer, allocator_type&gt; __end_cap_;
    public:
        constexpr const pointer&amp; __end_cap() const noexcept {
            return this-&gt;__end_cap_.first();
        }
        constexpr size_type size() const noexcept {
            return static_cast&lt;size_type&gt;(this-&gt;__end_ - this-&gt;__begin_);
        }
        constexpr size_type capacity() const noexcept {
            return static_cast&lt;size_type&gt;(__end_cap() - this-&gt;__begin_);
        }
    };
</code></pre>
So if the functions are fully inlined we should end up with<p><pre><code>    template&lt;class T&gt;
    bool can_fit(std::vector&lt;T&gt; const &amp;v, size_t n) {
        return static_cast&lt;size_t&gt;(v.__end_cap_.first() - v.__begin_) - static_cast&lt;size_t&gt;(v.__end_ - v.__begin_);
    }
</code></pre>
At least algebraically (and ignoring casts) it should be equivalent to v.__end_cap_.first() - v.__end_, which is more or less what the manual implementations do. Maybe the optimizer can&#x27;t make that transformation for some reason or another (overflow and&#x2F;or not knowing the relationship between the pointers involved, maybe)?<p>If you change can_fit(Vec&lt;S&gt;) to:<p><pre><code>    return (v.f - v.b) - (v.e - v.b) &gt;= n;
</code></pre>
You end up with code that looks pretty similar to the can_fit(std::vector&lt;S&gt;) overload (the same for clang, a bit different for GCC), so it does seem it might be something about the extra pointer math that can&#x27;t be safely reduced, and the casts aren&#x27;t really relevant.<p>(I&#x27;m also a bit surprised that can_fit_fast produces different assembly than the Vec can_fit overload)</div><br/><div id="39162910" class="c"><input type="checkbox" id="c-39162910" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162867">parent</a><span>|</span><a href="#39162342">next</a><span>|</span><label class="collapse" for="c-39162910">[-]</label><label class="expand" for="c-39162910">[3 more]</label></div><br/><div class="children"><div class="content">Kind of, yeah. The main thing to realize here is that pointer subtraction is not just arithmetic subtraction of the addresses; it&#x27;s also followed by a division by sizeof(T). (This is not obvious in this context unless you&#x27;ve seen it before.) Thus for the compiler to prove that (f - b) - (e - b) == f - e, it has to prove the remainders of each address subtraction (mod sizeof(T)) don&#x27;t affect the result. This is certainly possible, but it requires compilers to actually do some extra legwork (e.g.: assume these come from the same array, then prove that implies the remainders don&#x27;t affect the result, etc.) prior to reducing these to arithmetic operations. For whatever reason they don&#x27;t do that. My guess is the reason is something between &quot;we believe the general case would break too much existing code&quot; and &quot;we believe this special case isn&#x27;t common enough to be worth it&quot;. But who knows; maybe if someone files this as a missed optimization, they would try to implement it. I haven&#x27;t tried.<p>(There&#x27;s also a secondary issue here, which is that sizeof(S) isn&#x27;t a power of 2. That&#x27;s what&#x27;s introducing multiplications, instead of bit shifts. You might not see as drastic of a difference if sizeof(S) == alignof(S).)</div><br/><div id="39163379" class="c"><input type="checkbox" id="c-39163379" checked=""/><div class="controls bullet"><span class="by">aw1621107</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162910">parent</a><span>|</span><a href="#39162342">next</a><span>|</span><label class="collapse" for="c-39163379">[-]</label><label class="expand" for="c-39163379">[2 more]</label></div><br/><div class="children"><div class="content">Yeah, the extra instructions from the division helped clue me into what might be going on, since the individual (f - b) and (e - b) calculations are visible in Clang&#x27;s output.<p>I feel the division by sizeof(T) shouldn&#x27;t matter <i>that</i> much, since the compiler knows it has pointers to T so I don&#x27;t think the divisions would have remainders. I want to say pointer overflow and arithmetic on pointers to different objects (allocations?) should also be UB, so I suppose that might clear up most obstacles? I think I&#x27;m still missing something...<p>Does make me wonder how frequently this pattern might pop up elsewhere if it does turn out to be optimizable.</div><br/><div id="39163406" class="c"><input type="checkbox" id="c-39163406" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39163379">parent</a><span>|</span><a href="#39162342">next</a><span>|</span><label class="collapse" for="c-39163406">[-]</label><label class="expand" for="c-39163406">[1 more]</label></div><br/><div class="children"><div class="content">My 1st paragraph was directly answering your 2nd paragraph here (starting from &quot;This is certainly possible...&quot; to the end). I was saying, compilers can optimize this if they want to, but it requires work to implement, and I can only guess (the reasons I listed) as to why they might not have done so yet.<p>&gt; Does make me wonder how frequently this pattern might pop up elsewhere if it does turn out to be optimizable.<p>Probably a fair bit, but as I mentioned, it might break a lot of code too, because there&#x27;s too much code in the wild doing illegal things with pointers (like shoving random state into the lower bits, etc.). Or not... the Clang folks would probably know better.</div><br/></div></div></div></div></div></div></div></div><div id="39162342" class="c"><input type="checkbox" id="c-39162342" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162103">parent</a><span>|</span><a href="#39162867">prev</a><span>|</span><a href="#39162154">next</a><span>|</span><label class="collapse" for="c-39162342">[-]</label><label class="expand" for="c-39162342">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if you actually measured it with proper compiler options? I saw some folks insist that STL is somehow slow blaming unnecessary layers but many of them are pretty much groundless. There are some genuine spots where STL has a real performance problems, but I don&#x27;t think your example illustrates it well.</div><br/><div id="39162357" class="c"><input type="checkbox" id="c-39162357" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162342">parent</a><span>|</span><a href="#39162154">next</a><span>|</span><label class="collapse" for="c-39162357">[-]</label><label class="expand" for="c-39162357">[1 more]</label></div><br/><div class="children"><div class="content">Click the link in my post, I added it so you can see everything in action for yourself.<p>(Although, note I didn&#x27;t claim &quot;the STL is slow&quot;... that&#x27;s painting with a much broader stroke than I made.)</div><br/></div></div></div></div><div id="39162154" class="c"><input type="checkbox" id="c-39162154" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162103">parent</a><span>|</span><a href="#39162342">prev</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162154">[-]</label><label class="expand" for="c-39162154">[7 more]</label></div><br/><div class="children"><div class="content">Why would that be faster? Those function calls are going to be inlined.</div><br/><div id="39162161" class="c"><input type="checkbox" id="c-39162161" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162154">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162161">[-]</label><label class="expand" for="c-39162161">[6 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not the function calls they are alluding to, it&#x27;s the way the compiler generates a bunch of shifts and multiplies except in the can_fit_2 case.</div><br/><div id="39162329" class="c"><input type="checkbox" id="c-39162329" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162161">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162329">[-]</label><label class="expand" for="c-39162329">[5 more]</label></div><br/><div class="children"><div class="content">Turns out GCC is more clever than Clang here, and MSVC is just horrendous. (See update, I posted a link.)</div><br/><div id="39162408" class="c"><input type="checkbox" id="c-39162408" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162329">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162408">[-]</label><label class="expand" for="c-39162408">[4 more]</label></div><br/><div class="children"><div class="content">I somewhat agree with your point (esp. that MSVC is hideous) but I also stand by mine. I don&#x27;t feel that checking the capacity is something that would be in my tight loop, because checking for capacity to hold N is something you do before adding N items, which amortizes the cost, meaning the capacity check is just off the real hot path. So it doesn&#x27;t feel like a realistic use case.<p>Speaking of realism, putting these in quickbench seems to confirm that the differences between them are not material, and that the STL version is in fact the quickest, but they are all essentially free. There&#x27;s not a way to make a realistic microbenchmark for this, for the same reason that it doesn&#x27;t feel like a real-world performance issue.<p>By the way clang does a much better job here: <a href="https:&#x2F;&#x2F;quick-bench.com&#x2F;q&#x2F;XcKK782d-7A6YHbiBRTlOnIRnPY" rel="nofollow">https:&#x2F;&#x2F;quick-bench.com&#x2F;q&#x2F;XcKK782d-7A6YHbiBRTlOnIRnPY</a></div><br/><div id="39162536" class="c"><input type="checkbox" id="c-39162536" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162408">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162536">[-]</label><label class="expand" for="c-39162536">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t feel that checking the capacity is something that would be in my tight loop, because checking for capacity to hold N is something you do before adding N items, which amortizes the cost, meaning the capacity check is just off the real hot path.<p>Your fallacy here is assuming that that just because N is a variable, therefore N is large. N can easily be 0, 1, 2, etc... it&#x27;s a variable because it&#x27;s not a fixed compile time value, not because it&#x27;s necessarily large. (This isn&#x27;t complexity analysis!)<p>&gt; Speaking of realism, putting these in quickbench seems to confirm that the differences between them are not material, and that the STL version is in fact the quickest,<p>Your benchmark is what&#x27;s unrealistic, not my example.<p>I&#x27;m guessing you didn&#x27;t look at the disassembly (?) because your STL version is using SSE2 instructions (vectorizing?), which should tell you something funny is going on, because this isn&#x27;t vectorizable, and it&#x27;s not like we have floating-point here (which uses SSE2 by default).<p>Notice you&#x27;re just doing arithmetic on the pointers repeatedly. You&#x27;re not actually modifying them. It sure looks like Clang is noticing this and vectorizing your (completely useless) math. This is as far from &quot;realistic&quot; as you could possibly make the benchmark. Nobody would do this and then throw away the result. They would actually try to modify the vector in between.<p>I don&#x27;t have the energy to play with your example, but I would suggest playing around with it more and trying to disprove your position before assuming you&#x27;ve proven anything. Benchmarks are notoriously easy to get wrong.<p>&gt; So it doesn&#x27;t feel like a realistic use case.<p>I only knew of this example because I&#x27;ve literally had to optimize this before.
Not everyone has seen every performance problem; clearly you hadn&#x27;t run across this issue before. That&#x27;s fine, but that doesn&#x27;t mean reality is limited to what you&#x27;ve seen.<p>I really recommend not replying with this sentiment in the future. This sort of denial of people&#x27;s reality (sadly too common in the performance space) just turns people off from the conversation, and makes them immediately discredit (or just ignore&#x2F;disengage from) everything you say afterward. Which is a shame, because this kind of a conversation can be a learning experience for both sides, but it can&#x27;t do that if you just cement yourself in your own position and assume others are painting a false reality.</div><br/><div id="39162659" class="c"><input type="checkbox" id="c-39162659" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162536">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162659">[-]</label><label class="expand" for="c-39162659">[2 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t believe you typed all that just to show your condescending, point-missing aspect to its fullest.</div><br/><div id="39162783" class="c"><input type="checkbox" id="c-39162783" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162659">parent</a><span>|</span><a href="#39161160">next</a><span>|</span><label class="collapse" for="c-39162783">[-]</label><label class="expand" for="c-39162783">[1 more]</label></div><br/><div class="children"><div class="content">I gave you an example from my personal experience in the real world. Instead of asking for the context, a benchmark, or anything else, just went ahead and declared I&#x27;m giving you an unrealistic example... surely you can see why this is kind of offensive? I suggested you don&#x27;t do that, and even explained specifically what appeared off in your benchmark. This is missing the point and being condescending?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="39161160" class="c"><input type="checkbox" id="c-39161160" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161140">parent</a><span>|</span><a href="#39162103">prev</a><span>|</span><a href="#39161807">next</a><span>|</span><label class="collapse" for="c-39161160">[-]</label><label class="expand" for="c-39161160">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the issue that std::vector&lt;bool&gt; is required by the standard to be specialized as a bitset, which is a footgun in generic code since you can normally take the address of a vector element but not if it&#x27;s a vector of bool. Having a bitset in the standard library is fine but it should have been a seperate type.<p>Admittedly that&#x27;s not a performance issue, but it&#x27;s annoying.</div><br/><div id="39161544" class="c"><input type="checkbox" id="c-39161544" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161160">parent</a><span>|</span><a href="#39161807">next</a><span>|</span><label class="collapse" for="c-39161544">[-]</label><label class="expand" for="c-39161544">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true but I think everyone knows about vector&lt;bool&gt; being quirky. By the way, the standard does not require vector&lt;bool&gt; to be implemented as a bitset. Instead, it relaxes some of the details of vector, in a way that allows the implementation to do it that way. But these choices are implementation details.<p>Vector&lt;bool&gt; is a little weird if you are just starting with C++, but it does have major performance benefits in its niche, and it came from the 1990s so we can be generous in overlooking its rough edges.</div><br/></div></div></div></div></div></div><div id="39161807" class="c"><input type="checkbox" id="c-39161807" checked=""/><div class="controls bullet"><span class="by">CyberDildonics</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161104">parent</a><span>|</span><a href="#39161140">prev</a><span>|</span><a href="#39161661">next</a><span>|</span><label class="collapse" for="c-39161807">[-]</label><label class="expand" for="c-39161807">[1 more]</label></div><br/><div class="children"><div class="content">What specifically is wrong with vector? There have been a lot of hash maps done with flat memory to minimize allocations and pointer hopping over the STL but vector doesn&#x27;t have those problems.</div><br/></div></div></div></div><div id="39161661" class="c"><input type="checkbox" id="c-39161661" checked=""/><div class="controls bullet"><span class="by">MichaelMoser123</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161104">prev</a><span>|</span><a href="#39161101">next</a><span>|</span><label class="collapse" for="c-39161661">[-]</label><label class="expand" for="c-39161661">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t it contradicts the &#x27;bloat free&#x27; requirement, if every library needs to have its own version of std::list std::vector, std::unordered_map etc ?<p>I mean: i remember the days, when each and every project had its own string class.</div><br/><div id="39161785" class="c"><input type="checkbox" id="c-39161785" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161661">parent</a><span>|</span><a href="#39161101">next</a><span>|</span><label class="collapse" for="c-39161785">[-]</label><label class="expand" for="c-39161785">[1 more]</label></div><br/><div class="children"><div class="content">The implementations of vector, list, and unordered_map in every standard library I&#x27;ve used have been sufficient for every C++ library I&#x27;ve worked on.<p>There are special cases, and there are engineering politics, but it&#x27;s all basically fine.</div><br/></div></div></div></div><div id="39161253" class="c"><input type="checkbox" id="c-39161253" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39161042">parent</a><span>|</span><a href="#39161101">prev</a><span>|</span><a href="#39160980">next</a><span>|</span><label class="collapse" for="c-39161253">[-]</label><label class="expand" for="c-39161253">[3 more]</label></div><br/><div class="children"><div class="content">Because unlike CoreLib, the standard library in C++ tends to have a lot of insanity backed in. My knowledge on it is somewhat limited but looking into its APIs for working with strings (in large inherited from C) was so traumatizing that I only ever wonder why there are still self-respecting projects that <i>don&#x27;t</i> reimplement parts of STL.<p>Example: want to measure the length of a UTF-8 code point in a string and did not synchronize the call? Well, too bad, now you might have corrupted the global mutable state it relies on! (the fact that you can make such a trivial piece of code have two!!! points of thread-safety failure one is C locale and another is transcoder still refuses to leave my mind)</div><br/><div id="39162086" class="c"><input type="checkbox" id="c-39162086" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39161253">parent</a><span>|</span><a href="#39160980">next</a><span>|</span><label class="collapse" for="c-39162086">[-]</label><label class="expand" for="c-39162086">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t believe someone actually went out of their way to downvote this haha</div><br/><div id="39162815" class="c"><input type="checkbox" id="c-39162815" checked=""/><div class="controls bullet"><span class="by">Chaosvex</span><span>|</span><a href="#39161042">root</a><span>|</span><a href="#39162086">parent</a><span>|</span><a href="#39160980">next</a><span>|</span><label class="collapse" for="c-39162815">[-]</label><label class="expand" for="c-39162815">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like you weren&#x27;t working with C++&#x27;s string API. std::string knows nothing about the encoding of the data it encapsulates and can be used to store anything. There are the codecvt functions but it doesn&#x27;t sound like you&#x27;re talking about those, either.</div><br/></div></div></div></div></div></div></div></div><div id="39160980" class="c"><input type="checkbox" id="c-39160980" checked=""/><div class="controls bullet"><span class="by">Profan</span><span>|</span><a href="#39161042">prev</a><span>|</span><label class="collapse" for="c-39160980">[-]</label><label class="expand" for="c-39160980">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s still funny to me how something titled &quot;Sane C++ libraries&quot; has zero interop with the STL; guaranteeing an even more fragmented C++ ecosystem.<p>C++ has its place, but something new could not possibly displace it soon enough, even with C it feels like libraries fit together more easily.</div><br/><div id="39161036" class="c"><input type="checkbox" id="c-39161036" checked=""/><div class="controls bullet"><span class="by">chornos</span><span>|</span><a href="#39160980">parent</a><span>|</span><label class="collapse" for="c-39161036">[-]</label><label class="expand" for="c-39161036">[1 more]</label></div><br/><div class="children"><div class="content">Its the very reason C++ is still alive. Its unopinionated  on how u code and coding enviroment. Plenty of other language are far more restricted in their ecosystem</div><br/></div></div></div></div></div></div></div></div></div></body></html>