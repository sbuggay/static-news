<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734858060859" as="style"/><link rel="stylesheet" href="styles.css?v=1734858060859"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/rivet-gg/rivet">Show HN: Rivet Actors – Durable Objects build with Rust, FoundationDB, Isolates</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>NathanFlurry</span> | <span>22 comments</span></div><br/><div><div id="42484951" class="c"><input type="checkbox" id="c-42484951" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#42484717">next</a><span>|</span><label class="collapse" for="c-42484951">[-]</label><label class="expand" for="c-42484951">[1 more]</label></div><br/><div class="children"><div class="content">For ages I&#x27;ve been hoping someone will clone Durable Objects and here you are! I&#x27;m going to check this out.<p>Are there any gotchas or differences from Durable Objects behaviour when using Rivet Actors? There seems to be quite a lot of subtlety in some of how they handle e.g. IO, so I assume you wouldn&#x27;t be compatible with this directly?<p><a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;durable-objects-easy-fast-correct-choose-three&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;durable-objects-easy-fast-correc...</a></div><br/></div></div><div id="42484717" class="c"><input type="checkbox" id="c-42484717" checked=""/><div class="controls bullet"><span class="by">Hixon10</span><span>|</span><a href="#42484951">prev</a><span>|</span><a href="#42477308">next</a><span>|</span><label class="collapse" for="c-42484717">[-]</label><label class="expand" for="c-42484717">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Here&#x27;s where Rivet&#x27;s architecture gets fun – we don&#x27;t rely on a traditional orchestrator like Kubernetes or Nomad for our runtime. Instead, our orchestrator is powered by an in-house actor-like workflow engine – similar to how FoundationDB is powered by their own actor library (Flow [4]) internally. It lets us reliably &amp; efficiently build complex logic – like our orchestrator – that would normally be incredibly difficult to build correctly. For example, here&#x27;s the logic that powers Rivet Actors themselves with complex mechanisms like retry upgrades, retry backoffs, and draining [2].<p>It is a bit unclear for me, do you use actors themself to develop Rivet Actors, or it is another actor-like workflow engine, not the final product?<p>(I would be super happy to read an article, which explains architecture, main blocks of the system, gives some an example)</div><br/></div></div><div id="42477308" class="c"><input type="checkbox" id="c-42477308" checked=""/><div class="controls bullet"><span class="by">iFire</span><span>|</span><a href="#42484717">prev</a><span>|</span><a href="#42482630">next</a><span>|</span><label class="collapse" for="c-42477308">[-]</label><label class="expand" for="c-42477308">[3 more]</label></div><br/><div class="children"><div class="content">If I wanted a Rivet integration with Godot Engine and&#x2F;or Elixir, how would I do it for shared durable objects in a virtual reality environment?<p>I have code for Godot Engine Foundationdb access, but I&#x27;m cutting too many encapsulation layers.</div><br/><div id="42479990" class="c"><input type="checkbox" id="c-42479990" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42477308">parent</a><span>|</span><a href="#42482630">next</a><span>|</span><label class="collapse" for="c-42479990">[-]</label><label class="expand" for="c-42479990">[2 more]</label></div><br/><div class="children"><div class="content">You have Godot wired up to talk to FoundationDB? That&#x27;s incredibly cool, curious about your use case.<p>Godot runs using our container runtime  on Rivet. The FDB API for containers is currently undocumented. I&#x27;d be happy to share early access on Discord – <a href="https:&#x2F;&#x2F;rivet.gg&#x2F;discord">https:&#x2F;&#x2F;rivet.gg&#x2F;discord</a><p>Games running on Rivet usually have a hybrid of actors that handle persistent storage (e.g. a matchmaker) and the game server itself.</div><br/><div id="42483186" class="c"><input type="checkbox" id="c-42483186" checked=""/><div class="controls bullet"><span class="by">iFire</span><span>|</span><a href="#42477308">root</a><span>|</span><a href="#42479990">parent</a><span>|</span><a href="#42482630">next</a><span>|</span><label class="collapse" for="c-42483186">[-]</label><label class="expand" for="c-42483186">[1 more]</label></div><br/><div class="children"><div class="content">I aim to build a collaborative VR world editor in Godot using mvsqlite for shared scene persistence.<p>I was salvaging someone else&#x27;s toy project. The main problem with my research was write performance in SQLite on FDB. I didn&#x27;t have the capacity to integrate Hctree, which was in the pipeline.<p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;V-Sekai&#x2F;godot-mvsqlite">https:&#x2F;&#x2F;github.com&#x2F;V-Sekai&#x2F;godot-mvsqlite</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;V-Sekai&#x2F;mvsqlite">https:&#x2F;&#x2F;github.com&#x2F;V-Sekai&#x2F;mvsqlite</a><p>* <a href="https:&#x2F;&#x2F;github.com&#x2F;V-Sekai&#x2F;elixir-mvsqlite">https:&#x2F;&#x2F;github.com&#x2F;V-Sekai&#x2F;elixir-mvsqlite</a><p>* <a href="https:&#x2F;&#x2F;sqlite.org&#x2F;hctree&#x2F;doc&#x2F;hctree&#x2F;doc&#x2F;hctree&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;hctree&#x2F;doc&#x2F;hctree&#x2F;doc&#x2F;hctree&#x2F;index.html</a><p>Let&#x27;s connect on discord.</div><br/></div></div></div></div></div></div><div id="42482630" class="c"><input type="checkbox" id="c-42482630" checked=""/><div class="controls bullet"><span class="by">FjordWarden</span><span>|</span><a href="#42477308">prev</a><span>|</span><a href="#42482964">next</a><span>|</span><label class="collapse" for="c-42482630">[-]</label><label class="expand" for="c-42482630">[2 more]</label></div><br/><div class="children"><div class="content">How is this different from the Durable Promises idea by ResonateHQ?
It seams to me a bitter easer to get started with as a small standalone project.
Would you mind comparing this solutions to that?</div><br/><div id="42483889" class="c"><input type="checkbox" id="c-42483889" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42482630">parent</a><span>|</span><a href="#42482964">next</a><span>|</span><label class="collapse" for="c-42483889">[-]</label><label class="expand" for="c-42483889">[1 more]</label></div><br/><div class="children"><div class="content">I skimmed a bit about Durable Promises, and if I understand correctly, they’re similar to workflow tools like Temporal but come with high-quality language bindings that let you write workflow steps using async&#x2F;await.<p>We built something almost identical in Rust to let us use async&#x2F;await for long-running &amp; failure-prone workflows. This powers almost everything we do at Rivet. We have a technical writeup coming later, but here&#x27;s a couple links of interest:<p>- Rough overview: <a href="https:&#x2F;&#x2F;github.com&#x2F;rivet-gg&#x2F;rivet&#x2F;blob&#x2F;58b073a7cae20adcf0fa36e46ebb4c04da44a1e6&#x2F;docs-internal&#x2F;libraries&#x2F;workflow&#x2F;OVERVIEW.md">https:&#x2F;&#x2F;github.com&#x2F;rivet-gg&#x2F;rivet&#x2F;blob&#x2F;58b073a7cae20adcf0fa3...</a><p>- Example async&#x2F;await-heavy workflow: <a href="https:&#x2F;&#x2F;github.com&#x2F;rivet-gg&#x2F;rivet&#x2F;blob&#x2F;58b073a7cae20adcf0fa36e46ebb4c04da44a1e6&#x2F;packages&#x2F;services&#x2F;linode&#x2F;src&#x2F;workflows&#x2F;server&#x2F;mod.rs#L97">https:&#x2F;&#x2F;github.com&#x2F;rivet-gg&#x2F;rivet&#x2F;blob&#x2F;58b073a7cae20adcf0fa3...</a><p>- Example actor-like workflow: <a href="https:&#x2F;&#x2F;github.com&#x2F;rivet-gg&#x2F;rivet&#x2F;blob&#x2F;58b073a7cae20adcf0fa36e46ebb4c04da44a1e6&#x2F;packages&#x2F;services&#x2F;pegboard&#x2F;src&#x2F;workflows&#x2F;client.rs#L16">https:&#x2F;&#x2F;github.com&#x2F;rivet-gg&#x2F;rivet&#x2F;blob&#x2F;58b073a7cae20adcf0fa3...</a><p>Rivet Actors can start, stop, or crash at any time and still continue functioning, much like Durable Promises.<p>However, their scope differs: Rivet Actors are broader and designed for anything stateful &amp; realtime, while Durable Promises seem focused on workflows with complex control flow.<p>Rivet Actors can (and likely will) support workflow-like applications in the future, since state management and rescheduling are already built-in.<p>For a deeper dive, Temporal has a writeup comparing actors and workflows: <a href="https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;workflows-as-actors-is-it-really-possible" rel="nofollow">https:&#x2F;&#x2F;temporal.io&#x2F;blog&#x2F;workflows-as-actors-is-it-really-po...</a></div><br/></div></div></div></div><div id="42482964" class="c"><input type="checkbox" id="c-42482964" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#42482630">prev</a><span>|</span><a href="#42472661">next</a><span>|</span><label class="collapse" for="c-42482964">[-]</label><label class="expand" for="c-42482964">[4 more]</label></div><br/><div class="children"><div class="content">Here’s my once a month comment that I should probably put on autopilot:<p>“at least half of show HN posts are just reimplementations of what already exits in Erlang&#x2F;Elixir”.</div><br/><div id="42483005" class="c"><input type="checkbox" id="c-42483005" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#42482964">parent</a><span>|</span><a href="#42483604">next</a><span>|</span><label class="collapse" for="c-42483005">[-]</label><label class="expand" for="c-42483005">[1 more]</label></div><br/><div class="children"><div class="content">The actor model existed before Erlang, and Erlang doesn&#x27;t have some kind of a monopoly on it. Akka is pretty good too.<p>Same as every OOP isn&#x27;t &quot;something that exists already in Java&quot;</div><br/></div></div><div id="42483604" class="c"><input type="checkbox" id="c-42483604" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42482964">parent</a><span>|</span><a href="#42483005">prev</a><span>|</span><a href="#42472661">next</a><span>|</span><label class="collapse" for="c-42483604">[-]</label><label class="expand" for="c-42483604">[2 more]</label></div><br/><div class="children"><div class="content">Haha, I’m with you there. I was considering calling that out in the post.<p>I dearly love Erlang &amp; co., but its learning curve is way too steep for most developers today. Our goal is to bring the benefits of Erlang&#x2F;Akka&#x2F;Orleans&#x2F;etc. to more developers by:<p>(a) supporting mainstream languages, and<p>(b) lowering the technical and conceptual barriers to entry.</div><br/><div id="42484899" class="c"><input type="checkbox" id="c-42484899" checked=""/><div class="controls bullet"><span class="by">cpursley</span><span>|</span><a href="#42482964">root</a><span>|</span><a href="#42483604">parent</a><span>|</span><a href="#42472661">next</a><span>|</span><label class="collapse" for="c-42484899">[-]</label><label class="expand" for="c-42484899">[1 more]</label></div><br/><div class="children"><div class="content">Erlang has its quirks but Elixir at least is an order of magnitude easier to learn than Rust or Java.</div><br/></div></div></div></div></div></div><div id="42472661" class="c"><input type="checkbox" id="c-42472661" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#42482964">prev</a><span>|</span><a href="#42482888">next</a><span>|</span><label class="collapse" for="c-42472661">[-]</label><label class="expand" for="c-42472661">[3 more]</label></div><br/><div class="children"><div class="content">Related discussion in 2023 <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37188659">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37188659</a></div><br/><div id="42472780" class="c"><input type="checkbox" id="c-42472780" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42472661">parent</a><span>|</span><a href="#42482238">next</a><span>|</span><label class="collapse" for="c-42472780">[-]</label><label class="expand" for="c-42472780">[1 more]</label></div><br/><div class="children"><div class="content">Yep! Same repo, lots of changes. Since we were on HN in 2023, we&#x27;ve:<p>- Rewrote Nomad from scratch with our own in-house workflow engine<p>- Launched Rivet Actors and isolate runtime<p>- Overhauled our OSS experience to make self-hosting easier<p>- Rewrote frontend from scratch with shadcn to be like the cool kids<p>- Replaced Nebula with mTLS<p>- Completely stripped out Redis for non-caching use cases<p>We&#x27;ve also opened up the platform to non-gaming use cases.</div><br/></div></div><div id="42482238" class="c"><input type="checkbox" id="c-42482238" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42472661">parent</a><span>|</span><a href="#42472780">prev</a><span>|</span><a href="#42482888">next</a><span>|</span><label class="collapse" for="c-42482238">[-]</label><label class="expand" for="c-42482238">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve added that link above. Thanks!</div><br/></div></div></div></div><div id="42482888" class="c"><input type="checkbox" id="c-42482888" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42472661">prev</a><span>|</span><a href="#42482950">next</a><span>|</span><label class="collapse" for="c-42482888">[-]</label><label class="expand" for="c-42482888">[4 more]</label></div><br/><div class="children"><div class="content">What kinds of web sites need this level of complexity? They must be doing something really hard and tightly coordinated, such as collaborative editing, right?<p>Does this have enough performance to solve the server cost problem of Improbable&#x27;s metaverse back end? That&#x27;s a remote object system too expensive to run 24&#x2F;7.</div><br/><div id="42483483" class="c"><input type="checkbox" id="c-42483483" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42482888">parent</a><span>|</span><a href="#42483009">next</a><span>|</span><label class="collapse" for="c-42483483">[-]</label><label class="expand" for="c-42483483">[1 more]</label></div><br/><div class="children"><div class="content">Hey!<p>&gt; What kinds of web sites need this level of complexity?<p>The most common use cases are high contention &amp; strong consistency workloads where using an OLTP database doesn&#x27;t work well. A few examples:<p>- Collaborative docs<p>- Local-first &amp; CRDT sync (e.g. Yjs)<p>- Stateful multiplayer games, often async multiplayer (e.g. chess)<p>- Agentic workflows with frequent memory updates<p>- Chat<p>- Scheduling software<p>- Rate limiting<p>Actors can also be used for stateless realtime workloads that benefit from edge computing, similar to what you would use existing serverless edge functions for.<p>The actor model is widely used in larger companies. The best-known example is how WhatsApp used Erlang to scale to 900 M users with 50 devs [2]. It&#x27;s also widely used at Discord, LinkedIn, Microsoft, etc. Take a look at Erlang&#x2F;Elixir, Akka, and Orleans for prior art.<p>&gt; Does this have enough performance to solve the server cost problem of Improbable&#x27;s metaverse back end?<p>Actors usually have a single responsibility (e.g. document or chat room) while Improbable focused on building expansive worlds without clear boundaries between entities. Our docs include tips on scoping the responsibility of actors [1].<p>The actor model encourages actor-actor communication, sort of similar how entities in the ECS model communicate in games.<p>&gt; That&#x27;s a remote object system too expensive to run 24&#x2F;7.<p>Actors automatically go to sleep when unused. They provide the benefit of realtime workloads without the cost of keep idle compute sitting around.<p>[1] <a href="https:&#x2F;&#x2F;rivet.gg&#x2F;docs&#x2F;scaling#tips-for-architecting-actors-for-scale">https:&#x2F;&#x2F;rivet.gg&#x2F;docs&#x2F;scaling#tips-for-architecting-actors-f...</a><p>[2] <a href="https:&#x2F;&#x2F;www.wired.com&#x2F;2015&#x2F;09&#x2F;whatsapp-serves-900-million-users-50-engineers&#x2F;#:~:text=Part%20of%20the%20trick%20is%20that%20the%20company%20builds%20its%20service%20using%20a%20programming%20language%20called%20Erlang" rel="nofollow">https:&#x2F;&#x2F;www.wired.com&#x2F;2015&#x2F;09&#x2F;whatsapp-serves-900-million-us...</a>.</div><br/></div></div><div id="42483009" class="c"><input type="checkbox" id="c-42483009" checked=""/><div class="controls bullet"><span class="by">declan_roberts</span><span>|</span><a href="#42482888">parent</a><span>|</span><a href="#42483483">prev</a><span>|</span><a href="#42482950">next</a><span>|</span><label class="collapse" for="c-42483009">[-]</label><label class="expand" for="c-42483009">[2 more]</label></div><br/><div class="children"><div class="content">If you have a really tiny bit of compute that must happen on the edge, I guess it makes sense.</div><br/><div id="42483497" class="c"><input type="checkbox" id="c-42483497" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42482888">root</a><span>|</span><a href="#42483009">parent</a><span>|</span><a href="#42482950">next</a><span>|</span><label class="collapse" for="c-42483497">[-]</label><label class="expand" for="c-42483497">[1 more]</label></div><br/><div class="children"><div class="content">For example – I&#x27;m a big proponent of local-first apps, but even those require a sync server. You can easily implement one in under 100 lines of code with actors.</div><br/></div></div></div></div></div></div><div id="42482950" class="c"><input type="checkbox" id="c-42482950" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42482888">prev</a><span>|</span><label class="collapse" for="c-42482950">[-]</label><label class="expand" for="c-42482950">[3 more]</label></div><br/><div class="children"><div class="content">Out of curiosity, what&#x27;s the sort of consistency (in the sense of linearizable etc.,.) provided here? If an RPC is handled by some actor, is it guaranteed to have seen all previously accepted messages that completed up to that point?<p>If so, how does that work?<p>Edit: I guess this sort of comes by forcing everything to round trip through foundationdb for state? As long as the actor reads the state from foundationdb before handling the response, and writes to foundationdb before sending a reply, it should guarantee the same sort of consistency you&#x27;d get from foundationdb?<p>What about calls to other actors? If I make a potentially state changing RPC call to some other actor as a part of handling an RPC, do those commit together, or is it possible for the other actor to commit without me?</div><br/><div id="42483667" class="c"><input type="checkbox" id="c-42483667" checked=""/><div class="controls bullet"><span class="by">NathanFlurry</span><span>|</span><a href="#42482950">parent</a><span>|</span><label class="collapse" for="c-42483667">[-]</label><label class="expand" for="c-42483667">[2 more]</label></div><br/><div class="children"><div class="content">We document as many design decisions like this as we can. Here’s a related bit on serial vs. parallel RPC&#x2F;message handling [1].<p>&gt; I guess this sort of comes by forcing everything to round-trip through FoundationDB for state?<p>If you’re using the KV API directly, this is correct.<p>Actors also have a `this._state` property, which is automatically written to FDB after each RPC call if modified [2]. This allows developers to rapidly prototype by writing vanilla JS code like `this._state.count += 1` without having to worry about writing state and its associated edge cases.<p>&gt; What about calls to other actors? If I make a potentially state-changing RPC call to some other actor as part of handling an RPC, do those commit together, or is it possible for the other actor to commit without me?<p>Not at the moment. You’d need to use a 2-phase commit for that.<p>[1] <a href="https:&#x2F;&#x2F;rivet.gg&#x2F;docs&#x2F;internals&#x2F;design-decisions#parallel-rpc-handlers-vs-serial-message-handlers">https:&#x2F;&#x2F;rivet.gg&#x2F;docs&#x2F;internals&#x2F;design-decisions#parallel-rp...</a><p>[2] <a href="https:&#x2F;&#x2F;rivet.gg&#x2F;docs&#x2F;state#state-saves">https:&#x2F;&#x2F;rivet.gg&#x2F;docs&#x2F;state#state-saves</a></div><br/><div id="42484286" class="c"><input type="checkbox" id="c-42484286" checked=""/><div class="controls bullet"><span class="by">foota</span><span>|</span><a href="#42482950">root</a><span>|</span><a href="#42483667">parent</a><span>|</span><label class="collapse" for="c-42484286">[-]</label><label class="expand" for="c-42484286">[1 more]</label></div><br/><div class="children"><div class="content">Got it, thanks for the reply!<p>It might be interesting if there were a way to represent a part of a transaction to commit as a sort of effect of an RPC. I don&#x27;t know the details, but I&#x27;m aware of a non-public system that does a similar sort of thing to coordinate a distributed transaction between many different RPC services that are otherwise opaque.<p>E.g., you make a bunch of RPC calls, some part of the framework is tracking the read set and writes that need to be made, and then when the root of the RPC is ready to commit it can all atomically commit or fail (if there was a transaction conflict or something).</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>