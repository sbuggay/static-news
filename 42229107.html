<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732525268515" as="style"/><link rel="stylesheet" href="styles.css?v=1732525268515"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://inside.java/2024/11/22/mark-scavenge-gc/">Mark–Scavenge: Waiting for Trash to Take Itself Out</a> <span class="domain">(<a href="https://inside.java">inside.java</a>)</span></div><div class="subtext"><span>vips7L</span> | <span>30 comments</span></div><br/><div><div id="42231626" class="c"><input type="checkbox" id="c-42231626" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#42229771">next</a><span>|</span><label class="collapse" for="c-42231626">[-]</label><label class="expand" for="c-42231626">[1 more]</label></div><br/><div class="children"><div class="content">This is fascinating.<p>The idea of mark&#x2F;scavenge is pretty cool for page-based allocation and deallocation.<p>Also real-time or maybe latency-intolerant systems, which basically can&#x27;t block for garbage collection.  You could probably keep scavenging and stay ahead of things without impacting things in a black and white way.</div><br/></div></div><div id="42229771" class="c"><input type="checkbox" id="c-42229771" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42231626">prev</a><span>|</span><a href="#42231934">next</a><span>|</span><label class="collapse" for="c-42229771">[-]</label><label class="expand" for="c-42229771">[24 more]</label></div><br/><div class="children"><div class="content"><i>&gt; Modern garbage collection assumes that the weak generational hypothesis holds and that most objects die young</i><p>Aside, I&#x27;m curious how first-class support for value types and Go-style stack allocation via escape analysis changes the value proposition of the generational hypothesis. If we hypothesize that short-lived objects are local to a single function scope (and thus eligible for stack allocation either explicitly via a value type or heuristically via escape analysis) then it might completely upend the generational hypothesis and make it so that relatively more long-lived objects are getting heap-allocated. Surely someone&#x27;s done some studies on this?</div><br/><div id="42230245" class="c"><input type="checkbox" id="c-42230245" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42229771">parent</a><span>|</span><a href="#42231160">next</a><span>|</span><label class="collapse" for="c-42230245">[-]</label><label class="expand" for="c-42230245">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it might completely upend the generational hypothesis<p>The generational hypothesis is about object lifetime, and that doesn&#x27;t change.<p>It does change the relevance of the generational hypothesis to garbage collection.<p>&gt; Surely someone&#x27;s done some studies on this?<p>The go team has, and that&#x27;s why go doesn&#x27;t have a generational GC. The complexity of adding generational support, especially in a mutation-based language (so needing memory barriers and the like) was found not to benefit when a significant fraction of the newborn objects don&#x27;t even reach the youngen. See <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;70257#discussioncomment-11201305">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;70257#discussioncom...</a> from the current discussion of adding opt-in ad-hoc support for memory regions.</div><br/></div></div><div id="42231160" class="c"><input type="checkbox" id="c-42231160" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#42229771">parent</a><span>|</span><a href="#42230245">prev</a><span>|</span><a href="#42230855">next</a><span>|</span><label class="collapse" for="c-42231160">[-]</label><label class="expand" for="c-42231160">[1 more]</label></div><br/><div class="children"><div class="content">If you flip the argument on its head you can frame it as: since most objects die young it&#x27;s very likely they will stay on the stack and thus it makes sense to invest in an allocation-site optimizer that will put the object on the heap only if static escape analysis says it may escape the lexical scope.</div><br/></div></div><div id="42230855" class="c"><input type="checkbox" id="c-42230855" checked=""/><div class="controls bullet"><span class="by">uluyol</span><span>|</span><a href="#42229771">parent</a><span>|</span><a href="#42231160">prev</a><span>|</span><a href="#42229820">next</a><span>|</span><label class="collapse" for="c-42230855">[-]</label><label class="expand" for="c-42230855">[1 more]</label></div><br/><div class="children"><div class="content">You might be interested in this talk: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;ismmkeynote" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;ismmkeynote</a></div><br/></div></div><div id="42229820" class="c"><input type="checkbox" id="c-42229820" checked=""/><div class="controls bullet"><span class="by">DamonHD</span><span>|</span><a href="#42229771">parent</a><span>|</span><a href="#42230855">prev</a><span>|</span><a href="#42230094">next</a><span>|</span><label class="collapse" for="c-42229820">[-]</label><label class="expand" for="c-42229820">[17 more]</label></div><br/><div class="children"><div class="content">AFAIK not nearly enough stuff gets caught by escape analysis - and thus stack allocated - to make a difference.</div><br/><div id="42230312" class="c"><input type="checkbox" id="c-42230312" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42229820">parent</a><span>|</span><a href="#42229860">next</a><span>|</span><label class="collapse" for="c-42230312">[-]</label><label class="expand" for="c-42230312">[1 more]</label></div><br/><div class="children"><div class="content">Go has much more significant stack allocation capabilities, most notably it has no problem allocating entire structs on the stack so doesn&#x27;t need scalar replacement, which falls over if you breathe on it (<a href="https:&#x2F;&#x2F;pkolaczk.github.io&#x2F;overhead-of-optional&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pkolaczk.github.io&#x2F;overhead-of-optional&#x2F;</a>).<p>According to <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;70257#discussioncomment-11201305">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;70257#discussioncom...</a><p>&gt; the weak generational hypothesis does not hold up well with respect to heap-allocated memory in many real-world Go programs (think 60-70% young object mortality vs. the 95% typically expected)</div><br/></div></div><div id="42229860" class="c"><input type="checkbox" id="c-42229860" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42229820">parent</a><span>|</span><a href="#42230312">prev</a><span>|</span><a href="#42230081">next</a><span>|</span><label class="collapse" for="c-42229860">[-]</label><label class="expand" for="c-42229860">[9 more]</label></div><br/><div class="children"><div class="content">I&#x27;m open to believing that this is true, but some real numbers would be nice. Surely it wouldn&#x27;t be a hugely invasive change to fork the Go compiler, change the stack allocation check to `return false`, and then measure the overhead of the garbage collector on real Go programs with stack allocation both enabled and disabled.</div><br/><div id="42230116" class="c"><input type="checkbox" id="c-42230116" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42229860">parent</a><span>|</span><a href="#42230000">next</a><span>|</span><label class="collapse" for="c-42230116">[-]</label><label class="expand" for="c-42230116">[1 more]</label></div><br/><div class="children"><div class="content">The reason escape analysis is not &quot;good enough&quot; is why we have project Valhalla trying to bring Value Types into the JVM.<p>I don&#x27;t have numbers at hand, but I remember the JDK Expert Group talking about this extensively in the past and why they deferred bringing Value Types for such a long time. They hoped complex enough EA can get rid of indirections and heap allocations but it just wasn&#x27;t powerful enough, even with all advances throughout the years.</div><br/></div></div><div id="42230000" class="c"><input type="checkbox" id="c-42230000" checked=""/><div class="controls bullet"><span class="by">DamonHD</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42229860">parent</a><span>|</span><a href="#42230116">prev</a><span>|</span><a href="#42230081">next</a><span>|</span><label class="collapse" for="c-42230000">[-]</label><label class="expand" for="c-42230000">[7 more]</label></div><br/><div class="children"><div class="content">I may have been answering past you - I am thinking of Java running on the JDK here.  And indeed I may be out of date also.</div><br/><div id="42230676" class="c"><input type="checkbox" id="c-42230676" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230000">parent</a><span>|</span><a href="#42231107">next</a><span>|</span><label class="collapse" for="c-42230676">[-]</label><label class="expand" for="c-42230676">[5 more]</label></div><br/><div class="children"><div class="content">Yeah in Java land specifically I think the question would become, &quot;does the generational hypothesis still hold up once we have Valhalla and a much larger share of short-lived objects are stack allocated as value types?&quot; but of course it may be years until the ecosystem reaches that point, if ever.</div><br/><div id="42230833" class="c"><input type="checkbox" id="c-42230833" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230676">parent</a><span>|</span><a href="#42231107">next</a><span>|</span><label class="collapse" for="c-42230833">[-]</label><label class="expand" for="c-42230833">[4 more]</label></div><br/><div class="children"><div class="content">As shown by C#, it will generally continue to be relevant since both primarily use JIT compilation with ability to modify code at runtime which can violate inter-procedural escape analysis assumptions leading to heap allocations of the objects that are passed down to the callees (there is work scheduled for .NET 10 to address this, at least for AOT compilation where interproc analysis conclusions will be impossible to violate).<p>You can craft a workload which violates the hypothesis by only allocating objects that live for a long time but both JVM and .NET GC implementations are still much faster designs than Go&#x27;s GC which prioritizes small memory footprint and consistent latency on <i>low</i> allocation traffic (though as of .NET 9, SRV GC puts much more priority on this, making similar tradeoffs).</div><br/><div id="42230933" class="c"><input type="checkbox" id="c-42230933" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230833">parent</a><span>|</span><a href="#42231107">next</a><span>|</span><label class="collapse" for="c-42230933">[-]</label><label class="expand" for="c-42230933">[3 more]</label></div><br/><div class="children"><div class="content">&gt; <i>ability to modify code at runtime</i><p>Would Java&#x27;s moves towards &quot;integrity by default&quot; mean that this could be ruled out in more cases?</div><br/><div id="42231419" class="c"><input type="checkbox" id="c-42231419" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230933">parent</a><span>|</span><a href="#42231107">next</a><span>|</span><label class="collapse" for="c-42231419">[-]</label><label class="expand" for="c-42231419">[2 more]</label></div><br/><div class="children"><div class="content">Reading through the JEP again it does not seem to be related - it is about deprecating unsafe APIs that the executed code itself uses. OpenJDK also has &quot;partial escape analysis&quot; where the object that only conditionally escapes can still be placed on the stack&#x2F;scalar replaced.<p>I&#x27;m not privy to the exact APIs that OpenJDK exposes but in .NET the main limitation around escape analysis that spans multiple methods is the fact that CoreCLR has re-JIT API which allows to perform a multitude of actions like attaching a profiler or a debugger to a live application and forcing the runtime to deoptimize a particular method for debugging, or modifying the implementation and re-JITting the result. Debug codegen is very different especially around GC liveness tracking and escape analysis that builds on top of it - it means that even debug code would have to uphold stack-allocated nature of such object in some way, complicating the design significantly. In addition to that, debuggers and other instrumentation may observe object references that would have otherwise not escaped local scope.<p>This creates an unfortunate situation where the above almost never happens in production, but ignoring it and &quot;just stack-allocating anyway&quot; would lead to disastrous breakage for all sorts of existing instrumentation. Because Go does not have to deal with this constraint, it can perform interproc escape analysis without risk - whether a pointer escapes or not can be statically proven. For NativeAOT, .NET could approach this problem in the same way, but paraphrasing compiler team: &quot;We would like to avoid optimizations only available for one of the target types be it JIT or AOT, and only supporting AOT would not benefit the majority of the .NET users&quot;.<p>There is, however, recognition that more comprehensive interproc analysis could be very beneficial, including the EA which is why it is planned to work on it in .NET 10:<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;issues&#x2F;108931">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;issues&#x2F;108931</a> IPA framework<p>- <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;issues&#x2F;104936">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtime&#x2F;issues&#x2F;104936</a> Stack allocation enhancements</div><br/><div id="42231771" class="c"><input type="checkbox" id="c-42231771" checked=""/><div class="controls bullet"><span class="by">cempaka</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42231419">parent</a><span>|</span><a href="#42231107">next</a><span>|</span><label class="collapse" for="c-42231771">[-]</label><label class="expand" for="c-42231771">[1 more]</label></div><br/><div class="children"><div class="content">Yeah there&#x27;s a JEP around deprecating access to sun.misc.Unsafe, but that&#x27;s part of a larger effort including Jigsaw to push the Java ecosystem in the direction of modular builds, where more invariants are assumed to hold (e.g. &quot; &#x27;final&#x27; fields are <i>actually</i> final&quot;) unless explicitly opted out for each module. I would assume the lack of such guarantees in the status quo wreaks a lot of havoc with EA.<p>Profiling and debugging would be separate considerations -- I&#x27;m really not sure what limitations those impose on the JVM JIT.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42231107" class="c"><input type="checkbox" id="c-42231107" checked=""/><div class="controls bullet"><span class="by">DamonHD</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230000">parent</a><span>|</span><a href="#42230676">prev</a><span>|</span><a href="#42230081">next</a><span>|</span><label class="collapse" for="c-42231107">[-]</label><label class="expand" for="c-42231107">[1 more]</label></div><br/><div class="children"><div class="content">Ahem --- JDK =&gt; JVM!</div><br/></div></div></div></div></div></div><div id="42230081" class="c"><input type="checkbox" id="c-42230081" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42229820">parent</a><span>|</span><a href="#42229860">prev</a><span>|</span><a href="#42230161">next</a><span>|</span><label class="collapse" for="c-42230081">[-]</label><label class="expand" for="c-42230081">[1 more]</label></div><br/><div class="children"><div class="content">Historically, Hotspot&#x27;s escape analysis only resulted in avoided heap allocations (via scalar replacement) if all uses were inlined. I don&#x27;t think this has changed.</div><br/></div></div><div id="42230161" class="c"><input type="checkbox" id="c-42230161" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42229820">parent</a><span>|</span><a href="#42230081">prev</a><span>|</span><a href="#42230094">next</a><span>|</span><label class="collapse" for="c-42230161">[-]</label><label class="expand" for="c-42230161">[5 more]</label></div><br/><div class="children"><div class="content">Is there a language that makes this explicit, allocates the variables on the stack via compiler enforced notation?</div><br/><div id="42230236" class="c"><input type="checkbox" id="c-42230236" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230161">parent</a><span>|</span><a href="#42230300">next</a><span>|</span><label class="collapse" for="c-42230236">[-]</label><label class="expand" for="c-42230236">[3 more]</label></div><br/><div class="children"><div class="content">C, C++, Rust, Zig, …</div><br/><div id="42232629" class="c"><input type="checkbox" id="c-42232629" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230236">parent</a><span>|</span><a href="#42230300">next</a><span>|</span><label class="collapse" for="c-42232629">[-]</label><label class="expand" for="c-42232629">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s Zig&#x27;s notation for it?</div><br/><div id="42233718" class="c"><input type="checkbox" id="c-42233718" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42232629">parent</a><span>|</span><a href="#42230300">next</a><span>|</span><label class="collapse" for="c-42233718">[-]</label><label class="expand" for="c-42233718">[1 more]</label></div><br/><div class="children"><div class="content">Not doing anything, same as the other 3.<p>Heap allocation is what requires requesting memory from an  allocator.</div><br/></div></div></div></div></div></div><div id="42230300" class="c"><input type="checkbox" id="c-42230300" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230161">parent</a><span>|</span><a href="#42230236">prev</a><span>|</span><a href="#42230094">next</a><span>|</span><label class="collapse" for="c-42230300">[-]</label><label class="expand" for="c-42230300">[1 more]</label></div><br/><div class="children"><div class="content">C# (.NET in general) :)<p>Well, variables cannot be forced to stack specifically. They are placed in the &quot;local scope&quot;. And that would usually be either stack or CPU registers - thinking in stack only is a somewhat flawed mental model.<p>Both C# and F# complicate this by supporting closures, iterator and async methods which capture variables placing them in a state machine box &#x2F; display class instead which would be located on the heap, unless stack-allocated by escape analysis (unlikely because these usually cross method boundaries).<p>However, .NET has `ref structs` (or, in F#, [&lt;Struct; IsByRefLike&gt;] types) which are subject to lifetime analysis and can never be placed on the heap directly or otherwise.</div><br/></div></div></div></div></div></div><div id="42230094" class="c"><input type="checkbox" id="c-42230094" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#42229771">parent</a><span>|</span><a href="#42229820">prev</a><span>|</span><a href="#42230184">next</a><span>|</span><label class="collapse" for="c-42230094">[-]</label><label class="expand" for="c-42230094">[2 more]</label></div><br/><div class="children"><div class="content">But stack allocated objects are not part of the heap and therefore not even part of Garbage Collection? And afaik stack allocation is already done for objects which don&#x27;t escape a method.</div><br/><div id="42234105" class="c"><input type="checkbox" id="c-42234105" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42229771">root</a><span>|</span><a href="#42230094">parent</a><span>|</span><a href="#42230184">next</a><span>|</span><label class="collapse" for="c-42234105">[-]</label><label class="expand" for="c-42234105">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but that’s the point: objects which don’t escape are pretty much all young objects. So by this process the stack captures a significant fraction of the young generation, that young generation never reaches the heap and this is never under consideration by the GC.<p>Essentially the stack is a form of younggen. It is not as complete (as there are things which must be heap allocated) but because it <i>is</i>, it reduces the benefits of a generational GC… without having much impact on its costs and complexity.<p>Depending on work load, that competition can be sufficient to make a generational GC net negative.</div><br/></div></div></div></div></div></div><div id="42231934" class="c"><input type="checkbox" id="c-42231934" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#42229771">prev</a><span>|</span><a href="#42230109">next</a><span>|</span><label class="collapse" for="c-42231934">[-]</label><label class="expand" for="c-42231934">[1 more]</label></div><br/><div class="children"><div class="content">I was wondering if the .java TLD belonged to the Java island, or to Oracle or to someone else.<p><a href="https:&#x2F;&#x2F;icannwiki.org&#x2F;.java" rel="nofollow">https:&#x2F;&#x2F;icannwiki.org&#x2F;.java</a><p>It’s Oracle.</div><br/></div></div><div id="42230109" class="c"><input type="checkbox" id="c-42230109" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#42231934">prev</a><span>|</span><a href="#42229647">next</a><span>|</span><label class="collapse" for="c-42230109">[-]</label><label class="expand" for="c-42230109">[1 more]</label></div><br/><div class="children"><div class="content">How does this relate to Shenandoah&#x27;s region selection logic? Doesn&#x27;t it have similar behavior?</div><br/></div></div><div id="42229647" class="c"><input type="checkbox" id="c-42229647" checked=""/><div class="controls bullet"><span class="by">A4ET8a8uTh0</span><span>|</span><a href="#42230109">prev</a><span>|</span><label class="collapse" for="c-42229647">[-]</label><label class="expand" for="c-42229647">[2 more]</label></div><br/><div class="children"><div class="content">What a time to be alive, I read it the opening fully expecting to see an open source automated trashcan that takes itself to the curb each Monday. I was disappointed to find out it is about an actual garbage collection algorithm.</div><br/><div id="42229786" class="c"><input type="checkbox" id="c-42229786" checked=""/><div class="controls bullet"><span class="by">garblegarble</span><span>|</span><a href="#42229647">parent</a><span>|</span><label class="collapse" for="c-42229786">[-]</label><label class="expand" for="c-42229786">[1 more]</label></div><br/><div class="children"><div class="content">I know this is completely off-topic, but you might be interested in this[1] YouTuber who did something not far off that...<p>1: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VhYEOG9LOIk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=VhYEOG9LOIk</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>