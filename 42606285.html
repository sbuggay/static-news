<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736326879435" as="style"/><link rel="stylesheet" href="styles.css?v=1736326879435"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/RealTimeChris/BenchmarkSuite/blob/digit-counting/Benchmark/main.cpp">Optimizing uint64_t Digit Counting: A Method that Beats Lemire&#x27;s by up to 143%</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>realtimechris</span> | <span>13 comments</span></div><br/><div><div id="42631738" class="c"><input type="checkbox" id="c-42631738" checked=""/><div class="controls bullet"><span class="by">hairtuq</span><span>|</span><a href="#42632310">next</a><span>|</span><label class="collapse" for="c-42631738">[-]</label><label class="expand" for="c-42631738">[1 more]</label></div><br/><div class="children"><div class="content">Here is a cute variant that doesn&#x27;t need lzcnt nor tables, but only works up to 99,999:<p><pre><code>    (((x + 393206) &amp; (x + 524188)) ^ ((x + 916504) &amp; (x + 514288))) &gt;&gt; 17
</code></pre>
This is for integer log 10, but could be adapted for number of digits. It needs a wrapper for 64 bit to invoke it multiple times, but most numbers in a JSON are small, so it might even be competitive; it needs only 4 cycles with enough instruction level parallelism.<p>I gathered this idea from the output of a superoptimizer, it was fun to figure out how it works. For spoilers, see [1].<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;master&#x2F;library&#x2F;core&#x2F;src&#x2F;num&#x2F;int_log10.rs">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;master&#x2F;library&#x2F;core&#x2F;s...</a></div><br/></div></div><div id="42632310" class="c"><input type="checkbox" id="c-42632310" checked=""/><div class="controls bullet"><span class="by">billpg</span><span>|</span><a href="#42631738">prev</a><span>|</span><a href="#42629684">next</a><span>|</span><label class="collapse" for="c-42632310">[-]</label><label class="expand" for="c-42632310">[1 more]</label></div><br/><div class="children"><div class="content">If you were to ask me to write some code to convert an int64 into ascii decimals, I&#x27;d start with a 20 character buffer (because int64 will never need more), loop to populate the buffer with ascii decimal digits from the lowest significant end, then once the loop has finished and we know how many digits, copy the buffer into its place.<p>I&#x27;d love to told that this method in the article is actually significantly more efficient than my possibly naïve approach.</div><br/></div></div><div id="42629684" class="c"><input type="checkbox" id="c-42629684" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#42632310">prev</a><span>|</span><a href="#42630085">next</a><span>|</span><label class="collapse" for="c-42629684">[-]</label><label class="expand" for="c-42629684">[1 more]</label></div><br/><div class="children"><div class="content">A latency improvement would be to have digitCountThresholds be indexed by the lzcnt, instead of the result of the other LUT. Increases the size of that lookup table from 160B to 512B though. Funnily enough I&#x27;ve had this approach in a local copy of Ryu when I was working on cutting it down for my purposes. Unfortunately whatever ended up public had cut this out too.<p>edit: some chat messages of me at [0]. Some previous unrelated discussion found at [1].<p>[0]: <a href="https:&#x2F;&#x2F;app.element.io&#x2F;#&#x2F;room&#x2F;#bqn:matrix.org&#x2F;$KKIK86x0tygAfOodAx6z5ZD3lc8iSrKRXxMmYlE2Le8" rel="nofollow">https:&#x2F;&#x2F;app.element.io&#x2F;#&#x2F;room&#x2F;#bqn:matrix.org&#x2F;$KKIK86x0tygAf...</a> (arbitrarily capped at 18 digits because Ryu didn&#x27;t need more)<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ulfjack&#x2F;ryu&#x2F;issues&#x2F;34">https:&#x2F;&#x2F;github.com&#x2F;ulfjack&#x2F;ryu&#x2F;issues&#x2F;34</a></div><br/></div></div><div id="42630085" class="c"><input type="checkbox" id="c-42630085" checked=""/><div class="controls bullet"><span class="by">0xcoffee</span><span>|</span><a href="#42629684">prev</a><span>|</span><a href="#42606286">next</a><span>|</span><label class="collapse" for="c-42630085">[-]</label><label class="expand" for="c-42630085">[1 more]</label></div><br/><div class="children"><div class="content">C# Version:<p><pre><code>    private static uint FastDigitCount(ulong value)
    {
        ReadOnlySpan&lt;byte&gt; digitCounts = [19, 19, 19, 19, 18, 18, 18, 17, 17, 17, 16, 16, 16, 16, 15, 15, 15, 14, 14, 14, 13, 13, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 10, 9, 9, 9, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1];
        ReadOnlySpan&lt;ulong&gt; digitCountThresholds = [0, 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 9999999999, 99999999999, 999999999999, 9999999999999, 99999999999999, 999999999999999, 9999999999999999, 99999999999999999, 999999999999999999, 9999999999999999999];
    
        var leadingZeros = BitOperations.LeadingZeroCount(value);
        var originalDigitCount = digitCounts[leadingZeros];
        return originalDigitCount + (value &gt; digitCountThresholds[originalDigitCount] ? 1u : 0u);
    }
</code></pre>
Benchmark: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;79337820&#x2F;4503491" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;79337820&#x2F;4503491</a></div><br/></div></div><div id="42606286" class="c"><input type="checkbox" id="c-42606286" checked=""/><div class="controls bullet"><span class="by">realtimechris</span><span>|</span><a href="#42630085">prev</a><span>|</span><label class="collapse" for="c-42606286">[-]</label><label class="expand" for="c-42606286">[8 more]</label></div><br/><div class="children"><div class="content">*Optimizing uint64_t Digit Counting: A New Method that Beats Lemire&#x27;s by Up to 27%*<p>In the quest to improve the performance of my high-speed JSON library, JSONIFIER, I recently stumbled upon a breakthrough in optimizing the calculation of digit counts for `uint64_t` values. While Lemire’s method of using the `lzcnt` instruction for determining the number of digits in a 32-bit unsigned integer has been widely regarded as efficient, I’ve developed a new method that achieves even faster results for 64-bit unsigned integers (i.e., `uint64_t`), with significant gains across different compilers and platforms.<p>### The Existing Method: Lemire’s Approach<p>Lemire’s method, known for its efficiency, calculates the number of digits in a `uint32_t` by leveraging the `lzcnt` instruction, which finds the index of the most significant bit set to 1. This is combined with a static lookup table to map the result to the corresponding number of digits.<p>Here’s the code for Lemire’s method:<p>```cpp
JSONIFIER_INLINE int int_log2(uint32_t x) {
    return 31 - simd_internal::lzcnt(x | 1);
}<p>JSONIFIER_INLINE int fast_digit_count(uint32_t x) {
    static uint64_t table[] = { ... };
    return (x + table[int_log2(x)]) &gt;&gt; 32;
}
```<p>While this approach works well for 32-bit integers, the need for a faster and more efficient solution for `uint64_t` led me to create an alternative method, which uses a more streamlined approach without the overhead of a lookup table.<p>### My New Method: RTC-64-Bit Digit Counting<p>I’ve designed a new approach for 64-bit unsigned integers that leverages a similar logic but optimizes the process by storing precomputed digit counts for specific ranges and applying simple threshold checks. The result is faster execution with reduced computational overhead.<p>Here&#x27;s the code for the new method:<p>```cpp
JSONIFIER_INLINE_VARIABLE uint8_t digitCounts[]{ ... };<p>JSONIFIER_INLINE_VARIABLE uint64_t digitCountThresholds[]{ ... };<p>JSONIFIER_INLINE uint64_t fastDigitCount(const uint64_t inputValue) {
    const uint64_t originalDigitCount{ digitCounts[simd_internal::lzcnt(inputValue)] };
    return originalDigitCount + static_cast&lt;uint64_t&gt;(inputValue &gt; digitCountThresholds[originalDigitCount]);
}
```<p>This method works by using a static array to hold the precomputed digit counts and another array for threshold values that determine the exact number of digits in a `uint64_t`. The key optimization lies in the efficient use of a bit manipulation technique and direct threshold checking to avoid unnecessary computations.<p>### [Benchmark Results](<a href="https:&#x2F;&#x2F;github.com&#x2F;RealTimeChris&#x2F;BenchmarkSuite&#x2F;blob&#x2F;digit-counting&#x2F;Benchmark&#x2F;main.cpp">https:&#x2F;&#x2F;github.com&#x2F;RealTimeChris&#x2F;BenchmarkSuite&#x2F;blob&#x2F;digit-c...</a>)<p>I ran performance benchmarks comparing my new RTC-64-bit method with Lemire’s approach and the traditional `log10` method across various platforms and compilers. The results were consistently impressive:<p>#### GCC&#x2F;Ubuntu:
- *RTC-64-bit* outperforms *Lemire-32-bit* by *27.33%*.
- *Lemire-32-bit* beats *Log10-32-bit* by a massive *814.16%*.<p>#### Clang&#x2F;Ubuntu:
- *RTC-64-bit* outperforms *Lemire-32-bit* by *143.34%*.
- *Lemire-32-bit* beats *Log10-32-bit* by *522.01%*.<p>#### MSVC&#x2F;Windows:
- *RTC-64-bit* is *12.50%* faster than *Lemire-32-bit*.
- *Lemire-32-bit* beats *Log10-32-bit* by *515.90%*.<p>#### Clang&#x2F;MacOS:
- *RTC-64-bit* is *25.37%* faster than *Lemire-32-bit*.
- *Lemire-32-bit* beats *Log10-32-bit* by *343.97%*.<p>### Key Takeaways<p>The RTC-64-bit method not only delivers improved performance on modern hardware but also significantly reduces the overhead of traditional methods by eliminating the need for a large lookup table. This is especially beneficial for high-performance applications where every cycle counts, such as in JSON serialization and parsing, where speed is critical.</div><br/><div id="42629739" class="c"><input type="checkbox" id="c-42629739" checked=""/><div class="controls bullet"><span class="by">mabster</span><span>|</span><a href="#42606286">parent</a><span>|</span><a href="#42629136">next</a><span>|</span><label class="collapse" for="c-42629739">[-]</label><label class="expand" for="c-42629739">[1 more]</label></div><br/><div class="children"><div class="content">FYI, Hackers Delight uses a slight variation of Lemire&#x27;s. He multiplies by 19&#x2F;64 (so the divisor is a shift) and has the highest integer at the end of his table (i.e. 2^64 - 1). He also uses a shift instead of a conditional, so his code is branchless.<p>Generally I prefer this kind of approach. But, I suspect your digit counting is a very hot path so your tables will generally be in cache. So your approach will likely win anyway.</div><br/></div></div><div id="42629136" class="c"><input type="checkbox" id="c-42629136" checked=""/><div class="controls bullet"><span class="by">nick__m</span><span>|</span><a href="#42606286">parent</a><span>|</span><a href="#42629739">prev</a><span>|</span><a href="#42629491">next</a><span>|</span><label class="collapse" for="c-42629136">[-]</label><label class="expand" for="c-42629136">[1 more]</label></div><br/><div class="children"><div class="content">if you prefix your code by two space on every lines it will be more readable, ex:<p><pre><code>  JSONIFIER_INLINE int fast_digit_count(uint32_t x)
  {
    static uint64_t table[] = { ... }; 
    return (x + table[int_log2(x)]) &gt;&gt; 32; 
  }</code></pre></div><br/></div></div><div id="42629491" class="c"><input type="checkbox" id="c-42629491" checked=""/><div class="controls bullet"><span class="by">orra</span><span>|</span><a href="#42606286">parent</a><span>|</span><a href="#42629136">prev</a><span>|</span><label class="collapse" for="c-42629491">[-]</label><label class="expand" for="c-42629491">[5 more]</label></div><br/><div class="children"><div class="content">Very nice work. But could you please explain <i>why</i> counting digits quickly (or even slowly) is useful for a JSON serializer? This is lower level than I&#x27;m used to working. Is this so you can alloc the right amount of memory, or something else?</div><br/><div id="42629560" class="c"><input type="checkbox" id="c-42629560" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42606286">root</a><span>|</span><a href="#42629491">parent</a><span>|</span><a href="#42629796">next</a><span>|</span><label class="collapse" for="c-42629560">[-]</label><label class="expand" for="c-42629560">[1 more]</label></div><br/><div class="children"><div class="content">Yes. And for string formatting in general such as sprintf to calculate buffer size. Also for proposes of calculating length for string padding and alignment.</div><br/></div></div><div id="42629796" class="c"><input type="checkbox" id="c-42629796" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42606286">root</a><span>|</span><a href="#42629491">parent</a><span>|</span><a href="#42629560">prev</a><span>|</span><label class="collapse" for="c-42629796">[-]</label><label class="expand" for="c-42629796">[3 more]</label></div><br/><div class="children"><div class="content">Honestly? Most of the time you can use an approximation. At worst you allocate a single extra byte unless your integers are hundreds of bits long (I worked this out once but I forget where I left the details). Just multiply by the ratio of logs or something like that.</div><br/><div id="42631950" class="c"><input type="checkbox" id="c-42631950" checked=""/><div class="controls bullet"><span class="by">eapriv</span><span>|</span><a href="#42606286">root</a><span>|</span><a href="#42629796">parent</a><span>|</span><a href="#42630856">next</a><span>|</span><label class="collapse" for="c-42631950">[-]</label><label class="expand" for="c-42631950">[1 more]</label></div><br/><div class="children"><div class="content">Isn’t “the ratio of logs” going to be slower?</div><br/></div></div><div id="42630856" class="c"><input type="checkbox" id="c-42630856" checked=""/><div class="controls bullet"><span class="by">Nevermark</span><span>|</span><a href="#42606286">root</a><span>|</span><a href="#42629796">parent</a><span>|</span><a href="#42631950">prev</a><span>|</span><label class="collapse" for="c-42630856">[-]</label><label class="expand" for="c-42630856">[1 more]</label></div><br/><div class="children"><div class="content">Nice. The best kind of optimization: Go lazy, to go fast.<p>I often go slow, to go fast. But lazy is the supremum.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>