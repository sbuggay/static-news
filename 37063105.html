<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691830860179" as="style"/><link rel="stylesheet" href="styles.css?v=1691830860179"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bitfieldconsulting.com/golang/iterators">Iterators in Go: A proposed extension</a> <span class="domain">(<a href="https://bitfieldconsulting.com">bitfieldconsulting.com</a>)</span></div><div class="subtext"><span>gus_leonel</span> | <span>56 comments</span></div><br/><div><div id="37096643" class="c"><input type="checkbox" id="c-37096643" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37096493">next</a><span>|</span><label class="collapse" for="c-37096643">[-]</label><label class="expand" for="c-37096643">[25 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also not seeing why this is necessary. Range over int is pure syntax sugar, and while range over func could be useful, iterators can be easily implemented with current Go features.<p>I love Go because of its simplicity, and because it strictly adheres to the &quot;there&#x27;s only one way to do it&quot; mantra. Adding syntax sugar muddles this, and introducing another keyword and construct makes the code less readable.<p>I hope that this proposal is rejected, and that it&#x27;s not a sign of Go becoming yet another kitchen sink language.</div><br/><div id="37098316" class="c"><input type="checkbox" id="c-37098316" checked=""/><div class="controls bullet"><span class="by">greyman</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37097602">next</a><span>|</span><label class="collapse" for="c-37098316">[-]</label><label class="expand" for="c-37098316">[1 more]</label></div><br/><div class="children"><div class="content">I too hope this will be rejected, the proposal is terrible. One of the core advantages of Go was, that if newbie colleague comes to the team, he will be able to read and understand the code very quickly. Things like this will over time kill this Go&#x27;s advantage.</div><br/></div></div><div id="37097602" class="c"><input type="checkbox" id="c-37097602" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37098316">prev</a><span>|</span><a href="#37097285">next</a><span>|</span><label class="collapse" for="c-37097602">[-]</label><label class="expand" for="c-37097602">[3 more]</label></div><br/><div class="children"><div class="content">&gt; iterators can be easily implemented with current Go features.<p>It&#x27;s rare that <i>can</i> is relevant when it comes to language design. You typically <i>can</i> do anything in any language.<p>Adding dedicated support for iterators would promote it as <i>the</i> way to iterate. That would actually simplify the language - one way to express a common need as opposed to the current mess of ~5 different ways [1]:<p>&quot;In the standard library alone, we have archive&#x2F;tar.Reader.Next, bufio.Reader.ReadByte, bufio.Scanner.Scan, container&#x2F;ring.Ring.Do, database&#x2F;sql.Rows, expvar.Do, flag.Visit, go&#x2F;token.FileSet.Iterate, path&#x2F;filepath.Walk, go&#x2F;token.FileSet.Iterate, runtime.Frames.Next, and sync.Map.Range, hardly any of which agree on the exact details of iteration. Even the functions that agree on the signature don’t always agree about the semantics.&quot;<p>Go would have been a far simpler language had it originally shipped with generics, iterators, and sum types.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;56413</a></div><br/><div id="37098010" class="c"><input type="checkbox" id="c-37098010" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097602">parent</a><span>|</span><a href="#37097285">next</a><span>|</span><label class="collapse" for="c-37098010">[-]</label><label class="expand" for="c-37098010">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you to an extent. But adding more features is always a tradeoff between introducing complexity, and supporting a use case that might not be useful in all programs.<p>For example, generics were a highly controversial topic, and many people still believe that Go didn&#x27;t need them. I&#x27;m partially in that camp. I&#x27;ve encountered maybe one or two situations where generics would&#x27;ve been convenient since Go 1.18, and in both cases not jumping straight at the opportunity to use them, but being forced to refactor and approach the solution in a different way, has produced simpler and more readable code. To this day, I struggle with Go&#x27;s generics syntax, and it just looks alien to me.<p>Iterators are a useful feature, but are they really generally useful to deserve a change in the language spec? Like generics, I&#x27;ve yet to encounter a situation where they&#x27;re truly required, and when I do, implementing them myself is trivial.<p>So, sure, language designers can cram every programming construct we&#x27;ve invented in the last 50 years, as Rust and Raku have done, and many programmers will find this very convenient and flexible, but a more focused and conservative approach produces a simpler language that is easy to pickup and read. This is what drew me to Go in the first place, and lately it seems that this is changing.</div><br/></div></div></div></div><div id="37097285" class="c"><input type="checkbox" id="c-37097285" checked=""/><div class="controls bullet"><span class="by">MAGZine</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37097602">prev</a><span>|</span><a href="#37098121">next</a><span>|</span><label class="collapse" for="c-37097285">[-]</label><label class="expand" for="c-37097285">[2 more]</label></div><br/><div class="children"><div class="content">because go developers are sick of being pure and like to type shorter things (and I don&#x27;t mean variable names) to get their jobs done.<p>programming is a lazy hobby. it&#x27;s why as soon as generics were released, I immediately implemented &#x27;Keys&#x27;, &#x27;Values&#x27;, &#x27;ToSet&#x27;, etc. Writing multiple lines to do the equivalent of these functions might be &#x27;pure&#x27; but it&#x27;s not easier to read. Worse: instead of standardizing these common operations, you just have everyone rolling their own implementations of the exact same functions with slightly different naming&#x2F;parameters&#x2F;etc.<p>Am I confused in that there is some merit to this approach beyond dogma? Why do we, as a community, need to accept so few batteries? If you want to only use assembly in your code (the purest!), that&#x27;s always an option.</div><br/><div id="37098206" class="c"><input type="checkbox" id="c-37098206" checked=""/><div class="controls bullet"><span class="by">imiric</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097285">parent</a><span>|</span><a href="#37098121">next</a><span>|</span><label class="collapse" for="c-37098206">[-]</label><label class="expand" for="c-37098206">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about purity or dogma. It&#x27;s about keeping complexity out of the language as much as possible, which is much harder to do. Language designers always make a tradeoff between making programming tasks convenient, and introducing more complexity that makes the language more difficult to maintain and less approachable, and programs written in it more difficult to read and reason about.<p>Being productive in a language is not just about using every convenience at your disposal, and typing less. It&#x27;s about producing code that is easy to read and approachable for others or yourself years down the line. The more language features one needs to be aware of when writing or reading code, the less approachable it is.<p>Having less features also forces the programmer to rethink their solution in a less clever way. In dynamic languages like Python and Ruby it&#x27;s very convenient to use some fancy trick to write less code. In languages like Rust or Raku, you can (ab)use some obscure feature in a non-intuitive way, and feel good about the &quot;elegance&quot; of the solution, but a fresh pair of eyes might struggle to understand what the code actually does. Considering reading code is much more important than writing it, as we literally write code for humans, not machines, optimizing for simplicity and having less features in a language is a more productive long-term approach.</div><br/></div></div></div></div><div id="37098121" class="c"><input type="checkbox" id="c-37098121" checked=""/><div class="controls bullet"><span class="by">cy_hauser</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37097285">prev</a><span>|</span><a href="#37097496">next</a><span>|</span><label class="collapse" for="c-37098121">[-]</label><label class="expand" for="c-37098121">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; &quot;there&#x27;s only one way to do it&quot;<p>What&#x27;s the one way to do iterators now? I thought this proposal came about because there wasn&#x27;t a default way and everybody had to roll their own.</div><br/></div></div><div id="37097496" class="c"><input type="checkbox" id="c-37097496" checked=""/><div class="controls bullet"><span class="by">JyB</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37098121">prev</a><span>|</span><a href="#37096674">next</a><span>|</span><label class="collapse" for="c-37097496">[-]</label><label class="expand" for="c-37097496">[4 more]</label></div><br/><div class="children"><div class="content">Exactly. Go making it&#x27;s way faster than I expected to be replaced by yet another language that discovers that there&#x27;s a demand for feature restriction and simplicity. The very thing that made it popular in the first place. It should be rejected but I&#x27;m losing hope. I have less and less faith in rsc as time passes.</div><br/><div id="37098172" class="c"><input type="checkbox" id="c-37098172" checked=""/><div class="controls bullet"><span class="by">cy_hauser</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097496">parent</a><span>|</span><a href="#37097582">next</a><span>|</span><label class="collapse" for="c-37098172">[-]</label><label class="expand" for="c-37098172">[1 more]</label></div><br/><div class="children"><div class="content">I think the pace has been extremely slow. So many of the changes to Go have been tool chain or library enhancements. Outside of generics related stuff, what are some added core language features that you&#x27;d prefer were not?</div><br/></div></div><div id="37097582" class="c"><input type="checkbox" id="c-37097582" checked=""/><div class="controls bullet"><span class="by">steeve</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097496">parent</a><span>|</span><a href="#37098172">prev</a><span>|</span><a href="#37097696">next</a><span>|</span><label class="collapse" for="c-37097582">[-]</label><label class="expand" for="c-37097582">[1 more]</label></div><br/><div class="children"><div class="content">Why do you have less faith in rsc? Asking because I feel the opposite.</div><br/></div></div><div id="37097696" class="c"><input type="checkbox" id="c-37097696" checked=""/><div class="controls bullet"><span class="by">throwawaygo</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097496">parent</a><span>|</span><a href="#37097582">prev</a><span>|</span><a href="#37096674">next</a><span>|</span><label class="collapse" for="c-37097696">[-]</label><label class="expand" for="c-37097696">[1 more]</label></div><br/><div class="children"><div class="content">Bingo</div><br/></div></div></div></div><div id="37096674" class="c"><input type="checkbox" id="c-37096674" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37097496">prev</a><span>|</span><a href="#37097284">next</a><span>|</span><label class="collapse" for="c-37096674">[-]</label><label class="expand" for="c-37096674">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a go newb, but would you do this with channels and gofuncs now?<p>The readability this provides is considerable.</div><br/><div id="37097140" class="c"><input type="checkbox" id="c-37097140" checked=""/><div class="controls bullet"><span class="by">liquidgecka</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096674">parent</a><span>|</span><a href="#37097148">next</a><span>|</span><label class="collapse" for="c-37097140">[-]</label><label class="expand" for="c-37097140">[1 more]</label></div><br/><div class="children"><div class="content">That kind of suffers if you want to be able to cheaply cancel the iteration.<p>Lets say the logic is:<p><pre><code>  for item := range list {
      if condition(item) {
          break
      }
  }
</code></pre>
That is nice and readable, but if the thing your iterating is returning items in a batch then this gets far, far uglier. Its possible to end up with one loop that fetches x items at a time, and another that iterates over those items.. etc. But if you switch that to channels you maintain the readability and everything is nice! .. Except, you need a way to cancel the iteration, and it can&#x27;t be closing the channel or the writer will panic.<p><pre><code>  items, cancelFunc := apiCall()
  for item := range items {
      if condition(items) {
          cancelFunc()
          for _ := range items { }
          break
      }
  }
  close(items)
</code></pre>
Now, this is even worse if you need some kind of finalization of the goroutine that spawns to write to the given channel. Now you have a wait group, or a second channel.. etc. If its possible to error in the middle of iteration then things get complicated as well.</div><br/></div></div><div id="37097148" class="c"><input type="checkbox" id="c-37097148" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096674">parent</a><span>|</span><a href="#37097140">prev</a><span>|</span><a href="#37096752">next</a><span>|</span><label class="collapse" for="c-37097148">[-]</label><label class="expand" for="c-37097148">[1 more]</label></div><br/><div class="children"><div class="content">I would probably just do the following:<p><pre><code>    type Iterator[T any] interface {
        HasNext() bool
        GetNext() T
    }
</code></pre>
And then use it like:<p><pre><code>    for i.HasNext() {
        current := i.GetNext()
        &#x2F;&#x2F; do things here
    }
</code></pre>
It&#x27;s an extra line, sure, but it&#x27;s pretty obvious what&#x27;s going on.</div><br/></div></div><div id="37096752" class="c"><input type="checkbox" id="c-37096752" checked=""/><div class="controls bullet"><span class="by">slashdev</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096674">parent</a><span>|</span><a href="#37097148">prev</a><span>|</span><a href="#37096737">next</a><span>|</span><label class="collapse" for="c-37096752">[-]</label><label class="expand" for="c-37096752">[5 more]</label></div><br/><div class="children"><div class="content">And make a simple iterator into a multithreaded program with channels and goroutines?<p>Slower. More complex. Why?!?<p>Just call your function in a loop.</div><br/><div id="37097054" class="c"><input type="checkbox" id="c-37097054" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096752">parent</a><span>|</span><a href="#37097340">next</a><span>|</span><label class="collapse" for="c-37097054">[-]</label><label class="expand" for="c-37097054">[1 more]</label></div><br/><div class="children"><div class="content">Which is to say: yes!  Many do it with channels currently.<p>It&#x27;s awful, but they do it.</div><br/></div></div><div id="37097340" class="c"><input type="checkbox" id="c-37097340" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096752">parent</a><span>|</span><a href="#37097054">prev</a><span>|</span><a href="#37096737">next</a><span>|</span><label class="collapse" for="c-37097340">[-]</label><label class="expand" for="c-37097340">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Slower<p>Why would that be slower?</div><br/><div id="37097637" class="c"><input type="checkbox" id="c-37097637" checked=""/><div class="controls bullet"><span class="by">Mawr</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097340">parent</a><span>|</span><a href="#37096737">next</a><span>|</span><label class="collapse" for="c-37097637">[-]</label><label class="expand" for="c-37097637">[2 more]</label></div><br/><div class="children"><div class="content">The design of channels is constrained by the need to support concurrency. If you do not need concurrency, using something designed to support it will be suboptimal. And because it&#x27;s specifically concurrency, the overhead will be substantial.<p>... that&#x27;s the theory behind it. For more grounded explanations, see [1] &amp; [2].<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29510751">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29510751</a><p>[2] <a href="https:&#x2F;&#x2F;ewencp.org&#x2F;blog&#x2F;golang-iterators&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;ewencp.org&#x2F;blog&#x2F;golang-iterators&#x2F;index.html</a></div><br/><div id="37097752" class="c"><input type="checkbox" id="c-37097752" checked=""/><div class="controls bullet"><span class="by">konart</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097637">parent</a><span>|</span><a href="#37096737">next</a><span>|</span><label class="collapse" for="c-37097752">[-]</label><label class="expand" for="c-37097752">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I kind forgot we don&#x27;t have anything concurrency related here.<p>Thanks for the links!</div><br/></div></div></div></div></div></div></div></div><div id="37096737" class="c"><input type="checkbox" id="c-37096737" checked=""/><div class="controls bullet"><span class="by">d1str0</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096674">parent</a><span>|</span><a href="#37096752">prev</a><span>|</span><a href="#37097095">next</a><span>|</span><label class="collapse" for="c-37096737">[-]</label><label class="expand" for="c-37096737">[1 more]</label></div><br/><div class="children"><div class="content">Thats how I would do it. You can have a goroutine send on a channel (buffered or non buffered), and then another function can consume the chan as needed which lets the goroutine generate results as needed as well.</div><br/></div></div><div id="37097095" class="c"><input type="checkbox" id="c-37097095" checked=""/><div class="controls bullet"><span class="by">jasonhansel</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37096674">parent</a><span>|</span><a href="#37096737">prev</a><span>|</span><a href="#37097284">next</a><span>|</span><label class="collapse" for="c-37097095">[-]</label><label class="expand" for="c-37097095">[1 more]</label></div><br/><div class="children"><div class="content">As I recall, the performance of that approach is quite bad, even with Go&#x27;s concurrency support.</div><br/></div></div></div></div><div id="37097284" class="c"><input type="checkbox" id="c-37097284" checked=""/><div class="controls bullet"><span class="by">tapirl</span><span>|</span><a href="#37096643">parent</a><span>|</span><a href="#37096674">prev</a><span>|</span><a href="#37096493">next</a><span>|</span><label class="collapse" for="c-37097284">[-]</label><label class="expand" for="c-37097284">[3 more]</label></div><br/><div class="children"><div class="content">Go development is becoming more and more KPI driven.</div><br/><div id="37097791" class="c"><input type="checkbox" id="c-37097791" checked=""/><div class="controls bullet"><span class="by">slekker</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097284">parent</a><span>|</span><a href="#37096493">next</a><span>|</span><label class="collapse" for="c-37097791">[-]</label><label class="expand" for="c-37097791">[2 more]</label></div><br/><div class="children"><div class="content">What is KPI in this context?</div><br/><div id="37097951" class="c"><input type="checkbox" id="c-37097951" checked=""/><div class="controls bullet"><span class="by">nullifidian</span><span>|</span><a href="#37096643">root</a><span>|</span><a href="#37097791">parent</a><span>|</span><a href="#37096493">next</a><span>|</span><label class="collapse" for="c-37097951">[-]</label><label class="expand" for="c-37097951">[1 more]</label></div><br/><div class="children"><div class="content">They probably meant that programming language designers&#x2F;developers can only advance their careers by adding&#x2F;implementing features, not presiding over something complete.</div><br/></div></div></div></div></div></div></div></div><div id="37096493" class="c"><input type="checkbox" id="c-37096493" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#37096643">prev</a><span>|</span><a href="#37096637">next</a><span>|</span><label class="collapse" for="c-37096493">[-]</label><label class="expand" for="c-37096493">[1 more]</label></div><br/><div class="children"><div class="content">This approach feels quite invasive compared to adding a standard interface that `range` accepts. Some discussions have happened before, eg <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;54245">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;discussions&#x2F;54245</a><p>A standard interface feels a cleaner than these nested callback functions.</div><br/></div></div><div id="37096637" class="c"><input type="checkbox" id="c-37096637" checked=""/><div class="controls bullet"><span class="by">joneholland</span><span>|</span><a href="#37096493">prev</a><span>|</span><a href="#37097960">next</a><span>|</span><label class="collapse" for="c-37096637">[-]</label><label class="expand" for="c-37096637">[4 more]</label></div><br/><div class="children"><div class="content">This is a weird approach.  They are essentially manually implementing the “yield return” functionality from c#.<p>C# defines an interface IEnumerable&lt;T&gt; with a “next” method, and originally you’d need to implement this interface which was a bit of boiler plate.<p>They added “yield return” which would create compiler generated syntax sugar to return a generator function like this go proposal, but your code looked identical to a non iterative version.<p>The go proposal feels like the worst of both worlds and like the team misunderstood the purpose.</div><br/><div id="37096682" class="c"><input type="checkbox" id="c-37096682" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37096637">parent</a><span>|</span><a href="#37097960">next</a><span>|</span><label class="collapse" for="c-37096682">[-]</label><label class="expand" for="c-37096682">[3 more]</label></div><br/><div class="children"><div class="content">The proposal is more powerful than the C# &quot;yield return&quot; functionality because it allows the yield function to be passed to subroutines.</div><br/><div id="37096788" class="c"><input type="checkbox" id="c-37096788" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#37096637">root</a><span>|</span><a href="#37096682">parent</a><span>|</span><a href="#37097960">next</a><span>|</span><label class="collapse" for="c-37096788">[-]</label><label class="expand" for="c-37096788">[2 more]</label></div><br/><div class="children"><div class="content">How is that better than the C# solution of just making the subroutine return an IEnumerable, then yielding its elements in the calling function? (aside from maybe marginally better perf characteristics)?</div><br/><div id="37096850" class="c"><input type="checkbox" id="c-37096850" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37096637">root</a><span>|</span><a href="#37096788">parent</a><span>|</span><a href="#37097960">next</a><span>|</span><label class="collapse" for="c-37096850">[-]</label><label class="expand" for="c-37096850">[1 more]</label></div><br/><div class="children"><div class="content">It works with subroutines that don&#x27;t know anything about iterators or yielding but do know about first-class functions. It&#x27;s also less boilerplate, since there isn&#x27;t a `yield from`, I guess.</div><br/></div></div></div></div></div></div></div></div><div id="37097960" class="c"><input type="checkbox" id="c-37097960" checked=""/><div class="controls bullet"><span class="by">reichstein</span><span>|</span><a href="#37096637">prev</a><span>|</span><a href="#37096606">next</a><span>|</span><label class="collapse" for="c-37097960">[-]</label><label class="expand" for="c-37097960">[1 more]</label></div><br/><div class="children"><div class="content">This design avoids the inefficiencies and most of the problems of having an?_iterator_, like the classical Java `hasNext`&#x2F;`moveNext` or C# `MoveNext`&#x2F;`Current` interfaces.
Those iterators require you to keep the state between elements as values, effectively CPS transforming and defunctionalizing the control flow of actually iterating the elements.<p>This iterator function here is really just a `forEach`&#x2F;`Each` method where the callback can return a boolean. You can&#x27;t easily use that to split iteration, say iterate the first five elements, then go do something else, and come back to iterate the rest, doing something completely different.<p>But that also means it doesn&#x27;t have to worry, as much, about the iterator going stale because the underlying structure changes (`ConcurrentModificationError`), or not knowing when to clean up, because somebody might call `hasNext`at any later time.<p>So this is basically just a nicer `forEach` method.</div><br/></div></div><div id="37096606" class="c"><input type="checkbox" id="c-37096606" checked=""/><div class="controls bullet"><span class="by">galkk</span><span>|</span><a href="#37097960">prev</a><span>|</span><a href="#37096985">next</a><span>|</span><label class="collapse" for="c-37096606">[-]</label><label class="expand" for="c-37096606">[1 more]</label></div><br/><div class="children"><div class="content">Iterators are great, I really loved simplicity of `yield` in c# and python.<p>Go&#x27;s proposed syntax is god awful. Why they are doing that to devs and themselves? Should we expect it to improve in like 15-20 versions, like it happened with any and generic mix&#x2F;max functions?</div><br/></div></div><div id="37096985" class="c"><input type="checkbox" id="c-37096985" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37096606">prev</a><span>|</span><a href="#37097871">next</a><span>|</span><label class="collapse" for="c-37096985">[-]</label><label class="expand" for="c-37096985">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing this is following the same &#x2F; highly similar motivation as rsc&#x27;s coroutines post about a month ago: <a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;coro" rel="nofollow noreferrer">https:&#x2F;&#x2F;research.swtch.com&#x2F;coro</a><p>I welcome people embracing function closures more, as I feel they&#x27;re a drastically under-used language tool (particularly in Go where everyone crams everything into single-func interfaces which  are <i>almost</i> exclusively far worse).  More exposure to it helps people become comfortable with it, and now that we have generics it&#x27;s finally not a pile of pain and agony at all times.  And <i>just using functions</i> makes it very flexible &#x2F; doesn&#x27;t repeat the &quot;X for me but not for thee&quot; issues of past Go versions.<p>I&#x27;m not entirely sure how I feel about this proposal though.  It kinda feels like it&#x27;s trying to put a round peg into a square hole.  If you try hard enough, everything can go in the square hole!  But that doesn&#x27;t mean it&#x27;s a good fit.</div><br/><div id="37097367" class="c"><input type="checkbox" id="c-37097367" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37096985">parent</a><span>|</span><a href="#37097871">next</a><span>|</span><label class="collapse" for="c-37097367">[-]</label><label class="expand" for="c-37097367">[3 more]</label></div><br/><div class="children"><div class="content">It would be nice if the proposal defined the semantics of getting single item from the iterator (or detecting that it is out of items) and exposed an api for this, then defined the behavior of range as equivalent to some pattern using these primitives.<p>As is the proposal says &quot;there should be some coro.Pull type thing&quot; which is a bit terse and says nothing about whether the implementation of coro.Pull will be fast or whether it will be built on range + channels</div><br/><div id="37097945" class="c"><input type="checkbox" id="c-37097945" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#37096985">root</a><span>|</span><a href="#37097367">parent</a><span>|</span><a href="#37097816">next</a><span>|</span><label class="collapse" for="c-37097945">[-]</label><label class="expand" for="c-37097945">[1 more]</label></div><br/><div class="children"><div class="content">I suspect getting a single item out will be that you just make a<p><pre><code>  func next[T](i iterfunc[T]) T {
    var item T
    i(func(it T) bool){
      item = it
      return true &#x2F;&#x2F; likely
    })
    return item
  }
</code></pre>
and use it.  Semantics should be the same as ranging would desugar to (since that&#x27;s all this is), though the variable arity will be slightly annoying of course.</div><br/></div></div><div id="37097816" class="c"><input type="checkbox" id="c-37097816" checked=""/><div class="controls bullet"><span class="by">znkr</span><span>|</span><a href="#37096985">root</a><span>|</span><a href="#37097367">parent</a><span>|</span><a href="#37097945">prev</a><span>|</span><a href="#37097871">next</a><span>|</span><label class="collapse" for="c-37097816">[-]</label><label class="expand" for="c-37097816">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;research.swtch.com&#x2F;coro" rel="nofollow noreferrer">https:&#x2F;&#x2F;research.swtch.com&#x2F;coro</a></div><br/></div></div></div></div></div></div><div id="37097871" class="c"><input type="checkbox" id="c-37097871" checked=""/><div class="controls bullet"><span class="by">veber-alex</span><span>|</span><a href="#37096985">prev</a><span>|</span><a href="#37097998">next</a><span>|</span><label class="collapse" for="c-37097871">[-]</label><label class="expand" for="c-37097871">[2 more]</label></div><br/><div class="children"><div class="content">This proposal seems pretty bad to me.<p>I think Go lacks the features to make this ergonomic and flexible.<p>Before adding iterators the language should add tuples so that you won&#x27;t need to special case 0,1 and 2 artity functions.<p>And shorter syntax for anonymous functions to make writing this less verbose, I believe this has been proposed before.<p>Also the special case for &quot;0..N&quot; ranges seems very unnecessary.</div><br/><div id="37098093" class="c"><input type="checkbox" id="c-37098093" checked=""/><div class="controls bullet"><span class="by">mutatio</span><span>|</span><a href="#37097871">parent</a><span>|</span><a href="#37097998">next</a><span>|</span><label class="collapse" for="c-37098093">[-]</label><label class="expand" for="c-37098093">[1 more]</label></div><br/><div class="children"><div class="content">I was thinking exactly this. Coming from Rust, but also as a fan of Go, I can&#x27;t help that the building blocks just aren&#x27;t there to construct a satisfying form of iterators, and like you said that would be language support for tuples and expanding the flexibility of Go&#x27;s generics for methods to support the composition Rust allows, such as: iter.skip(10).take(10).map()...</div><br/></div></div></div></div><div id="37097998" class="c"><input type="checkbox" id="c-37097998" checked=""/><div class="controls bullet"><span class="by">c0balt</span><span>|</span><a href="#37097871">prev</a><span>|</span><a href="#37097995">next</a><span>|</span><label class="collapse" for="c-37097998">[-]</label><label class="expand" for="c-37097998">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, it looks interesting but it seems to lack a precise need that&#x27;s not covered atm imo.<p>I also wonder how defer would be handled. After the last yield? After each yield? Should defer be executed when an iterator is not fully consumed?</div><br/></div></div><div id="37097995" class="c"><input type="checkbox" id="c-37097995" checked=""/><div class="controls bullet"><span class="by">kubb</span><span>|</span><a href="#37097998">prev</a><span>|</span><a href="#37097666">next</a><span>|</span><label class="collapse" for="c-37097995">[-]</label><label class="expand" for="c-37097995">[1 more]</label></div><br/><div class="children"><div class="content">I much preferred the iterate by function approach described by one of the blogger guys a while ago (Muratori? Bendersky? Cassettieri? I can&#x27;t quite recall the name atm).</div><br/></div></div><div id="37097666" class="c"><input type="checkbox" id="c-37097666" checked=""/><div class="controls bullet"><span class="by">flanked-evergl</span><span>|</span><a href="#37097995">prev</a><span>|</span><a href="#37096474">next</a><span>|</span><label class="collapse" for="c-37097666">[-]</label><label class="expand" for="c-37097666">[1 more]</label></div><br/><div class="children"><div class="content">I have used some iterator libraries for go and they do make for much more manageable code, especially if you start nesting iterators, like iterating over JSON which reads from an iterator over a blob from blob storage. And it also makes it simpler to apply filters at various points. Using callbacks also works but makes for nastier code.</div><br/></div></div><div id="37096474" class="c"><input type="checkbox" id="c-37096474" checked=""/><div class="controls bullet"><span class="by">packetlost</span><span>|</span><a href="#37097666">prev</a><span>|</span><a href="#37098042">next</a><span>|</span><label class="collapse" for="c-37096474">[-]</label><label class="expand" for="c-37096474">[2 more]</label></div><br/><div class="children"><div class="content">Not sure how I feel about this particular approach to iterators. I&#x27;d love for there to be <i>some</i> generate way to `range` over a generic collection, but idk about this.</div><br/><div id="37097164" class="c"><input type="checkbox" id="c-37097164" checked=""/><div class="controls bullet"><span class="by">liquidgecka</span><span>|</span><a href="#37096474">parent</a><span>|</span><a href="#37098042">next</a><span>|</span><label class="collapse" for="c-37097164">[-]</label><label class="expand" for="c-37097164">[1 more]</label></div><br/><div class="children"><div class="content">Honestly I would just prefer an interface that can be implemented (not this interface.. one like it that is better thought out).<p><pre><code>  type Iterator interface{} {
    &#x2F;&#x2F; Returns the next object and true, or nil and false if iteration has ended.
    func NextIteration() (interface{}, bool)
  }
</code></pre>
Even better (in my opinion) if it also adds a finalizer function to help clean up resources used during iteration and some kind of error handling.. but that might be asking too much given my track record of getting golang improvements approved. I still want else on for statements dang it! =)</div><br/></div></div></div></div><div id="37098042" class="c"><input type="checkbox" id="c-37098042" checked=""/><div class="controls bullet"><span class="by">hknmtt</span><span>|</span><a href="#37096474">prev</a><span>|</span><a href="#37096571">next</a><span>|</span><label class="collapse" for="c-37098042">[-]</label><label class="expand" for="c-37098042">[1 more]</label></div><br/><div class="children"><div class="content">a) one item at a time means slow because when you are iterating maps&#x2F;slice&#x2F;array you have it all in memory so it is fast. with one item you have to constantly rewrite memory, move data and whatnot<p>b) yo can always use for loop in a traditional for way with standard arguments(init, stop, next)<p>c) yield is poor way of doing channels, i do not see why we should be degrading our code<p>d) this entire premise is stupid :D</div><br/></div></div><div id="37096571" class="c"><input type="checkbox" id="c-37096571" checked=""/><div class="controls bullet"><span class="by">downvotetruth</span><span>|</span><a href="#37098042">prev</a><span>|</span><a href="#37097168">next</a><span>|</span><label class="collapse" for="c-37096571">[-]</label><label class="expand" for="c-37096571">[6 more]</label></div><br/><div class="children"><div class="content">But what about gonerators? &#x2F;s</div><br/><div id="37097688" class="c"><input type="checkbox" id="c-37097688" checked=""/><div class="controls bullet"><span class="by">zer8k</span><span>|</span><a href="#37096571">parent</a><span>|</span><a href="#37097616">next</a><span>|</span><label class="collapse" for="c-37097688">[-]</label><label class="expand" for="c-37097688">[1 more]</label></div><br/><div class="children"><div class="content">`Gonerator` is the pattern for side-effect only deleting a list. Just implement gonerator and your lovely list will delete itself.<p><pre><code>    for k := i.getNext() {
       yeet k 
    }

</code></pre>
I&#x27;m willing to negotiate on `yeet` but its close enough to `yield` it feels natural.</div><br/></div></div><div id="37097616" class="c"><input type="checkbox" id="c-37097616" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#37096571">parent</a><span>|</span><a href="#37097688">prev</a><span>|</span><a href="#37097555">next</a><span>|</span><label class="collapse" for="c-37097616">[-]</label><label class="expand" for="c-37097616">[1 more]</label></div><br/><div class="children"><div class="content">If <i>go</i> had <i>monads</i>…</div><br/></div></div><div id="37097555" class="c"><input type="checkbox" id="c-37097555" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#37096571">parent</a><span>|</span><a href="#37097616">prev</a><span>|</span><a href="#37096688">next</a><span>|</span><label class="collapse" for="c-37097555">[-]</label><label class="expand" for="c-37097555">[1 more]</label></div><br/><div class="children"><div class="content">Yes please, goroutines and gonerators.</div><br/></div></div><div id="37096688" class="c"><input type="checkbox" id="c-37096688" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#37096571">parent</a><span>|</span><a href="#37097555">prev</a><span>|</span><a href="#37097168">next</a><span>|</span><label class="collapse" for="c-37096688">[-]</label><label class="expand" for="c-37096688">[2 more]</label></div><br/><div class="children"><div class="content">This proposal is about generators.</div><br/></div></div></div></div><div id="37097168" class="c"><input type="checkbox" id="c-37097168" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#37096571">prev</a><span>|</span><label class="collapse" for="c-37097168">[-]</label><label class="expand" for="c-37097168">[5 more]</label></div><br/><div class="children"><div class="content">Wait, so you return `false` to terminate the iterator? Stupid!! Now I can’t have an iterator that returns Booleans.<p>UPDATE: I misread the article. This isn’t what happens. My bad.<p>Honestly, I feel like Go focuses so much on superficial simplicity that you wind up with bad&#x2F;leaky abstractions all over the place as well as bad primitive obsession.<p>&#x2F;rant</div><br/><div id="37097229" class="c"><input type="checkbox" id="c-37097229" checked=""/><div class="controls bullet"><span class="by">leijurv</span><span>|</span><a href="#37097168">parent</a><span>|</span><a href="#37097250">next</a><span>|</span><label class="collapse" for="c-37097229">[-]</label><label class="expand" for="c-37097229">[2 more]</label></div><br/><div class="children"><div class="content">No that&#x27;s not at all how this works. The iterator could &quot;return&quot; a boolean by passing a boolean to &quot;yield&quot;. The return value of &quot;yield&quot; just indicates if the generator should continue, or stop because the actual loop has exited (due to break or return).</div><br/><div id="37097259" class="c"><input type="checkbox" id="c-37097259" checked=""/><div class="controls bullet"><span class="by">ashton314</span><span>|</span><a href="#37097168">root</a><span>|</span><a href="#37097229">parent</a><span>|</span><a href="#37097250">next</a><span>|</span><label class="collapse" for="c-37097259">[-]</label><label class="expand" for="c-37097259">[1 more]</label></div><br/><div class="children"><div class="content">Oh fie you’re right and I misread that. Thanks for correcting me. I’ve updated my comment.</div><br/></div></div></div></div><div id="37097250" class="c"><input type="checkbox" id="c-37097250" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#37097168">parent</a><span>|</span><a href="#37097229">prev</a><span>|</span><a href="#37097207">next</a><span>|</span><label class="collapse" for="c-37097250">[-]</label><label class="expand" for="c-37097250">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Now I can&#x27;t have an iterator that returns Booleans.<p>No, you&#x27;ve misunderstood it.<p>The iterator function gets a yield function which can be called with a value (the value to be yielded). The yield function returns a boolean indicating whether the process should continue or terminate.<p><pre><code>  func SomeIterator(yield func(bool) bool) bool {
    for whatever {
      if !yield(a_calculated_boolean_value) {
        return false
      }
    }
    return true
  }
</code></pre>
There, yielding boolean values without incident.</div><br/></div></div><div id="37097207" class="c"><input type="checkbox" id="c-37097207" checked=""/><div class="controls bullet"><span class="by">marcopolo</span><span>|</span><a href="#37097168">parent</a><span>|</span><a href="#37097250">prev</a><span>|</span><label class="collapse" for="c-37097207">[-]</label><label class="expand" for="c-37097207">[1 more]</label></div><br/><div class="children"><div class="content">Sure you can. The bool is a signal telling the thing yielding values to stop.</div><br/></div></div></div></div></div></div></div></div></div></body></html>