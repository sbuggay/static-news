<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719133273248" as="style"/><link rel="stylesheet" href="styles.css?v=1719133273248"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://prescheme.org/posts/announcing-the-pre-scheme-restoration.html">The Pre-Scheme Restoration</a>Â <span class="domain">(<a href="https://prescheme.org">prescheme.org</a>)</span></div><div class="subtext"><span>nickmain</span> | <span>47 comments</span></div><br/><div><div id="40748559" class="c"><input type="checkbox" id="c-40748559" checked=""/><div class="controls bullet"><span class="by">JonChesterfield</span><span>|</span><a href="#40738114">next</a><span>|</span><label class="collapse" for="c-40748559">[-]</label><label class="expand" for="c-40748559">[3 more]</label></div><br/><div class="children"><div class="content">Fantastic news! This is a really interesting place in the design space and has come so close to being lost to history.<p>I believe the idea is essentially to write C semantics in scheme notation. Variables get marked with &#x27;u32&#x27; or similar instead of being implicit sum types of anything the language can represent, memory allocation is explicit instead of garbage collected. In itself that essentially means writing C syntax trees in prefix notation, which is probably an acquired taste.<p>However scheme also comes with the compile time macro layer and that lot runs just fine in pre-scheme, garbage collected and all, because it&#x27;s burned off before runtime anyway. Specifically, it&#x27;s wholly macro-expanded before compilation to C (or similar), which is the obvious lowering to use for execution.<p>Also scheme has tooling, so if you&#x27;re careful, the type annotated Cish syntax trees execute correctly as scheme, so you can debug the thing there, unit test it from scheme and so forth.<p>I <i>really</i> like it as a path to writing lisp runtimes in something that isn&#x27;t C since an alarming fraction of them turn out to have a C runtime library at the bottom of the stack. Also for writing other things that I tend to write in C, where it&#x27;s really the semantics I want and the syntax getting in the way.</div><br/><div id="40763129" class="c"><input type="checkbox" id="c-40763129" checked=""/><div class="controls bullet"><span class="by">jaccarmac</span><span>|</span><a href="#40748559">parent</a><span>|</span><a href="#40764840">next</a><span>|</span><label class="collapse" for="c-40763129">[-]</label><label class="expand" for="c-40763129">[1 more]</label></div><br/><div class="children"><div class="content">Smalltalk can use a similar bootstrapping method, which blew my mind the first time I read and understood (see <a href="https:&#x2F;&#x2F;ftp.squeak.org&#x2F;docs&#x2F;OOPSLA.Squeak.html" rel="nofollow">https:&#x2F;&#x2F;ftp.squeak.org&#x2F;docs&#x2F;OOPSLA.Squeak.html</a>, &quot;Smalltalk to C Translation&quot;). In that world, images can easily obscure some of the lineage. Scheme has the advantage of having a standard to hold dialects to. I am watching this project with interest.</div><br/></div></div><div id="40764840" class="c"><input type="checkbox" id="c-40764840" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#40748559">parent</a><span>|</span><a href="#40763129">prev</a><span>|</span><a href="#40738114">next</a><span>|</span><label class="collapse" for="c-40764840">[-]</label><label class="expand" for="c-40764840">[1 more]</label></div><br/><div class="children"><div class="content">This is similar to how <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;</a> is written<p>There are two complete implementations<p>1. one that runs under a stock Python interpreter (which doesn&#x27;t use static types)<p>2. one that&#x27;s pure C++, translated from statically typed Python code, and from data structures generated in Python<p>In the second case, everything before main() is  &quot;burned off&quot; at build time -- e.g. there is metaprogramming on lexers, flag parsers, dicts, etc. that gets run and then turned into static C data -- i.e. data that incurs zero startup cost<p>Comparison to Pre-Scheme: <a href="https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;tjiwrd&#x2F;revival_pre_scheme_systems_programming#c_s7b2sp" rel="nofollow">https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;tjiwrd&#x2F;revival_pre_scheme_systems_progra...</a> (types, compiler output, and GC)<p><i>Brief Descriptions of a Python to C++ Translator</i> - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2022&#x2F;05&#x2F;mycpp.html" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2022&#x2F;05&#x2F;mycpp.html</a><p>...<p>And related to your other point, I remember looking at Racket&#x27;s implementation around the time it started the Chez Scheme conversion.   For some reason, I was surprised that it was over 100K lines of hand-written C in the runtime -- it looked similar to CPython in many ways (which is at  least 250K lines of C in the core).</div><br/></div></div></div></div><div id="40738114" class="c"><input type="checkbox" id="c-40738114" checked=""/><div class="controls bullet"><span class="by">paroneayea</span><span>|</span><a href="#40748559">prev</a><span>|</span><a href="#40749558">next</a><span>|</span><label class="collapse" for="c-40738114">[-]</label><label class="expand" for="c-40738114">[1 more]</label></div><br/><div class="children"><div class="content">Pre-Scheme is an <i>incredible</i> piece of history, largely forgotten and lost to time outside of a very small group that knew about it.  Live hackable at the REPL, and yet with static type inference (Hindley-Milner!), compiles to C, no GC?  It&#x27;s something I&#x27;ve always wanted, and it <i>existed</i>, but it felt like one of those lost pieces of technology that was at risk of fading into the dustbin of history.<p>But no more!  It&#x27;s so exciting that Andrew Whatson has begun reviving the project with such great enthusiasm and making it so that Pre-Scheme can run on top of a variety of Schemes.  And it&#x27;s wonderful that NLnet has recognized how important this effort is.  I think Pre-Scheme could play an interesting role alongside Zed and Rust, and indeed I know that Andrew plans to incorporate many of the newer ideas explored in those languages on top of Pre-Scheme eventually.<p>Go Pre-Scheme revival... I&#x27;m cheering it on, and can&#x27;t wait to use this stuff myself!</div><br/></div></div><div id="40749558" class="c"><input type="checkbox" id="c-40749558" checked=""/><div class="controls bullet"><span class="by">voidhorse</span><span>|</span><a href="#40738114">prev</a><span>|</span><a href="#40738718">next</a><span>|</span><label class="collapse" for="c-40749558">[-]</label><label class="expand" for="c-40749558">[4 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp">https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp</a> is a recent attempt to create a similar language, but with a Rust-inspired borrow checker. though it looks like prescheme would end up being less dependent on C  ultimately, this is another option in the space.</div><br/><div id="40764184" class="c"><input type="checkbox" id="c-40764184" checked=""/><div class="controls bullet"><span class="by">dleslie</span><span>|</span><a href="#40749558">parent</a><span>|</span><a href="#40750135">next</a><span>|</span><label class="collapse" for="c-40764184">[-]</label><label class="expand" for="c-40764184">[1 more]</label></div><br/><div class="children"><div class="content">Without a new maintainer and perhaps a group of dedicated supporters, Carp may as well be considered abandoned. The existing head maintainer and major contributor has moved on to other things.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp&#x2F;issues&#x2F;1460#issuecomment-2021047651">https:&#x2F;&#x2F;github.com&#x2F;carp-lang&#x2F;Carp&#x2F;issues&#x2F;1460#issuecomment-2...</a></div><br/></div></div><div id="40750135" class="c"><input type="checkbox" id="c-40750135" checked=""/><div class="controls bullet"><span class="by">dualogy</span><span>|</span><a href="#40749558">parent</a><span>|</span><a href="#40764184">prev</a><span>|</span><a href="#40738718">next</a><span>|</span><label class="collapse" for="c-40750135">[-]</label><label class="expand" for="c-40750135">[2 more]</label></div><br/><div class="children"><div class="content">Stumbled upon this a while ago while looking for &quot;a systems Scheme&quot;, but abandonware in my book given the most recent commit date (and GH Issue).<p>Settled on Gerbil Scheme instead, lively community &amp; been actively developed to this day for over 15 years now. Although fair warning, still GC&#x27;d and (for now) only type-annotated, not (100%) statically typed. But stdlib-wise and compilation-wise still way more &quot;systems-bent&quot; than most Schemes out there.</div><br/><div id="40750252" class="c"><input type="checkbox" id="c-40750252" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#40749558">root</a><span>|</span><a href="#40750135">parent</a><span>|</span><a href="#40738718">next</a><span>|</span><label class="collapse" for="c-40750252">[-]</label><label class="expand" for="c-40750252">[1 more]</label></div><br/><div class="children"><div class="content">Guile is quite systems focused, as well, what with all the POSIX stuff it exposes. But neither Guile nor Gerbil can be used to implement their own runtimes. You need to write the GC, somehow. This is why Pre-Scheme exists.</div><br/></div></div></div></div></div></div><div id="40738718" class="c"><input type="checkbox" id="c-40738718" checked=""/><div class="controls bullet"><span class="by">davexunit</span><span>|</span><a href="#40749558">prev</a><span>|</span><a href="#40764313">next</a><span>|</span><label class="collapse" for="c-40738718">[-]</label><label class="expand" for="c-40738718">[5 more]</label></div><br/><div class="children"><div class="content">I am so excited for a Lispy systems language. Existing languages just don&#x27;t do it for me, though I think Zig is the closest to being what I&#x27;m into. So much good stuff in Scheme48. Glad the good ideas are being revived.</div><br/><div id="40750144" class="c"><input type="checkbox" id="c-40750144" checked=""/><div class="controls bullet"><span class="by">dualogy</span><span>|</span><a href="#40738718">parent</a><span>|</span><a href="#40764313">next</a><span>|</span><label class="collapse" for="c-40750144">[-]</label><label class="expand" for="c-40750144">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I am so excited for a Lispy systems language.<p>Can recommend Gerbil Scheme. Although fair warning, still GC&#x27;d and (for now) only type-annotated, not (100%) statically typed. But stdlib-wise and compilation-wise still way more &quot;systems-bent&quot; than most Schemes out there.</div><br/><div id="40762822" class="c"><input type="checkbox" id="c-40762822" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40738718">root</a><span>|</span><a href="#40750144">parent</a><span>|</span><a href="#40763603">next</a><span>|</span><label class="collapse" for="c-40762822">[-]</label><label class="expand" for="c-40762822">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Gerbil Scheme â A Lisp for the 21st Century</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39809323">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39809323</a> - March 2024 (126 comments)<p><i>Gerbil â A meta-dialect of Scheme</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20585637">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=20585637</a> - Aug 2019 (17 comments)<p><i>Gerbil Scheme</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17707622">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17707622</a> - Aug 2018 (9 comments)<p><i>Gerbil â An opinionated dialect of Scheme designed for systems programming</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15394603">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=15394603</a> - Oct 2017 (78 comments)</div><br/></div></div><div id="40763603" class="c"><input type="checkbox" id="c-40763603" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#40738718">root</a><span>|</span><a href="#40750144">parent</a><span>|</span><a href="#40762822">prev</a><span>|</span><a href="#40764313">next</a><span>|</span><label class="collapse" for="c-40763603">[-]</label><label class="expand" for="c-40763603">[2 more]</label></div><br/><div class="children"><div class="content">Gerbil is based on Gambit, right? Have you tried Gambit itself? I&#x27;m curious how they compare.</div><br/><div id="40765711" class="c"><input type="checkbox" id="c-40765711" checked=""/><div class="controls bullet"><span class="by">dualogy</span><span>|</span><a href="#40738718">root</a><span>|</span><a href="#40763603">parent</a><span>|</span><a href="#40764313">next</a><span>|</span><label class="collapse" for="c-40765711">[-]</label><label class="expand" for="c-40765711">[1 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t, so no hard &quot;comparison&quot; results to offer â but Gambits libs are included in Gerbil and readily importable or some of them (maybe all? dunno) auto-imported, and Gambit is Gerbil&#x27;s compilation foundation essentially AFAIK. Where it differs from or expands upon the Gambit basis is &quot;our own macro expander&quot; (haven&#x27;t particular gotten into that area of understanding yet tho) and the extremely-modern-real-worldish stdlib (http, json, actors, db driver bindings etc), perhaps other aspects too (ie. might cover further SRFIs beyond what Gambit does, dunno for sure though; ie. the FFI might be beyond Gambit&#x27;s or not, again I wouldn&#x27;t know).</div><br/></div></div></div></div></div></div></div></div><div id="40764313" class="c"><input type="checkbox" id="c-40764313" checked=""/><div class="controls bullet"><span class="by">troad</span><span>|</span><a href="#40738718">prev</a><span>|</span><a href="#40748935">next</a><span>|</span><label class="collapse" for="c-40764313">[-]</label><label class="expand" for="c-40764313">[1 more]</label></div><br/><div class="children"><div class="content">This is very cool. I&#x27;ve added it to my RSS reader, can&#x27;t wait to see what comes of it.<p>Genuine question: would there be any advantages in targeting LLVM IR, rather than transpiling to C? With C being notoriously implementation dependent (down to things like the sizes of integer types), it seems like a messy target for something intended to be a sane systems language.</div><br/></div></div><div id="40748935" class="c"><input type="checkbox" id="c-40748935" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#40764313">prev</a><span>|</span><a href="#40751117">next</a><span>|</span><label class="collapse" for="c-40748935">[-]</label><label class="expand" for="c-40748935">[4 more]</label></div><br/><div class="children"><div class="content">Scheme with HM type system sounds fun. I&#x27;ve used ocaml a fair bit and I really find that the sweet spot for effectiveness of types vs arguing with the compiler. Racket and common lisp both have optional type systems but neither ever really clicked with me.</div><br/><div id="40749339" class="c"><input type="checkbox" id="c-40749339" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#40748935">parent</a><span>|</span><a href="#40765328">next</a><span>|</span><label class="collapse" for="c-40749339">[-]</label><label class="expand" for="c-40749339">[2 more]</label></div><br/><div class="children"><div class="content">Have you tried Alexis King&#x27;s Hackett? It was an experiment in coercing Haskell semantics into lisp syntax and it came out really nicely.<p><a href="https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;hackett&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;hackett&#x2F;</a></div><br/><div id="40749398" class="c"><input type="checkbox" id="c-40749398" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#40748935">root</a><span>|</span><a href="#40749339">parent</a><span>|</span><a href="#40765328">next</a><span>|</span><label class="collapse" for="c-40749398">[-]</label><label class="expand" for="c-40749398">[1 more]</label></div><br/><div class="children"><div class="content">Totally new to me, thanks! It looks really fun.</div><br/></div></div></div></div><div id="40765328" class="c"><input type="checkbox" id="c-40765328" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40748935">parent</a><span>|</span><a href="#40749339">prev</a><span>|</span><a href="#40751117">next</a><span>|</span><label class="collapse" for="c-40765328">[-]</label><label class="expand" for="c-40765328">[1 more]</label></div><br/><div class="children"><div class="content">Common Lisp has Coalton [1]. It&#x27;s basically a functional Lisp embedded within Common Lisp which has HM types and a bit more modern constructs than CL.<p>[1] <a href="https:&#x2F;&#x2F;coalton-lang.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;coalton-lang.github.io&#x2F;</a></div><br/></div></div></div></div><div id="40751117" class="c"><input type="checkbox" id="c-40751117" checked=""/><div class="controls bullet"><span class="by">roleks</span><span>|</span><a href="#40748935">prev</a><span>|</span><a href="#40762136">next</a><span>|</span><label class="collapse" for="c-40751117">[-]</label><label class="expand" for="c-40751117">[1 more]</label></div><br/><div class="children"><div class="content">few days I&#x27;ve spent a few hours with prescheme, but was stopped in the end because there where gcc errors. I&#x27;ve felt a little guilty to have have spent some quite some time, but not have achieved anything. But thats the thing with Prescheme, so fascinating I could not resist. I mean look at its history, at all the cool and unique features.
Anyway, very cool to read this news, I&#x27;m also a little relieved not to have burnt all this hours into nothings. Very glad to see the story continues.</div><br/></div></div><div id="40762136" class="c"><input type="checkbox" id="c-40762136" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#40751117">prev</a><span>|</span><a href="#40748404">next</a><span>|</span><label class="collapse" for="c-40762136">[-]</label><label class="expand" for="c-40762136">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Pre-scheme: A Scheme dialect for systems programming (1997) [pdf]</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29725313">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29725313</a> - Dec 2021 (12 comments)<p>(surprised there hasn&#x27;t been more)</div><br/></div></div><div id="40748404" class="c"><input type="checkbox" id="c-40748404" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#40762136">prev</a><span>|</span><a href="#40737659">next</a><span>|</span><label class="collapse" for="c-40748404">[-]</label><label class="expand" for="c-40748404">[1 more]</label></div><br/><div class="children"><div class="content">NLNet is doing god&#x27;s work funding really cool projects that would have a very hard time justifying their existence to some mainstream donors.<p>I dream of some day soon running Emacs&#x2F;Guix&#x2F;Hurd on an open RISC-V chip and not having it be some flossy novelty but a genuine spiritual successor to  Genera and the Lisp Machines.</div><br/></div></div><div id="40737659" class="c"><input type="checkbox" id="c-40737659" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40748404">prev</a><span>|</span><a href="#40749300">next</a><span>|</span><label class="collapse" for="c-40737659">[-]</label><label class="expand" for="c-40737659">[4 more]</label></div><br/><div class="children"><div class="content">According to the article: thanks to a grant from the NLnet foundation under the NGI Zero Core program, Pre-Scheme can continue to be developed. It&#x27;s supposed to be a C alternative. Currently, it compiles to C, has a Hindley Milner type system, macros, and it can run in a Scheme REPL. And they have a roadmap of features now.<p>This is pretty cool, and it&#x27;s generous of them to grant them funding, but (and I&#x27;m not trying to be rude) I wonder why they chose to give a grant for Pre-Scheme specifically. This seems only loosely related to the goals of the NGI Zero Core program (linked in the article):<p>&quot;The next generation internet initiative envisions the information age will be an era that brings out the best in all of us. We want to enable human potential, mobility and creativity at the largest possible scale â while dealing responsibly with our natural resources. In order to preserve and expand the European way of life, the programme helps shape a value-centric, human and inclusive Internet for all.&quot;<p>...<p>&quot;We want a more resilient, trustworthy and open internet. We want to empower end-users. Given the speed at which the &#x27;twin transition&#x27; is taking place, we need a greener internet and more sustainable services sooner rather than later. Neither will happen at global scale without protocol evolution, which â as the case of three decades of IPv6 introduction demonstrates â is extremely challenging. NGI0 Core is designed to push beyond the status quo and create a virtuous cycle of innovation through free and open source software, libre hardware and open standards. If we want everyone to use and benefit from the internet to its full potential without holding back, the internet must be built on strong and transparent technologies that allow for permissionless innovation and are equally accessible to all.&quot;</div><br/><div id="40738086" class="c"><input type="checkbox" id="c-40738086" checked=""/><div class="controls bullet"><span class="by">paroneayea</span><span>|</span><a href="#40737659">parent</a><span>|</span><a href="#40749300">next</a><span>|</span><label class="collapse" for="c-40738086">[-]</label><label class="expand" for="c-40738086">[3 more]</label></div><br/><div class="children"><div class="content">Pre-Scheme is one more path to moving away from low level programming being done on top of directly programmed C for one thing, and the revival effort directly ties in by moving Pre-Scheme to be on top of r7rs, an open standard. This opens up Pre-Scheme to a variety of other ecosystems that NLnet already invests in, including Guix, Mes, and Guile, which have put a lot of efforts into secure and highly reproducible (and indeed bootstrappable) computing.  There&#x27;s definitely some ties in with security and security-oriented communities NLnet already funds, and this project directly works towards moving towards a more standardized approach, leading to hopefully broader adoption.</div><br/><div id="40738211" class="c"><input type="checkbox" id="c-40738211" checked=""/><div class="controls bullet"><span class="by">trealira</span><span>|</span><a href="#40737659">root</a><span>|</span><a href="#40738086">parent</a><span>|</span><a href="#40748732">next</a><span>|</span><label class="collapse" for="c-40738211">[-]</label><label class="expand" for="c-40738211">[1 more]</label></div><br/><div class="children"><div class="content">I see, thanks for contextualizing it for me; I hadn&#x27;t known about the ecosystems NLnet is involved in.</div><br/></div></div></div></div></div></div><div id="40749300" class="c"><input type="checkbox" id="c-40749300" checked=""/><div class="controls bullet"><span class="by">ethagnawl</span><span>|</span><a href="#40737659">prev</a><span>|</span><a href="#40748722">next</a><span>|</span><label class="collapse" for="c-40749300">[-]</label><label class="expand" for="c-40749300">[12 more]</label></div><br/><div class="children"><div class="content">&gt; On another front, the Guix project is a major force bringing new users to Scheme, providing <i>an unparalleled foundation</i> for free and reproducible computing.<p>The Nix&#x2F;OS folks might take exception. I&#x27;m guessing this is tongue-in-cheek but it belies the tone of the rest of the post.<p>In all seriousness, though, this is exciting from a modern, end-user&#x27;s vantage point and fascinating from an historical perspective.</div><br/><div id="40749425" class="c"><input type="checkbox" id="c-40749425" checked=""/><div class="controls bullet"><span class="by">ryukafalz</span><span>|</span><a href="#40749300">parent</a><span>|</span><a href="#40748722">next</a><span>|</span><label class="collapse" for="c-40749425">[-]</label><label class="expand" for="c-40749425">[11 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t read as tongue-in-cheek to me. NixOS does not have an equivalent to Guix&#x27;s full-source bootstrap mentioned in the next sentence: <a href="https:&#x2F;&#x2F;guix.gnu.org&#x2F;blog&#x2F;2023&#x2F;the-full-source-bootstrap-building-from-source-all-the-way-down&#x2F;" rel="nofollow">https:&#x2F;&#x2F;guix.gnu.org&#x2F;blog&#x2F;2023&#x2F;the-full-source-bootstrap-bui...</a><p>Nixpkgs also doesn&#x27;t seem to require that all packages be built from source - which, if you&#x27;re really looking for reproducibility, is a downside. I recognize that there are practical reasons for this, and it&#x27;s part of why Nix has so many more packages available than Guix, but IMO it makes Guix a better foundation to build on if you want as much of your system as possible to be reproducible.</div><br/><div id="40751058" class="c"><input type="checkbox" id="c-40751058" checked=""/><div class="controls bullet"><span class="by">rssoconnor</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40749425">parent</a><span>|</span><a href="#40749497">next</a><span>|</span><label class="collapse" for="c-40751058">[-]</label><label class="expand" for="c-40751058">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Nixpkgs also doesn&#x27;t seem to require that all packages be built from source - which, if you&#x27;re really looking for reproducibility, is a downside.<p>Does Guix not have GHC (Glasgow Haskell Compiler) or did it somehow bootstrap GHC?  Last time I checked bootstrapping GHC on today&#x27;s hardware is effectively an unsolved problem. [1]<p>&gt; NixOS does not have an equivalent to Guix&#x27;s full-source bootstrap<p>While you are not wrong, there is nothing fundamentally stopping Nixpkgs from being bootstrapped in a similar way to Guix.  emilytrau has already done a lot of the work. [2]<p>[1] <a href="https:&#x2F;&#x2F;elephly.net&#x2F;posts&#x2F;2017-01-09-bootstrapping-haskell-part-1.html" rel="nofollow">https:&#x2F;&#x2F;elephly.net&#x2F;posts&#x2F;2017-01-09-bootstrapping-haskell-p...</a>
[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;227914">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;pull&#x2F;227914</a></div><br/><div id="40752311" class="c"><input type="checkbox" id="c-40752311" checked=""/><div class="controls bullet"><span class="by">ryukafalz</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40751058">parent</a><span>|</span><a href="#40749497">next</a><span>|</span><label class="collapse" for="c-40752311">[-]</label><label class="expand" for="c-40752311">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Does Guix not have GHC (Glasgow Haskell Compiler) or did it somehow bootstrap GHC? Last time I checked bootstrapping GHC on today&#x27;s hardware is effectively an unsolved problem.<p>I think you&#x27;re right, it looks like they&#x27;ve gotten a little further now than in that post but there&#x27;s still a gap in the bootstrap chain. So maybe not every package is fully bootstrapped, but they do seem to take it more seriously.<p>&gt; While you are not wrong, there is nothing fundamentally stopping Nixpkgs from being bootstrapped in a similar way to Guix. emilytrau has already done a lot of the work.<p>Yes, I agree, and I hope they get there! I just also think that acknowledging the places where Guix is currently ahead isn&#x27;t wrong. Nix isn&#x27;t the only game in town anymore.</div><br/><div id="40752600" class="c"><input type="checkbox" id="c-40752600" checked=""/><div class="controls bullet"><span class="by">rssoconnor</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40752311">parent</a><span>|</span><a href="#40749497">next</a><span>|</span><label class="collapse" for="c-40752600">[-]</label><label class="expand" for="c-40752600">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it looks like they&#x27;ve gotten a little further now than in that post<p>Can you say more, or provide any references?  I would be interested in the state of the art here.</div><br/><div id="40754650" class="c"><input type="checkbox" id="c-40754650" checked=""/><div class="controls bullet"><span class="by">ryukafalz</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40752600">parent</a><span>|</span><a href="#40749497">next</a><span>|</span><label class="collapse" for="c-40754650">[-]</label><label class="expand" for="c-40754650">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a comment in the Guix source (added by the author of that first post you linked, Ricardo Wurmus) that seems to indicate that they found a way around the segfault problem described in the post by using a registerised version of GHC: <a href="https:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;cgit&#x2F;guix.git&#x2F;tree&#x2F;gnu&#x2F;packages&#x2F;haskell.scm#n366" rel="nofollow">https:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;cgit&#x2F;guix.git&#x2F;tree&#x2F;gnu&#x2F;packages...</a><p>I had to look up exactly what this means, not being very familiar with the Haskell ecosystem myself. It looks like it&#x27;s not the raw source form and is architecture-specific, but it&#x27;s also not the compiled binary form. So that&#x27;s not perfect, but better than relying on the compiled binaries I guess. (Unfortunate for me since my laptop is ARM and I&#x27;d like to be able to use git-annex, haha.) But this seems to work for older versions of GHC.<p>This post by Simon Tournier from last year describes the current situation near the bottom, and from what I can tell this is still correct: <a href="https:&#x2F;&#x2F;simon.tournier.info&#x2F;posts&#x2F;2023-10-01-bootstrapping.html" rel="nofollow">https:&#x2F;&#x2F;simon.tournier.info&#x2F;posts&#x2F;2023-10-01-bootstrapping.h...</a><p>&gt; The bootstrapping problem for Haskell is not solved. And Ricardo works hard on it. Currently, from the older GHC around (4.08.2), which relies on gcc-2.95 â part of the Bootstrapping story above â it is possible to chain until version 6.10.4. Then versions 6.12.3 and 7.4.2 are not packaged yet for completing the Haskell chain from version 4.08.2 to modern version as 9.2.5; fully connecting the dots with bootstrap-seeds and dropping these 450MiB of binaries. The solution of this chicken-or-the-egg is not yet complete.</div><br/></div></div></div></div></div></div></div></div><div id="40749497" class="c"><input type="checkbox" id="c-40749497" checked=""/><div class="controls bullet"><span class="by">Y_Y</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40749425">parent</a><span>|</span><a href="#40751058">prev</a><span>|</span><a href="#40754379">next</a><span>|</span><label class="collapse" for="c-40749497">[-]</label><label class="expand" for="c-40749497">[3 more]</label></div><br/><div class="children"><div class="content">There is also the &quot;secret&quot; nonguix channel which packages nonfree things for Guix: <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;nonguix&#x2F;nonguix" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;nonguix&#x2F;nonguix</a><p>It&#x27;s a funny problem but because it&#x27;s antithetical to the original project&#x27;s spirit you won&#x27;t hear about it from any official Guix sources and so it&#x27;s relatively unknown.</div><br/><div id="40765453" class="c"><input type="checkbox" id="c-40765453" checked=""/><div class="controls bullet"><span class="by">sham1</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40749497">parent</a><span>|</span><a href="#40749726">next</a><span>|</span><label class="collapse" for="c-40765453">[-]</label><label class="expand" for="c-40765453">[1 more]</label></div><br/><div class="children"><div class="content">Nonfree software is a major part of nonguix, both because of the ethical problems which are the raisons d&#x27;Ãªtre of the GNU project, there&#x27;s also the more practical consequence drom the nonfree nature, that you can&#x27;t bootstrap the binaries any you can&#x27;t know their provinence beyond &quot;it&#x27;s from the vendor&quot;.<p>However just to clarify for others, it&#x27;s not the only thing there of course. There is free software in nonguix, maybe because it&#x27;s PITA to bootstrap,  like for example Leinigen and other parts of the Clojure ecosystem, as well as everything and anything written using Electron. And of course notable free software things there are also the blobbed Linux kernel (probably obvious reasons), as well as Firefox, since Mozilla has some interesting trademark opinions, so you can&#x27;t have it on the main Guix channel.</div><br/></div></div><div id="40749726" class="c"><input type="checkbox" id="c-40749726" checked=""/><div class="controls bullet"><span class="by">ryukafalz</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40749497">parent</a><span>|</span><a href="#40765453">prev</a><span>|</span><a href="#40754379">next</a><span>|</span><label class="collapse" for="c-40749726">[-]</label><label class="expand" for="c-40749726">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say it&#x27;s relatively unknown, I see it come up just about every time Guix comes up in discussions here. And I&#x27;m glad nonguix exists, for what it&#x27;s worth.<p>But it&#x27;s helpful to have Guix itself aim for reproducibility even if nonguix exists, so you can install upstream Guix alone if you&#x27;re looking for reproducibility.</div><br/></div></div></div></div><div id="40754379" class="c"><input type="checkbox" id="c-40754379" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40749425">parent</a><span>|</span><a href="#40749497">prev</a><span>|</span><a href="#40748722">next</a><span>|</span><label class="collapse" for="c-40754379">[-]</label><label class="expand" for="c-40754379">[3 more]</label></div><br/><div class="children"><div class="content">Nix doesn&#x27;t require everything to be built from source, sure, but everything downloaded must match a provided hash. What&#x27;s the difference between downloading source code and binaries at that point?</div><br/><div id="40759956" class="c"><input type="checkbox" id="c-40759956" checked=""/><div class="controls bullet"><span class="by">ryukafalz</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40754379">parent</a><span>|</span><a href="#40748722">next</a><span>|</span><label class="collapse" for="c-40759956">[-]</label><label class="expand" for="c-40759956">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easier to audit source code than binaries, and easier to audit it once than once for each architecture.</div><br/><div id="40765245" class="c"><input type="checkbox" id="c-40765245" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#40749300">root</a><span>|</span><a href="#40759956">parent</a><span>|</span><a href="#40748722">next</a><span>|</span><label class="collapse" for="c-40765245">[-]</label><label class="expand" for="c-40765245">[1 more]</label></div><br/><div class="children"><div class="content">Auditing is irrelevant to whether or not it&#x27;s reproducable, which was the question here.<p>You also forgo any improvements to compiler improvements</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40748722" class="c"><input type="checkbox" id="c-40748722" checked=""/><div class="controls bullet"><span class="by">dg_meme</span><span>|</span><a href="#40749300">prev</a><span>|</span><a href="#40749085">next</a><span>|</span><label class="collapse" for="c-40748722">[-]</label><label class="expand" for="c-40748722">[2 more]</label></div><br/><div class="children"><div class="content">Please don&#x27;t write &quot;thanks to a generous grant from the NLnet foundation under the NGI Zero Core program&quot;. The most of money comes from the European Commission through the Horizon Europe &#x2F; NGI funding schemes. NLNet is mainly the operator of the call.</div><br/><div id="40749263" class="c"><input type="checkbox" id="c-40749263" checked=""/><div class="controls bullet"><span class="by">paroneayea</span><span>|</span><a href="#40748722">parent</a><span>|</span><a href="#40749085">next</a><span>|</span><label class="collapse" for="c-40749263">[-]</label><label class="expand" for="c-40749263">[1 more]</label></div><br/><div class="children"><div class="content">The European Commission deserves thanks for funding the commons, a thing that rarely happens by governments, but should!  NGI Zero was thanked though?<p>NLnet being the operator of the call is no small thing though, having been through the process they are very thoughtful, knowledgeable, thorough in how they run things.  They even run the software they fund and verify it&#x27;s working and check that the overall ideas are sensible, which is something I can&#x27;t say of many other grant programs I&#x27;ve interacted with.  So NLnet does deserve thanks.</div><br/></div></div></div></div><div id="40749085" class="c"><input type="checkbox" id="c-40749085" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40748722">prev</a><span>|</span><a href="#40748945">next</a><span>|</span><label class="collapse" for="c-40749085">[-]</label><label class="expand" for="c-40749085">[6 more]</label></div><br/><div class="children"><div class="content">The hell of the systems language is the systems, not that it has infix syntax.</div><br/><div id="40764346" class="c"><input type="checkbox" id="c-40764346" checked=""/><div class="controls bullet"><span class="by">neilv</span><span>|</span><a href="#40749085">parent</a><span>|</span><a href="#40763185">next</a><span>|</span><label class="collapse" for="c-40764346">[-]</label><label class="expand" for="c-40764346">[2 more]</label></div><br/><div class="children"><div class="content">When they write this:<p>&gt; <i>Scheme syntax, with full support for macros,</i><p>you can read that <i>not</i> as that Scheme prefix syntax alone is a big selling point, but the fact that it then supports Scheme macros (which are much better than in most other languages that support some kind of macros, partly due to the syntax making this easier).<p>Then you can read the rest of the sentence, for a bonus:<p>&gt; <i>and a compatibility library to run Pre-Scheme code in a Scheme interpreter.</i><p>Which means that you can do things like develop using this language within a normal Scheme development environment, possibly share code between developing for the PreScheme compiler target and non-PreScheme targets, etc.</div><br/><div id="40765410" class="c"><input type="checkbox" id="c-40765410" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#40749085">root</a><span>|</span><a href="#40764346">parent</a><span>|</span><a href="#40763185">next</a><span>|</span><label class="collapse" for="c-40765410">[-]</label><label class="expand" for="c-40765410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; but the fact that it then supports Scheme macros<p>Good for them.<p>&gt; possibly share code between developing for the PreScheme compiler target and non-PreScheme targets<p>&quot;possibly&quot; is a strong word, seeing that Pre-Scheme is a statically typed, explicitly memory managed subset and all. There&#x27;s a very large and coarse-grained semantic leap.<p>Then you can read the rest of &lt;<a href="https:&#x2F;&#x2F;www.steveblackburn.org&#x2F;pubs&#x2F;papers&#x2F;vmmagic-vee-2009.pdf" rel="nofollow">https:&#x2F;&#x2F;www.steveblackburn.org&#x2F;pubs&#x2F;papers&#x2F;vmmagic-vee-2009....</a>&gt;, for a bonus.</div><br/></div></div></div></div><div id="40763185" class="c"><input type="checkbox" id="c-40763185" checked=""/><div class="controls bullet"><span class="by">kagevf</span><span>|</span><a href="#40749085">parent</a><span>|</span><a href="#40764346">prev</a><span>|</span><a href="#40763594">next</a><span>|</span><label class="collapse" for="c-40763185">[-]</label><label class="expand" for="c-40763185">[1 more]</label></div><br/><div class="children"><div class="content">It looks like with this, you get macros and a repl, though.</div><br/></div></div><div id="40763594" class="c"><input type="checkbox" id="c-40763594" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#40749085">parent</a><span>|</span><a href="#40763185">prev</a><span>|</span><a href="#40749212">next</a><span>|</span><label class="collapse" for="c-40763594">[-]</label><label class="expand" for="c-40763594">[1 more]</label></div><br/><div class="children"><div class="content">Pre-Scheme can be run in a Scheme system, then when it is found to be correct there, compiled VERY straightforwardly to C. This is a huge win in terms of productivity. Plus, at the top level, at compile time, you have <i>all</i> of Scheme available.</div><br/></div></div><div id="40749212" class="c"><input type="checkbox" id="c-40749212" checked=""/><div class="controls bullet"><span class="by">Zambyte</span><span>|</span><a href="#40749085">parent</a><span>|</span><a href="#40763594">prev</a><span>|</span><a href="#40748945">next</a><span>|</span><label class="collapse" for="c-40749212">[-]</label><label class="expand" for="c-40749212">[1 more]</label></div><br/><div class="children"><div class="content">Depends on if your &quot;systems programming&quot; activities consist of compiling Scheme or not.</div><br/></div></div></div></div><div id="40748945" class="c"><input type="checkbox" id="c-40748945" checked=""/><div class="controls bullet"><span class="by">pjc50</span><span>|</span><a href="#40749085">prev</a><span>|</span><label class="collapse" for="c-40748945">[-]</label><label class="expand" for="c-40748945">[1 more]</label></div><br/><div class="children"><div class="content">A Hindley-Milner typed language with rigorous semantics for targeting native platforms? Amazing! Pity about the syntax.</div><br/></div></div></div></div></div></div></div></body></html>