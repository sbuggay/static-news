<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1707987667563" as="style"/><link rel="stylesheet" href="styles.css?v=1707987667563"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rosenzweig.io/blog/conformant-gl46-on-the-m1.html">Conformant OpenGL 4.6 on the M1</a> <span class="domain">(<a href="https://rosenzweig.io">rosenzweig.io</a>)</span></div><div class="subtext"><span>patadune</span> | <span>83 comments</span></div><br/><div><div id="39376815" class="c"><input type="checkbox" id="c-39376815" checked=""/><div class="controls bullet"><span class="by">zdimension</span><span>|</span><a href="#39374200">next</a><span>|</span><label class="collapse" for="c-39376815">[-]</label><label class="expand" for="c-39376815">[1 more]</label></div><br/><div class="children"><div class="content">Alyssa Rosenzweig is a gift to the community that keeps on giving. Every one of her blog posts is a guarantee to learn something you didn&#x27;t know about the internals of modern graphics hardware.</div><br/></div></div><div id="39374200" class="c"><input type="checkbox" id="c-39374200" checked=""/><div class="controls bullet"><span class="by">noiv</span><span>|</span><a href="#39376815">prev</a><span>|</span><a href="#39377227">next</a><span>|</span><label class="collapse" for="c-39374200">[-]</label><label class="expand" for="c-39374200">[1 more]</label></div><br/><div class="children"><div class="content">This endeavour proofs to me skills beat talkativeness every single day. Just reading the blogs sets my brain on fire. There is so much to unpack. The punch line is not the last but the second sentence, nevertheless you&#x27;re forced to follow the path into the rabbit hole until you enjoy reading one bit manipulation after the other.<p>If there ever are benchmarks with eureka effects per paragraph Alyssa will lead them all.<p>Just thanks!</div><br/></div></div><div id="39377227" class="c"><input type="checkbox" id="c-39377227" checked=""/><div class="controls bullet"><span class="by">jokoon</span><span>|</span><a href="#39374200">prev</a><span>|</span><a href="#39376301">next</a><span>|</span><label class="collapse" for="c-39377227">[-]</label><label class="expand" for="c-39377227">[13 more]</label></div><br/><div class="children"><div class="content">One day, Apple will deprecate opengl 3.3 core, and I guess everybody might end up deprecating it.<p>I&#x27;ve read that generally opengl is just easier to use than vulkan, I don&#x27;t know if that&#x27;s true, but if something is too complicated, it becomes just too hard for less experienced devs to exploit those GPU, and it becomes a barrier to entry, which might discourage some indie game developers.<p>Although everyone uses unity and unreal now, baking things from scratch or using other engines is just weird now, for some reason. It&#x27;s really annoying, and it&#x27;s fun to see gamedev wake up after unity tried to lock things more.<p>Open source in gaming has always been stretched thin. Godot is there, but I doubt it&#x27;s able to seriously compete with unity and unreal even if I want it to, so even if godot is capable, indie gamedevs are more experienced with unity and unreal and will stick to those.<p>The state of open source in game dev feels really hopeless sometimes, the rise of next gen graphics API are not making things easy.</div><br/><div id="39380469" class="c"><input type="checkbox" id="c-39380469" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#39377227">parent</a><span>|</span><a href="#39377384">next</a><span>|</span><label class="collapse" for="c-39380469">[-]</label><label class="expand" for="c-39380469">[1 more]</label></div><br/><div class="children"><div class="content">WGPU is kinda supposed to solve the problem by making a cross platform API more user friendly than Vulkan. The problem with OpenGL is that it is too far from how GPUs work and it&#x27;s hard to get good performance out of it.</div><br/></div></div><div id="39377384" class="c"><input type="checkbox" id="c-39377384" checked=""/><div class="controls bullet"><span class="by">taminka</span><span>|</span><a href="#39377227">parent</a><span>|</span><a href="#39380469">prev</a><span>|</span><a href="#39379037">next</a><span>|</span><label class="collapse" for="c-39377384">[-]</label><label class="expand" for="c-39377384">[5 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve read that generally opengl is just easier to use than vulkan<p>[here&#x27;s](<a href="https:&#x2F;&#x2F;learnopengl.com&#x2F;code_viewer_gh.php?code=src&#x2F;1.getting_started&#x2F;2.2.hello_triangle_indexed&#x2F;hello_triangle_indexed.cpp" rel="nofollow">https:&#x2F;&#x2F;learnopengl.com&#x2F;code_viewer_gh.php?code=src&#x2F;1.gettin...</a>) an opengl triangle rendering example code (~200 LOC)<p>[here&#x27;s](<a href="https:&#x2F;&#x2F;vulkan-tutorial.com&#x2F;code&#x2F;17_swap_chain_recreation.cpp" rel="nofollow">https:&#x2F;&#x2F;vulkan-tutorial.com&#x2F;code&#x2F;17_swap_chain_recreation.cp...</a>) a vulkan triangle rendering example code (~1000 LOC)<p>ye it&#x27;s fair to say opengl is a bit easier to use ijbol</div><br/><div id="39379024" class="c"><input type="checkbox" id="c-39379024" checked=""/><div class="controls bullet"><span class="by">_gabe_</span><span>|</span><a href="#39377227">root</a><span>|</span><a href="#39377384">parent</a><span>|</span><a href="#39377488">next</a><span>|</span><label class="collapse" for="c-39379024">[-]</label><label class="expand" for="c-39379024">[2 more]</label></div><br/><div class="children"><div class="content">You’re getting downvoted for some reason, but OpenGL is absolutely easier. It abstracts so much (and for beginners there’s still a ton even with all the abstraction!). No need to think about how to prep pipelines, optimally upload your data, manually synchronize your rendering, and more with OpenGL, unlike Vulkan. The low level nature of Vulkan allows you to eek out every bit of performance, but for indie game developers and the majority of graphics development that doesn’t depend on realtime PBR with giant amounts of data, OpenGL is still immensely useful.<p>If anything, an OpenGL-like API will naturally be developed on top of Vulkan for the users that don’t care about all that stuff. And once again, I can’t stress this enough, OpenGL is still <i>a lot</i> for beginners. Shaders, geometric transformations, the fixed function pipeline, vertex layouts, shader buffer objects, textures, mip maps, instancing, buffers in general, there’s sooo much to learn and these foundations transcend OpenGL and apply to all graphics rendering. As a beginner, OpenGL allowing me to focus on the higher level details was immensely beneficial for me getting started on my graphics programming journey.</div><br/><div id="39379352" class="c"><input type="checkbox" id="c-39379352" checked=""/><div class="controls bullet"><span class="by">scheeseman486</span><span>|</span><a href="#39377227">root</a><span>|</span><a href="#39379024">parent</a><span>|</span><a href="#39377488">next</a><span>|</span><label class="collapse" for="c-39379352">[-]</label><label class="expand" for="c-39379352">[1 more]</label></div><br/><div class="children"><div class="content">It won&#x27;t be OpenGL-like, it will probably just be OpenGL
<a href="https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;drivers&#x2F;zink.html" rel="nofollow">https:&#x2F;&#x2F;docs.mesa3d.org&#x2F;drivers&#x2F;zink.html</a></div><br/></div></div></div></div><div id="39377488" class="c"><input type="checkbox" id="c-39377488" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39377227">root</a><span>|</span><a href="#39377384">parent</a><span>|</span><a href="#39379024">prev</a><span>|</span><a href="#39379037">next</a><span>|</span><label class="collapse" for="c-39377488">[-]</label><label class="expand" for="c-39377488">[2 more]</label></div><br/><div class="children"><div class="content">This is a bit misleading.  Much of the extra code that you&#x27;d have to write in Vulkan to get to first-triangle is just that, a one-time cost.  And you can use a third-party library, framework or engine to take care of it.  Vulkan merely splits out the hardware-native low level from the library support layer, that were conflated in OpenGL, and lets the latter evolve freely via a third party ecosystem.  That&#x27;s just a sensible choice.</div><br/><div id="39377742" class="c"><input type="checkbox" id="c-39377742" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#39377227">root</a><span>|</span><a href="#39377488">parent</a><span>|</span><a href="#39379037">next</a><span>|</span><label class="collapse" for="c-39377742">[-]</label><label class="expand" for="c-39377742">[1 more]</label></div><br/><div class="children"><div class="content">And often those LOC examples use GLFW or some other library to load OpenGL. Loading a Vulkan instance is a walk in the park compared to initializing an OpenGL context, especially on Windows. It&#x27;s incredibly misleading. If you allowed utility libraries for Vulkan to compare LOC-to-triangle Vulkan would be much closer to OpenGL.</div><br/></div></div></div></div></div></div><div id="39379037" class="c"><input type="checkbox" id="c-39379037" checked=""/><div class="controls bullet"><span class="by">xign</span><span>|</span><a href="#39377227">parent</a><span>|</span><a href="#39377384">prev</a><span>|</span><a href="#39379716">next</a><span>|</span><label class="collapse" for="c-39379037">[-]</label><label class="expand" for="c-39379037">[1 more]</label></div><br/><div class="children"><div class="content">FWIW Metal is actually easier to use than Vulkan in my opinion, as Vulkan is kind of designed to be super flexible and doesn&#x27;t have as much niceties in it. Either way, OpenGL was simply too high level to be exposed as the direct API of the drivers. It&#x27;s much better to have a lower level API like Vulkan as the base layer, and then build something like OpenGL <i>on top of</i> Vulkan instead. It maps much better to how GPU hardware works this way. There&#x27;s a reason why we have a concept of software layers.<p>It&#x27;s also not quite true that everyone uses Unity and Unreal. Just look at the Game of the Year nominees from The Game Award 2023. All 6 of them were built using in-house game engines. Among indies there are also still some amount of developers who develop their own engines (e.g. Hades), but it&#x27;s true that the majority of them will just use an off-the-shelf one.</div><br/></div></div><div id="39379716" class="c"><input type="checkbox" id="c-39379716" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#39377227">parent</a><span>|</span><a href="#39379037">prev</a><span>|</span><a href="#39379466">next</a><span>|</span><label class="collapse" for="c-39379716">[-]</label><label class="expand" for="c-39379716">[3 more]</label></div><br/><div class="children"><div class="content">OpenGL is not deprecated, it is simpler and continues to be used where Vulkan is overkill. Using it for greenfields is a good choice if it covers all your needs (and if you don&#x27;t mind the stateful render pipeline).</div><br/><div id="39379949" class="c"><input type="checkbox" id="c-39379949" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39377227">root</a><span>|</span><a href="#39379716">parent</a><span>|</span><a href="#39380026">next</a><span>|</span><label class="collapse" for="c-39379949">[-]</label><label class="expand" for="c-39379949">[1 more]</label></div><br/><div class="children"><div class="content">It kind of is, OpenGL 4.6 is the very last version, the red book only covers until OpenGL 4.5, and some hardware vendors are now shipping OpenGL on top of Vulkan or DirectX, instead of providing native OpenGL drivers.<p>While not officially deprecated, it is standing still and won&#x27;t get anything newer past 2017 hardware, not even newer extensions are being made available.</div><br/></div></div><div id="39380026" class="c"><input type="checkbox" id="c-39380026" checked=""/><div class="controls bullet"><span class="by">klausa</span><span>|</span><a href="#39377227">root</a><span>|</span><a href="#39379716">parent</a><span>|</span><a href="#39379949">prev</a><span>|</span><a href="#39379466">next</a><span>|</span><label class="collapse" for="c-39380026">[-]</label><label class="expand" for="c-39380026">[1 more]</label></div><br/><div class="children"><div class="content">It is officially deprecated on all Apple platforms, and has been for five years now.<p>Whether it will actually stop working anytime soon is a different question; but it is not a supported API.</div><br/></div></div></div></div><div id="39379466" class="c"><input type="checkbox" id="c-39379466" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#39377227">parent</a><span>|</span><a href="#39379716">prev</a><span>|</span><a href="#39377775">next</a><span>|</span><label class="collapse" for="c-39379466">[-]</label><label class="expand" for="c-39379466">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One day, Apple will deprecate opengl 3.3 core, and I guess everybody might end up deprecating it.<p>And here I am, recalling all the games and programs that failed once OpenGL 2.0 was implemented because they required OpenGL 1.1 or 1.2 but just checked the minor version number... time flies!</div><br/></div></div><div id="39377775" class="c"><input type="checkbox" id="c-39377775" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39377227">parent</a><span>|</span><a href="#39379466">prev</a><span>|</span><a href="#39376301">next</a><span>|</span><label class="collapse" for="c-39377775">[-]</label><label class="expand" for="c-39377775">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that one of the primary reasons Vulkan was developed was because OpenGL was not a good model for GPUs, and supporting it prevented people from taking advantage of the hardware in many cases.</div><br/></div></div></div></div><div id="39376301" class="c"><input type="checkbox" id="c-39376301" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#39377227">prev</a><span>|</span><a href="#39377810">next</a><span>|</span><label class="collapse" for="c-39376301">[-]</label><label class="expand" for="c-39376301">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Regrettably, the M1 doesn’t map well to any graphics standard newer than OpenGL ES 3.1. While Vulkan makes some of these features optional, the missing features are required to layer DirectX and OpenGL on top. No existing solution on M1 gets past the OpenGL 4.1 feature set.<p>I&#x27;m very curious to know the performance impact of this, particularly compared to using Metal on macOS. (I&#x27;m sure the answer is &quot;it depends&quot;, but still.)<p>It&#x27;s possible the article answers this question, but I didn&#x27;t understand most of it. :(</div><br/><div id="39376652" class="c"><input type="checkbox" id="c-39376652" checked=""/><div class="controls bullet"><span class="by">gilgoomesh</span><span>|</span><a href="#39376301">parent</a><span>|</span><a href="#39377810">next</a><span>|</span><label class="collapse" for="c-39376652">[-]</label><label class="expand" for="c-39376652">[1 more]</label></div><br/><div class="children"><div class="content">There isn&#x27;t necessarily much difference between implementing features in driver compute code versus GPU hardware support. Even the &quot;hardware support&quot; is usually implemented in GPU microcode. It often goes through the same silicon. Any feature could hit a performance bottleneck and it&#x27;s hard to know which feature will bottleneck until you try.</div><br/></div></div></div></div><div id="39377810" class="c"><input type="checkbox" id="c-39377810" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39376301">prev</a><span>|</span><a href="#39372872">next</a><span>|</span><label class="collapse" for="c-39377810">[-]</label><label class="expand" for="c-39377810">[4 more]</label></div><br/><div class="children"><div class="content">I find it very amusing that transitioning out of bounds accesses from traps to returning some random data is called “robustness”. Graphics programming certainly is weird.</div><br/><div id="39378739" class="c"><input type="checkbox" id="c-39378739" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#39377810">parent</a><span>|</span><a href="#39379101">next</a><span>|</span><label class="collapse" for="c-39378739">[-]</label><label class="expand" for="c-39378739">[1 more]</label></div><br/><div class="children"><div class="content">It makes sense from the perspective of writing graphics drivers, and aligns with Postel&#x27;s law (also called the robustness principle). GPU drivers are all about making broken applications run, or run faster. Making your GPU drivers strict by default won&#x27;t fix the systemic problems with the video game industry shipping broken code, it&#x27;ll just drive away all of your users.<p>And on hardware where branches are generally painfully expensive, it sounds <i>really</i> useful to have a flag to tell the system to quietly handle edge cases in whatever way is most efficient. I suspect there are a lot of valid use cases for such a mode where the programmer can be reasonably sure that those edge cases will have little or no impact on what the user ends up seeing in the final rendered frame.</div><br/></div></div><div id="39379101" class="c"><input type="checkbox" id="c-39379101" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#39377810">parent</a><span>|</span><a href="#39378739">prev</a><span>|</span><a href="#39379965">next</a><span>|</span><label class="collapse" for="c-39379101">[-]</label><label class="expand" for="c-39379101">[1 more]</label></div><br/><div class="children"><div class="content">The out of bounds accesses don&#x27;t necessarily trap without the robustness checks, so the robustness is about delivering known results under those goofy cases.  So it makes sense when you combine that with the fact that GPUs are pretty against traps in general.  Carmack remarked once that it&#x27;s was a pain to get manufacturers to be into the idea of virtual memory when he was designing megatexture.</div><br/></div></div><div id="39379965" class="c"><input type="checkbox" id="c-39379965" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39377810">parent</a><span>|</span><a href="#39379101">prev</a><span>|</span><a href="#39372872">next</a><span>|</span><label class="collapse" for="c-39379965">[-]</label><label class="expand" for="c-39379965">[1 more]</label></div><br/><div class="children"><div class="content">This is one of the reasons why C and C++ have a rosy life ahead of themselves on graphics, HPC, HEP, HFT domains.<p>In domains where &quot;performance trumps safety&quot; culture reigns, talking about other programing languages is like talking to a wall.</div><br/></div></div></div></div><div id="39372872" class="c"><input type="checkbox" id="c-39372872" checked=""/><div class="controls bullet"><span class="by">politician</span><span>|</span><a href="#39377810">prev</a><span>|</span><a href="#39374026">next</a><span>|</span><label class="collapse" for="c-39372872">[-]</label><label class="expand" for="c-39372872">[6 more]</label></div><br/><div class="children"><div class="content">This is for Fedora on the M1. It would be amazing to get this for macOS. What&#x27;s involved in pulling something like that off?</div><br/><div id="39372992" class="c"><input type="checkbox" id="c-39372992" checked=""/><div class="controls bullet"><span class="by">jamesfmilne</span><span>|</span><a href="#39372872">parent</a><span>|</span><a href="#39380276">next</a><span>|</span><label class="collapse" for="c-39372992">[-]</label><label class="expand" for="c-39372992">[1 more]</label></div><br/><div class="children"><div class="content">Ultimately they build command buffers and send them to the GPU. You&#x27;d need a way to do that from macOS.<p>The original Mesa drivers for the M1 GPU were bootstrapped by doing just that, sending command buffers to the AGX driver in macOS using IOKit.<p><a href="https:&#x2F;&#x2F;rosenzweig.io&#x2F;blog&#x2F;asahi-gpu-part-2.html" rel="nofollow">https:&#x2F;&#x2F;rosenzweig.io&#x2F;blog&#x2F;asahi-gpu-part-2.html</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;AsahiLinux&#x2F;gpu&#x2F;blob&#x2F;main&#x2F;demo&#x2F;iokit.c">https:&#x2F;&#x2F;github.com&#x2F;AsahiLinux&#x2F;gpu&#x2F;blob&#x2F;main&#x2F;demo&#x2F;iokit.c</a><p>So you&#x27;d need a bit more glue in Mesa to get the surfaces from the GPU into something you can composite onto the screen in macOS.</div><br/></div></div><div id="39380276" class="c"><input type="checkbox" id="c-39380276" checked=""/><div class="controls bullet"><span class="by">skykooler</span><span>|</span><a href="#39372872">parent</a><span>|</span><a href="#39372992">prev</a><span>|</span><a href="#39372951">next</a><span>|</span><label class="collapse" for="c-39380276">[-]</label><label class="expand" for="c-39380276">[1 more]</label></div><br/><div class="children"><div class="content">According to the devs, it isn&#x27;t really possible due to Apple not having a stable public kernel API: <a href="https:&#x2F;&#x2F;social.treehouse.systems&#x2F;@AsahiLinux&#x2F;111930744188229065" rel="nofollow">https:&#x2F;&#x2F;social.treehouse.systems&#x2F;@AsahiLinux&#x2F;111930744188229...</a></div><br/></div></div><div id="39372951" class="c"><input type="checkbox" id="c-39372951" checked=""/><div class="controls bullet"><span class="by">fayalalebrun</span><span>|</span><a href="#39372872">parent</a><span>|</span><a href="#39380276">prev</a><span>|</span><a href="#39379447">next</a><span>|</span><label class="collapse" for="c-39372951">[-]</label><label class="expand" for="c-39372951">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps already possible via MoltenVK -&gt; Vulkan -&gt; Zink?</div><br/><div id="39373958" class="c"><input type="checkbox" id="c-39373958" checked=""/><div class="controls bullet"><span class="by">Guzba</span><span>|</span><a href="#39372872">root</a><span>|</span><a href="#39372951">parent</a><span>|</span><a href="#39379447">next</a><span>|</span><label class="collapse" for="c-39373958">[-]</label><label class="expand" for="c-39373958">[1 more]</label></div><br/><div class="children"><div class="content">Probably needs one or two more layers just to be sure.</div><br/></div></div></div></div><div id="39379447" class="c"><input type="checkbox" id="c-39379447" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#39372872">parent</a><span>|</span><a href="#39372951">prev</a><span>|</span><a href="#39374026">next</a><span>|</span><label class="collapse" for="c-39379447">[-]</label><label class="expand" for="c-39379447">[1 more]</label></div><br/><div class="children"><div class="content">I think Apple bans third party kernel drivers? To write a proper Vulkan or OpenGL implementation you need a kernel counterpart for handling the GPU if I understand correctly. That&#x27;s probably the reason no one bothers implementing native Vulkan for macOS.<p>But if it&#x27;s doable with Apple&#x27;s driver - then not sure.</div><br/></div></div></div></div><div id="39374026" class="c"><input type="checkbox" id="c-39374026" checked=""/><div class="controls bullet"><span class="by">breather</span><span>|</span><a href="#39372872">prev</a><span>|</span><a href="#39373557">next</a><span>|</span><label class="collapse" for="c-39374026">[-]</label><label class="expand" for="c-39374026">[6 more]</label></div><br/><div class="children"><div class="content">This is obviously very exciting, but—why not target Vulkan first? It seems like the more salient target these days and one on top of which we already have an OpenGL implementation.</div><br/><div id="39376616" class="c"><input type="checkbox" id="c-39376616" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#39374026">parent</a><span>|</span><a href="#39374112">next</a><span>|</span><label class="collapse" for="c-39376616">[-]</label><label class="expand" for="c-39376616">[1 more]</label></div><br/><div class="children"><div class="content">OpenGL-on-Vulkan compat layers aren&#x27;t magic. For them to support a given OpenGL feature, an equivalent feature must be supported by the Vulkan driver (often as an extension). That means you can&#x27;t just implement a baseline Vulkan driver and get OGL 4.6 support for free, you must put in the work to implement all the OGL 4.6 features in your Vulkan driver if you want MESA to translate OGL 4.6 to Vulkan for you.<p>Plus, this isn&#x27;t Alyssa&#x27;s first reverse engineering + OpenGL driver project. I don&#x27;t know the details but I&#x27;d imagine it&#x27;s much easier and quicker to implement a driver for an API you&#x27;re used to making drivers for, than to implement a driver for an API you aren&#x27;t.</div><br/></div></div><div id="39374112" class="c"><input type="checkbox" id="c-39374112" checked=""/><div class="controls bullet"><span class="by">wtallis</span><span>|</span><a href="#39374026">parent</a><span>|</span><a href="#39376616">prev</a><span>|</span><a href="#39374459">next</a><span>|</span><label class="collapse" for="c-39374112">[-]</label><label class="expand" for="c-39374112">[3 more]</label></div><br/><div class="children"><div class="content">They started with targeting older OpenGL to get a basic feature set working first. I guess from there, getting up to a more recent OpenGL was less work than doing a complete Vulkan implementation, and they probably learned a lot about what they&#x27;ll need to do for Vulkan.</div><br/><div id="39375402" class="c"><input type="checkbox" id="c-39375402" checked=""/><div class="controls bullet"><span class="by">breather</span><span>|</span><a href="#39374026">root</a><span>|</span><a href="#39374112">parent</a><span>|</span><a href="#39374459">next</a><span>|</span><label class="collapse" for="c-39375402">[-]</label><label class="expand" for="c-39375402">[2 more]</label></div><br/><div class="children"><div class="content">Ok, this makes a lot of sense—OpenGL sort of forms a pathway of incremental support.</div><br/><div id="39376060" class="c"><input type="checkbox" id="c-39376060" checked=""/><div class="controls bullet"><span class="by">simcop2387</span><span>|</span><a href="#39374026">root</a><span>|</span><a href="#39375402">parent</a><span>|</span><a href="#39374459">next</a><span>|</span><label class="collapse" for="c-39376060">[-]</label><label class="expand" for="c-39376060">[1 more]</label></div><br/><div class="children"><div class="content">Along with that, it&#x27;s more immediately useful as it&#x27;s used for desktops and compositers still, so getting a useful environment necessitates it.</div><br/></div></div></div></div></div></div><div id="39374459" class="c"><input type="checkbox" id="c-39374459" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#39374026">parent</a><span>|</span><a href="#39374112">prev</a><span>|</span><a href="#39373557">next</a><span>|</span><label class="collapse" for="c-39374459">[-]</label><label class="expand" for="c-39374459">[1 more]</label></div><br/><div class="children"><div class="content">I thought something similar, but from their comments, to support OpenGL over Vulkan you need higher versions of Vulkan anyway and it&#x27;s still a big effort. So they decided to go with (lower versions of) OpenGL first to get something functional sooner.</div><br/></div></div></div></div><div id="39373557" class="c"><input type="checkbox" id="c-39373557" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#39374026">prev</a><span>|</span><a href="#39372866">next</a><span>|</span><label class="collapse" for="c-39373557">[-]</label><label class="expand" for="c-39373557">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>How do we break the 4.1 barrier? Without hardware support, new features need new tricks. Geometry shaders, tessellation, and transform feedback become compute shaders. Cull distance becomes a transformed interpolated value. Clip control becomes a vertex shader epilogue. The list goes on.</i><p>I wonder how much of this work is in m1 gpu code, versus how much feature-implemented-on-another-festure work could be reused by others.<p>This feels very similar to what Zink does (runs complex opengl capabilities via a more primitive Vulkan), except there is no Vulkan backend to target for m1. Yet.</div><br/><div id="39376184" class="c"><input type="checkbox" id="c-39376184" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#39373557">parent</a><span>|</span><a href="#39372866">next</a><span>|</span><label class="collapse" for="c-39376184">[-]</label><label class="expand" for="c-39376184">[1 more]</label></div><br/><div class="children"><div class="content">More generally, you could execute complex OpenGL or Vulkan on some more-or-less arbitrary combination of CPU soft-rendering and hardware-specific native acceleration support. It would just be a matter of doing the work, and it could be reused across a wide variety of hardware - including perhaps older hardware that may be quite well understood but not usable on its own for modern workloads.</div><br/></div></div></div></div><div id="39372866" class="c"><input type="checkbox" id="c-39372866" checked=""/><div class="controls bullet"><span class="by">ics</span><span>|</span><a href="#39373557">prev</a><span>|</span><a href="#39373238">next</a><span>|</span><label class="collapse" for="c-39372866">[-]</label><label class="expand" for="c-39372866">[3 more]</label></div><br/><div class="children"><div class="content">Another upvote, another article I wish I had the knowledge and patience to understand better in context. Still, Alyssa&#x27;s writeups are a fun read.</div><br/><div id="39373156" class="c"><input type="checkbox" id="c-39373156" checked=""/><div class="controls bullet"><span class="by">randgoog</span><span>|</span><a href="#39372866">parent</a><span>|</span><a href="#39373238">next</a><span>|</span><label class="collapse" for="c-39373156">[-]</label><label class="expand" for="c-39373156">[2 more]</label></div><br/><div class="children"><div class="content">Same, I wish I knew more about graphics programming. It seems like such a steep learning curve though so I get discouraged.</div><br/><div id="39379268" class="c"><input type="checkbox" id="c-39379268" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#39372866">root</a><span>|</span><a href="#39373156">parent</a><span>|</span><a href="#39373238">next</a><span>|</span><label class="collapse" for="c-39379268">[-]</label><label class="expand" for="c-39379268">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t be discouraged, modern graphics APIs really are a mess, but you don&#x27;t need to understand 1&#x2F;100th of them to get graphics going. Also, this post is more about programming drivers than programming graphics.</div><br/></div></div></div></div></div></div><div id="39373238" class="c"><input type="checkbox" id="c-39373238" checked=""/><div class="controls bullet"><span class="by">ryandvm</span><span>|</span><a href="#39372866">prev</a><span>|</span><a href="#39373313">next</a><span>|</span><label class="collapse" for="c-39373238">[-]</label><label class="expand" for="c-39373238">[22 more]</label></div><br/><div class="children"><div class="content">Kind of crazy to think that the only reason OpenGL was ever a thing for 3D gaming was because of John Carmack&#x27;s obsession with using it for Quake II back in the 90s.</div><br/><div id="39379991" class="c"><input type="checkbox" id="c-39379991" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39373238">parent</a><span>|</span><a href="#39373384">next</a><span>|</span><label class="collapse" for="c-39379991">[-]</label><label class="expand" for="c-39379991">[1 more]</label></div><br/><div class="children"><div class="content">John Carmack a couple of years later, back in 2011:<p>&gt; Speaking to bit-tech for a forthcoming Custom PC feature about the future of OpenGL in PC gaming, Carmack said &#x27;I actually think that Direct3D is a rather better API today.&#x27; He also added that &#x27;Microsoft had the courage to continue making significant incompatible changes to improve the API, while OpenGL has been held back by compatibility concerns. Direct3D handles multi-threading better, and newer versions manage state better.&#x27;<p>&gt; It is really just inertia that keeps us on OpenGL at this point,&#x27; Carmack told us. He also explained that the developer has no plans to move over to Direct3D, despite its advantages.<p>From <a href="https:&#x2F;&#x2F;www.bit-tech.net&#x2F;news&#x2F;gaming&#x2F;pc&#x2F;carmack-directx-better-opengl&#x2F;1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bit-tech.net&#x2F;news&#x2F;gaming&#x2F;pc&#x2F;carmack-directx-bett...</a></div><br/></div></div><div id="39373384" class="c"><input type="checkbox" id="c-39373384" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#39373238">parent</a><span>|</span><a href="#39379991">prev</a><span>|</span><a href="#39373304">next</a><span>|</span><label class="collapse" for="c-39373384">[-]</label><label class="expand" for="c-39373384">[3 more]</label></div><br/><div class="children"><div class="content">Quake is just (a probably small (not wanting to dimish it, of course)) part of the history. SGI and the enormous effort to get compliant implementations on many different systems and architectures are what made OpenGL what it eventually became.</div><br/><div id="39375238" class="c"><input type="checkbox" id="c-39375238" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373384">parent</a><span>|</span><a href="#39373304">next</a><span>|</span><label class="collapse" for="c-39375238">[-]</label><label class="expand" for="c-39375238">[2 more]</label></div><br/><div class="children"><div class="content">I think both SGI and Quake were absolutely crucial.<p>Without Quake, OpenGL would have remained an extremely niche thing for professional CAD and modeling software. And Microsoft would have <i>completely</i> owned the 3D gaming API space.<p>Quake (and Quake 2, and Quake 3, and the many games that licensed those engines) really opened the floodgates in terms of mass market users demanding OpenGL capabilities (or at least a subset of them) from their hardware and drivers.<p>I&#x27;m not sure how to measure this in an objective way, but if the mass market of PC gamers didn&#x27;t dwarf the professional CAD&#x2F;modeling market by several orders of magnitude, I will print out my HN posting history and eat it.</div><br/><div id="39380001" class="c"><input type="checkbox" id="c-39380001" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39375238">parent</a><span>|</span><a href="#39373304">next</a><span>|</span><label class="collapse" for="c-39380001">[-]</label><label class="expand" for="c-39380001">[1 more]</label></div><br/><div class="children"><div class="content">Microsoft never owned the 3D gaming API space, SEGA, Sony and Nintendo also have&#x2F;had their own APIs.</div><br/></div></div></div></div></div></div><div id="39373304" class="c"><input type="checkbox" id="c-39373304" checked=""/><div class="controls bullet"><span class="by">cmovq</span><span>|</span><a href="#39373238">parent</a><span>|</span><a href="#39373384">prev</a><span>|</span><a href="#39376384">next</a><span>|</span><label class="collapse" for="c-39373304">[-]</label><label class="expand" for="c-39373304">[6 more]</label></div><br/><div class="children"><div class="content">I don’t know that it was the only reason, but Carmack’s push for OpenGL certainly helped. A lot of things related to 3D games are thanks to doom and Quake.</div><br/><div id="39376402" class="c"><input type="checkbox" id="c-39376402" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373304">parent</a><span>|</span><a href="#39373828">next</a><span>|</span><label class="collapse" for="c-39376402">[-]</label><label class="expand" for="c-39376402">[1 more]</label></div><br/><div class="children"><div class="content">It also helped that the API was actually user friendly compared to the earlier versions of Direct3D.</div><br/></div></div><div id="39373828" class="c"><input type="checkbox" id="c-39373828" checked=""/><div class="controls bullet"><span class="by">pengaru</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373304">parent</a><span>|</span><a href="#39376402">prev</a><span>|</span><a href="#39376384">next</a><span>|</span><label class="collapse" for="c-39373828">[-]</label><label class="expand" for="c-39373828">[4 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of things related to 3D games are thanks to doom and Quake.<p>Quake sure, but Doom?  IIRC Doom is far more like Wolf3D&#x27;s 2.5D&#x2F;raycasting than the &quot;true 3D&quot; of Quake, it cpu rendered to a frame buffer with zero hardware acceleration.  I find it hard to believe it made any lasting impact on any subsequent 3D rendering APIs.</div><br/><div id="39374961" class="c"><input type="checkbox" id="c-39374961" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373828">parent</a><span>|</span><a href="#39376238">next</a><span>|</span><label class="collapse" for="c-39374961">[-]</label><label class="expand" for="c-39374961">[2 more]</label></div><br/><div class="children"><div class="content">Quake didn&#x27;t use hardware acceleration either. It was only the later VQuake and GLQuake releases that did.</div><br/><div id="39375255" class="c"><input type="checkbox" id="c-39375255" checked=""/><div class="controls bullet"><span class="by">JohnBooty</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39374961">parent</a><span>|</span><a href="#39376238">next</a><span>|</span><label class="collapse" for="c-39375255">[-]</label><label class="expand" for="c-39375255">[1 more]</label></div><br/><div class="children"><div class="content">I think for the purposes of this discussion &quot;Quake&quot; is acceptable shorthand for GLQuake, Quake 2, Quake 3, all the games that used those engines, etc.</div><br/></div></div></div></div><div id="39376238" class="c"><input type="checkbox" id="c-39376238" checked=""/><div class="controls bullet"><span class="by">babypuncher</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373828">parent</a><span>|</span><a href="#39374961">prev</a><span>|</span><a href="#39376384">next</a><span>|</span><label class="collapse" for="c-39376238">[-]</label><label class="expand" for="c-39376238">[1 more]</label></div><br/><div class="children"><div class="content">Quake got official 3D accelerated versions like GLQuake and VQuake. The improved visuals and better performance these versions offered drove a lot of early 3D accelerator sales in the consumer space.</div><br/></div></div></div></div></div></div><div id="39376384" class="c"><input type="checkbox" id="c-39376384" checked=""/><div class="controls bullet"><span class="by">badsectoracula</span><span>|</span><a href="#39373238">parent</a><span>|</span><a href="#39373304">prev</a><span>|</span><a href="#39374147">next</a><span>|</span><label class="collapse" for="c-39376384">[-]</label><label class="expand" for="c-39376384">[1 more]</label></div><br/><div class="children"><div class="content">Fun fact: the earliest archived OpenGL site was a big &quot;FAST GAMES GRAPHICS&quot; banner with an animated Quake 1 graphic and a menu for other stuff :-P<p><a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;19970707113513&#x2F;http:&#x2F;&#x2F;www.opengl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;19970707113513&#x2F;http:&#x2F;&#x2F;www.opengl...</a></div><br/></div></div><div id="39374147" class="c"><input type="checkbox" id="c-39374147" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#39373238">parent</a><span>|</span><a href="#39376384">prev</a><span>|</span><a href="#39373879">next</a><span>|</span><label class="collapse" for="c-39374147">[-]</label><label class="expand" for="c-39374147">[1 more]</label></div><br/><div class="children"><div class="content">For context <a href="https:&#x2F;&#x2F;www.chrishecker.com&#x2F;OpenGL&#x2F;Press_Release" rel="nofollow">https:&#x2F;&#x2F;www.chrishecker.com&#x2F;OpenGL&#x2F;Press_Release</a></div><br/></div></div><div id="39373879" class="c"><input type="checkbox" id="c-39373879" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39373238">parent</a><span>|</span><a href="#39374147">prev</a><span>|</span><a href="#39373313">next</a><span>|</span><label class="collapse" for="c-39373879">[-]</label><label class="expand" for="c-39373879">[9 more]</label></div><br/><div class="children"><div class="content">And yet it still got its ass kicked by Direct3D because Microsoft made better stuff. Better API, better tooling, better debuggability.<p>Honestly, it would&#x27;ve been better to leave OpenGL to the legacy CAD vendors and standardize on Direct3D roundabout 1997 or so.</div><br/><div id="39374187" class="c"><input type="checkbox" id="c-39374187" checked=""/><div class="controls bullet"><span class="by">Keyframe</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373879">parent</a><span>|</span><a href="#39374044">next</a><span>|</span><label class="collapse" for="c-39374187">[-]</label><label class="expand" for="c-39374187">[1 more]</label></div><br/><div class="children"><div class="content">Ye good ol&#x27; Microsoft stiffled OpenGL on Windows, hence open letter <a href="https:&#x2F;&#x2F;www.chrishecker.com&#x2F;OpenGL&#x2F;Press_Release" rel="nofollow">https:&#x2F;&#x2F;www.chrishecker.com&#x2F;OpenGL&#x2F;Press_Release</a> not to mention insidious thing they did on Fahrenheit (next gen OpenGL+Direct3D, one to rule them all) when they were supposed to be working on it together with SGI. Microsoft did a well job after with it, but they were and are a shit company that made sus maneuvers to make success; Not all of them technical.</div><br/></div></div><div id="39374044" class="c"><input type="checkbox" id="c-39374044" checked=""/><div class="controls bullet"><span class="by">breather</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39373879">parent</a><span>|</span><a href="#39374187">prev</a><span>|</span><a href="#39373313">next</a><span>|</span><label class="collapse" for="c-39374044">[-]</label><label class="expand" for="c-39374044">[7 more]</label></div><br/><div class="children"><div class="content">Well, except for only working on xbox and windows, which pretty much destroys it as a viable direct target for modern games or apps.<p>&gt; Honestly, it would&#x27;ve been better to leave OpenGL to the legacy CAD vendors and standardize on Direct3D roundabout 1997 or so.<p>If you remember what Microsoft was like in those days, the chances of D3D being standardized in a viable way on any platform but windows were about the same chances as an ice cube in hell stands.</div><br/><div id="39379973" class="c"><input type="checkbox" id="c-39379973" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39374044">parent</a><span>|</span><a href="#39377038">next</a><span>|</span><label class="collapse" for="c-39379973">[-]</label><label class="expand" for="c-39379973">[1 more]</label></div><br/><div class="children"><div class="content">Nintendo and Sony 3D APIs are also exlusive to their consoles, people keep forgeting about them.</div><br/></div></div><div id="39377038" class="c"><input type="checkbox" id="c-39377038" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39374044">parent</a><span>|</span><a href="#39379973">prev</a><span>|</span><a href="#39374377">next</a><span>|</span><label class="collapse" for="c-39377038">[-]</label><label class="expand" for="c-39377038">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a viable direct target for modern games<p>Aside from PlayStation exclusives, nearly every AAA game in the past 20+ years has targeted Direct3D and HLSL first. Any other backend is a port.</div><br/><div id="39377754" class="c"><input type="checkbox" id="c-39377754" checked=""/><div class="controls bullet"><span class="by">p_l</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39377038">parent</a><span>|</span><a href="#39374377">next</a><span>|</span><label class="collapse" for="c-39377754">[-]</label><label class="expand" for="c-39377754">[1 more]</label></div><br/><div class="children"><div class="content">The XBox versions of DirectX aren&#x27;t exactly compatible (in some pretty significant ways, IIRC)</div><br/></div></div></div></div><div id="39374377" class="c"><input type="checkbox" id="c-39374377" checked=""/><div class="controls bullet"><span class="by">malermeister</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39374044">parent</a><span>|</span><a href="#39377038">prev</a><span>|</span><a href="#39373313">next</a><span>|</span><label class="collapse" for="c-39374377">[-]</label><label class="expand" for="c-39374377">[3 more]</label></div><br/><div class="children"><div class="content">Technically, also Linux (and probably other Vulkan platforms) with dxvk.</div><br/><div id="39375597" class="c"><input type="checkbox" id="c-39375597" checked=""/><div class="controls bullet"><span class="by">breather</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39374377">parent</a><span>|</span><a href="#39373313">next</a><span>|</span><label class="collapse" for="c-39375597">[-]</label><label class="expand" for="c-39375597">[2 more]</label></div><br/><div class="children"><div class="content">I had no idea this was a thing! Cheers.</div><br/><div id="39376052" class="c"><input type="checkbox" id="c-39376052" checked=""/><div class="controls bullet"><span class="by">malermeister</span><span>|</span><a href="#39373238">root</a><span>|</span><a href="#39375597">parent</a><span>|</span><a href="#39373313">next</a><span>|</span><label class="collapse" for="c-39376052">[-]</label><label class="expand" for="c-39376052">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also VKD3D for dx12!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39373313" class="c"><input type="checkbox" id="c-39373313" checked=""/><div class="controls bullet"><span class="by">marcodiego</span><span>|</span><a href="#39373238">prev</a><span>|</span><a href="#39373214">next</a><span>|</span><label class="collapse" for="c-39373313">[-]</label><label class="expand" for="c-39373313">[21 more]</label></div><br/><div class="children"><div class="content">&quot;Unlike the vendor’s non-conformant 4.1 drivers, our open source Linux drivers are conformant to the latest OpenGL versions, finally promising broad compatibility with modern OpenGL workloads, like Blender, Ryujinx, and Citra.&quot;<p>Looks like apple silicon are currently the best hardware for running linux and linux is the best OS for apple silicon machines.</div><br/><div id="39373439" class="c"><input type="checkbox" id="c-39373439" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39373758">next</a><span>|</span><label class="collapse" for="c-39373439">[-]</label><label class="expand" for="c-39373439">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Looks like apple silicon are currently the best hardware for running linux and linux is the best OS for apple silicon machines<p>Blender has Metal support for Apple Silicon macs. The Metal API is better architected (largely due to being more modern and being developed with benefit of hindsight) so all things equal I&#x27;d pick the Metal version on Mac.<p>In case you missed it in the article, the M1 GPU does not natively support OpenGL 4.6. They had to emulate certain features. The blog post goes into some of the performance compromises that were necessary to make the full OpenGL emulation work properly. Absolutely a good compromise if you&#x27;re on Linux and need to run a modern OpenGL app, but if your only goal is to run Blender as well as possible then you&#x27;d want to stick to macOS.<p>Ryujinx is a Nintendo Switch emulator. They added support for Apple Silicon Macs a couple years ago and have been improving since then: <a href="https:&#x2F;&#x2F;blog.ryujinx.org&#x2F;the-impossible-port-macos&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.ryujinx.org&#x2F;the-impossible-port-macos&#x2F;</a><p>Linux on Apple hardware has come a long way due to some incredible feats of engineering, but it&#x27;s far from perfect. Calling it the &quot;best OS for Apple Silicon&quot; is a huuuuge reach.<p>It&#x27;s great if you need to run Linux for day to day operations, though.</div><br/><div id="39373687" class="c"><input type="checkbox" id="c-39373687" checked=""/><div class="controls bullet"><span class="by">galad87</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373439">parent</a><span>|</span><a href="#39373758">next</a><span>|</span><label class="collapse" for="c-39373687">[-]</label><label class="expand" for="c-39373687">[2 more]</label></div><br/><div class="children"><div class="content">Right, Blender Cycles for example can run on Metal, but neither on OpenGL or Vulkan.
So while it&#x27;s nice to have a working OpenGL, it depends if your workflow requires OpenGL apps.</div><br/><div id="39374466" class="c"><input type="checkbox" id="c-39374466" checked=""/><div class="controls bullet"><span class="by">vetinari</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373687">parent</a><span>|</span><a href="#39373758">next</a><span>|</span><label class="collapse" for="c-39374466">[-]</label><label class="expand" for="c-39374466">[1 more]</label></div><br/><div class="children"><div class="content">I would be very surprised, if Blender Cycles ever ran on top of OpenGL or Vulkan other than using OpenGL or Vulkan as a loader for compute shaders.<p>That&#x27;s why it is running as CUDA&#x2F;OptiX&#x2F;HIP&#x2F;oneAPI on Windows and Linux.</div><br/></div></div></div></div></div></div><div id="39373758" class="c"><input type="checkbox" id="c-39373758" checked=""/><div class="controls bullet"><span class="by">johnbatch</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39373439">prev</a><span>|</span><a href="#39373447">next</a><span>|</span><label class="collapse" for="c-39373758">[-]</label><label class="expand" for="c-39373758">[3 more]</label></div><br/><div class="children"><div class="content">Strange the article doesn&#x27;t use the word &quot;Apple&quot; once, and instead awkwardly uses &quot;the vendor&quot; to refer to Apple.</div><br/><div id="39373965" class="c"><input type="checkbox" id="c-39373965" checked=""/><div class="controls bullet"><span class="by">breather</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373758">parent</a><span>|</span><a href="#39373447">next</a><span>|</span><label class="collapse" for="c-39373965">[-]</label><label class="expand" for="c-39373965">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s inline with how the linux&#x2F;floss community refers to hardware vendors in general, even if Apple is a unique case in many circumstances.</div><br/><div id="39377269" class="c"><input type="checkbox" id="c-39377269" checked=""/><div class="controls bullet"><span class="by">doubled112</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373965">parent</a><span>|</span><a href="#39373447">next</a><span>|</span><label class="collapse" for="c-39377269">[-]</label><label class="expand" for="c-39377269">[1 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t CentOS use &quot;the vendor&quot; instead of RHEL like this too?</div><br/></div></div></div></div></div></div><div id="39373447" class="c"><input type="checkbox" id="c-39373447" checked=""/><div class="controls bullet"><span class="by">sho_hn</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39373758">prev</a><span>|</span><a href="#39376515">next</a><span>|</span><label class="collapse" for="c-39373447">[-]</label><label class="expand" for="c-39373447">[4 more]</label></div><br/><div class="children"><div class="content">I would love for my employer to support that config at work. We have quite lovely Linux dev laptops, but the battery life of the M1&#x2F;M2 machines in the IT shop is definitely enticing, and Asahi Linux gets closer to MacOS in that regard than you might think given the relative maturity and optimization.</div><br/><div id="39376459" class="c"><input type="checkbox" id="c-39376459" checked=""/><div class="controls bullet"><span class="by">eek2121</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373447">parent</a><span>|</span><a href="#39376515">next</a><span>|</span><label class="collapse" for="c-39376459">[-]</label><label class="expand" for="c-39376459">[3 more]</label></div><br/><div class="children"><div class="content">It definitely isn’t ready for use as a daily driver. There are lots of bits missing (see below for an example) and power management isn’t great compared to macOS.</div><br/><div id="39379368" class="c"><input type="checkbox" id="c-39379368" checked=""/><div class="controls bullet"><span class="by">rowanG077</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39376459">parent</a><span>|</span><a href="#39376515">next</a><span>|</span><label class="collapse" for="c-39379368">[-]</label><label class="expand" for="c-39379368">[2 more]</label></div><br/><div class="children"><div class="content">How so? I&#x27;m daily driving it as my only machine since November.sure there are missing features but none that are really essential for most people.</div><br/><div id="39380052" class="c"><input type="checkbox" id="c-39380052" checked=""/><div class="controls bullet"><span class="by">klausa</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39379368">parent</a><span>|</span><a href="#39376515">next</a><span>|</span><label class="collapse" for="c-39380052">[-]</label><label class="expand" for="c-39380052">[1 more]</label></div><br/><div class="children"><div class="content">You and I have very different work environments for you to be able to claim that microphones aren&#x27;t essential for most people.</div><br/></div></div></div></div></div></div></div></div><div id="39376457" class="c"><input type="checkbox" id="c-39376457" checked=""/><div class="controls bullet"><span class="by">tarruda</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39376515">prev</a><span>|</span><a href="#39373880">next</a><span>|</span><label class="collapse" for="c-39376457">[-]</label><label class="expand" for="c-39376457">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Looks like apple silicon are currently the best hardware for running linux<p>I wonder if this effort to run Linux on apple silicon will continue if  snapdragon X laptops become mainstream.</div><br/><div id="39380317" class="c"><input type="checkbox" id="c-39380317" checked=""/><div class="controls bullet"><span class="by">seabrookmx</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39376457">parent</a><span>|</span><a href="#39373880">next</a><span>|</span><label class="collapse" for="c-39380317">[-]</label><label class="expand" for="c-39380317">[1 more]</label></div><br/><div class="children"><div class="content">I think it will. One of the main issues with desktop linux is still broad hardware support. Random crap like fingerprint readers or Wi-Fi cards still don&#x27;t work on certain machines. By having a very constrained set of hardware options, it makes it a lot easier to support. The snapdragon devices are also starting way behind.. both the Surface X and Lenovo X13S snapdragon devices exist today but Linux support isn&#x27;t close to Asahi.</div><br/></div></div></div></div><div id="39373880" class="c"><input type="checkbox" id="c-39373880" checked=""/><div class="controls bullet"><span class="by">brucethemoose2</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39376457">prev</a><span>|</span><a href="#39373948">next</a><span>|</span><label class="collapse" for="c-39373880">[-]</label><label class="expand" for="c-39373880">[1 more]</label></div><br/><div class="children"><div class="content">And Sodium! (For minecraft)</div><br/></div></div><div id="39373948" class="c"><input type="checkbox" id="c-39373948" checked=""/><div class="controls bullet"><span class="by">specto</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39373880">prev</a><span>|</span><a href="#39373442">next</a><span>|</span><label class="collapse" for="c-39373948">[-]</label><label class="expand" for="c-39373948">[2 more]</label></div><br/><div class="children"><div class="content">Still waiting for some hardware support and hardware video decoding.</div><br/><div id="39374583" class="c"><input type="checkbox" id="c-39374583" checked=""/><div class="controls bullet"><span class="by">stirlo</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373948">parent</a><span>|</span><a href="#39373442">next</a><span>|</span><label class="collapse" for="c-39374583">[-]</label><label class="expand" for="c-39374583">[1 more]</label></div><br/><div class="children"><div class="content">Hardware video decoding is well on the way: <a href="https:&#x2F;&#x2F;github.com&#x2F;eiln&#x2F;avd">https:&#x2F;&#x2F;github.com&#x2F;eiln&#x2F;avd</a></div><br/></div></div></div></div><div id="39373442" class="c"><input type="checkbox" id="c-39373442" checked=""/><div class="controls bullet"><span class="by">vrodic</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39373948">prev</a><span>|</span><a href="#39373616">next</a><span>|</span><label class="collapse" for="c-39373442">[-]</label><label class="expand" for="c-39373442">[2 more]</label></div><br/><div class="children"><div class="content">apparently a lot of hardware is still not properly supported, like speakers, microphones and energy saving</div><br/><div id="39373802" class="c"><input type="checkbox" id="c-39373802" checked=""/><div class="controls bullet"><span class="by">acdha</span><span>|</span><a href="#39373313">root</a><span>|</span><a href="#39373442">parent</a><span>|</span><a href="#39373616">next</a><span>|</span><label class="collapse" for="c-39373802">[-]</label><label class="expand" for="c-39373802">[1 more]</label></div><br/><div class="children"><div class="content">Here’s the list of very detailed support status: speakers are generally supported but microphones are not. They have a driver for some energy savings but it has some rough edges.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;AsahiLinux&#x2F;docs&#x2F;wiki&#x2F;Feature-Support">https:&#x2F;&#x2F;github.com&#x2F;AsahiLinux&#x2F;docs&#x2F;wiki&#x2F;Feature-Support</a></div><br/></div></div></div></div><div id="39373616" class="c"><input type="checkbox" id="c-39373616" checked=""/><div class="controls bullet"><span class="by">seba_dos1</span><span>|</span><a href="#39373313">parent</a><span>|</span><a href="#39373442">prev</a><span>|</span><a href="#39373499">next</a><span>|</span><label class="collapse" for="c-39373616">[-]</label><label class="expand" for="c-39373616">[1 more]</label></div><br/><div class="children"><div class="content">...and you came to that conclusion because of OpenGL 4.6 - something that several other platforms enjoyed under GNU&#x2F;Linux with FLOSS drivers for more than half a decade now?</div><br/></div></div></div></div></div></div></div></div></div></body></html>