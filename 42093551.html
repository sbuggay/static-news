<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731488470162" as="style"/><link rel="stylesheet" href="styles.css?v=1731488470162"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://brooksblog.bearblog.dev/rusts-sneaky-deadlock-with-if-let-blocks/">Rust&#x27;s Sneaky Deadlock With `if let` Blocks</a> <span class="domain">(<a href="https://brooksblog.bearblog.dev">brooksblog.bearblog.dev</a>)</span></div><div class="subtext"><span>lukastyrychtr</span> | <span>72 comments</span></div><br/><div><div id="42121804" class="c"><input type="checkbox" id="c-42121804" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#42123706">next</a><span>|</span><label class="collapse" for="c-42121804">[-]</label><label class="expand" for="c-42121804">[3 more]</label></div><br/><div class="children"><div class="content">Clippy already has an error for this pattern with Mutex. It should be trivial to extend it to cover RwLock.<p><pre><code>    error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock
      --&gt; src&#x2F;main.rs:5:5
       |
    5  |       if let Some(num) = *map.lock().unwrap() {
       |       ^                   --- this Mutex will remain locked for the entire `if let`-block...
       |  _____|
       | |
    6  | |         eprintln!(&quot;There&#x27;s a number in there: {num}&quot;);
    7  | |     } else {
    8  | |         let mut lock2 = map.lock().unwrap();
       | |                         --- ... and is tried to lock again here, which will always deadlock.
    9  | |         *lock2 = Some(5);
    10 | |         eprintln!(&quot;There will now be a number {lock2:?}&quot;);
    11 | |     }
       | |_____^
       |
       = help: move the lock call outside of the `if let ...` expression
       = help: for further information visit https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#if_let_mutex
       = note: `#[deny(clippy::if_let_mutex)]` on by default</code></pre></div><br/><div id="42123440" class="c"><input type="checkbox" id="c-42123440" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#42121804">parent</a><span>|</span><a href="#42123706">next</a><span>|</span><label class="collapse" for="c-42123440">[-]</label><label class="expand" for="c-42123440">[2 more]</label></div><br/><div class="children"><div class="content">There are a lot of alternative lock implementations that are used all the time, with the most common ones probably being tokios RwLock&#x2F;Mutex and parking_lot.<p>That lint won&#x27;t help for those.</div><br/><div id="42123939" class="c"><input type="checkbox" id="c-42123939" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42121804">root</a><span>|</span><a href="#42123440">parent</a><span>|</span><a href="#42123706">next</a><span>|</span><label class="collapse" for="c-42123939">[-]</label><label class="expand" for="c-42123939">[1 more]</label></div><br/><div class="children"><div class="content">There was an idea floated for another lint `#[diagnostics::lint_as_temporary(reason = &quot;...&quot;)]`, which is supposed to be added by implementors of such locks. <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154#issuecomment-2442178932">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154#issuecomment...</a></div><br/></div></div></div></div></div></div><div id="42123706" class="c"><input type="checkbox" id="c-42123706" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#42121804">prev</a><span>|</span><a href="#42121782">next</a><span>|</span><label class="collapse" for="c-42123706">[-]</label><label class="expand" for="c-42123706">[4 more]</label></div><br/><div class="children"><div class="content">While I never dove deep into Rust, until now I have kinda naively expected for some reason that Rust&#x27;s lifetimes and ownership model prevents these trivial deadlocks at compile time. Thinking about it now, there&#x27;s no reason why it would. Still lots of footguns.<p>Also, from my experience, acquiring and releasing a mutex multiple times within a single code path feels to me like a smelly, subtly faulty code. Are there legitimate cases when it is inevitable and correct?</div><br/><div id="42123996" class="c"><input type="checkbox" id="c-42123996" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42123706">parent</a><span>|</span><a href="#42123812">next</a><span>|</span><label class="collapse" for="c-42123996">[-]</label><label class="expand" for="c-42123996">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have kinda naively expected for some reason that Rust&#x27;s lifetimes and ownership model prevents these trivial deadlocks at compile time.<p>A `Mutex`&#x2F;`RwLock` is doing borrow checking at runtime, effectively replacing the compile time one.</div><br/></div></div><div id="42123812" class="c"><input type="checkbox" id="c-42123812" checked=""/><div class="controls bullet"><span class="by">vanviegen</span><span>|</span><a href="#42123706">parent</a><span>|</span><a href="#42123996">prev</a><span>|</span><a href="#42123807">next</a><span>|</span><label class="collapse" for="c-42123812">[-]</label><label class="expand" for="c-42123812">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have kinda naively expected for some reason that Rust&#x27;s lifetimes and ownership model prevents these trivial deadlocks at compile time.<p>It does in a way, as you&#x27;d generally do multi-threading using message passing (for which the borrow checker can verify thread-exclusive data access) instead of manual locking.</div><br/></div></div><div id="42123807" class="c"><input type="checkbox" id="c-42123807" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#42123706">parent</a><span>|</span><a href="#42123812">prev</a><span>|</span><a href="#42121782">next</a><span>|</span><label class="collapse" for="c-42123807">[-]</label><label class="expand" for="c-42123807">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, intuitively Mutex is actually one of the tools that you use to negotiate with the borrow checker (it&#x27;s one implementation of &quot;interior mutability&quot;, allowing conversions from immutable to mutable borrows by taking the lock), so it is kind of by definition not something Rust can prevent, outside of lints and other static analysis.<p>I can&#x27;t think of a use case for taking a mutex lock multiple times in a code path, but there is a common cache pattern with RwLock, where you have a &quot;fast path&quot; that only takes a read lock to perform a lookup, and then only take a write lock when inserting a new entry. In this case, you should be using an upgradable read lock, so there is technically a &quot;re-lock&quot; of the same RwLock on upgrade in the same codepath. This model <i>does</i> prevent deadlocks because of move semantics.</div><br/></div></div></div></div><div id="42121782" class="c"><input type="checkbox" id="c-42121782" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42123706">prev</a><span>|</span><a href="#42124008">next</a><span>|</span><label class="collapse" for="c-42121782">[-]</label><label class="expand" for="c-42121782">[8 more]</label></div><br/><div class="children"><div class="content">This is going to be fixed in Rust 2024:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;124085">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;124085</a></div><br/><div id="42121784" class="c"><input type="checkbox" id="c-42121784" checked=""/><div class="controls bullet"><span class="by">dgfitz</span><span>|</span><a href="#42121782">parent</a><span>|</span><a href="#42124008">next</a><span>|</span><label class="collapse" for="c-42121784">[-]</label><label class="expand" for="c-42121784">[7 more]</label></div><br/><div class="children"><div class="content">Did they just miss this in the spec?</div><br/><div id="42121815" class="c"><input type="checkbox" id="c-42121815" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42121782">root</a><span>|</span><a href="#42121784">parent</a><span>|</span><a href="#42124008">next</a><span>|</span><label class="collapse" for="c-42121815">[-]</label><label class="expand" for="c-42121815">[6 more]</label></div><br/><div class="children"><div class="content">From my understanding: The original implementation is consistent with the behavior of `match`. However it was realized that it is both less intuitive than early dropping (as this post suggests) and also gets in the way of understandable semantics for if let chains, so the decision was made to change it in the next edition.<p>match still retains the old behavior.</div><br/><div id="42122418" class="c"><input type="checkbox" id="c-42122418" checked=""/><div class="controls bullet"><span class="by">acjohnson55</span><span>|</span><a href="#42121782">root</a><span>|</span><a href="#42121815">parent</a><span>|</span><a href="#42124008">next</a><span>|</span><label class="collapse" for="c-42122418">[-]</label><label class="expand" for="c-42122418">[5 more]</label></div><br/><div class="children"><div class="content">Why does the behavior make sense in match?</div><br/><div id="42122721" class="c"><input type="checkbox" id="c-42122721" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42121782">root</a><span>|</span><a href="#42122418">parent</a><span>|</span><a href="#42122649">next</a><span>|</span><label class="collapse" for="c-42122721">[-]</label><label class="expand" for="c-42122721">[2 more]</label></div><br/><div class="children"><div class="content">Match has multiple branches, and some or all of them can bind variables, (borrowed from the value matched against), defined in that branch. For that to be possible, it means that the temporary lifetime of the matched value must encompass all the branches.<p>Compared to that, if let - else has only two branches: one where matching (and possible variable binding) happens, and one where it doesn&#x27;t. You couldn&#x27;t have anything borrowed from the matched value in the else branch, so the lifetime extending to encompass the else branch is not strictly necessary.</div><br/><div id="42123063" class="c"><input type="checkbox" id="c-42123063" checked=""/><div class="controls bullet"><span class="by">NobodyNada</span><span>|</span><a href="#42121782">root</a><span>|</span><a href="#42122721">parent</a><span>|</span><a href="#42122649">next</a><span>|</span><label class="collapse" for="c-42123063">[-]</label><label class="expand" for="c-42123063">[1 more]</label></div><br/><div class="children"><div class="content">Also, from a pure syntax perspective, an if let block reads like it creates a binding that exists within the scope of the braces after the if, and a match block reads like it creates a binding that exists within the &quot;scope&quot; of the braces surrounding the entire match block.<p>These all read the same to me from a scoping perspective:<p><pre><code>    if let Some(x) = expr {
        &#x2F;&#x2F; expr is live here
    }

    while let Some(x) = expr {
        &#x2F;&#x2F; expr is live here
    }

    match expr {
        &#x2F;&#x2F; expr is live here
        Some(x) =&gt; {},
        _ =&gt; { &#x2F;* expr is still live, doesn&#x27;t matter that x is inaccessible *&#x2F;
    }

    fn foo(x: i32) {
        &#x2F;&#x2F; same idea, the variable x belongs to the scope it&#x27;s declared alongside
    }
</code></pre>
For the scope of an if-let expression to extend into the else block afterwards violates the principle of least surprise for me -- and clearly the author of the OP too!<p><pre><code>    if let Some(x) = expr {
        &#x2F;&#x2F; expr is live here
    } else {
        &#x2F;&#x2F; ??? why is expr live here? the if is clearly &quot;out of scope!&quot;
    }</code></pre></div><br/></div></div></div></div><div id="42122649" class="c"><input type="checkbox" id="c-42122649" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42121782">root</a><span>|</span><a href="#42122418">parent</a><span>|</span><a href="#42122721">prev</a><span>|</span><a href="#42124008">next</a><span>|</span><label class="collapse" for="c-42122649">[-]</label><label class="expand" for="c-42122649">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154</a> has some discussion about all the possibilities. It&#x27;s pretty subtle, but I think everyone agrees that the current behavior of if let is unintuitive. Beyond that there are a bunch of possibilities none of which is clearly superior.</div><br/><div id="42122845" class="c"><input type="checkbox" id="c-42122845" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42121782">root</a><span>|</span><a href="#42122649">parent</a><span>|</span><a href="#42124008">next</a><span>|</span><label class="collapse" for="c-42122845">[-]</label><label class="expand" for="c-42122845">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154#issuecomment-2444591506">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154#issuecomment...</a> Especially this matrix was helpful! The behaviour that&#x27;s going to be adopted in Rust 2024 is the Rust2024.1 one. They were having doubts about the rules becoming too complex&#x2F;non-uniform, but at least dropping early means compiler errors rather than deadlocks.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42124008" class="c"><input type="checkbox" id="c-42124008" checked=""/><div class="controls bullet"><span class="by">peterkelly</span><span>|</span><a href="#42121782">prev</a><span>|</span><a href="#42122173">next</a><span>|</span><label class="collapse" for="c-42124008">[-]</label><label class="expand" for="c-42124008">[1 more]</label></div><br/><div class="children"><div class="content">One way to solve this at the language level would be to require that each lock has a specified priority associated with it, and have the compiler enforce a constraint that locks can only be obtained in the order of their priority.<p>For each statement, the compiler could keep track of the current &quot;lock priority&quot;. If an attempt is made to obtain a new lock with a lower or equal priority, the compiler would reject this. Otherwise, the compiler would use the priority of the new lock as the lock priority for all statements within the scope of the block in which that lock is held.<p>Aside from modifying the language, the same basic idea could be implemented at the library level by exposing a lock type which still requires a priority to be specified at creation time, but tracks the current lock priority (per thread) at runtime and panics when the constraint is violated. Since the panics would be deterministic, they and the book-keeping required to track the current lock priority could be enabled only in debug mode.</div><br/></div></div><div id="42122173" class="c"><input type="checkbox" id="c-42122173" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42124008">prev</a><span>|</span><a href="#42121943">next</a><span>|</span><label class="collapse" for="c-42122173">[-]</label><label class="expand" for="c-42122173">[8 more]</label></div><br/><div class="children"><div class="content">A lock taken in the conditional test term <i>should</i> lock for the duration of the if-clause. If you release the lock early, you add the risk of a race condition, where some other thread executes between the test and the execution of the if or else clause, changing the state.</div><br/><div id="42123897" class="c"><input type="checkbox" id="c-42123897" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42122173">parent</a><span>|</span><a href="#42122662">next</a><span>|</span><label class="collapse" for="c-42123897">[-]</label><label class="expand" for="c-42123897">[1 more]</label></div><br/><div class="children"><div class="content">Right.  But the problem is that with an &#x27;if let&#x27;, it <i>also</i> locks for the &#x27;else&#x27;, which is not intuitive or expected.<p>The problem is that the syntax of &#x27;if let&#x27; makes the programmer assume a particular scoping, but its desugaring implies something else.</div><br/></div></div><div id="42122662" class="c"><input type="checkbox" id="c-42122662" checked=""/><div class="controls bullet"><span class="by">reitzensteinm</span><span>|</span><a href="#42122173">parent</a><span>|</span><a href="#42123897">prev</a><span>|</span><a href="#42122303">next</a><span>|</span><label class="collapse" for="c-42122662">[-]</label><label class="expand" for="c-42122662">[1 more]</label></div><br/><div class="children"><div class="content">Right - if the pattern in the referenced blog post is used to implement lazy init, racing threads can double initialize.<p>But it&#x27;s not possible to upgrade a read to write lock as racing threads can cause a deadlock, and upgradable RwLock variants don&#x27;t hand out multiple upgradable read locks.<p>To maintain concurrent access, the referenced code must recheck the data once a write lock is granted, to gracefully handle TOCTOU.<p>(I know you were making a general point, I&#x27;m just fleshing out this specific example)</div><br/></div></div><div id="42122303" class="c"><input type="checkbox" id="c-42122303" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42122173">parent</a><span>|</span><a href="#42122662">prev</a><span>|</span><a href="#42122928">next</a><span>|</span><label class="collapse" for="c-42122303">[-]</label><label class="expand" for="c-42122303">[4 more]</label></div><br/><div class="children"><div class="content">But in Rust, the lock protects the contents inside it and lends the contents only for the lifetime the lock is being held, so if one tries to modify the contents when the lock is already released, you are going to get a compiler error, not a race condition.</div><br/><div id="42122522" class="c"><input type="checkbox" id="c-42122522" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#42122173">root</a><span>|</span><a href="#42122303">parent</a><span>|</span><a href="#42122928">next</a><span>|</span><label class="collapse" for="c-42122522">[-]</label><label class="expand" for="c-42122522">[3 more]</label></div><br/><div class="children"><div class="content">Parent was referring to a time of check to time of use bug. This kind of problem occurs every time you need to  release and reacquire a lock between the point of decision and the point where the data is modified. The decision on which the modification is based may have been invalidated by another thread while the lock was released.</div><br/><div id="42123073" class="c"><input type="checkbox" id="c-42123073" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42122173">root</a><span>|</span><a href="#42122522">parent</a><span>|</span><a href="#42122676">next</a><span>|</span><label class="collapse" for="c-42123073">[-]</label><label class="expand" for="c-42123073">[1 more]</label></div><br/><div class="children"><div class="content">Right. I could have been clearer.<p>There are two errors to avoid here:<p>- Read lock, read some data, unlock, relock for writing, act on data read during previous locked period. That&#x27;s a time of check&#x2F;time of use error.<p>- Acquire a read lock, then upgrade to a write lock. MutexLock does not let you do that. If you do that from two threads, you can deadlock. You can do that in SQL, but SQL can back out a transaction that deadlocks.<p>This is not a problem with Rust. Rust prevented the author from shooting themself in the foot.</div><br/></div></div><div id="42122676" class="c"><input type="checkbox" id="c-42122676" checked=""/><div class="controls bullet"><span class="by">GolDDranks</span><span>|</span><a href="#42122173">root</a><span>|</span><a href="#42122522">parent</a><span>|</span><a href="#42123073">prev</a><span>|</span><a href="#42122928">next</a><span>|</span><label class="collapse" for="c-42122676">[-]</label><label class="expand" for="c-42122676">[1 more]</label></div><br/><div class="children"><div class="content">I was going to say &quot;d&#x27;oh, that&#x27;s locking 101&quot;, but the original article indeed does that kind of a thing with the else branch. They should have chosen a better example do demonstrate the point, but it&#x27;s hard to say if the current racy behaviour is even wrong because they didn&#x27;t have any real-life semantics&#x2F;use-case in the example...</div><br/></div></div></div></div></div></div><div id="42122928" class="c"><input type="checkbox" id="c-42122928" checked=""/><div class="controls bullet"><span class="by">colanderman</span><span>|</span><a href="#42122173">parent</a><span>|</span><a href="#42122303">prev</a><span>|</span><a href="#42121943">next</a><span>|</span><label class="collapse" for="c-42122928">[-]</label><label class="expand" for="c-42122928">[1 more]</label></div><br/><div class="children"><div class="content">This is true, but it&#x27;s <i>also</i> true that a lock ought only be held in the lexical scope of its guard&#x27;s let binding. That the scope of temporaries is extended outside the binding scope in this one case is surprising.<p>In a review I&#x27;d flag code which depended on this behavior -- it&#x27;s much clearer instead to simply take the lock outside the if statement.</div><br/></div></div></div></div><div id="42121943" class="c"><input type="checkbox" id="c-42121943" checked=""/><div class="controls bullet"><span class="by">senorrib</span><span>|</span><a href="#42122173">prev</a><span>|</span><a href="#42121666">next</a><span>|</span><label class="collapse" for="c-42121943">[-]</label><label class="expand" for="c-42121943">[6 more]</label></div><br/><div class="children"><div class="content">Is there any explicit reason as to why RWLock can’t simply try to upgrade the read-lock to write-lock given they’re both being held by the same thread?</div><br/><div id="42122034" class="c"><input type="checkbox" id="c-42122034" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#42121943">parent</a><span>|</span><a href="#42122040">next</a><span>|</span><label class="collapse" for="c-42122034">[-]</label><label class="expand" for="c-42122034">[4 more]</label></div><br/><div class="children"><div class="content">Yes, allowing this to execute would be very unsound:<p><pre><code>    let lock = RwLock::new(Box::new(111));
    let r: &amp;i32 = &amp;**lock.read().unwrap(); &#x2F;&#x2F; points to 111
    *lock.write().unwrap() = Box::new(222); &#x2F;&#x2F; allocates a new Box and deallocates 111
    println!(&quot;{}&quot;, *r); &#x2F;&#x2F; use after free</code></pre></div><br/><div id="42122206" class="c"><input type="checkbox" id="c-42122206" checked=""/><div class="controls bullet"><span class="by">NobodyNada</span><span>|</span><a href="#42121943">root</a><span>|</span><a href="#42122034">parent</a><span>|</span><a href="#42122040">next</a><span>|</span><label class="collapse" for="c-42122206">[-]</label><label class="expand" for="c-42122206">[3 more]</label></div><br/><div class="children"><div class="content">It can be done safely with an upgrade method that requires an owned read guard. The RwLock implementation provided by the parking_lot crate supports this safely:<p><pre><code>    let lock = RwLock::new(Box::new(111));
    let read = lock.upgradable_read();
    let r: &amp;i32 = &amp;**read; &#x2F;&#x2F; points to 111
    *RwLockUpgradableReadGuard::upgrade(read) = Box::new(222); &#x2F;&#x2F; error[E0505]: cannot move out of `read` because it is borrowed
    println!(&quot;{}&quot;, *r);</code></pre></div><br/><div id="42123915" class="c"><input type="checkbox" id="c-42123915" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42121943">root</a><span>|</span><a href="#42122206">parent</a><span>|</span><a href="#42122273">next</a><span>|</span><label class="collapse" for="c-42123915">[-]</label><label class="expand" for="c-42123915">[1 more]</label></div><br/><div class="children"><div class="content">The problem is that in the &#x27;if let&#x27; case, the &#x27;else&#x27; block has no access to the read guard.  It&#x27;s out of scope, except that the compiler hasn&#x27;t dropped it yet.</div><br/></div></div><div id="42122273" class="c"><input type="checkbox" id="c-42122273" checked=""/><div class="controls bullet"><span class="by">anderskaseorg</span><span>|</span><a href="#42121943">root</a><span>|</span><a href="#42122206">parent</a><span>|</span><a href="#42123915">prev</a><span>|</span><a href="#42122040">next</a><span>|</span><label class="collapse" for="c-42122273">[-]</label><label class="expand" for="c-42122273">[1 more]</label></div><br/><div class="children"><div class="content">Of course (but that’s not relevant to the original scenario, where the programmer is hypothetically not aware that the read lock is still being held, let alone that they could manually upgrade it after changing to a different lock library).</div><br/></div></div></div></div></div></div><div id="42122040" class="c"><input type="checkbox" id="c-42122040" checked=""/><div class="controls bullet"><span class="by">webkike</span><span>|</span><a href="#42121943">parent</a><span>|</span><a href="#42122034">prev</a><span>|</span><a href="#42121666">next</a><span>|</span><label class="collapse" for="c-42122040">[-]</label><label class="expand" for="c-42122040">[1 more]</label></div><br/><div class="children"><div class="content">Would be much more expensive to implement. RwLocks are basically Atomics wrapping a pointer and have no knowledge of who has acquired the lock</div><br/></div></div></div></div><div id="42121666" class="c"><input type="checkbox" id="c-42121666" checked=""/><div class="controls bullet"><span class="by">Sytten</span><span>|</span><a href="#42121943">prev</a><span>|</span><a href="#42122118">next</a><span>|</span><label class="collapse" for="c-42121666">[-]</label><label class="expand" for="c-42121666">[5 more]</label></div><br/><div class="children"><div class="content">Happy to be corrected, but from what I gathered RWLock should mostly be avoided in favour of a simple Mutex unless you have a very read-heavy usecase and even then the performances are subpar compared to mutex.</div><br/><div id="42121757" class="c"><input type="checkbox" id="c-42121757" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42121666">parent</a><span>|</span><a href="#42121740">next</a><span>|</span><label class="collapse" for="c-42121757">[-]</label><label class="expand" for="c-42121757">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you, but the problem the article is talking about is unexpected lifetime with `if let` which is not just limited to RwLock.</div><br/></div></div><div id="42121740" class="c"><input type="checkbox" id="c-42121740" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#42121666">parent</a><span>|</span><a href="#42121757">prev</a><span>|</span><a href="#42122333">next</a><span>|</span><label class="collapse" for="c-42121740">[-]</label><label class="expand" for="c-42121740">[1 more]</label></div><br/><div class="children"><div class="content">maybe but that is unrelated to the distilled problem shown in the blog and RWLocks are not the only way this can bite you<p>but it&#x27;s also behavior for rust match-like statements in general so nothing new nor specific to if let</div><br/></div></div><div id="42122333" class="c"><input type="checkbox" id="c-42122333" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42121666">parent</a><span>|</span><a href="#42121740">prev</a><span>|</span><a href="#42121909">next</a><span>|</span><label class="collapse" for="c-42122333">[-]</label><label class="expand" for="c-42122333">[1 more]</label></div><br/><div class="children"><div class="content">The weirdest part about rwlock (not rust-specific) is when you end up using it in a case where the writes are the shared case and the reads are the exclusive case.</div><br/></div></div><div id="42121909" class="c"><input type="checkbox" id="c-42121909" checked=""/><div class="controls bullet"><span class="by">roland35</span><span>|</span><a href="#42121666">parent</a><span>|</span><a href="#42122333">prev</a><span>|</span><a href="#42122118">next</a><span>|</span><label class="collapse" for="c-42121909">[-]</label><label class="expand" for="c-42121909">[1 more]</label></div><br/><div class="children"><div class="content">I like to use rwlock on my code which reads once every few hours... Maybe I should change that!</div><br/></div></div></div></div><div id="42122118" class="c"><input type="checkbox" id="c-42122118" checked=""/><div class="controls bullet"><span class="by">Kab1r</span><span>|</span><a href="#42121666">prev</a><span>|</span><a href="#42121592">next</a><span>|</span><label class="collapse" for="c-42122118">[-]</label><label class="expand" for="c-42122118">[4 more]</label></div><br/><div class="children"><div class="content">I would call this a compiler bug</div><br/><div id="42123232" class="c"><input type="checkbox" id="c-42123232" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#42122118">parent</a><span>|</span><a href="#42121592">next</a><span>|</span><label class="collapse" for="c-42123232">[-]</label><label class="expand" for="c-42123232">[3 more]</label></div><br/><div class="children"><div class="content">It’s getting fixed soon - <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;124085">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;124085</a></div><br/><div id="42123522" class="c"><input type="checkbox" id="c-42123522" checked=""/><div class="controls bullet"><span class="by">Kab1r</span><span>|</span><a href="#42122118">root</a><span>|</span><a href="#42123232">parent</a><span>|</span><a href="#42121592">next</a><span>|</span><label class="collapse" for="c-42123522">[-]</label><label class="expand" for="c-42123522">[2 more]</label></div><br/><div class="children"><div class="content">If the change is targeting a rust edition it&#x27;s being treated as a feature&#x2F;improvement not as a compiler bug. If there isn&#x27;t a spec that explicitly says that this is expected behavior (and as far as I know there isn&#x27;t a concrete spec for the rust language) it should be instead treated as a backwards compatible bug fix</div><br/><div id="42123925" class="c"><input type="checkbox" id="c-42123925" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42122118">root</a><span>|</span><a href="#42123522">parent</a><span>|</span><a href="#42121592">next</a><span>|</span><label class="collapse" for="c-42123925">[-]</label><label class="expand" for="c-42123925">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s being treated as a breaking change, which it is.  It is not a backwards-compatible bug fix.<p>You are correct that there is no concrete spec for the Rust language; the current state of the compiler and stdlib is the &quot;spec&quot;.  So this is a breaking change to the &quot;spec&quot;, and requires a new edition.</div><br/></div></div></div></div></div></div></div></div><div id="42121592" class="c"><input type="checkbox" id="c-42121592" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#42122118">prev</a><span>|</span><label class="collapse" for="c-42121592">[-]</label><label class="expand" for="c-42121592">[32 more]</label></div><br/><div class="children"><div class="content">This is why pthread_mutex_lock() and pthread_mutex_unlock() will always be kings - it is clear when things are locked and when they are unlocked. Nobody needs to write articles warning you about pthread_mutex being taken randomly by syntactic sugar and not released till a magic later time due to the same sugar. Ditto for RWlock&#x2F;XYZloc&#x2F;ABClock&#x2F;etc...</div><br/><div id="42121789" class="c"><input type="checkbox" id="c-42121789" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42123940">next</a><span>|</span><label class="collapse" for="c-42121789">[-]</label><label class="expand" for="c-42121789">[6 more]</label></div><br/><div class="children"><div class="content">I think mutexes that own their data are genuinely much easier to reason about than mutexes that don&#x27;t.<p>In this case this is a Rust bug that will be fixed in the next edition: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;124085">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;124085</a></div><br/><div id="42122963" class="c"><input type="checkbox" id="c-42122963" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121789">parent</a><span>|</span><a href="#42123940">next</a><span>|</span><label class="collapse" for="c-42122963">[-]</label><label class="expand" for="c-42122963">[5 more]</label></div><br/><div class="children"><div class="content">That&#x27;s arguably true, but only insofar as it makes sense to talk about a mutex &quot;owning&quot; &quot;data&quot;.  There are many kinds of data that can&#x27;t be owned by the language runtime like this (think about async&#x2F;shared&#x2F;DMA buffers, register blocks on foreign hardware, memory-mapped database files), but that still clearly need synchronization.  Even things like coarse-grained locks taken at the subsystem level (e.g. to avoid having a separate atomic in every little object) are a bad fit for this kind of API.<p>There&#x27;s value to being opinionated about API design, but there&#x27;s also cost.  And Rust is supposed to be playing in the same sandbox as the lower level tools.</div><br/><div id="42123218" class="c"><input type="checkbox" id="c-42123218" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42122963">parent</a><span>|</span><a href="#42123319">next</a><span>|</span><label class="collapse" for="c-42123218">[-]</label><label class="expand" for="c-42123218">[1 more]</label></div><br/><div class="children"><div class="content">Here’s what I understand from your comment, correct me if I’m wrong. You’re saying there is a runtime cost associated with a mutex&#x2F;rwlock owning the data. And secondly, you think it isn’t possible to implement this pattern in other areas that need locking.<p>I don’t think either of those is true. Encoding the ownership in the type system makes things clearer, imposes a <i>compile-time</i> cost but not <i>run-time</i> cost. Also, there isn’t any magic in the stdlib implementation of Mutex and Rwlock other than implementing it natively for every OS. This means that it is possible to implement the pattern for the examples you gave.</div><br/></div></div><div id="42123319" class="c"><input type="checkbox" id="c-42123319" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42122963">parent</a><span>|</span><a href="#42123218">prev</a><span>|</span><a href="#42123247">next</a><span>|</span><label class="collapse" for="c-42123319">[-]</label><label class="expand" for="c-42123319">[2 more]</label></div><br/><div class="children"><div class="content">That is true, but I don&#x27;t believe Rust imposes a cost here. The worst case degrades to a `Mutex&lt;()&gt;` and then whatever&#x27;s being guarded being managed separately.</div><br/><div id="42123855" class="c"><input type="checkbox" id="c-42123855" checked=""/><div class="controls bullet"><span class="by">simonask</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42123319">parent</a><span>|</span><a href="#42123247">next</a><span>|</span><label class="collapse" for="c-42123855">[-]</label><label class="expand" for="c-42123855">[1 more]</label></div><br/><div class="children"><div class="content">From an API design point of view, I would always encapsulate the logically mutable state in some type `Foo`, even if it doesn&#x27;t literally own the memory, and then expose a safe API using `Mutex&lt;Foo&gt;`.<p>Idiomatically, you would then make `Foo::new_unchecked()` unsafe, with the precondition that nobody else is accessing the same external resource, and that `Foo::new_unchecked()` is only ever called once.</div><br/></div></div></div></div><div id="42123247" class="c"><input type="checkbox" id="c-42123247" checked=""/><div class="controls bullet"><span class="by">zacmps</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42122963">parent</a><span>|</span><a href="#42123319">prev</a><span>|</span><a href="#42123940">next</a><span>|</span><label class="collapse" for="c-42123247">[-]</label><label class="expand" for="c-42123247">[1 more]</label></div><br/><div class="children"><div class="content">You can also use a mutex that doesn&#x27;t own data in Rust if you need to.</div><br/></div></div></div></div></div></div><div id="42123940" class="c"><input type="checkbox" id="c-42123940" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42121789">prev</a><span>|</span><a href="#42121720">next</a><span>|</span><label class="collapse" for="c-42123940">[-]</label><label class="expand" for="c-42123940">[3 more]</label></div><br/><div class="children"><div class="content">No thanks; it&#x27;s so so so easy to forget to unlock a mutex; I&#x27;d rather the language and stdlib just make it impossible for me to do so.<p>Ultimately this isn&#x27;t really a problem with how Rust&#x27;s Mutex&#x2F;RwLock&#x2F;etc. works, it&#x27;s just a poor choice with how the lifetime of the lock guard is figured in the &#x27;if let&#x27; case.  This poor choice will be fixed in the 2024 Rust edition, and this problem will go away.</div><br/><div id="42124095" class="c"><input type="checkbox" id="c-42124095" checked=""/><div class="controls bullet"><span class="by">nikki93</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42123940">parent</a><span>|</span><a href="#42124163">next</a><span>|</span><label class="collapse" for="c-42124095">[-]</label><label class="expand" for="c-42124095">[1 more]</label></div><br/><div class="children"><div class="content">I think a &#x27;linear types&#x27; ish model where the compiler flags an error if you didn&#x27;t write the explicit unlock call, and only compiles if some acceptable unlock call (or set of calls) is added, would be a good design. It can &#x2F; would also prevent use-after-consume. I do want the static checks, but I don&#x27;t think that means that implicit function calls need to be generated on a } or a = (assigning to a variable causes a drop) etc. This is what Rust already does with `.clone()` -- needing the explicit call -- and I think it makes sense for a lot of cases of implicit drop. I have seen discussions about implementing this for Rust and I have it implemented in a C borrow checker experiment I&#x27;m trying. ATS is also an example of this, and going further is something like Frama-C or seL4 and so on.<p>The main point being: the implicitness is not necessary for &quot;compiler makes sure you don&#x27;t forget&quot;. So the original comment about how usage of the explicitly named and paired APIs can clarify intent both for the writer and reader can still stand while not implying that forgetting is involved. I see this dichotomy often being drawn and I think it&#x27;s important to consider the language design space more granularly.<p>(the explicit calls also let you &quot;go to defintion&quot; on the editor to see their code, learn what to look up in a manual, see reasonable function names in stack traces and profiles, pass arguments to the drop call, let the drop call have return &#x2F; error values you can do something about (consider `fclose`), let the drop call be async, ...)</div><br/></div></div><div id="42124163" class="c"><input type="checkbox" id="c-42124163" checked=""/><div class="controls bullet"><span class="by">tucnak</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42123940">parent</a><span>|</span><a href="#42124095">prev</a><span>|</span><a href="#42121720">next</a><span>|</span><label class="collapse" for="c-42124163">[-]</label><label class="expand" for="c-42124163">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;gaultier.github.io&#x2F;blog&#x2F;perhaps_rust_needs_defer.html" rel="nofollow">https:&#x2F;&#x2F;gaultier.github.io&#x2F;blog&#x2F;perhaps_rust_needs_defer.htm...</a></div><br/></div></div></div></div><div id="42121720" class="c"><input type="checkbox" id="c-42121720" checked=""/><div class="controls bullet"><span class="by">CJefferson</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42123940">prev</a><span>|</span><a href="#42121703">next</a><span>|</span><label class="collapse" for="c-42121720">[-]</label><label class="expand" for="c-42121720">[5 more]</label></div><br/><div class="children"><div class="content">There are however many PRs about people ignoring the return values of pthread_mutex_lock(), or missing an unlock on one route through a function.</div><br/><div id="42121748" class="c"><input type="checkbox" id="c-42121748" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121720">parent</a><span>|</span><a href="#42121703">next</a><span>|</span><label class="collapse" for="c-42121748">[-]</label><label class="expand" for="c-42121748">[4 more]</label></div><br/><div class="children"><div class="content">and nothing prevents you from explicitly dropping lock guards in rust either<p>actually it&#x27;s a common pattern in complicated multi threaded code or similar to require that</div><br/><div id="42121801" class="c"><input type="checkbox" id="c-42121801" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121748">parent</a><span>|</span><a href="#42123286">next</a><span>|</span><label class="collapse" for="c-42121801">[-]</label><label class="expand" for="c-42121801">[1 more]</label></div><br/><div class="children"><div class="content">Dropping a lock guard in rust requires you to have already dropped the borrow — the shared memory under lock is only accessible through the guard, and you can’t drop an object if you have a reference to it. This is not true in C, where you can reference the shared memory after the lock is released.</div><br/></div></div><div id="42123286" class="c"><input type="checkbox" id="c-42123286" checked=""/><div class="controls bullet"><span class="by">lodovic</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121748">parent</a><span>|</span><a href="#42121801">prev</a><span>|</span><a href="#42123954">next</a><span>|</span><label class="collapse" for="c-42123286">[-]</label><label class="expand" for="c-42123286">[1 more]</label></div><br/><div class="children"><div class="content">The rust compiler (or the rust-analyzer) directs developers to use mutexes or other guards, even in single-threaded code when the use case wouldn&#x27;t strictly require it. Where we would get undefined behavior in C, we get deadlocks in rust. This forces developers to handle these cases, but this can be quite painful to implement, especially in embedded or no_std environments.</div><br/></div></div><div id="42123954" class="c"><input type="checkbox" id="c-42123954" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121748">parent</a><span>|</span><a href="#42123286">prev</a><span>|</span><a href="#42121703">next</a><span>|</span><label class="collapse" for="c-42123954">[-]</label><label class="expand" for="c-42123954">[1 more]</label></div><br/><div class="children"><div class="content">So what?  If you drop the lock guard, you get a straightforward compiler error if you later try to access the data in it.  You don&#x27;t get a runtime bug that you have to track down like you get if you forget a pthread_mutex_unlock().</div><br/></div></div></div></div></div></div><div id="42121703" class="c"><input type="checkbox" id="c-42121703" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42121720">prev</a><span>|</span><a href="#42121889">next</a><span>|</span><label class="collapse" for="c-42121703">[-]</label><label class="expand" for="c-42121703">[1 more]</label></div><br/><div class="children"><div class="content">In rust, this is y=x.lock(), and later drop(y) or just end the scope block.<p>Sugary syntax is always an issue when side effects matter.<p>Having said that, I adore procedural code in general, but it does make ownership a fun mental exercise.</div><br/></div></div><div id="42121889" class="c"><input type="checkbox" id="c-42121889" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42121703">prev</a><span>|</span><a href="#42121651">next</a><span>|</span><label class="collapse" for="c-42121889">[-]</label><label class="expand" for="c-42121889">[6 more]</label></div><br/><div class="children"><div class="content">This really reads like satire but feels like the author is actually being sincere. I’ve seen so many deadlocks happening due to pthread mutexes. Certainly way more than this syntactic corner case. It’s so common in fact that I saw a codebase that made their mutexes recursive to avoid having to think about it.</div><br/><div id="42121923" class="c"><input type="checkbox" id="c-42121923" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121889">parent</a><span>|</span><a href="#42121651">next</a><span>|</span><label class="collapse" for="c-42121923">[-]</label><label class="expand" for="c-42121923">[5 more]</label></div><br/><div class="children"><div class="content">Recursive mutexes are usually a sign of bad design. Design better. Deadlocks are a sign of bad developers. Hire better.</div><br/><div id="42123970" class="c"><input type="checkbox" id="c-42123970" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121923">parent</a><span>|</span><a href="#42122351">next</a><span>|</span><label class="collapse" for="c-42123970">[-]</label><label class="expand" for="c-42123970">[1 more]</label></div><br/><div class="children"><div class="content">Deadlocks are a sign of normal humans getting tripped up by crappy abstractions.<p>If you&#x27;re going to claim you&#x27;ve never written a deadlock in your life, well... I&#x27;m not sure I&#x27;d believe that.</div><br/></div></div><div id="42122351" class="c"><input type="checkbox" id="c-42122351" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42110846">parent</a><span>|</span><a href="#42123970">prev</a><span>|</span><a href="#42122013">next</a><span>|</span><label class="collapse" for="c-42122351">[-]</label><label class="expand" for="c-42122351">[1 more]</label></div><br/><div class="children"><div class="content">Ideally alcohol would also be banned. Obviously that doesn’t work because of enforcement challenges so we shouldn’t ban gambling either. But that doesn’t mean we need to make it super easy.</div><br/></div></div><div id="42122013" class="c"><input type="checkbox" id="c-42122013" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121923">parent</a><span>|</span><a href="#42122351">prev</a><span>|</span><a href="#42122357">next</a><span>|</span><label class="collapse" for="c-42122013">[-]</label><label class="expand" for="c-42122013">[1 more]</label></div><br/><div class="children"><div class="content">Who hurt you?</div><br/></div></div><div id="42122357" class="c"><input type="checkbox" id="c-42122357" checked=""/><div class="controls bullet"><span class="by">techbrovanguard</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121923">parent</a><span>|</span><a href="#42122013">prev</a><span>|</span><a href="#42121651">next</a><span>|</span><label class="collapse" for="c-42122357">[-]</label><label class="expand" for="c-42122357">[1 more]</label></div><br/><div class="children"><div class="content">this is pretty obvious bait</div><br/></div></div></div></div></div></div><div id="42121929" class="c"><input type="checkbox" id="c-42121929" checked=""/><div class="controls bullet"><span class="by">echelon</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42121651">prev</a><span>|</span><a href="#42121616">next</a><span>|</span><label class="collapse" for="c-42121929">[-]</label><label class="expand" for="c-42121929">[1 more]</label></div><br/><div class="children"><div class="content">No way. The compiler doesn&#x27;t help you.<p>Plus you&#x27;re working in a memory unsafe, concurrency unsafe language.</div><br/></div></div><div id="42121616" class="c"><input type="checkbox" id="c-42121616" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42121592">parent</a><span>|</span><a href="#42121929">prev</a><span>|</span><label class="collapse" for="c-42121616">[-]</label><label class="expand" for="c-42121616">[8 more]</label></div><br/><div class="children"><div class="content">I see it as a consequence of Rust being too liberal with additions to the language.  It&#x27;s hard to maintain some of these guarantees in the presence of certain syntactic forms.  This happens in all languages.<p>It is a little hilarious to see a rustaceon write:<p>&gt; and you can sus out if a program is going to cause a deadlock by just making sure you aren&#x27;t acquiring multiple simultaneous locks.<p>Ah..  not a problem!  You just have to not ever have the problem.  Then,  of course at the opposite end of the article:<p>&gt; I wrote this block because this has specifically bitten different Rust crates in the wasmCloud project multiple times<p>:D</div><br/><div id="42121724" class="c"><input type="checkbox" id="c-42121724" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121616">parent</a><span>|</span><a href="#42121671">next</a><span>|</span><label class="collapse" for="c-42121724">[-]</label><label class="expand" for="c-42121724">[6 more]</label></div><br/><div class="children"><div class="content">The issue here isn&#x27;t new features at all.<p>`if let` is more or less syntax sugar for `match`.<p>And match behaves like that, too and has been in rust since 1.0.<p>That match did behaves like that is due to some old, you could say legacy, reasons and had been criticized even in the early rust 1.x days.<p>But changing a behavior which subtle change when locks are released is not something you can easily fix with a rust edition so we are pretty much stuck with it.</div><br/><div id="42121788" class="c"><input type="checkbox" id="c-42121788" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121724">parent</a><span>|</span><a href="#42121940">next</a><span>|</span><label class="collapse" for="c-42121788">[-]</label><label class="expand" for="c-42121788">[2 more]</label></div><br/><div class="children"><div class="content">Funny you say that: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;131154</a><p>Looks like this is getting fixed in Rust 2024 :)</div><br/><div id="42121976" class="c"><input type="checkbox" id="c-42121976" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121788">parent</a><span>|</span><a href="#42121940">next</a><span>|</span><label class="collapse" for="c-42121976">[-]</label><label class="expand" for="c-42121976">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t been supper up to date with changes to rust-lang recently (I had seen that they are stabilizing if_let_rescope but didn&#x27;t look into what it is, to much to do at work).<p>Through making if-let less syntax sugar for changing a implicit behavior people most likely didn&#x27;t rely on but have problems with seems like a very good idea<p>My comment about this being hard to change was mainly about match. Not considering the option of making if-let less syntax sugary.<p>And in difference to if-let, for match people do (or at least did years ago in production code) rely on it.</div><br/></div></div></div></div><div id="42121940" class="c"><input type="checkbox" id="c-42121940" checked=""/><div class="controls bullet"><span class="by">dathinab</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121724">parent</a><span>|</span><a href="#42121788">prev</a><span>|</span><a href="#42121835">next</a><span>|</span><label class="collapse" for="c-42121940">[-]</label><label class="expand" for="c-42121940">[1 more]</label></div><br/><div class="children"><div class="content">To elaborate a bit more this is a consequence of a overlapping of two design decisions:<p>1) temporaries being added &quot;alongside&quot; the item they appear in. This makes a tone of thing much much simpler, but comes back to bites us here.<p>2) &quot;alongside&quot; for match statement meaning alongside the whole statement (but for `if &lt;cond&gt; {` it&#x27;s alongside the condition)<p>3) things being always dropped at the very end of the scope if not moved out from it earlier, which again makes things easier to understand in most cases.<p>both had been discussed a bunch around 1.0&#x2F;early 1.x days and both are things which in most situations make it easier to write rust code (and for beginners potentially much easier)<p>but both have also drawbacks<p>like the not-that-common example in this blog<p>or e.g. in async where rust has to keep any values which impl Drop around across async await calls as it can&#x27;t know if there is a side effect in Drop<p>In the past I personally had been a contender of allowing the compiler to drop value anywhere between the last time they have been referenced and the end of the scopes without any rules or stability about where exactly (i.e. if you need a guard to be kept around you need to be explicit about it).<p>But working more together with people of very varying skill levels in the last 5&#x2F;6 years made me change my mind and agree that that would have been a terrible idea.<p>And having rules about guaranteed drops as early as possible seem initially easy but aren&#x27;t due to things like conditional moves, partial moves etc. I.e. it would still be quite a bit more complicated to teach it.<p>Furthermore in both alternatives to 3) you likely still wouldn&#x27;t (guaranteed) drop the guard temporary in the other match branch before you requesting the new guard as guaranteeing compiler behavior like that means having a lot of additional edges in many partial move scenarios and potentially even a bunch of additional branch. In both cases it would likely increase code size and mess with the branch predictor and I-caches and be generally just not good (but it would help with async await boundaries).</div><br/></div></div><div id="42121835" class="c"><input type="checkbox" id="c-42121835" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121724">parent</a><span>|</span><a href="#42121940">prev</a><span>|</span><a href="#42121671">next</a><span>|</span><label class="collapse" for="c-42121835">[-]</label><label class="expand" for="c-42121835">[2 more]</label></div><br/><div class="children"><div class="content">&gt; `if let` is more or less syntax sugar for `match`.<p>Which are new features for systems languages that otherwise rely on RAII for locking.  So it&#x27;s in the class of &quot;original sin.&quot;<p>&gt; so we are pretty much stuck with it.<p>You could refuse to compile it under some set of flags.  Isn&#x27;t that the basic value premise of the language here?</div><br/><div id="42121873" class="c"><input type="checkbox" id="c-42121873" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42121592">root</a><span>|</span><a href="#42121835">parent</a><span>|</span><a href="#42121671">next</a><span>|</span><label class="collapse" for="c-42121873">[-]</label><label class="expand" for="c-42121873">[1 more]</label></div><br/><div class="children"><div class="content">It is true that Rust is the first major language with both pervasive, deterministic RAII and pattern matching. Kind of wild to be honest! A real marriage of systems and functional code.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>