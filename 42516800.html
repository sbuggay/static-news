<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1735290050552" as="style"/><link rel="stylesheet" href="styles.css?v=1735290050552"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.imperialviolet.org/tourofwebauthn/tourofwebauthn.html">A Tour of WebAuthn</a> <span class="domain">(<a href="https://www.imperialviolet.org">www.imperialviolet.org</a>)</span></div><div class="subtext"><span>caust1c</span> | <span>84 comments</span></div><br/><div><div id="42518893" class="c"><input type="checkbox" id="c-42518893" checked=""/><div class="controls bullet"><span class="by">arianvanp</span><span>|</span><a href="#42519221">next</a><span>|</span><label class="collapse" for="c-42518893">[-]</label><label class="expand" for="c-42518893">[3 more]</label></div><br/><div class="children"><div class="content">There are some hairy edge cases during registration that many get wrong. (At least GitHub and google  had this bug) that if create() returns but the passkey never reaches the server due to bad networking conditions that your password manager thinks it can log in but the server never recorded the passkey for the user. Basically there is no transactionality and you can get in a split brain situation where your password manager and your server don&#x27;t agree and it&#x27;s very confusing for end users.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;w3c&#x2F;webauthn&#x2F;issues&#x2F;2038">https:&#x2F;&#x2F;github.com&#x2F;w3c&#x2F;webauthn&#x2F;issues&#x2F;2038</a><p>They apparently came up with a fix for this using something called Signals API but I don&#x27;t think any browser implemented that yet.<p>Just wanted to highlight that this part of the UX is hairy and hard to get right</div><br/><div id="42519187" class="c"><input type="checkbox" id="c-42519187" checked=""/><div class="controls bullet"><span class="by">arnarbi</span><span>|</span><a href="#42518893">parent</a><span>|</span><a href="#42519221">next</a><span>|</span><label class="collapse" for="c-42519187">[-]</label><label class="expand" for="c-42519187">[2 more]</label></div><br/><div class="children"><div class="content">Chrome on desktop did: <a href="https:&#x2F;&#x2F;developer.chrome.com&#x2F;docs&#x2F;identity&#x2F;webauthn-signal-api" rel="nofollow">https:&#x2F;&#x2F;developer.chrome.com&#x2F;docs&#x2F;identity&#x2F;webauthn-signal-a...</a></div><br/><div id="42520343" class="c"><input type="checkbox" id="c-42520343" checked=""/><div class="controls bullet"><span class="by">jesseendahl</span><span>|</span><a href="#42518893">root</a><span>|</span><a href="#42519187">parent</a><span>|</span><a href="#42519221">next</a><span>|</span><label class="collapse" for="c-42520343">[-]</label><label class="expand" for="c-42520343">[1 more]</label></div><br/><div class="children"><div class="content">Nice seeing you here! :)</div><br/></div></div></div></div></div></div><div id="42519221" class="c"><input type="checkbox" id="c-42519221" checked=""/><div class="controls bullet"><span class="by">tgsovlerkhgsel</span><span>|</span><a href="#42518893">prev</a><span>|</span><a href="#42520116">next</a><span>|</span><label class="collapse" for="c-42519221">[-]</label><label class="expand" for="c-42519221">[6 more]</label></div><br/><div class="children"><div class="content">This is an excellent write-up that finally motivated me to try to understand the mess that was left behind as new standards kept being layered on top of each other.<p>Given the requirement for discoverable credentials and sync, truly open&#x2F;independent passkey implementations seem impossible&#x2F;impractical. For example, you couldn&#x27;t just have a set of Trezor-style devices that you load with the same seed and use that as your passkey without syncing the &quot;discoverable&quot; part of the credentials through some kind of cloud service. (The cloud service wouldn&#x27;t need to be trusted with the actual keys, but you couldn&#x27;t operate without it.)<p>As a result, it looks like you can essentially choose which ecosystem you want to lock yourself into...<p>With authenticatorAttachment, sites have been given a convenient foot-gun to make sure no single setup actually works for all sites, and with both the discoverable and non-discoverable credentials supported, inconsistency in the login flow for maximum confusion is guaranteed.<p>Add to it that this is like the 4th or 5th iteration of a standard in the field in about 10 years, and there&#x27;s endless opportunity to get locked out because providers migrated from one standard (or buggy implementation) to another, or start setting things up only for the 6th standard to obsolete what you had (again, potentially locking you out).<p>And then people are surprised that users stick with passwords.</div><br/><div id="42520651" class="c"><input type="checkbox" id="c-42520651" checked=""/><div class="controls bullet"><span class="by">raxxor</span><span>|</span><a href="#42519221">parent</a><span>|</span><a href="#42520004">next</a><span>|</span><label class="collapse" for="c-42520651">[-]</label><label class="expand" for="c-42520651">[2 more]</label></div><br/><div class="children"><div class="content">Even the closed-system solution pose problems. I think it didn&#x27;t get much airtime, but when Chrome switched their approach to save passwords, a lot of users lost access to their accounts. A case where a feature wasn&#x27;t sensibly discontinued.<p>The workaround now isn&#x27;t using passkeys, something few people understand. Instead most seem to be migrating to an external password managers. Honestly, I don&#x27;t have many arguments against this as these at least generate save passwords. There are many advantages to this approach.<p>I believe moving forward, sticking to passwords might indeed be more viable. I think explaining users to upload their public ssl key is safer and more universal at this point.</div><br/><div id="42520668" class="c"><input type="checkbox" id="c-42520668" checked=""/><div class="controls bullet"><span class="by">portaouflop</span><span>|</span><a href="#42519221">root</a><span>|</span><a href="#42520651">parent</a><span>|</span><a href="#42520004">next</a><span>|</span><label class="collapse" for="c-42520668">[-]</label><label class="expand" for="c-42520668">[1 more]</label></div><br/><div class="children"><div class="content">I use password as main auth method for everything (via a pw manager) - but then I often add passkey or similar for convenience. 
If I get locked out I still have the trad method as fallback; for me that’s the best of both worlds.<p>If you don’t offer password as method I will not use your service. 
The worst are those that only offer code via email&#x2F;sms or social login - miss me with that …</div><br/></div></div></div></div><div id="42520004" class="c"><input type="checkbox" id="c-42520004" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#42519221">parent</a><span>|</span><a href="#42520651">prev</a><span>|</span><a href="#42520477">next</a><span>|</span><label class="collapse" for="c-42520004">[-]</label><label class="expand" for="c-42520004">[1 more]</label></div><br/><div class="children"><div class="content">There is no technical requirement for discoverable credentials in most scenarios.<p>Sure, not having to type your username is nice, but I&#x27;ll gladly still do that if it allows &quot;passphrase-based paper-restore-able authenticators&quot; such as the one you describe. (I have one of these, in fact!)<p>Many services I use that do support WebAuthN allow either variant to be used (i.e. they&#x27;ll prefer discoverable credentials but will work just fine with non-discoverable ones), and arguably that should be how almost everybody ought to  implement it.<p>Unfortunately, at least as many other services completely botch it, e.g. by making discoverable credentials mandatory, by allowlisting browsers (e.g. Paypal), allowlisting authenticators (e.g. my government&#x27;s e-signature platform), or by using them in a functionally braindead way (e.g. Amazon, who for completely unfathomable reasons <i>still requires TOTP behind WebAuthn</i>, i.e. they replace the password with it, not the second factor).<p>So far I haven&#x27;t noticed a strong trend towards enforcing discoverable credentials, but let&#x27;s please name and shame everybody doing that. It&#x27;s completely unnecessary.</div><br/></div></div><div id="42520477" class="c"><input type="checkbox" id="c-42520477" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#42519221">parent</a><span>|</span><a href="#42520004">prev</a><span>|</span><a href="#42519984">next</a><span>|</span><label class="collapse" for="c-42520477">[-]</label><label class="expand" for="c-42520477">[1 more]</label></div><br/><div class="children"><div class="content"><i>And then people are surprised that users stick with passwords.</i><p>IMHO that and a TOTP seems to be a sweet spot.</div><br/></div></div></div></div><div id="42520116" class="c"><input type="checkbox" id="c-42520116" checked=""/><div class="controls bullet"><span class="by">Zamicol</span><span>|</span><a href="#42519221">prev</a><span>|</span><a href="#42517604">next</a><span>|</span><label class="collapse" for="c-42520116">[-]</label><label class="expand" for="c-42520116">[2 more]</label></div><br/><div class="children"><div class="content">WebAuthn and passkeys are a disaster.<p>Much of the specs were created behind closed doors and never done in a way where we could have had outside input. They&#x27;re completely corporate driven and designed to control users not empower them.</div><br/><div id="42520423" class="c"><input type="checkbox" id="c-42520423" checked=""/><div class="controls bullet"><span class="by">reddalo</span><span>|</span><a href="#42520116">parent</a><span>|</span><a href="#42517604">next</a><span>|</span><label class="collapse" for="c-42520423">[-]</label><label class="expand" for="c-42520423">[1 more]</label></div><br/><div class="children"><div class="content">I agree. I will not use them, not as a user, nor as a developer.</div><br/></div></div></div></div><div id="42517604" class="c"><input type="checkbox" id="c-42517604" checked=""/><div class="controls bullet"><span class="by">treve</span><span>|</span><a href="#42520116">prev</a><span>|</span><a href="#42518192">next</a><span>|</span><label class="collapse" for="c-42517604">[-]</label><label class="expand" for="c-42517604">[1 more]</label></div><br/><div class="children"><div class="content">Looks like an amazing resource for webauthn. Currently diving into this so it comes at a nice time for me.<p>But it&#x27;s also great advertising against WebAuthn. Hard to believe that this kind of complexity is needed, but as with OpenID Connect it feels like enterprise  interests are running the ship, not end-users. Ease of implementation seems like a non-goal.</div><br/></div></div><div id="42518192" class="c"><input type="checkbox" id="c-42518192" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#42517604">prev</a><span>|</span><a href="#42519412">next</a><span>|</span><label class="collapse" for="c-42518192">[-]</label><label class="expand" for="c-42518192">[4 more]</label></div><br/><div class="children"><div class="content">It interested me how quickly all of my auth methods started to include &quot;pick the right one of three presented numbers&quot; tests after TOTP got widespread. I&#x27;m guessing there is some replay method which they wanted to prevent? This is distinct from in protocol large random value challenges, it must be to ensure a Hooman, or very numerate dog is actually present.</div><br/><div id="42518587" class="c"><input type="checkbox" id="c-42518587" checked=""/><div class="controls bullet"><span class="by">g_p</span><span>|</span><a href="#42518192">parent</a><span>|</span><a href="#42519184">next</a><span>|</span><label class="collapse" for="c-42518587">[-]</label><label class="expand" for="c-42518587">[1 more]</label></div><br/><div class="children"><div class="content">TOTP codes are phishable and repayable in real-time - both via web (visiting the wrong site which asks for a TOTP and relays it within a few seconds), and via social engineering over the phone (give us one of the codes to prove it&#x27;s you and we can keep your account safe).<p>Adding number matching or similar helps ensure that the same user is initiating the session as is approving it - an issue when people discovered that Microsoft (among others) would do push messages to authenticate a login, and that users (if spammed late at night with constant requests), would often eventually hit allow to stop the notifications.</div><br/></div></div><div id="42519184" class="c"><input type="checkbox" id="c-42519184" checked=""/><div class="controls bullet"><span class="by">hirsin</span><span>|</span><a href="#42518192">parent</a><span>|</span><a href="#42518587">prev</a><span>|</span><a href="#42519412">next</a><span>|</span><label class="collapse" for="c-42519184">[-]</label><label class="expand" for="c-42519184">[2 more]</label></div><br/><div class="children"><div class="content">Pick the right number is not secure (enough), unfortunately - MFA exhaustion leads to users hitting one of three at random in an attempt to &quot;make the notifications stop&quot; (that are, naturally, being spammed by the attacker with a password but no mfa).<p>The attacker just has to spam them a few dozen times to get the victim to pick the right one at random and let the attacker in.<p>This is why it&#x27;s switched on good platforms to &quot;type in the number you see&quot;, which mitigated this.</div><br/><div id="42520018" class="c"><input type="checkbox" id="c-42520018" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#42518192">root</a><span>|</span><a href="#42519184">parent</a><span>|</span><a href="#42519412">next</a><span>|</span><label class="collapse" for="c-42520018">[-]</label><label class="expand" for="c-42520018">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s slightly better against people essentially accidentally letting attackers in, but still completely phishable by e.g. tech support scammers.<p>The big advantage of WebAuthN is that (at least for sane implementations, including all I&#x27;ve seen) there just is no way to enter an attacker-provided number and&#x2F;or supply a displayed code to an attacker.</div><br/></div></div></div></div></div></div><div id="42519412" class="c"><input type="checkbox" id="c-42519412" checked=""/><div class="controls bullet"><span class="by">zcdziura</span><span>|</span><a href="#42518192">prev</a><span>|</span><a href="#42517208">next</a><span>|</span><label class="collapse" for="c-42519412">[-]</label><label class="expand" for="c-42519412">[3 more]</label></div><br/><div class="children"><div class="content">Can anyone recommend a good dummy passkey provider to use when developing and testing RESTful authentication services that will rely on WebAuthn? Every example that I&#x27;ve seen online for interacting with a WebAuthn service assumes that you&#x27;re working within the context of the browser and can use the Navigator APIs.<p>I like to use regular ol&#x27; cURL when testing out API endpoints, and it would be great if there were some kind of dummy CLI program that I could use to generate the WebAuthn key agreements and materials.</div><br/><div id="42520048" class="c"><input type="checkbox" id="c-42520048" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#42519412">parent</a><span>|</span><a href="#42517208">next</a><span>|</span><label class="collapse" for="c-42520048">[-]</label><label class="expand" for="c-42520048">[2 more]</label></div><br/><div class="children"><div class="content">What exactly are you trying to test? Is there even a non-browser standard&#x2F;protocol for using WebAuthN (which is a web standard, after all)?</div><br/><div id="42520298" class="c"><input type="checkbox" id="c-42520298" checked=""/><div class="controls bullet"><span class="by">pabs3</span><span>|</span><a href="#42519412">root</a><span>|</span><a href="#42520048">parent</a><span>|</span><a href="#42517208">next</a><span>|</span><label class="collapse" for="c-42520298">[-]</label><label class="expand" for="c-42520298">[1 more]</label></div><br/><div class="children"><div class="content">There isn&#x27;t even a non-JavaScript way to use WebAuthn, let alone a non-browser way to use it. You could manually rewrite the JS for each site into curl calls or something I suppose.</div><br/></div></div></div></div></div></div><div id="42517208" class="c"><input type="checkbox" id="c-42517208" checked=""/><div class="controls bullet"><span class="by">xenophonf</span><span>|</span><a href="#42519412">prev</a><span>|</span><a href="#42518531">next</a><span>|</span><label class="collapse" for="c-42517208">[-]</label><label class="expand" for="c-42517208">[5 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always wanted to write a serverless OIDC provider&#x2F;SAML IdP but got stymied by the WebAuthn standards, which don&#x27;t seem to be written for normal people.  :(  But this e-book looks like it might have enough actual code interleaved with exposition to serve as more than just a high-level intro.</div><br/><div id="42517301" class="c"><input type="checkbox" id="c-42517301" checked=""/><div class="controls bullet"><span class="by">caust1c</span><span>|</span><a href="#42517208">parent</a><span>|</span><a href="#42520633">next</a><span>|</span><label class="collapse" for="c-42517301">[-]</label><label class="expand" for="c-42517301">[2 more]</label></div><br/><div class="children"><div class="content">Adam Langley is probably one of the most gifted teachers when it comes to explaining cryptography concepts.  Very clear, concise, precise, and makes it simple enough for me to follow without getting my neurons all knotted up.</div><br/><div id="42517323" class="c"><input type="checkbox" id="c-42517323" checked=""/><div class="controls bullet"><span class="by">jf</span><span>|</span><a href="#42517208">root</a><span>|</span><a href="#42517301">parent</a><span>|</span><a href="#42520633">next</a><span>|</span><label class="collapse" for="c-42517323">[-]</label><label class="expand" for="c-42517323">[1 more]</label></div><br/><div class="children"><div class="content">Agreed, I implemented TLS key pinning for a project at Okta using one of Adam&#x27;s blog posts</div><br/></div></div></div></div><div id="42520633" class="c"><input type="checkbox" id="c-42520633" checked=""/><div class="controls bullet"><span class="by">nmadden</span><span>|</span><a href="#42517208">parent</a><span>|</span><a href="#42517301">prev</a><span>|</span><a href="#42517939">next</a><span>|</span><label class="collapse" for="c-42520633">[-]</label><label class="expand" for="c-42520633">[1 more]</label></div><br/><div class="children"><div class="content">Yes, the WebAuthn spec is pretty unreadable. Every time I open it I feel like I’m lost in a maze of twisty hyperlinks, all alike.</div><br/></div></div><div id="42517939" class="c"><input type="checkbox" id="c-42517939" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#42517208">parent</a><span>|</span><a href="#42520633">prev</a><span>|</span><a href="#42518531">next</a><span>|</span><label class="collapse" for="c-42517939">[-]</label><label class="expand" for="c-42517939">[1 more]</label></div><br/><div class="children"><div class="content">OIDC providers are surprisingly NOT complicated! I created one to implement single sign-on with AWS, and it ended up being only around 200 lines of code in Go. All you need to do is create a JSON blob that is signed by a public key that is known to the consumer of the IDP.<p>I&#x27;ll need to do a write-up for it.</div><br/></div></div></div></div><div id="42518531" class="c"><input type="checkbox" id="c-42518531" checked=""/><div class="controls bullet"><span class="by">lapcat</span><span>|</span><a href="#42517208">prev</a><span>|</span><a href="#42517132">next</a><span>|</span><label class="collapse" for="c-42518531">[-]</label><label class="expand" for="c-42518531">[16 more]</label></div><br/><div class="children"><div class="content">&gt; A passkey is a synced, discoverable WebAuthn credential.<p>This is my fundamental problem with passkeys: I don&#x27;t want to use any syncing service.<p>To be clear, I don&#x27;t want to deprive other people of the ability to sync their credentials; I simply want to opt out myself. I just want to be able to manually back up and restore my credentials, like I&#x27;ve always done with passwords, but the passkey vendors seem to want to refuse to give anyone this ability. The vendors claim that this is to make phishing impossible, but I abhor paternalism in all forms, and also it&#x27;s suspicious that this paternalism forces people to use the syncing systems of the passkey vendors, which are usually paid subscriptions. So passkeys become an endless supply of money for the vendors.<p>It&#x27;s very telling that passkeys were designed <i>and</i> shipped without any export&#x2F;import mechanism. You can plainly see the priority of the passkey vendors, which is to lock you in. Allegedly, export&#x2F;import is coming <i>sometime</i> in the future, but I strongly suspect that they&#x27;ll end up with some kind of &quot;approved provider&quot; system so that the big passkey vendors can retain absolute control and avoid giving power to the users.</div><br/><div id="42518750" class="c"><input type="checkbox" id="c-42518750" checked=""/><div class="controls bullet"><span class="by">amlozano</span><span>|</span><a href="#42518531">parent</a><span>|</span><a href="#42520352">next</a><span>|</span><label class="collapse" for="c-42518750">[-]</label><label class="expand" for="c-42518750">[7 more]</label></div><br/><div class="children"><div class="content">This is the exact reason I self host vault warden. I get all the convenience of syncing passkeys, but know that I am the only one with access to the back-end.<p>I am also slightly paranoid as a security engineer, and admit that whole heartedly.</div><br/><div id="42518793" class="c"><input type="checkbox" id="c-42518793" checked=""/><div class="controls bullet"><span class="by">g_p</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518750">parent</a><span>|</span><a href="#42520352">next</a><span>|</span><label class="collapse" for="c-42518793">[-]</label><label class="expand" for="c-42518793">[6 more]</label></div><br/><div class="children"><div class="content">I share your paranoia and felt that passkeys were a step back as anything getting access to your browser extension memory can realistically dump both your &quot;password&quot; and MFA (&quot;passkey&quot;) in one move.<p>I wonder if there would be a way for vaultwarden to wrap passkeys such that a hardware FIDO2 key is needed to decrypt them &quot;per-use&quot;, and prevent software on the host from stealing a pile of passkeys that give direct access to accounts without further MFA.<p>Right now it feels like passkeys in the password manager is akin to storing MFA seeds and recovery keys in the same password manager...</div><br/><div id="42519016" class="c"><input type="checkbox" id="c-42519016" checked=""/><div class="controls bullet"><span class="by">briHass</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518793">parent</a><span>|</span><a href="#42519141">next</a><span>|</span><label class="collapse" for="c-42519016">[-]</label><label class="expand" for="c-42519016">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m also waiting for a password manager that tightly integrates with a hardware device to protect passwords individually and in-memory.<p>I wrote a quick PoC using certificates to encrypt a password, with the cert private key &#x27;stored&#x27; in the TPM, with a PIN. This is pretty easy on Windows, which exposes the TPM as a special crypto provider.</div><br/><div id="42519715" class="c"><input type="checkbox" id="c-42519715" checked=""/><div class="controls bullet"><span class="by">g_p</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42519016">parent</a><span>|</span><a href="#42519141">next</a><span>|</span><label class="collapse" for="c-42519715">[-]</label><label class="expand" for="c-42519715">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a pretty neat solution. I like that idea.<p>If you wanted to go a step further, you could use a smartcard with hardware PIN reader as a PKCS11 crypto device, and use that to decrypt the long lived keys in the store, then pass it back to the host encrypted by a platform-protected key to be decrypted and used.<p>If you could get the right implementation specifics together, you could likely then have the smart card simultaneously re-encrypt the credential with a key bound to PCR state of the TPM via a policy. You&#x27;d then decrypt that ciphertext on TPM without a PIN, but conditional on PCR state of a couple of PCRs that represent your system like the secure boot toggle state and allowed CAs.<p>That lets you be a bit more &quot;cross device&quot; than a fully TPM solution does, though your certificate technique works fine as long as you keep an offline backup for enrollment if anything changes on your system.</div><br/></div></div></div></div><div id="42519141" class="c"><input type="checkbox" id="c-42519141" checked=""/><div class="controls bullet"><span class="by">MaKey</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518793">parent</a><span>|</span><a href="#42519016">prev</a><span>|</span><a href="#42519109">next</a><span>|</span><label class="collapse" for="c-42519141">[-]</label><label class="expand" for="c-42519141">[2 more]</label></div><br/><div class="children"><div class="content">Storing the passkeys on a device protected by a PIN is an option too. Example: T2F2-PIN+ Release3 by Token2 can store 300 passkeys.</div><br/><div id="42519669" class="c"><input type="checkbox" id="c-42519669" checked=""/><div class="controls bullet"><span class="by">g_p</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42519141">parent</a><span>|</span><a href="#42519109">next</a><span>|</span><label class="collapse" for="c-42519669">[-]</label><label class="expand" for="c-42519669">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a fair point, although as the PIN is validated locally, you could argue from the server perspective you gain a second (knowledge) factor, but from a local perspective it&#x27;s entirely correlated with the existing stored factor (a weakness in the local device implementation can skip that PIN check and yield the result).<p>Perhaps this is excessive, but it&#x27;s a model where I like to see layers of security that depend on different, uncorrelated failures being required to bypass them.<p>Today if you want to get into an account using &quot;FIDO2 as MFA&quot; you need both the account credentials or ability to reach the Fido prompt (say password reset), and the hardware token device (with optional pin). The device alone being compromised shouldn&#x27;t get you into the account.</div><br/></div></div></div></div><div id="42519109" class="c"><input type="checkbox" id="c-42519109" checked=""/><div class="controls bullet"><span class="by">amlozano</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518793">parent</a><span>|</span><a href="#42519141">prev</a><span>|</span><a href="#42520352">next</a><span>|</span><label class="collapse" for="c-42519109">[-]</label><label class="expand" for="c-42519109">[1 more]</label></div><br/><div class="children"><div class="content">For anything that is important enough, I put passkeys on 2 separate FIDO2 key devices directly. Services that come to mind are things with recovery backdoors; like email or device backups. Unfortunately many banks and financial institutions don&#x27;t support passkeys, but I&#x27;d consider using that solution there too.</div><br/></div></div></div></div></div></div><div id="42520352" class="c"><input type="checkbox" id="c-42520352" checked=""/><div class="controls bullet"><span class="by">Elucalidavah</span><span>|</span><a href="#42518531">parent</a><span>|</span><a href="#42518750">prev</a><span>|</span><a href="#42518581">next</a><span>|</span><label class="collapse" for="c-42520352">[-]</label><label class="expand" for="c-42520352">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention that a better security would involve a master key, and revocable subkeys signed with it, one for each device, instead of syncing. Not to mention n-of-m requirements.<p>And sure, I understand that most people <i>need</i> the paternalistic form, whey they are not given any guns and are also unable to export their keys from some service.<p>For example, with TOTP, the key is given to the user in the QR code, but common authenticator apps are unable to export the same data after it was imported. But not all; and the only bad thing about this is that the export restriction is a surprise to those who didn&#x27;t expect it.</div><br/></div></div><div id="42518581" class="c"><input type="checkbox" id="c-42518581" checked=""/><div class="controls bullet"><span class="by">ylk</span><span>|</span><a href="#42518531">parent</a><span>|</span><a href="#42520352">prev</a><span>|</span><a href="#42520027">next</a><span>|</span><label class="collapse" for="c-42518581">[-]</label><label class="expand" for="c-42518581">[5 more]</label></div><br/><div class="children"><div class="content">Just use a password manager that doesn&#x27;t sync by itself then<p><a href="https:&#x2F;&#x2F;keepassxc.org&#x2F;docs&#x2F;KeePassXC_UserGuide#_passkeys" rel="nofollow">https:&#x2F;&#x2F;keepassxc.org&#x2F;docs&#x2F;KeePassXC_UserGuide#_passkeys</a></div><br/><div id="42518609" class="c"><input type="checkbox" id="c-42518609" checked=""/><div class="controls bullet"><span class="by">g_p</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518581">parent</a><span>|</span><a href="#42518716">next</a><span>|</span><label class="collapse" for="c-42518609">[-]</label><label class="expand" for="c-42518609">[3 more]</label></div><br/><div class="children"><div class="content">The downside of this (at least in my personal view) is it&#x27;s a regression from the elevated security you got with non-resident FIDO&#x2F;U2F MFA.<p>The moment you go &quot;passkey&quot; and have to use a system like the one you suggest, you need to trust software based storage of long term credentials.<p>That isn&#x27;t the case with a hardware FIDO2&#x2F;U2F token, which has unlimited capacity for non-resident MFA keys the server holds for you to decrypt and use locally to sign login attempts.<p>I liked that FIDO seemed to get towards hardware backed security modules for login, without cognitive load of worrying about number of sites and yubikey slot capacity. Resident Webauthn keys limit the number of sites you can have, and push you towards software based solutions (so you lose out on doing the crypto on the single purpose, limited platform that&#x27;s dedicated to generating those signatures).</div><br/><div id="42518663" class="c"><input type="checkbox" id="c-42518663" checked=""/><div class="controls bullet"><span class="by">ylk</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518609">parent</a><span>|</span><a href="#42518716">next</a><span>|</span><label class="collapse" for="c-42518663">[-]</label><label class="expand" for="c-42518663">[2 more]</label></div><br/><div class="children"><div class="content">I agree that it&#x27;s annoying that there&#x27;s now a limit on the amount of credentials you can store on hardware keys. But while older Yubikeys only support 25 resident keys, models with firmware 5.7 onwards support 100. That probably makes it feasible to exclusively store passkeys in hardware.
<a href="https:&#x2F;&#x2F;www.yubico.com&#x2F;blog&#x2F;empowering-enterprise-security-at-scale-with-new-product-innovations-yubikey-5-7-and-yubico-authenticator-7&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.yubico.com&#x2F;blog&#x2F;empowering-enterprise-security-a...</a><p>However, I don&#x27;t know whether it&#x27;s possible to delete only a single resident key you no longer need.</div><br/><div id="42518720" class="c"><input type="checkbox" id="c-42518720" checked=""/><div class="controls bullet"><span class="by">g_p</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518663">parent</a><span>|</span><a href="#42518716">next</a><span>|</span><label class="collapse" for="c-42518720">[-]</label><label class="expand" for="c-42518720">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, a fair point (though if you can&#x27;t manage keys one by one that seems a massive usability issue and oversight with no safe path to resolution).<p>This adds another step needing considered for a user, as finite storage means a whole edge case to consider (can&#x27;t register as slots full), and no simple actionable step to take (&quot;which account would you like to never be able to log into again?&quot; or &quot;sorry you need to wipe this key and lose everything, or buy another one&quot;)<p>I feel there is a usability aspect of FIDO2 (for non-resident MFA) that is being overlooked - the paradigm was simple - a physical key you don&#x27;t lose, and you can have multiple keys. The gotcha was no way to replicate backup keys, which becomes fairly difficult for users. But hey - passkeys launched with no export or migration process between closed device ecosystems!<p>From my perspective though, I won&#x27;t use passkeys until I get sufficient control over them to be allowed to decide if I want to make them &quot;resident&quot; or not. (I don&#x27;t want resident keys!!)<p>I want to use non-resident keys everywhere as a hardware-backed second factor that is phishing resistant, without capacity limitations (so zero cognitive burden on whether to use or not).<p>It feels like a regression for passkeys to be forgetting about what (for me at least) was the core basic use-case of FIDO2 - as a highly secure second factor for someone who already can manage storage of secrets in software, and just wants high assurance phishing resistant MFA during their conventional login process.</div><br/></div></div></div></div></div></div><div id="42518716" class="c"><input type="checkbox" id="c-42518716" checked=""/><div class="controls bullet"><span class="by">lapcat</span><span>|</span><a href="#42518531">root</a><span>|</span><a href="#42518581">parent</a><span>|</span><a href="#42518609">prev</a><span>|</span><a href="#42520027">next</a><span>|</span><label class="collapse" for="c-42518716">[-]</label><label class="expand" for="c-42518716">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no browser extension available for Safari: <a href="https:&#x2F;&#x2F;keepassxc.org&#x2F;docs&#x2F;KeePassXC_GettingStarted#_setup_browser_integration" rel="nofollow">https:&#x2F;&#x2F;keepassxc.org&#x2F;docs&#x2F;KeePassXC_GettingStarted#_setup_b...</a></div><br/></div></div></div></div><div id="42520027" class="c"><input type="checkbox" id="c-42520027" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#42518531">parent</a><span>|</span><a href="#42518581">prev</a><span>|</span><a href="#42518797">next</a><span>|</span><label class="collapse" for="c-42520027">[-]</label><label class="expand" for="c-42520027">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The vendors claim that this is to make phishing impossible<p>They do? I don&#x27;t see how, since non-discoverable WebAuthN credentials make phishing just as impossible.<p>The only thing discoverable credentials allow on top of non-discoverable ones is avoiding having the user type in their username or email address.</div><br/></div></div></div></div></div></div></div></div></div></body></html>