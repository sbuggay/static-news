<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701594056206" as="style"/><link rel="stylesheet" href="styles.css?v=1701594056206"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://medium.com/@ozoniuss/optimizing-go-string-operations-with-practical-examples-83df39b776fb">Optimizing Go string operations with practical examples</a> <span class="domain">(<a href="https://medium.com">medium.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>17 comments</span></div><br/><div><div id="38505413" class="c"><input type="checkbox" id="c-38505413" checked=""/><div class="controls bullet"><span class="by">jensneuse</span><span>|</span><a href="#38504856">next</a><span>|</span><label class="collapse" for="c-38505413">[-]</label><label class="expand" for="c-38505413">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;re using similar techniques to parse and merge JSON objects, which could be applied to this problem as well. Essentially, you could index the whole input into an AST and the. Traverse the AST to find the data you&#x27;re looking for. In our case, we&#x27;re not just doing that, but recursively merge JSON objects at the AST level which is a lot faster than merging the actual data. The full blog post on the problem and solution can be found here: <a href="https:&#x2F;&#x2F;wundergraph.com&#x2F;blog&#x2F;astjson_high_performance_json_transformations_in_golang" rel="nofollow noreferrer">https:&#x2F;&#x2F;wundergraph.com&#x2F;blog&#x2F;astjson_high_performance_json_t...</a></div><br/></div></div><div id="38504856" class="c"><input type="checkbox" id="c-38504856" checked=""/><div class="controls bullet"><span class="by">NAHWheatCracker</span><span>|</span><a href="#38505413">prev</a><span>|</span><a href="#38504169">next</a><span>|</span><label class="collapse" for="c-38504856">[-]</label><label class="expand" for="c-38504856">[7 more]</label></div><br/><div class="children"><div class="content">I&#x27;m doing Advent on Discord with a former coworker this year.<p>This morning we compared the performance of his solution in Rust to my solution in Go. His was running 2-4x faster than mine but we couldn&#x27;t figure out why and it seemed so straight forward that we assumed Rust was just that much faster.<p>I had assumed strings.Split would return sub-slices of the original string until I read this post. Sure enough, I rewrite it using strings.Index and manually creating sub-slices and now it&#x27;s comparable, albeit less readable.<p>Looking at the standard library source doesn&#x27;t make it clear to me why this even works. strings.Split is appending sub-slices of the input string to the return value. I don&#x27;t understand where the allocations are coming from, but I&#x27;m just not knowledgeable enough about go slices.</div><br/><div id="38505802" class="c"><input type="checkbox" id="c-38505802" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#38504856">parent</a><span>|</span><a href="#38505038">next</a><span>|</span><label class="collapse" for="c-38505802">[-]</label><label class="expand" for="c-38505802">[1 more]</label></div><br/><div class="children"><div class="content">Why are you even making strings to begin with most of the time?</div><br/></div></div><div id="38505038" class="c"><input type="checkbox" id="c-38505038" checked=""/><div class="controls bullet"><span class="by">SPBS</span><span>|</span><a href="#38504856">parent</a><span>|</span><a href="#38505802">prev</a><span>|</span><a href="#38504169">next</a><span>|</span><label class="collapse" for="c-38505038">[-]</label><label class="expand" for="c-38505038">[5 more]</label></div><br/><div class="children"><div class="content">strings.Split <i>does</i> return subslices of the original string. It&#x27;s not making a copy of the string. Allocations still have to be made for slice that holds the result of strings.Split. That&#x27;s where the allocations are coming from.</div><br/><div id="38505206" class="c"><input type="checkbox" id="c-38505206" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#38504856">root</a><span>|</span><a href="#38505038">parent</a><span>|</span><a href="#38504169">next</a><span>|</span><label class="collapse" for="c-38505206">[-]</label><label class="expand" for="c-38505206">[4 more]</label></div><br/><div class="children"><div class="content">From looking into Rust&#x27;s implementation of the iterator that&#x27;s returned when splitting a string (which takes a bit of mental parsing, given the heavy use of macros: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;src&#x2F;core&#x2F;str&#x2F;iter.rs.html#731-747" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;src&#x2F;core&#x2F;str&#x2F;iter.rs.html#731-747</a>), it seems like it has a reference to the original string and an index that it increments until it finds the next pattern to &quot;split&quot; on. This seems like something that would be pretty easy to do in Go as well, except Go doesn&#x27;t really have any standard iterator API from what I can tell. This seems like a pretty clear argument for why having one is preferable to just returning slices everywhere though; even if you end up wanting to iterator through everything immediately, you avoid allocating unless you actually have to. In Rust, you can do this by just calling `collect` on the iterator, and although I suspect whoever implemented this API for Go wouldn&#x27;t like the &quot;magic&quot; of it generically supporting collecting into whatever container you want, it feels like even just having an iterator with a method to collect into a slice and nothing else would be preferable.</div><br/><div id="38505528" class="c"><input type="checkbox" id="c-38505528" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#38504856">root</a><span>|</span><a href="#38505206">parent</a><span>|</span><a href="#38505743">next</a><span>|</span><label class="collapse" for="c-38505528">[-]</label><label class="expand" for="c-38505528">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it feels like even just having an iterator with a method to collect into a slice and nothing else would be preferable.<p>Most langages just have constructors or factory functions from iterator (or even iterable) to container. It’s a less generic (especially if constructors and functions are segregated) and &#x2F; or efficient but otherwise works fine. No need for the iterator whatever (protocol, interface, trait) to have specific knowledge of individual collections.</div><br/></div></div><div id="38505743" class="c"><input type="checkbox" id="c-38505743" checked=""/><div class="controls bullet"><span class="by">pstuart</span><span>|</span><a href="#38504856">root</a><span>|</span><a href="#38505206">parent</a><span>|</span><a href="#38505528">prev</a><span>|</span><a href="#38504169">next</a><span>|</span><label class="collapse" for="c-38505743">[-]</label><label class="expand" for="c-38505743">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s going to be experimental support for built-in iteration in 1.22: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;61897">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;61897</a></div><br/><div id="38505806" class="c"><input type="checkbox" id="c-38505806" checked=""/><div class="controls bullet"><span class="by">ikiris</span><span>|</span><a href="#38504856">root</a><span>|</span><a href="#38505743">parent</a><span>|</span><a href="#38504169">next</a><span>|</span><label class="collapse" for="c-38505806">[-]</label><label class="expand" for="c-38505806">[1 more]</label></div><br/><div class="children"><div class="content">oh nice. i hope this lands.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38504169" class="c"><input type="checkbox" id="c-38504169" checked=""/><div class="controls bullet"><span class="by">costco</span><span>|</span><a href="#38504856">prev</a><span>|</span><a href="#38505620">next</a><span>|</span><label class="collapse" for="c-38504169">[-]</label><label class="expand" for="c-38504169">[1 more]</label></div><br/><div class="children"><div class="content">Nice practical article.  I tried to rewrite the code in it to use byte slices and calls to the bytes package instead of strings while keeping the calls to Split, thinking it would be faster due to less copying.  The allocations were actually about 1.5x higher than in the original string version.  It turns out a slice header in Go is 24 bytes versus 16 for a string header, and 24&#x2F;16 = 1.5.<p>Tangentially related:<p>Not really necessary here but lately I&#x27;ve been using buffer pools like the one by the fasthttp author to avoid allocating in performance sensitive places.  But the code is sometimes pretty ugly.<p><pre><code>        &#x2F;&#x2F; get buffer from pool
        body := bytebufferpool.Get()

        &#x2F;&#x2F; create request body
        body.WriteString(`{&quot;config_id&quot;:&quot;`)
        for i := range configID {
                c := configID[i]
                if c != &#x27;&#x2F;&#x27; {
                        body.WriteByte(c)
                } else {
                        &#x2F;&#x2F; escape slash
                        body.WriteByte(&#x27;\\&#x27;)
                        body.WriteByte(&#x27;&#x2F;&#x27;)
                }
        }
        body.WriteString(`&quot;,&quot;commit&quot;:`)
        if commit {
                body.WriteByte(&#x27;1&#x27;)
        } else {
                body.WriteByte(&#x27;0&#x27;)
        }
        body.WriteString(`,&quot;struct_items&quot;:[]}`)

        &#x2F;&#x2F; send request
        ...

        &#x2F;&#x2F; add back to pool
        bytebufferpool.Put(body)</code></pre></div><br/></div></div><div id="38505620" class="c"><input type="checkbox" id="c-38505620" checked=""/><div class="controls bullet"><span class="by">coumbaya</span><span>|</span><a href="#38504169">prev</a><span>|</span><a href="#38505228">next</a><span>|</span><label class="collapse" for="c-38505620">[-]</label><label class="expand" for="c-38505620">[1 more]</label></div><br/><div class="children"><div class="content">Interesting article ! Another imrpovement (unrelated to strings) would be to exit the function as soon a an impossible RGB value is reached (instead of processing everyrhing).</div><br/></div></div><div id="38505233" class="c"><input type="checkbox" id="c-38505233" checked=""/><div class="controls bullet"><span class="by">mitchbob</span><span>|</span><a href="#38505228">prev</a><span>|</span><a href="#38503570">next</a><span>|</span><label class="collapse" for="c-38505233">[-]</label><label class="expand" for="c-38505233">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;archive.is&#x2F;U54jZ" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.is&#x2F;U54jZ</a></div><br/></div></div><div id="38503570" class="c"><input type="checkbox" id="c-38503570" checked=""/><div class="controls bullet"><span class="by">RenThraysk</span><span>|</span><a href="#38505233">prev</a><span>|</span><label class="collapse" for="c-38503570">[-]</label><label class="expand" for="c-38503570">[4 more]</label></div><br/><div class="children"><div class="content">Seems to have missed the strings.Cut* family added to go 1.18</div><br/><div id="38503907" class="c"><input type="checkbox" id="c-38503907" checked=""/><div class="controls bullet"><span class="by">costco</span><span>|</span><a href="#38503570">parent</a><span>|</span><label class="collapse" for="c-38503907">[-]</label><label class="expand" for="c-38503907">[3 more]</label></div><br/><div class="children"><div class="content">Well, they are implemented in a pretty similar way: <a href="https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;refs&#x2F;tags&#x2F;go1.21.4:src&#x2F;strings&#x2F;strings.go;l=1278" rel="nofollow noreferrer">https:&#x2F;&#x2F;cs.opensource.google&#x2F;go&#x2F;go&#x2F;+&#x2F;refs&#x2F;tags&#x2F;go1.21.4:src&#x2F;...</a> so it shouldn&#x27;t affect the benchmarks too much.</div><br/><div id="38504049" class="c"><input type="checkbox" id="c-38504049" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#38503570">root</a><span>|</span><a href="#38503907">parent</a><span>|</span><label class="collapse" for="c-38504049">[-]</label><label class="expand" for="c-38504049">[2 more]</label></div><br/><div class="children"><div class="content">Cut only scans the string once (not twice) and doesn&#x27;t allocate a slice to return.</div><br/><div id="38504213" class="c"><input type="checkbox" id="c-38504213" checked=""/><div class="controls bullet"><span class="by">costco</span><span>|</span><a href="#38503570">root</a><span>|</span><a href="#38504049">parent</a><span>|</span><label class="collapse" for="c-38504213">[-]</label><label class="expand" for="c-38504213">[1 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m confused on how strings work but if this doesn&#x27;t allocate:<p><pre><code>        &#x2F;&#x2F; excerpted from Cut
        if i := Index(s, sep); i &gt;= 0 {
                return s[:i], s[i+len(sep):], true
        }
        return s, &quot;&quot;, false
</code></pre>
Then why shouldn&#x27;t this also not allocate?<p><pre><code>        eoc = strings.Index(round, &quot;, &quot;)
        if eoc == -1 {
                currentScoreWithColor = round
        } else {
                currentScoreWithColor = round[:eoc]
                round = round[eoc+2:]
        }
</code></pre>
Edit: oh, you&#x27;re comparing it to Split.  I was comparing it to what they ended up implementing.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>