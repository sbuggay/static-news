<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729933251992" as="style"/><link rel="stylesheet" href="styles.css?v=1729933251992"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://web.archive.org/web/20230228035749/https://sites.inka.de/~W1011/devel/tcp-tcp.html">TCP over TCP is a bad idea (2000)</a>Â <span class="domain">(<a href="https://web.archive.org">web.archive.org</a>)</span></div><div class="subtext"><span>Deeg9rie9usi</span> | <span>40 comments</span></div><br/><div><div id="41950191" class="c"><input type="checkbox" id="c-41950191" checked=""/><div class="controls bullet"><span class="by">aarmenaa</span><span>|</span><a href="#41948705">next</a><span>|</span><label class="collapse" for="c-41950191">[-]</label><label class="expand" for="c-41950191">[19 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve just spent the last month learning exactly why I definitely do want a TCP over TCP VPN.  The short answer is almost every cloud vendor assumes you&#x27;re doing TCP, and they&#x27;ve taken the &quot;unreliable&quot; part of UDP to heart.  It is practically impossible run any modern VPN on most cloud providers anymore.<p>Over the last month, I&#x27;ve been attempting to set up a fast Wireguard VPN tunnel between AWS and OVH.  AWS killed all internet access on the instance with zero warning and sent us an email indicating that they suspected the instance was compromised and being used as part of a DDOS attack.  OVH randomly performs &quot;DDOS mitigation&quot; anytime the tunnel is under any load.  In both cases we were able to talk to someone and have the issue addressed, but I wanna stress: this is one stream between two IPs -- there&#x27;s <i>nothing</i> that makes this anything close to looking like a DDOS.  Even after getting everything properly blessed, OVH drops all UDP traffic over 1 Gbps.  It took them a month of back-and-forth troubleshooting to tell us this.<p>The really terrible part is &quot;TCP over TCP is bad&quot; is now so prevalent there&#x27;s basically no good VPN options for it if you need it.  Wireguard won&#x27;t do it directly, but there&#x27;s hacks involving udp2raw.  I tried it, and wasn&#x27;t able to achieve more than 100 Mbps.  OpenVPN can do it, but is single-threaded and won&#x27;t reasonably do more than 1 Gbps without hardware acceleration, which didn&#x27;t appear to work on EC2 instances.  strongSwan cannot be configured to do unencapsulated ESP anymore -- they removed the option -- so it&#x27;s UDP encapsulated only.  Their reasoning is UDP is necessary for NAT traversal, and of course everybody needs that.  It&#x27;s also thread-per-SA so also not fast.  The only solution I&#x27;ve found than can do something not UDP is Libreswan, which can still do unencapsulated ESP (IP Protocol 50) if you ask nicely.  It&#x27;s also thread-per-SA, but I&#x27;ve managed to wring 2 - 3 Gbps out of a single core after tinkering with the configuration.<p>For the love of all that&#x27;s good in the world, just add performant TCP support to Wireguard.  I do not care about what happens in non-optimal conditions.<p>&#x2F;rant</div><br/><div id="41953533" class="c"><input type="checkbox" id="c-41953533" checked=""/><div class="controls bullet"><span class="by">danw1979</span><span>|</span><a href="#41950191">parent</a><span>|</span><a href="#41950486">next</a><span>|</span><label class="collapse" for="c-41953533">[-]</label><label class="expand" for="c-41953533">[1 more]</label></div><br/><div class="children"><div class="content">Did you try udp&#x2F;443 to see if OVH clobber that traffic ?<p>I was quite hoping that the advent of QUIC would let us all use UDP again, albeit on one port.</div><br/></div></div><div id="41950486" class="c"><input type="checkbox" id="c-41950486" checked=""/><div class="controls bullet"><span class="by">kwantam</span><span>|</span><a href="#41950191">parent</a><span>|</span><a href="#41953533">prev</a><span>|</span><a href="#41950878">next</a><span>|</span><label class="collapse" for="c-41950486">[-]</label><label class="expand" for="c-41950486">[9 more]</label></div><br/><div class="children"><div class="content">The whole point of this article is that performant Wireguard-over-TCP support in Wireguard simply does not work. You&#x27;re not fighting the prevalence of an idea, you&#x27;re fighting an inherent behavior of the system as currently constituted.<p>In more detail, let&#x27;s imagine we make a Wireguard-over-TCP tunnel. The &quot;outer&quot; TCP connection carrying the Wireguard tunnel is, well, a TCP connection. So Wireguard can&#x27;t stop the connection from retransmitting. Likewise, any &quot;inner&quot; TCP connections routed through the Wireguard tunnel are plain-vanilla TCP connections; Wireguard cannot stop them from retransmitting, either. The retransmit-in-retransmit behavior is precisely the issue.<p>So, what could we possibly do about this? Well, Wireguard certainly cannot modify the inner TCP connections (because then it wouldn&#x27;t be providing a tunnel).<p>Could it work with a modified outer TCP connection? Maybe---perhaps Wireguard could implement a user-space &quot;TCP&quot; stack that sends syntactically valid TCP segments but never retransmits, then run that on both ends of the connection. In essence, UDP masquerading as TCP. But there&#x27;s no guarantee that this faux-TCP connection wouldn&#x27;t break in weird ways because the network (especially, as you&#x27;ve discovered, any cloud provider&#x27;s network!) isn&#x27;t just a dumb pipe: middleboxes, for example, expect TCP to behave like TCP.<p>Good news (and oops), it looks like I&#x27;ve just accidentally described phantun (and maybe other solutions): <a href="https:&#x2F;&#x2F;github.com&#x2F;dndx&#x2F;phantun">https:&#x2F;&#x2F;github.com&#x2F;dndx&#x2F;phantun</a> I&#x27;d be curious if this manages to sidestep the issues you&#x27;re seeing with AWS and OVH.</div><br/><div id="41950728" class="c"><input type="checkbox" id="c-41950728" checked=""/><div class="controls bullet"><span class="by">aarmenaa</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41950486">parent</a><span>|</span><a href="#41952423">next</a><span>|</span><label class="collapse" for="c-41950728">[-]</label><label class="expand" for="c-41950728">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The retransmit-in-retransmit behavior is precisely the issue.<p>But you&#x27;re concerned about an issue I do not have.  In practice retransmits are rare between my endpoints, and if they did occur poor performance is acceptable for some period of time.  I just need it to me fast <i>most of the time</i>.  To reiterate: I do not care about what happens in non-optimal conditions.<p>&gt; it looks like I&#x27;ve just accidentally described phantun (and maybe other solutions): <a href="https:&#x2F;&#x2F;github.com&#x2F;dndx&#x2F;phantun">https:&#x2F;&#x2F;github.com&#x2F;dndx&#x2F;phantun</a><p>I&#x27;ll definitely look into that.  They specifically mention being more performant than udp2raw, so that&#x27;s nice.</div><br/><div id="41950969" class="c"><input type="checkbox" id="c-41950969" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41950728">parent</a><span>|</span><a href="#41952423">next</a><span>|</span><label class="collapse" for="c-41950969">[-]</label><label class="expand" for="c-41950969">[6 more]</label></div><br/><div class="children"><div class="content">&gt;  In practice retransmits are rare between my endpoints<p>You seem to be mistaken about how (most) TCP implementations work. They regularly trigger packet loss and retransmissions as part of their mechanism to determine the optimal transmission rate over an entire path (made up of potentially multiple point-to-point connections with dynamically varying capacity).<p>That mechanism breaks down horribly when using TCP-over-TCP.</div><br/><div id="41951509" class="c"><input type="checkbox" id="c-41951509" checked=""/><div class="controls bullet"><span class="by">screcth</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41950969">parent</a><span>|</span><a href="#41951271">next</a><span>|</span><label class="collapse" for="c-41951509">[-]</label><label class="expand" for="c-41951509">[2 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t the tunneling software detect when the upper TCP is retransmitting segments and drop them?<p>That would give the lower TCP enough time to transmit the original segment.</div><br/><div id="41951663" class="c"><input type="checkbox" id="c-41951663" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41951509">parent</a><span>|</span><a href="#41951271">next</a><span>|</span><label class="collapse" for="c-41951663">[-]</label><label class="expand" for="c-41951663">[1 more]</label></div><br/><div class="children"><div class="content">Maybe, but packet loss isn&#x27;t the only problem. You&#x27;ll also want to preserve latency (TCP has a pretty sophisticated latency estimation mechanism), for example.<p>Some middleboxes will also do terrible things to your TCP streams (restrictive firewalls only allowing TCP are good candidates for that), and then all bets are off.<p>If you&#x27;re really required to use TCP, the &quot;fake TCP&quot; approach that others in sibling threads have mentioned seems more promising (but again, beware of middleboxes).</div><br/></div></div></div></div><div id="41951271" class="c"><input type="checkbox" id="c-41951271" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41950969">parent</a><span>|</span><a href="#41951509">prev</a><span>|</span><a href="#41952423">next</a><span>|</span><label class="collapse" for="c-41951271">[-]</label><label class="expand" for="c-41951271">[3 more]</label></div><br/><div class="children"><div class="content">But, my connection speed is usually greater and my loss is much less to my VPN endpoint than to whatever services I am accessing though that endpoint.  As a result it doesn&#x27;t affect things much.  Further, accessing it with UDP is not always possible.</div><br/><div id="41951768" class="c"><input type="checkbox" id="c-41951768" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41951271">parent</a><span>|</span><a href="#41952423">next</a><span>|</span><label class="collapse" for="c-41951768">[-]</label><label class="expand" for="c-41951768">[2 more]</label></div><br/><div class="children"><div class="content">&gt; [...] my loss is much less [...]<p>Unless it&#x27;s actually zero, any loss on the &quot;outer&quot; TCP stream will cause a retransmission, visible to the inner one as a sharp jump in latency of <i>all</i> data following the loss. Most TCP stacks don&#x27;t handle that very well either.</div><br/><div id="41951852" class="c"><input type="checkbox" id="c-41951852" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41951768">parent</a><span>|</span><a href="#41952423">next</a><span>|</span><label class="collapse" for="c-41951852">[-]</label><label class="expand" for="c-41951852">[1 more]</label></div><br/><div class="children"><div class="content">Sure, even when outer loss is pretty close to zero, it&#x27;s conceptually not great.<p>On the other hand, I get 400mbps over TCP-over-TCP connections, and can&#x27;t connect in any other reasonable way.  400mbps &gt; 0.<p>Even tunneling in UDP is not great due to MTU effects.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41950878" class="c"><input type="checkbox" id="c-41950878" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41950191">parent</a><span>|</span><a href="#41950486">prev</a><span>|</span><a href="#41950834">next</a><span>|</span><label class="collapse" for="c-41950878">[-]</label><label class="expand" for="c-41950878">[2 more]</label></div><br/><div class="children"><div class="content">&gt; just add performant TCP support to Wireguard<p>But IP over TCP is <i>in principle</i> non-performant. There&#x27;s no (non-evil) magic Wireguard could perform to get around that.<p>Adding TCP support to Wireguard would add a whole bunch of complexity that it doesn&#x27;t need â for a very niche use case (i.e. where you absolutely have to get an IP VPN to work over a restrictive firewall).<p>&gt; Wireguard won&#x27;t do it directly, but there&#x27;s hacks involving udp2raw.<p>Which significantly does not do UDP over TCP in the problematic sense (it just masquerades UDP as TCP, without providing a second set of TCP control loops on top of the first one).<p>&gt; AWS killed all internet access on the instance with zero warning and sent us an email indicating that they suspected the instance was compromised and being used as part of a DDOS attack.<p>It makes no sense for that to be due to Wireguard usage, though (not saying I don&#x27;t believe you that it happened, just their explanation or your assumption of their motivation seems strange). Things like Tailscale use Wireguard and should be common enough for AWS to know about them by now, I&#x27;d assume?</div><br/><div id="41952434" class="c"><input type="checkbox" id="c-41952434" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41950878">parent</a><span>|</span><a href="#41950834">next</a><span>|</span><label class="collapse" for="c-41952434">[-]</label><label class="expand" for="c-41952434">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But IP over TCP is in principle non-performant.<p>No it&#x27;s not.  In principle it risks meltdown, which is different.  A link that occasionally breaks can be performant while it&#x27;s working.</div><br/></div></div></div></div><div id="41950834" class="c"><input type="checkbox" id="c-41950834" checked=""/><div class="controls bullet"><span class="by">chgs</span><span>|</span><a href="#41950191">parent</a><span>|</span><a href="#41950878">prev</a><span>|</span><a href="#41951052">next</a><span>|</span><label class="collapse" for="c-41950834">[-]</label><label class="expand" for="c-41950834">[1 more]</label></div><br/><div class="children"><div class="content">I run WireGuard to all my ec2 and AWS instances with no problem. I also run UDP video streams into AWS with little issue.</div><br/></div></div><div id="41951052" class="c"><input type="checkbox" id="c-41951052" checked=""/><div class="controls bullet"><span class="by">Hikikomori</span><span>|</span><a href="#41950191">parent</a><span>|</span><a href="#41950834">prev</a><span>|</span><a href="#41950460">next</a><span>|</span><label class="collapse" for="c-41951052">[-]</label><label class="expand" for="c-41951052">[2 more]</label></div><br/><div class="children"><div class="content">Did ipsec over udp for client vpn, to datacenter and even to Azure from AWS. No issues whatsoever, never did more than a Gbit over 1 tunnel though.</div><br/><div id="41951325" class="c"><input type="checkbox" id="c-41951325" checked=""/><div class="controls bullet"><span class="by">aarmenaa</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41951052">parent</a><span>|</span><a href="#41950460">next</a><span>|</span><label class="collapse" for="c-41951325">[-]</label><label class="expand" for="c-41951325">[1 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve run Wireguard tunnels that max out at 1 Gbps in AWS for years with no issues (on the AWS side, anyways).  It seems like things get hairy once you want to do more than that.</div><br/></div></div></div></div><div id="41950460" class="c"><input type="checkbox" id="c-41950460" checked=""/><div class="controls bullet"><span class="by">throwing_away</span><span>|</span><a href="#41950191">parent</a><span>|</span><a href="#41951052">prev</a><span>|</span><a href="#41948705">next</a><span>|</span><label class="collapse" for="c-41950460">[-]</label><label class="expand" for="c-41950460">[3 more]</label></div><br/><div class="children"><div class="content">Did you go down the shadowsocks path at all?</div><br/><div id="41951314" class="c"><input type="checkbox" id="c-41951314" checked=""/><div class="controls bullet"><span class="by">aarmenaa</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41950460">parent</a><span>|</span><a href="#41948705">next</a><span>|</span><label class="collapse" for="c-41951314">[-]</label><label class="expand" for="c-41951314">[2 more]</label></div><br/><div class="children"><div class="content">I did not.  I&#x27;m not terribly familiar with it, but it doesn&#x27;t look like I can do general routing with it, right?  My end goal is to route between two subnets.</div><br/><div id="41953056" class="c"><input type="checkbox" id="c-41953056" checked=""/><div class="controls bullet"><span class="by">riobard</span><span>|</span><a href="#41950191">root</a><span>|</span><a href="#41951314">parent</a><span>|</span><a href="#41948705">next</a><span>|</span><label class="collapse" for="c-41953056">[-]</label><label class="expand" for="c-41953056">[1 more]</label></div><br/><div class="children"><div class="content">Nope, shadowsocks is just plain TCP-in-TCP (not TCP-over-TCP) proxy. If you cannot have performant routing between clouds due to UDP QoS, then the only sensible solution would be to setup proxy nodes on both sides and transparently redirect TCP (if that&#x27;s all you need) traffic through the proxy.<p>(I wrote <a href="https:&#x2F;&#x2F;github.com&#x2F;shadowsocks&#x2F;go-shadowsocks2">https:&#x2F;&#x2F;github.com&#x2F;shadowsocks&#x2F;go-shadowsocks2</a>)</div><br/></div></div></div></div></div></div></div></div><div id="41948705" class="c"><input type="checkbox" id="c-41948705" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#41950191">prev</a><span>|</span><a href="#41949076">next</a><span>|</span><label class="collapse" for="c-41948705">[-]</label><label class="expand" for="c-41948705">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Why TCP over TCP is a bad idea (2001)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25080693">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25080693</a> - Nov 2020 (68 comments)<p><i>Why TCP Over TCP Is a Bad Idea (2001)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9281954">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9281954</a> - March 2015 (43 comments)<p><i>Why TCP Over TCP Is A Bad Idea</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2409090">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=2409090</a> - April 2011 (26 comments)</div><br/></div></div><div id="41949076" class="c"><input type="checkbox" id="c-41949076" checked=""/><div class="controls bullet"><span class="by">Svip</span><span>|</span><a href="#41948705">prev</a><span>|</span><a href="#41952694">next</a><span>|</span><label class="collapse" for="c-41949076">[-]</label><label class="expand" for="c-41949076">[6 more]</label></div><br/><div class="children"><div class="content">I notice that the earliest version of this post[0] is dated 1999, whilst the latest version is modified in 2001 (see the main link).  Which year would be appropriate to mark it on HN?  1999?  2001?<p>[0] <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20000310230940&#x2F;http:&#x2F;&#x2F;sites.inka.de&#x2F;~W1011&#x2F;devel&#x2F;tcp-tcp.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20000310230940&#x2F;http:&#x2F;&#x2F;sites.inka...</a></div><br/><div id="41949695" class="c"><input type="checkbox" id="c-41949695" checked=""/><div class="controls bullet"><span class="by">Shared404</span><span>|</span><a href="#41949076">parent</a><span>|</span><a href="#41949200">next</a><span>|</span><label class="collapse" for="c-41949695">[-]</label><label class="expand" for="c-41949695">[1 more]</label></div><br/><div class="children"><div class="content">IMO the latest update is the best option. Or a syntax like (&lt;original date&gt;, updated &lt;update date&gt;) if the update was not super substantial.</div><br/></div></div><div id="41949200" class="c"><input type="checkbox" id="c-41949200" checked=""/><div class="controls bullet"><span class="by">dmitrygr</span><span>|</span><a href="#41949076">parent</a><span>|</span><a href="#41949695">prev</a><span>|</span><a href="#41952694">next</a><span>|</span><label class="collapse" for="c-41949200">[-]</label><label class="expand" for="c-41949200">[4 more]</label></div><br/><div class="children"><div class="content">sqrt(1999 * 2001)</div><br/><div id="41950021" class="c"><input type="checkbox" id="c-41950021" checked=""/><div class="controls bullet"><span class="by">pif</span><span>|</span><a href="#41949076">root</a><span>|</span><a href="#41949200">parent</a><span>|</span><a href="#41949217">next</a><span>|</span><label class="collapse" for="c-41950021">[-]</label><label class="expand" for="c-41950021">[1 more]</label></div><br/><div class="children"><div class="content">(|1999&gt; + |2001&gt;)*Sqrt(1&#x2F;2)</div><br/></div></div><div id="41949217" class="c"><input type="checkbox" id="c-41949217" checked=""/><div class="controls bullet"><span class="by">schmidtleonard</span><span>|</span><a href="#41949076">root</a><span>|</span><a href="#41949200">parent</a><span>|</span><a href="#41950021">prev</a><span>|</span><a href="#41952694">next</a><span>|</span><label class="collapse" for="c-41949217">[-]</label><label class="expand" for="c-41949217">[2 more]</label></div><br/><div class="children"><div class="content">(1999^-1 + 2001^-1)^-1</div><br/><div id="41949799" class="c"><input type="checkbox" id="c-41949799" checked=""/><div class="controls bullet"><span class="by">exe34</span><span>|</span><a href="#41949076">root</a><span>|</span><a href="#41949217">parent</a><span>|</span><a href="#41952694">next</a><span>|</span><label class="collapse" for="c-41949799">[-]</label><label class="expand" for="c-41949799">[1 more]</label></div><br/><div class="children"><div class="content">2000ish</div><br/></div></div></div></div></div></div></div></div><div id="41952694" class="c"><input type="checkbox" id="c-41952694" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#41949076">prev</a><span>|</span><a href="#41949868">next</a><span>|</span><label class="collapse" for="c-41952694">[-]</label><label class="expand" for="c-41952694">[1 more]</label></div><br/><div class="children"><div class="content">If you are in a situation where you have to anyway, you can use multiple TCP sockets and round robin them (with Nagle off) such that you are always sending just one packet over each.  You&#x27;ll get overhead and some unneeded acks, but no front of line blocking of the second layer of TCP mechanics going on.</div><br/></div></div><div id="41949868" class="c"><input type="checkbox" id="c-41949868" checked=""/><div class="controls bullet"><span class="by">01HNNWZ0MV43FF</span><span>|</span><a href="#41952694">prev</a><span>|</span><a href="#41951562">next</a><span>|</span><label class="collapse" for="c-41949868">[-]</label><label class="expand" for="c-41949868">[8 more]</label></div><br/><div class="children"><div class="content">Port forwarding doesn&#x27;t count, right?</div><br/><div id="41950015" class="c"><input type="checkbox" id="c-41950015" checked=""/><div class="controls bullet"><span class="by">duskwuff</span><span>|</span><a href="#41949868">parent</a><span>|</span><a href="#41950939">next</a><span>|</span><label class="collapse" for="c-41950015">[-]</label><label class="expand" for="c-41950015">[6 more]</label></div><br/><div class="children"><div class="content">Correct, because that doesn&#x27;t transform the TCP stream.<p>&quot;TCP over TCP&quot; specifically means a TCP stream whose payload represents a sequence of TCP packets.</div><br/><div id="41950184" class="c"><input type="checkbox" id="c-41950184" checked=""/><div class="controls bullet"><span class="by">AStonesThrow</span><span>|</span><a href="#41949868">root</a><span>|</span><a href="#41950015">parent</a><span>|</span><a href="#41950939">next</a><span>|</span><label class="collapse" for="c-41950184">[-]</label><label class="expand" for="c-41950184">[5 more]</label></div><br/><div class="children"><div class="content">TCP doesn&#x27;t use &quot;packets&quot;. They&#x27;re called &quot;segments&quot;.</div><br/><div id="41950947" class="c"><input type="checkbox" id="c-41950947" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41949868">root</a><span>|</span><a href="#41950184">parent</a><span>|</span><a href="#41950939">next</a><span>|</span><label class="collapse" for="c-41950947">[-]</label><label class="expand" for="c-41950947">[4 more]</label></div><br/><div class="children"><div class="content">A TCP packet is a pretty common term for an IP packet  containing a TCP segment.<p>VPNs usually forward IP packets, so the usage seems correct to me here.</div><br/><div id="41951228" class="c"><input type="checkbox" id="c-41951228" checked=""/><div class="controls bullet"><span class="by">AStonesThrow</span><span>|</span><a href="#41949868">root</a><span>|</span><a href="#41950947">parent</a><span>|</span><a href="#41950939">next</a><span>|</span><label class="collapse" for="c-41951228">[-]</label><label class="expand" for="c-41951228">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s wrong.<p>&quot;TCP packet&quot; is a pretty common colloquial term which is also factually wrong. There is no such thing as &quot;packet&quot; at the TCP protocol layer.<p>This paper is discussing the tunnelling of payloads with PPP over SSH.<p>You can see in the stacked diagram that &quot;TCP&quot; appears in two layers of the protocol stack, as does IP.<p>Essentially, they&#x27;re encapsulating TCP segments inside other TCP segments, although there are also trappings of IP, PPP, and SSH protocols in-between those.<p>This isn&#x27;t a VPN use case at all. And if a VPN is forwarding IP packets, then it&#x27;s forwarding IP packets.</div><br/><div id="41953393" class="c"><input type="checkbox" id="c-41953393" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41949868">root</a><span>|</span><a href="#41951228">parent</a><span>|</span><a href="#41950939">next</a><span>|</span><label class="collapse" for="c-41953393">[-]</label><label class="expand" for="c-41953393">[2 more]</label></div><br/><div class="children"><div class="content">&quot;TCP packet&quot; is an absolutely correct term.<p>As the previous poster said, a &quot;TCP packet&quot; is not a &quot;TCP segment&quot;.<p>A &quot;TCP packet&quot; is an IP packet that carries some part of the TCP byte stream, i.e. normally some part of one TCP segment.<p>Each &quot;TCP packet&quot; carries its own TCP header, so the division of the TCP segments into TCP packets is visible and significant when you look at a TCP data flow from outside, even if it does not matter internally for the processes that communicate through TCP.<p>There are probably much more people who care about TCP packets than about TCP segments. When you are configuring firewall rules or monitoring network traffic, you are concerned about TCP packets, almost never about TCP segments.</div><br/><div id="41953424" class="c"><input type="checkbox" id="c-41953424" checked=""/><div class="controls bullet"><span class="by">AStonesThrow</span><span>|</span><a href="#41949868">root</a><span>|</span><a href="#41953393">parent</a><span>|</span><a href="#41950939">next</a><span>|</span><label class="collapse" for="c-41953424">[-]</label><label class="expand" for="c-41953424">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s an IP packet. There&#x27;s no such thing as &quot;TCP packets&quot;.<p>IP packets can encapsulate various things depending on how you set their protocol fields. But packets are not TCP. This is quite straightforward. It simply has to do with distinct PDU nomenclature at each layer.<p>You can have Ethernet frames carrying IP packets too, but they are not &quot;Ethernet packets&quot;; that would be absurd.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41950939" class="c"><input type="checkbox" id="c-41950939" checked=""/><div class="controls bullet"><span class="by">lxgr</span><span>|</span><a href="#41949868">parent</a><span>|</span><a href="#41950015">prev</a><span>|</span><a href="#41951562">next</a><span>|</span><label class="collapse" for="c-41950939">[-]</label><label class="expand" for="c-41950939">[1 more]</label></div><br/><div class="children"><div class="content">Port forwarding is TCP &quot;next to&quot; TCP, so that&#x27;s fine, yes!<p>It can even be beneficial in some cases: If a host has an old&#x2F;bad TCP stack not able to deal well with some network situation (latency, packet loss, you name it), port forwarding from a closer&#x2F;less affected host can resolve the issue.<p>Happened to me once for the terrible old eBook delivery server from my public library when a continent away: It handled the long latency so poorly, a 30 MB download would have taken two hours. SSH forwarding brought that down to seconds.</div><br/></div></div></div></div><div id="41951562" class="c"><input type="checkbox" id="c-41951562" checked=""/><div class="controls bullet"><span class="by">some_furry</span><span>|</span><a href="#41949868">prev</a><span>|</span><a href="#41935007">next</a><span>|</span><label class="collapse" for="c-41951562">[-]</label><label class="expand" for="c-41951562">[2 more]</label></div><br/><div class="children"><div class="content">Yes, but what about IPv6 over Amazon S3?<p><a href="https:&#x2F;&#x2F;xeiaso.net&#x2F;blog&#x2F;anything-message-queue&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xeiaso.net&#x2F;blog&#x2F;anything-message-queue&#x2F;</a></div><br/><div id="41951885" class="c"><input type="checkbox" id="c-41951885" checked=""/><div class="controls bullet"><span class="by">bcrl</span><span>|</span><a href="#41951562">parent</a><span>|</span><a href="#41935007">next</a><span>|</span><label class="collapse" for="c-41951885">[-]</label><label class="expand" for="c-41951885">[1 more]</label></div><br/><div class="children"><div class="content">Time to pull RFC 1149: A Standard for the Transmission of IP Datagrams on Avian Carriers.  <a href="https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc1149" rel="nofollow">https:&#x2F;&#x2F;www.rfc-editor.org&#x2F;rfc&#x2F;rfc1149</a></div><br/></div></div></div></div></div></div></div></div></div></body></html>