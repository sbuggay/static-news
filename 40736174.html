<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719133273248" as="style"/><link rel="stylesheet" href="styles.css?v=1719133273248"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jupiter-ace.co.uk/Forth_general_practical_computing8108.html">As you learn Forth, it learns from you (1981)</a> <span class="domain">(<a href="https://jupiter-ace.co.uk">jupiter-ace.co.uk</a>)</span></div><div class="subtext"><span>hggh</span> | <span>54 comments</span></div><br/><div><div id="40760886" class="c"><input type="checkbox" id="c-40760886" checked=""/><div class="controls bullet"><span class="by">asguy</span><span>|</span><a href="#40761086">next</a><span>|</span><label class="collapse" for="c-40760886">[-]</label><label class="expand" for="c-40760886">[23 more]</label></div><br/><div class="children"><div class="content">Programming Forth caused the most massive change in my programming mindset (the LSD of programming languages).  Even more so than Lisp.  Thinking of the rapid rise of the base language to the problem domain (i.e. it&#x27;s a DSL construction kit) opened my eyes to how to design useful and extensible APIs.<p><a href="https:&#x2F;&#x2F;thinking-forth.sourceforge.net" rel="nofollow">https:&#x2F;&#x2F;thinking-forth.sourceforge.net</a> is worth reading, even if you have no desire to ever program any Forth.</div><br/><div id="40761019" class="c"><input type="checkbox" id="c-40761019" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40760886">parent</a><span>|</span><a href="#40761086">next</a><span>|</span><label class="collapse" for="c-40761019">[-]</label><label class="expand" for="c-40761019">[22 more]</label></div><br/><div class="children"><div class="content">What are your main lessons from Forth for API design? Is it something you could summarize?</div><br/><div id="40763733" class="c"><input type="checkbox" id="c-40763733" checked=""/><div class="controls bullet"><span class="by">asguy</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761019">parent</a><span>|</span><a href="#40761566">next</a><span>|</span><label class="collapse" for="c-40763733">[-]</label><label class="expand" for="c-40763733">[1 more]</label></div><br/><div class="children"><div class="content">There have been some great responses that cover the gist of it, but to add a couple more mundane specifics:<p>- Build up the thinnest abstraction that lets you express a solution in the problem domain.<p>- Allow the API user to express their intent, and not be focused on mechanics they don&#x27;t need to understand to get the job done.<p>- Focus on getting the interfaces right before the implementation is perfect.<p>- A clean interface will allow you to make drastic changes to the implementation without the API consumer becoming aware.</div><br/></div></div><div id="40761566" class="c"><input type="checkbox" id="c-40761566" checked=""/><div class="controls bullet"><span class="by">diffxx</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761019">parent</a><span>|</span><a href="#40763733">prev</a><span>|</span><a href="#40761177">next</a><span>|</span><label class="collapse" for="c-40761566">[-]</label><label class="expand" for="c-40761566">[4 more]</label></div><br/><div class="children"><div class="content">Not the OP, but for me one of the main lessons from Forth is that the boundary between high and low level code can be as thin as you make it. With Forth, you can define high level words using low level primitive words. You then weave these low level words together at a high level. After you have written a correct solution at a high level, bottlenecks can be optimized out by introducing new low level words. It&#x27;s like you are solving a problem by designing an instruction set specifically for that problem. But unlike a hardware ISA, you can add new instructions tailor made for the specific problem you are presently solving.<p>Paul Graham has described lisp as a tool for writing fast programs fast (that&#x27;s the gist at least). IIRC, he clarifies that each fast is a phase. Lisp allows you to write a fast, high level, prototype that might have poor runtime performance and then you refine the prototype so that the compiler can generate fast machine code.<p>Forth is similar but feels closer to the machine than Lisp because of the stack based threading model. In Forth, you often don&#x27;t need manual memory management _or_ garbage collection and you can easily extend the system with new low level words. But it does require you to think differently about your program design so that it fits the stack based vm model.<p>Historically, Forth has been implemented in assembly but you can write a Forth that targets any host. The truly mind expanding thing is that you, an individual, can write a Forth compiler and you can also write it in such a way that it has multiple targets. For example, you can generate native, jvm and js targets from the same underlying source. Usually this can be done by translating the forth generated AST to source code for another high level language. This allows you to write a fast high level language quickly without getting bogged down in writing, say, fast x86 codegen or a garbage collector. To get started, you just target the host language with the best high level properties that you need (which will be problem and context specific). I don&#x27;t enjoy writing c, but I have no problem translating to c if I need to for performance or for syscall access.<p>To illustrate the practical power of this. Suppose that you have an important subcomponent of your system that was written in, say, Node.js. It turns out that this is a critical bottleneck that cannot easily be optimized in javascript. You don&#x27;t want to rewrite the whole system, but you do want to rewrite that component and have it seamlessly interoperate with the existing system. You could write a small Forth DSL for that subcomponent. This Forth will target javascript initially. You translate the subcomponent into Forth and reuse all of the existing tests (that were presumably also written in javascript). Then you rewrite the tests in Forth so that the entire subcomponent is now written in Forth. Now you write a new backend that translates to say, c or rust with node bindings. You can run the native implementation against a native implementation of the test suite since they&#x27;re both written in high level Forth at this point. Then you can flip the switch between the native or javascript implementations and be confident that both implementations are identical because they have the same high level description.<p>Once you start seeing things this way though, you start realizing that you can write Forth style code in any language (and the reverse is also true). Forth is as much about a process for solving programming problems as it is a specific, concrete language. This is also why there is the old adage &quot;once you&#x27;ve seen one Forth, you&#x27;ve seen one Forth.&quot;</div><br/><div id="40765213" class="c"><input type="checkbox" id="c-40765213" checked=""/><div class="controls bullet"><span class="by">8bitsrule</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761566">parent</a><span>|</span><a href="#40762579">next</a><span>|</span><label class="collapse" for="c-40765213">[-]</label><label class="expand" for="c-40765213">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t use FORTH long, maybe for a year, (back when 8080s were The Thing), but I remember my first reaction (after learning about Reverse Polish) to it: it was like using assembly language, but without the pain.<p>(Moved to 6502; don&#x27;t recall having a version for that.)</div><br/></div></div><div id="40762579" class="c"><input type="checkbox" id="c-40762579" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761566">parent</a><span>|</span><a href="#40765213">prev</a><span>|</span><a href="#40761177">next</a><span>|</span><label class="collapse" for="c-40762579">[-]</label><label class="expand" for="c-40762579">[2 more]</label></div><br/><div class="children"><div class="content">I think a lot of recent Forths (at least outside of the embedded space) have been written in C or C++ rather than assembly now that the processors are incredibly complicated. Of course, you can write forth on anything including the JVM or in Python...etc.</div><br/><div id="40765426" class="c"><input type="checkbox" id="c-40765426" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40762579">parent</a><span>|</span><a href="#40761177">next</a><span>|</span><label class="collapse" for="c-40765426">[-]</label><label class="expand" for="c-40765426">[1 more]</label></div><br/><div class="children"><div class="content">I think jonesforth is the most popular implementation teaching implementation: <a href="https:&#x2F;&#x2F;github.com&#x2F;nornagon&#x2F;jonesforth&#x2F;blob&#x2F;master&#x2F;jonesforth.S">https:&#x2F;&#x2F;github.com&#x2F;nornagon&#x2F;jonesforth&#x2F;blob&#x2F;master&#x2F;jonesfort...</a><p>Factor might be a counterexample if one considers it a Forth, the VM is in part implemented in C++: <a href="https:&#x2F;&#x2F;github.com&#x2F;factor&#x2F;factor">https:&#x2F;&#x2F;github.com&#x2F;factor&#x2F;factor</a><p>I think it&#x27;s portability and ease of development rather than CPU architecture complexity that makes someone pick C&#x2F;C++ over assembly when implementing a Forth system. Because the Forth won&#x27;t need much of the assembly language or obscure CPU instructions, the complexity of the architecture won&#x27;t really matter to whoever is implementing it.</div><br/></div></div></div></div></div></div><div id="40761177" class="c"><input type="checkbox" id="c-40761177" checked=""/><div class="controls bullet"><span class="by">saulpw</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761019">parent</a><span>|</span><a href="#40761566">prev</a><span>|</span><a href="#40761086">next</a><span>|</span><label class="collapse" for="c-40761177">[-]</label><label class="expand" for="c-40761177">[16 more]</label></div><br/><div class="children"><div class="content">They just said it was like the LSD of programming languages.  Your question is kind of like &quot;What are your main takeaways from LSD?  Can you summarize?&quot; which realllly misses the point.</div><br/><div id="40761244" class="c"><input type="checkbox" id="c-40761244" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761177">parent</a><span>|</span><a href="#40761572">next</a><span>|</span><label class="collapse" for="c-40761244">[-]</label><label class="expand" for="c-40761244">[10 more]</label></div><br/><div class="children"><div class="content">I don’t think so. There are many ways to describe how a mind altering experience with LSD would change how you relate to yourself and your environment. I am curious how Forth changed parent’s approach to programming.</div><br/><div id="40765585" class="c"><input type="checkbox" id="c-40765585" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761244">parent</a><span>|</span><a href="#40761334">next</a><span>|</span><label class="collapse" for="c-40765585">[-]</label><label class="expand" for="c-40765585">[1 more]</label></div><br/><div class="children"><div class="content">You can describe LSD, or a novel programming paradigm, just as well as you can describe Beethoven&#x27;s 5th symphony in words.<p>The amount of lost bits of information makes the explanation totally worthless, even though you technically can explain it. The point is it&#x27;s a waste of time. You won&#x27;t understand LSD, Beethoven or Forth until you have tried them.</div><br/></div></div><div id="40761334" class="c"><input type="checkbox" id="c-40761334" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761244">parent</a><span>|</span><a href="#40765585">prev</a><span>|</span><a href="#40761572">next</a><span>|</span><label class="collapse" for="c-40761334">[-]</label><label class="expand" for="c-40761334">[8 more]</label></div><br/><div class="children"><div class="content">Probably in a similar way to learning Haskell, assembly, Erlang, data-oriented design, 4k demo programming, or any other thing that is unconventional enough that your normal patterns don&#x27;t work and you are forced to expand the set of ways you know how to program.</div><br/><div id="40761492" class="c"><input type="checkbox" id="c-40761492" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761334">parent</a><span>|</span><a href="#40761450">next</a><span>|</span><label class="collapse" for="c-40761492">[-]</label><label class="expand" for="c-40761492">[4 more]</label></div><br/><div class="children"><div class="content">Not OP, but I would only partially agree with that statement. Sure, learning all those things is mind altering. If you only know Java or Python...Haskell is very unusual.<p>However, the Forth experience and reading about legends like Chuck Moore (at least for myself), just gave me this feeling that most of our problems come from software bloat and having these infinite abstraction levels where nobody ever truly understands what in the world is going on anymore. Such a system is ironically more efficient from a developer&#x27;s perspective (at least until you run into weird bugs and edge cases) as developers just basically glue together libraries and only need surface level understanding to get something running. Another option might be to design your own hardware and then a simple forth system on top of that which exactly solves the problem and nothing else. The implementor would have laser level understanding of the design choices. Of course, there are other issues such as how to maintain such a unicorn, even if it is beautiful and elegant. Today, we have lovecraftian horrors with huge swaths of people working together to keep all the abstraction levels working together and hope there aren&#x27;t any leftpad incidents.</div><br/><div id="40762101" class="c"><input type="checkbox" id="c-40762101" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761492">parent</a><span>|</span><a href="#40764213">next</a><span>|</span><label class="collapse" for="c-40762101">[-]</label><label class="expand" for="c-40762101">[2 more]</label></div><br/><div class="children"><div class="content">&gt;having these infinite abstraction levels where nobody ever truly understands what in the world is going on anymore<p>s&#x2F;infinite abstraction levels&#x2F;Rube Goldberg contraptions&#x2F;</div><br/><div id="40762198" class="c"><input type="checkbox" id="c-40762198" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40762101">parent</a><span>|</span><a href="#40764213">next</a><span>|</span><label class="collapse" for="c-40762198">[-]</label><label class="expand" for="c-40762198">[1 more]</label></div><br/><div class="children"><div class="content">Lol. Probably a more apt description.</div><br/></div></div></div></div><div id="40764213" class="c"><input type="checkbox" id="c-40764213" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761492">parent</a><span>|</span><a href="#40762101">prev</a><span>|</span><a href="#40761450">next</a><span>|</span><label class="collapse" for="c-40764213">[-]</label><label class="expand" for="c-40764213">[1 more]</label></div><br/><div class="children"><div class="content">Low level &quot;machine sympathetic&quot; programming is just one type. If you restrict yourself to it, you&#x27;ll be no better than the programmer who&#x27;s restricted to any other type. All these abstractions didn&#x27;t spring out of nowhere - in many cases they make for very flexible software that is cheap to create. Go learn both ends. And the middle. And the weird outliers.</div><br/></div></div></div></div><div id="40761450" class="c"><input type="checkbox" id="c-40761450" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761334">parent</a><span>|</span><a href="#40761492">prev</a><span>|</span><a href="#40761572">next</a><span>|</span><label class="collapse" for="c-40761450">[-]</label><label class="expand" for="c-40761450">[3 more]</label></div><br/><div class="children"><div class="content">This is both vague and speculative though. Vague because you have made no specific claims that could be evaluated one way or the other. Speculative because you have said nothing about Forth.<p>You cannot make engineering decisions based on &quot;it&#x27;ll change how you program.&quot; There are several concrete examples of turning imperative code into pure monadic code that contains less boilerplate and is less noisy with Haskell&#x27;s do notation. Exhaustiveness checking, encoding invariants in types, those all have good examples that one can read and agree or disagree with. Surely there are concrete examples that one can give about Forth too?</div><br/><div id="40765682" class="c"><input type="checkbox" id="c-40765682" checked=""/><div class="controls bullet"><span class="by">saulpw</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761450">parent</a><span>|</span><a href="#40762998">next</a><span>|</span><label class="collapse" for="c-40765682">[-]</label><label class="expand" for="c-40765682">[1 more]</label></div><br/><div class="children"><div class="content">The creator of Forth wrote this:<p>&gt; I wish I knew what to tell you that would lead you to write good Forth. I can demonstrate. I have demonstrated in the past, ad nauseam, applications where I can reduce the amount of code by 90% percent and in some cases 99%. It can be done, but in a case by case basis. The general principle still eludes me. -- Chuck Moore<p><a href="https:&#x2F;&#x2F;www.ultratechnology.com&#x2F;moore4th.htm" rel="nofollow">https:&#x2F;&#x2F;www.ultratechnology.com&#x2F;moore4th.htm</a><p>You might appreciate other quotes from the above page.</div><br/></div></div><div id="40762998" class="c"><input type="checkbox" id="c-40762998" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761450">parent</a><span>|</span><a href="#40765682">prev</a><span>|</span><a href="#40761572">next</a><span>|</span><label class="collapse" for="c-40762998">[-]</label><label class="expand" for="c-40762998">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s metaphysical. Like learning a foreign language widen your perspective. It&#x27;s a particular insight you gain about the act of programming that makes you realize that you&#x27;ve been boxing yourself to a very small imperative&#x2F;oop space.<p>Writing C code feels like writing a rule book, writing java feels like designing a lego set, writing lisp feels like writing proof, writing prolog feels like writing puzzles. Writing forth feels like writing a dictionary, then after that you write a few sentences. They&#x27;re different feeling, but forth is one of the most flexible as you can go up and down from the most basic units to the high level ones. As another comment has mentioned, you can program forth where the basic units are elements from another language, and construct a dsl&#x2F;dictionary out of it. Then switch the basic units while retaining your business logic for a faster implementation without a full rewrite.</div><br/></div></div></div></div></div></div></div></div><div id="40761572" class="c"><input type="checkbox" id="c-40761572" checked=""/><div class="controls bullet"><span class="by">LudwigNagasena</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761177">parent</a><span>|</span><a href="#40761244">prev</a><span>|</span><a href="#40761292">next</a><span>|</span><label class="collapse" for="c-40761572">[-]</label><label class="expand" for="c-40761572">[1 more]</label></div><br/><div class="children"><div class="content">API design is something relatively concrete though. One can provide examples of pre-Forth and post-Forth design.</div><br/></div></div><div id="40761292" class="c"><input type="checkbox" id="c-40761292" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761177">parent</a><span>|</span><a href="#40761572">prev</a><span>|</span><a href="#40761086">next</a><span>|</span><label class="collapse" for="c-40761292">[-]</label><label class="expand" for="c-40761292">[4 more]</label></div><br/><div class="children"><div class="content">Several literary careers have been made on summarizing the main takeaways from LSD.</div><br/><div id="40761475" class="c"><input type="checkbox" id="c-40761475" checked=""/><div class="controls bullet"><span class="by">klyrs</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761292">parent</a><span>|</span><a href="#40761342">next</a><span>|</span><label class="collapse" for="c-40761475">[-]</label><label class="expand" for="c-40761475">[2 more]</label></div><br/><div class="children"><div class="content">In my experience, the value of a trip isn&#x27;t what you take away from it; it&#x27;s the things that you can&#x27;t take with you.  Nobody really wants to see a whole slideshow of your vacation photos; it&#x27;ll never compare to being there.</div><br/><div id="40765614" class="c"><input type="checkbox" id="c-40765614" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761475">parent</a><span>|</span><a href="#40761342">next</a><span>|</span><label class="collapse" for="c-40765614">[-]</label><label class="expand" for="c-40765614">[1 more]</label></div><br/><div class="children"><div class="content">There is a large contingent of people that claim to know about X because they read a good book on it, which is ludicrous nonsense. Indeed the most unique things of any experience is what you cannot put into words.<p>Language is a very lossy compression algorithm, and some concepts aren&#x27;t even computable in the first place (i.e feeling and emotions)</div><br/></div></div></div></div><div id="40761342" class="c"><input type="checkbox" id="c-40761342" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40760886">root</a><span>|</span><a href="#40761292">parent</a><span>|</span><a href="#40761475">prev</a><span>|</span><a href="#40761086">next</a><span>|</span><label class="collapse" for="c-40761342">[-]</label><label class="expand" for="c-40761342">[1 more]</label></div><br/><div class="children"><div class="content">If several literary careers have been made summarizing it, and it still is not adequately summarized, that proves the point.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40761086" class="c"><input type="checkbox" id="c-40761086" checked=""/><div class="controls bullet"><span class="by">detourdog</span><span>|</span><a href="#40760886">prev</a><span>|</span><a href="#40765297">next</a><span>|</span><label class="collapse" for="c-40761086">[-]</label><label class="expand" for="c-40761086">[1 more]</label></div><br/><div class="children"><div class="content">Here is a link to the byte magazine issue that inspired the above article.
<a href="https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;byte-magazine-1980-08&#x2F;page&#x2F;n2&#x2F;mode&#x2F;1up" rel="nofollow">https:&#x2F;&#x2F;archive.org&#x2F;details&#x2F;byte-magazine-1980-08&#x2F;page&#x2F;n2&#x2F;mo...</a></div><br/></div></div><div id="40765297" class="c"><input type="checkbox" id="c-40765297" checked=""/><div class="controls bullet"><span class="by">simplify</span><span>|</span><a href="#40761086">prev</a><span>|</span><a href="#40761619">next</a><span>|</span><label class="collapse" for="c-40765297">[-]</label><label class="expand" for="c-40765297">[2 more]</label></div><br/><div class="children"><div class="content">Are there any Forth variants that have static typing? Or more generally, are there any interesting type systems that target stack-based machines?</div><br/><div id="40765447" class="c"><input type="checkbox" id="c-40765447" checked=""/><div class="controls bullet"><span class="by">cess11</span><span>|</span><a href="#40765297">parent</a><span>|</span><a href="#40761619">next</a><span>|</span><label class="collapse" for="c-40765447">[-]</label><label class="expand" for="c-40765447">[1 more]</label></div><br/><div class="children"><div class="content">Forth has integers and that&#x27;s about it. You can have words that interpret the integers and e.g. show you characters instead, but it&#x27;s usually just a thin cover over the numbers.<p>The JVM is stack-based and static typing rather common in the languages that runs on it.<p>Factor has dynamic typing, though I haven&#x27;t thought much about that, it kind of stays in the background. It&#x27;s more a tool for problem solving than a description of some type theory: <a href="https:&#x2F;&#x2F;factorcode.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;factorcode.org&#x2F;</a></div><br/></div></div></div></div><div id="40761619" class="c"><input type="checkbox" id="c-40761619" checked=""/><div class="controls bullet"><span class="by">aquariusDue</span><span>|</span><a href="#40765297">prev</a><span>|</span><a href="#40761123">next</a><span>|</span><label class="collapse" for="c-40761619">[-]</label><label class="expand" for="c-40761619">[1 more]</label></div><br/><div class="children"><div class="content">For people interested in Forth I think this is a nice intro: <a href="https:&#x2F;&#x2F;ratfactor.com&#x2F;forth&#x2F;the_programming_language_that_writes_itself.html" rel="nofollow">https:&#x2F;&#x2F;ratfactor.com&#x2F;forth&#x2F;the_programming_language_that_wr...</a></div><br/></div></div><div id="40761123" class="c"><input type="checkbox" id="c-40761123" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#40761619">prev</a><span>|</span><a href="#40761509">next</a><span>|</span><label class="collapse" for="c-40761123">[-]</label><label class="expand" for="c-40761123">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a vintage computer collector and the Jupiter Ace would be the holy grail of my collection. Has anyone seen one in real life?</div><br/><div id="40761692" class="c"><input type="checkbox" id="c-40761692" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#40761123">parent</a><span>|</span><a href="#40764257">next</a><span>|</span><label class="collapse" for="c-40761692">[-]</label><label class="expand" for="c-40761692">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s one in the Cambridge computer museum: <a href="https:&#x2F;&#x2F;www.computinghistory.org.uk&#x2F;det&#x2F;1332&#x2F;Jupiter-Ace&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.computinghistory.org.uk&#x2F;det&#x2F;1332&#x2F;Jupiter-Ace&#x2F;</a><p>Steve Vickers, one of the founders of Jupiter Cantab, was my university lecturer back in the 90s.  He taught a very obscure course in mathematical structures, and in a sense was both the first and last (a decade and a half later) to teach me computer science.  Previous comments: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23760382">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=23760382</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26375986">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26375986</a></div><br/></div></div><div id="40764257" class="c"><input type="checkbox" id="c-40764257" checked=""/><div class="controls bullet"><span class="by">mhandley</span><span>|</span><a href="#40761123">parent</a><span>|</span><a href="#40761692">prev</a><span>|</span><a href="#40761718">next</a><span>|</span><label class="collapse" for="c-40764257">[-]</label><label class="expand" for="c-40764257">[2 more]</label></div><br/><div class="children"><div class="content">A Jupiter Ace was my second computer, when I was 14 or 15, after a Sinclair ZX81.  Great little computer, but compared to the Spectrum that came out around the same time, it had a worse keyboard, only black and white graphics and 3KB of RAM.  Because it used Forth, you could do quite a lot in 3KB, but it was still a bit limiting.  I think mine was a very early one, because it had some added soldered wires on the board, correcting some errors.<p>Mine got modified quite a bit over the next couple of years.  Extra RAM.  Some dumpster diving got me several keypads with good quality keys.  I took them apart and made a proper keyboard to replace the original dead rubber monstrosity.<p>I made a parallel I&#x2F;O port out of TTL logic and veroboard. And then temporarily my Ace rode about on the top of a fairly flaky micromouse exploring mazes. It didn&#x27;t win any prizes but it did get me an A in O-level Technology.<p>My school was throwing out an old teletype, so I scavenged that.   Then I modified the parallel I&#x2F;O port to output +&#x2F;- 12V on one pin, and wrote software to bit-bang RS232 at 110 baud.  Back before the Internet, just finding the specs for RS232 was not so simple - our local library was a bit limited in that way - but I got there in the end.  A lot of guesswork and trial and error.  I don&#x27;t think anyone made a printer for the Ace, so I may have had the only one.  Being able to print code listings really helped.<p>The first summer I wrote a whole load of games, mostly in Forth, but sometimes Forth just wasn&#x27;t fast enough.  I got a copy of &quot;Mastering Machine Code on Your ZX81&quot;, and learned Z80 machine code.   If there was an assembler available, I didn&#x27;t have it, so this was all hand-assembled.  Getting jumps right was a total pain, as was debugging.  Generally, it either worked first time, or you started from scratch again.  Usually I got there in the end.<p>I sold those games through a ad in &quot;Your Computer&quot; magazine, and earned back the price of the computer several times.  But recording and shipping tapes one at a time got tedious really fast, so I didn&#x27;t take that any further.<p>Somewhere over the years, with my parents moving house multiple times, the Ace disappeared.  Many years later, I found one on Ebay, and still have it.  But somehow I never fell back in love with it - it just wasn&#x27;t as good as I remembered my one rather non-stock one being at that formative time in my life.</div><br/><div id="40765278" class="c"><input type="checkbox" id="c-40765278" checked=""/><div class="controls bullet"><span class="by">8bitsrule</span><span>|</span><a href="#40761123">root</a><span>|</span><a href="#40764257">parent</a><span>|</span><a href="#40761718">next</a><span>|</span><label class="collapse" for="c-40765278">[-]</label><label class="expand" for="c-40765278">[1 more]</label></div><br/><div class="children"><div class="content">Oh man, those were fun times. I started with a Model 15 TTY (for ham radio). When I got my first 8080 machine (statuc RAM was an expensive extra), I learned a lot by making a PC board to convert 45bps (5-bit characters) to 110bps Baudot (using 2 crystals). Then teaching the 8080 to table-convert baudot to ASCII (from a &#x27;ring buffer&#x27; filled using interrupts).<p>The good old days, before layers of &#x27;protection&#x27; got baked in (Apple II vs Mac).</div><br/></div></div></div></div><div id="40761718" class="c"><input type="checkbox" id="c-40761718" checked=""/><div class="controls bullet"><span class="by">renewedrebecca</span><span>|</span><a href="#40761123">parent</a><span>|</span><a href="#40764257">prev</a><span>|</span><a href="#40762416">next</a><span>|</span><label class="collapse" for="c-40761718">[-]</label><label class="expand" for="c-40761718">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen one once at a HamFest or something.<p>There are kits out there to make your own though:<p><a href="https:&#x2F;&#x2F;www.tfw8b.com&#x2F;product&#x2F;minstrel-4d-turbo-jupiter-ace-compatible-computer-kit&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tfw8b.com&#x2F;product&#x2F;minstrel-4d-turbo-jupiter-ace-...</a></div><br/></div></div><div id="40762416" class="c"><input type="checkbox" id="c-40762416" checked=""/><div class="controls bullet"><span class="by">olvn</span><span>|</span><a href="#40761123">parent</a><span>|</span><a href="#40761718">prev</a><span>|</span><a href="#40761603">next</a><span>|</span><label class="collapse" for="c-40762416">[-]</label><label class="expand" for="c-40762416">[2 more]</label></div><br/><div class="children"><div class="content">several on ebay, here&#x27;s one:<p><a href="https:&#x2F;&#x2F;www.ebay.com&#x2F;itm&#x2F;115272079823?itmmeta=01J10WB15JY1KFBCPX0JPRGAK3&amp;hash=item1ad6c059cf:g:DiUAAOSwArliHKaL&amp;itmprp=enc%3AAQAJAAAA8E8We0Yvs9BKet8CHAggS1jcNGqzZR34NN89fxJZkqXXAjkUGdA%2BgBjYnmCQmrZ94tY583arlPJiRkrLotZhxOmrBBNmqCZu6PWUaWLLzeNc%2Frs1nS52AinFhofLxB0rtjViXZACy8uqwTIaabiA6vxxXlLZfbxfuj%2F2a7P4imcQxGlaBVSPws7XRoF%2B%2BBMcLMrsDCjGGrdZ0LHdbTKkXG43JQPmAuiPklVdpw8qEl3jnUPum4x87SqwKOVB1gY0AjfeJJIErwvrkYYd1mUEL1LwWSrEJSmLLWvTByK4rWvzBA6Tt%2BZFjHJLUih7JwEx6g%3D%3D%7Ctkp%3ABk9SR_CSrJyIZA" rel="nofollow">https:&#x2F;&#x2F;www.ebay.com&#x2F;itm&#x2F;115272079823?itmmeta=01J10WB15JY1KF...</a></div><br/><div id="40764565" class="c"><input type="checkbox" id="c-40764565" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#40761123">root</a><span>|</span><a href="#40762416">parent</a><span>|</span><a href="#40761603">next</a><span>|</span><label class="collapse" for="c-40764565">[-]</label><label class="expand" for="c-40764565">[1 more]</label></div><br/><div class="children"><div class="content">For only 1600 pounds.</div><br/></div></div></div></div><div id="40761603" class="c"><input type="checkbox" id="c-40761603" checked=""/><div class="controls bullet"><span class="by">tengwar2</span><span>|</span><a href="#40761123">parent</a><span>|</span><a href="#40762416">prev</a><span>|</span><a href="#40761676">next</a><span>|</span><label class="collapse" for="c-40761603">[-]</label><label class="expand" for="c-40761603">[6 more]</label></div><br/><div class="children"><div class="content">Do you have any OpenBoot&#x2F;OpenFirmware machines like the Sun4 or early SPARCstations? I was wondering what they were like as pure Forth machines.</div><br/><div id="40762478" class="c"><input type="checkbox" id="c-40762478" checked=""/><div class="controls bullet"><span class="by">adrianmonk</span><span>|</span><a href="#40761123">root</a><span>|</span><a href="#40761603">parent</a><span>|</span><a href="#40764334">prev</a><span>|</span><a href="#40762125">next</a><span>|</span><label class="collapse" for="c-40762478">[-]</label><label class="expand" for="c-40762478">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a Forth programmer, but I used to be a Sun sysadmin. From what I recall, the Forth code on a SPARCstation is interpreted and pretty slow.<p>These docs support that: <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E19455-01&#x2F;816-1177-10&#x2F;816-1177-10.pdf" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;cd&#x2F;E19455-01&#x2F;816-1177-10&#x2F;816-1177-10...</a><p>The system supports FCode, which is processor-independent byte code. This allows expansion devices (like a card or peripheral) to bring with them their own platform-independent device drivers, which is pretty cool. So you could make a disk controller card and then any system that you plug it into could boot off it, no matter the CPU architecture.<p>Anyway, the point is, since it was mainly used for booting and diagnostics, I don&#x27;t think they put much effort into performance. For it to be an actually good Forth environment, I think you&#x27;d want to have some way to run Forth programs as native code, either by adding the option to JIT the FCode instead of interpreting it or by adding a compiler that compiles Forth source to native.<p>Also, I believe the old PowerPC Macs (like G3, G4, and G5) used Open Firmware, so if you wanted this Forth experience, you have that option in addition to Sun workstations.</div><br/><div id="40765398" class="c"><input type="checkbox" id="c-40765398" checked=""/><div class="controls bullet"><span class="by">mlyle</span><span>|</span><a href="#40761123">root</a><span>|</span><a href="#40762478">parent</a><span>|</span><a href="#40762691">next</a><span>|</span><label class="collapse" for="c-40765398">[-]</label><label class="expand" for="c-40765398">[1 more]</label></div><br/><div class="children"><div class="content">The text mode on the framebuffer was terrible on most machines, too.<p>Still, stop-a and then e.g.  3719 824 + 53 * .    when you needed a little bit of arithmetic help was always a possibility ;)</div><br/></div></div><div id="40762691" class="c"><input type="checkbox" id="c-40762691" checked=""/><div class="controls bullet"><span class="by">tengwar2</span><span>|</span><a href="#40761123">root</a><span>|</span><a href="#40762478">parent</a><span>|</span><a href="#40765398">prev</a><span>|</span><a href="#40762125">next</a><span>|</span><label class="collapse" for="c-40762691">[-]</label><label class="expand" for="c-40762691">[1 more]</label></div><br/><div class="children"><div class="content">The G4 did indeed support Open Firmware: I had an MDD.</div><br/></div></div></div></div><div id="40762125" class="c"><input type="checkbox" id="c-40762125" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#40761123">root</a><span>|</span><a href="#40761603">parent</a><span>|</span><a href="#40762478">prev</a><span>|</span><a href="#40761676">next</a><span>|</span><label class="collapse" for="c-40762125">[-]</label><label class="expand" for="c-40762125">[1 more]</label></div><br/><div class="children"><div class="content">Mitch Bradley was the author of a great deal of that Forth; his CForth is on GitHub : <a href="https:&#x2F;&#x2F;github.com&#x2F;MitchBradley&#x2F;cforth">https:&#x2F;&#x2F;github.com&#x2F;MitchBradley&#x2F;cforth</a><p>(It might be easier than finding an old Sun machine)</div><br/></div></div></div></div><div id="40761676" class="c"><input type="checkbox" id="c-40761676" checked=""/><div class="controls bullet"><span class="by">paulb73</span><span>|</span><a href="#40761123">parent</a><span>|</span><a href="#40761603">prev</a><span>|</span><a href="#40761509">next</a><span>|</span><label class="collapse" for="c-40761676">[-]</label><label class="expand" for="c-40761676">[1 more]</label></div><br/><div class="children"><div class="content">At my local fine-fare (80s uk superstore) they sold computers in a &#x27;concession&#x27; stand.<p>They sold Jupiter Aces. Wish I had the money back then to get one!</div><br/></div></div></div></div><div id="40761509" class="c"><input type="checkbox" id="c-40761509" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#40761123">prev</a><span>|</span><a href="#40765068">next</a><span>|</span><label class="collapse" for="c-40761509">[-]</label><label class="expand" for="c-40761509">[11 more]</label></div><br/><div class="children"><div class="content">When I read old articles like this, I start wondering what the story was behind all those companies mentioned.  Stackworks Forth, Alan Ashley Assembler.  You almost never hear of a company which is still around.<p>Was it actually possible, back then, to make a living selling Forth for CP&#x2F;M computers?   Or Assemblers?   Did Stackworks have an office, with a jaded-looking middle-aged secretary who put out her cigarettes in an ashtray on her desk, before she picked up when the phone rang?  A glad-handling salesman who came back to the office every few weeks before going out to sell?<p>I don&#x27;t think it has been possible to sell a compiler which isn&#x27;t a loss-leader in a bundle for what, 30 years?<p>Or were these side hustles?   Alan Ashley, was his day job being a math teacher or something, and he did this to round out his budget?<p>The industry was a heck of a lot smaller back then, but these old articles mention way more different companies.  Seems like before all these behemoth monopolies there was a lot more air to breathe.</div><br/><div id="40764562" class="c"><input type="checkbox" id="c-40764562" checked=""/><div class="controls bullet"><span class="by">ralphc</span><span>|</span><a href="#40761509">parent</a><span>|</span><a href="#40762669">next</a><span>|</span><label class="collapse" for="c-40764562">[-]</label><label class="expand" for="c-40764562">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;70s and &#x27;80s you would advertise in computer magazines. At the bottom of each ad as a little number, and in the magazine was a tear-out postcard that went back to the magazine. The postcard was filled with little numbers; you would circle the number associated with and ad, and the company would send you information about their company, price lists, etc.<p>The &#x27;70s and early &#x27;80s, it was CP&#x2F;M, TRS-80, Apple ][ software. By the mid &#x27;80s and into the early &#x27;90s it was all one-person shops that were making custom UI controls for Windows 3.1. Tree and list controls were popular, plus some database connectors. By this time there were small companies making C++ libraries to make Windows programming easier, I remember Zinc and Zapp. They were wiped out when Visual C++ came out with Microsoft Foundation Classes.</div><br/></div></div><div id="40762669" class="c"><input type="checkbox" id="c-40762669" checked=""/><div class="controls bullet"><span class="by">cgh</span><span>|</span><a href="#40761509">parent</a><span>|</span><a href="#40764562">prev</a><span>|</span><a href="#40763717">next</a><span>|</span><label class="collapse" for="c-40762669">[-]</label><label class="expand" for="c-40762669">[2 more]</label></div><br/><div class="children"><div class="content">The first developer tool I ever bought was Develop-64, an assembler for the Commodore 64 by a company called French Silk software. I was around thirteen years old and I figured this was some big professional company. Much later, I realised it was basically one guy and there was no way this was a full-time job. I think these tiny shops were pretty common back then, basically hobbyists trying to monetise their creations.</div><br/><div id="40765422" class="c"><input type="checkbox" id="c-40765422" checked=""/><div class="controls bullet"><span class="by">8bitsrule</span><span>|</span><a href="#40761509">root</a><span>|</span><a href="#40762669">parent</a><span>|</span><a href="#40763717">next</a><span>|</span><label class="collapse" for="c-40765422">[-]</label><label class="expand" for="c-40765422">[1 more]</label></div><br/><div class="children"><div class="content">At the same time, disassemblers were handy tools for figuring out how things were done. Could be very learnful. Then they mysteriously went away for some reason.</div><br/></div></div></div></div><div id="40763717" class="c"><input type="checkbox" id="c-40763717" checked=""/><div class="controls bullet"><span class="by">spc476</span><span>|</span><a href="#40761509">parent</a><span>|</span><a href="#40762669">prev</a><span>|</span><a href="#40761741">next</a><span>|</span><label class="collapse" for="c-40763717">[-]</label><label class="expand" for="c-40763717">[1 more]</label></div><br/><div class="children"><div class="content">I knew some acquaintances back in the day (late 80s&#x2F;early 90s) who had a company selling X servers.  It wasn&#x27;t a big operation (maybe half a dozen people total) and it worked out of a small office in the industrial section of Ft. Lauderdale (a fairly seedy looking neighborhood to say the least).  But they made a decent living for maybe a decade or so and had some fairly big customers.</div><br/></div></div><div id="40761741" class="c"><input type="checkbox" id="c-40761741" checked=""/><div class="controls bullet"><span class="by">tengwar2</span><span>|</span><a href="#40761509">parent</a><span>|</span><a href="#40763717">prev</a><span>|</span><a href="#40762140">next</a><span>|</span><label class="collapse" for="c-40761741">[-]</label><label class="expand" for="c-40761741">[2 more]</label></div><br/><div class="children"><div class="content">It would depend on the generation of CP&#x2F;M. CP&#x2F;M 1.0 and 1.1 had Gary Kildall dealing with it when he came off duty from a nuclear submarine. CBASIC (from Compiler Systems aka Gordon Eubanks) dated from the same period and was also a part time activity for a nuclear sailor. CP&#x2F;M 3.0 was mature - you had a lot of professional compiler companies like Prospero, Borland, FTL, and  HiSoft, but by that stage. Some of them, like Prospero and HiSoft dated back to the CP&#x2F;M 2.2 era, and I got the impression that they had three or four staff.</div><br/><div id="40762132" class="c"><input type="checkbox" id="c-40762132" checked=""/><div class="controls bullet"><span class="by">rhelz</span><span>|</span><a href="#40761509">root</a><span>|</span><a href="#40761741">parent</a><span>|</span><a href="#40762140">next</a><span>|</span><label class="collapse" for="c-40762132">[-]</label><label class="expand" for="c-40762132">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the view back into history.  I was kinda under the impression that this side-hustle thing was new.  Apparently its not only old, but was an essential part of the technological progress we&#x27;ve had since then.</div><br/></div></div></div></div><div id="40762140" class="c"><input type="checkbox" id="c-40762140" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#40761509">parent</a><span>|</span><a href="#40761741">prev</a><span>|</span><a href="#40761633">next</a><span>|</span><label class="collapse" for="c-40762140">[-]</label><label class="expand" for="c-40762140">[1 more]</label></div><br/><div class="children"><div class="content">Commoditize your complement. If you sell operating systems, it pays to make compilers a commodity so that everyone can write programs for your operating system. This is true even if you aren’t “selling” the OS in the traditional sense of the word.<p>The alternative is a world where developer tools are expensive, and thus only the rich can program their own computer.</div><br/></div></div><div id="40761633" class="c"><input type="checkbox" id="c-40761633" checked=""/><div class="controls bullet"><span class="by">diffxx</span><span>|</span><a href="#40761509">parent</a><span>|</span><a href="#40762140">prev</a><span>|</span><a href="#40765068">next</a><span>|</span><label class="collapse" for="c-40761633">[-]</label><label class="expand" for="c-40761633">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think it has been possible to sell a compiler which isn&#x27;t a loss-leader in a bundle for what, 30 years?<p>I agree and personally feel that this is unfortunate and that we are in some ways imprisoned using mediocre to bad compilers by our collective refusal to pay for better ones.</div><br/><div id="40765730" class="c"><input type="checkbox" id="c-40765730" checked=""/><div class="controls bullet"><span class="by">Falkon1313</span><span>|</span><a href="#40761509">root</a><span>|</span><a href="#40761633">parent</a><span>|</span><a href="#40761906">next</a><span>|</span><label class="collapse" for="c-40765730">[-]</label><label class="expand" for="c-40765730">[1 more]</label></div><br/><div class="children"><div class="content">Eh, the ones made by one or two people working part time and selling them as shareware weren&#x27;t necessarily better than what we have available now. They may have been good enough for their time, but probably wouldn&#x27;t cut it today.<p>And the ones made by corporations were prohibitively expensive. As a teenager wanting to learn, or a hobbyist making programs for fun, would you really pay $4500 for a compiler to tinker with projects in your spare time? There&#x27;s one reason hardly anyone uses Delphi anymore. By the time they finally released a Community Edition, there was no community left that had grown up learning Pascal.</div><br/></div></div><div id="40761906" class="c"><input type="checkbox" id="c-40761906" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#40761509">root</a><span>|</span><a href="#40761633">parent</a><span>|</span><a href="#40765730">prev</a><span>|</span><a href="#40765068">next</a><span>|</span><label class="collapse" for="c-40761906">[-]</label><label class="expand" for="c-40761906">[1 more]</label></div><br/><div class="children"><div class="content">i agree that we should have a better model as a society to produce things like compilers, but having a direct retail relationship with a closed source provider was pretty nasty.<p>because of tooling, large code bases, and weak standardization they had a huge amount of lockin. and only a single narrow funnel in which to address deficiencies.<p>and while certainly on a lower tier than EDA seats, werent super cheap. they usually had limited platform support. while they did optimize better for their targets, otherwise they were poorer systems than gcc, with all its warts.</div><br/></div></div></div></div></div></div><div id="40765068" class="c"><input type="checkbox" id="c-40765068" checked=""/><div class="controls bullet"><span class="by">7810905574</span><span>|</span><a href="#40761509">prev</a><span>|</span><label class="collapse" for="c-40765068">[-]</label><label class="expand" for="c-40765068">[1 more]</label></div><br/><div class="children"><div class="content">Gjk</div><br/></div></div></div></div></div></div></div></body></html>