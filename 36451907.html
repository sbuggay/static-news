<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687597258424" as="style"/><link rel="stylesheet" href="styles.css?v=1687597258424"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://neugierig.org/software/blog/2023/06/twos-complement.html">Finally getting two&#x27;s complement</a> <span class="domain">(<a href="https://neugierig.org">neugierig.org</a>)</span></div><div class="subtext"><span>thepbone</span> | <span>12 comments</span></div><br/><div><div id="36456855" class="c"><input type="checkbox" id="c-36456855" checked=""/><div class="controls bullet"><span class="by">masswerk</span><span>|</span><a href="#36456800">next</a><span>|</span><label class="collapse" for="c-36456855">[-]</label><label class="expand" for="c-36456855">[2 more]</label></div><br/><div class="children"><div class="content">I think, you can&#x27;t address two&#x27;s complement without mentioning one&#x27;s complement.<p>So what is one&#x27;s complement? Simply all bits flipped. (XOR the word length – each bitbecomes its complement.) There&#x27;s a simplicity and beauty to this and math just works with addition and subtraction. There&#x27;s also the notable feature of the most significant bit, which, if excluded from the usable range of numbers, becomes the sign-bit. If it is empty (clear), it must be a positive number, if it&#x27;s set, we have a negative number.<p>So everything perfect, then? Not at all. What happens, if we flipp all bits on zero (0000)? Well, it becomes all bits set (1111). How do we convert a number to it&#x27;s signed counterpart? We flip all bits and … Oh, this must be negative zero. Maybe we can deal with this? Sort of. But it&#x27;s somewhat nasty, because we need an extra steps to traverse zero. Say, we go from +1 to -1, there isn&#x27;t just a zero between, making this a difference of 2 – as it should be –, but there&#x27;s +0 and -0. That&#x27;s odd.<p>Can we do something about this? Namely, can we get rid of negative zero? Well, as we&#x27;ve seen, we have an extra step on the negative side of things… what about just adding 1 to compensate for this? So, for -1, we wouldn&#x27;t write 1110 (flipping all bits of 0001), but 1111? – Well, this works! we just eliminated negative zero! Welcome to two&#x27;s complement.</div><br/><div id="36456880" class="c"><input type="checkbox" id="c-36456880" checked=""/><div class="controls bullet"><span class="by">omnicognate</span><span>|</span><a href="#36456855">parent</a><span>|</span><a href="#36456800">next</a><span>|</span><label class="collapse" for="c-36456880">[-]</label><label class="expand" for="c-36456880">[1 more]</label></div><br/><div class="children"><div class="content">* * *</div><br/></div></div></div></div><div id="36456800" class="c"><input type="checkbox" id="c-36456800" checked=""/><div class="controls bullet"><span class="by">runiq</span><span>|</span><a href="#36456855">prev</a><span>|</span><a href="#36456682">next</a><span>|</span><label class="collapse" for="c-36456800">[-]</label><label class="expand" for="c-36456800">[1 more]</label></div><br/><div class="children"><div class="content">For context: This is the author of the Chrome Linux port, of Ninja-the-build-system, and of GtkSpell. Now I feel less bad about not having understood two&#x27;s complement before. :)</div><br/></div></div><div id="36456682" class="c"><input type="checkbox" id="c-36456682" checked=""/><div class="controls bullet"><span class="by">LinAGKar</span><span>|</span><a href="#36456800">prev</a><span>|</span><a href="#36456498">next</a><span>|</span><label class="collapse" for="c-36456682">[-]</label><label class="expand" for="c-36456682">[1 more]</label></div><br/><div class="children"><div class="content">One way to look at it is that the highest bit is negative instead of positive. So in an unsigned 8-bit integer, the highest bit is worth 128. In a signed integer, it&#x27;s worth -128.</div><br/></div></div><div id="36456498" class="c"><input type="checkbox" id="c-36456498" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#36456682">prev</a><span>|</span><a href="#36456687">next</a><span>|</span><label class="collapse" for="c-36456498">[-]</label><label class="expand" for="c-36456498">[1 more]</label></div><br/><div class="children"><div class="content">An (in my opinion) easier way to remember the bit representation is to remember that a positive number and its negative counterpart should add to 0. But zero is congruent to 2^b (where b is the number of bits). So equivalently, a number and its negative counterpart should add up to 2^b (since bits can’t add to 0).<p>Then, suppose we take a positive number x and invert all its bits to get y. Then x + y = 1111… = 2^b-1. So if we choose one of x or y to represent with +1 in its bit representation, they will be positive&#x2F;negative counterparts. It’s easier to keep positive numbers having the same representation as unsigned, so we choose to represent the bit value of -x with +1.</div><br/></div></div><div id="36456687" class="c"><input type="checkbox" id="c-36456687" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#36456498">prev</a><span>|</span><a href="#36456670">next</a><span>|</span><label class="collapse" for="c-36456687">[-]</label><label class="expand" for="c-36456687">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Suppose you have the bit pattern 0xFE and you add 0x1 to it, producing 0xFF. If you interpret that operation as signed math it&#x27;s computing 254 + 1 = 255, while if you interpret it as unsigned math it was -2 + 1 = -1.<p>Isn&#x27;t that backwards?  The first one is unsigned, the second one is signed.</div><br/></div></div><div id="36456670" class="c"><input type="checkbox" id="c-36456670" checked=""/><div class="controls bullet"><span class="by">jonsen</span><span>|</span><a href="#36456687">prev</a><span>|</span><a href="#36456636">next</a><span>|</span><label class="collapse" for="c-36456670">[-]</label><label class="expand" for="c-36456670">[1 more]</label></div><br/><div class="children"><div class="content">Since the decimal number system is &quot;the&quot; system of all number systems (as we are pestered with it from an early age before our brains have developed suitable abstraction capability until it just becomes second nature) it can be advantageous to think through how tens complement representation works in the decimal number system.</div><br/></div></div><div id="36456636" class="c"><input type="checkbox" id="c-36456636" checked=""/><div class="controls bullet"><span class="by">asicsp</span><span>|</span><a href="#36456670">prev</a><span>|</span><a href="#36456469">next</a><span>|</span><label class="collapse" for="c-36456636">[-]</label><label class="expand" for="c-36456636">[1 more]</label></div><br/><div class="children"><div class="content">See also: <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1125304&#x2F;why-prefer-twos-complement-over-sign-and-magnitude-for-signed-numbers" rel="nofollow noreferrer">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;1125304&#x2F;why-prefer-twos-...</a></div><br/></div></div><div id="36456469" class="c"><input type="checkbox" id="c-36456469" checked=""/><div class="controls bullet"><span class="by">ytret</span><span>|</span><a href="#36456636">prev</a><span>|</span><a href="#36456562">next</a><span>|</span><label class="collapse" for="c-36456469">[-]</label><label class="expand" for="c-36456469">[1 more]</label></div><br/><div class="children"><div class="content">Another way to understand what e.g. 0xFE means as a signed integer is to just add a number until it equals 0. So, 0xFE + 1 = 0xFF, not zero. 0xFE + 2 = 0. Therefore, 0xFE is -2.</div><br/></div></div><div id="36456562" class="c"><input type="checkbox" id="c-36456562" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#36456469">prev</a><span>|</span><label class="collapse" for="c-36456562">[-]</label><label class="expand" for="c-36456562">[2 more]</label></div><br/><div class="children"><div class="content">Sadly, I thought the title meant that the Cbstandard was finally standardising on twos complement for integers, i.e finally getting twos complement.</div><br/><div id="36456664" class="c"><input type="checkbox" id="c-36456664" checked=""/><div class="controls bullet"><span class="by">loup-vaillant</span><span>|</span><a href="#36456562">parent</a><span>|</span><label class="collapse" for="c-36456664">[-]</label><label class="expand" for="c-36456664">[1 more]</label></div><br/><div class="children"><div class="content">It kind of did if I recall correctly, but in the most infuriating way possible: signed overflow is still undefined!</div><br/></div></div></div></div></div></div></div></div></div></body></html>