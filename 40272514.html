<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715245271374" as="style"/><link rel="stylesheet" href="styles.css?v=1715245271374"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ifesunmola.com/how-to-use-the-foreign-function-api-in-java-22-to-call-c-libraries/">How to Use the Foreign Function API in Java 22 to Call C Libraries</a> <span class="domain">(<a href="https://ifesunmola.com">ifesunmola.com</a>)</span></div><div class="subtext"><span>pjmlp</span> | <span>114 comments</span></div><br/><div><div id="40306428" class="c"><input type="checkbox" id="c-40306428" checked=""/><div class="controls bullet"><span class="by">jakjak123</span><span>|</span><a href="#40301793">next</a><span>|</span><label class="collapse" for="c-40306428">[-]</label><label class="expand" for="c-40306428">[1 more]</label></div><br/><div class="children"><div class="content">I had a C library I needed to ideally use from Java directly. The new FFI API looks great, but unfortunately the C API relied heavily on macros and void* arguments, making it incredibly difficult to model from Java.</div><br/></div></div><div id="40301793" class="c"><input type="checkbox" id="c-40301793" checked=""/><div class="controls bullet"><span class="by">thefaux</span><span>|</span><a href="#40306428">prev</a><span>|</span><a href="#40300347">next</a><span>|</span><label class="collapse" for="c-40301793">[-]</label><label class="expand" for="c-40301793">[5 more]</label></div><br/><div class="children"><div class="content">I am sort of surprised that there isn&#x27;t a widely used tool that uses codegen to generate jni bindings sort of like what the jna does but at build time. You could go meta and bundle a builder in a jar that looks for the shared library in a particular place and shells out to build and install the native library if it is missing on the host computer. This would run once pretty similar I think to bundling native code in npm.<p>I have bundled shared libraries for five or six platforms in a java library that needs to make syscalls. It works but it is a pain if anything ever changes or a new platform needs to be brought up. Checking in binaries always feels icky but is necessary if not all targets can be built on a single machine.<p>The problem with the new api is that people upgrade java very slowly in most contexts. For an oss library developer, I see very little value add in this feature because I&#x27;m still stuck for all of my users who are using an older version of java. If I integrate the new ffi api, now I have to support both it and the jni api.</div><br/><div id="40303013" class="c"><input type="checkbox" id="c-40303013" checked=""/><div class="controls bullet"><span class="by">MaxBarraclough</span><span>|</span><a href="#40301793">parent</a><span>|</span><a href="#40305101">next</a><span>|</span><label class="collapse" for="c-40303013">[-]</label><label class="expand" for="c-40303013">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I am sort of surprised that there isn&#x27;t a widely used tool that uses codegen to generate jni bindings sort of like what the jna does but at build time<p>There are several, including SWIG.</div><br/><div id="40304317" class="c"><input type="checkbox" id="c-40304317" checked=""/><div class="controls bullet"><span class="by">andoando</span><span>|</span><a href="#40301793">root</a><span>|</span><a href="#40303013">parent</a><span>|</span><a href="#40305101">next</a><span>|</span><label class="collapse" for="c-40304317">[-]</label><label class="expand" for="c-40304317">[1 more]</label></div><br/><div class="children"><div class="content">Which is still a pita to use unless maybe you really know what youre doing.</div><br/></div></div></div></div><div id="40305101" class="c"><input type="checkbox" id="c-40305101" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#40301793">parent</a><span>|</span><a href="#40303013">prev</a><span>|</span><a href="#40303045">next</a><span>|</span><label class="collapse" for="c-40305101">[-]</label><label class="expand" for="c-40305101">[1 more]</label></div><br/><div class="children"><div class="content">Back in 1998 I wrote a code generator to make JNI stubs for LAPACK.  It’s the kind of programming that goes that way.</div><br/></div></div><div id="40303045" class="c"><input type="checkbox" id="c-40303045" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#40301793">parent</a><span>|</span><a href="#40305101">prev</a><span>|</span><a href="#40300347">next</a><span>|</span><label class="collapse" for="c-40303045">[-]</label><label class="expand" for="c-40303045">[1 more]</label></div><br/><div class="children"><div class="content">There is SWIG, which does bings to and from C for almost every language that exists.</div><br/></div></div></div></div><div id="40300347" class="c"><input type="checkbox" id="c-40300347" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#40301793">prev</a><span>|</span><a href="#40306125">next</a><span>|</span><label class="collapse" for="c-40300347">[-]</label><label class="expand" for="c-40300347">[44 more]</label></div><br/><div class="children"><div class="content">What I&#x27;m missing is a model for building&#x2F;distributing those C libraries with a java application.<p>Every ffi example I&#x27;ve found seem to operate on the assumption that you want to invoke syscalls or libc, which (with possibly the exception of like madvise and aioring) Java already mostly has decent facilities to interact with even without native calls.</div><br/><div id="40301123" class="c"><input type="checkbox" id="c-40301123" checked=""/><div class="controls bullet"><span class="by">sedro</span><span>|</span><a href="#40300347">parent</a><span>|</span><a href="#40301718">next</a><span>|</span><label class="collapse" for="c-40301123">[-]</label><label class="expand" for="c-40301123">[3 more]</label></div><br/><div class="children"><div class="content">Native libraries are typically packaged inside a jar so that everything works over the existing build and dependency management systems.<p>For example, each these jars named &quot;native-$os-$arch.jar&quot; contain a .dll&#x2F;.so&#x2F;.dylib:
<a href="https:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;com&#x2F;aayushatharva&#x2F;brotli4j&#x2F;" rel="nofollow">https:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;com&#x2F;aayushatharva&#x2F;brotli4j&#x2F;</a><p>JNA will extract the appropriate native library (using os.name and os.arch system properties), save the library to a temp file, then load it.</div><br/><div id="40304602" class="c"><input type="checkbox" id="c-40304602" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301123">parent</a><span>|</span><a href="#40301718">next</a><span>|</span><label class="collapse" for="c-40304602">[-]</label><label class="expand" for="c-40304602">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; JNA will extract the appropriate native library ..., save the library to a temp file, then load it.
</code></pre>
JNA does this?<p>FYI: JNA = Java Native Access project: <a href="https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna">https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna</a></div><br/><div id="40305045" class="c"><input type="checkbox" id="c-40305045" checked=""/><div class="controls bullet"><span class="by">sedro</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304602">parent</a><span>|</span><a href="#40301718">next</a><span>|</span><label class="collapse" for="c-40305045">[-]</label><label class="expand" for="c-40305045">[1 more]</label></div><br/><div class="children"><div class="content">It does! Code is here <a href="https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna&#x2F;blob&#x2F;40f0a1249b5ad03020b5a2b66f42b9546e6d4edf&#x2F;src&#x2F;com&#x2F;sun&#x2F;jna&#x2F;NativeLibrary.java#L297-L308">https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna&#x2F;blob&#x2F;40f0a1249b5ad...</a></div><br/></div></div></div></div></div></div><div id="40301718" class="c"><input type="checkbox" id="c-40301718" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#40300347">parent</a><span>|</span><a href="#40301123">prev</a><span>|</span><a href="#40300722">next</a><span>|</span><label class="collapse" for="c-40301718">[-]</label><label class="expand" for="c-40301718">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Every ffi example I&#x27;ve found seem to operate on the assumption that you want to invoke syscalls or libc ... Java already mostly has decent facilities to interact with even without native calls.<p>Because you would use ffi to interact with libraries that don&#x27;t have Java wrappers yet: IE, you&#x27;re writing the wrapper.<p>Using syscalls or libc is a way to write an example against a known library that you&#x27;re probably familiar with.</div><br/></div></div><div id="40300722" class="c"><input type="checkbox" id="c-40300722" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300347">parent</a><span>|</span><a href="#40301718">prev</a><span>|</span><a href="#40303594">next</a><span>|</span><label class="collapse" for="c-40300722">[-]</label><label class="expand" for="c-40300722">[4 more]</label></div><br/><div class="children"><div class="content">The recommended distribution model for Java applications is a jlinked runtime image [1], which supports including native libraries in the image.<p>[1]: Technically, this is the only distribution model because all Java runtimes as of JDK 9 are created with jlink, including the runtime included in the JDK (which many people use as-is), but I mean a custom runtime packaged with the application.</div><br/><div id="40301398" class="c"><input type="checkbox" id="c-40301398" checked=""/><div class="controls bullet"><span class="by">maksut</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300722">parent</a><span>|</span><a href="#40303594">next</a><span>|</span><label class="collapse" for="c-40301398">[-]</label><label class="expand" for="c-40301398">[3 more]</label></div><br/><div class="children"><div class="content">Is that still true when distributing libraries?</div><br/><div id="40302347" class="c"><input type="checkbox" id="c-40302347" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301398">parent</a><span>|</span><a href="#40301918">next</a><span>|</span><label class="collapse" for="c-40302347">[-]</label><label class="expand" for="c-40302347">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely not. jlink is used to distribute applications (it includes your code, the Java libs you use, i.e. their jars, and the trimmed-down JVM with the modules you&#x27;re using so that your distribution is not so big - typically around 30MB).<p>Java libraries are still obtained from Maven repositories via Maven&#x2F;Gradle&#x2F;Ant&#x2F;Bazel&#x2F;etc.</div><br/></div></div><div id="40301918" class="c"><input type="checkbox" id="c-40301918" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301398">parent</a><span>|</span><a href="#40302347">prev</a><span>|</span><a href="#40303594">next</a><span>|</span><label class="collapse" for="c-40301918">[-]</label><label class="expand" for="c-40301918">[1 more]</label></div><br/><div class="children"><div class="content">If you distribute libraries as jmod files, which few libraries do (in that case, jlink would automatically extract the native libraries and place them in the appropriate location).</div><br/></div></div></div></div></div></div><div id="40303594" class="c"><input type="checkbox" id="c-40303594" checked=""/><div class="controls bullet"><span class="by">aardvark179</span><span>|</span><a href="#40300347">parent</a><span>|</span><a href="#40300722">prev</a><span>|</span><a href="#40300693">next</a><span>|</span><label class="collapse" for="c-40303594">[-]</label><label class="expand" for="c-40303594">[6 more]</label></div><br/><div class="children"><div class="content">So, other people have already answered this, but this does seem to be a gap where many developers lack some piece of knowledge to chain the whole solution together. You normally package this sort of thing by putting the native library in a jar, extracting it to a tmp file that will be deleted on exit, and opening that dynamic library.<p>I’ve met many perfectly reasonable developers who do know all those steps can be done but can’t put them all together - maybe because it just hasn’t clicked that you can store a library in a jar. It feels like something tutorials should cover, but I think falls into the, “surely everyone can work it out?” category.</div><br/><div id="40305539" class="c"><input type="checkbox" id="c-40305539" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303594">parent</a><span>|</span><a href="#40304213">next</a><span>|</span><label class="collapse" for="c-40305539">[-]</label><label class="expand" for="c-40305539">[1 more]</label></div><br/><div class="children"><div class="content">&gt;exract it to a tmp file that will be deleted on <i>exit</i>,<p>actually you delete it immediately (after load) on anything that&#x27;s not windows... even then but it&#x27;s likely to return false.<p>deleteOnExit just stores the path to delete and uses a shutdownHook to actually call delete. Nothing really special about it</div><br/></div></div><div id="40304213" class="c"><input type="checkbox" id="c-40304213" checked=""/><div class="controls bullet"><span class="by">sedro</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303594">parent</a><span>|</span><a href="#40305539">prev</a><span>|</span><a href="#40304140">next</a><span>|</span><label class="collapse" for="c-40304213">[-]</label><label class="expand" for="c-40304213">[1 more]</label></div><br/><div class="children"><div class="content">You would also need to learn about Maven profiles and activation. And for other build tools, you&#x27;ll be delighted to know they have <i>partial</i> support.</div><br/></div></div><div id="40304140" class="c"><input type="checkbox" id="c-40304140" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303594">parent</a><span>|</span><a href="#40304213">prev</a><span>|</span><a href="#40300693">next</a><span>|</span><label class="collapse" for="c-40304140">[-]</label><label class="expand" for="c-40304140">[3 more]</label></div><br/><div class="children"><div class="content">&gt; extracting it to a tmp file<p>i wonder if there&#x27;s a way to do this entirely in memory? Because some deployment scenarios might not have disk space at all.</div><br/><div id="40304199" class="c"><input type="checkbox" id="c-40304199" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304140">parent</a><span>|</span><a href="#40305566">next</a><span>|</span><label class="collapse" for="c-40304199">[-]</label><label class="expand" for="c-40304199">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;tmp is often a RAM disk in such cases</div><br/></div></div><div id="40305566" class="c"><input type="checkbox" id="c-40305566" checked=""/><div class="controls bullet"><span class="by">xxs</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304140">parent</a><span>|</span><a href="#40304199">prev</a><span>|</span><a href="#40300693">next</a><span>|</span><label class="collapse" for="c-40305566">[-]</label><label class="expand" for="c-40305566">[1 more]</label></div><br/><div class="children"><div class="content">not with java - it needs a path. Of course if you have a ram disk (e.g. &#x2F;tmp) it&#x27;d do the job.</div><br/></div></div></div></div></div></div><div id="40300693" class="c"><input type="checkbox" id="c-40300693" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40300347">parent</a><span>|</span><a href="#40303594">prev</a><span>|</span><a href="#40300675">next</a><span>|</span><label class="collapse" for="c-40300693">[-]</label><label class="expand" for="c-40300693">[28 more]</label></div><br/><div class="children"><div class="content">You do it the standard way, package them inside the jar file.</div><br/><div id="40300783" class="c"><input type="checkbox" id="c-40300783" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300693">parent</a><span>|</span><a href="#40301261">next</a><span>|</span><label class="collapse" for="c-40300783">[-]</label><label class="expand" for="c-40300783">[20 more]</label></div><br/><div class="children"><div class="content">Oh, does this actually work?<p>I was on the assumption that it was dynamically linking the libarary with the OS dynamic linker, which in no OS I&#x27;m aware of is capable of loading libraries inside of zip files.<p>Not sure where I got that notion. Maybe I was overthinking this.</div><br/><div id="40302373" class="c"><input type="checkbox" id="c-40302373" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300783">parent</a><span>|</span><a href="#40300836">next</a><span>|</span><label class="collapse" for="c-40302373">[-]</label><label class="expand" for="c-40302373">[3 more]</label></div><br/><div class="children"><div class="content">I remember using Sqlite Java and not having to install sqlite on the image. Then I looked inside the Sqlite-java&#x27;s jar and they just packed the sqlite binaries for the different OSs in the jar!!</div><br/><div id="40305579" class="c"><input type="checkbox" id="c-40305579" checked=""/><div class="controls bullet"><span class="by">dehrmann</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40302373">parent</a><span>|</span><a href="#40302495">next</a><span>|</span><label class="collapse" for="c-40305579">[-]</label><label class="expand" for="c-40305579">[1 more]</label></div><br/><div class="children"><div class="content">Not sure if this is still the case, but one of the Java Sqlite driver used something called NestedVM to run Sqlite in the JVM when a native library wasn&#x27;t available. It worked by cross-compiling the code to mips, then transpiling the mips assembly to Java byte code. I can&#x27;t remember if it bridged system calls or libc calls to Java for things like file IO.</div><br/></div></div><div id="40302495" class="c"><input type="checkbox" id="c-40302495" checked=""/><div class="controls bullet"><span class="by">DannyB2</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40302373">parent</a><span>|</span><a href="#40305579">prev</a><span>|</span><a href="#40300836">next</a><span>|</span><label class="collapse" for="c-40302495">[-]</label><label class="expand" for="c-40302495">[1 more]</label></div><br/><div class="children"><div class="content">I once (2016 ish) used a serial-port library for Java.  Needed to be cross platform desktop app for Linux, Windows and Mac (in that order, all on x86&#x2F;64).  And it was.  I have forgotten the name of the library project I included, but it included DLL binaries for the platforms we were targeting.</div><br/></div></div></div></div><div id="40300836" class="c"><input type="checkbox" id="c-40300836" checked=""/><div class="controls bullet"><span class="by">zten</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300783">parent</a><span>|</span><a href="#40302373">prev</a><span>|</span><a href="#40303955">next</a><span>|</span><label class="collapse" for="c-40300836">[-]</label><label class="expand" for="c-40300836">[15 more]</label></div><br/><div class="children"><div class="content">Yes. Check out a library like zstd-jni. You&#x27;ll find native libraries inside it. It&#x27;ll load from the classpath first, and then ask the OS linker to find it.</div><br/><div id="40301137" class="c"><input type="checkbox" id="c-40301137" checked=""/><div class="controls bullet"><span class="by">maksut</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300836">parent</a><span>|</span><a href="#40300891">next</a><span>|</span><label class="collapse" for="c-40301137">[-]</label><label class="expand" for="c-40301137">[11 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to learn how they do it. Because last time I&#x27;ve looked at this, the suggested solution was to copy the binaries from claspath (eg: the jar) into a temporary folder then load it from there. It feels icky :)</div><br/><div id="40302053" class="c"><input type="checkbox" id="c-40302053" checked=""/><div class="controls bullet"><span class="by">zten</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301137">parent</a><span>|</span><a href="#40301387">next</a><span>|</span><label class="collapse" for="c-40302053">[-]</label><label class="expand" for="c-40302053">[7 more]</label></div><br/><div class="children"><div class="content">Yep, you&#x27;re right, they do exactly that. Apologies for the confusion.<p>Decompiled class file:<p><pre><code>    try {
        var4 = File.createTempFile(&quot;libzstd-jni-1.5.0-4&quot;, &quot;.&quot; + libExtension(), var0);
        var4.deleteOnExit();</code></pre></div><br/><div id="40304154" class="c"><input type="checkbox" id="c-40304154" checked=""/><div class="controls bullet"><span class="by">sedro</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40302053">parent</a><span>|</span><a href="#40301387">next</a><span>|</span><label class="collapse" for="c-40304154">[-]</label><label class="expand" for="c-40304154">[6 more]</label></div><br/><div class="children"><div class="content">This wouldn&#x27;t work on Windows, because you can&#x27;t delete a DLL while it&#x27;s in use</div><br/><div id="40305316" class="c"><input type="checkbox" id="c-40305316" checked=""/><div class="controls bullet"><span class="by">electrum</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304154">parent</a><span>|</span><a href="#40304544">next</a><span>|</span><label class="collapse" for="c-40305316">[-]</label><label class="expand" for="c-40305316">[1 more]</label></div><br/><div class="children"><div class="content">You might be able to use FILE_FLAG_DELETE_ON_CLOSE, but this would likely require calling the Windows API functions directly.</div><br/></div></div><div id="40304544" class="c"><input type="checkbox" id="c-40304544" checked=""/><div class="controls bullet"><span class="by">BenjiWiebe</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304154">parent</a><span>|</span><a href="#40305316">prev</a><span>|</span><a href="#40301387">next</a><span>|</span><label class="collapse" for="c-40304544">[-]</label><label class="expand" for="c-40304544">[4 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you: 
Extract DLL
Load DLL
Unload DLL
Delete DLL
?<p>Though in the example given, I do see your point now. You&#x27;d have to make sure the DLL was unloaded before the delete-on-exit happened.</div><br/><div id="40304991" class="c"><input type="checkbox" id="c-40304991" checked=""/><div class="controls bullet"><span class="by">sedro</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304544">parent</a><span>|</span><a href="#40304881">next</a><span>|</span><label class="collapse" for="c-40304991">[-]</label><label class="expand" for="c-40304991">[1 more]</label></div><br/><div class="children"><div class="content">According to JNA it&#x27;s not safe to unload the DLL:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna&#x2F;blob&#x2F;40f0a1249b5ad03020b5a2b66f42b9546e6d4edf&#x2F;src&#x2F;com&#x2F;sun&#x2F;jna&#x2F;Native.java#L283-L293">https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna&#x2F;blob&#x2F;40f0a1249b5ad...</a><p><pre><code>  Do NOT force the class loader to unload the native library, since
  that introduces issues with cleaning up any extant JNA bits
  (e.g. Memory) which may still need use of the library before shutdown.
</code></pre>
Following the blame back to 2011, they did unload DLLs before <a href="https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna&#x2F;commit&#x2F;71de662675bdfb9a3072be910ac052f9c262bab6">https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna&#x2F;commit&#x2F;71de662675b...</a><p><pre><code>  Remove any automatically unpacked native library.  Forcing the class
  loader to unload it first is only required on Windows, since the
  temporary native library is still &quot;in use&quot; and can&#x27;t be deleted until
  the native library is removed from its class loader.  Any deferred
  execution we might install at this point would prevent the Native
  class and its class loader from being GC&#x27;d, so we instead force 
  the native library unload just a little bit prematurely.
</code></pre>
Users reported occasional access violation errors during shutdown.</div><br/></div></div><div id="40304881" class="c"><input type="checkbox" id="c-40304881" checked=""/><div class="controls bullet"><span class="by">tadfisher</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304544">parent</a><span>|</span><a href="#40304991">prev</a><span>|</span><a href="#40301387">next</a><span>|</span><label class="collapse" for="c-40304881">[-]</label><label class="expand" for="c-40304881">[2 more]</label></div><br/><div class="children"><div class="content">You can install a shutdown hook to do cleanup like this.<p><pre><code>    Runtime.getRuntime().addShutdownHook(...)</code></pre></div><br/><div id="40305010" class="c"><input type="checkbox" id="c-40305010" checked=""/><div class="controls bullet"><span class="by">sedro</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40304881">parent</a><span>|</span><a href="#40301387">next</a><span>|</span><label class="collapse" for="c-40305010">[-]</label><label class="expand" for="c-40305010">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how java.io.File#deleteOnExit works under the hood. The DLL is still loaded at that point and can&#x27;t be deleted.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40301387" class="c"><input type="checkbox" id="c-40301387" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301137">parent</a><span>|</span><a href="#40302053">prev</a><span>|</span><a href="#40300891">next</a><span>|</span><label class="collapse" for="c-40301387">[-]</label><label class="expand" for="c-40301387">[3 more]</label></div><br/><div class="children"><div class="content">EDIT: Disregard. I am wrong. Original below.<p>You can just load as a resource. We do this internally since much of network stack is C. But we use JNI because code is older than Java 22.</div><br/><div id="40301671" class="c"><input type="checkbox" id="c-40301671" checked=""/><div class="controls bullet"><span class="by">maksut</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301387">parent</a><span>|</span><a href="#40300891">next</a><span>|</span><label class="collapse" for="c-40301671">[-]</label><label class="expand" for="c-40301671">[2 more]</label></div><br/><div class="children"><div class="content">You made me search it again. And still I don&#x27;t see how that&#x27;s possible. `Runtime.load` requires a regular file with an absolute path[0].<p>Stackoverflow is full of &quot;copy it into a temp file&quot; solutions. ChatGPT keeps saying &quot;sorry&quot; but still insists on copying it into a temp file :)<p>[0] - <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en%2Fjava%2Fjavase%2F22%2Fdocs%2Fapi%2F%2F&#x2F;java.base&#x2F;java&#x2F;lang&#x2F;Runtime.html#load(java.lang.String)" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en%2Fjava%2Fjavase%2F22%2Fdocs%2Fapi...</a></div><br/><div id="40301749" class="c"><input type="checkbox" id="c-40301749" checked=""/><div class="controls bullet"><span class="by">renewiltord</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301671">parent</a><span>|</span><a href="#40300891">next</a><span>|</span><label class="collapse" for="c-40301749">[-]</label><label class="expand" for="c-40301749">[1 more]</label></div><br/><div class="children"><div class="content">Embarrassing of me to give you wrong answer. I went and checked my old code and:<p><pre><code>     new FileOutputStream(tmpFile)
</code></pre>
Apologies.</div><br/></div></div></div></div></div></div></div></div><div id="40300891" class="c"><input type="checkbox" id="c-40300891" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300836">parent</a><span>|</span><a href="#40301137">prev</a><span>|</span><a href="#40303955">next</a><span>|</span><label class="collapse" for="c-40300891">[-]</label><label class="expand" for="c-40300891">[3 more]</label></div><br/><div class="children"><div class="content">Sounds promising.<p>I have some extremely unwieldy off-heap operations currently implemented in Java (like quicksort for 128 bit records) that would be very nice to offload as FFI calls to the corresponding a single-line C++ function.</div><br/><div id="40301219" class="c"><input type="checkbox" id="c-40301219" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300891">parent</a><span>|</span><a href="#40303955">next</a><span>|</span><label class="collapse" for="c-40301219">[-]</label><label class="expand" for="c-40301219">[2 more]</label></div><br/><div class="children"><div class="content">Why not give C# a try instead? It has everything you ask for and then some.</div><br/><div id="40305619" class="c"><input type="checkbox" id="c-40305619" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301219">parent</a><span>|</span><a href="#40303955">next</a><span>|</span><label class="collapse" for="c-40305619">[-]</label><label class="expand" for="c-40305619">[1 more]</label></div><br/><div class="children"><div class="content">Wow, you all are sure mad enough to go out of your way and downvote my comments elsewhere.<p>Stay in the swamp :)</div><br/></div></div></div></div></div></div></div></div><div id="40303955" class="c"><input type="checkbox" id="c-40303955" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300783">parent</a><span>|</span><a href="#40300836">prev</a><span>|</span><a href="#40301261">next</a><span>|</span><label class="collapse" for="c-40303955">[-]</label><label class="expand" for="c-40303955">[1 more]</label></div><br/><div class="children"><div class="content">Android knows how to do this, actually.</div><br/></div></div></div></div><div id="40301261" class="c"><input type="checkbox" id="c-40301261" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40300693">parent</a><span>|</span><a href="#40300783">prev</a><span>|</span><a href="#40300675">next</a><span>|</span><label class="collapse" for="c-40301261">[-]</label><label class="expand" for="c-40301261">[7 more]</label></div><br/><div class="children"><div class="content">Is there a solution when the binaries are 500mb+ per platform?</div><br/><div id="40306174" class="c"><input type="checkbox" id="c-40306174" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301261">parent</a><span>|</span><a href="#40303097">next</a><span>|</span><label class="collapse" for="c-40306174">[-]</label><label class="expand" for="c-40306174">[1 more]</label></div><br/><div class="children"><div class="content">Libraries like JCEF have support tools to download the libraries either at runtime or during the build, to offload from Maven Central.</div><br/></div></div><div id="40303097" class="c"><input type="checkbox" id="c-40303097" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40301261">parent</a><span>|</span><a href="#40306174">prev</a><span>|</span><a href="#40300675">next</a><span>|</span><label class="collapse" for="c-40303097">[-]</label><label class="expand" for="c-40303097">[5 more]</label></div><br/><div class="children"><div class="content">People seem pretty happy when Go and Rust do the same with static linking, advocating how great it happens to be.</div><br/><div id="40303831" class="c"><input type="checkbox" id="c-40303831" checked=""/><div class="controls bullet"><span class="by">yw3410</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303097">parent</a><span>|</span><a href="#40305601">next</a><span>|</span><label class="collapse" for="c-40303831">[-]</label><label class="expand" for="c-40303831">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t be as aggressive at removing functions in Java than in Rust though since it&#x27;s dynamic dispatch (e.g., if you use toString once in your code, you need to keep all implementations of toString which are reachable even if users don&#x27;t use reflection).</div><br/></div></div><div id="40305601" class="c"><input type="checkbox" id="c-40305601" checked=""/><div class="controls bullet"><span class="by">fire_lake</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303097">parent</a><span>|</span><a href="#40303831">prev</a><span>|</span><a href="#40303578">next</a><span>|</span><label class="collapse" for="c-40305601">[-]</label><label class="expand" for="c-40305601">[1 more]</label></div><br/><div class="children"><div class="content">In Java libraries are shared precompiled so the package manager either needs to be platform aware or distribute fat bundles.</div><br/></div></div><div id="40303578" class="c"><input type="checkbox" id="c-40303578" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303097">parent</a><span>|</span><a href="#40305601">prev</a><span>|</span><a href="#40300675">next</a><span>|</span><label class="collapse" for="c-40303578">[-]</label><label class="expand" for="c-40303578">[2 more]</label></div><br/><div class="children"><div class="content">Static linking in Go and Rust includes compiled code only for the target platform. It does not include compiled code for every possible architecture, including 32-bit MacOS and Solaris on PowerPC.</div><br/><div id="40304110" class="c"><input type="checkbox" id="c-40304110" checked=""/><div class="controls bullet"><span class="by">SJC_Hacker</span><span>|</span><a href="#40300347">root</a><span>|</span><a href="#40303578">parent</a><span>|</span><a href="#40300675">next</a><span>|</span><label class="collapse" for="c-40304110">[-]</label><label class="expand" for="c-40304110">[1 more]</label></div><br/><div class="children"><div class="content">Solaris... now thats a name I have not heard in a long time.  A long time.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40300675" class="c"><input type="checkbox" id="c-40300675" checked=""/><div class="controls bullet"><span class="by">ruslan_talpa</span><span>|</span><a href="#40300347">parent</a><span>|</span><a href="#40300693">prev</a><span>|</span><a href="#40306125">next</a><span>|</span><label class="collapse" for="c-40300675">[-]</label><label class="expand" for="c-40300675">[1 more]</label></div><br/><div class="children"><div class="content">Put them in a jar?</div><br/></div></div></div></div><div id="40306125" class="c"><input type="checkbox" id="c-40306125" checked=""/><div class="controls bullet"><span class="by">stevefan1999</span><span>|</span><a href="#40300347">prev</a><span>|</span><a href="#40301315">next</a><span>|</span><label class="collapse" for="c-40306125">[-]</label><label class="expand" for="c-40306125">[1 more]</label></div><br/><div class="children"><div class="content">Compared to .NET&#x27;s P&#x2F;Invoke this is still way too convoluted. Of course Java has its own domain problem such as treating everything as a reference (and thus pointer, there is a reason Java has NullPointerException rather than NullReferenceException) and the lack of stack value types (everything lives on heap unless escape analysis allows some data to stay on stack, but it is uncontrollable anyway) makes translation of Plain-Old-Data (POD) types in Java very difficult, which is mostly a no-op with C#. That&#x27;s why JNI exists as a mediator between native code and Java VM.<p>In C# I can just do something like this conceptual code:<p>```<p>&#x2F;&#x2F; FILE *fopen(const char *filename, const char *mode)<p>[DllImport(&quot;libc&quot;)]
public unsafe extern nint fopen([MarshalAs(UnmanagedType.LPStr)] string filename, [MarshalAs(UnmanagedType.LPStr)] string mode);<p>&#x2F;&#x2F; char *fgets(char *str, int n, FILE *stream)<p>[DllImport(&quot;libc&quot;)]
public unsafe extern nint fgets([MarshalAs(UnmanagedType.LPStr)] string str, int n, nint stream);<p>&#x2F;&#x2F; int fclose(FILE *stream)<p>[DllImport(&quot;libc&quot;)]
public unsafe extern int fclose(nint stream);<p>```<p>So much less code, and so much more precise than any of the Java JNI and FFI stuff.</div><br/></div></div><div id="40301315" class="c"><input type="checkbox" id="c-40301315" checked=""/><div class="controls bullet"><span class="by">xyproto</span><span>|</span><a href="#40306125">prev</a><span>|</span><a href="#40302356">next</a><span>|</span><label class="collapse" for="c-40301315">[-]</label><label class="expand" for="c-40301315">[17 more]</label></div><br/><div class="children"><div class="content">Does this mean that one can use SDL2 together with Java without bending over backwards?</div><br/><div id="40301898" class="c"><input type="checkbox" id="c-40301898" checked=""/><div class="controls bullet"><span class="by">maksut</span><span>|</span><a href="#40301315">parent</a><span>|</span><a href="#40301649">next</a><span>|</span><label class="collapse" for="c-40301898">[-]</label><label class="expand" for="c-40301898">[1 more]</label></div><br/><div class="children"><div class="content">I have played with raylib bindings for clojure by using the new foreign function api. It was a lot of fun. SDL might be a better fit because it prefers pass by reference arguments [0].<p>[0] <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;raysan5&#x2F;17392498d40e2cb281f5d09c0a4bf798" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;raysan5&#x2F;17392498d40e2cb281f5d09c0a4b...</a></div><br/></div></div><div id="40301649" class="c"><input type="checkbox" id="c-40301649" checked=""/><div class="controls bullet"><span class="by">marginalia_nu</span><span>|</span><a href="#40301315">parent</a><span>|</span><a href="#40301898">prev</a><span>|</span><a href="#40301515">next</a><span>|</span><label class="collapse" for="c-40301649">[-]</label><label class="expand" for="c-40301649">[1 more]</label></div><br/><div class="children"><div class="content">Oh man that&#x27;s a cool idea.<p>Might just build a SDL2-wrapper for ffi just as an FFI and FMI-exercise.</div><br/></div></div><div id="40301515" class="c"><input type="checkbox" id="c-40301515" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">parent</a><span>|</span><a href="#40301649">prev</a><span>|</span><a href="#40302356">next</a><span>|</span><label class="collapse" for="c-40301515">[-]</label><label class="expand" for="c-40301515">[14 more]</label></div><br/><div class="children"><div class="content">It seems it will make it somewhat easier.<p>But if you want to use SDL2 from something higher-level, you will be <i>much</i> better served by C# which will give you minimal FFI cost and most data structures you want to express in C as-is.</div><br/><div id="40302135" class="c"><input type="checkbox" id="c-40302135" checked=""/><div class="controls bullet"><span class="by">maksut</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40301515">parent</a><span>|</span><a href="#40303043">next</a><span>|</span><label class="collapse" for="c-40302135">[-]</label><label class="expand" for="c-40302135">[11 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know much about C#. It certainly looks more popular in gamedev circles.<p>When I played with this new java api. I wasn&#x27;t worried about the FFI cost. It seemed fast enough to me. My toy application was performing about 0.77x of pure C equivalent. I think Java&#x27;s memory model and heavy heap use might hurt more. Hopefully Java will catch up when it gets value objects with Project Valhalla. Next decade or so :)</div><br/><div id="40302273" class="c"><input type="checkbox" id="c-40302273" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40302135">parent</a><span>|</span><a href="#40303043">next</a><span>|</span><label class="collapse" for="c-40302273">[-]</label><label class="expand" for="c-40302273">[10 more]</label></div><br/><div class="children"><div class="content">Genuine curiosity - what would be your motivation to use Java over C# here aside from familiarity (which is perfectly understandable)? The latter takes heavy focus on making sure to provide features like structs and pointers with little to no friction, you can even AOT compile it and statically link SDL2 into a single executable.<p>In improbable case you may want to try it out, then all it needs is<p>- SDK from <a href="https:&#x2F;&#x2F;dot.net&#x2F;download" rel="nofollow">https:&#x2F;&#x2F;dot.net&#x2F;download</a> (or package manager of your choice if you are on Linux e.g. `sudo apt-get install dotnet-sdk-8.0`, !do not! use Homebrew if you are on macOS however, use .pkg installer)<p>- C# extension for VS Code (DevKit is not needed)<p>- SDL2 abstraction: <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;Silk.NET">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;Silk.NET</a> (there are all sorts of alternate bindings depending on your preferences)</div><br/><div id="40305510" class="c"><input type="checkbox" id="c-40305510" checked=""/><div class="controls bullet"><span class="by">stoperaticless</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40302273">parent</a><span>|</span><a href="#40304509">next</a><span>|</span><label class="collapse" for="c-40305510">[-]</label><label class="expand" for="c-40305510">[5 more]</label></div><br/><div class="children"><div class="content">Not the op, but at some point I did choose between the two paths&#x2F;jobs assuming I will get more proficient in only one of them each year (which is true, I stayed junior in C#).<p>Why I chose Java boils down to two reasons:<p>- runs on linux (I know there is some version of c# that eventually opened up, but I kind of expect it to have lot of conditions for being cross platform, I assume that standard c# code is not crossplatform due to some reason (e.g. Com usage might be standard way of doing stuff), which would make finding crossplatform answers tedious)<p>- whole ecosystem is more open source and more involved parties (which I interpreted as abit less controlled by the corporate overlord, so if corporate overlord went rogue, greater chance that language would survive somehow)<p>Never needed to call into C though..</div><br/><div id="40306173" class="c"><input type="checkbox" id="c-40306173" checked=""/><div class="controls bullet"><span class="by">5e92cb50239222b</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40305510">parent</a><span>|</span><a href="#40305616">next</a><span>|</span><label class="collapse" for="c-40306173">[-]</label><label class="expand" for="c-40306173">[2 more]</label></div><br/><div class="children"><div class="content">Despite what some fanatics may claim, operating systems other than Windows are still second class citizens (saying this after five years of doing .NET development almost exclusively on Linux), especially for dev, and operating systems other than the big three are not supported at all. So no BSDs (even FreeBSD) or Solaris if you ever need it.<p>Since the open .NET is pretty young, and they still have trouble with community perception due to their past actions, finding high quality FOSS libraries may pose a problem depending on what you&#x27;re doing. Pretty much everything from MS is open and high quality, but they don&#x27;t provide everything under the sun.<p>And with Java you always have alternative runtimes in case this Oracle deal goes sideways for any reason.<p>So you&#x27;re all good, don&#x27;t worry about it.</div><br/><div id="40306383" class="c"><input type="checkbox" id="c-40306383" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40306173">parent</a><span>|</span><a href="#40305616">next</a><span>|</span><label class="collapse" for="c-40306383">[-]</label><label class="expand" for="c-40306383">[1 more]</label></div><br/><div class="children"><div class="content">FreeBSD: `pkg install lang&#x2F;dotnet` (from <a href="https:&#x2F;&#x2F;www.freshports.org&#x2F;lang&#x2F;dotnet" rel="nofollow">https:&#x2F;&#x2F;www.freshports.org&#x2F;lang&#x2F;dotnet</a>)<p>GObject (GTK4 and similar): <a href="https:&#x2F;&#x2F;github.com&#x2F;gircore&#x2F;gir.core">https:&#x2F;&#x2F;github.com&#x2F;gircore&#x2F;gir.core</a> (significantly better and faster than Java alternatives, this is just one example among many)<p>Young: first OSS version was released 8 years ago<p>Solaris: might as well say &quot;it runs COBOL but not .NET&quot;<p>It&#x27;s funny that everyone missed the initial context of the question and jumped onto parroting the same arguments as years ago, without actually addressing the matter at hand or saying anything of substance. Unsurprising show of ignorance by Java community. Please stay this way - will help the industry move on faster.<p>The premise is always the same - if something is missing in {technology I don&#x27;t like}, it&#x27;s a deal-breaker, and when it&#x27;s not or was always there - it never mattered, or is harmful actually, that is, until {technology I like} gets it as well.</div><br/></div></div></div></div><div id="40305616" class="c"><input type="checkbox" id="c-40305616" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40305510">parent</a><span>|</span><a href="#40306173">prev</a><span>|</span><a href="#40304509">next</a><span>|</span><label class="collapse" for="c-40305616">[-]</label><label class="expand" for="c-40305616">[2 more]</label></div><br/><div class="children"><div class="content">Neither point is true today FWIW.<p>Neither point was ever true in the last ~10 years when it comes to gamedev (or where you want to use SDL) where Java was and continues to be a <i>much</i> weaker choice.</div><br/><div id="40305850" class="c"><input type="checkbox" id="c-40305850" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40305616">parent</a><span>|</span><a href="#40304509">next</a><span>|</span><label class="collapse" for="c-40305850">[-]</label><label class="expand" for="c-40305850">[1 more]</label></div><br/><div class="children"><div class="content">Java’s ecosystem is just vastly bigger. In many categories, Java has multiple open-source offerings vs .NET’s single, proprietary one that is often just a bad copy of one of the former libraries.</div><br/></div></div></div></div></div></div><div id="40304509" class="c"><input type="checkbox" id="c-40304509" checked=""/><div class="controls bullet"><span class="by">spullara</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40302273">parent</a><span>|</span><a href="#40305510">prev</a><span>|</span><a href="#40303388">next</a><span>|</span><label class="collapse" for="c-40304509">[-]</label><label class="expand" for="c-40304509">[2 more]</label></div><br/><div class="children"><div class="content">Java now has &lt;1ms max pause time garbage collectors with TB heaps. If you are writing a game GC matters a lot.</div><br/><div id="40305617" class="c"><input type="checkbox" id="c-40305617" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40304509">parent</a><span>|</span><a href="#40303388">next</a><span>|</span><label class="collapse" for="c-40305617">[-]</label><label class="expand" for="c-40305617">[1 more]</label></div><br/><div class="children"><div class="content">Interesting! What games did you write code for?</div><br/></div></div></div></div><div id="40303388" class="c"><input type="checkbox" id="c-40303388" checked=""/><div class="controls bullet"><span class="by">lazide</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40302273">parent</a><span>|</span><a href="#40304509">prev</a><span>|</span><a href="#40303043">next</a><span>|</span><label class="collapse" for="c-40303388">[-]</label><label class="expand" for="c-40303388">[2 more]</label></div><br/><div class="children"><div class="content">Not the original poster, but most folks have little choice what ecosystem they’re using.<p>And once you have enough momentum, switching isn’t usually worth it.<p>(As someone who has done Perl, C, Java, C#, Kotlin, JS, and Python professionally - god help me. Maybe a million lines of code all in now?)</div><br/><div id="40305648" class="c"><input type="checkbox" id="c-40305648" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40303388">parent</a><span>|</span><a href="#40303043">next</a><span>|</span><label class="collapse" for="c-40305648">[-]</label><label class="expand" for="c-40305648">[1 more]</label></div><br/><div class="children"><div class="content">Fair enough</div><br/></div></div></div></div></div></div></div></div><div id="40303043" class="c"><input type="checkbox" id="c-40303043" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40301515">parent</a><span>|</span><a href="#40302135">prev</a><span>|</span><a href="#40302356">next</a><span>|</span><label class="collapse" for="c-40303043">[-]</label><label class="expand" for="c-40303043">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re are (or were) right. Java has (had) an awful performance of a foreign API call, and I wonder was this fixed in this release, because as I heard, fixing it was the main reason of the upcoming functionality</div><br/><div id="40303172" class="c"><input type="checkbox" id="c-40303172" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40301315">root</a><span>|</span><a href="#40303043">parent</a><span>|</span><a href="#40302356">next</a><span>|</span><label class="collapse" for="c-40303172">[-]</label><label class="expand" for="c-40303172">[1 more]</label></div><br/><div class="children"><div class="content">It could bring Java closer in FFI overhead but not necessarily match. There are still missing features like structs, C pointers (though in C# they are superseded quite a bit by byrefs aka `ref T` syntax, e.g. used by Span&lt;T&gt;), stack allocated buffers, etc.<p>C# also has function pointers (managed&#x2F;unmanaged) and C exports with NativeAOT.</div><br/></div></div></div></div></div></div></div></div><div id="40302356" class="c"><input type="checkbox" id="c-40302356" checked=""/><div class="controls bullet"><span class="by">iso8859-1</span><span>|</span><a href="#40301315">prev</a><span>|</span><a href="#40300948">next</a><span>|</span><label class="collapse" for="c-40302356">[-]</label><label class="expand" for="c-40302356">[7 more]</label></div><br/><div class="children"><div class="content">Calling C is easy. But how do you call C++? Shiboken has a language that let&#x27;s you express ownership properties on C++ data structures&#x2F;methods&#x2F;functions. It&#x27;s tailored to generating Python FFI bindings though. It would be so nice if there were a cross-platform language to do this.</div><br/><div id="40303894" class="c"><input type="checkbox" id="c-40303894" checked=""/><div class="controls bullet"><span class="by">qweqwe14</span><span>|</span><a href="#40302356">parent</a><span>|</span><a href="#40306182">next</a><span>|</span><label class="collapse" for="c-40303894">[-]</label><label class="expand" for="c-40303894">[3 more]</label></div><br/><div class="children"><div class="content">The answer is basically you don&#x27;t. It&#x27;s impossible to make a sane, stable FFI for a language unless you put it behind a C ABI, which is relatively basic, but this is exactly why it&#x27;s most suitable for FFI: implementing support for calling C functions is way more trivial than figuring out how to call the latest C++&#x2F;Rust&#x2F;etc monstrosity.</div><br/><div id="40303935" class="c"><input type="checkbox" id="c-40303935" checked=""/><div class="controls bullet"><span class="by">zozbot234</span><span>|</span><a href="#40302356">root</a><span>|</span><a href="#40303894">parent</a><span>|</span><a href="#40305245">next</a><span>|</span><label class="collapse" for="c-40303935">[-]</label><label class="expand" for="c-40303935">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The answer is basically you don&#x27;t. It&#x27;s impossible to make a sane, stable FFI for a language unless you put it behind a C ABI<p>The Swift folks have put a lot of effort into attaining a stable ABI that&#x27;s native to their language.  They can achieve that because Swift is the officially endorsed language for development on Mac OS and iOS, so it (together with the platform itself) can set a standard that other languages will have to live with.<p>In a way, software VM&#x27;s like the JVM and CLR can also be said to define &#x27;ABIs&#x27; of sorts within their runtime, that every language implementation on these runtimes will have to deal with.</div><br/></div></div><div id="40305245" class="c"><input type="checkbox" id="c-40305245" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40302356">root</a><span>|</span><a href="#40303894">parent</a><span>|</span><a href="#40303935">prev</a><span>|</span><a href="#40306182">next</a><span>|</span><label class="collapse" for="c-40305245">[-]</label><label class="expand" for="c-40305245">[1 more]</label></div><br/><div class="children"><div class="content">There do exist ABIs that aren&#x27;t the C ABI.  But saying &quot;use the C ABI&quot; is far more portable than anything else.<p>I can also point to the GCC Inline Assembler as an excellent way to call arbitrary functions whether they implement the standard C procedure call standard or not.  By providing the list of arguments and what register they correspond to, along with the clobber list, you know everything you need to know to call the function.  So it&#x27;s more suitable for &quot;fastcall&quot; type functions where you need the arguments to correspond to particular registers.<p>But of course, ASM isn&#x27;t portable.</div><br/></div></div></div></div><div id="40306182" class="c"><input type="checkbox" id="c-40306182" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40302356">parent</a><span>|</span><a href="#40303894">prev</a><span>|</span><a href="#40303059">next</a><span>|</span><label class="collapse" for="c-40306182">[-]</label><label class="expand" for="c-40306182">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s javacpp which can do that.</div><br/></div></div><div id="40303059" class="c"><input type="checkbox" id="c-40303059" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#40302356">parent</a><span>|</span><a href="#40306182">prev</a><span>|</span><a href="#40303037">next</a><span>|</span><label class="collapse" for="c-40303059">[-]</label><label class="expand" for="c-40303059">[1 more]</label></div><br/><div class="children"><div class="content">This is something new. Before it you had to create a native-compatible shared library that returns jString&#x2F;jObject instead or use a proxy which did this for you (JNA). Let&#x27;s see what happens next, maybe even shiboken</div><br/></div></div><div id="40303037" class="c"><input type="checkbox" id="c-40303037" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#40302356">parent</a><span>|</span><a href="#40303059">prev</a><span>|</span><a href="#40300948">next</a><span>|</span><label class="collapse" for="c-40303037">[-]</label><label class="expand" for="c-40303037">[1 more]</label></div><br/><div class="children"><div class="content">You put your C++ behind a C API.</div><br/></div></div></div></div><div id="40300948" class="c"><input type="checkbox" id="c-40300948" checked=""/><div class="controls bullet"><span class="by">alex_suzuki</span><span>|</span><a href="#40302356">prev</a><span>|</span><a href="#40301525">next</a><span>|</span><label class="collapse" for="c-40300948">[-]</label><label class="expand" for="c-40300948">[1 more]</label></div><br/><div class="children"><div class="content">Wonder if this will make JNA (Java Native Access) redundant at some point: <a href="https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna">https:&#x2F;&#x2F;github.com&#x2F;java-native-access&#x2F;jna</a><p>Very useful, especially the prebundled platform bindings.</div><br/></div></div><div id="40301525" class="c"><input type="checkbox" id="c-40301525" checked=""/><div class="controls bullet"><span class="by">creativeSlumber</span><span>|</span><a href="#40300948">prev</a><span>|</span><a href="#40305467">next</a><span>|</span><label class="collapse" for="c-40301525">[-]</label><label class="expand" for="c-40301525">[5 more]</label></div><br/><div class="children"><div class="content">Not directly related to the artcile,but is there any article that explain how memory management (stack&#x2F;heap) work when using FFI in java. Also when a call is made though FFI to a C library, is there a separate java and C call stack? I haven&#x27;t found a good article yet on what happens under the hood.</div><br/><div id="40302388" class="c"><input type="checkbox" id="c-40302388" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#40301525">parent</a><span>|</span><a href="#40301713">next</a><span>|</span><label class="collapse" for="c-40302388">[-]</label><label class="expand" for="c-40302388">[1 more]</label></div><br/><div class="children"><div class="content">For the heap, JEP 454 is reasonably detailed:  <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454</a><p>It describes how to adopt memory from C and have C adopt memory you allocate, and gives control over how memory is allocated in an arena.<p>The arena has lifecycle boundaries, and allocations determine the memory space available.  Java guarantees (only) that you can&#x27;t use unallocated memory or memory outside the arena, and if you access via a (correct) value layout, you should be able to navigate structure correctly.<p>The interesting stuff is passing function pointers back and forth - look for `downcall method handles`.</div><br/></div></div><div id="40301713" class="c"><input type="checkbox" id="c-40301713" checked=""/><div class="controls bullet"><span class="by">dzaima</span><span>|</span><a href="#40301525">parent</a><span>|</span><a href="#40302388">prev</a><span>|</span><a href="#40305467">next</a><span>|</span><label class="collapse" for="c-40301713">[-]</label><label class="expand" for="c-40301713">[3 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t have an article, but the gist on stacks is that Java still uses the regular architecture stack (rsp on x86, etc) that the FFI&#x27;d code will, and on exit to&#x2F;entry from FFI it&#x27;d have to store its stack end&#x2F;start pointer (or otherwise be able to figure the range out) such that GC knows what to scan.</div><br/><div id="40303902" class="c"><input type="checkbox" id="c-40303902" checked=""/><div class="controls bullet"><span class="by">kgeist</span><span>|</span><a href="#40301525">root</a><span>|</span><a href="#40301713">parent</a><span>|</span><a href="#40305467">next</a><span>|</span><label class="collapse" for="c-40303902">[-]</label><label class="expand" for="c-40303902">[2 more]</label></div><br/><div class="children"><div class="content">I wonder how it works when you use virtual threads. In Go, goroutines have resizable stacks which notoriously complicates FFI because C has no idea about resizable stacks (IIRC they have to temporarily switch to a separate, special C stack).</div><br/><div id="40306183" class="c"><input type="checkbox" id="c-40306183" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#40301525">root</a><span>|</span><a href="#40303902">parent</a><span>|</span><a href="#40305467">next</a><span>|</span><label class="collapse" for="c-40306183">[-]</label><label class="expand" for="c-40306183">[1 more]</label></div><br/><div class="children"><div class="content">When it&#x27;s running a virtual thread is using a physical OS level thread, and if you call into C then that virtual thread won&#x27;t suspend. It pins the OS thread. So it&#x27;s all transparent.</div><br/></div></div></div></div></div></div></div></div><div id="40305467" class="c"><input type="checkbox" id="c-40305467" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#40301525">prev</a><span>|</span><a href="#40301312">next</a><span>|</span><label class="collapse" for="c-40305467">[-]</label><label class="expand" for="c-40305467">[1 more]</label></div><br/><div class="children"><div class="content">I can’t see why I’d ever reach for it, but I do like knowing that Java is actively being improved over time</div><br/></div></div><div id="40300285" class="c"><input type="checkbox" id="c-40300285" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#40301312">prev</a><span>|</span><a href="#40303018">next</a><span>|</span><label class="collapse" for="c-40300285">[-]</label><label class="expand" for="c-40300285">[27 more]</label></div><br/><div class="children"><div class="content">What’s the use case here? Developing drivers with Java?</div><br/><div id="40300363" class="c"><input type="checkbox" id="c-40300363" checked=""/><div class="controls bullet"><span class="by">invalidname</span><span>|</span><a href="#40300285">parent</a><span>|</span><a href="#40300374">next</a><span>|</span><label class="collapse" for="c-40300363">[-]</label><label class="expand" for="c-40300363">[2 more]</label></div><br/><div class="children"><div class="content">Invoking native code has always been necessary in Java. In the past it was done via JNI which has many issues. These new APIs solve the issues and simplify the API. The use case is interacting with anything that isn&#x27;t written in Java.</div><br/><div id="40302483" class="c"><input type="checkbox" id="c-40302483" checked=""/><div class="controls bullet"><span class="by">xtracto</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300363">parent</a><span>|</span><a href="#40300374">next</a><span>|</span><label class="collapse" for="c-40302483">[-]</label><label class="expand" for="c-40302483">[1 more]</label></div><br/><div class="children"><div class="content">Blast from the past!  I remember doing JNI integration in Java  around 2003! It&#x27;s been so long I don&#x27;t remember details but you had to declare some  interfaces in java, then some middleware .h or .c and then call the native library iirc.<p>Glad to see things are progressing!!</div><br/></div></div></div></div><div id="40300374" class="c"><input type="checkbox" id="c-40300374" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40300285">parent</a><span>|</span><a href="#40300363">prev</a><span>|</span><a href="#40303018">next</a><span>|</span><label class="collapse" for="c-40300374">[-]</label><label class="expand" for="c-40300374">[24 more]</label></div><br/><div class="children"><div class="content">Same use case as to why .NET has low&#x2F;zero-cost FFI.<p>This is similar, except more boilerplate and much, much slower.</div><br/><div id="40300668" class="c"><input type="checkbox" id="c-40300668" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300374">parent</a><span>|</span><a href="#40300674">next</a><span>|</span><label class="collapse" for="c-40300668">[-]</label><label class="expand" for="c-40300668">[4 more]</label></div><br/><div class="children"><div class="content">The FFM downcalls in OpenJDK compile down to argument shuffling + a CALL instruction (in &quot;critical&quot; linker mode), i.e. the same machine code gcc&#x2F;clang would generate for a call from a C program.</div><br/><div id="40304126" class="c"><input type="checkbox" id="c-40304126" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300668">parent</a><span>|</span><a href="#40300917">next</a><span>|</span><label class="collapse" for="c-40304126">[-]</label><label class="expand" for="c-40304126">[2 more]</label></div><br/><div class="children"><div class="content">What does it do if you need to pass a struct that contains another struct?</div><br/><div id="40304494" class="c"><input type="checkbox" id="c-40304494" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40304126">parent</a><span>|</span><a href="#40300917">next</a><span>|</span><label class="collapse" for="c-40304494">[-]</label><label class="expand" for="c-40304494">[1 more]</label></div><br/><div class="children"><div class="content">The same, but you need to define the layout appropriately. The JEP covers the basics: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454</a>. As I explained in another comment [1], we didn&#x27;t want to trade off performance or limit the runtime, so the API for describing native layouts is more elaborate.<p>[1]: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40303242">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40303242</a></div><br/></div></div></div></div><div id="40300917" class="c"><input type="checkbox" id="c-40300917" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300668">parent</a><span>|</span><a href="#40304126">prev</a><span>|</span><a href="#40300674">next</a><span>|</span><label class="collapse" for="c-40300917">[-]</label><label class="expand" for="c-40300917">[1 more]</label></div><br/><div class="children"><div class="content">This is what it is compiled to in .NET[0] today more or less[1]. What does OpenJDK compile these to? (edit: misread as <i>could</i> compile. Hmm, I wonder how much the difference will there be in average FFI cost with newer APIs vs direct calls)<p>[0] Objects that need pinning are pinned(by toggling a bit in object header), byrefs are pinned by simply storing them on the stack, arguments that need marshalling involve calling corresponding marshalling code. That code can allocate intermediate data on heap, on stack or call NativeMemory.Alloc&#x2F;.Free C-style.<p>[1] Overhead can be further reduced by 1. annotating FFI calls with [SuppressGCTransition] which saves on possible arguments stack spills and GC helper call, replacing the call with a single flag check and optional call into GC in epilog, 2. in NativeAOT, p&#x2F;invokes can be &quot;direct&quot; which saves on initialization checks and indirections (though they are reduced in JIT as it can bake data directly into codegen after static init has finished on recompilation). This has a tradeoff as system&#x27;s dynamic loader will be used at application startup instead of regular lazy initialization and 3. direct p&#x2F;invokes can be upgraded to static linking, which transforms them into direct calls identical to regular C calls save for the same GC flag check in post-condition. This comes with compiling .NET executables and libraries into a single statically linked binary (well, statically linked for the native dependencies the user has opted into linking this way).</div><br/></div></div></div></div><div id="40300674" class="c"><input type="checkbox" id="c-40300674" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300374">parent</a><span>|</span><a href="#40300668">prev</a><span>|</span><a href="#40304051">next</a><span>|</span><label class="collapse" for="c-40300674">[-]</label><label class="expand" for="c-40300674">[14 more]</label></div><br/><div class="children"><div class="content">I still have some hopes that it will evolve towards a P&#x2F;Invoke like experience.<p>While a step closer to Valhala, the whole dev experience is still quite lacking versus what .NET offers.<p>Currently is too much like making direct use of InteropServices.</div><br/><div id="40300929" class="c"><input type="checkbox" id="c-40300929" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300674">parent</a><span>|</span><a href="#40304051">next</a><span>|</span><label class="collapse" for="c-40300929">[-]</label><label class="expand" for="c-40300929">[13 more]</label></div><br/><div class="children"><div class="content">&gt; I still have some hopes that it will evolve towards a P&#x2F;Invoke like experience.<p>Doubtful, given that this is something we worked hard to avoid. To be efficient, a P&#x2F;Invoke-like model places restrictions on the runtime, which inhibits optimisation and flexibility and this cost is worth it only when native calls are relatively common. In Java they are rare and easily abstracted away, so we opted for a model that offers full control without giving up on abstraction, given that only a very small number of experts (&lt;1%) would directly write native calls and then hide them as implementation details. I&#x27;m not saying this approach is the right one for all languages, but it&#x27;s clearly the right one for Java given the frequency of native calls and who makes them.<p>Of course, you can wrap FFM with a higher-level P&#x2F;Invoke-like mechanism, but it won&#x27;t give you as much control.</div><br/><div id="40301157" class="c"><input type="checkbox" id="c-40301157" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300929">parent</a><span>|</span><a href="#40301910">next</a><span>|</span><label class="collapse" for="c-40301157">[-]</label><label class="expand" for="c-40301157">[9 more]</label></div><br/><div class="children"><div class="content">Well, for developers like myself that feel at home with JNI, the current development experience, even with jpackage, is too much to ask for.<p>I will rather keep writing C++ with JNI, instead of enduring the current boilerplate, specially if I already need to manually create header files to feed into jpackage, for basic stuff like struct definitions, which I don&#x27;t feel like writing by hand.<p>As for performance, this is something I agree with neonsunset, unless we see Techpowerbenchmarks level of Panama beating P&#x2F;Invoke, it is pretty much theoretical stuff at the expense of developer convience.</div><br/><div id="40302049" class="c"><input type="checkbox" id="c-40302049" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40301157">parent</a><span>|</span><a href="#40301820">next</a><span>|</span><label class="collapse" for="c-40302049">[-]</label><label class="expand" for="c-40302049">[7 more]</label></div><br/><div class="children"><div class="content">We can&#x27;t tailor every feature to the widely disparate preferences of so many developers nor do we try to convince every last developer of the merit of our approach -- this is both impractical and a losing strategy. Rather, we rely on our experience designing a highly successful language and platform, and consult with companies -- each employing thousands of Java developers -- and authors of some of the most popular relevant Java libraries to ensure that we meet their requirements. Of course, we also look at what other languages have done and the tradeoffs they&#x27;ve accepted (some of which may not be appropriate for Java [1]), but there are always many possible designs and we don&#x27;t adopt one from a less successful language <i>just</i> because it, too, has its fans.<p>I would encourage those who think that we&#x27;re <i>consistently</i> making suboptimal choices for Java compared to choices made by significantly less successful languages to consider whether it is possible that their preferences are not aligned with those of the software market at large. Java is and aims to continue being the world&#x27;s most popular language for serious server software, and that requires tailoring designs to a very large audience.<p>I always notice a certain lack of respect on forums such as HN for the world&#x27;s most consistently successful and popular languages -- JS, Java, and Python. Different programmers have different preferences and I&#x27;m all for rooting for the underdog now and again, but you simply cannot consistently make wrong decisions over a very long period of time and yet consistently win. What we do may not be everyone&#x27;s cup of tea (no language is), but it is clearly that of a whole lot of people. We work to offer value to them.<p>[1]: E.g. the design of native interop has significantly impacted that of user-mode threads (or lack thereof: <a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtimelab&#x2F;issues&#x2F;2398">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;runtimelab&#x2F;issues&#x2F;2398</a>) in both .NET and Go, and we weren&#x27;t willing to make such tradeoffs in either performance or programming model.</div><br/><div id="40303166" class="c"><input type="checkbox" id="c-40303166" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40302049">parent</a><span>|</span><a href="#40304147">next</a><span>|</span><label class="collapse" for="c-40303166">[-]</label><label class="expand" for="c-40303166">[2 more]</label></div><br/><div class="children"><div class="content">I can say that in my bubble we reach out for Java, because of Spring, AEM and Android.<p>That is it, other use cases, have other programming stacks.<p>As such our native libraries are written in consideration to be consumed at very least, across .NET (P&#x2F;Invoke,  C++&#x2F;CLI, COM), Java (JNI), nodejs (C++ addons), Swift.<p>So to move the existing development workflow from JNI to Panama, it must be an easy sell why we should budget rewrites to start with.<p>Also in regards to &quot;hate&quot;, if all decisions were that great there wouldn&#x27;t be needed to create a new library support group to help Java ecosystem actually move forward and adopt new Java versions, as I learned from JFokus related content.</div><br/><div id="40303242" class="c"><input type="checkbox" id="c-40303242" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40303166">parent</a><span>|</span><a href="#40304147">next</a><span>|</span><label class="collapse" for="c-40303242">[-]</label><label class="expand" for="c-40303242">[1 more]</label></div><br/><div class="children"><div class="content">You shouldn&#x27;t! We&#x27;re not trying to &quot;sell&quot; any rewrite from JNI to FFM. Since FFM is both significantly easier to use and offers better performance, most people would choose to write <i>new</i> interop code with FFM; that is an easy sell. But that&#x27;s not to say that these benefits justify a rewrite of <i>existing</i> code, and we have no plan to remove JNI. JNI and FFM can coexist in same program (and even in the same class). However, we are about to place the same protections on JNI as those we have on FFM to ensure that Java programs are free of undefined behaviour by default, and that modules that may introduce undefined behaviour are clearly acknowledged by the application so that the application owners may give them closer scrutiny if they wish [1].<p>To elaborate just a bit more on what I wrote in my previous comment, to get a straightforward interop with C you need to place certain restrictions on the runtime which limit your ability to implement certain abstractions such as moving GCs and user-mode threads. Because native interop requires special care anyway due to native memory management, which makes it significantly more complex than ordinary code and so less suitable for direct exposure to application developers -- so it&#x27;s best done by experts in the area -- and on top of that native calls in Java aren&#x27;t common, we decided not to sacrifice the runtime in favour of more direct interop. As a result, native interop is somewhat more elaborate to code, but as it requires some special expertise and so should be hidden away from application developers anyway, we decided it&#x27;s better to place the extra burden on the experts doing the interop rather than trade off runtime capabilities and performance. We think this is the better tradeoff for Java. Consequently, we have both compacting collectors and no performance penalty for native calls on virtual threads. Other languages made whatever tradeoffs they thought were right for them, but they did very clearly sacrifice something.<p>[1]: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;472" rel="nofollow">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;472</a></div><br/></div></div></div></div><div id="40304147" class="c"><input type="checkbox" id="c-40304147" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40302049">parent</a><span>|</span><a href="#40303166">prev</a><span>|</span><a href="#40301820">next</a><span>|</span><label class="collapse" for="c-40304147">[-]</label><label class="expand" for="c-40304147">[4 more]</label></div><br/><div class="children"><div class="content">A &quot;certain lack of respect&quot; comes from having to work with these languages for literally decades, and knowing their warts (and how those warts compare to some other similarly popular languages).<p>In general, being successful and popular had little to do with how well a PL is designed. Visual Basic, PHP, and even C are some historical examples that I have plenty of personal experience with.</div><br/><div id="40304534" class="c"><input type="checkbox" id="c-40304534" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40304147">parent</a><span>|</span><a href="#40301820">next</a><span>|</span><label class="collapse" for="c-40304534">[-]</label><label class="expand" for="c-40304534">[3 more]</label></div><br/><div class="children"><div class="content">&gt; In general, being successful and popular had little to do with how well a PL is designed.<p>Perhaps, but it is fairly easy to design a product for a small, self-selecting group of fans who find the aesthetics appealing and so declare the design good for their taste. Unless a language becomes heavily used in codebases that are maintained for years by a large variety of programmers, it&#x27;s hard to tell how well it is actually designed as a mass-appeal product.<p>Two of the three languages you mentioned weren&#x27;t able to attain nearly the same success as Java for as long a duration. I&#x27;d give C a similar success score because what it lacks in popularity it still makes up for in longevity, being almost twice as old. There are good reasons for why C is still as popular as it is. For example, in its domain -- which requires compilation to exotic architectures -- &quot;good design&quot; entails being able to easily implement efficient compilers.</div><br/><div id="40305224" class="c"><input type="checkbox" id="c-40305224" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40304534">parent</a><span>|</span><a href="#40301820">next</a><span>|</span><label class="collapse" for="c-40305224">[-]</label><label class="expand" for="c-40305224">[2 more]</label></div><br/><div class="children"><div class="content">Of course, when you compare languages, you have to compare them to contemporary ones that also target the same niche. In case of C, that would be e.g. Modula-2. The consequences of the industry making an expedient but wrong choice then - 45 years ago! - are still with us: C++ only just got proper modules, and even then most C++ code written today is still mostly using #include...<p>And to be clear, I&#x27;m not advocating for aesthetics here. It&#x27;s not like C# is a model of purity, either; but I would say that their choices over the years have been more pragmatic overall from the perspective of someone who needs to write readable, good quality code without jumping through too many hoops or getting lost in the verbiage.</div><br/><div id="40305914" class="c"><input type="checkbox" id="c-40305914" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40305224">parent</a><span>|</span><a href="#40301820">next</a><span>|</span><label class="collapse" for="c-40305914">[-]</label><label class="expand" for="c-40305914">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C# [..] but I would say that their choices over the years have been more pragmatic overall from the perspective of someone who needs to write readable, good quality code without jumping through too many hoops or getting lost in the verbiage.<p>I personally don’t agree with that, C# is very “impulsive” at adding new features, which sounds cool in isolation, but makes the language significantly more complex to understand, and has non-intuitive interactions with other features.<p>I think C# is quick at going the C++ way, and there is no return from there if we guarantee compatibility.<p>I much prefer Java’s approach, where yeah, at times one might lack some syntactic sugar&#x2F;nicety (often greatly overcome by IDE&#x2F;tooling’s advancements), but over time they do add important ones, but only commit to features that have been earnestly tried and sustainable.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40301820" class="c"><input type="checkbox" id="c-40301820" checked=""/><div class="controls bullet"><span class="by">_old_dude_</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40301157">parent</a><span>|</span><a href="#40302049">prev</a><span>|</span><a href="#40301910">next</a><span>|</span><label class="collapse" for="c-40301820">[-]</label><label class="expand" for="c-40301820">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  s&#x2F;jpackage&#x2F;jextract&#x2F;g</code></pre></div><br/></div></div></div></div><div id="40301910" class="c"><input type="checkbox" id="c-40301910" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300929">parent</a><span>|</span><a href="#40301157">prev</a><span>|</span><a href="#40304051">next</a><span>|</span><label class="collapse" for="c-40301910">[-]</label><label class="expand" for="c-40301910">[3 more]</label></div><br/><div class="children"><div class="content">&gt; [...] and this cost is worth it only when native calls are relatively common. In Java they are rare and easily abstracted away, [...] but it&#x27;s clearly the right one for Java given the frequency of native calls [...]<p>Native calls are rare in Java <i>because they&#x27;re such a pain</i>. If it wasn&#x27;t so hard to do native calls in Java, it would be common even for non-experts to make use of non-Java libraries.</div><br/><div id="40302180" class="c"><input type="checkbox" id="c-40302180" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40301910">parent</a><span>|</span><a href="#40305933">next</a><span>|</span><label class="collapse" for="c-40302180">[-]</label><label class="expand" for="c-40302180">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think so, given that there are more popular Java libraries than popular libraries with a C ABI. There is a small number of very popular C libraries that result in the majority of native call uses. But in any event, calling native libraries in Java is now no longer a pain thanks to FFM (and jextract [1]) so we&#x27;ll see.<p>Note that interaction with native libraries often requires a more careful management of native memory that, though much easier now with FFM, is still significantly trickier (and more dangerous in terms of introducing undefined behaviour) than interacting with Java code regardless of how that interaction is declared in code. In Java, as in Python, interaction with native code -- in the vast majority of cases -- is best encapsulated inside a Java library and not often directly exposed to application programmers.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;openjdk&#x2F;jextract">https:&#x2F;&#x2F;github.com&#x2F;openjdk&#x2F;jextract</a></div><br/></div></div><div id="40305933" class="c"><input type="checkbox" id="c-40305933" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40301910">parent</a><span>|</span><a href="#40302180">prev</a><span>|</span><a href="#40304051">next</a><span>|</span><label class="collapse" for="c-40305933">[-]</label><label class="expand" for="c-40305933">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly enough, this actually turned into a positive over time — also, java was usually fast enough (compared to python) to avoid reaching for native all the time, so it wasn’t as big a pain point, it managed to create an almost completely pure, 99.9% java ecosystem. This means that even very very complex java apps will basically work on every OS, unlike python and to a smaller extent nodejs, where some cryptic dependency is only for windows&#x2F;linux, etc.</div><br/></div></div></div></div></div></div></div></div><div id="40304051" class="c"><input type="checkbox" id="c-40304051" checked=""/><div class="controls bullet"><span class="by">miffy900</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40300374">parent</a><span>|</span><a href="#40300674">prev</a><span>|</span><a href="#40300922">next</a><span>|</span><label class="collapse" for="c-40304051">[-]</label><label class="expand" for="c-40304051">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This is similar, except more boilerplate and much, much slower.<p>That&#x27;s JNI, which really was truly terrible. Java 22 introducing FFM is finally an admission that JNI was crap and a dead end.</div><br/><div id="40305428" class="c"><input type="checkbox" id="c-40305428" checked=""/><div class="controls bullet"><span class="by">peterashford</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40304051">parent</a><span>|</span><a href="#40300922">next</a><span>|</span><label class="collapse" for="c-40305428">[-]</label><label class="expand" for="c-40305428">[3 more]</label></div><br/><div class="children"><div class="content">JNI worked it just wasnt as ergonomic as it could have been - which was on purpose. I disagree that Java should have discouraged use of JNI in that way but it was hardly &quot;crap and a dead end&quot;</div><br/><div id="40305687" class="c"><input type="checkbox" id="c-40305687" checked=""/><div class="controls bullet"><span class="by">miffy900</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40305428">parent</a><span>|</span><a href="#40300922">next</a><span>|</span><label class="collapse" for="c-40305687">[-]</label><label class="expand" for="c-40305687">[2 more]</label></div><br/><div class="children"><div class="content">&gt; JNI worked it just wasnt as ergonomic as it could have been - which was on purpose<p>There&#x27;s a reason they&#x27;re calling it the &#x27;FFM&#x27; API and not JNI v2. The API devs were correct in rethinking the approach to native interop.<p>This just proves my point; being crappy ON PURPOSE is why it&#x27;s a dead end; it&#x27;s very difficult to improve something that&#x27;s been deliberately designed badly.<p>Besides that, no Java dev in their right mind is going to continue to use JNI once they upgrade to Java 22 and realise FFM exists.</div><br/><div id="40306111" class="c"><input type="checkbox" id="c-40306111" checked=""/><div class="controls bullet"><span class="by">peterashford</span><span>|</span><a href="#40300285">root</a><span>|</span><a href="#40305687">parent</a><span>|</span><a href="#40300922">next</a><span>|</span><label class="collapse" for="c-40306111">[-]</label><label class="expand" for="c-40306111">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason to use it now, yes. It wasn&#x27;t a dead end because people absolutely could and were using it just fine (if not happily)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40303018" class="c"><input type="checkbox" id="c-40303018" checked=""/><div class="controls bullet"><span class="by">p0w3n3d</span><span>|</span><a href="#40300285">prev</a><span>|</span><a href="#40305259">next</a><span>|</span><label class="collapse" for="c-40303018">[-]</label><label class="expand" for="c-40303018">[2 more]</label></div><br/><div class="children"><div class="content">Last time I checked (ca. 2017-9) every call to foreign API in Java had to create a memory barrier causing flush of all CPU cache. This was different to using normal JVM interfaces and when I asked some guy on a Java conference, he told me they cheated during writing of  calls to JVM API, but other people need to adhere to rules. I wonder what happened in this matter in Java 22, as this change was highly expected</div><br/><div id="40303134" class="c"><input type="checkbox" id="c-40303134" checked=""/><div class="controls bullet"><span class="by">ryanpetrich</span><span>|</span><a href="#40303018">parent</a><span>|</span><a href="#40305259">next</a><span>|</span><label class="collapse" for="c-40303134">[-]</label><label class="expand" for="c-40303134">[1 more]</label></div><br/><div class="children"><div class="content">Memory barriers don&#x27;t force a flush of all CPU cache. They will enforce the ordering of memory operations issued before and after the barrier instruction, preserving the contents of the CPU&#x27;s various caches.</div><br/></div></div></div></div><div id="40305259" class="c"><input type="checkbox" id="c-40305259" checked=""/><div class="controls bullet"><span class="by">Dwedit</span><span>|</span><a href="#40303018">prev</a><span>|</span><label class="collapse" for="c-40305259">[-]</label><label class="expand" for="c-40305259">[1 more]</label></div><br/><div class="children"><div class="content">C# does a much better job of calling into C Code.  All the programmer has to do is either write a extern function with the &quot;DllImport&quot; attribute, or they can turn a raw function pointer into a delegate.  (Or even directly use a function pointer in newer versions of C#)</div><br/></div></div></div></div></div></div></div></body></html>