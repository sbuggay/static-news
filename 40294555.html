<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715158874819" as="style"/><link rel="stylesheet" href="styles.css?v=1715158874819"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fouronnes.github.io/cppiceberg/">The C++ Iceberg</a> <span class="domain">(<a href="https://fouronnes.github.io">fouronnes.github.io</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>51 comments</span></div><br/><div><div id="40295677" class="c"><input type="checkbox" id="c-40295677" checked=""/><div class="controls bullet"><span class="by">bingo3131</span><span>|</span><a href="#40294971">next</a><span>|</span><label class="collapse" for="c-40295677">[-]</label><label class="expand" for="c-40295677">[1 more]</label></div><br/><div class="children"><div class="content">For those who missed it: each item on the iceberg is actually a link that explains the topic in more detail.</div><br/></div></div><div id="40294971" class="c"><input type="checkbox" id="c-40294971" checked=""/><div class="controls bullet"><span class="by">camel-cdr</span><span>|</span><a href="#40295677">prev</a><span>|</span><a href="#40295295">next</a><span>|</span><label class="collapse" for="c-40294971">[-]</label><label class="expand" for="c-40294971">[2 more]</label></div><br/><div class="children"><div class="content">I love how crazy C and C++ can be sometimes.<p>We did a C preprocessor meta programming iceberg a while back: <a href="https:&#x2F;&#x2F;jadlevesque.github.io&#x2F;PPMP-Iceberg&#x2F;" rel="nofollow">https:&#x2F;&#x2F;jadlevesque.github.io&#x2F;PPMP-Iceberg&#x2F;</a></div><br/><div id="40295008" class="c"><input type="checkbox" id="c-40295008" checked=""/><div class="controls bullet"><span class="by">mog_dev</span><span>|</span><a href="#40294971">parent</a><span>|</span><a href="#40295295">next</a><span>|</span><label class="collapse" for="c-40295008">[-]</label><label class="expand" for="c-40295008">[1 more]</label></div><br/><div class="children"><div class="content">I really like this interactive iceberg !
Have you made any other?</div><br/></div></div></div></div><div id="40295295" class="c"><input type="checkbox" id="c-40295295" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#40294971">prev</a><span>|</span><a href="#40295419">next</a><span>|</span><label class="collapse" for="c-40295295">[-]</label><label class="expand" for="c-40295295">[27 more]</label></div><br/><div class="children"><div class="content">The most terrifying concept is still the good old undefined behavior. How is it possible that a simple `gets()` call can pop a reverse shell and empty your bank account? Or steal national secrets and potentially cause a war? Undefined truly means undefined, though few people realize the scope at first when they read those innocent sounding words:<p><i>The behavior is undefined</i></div><br/><div id="40295363" class="c"><input type="checkbox" id="c-40295363" checked=""/><div class="controls bullet"><span class="by">wolletd</span><span>|</span><a href="#40295295">parent</a><span>|</span><a href="#40295362">next</a><span>|</span><label class="collapse" for="c-40295363">[-]</label><label class="expand" for="c-40295363">[12 more]</label></div><br/><div class="children"><div class="content">What I don&#x27;t get is, why are we still adding more undefined behaviour to the standard?<p>For example, C++23 got std::unreachable. From my dips into Rust, I expected something similar to std::abort, terminating the program in some sane and possibly helpful way.<p>However, in C++, std::unreachable just invokes undefined behaviour when called. It&#x27;s not usable as a guard from programming errors, it&#x27;s just an optimization hint. You still have to write the guard yourself.<p>I&#x27;m left wondering about the use-cases for this.</div><br/><div id="40295441" class="c"><input type="checkbox" id="c-40295441" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295577">next</a><span>|</span><label class="collapse" for="c-40295441">[-]</label><label class="expand" for="c-40295441">[3 more]</label></div><br/><div class="children"><div class="content">std::unreachable is actually a quite useful optimisation tool. For instance if you are sure that a switch-case default branch is actually unreachable you can put a std::unreachable into the default-branch to hint the compiler that it may remove a range check in front of the switch-case jump table access (since you promised to the compiler that the default branch is never reached).<p>It&#x27;s a double edged sword of course. If control flow actually hits the default branch, then all bets are off (because that means the code will access an out-of-range jump table slot and jump somewhere into the wilderness).<p>AFAIK compilers are free to perform something like Rust&#x27;s panic when std::unreachable is actually hit, but that makes only sense in debug mode. Because in the above example, the compiler would need to add a range check to figure out if panic needs to be called and that would completely defeat the idea of removing that range check in the first place.</div><br/><div id="40295609" class="c"><input type="checkbox" id="c-40295609" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295441">parent</a><span>|</span><a href="#40295577">next</a><span>|</span><label class="collapse" for="c-40295609">[-]</label><label class="expand" for="c-40295609">[2 more]</label></div><br/><div class="children"><div class="content">I recommend omitting the default case and putting std::unreachable() outside the switch and omitting the default label for the sole reason that compilers are more likely to warn for a missed case label this way (-Wswitch vs -Wswitch-enum in gcc&#x2F;clang, the former is included in -Wall, the latter isn&#x27;t included even in -Wextra).<p>This also allows expressing intent: no default label means that I meant to handle all cases, and having a default means that I opted into a fallback, please don&#x27;t warn. That&#x27;s probably why -Wswitch-enum isn&#x27;t enabled by default, too many false positives without a convenient way to suppress the warning.</div><br/><div id="40295684" class="c"><input type="checkbox" id="c-40295684" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295609">parent</a><span>|</span><a href="#40295577">next</a><span>|</span><label class="collapse" for="c-40295684">[-]</label><label class="expand" for="c-40295684">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, how would that look like? Like this?<p><pre><code>    if ((val &lt; min) || (val &gt;= max)) {
        __builtin_unreachable();
    }
    switch (val) {
        ...
    }
</code></pre>
I haven&#x27;t actually tried that, but if it works as intended it would actually be better yeah (not really in the case where I&#x27;m using it, because I&#x27;m switching on an integer, not an enum).</div><br/></div></div></div></div></div></div><div id="40295577" class="c"><input type="checkbox" id="c-40295577" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295441">prev</a><span>|</span><a href="#40295632">next</a><span>|</span><label class="collapse" for="c-40295577">[-]</label><label class="expand" for="c-40295577">[1 more]</label></div><br/><div class="children"><div class="content">Rust has core::hint::unreachable_unchecked, which is an unsafe function that, since we promised never to call it, also promises never to return. This has Undefined Behaviour if you call it, since you formally promised not to (the consequence of unsafely promising something and then going back on it is usually Undefined Behaviour in Rust).<p>Rust does also have the safe macro core::unreachable which will panic if reached, but while the compiler can assume this <i>probably</i> won&#x27;t happen and optimise accordingly, it usually can&#x27;t know that it won&#x27;t happen (and if it can your decision to add the macro may be unwise)<p>One reason C++ gets more and more Undefined Behaviour is consistency. The committee will, unless prompted hard not to, draw analogies to existing UB in the language and use that to justify making your new thing Undefined in the tricky cases. The results are pretty embarrassing.</div><br/></div></div><div id="40295632" class="c"><input type="checkbox" id="c-40295632" checked=""/><div class="controls bullet"><span class="by">shultays</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295577">prev</a><span>|</span><a href="#40295606">next</a><span>|</span><label class="collapse" for="c-40295632">[-]</label><label class="expand" for="c-40295632">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  What I don&#x27;t get is, why are we still adding more undefined behaviour to the standard?
</code></pre>
Because it allows flexibility for compilers to implement features efficiently on various platforms.<p>You can define undefined behavior if you wish. Make your own unreachable that prints an error and aborts gracefully when reached in debug builds, and calls std::unreachable in release builds.</div><br/></div></div><div id="40295606" class="c"><input type="checkbox" id="c-40295606" checked=""/><div class="controls bullet"><span class="by">elsjaako</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295632">prev</a><span>|</span><a href="#40295532">next</a><span>|</span><label class="collapse" for="c-40295606">[-]</label><label class="expand" for="c-40295606">[2 more]</label></div><br/><div class="children"><div class="content">You might be interested in the compiler option -fsanitize=undefined. I think it works for gcc and clang. I don&#x27;t think it catches all undefined behavior, but it catches some.</div><br/><div id="40295648" class="c"><input type="checkbox" id="c-40295648" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295606">parent</a><span>|</span><a href="#40295532">next</a><span>|</span><label class="collapse" for="c-40295648">[-]</label><label class="expand" for="c-40295648">[1 more]</label></div><br/><div class="children"><div class="content">On libstdc++ std::unreachable() also reliably crashes if you define either _GLIBCXX_DEBUG or _GLIBCXX_ASSERTIONS. libc++ should have a similar macro. I expect MS STL to also reliably crash on debug builds here, as it&#x27;s quite heavy on debug assertions in the standard library anyway by default (and debug and release builds are explicitly not ABI compatible there).</div><br/></div></div></div></div><div id="40295532" class="c"><input type="checkbox" id="c-40295532" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295606">prev</a><span>|</span><a href="#40295372">next</a><span>|</span><label class="collapse" for="c-40295532">[-]</label><label class="expand" for="c-40295532">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t &#x27;invoke&#x27; undefined behavior in the sense that it calls some function &#x27;doRandomShit()&#x27;.<p>What happens is:
Compilers sees unreachable and assumes that this codepath will never run, so it just yeet it out of existence.
For example, maybe it will remove the preceding if-statement and rather then check its condition, just insert true or false. Afterall, why waste computing on checking condition if we know it will <i>never</i> resolve to the unreachable path.<p>In Rust, the same if-statement won&#x27;t be optimized away, and if the code happens to go for the unreachable path, it will call panic.<p>Now, the example is a simplification, but it&#x27;s just to demonstrate that UB comes from compilers (verry aggressively) assuming UB will never happen, and not because someone decided to &quot;add it&quot;.</div><br/></div></div><div id="40295372" class="c"><input type="checkbox" id="c-40295372" checked=""/><div class="controls bullet"><span class="by">bun_terminator</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295532">prev</a><span>|</span><a href="#40295610">next</a><span>|</span><label class="collapse" for="c-40295372">[-]</label><label class="expand" for="c-40295372">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s faster and&#x2F;or easier to implement. Sometimes a lot</div><br/><div id="40295397" class="c"><input type="checkbox" id="c-40295397" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295372">parent</a><span>|</span><a href="#40295610">next</a><span>|</span><label class="collapse" for="c-40295397">[-]</label><label class="expand" for="c-40295397">[1 more]</label></div><br/><div class="children"><div class="content">And if you ever reach it then maybe the program will crash, or maybe demons will start flying out of your nose. No one really knows, and that&#x27;s what makes undefined behavior exciting!</div><br/></div></div></div></div><div id="40295610" class="c"><input type="checkbox" id="c-40295610" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295363">parent</a><span>|</span><a href="#40295372">prev</a><span>|</span><a href="#40295362">next</a><span>|</span><label class="collapse" for="c-40295610">[-]</label><label class="expand" for="c-40295610">[1 more]</label></div><br/><div class="children"><div class="content">-funreachable-traps</div><br/></div></div></div></div><div id="40295362" class="c"><input type="checkbox" id="c-40295362" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40295295">parent</a><span>|</span><a href="#40295363">prev</a><span>|</span><a href="#40295561">next</a><span>|</span><label class="collapse" for="c-40295362">[-]</label><label class="expand" for="c-40295362">[10 more]</label></div><br/><div class="children"><div class="content">The UB mess only started when compiler writers decided it is ok to exploit UB for optimisations which then leads to wildly unpredictable behaviour when you actually hit UB.<p>But also: turn warnings to 11, use UBSAN, ASAN, TSAN and static analysers. These are all easy steps to make C and C++ code a lot more robust.</div><br/><div id="40295531" class="c"><input type="checkbox" id="c-40295531" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295362">parent</a><span>|</span><a href="#40295561">next</a><span>|</span><label class="collapse" for="c-40295531">[-]</label><label class="expand" for="c-40295531">[9 more]</label></div><br/><div class="children"><div class="content">No, UB has always been just undefined. `gets()`, one of the most exploited functions in the history of computers, does not require any clever malice from the compiler. And there are a lot of such examples. In fact practice has shown that it has always been very, very hard to write a program that cannot reach UB.<p>Thinking that you know what `undefined` really is results in undefined behavior.</div><br/><div id="40295631" class="c"><input type="checkbox" id="c-40295631" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295531">parent</a><span>|</span><a href="#40295567">next</a><span>|</span><label class="collapse" for="c-40295631">[-]</label><label class="expand" for="c-40295631">[4 more]</label></div><br/><div class="children"><div class="content">Just because &#x27;undefined behaviour&#x27; means &#x27;theoretically anything can happen&#x27; doesn&#x27;t mean that it will happen in practice. You also don&#x27;t need to summon the UB ghosts to delete your all files, a regular logic bug works just as well, even in a language without any UB.<p>In older compilers, UB behaviour was a lot more predictable because the code transformations done by optimizing compilers were by far not as complex as today.<p>In the C standard, &#x27;undefined behaviour&#x27; is basically a catch-all phrase for a lot of different things: from badly designed stdlib function that miss obvious security checks (like gets()) to the compiler generating non-sensical code.<p>The latter is what&#x27;s much more dangerous. It&#x27;s trivial to just not use the C stdlib  functions, but code generation problems caused by UB are much harder to catch.</div><br/><div id="40295670" class="c"><input type="checkbox" id="c-40295670" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295631">parent</a><span>|</span><a href="#40295567">next</a><span>|</span><label class="collapse" for="c-40295670">[-]</label><label class="expand" for="c-40295670">[3 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s the former that&#x27;s more dangerous, and it has been there from the beginning. Every time you dereference a bad pointer (already free&#x27;d, corrupted, badly casted, ...), every time you go over the bounds of some array, every time you read memory that hasn&#x27;t been initialized, every time you (write) access the same memory from two threads without synchronization, etc. - this is the bread and butter of binary exploitation. Exploits are fully expected under C&#x2F;C++ spec, after all <i>the behavior is undefined</i>.</div><br/><div id="40295717" class="c"><input type="checkbox" id="c-40295717" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295670">parent</a><span>|</span><a href="#40295567">next</a><span>|</span><label class="collapse" for="c-40295717">[-]</label><label class="expand" for="c-40295717">[2 more]</label></div><br/><div class="children"><div class="content">But at the same time it is totally expected in C and C++ that range checking is the responsibility of the programmer, and most of those problems are trivial to catch with Valgrind or ASAN. E.g. yes, it is a problem, yes, 70% of all CVEs are caused by memory corruption, <i>but</i> the problem is totally obvious and trivial to debug. It&#x27;s basically part of the contract when deciding to use C or C++.<p>Compared to such &#x27;obvious&#x27; memory corruption problems caused by invalid pointers or missing range checks, obscure code generation issues caused by UB are much harder to identify and the behaviour may also change randomly between compiler versions - <i>this</i> is the actually scary thing about UB, and it&#x27;s also a relatively &quot;new&quot; thing.</div><br/><div id="40295807" class="c"><input type="checkbox" id="c-40295807" checked=""/><div class="controls bullet"><span class="by">H8crilA</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295717">parent</a><span>|</span><a href="#40295567">next</a><span>|</span><label class="collapse" for="c-40295807">[-]</label><label class="expand" for="c-40295807">[1 more]</label></div><br/><div class="children"><div class="content">The point is exactly that &quot;it is totally expected&quot;, and it has caused massive losses over the decades. It has been abused for everything ranging from turning your friend&#x27;s PC off, to ransomware, to state-on-state espionage and even causing nuclear incidents in Iran&#x27;s enrichment facilities.<p><i>The behavior is undefined.</i></div><br/></div></div></div></div></div></div></div></div><div id="40295567" class="c"><input type="checkbox" id="c-40295567" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295531">parent</a><span>|</span><a href="#40295631">prev</a><span>|</span><a href="#40295561">next</a><span>|</span><label class="collapse" for="c-40295567">[-]</label><label class="expand" for="c-40295567">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not like UB is some magic functions that gets called when encountering UB.<p>Every UB could verry well be wrapped in error checking and we could have 0 UB out there.
We don&#x27;t do that, but that&#x27;s because of (our) choice, not some superficial entity that poses machine when running into UB.</div><br/><div id="40295630" class="c"><input type="checkbox" id="c-40295630" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295567">parent</a><span>|</span><a href="#40295561">next</a><span>|</span><label class="collapse" for="c-40295630">[-]</label><label class="expand" for="c-40295630">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Every UB could very well be wrapped in error checking<p>Not in C and C++. How would you check that a pointer is safe to dereference for example?</div><br/><div id="40295687" class="c"><input type="checkbox" id="c-40295687" checked=""/><div class="controls bullet"><span class="by">Xeamek</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295630">parent</a><span>|</span><a href="#40295561">next</a><span>|</span><label class="collapse" for="c-40295687">[-]</label><label class="expand" for="c-40295687">[2 more]</label></div><br/><div class="children"><div class="content">What do you mean?
Just check if it&#x27;s not null?</div><br/><div id="40295777" class="c"><input type="checkbox" id="c-40295777" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295687">parent</a><span>|</span><a href="#40295561">next</a><span>|</span><label class="collapse" for="c-40295777">[-]</label><label class="expand" for="c-40295777">[1 more]</label></div><br/><div class="children"><div class="content">Not all non-null pointers are safe to dereference.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40295561" class="c"><input type="checkbox" id="c-40295561" checked=""/><div class="controls bullet"><span class="by">qiqitori</span><span>|</span><a href="#40295295">parent</a><span>|</span><a href="#40295362">prev</a><span>|</span><a href="#40295528">next</a><span>|</span><label class="collapse" for="c-40295561">[-]</label><label class="expand" for="c-40295561">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the standard (C99) uses the term &quot;undefined&quot; in its description of the gets() function. (Also gets has been removed from the standard in C11.) But maybe it uses the term to describe what happens when you change memory that shouldn&#x27;t be changed. Well, what do you think the C standard should say in such a case, without knowledge of the system you&#x27;re running on?<p>There are of course some functions where it would have been nice to allow passing in an invalid value and the function just returning its normal error or &quot;no&quot; return value. E.g. isalnum might be nicer if it didn&#x27;t crash for input &gt; 255. (But perhaps it&#x27;s not possible in all implementations without adding some other constraints that didn&#x27;t exist before.)</div><br/></div></div><div id="40295528" class="c"><input type="checkbox" id="c-40295528" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40295295">parent</a><span>|</span><a href="#40295561">prev</a><span>|</span><a href="#40295402">next</a><span>|</span><label class="collapse" for="c-40295528">[-]</label><label class="expand" for="c-40295528">[2 more]</label></div><br/><div class="children"><div class="content">Forget gets() - that&#x27;s obviously a terrible idea, and most people see immediately why, it is no longer in modern C for example.<p>Consider that abs() of signed integers has UB! Because the signed integers aren&#x27;t balanced it&#x27;s tricky to decide what should happen if we abs() the most negative value of a particular size of signed integer. In a language like Rust you get to specify what you meant here, if you don&#x27;t then you get a panic when it happens. But C++ instead gives this... Undefined Behaviour!<p>Or take division by zero. It&#x27;s easy enough to say that you think the signed integers should have wrapping arithmetic. Doesn&#x27;t make much sense, but hey, it&#x27;s <i>defined</i> at least. However, even if you define overflow as wrapping, division by zero is a different problem. In Rust they can explicitly say this can&#x27;t happen using NonZero types (e.g. NonZeroI16 is a 16-bit signed integer, but it can&#x27;t be zero) and get the high performance machine code, but in C++ to get that same code they just say division by zero is Undefined Behaviour.</div><br/><div id="40295605" class="c"><input type="checkbox" id="c-40295605" checked=""/><div class="controls bullet"><span class="by">nneonneo</span><span>|</span><a href="#40295295">root</a><span>|</span><a href="#40295528">parent</a><span>|</span><a href="#40295402">next</a><span>|</span><label class="collapse" for="c-40295605">[-]</label><label class="expand" for="c-40295605">[1 more]</label></div><br/><div class="children"><div class="content">gets() might be (mostly) gone, but scanf(“%s”, buf) still exists and produces no warnings or errors from the compiler.</div><br/></div></div></div></div></div></div><div id="40295419" class="c"><input type="checkbox" id="c-40295419" checked=""/><div class="controls bullet"><span class="by">axegon_</span><span>|</span><a href="#40295295">prev</a><span>|</span><a href="#40295286">next</a><span>|</span><label class="collapse" for="c-40295419">[-]</label><label class="expand" for="c-40295419">[1 more]</label></div><br/><div class="children"><div class="content">Kudos to whoever made this. No, really, thanks for making me laugh, I needed this.</div><br/></div></div><div id="40295286" class="c"><input type="checkbox" id="c-40295286" checked=""/><div class="controls bullet"><span class="by">Deeg9rie9usi</span><span>|</span><a href="#40295419">prev</a><span>|</span><a href="#40295360">next</a><span>|</span><label class="collapse" for="c-40295286">[-]</label><label class="expand" for="c-40295286">[1 more]</label></div><br/><div class="children"><div class="content">Dupes:
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40273141">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40273141</a>
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39384093">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39384093</a></div><br/></div></div><div id="40295360" class="c"><input type="checkbox" id="c-40295360" checked=""/><div class="controls bullet"><span class="by">yu3zhou4</span><span>|</span><a href="#40295286">prev</a><span>|</span><a href="#40294950">next</a><span>|</span><label class="collapse" for="c-40295360">[-]</label><label class="expand" for="c-40295360">[2 more]</label></div><br/><div class="children"><div class="content">It would be great to get an explanation for each of items here for non-C++ devs</div><br/><div id="40295664" class="c"><input type="checkbox" id="c-40295664" checked=""/><div class="controls bullet"><span class="by">QuackyTheDuck</span><span>|</span><a href="#40295360">parent</a><span>|</span><a href="#40294950">next</a><span>|</span><label class="collapse" for="c-40295664">[-]</label><label class="expand" for="c-40295664">[1 more]</label></div><br/><div class="children"><div class="content">Just click on a term to be redirected to an explanation.</div><br/></div></div></div></div><div id="40294950" class="c"><input type="checkbox" id="c-40294950" checked=""/><div class="controls bullet"><span class="by">bun_terminator</span><span>|</span><a href="#40295360">prev</a><span>|</span><a href="#40295468">next</a><span>|</span><label class="collapse" for="c-40294950">[-]</label><label class="expand" for="c-40294950">[4 more]</label></div><br/><div class="children"><div class="content">A lot of classic c++isms, some good ones. constexpr weirdness is among my top choices</div><br/><div id="40295411" class="c"><input type="checkbox" id="c-40295411" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40294950">parent</a><span>|</span><a href="#40295438">next</a><span>|</span><label class="collapse" for="c-40295411">[-]</label><label class="expand" for="c-40295411">[2 more]</label></div><br/><div class="children"><div class="content">&gt; A good way to think about constant expressions is that `constexpr` is a hint that lets the compiler know that the variable or function CAN be evaluated at compile time, but it is not required<p>In D, CTFE (Compile Time Function Evaluation) is guaranteed to run at compile time. CTFE happens whenever there&#x27;s a constant-expression in the grammar, such as the initialization of an enum:<p><pre><code>    enum A = func(3);
</code></pre>
func(3) evaluates at compile time.</div><br/><div id="40295655" class="c"><input type="checkbox" id="c-40295655" checked=""/><div class="controls bullet"><span class="by">bingo3131</span><span>|</span><a href="#40294950">root</a><span>|</span><a href="#40295411">parent</a><span>|</span><a href="#40295438">next</a><span>|</span><label class="collapse" for="c-40295655">[-]</label><label class="expand" for="c-40295655">[1 more]</label></div><br/><div class="children"><div class="content">Calling it a hint is very much over-simplifying things as there are also restrictions on what a constexpr function is and is not allowed to do, although those restrictions become fewer and fewer as time goes on as compilers are so advanced that they can emulate more system level things at compile time.<p>Also, constexpr on a variable is not a hint - it must be evaluated at compile time, where-as a constexpr function will be evaluated at either compile time or runtime depending on the context and arguments passed to it. For a function that you either want to work at compile time or not at all (compile error), consteval is the hardened version.<p>Yes, sadly this means &quot;constexpr&quot; variables and &quot;consteval&quot; functions must be calculated at compile time, while &quot;constexpr&quot; functions can be used both at compile time and runtime. An annoying distinction.</div><br/></div></div></div></div><div id="40295438" class="c"><input type="checkbox" id="c-40295438" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#40294950">parent</a><span>|</span><a href="#40295411">prev</a><span>|</span><a href="#40295468">next</a><span>|</span><label class="collapse" for="c-40295438">[-]</label><label class="expand" for="c-40295438">[1 more]</label></div><br/><div class="children"><div class="content">I agree, but the &quot;constexpr&quot; weirdness links to a video with a clickbait title.<p>You are expected to watch most of the video, before learning that the purpose of the video is to argue that in almost all cases one should use &quot;static constexpr&quot; and not just &quot;constexpr&quot;.<p>The argumentation can be interesting, but it would have been nicer to just state the conclusion from the beginning, allowing a decision of whether it is desirable to spend time to also know the reasons for this.</div><br/></div></div></div></div><div id="40295468" class="c"><input type="checkbox" id="c-40295468" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#40294950">prev</a><span>|</span><a href="#40295140">next</a><span>|</span><label class="collapse" for="c-40295468">[-]</label><label class="expand" for="c-40295468">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s also the <i>Static Initialization Order Fiasco</i>.</div><br/></div></div><div id="40295140" class="c"><input type="checkbox" id="c-40295140" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#40295468">prev</a><span>|</span><a href="#40294993">next</a><span>|</span><label class="collapse" for="c-40295140">[-]</label><label class="expand" for="c-40295140">[1 more]</label></div><br/><div class="children"><div class="content">Damn, I should write more C++ again. I am missing so much fun. (Edit: I am not sure myself if I mean this sarcastic or not)</div><br/></div></div><div id="40294993" class="c"><input type="checkbox" id="c-40294993" checked=""/><div class="controls bullet"><span class="by">DonHopkins</span><span>|</span><a href="#40295140">prev</a><span>|</span><a href="#40295066">next</a><span>|</span><label class="collapse" for="c-40294993">[-]</label><label class="expand" for="c-40294993">[1 more]</label></div><br/><div class="children"><div class="content">The PHP Hammer would be the perfect tool to chip away at the C++ Iceberg with!<p><a href="https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;the-php-singularity&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.codinghorror.com&#x2F;the-php-singularity&#x2F;</a></div><br/></div></div><div id="40295066" class="c"><input type="checkbox" id="c-40295066" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40294993">prev</a><span>|</span><label class="collapse" for="c-40295066">[-]</label><label class="expand" for="c-40295066">[9 more]</label></div><br/><div class="children"><div class="content">inline definitely means inline, as in the definition is provided in-line with the declaration.<p>People are just confusing it with the inlining optimization that a compiler might do.</div><br/><div id="40295100" class="c"><input type="checkbox" id="c-40295100" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#40295066">parent</a><span>|</span><a href="#40295420">next</a><span>|</span><label class="collapse" for="c-40295100">[-]</label><label class="expand" for="c-40295100">[7 more]</label></div><br/><div class="children"><div class="content">It’s more precise to say that inline means “this definition might be duplicated.” Non-inline functions also are allowed to have their definitions provided inline with the declaration; the difference is that the linker will error if it encounters a duplicate non-inline definition.</div><br/><div id="40295167" class="c"><input type="checkbox" id="c-40295167" checked=""/><div class="controls bullet"><span class="by">josemanuel</span><span>|</span><a href="#40295066">root</a><span>|</span><a href="#40295100">parent</a><span>|</span><a href="#40295177">next</a><span>|</span><label class="collapse" for="c-40295167">[-]</label><label class="expand" for="c-40295167">[3 more]</label></div><br/><div class="children"><div class="content">Are you thinking of &quot;weak&quot; rather than &quot;inline&quot;?
I always thought of &quot;inline&quot; as a hint to the compiler -- the compiler can inline, but it may not, depending on some compiler-specific optimisation objective (execution speed, code size, ...).</div><br/><div id="40295400" class="c"><input type="checkbox" id="c-40295400" checked=""/><div class="controls bullet"><span class="by">tylerhou</span><span>|</span><a href="#40295066">root</a><span>|</span><a href="#40295167">parent</a><span>|</span><a href="#40295179">next</a><span>|</span><label class="collapse" for="c-40295400">[-]</label><label class="expand" for="c-40295400">[1 more]</label></div><br/><div class="children"><div class="content">No, I am not thinking of weak; this is why “inline does not mean inline” is on the iceberg :). Although practically speaking inline is also used as a hint. But chiefly it refers to inline linkage.<p>I’m actually also not familiar with weak, but a quick glance suggests that it might not mean the same thing as inline. Can weak symbols be defined multiple times? EDIT: yes, according to an SO post compilers often use weak to implement inline.</div><br/></div></div><div id="40295179" class="c"><input type="checkbox" id="c-40295179" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40295066">root</a><span>|</span><a href="#40295167">parent</a><span>|</span><a href="#40295400">prev</a><span>|</span><a href="#40295177">next</a><span>|</span><label class="collapse" for="c-40295179">[-]</label><label class="expand" for="c-40295179">[1 more]</label></div><br/><div class="children"><div class="content">You thought wrong.<p>Marking the symbol as weak is what inline indeed does from a technical point of view.</div><br/></div></div></div></div><div id="40295177" class="c"><input type="checkbox" id="c-40295177" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#40295066">root</a><span>|</span><a href="#40295100">parent</a><span>|</span><a href="#40295167">prev</a><span>|</span><a href="#40295420">next</a><span>|</span><label class="collapse" for="c-40295177">[-]</label><label class="expand" for="c-40295177">[3 more]</label></div><br/><div class="children"><div class="content">I fail to see how it&#x27;s more precise. Obviously if the definition is inline, it&#x27;s duplicated in every point where the declaration is imported.<p>Beginners fail to understand for example that providing a class member function definition within the class definition makes it inline, but that&#x27;s already what you&#x27;re doing textually, and that&#x27;s what the keyword means.</div><br/><div id="40295809" class="c"><input type="checkbox" id="c-40295809" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40295066">root</a><span>|</span><a href="#40295177">parent</a><span>|</span><a href="#40295319">next</a><span>|</span><label class="collapse" for="c-40295809">[-]</label><label class="expand" for="c-40295809">[1 more]</label></div><br/><div class="children"><div class="content">If you textually define a function &quot;inline&quot; in an header file yet do not mark it inline, you are duplicating it in every point where the declaration is imported, yet, not being inline for linkage purposes, you will get compilation errors.<p>Member and template functions are special cased to be implicitly inline.</div><br/></div></div><div id="40295319" class="c"><input type="checkbox" id="c-40295319" checked=""/><div class="controls bullet"><span class="by">wolletd</span><span>|</span><a href="#40295066">root</a><span>|</span><a href="#40295177">parent</a><span>|</span><a href="#40295809">prev</a><span>|</span><a href="#40295420">next</a><span>|</span><label class="collapse" for="c-40295319">[-]</label><label class="expand" for="c-40295319">[1 more]</label></div><br/><div class="children"><div class="content">You can declare and inline-define a function in a CPP file and you don&#x27;t need inline because there are no other places that can import it.<p>It&#x27;s only needed for functions defined in header files where multiple definitions may exist after compiling object files.</div><br/></div></div></div></div></div></div><div id="40295420" class="c"><input type="checkbox" id="c-40295420" checked=""/><div class="controls bullet"><span class="by">112233</span><span>|</span><a href="#40295066">parent</a><span>|</span><a href="#40295100">prev</a><span>|</span><label class="collapse" for="c-40295420">[-]</label><label class="expand" for="c-40295420">[1 more]</label></div><br/><div class="children"><div class="content">Definition of inline members definitely does not have to appear with declaration (and usually does not for legibility reasons).<p><pre><code>    struct X { inline void f(); };
</code></pre>
is a perfectly valid inline.</div><br/></div></div></div></div></div></div></div></div></div></body></html>