<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705568482567" as="style"/><link rel="stylesheet" href="styles.css?v=1705568482567"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://notes.jordanscales.com/infinite-lists">Operating on infinite lists</a>Â <span class="domain">(<a href="https://notes.jordanscales.com">notes.jordanscales.com</a>)</span></div><div class="subtext"><span>azhenley</span> | <span>5 comments</span></div><br/><div><div id="39039318" class="c"><input type="checkbox" id="c-39039318" checked=""/><div class="controls bullet"><span class="by">tomsmeding</span><span>|</span><a href="#39039280">next</a><span>|</span><label class="collapse" for="c-39039318">[-]</label><label class="expand" for="c-39039318">[1 more]</label></div><br/><div class="children"><div class="content">Very much inspired by lazy functional programming :)<p>Because of the inherent laziness in the language, Haskell&#x27;s list type works like this. Except better: if you walk over a list, examining its values, you have to call those functions; but Haskell then stores (memoises) those results, so that the second time you walk over the list, the functions don&#x27;t need to be called again since that initial part is already evaluated. This is what functional programming people refer to when they say <i>call-by-need</i>.<p>This is particularly helpful if the computation to produce the list is expensive. For example, (weird example, sorry) a list of every 1000th prime number. That gets moderately more expensive as you look at bigger and bigger numbers, so it would be good not to do that many times if you can help it.</div><br/></div></div><div id="39039280" class="c"><input type="checkbox" id="c-39039280" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#39039318">prev</a><span>|</span><a href="#39039177">next</a><span>|</span><label class="collapse" for="c-39039280">[-]</label><label class="expand" for="c-39039280">[1 more]</label></div><br/><div class="children"><div class="content">I would have just used a generator function or a recursive objective. You&#x27;re allowed to define objects with more than 1 statement.</div><br/></div></div><div id="39039177" class="c"><input type="checkbox" id="c-39039177" checked=""/><div class="controls bullet"><span class="by">LesZedCB</span><span>|</span><a href="#39039280">prev</a><span>|</span><a href="#39038936">next</a><span>|</span><label class="collapse" for="c-39039177">[-]</label><label class="expand" for="c-39039177">[1 more]</label></div><br/><div class="children"><div class="content">summoning a lisp from the aether never gets old</div><br/></div></div><div id="39038936" class="c"><input type="checkbox" id="c-39038936" checked=""/><div class="controls bullet"><span class="by">m-a-r-c-e-l</span><span>|</span><a href="#39039177">prev</a><span>|</span><label class="collapse" for="c-39038936">[-]</label><label class="expand" for="c-39038936">[1 more]</label></div><br/><div class="children"><div class="content">Very nice approach...</div><br/></div></div></div></div></div></div></div></body></html>