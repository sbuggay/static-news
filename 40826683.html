<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719651672257" as="style"/><link rel="stylesheet" href="styles.css?v=1719651672257"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://words.filippo.io/dispatches/xaes-256-gcm/">The XAES-256-GCM extended-nonce AEAD</a> <span class="domain">(<a href="https://words.filippo.io">words.filippo.io</a>)</span></div><div class="subtext"><span>FiloSottile</span> | <span>22 comments</span></div><br/><div><div id="40828231" class="c"><input type="checkbox" id="c-40828231" checked=""/><div class="controls bullet"><span class="by">dchest</span><span>|</span><a href="#40827440">next</a><span>|</span><label class="collapse" for="c-40828231">[-]</label><label class="expand" for="c-40828231">[2 more]</label></div><br/><div class="children"><div class="content">The design is very clever: since it&#x27;s based on CMAC, we can use AES-CBC to derive keys where lower level primitives are not available.<p>In AES-CBC terms, the algorithm can be described as:<p><pre><code>    1. L = AES-CBC-256ₖ(iv = 0¹²⁸, plaintext = 0¹²⁸)[:16]
    2. If MSB₁(L) = 0, then K1 = L &lt;&lt; 1;
       Else K1 = (L &lt;&lt; 1) ⊕ 0¹²⁰10000111
    3. M1 = 0x00 || 0x01 || X || 0x00 || N[:12]
    4. M2 = 0x00 || 0x02 || X || 0x00 || N[:12]
    5. Kₓ = AES-CBC-256ₖ(iv = K1, plaintext = M1)[:16] || AES-CBC-256ₖ(iv = K1, plaintext = M2)[:16]
    6. Nₓ = N[12:]
</code></pre>
Where AES-CBC-256 returns the first 128-bit block of the ciphertext, discarding the padded block. (Thus, if you can&#x27;t turn off padding, it costs three additional AES calls with the same key compared to a lower level implementation — not bad). After deriving a key, use it with the standard AES-GCM.<p>Here&#x27;s my JS implementation based on WebCrypto API, which uses this fact: <a href="https:&#x2F;&#x2F;github.com&#x2F;dchest&#x2F;xaes">https:&#x2F;&#x2F;github.com&#x2F;dchest&#x2F;xaes</a><p>It accepts a proper CryptoKey intended for AES-CBC, supporting all CryptoKey features, e.g. storing it in IndexedDB with &quot;extractable&quot; bit set to false.<p>Great job, Filippo!</div><br/><div id="40828819" class="c"><input type="checkbox" id="c-40828819" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#40828231">parent</a><span>|</span><a href="#40827440">next</a><span>|</span><label class="collapse" for="c-40828819">[-]</label><label class="expand" for="c-40828819">[1 more]</label></div><br/><div class="children"><div class="content">It seems to be standard in that field, but to be honest, I hate cryptographic notation. AFAICT, about half of the numbers in that pseudo-code count a number of bytes, and the other half a number of bits, and without already knowing the algorithms, it&#x27;s almost impossible to tell which is which. E.g., N[:12] seems to be twelve bytes, while 0¹²⁸ is 16 bytes. X is actually the character &#x27;X&#x27;, i.e. the bit string 01011000. While L is actually a variable, not the bit string 01001100. And so on. It&#x27;s clear that mathematicians don&#x27;t like unambiguous notation nearly as much as CS people do.</div><br/></div></div></div></div><div id="40827440" class="c"><input type="checkbox" id="c-40827440" checked=""/><div class="controls bullet"><span class="by">rzimmerman</span><span>|</span><a href="#40828231">prev</a><span>|</span><a href="#40827946">next</a><span>|</span><label class="collapse" for="c-40827440">[-]</label><label class="expand" for="c-40827440">[1 more]</label></div><br/><div class="children"><div class="content">It seems like this removes the footgun in vanilla AES-GCM where you really need to rotate keys every ~2^32 messages <i>if</i> you are using a random nonce. Nonce collision in AES-GCM is catastrophic (it allows attackers to at least sign arbitrary messages). You don&#x27;t need to use a random nonce, but it&#x27;s usually recommended. Fairly clever to use two primitives (counter-based KDF and vanilla GCM) to make this FIPS compliant.</div><br/></div></div><div id="40827946" class="c"><input type="checkbox" id="c-40827946" checked=""/><div class="controls bullet"><span class="by">convivialdingo</span><span>|</span><a href="#40827440">prev</a><span>|</span><a href="#40801467">next</a><span>|</span><label class="collapse" for="c-40827946">[-]</label><label class="expand" for="c-40827946">[2 more]</label></div><br/><div class="children"><div class="content">This is freaking fantastic- I only wish it existed when I wrote my last encrypted filesystem a few years back.<p>Nonce collision is a huge concern on large file system deployments. 2^32 seems huge but when you’re writing 100k iops a second on a PB array the chance of collision is almost guaranteed if you’re betting on PRNG randomness.</div><br/></div></div><div id="40801467" class="c"><input type="checkbox" id="c-40801467" checked=""/><div class="controls bullet"><span class="by">tatersolid</span><span>|</span><a href="#40827946">prev</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40801467">[-]</label><label class="expand" for="c-40801467">[6 more]</label></div><br/><div class="children"><div class="content">I would love to see this used in a FIPS-compliant variant of age[1] for archival file encryption use cases. We had banking industry auditors veto age for this use case due to the use of ChaCha instead of AES (they were fine with the X25519 public key part of age which I think was somewhat recently approved by NIST).<p>I’ve no experience with golang but it seems like it should drop right in based on the age spec. I might give it a shot if time ever permits. I guess I should call it “cage” as in “compliant actually good encryption”<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;age">https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;age</a></div><br/><div id="40827675" class="c"><input type="checkbox" id="c-40827675" checked=""/><div class="controls bullet"><span class="by">jmprspret</span><span>|</span><a href="#40801467">parent</a><span>|</span><a href="#40827718">next</a><span>|</span><label class="collapse" for="c-40827675">[-]</label><label class="expand" for="c-40827675">[1 more]</label></div><br/><div class="children"><div class="content">&gt; “compliant actually good encryption”<p>an oxymoron, perhaps</div><br/></div></div><div id="40827718" class="c"><input type="checkbox" id="c-40827718" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40801467">parent</a><span>|</span><a href="#40827675">prev</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40827718">[-]</label><label class="expand" for="c-40827718">[4 more]</label></div><br/><div class="children"><div class="content">FWIW Go doesn&#x27;t have an implementation of XAES in the stdlib yet, there&#x27;s only the reference implementation in C2SP.</div><br/><div id="40827943" class="c"><input type="checkbox" id="c-40827943" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827718">parent</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40827943">[-]</label><label class="expand" for="c-40827943">[3 more]</label></div><br/><div class="children"><div class="content">Thank goodness. I am kind of sick of the constant churn in the crypto package.<p>I get that you want to keep up to date with security, but the entire crypto tree is basically a playground for Filippo Valsorda at this point. Meanwhile stuff that I actually need like CMAC is &quot;won&#x27;t fix&quot;</div><br/><div id="40827980" class="c"><input type="checkbox" id="c-40827980" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827943">parent</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40827980">[-]</label><label class="expand" for="c-40827980">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s another language with a stdlib that includes CMAC?</div><br/><div id="40828210" class="c"><input type="checkbox" id="c-40828210" checked=""/><div class="controls bullet"><span class="by">rdpintqogeogsaa</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827980">parent</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40828210">[-]</label><label class="expand" for="c-40828210">[1 more]</label></div><br/><div class="children"><div class="content">Zig[1].<p>[1] <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.11.0&#x2F;std&#x2F;#A;std:crypto.auth.cmac" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.11.0&#x2F;std&#x2F;#A;std:crypto.a...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>