<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1719738059202" as="style"/><link rel="stylesheet" href="styles.css?v=1719738059202"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://words.filippo.io/dispatches/xaes-256-gcm/">The XAES-256-GCM extended-nonce AEAD</a> <span class="domain">(<a href="https://words.filippo.io">words.filippo.io</a>)</span></div><div class="subtext"><span>FiloSottile</span> | <span>62 comments</span></div><br/><div><div id="40828231" class="c"><input type="checkbox" id="c-40828231" checked=""/><div class="controls bullet"><span class="by">dchest</span><span>|</span><a href="#40827440">next</a><span>|</span><label class="collapse" for="c-40828231">[-]</label><label class="expand" for="c-40828231">[12 more]</label></div><br/><div class="children"><div class="content">The design is very clever: since it&#x27;s based on CMAC, we can use AES-CBC to derive keys where lower level primitives are not available.<p>In AES-CBC terms, the algorithm can be described as:<p><pre><code>    1. L = AES-CBC-256ₖ(iv = 0¹²⁸, plaintext = 0¹²⁸)[:16]
    2. If MSB₁(L) = 0, then K1 = L &lt;&lt; 1;
       Else K1 = (L &lt;&lt; 1) ⊕ 0¹²⁰10000111
    3. M1 = 0x00 || 0x01 || X || 0x00 || N[:12]
    4. M2 = 0x00 || 0x02 || X || 0x00 || N[:12]
    5. Kₓ = AES-CBC-256ₖ(iv = K1, plaintext = M1)[:16] || AES-CBC-256ₖ(iv = K1, plaintext = M2)[:16]
    6. Nₓ = N[12:]
</code></pre>
Where AES-CBC-256 returns the first 128-bit block of the ciphertext, discarding the padded block. (Thus, if you can&#x27;t turn off padding, it costs three additional AES calls with the same key compared to a lower level implementation — not bad). After deriving a key, use it with the standard AES-GCM.<p>Here&#x27;s my JS implementation based on WebCrypto API, which uses this fact: <a href="https:&#x2F;&#x2F;github.com&#x2F;dchest&#x2F;xaes">https:&#x2F;&#x2F;github.com&#x2F;dchest&#x2F;xaes</a><p>It accepts a proper CryptoKey intended for AES-CBC, supporting all CryptoKey features, e.g. storing it in IndexedDB with &quot;extractable&quot; bit set to false.<p>Great job, Filippo!</div><br/><div id="40828819" class="c"><input type="checkbox" id="c-40828819" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#40828231">parent</a><span>|</span><a href="#40830388">next</a><span>|</span><label class="collapse" for="c-40828819">[-]</label><label class="expand" for="c-40828819">[4 more]</label></div><br/><div class="children"><div class="content">It seems to be standard in that field, but to be honest, I hate cryptographic notation. AFAICT, about half of the numbers in that pseudo-code count a number of bytes, and the other half a number of bits, and without already knowing the algorithms, it&#x27;s almost impossible to tell which is which. E.g., N[:12] seems to be twelve bytes, while 0¹²⁸ is 16 bytes. X is actually the character &#x27;X&#x27;, i.e. the bit string 01011000. While L is actually a variable, not the bit string 01001100. And so on. It&#x27;s clear that mathematicians don&#x27;t like unambiguous notation nearly as much as CS people do.</div><br/><div id="40829062" class="c"><input type="checkbox" id="c-40829062" checked=""/><div class="controls bullet"><span class="by">dchest</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40828819">parent</a><span>|</span><a href="#40828884">next</a><span>|</span><label class="collapse" for="c-40829062">[-]</label><label class="expand" for="c-40829062">[1 more]</label></div><br/><div class="children"><div class="content">Well, X is a variable that&#x27;s equal to &#x27;X&#x27; :) It&#x27;s a mix of cryptographic notation, Go&#x2F;Python notations for slices, and my ad-hoc notation for AES-CBC. To be fair, I find such pseudocode easier to read than math notation, but it&#x27;s because I&#x27;m more used to it.</div><br/></div></div><div id="40828884" class="c"><input type="checkbox" id="c-40828884" checked=""/><div class="controls bullet"><span class="by">bvrmn</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40828819">parent</a><span>|</span><a href="#40829062">prev</a><span>|</span><a href="#40830388">next</a><span>|</span><label class="collapse" for="c-40828884">[-]</label><label class="expand" for="c-40828884">[2 more]</label></div><br/><div class="children"><div class="content">Agree. Bytes and bits mix is quite awful. For implementation purposes it could be more programming oriented. 0¹²⁸ -&gt; `[0] * 16` (it&#x27;s python oriented, maybe C has short idiom for that) or nice example with padded data: 0¹²⁰10000111 -&gt; `[0] * 15 || 0b10000111`. `X` should be clearly &#x27;X&#x27;.<p>I guess crypto pros are ok with notation. But for hobbyist it requires some reverse engineering every time.</div><br/><div id="40828991" class="c"><input type="checkbox" id="c-40828991" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40828884">parent</a><span>|</span><a href="#40830388">next</a><span>|</span><label class="collapse" for="c-40828991">[-]</label><label class="expand" for="c-40828991">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t disagree, actually. I was copying the NIST source document notation with 0¹²⁸ and 0¹²⁰10000111, but it probably does more harm than good. `X` was just me being too clever. (In my defense, `X` is formatted differently from variables in the original, and all variables are defined.)<p>Done. <a href="https:&#x2F;&#x2F;github.com&#x2F;C2SP&#x2F;C2SP&#x2F;pull&#x2F;86&#x2F;files">https:&#x2F;&#x2F;github.com&#x2F;C2SP&#x2F;C2SP&#x2F;pull&#x2F;86&#x2F;files</a></div><br/></div></div></div></div></div></div><div id="40830388" class="c"><input type="checkbox" id="c-40830388" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#40828231">parent</a><span>|</span><a href="#40828819">prev</a><span>|</span><a href="#40830819">next</a><span>|</span><label class="collapse" for="c-40830388">[-]</label><label class="expand" for="c-40830388">[6 more]</label></div><br/><div class="children"><div class="content">&gt; 0¹²⁰10000111<p>for those of you(like me) wondering where this apparently spooky constant is coming from, it is a bitstring of the coefficients of the lexically first irreducible polynomial of degree b with the minimum possible number of non-zero terms, where b is the block size(in bits) of the underlying block cipher with which CMAC is instantiated. So, nothing up the sleeve here.</div><br/><div id="40831266" class="c"><input type="checkbox" id="c-40831266" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40830388">parent</a><span>|</span><a href="#40834224">next</a><span>|</span><label class="collapse" for="c-40831266">[-]</label><label class="expand" for="c-40831266">[4 more]</label></div><br/><div class="children"><div class="content">My natural follow-up question was &quot;why can&#x27;t you just have K1 = L?&quot; Obviously it&#x27;s inherited from CMAC, but why does CMAC do it?<p>Investigating further, general-case CMAC involves generating a K1 and a K2, which afaict just need to be arbitrarily different from each other. So why not something even simpler, like &quot;xor with 1&quot;?</div><br/><div id="40832561" class="c"><input type="checkbox" id="c-40832561" checked=""/><div class="controls bullet"><span class="by">pbsd</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40831266">parent</a><span>|</span><a href="#40832577">next</a><span>|</span><label class="collapse" for="c-40832561">[-]</label><label class="expand" for="c-40832561">[2 more]</label></div><br/><div class="children"><div class="content">The multiplication in CMAC is there to distinguish between full and partial final input blocks. It can&#x27;t be simply a xor with a constant because that would be easily cancelable in the input, and wouldn&#x27;t satisfy the required xor-universal-like properties required by the security proof.<p>The input here is highly restricted so there&#x27;s no point to it.</div><br/><div id="40834341" class="c"><input type="checkbox" id="c-40834341" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40832561">parent</a><span>|</span><a href="#40832577">next</a><span>|</span><label class="collapse" for="c-40834341">[-]</label><label class="expand" for="c-40834341">[1 more]</label></div><br/><div class="children"><div class="content">My reaction was &quot;Huh? What multiplication?&quot;<p>The answer is that we&#x27;re treating this as a Galois field&#x2F;finite field of order 2^128 with the reducing polynomial (2^128 + 0b10000111).<p>Under that framework, the left shift and possible XOR  implement multiplication by 2.  (An example of general multiplication here: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite_field_arithmetic#Program_examples" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite_field_arithmetic#Progra...</a>)</div><br/></div></div></div></div></div></div><div id="40834224" class="c"><input type="checkbox" id="c-40834224" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40828231">root</a><span>|</span><a href="#40830388">parent</a><span>|</span><a href="#40831266">prev</a><span>|</span><a href="#40830819">next</a><span>|</span><label class="collapse" for="c-40834224">[-]</label><label class="expand" for="c-40834224">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an 8 bit constant padded to 128 bits, so while I appreciate the explanation it&#x27;s not nearly enough entropy to spook me.</div><br/></div></div></div></div><div id="40830819" class="c"><input type="checkbox" id="c-40830819" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#40828231">parent</a><span>|</span><a href="#40830388">prev</a><span>|</span><a href="#40827440">next</a><span>|</span><label class="collapse" for="c-40830819">[-]</label><label class="expand" for="c-40830819">[1 more]</label></div><br/><div class="children"><div class="content">Not a crypto guy. So would the high-level summary be something like this?<p>Standard AES-GCM AEAD will catastrophically fail if you use the same nonce twice[1] for different messages, and the size of the size of the nonce is small enough that one cannot safely use a random nonce in many cases.<p>This work provides an easy to use way to avoid that. It does so by changing not just the nonce but also the key used per message for the AES-GCM call.<p>And it uses only &quot;plain&quot; AES which is readily available if you have AES-GCM, and no fancy new constructions which may have unknown weaknesses.<p>The overhead per message is just two small buffers that needs to be encrypted&#x2F;decrypted with &quot;plain&quot; AES and a longer 192 bit nonce.<p>[1]: <a href="https:&#x2F;&#x2F;frereit.de&#x2F;aes_gcm&#x2F;" rel="nofollow">https:&#x2F;&#x2F;frereit.de&#x2F;aes_gcm&#x2F;</a></div><br/></div></div></div></div><div id="40827440" class="c"><input type="checkbox" id="c-40827440" checked=""/><div class="controls bullet"><span class="by">rzimmerman</span><span>|</span><a href="#40828231">prev</a><span>|</span><a href="#40827946">next</a><span>|</span><label class="collapse" for="c-40827440">[-]</label><label class="expand" for="c-40827440">[8 more]</label></div><br/><div class="children"><div class="content">It seems like this removes the footgun in vanilla AES-GCM where you really need to rotate keys every ~2^32 messages <i>if</i> you are using a random nonce. Nonce collision in AES-GCM is catastrophic (it allows attackers to at least sign arbitrary messages). You don&#x27;t need to use a random nonce, but it&#x27;s usually recommended. Fairly clever to use two primitives (counter-based KDF and vanilla GCM) to make this FIPS compliant.</div><br/><div id="40830108" class="c"><input type="checkbox" id="c-40830108" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40827440">parent</a><span>|</span><a href="#40827946">next</a><span>|</span><label class="collapse" for="c-40830108">[-]</label><label class="expand" for="c-40830108">[7 more]</label></div><br/><div class="children"><div class="content">No, this makes random nonces safe in the first place. With standard AES-GCM, you should use <i>deterministic</i> nonce generation since 96 bits is not enough to avoid random collisions. Also, you must change the nonce (or key) after 2^32 blocks <i>regardless of how it was generated</i> because the counter rolls over and the next block would use the same nonce+counter as the first block.</div><br/><div id="40830893" class="c"><input type="checkbox" id="c-40830893" checked=""/><div class="controls bullet"><span class="by">chc4</span><span>|</span><a href="#40827440">root</a><span>|</span><a href="#40830108">parent</a><span>|</span><a href="#40827946">next</a><span>|</span><label class="collapse" for="c-40830893">[-]</label><label class="expand" for="c-40830893">[6 more]</label></div><br/><div class="children"><div class="content">You are wrong. NIST recommendations outline both deterministic <i>or</i> RBG-based construction. The 2^32 invocation limit is only for random nonce or if your deterministic construction is less than 96bits. Lots of people are doing random nonces.<p><a href="https:&#x2F;&#x2F;csrc.nist.gov&#x2F;pubs&#x2F;sp&#x2F;800&#x2F;38&#x2F;d&#x2F;final" rel="nofollow">https:&#x2F;&#x2F;csrc.nist.gov&#x2F;pubs&#x2F;sp&#x2F;800&#x2F;38&#x2F;d&#x2F;final</a></div><br/><div id="40831285" class="c"><input type="checkbox" id="c-40831285" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40827440">root</a><span>|</span><a href="#40830893">parent</a><span>|</span><a href="#40831455">next</a><span>|</span><label class="collapse" for="c-40831285">[-]</label><label class="expand" for="c-40831285">[3 more]</label></div><br/><div class="children"><div class="content">That link says the document needs revising, specifically &quot;to clarify the guidance in connection with the IV constructions&quot; (NIST calls the nonce an IV). It defines GCM normatively but its non-normative recommendations are outdated.<p>I also don&#x27;t agree with the specific claim (made or at least implied by NIST) that a single 96-bit deterministic nonce isn&#x27;t limited to 2³² blocks. The counter block will wrap around regardless of how the nonce was generated, because the GCTR function that is used to compute the ciphertext and authentication tag sets CBᵢ = inc32(CBᵢ₋₁) and CB₁ = ICB = inc₃₂(J₀) with J₀ a function of the nonce and inc₃₂ only incrementing the bottom 32 bits. Modern recommendations do not make this distinction around how the nonce was generated and I see no justification made for it by NIST. Perhaps it was meant to apply to the case where a portion of the nonce was implicit and thus not sent or stored in the clear, but deterministic generation doesn&#x27;t always mean partially implicit nonces and the implicit part is too small (usually 32 bits) and too easy to obtain (often derived from a hardware identifier) to provide any additional security anyway.<p>Using any nonce lengths other than 96 bits is not recommended today, regardless of the recommendations in 2007. Shorter lengths are obviously a poor choice, but longer lengths are not always supported by implementations. Moreover, while the published standard supports various lengths (with support for &lt;96 bits marked for removal), the invocation of the GHASH function and its effect on nonce entropy is not well studied AFAIK and all nonces other than 96 bits are fed into GHASH. Thus, one shouldn&#x27;t use a nonce longer than 96 bits, which means the birthday paradox can become a real problem if the same key is used to encrypt a large number of messages, each with different nonces. A single or relatively small number of CSPRNG-generated nonces for the same key is usually okay; a lot is a problem. This problem is a major reason why AES-GCM-SIV, XChaCha20-Poly1305, and XAES-256-GCM even exist.</div><br/><div id="40831546" class="c"><input type="checkbox" id="c-40831546" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40827440">root</a><span>|</span><a href="#40831285">parent</a><span>|</span><a href="#40831455">next</a><span>|</span><label class="collapse" for="c-40831546">[-]</label><label class="expand" for="c-40831546">[2 more]</label></div><br/><div class="children"><div class="content">For some elaboration on my issues with NIST recommendations, let us consider NIST&#x27;s response to public comments <i>from 2021</i>:<p>NSA raised the issue of &quot;Counter wrapping, or integer overflow, because counter is
32 bits&quot; to which NIST replied that &quot;WITH CURRENT COMPUTING ABILITIES [...] Counter should not overflow&quot;. I find that to be a thoroughly inadequate response. Obviously current computing capabilities can overflow a 32-bit counter. That also translates (as NSA also pointed out) to 68GB of data encrypted with the same nonce, which is still &quot;a lot&quot; for some use cases, but easy to exceed for other use cases in the age of terabytes and petabytes.<p>On the issue of nonce reuse specifically, NIST respond to NSA&#x27;s concerns with &#x27;Generate a new 96-bit nonce for each
message using a cryptographically strong PRNG. Re-key at reasonably regular intervals, where &quot;reasonably regular&quot; is
defined by how much data and how many messages are being encrypted&#x27;. I think that broadly validates what I said. However, &quot;reasonably regular&quot; is not actionable guidance, and it is not always possible to re-key easily.<p><a href="https:&#x2F;&#x2F;csrc.nist.gov&#x2F;csrc&#x2F;media&#x2F;projects&#x2F;crypto-publication-review-project&#x2F;documents&#x2F;initial-comments&#x2F;sp800-38d-initial-public-comments-2021.pdf" rel="nofollow">https:&#x2F;&#x2F;csrc.nist.gov&#x2F;csrc&#x2F;media&#x2F;projects&#x2F;crypto-publication...</a></div><br/><div id="40833057" class="c"><input type="checkbox" id="c-40833057" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40827440">root</a><span>|</span><a href="#40831546">parent</a><span>|</span><a href="#40831455">next</a><span>|</span><label class="collapse" for="c-40833057">[-]</label><label class="expand" for="c-40833057">[1 more]</label></div><br/><div class="children"><div class="content">I framed that as NIST responses to NSA concerns, but on re-reading, it seems that the table I&#x27;m quoting is entirely produced by the NSA. This doesn&#x27;t really affect the substance of what I wrote with regard to technical details, but I may have misattributed statements to NIST that came from NSA.</div><br/></div></div></div></div></div></div><div id="40831455" class="c"><input type="checkbox" id="c-40831455" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40827440">root</a><span>|</span><a href="#40830893">parent</a><span>|</span><a href="#40831285">prev</a><span>|</span><a href="#40831157">next</a><span>|</span><label class="collapse" for="c-40831455">[-]</label><label class="expand" for="c-40831455">[1 more]</label></div><br/><div class="children"><div class="content">They&#x27;re not wrong, and the limited nonce space in standard GCM is one of the most common problems cryptography engineers have with GCM.</div><br/></div></div></div></div></div></div></div></div><div id="40827946" class="c"><input type="checkbox" id="c-40827946" checked=""/><div class="controls bullet"><span class="by">convivialdingo</span><span>|</span><a href="#40827440">prev</a><span>|</span><a href="#40801467">next</a><span>|</span><label class="collapse" for="c-40827946">[-]</label><label class="expand" for="c-40827946">[5 more]</label></div><br/><div class="children"><div class="content">This is freaking fantastic- I only wish it existed when I wrote my last encrypted filesystem a few years back.<p>Nonce collision is a huge concern on large file system deployments. 2^32 seems huge but when you’re writing 100k iops a second on a PB array the chance of collision is almost guaranteed if you’re betting on PRNG randomness.</div><br/><div id="40832529" class="c"><input type="checkbox" id="c-40832529" checked=""/><div class="controls bullet"><span class="by">notfed</span><span>|</span><a href="#40827946">parent</a><span>|</span><a href="#40828910">next</a><span>|</span><label class="collapse" for="c-40832529">[-]</label><label class="expand" for="c-40832529">[1 more]</label></div><br/><div class="children"><div class="content">The CAESAR competition [1] ended in 2019 and resulted in multiple different AEADs, most with plenty of nonce space.<p>[1] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;CAESAR_Competition" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;CAESAR_Competition</a></div><br/></div></div><div id="40828910" class="c"><input type="checkbox" id="c-40828910" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#40827946">parent</a><span>|</span><a href="#40832529">prev</a><span>|</span><a href="#40828565">next</a><span>|</span><label class="collapse" for="c-40828910">[-]</label><label class="expand" for="c-40828910">[2 more]</label></div><br/><div class="children"><div class="content">Why is nonce collision a problem though? It just means that two blocks share the same encryption key, right? Without knowing the plaintext in either block, how does that weaken the security of the system?</div><br/><div id="40829102" class="c"><input type="checkbox" id="c-40829102" checked=""/><div class="controls bullet"><span class="by">dchest</span><span>|</span><a href="#40827946">root</a><span>|</span><a href="#40828910">parent</a><span>|</span><a href="#40828565">next</a><span>|</span><label class="collapse" for="c-40829102">[-]</label><label class="expand" for="c-40829102">[1 more]</label></div><br/><div class="children"><div class="content">Encryption with the same key and repeated nonce&#x2F;counter produce the same cipher stream. Ciphertext in GCM (or CTR) mode is cipherstream XOR plaintext, thus given two ciphertexts with the same key&#x2F;nonce:<p>ciphertext1 XOR ciphertext2 = (cipherstream XOR plaintext1) XOR (cipherstream XOR plaintext2) = plaintext1 XOR plaintext2<p>In GCM it can also break authentication.</div><br/></div></div></div></div></div></div><div id="40801467" class="c"><input type="checkbox" id="c-40801467" checked=""/><div class="controls bullet"><span class="by">tatersolid</span><span>|</span><a href="#40827946">prev</a><span>|</span><a href="#40829195">next</a><span>|</span><label class="collapse" for="c-40801467">[-]</label><label class="expand" for="c-40801467">[19 more]</label></div><br/><div class="children"><div class="content">I would love to see this used in a FIPS-compliant variant of age[1] for archival file encryption use cases. We had banking industry auditors veto age for this use case due to the use of ChaCha instead of AES (they were fine with the X25519 public key part of age which I think was somewhat recently approved by NIST).<p>I’ve no experience with golang but it seems like it should drop right in based on the age spec. I might give it a shot if time ever permits. I guess I should call it “cage” as in “compliant actually good encryption”<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;age">https:&#x2F;&#x2F;github.com&#x2F;FiloSottile&#x2F;age</a></div><br/><div id="40827675" class="c"><input type="checkbox" id="c-40827675" checked=""/><div class="controls bullet"><span class="by">jmprspret</span><span>|</span><a href="#40801467">parent</a><span>|</span><a href="#40829877">next</a><span>|</span><label class="collapse" for="c-40827675">[-]</label><label class="expand" for="c-40827675">[2 more]</label></div><br/><div class="children"><div class="content">&gt; “compliant actually good encryption”<p>an oxymoron, perhaps</div><br/><div id="40834883" class="c"><input type="checkbox" id="c-40834883" checked=""/><div class="controls bullet"><span class="by">d-z-m</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827675">parent</a><span>|</span><a href="#40829877">next</a><span>|</span><label class="collapse" for="c-40834883">[-]</label><label class="expand" for="c-40834883">[1 more]</label></div><br/><div class="children"><div class="content">also an unfortunate acronym</div><br/></div></div></div></div><div id="40829877" class="c"><input type="checkbox" id="c-40829877" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40801467">parent</a><span>|</span><a href="#40827675">prev</a><span>|</span><a href="#40827718">next</a><span>|</span><label class="collapse" for="c-40829877">[-]</label><label class="expand" for="c-40829877">[1 more]</label></div><br/><div class="children"><div class="content">&gt; they were fine with the X25519 public key part of age which I think was somewhat recently approved by NIST<p>As far as I can tell, Ed25519 is approved (FIPS 186-5), but X25519 is still not (yet).</div><br/></div></div><div id="40827718" class="c"><input type="checkbox" id="c-40827718" checked=""/><div class="controls bullet"><span class="by">candiddevmike</span><span>|</span><a href="#40801467">parent</a><span>|</span><a href="#40829877">prev</a><span>|</span><a href="#40829195">next</a><span>|</span><label class="collapse" for="c-40827718">[-]</label><label class="expand" for="c-40827718">[15 more]</label></div><br/><div class="children"><div class="content">FWIW Go doesn&#x27;t have an implementation of XAES in the stdlib yet, there&#x27;s only the reference implementation in C2SP.</div><br/><div id="40827943" class="c"><input type="checkbox" id="c-40827943" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827718">parent</a><span>|</span><a href="#40829195">next</a><span>|</span><label class="collapse" for="c-40827943">[-]</label><label class="expand" for="c-40827943">[14 more]</label></div><br/><div class="children"><div class="content">Thank goodness. I am kind of sick of the constant churn in the crypto package.<p>I get that you want to keep up to date with security, but the entire crypto tree is basically a playground for Filippo Valsorda at this point. Meanwhile stuff that I actually need like CMAC is &quot;won&#x27;t fix&quot;</div><br/><div id="40830173" class="c"><input type="checkbox" id="c-40830173" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827943">parent</a><span>|</span><a href="#40827980">next</a><span>|</span><label class="collapse" for="c-40830173">[-]</label><label class="expand" for="c-40830173">[6 more]</label></div><br/><div class="children"><div class="content">What churn does the crypto package get? It&#x27;s part of the standard library and so bound by the compatibility promise, which basically freezes existing things in place.</div><br/><div id="40830343" class="c"><input type="checkbox" id="c-40830343" checked=""/><div class="controls bullet"><span class="by">38</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40830173">parent</a><span>|</span><a href="#40827980">next</a><span>|</span><label class="collapse" for="c-40830343">[-]</label><label class="expand" for="c-40830343">[5 more]</label></div><br/><div class="children"><div class="content">see for yourself<p><a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commits&#x2F;master&#x2F;src&#x2F;crypto">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;commits&#x2F;master&#x2F;src&#x2F;crypto</a></div><br/><div id="40831037" class="c"><input type="checkbox" id="c-40831037" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40830343">parent</a><span>|</span><a href="#40830649">next</a><span>|</span><label class="collapse" for="c-40831037">[-]</label><label class="expand" for="c-40831037">[1 more]</label></div><br/><div class="children"><div class="content">Churn implies upheaval, breaking things that used to (and ought to) work. I don&#x27;t see examples of that from the first few commits I examined.</div><br/></div></div><div id="40830649" class="c"><input type="checkbox" id="c-40830649" checked=""/><div class="controls bullet"><span class="by">arccy</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40830343">parent</a><span>|</span><a href="#40831037">prev</a><span>|</span><a href="#40827980">next</a><span>|</span><label class="collapse" for="c-40830649">[-]</label><label class="expand" for="c-40830649">[3 more]</label></div><br/><div class="children"><div class="content">so pretty stable, and you&#x27;re mad that other people won&#x27;t do free work for you to implement a mostly unused spec.</div><br/><div id="40831645" class="c"><input type="checkbox" id="c-40831645" checked=""/><div class="controls bullet"><span class="by">sevg</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40830649">parent</a><span>|</span><a href="#40831282">next</a><span>|</span><label class="collapse" for="c-40831645">[-]</label><label class="expand" for="c-40831645">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of this kind of entitlement around.<p>Trash other peoples&#x27; work as &quot;playground&quot; activity, and demand they work on something else for free.</div><br/></div></div></div></div></div></div></div></div><div id="40827980" class="c"><input type="checkbox" id="c-40827980" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827943">parent</a><span>|</span><a href="#40830173">prev</a><span>|</span><a href="#40829195">next</a><span>|</span><label class="collapse" for="c-40827980">[-]</label><label class="expand" for="c-40827980">[7 more]</label></div><br/><div class="children"><div class="content">What&#x27;s another language with a stdlib that includes CMAC?</div><br/><div id="40828210" class="c"><input type="checkbox" id="c-40828210" checked=""/><div class="controls bullet"><span class="by">rdpintqogeogsaa</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827980">parent</a><span>|</span><a href="#40828867">next</a><span>|</span><label class="collapse" for="c-40828210">[-]</label><label class="expand" for="c-40828210">[1 more]</label></div><br/><div class="children"><div class="content">Zig[1].<p>[1] <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.11.0&#x2F;std&#x2F;#A;std:crypto.auth.cmac" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;0.11.0&#x2F;std&#x2F;#A;std:crypto.a...</a></div><br/></div></div><div id="40828867" class="c"><input type="checkbox" id="c-40828867" checked=""/><div class="controls bullet"><span class="by">ramchip</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40827980">parent</a><span>|</span><a href="#40828210">prev</a><span>|</span><a href="#40830035">next</a><span>|</span><label class="collapse" for="c-40828867">[-]</label><label class="expand" for="c-40828867">[4 more]</label></div><br/><div class="children"><div class="content">Erlang &#x2F; Elixir</div><br/><div id="40831474" class="c"><input type="checkbox" id="c-40831474" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40828867">parent</a><span>|</span><a href="#40830035">next</a><span>|</span><label class="collapse" for="c-40831474">[-]</label><label class="expand" for="c-40831474">[3 more]</label></div><br/><div class="children"><div class="content">Link? Does Elixir even have cryptography in the stdlib?</div><br/><div id="40832838" class="c"><input type="checkbox" id="c-40832838" checked=""/><div class="controls bullet"><span class="by">petronio</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40831474">parent</a><span>|</span><a href="#40830035">next</a><span>|</span><label class="collapse" for="c-40832838">[-]</label><label class="expand" for="c-40832838">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;crypto&#x2F;crypto" rel="nofollow">https:&#x2F;&#x2F;www.erlang.org&#x2F;doc&#x2F;apps&#x2F;crypto&#x2F;crypto</a><p>Elixir can call Erlang&#x2F;OTP modules directly, so they also have access to that same module. Erlang&#x2F;OTP is a hard dependency for Elixir afaik.</div><br/><div id="40833369" class="c"><input type="checkbox" id="c-40833369" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#40801467">root</a><span>|</span><a href="#40832838">parent</a><span>|</span><a href="#40830035">next</a><span>|</span><label class="collapse" for="c-40833369">[-]</label><label class="expand" for="c-40833369">[1 more]</label></div><br/><div class="children"><div class="content">Gotcha, thanks!</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="40829195" class="c"><input type="checkbox" id="c-40829195" checked=""/><div class="controls bullet"><span class="by">omginternets</span><span>|</span><a href="#40801467">prev</a><span>|</span><a href="#40830119">next</a><span>|</span><label class="collapse" for="c-40829195">[-]</label><label class="expand" for="c-40829195">[3 more]</label></div><br/><div class="children"><div class="content">Question from a non-cryptographer:  why use 192bit nonces instead of 256? I can’t imagine those extra bits would be considered costly in any practical application.</div><br/><div id="40829343" class="c"><input type="checkbox" id="c-40829343" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#40829195">parent</a><span>|</span><a href="#40830119">next</a><span>|</span><label class="collapse" for="c-40829343">[-]</label><label class="expand" for="c-40829343">[2 more]</label></div><br/><div class="children"><div class="content">There is no space for 256 bits: 192 bits is 96 bits from the underlying nonce space, and 96 bits that go into the 128-bit CMAC block (along with the necessary prefix). We could make the CMAC input longer, but then we&#x27;d have to run the AES-256 block function more times (and we&#x27;d hit some annoying key control issues in the CMAC KDF).<p>This is actually similar to why XChaCha20Poly1305 has 192-bit nonces, and consistency with the other major extended-nonce AEAD is another mild advantage.</div><br/><div id="40834670" class="c"><input type="checkbox" id="c-40834670" checked=""/><div class="controls bullet"><span class="by">marshray</span><span>|</span><a href="#40829195">root</a><span>|</span><a href="#40829343">parent</a><span>|</span><a href="#40830119">next</a><span>|</span><label class="collapse" for="c-40834670">[-]</label><label class="expand" for="c-40834670">[1 more]</label></div><br/><div class="children"><div class="content">Reducing security below 128 bits in order to save a block of AES will anger the gods and surely we will be made to pay. Turn back now, while there is still time.</div><br/></div></div></div></div></div></div><div id="40830119" class="c"><input type="checkbox" id="c-40830119" checked=""/><div class="controls bullet"><span class="by">upofadown</span><span>|</span><a href="#40829195">prev</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40830119">[-]</label><label class="expand" for="c-40830119">[3 more]</label></div><br/><div class="children"><div class="content">&gt;(2⁸⁰ messages with collision risk 2⁻³²)<p>Would there be an issue before that due to the fact that the AES block size is only 128 bits?</div><br/><div id="40831356" class="c"><input type="checkbox" id="c-40831356" checked=""/><div class="controls bullet"><span class="by">FiloSottile</span><span>|</span><a href="#40830119">parent</a><span>|</span><a href="#40831011">next</a><span>|</span><label class="collapse" for="c-40831356">[-]</label><label class="expand" for="c-40831356">[1 more]</label></div><br/><div class="children"><div class="content">Assuming you’re referring to the birthday bound on blocks (<a href="https:&#x2F;&#x2F;sweet32.info" rel="nofollow">https:&#x2F;&#x2F;sweet32.info</a>) that’s a limit on blocks encrypted with a single key. XAES derives large keys per message, so it achieves what are commonly referred to as “better-than-birthday” bounds.</div><br/></div></div><div id="40831011" class="c"><input type="checkbox" id="c-40831011" checked=""/><div class="controls bullet"><span class="by">Retr0id</span><span>|</span><a href="#40830119">parent</a><span>|</span><a href="#40831356">prev</a><span>|</span><a href="#40827853">next</a><span>|</span><label class="collapse" for="c-40831011">[-]</label><label class="expand" for="c-40831011">[1 more]</label></div><br/><div class="children"><div class="content">No<p>(it&#x27;s difficult to give a more detailed answer than that, without more detail on why you think it&#x27;d be an issue)</div><br/></div></div></div></div></div></div></div></div></div></body></html>