<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1716022854490" as="style"/><link rel="stylesheet" href="styles.css?v=1716022854490"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="http://www.unixwiz.net/techtips/reading-cdecl.html">How to read C type declarations (2003)</a> <span class="domain">(<a href="http://www.unixwiz.net">www.unixwiz.net</a>)</span></div><div class="subtext"><span>aragonite</span> | <span>120 comments</span></div><br/><div><div id="40389064" class="c"><input type="checkbox" id="c-40389064" checked=""/><div class="controls bullet"><span class="by">mmaniac</span><span>|</span><a href="#40388043">next</a><span>|</span><label class="collapse" for="c-40389064">[-]</label><label class="expand" for="c-40389064">[8 more]</label></div><br/><div class="children"><div class="content">C type declarations (and array decays, for that matter) seem to be baggage from B.<p>In B the only type is the machine word, which can perform arithmetic and be dereferenced. Arrays the only special kind of declaration and are declared like<p><pre><code>  auto foo[10]</code></pre>
Where auto is a storage class specifier like extern or static.<p>In that world, having declaration follow usage makes perfect sense. There&#x27;s no &quot;other&quot; kinds of data to worry about, the operators you can apply to an expression describes its type exactly.</div><br/><div id="40392371" class="c"><input type="checkbox" id="c-40392371" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40389064">parent</a><span>|</span><a href="#40388043">next</a><span>|</span><label class="collapse" for="c-40392371">[-]</label><label class="expand" for="c-40392371">[7 more]</label></div><br/><div class="children"><div class="content">The array decay is probably the worst mistake C made, and was unfortunately carried over to C++. Fortunately, it is fixable:<p><a href="https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html" rel="nofollow">https:&#x2F;&#x2F;www.digitalmars.com&#x2F;articles&#x2F;C-biggest-mistake.html</a></div><br/><div id="40396954" class="c"><input type="checkbox" id="c-40396954" checked=""/><div class="controls bullet"><span class="by">Ferret7446</span><span>|</span><a href="#40389064">root</a><span>|</span><a href="#40392371">parent</a><span>|</span><a href="#40393242">next</a><span>|</span><label class="collapse" for="c-40396954">[-]</label><label class="expand" for="c-40396954">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t seem that bad to me.  You can easily understand it by reading a short article, and it makes sense in a basic CS 101 mental model of computing.</div><br/></div></div><div id="40393242" class="c"><input type="checkbox" id="c-40393242" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40389064">root</a><span>|</span><a href="#40392371">parent</a><span>|</span><a href="#40396954">prev</a><span>|</span><a href="#40394537">next</a><span>|</span><label class="collapse" for="c-40393242">[-]</label><label class="expand" for="c-40393242">[3 more]</label></div><br/><div class="children"><div class="content">As usual the worst mistake is Hoare&#x27;s Billion Dollar Mistake (null). But yes obviously arrays shouldn&#x27;t decay.<p>The &quot;fix&quot; would be to not have arrays decay. I believe C++ could probably get there if it had taken Epochs, I further believe taking Epochs (P1881) when it was proposed would have been extremely disruptive but perhaps possible and <i>worth attempting</i>. I do not believe it&#x27;s still possible, the moment passed and with it, in my view, any hope of salvaging C++.<p>Without Epochs, any and every such change to C++ is similarly disruptive and that&#x27;s too expensive so more or less nothing gets fixed, instead layers of kludges must be added. That&#x27;s how Foonathan ends up with: class foo final trivially_relocatable namespace() { … };</div><br/><div id="40393698" class="c"><input type="checkbox" id="c-40393698" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40389064">root</a><span>|</span><a href="#40393242">parent</a><span>|</span><a href="#40394537">next</a><span>|</span><label class="collapse" for="c-40393698">[-]</label><label class="expand" for="c-40393698">[2 more]</label></div><br/><div class="children"><div class="content">The change I proposed is not disruptive in any way.<p>As for the billion dollar mistake, a null pointer reference results in a seg fault. But the array decay results in buffer overflows, the #1 problem in shipped C code, and the buffer overflows result in memory corruption. Memory corruption is much, much, much worse than a seg fault. For example, buffer overflows are exploitable by malware. Seg faults are not.<p>Hence, the array decay is the worst mistake.</div><br/><div id="40393736" class="c"><input type="checkbox" id="c-40393736" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40389064">root</a><span>|</span><a href="#40393698">parent</a><span>|</span><a href="#40394537">next</a><span>|</span><label class="collapse" for="c-40393736">[-]</label><label class="expand" for="c-40393736">[1 more]</label></div><br/><div class="children"><div class="content">I am baffled by the lack of interest in incorporating the proposal into C. Instead, C23 gets Unicode normalized identifiers, a complex and pointless feature that is easily achieved by other means, if one really really wants it.</div><br/></div></div></div></div></div></div><div id="40394537" class="c"><input type="checkbox" id="c-40394537" checked=""/><div class="controls bullet"><span class="by">juped</span><span>|</span><a href="#40389064">root</a><span>|</span><a href="#40392371">parent</a><span>|</span><a href="#40393242">prev</a><span>|</span><a href="#40388043">next</a><span>|</span><label class="collapse" for="c-40394537">[-]</label><label class="expand" for="c-40394537">[2 more]</label></div><br/><div class="children"><div class="content">I never knew you shared my biggest gripe with C. I really wish this or an equivalent had made it into some C standard.</div><br/><div id="40395089" class="c"><input type="checkbox" id="c-40395089" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40389064">root</a><span>|</span><a href="#40394537">parent</a><span>|</span><a href="#40388043">next</a><span>|</span><label class="collapse" for="c-40395089">[-]</label><label class="expand" for="c-40395089">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s so easy to fix, too.</div><br/></div></div></div></div></div></div></div></div><div id="40388043" class="c"><input type="checkbox" id="c-40388043" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#40389064">prev</a><span>|</span><a href="#40395366">next</a><span>|</span><label class="collapse" for="c-40388043">[-]</label><label class="expand" for="c-40388043">[1 more]</label></div><br/><div class="children"><div class="content">Treat them like ordinary expressions around an identifier. At the deepest level is the identifer, then some operators around it with a certain precedence, and finally, on the left, a list of type specifiers indicating the final type of the expression when all the operators are applied.<p>Those operators are the same ones you would use in an expression to use your declared object. They are the unary dereferencing operator, the array subscription operator, the function call operator and the parentheses for overcoming default precedence.</div><br/></div></div><div id="40395366" class="c"><input type="checkbox" id="c-40395366" checked=""/><div class="controls bullet"><span class="by">squarefoot</span><span>|</span><a href="#40388043">prev</a><span>|</span><a href="#40388145">next</a><span>|</span><label class="collapse" for="c-40395366">[-]</label><label class="expand" for="c-40395366">[2 more]</label></div><br/><div class="children"><div class="content">Many moons ago the &quot;cdecl&quot; tool turned out incredibly useful to check if I got declarations right.<p>cdecl&gt; declare bar as const pointer to array 5 of pointer to function (int) returning const pointer to char<p>char * const (<i>(</i> const bar)[5])(int )<p>Also online at <a href="https:&#x2F;&#x2F;cdecl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cdecl.org&#x2F;</a></div><br/><div id="40396470" class="c"><input type="checkbox" id="c-40396470" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#40395366">parent</a><span>|</span><a href="#40388145">next</a><span>|</span><label class="collapse" for="c-40396470">[-]</label><label class="expand" for="c-40396470">[1 more]</label></div><br/><div class="children"><div class="content">Wow, I remember messing with cdecl at least a solid decade ago (if I’m not mistaken). I’m surprised the project is still active!</div><br/></div></div></div></div><div id="40388145" class="c"><input type="checkbox" id="c-40388145" checked=""/><div class="controls bullet"><span class="by">cjs_ac</span><span>|</span><a href="#40395366">prev</a><span>|</span><a href="#40390262">next</a><span>|</span><label class="collapse" for="c-40388145">[-]</label><label class="expand" for="c-40388145">[33 more]</label></div><br/><div class="children"><div class="content">Rob Pike has some commentary on this in this blog post on Go&#x27;s declaration syntax: <a href="https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;declaration-syntax" rel="nofollow">https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;declaration-syntax</a></div><br/><div id="40388899" class="c"><input type="checkbox" id="c-40388899" checked=""/><div class="controls bullet"><span class="by">ninkendo</span><span>|</span><a href="#40388145">parent</a><span>|</span><a href="#40390262">next</a><span>|</span><label class="collapse" for="c-40388899">[-]</label><label class="expand" for="c-40388899">[32 more]</label></div><br/><div class="children"><div class="content">&gt; Go takes its cue from here, but in the interests of brevity it drops the colon<p>This was the biggest mistake IMO. Go’s declaration syntax needs colons, it would have been 100x more readable.<p>Compare:<p><pre><code>    func foo(x int, y int) int {
        var sum int = x + y
        return sum
    }
</code></pre>
To:<p><pre><code>    func foo(x: int, y: int): int {
        var sum: int = x + y
        return sum
    }
</code></pre>
The colons would have made it so much more clear to read for me.</div><br/><div id="40391081" class="c"><input type="checkbox" id="c-40391081" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40389117">next</a><span>|</span><label class="collapse" for="c-40391081">[-]</label><label class="expand" for="c-40391081">[1 more]</label></div><br/><div class="children"><div class="content">The irony is that Pike&#x27;s previous language, Limbo, did use colons here: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Limbo_(programming_language)#Examples" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Limbo_(programming_language)#E...</a><p>I can only assume he removed them, not for brevity, but as a compromise for the sake of C programmers to only ask them to learn one new thing rather than two.</div><br/></div></div><div id="40389117" class="c"><input type="checkbox" id="c-40389117" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40391081">prev</a><span>|</span><a href="#40393119">next</a><span>|</span><label class="collapse" for="c-40389117">[-]</label><label class="expand" for="c-40389117">[1 more]</label></div><br/><div class="children"><div class="content">The lack of colons is also hard for  the parser. The recursive-descent code for parsing a Go parameter declaration is quite tricky and got even trickier after they introduced generic types.</div><br/></div></div><div id="40393119" class="c"><input type="checkbox" id="c-40393119" checked=""/><div class="controls bullet"><span class="by">king_geedorah</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40389117">prev</a><span>|</span><a href="#40389192">next</a><span>|</span><label class="collapse" for="c-40393119">[-]</label><label class="expand" for="c-40393119">[1 more]</label></div><br/><div class="children"><div class="content">Might as well just drop the var keyword altogether at that point.<p><pre><code>    func foo(x: int, y: int): int {
        sum : int = x + y
        return x + y
    }
</code></pre>
With type inference the type declaration just collapses out to what you have now.<p><pre><code>    func foo(x: int, y: int): int {
        sum := x + y
        return x + y
    }
</code></pre>
I&#x27;ve seen it in a few languages and it has seemed quite nice in use and appearance to me.</div><br/></div></div><div id="40389192" class="c"><input type="checkbox" id="c-40389192" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40393119">prev</a><span>|</span><a href="#40389021">next</a><span>|</span><label class="collapse" for="c-40389192">[-]</label><label class="expand" for="c-40389192">[2 more]</label></div><br/><div class="children"><div class="content">The types stand out more with colons, certainly, but I don&#x27;t find the former example any harder to read. It helps that types can only show up in certain places. Readability does suffer when multiple consecutive parameters use the same type and it&#x27;s elided on all but the last, though. That&#x27;s a quirk unique to Go that I haven&#x27;t seen on any language using colons to specify types.</div><br/><div id="40392414" class="c"><input type="checkbox" id="c-40392414" checked=""/><div class="controls bullet"><span class="by">lpribis</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40389192">parent</a><span>|</span><a href="#40389021">next</a><span>|</span><label class="collapse" for="c-40392414">[-]</label><label class="expand" for="c-40392414">[1 more]</label></div><br/><div class="children"><div class="content">Ada and Pascal are both languages which allow multiple consecutive parameters with the same type and also use `name: type` syntax. I agree, even when using Ada&#x2F;Pascal with colons its difficult to mentally parse.</div><br/></div></div></div></div><div id="40389021" class="c"><input type="checkbox" id="c-40389021" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40389192">prev</a><span>|</span><a href="#40389428">next</a><span>|</span><label class="collapse" for="c-40389021">[-]</label><label class="expand" for="c-40389021">[1 more]</label></div><br/><div class="children"><div class="content">So many things that it misses out, not only colons.</div><br/></div></div><div id="40389428" class="c"><input type="checkbox" id="c-40389428" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40389021">prev</a><span>|</span><a href="#40394546">next</a><span>|</span><label class="collapse" for="c-40389428">[-]</label><label class="expand" for="c-40389428">[1 more]</label></div><br/><div class="children"><div class="content">It just looks busier without any benefit to me.</div><br/></div></div><div id="40394546" class="c"><input type="checkbox" id="c-40394546" checked=""/><div class="controls bullet"><span class="by">Zardoz84</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40389428">prev</a><span>|</span><a href="#40389427">next</a><span>|</span><label class="collapse" for="c-40394546">[-]</label><label class="expand" for="c-40394546">[1 more]</label></div><br/><div class="children"><div class="content">I personally find more readable to have the type first and no colon, and type inference :<p><pre><code>    int func foo(int x, int y) {
        var sum = x + y
        return sum
    }</code></pre></div><br/></div></div><div id="40389427" class="c"><input type="checkbox" id="c-40389427" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40388899">parent</a><span>|</span><a href="#40394546">prev</a><span>|</span><a href="#40390262">next</a><span>|</span><label class="collapse" for="c-40389427">[-]</label><label class="expand" for="c-40389427">[23 more]</label></div><br/><div class="children"><div class="content">Having the colon touching the type definition always made more sense to me<p>So instead of this:<p><pre><code>  func foo(x: int, y: int): int   {
      var sum: int = x + y
      return sum
  }
</code></pre>
You’d have this instead:<p><pre><code>  func foo(x :int, y :int) :int   {
      var sum :int = x + y
      return sum
  }</code></pre></div><br/><div id="40389922" class="c"><input type="checkbox" id="c-40389922" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40389427">parent</a><span>|</span><a href="#40390262">next</a><span>|</span><label class="collapse" for="c-40389922">[-]</label><label class="expand" for="c-40389922">[22 more]</label></div><br/><div class="children"><div class="content">What the fuck? No.<p>That makes as much sense as `int *i`, when `int* i` is obviously the correct (though heterodox) way.</div><br/><div id="40390198" class="c"><input type="checkbox" id="c-40390198" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40389922">parent</a><span>|</span><a href="#40393662">next</a><span>|</span><label class="collapse" for="c-40390198">[-]</label><label class="expand" for="c-40390198">[19 more]</label></div><br/><div class="children"><div class="content">And how would you read the following?<p><pre><code>  int* i, j;
</code></pre>
C declarations simply are not &quot;first the type, then the variable&quot;...</div><br/><div id="40391271" class="c"><input type="checkbox" id="c-40391271" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40390198">parent</a><span>|</span><a href="#40390440">next</a><span>|</span><label class="collapse" for="c-40391271">[-]</label><label class="expand" for="c-40391271">[17 more]</label></div><br/><div class="children"><div class="content">IMHO the way comma behaves when declaring multiple variables of the same type was a mistake from day one.  The sort of thing that only sticks around because it would break too much existing code to fix it.  If I were in charge I&#x27;d declare the syntax deprecated in the next version of C and introduce a new character, maybe | that would do the same thing except it would propagate the pointer as you would expect.<p>In my code I never use it.  Every variable gets its own line.  You might think this would blow up the declarations, but in practice it&#x27;s not a problem, especially in modern C where you can move declarations down to where they&#x27;re used instead of stuffing them all up at the top of the function.</div><br/><div id="40392272" class="c"><input type="checkbox" id="c-40392272" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40391271">parent</a><span>|</span><a href="#40390440">next</a><span>|</span><label class="collapse" for="c-40392272">[-]</label><label class="expand" for="c-40392272">[16 more]</label></div><br/><div class="children"><div class="content">The only &quot;type&quot; thing about the declaration above is &quot;int&quot;, and that does get applied to all the comma-separated expressions -- so in that way the comma acts totally reasonable.<p>People think that &quot;int *x;&quot; means &quot;declare x as a pointer-to-int&quot; but really it means &quot;declare x such that *x (it&#x27;s a code expression) is of type int.&quot; So it&#x27;s a really roundabout way to say that x is a &quot;pointer to x&quot; while that concept of &quot;pointer to&quot; isn&#x27;t even in the language syntax.</div><br/><div id="40392440" class="c"><input type="checkbox" id="c-40392440" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392272">parent</a><span>|</span><a href="#40390440">next</a><span>|</span><label class="collapse" for="c-40392440">[-]</label><label class="expand" for="c-40392440">[15 more]</label></div><br/><div class="children"><div class="content">Which makes it even worse because it is inconsistent in real world use.  &quot;long&quot; is propagated through the comma, but * is not.</div><br/><div id="40392657" class="c"><input type="checkbox" id="c-40392657" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392440">parent</a><span>|</span><a href="#40390440">next</a><span>|</span><label class="collapse" for="c-40392657">[-]</label><label class="expand" for="c-40392657">[14 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not inconsistent. There are two things in a declaration: a type (here int) and an expression (here *x). If you add commas you can have multiple of the latter. That&#x27;s it. Stop thinking of the star as part of the type, it isn&#x27;t. Leave it with the expression to the right, and thinks make sense .<p>It&#x27;s why I always cringe when I see<p><pre><code>  int* x;
</code></pre>
as opposed to<p><pre><code>   int *x;
</code></pre>
There is a reason why K&amp;R do it that way.</div><br/><div id="40392938" class="c"><input type="checkbox" id="c-40392938" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392657">parent</a><span>|</span><a href="#40393262">next</a><span>|</span><label class="collapse" for="c-40392938">[-]</label><label class="expand" for="c-40392938">[4 more]</label></div><br/><div class="children"><div class="content">The idea that the * isn&#x27;t part of the type has always felt completely wrong to me.   The entire concept of an expression modifying the type doesn&#x27;t provide any benefit that I can see.  The only thing the expression should be doing is giving you the chance to assign the name to the new variable you&#x27;re creating.  Once you define the type, which might be a pointer or not, it should be fixed.<p>I get that this is a pretty fundamental disagreement between me and Knuth &amp; Richie, but I think history has shown that this idea of splitting exactly one aspect of the type (if the variable is direct or a pointer) was a mistake.  It&#x27;s been the cause of a lot of bugs and the cases where you want to define both direct and indirect types on the same line basically don&#x27;t exist.  For clarity you should split those definitions up regardless of what the syntax allows.<p>There are basically no cases where you should be writing the following code even if it is technically correct:<p><pre><code>    int *pointer, direct;</code></pre></div><br/><div id="40394533" class="c"><input type="checkbox" id="c-40394533" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392938">parent</a><span>|</span><a href="#40394674">next</a><span>|</span><label class="collapse" for="c-40394533">[-]</label><label class="expand" for="c-40394533">[1 more]</label></div><br/><div class="children"><div class="content">I never use comma, I always define one variable per line. Much easier to edit and read. However, the way it works is certainly not inconsistent.<p>As to your other concerns, it makes perfect sense.<p><pre><code>   int WHATEVER;
</code></pre>
read as &quot;WHATEVER is an int&quot; and you can work backwards from there. There is no more type syntax than that. The thing is, it&#x27;s much easier to look at stuff this way since otherwise you&#x27;ll have to shift back and forth between 2 different syntaxes (types and expressions) all the time.<p>I&#x27;ve been looking a lot for a better more algebraic syntax too. All syntaxes I&#x27;ve found have lost on two axes _in the common and simple cases_<p>- low cognitive overhead<p>- terseness<p>Yes, the principle of declaration follows usage is already stretched to its limit, and C++ has certainly overstretched it. But still for the bread-and-butter use cases, the &quot;better&quot; syntaxes seem to always lose on those 2 axes.</div><br/></div></div><div id="40394674" class="c"><input type="checkbox" id="c-40394674" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392938">parent</a><span>|</span><a href="#40394533">prev</a><span>|</span><a href="#40395915">next</a><span>|</span><label class="collapse" for="c-40394674">[-]</label><label class="expand" for="c-40394674">[1 more]</label></div><br/><div class="children"><div class="content">I only declare multiple variables in one line if it is a &quot;simple&quot; type, without pointers, arrays, functions, etc.<p>Also, a code such as:<p><pre><code>  int*x=y;
</code></pre>
will define the initial value of x and not of *x. For this reason, a space before the asterisk can be confusing in this way. And, for the reasons described in another comment, putting the space after the asterisk is also confusing. So, I find it clearer to omit both spaces.<p>When I require more complicated types, I will generally use typedef (or typeof) instead of having to deal with the confusing syntax of types in C.</div><br/></div></div><div id="40395915" class="c"><input type="checkbox" id="c-40395915" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392938">parent</a><span>|</span><a href="#40394674">prev</a><span>|</span><a href="#40393262">next</a><span>|</span><label class="collapse" for="c-40395915">[-]</label><label class="expand" for="c-40395915">[1 more]</label></div><br/><div class="children"><div class="content">Kernighan &amp; Ritchie :p<p>The rest of your post is perfect and objectively (subjectively) correct.<p>While I fortunately knew that `int* x, y` means `y` is <i>not</i> a pointer, I always assumed it was some kind of capricious oversight of the compiler. I had no idea the rationale was &quot;the expression `*x` declares `x` to be a pointer to the type west of it&quot;. That strikes me as so weird! XD</div><br/></div></div></div></div><div id="40393262" class="c"><input type="checkbox" id="c-40393262" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392657">parent</a><span>|</span><a href="#40392938">prev</a><span>|</span><a href="#40393357">next</a><span>|</span><label class="collapse" for="c-40393262">[-]</label><label class="expand" for="c-40393262">[2 more]</label></div><br/><div class="children"><div class="content">&gt; There is a reason why K&amp;R do it that way.<p>This was and remains a bad decision, full stop.<p>&#x27;Pointer to something&#x27; <i>should</i> have been a parametrised type rather than C&#x27;s weird syntax of overloading operator*. And I won&#x27;t accept the argument that C was too old to have parametrised types: ML, Lisp, and many other functional-first languages developed alongside C and had them. We&#x27;ve just stuck with C because it got popular because of UNIX and then Linux.<p>I avoid raw pointers whenever I can when I write C++, and I yearn for a language that exposes pointers with a rich and expressive type system instead of making them glorified 64-bit unsigned ints. Pointers ought to be one-dimensional unsigned parametrised affine space types[1] (note: <i>not</i> affine types, which are completely different[2]), with several implications:<p>- comparing pointers to different types should be invalid<p>- subtracting pointers to the same type should return a signed &#x27;pointer difference&#x27; type<p>- adding pointers to the same type should be invalid<p>- Get the address contained by a pointer with Ptr&lt;T&gt;::address()<p>[1]: <a href="http:&#x2F;&#x2F;videocortex.io&#x2F;2018&#x2F;Affine-Space-Types&#x2F;" rel="nofollow">http:&#x2F;&#x2F;videocortex.io&#x2F;2018&#x2F;Affine-Space-Types&#x2F;</a><p>[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Substructural_type_system#Affine_type_systems" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Substructural_type_system#Affi...</a></div><br/><div id="40394373" class="c"><input type="checkbox" id="c-40394373" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40393262">parent</a><span>|</span><a href="#40393357">next</a><span>|</span><label class="collapse" for="c-40394373">[-]</label><label class="expand" for="c-40394373">[1 more]</label></div><br/><div class="children"><div class="content">Would&#x27;ve, should&#x27;ve, could&#x27;ve.<p>Programming languages are a huge waste of time. It&#x27;s a domain with <i>lots</i> of opportunities for bike-shedding, and then for hard-core R&amp;D too. But programming is still engineering, simple &amp; easy that gets the job done wins over needlessly complex. And yes, inertia is real too, but if a programming language was dramatically better at what C does best, I wouldn&#x27;t still start new code in it.<p>When you&#x27;re doing systems programming, pointers being &quot;glorified&quot; 64-bit ints is pretty much what you need. When your requirements hit reality, all the nice abstractions break down quite easily.<p>&gt; I avoid raw pointers whenever I can when I write C++<p>Empirically, this is the path to madness.<p>&gt; - comparing pointers to different types should be invalid<p>It produces a warning on my C compiler and an error on C++ compiler. Note that there _can_ be pointers containing equal addresses with different types -- a struct and its first member have the same address.<p>&gt; - adding pointers to the same type should be invalid<p>I think it is, or what exactly do you mean?<p>&gt; - subtracting pointers to the same type should return a signed &#x27;pointer difference&#x27; type<p>it does, that type is called ptrdiff_t, which is a signed integer type.<p>&gt; - Get the address contained by a pointer with Ptr&lt;T&gt;::address()<p>But you didn&#x27;t want them to be glorified 64-bit ints? Well, because of pointer arithmetic, which is a practical necessity, they kind of are, but then again they&#x27;re not because C tries to abstract from that. You can kinda unwrap the pointer abstraction by casting to the (optional) uintptr_t type.<p>The thing is, not all machines necessarily have one flat address space that contains everything from functions to all data. Pointer representation isn&#x27;t necessarily uniform -- e.g., you can have a bigger type for void-pointers that contain type information too, this way you could do run-time type checking.</div><br/></div></div></div></div><div id="40393357" class="c"><input type="checkbox" id="c-40393357" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392657">parent</a><span>|</span><a href="#40393262">prev</a><span>|</span><a href="#40393811">next</a><span>|</span><label class="collapse" for="c-40393357">[-]</label><label class="expand" for="c-40393357">[5 more]</label></div><br/><div class="children"><div class="content">To me int* x is preferred, here&#x27;s why...<p>I read it like &#x27;IntegerPointer x&#x27; or &#x27;x is an integerPointer&#x27; or &#x27;x is a pointer to an integer&#x27;<p>It rhymes with the following :
&#x27;MilkGlass m&#x27; reads as:<p>&#x27;m is a MilkGlass&#x27; or &#x27;m is a Glass of Milk&#x27;</div><br/><div id="40394169" class="c"><input type="checkbox" id="c-40394169" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40393357">parent</a><span>|</span><a href="#40393811">next</a><span>|</span><label class="collapse" for="c-40394169">[-]</label><label class="expand" for="c-40394169">[4 more]</label></div><br/><div class="children"><div class="content">Yeah but this quickly breaks down -- it&#x27;s not how it &quot;really works&quot;. What about arrays for example?<p><pre><code>   int* x[200];
</code></pre>
You can fight all you want, but C doesn&#x27;t have type syntax. What you&#x27;re looking at is expression syntax.</div><br/><div id="40394304" class="c"><input type="checkbox" id="c-40394304" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40394169">parent</a><span>|</span><a href="#40393811">next</a><span>|</span><label class="collapse" for="c-40394304">[-]</label><label class="expand" for="c-40394304">[3 more]</label></div><br/><div class="children"><div class="content">I would read that x is a collection of 200 intPointers. Is that not correct?</div><br/><div id="40394439" class="c"><input type="checkbox" id="c-40394439" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40394304">parent</a><span>|</span><a href="#40396305">next</a><span>|</span><label class="collapse" for="c-40394439">[-]</label><label class="expand" for="c-40394439">[1 more]</label></div><br/><div class="children"><div class="content">Well yes but there is something off because 200 is not with the &quot;type&quot; anymore.<p>Now do a pointer to an array of 200 ints.</div><br/></div></div><div id="40396305" class="c"><input type="checkbox" id="c-40396305" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40394304">parent</a><span>|</span><a href="#40394439">prev</a><span>|</span><a href="#40393811">next</a><span>|</span><label class="collapse" for="c-40396305">[-]</label><label class="expand" for="c-40396305">[1 more]</label></div><br/><div class="children"><div class="content">Of course you can read it. That was just an example to show that C declarations can&#x27;t always be decomposed into a left part which is the type and a right one which is the variable. It works on the simple case of a pointer, because * is a prefix operator, but it fails on arrays, because [] is postfix.<p><pre><code>  int *   &lt;---&gt;   foo;
  int []   &lt;---&gt;   foo; &#x2F;&#x2F; ugh no!
</code></pre>
The latter would work if C had been designed differently, with operations defined on types. But it was designed with operations defined on values, not on types. There&#x27;s not a way to express &quot;foo is a pointer to int&quot;, you must say &quot;when you dereference foo you get an int&quot; (in fact, * means dereference, not pointer).<p>Imagine if English had not a word for &quot;son&quot;. To say Bob is Adam&#x27;s son you would say &quot;Bob&#x27;s father is Adam&quot;.<p>To tell the truth, C does have the dual of * that is &amp;. If operations on types were defined (and they are not!), then we could have a syntax like this:<p><pre><code>  &amp;int foo;
</code></pre>
In any case, we wouldn&#x27;t solve the issue with arrays, because, while [] is the operator that, given an array, returns one element of it, its inverse operator doesn&#x27;t exist.<p>It&#x27;s not difficult to imagine a different language with a rich set of operators defined for types. We could have &amp;T for &quot;pointer to type T&quot;, T<i>n (note the infix </i>, as multiplication) for &quot;array of n elements of type T&quot;, and so on. Then declarations could be easier:<p><pre><code>  &amp;int  ptr;
  float*3  rgb;
  &amp;int*8  foo; &#x2F;&#x2F; array of 8 ptr
  &amp;(int*8) bar; &#x2F;&#x2F; ptr to array
</code></pre>
See how we are using full expressions including parentheses with types?<p>At this point, you would also move the variable to the left and the type to the right, and maybe add a colon for clarity:<p><pre><code>  ptr : &amp;int;
  rgb : float * 3;
  foo : &amp;int * 8;
  bar : &amp;(int * 8);
</code></pre>
But this is another language, not C.</div><br/></div></div></div></div></div></div></div></div><div id="40393811" class="c"><input type="checkbox" id="c-40393811" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40392657">parent</a><span>|</span><a href="#40393357">prev</a><span>|</span><a href="#40390440">next</a><span>|</span><label class="collapse" for="c-40393811">[-]</label><label class="expand" for="c-40393811">[2 more]</label></div><br/><div class="children"><div class="content">So what about smart pointers?  Is it not inconsistent that smart pointers are a type but raw pointers are not?</div><br/><div id="40394131" class="c"><input type="checkbox" id="c-40394131" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40393811">parent</a><span>|</span><a href="#40390440">next</a><span>|</span><label class="collapse" for="c-40394131">[-]</label><label class="expand" for="c-40394131">[1 more]</label></div><br/><div class="children"><div class="content">Raw pointers &quot;are&quot; a type too. It&#x27;s just that there isn&#x27;t really syntax to describe the type, at least in the original declaration syntax.<p>Note that structs and typedefs that you define are proper type names, you can switch out &quot;int&quot; for them. You can easily &quot;typedef int *intPtr;&quot; and then merrily go &quot;intPtr myptr&quot;.<p>(I think cast type-specs might be a bit of an exception here were the rule breaks a bit -- because they don&#x27;t &quot;use&quot; a name in the cast &quot;expression&quot;. I don&#x27;t intimately understand how those work. The whole thing is an idea that was stretched to the limits, especially with C++ where consistency has pretty much been given up).</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40390440" class="c"><input type="checkbox" id="c-40390440" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40390198">parent</a><span>|</span><a href="#40391271">prev</a><span>|</span><a href="#40393662">next</a><span>|</span><label class="collapse" for="c-40390440">[-]</label><label class="expand" for="c-40390440">[1 more]</label></div><br/><div class="children"><div class="content">you would read it, spot the problem, and fix it to make it two lines.<p>if you dont have space for that one line, switch back to punchcards</div><br/></div></div></div></div><div id="40393662" class="c"><input type="checkbox" id="c-40393662" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40389922">parent</a><span>|</span><a href="#40390198">prev</a><span>|</span><a href="#40390262">next</a><span>|</span><label class="collapse" for="c-40393662">[-]</label><label class="expand" for="c-40393662">[2 more]</label></div><br/><div class="children"><div class="content">What’s wrong with ‘x :int*’ ?</div><br/><div id="40393903" class="c"><input type="checkbox" id="c-40393903" checked=""/><div class="controls bullet"><span class="by">skupig</span><span>|</span><a href="#40388145">root</a><span>|</span><a href="#40393662">parent</a><span>|</span><a href="#40390262">next</a><span>|</span><label class="collapse" for="c-40393903">[-]</label><label class="expand" for="c-40393903">[1 more]</label></div><br/><div class="children"><div class="content">Let me illustrate it like this<p>:does this look correct to you?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40390262" class="c"><input type="checkbox" id="c-40390262" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40388145">prev</a><span>|</span><a href="#40388544">next</a><span>|</span><label class="collapse" for="c-40390262">[-]</label><label class="expand" for="c-40390262">[4 more]</label></div><br/><div class="children"><div class="content">Reminded of that time I tried to sneak this ternary delight into FreeBSD src:<p><pre><code>    if ((Lflag ? chown : lchown)(p-&gt;fts_accpath, s-&gt;st_uid, -1))
            (void)printf(&quot; not modified: %s\n&quot;,
                strerror(errno));
</code></pre>
which relies on the function prototypes of the chown(2) and lchown(2) syscalls being otherwise identical.</div><br/><div id="40391294" class="c"><input type="checkbox" id="c-40391294" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40390262">parent</a><span>|</span><a href="#40391221">next</a><span>|</span><label class="collapse" for="c-40391294">[-]</label><label class="expand" for="c-40391294">[2 more]</label></div><br/><div class="children"><div class="content">Nothing says &quot;I&#x27;m up to some shenanigans&quot; than the ? : syntax in C.</div><br/><div id="40395524" class="c"><input type="checkbox" id="c-40395524" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#40390262">root</a><span>|</span><a href="#40391294">parent</a><span>|</span><a href="#40391221">next</a><span>|</span><label class="collapse" for="c-40395524">[-]</label><label class="expand" for="c-40395524">[1 more]</label></div><br/><div class="children"><div class="content">Except for nested ones; even more fun.</div><br/></div></div></div></div><div id="40391221" class="c"><input type="checkbox" id="c-40391221" checked=""/><div class="controls bullet"><span class="by">kjs3</span><span>|</span><a href="#40390262">parent</a><span>|</span><a href="#40391294">prev</a><span>|</span><a href="#40388544">next</a><span>|</span><label class="collapse" for="c-40391221">[-]</label><label class="expand" for="c-40391221">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s demented.  I don&#x27;t think I&#x27;d ever think to even try that in C.  <i>chef kiss</i></div><br/></div></div></div></div><div id="40388544" class="c"><input type="checkbox" id="c-40388544" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#40390262">prev</a><span>|</span><a href="#40388445">next</a><span>|</span><label class="collapse" for="c-40388544">[-]</label><label class="expand" for="c-40388544">[2 more]</label></div><br/><div class="children"><div class="content">Unfortunately I was astounded, horrified, and simultaneously pleased to discover that I was immediately able to decipher the &quot;hard&quot; (huh ?????) example.<p>Although if I was writing this myself, I would split it up like so:<p><pre><code>    typedef char *StringArray[];
    typedef StringArray *Func();
    Func **foo[][8];
</code></pre>
Which is equivalent and much easier to read. (Although still not trivial. I have no idea what purpose this type really serves. The type names are placeholders as a result.)<p>C type declarations become particularly tricky specifically when people try to directly declare (or typedef) pointers to functions&#x2F;arrays without an intermediate typedef for the function&#x2F;array type.<p>So if you make it a rule to typedef array types before creating pointers to them (although this usually makes for some rather unreadable code so maybe try avoiding it in general) and to typedef function types before creating pointers to them, you will usually have much more readable code.<p>As a bonus, you can then use the function typedef to provide an early type-check for a callback function (even if it&#x27;s a callback your code doesn&#x27;t directly use). E.g.:<p><pre><code>    typedef int Func(int a);
    Func foo;
    int foo(int a)
    {
        return a * 2;
    }
</code></pre>
Or, you know, switch to a higher level language.</div><br/><div id="40388799" class="c"><input type="checkbox" id="c-40388799" checked=""/><div class="controls bullet"><span class="by">dvhh</span><span>|</span><a href="#40388544">parent</a><span>|</span><a href="#40388445">next</a><span>|</span><label class="collapse" for="c-40388799">[-]</label><label class="expand" for="c-40388799">[1 more]</label></div><br/><div class="children"><div class="content">Was thinking the same, but there is always this &quot;clever&quot; dev who insist on putting everything in one line</div><br/></div></div></div></div><div id="40388445" class="c"><input type="checkbox" id="c-40388445" checked=""/><div class="controls bullet"><span class="by">seodisparate</span><span>|</span><a href="#40388544">prev</a><span>|</span><a href="#40392941">next</a><span>|</span><label class="collapse" for="c-40388445">[-]</label><label class="expand" for="c-40388445">[6 more]</label></div><br/><div class="children"><div class="content">Reminds me of <a href="https:&#x2F;&#x2F;goshdarnfunctionpointers.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;goshdarnfunctionpointers.com&#x2F;</a> which has helped in some cases.</div><br/><div id="40388499" class="c"><input type="checkbox" id="c-40388499" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#40388445">parent</a><span>|</span><a href="#40392941">next</a><span>|</span><label class="collapse" for="c-40388499">[-]</label><label class="expand" for="c-40388499">[5 more]</label></div><br/><div class="children"><div class="content">I think I&#x27;ve been writing C for well over 10 years now and this year was finally the one where I forced myself to remember function pointer declarations.
I don&#x27;t even know why it took me so long to remember such a simple thing, but possibly writing &quot;c function pointer&quot; into my favorite search engine and hitting enter was faster than thinking about it for a moment.<p>But maybe also because I changed up my general programming approach a bit and try to think a bit longer before hitting up a search engine. Also forced myself to read more reference sheets than stackoverflow or chatgpt. And I must say, this made me a lot more comfortable, because I understand more. Can recommend to go through the struggle&#x2F;10</div><br/><div id="40390848" class="c"><input type="checkbox" id="c-40390848" checked=""/><div class="controls bullet"><span class="by">scoutt</span><span>|</span><a href="#40388445">root</a><span>|</span><a href="#40388499">parent</a><span>|</span><a href="#40393433">next</a><span>|</span><label class="collapse" for="c-40390848">[-]</label><label class="expand" for="c-40390848">[2 more]</label></div><br/><div class="children"><div class="content">I thought it was just me, that after 20 years of writing C I still have to look how to declare function pointers.</div><br/><div id="40391297" class="c"><input type="checkbox" id="c-40391297" checked=""/><div class="controls bullet"><span class="by">jandrese</span><span>|</span><a href="#40388445">root</a><span>|</span><a href="#40390848">parent</a><span>|</span><a href="#40393433">next</a><span>|</span><label class="collapse" for="c-40391297">[-]</label><label class="expand" for="c-40391297">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m weird that I have no problem getting function pointers but have to look up the syntax to declare an enum every damn time.</div><br/></div></div></div></div><div id="40393433" class="c"><input type="checkbox" id="c-40393433" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#40388445">root</a><span>|</span><a href="#40388499">parent</a><span>|</span><a href="#40390848">prev</a><span>|</span><a href="#40389969">next</a><span>|</span><label class="collapse" for="c-40393433">[-]</label><label class="expand" for="c-40393433">[1 more]</label></div><br/><div class="children"><div class="content">What i usually do is:
Write a normal function declaration, prepend it with typedef and append _t to the function name. DONE<p>The same trick works for anything you want to typedef!</div><br/></div></div><div id="40389969" class="c"><input type="checkbox" id="c-40389969" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#40388445">root</a><span>|</span><a href="#40388499">parent</a><span>|</span><a href="#40393433">prev</a><span>|</span><a href="#40392941">next</a><span>|</span><label class="collapse" for="c-40389969">[-]</label><label class="expand" for="c-40389969">[1 more]</label></div><br/><div class="children"><div class="content">When they&#x27;re function parameters, you can write them as regular function declarations, btw. ;) Might hurt your memorization efforts though.</div><br/></div></div></div></div></div></div><div id="40392941" class="c"><input type="checkbox" id="c-40392941" checked=""/><div class="controls bullet"><span class="by">jxy</span><span>|</span><a href="#40388445">prev</a><span>|</span><a href="#40388132">next</a><span>|</span><label class="collapse" for="c-40392941">[-]</label><label class="expand" for="c-40392941">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s fun stuff of translating C declarations to English, given English uses its special order for possessive and verb object order. If you use Japanese, you can write the Japanese from left to write in order, while reading the C declarations from outside in.<p><pre><code>    char *(*(**foo [][8])())[]
</code></pre>
then reads as<p>charへのポインタの配列へのポインタを返す関数へのポインタへのポインタの8要素からなる配列の未定サイズの配列<p>which uses the reverse of English possessive, and object verb order.</div><br/></div></div><div id="40388132" class="c"><input type="checkbox" id="c-40388132" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40392941">prev</a><span>|</span><a href="#40388487">next</a><span>|</span><label class="collapse" for="c-40388132">[-]</label><label class="expand" for="c-40388132">[12 more]</label></div><br/><div class="children"><div class="content">It is a bit sad that an entire blog post is required to explain type declarations in a language as common as C. It is even worse that C++ stuck with it. It more atrocious still that C decided it was good syntax to attach operator* to the name instead of the type to justify this crazy business, which thankfully C++ reversed a little with `auto` and West const.<p>Imagine how much easier that last example would be with a trailing return type, Ptr&lt;&gt; and Array&lt;&gt; parametrised types, and lambda-esque function objects instead of function pointers:<p><pre><code>  char * (*(**foo[][8])())[]
</code></pre>
versus<p><pre><code>  let foo: Array&lt;Array&lt;Ptr&lt;() -&gt; Ptr&lt;Arr&lt;Ptr&lt;Char&gt;&gt;&gt;&gt;, 8&gt;&gt; = ...
</code></pre>
It&#x27;s immediately clear what the top-level type of `foo` is: some parametrised `Array`. We can do better, though.<p>In this hypothetical language, one would probably dispense with &#x27;pointer to char&#x27; and &#x27;pointer to array&#x27; and replace them with view&#x2F;range&#x2F;span types, eliminating a layer of type parametrisation and many classes of bugs:<p><pre><code>  let foo: Span&lt;Array&lt;Ptr&lt;() -&gt; Ptr&lt;Arr&lt;StringView&gt;&gt;&gt;, 8&gt;&gt; = ...
</code></pre>
Though I am dumbfounded by why there needs to be a &#x27;pointer to array&#x27; in the function return type, and a &#x27;pointer to function pointer&#x27;. I assume these are unknown arrays themselves, which means...<p><pre><code>  let foo: Span&lt;Array&lt;Span&lt;() -&gt; Span&lt;Arr&lt;StringView&gt;&gt;&gt;, 8&gt;&gt; = ...
</code></pre>
A perfect language would probably have multi-dimensional spans, which would eliminate the two `Span&lt;Array&lt;&gt;&gt;` and replace with some `MultiSpan&lt;&gt;`.<p>Addendum: <a href="https:&#x2F;&#x2F;cdecl.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cdecl.org&#x2F;</a> is a very useful and very self-aware resource: &#x27;C gibberish ↔ English&#x27;.</div><br/><div id="40391072" class="c"><input type="checkbox" id="c-40391072" checked=""/><div class="controls bullet"><span class="by">BearOso</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40388380">next</a><span>|</span><label class="collapse" for="c-40391072">[-]</label><label class="expand" for="c-40391072">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve never seen anything that complex in my experience, and it would be considered bad code pretty much everywhere.<p>Rule #1 of programming is to make code easy to understand and self-documenting. This should be a sequence of typedefs with self-explanatory names followed by a function call taking one pointer or type and returning another.</div><br/></div></div><div id="40388380" class="c"><input type="checkbox" id="c-40388380" checked=""/><div class="controls bullet"><span class="by">optymizer</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40391072">prev</a><span>|</span><a href="#40391557">next</a><span>|</span><label class="collapse" for="c-40388380">[-]</label><label class="expand" for="c-40388380">[1 more]</label></div><br/><div class="children"><div class="content">imo anything beyond Array&lt;Something&gt; should usually be aliased to help with readability.<p>Array&lt;Ptr&lt;(Int, String) -&gt; Bool&gt;&gt;<p>Should be:<p>Array&lt;OnClickCallback&gt;<p>Applying that to C code keeps the insane decls in check, especially when using function pointer types</div><br/></div></div><div id="40391557" class="c"><input type="checkbox" id="c-40391557" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40388380">prev</a><span>|</span><a href="#40393455">next</a><span>|</span><label class="collapse" for="c-40391557">[-]</label><label class="expand" for="c-40391557">[1 more]</label></div><br/><div class="children"><div class="content">Just create typedefs or use typeof. One could wrap this in<p><pre><code>  #define _Ptr(T) typeof(T\*)
  #define _Array(T,N) typeof(T[N])
  _Ptr(_Array(int, 8)) x = ...

</code></pre>
and one can also define view and span types in C. No hypothetical language needed.  But I do not think this is an improvement.</div><br/></div></div><div id="40393455" class="c"><input type="checkbox" id="c-40393455" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40391557">prev</a><span>|</span><a href="#40388635">next</a><span>|</span><label class="collapse" for="c-40393455">[-]</label><label class="expand" for="c-40393455">[1 more]</label></div><br/><div class="children"><div class="content">Still, C syntax is 100 times easier to remember than things like templating, smart pointers, dozen flavours of initialyzers in C++, which is used continuously as well.</div><br/></div></div><div id="40388635" class="c"><input type="checkbox" id="c-40388635" checked=""/><div class="controls bullet"><span class="by">tempodox</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40393455">prev</a><span>|</span><a href="#40388327">next</a><span>|</span><label class="collapse" for="c-40388635">[-]</label><label class="expand" for="c-40388635">[2 more]</label></div><br/><div class="children"><div class="content">West const is a travesty given that either side, or both, of a pointer can be `const`.  And with refs I prefer to see that something is a `const &amp;` in one place instead of scanning 3 km of template argument list to find that out.</div><br/><div id="40390358" class="c"><input type="checkbox" id="c-40390358" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40388132">root</a><span>|</span><a href="#40388635">parent</a><span>|</span><a href="#40388327">next</a><span>|</span><label class="collapse" for="c-40390358">[-]</label><label class="expand" for="c-40390358">[1 more]</label></div><br/><div class="children"><div class="content">Ahh, what a typo. I meant East const: <a href="https:&#x2F;&#x2F;hackingcpp.com&#x2F;cpp&#x2F;design&#x2F;east_vs_west_const.html" rel="nofollow">https:&#x2F;&#x2F;hackingcpp.com&#x2F;cpp&#x2F;design&#x2F;east_vs_west_const.html</a></div><br/></div></div></div></div><div id="40388327" class="c"><input type="checkbox" id="c-40388327" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40388635">prev</a><span>|</span><a href="#40388261">next</a><span>|</span><label class="collapse" for="c-40388327">[-]</label><label class="expand" for="c-40388327">[2 more]</label></div><br/><div class="children"><div class="content">Span&lt;T&gt; is pretty much C# syntax :)<p>(Also funny, multi-dimensional spans are coming in the form of TensorSpan&lt;T&gt;)</div><br/><div id="40388341" class="c"><input type="checkbox" id="c-40388341" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40388132">root</a><span>|</span><a href="#40388327">parent</a><span>|</span><a href="#40388261">next</a><span>|</span><label class="collapse" for="c-40388341">[-]</label><label class="expand" for="c-40388341">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. Very inspired by .NET, C++, and Rust.</div><br/></div></div></div></div><div id="40388261" class="c"><input type="checkbox" id="c-40388261" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#40388132">parent</a><span>|</span><a href="#40388327">prev</a><span>|</span><a href="#40388487">next</a><span>|</span><label class="collapse" for="c-40388261">[-]</label><label class="expand" for="c-40388261">[3 more]</label></div><br/><div class="children"><div class="content">In C++, you <i>can</i> do much of what you want with std::array, std::mdspan... and you could also create a Ptr&lt;T&gt; with &quot;using&quot; to define a type alias for T* -- see [0]. Of course the default syntax for pointers is T* and that&#x27;s not going to change, so it&#x27;ll be an uphill battle to keep consistent in any codebase. (I guess systematic use of a rule in clang-tidy or such could help with that.)<p>[0] <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;type_alias" rel="nofollow">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;type_alias</a></div><br/><div id="40388340" class="c"><input type="checkbox" id="c-40388340" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40388132">root</a><span>|</span><a href="#40388261">parent</a><span>|</span><a href="#40388487">next</a><span>|</span><label class="collapse" for="c-40388340">[-]</label><label class="expand" for="c-40388340">[2 more]</label></div><br/><div class="children"><div class="content">Indeed, and there&#x27;s `std::function` (albeit not being a zero-cost abstraction; I believe `std::move_only_function` and `std::copyable_function` in C++23 and C++26 respectively are replacements) and lambda statements. But C++ decided the bracket salad `[](){}` was the best way to write lambdas, and I&#x27;ll never forgive the standard for it.</div><br/><div id="40392293" class="c"><input type="checkbox" id="c-40392293" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#40388132">root</a><span>|</span><a href="#40388340">parent</a><span>|</span><a href="#40388487">next</a><span>|</span><label class="collapse" for="c-40392293">[-]</label><label class="expand" for="c-40392293">[1 more]</label></div><br/><div class="children"><div class="content">Any sort of type erasure on functions will have a non-zero cost. That&#x27;s why the only zero-cost abstraction is having a template parameter (such as remove_if), but these come with a code size cost instead.</div><br/></div></div></div></div></div></div></div></div><div id="40388487" class="c"><input type="checkbox" id="c-40388487" checked=""/><div class="controls bullet"><span class="by">daghamm</span><span>|</span><a href="#40388132">prev</a><span>|</span><a href="#40388226">next</a><span>|</span><label class="collapse" for="c-40388487">[-]</label><label class="expand" for="c-40388487">[3 more]</label></div><br/><div class="children"><div class="content">C type declarations are quite sane, until you need function pointers. Then things get really crazy.<p>Consider this type declaration in Go:<p><pre><code>    func(string) []func(int)[]*float64

</code></pre>
This took me 5 seconds to write. The C&#x2F;C++ counterpart would probably take an hour to get right :(</div><br/><div id="40388774" class="c"><input type="checkbox" id="c-40388774" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#40388487">parent</a><span>|</span><a href="#40388627">next</a><span>|</span><label class="collapse" for="c-40388774">[-]</label><label class="expand" for="c-40388774">[1 more]</label></div><br/><div class="children"><div class="content">Function pointers are easy if you typedef the function type.<p>What a pointer to function (int) returning int?<p>The difficult way:<p><pre><code>    int (*p)(int);
</code></pre>
The easy way:<p><pre><code>    typedef int Func(int);
    Func *p;
</code></pre>
The typedef reads just like a normal function declaration except for the name is the type name rather than the function symbol name. Just like a function declaration, you can add more documentation by giving the parameters names. e.g.:<p><pre><code>    &#x2F;&#x2F; used for some hypothetical allocator API
    typedef void *Alloc(size_t size);
</code></pre>
Similar trick can be used for pointers to arrays (just typedef the array type). Although in practice pointers to arrays just make for awful code.</div><br/></div></div><div id="40388627" class="c"><input type="checkbox" id="c-40388627" checked=""/><div class="controls bullet"><span class="by">lieks</span><span>|</span><a href="#40388487">parent</a><span>|</span><a href="#40388774">prev</a><span>|</span><a href="#40388226">next</a><span>|</span><label class="collapse" for="c-40388627">[-]</label><label class="expand" for="c-40388627">[1 more]</label></div><br/><div class="children"><div class="content">Hmm... Let&#x27;s see...<p>Oh, functions can&#x27;t return arrays in C. That would be a pointer. Well, that makes it easier.<p><pre><code>    double **(**(*)(char *))(int)
</code></pre>
It did take a couple minutes, but I just woke up. Also, idiomatically there would be a typedef:<p><pre><code>    typedef double **A(int);
    typedef A **B(char *);
    B *
</code></pre>
That took a few seconds to write.</div><br/></div></div></div></div><div id="40388226" class="c"><input type="checkbox" id="c-40388226" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#40388487">prev</a><span>|</span><a href="#40388228">next</a><span>|</span><label class="collapse" for="c-40388226">[-]</label><label class="expand" for="c-40388226">[2 more]</label></div><br/><div class="children"><div class="content">Obligatory cdecl plug: <a href="https:&#x2F;&#x2F;cdecl.org&#x2F;?q=int+%28*%28*foo%29%28void+%29%29%5B3%5D" rel="nofollow">https:&#x2F;&#x2F;cdecl.org&#x2F;?q=int+%28*%28*foo%29%28void+%29%29%5B3%5D</a></div><br/><div id="40388446" class="c"><input type="checkbox" id="c-40388446" checked=""/><div class="controls bullet"><span class="by">TomMasz</span><span>|</span><a href="#40388226">parent</a><span>|</span><a href="#40388228">next</a><span>|</span><label class="collapse" for="c-40388446">[-]</label><label class="expand" for="c-40388446">[1 more]</label></div><br/><div class="children"><div class="content">My (pardon the pun) goto utility back in my C programming days.</div><br/></div></div></div></div><div id="40388228" class="c"><input type="checkbox" id="c-40388228" checked=""/><div class="controls bullet"><span class="by">ckocagil</span><span>|</span><a href="#40388226">prev</a><span>|</span><a href="#40389653">next</a><span>|</span><label class="collapse" for="c-40388228">[-]</label><label class="expand" for="c-40388228">[2 more]</label></div><br/><div class="children"><div class="content">Using the clockwise spiral rule.<p><a href="https:&#x2F;&#x2F;c-faq.com&#x2F;decl&#x2F;spiral.anderson.html" rel="nofollow">https:&#x2F;&#x2F;c-faq.com&#x2F;decl&#x2F;spiral.anderson.html</a></div><br/><div id="40388281" class="c"><input type="checkbox" id="c-40388281" checked=""/><div class="controls bullet"><span class="by">tumult</span><span>|</span><a href="#40388228">parent</a><span>|</span><a href="#40389653">next</a><span>|</span><label class="collapse" for="c-40388281">[-]</label><label class="expand" for="c-40388281">[1 more]</label></div><br/><div class="children"><div class="content">The spiral rule is not real and fails on even basic examples like<p><pre><code>    char * foo[10][5];
</code></pre>
The OP article shows you how to actually read the declarations, not a fake trick that will lead you astray.</div><br/></div></div></div></div><div id="40389653" class="c"><input type="checkbox" id="c-40389653" checked=""/><div class="controls bullet"><span class="by">teddyh</span><span>|</span><a href="#40388228">prev</a><span>|</span><a href="#40388030">next</a><span>|</span><label class="collapse" for="c-40389653">[-]</label><label class="expand" for="c-40389653">[9 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  $ sudo apt install cdecl
  […]
  $ cdecl
  Type `help&#x27; or `?&#x27; for help
  cdecl&gt; explain char *(*(**foo[][8])())[];
  declare foo as array of array 8 of pointer to pointer to function returning pointer to array of pointer to char
  cdecl&gt;</code></pre></div><br/><div id="40391849" class="c"><input type="checkbox" id="c-40391849" checked=""/><div class="controls bullet"><span class="by">asimeqi</span><span>|</span><a href="#40389653">parent</a><span>|</span><a href="#40393511">next</a><span>|</span><label class="collapse" for="c-40391849">[-]</label><label class="expand" for="c-40391849">[2 more]</label></div><br/><div class="children"><div class="content">Why do I remember The C Programming Language book by K&amp;R explaining how to write a version of cdecl? I just checked the second edition of the book and my memory seems to be wrong.</div><br/><div id="40392572" class="c"><input type="checkbox" id="c-40392572" checked=""/><div class="controls bullet"><span class="by">sea6ear</span><span>|</span><a href="#40389653">root</a><span>|</span><a href="#40391849">parent</a><span>|</span><a href="#40393511">next</a><span>|</span><label class="collapse" for="c-40392572">[-]</label><label class="expand" for="c-40392572">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not listed as cdecl and (therefore?) not findable in the index, but in chapter 5 - Pointers and Arrays - the book presents the programs dcl and undcl that translate between C declarations and English renderings of them.<p>I believe dcl mimics the cdecl program.</div><br/></div></div></div></div><div id="40393511" class="c"><input type="checkbox" id="c-40393511" checked=""/><div class="controls bullet"><span class="by">nuancebydefault</span><span>|</span><a href="#40389653">parent</a><span>|</span><a href="#40391849">prev</a><span>|</span><a href="#40392362">next</a><span>|</span><label class="collapse" for="c-40393511">[-]</label><label class="expand" for="c-40393511">[1 more]</label></div><br/><div class="children"><div class="content">I think brackets are needed in the sentence, otherwise it is ambiguous?</div><br/></div></div><div id="40392362" class="c"><input type="checkbox" id="c-40392362" checked=""/><div class="controls bullet"><span class="by">WalterBright</span><span>|</span><a href="#40389653">parent</a><span>|</span><a href="#40393511">prev</a><span>|</span><a href="#40389833">next</a><span>|</span><label class="collapse" for="c-40392362">[-]</label><label class="expand" for="c-40392362">[1 more]</label></div><br/><div class="children"><div class="content">D Language:<p><pre><code>    char*[]*function()[8][] foo;</code></pre></div><br/></div></div><div id="40389833" class="c"><input type="checkbox" id="c-40389833" checked=""/><div class="controls bullet"><span class="by">pquki4</span><span>|</span><a href="#40389653">parent</a><span>|</span><a href="#40392362">prev</a><span>|</span><a href="#40391062">next</a><span>|</span><label class="collapse" for="c-40389833">[-]</label><label class="expand" for="c-40389833">[1 more]</label></div><br/><div class="children"><div class="content">Wow, nice. Now I think every IDE should come with this...</div><br/></div></div><div id="40391062" class="c"><input type="checkbox" id="c-40391062" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40389653">parent</a><span>|</span><a href="#40389833">prev</a><span>|</span><a href="#40392661">next</a><span>|</span><label class="collapse" for="c-40391062">[-]</label><label class="expand" for="c-40391062">[2 more]</label></div><br/><div class="children"><div class="content">Thought I&#x27;d take a crack at it in Zig:<p><pre><code>    const foo: [_][8]**fn () [*][*:0]const u8;
</code></pre>
This is an array of result-defined size, of arrays of eight pointers to fn pointers, which returns a many-item pointer to null-terminated arrays of u8. Null terminated because we&#x27;re going to assume that the C data structure is properly null-terminated...<p>Still an insane data structure, and I&#x27;m still learning Zig, so I can&#x27;t promise this is precisely equivalent to the C, I got as close as I could and am unwilling to try and compile, let alone build, such a type.<p>No one would actually do this unless they needed `extern` compatibility. Ignoring the fact (pointed out in the Fine Article) that no one would use anything vaguely like this, a more Zig native version might be<p><pre><code>    const foo: [_][8]**fn() [][]const u8
</code></pre>
Which returns a slice of slices of immutable u8s, these being fat pointers which include their length.</div><br/><div id="40391808" class="c"><input type="checkbox" id="c-40391808" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#40389653">root</a><span>|</span><a href="#40391062">parent</a><span>|</span><a href="#40392661">next</a><span>|</span><label class="collapse" for="c-40391808">[-]</label><label class="expand" for="c-40391808">[1 more]</label></div><br/><div class="children"><div class="content">Nim equivalent:<p><pre><code>   seq[array[8, ptr ptr proc(): ptr seq[ptr char]]]]
</code></pre>
I love having actual words instead of random punctuation soup.</div><br/></div></div></div></div></div></div><div id="40388030" class="c"><input type="checkbox" id="c-40388030" checked=""/><div class="controls bullet"><span class="by">rep_lodsb</span><span>|</span><a href="#40389653">prev</a><span>|</span><label class="collapse" for="c-40388030">[-]</label><label class="expand" for="c-40388030">[34 more]</label></div><br/><div class="children"><div class="content">C syntax is just horrible. It would be better to have something like &quot;ARRAY [100] OF POINTER TO FUNCTION RETURNING POINTER TO INT&quot;, if you need it more than once or twice you can declare a type for it.</div><br/><div id="40388366" class="c"><input type="checkbox" id="c-40388366" checked=""/><div class="controls bullet"><span class="by">PhilipRoman</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40388509">next</a><span>|</span><label class="collapse" for="c-40388366">[-]</label><label class="expand" for="c-40388366">[1 more]</label></div><br/><div class="children"><div class="content">The root problem is having both postfix and prefix operators (and whatever their combination is called) for types.<p>Plus the fact that arrays in type names sometimes act as pointers and sometimes not.</div><br/></div></div><div id="40388509" class="c"><input type="checkbox" id="c-40388509" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40388366">prev</a><span>|</span><a href="#40390689">next</a><span>|</span><label class="collapse" for="c-40388509">[-]</label><label class="expand" for="c-40388509">[4 more]</label></div><br/><div class="children"><div class="content">Still unclear at things like “returning pointer to array of pointer to function …”.<p>The best shot is to name intermediate types, since they aren’t really intermediate most of the times. Properly structured programs tend to disassemble complex structures to work on them, so you need these names anyway.<p>That said, C compilers definitely lack -Wunreadable-types flag which must be default.</div><br/><div id="40388683" class="c"><input type="checkbox" id="c-40388683" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40388509">parent</a><span>|</span><a href="#40388619">next</a><span>|</span><label class="collapse" for="c-40388683">[-]</label><label class="expand" for="c-40388683">[2 more]</label></div><br/><div class="children"><div class="content">Pointers to arrays are an incredibly rare thing in real-world C programming, let alone functions returning them. They contain the same address as a pointer to the beginning of that array, with the only difference that pointer arithmetic will be done in sizeof(arr) steps, not in element-size steps.<p>It is a widely accepted practice to typedef pointers to functions.<p>With pointers, more than 2 levels of indirection is an indication of a badly written program.<p>In practice, the most complex declarations you should write are &quot;pointer to pointer to x&quot;, &quot;array of pointers to x&quot;, &quot;array of function pointers returning x&quot;. Stuff like &quot;pointer to function returning pointer to pointer to array&quot; is nonsensical most of the time.</div><br/><div id="40389491" class="c"><input type="checkbox" id="c-40389491" checked=""/><div class="controls bullet"><span class="by">DrNosferatu</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40388683">parent</a><span>|</span><a href="#40388619">next</a><span>|</span><label class="collapse" for="c-40389491">[-]</label><label class="expand" for="c-40389491">[1 more]</label></div><br/><div class="children"><div class="content">Rare? Unless it’s people obfuscating the codebase so they are able to keep their job forever without delivering any new&#x2F;real value.</div><br/></div></div></div></div><div id="40388619" class="c"><input type="checkbox" id="c-40388619" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40388509">parent</a><span>|</span><a href="#40388683">prev</a><span>|</span><a href="#40390689">next</a><span>|</span><label class="collapse" for="c-40388619">[-]</label><label class="expand" for="c-40388619">[1 more]</label></div><br/><div class="children"><div class="content">I was about to say the same thing.  If you have an array of widgets used in several places in your program it would be odd not give it a name.  Then you can have a pointer to it, etc.</div><br/></div></div></div></div><div id="40390689" class="c"><input type="checkbox" id="c-40390689" checked=""/><div class="controls bullet"><span class="by">jcparkyn</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40388509">prev</a><span>|</span><a href="#40388358">next</a><span>|</span><label class="collapse" for="c-40390689">[-]</label><label class="expand" for="c-40390689">[1 more]</label></div><br/><div class="children"><div class="content">I was with you until the second sentence - there&#x27;s so many better syntaxes C could&#x27;ve used but that&#x27;s not one of them.</div><br/></div></div><div id="40388358" class="c"><input type="checkbox" id="c-40388358" checked=""/><div class="controls bullet"><span class="by">pyjarrett</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40390689">prev</a><span>|</span><a href="#40392315">next</a><span>|</span><label class="collapse" for="c-40388358">[-]</label><label class="expand" for="c-40388358">[1 more]</label></div><br/><div class="children"><div class="content">Ada syntax is close to what you described:<p><pre><code>    Foo : array (Positive range 1 .. 100) of access function return access Integer;</code></pre></div><br/></div></div><div id="40392315" class="c"><input type="checkbox" id="c-40392315" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40388358">prev</a><span>|</span><a href="#40390391">next</a><span>|</span><label class="collapse" for="c-40392315">[-]</label><label class="expand" for="c-40392315">[1 more]</label></div><br/><div class="children"><div class="content">I agree it&#x27;s annoying (really bad for tooling), and what&#x27;s more annoying is that for a human who understands how it works, there is no syntax as easy to read and write as C declaration syntax. It&#x27;s terse and intuitive, not adding new type syntax but reusing what already exists as expression syntax.</div><br/></div></div><div id="40390391" class="c"><input type="checkbox" id="c-40390391" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40392315">prev</a><span>|</span><a href="#40388298">next</a><span>|</span><label class="collapse" for="c-40390391">[-]</label><label class="expand" for="c-40390391">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    uggclang: error in integer literal, did you mean &quot;ONE HUNDRED&quot;? at line one</code></pre></div><br/></div></div><div id="40388298" class="c"><input type="checkbox" id="c-40388298" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40390391">prev</a><span>|</span><a href="#40392665">next</a><span>|</span><label class="collapse" for="c-40388298">[-]</label><label class="expand" for="c-40388298">[2 more]</label></div><br/><div class="children"><div class="content">You missed the opening &quot;PROCEDURE DIVISION.&quot;.</div><br/><div id="40388634" class="c"><input type="checkbox" id="c-40388634" checked=""/><div class="controls bullet"><span class="by">ape4</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40388298">parent</a><span>|</span><a href="#40392665">next</a><span>|</span><label class="collapse" for="c-40388634">[-]</label><label class="expand" for="c-40388634">[1 more]</label></div><br/><div class="children"><div class="content">ADD A TO B GIVING C would be so much clearer</div><br/></div></div></div></div><div id="40389291" class="c"><input type="checkbox" id="c-40389291" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40388030">parent</a><span>|</span><a href="#40392665">prev</a><span>|</span><label class="collapse" for="c-40389291">[-]</label><label class="expand" for="c-40389291">[21 more]</label></div><br/><div class="children"><div class="content">&gt; C syntax is just horrible.<p>All syntax is horrible.  Rust is the en vogue tool of the moment and it&#x27;s objectively harder to read than C.  Python used to be clean and now it&#x27;s sort of a mess.   C++, well...<p>Some languages try to get away with having simple syntax though.  Javascript is in this camp, as of course are all the Lisps.  And the result is that you end up drowning in a sea of <i>complicated semantics</i> instead, c.f. the famous &quot;wat&quot; video or the fact that every sexpr macro-ized DSL works like its own little butterfly.<p>You can&#x27;t win. C is fine.  Could you do better if you started from scratch?  Sure.  Would it last?  No.</div><br/><div id="40389535" class="c"><input type="checkbox" id="c-40389535" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389291">parent</a><span>|</span><a href="#40391195">next</a><span>|</span><label class="collapse" for="c-40389535">[-]</label><label class="expand" for="c-40389535">[14 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is the en vogue tool of the moment and it&#x27;s objectively harder to read than C<p>I think you&#x27;re just used to C syntax. I find Rust syntax <i>much</i> easier to read than C syntax (and that was already true when I didn&#x27;t know either language well).</div><br/><div id="40389935" class="c"><input type="checkbox" id="c-40389935" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389535">parent</a><span>|</span><a href="#40391195">next</a><span>|</span><label class="collapse" for="c-40389935">[-]</label><label class="expand" for="c-40389935">[13 more]</label></div><br/><div class="children"><div class="content">Meh.  Grandparent who thinks &quot;C is horrible&quot; just isn&#x27;t used to C.  Familiarity breeds facility, that&#x27;s no surprise.  But no, Rust is just bad at this point given all the stuff that&#x27;s been added and all the historical idioms that were pushed and then abandoned.  It&#x27;s not C++ bad, but it&#x27;s objectively &quot;worse&quot; than C whose quirks all fit in a tiny K&amp;R paperback.</div><br/><div id="40391011" class="c"><input type="checkbox" id="c-40391011" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389935">parent</a><span>|</span><a href="#40390547">next</a><span>|</span><label class="collapse" for="c-40391011">[-]</label><label class="expand" for="c-40391011">[10 more]</label></div><br/><div class="children"><div class="content">If anything is objectively wrong, it&#x27;s C&#x27;s grammar, and it&#x27;s not even close.<p>When you have an entire Wikipedia article dedicated to how infamously hard your language is to parse, you have no choice but to admit that you&#x27;ve messed up: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lexer_hack" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lexer_hack</a><p>And let&#x27;s not forget: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dangling_else" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dangling_else</a></div><br/><div id="40392096" class="c"><input type="checkbox" id="c-40392096" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40391011">parent</a><span>|</span><a href="#40391474">next</a><span>|</span><label class="collapse" for="c-40392096">[-]</label><label class="expand" for="c-40392096">[7 more]</label></div><br/><div class="children"><div class="content">C itself is not that hard to parse. The &quot;lexer hack&quot; thing is a theoretical impurity but it just means you have to add types to a type table -- and probably open and close scopes -- while parsing. The preprocessor though seems to be pretty annoying.<p>C++ must be comparatively a lot harder to parse -- C++ syntax is a huge amount of complexity added to a system that wasn&#x27;t designed with that in mind.<p>That you link &quot;Dangling else&quot; is curious. The wikipedia page talks about &quot;ambiguity&quot; but in my mind it&#x27;s no different than the ambiguity in &quot;a + b * c&quot;, does it mean &quot;(a + b) * c&quot; or &quot;a + (b * c)&quot;? Well, make a choice and write it down.</div><br/><div id="40394084" class="c"><input type="checkbox" id="c-40394084" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40392096">parent</a><span>|</span><a href="#40395955">next</a><span>|</span><label class="collapse" for="c-40394084">[-]</label><label class="expand" for="c-40394084">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Well, make a choice and write it down.<p>Or don&#x27;t and don&#x27;t allow unnecessary ambiguity. For * and +, there&#x27;s a agreed upon order of operations far more universal than a programming language, but it&#x27;s sensible to use a partial order so nobody is mistaken about whether e.g. logical or and bitshift binds tighter. Similary C counld have just not have allowed omitting the braces around single-line else clauses and would have been a simpler language for it.</div><br/><div id="40394765" class="c"><input type="checkbox" id="c-40394765" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40394084">parent</a><span>|</span><a href="#40395955">next</a><span>|</span><label class="collapse" for="c-40394765">[-]</label><label class="expand" for="c-40394765">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For * and +, there&#x27;s a agreed upon order of operations<p>So... we collectively made a choice and wrote it down, then?  I think you whooshed on the point.  The if&#x2F;else ambiguity is just a precedence rule, like many others in the expression grammar of every (well, every non-lisp) language that exists.</div><br/><div id="40395946" class="c"><input type="checkbox" id="c-40395946" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40394765">parent</a><span>|</span><a href="#40395955">next</a><span>|</span><label class="collapse" for="c-40395946">[-]</label><label class="expand" for="c-40395946">[2 more]</label></div><br/><div class="children"><div class="content">Needing to specify associativity for operations that have absolutely no reason to be ambiguous in the first place is a flaw of language design. It&#x27;s needless complexity. Isn&#x27;t C supposed to be a &quot;simple&quot; language?</div><br/><div id="40396443" class="c"><input type="checkbox" id="c-40396443" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40395946">parent</a><span>|</span><a href="#40395955">next</a><span>|</span><label class="collapse" for="c-40396443">[-]</label><label class="expand" for="c-40396443">[1 more]</label></div><br/><div class="children"><div class="content">You lost me.  How does if&#x2F;else have &quot;no reason to be ambiguous in the first place&quot;.  It&#x27;s ambiguous <i>in the actual language from which it was derived</i>.  English itself has no syntax for expressing a nested &quot;if&quot; such that you can match the right &quot;else&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="40395955" class="c"><input type="checkbox" id="c-40395955" checked=""/><div class="controls bullet"><span class="by">kibwen</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40392096">parent</a><span>|</span><a href="#40394084">prev</a><span>|</span><a href="#40391474">next</a><span>|</span><label class="collapse" for="c-40395955">[-]</label><label class="expand" for="c-40395955">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; it just means you have to add types to a type table -- and probably open and close scopes -- while parsing</i><p>Which is a flaw that other languages don&#x27;t have to deal with, because they learned from C&#x27;s mistakes. There&#x27;s no justifiable reason for a language&#x27;s grammar to make this sort of thing necessary. C would be better--and simpler--without it.</div><br/><div id="40396569" class="c"><input type="checkbox" id="c-40396569" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40395955">parent</a><span>|</span><a href="#40391474">next</a><span>|</span><label class="collapse" for="c-40396569">[-]</label><label class="expand" for="c-40396569">[1 more]</label></div><br/><div class="children"><div class="content">Did they learn? What about Java or C# then, for example?<p>I would like to have a better syntax too but it&#x27;s a tradeoff. I really want to like more algebraic syntaxes like Zig&#x2F;Odin&#x2F;Jai but C&#x27;s terseness and ease of use for the common, simple cases is unmatched unfortunately.</div><br/></div></div></div></div></div></div><div id="40391474" class="c"><input type="checkbox" id="c-40391474" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40391011">parent</a><span>|</span><a href="#40392096">prev</a><span>|</span><a href="#40392656">next</a><span>|</span><label class="collapse" for="c-40391474">[-]</label><label class="expand" for="c-40391474">[1 more]</label></div><br/><div class="children"><div class="content">Having written a C parser, C is not hard to parse. It does not fit some nice model, and if you assume this and don&#x27;t know about the issues, you might waste your time. It iis still simple to write a C parser.</div><br/></div></div><div id="40392656" class="c"><input type="checkbox" id="c-40392656" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40391011">parent</a><span>|</span><a href="#40391474">prev</a><span>|</span><a href="#40390547">next</a><span>|</span><label class="collapse" for="c-40392656">[-]</label><label class="expand" for="c-40392656">[1 more]</label></div><br/><div class="children"><div class="content">There are C compilers that run in 64k of RAM.  Let&#x27;s not overstate the complexity here.</div><br/></div></div></div></div><div id="40390547" class="c"><input type="checkbox" id="c-40390547" checked=""/><div class="controls bullet"><span class="by">leetcrew</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389935">parent</a><span>|</span><a href="#40391011">prev</a><span>|</span><a href="#40391195">next</a><span>|</span><label class="collapse" for="c-40390547">[-]</label><label class="expand" for="c-40390547">[2 more]</label></div><br/><div class="children"><div class="content">it&#x27;s subjective to an extent, but requiring a &quot;reverse spiral rule&quot; (which itself has exceptions) to understand inline types is about as close to objectively bad as it gets.<p>rust surely has it&#x27;s issues, but reading types is not one of them. whatever you put inside the &lt;&gt; of a outermost symbol is a straightforward tree parse.</div><br/><div id="40392132" class="c"><input type="checkbox" id="c-40392132" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40390547">parent</a><span>|</span><a href="#40391195">next</a><span>|</span><label class="collapse" for="c-40392132">[-]</label><label class="expand" for="c-40392132">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;reverse spiral rule&quot; is a myth and that website should be shut down. It only adds confusion for the already confused.<p>C type syntax has a simple guiding principle, there is no type syntax and &quot;declaration follows usage&quot; i.e. normal expression syntax. A few ugly additions that don&#x27;t cleanly fit in this model were made later for practical reasons, but they don&#x27;t change the basic idea, which is that there is so little to C type syntax that you can barely see it (which may also be why it&#x27;s so easy to read once you&#x27;ve grokked it).</div><br/></div></div></div></div></div></div></div></div><div id="40391195" class="c"><input type="checkbox" id="c-40391195" checked=""/><div class="controls bullet"><span class="by">mmaniac</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389291">parent</a><span>|</span><a href="#40389535">prev</a><span>|</span><a href="#40389590">next</a><span>|</span><label class="collapse" for="c-40391195">[-]</label><label class="expand" for="c-40391195">[1 more]</label></div><br/><div class="children"><div class="content">C syntax is only better than Rust&#x27;s because of its simplicity. If C were as semantically rich as Rust it&#x27;d be more of an unreadable mess.<p>That said, C&#x27;s syntactic missteps appear to be accidents, while Rust delights itself in being ugly.</div><br/></div></div><div id="40389590" class="c"><input type="checkbox" id="c-40389590" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389291">parent</a><span>|</span><a href="#40391195">prev</a><span>|</span><a href="#40391198">next</a><span>|</span><label class="collapse" for="c-40389590">[-]</label><label class="expand" for="c-40389590">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rust is the en vogue tool of the moment and it&#x27;s objectively harder to read than C<p>If this is &quot;objectively&quot; true please link the study which was able to somehow measure that.</div><br/><div id="40389902" class="c"><input type="checkbox" id="c-40389902" checked=""/><div class="controls bullet"><span class="by">shrimp_emoji</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389590">parent</a><span>|</span><a href="#40391198">next</a><span>|</span><label class="collapse" for="c-40389902">[-]</label><label class="expand" for="c-40389902">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s subjectively objective. Rust syntax is hard and spiky, like a crab&#x27;s carapace.</div><br/></div></div></div></div><div id="40391198" class="c"><input type="checkbox" id="c-40391198" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40389291">parent</a><span>|</span><a href="#40389590">prev</a><span>|</span><label class="collapse" for="c-40391198">[-]</label><label class="expand" for="c-40391198">[3 more]</label></div><br/><div class="children"><div class="content">There are several languages which are motivated by providing a better experience than C in C&#x27;s native domain. Rust is not one of those languages.<p>Rust has an innovative, but highly opinionated, memory model: the premise is writing high performance <i>memory safe</i> programs, with &#x27;zero cost&#x27; abstractions and so on. You might write a program in Rust rather than C in the way you might write a program in Go rather than C: because the application is better modeled in a language which isn&#x27;t C. For programs which pertain to the domain where C should be considered on its merits, if you try to write them in Rust, you may as well start each module with an unsafe block.<p>But no, C is not fine. It has a stunning amount of own-goals making it <i>pointlessly difficult</i> to write a program with a fine-grained memory policy that is correct.  C also doesn&#x27;t have a syntax <i>at all</i> until you&#x27;ve run CPP, and then you have a context-sensitive parse. Neither of these are mere technical formalities, they actively inhibit understanding a C program.</div><br/><div id="40392725" class="c"><input type="checkbox" id="c-40392725" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40391198">parent</a><span>|</span><label class="collapse" for="c-40392725">[-]</label><label class="expand" for="c-40392725">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  For programs which pertain to the domain where C should be considered on its merits, if you try to write them in Rust, you may as well start each module with an unsafe block.<p>This is often said, but does not reflect reality. At this point, we have tons of bare-metal and OS-level Rust code existing in the world, and it still has very little unsafe overall.</div><br/><div id="40393445" class="c"><input type="checkbox" id="c-40393445" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#40388030">root</a><span>|</span><a href="#40392725">parent</a><span>|</span><label class="collapse" for="c-40393445">[-]</label><label class="expand" for="c-40393445">[1 more]</label></div><br/><div class="children"><div class="content">Granted, that was put poorly, let me try again. What I said doesn&#x27;t in fact have the implication you took from it, but I didn&#x27;t explain myself particularly well.<p>There are many programs one can write in C, or Zig, or some other manual-transmission language, which, if you wrote them in Rust, would just be wrapped in a big unsafe block.  That isn&#x27;t because those programs have memory errors in them, it&#x27;s because they have a memory policy which safe Rust doesn&#x27;t support.<p>Examples include certain garbage collection algorithms, and embedded programs where all memory is pre-allocated and references shared somewhat promiscuously. It&#x27;s possible to write analogous programs in safe Rust, but not the same program. The space of programs which are both correct, and not possible in safe Rust, is infinite. They don&#x27;t come with compiler guarantees, so other support is needed. CompCert is a good example of an approach to that which isn&#x27;t Rust&#x27;s.<p>Keeping in mind that I&#x27;m referring to <i>specific programs</i>, not &quot;a program which solves the problem domain&quot;. Otherwise we could just say that since you can write a program which solves the problem domain in Python, there&#x27;s no use for Rust. That wouldn&#x27;t lead to a productive conversation, would it.<p>People still choose C over Rust, even knowing what Rust is. This isn&#x27;t the early days of the evangelism strike force, Steve. The above is why.<p>Sometimes they might be better off writing the analogous program in Rust, or seeing if they can get the program they&#x27;re trying to write with limited use of unsafe blocks. Sometimes not. I know you&#x27;ve put a lot of work into your hammer over the years, but it&#x27;s never going to be the only tool in the box.<p>Languages, and I&#x27;m thinking of Zig here, which make it easier to correctly implement a memory policy which doesn&#x27;t happen to be Rust&#x27;s, should be applauded, and not called &quot;a massive step backwards for the industry &lt;pouty sad face&gt;&quot;. Like it or not, they&#x27;re working in the same domain as Rust, based on different principles.<p>But yes, there is an infinitely large class of programs which can be written in the embedded and OS spaces, in Rust, with very little unsafe overall. I didn&#x27;t intend to imply otherwise.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>