<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734771666194" as="style"/><link rel="stylesheet" href="styles.css?v=1734771666194"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nullprogram.com/blog/2024/12/20/">Rules to avoid common extended inline assembly mistakes</a> <span class="domain">(<a href="https://nullprogram.com">nullprogram.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>8 comments</span></div><br/><div><div id="42477388" class="c"><input type="checkbox" id="c-42477388" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#42477968">next</a><span>|</span><label class="collapse" for="c-42477388">[-]</label><label class="expand" for="c-42477388">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Because it’s so treacherous, the first rule is to avoid it if at all possible. Modern compilers are loaded with intrinsics and built-ins that replace nearly all the old inline assembly use cases.<p>If you take away anything from this article, it should be at least this.  Intrinsics&#x2F;builtins should be your first approach.  Only use inline assembly if you can&#x27;t express what you need using intrinsics.</div><br/></div></div><div id="42477968" class="c"><input type="checkbox" id="c-42477968" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#42477388">prev</a><span>|</span><a href="#42477165">next</a><span>|</span><label class="collapse" for="c-42477968">[-]</label><label class="expand" for="c-42477968">[1 more]</label></div><br/><div class="children"><div class="content">One of my earliest surprises is: input-only and output-only may be mapped to the same register, and explicitly mapping one of them will not prevent this: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;bo3r749Ge" rel="nofollow">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;bo3r749Ge</a></div><br/></div></div><div id="42477165" class="c"><input type="checkbox" id="c-42477165" checked=""/><div class="controls bullet"><span class="by">tom_</span><span>|</span><a href="#42477968">prev</a><span>|</span><a href="#42478122">next</a><span>|</span><label class="collapse" for="c-42477165">[-]</label><label class="expand" for="c-42477165">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always been a mystery to me why people put up with this stuff. Adding strings to the assembler output is fine if you want to assemble some unsupported instruction, and a useful getout clause. But as the only option, it sucks, and it&#x27;s no fun if you want to insert more than 1 instruction.<p>I used CodeWarrior for PowerPC about 15 years ago, and its inline assembler was very easy to use. No markup required, and you didn&#x27;t even have to really understand the ABI. Write a C function, add &quot;register&quot; to the parameters, put register variables inside the function, add an asm block inside it, then do your worst. It&#x27;d track variable liveness to allocate registers, and rearrange instructions to lengthen dependency chains. Any problems, you&#x27;d get an error. Very nice.</div><br/><div id="42477671" class="c"><input type="checkbox" id="c-42477671" checked=""/><div class="controls bullet"><span class="by">Conscat</span><span>|</span><a href="#42477165">parent</a><span>|</span><a href="#42477331">next</a><span>|</span><label class="collapse" for="c-42477671">[-]</label><label class="expand" for="c-42477671">[1 more]</label></div><br/><div class="children"><div class="content">Raw multi-line R&quot;()&quot; strings in C++ reduce some of the tedium. I wrote myself an Emacs tree sitter pattern to highlight asm syntax nicer than a string normally would, which helps. There is also the stasm library (which I haven&#x27;t used) that looks like a pleasant syntax. <a href="https:&#x2F;&#x2F;github.com&#x2F;stasinek&#x2F;stasm">https:&#x2F;&#x2F;github.com&#x2F;stasinek&#x2F;stasm</a><p>Clang (but not GCC) also supports the MSVC assembly syntax which is derived from Borland inline assembly. Unlike MSVC, Clang supports it in 64-bit mode and also for arm.</div><br/></div></div><div id="42477331" class="c"><input type="checkbox" id="c-42477331" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#42477165">parent</a><span>|</span><a href="#42477671">prev</a><span>|</span><a href="#42477682">next</a><span>|</span><label class="collapse" for="c-42477331">[-]</label><label class="expand" for="c-42477331">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used CodeWarrior for PowerPC, but that approach sounds like it requires the C compiler to understand the assembler instructions you are using. Is it? But most use cases of inline assembler I&#x27;ve seen these days is for using instructions that the compiler will not emit.</div><br/></div></div><div id="42477682" class="c"><input type="checkbox" id="c-42477682" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#42477165">parent</a><span>|</span><a href="#42477331">prev</a><span>|</span><a href="#42478122">next</a><span>|</span><label class="collapse" for="c-42477682">[-]</label><label class="expand" for="c-42477682">[1 more]</label></div><br/><div class="children"><div class="content">Most of the time I&#x27;ve used inline assembly it&#x27;s because the compiler was optimizing something badly. I don&#x27;t want it to rearrange anything.<p>(Scheduling is almost useless on modern desktop CPUs anyway, except for some instruction fusion patterns.)</div><br/></div></div></div></div><div id="42478122" class="c"><input type="checkbox" id="c-42478122" checked=""/><div class="controls bullet"><span class="by">brigade</span><span>|</span><a href="#42477165">prev</a><span>|</span><label class="collapse" for="c-42478122">[-]</label><label class="expand" for="c-42478122">[1 more]</label></div><br/><div class="children"><div class="content">There aren’t many reasons to write an inline asm block that the compiler will elide because of no apparent effects; more likely you screwed up the constraints. If it’s due to ensuring correct memory accesses relative to the compiler, it’s usually better to define appropriate “m” constraints to give the compiler appropriate visibility, or if it’s complex&#x2F;loopy enough to make that impossible then <i>that</i> is what the “memory” clobber is for, not volatile.<p>So I strongly disagree with 2 and 3.</div><br/></div></div></div></div></div></div></div></body></html>