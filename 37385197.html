<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693904466104" as="style"/><link rel="stylesheet" href="styles.css?v=1693904466104"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.theregister.com/2023/09/01/web_assembly_wasm_column/">WASM: Big deal or little deal?</a> <span class="domain">(<a href="https://www.theregister.com">www.theregister.com</a>)</span></div><div class="subtext"><span>elorant</span> | <span>54 comments</span></div><br/><div><div id="37387098" class="c"><input type="checkbox" id="c-37387098" checked=""/><div class="controls bullet"><span class="by">diego_moita</span><span>|</span><a href="#37387071">next</a><span>|</span><label class="collapse" for="c-37387098">[-]</label><label class="expand" for="c-37387098">[5 more]</label></div><br/><div class="children"><div class="content">It is a reasonable big deal in the niche of computation intensive applications.<p>It would be an huge deal or revolution if it could perform faster on plain DOM manipulation. By now, plain Javascript is faster than WASM [0].<p>That&#x27;s because all WASM&#x27;s DOM manipulation must go through the Javascript engine and many browsers do JIT compilation on Javascript.<p>Edit: be aware that the article has a more interesting discussion on WASM on the server side, as a replacement of technologies such as Docker&#x2F;containers, Java Virtual Machine and .Net.<p>[0] <a href="https:&#x2F;&#x2F;krausest.github.io&#x2F;js-framework-benchmark&#x2F;2023&#x2F;table_chrome_116.0.5845.82.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;krausest.github.io&#x2F;js-framework-benchmark&#x2F;2023&#x2F;table...</a></div><br/><div id="37387393" class="c"><input type="checkbox" id="c-37387393" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#37387098">parent</a><span>|</span><a href="#37387629">next</a><span>|</span><label class="collapse" for="c-37387393">[-]</label><label class="expand" for="c-37387393">[2 more]</label></div><br/><div class="children"><div class="content">Unless you don&#x27;t use the DOM at all for UI for web apps: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34612696">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34612696</a><p>It would enable any language to simply render their own UI and handle things like accessibility with their own accessibility based DOM that just handles the accessibility parts rather than the entire logic of the app. I believe this is what Flutter does.</div><br/><div id="37389401" class="c"><input type="checkbox" id="c-37389401" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#37387098">root</a><span>|</span><a href="#37387393">parent</a><span>|</span><a href="#37387629">next</a><span>|</span><label class="collapse" for="c-37389401">[-]</label><label class="expand" for="c-37389401">[1 more]</label></div><br/><div class="children"><div class="content">This means shipping an entire UI framework as part of the web app onto a computer that already is running multiple UI frameworks.<p>For example on macOS with Chrome, you’ll have Flutter running on Chromium running on AppKit. All of these provide text layout engines, compositors, 2D and 3D graphics, widget hierarchies, scripting languages… Hundreds of megabytes of redundant stuff loaded in memory to run some typically basic Flutter app.<p>I know, we can’t magically have native binaries delivered on the web (that was ActiveX and it was bad). But it somehow boggles the mind that this is what we ended up with.</div><br/></div></div></div></div><div id="37387629" class="c"><input type="checkbox" id="c-37387629" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#37387098">parent</a><span>|</span><a href="#37387393">prev</a><span>|</span><a href="#37387330">next</a><span>|</span><label class="collapse" for="c-37387629">[-]</label><label class="expand" for="c-37387629">[1 more]</label></div><br/><div class="children"><div class="content">Just days ago I was rewriting some matrix math operations for our game from C to WASM SIMD, only for most of them to barely tie the original performance (where for reference a crappy x86 SIMD routine gives me 3x to 5x).<p>That&#x27;s not something you&#x27;d use for &quot;computationally intensive&quot; applications. Frankly this shit has been around for years and the major implementations still suck.<p>As for servers, it&#x27;s insane to pretend you don&#x27;t know what your server&#x27;s CPU is and run your crap in what&#x27;s essentially a handicapped JVM. Made up solutions for made up problems.</div><br/></div></div><div id="37387330" class="c"><input type="checkbox" id="c-37387330" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#37387098">parent</a><span>|</span><a href="#37387629">prev</a><span>|</span><a href="#37387071">next</a><span>|</span><label class="collapse" for="c-37387330">[-]</label><label class="expand" for="c-37387330">[1 more]</label></div><br/><div class="children"><div class="content">A WASM-powered virtual DOM with painting privileges seems all but ascertained given the general direction Mozilla and other interested parties are taking the environment. Include the bubble&#x2F;capture phases and you’re completely there.</div><br/></div></div></div></div><div id="37387071" class="c"><input type="checkbox" id="c-37387071" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#37387098">prev</a><span>|</span><a href="#37388722">next</a><span>|</span><label class="collapse" for="c-37387071">[-]</label><label class="expand" for="c-37387071">[3 more]</label></div><br/><div class="children"><div class="content">Where I see this as a huge deal is for plug-in development. For finl, I was looking at the possibility of incorporating an interpreter for JavaScript or Python or Lua. Instead, I can create bindings for WASM and get a sandboxed environment for people to write their own extensions. There will be some packaging tools that I’ll want to provide (the idea being that a user specifies something like<p><pre><code>     \LoadExtension{yoyodyne:csv-reader:1.0}
</code></pre>
to bring in an extension and if there isn’t a local copy of the extension, it will fetch it from a repository, and I’ll want to bundle a bunch of stuff into a standard ZIP file layout (so that documentation, etc. will be easily fetched).<p>The list of languages that can compile to WASM increases on a regular basis and it seems by far the best route for plugin handling in a greenfield project.</div><br/><div id="37389367" class="c"><input type="checkbox" id="c-37389367" checked=""/><div class="controls bullet"><span class="by">flutetornado</span><span>|</span><a href="#37387071">parent</a><span>|</span><a href="#37387377">next</a><span>|</span><label class="collapse" for="c-37389367">[-]</label><label class="expand" for="c-37389367">[1 more]</label></div><br/><div class="children"><div class="content">Yes, on a related note Neovim just got support for WASM plugins and apparently WASM is 100% faster than Lua (neovim&#x27;s default plugin language runtime) for this use case according to the author. So now plugins in any language that can be compiled to WASM are possible.<p>Edit: <a href="https:&#x2F;&#x2F;github.com&#x2F;Borwe&#x2F;wasm_nvim">https:&#x2F;&#x2F;github.com&#x2F;Borwe&#x2F;wasm_nvim</a></div><br/></div></div><div id="37387377" class="c"><input type="checkbox" id="c-37387377" checked=""/><div class="controls bullet"><span class="by">bhelx</span><span>|</span><a href="#37387071">parent</a><span>|</span><a href="#37389367">prev</a><span>|</span><a href="#37388722">next</a><span>|</span><label class="collapse" for="c-37387377">[-]</label><label class="expand" for="c-37387377">[1 more]</label></div><br/><div class="children"><div class="content">I work on a project for building such plug-in systems. We have a wide variety of languages supported <a href="https:&#x2F;&#x2F;extism.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;extism.org&#x2F;</a><p>&gt; and I’ll want to bundle a bunch of stuff into a standard ZIP file layout (so that documentation, etc. will be easily fetched<p>I&#x27;ve always, thought it would be cool if Wasm runtimes had a generic supported format for this. Kind of like a Java JAR. But of course, you can implement a custom version for application pretty easily.</div><br/></div></div></div></div><div id="37388722" class="c"><input type="checkbox" id="c-37388722" checked=""/><div class="controls bullet"><span class="by">eternityforest</span><span>|</span><a href="#37387071">prev</a><span>|</span><a href="#37388431">next</a><span>|</span><label class="collapse" for="c-37388722">[-]</label><label class="expand" for="c-37388722">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m kind of afraid of this. When it gets DOM and drawing abilities, People are gonna build SO many things of varying levels of quality, from scratch, that probably could have been done with existing JS frameworks, don&#x27;t work well with browser features, require learning 583 languages to work on anything, etc.<p>It will be amazing for compute heavy stuff in the browser I&#x27;d imagine. Cross platform assembly is a super cool idea. If they can get it right at least we might have <i>something</i> besides a container that runs anywhere.<p>I&#x27;m just not sure I want them to mess with JS&#x2F;HTML based UI just when it was really getting awesome and declarative was becoming standard... And since web devs like. Making stuff harder than it needs to be they might...</div><br/></div></div><div id="37388431" class="c"><input type="checkbox" id="c-37388431" checked=""/><div class="controls bullet"><span class="by">mikewarot</span><span>|</span><a href="#37388722">prev</a><span>|</span><a href="#37386154">next</a><span>|</span><label class="collapse" for="c-37388431">[-]</label><label class="expand" for="c-37388431">[1 more]</label></div><br/><div class="children"><div class="content">In the beginning, there were incompatible microprocessors, so p-code was widely deployed to avoid having to write the same Pascal compiler over and over on every platform, but it was slow because it was interpreted, but even worse was that it tended to crash.<p>Later, the Java VM was created, to avoid rewriting the same code over on every platform, but it was slow because it was interpreted, but thanks to JIT, that was pretty much taken care of. The main problem then became the fact that it, like ActiveX before it (which wasn&#x27;t cross-platform), got general access to the file system, and could never really be safely used.<p>It remains to be seen if WASM&#x2F;WASI retain their commitment to capability based security, which is at this point the main selling point. There have now been fast cross platform systems, but this is the first that builds in capabilities, and doesn&#x27;t give general access to the file system.<p>Analogy #1 - We need such a system... it&#x27;s like power in a home... with a circuit breaker, and the promise that you&#x27;re only going to get 15 amps, not all of the power of the grid, flowing to anything you plug in.<p>Analogy #2 - It&#x27;s like cash in a wallet, you decide how much to hand over to an untrusted partner in a transaction. You should be able to decide what files&#x2F;folders to hand to a program, and know it won&#x27;t get anything more than that.<p>Analogy #3 - The IBM PC XT with twin floppy disks was the most secure general purpose computer of its time, and still is.  You had control over your data, full and transparent control, because you decided what the allowable side effects were when you decided what disks to let it access, and also if they were read-only or writeable. You can&#x27;t do that today.</div><br/></div></div><div id="37386154" class="c"><input type="checkbox" id="c-37386154" checked=""/><div class="controls bullet"><span class="by">CottonMcKnight</span><span>|</span><a href="#37388431">prev</a><span>|</span><a href="#37386040">next</a><span>|</span><label class="collapse" for="c-37386154">[-]</label><label class="expand" for="c-37386154">[22 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty objectively a big deal.<p>(Feature-limited) Photoshop was ported to WASM in 2021.<p><a href="https:&#x2F;&#x2F;web.dev&#x2F;ps-on-the-web&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.dev&#x2F;ps-on-the-web&#x2F;</a><p>With the deprecation and imminent removal of WebSQL, the official (Google) recommendation for SQL-in-browser is WASM SQLite.<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;wasm&#x2F;doc&#x2F;trunk&#x2F;index.md" rel="nofollow noreferrer">https:&#x2F;&#x2F;sqlite.org&#x2F;wasm&#x2F;doc&#x2F;trunk&#x2F;index.md</a></div><br/><div id="37387085" class="c"><input type="checkbox" id="c-37387085" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37386154">parent</a><span>|</span><a href="#37386610">next</a><span>|</span><label class="collapse" for="c-37387085">[-]</label><label class="expand" for="c-37387085">[3 more]</label></div><br/><div class="children"><div class="content">How is any of that a &quot;big deal&quot; though? We&#x27;ve been compiling arbitrary code to Javascript for years now.<p>I&#x27;m all for WASM but it seems more on the level of a new processor generation or faster RAM than something revolutionary. I&#x27;m sure it took a lot of hard work by smart people, but for most of us it&#x27;s an implementation detail.</div><br/><div id="37387262" class="c"><input type="checkbox" id="c-37387262" checked=""/><div class="controls bullet"><span class="by">blovescoffee</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387085">parent</a><span>|</span><a href="#37386610">next</a><span>|</span><label class="collapse" for="c-37387262">[-]</label><label class="expand" for="c-37387262">[2 more]</label></div><br/><div class="children"><div class="content">You should read about the creation of Figma. Some applications require a certain level of performance or they just don’t have much value prop. WASM made figma possible</div><br/><div id="37387316" class="c"><input type="checkbox" id="c-37387316" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387262">parent</a><span>|</span><a href="#37386610">next</a><span>|</span><label class="collapse" for="c-37387316">[-]</label><label class="expand" for="c-37387316">[1 more]</label></div><br/><div class="children"><div class="content">Figma existed before WASM was enabled in browsers so clearly that&#x27;s not true. They claim WASM improved their load times by 3x, which is a lot, but enough to make the difference between viable and not? I doubt it.</div><br/></div></div></div></div></div></div><div id="37386610" class="c"><input type="checkbox" id="c-37386610" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#37386154">parent</a><span>|</span><a href="#37387085">prev</a><span>|</span><a href="#37386446">next</a><span>|</span><label class="collapse" for="c-37386610">[-]</label><label class="expand" for="c-37386610">[5 more]</label></div><br/><div class="children"><div class="content">Say what? WebSQL was an experiment that ended up being replaced by indexeddb- it has been deprecated ever since, and was never part of the web standards.</div><br/><div id="37386777" class="c"><input type="checkbox" id="c-37386777" checked=""/><div class="controls bullet"><span class="by">CottonMcKnight</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37386610">parent</a><span>|</span><a href="#37387051">next</a><span>|</span><label class="collapse" for="c-37386777">[-]</label><label class="expand" for="c-37386777">[1 more]</label></div><br/><div class="children"><div class="content">It has been deprecated for a long time but still available in Chromium. It is being removed in Chromium 119 at the end of next month.<p>See the aside about SQLite WASM on this blog post.<p><a href="https:&#x2F;&#x2F;developer.chrome.com&#x2F;blog&#x2F;deprecating-web-sql&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.chrome.com&#x2F;blog&#x2F;deprecating-web-sql&#x2F;</a></div><br/></div></div><div id="37387051" class="c"><input type="checkbox" id="c-37387051" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37386610">parent</a><span>|</span><a href="#37386777">prev</a><span>|</span><a href="#37386446">next</a><span>|</span><label class="collapse" for="c-37387051">[-]</label><label class="expand" for="c-37387051">[3 more]</label></div><br/><div class="children"><div class="content">It’s telling that despite IndexedDB being around forever people would still rather download an entire SQLite runtime than use it. A deeply unsatisfying API.</div><br/><div id="37388306" class="c"><input type="checkbox" id="c-37388306" checked=""/><div class="controls bullet"><span class="by">smashed</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387051">parent</a><span>|</span><a href="#37386446">next</a><span>|</span><label class="collapse" for="c-37388306">[-]</label><label class="expand" for="c-37388306">[2 more]</label></div><br/><div class="children"><div class="content">If I remember correctly, the main argument against web sql was that it really was just SQLite disguised as a web standard. I.e. there was a single implementation which defined the spec: SQLite. Every browser implementation relied on it.<p>In retrospect, with the chrome monoculture we have today, this seems like a silly argument but at the time it was a legitimate concern.</div><br/></div></div></div></div></div></div><div id="37386446" class="c"><input type="checkbox" id="c-37386446" checked=""/><div class="controls bullet"><span class="by">Kiuhrly1</span><span>|</span><a href="#37386154">parent</a><span>|</span><a href="#37386610">prev</a><span>|</span><a href="#37386887">next</a><span>|</span><label class="collapse" for="c-37386446">[-]</label><label class="expand" for="c-37386446">[1 more]</label></div><br/><div class="children"><div class="content">For the web and other use cases where it is embedded in another program (e.g. sandboxed plugins, other places where Lua or similar would&#x27;ve gone previously), I think yes. But I really don&#x27;t see something like WASI or WASM servers sticking around, especially because it still has a noticeable performance penalty compared to native (can&#x27;t source this right now, need to sleep)</div><br/></div></div><div id="37386887" class="c"><input type="checkbox" id="c-37386887" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37386154">parent</a><span>|</span><a href="#37386446">prev</a><span>|</span><a href="#37386040">next</a><span>|</span><label class="collapse" for="c-37386887">[-]</label><label class="expand" for="c-37386887">[12 more]</label></div><br/><div class="children"><div class="content">We didn’t need wasm to compile to the web for decades prior. Having a target closer to machine code is good, but not revolutionary. Same for Photoshop on the web tbh. Who is even using this?</div><br/><div id="37387122" class="c"><input type="checkbox" id="c-37387122" checked=""/><div class="controls bullet"><span class="by">matthewowen</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37386887">parent</a><span>|</span><a href="#37387037">next</a><span>|</span><label class="collapse" for="c-37387122">[-]</label><label class="expand" for="c-37387122">[6 more]</label></div><br/><div class="children"><div class="content">Figma is built using WASM, sees significant benefit from it, and is pretty popular.<p>But absolutely there are a lot of of less demanding web applications out there that don’t need this. And in the case of Figma, it’s the core of the application that uses WASM, with the more webby UI bits outside of it for all the devex reasons you’d expect.<p>In truth it’s a medium deal in the sense that it enables use cases that simply aren’t feasible without it, but is arguably irrelevant for most “conventional” web dev problems.<p>In that vein I’d argue it is more relevant for use cases that currently aren’t on the web at all versus as an improvement for those that are.</div><br/><div id="37387576" class="c"><input type="checkbox" id="c-37387576" checked=""/><div class="controls bullet"><span class="by">o1y32</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387122">parent</a><span>|</span><a href="#37387285">next</a><span>|</span><label class="collapse" for="c-37387576">[-]</label><label class="expand" for="c-37387576">[1 more]</label></div><br/><div class="children"><div class="content">People bring up Figma in almost any discussion related to WebAssembly. I tried to dig into this and understand why they chose this, what kind of benefit they are getting from this and how it compares to alternatives. Turns out that there is no comparison in performance because the alternative (doing everything in JS) was never done, and the choice of going WebAssembly is more due to their history and stack than anything else. In other words, if they rewrote the whole thing with modern JavaScript ecosystem (e.g. TypeScript with strict typing, typed array), it is unclear that the product would be any worse than the current implementation, because nobody ever tried that.<p>Therefore, &quot;Figma is built on WebAssembly so WebAssembly is good&quot; is weak argument.</div><br/></div></div><div id="37387285" class="c"><input type="checkbox" id="c-37387285" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387122">parent</a><span>|</span><a href="#37387576">prev</a><span>|</span><a href="#37387037">next</a><span>|</span><label class="collapse" for="c-37387285">[-]</label><label class="expand" for="c-37387285">[4 more]</label></div><br/><div class="children"><div class="content">I can’t stand Figma, it’s limited, slow and in general, demonstrating nothing at all for its wasm use so that’s kind in support of my point. Something like Figma would get a lot more performance out of using WebGL. Which is only accessible through JS, and the emscripten bindings for it go through JS calls. So WASM is kind of a dead weight in this scenario.</div><br/><div id="37387338" class="c"><input type="checkbox" id="c-37387338" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387285">parent</a><span>|</span><a href="#37387037">next</a><span>|</span><label class="collapse" for="c-37387338">[-]</label><label class="expand" for="c-37387338">[3 more]</label></div><br/><div class="children"><div class="content">The company was last valued at $20B so they are doing something right.<p>They <i>are</i> using WebGL. Using WebGL from WebAssembly has some nice advantages; with Wasm you can use languages that are more accommodating to the sort of densely-packed data that you need to send to GPU buffers.<p>Here’s an interview I did with a raster graphics editor that touches on why they use Wasm for GPU. <a href="https:&#x2F;&#x2F;digest.browsertech.com&#x2F;archive&#x2F;browsertech-digest-how-modyfi-is-building-with&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;digest.browsertech.com&#x2F;archive&#x2F;browsertech-digest-ho...</a></div><br/><div id="37389373" class="c"><input type="checkbox" id="c-37389373" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387338">parent</a><span>|</span><a href="#37387488">next</a><span>|</span><label class="collapse" for="c-37389373">[-]</label><label class="expand" for="c-37389373">[1 more]</label></div><br/><div class="children"><div class="content">&gt; so they are doing something right<p>That doesn&#x27;t mean it&#x27;s a technical thing they&#x27;re doing right, particularly.</div><br/></div></div><div id="37387488" class="c"><input type="checkbox" id="c-37387488" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387338">parent</a><span>|</span><a href="#37389373">prev</a><span>|</span><a href="#37387037">next</a><span>|</span><label class="collapse" for="c-37387488">[-]</label><label class="expand" for="c-37387488">[1 more]</label></div><br/><div class="children"><div class="content">Accommodating how? Everything goes through JS, what they share is basically an ArrayBuffer (if we&#x27;re talking command buffers) which you can build directly in JS with the same JIT backend that powers WASM. I went through your article but it doesn&#x27;t describe how is WASM more &quot;accomodating&quot; to this.<p>One way or another, the command buffers are an encoding process. They&#x27;re not WASM code nor JS code, they&#x27;re GPU code. You need to build them from one platform for another platform. There&#x27;s no any direct correspondence between WASM and WebGPU, let alone WebGL.</div><br/></div></div></div></div></div></div></div></div><div id="37387037" class="c"><input type="checkbox" id="c-37387037" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37386887">parent</a><span>|</span><a href="#37387122">prev</a><span>|</span><a href="#37387058">next</a><span>|</span><label class="collapse" for="c-37387037">[-]</label><label class="expand" for="c-37387037">[2 more]</label></div><br/><div class="children"><div class="content">You’re asking who is using Photoshop on the web? A lot of people. Like there’s a ton of people using Office 365 in a browser rather than the native app.<p>HN loves to shit on webapps and honestly with very good reason but the reality is that for a lot of people a cloud-based app they can use on absolutely any computer (or, often, phone&#x2F;tablet) they can get their hands on is a huge boon.</div><br/><div id="37387633" class="c"><input type="checkbox" id="c-37387633" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387037">parent</a><span>|</span><a href="#37387058">next</a><span>|</span><label class="collapse" for="c-37387633">[-]</label><label class="expand" for="c-37387633">[1 more]</label></div><br/><div class="children"><div class="content">Absolutely any computer&#x2F;phone&#x2F;tablet has the concept of applications.<p>Web apps remove initial friction of installation, and for big apps not even that much because you still need to download it and run it. But they also pay up this gain, with huge interest, for every single second you use the app. This is not benefitting the users. The bottom line is dire.<p>However removing initial friction is all about getting your foot in the door. It&#x27;s like selling a printer under cost and then you get them with the ink. Get them the first drug dose free, and then you get them when they&#x27;re dependent. Offer a cheap design, and then you destroy them with the manufacturing.<p>A story as old as the world, of which this &quot;web megaapp&quot; model is a tiny microcosm of. The web is an excellent platform for small to medium apps. Photoshop is gigantic. And Figma and the other rest of its ilk are absolutely insufferable and I&#x27;m saying this as a webdev. I would be significantly happier if these products did NOT exist.<p>Heck if we took out WASM and these kind of products went away I&#x27;d consider it a net positive.</div><br/></div></div></div></div><div id="37387058" class="c"><input type="checkbox" id="c-37387058" checked=""/><div class="controls bullet"><span class="by">mfer</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37386887">parent</a><span>|</span><a href="#37387037">prev</a><span>|</span><a href="#37386040">next</a><span>|</span><label class="collapse" for="c-37387058">[-]</label><label class="expand" for="c-37387058">[3 more]</label></div><br/><div class="children"><div class="content">WASM is very useful for things outside the web.<p>Consider that a WASM build can be run server side on multiple OS and arch. The same build. The API can be controlled and locked down (think security).<p>The web is not the most interesting place for WASM.</div><br/><div id="37388399" class="c"><input type="checkbox" id="c-37388399" checked=""/><div class="controls bullet"><span class="by">3cats-in-a-coat</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37387058">parent</a><span>|</span><a href="#37386040">next</a><span>|</span><label class="collapse" for="c-37388399">[-]</label><label class="expand" for="c-37388399">[2 more]</label></div><br/><div class="children"><div class="content">You can also run the same build when there&#x27;s no OS fragmentation. Say all Windows machines run the same build. All iPhones run the same build (well not quite, but let&#x27;s say they automated and hid the builds very efficiently on the App Store, zero effort). All in all, builds are not a problem. If they&#x27;re a problem, it&#x27;s a symptom of a fragmented, immature ecosystem, which indeed many Linux&#x2F;BSD distros continue to be, in the big picture.<p>However none of this matters. Because we have Java and countless other cross-platform runtimes. WASM is at best just another variation on the same theme thrown in the same pool. I definitely see how one could justify WASM hype by saying all the things will be WASM because it&#x27;s so sandboxed and multiplatform. But that&#x27;s the engine of all hype cycles. Truth is it likely won&#x27;t happen, because WASM is nothing new and nothing unique. That niche is filled with solutions already.<p>We could theorize everyone will have a WASM compiler backend because it runs in browsers, therefore it&#x27;ll become more useful on servers as you have compiler backend for everything to WASM. However YOU yourself said the web is not the most interesting place for WASM. So what will supposedly drive the WASM ecosystem, that makes it interesting (the web) isn&#x27;t interesting, but it has to be interesting so the server use of WASM becomes more interesting. Quite the chicken egg problem there. Might work, might not.<p>I lived through a period on the web when every language had a JS compiler backend. You could compile Java to JS, Delphi to JS, C# to JS and so on. Maybe some of those solutions still exist in some half-dead form, but they&#x27;re largely abandoned, because people realized the best language to write JS in... is JS. This is also why TypeScript has such success, because it&#x27;s JavaScript itself (but with types).<p>For WASM we can argue there&#x27;s no such pressure to &quot;write JS in JS&quot; but there&#x27;s just very little value for it, outside the nerd realm of &quot;OMG assembly on the web&quot;. I know why Google wants it. It wants it because it indexes the web, and puts ads on the web, and so therefore it wants <i>everything</i> to be the web, because then it means Google can index and put ads on <i>everything</i>. That&#x27;s good for them, but not for anyone else. Downloading and running hundreds of MB of code for an app like Photoshop, or whatever, over the web is an absolutely miserable experience. Not to mention the HCI input capabilities and OS services available to the app, which are understandably limited in a browser.</div><br/><div id="37389392" class="c"><input type="checkbox" id="c-37389392" checked=""/><div class="controls bullet"><span class="by">robertlagrant</span><span>|</span><a href="#37386154">root</a><span>|</span><a href="#37388399">parent</a><span>|</span><a href="#37386040">next</a><span>|</span><label class="collapse" for="c-37389392">[-]</label><label class="expand" for="c-37389392">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All in all, builds are not a problem. If they&#x27;re a problem, it&#x27;s a symptom of a fragmented, immature ecosystem, which indeed many Linux&#x2F;BSD distros continue to be, in the big picture.<p>Can you give an example of how builds are a problem due to Linux&#x2F;BSD distros?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37386040" class="c"><input type="checkbox" id="c-37386040" checked=""/><div class="controls bullet"><span class="by">goalieca</span><span>|</span><a href="#37386154">prev</a><span>|</span><a href="#37386952">next</a><span>|</span><label class="collapse" for="c-37386040">[-]</label><label class="expand" for="c-37386040">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Does that sound familiar? It should, you could use that same description for containers<p>The reminds me of java but with native web browser support instead of applets.</div><br/><div id="37386547" class="c"><input type="checkbox" id="c-37386547" checked=""/><div class="controls bullet"><span class="by">coffeebeqn</span><span>|</span><a href="#37386040">parent</a><span>|</span><a href="#37387214">next</a><span>|</span><label class="collapse" for="c-37386547">[-]</label><label class="expand" for="c-37386547">[4 more]</label></div><br/><div class="children"><div class="content">This has all happened before. Java web things, Flash, etc. they all have the same problem that they don’t fit in with semantic web content</div><br/><div id="37386955" class="c"><input type="checkbox" id="c-37386955" checked=""/><div class="controls bullet"><span class="by">zdragnar</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37386547">parent</a><span>|</span><a href="#37387438">next</a><span>|</span><label class="collapse" for="c-37386955">[-]</label><label class="expand" for="c-37386955">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not why those things died, though. They died because smartphones stopped supporting them, and that combined with advancements in JS engine speed were all it took to get brother vendors to scrap the buggy, security-hole-ridden plugin ecosystem.<p>WASM should hopefully not be bad from a security perspective, but the up-front performance penalty of early demos in downloading megabytes for hello world was painful.<p>More purpose-fit, smaller modules ought to be broadly useful but I&#x27;ll not be holding my breath. Anything that needs to take over a canvas probably isn&#x27;t going to be widely adopted outside of some niche things like visual design tools or the occasional game.</div><br/></div></div><div id="37387438" class="c"><input type="checkbox" id="c-37387438" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37386547">parent</a><span>|</span><a href="#37386955">prev</a><span>|</span><a href="#37387214">next</a><span>|</span><label class="collapse" for="c-37387438">[-]</label><label class="expand" for="c-37387438">[2 more]</label></div><br/><div class="children"><div class="content">Flash and Java Applets both owned a rectangle of the screen. Wasm interacts with the page just like JS does. So in contrast to Flash and Java, Wasm fits in with semantic web content to the same extent that JS does.</div><br/><div id="37388438" class="c"><input type="checkbox" id="c-37388438" checked=""/><div class="controls bullet"><span class="by">throwaway847599</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37387438">parent</a><span>|</span><a href="#37387214">next</a><span>|</span><label class="collapse" for="c-37388438">[-]</label><label class="expand" for="c-37388438">[1 more]</label></div><br/><div class="children"><div class="content">Java applets could access the DOM and even run Javascript functions.</div><br/></div></div></div></div></div></div><div id="37387214" class="c"><input type="checkbox" id="c-37387214" checked=""/><div class="controls bullet"><span class="by">intrasight</span><span>|</span><a href="#37386040">parent</a><span>|</span><a href="#37386547">prev</a><span>|</span><a href="#37386934">next</a><span>|</span><label class="collapse" for="c-37387214">[-]</label><label class="expand" for="c-37387214">[1 more]</label></div><br/><div class="children"><div class="content">I was sure that &quot;Does that sound familiar&quot; would be followed by the history of Java. There&#x27;s no VM in Docker.</div><br/></div></div><div id="37386934" class="c"><input type="checkbox" id="c-37386934" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37386040">parent</a><span>|</span><a href="#37387214">prev</a><span>|</span><a href="#37386952">next</a><span>|</span><label class="collapse" for="c-37386934">[-]</label><label class="expand" for="c-37386934">[5 more]</label></div><br/><div class="children"><div class="content">That, but without the proprietary UI</div><br/><div id="37387092" class="c"><input type="checkbox" id="c-37387092" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37386934">parent</a><span>|</span><a href="#37386952">next</a><span>|</span><label class="collapse" for="c-37387092">[-]</label><label class="expand" for="c-37387092">[4 more]</label></div><br/><div class="children"><div class="content">Tclets were fully open source and Java applets were mostly open source. It doesn&#x27;t seem to have helped.</div><br/><div id="37387405" class="c"><input type="checkbox" id="c-37387405" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37387092">parent</a><span>|</span><a href="#37386952">next</a><span>|</span><label class="collapse" for="c-37387405">[-]</label><label class="expand" for="c-37387405">[3 more]</label></div><br/><div class="children"><div class="content">Perhaps I should say non-standard&#x2F;non-native.<p>Java applets used Java Swing UI</div><br/><div id="37387525" class="c"><input type="checkbox" id="c-37387525" checked=""/><div class="controls bullet"><span class="by">pvg</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37387405">parent</a><span>|</span><a href="#37387446">next</a><span>|</span><label class="collapse" for="c-37387525">[-]</label><label class="expand" for="c-37387525">[1 more]</label></div><br/><div class="children"><div class="content">Applets pre-dated and didn&#x27;t depend on Swing. But even native UI in the middle of a web-page looked non-native.</div><br/></div></div><div id="37387446" class="c"><input type="checkbox" id="c-37387446" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37386040">root</a><span>|</span><a href="#37387405">parent</a><span>|</span><a href="#37387525">prev</a><span>|</span><a href="#37386952">next</a><span>|</span><label class="collapse" for="c-37387446">[-]</label><label class="expand" for="c-37387446">[1 more]</label></div><br/><div class="children"><div class="content">Most WASM applications use extremely non-native UI elements.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37386952" class="c"><input type="checkbox" id="c-37386952" checked=""/><div class="controls bullet"><span class="by">pizzafeelsright</span><span>|</span><a href="#37386040">prev</a><span>|</span><a href="#37386523">next</a><span>|</span><label class="collapse" for="c-37386952">[-]</label><label class="expand" for="c-37386952">[1 more]</label></div><br/><div class="children"><div class="content">Huge.<p>I&#x27;ve been a Chrome OS user for a decade. I no longer worry about the OS, files, or versions. This is great. What we do need is the ability to build the UX locally outside the confines of the browser outside of the existing OS.<p>The idea that files can share user space with other files without explicit permission always felt off.</div><br/></div></div><div id="37386523" class="c"><input type="checkbox" id="c-37386523" checked=""/><div class="controls bullet"><span class="by">irrational</span><span>|</span><a href="#37386952">prev</a><span>|</span><a href="#37387774">next</a><span>|</span><label class="collapse" for="c-37386523">[-]</label><label class="expand" for="c-37386523">[5 more]</label></div><br/><div class="children"><div class="content">I judge things by how they affect me right now. Right now it is not a big deal. As a web developer I haven’t had a need for it and don’t anticipate a need for it any time in the near future. If I need to use it at some point in the future, maybe it will be a big deal.</div><br/><div id="37387021" class="c"><input type="checkbox" id="c-37387021" checked=""/><div class="controls bullet"><span class="by">crubier</span><span>|</span><a href="#37386523">parent</a><span>|</span><a href="#37387397">next</a><span>|</span><label class="collapse" for="c-37387021">[-]</label><label class="expand" for="c-37387021">[3 more]</label></div><br/><div class="children"><div class="content">&quot;If it&#x27;s not a big deal now it&#x27;s not a big deal now, and if it&#x27;s a big deal in the future then it will be a big deal in the future&quot; is not adding as much to the conversation as you think it is.<p>The point of HN is in large part about thinking about the future and not just look about how things are just &quot;right now&quot;. There is no point discussing the impact that things have right now, we can just measure it.</div><br/><div id="37387155" class="c"><input type="checkbox" id="c-37387155" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#37386523">root</a><span>|</span><a href="#37387021">parent</a><span>|</span><a href="#37387397">next</a><span>|</span><label class="collapse" for="c-37387155">[-]</label><label class="expand" for="c-37387155">[2 more]</label></div><br/><div class="children"><div class="content">But it’s not new. It’s been around for years. And I’m not really aware of any real uses on the web.<p>Other people in these comments have mentioned using it as an extension mechanism to other applications. That’s nice.<p>But what browsers use it internally? What popular JS&#x2F;TS libraries? What big websites?<p>It seems Figma does, but I had to Google to find that.<p>It’s an interesting idea, but it feels a bit like VRML or something else so far. “It’s going to take off, just give it time.”<p>Some things will. Some won’t. But WASM doesn’t seem to provide enough above JS to overcome the “we can just use JS” hurdle for the vast majority of uses so far.</div><br/><div id="37387421" class="c"><input type="checkbox" id="c-37387421" checked=""/><div class="controls bullet"><span class="by">tbrownaw</span><span>|</span><a href="#37386523">root</a><span>|</span><a href="#37387155">parent</a><span>|</span><a href="#37387397">next</a><span>|</span><label class="collapse" for="c-37387421">[-]</label><label class="expand" for="c-37387421">[1 more]</label></div><br/><div class="children"><div class="content">I believe blazor (dotnet in the browser) is built on it.</div><br/></div></div></div></div></div></div><div id="37387397" class="c"><input type="checkbox" id="c-37387397" checked=""/><div class="controls bullet"><span class="by">paulgb</span><span>|</span><a href="#37386523">parent</a><span>|</span><a href="#37387021">prev</a><span>|</span><a href="#37387774">next</a><span>|</span><label class="collapse" for="c-37387397">[-]</label><label class="expand" for="c-37387397">[1 more]</label></div><br/><div class="children"><div class="content">Web (site) developers will likely never have to learn Wasm if they don’t want to. But people are increase shipping regular application software to the browser as if it’s an OS. Technically you could say the developers of these apps are “web developers”, but the stack is increasingly diverging from the stack a web (site) developer would need to care about: Wasm, WebGPU, OPFS, etc.</div><br/></div></div></div></div><div id="37387774" class="c"><input type="checkbox" id="c-37387774" checked=""/><div class="controls bullet"><span class="by">singularity2001</span><span>|</span><a href="#37386523">prev</a><span>|</span><a href="#37386814">next</a><span>|</span><label class="collapse" for="c-37387774">[-]</label><label class="expand" for="c-37387774">[1 more]</label></div><br/><div class="children"><div class="content">WASM may live up to its promise when they finally fix js&#x2F;dom interop. Looks like it&#x27;s indefinitely postponed though. so we are stuck with ungodly glue calling between it and JavaScript (which is unavoidable if you want to do much with it), incredibly hacky.</div><br/></div></div><div id="37386814" class="c"><input type="checkbox" id="c-37386814" checked=""/><div class="controls bullet"><span class="by">julianeon</span><span>|</span><a href="#37387774">prev</a><span>|</span><a href="#37386944">next</a><span>|</span><label class="collapse" for="c-37386814">[-]</label><label class="expand" for="c-37386814">[2 more]</label></div><br/><div class="children"><div class="content">The tl;dr seems to be it’s a big deal if you need game console like performance in your browser. Want to mock up designs there? You need WASM.<p>But if your answer is “I’m building a SaaS, I don’t need incredible cutting edge performance” - it seems less necessary.</div><br/><div id="37387149" class="c"><input type="checkbox" id="c-37387149" checked=""/><div class="controls bullet"><span class="by">ajhurliman</span><span>|</span><a href="#37386814">parent</a><span>|</span><a href="#37386944">next</a><span>|</span><label class="collapse" for="c-37387149">[-]</label><label class="expand" for="c-37387149">[1 more]</label></div><br/><div class="children"><div class="content">Definitely. CAD in the browser? WASM. High-end photographic computation in the browser? WASM. Pretty much everything else… not WASM</div><br/></div></div></div></div><div id="37386944" class="c"><input type="checkbox" id="c-37386944" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#37386814">prev</a><span>|</span><label class="collapse" for="c-37386944">[-]</label><label class="expand" for="c-37386944">[1 more]</label></div><br/><div class="children"><div class="content">&quot;For example, Python has become the quick, easy way for people to work with machine learning programs – thank you, PyTorch. But you can&#x27;t simply drop these programs into WASM in a runtime and expect them to work. The problem is that you also need many third-party dependencies, which aren&#x27;t there yet.&quot;<p>Yes you can, ONNX. Yeah, it&#x27;s not _literally Pytorch_. But it takes about 10 minutes.</div><br/></div></div></div></div></div></div></div></body></html>