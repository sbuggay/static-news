<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731315674157" as="style"/><link rel="stylesheet" href="styles.css?v=1731315674157"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API">Web Locks API</a> <span class="domain">(<a href="https://developer.mozilla.org">developer.mozilla.org</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>86 comments</span></div><br/><div><div id="42102283" class="c"><input type="checkbox" id="c-42102283" checked=""/><div class="controls bullet"><span class="by">unilynx</span><span>|</span><a href="#42103439">next</a><span>|</span><label class="collapse" for="c-42102283">[-]</label><label class="expand" for="c-42102283">[15 more]</label></div><br/><div class="children"><div class="content">&gt; navigator.locks.request(&quot;my_resource&quot;, async (lock) =&gt; {<p>This would be so much more readable with `using`<p><pre><code>  {
    using lock = navigator.lock(&#x27;my_resource&#x27;);
    await do_something();
    await do_something_else();
  }
</code></pre>
(<a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-explicit-resource-management">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-explicit-resource-managemen...</a>)</div><br/><div id="42102699" class="c"><input type="checkbox" id="c-42102699" checked=""/><div class="controls bullet"><span class="by">yoavm</span><span>|</span><a href="#42102283">parent</a><span>|</span><a href="#42105298">next</a><span>|</span><label class="collapse" for="c-42102699">[-]</label><label class="expand" for="c-42102699">[7 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t actually feel more readable to me. I find the idea that the lock declaration sits at the same level as the lock content confusing.</div><br/><div id="42102768" class="c"><input type="checkbox" id="c-42102768" checked=""/><div class="controls bullet"><span class="by">zeroxfe</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102699">parent</a><span>|</span><a href="#42104780">next</a><span>|</span><label class="collapse" for="c-42102768">[-]</label><label class="expand" for="c-42102768">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s readable if you&#x27;re familiar with the RAII pattern which is used in languages like C++ and Go.</div><br/><div id="42104709" class="c"><input type="checkbox" id="c-42104709" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102768">parent</a><span>|</span><a href="#42104682">next</a><span>|</span><label class="collapse" for="c-42104709">[-]</label><label class="expand" for="c-42104709">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also similar to C#&#x27;s &quot;using ...;&quot; without a block. Syntax sugar there rather than RAII, but looks the same.</div><br/></div></div><div id="42104682" class="c"><input type="checkbox" id="c-42104682" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102768">parent</a><span>|</span><a href="#42104709">prev</a><span>|</span><a href="#42104819">next</a><span>|</span><label class="collapse" for="c-42104682">[-]</label><label class="expand" for="c-42104682">[2 more]</label></div><br/><div class="children"><div class="content">I always felt that pattern was a bit too clever than it was a good design.</div><br/><div id="42105300" class="c"><input type="checkbox" id="c-42105300" checked=""/><div class="controls bullet"><span class="by">karmarepellent</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42104682">parent</a><span>|</span><a href="#42104819">next</a><span>|</span><label class="collapse" for="c-42105300">[-]</label><label class="expand" for="c-42105300">[1 more]</label></div><br/><div class="children"><div class="content">Makes me wonder what part of the pattern you think is &quot;too clever&quot;? I think it is fairly easy to reason about when the lock is restricted to the encompassing block and automatically dropped when you leave the block.</div><br/></div></div></div></div><div id="42104819" class="c"><input type="checkbox" id="c-42104819" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102768">parent</a><span>|</span><a href="#42104682">prev</a><span>|</span><a href="#42104780">next</a><span>|</span><label class="collapse" for="c-42104819">[-]</label><label class="expand" for="c-42104819">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not RAII, but closer to dynamic-wind.</div><br/></div></div></div></div><div id="42104780" class="c"><input type="checkbox" id="c-42104780" checked=""/><div class="controls bullet"><span class="by">nesarkvechnep</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102699">parent</a><span>|</span><a href="#42102768">prev</a><span>|</span><a href="#42105298">next</a><span>|</span><label class="collapse" for="c-42104780">[-]</label><label class="expand" for="c-42104780">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it sits at the same level to signify the lifetime of the lock.</div><br/></div></div></div></div><div id="42105298" class="c"><input type="checkbox" id="c-42105298" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#42102283">parent</a><span>|</span><a href="#42102699">prev</a><span>|</span><a href="#42102924">next</a><span>|</span><label class="collapse" for="c-42105298">[-]</label><label class="expand" for="c-42105298">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   navigator whileLocked:&#x27;my_resource&#x27; do:{ :protected |
      protected doSomething.
      protected doOtherThing.
   }</code></pre></div><br/></div></div><div id="42102924" class="c"><input type="checkbox" id="c-42102924" checked=""/><div class="controls bullet"><span class="by">chrisfosterelli</span><span>|</span><a href="#42102283">parent</a><span>|</span><a href="#42105298">prev</a><span>|</span><a href="#42102537">next</a><span>|</span><label class="collapse" for="c-42102924">[-]</label><label class="expand" for="c-42102924">[2 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t we just `await` the lock call?<p>Edit: Nevermind, release of the lock is automatic when the callback resolves its promise. I get it now.</div><br/><div id="42104734" class="c"><input type="checkbox" id="c-42104734" checked=""/><div class="controls bullet"><span class="by">KTibow</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102924">parent</a><span>|</span><a href="#42102537">next</a><span>|</span><label class="collapse" for="c-42104734">[-]</label><label class="expand" for="c-42104734">[1 more]</label></div><br/><div class="children"><div class="content">If you really wanted it to be at the top level you could probably turn it into an explicit `release` call using a wrapper and two `Promise` constructors, though that would probably be a bad idea since it could introduce bugs</div><br/></div></div></div></div><div id="42102537" class="c"><input type="checkbox" id="c-42102537" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#42102283">parent</a><span>|</span><a href="#42102924">prev</a><span>|</span><a href="#42104571">next</a><span>|</span><label class="collapse" for="c-42102537">[-]</label><label class="expand" for="c-42102537">[3 more]</label></div><br/><div class="children"><div class="content">You can probably wrap it to have that API</div><br/><div id="42103869" class="c"><input type="checkbox" id="c-42103869" checked=""/><div class="controls bullet"><span class="by">n2d4</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42102537">parent</a><span>|</span><a href="#42104571">next</a><span>|</span><label class="collapse" for="c-42103869">[-]</label><label class="expand" for="c-42103869">[2 more]</label></div><br/><div class="children"><div class="content">Sadly it needs a language feature that doesn&#x27;t exist yet</div><br/><div id="42104912" class="c"><input type="checkbox" id="c-42104912" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42102283">root</a><span>|</span><a href="#42103869">parent</a><span>|</span><a href="#42104571">next</a><span>|</span><label class="collapse" for="c-42104912">[-]</label><label class="expand" for="c-42104912">[1 more]</label></div><br/><div class="children"><div class="content">s&#x2F;yet&#x2F;thankfully&#x2F;. We don’t need it cause it solves no real problem and the solution is loaded with implicit complexity.</div><br/></div></div></div></div></div></div><div id="42104571" class="c"><input type="checkbox" id="c-42104571" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42102283">parent</a><span>|</span><a href="#42102537">prev</a><span>|</span><a href="#42103439">next</a><span>|</span><label class="collapse" for="c-42104571">[-]</label><label class="expand" for="c-42104571">[1 more]</label></div><br/><div class="children"><div class="content">If it only weren’t for that crippled &quot;using&quot; syntax. On the other hand, though:<p><pre><code>    const denialOfService = res =&gt; void navigator.lock(res);
</code></pre>
I mean, one might write this just as well with the callback interface, but this is much easier to do accidentally.</div><br/></div></div></div></div><div id="42103439" class="c"><input type="checkbox" id="c-42103439" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#42102283">prev</a><span>|</span><a href="#42104213">next</a><span>|</span><label class="collapse" for="c-42103439">[-]</label><label class="expand" for="c-42103439">[11 more]</label></div><br/><div class="children"><div class="content">I wish the compatibility tables on MDN gave an indicator of <i>when</i> a feature became available.<p>My ideal would be a thing that says &quot;this hit 90% of deployed browsers 4 years ago&quot;, but just seeing the date it was added to each of the significant browser families would be amazingly useful.</div><br/><div id="42103591" class="c"><input type="checkbox" id="c-42103591" checked=""/><div class="controls bullet"><span class="by">spartanatreyu</span><span>|</span><a href="#42103439">parent</a><span>|</span><a href="#42103522">next</a><span>|</span><label class="collapse" for="c-42103591">[-]</label><label class="expand" for="c-42103591">[7 more]</label></div><br/><div class="children"><div class="content">It does.<p>Using the Web Locks API page as an example, let&#x27;s say we want to know when `LockManager` was added to Chrome. Here are the steps:<p>1. View the page: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Locks_API" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Web_Locks_A...</a>
2. Scroll down to the Browser compatibility table
3. Find the cell you&#x27;re interested in, in this example we&#x27;re looking at where the `LockManager` row meets the Chrome column.
4. We see a check and a version number (in this case 69).<p>So at this point we know that it has existed since version 69.<p>Now in the case that we don&#x27;t know that Chrome&#x27;s current version is already &lt; 100 and we need to know when a feature gained support:<p>5. Click on the cell to view the timeline of that cell.<p>Now we know that it was released on 2018-09-04, and it never had a smaller release requiring browser flags&#x2F;prefixes&#x2F;experiment flags&#x2F;etc...</div><br/><div id="42103868" class="c"><input type="checkbox" id="c-42103868" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#42103439">root</a><span>|</span><a href="#42103591">parent</a><span>|</span><a href="#42103522">next</a><span>|</span><label class="collapse" for="c-42103868">[-]</label><label class="expand" for="c-42103868">[6 more]</label></div><br/><div class="children"><div class="content">I honestly never thought to click on those! Thanks very much.<p>Now I&#x27;m digging around in <a href="https:&#x2F;&#x2F;github.com&#x2F;mdn&#x2F;browser-compat-data&#x2F;blob&#x2F;main&#x2F;api&#x2F;LockManager.json">https:&#x2F;&#x2F;github.com&#x2F;mdn&#x2F;browser-compat-data&#x2F;blob&#x2F;main&#x2F;api&#x2F;Loc...</a> and trying to find the browser release dates data...<p>Ooh, <a href="https:&#x2F;&#x2F;bcd.developer.mozilla.org&#x2F;bcd&#x2F;api&#x2F;v0&#x2F;current&#x2F;api.Lock.json" rel="nofollow">https:&#x2F;&#x2F;bcd.developer.mozilla.org&#x2F;bcd&#x2F;api&#x2F;v0&#x2F;current&#x2F;api.Loc...</a> is even better - it expands those browser dates and it&#x27;s served with access-control-allow-origin: *</div><br/><div id="42104014" class="c"><input type="checkbox" id="c-42104014" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#42103439">root</a><span>|</span><a href="#42103868">parent</a><span>|</span><a href="#42103522">next</a><span>|</span><label class="collapse" for="c-42104014">[-]</label><label class="expand" for="c-42104014">[5 more]</label></div><br/><div class="children"><div class="content">I used that to build this tool: <a href="https:&#x2F;&#x2F;tools.simonwillison.net&#x2F;mdn-timelines#Lock" rel="nofollow">https:&#x2F;&#x2F;tools.simonwillison.net&#x2F;mdn-timelines#Lock</a><p>It lets you search for an API and then displays a timeline. Details on how I built it here: <a href="https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;tools&#x2F;commit&#x2F;59323c6a30271c856aabb7456ae24f071f35d8ac#commitcomment-148934796">https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;tools&#x2F;commit&#x2F;59323c6a30271c856aabb...</a> and <a href="https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;tools&#x2F;commit&#x2F;472b46fda02e912c436041fda75fc2a6565462b4">https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;tools&#x2F;commit&#x2F;472b46fda02e912c43604...</a></div><br/><div id="42104387" class="c"><input type="checkbox" id="c-42104387" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#42103439">root</a><span>|</span><a href="#42104014">parent</a><span>|</span><a href="#42105085">next</a><span>|</span><label class="collapse" for="c-42104387">[-]</label><label class="expand" for="c-42104387">[3 more]</label></div><br/><div class="children"><div class="content">Blogged about it here: <a href="https:&#x2F;&#x2F;simonwillison.net&#x2F;2024&#x2F;Nov&#x2F;11&#x2F;mdn-browser-support-timelines&#x2F;" rel="nofollow">https:&#x2F;&#x2F;simonwillison.net&#x2F;2024&#x2F;Nov&#x2F;11&#x2F;mdn-browser-support-ti...</a></div><br/><div id="42104492" class="c"><input type="checkbox" id="c-42104492" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#42103439">root</a><span>|</span><a href="#42104387">parent</a><span>|</span><a href="#42105085">next</a><span>|</span><label class="collapse" for="c-42104492">[-]</label><label class="expand" for="c-42104492">[2 more]</label></div><br/><div class="children"><div class="content">thank you for posting transcripts!</div><br/><div id="42104536" class="c"><input type="checkbox" id="c-42104536" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#42103439">root</a><span>|</span><a href="#42104492">parent</a><span>|</span><a href="#42105085">next</a><span>|</span><label class="collapse" for="c-42104536">[-]</label><label class="expand" for="c-42104536">[1 more]</label></div><br/><div class="children"><div class="content">I do that a lot: most of the commits in that tools repo (which doubles as my &quot;playing around with LLM generated code&quot; repo) include links to the relevant conversations: <a href="https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;tools&#x2F;commits&#x2F;main&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;tools&#x2F;commits&#x2F;main&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42105085" class="c"><input type="checkbox" id="c-42105085" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42103439">root</a><span>|</span><a href="#42104014">parent</a><span>|</span><a href="#42104387">prev</a><span>|</span><a href="#42103522">next</a><span>|</span><label class="collapse" for="c-42105085">[-]</label><label class="expand" for="c-42105085">[1 more]</label></div><br/><div class="children"><div class="content">See also <a href="https:&#x2F;&#x2F;caniuse.com&#x2F;mdn-api_lock" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;mdn-api_lock</a>, “Date relative” view is mostly better.</div><br/></div></div></div></div></div></div></div></div><div id="42103522" class="c"><input type="checkbox" id="c-42103522" checked=""/><div class="controls bullet"><span class="by">MayorMonty</span><span>|</span><a href="#42103439">parent</a><span>|</span><a href="#42103591">prev</a><span>|</span><a href="#42103555">next</a><span>|</span><label class="collapse" for="c-42103522">[-]</label><label class="expand" for="c-42103522">[1 more]</label></div><br/><div class="children"><div class="content">I think this is the idea behind the Baseline &lt;Year&gt; standard you see on a lot of mdn features now, it shows the year when the feature was available in all 3 major browser engines</div><br/></div></div><div id="42103555" class="c"><input type="checkbox" id="c-42103555" checked=""/><div class="controls bullet"><span class="by">pcl</span><span>|</span><a href="#42103439">parent</a><span>|</span><a href="#42103522">prev</a><span>|</span><a href="#42104117">next</a><span>|</span><label class="collapse" for="c-42103555">[-]</label><label class="expand" for="c-42103555">[1 more]</label></div><br/><div class="children"><div class="content">You can get this from caniuse, right? Would be a simple enough browser extension to marry the two together.<p><a href="https:&#x2F;&#x2F;caniuse.com&#x2F;mdn-api_lock" rel="nofollow">https:&#x2F;&#x2F;caniuse.com&#x2F;mdn-api_lock</a></div><br/></div></div><div id="42104117" class="c"><input type="checkbox" id="c-42104117" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42103439">parent</a><span>|</span><a href="#42103555">prev</a><span>|</span><a href="#42104213">next</a><span>|</span><label class="collapse" for="c-42104117">[-]</label><label class="expand" for="c-42104117">[1 more]</label></div><br/><div class="children"><div class="content">caniuse.com</div><br/></div></div></div></div><div id="42104213" class="c"><input type="checkbox" id="c-42104213" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42103439">prev</a><span>|</span><a href="#42105272">next</a><span>|</span><label class="collapse" for="c-42104213">[-]</label><label class="expand" for="c-42104213">[4 more]</label></div><br/><div class="children"><div class="content">Why only in secure contexts? You can use storage APIs in insecure contexts, doing this by spinning, but the lock API which seems much more innocuous requires a secure context?</div><br/><div id="42105155" class="c"><input type="checkbox" id="c-42105155" checked=""/><div class="controls bullet"><span class="by">chrismorgan</span><span>|</span><a href="#42104213">parent</a><span>|</span><a href="#42104471">next</a><span>|</span><label class="collapse" for="c-42105155">[-]</label><label class="expand" for="c-42105155">[1 more]</label></div><br/><div class="children"><div class="content">I believe most new capabilities are limited to secure contexts, in part as a way of discouraging bad habits, even when there’s no particular risk. The ideal is that everything should run in a secure context, but it’s a hard sell removing existing functionality from insecure contexts. If it were being added now, I’m pretty sure storage APIs <i>would</i> be secure-only.<p>Search around and you’ll find various information and explanations about it. <a href="https:&#x2F;&#x2F;blog.mozilla.org&#x2F;security&#x2F;2018&#x2F;01&#x2F;15&#x2F;secure-contexts-everywhere&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.mozilla.org&#x2F;security&#x2F;2018&#x2F;01&#x2F;15&#x2F;secure-contexts...</a> is one, though <a href="https:&#x2F;&#x2F;w3ctag.github.io&#x2F;design-principles&#x2F;#secure-context" rel="nofollow">https:&#x2F;&#x2F;w3ctag.github.io&#x2F;design-principles&#x2F;#secure-context</a> has apparently been significantly watered down from what it was originally—see the initial proposal in <a href="https:&#x2F;&#x2F;github.com&#x2F;w3ctag&#x2F;design-principles&#x2F;pull&#x2F;75">https:&#x2F;&#x2F;github.com&#x2F;w3ctag&#x2F;design-principles&#x2F;pull&#x2F;75</a>, and what was then merged in <a href="https:&#x2F;&#x2F;github.com&#x2F;w3ctag&#x2F;design-principles&#x2F;pull&#x2F;89">https:&#x2F;&#x2F;github.com&#x2F;w3ctag&#x2F;design-principles&#x2F;pull&#x2F;89</a>.</div><br/></div></div><div id="42104471" class="c"><input type="checkbox" id="c-42104471" checked=""/><div class="controls bullet"><span class="by">endgame</span><span>|</span><a href="#42104213">parent</a><span>|</span><a href="#42105155">prev</a><span>|</span><a href="#42105272">next</a><span>|</span><label class="collapse" for="c-42104471">[-]</label><label class="expand" for="c-42104471">[2 more]</label></div><br/><div class="children"><div class="content">If certain lock names become well-known, maybe you could DoS browsers by holding random locks and never releasing them?</div><br/><div id="42104594" class="c"><input type="checkbox" id="c-42104594" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#42104213">root</a><span>|</span><a href="#42104471">parent</a><span>|</span><a href="#42105272">next</a><span>|</span><label class="collapse" for="c-42104594">[-]</label><label class="expand" for="c-42104594">[1 more]</label></div><br/><div class="children"><div class="content">I guess but since they&#x27;re origin-bound can you do anything except DoS your page?</div><br/></div></div></div></div></div></div><div id="42105272" class="c"><input type="checkbox" id="c-42105272" checked=""/><div class="controls bullet"><span class="by">cammil</span><span>|</span><a href="#42104213">prev</a><span>|</span><a href="#42102257">next</a><span>|</span><label class="collapse" for="c-42105272">[-]</label><label class="expand" for="c-42105272">[1 more]</label></div><br/><div class="children"><div class="content">I assume this is at the browser &quot;session&quot; level? In another browser, or private-session, would the locks be distinct?</div><br/></div></div><div id="42102257" class="c"><input type="checkbox" id="c-42102257" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#42105272">prev</a><span>|</span><a href="#42102116">next</a><span>|</span><label class="collapse" for="c-42102257">[-]</label><label class="expand" for="c-42102257">[6 more]</label></div><br/><div class="children"><div class="content">How does a shared memory space work if you have different versions of scripts for the same domain?</div><br/><div id="42103777" class="c"><input type="checkbox" id="c-42103777" checked=""/><div class="controls bullet"><span class="by">horsawlarway</span><span>|</span><a href="#42102257">parent</a><span>|</span><a href="#42103783">next</a><span>|</span><label class="collapse" for="c-42103777">[-]</label><label class="expand" for="c-42103777">[1 more]</label></div><br/><div class="children"><div class="content">Same way a shared database works across multiple client versions as you roll out a new deployment.<p>Or the same way two completely different processes can access the same address space with shared memory IPC.<p>You aren&#x27;t running in the same memory space, you&#x27;re just communicating with a shared resource.</div><br/></div></div><div id="42103783" class="c"><input type="checkbox" id="c-42103783" checked=""/><div class="controls bullet"><span class="by">owaislone</span><span>|</span><a href="#42102257">parent</a><span>|</span><a href="#42103777">prev</a><span>|</span><a href="#42102116">next</a><span>|</span><label class="collapse" for="c-42103783">[-]</label><label class="expand" for="c-42103783">[4 more]</label></div><br/><div class="children"><div class="content">Why would that matter? The tabs don&#x27;t share memory. Any code doesn&#x27;t run when it tries to acquire a lot that another piece of code from another tab has already acquired. The two tabs don&#x27;t even need to run the same app.</div><br/><div id="42105335" class="c"><input type="checkbox" id="c-42105335" checked=""/><div class="controls bullet"><span class="by">nitwit005</span><span>|</span><a href="#42102257">root</a><span>|</span><a href="#42103783">parent</a><span>|</span><a href="#42104601">next</a><span>|</span><label class="collapse" for="c-42105335">[-]</label><label class="expand" for="c-42105335">[1 more]</label></div><br/><div class="children"><div class="content">The need to test both versions being active.</div><br/></div></div><div id="42104601" class="c"><input type="checkbox" id="c-42104601" checked=""/><div class="controls bullet"><span class="by">mmazing</span><span>|</span><a href="#42102257">root</a><span>|</span><a href="#42103783">parent</a><span>|</span><a href="#42105335">prev</a><span>|</span><a href="#42102116">next</a><span>|</span><label class="collapse" for="c-42104601">[-]</label><label class="expand" for="c-42104601">[2 more]</label></div><br/><div class="children"><div class="content">Well, it might matter for functionality in the application.<p>After you fix a lock-related bug for example, how do you deal with an open tab running a different version of your code that is erroneously misusing a lock?<p>You need to account for that when you release new code, yeah? Rename the lock maybe? Some other logic?</div><br/><div id="42104967" class="c"><input type="checkbox" id="c-42104967" checked=""/><div class="controls bullet"><span class="by">geocar</span><span>|</span><a href="#42102257">root</a><span>|</span><a href="#42104601">parent</a><span>|</span><a href="#42102116">next</a><span>|</span><label class="collapse" for="c-42104967">[-]</label><label class="expand" for="c-42104967">[1 more]</label></div><br/><div class="children"><div class="content">What are you imagining doing with these web locks apis?</div><br/></div></div></div></div></div></div></div></div><div id="42102116" class="c"><input type="checkbox" id="c-42102116" checked=""/><div class="controls bullet"><span class="by">aabhay</span><span>|</span><a href="#42102257">prev</a><span>|</span><a href="#42102123">next</a><span>|</span><label class="collapse" for="c-42102116">[-]</label><label class="expand" for="c-42102116">[4 more]</label></div><br/><div class="children"><div class="content">I’ve been using this for a while now. But one thing I recently worked on required these locks to be extremely efficient. Does anyone have any benchmarks on usage of these locks? Preferably compared to the use of rust’s tokio mutex from a wasm context.</div><br/><div id="42103802" class="c"><input type="checkbox" id="c-42103802" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#42102116">parent</a><span>|</span><a href="#42102692">next</a><span>|</span><label class="collapse" for="c-42103802">[-]</label><label class="expand" for="c-42103802">[1 more]</label></div><br/><div class="children"><div class="content">You should write your own benchmarks! I&#x27;ve been using mitata for microbenchmarks which is what the bun and deno people use for their cool benchmark charts. It&#x27;s fast and tries to call the system GC between runs which helps reduce bias. github: <a href="https:&#x2F;&#x2F;github.com&#x2F;evanwashere&#x2F;mitata">https:&#x2F;&#x2F;github.com&#x2F;evanwashere&#x2F;mitata</a><p>I find iterating in mitata super fun and a little addictive. It&#x27;s hard to write a representative micro-benchmark, but optimizing them is still useful as long as you aren&#x27;t making anything worse, which is often easy to avoid. I recently used mitata-benchmark-guided optimization to rewrite a core data structure at Notion for a 5% latency decrease on a few endpoints at p90&#x2F;95&#x2F;99. One of our returning interns used it to assess serialization libraries and she found one 3x faster. a+++ would recommend</div><br/></div></div><div id="42102692" class="c"><input type="checkbox" id="c-42102692" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42102116">parent</a><span>|</span><a href="#42103802">prev</a><span>|</span><a href="#42102123">next</a><span>|</span><label class="collapse" for="c-42102692">[-]</label><label class="expand" for="c-42102692">[2 more]</label></div><br/><div class="children"><div class="content">If you’ve been using them for a while, don’t you have any benchmarks?</div><br/><div id="42103805" class="c"><input type="checkbox" id="c-42103805" checked=""/><div class="controls bullet"><span class="by">afavour</span><span>|</span><a href="#42102116">root</a><span>|</span><a href="#42102692">parent</a><span>|</span><a href="#42102123">next</a><span>|</span><label class="collapse" for="c-42103805">[-]</label><label class="expand" for="c-42103805">[1 more]</label></div><br/><div class="children"><div class="content">Don’t see why you’d assume that. Not all applications are time critical.</div><br/></div></div></div></div></div></div><div id="42102123" class="c"><input type="checkbox" id="c-42102123" checked=""/><div class="controls bullet"><span class="by">tantalor</span><span>|</span><a href="#42102116">prev</a><span>|</span><a href="#42102519">next</a><span>|</span><label class="collapse" for="c-42102123">[-]</label><label class="expand" for="c-42102123">[12 more]</label></div><br/><div class="children"><div class="content">Weird API to release the lock. What if you want to hold on to it? Then you need to do some silly promise wrapper. Would be better if there was a matching release() function.</div><br/><div id="42104934" class="c"><input type="checkbox" id="c-42104934" checked=""/><div class="controls bullet"><span class="by">wruza</span><span>|</span><a href="#42102123">parent</a><span>|</span><a href="#42102185">next</a><span>|</span><label class="collapse" for="c-42104934">[-]</label><label class="expand" for="c-42104934">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  p = Promise.withResolvers()
  navigator.locks.request(
    &quot;foo&quot;,
    p.promise,
  )
  p.resolve()
</code></pre>
I guess there’s room for .requestWithResolvers() still, they rarely learn the first lesson. Even the $subj article seems to be unaware of it and uses the silly wrapper way.</div><br/></div></div><div id="42102185" class="c"><input type="checkbox" id="c-42102185" checked=""/><div class="controls bullet"><span class="by">rockwotj</span><span>|</span><a href="#42102123">parent</a><span>|</span><a href="#42104934">prev</a><span>|</span><a href="#42102564">next</a><span>|</span><label class="collapse" for="c-42102185">[-]</label><label class="expand" for="c-42102185">[5 more]</label></div><br/><div class="children"><div class="content">Probably because there is no RAII semantics in JS and they don’t want to allow forgetting releasing the lock. Although the promise workaround is explicitly opting into this behavior</div><br/><div id="42102228" class="c"><input type="checkbox" id="c-42102228" checked=""/><div class="controls bullet"><span class="by">slimsag</span><span>|</span><a href="#42102123">root</a><span>|</span><a href="#42102185">parent</a><span>|</span><a href="#42102564">next</a><span>|</span><label class="collapse" for="c-42102228">[-]</label><label class="expand" for="c-42102228">[4 more]</label></div><br/><div class="children"><div class="content">Javascript in browsers already has a full atomics API:<p><a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Atomics" rel="nofollow">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Refe...</a><p>I&#x27;m not sure why Web Locks is useful TBH. I guess if you don&#x27;t understand atomics it&#x27;s a friendlier API?</div><br/><div id="42105350" class="c"><input type="checkbox" id="c-42105350" checked=""/><div class="controls bullet"><span class="by">mrkeen</span><span>|</span><a href="#42102123">root</a><span>|</span><a href="#42102228">parent</a><span>|</span><a href="#42102407">next</a><span>|</span><label class="collapse" for="c-42105350">[-]</label><label class="expand" for="c-42105350">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s &quot;atomic&quot; in the sense that it does <i>one</i> thing.  It lets you do &quot;actions&quot;, not &quot;transactions&quot;.  A transaction would allow you to do <i>multiple</i> things.<p>If the atomics API gave you ability to do multiple things, you wouldn&#x27;t need <i>compareExchange</i>, because you could just do <i>compare</i> and then <i>exchange</i>.</div><br/></div></div><div id="42102407" class="c"><input type="checkbox" id="c-42102407" checked=""/><div class="controls bullet"><span class="by">pavlov</span><span>|</span><a href="#42102123">root</a><span>|</span><a href="#42102228">parent</a><span>|</span><a href="#42105350">prev</a><span>|</span><a href="#42102394">next</a><span>|</span><label class="collapse" for="c-42102407">[-]</label><label class="expand" for="c-42102407">[1 more]</label></div><br/><div class="children"><div class="content">The Web Locks documentation explains that it works across tabs, i.e. separate processes:<p><i>”[…] allows a web app running in multiple tabs or workers to coordinate work and the use of resources”</i><p>A locking API is much more natural and less error-prone for this use case than using shared memory and atomics.</div><br/></div></div><div id="42102394" class="c"><input type="checkbox" id="c-42102394" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42102123">root</a><span>|</span><a href="#42102228">parent</a><span>|</span><a href="#42102407">prev</a><span>|</span><a href="#42102564">next</a><span>|</span><label class="collapse" for="c-42102394">[-]</label><label class="expand" for="c-42102394">[1 more]</label></div><br/><div class="children"><div class="content">You mean Atomics + SharedArrayBuffer, otherwise it won&#x27;t be shared across agents. I can imagine all the <i>postMessage</i> calls and <i>message</i> handlers swirling around in all agents to approximate something like the Web Locks API for a simple lock, but tbh I&#x27;d take the Web Locks API any day.</div><br/></div></div></div></div></div></div><div id="42102564" class="c"><input type="checkbox" id="c-42102564" checked=""/><div class="controls bullet"><span class="by">maxmcd</span><span>|</span><a href="#42102123">parent</a><span>|</span><a href="#42102185">prev</a><span>|</span><a href="#42102226">next</a><span>|</span><label class="collapse" for="c-42102564">[-]</label><label class="expand" for="c-42102564">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  class Lock {
    #release: () =&gt; void | undefined;
    constructor(public name: string) {}
    acquire() {
      if (this.#release !== undefined) throw new Error(&quot;Already locked&quot;);
      navigator.locks.request(this.name, async (lock) =&gt; {
        await new Promise&lt;void&gt;(resolve =&gt; {
          this.#release = resolve;
        });
      });
    }
    release() {
      if (this.#release === undefined) throw new Error(&quot;Not locked&quot;);
      this.#release();
    }
  }</code></pre></div><br/><div id="42102795" class="c"><input type="checkbox" id="c-42102795" checked=""/><div class="controls bullet"><span class="by">whilenot-dev</span><span>|</span><a href="#42102123">root</a><span>|</span><a href="#42102564">parent</a><span>|</span><a href="#42102226">next</a><span>|</span><label class="collapse" for="c-42102795">[-]</label><label class="expand" for="c-42102795">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not treating the aquire phase correctly:<p><pre><code>  class Lock {
    #resolve: (() =&gt; void) | undefined;
    #releasePromise: Promise&lt;void&gt; | undefined;

    constructor(public name: string) {}

    acquire(): Promise&lt;void&gt; {
      if (this.#releasePromise !== undefined) {
        throw new Error(&quot;Already aquired&quot;);
      }

      return new Promise((resolveAquire, _rejectAquire) =&gt; {
        this.#releasePromise = new Promise((resolveRelease, _rejectRelease) =&gt; {
          navigator.locks.request(this.name, async (lock) =&gt; {
            await new Promise&lt;void&gt;((resolve, _reject) =&gt; {
              this.#resolve = resolve;
              resolveAquire();
            });

            resolveRelease();
          });
        });
      });
    }
    
    async release(): Promise&lt;void&gt; {
      if (this.#releasePromise === undefined) {
        throw new Error(&quot;Already released&quot;);
      }

      this.#resolve();
      await this.#releasePromise;

      this.#resolve = undefined;
      this.#releasePromise = undefined;
    }
  }
</code></pre>
...the release phase still feels off without a Promise, but maybe somebody else can tackle that :D<p>EDIT: think I fixed it, untested though</div><br/><div id="42104439" class="c"><input type="checkbox" id="c-42104439" checked=""/><div class="controls bullet"><span class="by">maxmcd</span><span>|</span><a href="#42102123">root</a><span>|</span><a href="#42102795">parent</a><span>|</span><a href="#42103090">next</a><span>|</span><label class="collapse" for="c-42104439">[-]</label><label class="expand" for="c-42104439">[1 more]</label></div><br/><div class="children"><div class="content">ah! nice</div><br/></div></div></div></div></div></div><div id="42102226" class="c"><input type="checkbox" id="c-42102226" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#42102123">parent</a><span>|</span><a href="#42102564">prev</a><span>|</span><a href="#42102519">next</a><span>|</span><label class="collapse" for="c-42102226">[-]</label><label class="expand" for="c-42102226">[1 more]</label></div><br/><div class="children"><div class="content">The ergonomics here for 99.999% of uses seem great to me. Whatever async function you have can run for as long as it needs. That&#x27;s using the language, not adding more userland craft. It&#x27;s a good move.</div><br/></div></div></div></div><div id="42102519" class="c"><input type="checkbox" id="c-42102519" checked=""/><div class="controls bullet"><span class="by">gabrieledarrigo</span><span>|</span><a href="#42102123">prev</a><span>|</span><a href="#42103319">next</a><span>|</span><label class="collapse" for="c-42102519">[-]</label><label class="expand" for="c-42102519">[9 more]</label></div><br/><div class="children"><div class="content">Ciao guys,
what could be the use case for such API?</div><br/><div id="42102871" class="c"><input type="checkbox" id="c-42102871" checked=""/><div class="controls bullet"><span class="by">mooreds</span><span>|</span><a href="#42102519">parent</a><span>|</span><a href="#42102586">next</a><span>|</span><label class="collapse" for="c-42102871">[-]</label><label class="expand" for="c-42102871">[3 more]</label></div><br/><div class="children"><div class="content">This was the use case[0] that brought it to my attention:<p>- single page application using access and refresh tokens to interact with an API<p>- refresh is one time use, as recommended by the OAuth security best practices[1]<p>- SPA is open in more than one tab<p>- two tabs try to refresh the token at the same time, second one fails because refresh token is used up<p>0: <a href="https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;ambarvm.bsky.social&#x2F;post&#x2F;3lakznzipts22" rel="nofollow">https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;ambarvm.bsky.social&#x2F;post&#x2F;3lakznzipt...</a><p>1: <a href="https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-ietf-oauth-security-topics-29#name-recommendations" rel="nofollow">https:&#x2F;&#x2F;datatracker.ietf.org&#x2F;doc&#x2F;html&#x2F;draft-ietf-oauth-secur...</a></div><br/><div id="42105251" class="c"><input type="checkbox" id="c-42105251" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#42102519">root</a><span>|</span><a href="#42102871">parent</a><span>|</span><a href="#42103580">next</a><span>|</span><label class="collapse" for="c-42105251">[-]</label><label class="expand" for="c-42105251">[1 more]</label></div><br/><div class="children"><div class="content">I guess I don&#x27;t actually get the point, because if I am locking a resource in one tab so that other tabs can&#x27;t use that resource... how is that not going to lead to behavior that a user would think was broken.<p>Two tabs try to refresh the token at the same time, user opened tab 2, tab 2 can&#x27;t refresh because things locked in tab 1 - user thinks app is broken? Isn&#x27;t that the way it would happen. I guess you can detect it is locked in another tab though so you could give the user a warning about this?<p>I guess I am missing something about the scenario..</div><br/></div></div><div id="42103580" class="c"><input type="checkbox" id="c-42103580" checked=""/><div class="controls bullet"><span class="by">taosx</span><span>|</span><a href="#42102519">root</a><span>|</span><a href="#42102871">parent</a><span>|</span><a href="#42105251">prev</a><span>|</span><a href="#42102586">next</a><span>|</span><label class="collapse" for="c-42103580">[-]</label><label class="expand" for="c-42103580">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for this, I&#x27;ve been using the localstorage for the same use case a while ago, I&#x27;ll try to go back and update it.</div><br/></div></div></div></div><div id="42102586" class="c"><input type="checkbox" id="c-42102586" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#42102519">parent</a><span>|</span><a href="#42102871">prev</a><span>|</span><a href="#42102981">next</a><span>|</span><label class="collapse" for="c-42102586">[-]</label><label class="expand" for="c-42102586">[1 more]</label></div><br/><div class="children"><div class="content">if a crypto miner infects a site you have several tabs open they won&#x27;t fight for cpu at the same time.</div><br/></div></div><div id="42102981" class="c"><input type="checkbox" id="c-42102981" checked=""/><div class="controls bullet"><span class="by">loevborg</span><span>|</span><a href="#42102519">parent</a><span>|</span><a href="#42102586">prev</a><span>|</span><a href="#42103364">next</a><span>|</span><label class="collapse" for="c-42102981">[-]</label><label class="expand" for="c-42102981">[2 more]</label></div><br/><div class="children"><div class="content">Besides what sibling has written, write access to IndexedDB also often needs to be guarded by a mutex <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;pesterhazy&#x2F;4de96193af89a6dd5ce682ce2adff49a#no-locking-primitives-safari-firefox" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;pesterhazy&#x2F;4de96193af89a6dd5ce682ce2...</a></div><br/><div id="42104510" class="c"><input type="checkbox" id="c-42104510" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42102519">root</a><span>|</span><a href="#42102981">parent</a><span>|</span><a href="#42103364">next</a><span>|</span><label class="collapse" for="c-42104510">[-]</label><label class="expand" for="c-42104510">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get this complaint, because IndexedDB supports transactions. Why are these insufficient?</div><br/></div></div></div></div><div id="42103364" class="c"><input type="checkbox" id="c-42103364" checked=""/><div class="controls bullet"><span class="by">nchmy</span><span>|</span><a href="#42102519">parent</a><span>|</span><a href="#42102981">prev</a><span>|</span><a href="#42102550">next</a><span>|</span><label class="collapse" for="c-42103364">[-]</label><label class="expand" for="c-42103364">[1 more]</label></div><br/><div class="children"><div class="content">share a websocket&#x2F;sse connection via a worker</div><br/></div></div><div id="42102550" class="c"><input type="checkbox" id="c-42102550" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#42102519">parent</a><span>|</span><a href="#42103364">prev</a><span>|</span><a href="#42103319">next</a><span>|</span><label class="collapse" for="c-42102550">[-]</label><label class="expand" for="c-42102550">[1 more]</label></div><br/><div class="children"><div class="content">Click the link, read the words. There&#x27;s a list in it.</div><br/></div></div></div></div><div id="42103319" class="c"><input type="checkbox" id="c-42103319" checked=""/><div class="controls bullet"><span class="by">eyeris</span><span>|</span><a href="#42102519">prev</a><span>|</span><a href="#42102245">next</a><span>|</span><label class="collapse" for="c-42103319">[-]</label><label class="expand" for="c-42103319">[2 more]</label></div><br/><div class="children"><div class="content">Where did the steal method come from? Haven’t done much locking, but I haven’t ever seen lock stealing before</div><br/><div id="42104907" class="c"><input type="checkbox" id="c-42104907" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42103319">parent</a><span>|</span><a href="#42102245">next</a><span>|</span><label class="collapse" for="c-42104907">[-]</label><label class="expand" for="c-42104907">[1 more]</label></div><br/><div class="children"><div class="content">&quot;steal&quot; referres to &quot;acquire unsafely&quot;<p>Never seen it before for locks, but I guess it&#x27;s to deal with some bugs caused from some other code running from that origin.</div><br/></div></div></div></div><div id="42102245" class="c"><input type="checkbox" id="c-42102245" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#42103319">prev</a><span>|</span><a href="#42102825">next</a><span>|</span><label class="collapse" for="c-42102245">[-]</label><label class="expand" for="c-42102245">[1 more]</label></div><br/><div class="children"><div class="content">Not that it&#x27;s super important, but Web Locks API is getting some circulation after a question about how you keep multiple pages from trying to use a (single-use only) oauth refresh token at the same time. Which is a pretty good use case for this feature! <a href="https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;ambarvm.bsky.social&#x2F;post&#x2F;3lakznzipts22" rel="nofollow">https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;ambarvm.bsky.social&#x2F;post&#x2F;3lakznzipt...</a></div><br/></div></div><div id="42102825" class="c"><input type="checkbox" id="c-42102825" checked=""/><div class="controls bullet"><span class="by">rdsubhas</span><span>|</span><a href="#42102245">prev</a><span>|</span><a href="#42104946">next</a><span>|</span><label class="collapse" for="c-42102825">[-]</label><label class="expand" for="c-42102825">[6 more]</label></div><br/><div class="children"><div class="content">A lease is usually a better choice than a lock.<p>A lease has a time limit. A lock does not. Clearing stale locks manually is a PITA. I still assume, being a Web-scale contract, the lock would be automatically cleared if the browser is restarted or something. But honestly a lease makes users do better design from the get-go.</div><br/><div id="42102940" class="c"><input type="checkbox" id="c-42102940" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#42102825">parent</a><span>|</span><a href="#42103693">next</a><span>|</span><label class="collapse" for="c-42102940">[-]</label><label class="expand" for="c-42102940">[1 more]</label></div><br/><div class="children"><div class="content">I might agree in other contexts, but not with the use case here and how the API is designed.<p>It looks like the only potential for a &quot;stale lock&quot; is if somehow the async function passed to the request method hangs forever. But in web contexts I think that would be extremely unlikely for everyday use cases (e.g. most of the time I could imagine the async callback making remote calls using fetch, but normally that fetch has its own timeout). In contexts where it <i>could</i> happen, I&#x27;d argue it&#x27;s better to make the caller explicitly handle that case (e.g. by using `steal`) than potentially leave things in an indeterminate state because a lease timeout expired.</div><br/></div></div><div id="42103693" class="c"><input type="checkbox" id="c-42103693" checked=""/><div class="controls bullet"><span class="by">sweetjuly</span><span>|</span><a href="#42102825">parent</a><span>|</span><a href="#42102940">prev</a><span>|</span><a href="#42102852">next</a><span>|</span><label class="collapse" for="c-42103693">[-]</label><label class="expand" for="c-42103693">[1 more]</label></div><br/><div class="children"><div class="content">There is no real safe way to use lock <i>hold</i> timeouts. While a waiter can timeout and possibly handle failing to acquire the lock, there&#x27;s no generic safe way to steal the lock from the holder after a timeout since the holder may still be accessing the protected resources&#x2F;have left the resources in an inconsistent state. Adding a wait timeout which generates telemetry on a long wait may be useful for helping catch failures in production, but seizing the lock is almost always the wrong way to go about this.</div><br/></div></div><div id="42102852" class="c"><input type="checkbox" id="c-42102852" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#42102825">parent</a><span>|</span><a href="#42103693">prev</a><span>|</span><a href="#42102847">next</a><span>|</span><label class="collapse" for="c-42102852">[-]</label><label class="expand" for="c-42102852">[2 more]</label></div><br/><div class="children"><div class="content">Time limits are a recipe for non-determinism. Non-determinism is generally not what you want.</div><br/><div id="42102980" class="c"><input type="checkbox" id="c-42102980" checked=""/><div class="controls bullet"><span class="by">soulofmischief</span><span>|</span><a href="#42102825">root</a><span>|</span><a href="#42102852">parent</a><span>|</span><a href="#42102847">next</a><span>|</span><label class="collapse" for="c-42102980">[-]</label><label class="expand" for="c-42102980">[1 more]</label></div><br/><div class="children"><div class="content">Put another way, combining side effects and timers invariably causes race conditions.</div><br/></div></div></div></div><div id="42102847" class="c"><input type="checkbox" id="c-42102847" checked=""/><div class="controls bullet"><span class="by">mooreds</span><span>|</span><a href="#42102825">parent</a><span>|</span><a href="#42102852">prev</a><span>|</span><a href="#42104946">next</a><span>|</span><label class="collapse" for="c-42102847">[-]</label><label class="expand" for="c-42102847">[1 more]</label></div><br/><div class="children"><div class="content">Is there a native browser API for leases?</div><br/></div></div></div></div><div id="42104946" class="c"><input type="checkbox" id="c-42104946" checked=""/><div class="controls bullet"><span class="by">anon291</span><span>|</span><a href="#42102825">prev</a><span>|</span><a href="#42103882">next</a><span>|</span><label class="collapse" for="c-42104946">[-]</label><label class="expand" for="c-42104946">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes I wonder why we even bothered with javascript and didn&#x27;t just use POSIX.</div><br/></div></div><div id="42103882" class="c"><input type="checkbox" id="c-42103882" checked=""/><div class="controls bullet"><span class="by">SigmundA</span><span>|</span><a href="#42104946">prev</a><span>|</span><a href="#42105062">next</a><span>|</span><label class="collapse" for="c-42103882">[-]</label><label class="expand" for="c-42103882">[1 more]</label></div><br/><div class="children"><div class="content">The only reason I know and have used this api is because it helps prevent the tab from going to sleep if you hold on to the lock: <a href="https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;discussions&#x2F;edgeinsiderannouncements&#x2F;sleeping-tabs-faq&#x2F;1705434" rel="nofollow">https:&#x2F;&#x2F;techcommunity.microsoft.com&#x2F;discussions&#x2F;edgeinsidera...</a></div><br/></div></div><div id="42105062" class="c"><input type="checkbox" id="c-42105062" checked=""/><div class="controls bullet"><span class="by">shashashasha___</span><span>|</span><a href="#42103882">prev</a><span>|</span><a href="#42102503">next</a><span>|</span><label class="collapse" for="c-42105062">[-]</label><label class="expand" for="c-42105062">[1 more]</label></div><br/><div class="children"><div class="content">a lock API in single threaded js vm.
is a var true&#x2F;false really too hard these days that we need an API?</div><br/></div></div><div id="42102503" class="c"><input type="checkbox" id="c-42102503" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42105062">prev</a><span>|</span><a href="#42102969">next</a><span>|</span><label class="collapse" for="c-42102503">[-]</label><label class="expand" for="c-42102503">[5 more]</label></div><br/><div class="children"><div class="content">Using global names for this seems like a bad idea.</div><br/><div id="42102575" class="c"><input type="checkbox" id="c-42102575" checked=""/><div class="controls bullet"><span class="by">sureIy</span><span>|</span><a href="#42102503">parent</a><span>|</span><a href="#42102643">next</a><span>|</span><label class="collapse" for="c-42102575">[-]</label><label class="expand" for="c-42102575">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the problem? The whole concept is that it&#x27;s locking a resource super-globally, not only in the current tab, but across tabs.</div><br/><div id="42102731" class="c"><input type="checkbox" id="c-42102731" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42102503">root</a><span>|</span><a href="#42102575">parent</a><span>|</span><a href="#42102643">next</a><span>|</span><label class="collapse" for="c-42102731">[-]</label><label class="expand" for="c-42102731">[1 more]</label></div><br/><div class="children"><div class="content">Ah I misread. The intro made it sound like this was for locking within a tab, but it&#x27;s within a  origin.</div><br/></div></div></div></div><div id="42102643" class="c"><input type="checkbox" id="c-42102643" checked=""/><div class="controls bullet"><span class="by">RedShift1</span><span>|</span><a href="#42102503">parent</a><span>|</span><a href="#42102575">prev</a><span>|</span><a href="#42102509">next</a><span>|</span><label class="collapse" for="c-42102643">[-]</label><label class="expand" for="c-42102643">[1 more]</label></div><br/><div class="children"><div class="content">How many layers of namespacing do you want in between? 1? 2? 10? Perhaps we should go the SNMP route and start with 1.3.6.1.4.1?</div><br/></div></div><div id="42102509" class="c"><input type="checkbox" id="c-42102509" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#42102503">parent</a><span>|</span><a href="#42102643">prev</a><span>|</span><a href="#42102969">next</a><span>|</span><label class="collapse" for="c-42102509">[-]</label><label class="expand" for="c-42102509">[1 more]</label></div><br/><div class="children"><div class="content">Using global for bad ideas is kind of par for the course for all things JavaScript.</div><br/></div></div></div></div><div id="42102969" class="c"><input type="checkbox" id="c-42102969" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42102503">prev</a><span>|</span><label class="collapse" for="c-42102969">[-]</label><label class="expand" for="c-42102969">[6 more]</label></div><br/><div class="children"><div class="content">Expect deadlocks in web applications now? I wouldn&#x27;t necessarily trust a JS programmer with a lock, sorry. They are hard enough in C++ or other languages that generally require a lot more discipline.</div><br/><div id="42103403" class="c"><input type="checkbox" id="c-42103403" checked=""/><div class="controls bullet"><span class="by">vendiddy</span><span>|</span><a href="#42102969">parent</a><span>|</span><a href="#42103074">next</a><span>|</span><label class="collapse" for="c-42103403">[-]</label><label class="expand" for="c-42103403">[1 more]</label></div><br/><div class="children"><div class="content">I wish they adopted more of an actor model to emulate concurrency.<p>Or at least made it easier. I think I introducing locks is a mistake for the browser.</div><br/></div></div><div id="42103074" class="c"><input type="checkbox" id="c-42103074" checked=""/><div class="controls bullet"><span class="by">ukuina</span><span>|</span><a href="#42102969">parent</a><span>|</span><a href="#42103403">prev</a><span>|</span><label class="collapse" for="c-42103074">[-]</label><label class="expand" for="c-42103074">[4 more]</label></div><br/><div class="children"><div class="content">&gt; deadlocks only affect the locks themselves and code depending on them; the browser, other tabs, and other script in the page is not affected.<p>Also, you don&#x27;t need to use this API to lock up your web app.</div><br/><div id="42103174" class="c"><input type="checkbox" id="c-42103174" checked=""/><div class="controls bullet"><span class="by">yazzku</span><span>|</span><a href="#42102969">root</a><span>|</span><a href="#42103074">parent</a><span>|</span><label class="collapse" for="c-42103174">[-]</label><label class="expand" for="c-42103174">[3 more]</label></div><br/><div class="children"><div class="content">I have a hard time picturing how an application can be considered anything other than completely broken once a couple threads&#x2F;workers have deadlocked, so I don&#x27;t know what any of that quote means. Yeah, I get that browsers isolate tabs and that the damage is contained.</div><br/><div id="42104516" class="c"><input type="checkbox" id="c-42104516" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#42102969">root</a><span>|</span><a href="#42103174">parent</a><span>|</span><label class="collapse" for="c-42104516">[-]</label><label class="expand" for="c-42104516">[2 more]</label></div><br/><div class="children"><div class="content">You seem to be expecting these locks to block a thread, but they do not. A &quot;deadlock&quot; with these locks is simply a chunk of heap space holding a bunch of promises that will never resolve, occupying a few slots in the global event loop&#x27;s select statement.</div><br/><div id="42104930" class="c"><input type="checkbox" id="c-42104930" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42102969">root</a><span>|</span><a href="#42104516">parent</a><span>|</span><label class="collapse" for="c-42104930">[-]</label><label class="expand" for="c-42104930">[1 more]</label></div><br/><div class="children"><div class="content">Well yes, but some part of code that supposed to run, never runs because of a deadlock.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>