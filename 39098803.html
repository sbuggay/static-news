<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1706000462890" as="style"/><link rel="stylesheet" href="styles.css?v=1706000462890"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://zverok.substack.com/p/the-end-of-useless-ruby-sugar-on">The end of &quot;Useless Ruby sugar&quot;: On intuitions and evolutions</a> <span class="domain">(<a href="https://zverok.substack.com">zverok.substack.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>20 comments</span></div><br/><div><div id="39100359" class="c"><input type="checkbox" id="c-39100359" checked=""/><div class="controls bullet"><span class="by">lolinder</span><span>|</span><a href="#39100553">next</a><span>|</span><label class="collapse" for="c-39100359">[-]</label><label class="expand" for="c-39100359">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The best things are still a reasonably small core of concepts, with the development team working hard to “factorize” any new feature into those concepts, and the flexible syntax that is instrumental for making the core small<p>Incidentally, this is actually the definition of syntactic sugar, from a language design point of view. People often use it derogatorily to refer to bits of syntax that they simply don&#x27;t like, but as a term of art it refers to syntactic elements that are introduced in an effort to provide new <i>ergonomics</i>—new ways of working in a language—without altering the language&#x27;s fundamental primitives. As the article notes, in theory this method of language extension should actually keep the language <i>simpler</i> than if these elements were introduced as new semantic constructs.<p>There are a few places where this goes wrong in practice.<p>The first is that you end up accumulating a lot <i>more</i> syntax than you would if each syntactic extension to the language required a new semantic basis. It&#x27;s easy to support syntactic sugar on a compiler or interpreter backend, so a language that is built on this small-core-with-sugar model doesn&#x27;t have any natural forces urging it towards simplicity. To an experienced developer who watched all the layers of abstraction accumulate this doesn&#x27;t pose much of a problem, but it&#x27;s not always obvious to a newcomer what all this syntax desugars into, so for them it may as well be a new semantic element!<p>The other major place where I&#x27;ve seen sugar go wrong is that it rarely gets extra tooling to support it. A brand new semantic element will naturally need to be supported at every level of the language&#x27;s stack, but the entire point of adding sugar is to avoid that extra work, so the language developers often just assume that the existing tooling will suffice. This leads to rough edges in things like stack traces and the debugger, because the code that actually gets executed only bears a loose resemblance to the code that the developer wrote.<p>It should be possible to avoid these pitfalls and have a tight language with a small basis and solid tooling, but it requires a <i>lot</i> more discipline.</div><br/><div id="39100367" class="c"><input type="checkbox" id="c-39100367" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#39100359">parent</a><span>|</span><a href="#39100553">next</a><span>|</span><label class="collapse" for="c-39100367">[-]</label><label class="expand" for="c-39100367">[3 more]</label></div><br/><div class="children"><div class="content">Well, if you&#x27;re using Ruby in the first place, you&#x27;re probably not the kind of person who cares very much about how much the tooling can help you, because even the best-in-class tools are primitive compared to what you get for other languages.</div><br/><div id="39100981" class="c"><input type="checkbox" id="c-39100981" checked=""/><div class="controls bullet"><span class="by">psychoslave</span><span>|</span><a href="#39100359">root</a><span>|</span><a href="#39100367">parent</a><span>|</span><a href="#39100982">next</a><span>|</span><label class="collapse" for="c-39100981">[-]</label><label class="expand" for="c-39100981">[1 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on this? Apart tools requiring static typing as a foundation, I am not sure what tools you are thinking of.</div><br/></div></div><div id="39100982" class="c"><input type="checkbox" id="c-39100982" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#39100359">root</a><span>|</span><a href="#39100367">parent</a><span>|</span><a href="#39100981">prev</a><span>|</span><a href="#39100553">next</a><span>|</span><label class="collapse" for="c-39100982">[-]</label><label class="expand" for="c-39100982">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, as a Ruby dev my experience differs vastly.<p>In a context where I&#x27;m working on a few languages regularly and among a larger set of languages that coworkers are in charge of, I can see how Ruby has solved a ton of problems that other languages are still struggling with.<p>- package management: bundler&#x2F;rubygems has been a sa-holved problem for the longest time whereas npm&#x2F;yarn is an unholy mess, python is only beginning to see the light after refusing for so long, go mod is kind of a step in the right direction but still falls short in others, cargo is an outright copy but tries too hard to also be rake, a distinct problem making it a kintchensink... Gemfiles being descriptive, one can generate  lockfiles from their platform including information for a foreign one and it&#x27;s going to resolve consistently, including corner cases like this gem has a transitive dependency on a ruby extension and this platform has a binary gem at that version but that platform can build from source at that other version so I&#x27;m going to pick the one that&#x27;s consistent and respects the constraints that have been described, or bail out and yell at you. This makes using semver-like squiggly a breeze and a non-event.<p>- build tools: scons, cmake, ninja, doit &amp; al. feel both incredibly complex and limited compared to rake. Every single time build files end up becoming obscure behemoths. When they don&#x27;t they&#x27;re incredibly focused on one thing but to make them to anything else they become a hodgepodge of additional external scripts and have to rely on so many tricks and hacks, which is why I used to stick to make. People seem to also have forgotten that rake can perfectly replace make as well, but rake can do so much more and still present a consistent interface and task implementation.<p>- testing: minitest&#x2F;test, minitest&#x2F;spec, spec are running circles around any other test framework. The composability of reusable contexts, nested cases, and shared examples allows one to cover a ton of behaviours with very little test code that is eminently descriptive. Just the other day I did a deep reflector of some part of the code, and I only had to change a bunch of helpers as to how things should operate, and the entirety of my functional test suite was literally a zero-line diff.<p>- talking to browsers: capybara is still my go-to to automate browsers, whether in tests or not, headless or not. It&#x27;s just way too easy.<p>- linting: Rubocop has a metric ton of tunable checks to enforce your preferred style and optionally auto fixes a lot of violations, standardrb takes a tab from gofmt by giving you some sane community defaults for Rubocop and thus autoformats by default. Rubocop is easily extensible, either you pull things and can lint rakefiles, Rails, spec and whatnot, or if you have special cases you can write your own cops.<p>- typing and LSP: forget Sorbet, RBS+Steep is the way. RBS can generate typed skeletons either statically or dynamically using typeprof; ideally if you have good coverage you could run tests using typeprof and have automatic typing generation that can then be used entirely statically. Then the `rbs` command then allows you to <i>statically</i> ask a ton of questions about types but it&#x27;s not a linter by itself, that&#x27;s where Steep comes in. Steep comes with a LSP and it Just Works: autocompletion, inline type information, and so on. Type signatures can be packaged within gems, but if they&#x27;re not there&#x27;s rbs_collection, which also integrates with bundler.<p>So I&#x27;m not too sure what you&#x27;re referring to as &quot;tooling&quot; that would be primitive when compared to other languages when in my mind it&#x27;s the other languages that constantly play catch-up ;)</div><br/></div></div></div></div></div></div><div id="39100553" class="c"><input type="checkbox" id="c-39100553" checked=""/><div class="controls bullet"><span class="by">asimpletune</span><span>|</span><a href="#39100359">prev</a><span>|</span><a href="#39100186">next</a><span>|</span><label class="collapse" for="c-39100553">[-]</label><label class="expand" for="c-39100553">[1 more]</label></div><br/><div class="children"><div class="content">I always thought of syntactic sugar being something sweet to make the medicine go down.<p>“Just a spoonful of (syntactic) sugar makes the…”</div><br/></div></div><div id="39100186" class="c"><input type="checkbox" id="c-39100186" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#39100553">prev</a><span>|</span><label class="collapse" for="c-39100186">[-]</label><label class="expand" for="c-39100186">[14 more]</label></div><br/><div class="children"><div class="content">&gt; textual requires and module system could’ve been much cleaner<p>This irritated me a lot when I was a ruby programmer. Ruby&#x27;s require is analogous to C&#x27;s #include: modules are just files that get evaluated in order to add stuff to a global interpreter state.<p>It got to the point I went around asking people on IRC what they thought the perfect module system looked like. Studied long forgotten languages to see how they did it. To this day I&#x27;m obsessed with this. I feel like it&#x27;s one of those things you just <i>have</i> to get right since day one because it&#x27;s gonna be impossible to change it later.</div><br/><div id="39100732" class="c"><input type="checkbox" id="c-39100732" checked=""/><div class="controls bullet"><span class="by">urxvtcd</span><span>|</span><a href="#39100186">parent</a><span>|</span><a href="#39100245">next</a><span>|</span><label class="collapse" for="c-39100732">[-]</label><label class="expand" for="c-39100732">[1 more]</label></div><br/><div class="children"><div class="content">Any results from your research? That seems interesting.</div><br/></div></div><div id="39100245" class="c"><input type="checkbox" id="c-39100245" checked=""/><div class="controls bullet"><span class="by">dexwiz</span><span>|</span><a href="#39100186">parent</a><span>|</span><a href="#39100732">prev</a><span>|</span><a href="#39100353">next</a><span>|</span><label class="collapse" for="c-39100245">[-]</label><label class="expand" for="c-39100245">[2 more]</label></div><br/><div class="children"><div class="content">JavaScript’s modules only changed because the toolchain rapidly iterated several times over the course of a decade. Most languages don’t see this kind of churn. Even then the migration is at best partial.</div><br/><div id="39100792" class="c"><input type="checkbox" id="c-39100792" checked=""/><div class="controls bullet"><span class="by">Zanfa</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100245">parent</a><span>|</span><a href="#39100353">next</a><span>|</span><label class="collapse" for="c-39100792">[-]</label><label class="expand" for="c-39100792">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been fighting JS&#x2F;TS because I went with ESM over CJS for one of my new projects. It&#x27;s an endless minefield of configuration issues, crappy-to-none support from widely used libraries and half-baked tooling. There&#x27;s also generally no (up to date at least) documentation, so most knowledge comes from random Github issues with magical incantations to copy-paste into your configs. I must have wasted weeks worth of time on this busywork and there&#x27;s no end in sight since any new library might accidentally trigger some new edge case.<p>So yeah, I&#x27;d agree with saying the migration is partial at best.</div><br/></div></div></div></div><div id="39100353" class="c"><input type="checkbox" id="c-39100353" checked=""/><div class="controls bullet"><span class="by">oezi</span><span>|</span><a href="#39100186">parent</a><span>|</span><a href="#39100245">prev</a><span>|</span><a href="#39100338">next</a><span>|</span><label class="collapse" for="c-39100353">[-]</label><label class="expand" for="c-39100353">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t call what Ruby has a module system because it is just linear textual require.</div><br/></div></div><div id="39100338" class="c"><input type="checkbox" id="c-39100338" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#39100186">parent</a><span>|</span><a href="#39100353">prev</a><span>|</span><label class="collapse" for="c-39100338">[-]</label><label class="expand" for="c-39100338">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Ruby&#x27;s require is analogous to C&#x27;s #include: modules are just files that get evaluated in order to add stuff to a global interpreter state.<p>What&#x27;s the theoretical alternative? Adding stuff to a global interpreter state is the goal.<p>The weird part of #include, to me, is not that it ends up modifying the global interpreter state. That&#x27;s the point of calling it! The weird part, what C libraries tie themselves into endless knots to work around, is that when you #include something in more than one place, it will execute more than once.</div><br/><div id="39100452" class="c"><input type="checkbox" id="c-39100452" checked=""/><div class="controls bullet"><span class="by">riffraff</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100338">parent</a><span>|</span><a href="#39100552">next</a><span>|</span><label class="collapse" for="c-39100452">[-]</label><label class="expand" for="c-39100452">[7 more]</label></div><br/><div class="children"><div class="content">There&#x27;s at least a few? E.g.<p>* Lexical scoped imports a-la python<p>* Pass state to modules explicitly, which I think is what newspeak was doing (i.e there&#x27;s no global state)<p>Either way you&#x27;d lose ruby&#x27;s &quot;let&#x27;s add methods to Kernel and have them pop up everywhere&quot; so it&#x27;s a trade off.<p>Worth nothing: there are a few proposals around to have some sort of namespaces in Ruby, but it&#x27;s unclear they&#x27;ll ever happen.<p>E.g.<p><a href="https:&#x2F;&#x2F;bugs.ruby-lang.org&#x2F;issues&#x2F;19744" rel="nofollow">https:&#x2F;&#x2F;bugs.ruby-lang.org&#x2F;issues&#x2F;19744</a></div><br/><div id="39100651" class="c"><input type="checkbox" id="c-39100651" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100452">parent</a><span>|</span><a href="#39100552">next</a><span>|</span><label class="collapse" for="c-39100651">[-]</label><label class="expand" for="c-39100651">[6 more]</label></div><br/><div class="children"><div class="content">&gt;  Lexical scoped imports a-la python<p>How is this an alternative to modifying the global interpreter state?<p>Before I do any imports, I can type this:<p><pre><code>    os.getcwd()
</code></pre>
and the interpreter will crash, telling me that &quot;os&quot; doesn&#x27;t mean anything.<p>But if I do this:<p><pre><code>    import os
</code></pre>
then, <i>later</i>, I can type exactly the same thing:<p><pre><code>    os.getcwd()
</code></pre>
and the interpreter will call the function and return a string.<p>In order for the interpreter&#x27;s behavior to be different when presented with exactly the same input, it&#x27;s necessary that the state of the interpreter has changed. What&#x27;s the alternative?<p>And since this is the <i>entire purpose</i> of a module system -- causing the global interpreter to recognize names that it otherwise wouldn&#x27;t have -- it follows immediately that all module systems will operate by making changes to a global interpreter state.<p>The reason Python&#x27;s module system is better than C&#x27;s has nothing to do with whether or not either system modifies a global interpreter state, since that doesn&#x27;t differ between the systems. The reason is that Python allows you to specify what you want those modifications to be. If I have two Python libraries named os, I can import them like so:<p><pre><code>    from lib1 import os
    from lib2 import os as os2
</code></pre>
and now they don&#x27;t conflict. As far as I know, C has no such facility.</div><br/><div id="39101034" class="c"><input type="checkbox" id="c-39101034" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100651">parent</a><span>|</span><a href="#39100788">next</a><span>|</span><label class="collapse" for="c-39101034">[-]</label><label class="expand" for="c-39101034">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it follows immediately that all module systems will operate by making changes to a global interpreter state.<p>No, it doesn&#x27;t?<p><pre><code>    def print_sysinfo():
        import sys, os
        print (f&#x27;{sys.platform} {sys.version}, current dir is {os.getcwd()}&#x27;

    os.getcwd()  # throws NameError, because os is not a thing there.
</code></pre>
Now, you may argue that the &#x27;os&#x27; module is still loaded after a call to print_sysinfo() and while it&#x27;s true, it didn&#x27;t have to be so: Python could as well had have semantics of unloading modules that have zero references to them, and re-loading them anew every time they are imported again.<p>A language can have locally-scoped module semantics, it just that most of the time the static&#x2F;global scope is much more convenient.</div><br/></div></div><div id="39100788" class="c"><input type="checkbox" id="c-39100788" checked=""/><div class="controls bullet"><span class="by">movpasd</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100651">parent</a><span>|</span><a href="#39101034">prev</a><span>|</span><a href="#39100706">next</a><span>|</span><label class="collapse" for="c-39100788">[-]</label><label class="expand" for="c-39100788">[1 more]</label></div><br/><div class="children"><div class="content">I expect _global_ here refers to the language-level semantics, not internal interpreter semantics.<p>Python&#x27;s module system results in no implicit modifications to Python-level state between modules — at least, for a well-developed module. Since Python is so dynamic, you can of course jerry-rig all sorts of global consequences if you really want to. But without dynamic magic, all state is namespaced to the imported module, and must be explicitly given names within the importer, with no global consequences for parallel modules.<p>In your os.getcwd() example, the state is scoped to the importer module, so it&#x27;s not an example of global interpreter state.<p>I don&#x27;t know what Ruby&#x27;s module system looks like, so I don&#x27;t know for sure if that is the point the GP is making. It seems to me that you are in agreement, just disagree with the meaning of &quot;global&quot; in this context.</div><br/></div></div><div id="39100706" class="c"><input type="checkbox" id="c-39100706" checked=""/><div class="controls bullet"><span class="by">mirekrusin</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100651">parent</a><span>|</span><a href="#39100788">prev</a><span>|</span><a href="#39100552">next</a><span>|</span><label class="collapse" for="c-39100706">[-]</label><label class="expand" for="c-39100706">[3 more]</label></div><br/><div class="children"><div class="content">If you qualify imports transitive dependencies won’t pollute your scope. It also naturally deals better with name conflicts, allows cherry picking exports etc.</div><br/><div id="39100720" class="c"><input type="checkbox" id="c-39100720" checked=""/><div class="controls bullet"><span class="by">thaumasiotes</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100706">parent</a><span>|</span><a href="#39100552">next</a><span>|</span><label class="collapse" for="c-39100720">[-]</label><label class="expand" for="c-39100720">[2 more]</label></div><br/><div class="children"><div class="content">OK, where&#x27;s the part of this where we&#x27;re not modifying a global interpreter state?</div><br/><div id="39100867" class="c"><input type="checkbox" id="c-39100867" checked=""/><div class="controls bullet"><span class="by">tomstuart</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100720">parent</a><span>|</span><a href="#39100552">next</a><span>|</span><label class="collapse" for="c-39100867">[-]</label><label class="expand" for="c-39100867">[1 more]</label></div><br/><div class="children"><div class="content">You’re taking the use of the word “state” too literally. The original comment was complaining about how Ruby `require` adds names (constants) to a global <i>namespace</i>; Python `import` only binds names in the local scope.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39100552" class="c"><input type="checkbox" id="c-39100552" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#39100186">root</a><span>|</span><a href="#39100338">parent</a><span>|</span><a href="#39100452">prev</a><span>|</span><label class="collapse" for="c-39100552">[-]</label><label class="expand" for="c-39100552">[1 more]</label></div><br/><div class="children"><div class="content">Waitwhat, surely it&#x27;s not GLOBAL state, but &quot;module global&quot; or something?</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>