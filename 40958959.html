<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1720947675952" as="style"/><link rel="stylesheet" href="styles.css?v=1720947675952"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/ulid/spec">ULID: Like UUID but Sortable (2019)</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>fagnerbrack</span> | <span>27 comments</span></div><br/><div><div id="40959229" class="c"><input type="checkbox" id="c-40959229" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#40959265">next</a><span>|</span><label class="collapse" for="c-40959229">[-]</label><label class="expand" for="c-40959229">[3 more]</label></div><br/><div class="children"><div class="content">It says both:<p>&gt; Within the same millisecond, sort order is not guaranteed<p>And:<p>&gt; Monotonic sort order (correctly detects and handles the same millisecond)<p>Which is it?<p>To make it more confusing, the spec later contains a section about monotonic sort order[1]. And looks like not all libraries implement it [2].<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec?tab=readme-ov-file#monotonicity">https:&#x2F;&#x2F;github.com&#x2F;ulid&#x2F;spec?tab=readme-ov-file#monotonicity</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;suyash&#x2F;ulid&#x2F;issues&#x2F;10">https:&#x2F;&#x2F;github.com&#x2F;suyash&#x2F;ulid&#x2F;issues&#x2F;10</a></div><br/><div id="40959248" class="c"><input type="checkbox" id="c-40959248" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#40959229">parent</a><span>|</span><a href="#40959245">next</a><span>|</span><label class="collapse" for="c-40959248">[-]</label><label class="expand" for="c-40959248">[1 more]</label></div><br/><div class="children"><div class="content">I think it’s meant to be monotonic within one node but not cross-node (cross-node the sort order is random within the same millisecond). The random portion of the IDs are sequentially incrementing within a single MS on a given node.</div><br/></div></div><div id="40959245" class="c"><input type="checkbox" id="c-40959245" checked=""/><div class="controls bullet"><span class="by">GeertJohan</span><span>|</span><a href="#40959229">parent</a><span>|</span><a href="#40959248">prev</a><span>|</span><a href="#40959265">next</a><span>|</span><label class="collapse" for="c-40959245">[-]</label><label class="expand" for="c-40959245">[1 more]</label></div><br/><div class="children"><div class="content">Afaik it depends on the generate function you use. You can let it keep track of the increment when generating, at a performance cost (atomic operations).</div><br/></div></div></div></div><div id="40959265" class="c"><input type="checkbox" id="c-40959265" checked=""/><div class="controls bullet"><span class="by">martinrue</span><span>|</span><a href="#40959229">prev</a><span>|</span><a href="#40958982">next</a><span>|</span><label class="collapse" for="c-40959265">[-]</label><label class="expand" for="c-40959265">[6 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no mention of the UUID v7 in the README. Based on my basic understanding, v7 uses the first 48 bits to encode the Unix epoch, which makes them more useful for sort&#x2F;indexing scenarios. Might be useful to compare ULID and v7 in the README to make it clearer the benefits one has over the other.</div><br/><div id="40959279" class="c"><input type="checkbox" id="c-40959279" checked=""/><div class="controls bullet"><span class="by">laserbeam</span><span>|</span><a href="#40959265">parent</a><span>|</span><a href="#40959310">next</a><span>|</span><label class="collapse" for="c-40959279">[-]</label><label class="expand" for="c-40959279">[4 more]</label></div><br/><div class="children"><div class="content">There’s no mention because this is 5-7 years old. I believe that predates UUID 6-8.</div><br/><div id="40959313" class="c"><input type="checkbox" id="c-40959313" checked=""/><div class="controls bullet"><span class="by">martinrue</span><span>|</span><a href="#40959265">root</a><span>|</span><a href="#40959279">parent</a><span>|</span><a href="#40959310">next</a><span>|</span><label class="collapse" for="c-40959313">[-]</label><label class="expand" for="c-40959313">[3 more]</label></div><br/><div class="children"><div class="content">You know, I didn&#x27;t even look at the last commit! I assumed it was a new thing, and hence why it was being shared now. Here&#x27;s an idea for HN: when processing a repo link, auto add (&lt;time since last commit&gt;) to the end of the title.</div><br/><div id="40959648" class="c"><input type="checkbox" id="c-40959648" checked=""/><div class="controls bullet"><span class="by">linkdd</span><span>|</span><a href="#40959265">root</a><span>|</span><a href="#40959313">parent</a><span>|</span><a href="#40959494">next</a><span>|</span><label class="collapse" for="c-40959648">[-]</label><label class="expand" for="c-40959648">[1 more]</label></div><br/><div class="children"><div class="content">That would not convey the information &quot;does this predate $X?&quot;, because an older tech could still be maintained daily.</div><br/></div></div><div id="40959494" class="c"><input type="checkbox" id="c-40959494" checked=""/><div class="controls bullet"><span class="by">dotancohen</span><span>|</span><a href="#40959265">root</a><span>|</span><a href="#40959313">parent</a><span>|</span><a href="#40959648">prev</a><span>|</span><a href="#40959310">next</a><span>|</span><label class="collapse" for="c-40959494">[-]</label><label class="expand" for="c-40959494">[1 more]</label></div><br/><div class="children"><div class="content">Good idea, but in my opinion that information really only needs to be added if it is significantly long ago, such as when appending a parenthesized year to a title.</div><br/></div></div></div></div></div></div><div id="40959310" class="c"><input type="checkbox" id="c-40959310" checked=""/><div class="controls bullet"><span class="by">sakjur</span><span>|</span><a href="#40959265">parent</a><span>|</span><a href="#40959279">prev</a><span>|</span><a href="#40958982">next</a><span>|</span><label class="collapse" for="c-40959310">[-]</label><label class="expand" for="c-40959310">[1 more]</label></div><br/><div class="children"><div class="content">Digging into the discussions in the repo’s issues, I found someone linking to this comparison between ULIDs and UUIDs:  <a href="https:&#x2F;&#x2F;uuid.ramsey.dev&#x2F;en&#x2F;stable&#x2F;rfc4122&#x2F;version7.html" rel="nofollow">https:&#x2F;&#x2F;uuid.ramsey.dev&#x2F;en&#x2F;stable&#x2F;rfc4122&#x2F;version7.html</a><p>In short, it seems UUIDv7 is storage-wise compatible with ULID but not vice versa due to UUID’s versioning bits.</div><br/></div></div></div></div><div id="40958982" class="c"><input type="checkbox" id="c-40958982" checked=""/><div class="controls bullet"><span class="by">gnabgib</span><span>|</span><a href="#40959265">prev</a><span>|</span><a href="#40959200">next</a><span>|</span><label class="collapse" for="c-40958982">[-]</label><label class="expand" for="c-40958982">[1 more]</label></div><br/><div class="children"><div class="content">Discussions<p>(238 points, 6 years ago, 129 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18768909">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18768909</a><p>(213 points, 3 years ago, 100 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29794186">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29794186</a><p>(33 points, 2 years ago, 23 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34281969">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34281969</a><p><i>Now that UUIDv7 is lexicographic, does that mean there is no use for ULID?</i> (19 points, 26 days ago, 6 comments) <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40712872">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=40712872</a></div><br/></div></div><div id="40959200" class="c"><input type="checkbox" id="c-40959200" checked=""/><div class="controls bullet"><span class="by">cricalix</span><span>|</span><a href="#40958982">prev</a><span>|</span><a href="#40959207">next</a><span>|</span><label class="collapse" for="c-40959200">[-]</label><label class="expand" for="c-40959200">[12 more]</label></div><br/><div class="children"><div class="content">While looking into a replacement for auto increment primary keys, I also encountered TSIDs &#x2F; Snowflakes. At least with TSIDs you can store them easily as 64 bit integers; ULIDs were not as compact. Haven&#x27;t made a decision yet though.</div><br/><div id="40959225" class="c"><input type="checkbox" id="c-40959225" checked=""/><div class="controls bullet"><span class="by">leetrout</span><span>|</span><a href="#40959200">parent</a><span>|</span><a href="#40959207">next</a><span>|</span><label class="collapse" for="c-40959225">[-]</label><label class="expand" for="c-40959225">[11 more]</label></div><br/><div class="children"><div class="content">Keep ints for primary keys and keep all the db magic for your internal references then use ULIDs or TSIDs for your external keys and keep the ability to have well behaved indexes. Win-win with minimal disk impact</div><br/><div id="40959704" class="c"><input type="checkbox" id="c-40959704" checked=""/><div class="controls bullet"><span class="by">drowsspa</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959225">parent</a><span>|</span><a href="#40959517">prev</a><span>|</span><a href="#40959333">next</a><span>|</span><label class="collapse" for="c-40959704">[-]</label><label class="expand" for="c-40959704">[1 more]</label></div><br/><div class="children"><div class="content">Sure, if your only goal with them is hiding meta info and you&#x27;re generating your IDs into a RDBMS...</div><br/></div></div><div id="40959333" class="c"><input type="checkbox" id="c-40959333" checked=""/><div class="controls bullet"><span class="by">hn_throwaway_99</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959225">parent</a><span>|</span><a href="#40959704">prev</a><span>|</span><a href="#40959397">next</a><span>|</span><label class="collapse" for="c-40959333">[-]</label><label class="expand" for="c-40959333">[5 more]</label></div><br/><div class="children"><div class="content">The whole point of ULIDs and newer things like UUIDv7 is precisely so you don&#x27;t have to do that.<p>I would definitely just use a ULID or UUIDv7 as my sole primary DB key for new projects going forward. You get the benefit of ascending ordered primary keys, but the key is still globally unique so can be used as public keys.</div><br/><div id="40959553" class="c"><input type="checkbox" id="c-40959553" checked=""/><div class="controls bullet"><span class="by">Phil_Latio</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959333">parent</a><span>|</span><a href="#40959380">next</a><span>|</span><label class="collapse" for="c-40959553">[-]</label><label class="expand" for="c-40959553">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s the point of ULID again? People say one use case of UUIDs is that clients are able to generate the (random) primary key. Fair enough, I guess... Then they say autoincremental ids are bad because it could give indication about business activity (like how many orders have been done in a time frame). But with ULID or UUIDv7, this &quot;benefit&quot; is gone to some degree because timestamp is included.<p>If client-generation is not needed, then UUID is stupid to begin with, because any incremental id can be transformed (&quot;encrypted&quot;) to arbitary different format (which hides the real id). Also UUID is usually much larger: Waste of db&#x2F;index space, degraded performance. But I guess if people push everything in the cloud, they don&#x27;t even realize they are paying more than needed...<p>Conclusion: I don&#x27;t understand what you people are trying to &quot;solve&quot;. All those different UUID versions leads me to believe the issue is not the id, but developer confusion.</div><br/><div id="40959772" class="c"><input type="checkbox" id="c-40959772" checked=""/><div class="controls bullet"><span class="by">jw1224</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959553">parent</a><span>|</span><a href="#40959380">next</a><span>|</span><label class="collapse" for="c-40959772">[-]</label><label class="expand" for="c-40959772">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But with ULID or UUIDv7, this &quot;benefit&quot; is gone to some degree because timestamp is included<p>Including the timestamp only tells someone the time the UUID was generated. Unlike incrementing numeric IDs (which can simply be subtracted from one another to measure a change in database records), there’s no way to meaningfully count change over time.<p>&gt; any incremental id can be transformed (&quot;encrypted&quot;) to arbitary different format (which hides the real id)<p>Easier said than done… You then have the overhead of encrypting&#x2F;decrypting every client-facing ID before querying the database. You’ll also need to code workarounds in many frameworks, to bypass conventions where they expect keys in URL paths (for example).<p>&gt; Also UUID is usually much larger: Waste of db&#x2F;index space, degraded performance<p>With older UUIDs, sure, but sorted ones (like ULIDs) have consistent prefixes, allowing for very efficient indexing and querying with a binary tree search.</div><br/></div></div></div></div><div id="40959380" class="c"><input type="checkbox" id="c-40959380" checked=""/><div class="controls bullet"><span class="by">Arch-TK</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959333">parent</a><span>|</span><a href="#40959553">prev</a><span>|</span><a href="#40959397">next</a><span>|</span><label class="collapse" for="c-40959380">[-]</label><label class="expand" for="c-40959380">[2 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to do that if you don&#x27;t mind leaking metadata about the time when a record was created.</div><br/><div id="40959475" class="c"><input type="checkbox" id="c-40959475" checked=""/><div class="controls bullet"><span class="by">aabhay</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959380">parent</a><span>|</span><a href="#40959397">next</a><span>|</span><label class="collapse" for="c-40959475">[-]</label><label class="expand" for="c-40959475">[1 more]</label></div><br/><div class="children"><div class="content">Fair tradeoff if you ask me</div><br/></div></div></div></div></div></div><div id="40959397" class="c"><input type="checkbox" id="c-40959397" checked=""/><div class="controls bullet"><span class="by">dagss</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959225">parent</a><span>|</span><a href="#40959333">prev</a><span>|</span><a href="#40959207">next</a><span>|</span><label class="collapse" for="c-40959397">[-]</label><label class="expand" for="c-40959397">[2 more]</label></div><br/><div class="children"><div class="content">You say win-win but what is the win of having a seperate internal ID specifically?<p>It is possible to do as you say ofc but what is the advantage?</div><br/><div id="40959466" class="c"><input type="checkbox" id="c-40959466" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#40959200">root</a><span>|</span><a href="#40959397">parent</a><span>|</span><a href="#40959207">next</a><span>|</span><label class="collapse" for="c-40959466">[-]</label><label class="expand" for="c-40959466">[1 more]</label></div><br/><div class="children"><div class="content">One advantage is to use more compact data type for performance-critical paths. Table ID datatype will be used not just in the given table, but also in all tables referencing given table. Table ID is always indexed and foreign keys very often are indexed as well, so this datatype &quot;leaks&quot; to the many database indexes. If your index is compact, it allows for better RAM caching and generally faster queries. And, of course, faster writes.<p>Another advantage is that you don&#x27;t need to &quot;think&quot; about using sortable id, numeric serial id is sortable by default. It also helps with index size and insertion speed for primary key index and often foreign key indices.<p>Using completely random UUID leaks no data about record creation time. It might not look like sensitive information, but generally it&#x27;s better to be on a cautious side about leaking information.<p>Generating sortable ID is far from generally accepted solution. You need to find obscure libraries or write non-trivial code yourself for all languages you&#x27;re using. It&#x27;ll be solved in time, as UUIDv7 became standard, but we&#x27;re not there yet. UUID v4 is available in any language (and generally trivial to generate).</div><br/></div></div></div></div></div></div></div></div><div id="40959331" class="c"><input type="checkbox" id="c-40959331" checked=""/><div class="controls bullet"><span class="by">goralph</span><span>|</span><a href="#40959411">prev</a><span>|</span><a href="#40959608">next</a><span>|</span><label class="collapse" for="c-40959331">[-]</label><label class="expand" for="c-40959331">[1 more]</label></div><br/><div class="children"><div class="content">An auto incrementing integer (for internal use) and a string (for external) will be enough for the vast majority of use cases, is simple to understand, and works well.</div><br/></div></div><div id="40959608" class="c"><input type="checkbox" id="c-40959608" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#40959331">prev</a><span>|</span><label class="collapse" for="c-40959608">[-]</label><label class="expand" for="c-40959608">[1 more]</label></div><br/><div class="children"><div class="content">Hot take: I wish people just used UUIDs as UUIDs, instead of seeing the plethora of bits and going &quot;it&#x27;s free real estate&quot;. Treat it like a random identifier and move on with your life, rather than having all sorts of weird emergent properties that kinda sorta provide something valuable but not if you squint at it too hard.</div><br/></div></div></div></div></div></div></div></body></html>