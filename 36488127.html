<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687856459805" as="style"/><link rel="stylesheet" href="styles.css?v=1687856459805"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.uber.com/blog/microservice-architecture/">Domain-Oriented Microservice Architecture (2020)</a>Â <span class="domain">(<a href="https://www.uber.com">www.uber.com</a>)</span></div><div class="subtext"><span>yla92</span> | <span>10 comments</span></div><br/><div><div id="36488655" class="c"><input type="checkbox" id="c-36488655" checked=""/><div class="controls bullet"><span class="by">xwowsersx</span><span>|</span><a href="#36488953">next</a><span>|</span><label class="collapse" for="c-36488655">[-]</label><label class="expand" for="c-36488655">[7 more]</label></div><br/><div class="children"><div class="content">&gt; A single regression within a monolithic code base can bring the whole system (in this case, all of Uber) down.<p>Serious question: why though? I can&#x27;t think of a backend system where a single regression could bring the whole thing down. If something blows it up, it rarely takes the whole application down. What&#x27;s this scenario exactly? Maybe I&#x27;m only thinking of certain types of applications, but a single failure somewhere needn&#x27;t bring the whole thing down.<p>&gt; Poor separation of concerns. It was difficult to maintain good separations of concerns with a huge code base. In an exponential growth environment, expediency sometimes led to poor boundaries between logic and components.<p>I kind of get this...The idea is that if the other area of code simply isn&#x27;t accessible to you, you&#x27;re <i>forced</i> to keep the concerns separate? Seems like this could be dealt with by applying more discipline and just making sure to design things to be more modular and.. separate. This is the hallmark of any good code base. Do we need an entirely different architecture, with all the pitfalls that microservices entail, because we can&#x27;t seem to keep things clean and separate?<p>I really am asking these questions in good faith. I won&#x27;t hide the fact that I&#x27;m skeptical of the microservices fashion (and I know that Uber is at least trying to be more thoughtful here), but I am totally open to being convinced otherwise. I&#x27;m at this very moment gearing up to begin a new large project and am wondering what design makes the most sense and whether there&#x27;s a place for separate services so I&#x27;m curious to hear what people think. The one area I&#x27;m thinking about specifically is the fact that difference parts of a monolith might have different scaling requirements and if you have a single application then everything has to scale out or in as a unit. But it seems like this doesn&#x27;t require a separate code base necessarily...just the ability to run different parts of a single code base as its own applications or unit of deployment, no?<p>This old post from Michael DeHaan comes to mind as I&#x27;m thinking about this <a href="https:&#x2F;&#x2F;archive.ph&#x2F;YMRYx" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.ph&#x2F;YMRYx</a></div><br/><div id="36488862" class="c"><input type="checkbox" id="c-36488862" checked=""/><div class="controls bullet"><span class="by">localghost3000</span><span>|</span><a href="#36488655">parent</a><span>|</span><a href="#36488756">next</a><span>|</span><label class="collapse" for="c-36488862">[-]</label><label class="expand" for="c-36488862">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  I&#x27;m at this very moment gearing up to begin a new large project and am wondering what design makes the most sense<p>IMO a monolith is always the starting point until your team gets big enough to justify breaking it up.<p>&gt; Seems like this could be dealt with by applying more discipline and just making sure to design things to be more modular and.. separate<p>This really depends on the team size. As you get above, say, 30 engineers contributing to your codebase daily communicating those logical boundaries becomes nigh impossible without significant operational overhead. You either accept the chaos and let your codebase become a Big Ball Of Mud (most common) or you introduce so much process overhead that your team paradoxically gets slower the more people you add. I&#x27;m sure there are exceptions but it&#x27;s rare.<p>&gt; Do we need an entirely different architecture, with all the pitfalls that microservices entail, because we can&#x27;t seem to keep things clean and separate?<p>Microservices are probably not the tool to reach for no. Several &quot;fat&quot; services separated along some kind of bounded context within your domain? I&#x27;ve seen that work great as a next step in a monolithic architecture evolution. Teams can have the autonomy they need to make decisions quickly, separation of concerns is enforced by the network. The extra overhead incurred isn&#x27;t untenable since you only have a few services instead of a hundred.</div><br/></div></div><div id="36488756" class="c"><input type="checkbox" id="c-36488756" checked=""/><div class="controls bullet"><span class="by">nivertech</span><span>|</span><a href="#36488655">parent</a><span>|</span><a href="#36488862">prev</a><span>|</span><a href="#36490288">next</a><span>|</span><label class="collapse" for="c-36488756">[-]</label><label class="expand" for="c-36488756">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; A single regression within a monolithic code base can bring the whole system (in this case, all of Uber) down.<p>Serious question: why though? I can&#x27;t think of a backend system where a single regression could bring the whole thing down. If something blows it up, it rarely takes the whole application down. What&#x27;s this scenario exactly? Maybe I&#x27;m only thinking of certain types of applications, but a single failure somewhere needn&#x27;t bring the whole thing down.</i><p>A crash in a stateless distributed tier (e.g. web servers) will not take the whole system down.<p>But a crash while processing any request in a stateful non-distributed multithreaded system, can bring it down. It&#x27;s much harder to make stateful systems resilient and fault tolerant. Usually it&#x27;s solved by moving the state somewhere else (e.g. databases, message queues, or Kafka-style AOLs).<p>Exception: monolithic stateful systems using BEAM&#x2F;OTP&#x2F;Erlang&#x2F;Elixir. Here the blast radius is per Erlang process, so in the worst case only a single request&#x2F;user&#x2F;session should be affected. There are some classes of errors (e.g. out-of-memory, overloaded process message queues, or crash in native code library) which can bring down an entire Erlang node. This can be mitigated by running a cluster of several Erlang nodes (which is supported out-of-the box by BEAM VM and OTP).</div><br/></div></div><div id="36490288" class="c"><input type="checkbox" id="c-36490288" checked=""/><div class="controls bullet"><span class="by">KronisLV</span><span>|</span><a href="#36488655">parent</a><span>|</span><a href="#36488756">prev</a><span>|</span><a href="#36488817">next</a><span>|</span><label class="collapse" for="c-36490288">[-]</label><label class="expand" for="c-36490288">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Serious question: why though? I can&#x27;t think of a backend system where a single regression could bring the whole thing down. If something blows it up, it rarely takes the whole application down. What&#x27;s this scenario exactly? Maybe I&#x27;m only thinking of certain types of applications, but a single failure somewhere needn&#x27;t bring the whole thing down.<p>Suppose you have a web based CRUD that processes HTTP requests. To do this, it connects to a DB. There is one thread pool for HTTP requests, there&#x27;s another thread pool for DB connections. Suppose there&#x27;s an issue that causes a DB connection to hang (either a really slow query, or an issue with the DB thread pooling solution itself). All of the sudden, the DB thread pool is slowly getting exhausted, until no more queries can run because everything is hanging. Soon after, the HTTP request thread pool fills up, because requests are waiting for processing but none is being done. Users either see their requests frozen, or, if you&#x27;re packaging both the API and the front end resources in the same deployment unit, soon nobody can even load the static resources of the page. I&#x27;ve seen this happen with a Java web app that used an old DB pooling solution that caused a prod outage years ago. Had to rip it out and replace it with something else.<p>That said, the same could happen with stuff like scheduled processes conflicting, memory exhaustion, CPU utilization, disk usage and so on. Now, there shouldn&#x27;t be anything preventing you from running multiple instances of monolithic codebases in parallel, though sometimes systems aren&#x27;t written with that in mind (e.g. no DB queues&#x2F;RabbitMQ for messaging&#x2F;scheduled processes, no assumption of multiple instances accessing the same data, in-memory caches instead of Redis and so on) and you end up with a singleton application instead, which is worse than just a monolith. Either way, planning for components&#x2F;systems failing and being able to recover from that is almost always a good idea (health checks, automated restarts, some horizontal scaling, uptime notifications and alerting, some instrumentation like APM), unless you&#x27;re really short on time.<p>None of that means that you should start with microservices though, unless your whole team is really comfortable with that. Monoliths are okay, as are modular monoliths (same codebase, deploy different features for app instances with feature flags, like FEATURE_ENABLE_API, FEATURE_ENABLE_SCHEDULED_PROCESSES etc.).</div><br/></div></div><div id="36488817" class="c"><input type="checkbox" id="c-36488817" checked=""/><div class="controls bullet"><span class="by">mjr00</span><span>|</span><a href="#36488655">parent</a><span>|</span><a href="#36490288">prev</a><span>|</span><a href="#36490082">next</a><span>|</span><label class="collapse" for="c-36488817">[-]</label><label class="expand" for="c-36488817">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The idea is that if the other area of code simply isn&#x27;t accessible to you, you&#x27;re forced to keep the concerns separate? Seems like this could be dealt with by applying more discipline and just making sure to design things to be more modular and.. separate. This is the hallmark of any good code base. Do we need an entirely different architecture, with all the pitfalls that microservices entail, because we can&#x27;t seem to keep things clean and separate?<p>Yes, because code is written by humans, and humans make mistakes. &quot;Just have discipline and write good code&quot; doesn&#x27;t scale, especially in, as Uber&#x27;s case, quickly growing organizations where large numbers of people new to the codebase are contributing.</div><br/><div id="36489570" class="c"><input type="checkbox" id="c-36489570" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36488655">root</a><span>|</span><a href="#36488817">parent</a><span>|</span><a href="#36490082">next</a><span>|</span><label class="collapse" for="c-36489570">[-]</label><label class="expand" for="c-36489570">[1 more]</label></div><br/><div class="children"><div class="content">What is it about network calls that makes it easier to scale separation over function calls. To me the RPC you choose should be independent from the separation part of it.</div><br/></div></div></div></div><div id="36490082" class="c"><input type="checkbox" id="c-36490082" checked=""/><div class="controls bullet"><span class="by">pydry</span><span>|</span><a href="#36488655">parent</a><span>|</span><a href="#36488817">prev</a><span>|</span><a href="#36488953">next</a><span>|</span><label class="collapse" for="c-36490082">[-]</label><label class="expand" for="c-36490082">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I kind of get this...The idea is that if the other area of code simply isn&#x27;t accessible to you, you&#x27;re forced to keep the concerns separate?<p>IME about half of the microservice architectures Ive worked on have managed to make sure that the concerns and network boundaries cut across completely different places.<p>At least this mistake in a &quot;monolith&quot; (hate that word) is easier to undo.</div><br/></div></div></div></div><div id="36488953" class="c"><input type="checkbox" id="c-36488953" checked=""/><div class="controls bullet"><span class="by">netfortius</span><span>|</span><a href="#36488655">prev</a><span>|</span><a href="#36489545">next</a><span>|</span><label class="collapse" for="c-36488953">[-]</label><label class="expand" for="c-36488953">[1 more]</label></div><br/><div class="children"><div class="content">Stack Overflow doesn&#x27;t seem to have this issue.</div><br/></div></div><div id="36489545" class="c"><input type="checkbox" id="c-36489545" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#36488953">prev</a><span>|</span><label class="collapse" for="c-36489545">[-]</label><label class="expand" for="c-36489545">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Availability Risks. A single regression within a monolithic code base can bring the whole system (in this case, all of Uber) down.<p>A single regression in your isEven microservice can also take the whole system down. You can mitigate this by slowly rolling out new versions to try and catch regressions early so you can revert.<p>&gt;Risky, expensive deployments. These were painful and time consuming to perform with the frequent need for rollbacks.<p>Code that is going to be deployed all needs to be deployed. Painful deploys are going to happen with microservices too.<p>&gt;Poor separation of concerns. It was difficult to maintain good separations of concerns with a huge code base. In an exponential growth environment, expediency sometimes led to poor boundaries between logic and components.<p>Making libraries will boundaries without having to do an expensive network call.<p>&gt;Inefficient execution. These issues combined made it difficult for teams to execute autonomously or independently.<p>Monoliths let you work independently too. You go in and change something and now it is changed. No part of monoliths make it harder as a single person or team to make changes.<p>Also keep in mind Uber ships Android and iPhone apps which are monoliths. They don&#x27;t force you to install an app for entering a location, an app for making a payment, an app for looking up pricing, etc.</div><br/></div></div></div></div></div></div></div></body></html>