<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1705395658247" as="style"/><link rel="stylesheet" href="styles.css?v=1705395658247"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.ydb.tech/how-we-switched-to-java-21-virtual-threads-and-got-deadlock-in-tpc-c-for-postgresql-cca2fe08d70b">We switched to Java 21 virtual threads and got a deadlock in TPC-C for Postgres</a> <span class="domain">(<a href="https://blog.ydb.tech">blog.ydb.tech</a>)</span></div><div class="subtext"><span>magden</span> | <span>125 comments</span></div><br/><div><div id="39009737" class="c"><input type="checkbox" id="c-39009737" checked=""/><div class="controls bullet"><span class="by">synthetigram</span><span>|</span><a href="#39009513">next</a><span>|</span><label class="collapse" for="c-39009737">[-]</label><label class="expand" for="c-39009737">[5 more]</label></div><br/><div class="children"><div class="content">This problem is not going to go away so easily.  Numerous core Java classes (like BufferedInputStream) use synchronized.   I count 1600+ usages in java.base.    The blocking issue means it&#x27;s _much_ easier to accidentally run into this, rather than waving it away as an unlikely edge case.<p>I personally ran into this Using the built in com.sun webserver, with a virtual thread executor.  My VPS only has two CPUs which means the FJP that virtual threads run on only have 2 active threads at a time.  I ran into this hang when some of the connection hung, blocking any further requests from being processed.</div><br/><div id="39010868" class="c"><input type="checkbox" id="c-39010868" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39009737">parent</a><span>|</span><a href="#39010647">next</a><span>|</span><label class="collapse" for="c-39010868">[-]</label><label class="expand" for="c-39010868">[3 more]</label></div><br/><div class="children"><div class="content">People always forget that things that only happen every few million times, can happen fairly frequently on a busy server. This has bitten me numerous times. The nature of a lot of these types of issues is that they are hard to detect and hard to reproduce.<p>Virtual threads are nice for unblocking legacy code but they aren&#x27;t without issues. There are better options for new code with less trade offs on the jvm as well. I&#x27;ve recently been experimenting with jasync-postgresql (there&#x27;s  a mysql variant as well) as an alternative to JDBC in Kotlin. It&#x27;s a nice library. It does have some limitations and is a bit on the primitive side. But it appears to be somewhat widely used in various database frameworks for Scala, Java, and Kotlin.<p>Databases and database frameworks are an area on the JVM where there just is a huge amount of legacy code built on threads and blocking IO. It&#x27;s probably one of the reasons Oracle worked on virtual threads as migrating away from these frameworks is unlikely to ever happen in a lot of code bases. So, waving a magic wand and making all that code non blocking is very attractive. But of course that magic has some hard limitations and synchronize blocks are one of those. I imagine they are working on improving that further.</div><br/><div id="39011011" class="c"><input type="checkbox" id="c-39011011" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#39009737">root</a><span>|</span><a href="#39010868">parent</a><span>|</span><a href="#39010999">next</a><span>|</span><label class="collapse" for="c-39011011">[-]</label><label class="expand" for="c-39011011">[1 more]</label></div><br/><div class="children"><div class="content">The lack of support for synchronized isn&#x27;t a fundamental or hard limit, it&#x27;s just that the HotSpot implementation is complicated for performance reasons and they put off rewriting that code until later. They&#x27;re indeed working on that now and in some future version I guess wait&#x2F;notify and synchronized blocks will start to work. After all, you can easily transform such code into an equivalent that <i>does</i> work.</div><br/></div></div><div id="39010999" class="c"><input type="checkbox" id="c-39010999" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39009737">root</a><span>|</span><a href="#39010868">parent</a><span>|</span><a href="#39011011">prev</a><span>|</span><a href="#39010647">next</a><span>|</span><label class="collapse" for="c-39010999">[-]</label><label class="expand" for="c-39010999">[1 more]</label></div><br/><div class="children"><div class="content">Synchronized blocks are not a problem. Synchronized blocks that later don’t unblock the thread may sometimes be.</div><br/></div></div></div></div><div id="39010647" class="c"><input type="checkbox" id="c-39010647" checked=""/><div class="controls bullet"><span class="by">he0001</span><span>|</span><a href="#39009737">parent</a><span>|</span><a href="#39010868">prev</a><span>|</span><a href="#39009513">next</a><span>|</span><label class="collapse" for="c-39010647">[-]</label><label class="expand" for="c-39010647">[1 more]</label></div><br/><div class="children"><div class="content">BufferdInputStream is rewritten and is only using synchronized if subclassed. In fact there has been a lot of work removing the synchronized keyword.</div><br/></div></div></div></div><div id="39009513" class="c"><input type="checkbox" id="c-39009513" checked=""/><div class="controls bullet"><span class="by">mrintegrity</span><span>|</span><a href="#39009737">prev</a><span>|</span><a href="#39011056">next</a><span>|</span><label class="collapse" for="c-39009513">[-]</label><label class="expand" for="c-39009513">[27 more]</label></div><br/><div class="children"><div class="content">Totally off topic but I am getting tired of the AI generated images used on nearly all blog posts nowadays. They are instantly recognisable, it just seems low effort and lowers the feeling of quality one might otherwise have</div><br/><div id="39009555" class="c"><input type="checkbox" id="c-39009555" checked=""/><div class="controls bullet"><span class="by">sdedovic</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009938">next</a><span>|</span><label class="collapse" for="c-39009555">[-]</label><label class="expand" for="c-39009555">[1 more]</label></div><br/><div class="children"><div class="content">To me, its more about the style than the use of an AI. But I agree.<p>I enjoyed this writeup by Michael Lynch on finding an illustrator [1], for their blog. In doing some of my own writing, I&#x27;ve really found it enlightening how much secondary work goes into publishing your own work. I often think its so nice to be able to _just_ plug in what I want on a site and get a (more or less) free illustration. But as someone selling their own work &#x2F; time, it feels wrong. I&#x27;d rather pay a real human and build a relationship and have something more quality. On the other hand, though, it can be expensive, time consuming, and I&#x27;ve been screwed over. Often it seems like a bigger risk than its worth.<p>So idk, you&#x27;re trading some hardship and risk for an ethical dilemma but ease of use.<p>[1] <a href="https:&#x2F;&#x2F;mtlynch.io&#x2F;how-to-hire-a-cartoonist&#x2F;" rel="nofollow">https:&#x2F;&#x2F;mtlynch.io&#x2F;how-to-hire-a-cartoonist&#x2F;</a></div><br/></div></div><div id="39009938" class="c"><input type="checkbox" id="c-39009938" checked=""/><div class="controls bullet"><span class="by">cpeterso</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009555">prev</a><span>|</span><a href="#39009673">next</a><span>|</span><label class="collapse" for="c-39009938">[-]</label><label class="expand" for="c-39009938">[1 more]</label></div><br/><div class="children"><div class="content">Worse yet, the dining philosophers in the image have too many hands. No wonder they’re deadlocking! :)</div><br/></div></div><div id="39009673" class="c"><input type="checkbox" id="c-39009673" checked=""/><div class="controls bullet"><span class="by">minimaxir</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009938">prev</a><span>|</span><a href="#39010785">next</a><span>|</span><label class="collapse" for="c-39009673">[-]</label><label class="expand" for="c-39009673">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a quality spectrum of AI-generated header images. Some are just random DALL-E output which aren&#x27;t intrinsically relevant to the article (like the one used in this article), but you can have a little fun with it and do something distinct. This may require more control than just using Bing Image Creator.<p>Also, a thumbnail tip: square thumbnails are bad. If you have to use a square 1024x1024 AI generation, crop it to something like 1024x575, which incidentally can make things difficult if using AI generation since figuring out <i>what</i> to crop requires human intervention.</div><br/></div></div><div id="39010785" class="c"><input type="checkbox" id="c-39010785" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009673">prev</a><span>|</span><a href="#39009626">next</a><span>|</span><label class="collapse" for="c-39010785">[-]</label><label class="expand" for="c-39010785">[1 more]</label></div><br/><div class="children"><div class="content">I dislike the style this particular author chose, but don&#x27;t object in general.  Assuming the images are actually somewhat relevant (or at least funny), I think I&#x27;d prefer an AI-generated image over a big wall of text.<p>To each their own, though, of course.</div><br/></div></div><div id="39009626" class="c"><input type="checkbox" id="c-39009626" checked=""/><div class="controls bullet"><span class="by">blindriver</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39010785">prev</a><span>|</span><a href="#39010400">next</a><span>|</span><label class="collapse" for="c-39009626">[-]</label><label class="expand" for="c-39009626">[3 more]</label></div><br/><div class="children"><div class="content">I prefer AI generated images over stock photos though. You can tell that both are phony, but at least the AI can be a bit more creative.</div><br/><div id="39010019" class="c"><input type="checkbox" id="c-39010019" checked=""/><div class="controls bullet"><span class="by">Zardoz84</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009626">parent</a><span>|</span><a href="#39010400">next</a><span>|</span><label class="collapse" for="c-39010019">[-]</label><label class="expand" for="c-39010019">[2 more]</label></div><br/><div class="children"><div class="content">I prefer no images over IA stolen&#x2F;generated images.</div><br/><div id="39010088" class="c"><input type="checkbox" id="c-39010088" checked=""/><div class="controls bullet"><span class="by">jazzyjackson</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39010019">parent</a><span>|</span><a href="#39010400">next</a><span>|</span><label class="collapse" for="c-39010088">[-]</label><label class="expand" for="c-39010088">[1 more]</label></div><br/><div class="children"><div class="content">&gt; ...the Taft Test:<p>&gt; Does your page design improve when you replace every image with William Howard Taft?<p>&gt; If so, then, maybe all those images aren’t adding a lot to your article. At the very least, leave Taft there! You just admitted it looks better.<p><a href="https:&#x2F;&#x2F;idlewords.com&#x2F;talks&#x2F;website_obesity.htm" rel="nofollow">https:&#x2F;&#x2F;idlewords.com&#x2F;talks&#x2F;website_obesity.htm</a></div><br/></div></div></div></div></div></div><div id="39010400" class="c"><input type="checkbox" id="c-39010400" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009626">prev</a><span>|</span><a href="#39010985">next</a><span>|</span><label class="collapse" for="c-39010400">[-]</label><label class="expand" for="c-39010400">[1 more]</label></div><br/><div class="children"><div class="content">Whole Medium thing seems low effort. I hardly remember reading a well written article there.</div><br/></div></div><div id="39010985" class="c"><input type="checkbox" id="c-39010985" checked=""/><div class="controls bullet"><span class="by">danielovichdk</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39010400">prev</a><span>|</span><a href="#39010493">next</a><span>|</span><label class="collapse" for="c-39010985">[-]</label><label class="expand" for="c-39010985">[1 more]</label></div><br/><div class="children"><div class="content">Kinda like when someone pulls in FOSS code or a package without contributing or at least email the authors.</div><br/></div></div><div id="39010493" class="c"><input type="checkbox" id="c-39010493" checked=""/><div class="controls bullet"><span class="by">gcau</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39010985">prev</a><span>|</span><a href="#39009530">next</a><span>|</span><label class="collapse" for="c-39010493">[-]</label><label class="expand" for="c-39010493">[1 more]</label></div><br/><div class="children"><div class="content">It cheapens it, making it look like AI-generated seo-blog-spam. I&#x27;d rather a technical diagram or some plain icons, at least that would look tasteful.</div><br/></div></div><div id="39009530" class="c"><input type="checkbox" id="c-39009530" checked=""/><div class="controls bullet"><span class="by">azinman2</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39010493">prev</a><span>|</span><a href="#39011001">next</a><span>|</span><label class="collapse" for="c-39009530">[-]</label><label class="expand" for="c-39009530">[11 more]</label></div><br/><div class="children"><div class="content">Typically it’ll be in lieu of nothing or stock photography. Doesn’t it seem better than that?</div><br/><div id="39009543" class="c"><input type="checkbox" id="c-39009543" checked=""/><div class="controls bullet"><span class="by">dmart</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009530">parent</a><span>|</span><a href="#39009968">next</a><span>|</span><label class="collapse" for="c-39009543">[-]</label><label class="expand" for="c-39009543">[7 more]</label></div><br/><div class="children"><div class="content">Not really. I wish the trend of giant generic hero images on every blog post would go away, they almost never add any value. I think it was Medium that started the trend.</div><br/><div id="39009638" class="c"><input type="checkbox" id="c-39009638" checked=""/><div class="controls bullet"><span class="by">minimaxir</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009543">parent</a><span>|</span><a href="#39009562">next</a><span>|</span><label class="collapse" for="c-39009638">[-]</label><label class="expand" for="c-39009638">[4 more]</label></div><br/><div class="children"><div class="content">Unfortunately <i>all</i> social media sharing requires a thumbnail for easy clicking, no real way around it. (with Hacker News as the lone exception of course)<p>The default thumbnails in lieu of your own aren&#x27;t good.</div><br/><div id="39010564" class="c"><input type="checkbox" id="c-39010564" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009638">parent</a><span>|</span><a href="#39010461">next</a><span>|</span><label class="collapse" for="c-39010564">[-]</label><label class="expand" for="c-39010564">[1 more]</label></div><br/><div class="children"><div class="content">Use og:image then: <a href="https:&#x2F;&#x2F;ogp.me&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ogp.me&#x2F;</a></div><br/></div></div><div id="39010461" class="c"><input type="checkbox" id="c-39010461" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009638">parent</a><span>|</span><a href="#39010564">prev</a><span>|</span><a href="#39010164">next</a><span>|</span><label class="collapse" for="c-39010461">[-]</label><label class="expand" for="c-39010461">[1 more]</label></div><br/><div class="children"><div class="content">&gt; all social media sharing requires a thumbnail for easy clicking, no real way around it<p>This doesn&#x27;t mean you need a giant hero header, or an AI generated image, or even any images in your posts at all.</div><br/></div></div><div id="39010164" class="c"><input type="checkbox" id="c-39010164" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009638">parent</a><span>|</span><a href="#39010461">prev</a><span>|</span><a href="#39009562">next</a><span>|</span><label class="collapse" for="c-39010164">[-]</label><label class="expand" for="c-39010164">[1 more]</label></div><br/><div class="children"><div class="content">I’ll honestly take the “put some text in the thumbnail” trend that GitHub, Nuxt Content, etc all do, over a low-quality image.</div><br/></div></div></div></div><div id="39009562" class="c"><input type="checkbox" id="c-39009562" checked=""/><div class="controls bullet"><span class="by">iknowstuff</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009543">parent</a><span>|</span><a href="#39009638">prev</a><span>|</span><a href="#39009968">next</a><span>|</span><label class="collapse" for="c-39009562">[-]</label><label class="expand" for="c-39009562">[2 more]</label></div><br/><div class="children"><div class="content">They do add value, they make clicks more likely.</div><br/><div id="39011025" class="c"><input type="checkbox" id="c-39011025" checked=""/><div class="controls bullet"><span class="by">logifail</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009562">parent</a><span>|</span><a href="#39009968">next</a><span>|</span><label class="collapse" for="c-39011025">[-]</label><label class="expand" for="c-39011025">[1 more]</label></div><br/><div class="children"><div class="content">&gt; They do add value, they make clicks more likely<p>&quot;Making clicks more likely&quot; is a terrible measure of genuine value.<p>There are lots of images which will make people click, even if once they see your page they click &#x27;Back&#x27; a second later.  Our metrics are broken if we continue to attribute that click as &#x27;success&#x27;.</div><br/></div></div></div></div></div></div><div id="39009968" class="c"><input type="checkbox" id="c-39009968" checked=""/><div class="controls bullet"><span class="by">usrusr</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009530">parent</a><span>|</span><a href="#39009543">prev</a><span>|</span><a href="#39009547">next</a><span>|</span><label class="collapse" for="c-39009968">[-]</label><label class="expand" for="c-39009968">[1 more]</label></div><br/><div class="children"><div class="content">One is aesthetic filler that is true to its purpose of loosening up the typography of a wall of text. The other tends to be awkwardly clever on a level of awkward that was unknown to mankind until recently. I used to hate stock photography fillers just like everybody else, but now my preference is as clear as it would be surprising to past me.</div><br/></div></div><div id="39009547" class="c"><input type="checkbox" id="c-39009547" checked=""/><div class="controls bullet"><span class="by">i80and</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009530">parent</a><span>|</span><a href="#39009968">prev</a><span>|</span><a href="#39010541">next</a><span>|</span><label class="collapse" for="c-39009547">[-]</label><label class="expand" for="c-39009547">[1 more]</label></div><br/><div class="children"><div class="content">Genuinely it&#x27;s a downgrade in my opinion</div><br/></div></div><div id="39010541" class="c"><input type="checkbox" id="c-39010541" checked=""/><div class="controls bullet"><span class="by">happymellon</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39009530">parent</a><span>|</span><a href="#39009547">prev</a><span>|</span><a href="#39011001">next</a><span>|</span><label class="collapse" for="c-39010541">[-]</label><label class="expand" for="c-39010541">[1 more]</label></div><br/><div class="children"><div class="content">Considering it adds nothing but 5 megs of noise.<p>No.</div><br/></div></div></div></div><div id="39011001" class="c"><input type="checkbox" id="c-39011001" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009530">prev</a><span>|</span><a href="#39009703">next</a><span>|</span><label class="collapse" for="c-39011001">[-]</label><label class="expand" for="c-39011001">[1 more]</label></div><br/><div class="children"><div class="content">A smart guy (not me) put it like this:<p>&quot;to the trained eye you can already see that every single ai generated image is a picture of the same thing&quot;</div><br/></div></div><div id="39009703" class="c"><input type="checkbox" id="c-39009703" checked=""/><div class="controls bullet"><span class="by">ta8645</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39011001">prev</a><span>|</span><a href="#39010783">next</a><span>|</span><label class="collapse" for="c-39009703">[-]</label><label class="expand" for="c-39009703">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, the images attached to the article seemed great to me; they were colorful and fun.  I don&#x27;t see any reason to care who or what created them.</div><br/></div></div><div id="39010783" class="c"><input type="checkbox" id="c-39010783" checked=""/><div class="controls bullet"><span class="by">davidgerard</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39009703">prev</a><span>|</span><a href="#39010030">next</a><span>|</span><label class="collapse" for="c-39010783">[-]</label><label class="expand" for="c-39010783">[2 more]</label></div><br/><div class="children"><div class="content">exactly. It says &quot;I can&#x27;t be bothered producing this&quot; and I feel like, so why should I be bothered reading it?</div><br/><div id="39010799" class="c"><input type="checkbox" id="c-39010799" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39009513">root</a><span>|</span><a href="#39010783">parent</a><span>|</span><a href="#39010030">next</a><span>|</span><label class="collapse" for="c-39010799">[-]</label><label class="expand" for="c-39010799">[1 more]</label></div><br/><div class="children"><div class="content">Ah yes, let&#x27;s take the most uncharitable explanation and assume that&#x27;s the case.<p>Maybe they have no artistic ability of their own?  Maybe they just aren&#x27;t good at finding the kinds of images (that can be freely used without infringing on anyone&#x27;s copyright) that they need?<p>If it were me, and the guidance was &quot;never use AI generated images in your blog post&quot;, I would probably just not use any images at all.  Which I guess for some people would probably be best.  But personally I prefer walls of text to be broken up by... something.</div><br/></div></div></div></div><div id="39010030" class="c"><input type="checkbox" id="c-39010030" checked=""/><div class="controls bullet"><span class="by">Zetobal</span><span>|</span><a href="#39009513">parent</a><span>|</span><a href="#39010783">prev</a><span>|</span><a href="#39011056">next</a><span>|</span><label class="collapse" for="c-39010030">[-]</label><label class="expand" for="c-39010030">[1 more]</label></div><br/><div class="children"><div class="content">At least you now know which of your peers have no taste and strange beauty standards. Some images posted by my colleagues for everyone to see on LinkedIn look like sexist propaganda cartoons.<p>Stock images used to hide this &quot;quality&quot; better than I thought.</div><br/></div></div></div></div><div id="39011056" class="c"><input type="checkbox" id="c-39011056" checked=""/><div class="controls bullet"><span class="by">chucke1992</span><span>|</span><a href="#39009513">prev</a><span>|</span><a href="#39008360">next</a><span>|</span><label class="collapse" for="c-39011056">[-]</label><label class="expand" for="c-39011056">[1 more]</label></div><br/><div class="children"><div class="content">Personally I am curious how these features like virtual threads are tested when developed.</div><br/></div></div><div id="39008360" class="c"><input type="checkbox" id="c-39008360" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#39011056">prev</a><span>|</span><a href="#39010360">next</a><span>|</span><label class="collapse" for="c-39008360">[-]</label><label class="expand" for="c-39008360">[9 more]</label></div><br/><div class="children"><div class="content">It is a known caveat that virtual threads do not work well with long running synchronization by pinning the thread. That unfortunately means that for many applications it may be premature to adopt them, but it is mature enough for broader evaluation by the libraries and frameworks. The Java team provided a status of their efforts recently [1].<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WoQJnnMIlFY&amp;t=421s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WoQJnnMIlFY&amp;t=421s</a></div><br/><div id="39009726" class="c"><input type="checkbox" id="c-39009726" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#39008360">parent</a><span>|</span><a href="#39010648">next</a><span>|</span><label class="collapse" for="c-39009726">[-]</label><label class="expand" for="c-39009726">[3 more]</label></div><br/><div class="children"><div class="content">Sorry, the first sentence is a mis-informing wording.<p>The `synchronized` pins the thread only when from within of the `synchronized` the program calls a blocking operation that would normally unmount the virtual thread, like blockingQueue.take() or similar. (Which is not a sane coding practice). It&#x27;s because the unmounting, as it&#x27;s implemented today, does not work well with synchronized.<p>It&#x27;s better if people read JEP 444 than rely on forum comments, to avoid being misinformed.<p>Speaking of long-running - even without synchronized, a long running code keeps the native thread occupied, until some blocking operation is called. So an endless loop that does not call a virtual-thread-ready blocking operation will occupy the native thread forever.<p>Java virtual threads are a kind of cooperative multithreading - another virtual thread only gets chance to kick-in when some current virtual thread reaches specific blocking operations. In contrast to preemptive multi-threading with native threads.<p>So I agree with your conclusion. Virtual threads can not  (yet?) be blindly used as a drop-in replacement of native threads for existing code. And the new code needs to take their specifics into account.<p>BTW, another method I discovered to block the native carrier thread that executes a virtual thread is to call blocking reading through FileInputStream, for example reading from the console. The FileInputStream does not implement virtual thread parking at all (yet?).</div><br/><div id="39011045" class="c"><input type="checkbox" id="c-39011045" checked=""/><div class="controls bullet"><span class="by">mike_hearn</span><span>|</span><a href="#39008360">root</a><span>|</span><a href="#39009726">parent</a><span>|</span><a href="#39009813">next</a><span>|</span><label class="collapse" for="c-39011045">[-]</label><label class="expand" for="c-39011045">[1 more]</label></div><br/><div class="children"><div class="content">The issue in this case isn&#x27;t actually the synchronized block. The thread is blocked on Object.wait, which releases the monitor before sleeping. The problem is that Object.wait is implemented in native code still, which pins the thread. The idea is that these days wait isn&#x27;t exactly deprecated but there are better concurrency tools available, so they upgraded those first, leaving the Java 1 style concurrency tools for later. And Java 1 style concurrency has been improved on but is hardly insane, it can work well enough in many situations and is sometimes the basis for higher level concurrency utilities.</div><br/></div></div><div id="39009813" class="c"><input type="checkbox" id="c-39009813" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#39008360">root</a><span>|</span><a href="#39009726">parent</a><span>|</span><a href="#39011045">prev</a><span>|</span><a href="#39010648">next</a><span>|</span><label class="collapse" for="c-39009813">[-]</label><label class="expand" for="c-39009813">[1 more]</label></div><br/><div class="children"><div class="content">By long running I just meant anything that was not fast compute. I was more focused on finding the reference link so I agree my wording wasn’t clear.<p>Go started without preemption and added it later. The Java team has indicated a similar path, so we might see that tackled in the future. I think they could do that using safe points or JEP 312‘s handshakes, so it’s not infeasible.<p>For file io they wanted to explore io_ring and they might need to add a loom friendly resolver for JEP 418. There is just so much left, like scalable timers, that I think it’s going to be a long time until VTs will be a good default choice.</div><br/></div></div></div></div><div id="39010648" class="c"><input type="checkbox" id="c-39010648" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#39008360">parent</a><span>|</span><a href="#39009726">prev</a><span>|</span><a href="#39008521">next</a><span>|</span><label class="collapse" for="c-39010648">[-]</label><label class="expand" for="c-39010648">[3 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WoQJnnMIlFY&amp;t=260s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=WoQJnnMIlFY&amp;t=260s</a><p>To get the whole context, so virtual threads are unusable?<p>What holds a monitor by default and is there a workaround?<p>Found more:<p><pre><code>    A virtual thread cannot be unmounted during blocking operations when it is pinned to its carrier. A virtual thread is pinned in the following situations:

    The virtual thread runs code inside a synchronized block or method

    The virtual thread runs a native method or a foreign function (see Foreign Function and Memory API)
</code></pre>
For those those that don&#x27;t know what this means: Blocking network TCP IO needs a sychronized block to work = you can&#x27;t use virtual threads for networking. I wish they formulated it like that from the start!<p>Atleast now we know what they meant with don&#x27;t use virtual threads for anything but tasks &lt;- not blocking IO with synchronization!<p>So for now manual NIO is still the king of the hill.<p>We are reaching peak humanity levels of complexity!</div><br/><div id="39010759" class="c"><input type="checkbox" id="c-39010759" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#39008360">root</a><span>|</span><a href="#39010648">parent</a><span>|</span><a href="#39008521">next</a><span>|</span><label class="collapse" for="c-39010759">[-]</label><label class="expand" for="c-39010759">[2 more]</label></div><br/><div class="children"><div class="content">Perhaps it’s better to say that they are not yet general purpose. There are many caveats which need to be resolved and are being actively worked on. I would not use them broadly yet, but that could change rapidly.<p>A monitor will pin the VT to the carrier thread. That can have surprising incompatibility in the current jdk. Soon these footguns will be fixed and you can use them worry free.<p><a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;java&#x2F;comments&#x2F;1512xuo&#x2F;virtual_threads_interesting_deadlock&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;java&#x2F;comments&#x2F;1512xuo&#x2F;virtual_threa...</a></div><br/><div id="39010923" class="c"><input type="checkbox" id="c-39010923" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#39008360">root</a><span>|</span><a href="#39010759">parent</a><span>|</span><a href="#39008521">next</a><span>|</span><label class="collapse" for="c-39010923">[-]</label><label class="expand" for="c-39010923">[1 more]</label></div><br/><div class="children"><div class="content">Well see, if Patricio Chilano hasn&#x27;t fixed this in a year I would start to get VERY worried.<p>Moving monitors into Java is not a good solution, like the long solution they are working on.<p>Java should be the API not the implementation!</div><br/></div></div></div></div></div></div><div id="39008521" class="c"><input type="checkbox" id="c-39008521" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39008360">parent</a><span>|</span><a href="#39010648">prev</a><span>|</span><a href="#39010360">next</a><span>|</span><label class="collapse" for="c-39008521">[-]</label><label class="expand" for="c-39008521">[2 more]</label></div><br/><div class="children"><div class="content">The problem is not “long running synchronization” but synchronization that relies on stuff running outside of virtual threads to unblock itself. There is no issue beyond performance if you perform filesystem operations in your mounted state.</div><br/><div id="39008560" class="c"><input type="checkbox" id="c-39008560" checked=""/><div class="controls bullet"><span class="by">NovaX</span><span>|</span><a href="#39008360">root</a><span>|</span><a href="#39008521">parent</a><span>|</span><a href="#39010360">next</a><span>|</span><label class="collapse" for="c-39008560">[-]</label><label class="expand" for="c-39008560">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I wasn’t being particular about this exact issue and was generalizing about synchronization pinning the carrier. A deadlock is trivial once the implications of that are thought through.<p><a href="https:&#x2F;&#x2F;mail.openjdk.org&#x2F;pipermail&#x2F;loom-dev&#x2F;2023-July&#x2F;005993.html" rel="nofollow">https:&#x2F;&#x2F;mail.openjdk.org&#x2F;pipermail&#x2F;loom-dev&#x2F;2023-July&#x2F;005993...</a></div><br/></div></div></div></div></div></div><div id="39010360" class="c"><input type="checkbox" id="c-39010360" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#39008360">prev</a><span>|</span><a href="#39009145">next</a><span>|</span><label class="collapse" for="c-39010360">[-]</label><label class="expand" for="c-39010360">[1 more]</label></div><br/><div class="children"><div class="content">The warning shots across the bow where heard with this statement from the devs:<p>&quot;Don&#x27;t replace platform&#x2F;native threads with virtual ones, replace tasks (without further explanation) instead&quot;?!<p>Combine that with the fact that they chose to implement the scheduler in Java instead of C(++) and you&#x27;re set for performance problems.<p>Remember that NIO took from 1.5 to 1.7 to be usable&#x2F;performant and that was native!<p>Edit: Finally figured out why: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39010648">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39010648</a></div><br/></div></div><div id="39009145" class="c"><input type="checkbox" id="c-39009145" checked=""/><div class="controls bullet"><span class="by">vvern</span><span>|</span><a href="#39010360">prev</a><span>|</span><a href="#39008497">next</a><span>|</span><label class="collapse" for="c-39009145">[-]</label><label class="expand" for="c-39009145">[4 more]</label></div><br/><div class="children"><div class="content">Go has a mechanism to spawn a new thread (m in ho runtime parlance) if it thinks one of its threads might be blocked in a cgo (go’s “native function” equivalent). That prevents stuff like this.</div><br/><div id="39009502" class="c"><input type="checkbox" id="c-39009502" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#39009145">parent</a><span>|</span><a href="#39009519">next</a><span>|</span><label class="collapse" for="c-39009502">[-]</label><label class="expand" for="c-39009502">[2 more]</label></div><br/><div class="children"><div class="content">Java does the same for Object.wait(), only the number of such compensating threads is limited by default, but can be extended via config option. They have exhausted the default number of compensating threads, I think.<p>And they are mistaken to call this situation a &quot;pinning&quot;<p>JEP 444:<p>&gt; The vast majority of blocking operations in the JDK will unmount the virtual thread, freeing its carrier and the underlying OS thread to take on new work. However, some blocking operations in the JDK do not unmount the virtual thread, and thus block both its carrier and the underlying OS thread. This is because of limitations at either the OS level (e.g., many filesystem operations) or the JDK level (e.g., Object.wait()). The implementations of these blocking operations compensate for the capture of the OS thread by temporarily expanding the parallelism of the scheduler. Consequently, the number of platform threads in the scheduler&#x27;s ForkJoinPool may temporarily exceed the number of available processors. The maximum number of platform threads available to the scheduler can be tuned with the system property jdk.virtualThreadScheduler.maxPoolSize.<p>(In my testing the default ForkJoinPool limit was 256)<p>So theoretically they could have extended the jdk.virtualThreadScheduler.maxPoolSize to a number sufficient for the use case. Although their workaround with semaphores is probably more reliable - no need to guess the sufficient number.<p>The situation with Object.wait() is not what JEP 444 calls &quot;pinning&quot;. The &quot;pinning&quot; happens, for example, when one calls `syncronized(....) {blockingQueue.take()}`, which is not sane coding, BTW. In this case the native thread is blocked and is not compensated by another thread - much worse than the Object.wait(). The number of native threads that run virtual threads is equal to the number of CPUs by default, so &quot;pinning&quot; immediately makes one CPU unavailable to the virtual threads of the application.<p>All those issues are temporarily, as I understand. The JDK team works for fix Object.wait(), synchronized, etc.</div><br/><div id="39010026" class="c"><input type="checkbox" id="c-39010026" checked=""/><div class="controls bullet"><span class="by">delusional</span><span>|</span><a href="#39009145">root</a><span>|</span><a href="#39009502">parent</a><span>|</span><a href="#39009519">next</a><span>|</span><label class="collapse" for="c-39010026">[-]</label><label class="expand" for="c-39010026">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The situation with Object.wait() is not what JEP 444 calls &quot;pinning&quot;. The &quot;pinning&quot; happens, for example, when one calls `syncronized(....) {blockingQueue.take()}` [...]<p>To call Object.wait() you need to own the objects monitor, which would imply that your code would actually look like `synchronized(....) {Object.wait()}` in which case you would indeed be pinned.</div><br/></div></div></div></div><div id="39009519" class="c"><input type="checkbox" id="c-39009519" checked=""/><div class="controls bullet"><span class="by">neonsunset</span><span>|</span><a href="#39009145">parent</a><span>|</span><a href="#39009502">prev</a><span>|</span><a href="#39008497">next</a><span>|</span><label class="collapse" for="c-39009519">[-]</label><label class="expand" for="c-39009519">[1 more]</label></div><br/><div class="children"><div class="content">So does C# with active blocking detection (which injects threads to counteract this) and hill climbing algorithm to scale threadpool threads automatically.</div><br/></div></div></div></div><div id="39008497" class="c"><input type="checkbox" id="c-39008497" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39009145">prev</a><span>|</span><a href="#39008493">next</a><span>|</span><label class="collapse" for="c-39008497">[-]</label><label class="expand" for="c-39008497">[8 more]</label></div><br/><div class="children"><div class="content">This is a common problem when migrating a system from threads to virtual threads. In general, using primitives which block the current thread and prevent forward progress can quickly lead to deadlocks. It’s a hard issue to catch because in the past usually this would get “solved” by spawning a new thread to complete the task but in a world with virtual threads the runtime is usually reluctant to spawn more threads, so there’s nothing that can service more work if you’ve blocked all the threads.</div><br/><div id="39008974" class="c"><input type="checkbox" id="c-39008974" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#39008497">parent</a><span>|</span><a href="#39008493">next</a><span>|</span><label class="collapse" for="c-39008974">[-]</label><label class="expand" for="c-39008974">[7 more]</label></div><br/><div class="children"><div class="content">Is that all that&#x27;s happening here? There&#x27;s an implicit limit on real threads, where before it was unlimited by virtue of not using the virtual thread&#x27;s limited pool?<p>If it doesn&#x27;t spawn threads when <i>all</i> of them are blocked, that seems kinda dumb.  And a severe change in semantics.  It can be <i>conservative</i> and try running unpinned ones on fewer threads and shuffle them around and slowly spawn more to ensure eventual progress, which would mean a possibly significant optimization problem, but a hard cap impacts correctness.</div><br/><div id="39010536" class="c"><input type="checkbox" id="c-39010536" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39008497">root</a><span>|</span><a href="#39008974">parent</a><span>|</span><a href="#39009592">next</a><span>|</span><label class="collapse" for="c-39010536">[-]</label><label class="expand" for="c-39010536">[1 more]</label></div><br/><div class="children"><div class="content">Virtual threads were never intended as a drop-in replacement for platform threads. They offer the same API, but they are for different usage scenarios.<p>If you have lots of blocking I&#x2F;O (meaning: waiting for things happening on other threads or processes, which offers scheduling opportunities), use virtual threads. If you compute or call native code, keep using platform threads.<p>The issue with synchronized is eventually going to be resolved. But long-running computations (sorting, parsing, number crunching, etc) or native calls must also in the future be offloaded to an ExecutorService with platform threads.</div><br/></div></div><div id="39009592" class="c"><input type="checkbox" id="c-39009592" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#39008497">root</a><span>|</span><a href="#39008974">parent</a><span>|</span><a href="#39010536">prev</a><span>|</span><a href="#39008493">next</a><span>|</span><label class="collapse" for="c-39009592">[-]</label><label class="expand" for="c-39009592">[5 more]</label></div><br/><div class="children"><div class="content">My long held belief: green&#x2F;user-level&#x2F;M:N threading schemes never work at first, and only work reliably after extreme effort has been put into fixing all the cases where blocking code gets called underneath. afaik there are only two modern working implementations: golang and erlang. This article is consistent with that belief.</div><br/><div id="39009698" class="c"><input type="checkbox" id="c-39009698" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#39008497">root</a><span>|</span><a href="#39009592">parent</a><span>|</span><a href="#39010416">next</a><span>|</span><label class="collapse" for="c-39009698">[-]</label><label class="expand" for="c-39009698">[2 more]</label></div><br/><div class="children"><div class="content">There are many other implementations, although in less popular languages.<p>The trick is to include the green threads from the start, so there are no libraries that depend on real threading. That&#x27;s why Go and Erlang are so successful.</div><br/><div id="39010824" class="c"><input type="checkbox" id="c-39010824" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39008497">root</a><span>|</span><a href="#39009698">parent</a><span>|</span><a href="#39010416">next</a><span>|</span><label class="collapse" for="c-39010824">[-]</label><label class="expand" for="c-39010824">[1 more]</label></div><br/><div class="children"><div class="content">The funny thing is that Java did have green threads back in v1.1, but they were dropped in v1.3.<p>That doesn&#x27;t invalidate your point; more than 20 years of Java practice has focused on making things work well for platform threads.</div><br/></div></div></div></div><div id="39010416" class="c"><input type="checkbox" id="c-39010416" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#39008497">root</a><span>|</span><a href="#39009592">parent</a><span>|</span><a href="#39009698">prev</a><span>|</span><a href="#39010835">next</a><span>|</span><label class="collapse" for="c-39010416">[-]</label><label class="expand" for="c-39010416">[1 more]</label></div><br/><div class="children"><div class="content">Go suffers the same issue when calling into native code, that is why it has APIs to deal with it.<p>For example, <a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;runtime#LockOSThread" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;runtime#LockOSThread</a></div><br/></div></div><div id="39010835" class="c"><input type="checkbox" id="c-39010835" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#39008497">root</a><span>|</span><a href="#39009592">parent</a><span>|</span><a href="#39010416">prev</a><span>|</span><a href="#39008493">next</a><span>|</span><label class="collapse" for="c-39010835">[-]</label><label class="expand" for="c-39010835">[1 more]</label></div><br/><div class="children"><div class="content">It works well enough in Python and NodeJS.</div><br/></div></div></div></div></div></div></div></div><div id="39008493" class="c"><input type="checkbox" id="c-39008493" checked=""/><div class="controls bullet"><span class="by">papercrane</span><span>|</span><a href="#39008497">prev</a><span>|</span><a href="#39009260">next</a><span>|</span><label class="collapse" for="c-39008493">[-]</label><label class="expand" for="c-39008493">[5 more]</label></div><br/><div class="children"><div class="content">Curious if you considered switching to a different connection pooling library. These days I usually use HikariCP which is fast an actively maintained. c3p0 hasn&#x27;t had any activity for years, I&#x27;m not sure if it&#x27;s still maintained.</div><br/><div id="39010614" class="c"><input type="checkbox" id="c-39010614" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39008493">parent</a><span>|</span><a href="#39009961">next</a><span>|</span><label class="collapse" for="c-39010614">[-]</label><label class="expand" for="c-39010614">[1 more]</label></div><br/><div class="children"><div class="content">Crucially, c3p0 will probably never see the `synchronized` blocks being replaced by reentrant locks. Since LTS offers exist for Java 21, many libraries might actually do that. But I actually hope that the ecosystem resists, which would force virtual thread users suffering from this problem to upgrade soon.</div><br/></div></div><div id="39009961" class="c"><input type="checkbox" id="c-39009961" checked=""/><div class="controls bullet"><span class="by">rickette</span><span>|</span><a href="#39008493">parent</a><span>|</span><a href="#39010614">prev</a><span>|</span><a href="#39008829">next</a><span>|</span><label class="collapse" for="c-39009961">[-]</label><label class="expand" for="c-39009961">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, Hikari is the go to connection pool for some years now. It&#x27;s even the default when running Spring Boot.</div><br/></div></div><div id="39008829" class="c"><input type="checkbox" id="c-39008829" checked=""/><div class="controls bullet"><span class="by">eivanov89</span><span>|</span><a href="#39008493">parent</a><span>|</span><a href="#39009961">prev</a><span>|</span><a href="#39009610">next</a><span>|</span><label class="collapse" for="c-39008829">[-]</label><label class="expand" for="c-39008829">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps we&#x27;ll give HikariCP a chance. However, please keep in mind that the goal of the YDB team is to enhance database performance. We needed virtual threads to make TPC-C efficient enough to generate a reasonable load on a modest amount of hardware.</div><br/></div></div><div id="39009610" class="c"><input type="checkbox" id="c-39009610" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#39008493">parent</a><span>|</span><a href="#39008829">prev</a><span>|</span><a href="#39009260">next</a><span>|</span><label class="collapse" for="c-39009610">[-]</label><label class="expand" for="c-39009610">[1 more]</label></div><br/><div class="children"><div class="content">Been ages since I’ve touched it but back in 2017-2018 I had some fun integrating HikariCP in place of c3p0 in some Clojure projects and it was more performant.</div><br/></div></div></div></div><div id="39009260" class="c"><input type="checkbox" id="c-39009260" checked=""/><div class="controls bullet"><span class="by">moonchild</span><span>|</span><a href="#39008493">prev</a><span>|</span><a href="#39008299">next</a><span>|</span><label class="collapse" for="c-39009260">[-]</label><label class="expand" for="c-39009260">[7 more]</label></div><br/><div class="children"><div class="content">I am extremely confused.<p>&gt; There are two scenarios in which a virtual thread cannot be unmounted during blocking operations because it is pinned to its carrier:<p>&gt; When it executes code inside a synchronized block or method<p>Isn&#x27;t &#x27;synchronized&#x27; effectively sugar for taking a kind of lock?  Why can&#x27;t it be treated uniformly by the scheduler?</div><br/><div id="39009606" class="c"><input type="checkbox" id="c-39009606" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#39009260">parent</a><span>|</span><a href="#39009357">next</a><span>|</span><label class="collapse" for="c-39009606">[-]</label><label class="expand" for="c-39009606">[1 more]</label></div><br/><div class="children"><div class="content">The `synchronized` by itself does not cause any problems for virtual threads.<p>Only when one calls a blocking operation from synchronized, the thread is not unmounted. E.g. `synchronized (...) {blockingQueue.take()}`. Note that this is not a sane coding practice. (Calling a potentially long operation from within synchronized. The blockingQueue.take() does not need to be wrapped into synchronized. It has synchronization inside and plays well with virtual threads. Only when wrapped into the synchronized, the current implementation can not unmount the virtual thread.).<p>The JDK team works to remove quirks like pinning in the future versions.</div><br/></div></div><div id="39009357" class="c"><input type="checkbox" id="c-39009357" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#39009260">parent</a><span>|</span><a href="#39009606">prev</a><span>|</span><a href="#39008299">next</a><span>|</span><label class="collapse" for="c-39009357">[-]</label><label class="expand" for="c-39009357">[5 more]</label></div><br/><div class="children"><div class="content">No, synchronized is a very primitive lock implementation compared to what&#x27;s available in java.util.concurrent.Locks.<p>However, it&#x27;s built directly into the JVM specification, so it&#x27;s difficult to change while keeping compatibility, while j.u.c.Locks is just a library. In other words, they can&#x27;t change synchronized schematic, so they created j.u.c.Locks as a replacement.</div><br/><div id="39010143" class="c"><input type="checkbox" id="c-39010143" checked=""/><div class="controls bullet"><span class="by">altfredd</span><span>|</span><a href="#39009260">root</a><span>|</span><a href="#39009357">parent</a><span>|</span><a href="#39010625">next</a><span>|</span><label class="collapse" for="c-39010143">[-]</label><label class="expand" for="c-39010143">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s difficult to change while keeping compatibility<p>Actually, it is trivial to change. Just embed a ReentrantLock into every object and rewrite all calls to &quot;synchronized&quot;&#x2F;&quot;Object.wait&quot; to use that lock.<p>Unfortunately, this would result in a bit of performance regression (increasing per-object memory footprint). To solve that would require turning ReentrantLock into a magical intrinsic, fully integrated with lock bytes in the object header. Which is actually not that hard either — other runtimes like Golang or Android VM solve problems like this on daily basis. Oracle, however…</div><br/><div id="39010666" class="c"><input type="checkbox" id="c-39010666" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39009260">root</a><span>|</span><a href="#39010143">parent</a><span>|</span><a href="#39010625">next</a><span>|</span><label class="collapse" for="c-39010666">[-]</label><label class="expand" for="c-39010666">[1 more]</label></div><br/><div class="children"><div class="content">... was taking years to land Project Loom. So long that people started calling it vaporware. Project Valhalla is still regarded as such by many. It <i>had</i> to be shipped as soon as it was usable, even though a few rough edges remain that really ought to be deburred.<p>As you indicate, the complexity lies in not burning too many bridges with existing users and use cases. This is something that Android regularly does and which Go never really had to do due to its shorter history and up-front design.</div><br/></div></div></div></div><div id="39010625" class="c"><input type="checkbox" id="c-39010625" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39009260">root</a><span>|</span><a href="#39009357">parent</a><span>|</span><a href="#39010143">prev</a><span>|</span><a href="#39008299">next</a><span>|</span><label class="collapse" for="c-39010625">[-]</label><label class="expand" for="c-39010625">[2 more]</label></div><br/><div class="children"><div class="content">The j.u.c.*Locks exist for a very long time already.</div><br/><div id="39010757" class="c"><input type="checkbox" id="c-39010757" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#39009260">root</a><span>|</span><a href="#39010625">parent</a><span>|</span><a href="#39008299">next</a><span>|</span><label class="collapse" for="c-39010757">[-]</label><label class="expand" for="c-39010757">[1 more]</label></div><br/><div class="children"><div class="content">Since Java 1.5 in 2004. Twenty years this year. Before that it existed as a separate library developed by Doug Lee. I remember using that library before Java 1.5 was released. There is quite a bit of Java code out there that predates that of course. Also, lots of people continued to not grasp the essentials of that library and stuck with the primitives they knew. So there&#x27;s a lot of code there with synchronized blocks post Java 1.5 instead of the more robust concurrency primitives that came with the java.util.concurrent package.</div><br/></div></div></div></div></div></div></div></div><div id="39008299" class="c"><input type="checkbox" id="c-39008299" checked=""/><div class="controls bullet"><span class="by">taspeotis</span><span>|</span><a href="#39009260">prev</a><span>|</span><a href="#39008863">next</a><span>|</span><label class="collapse" for="c-39008299">[-]</label><label class="expand" for="c-39008299">[2 more]</label></div><br/><div class="children"><div class="content">Did they get a deadlock again? <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38939165">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=38939165</a></div><br/><div id="39008336" class="c"><input type="checkbox" id="c-39008336" checked=""/><div class="controls bullet"><span class="by">eivanov89</span><span>|</span><a href="#39008299">parent</a><span>|</span><a href="#39008863">next</a><span>|</span><label class="collapse" for="c-39008336">[-]</label><label class="expand" for="c-39008336">[1 more]</label></div><br/><div class="children"><div class="content">Haha, but quite frankly we had one more in TPC-C for YDB. But unrelated to the virtual threads.</div><br/></div></div></div></div><div id="39010415" class="c"><input type="checkbox" id="c-39010415" checked=""/><div class="controls bullet"><span class="by">DeathArrow</span><span>|</span><a href="#39008863">prev</a><span>|</span><a href="#39008410">next</a><span>|</span><label class="collapse" for="c-39010415">[-]</label><label class="expand" for="c-39010415">[2 more]</label></div><br/><div class="children"><div class="content">Why dining philosophers from the image have more than two hands?</div><br/><div id="39010505" class="c"><input type="checkbox" id="c-39010505" checked=""/><div class="controls bullet"><span class="by">isoprophlex</span><span>|</span><a href="#39010415">parent</a><span>|</span><a href="#39008410">next</a><span>|</span><label class="collapse" for="c-39010505">[-]</label><label class="expand" for="c-39010505">[1 more]</label></div><br/><div class="children"><div class="content">Because you&#x27;re reading a low-effort Medium webshit with AI generated images</div><br/></div></div></div></div><div id="39008410" class="c"><input type="checkbox" id="c-39008410" checked=""/><div class="controls bullet"><span class="by">xyst</span><span>|</span><a href="#39010415">prev</a><span>|</span><a href="#39008796">next</a><span>|</span><label class="collapse" for="c-39008410">[-]</label><label class="expand" for="c-39008410">[3 more]</label></div><br/><div class="children"><div class="content">Concurrency, parallelism. These are among the most misunderstood concepts in programming&#x2F;software development.<p>TLS (especially mutual TLS) and Oauth also join this club.</div><br/><div id="39008977" class="c"><input type="checkbox" id="c-39008977" checked=""/><div class="controls bullet"><span class="by">motoboi</span><span>|</span><a href="#39008410">parent</a><span>|</span><a href="#39008796">next</a><span>|</span><label class="collapse" for="c-39008977">[-]</label><label class="expand" for="c-39008977">[2 more]</label></div><br/><div class="children"><div class="content">Interestingly enough, I love both mutual-TLS and OAUTH (especially OIDC).</div><br/><div id="39010116" class="c"><input type="checkbox" id="c-39010116" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#39008410">root</a><span>|</span><a href="#39008977">parent</a><span>|</span><a href="#39008796">next</a><span>|</span><label class="collapse" for="c-39010116">[-]</label><label class="expand" for="c-39010116">[1 more]</label></div><br/><div class="children"><div class="content">Why is that interesting?</div><br/></div></div></div></div></div></div><div id="39008796" class="c"><input type="checkbox" id="c-39008796" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#39008410">prev</a><span>|</span><a href="#39008502">next</a><span>|</span><label class="collapse" for="c-39008796">[-]</label><label class="expand" for="c-39008796">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if HikariCP, currently the best Java DB Connection Pooling library, suffer the same issue as c3p0.</div><br/></div></div><div id="39008502" class="c"><input type="checkbox" id="c-39008502" checked=""/><div class="controls bullet"><span class="by">jake_morrison</span><span>|</span><a href="#39008796">prev</a><span>|</span><a href="#39008219">next</a><span>|</span><label class="collapse" for="c-39008502">[-]</label><label class="expand" for="c-39008502">[5 more]</label></div><br/><div class="children"><div class="content">Erlang is based on virtual threads (confusingly called processes).
The Erlang virtual machine schedules them on OS threads.
Erlang processes communicate using message passing, preventing deadlocks.
You can use millions of Erlang processes without problems, e.g., to handle millions of Elixir LiveView sessions.</div><br/><div id="39008902" class="c"><input type="checkbox" id="c-39008902" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#39008502">parent</a><span>|</span><a href="#39008645">next</a><span>|</span><label class="collapse" for="c-39008902">[-]</label><label class="expand" for="c-39008902">[1 more]</label></div><br/><div class="children"><div class="content">Erlang has the advantage that it was built around processes and is effectively preemptive. Processes can be descheduled anytime they make a function call or use receive to get or wait for messages and being a functional language, you have a finite amount of instructions before calling a function.<p>Other languages adding virtual threads later in life don&#x27;t have the same ability to feel preemptive. Although I think someone said Java has a nice trick or two?<p>Anyway, if all the virtual threads seem preemptive, you won&#x27;t have the case that your limited number of actual threads are waiting on locks and not yielding --- all Erlang processes yield eventually; usually in a fairly short time frame.</div><br/></div></div><div id="39008645" class="c"><input type="checkbox" id="c-39008645" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39008502">parent</a><span>|</span><a href="#39008902">prev</a><span>|</span><a href="#39010127">next</a><span>|</span><label class="collapse" for="c-39008645">[-]</label><label class="expand" for="c-39008645">[2 more]</label></div><br/><div class="children"><div class="content">You can have deadlock in Erlang, it&#x27;s just a bit harder. It happens when two processes are both waiting on the other to send them a message which is analogous to two threads each waiting for a mutex the other holds. The same thing can happen in Go with its channels, another message passing based concurrency control mechanism.</div><br/><div id="39008958" class="c"><input type="checkbox" id="c-39008958" checked=""/><div class="controls bullet"><span class="by">jake_morrison</span><span>|</span><a href="#39008502">root</a><span>|</span><a href="#39008645">parent</a><span>|</span><a href="#39010127">next</a><span>|</span><label class="collapse" for="c-39008958">[-]</label><label class="expand" for="c-39008958">[1 more]</label></div><br/><div class="children"><div class="content">Sure, you can make deadlocks in any language, but it&#x27;s uncommon in Erlang.
Shared state is the exception, and message passing means that things that manage state, such as gen_servers, only process one message at a time from their inbox.<p>Contrast this with languages like Java where every object is a potential concurrency problem. Or the 10+ years of trying to make Python async (see Twisted).</div><br/></div></div></div></div><div id="39010127" class="c"><input type="checkbox" id="c-39010127" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#39008502">parent</a><span>|</span><a href="#39008645">prev</a><span>|</span><a href="#39008219">next</a><span>|</span><label class="collapse" for="c-39010127">[-]</label><label class="expand" for="c-39010127">[1 more]</label></div><br/><div class="children"><div class="content">This feels like something I could read on Wikipedia about Erlang, how does this add anything to the topic?</div><br/></div></div></div></div><div id="39008219" class="c"><input type="checkbox" id="c-39008219" checked=""/><div class="controls bullet"><span class="by">oldgradstudent</span><span>|</span><a href="#39008502">prev</a><span>|</span><a href="#39008330">next</a><span>|</span><label class="collapse" for="c-39008219">[-]</label><label class="expand" for="c-39008219">[25 more]</label></div><br/><div class="children"><div class="content">Java virtual threads did not cause a deadlock here.<p>The deadlock was a usage error.<p>A better title would be: Naively switching to Java virtual threads caused a deadlock in TPC-C for Progress SQL.</div><br/><div id="39009222" class="c"><input type="checkbox" id="c-39009222" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#39008219">parent</a><span>|</span><a href="#39008323">next</a><span>|</span><label class="collapse" for="c-39009222">[-]</label><label class="expand" for="c-39009222">[1 more]</label></div><br/><div class="children"><div class="content">Submitted title was &quot;Java virtual threads caused a deadlock in TPC-C for PostgreSQL&quot;. We&#x27;ve reverted it now to the article&#x27;s own title (truncated to fit HN&#x27;s 80 char limit).<p>&quot;<i>Please use the original title, unless it is misleading or linkbait; don&#x27;t editorialize.</i>&quot; - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;newsguidelines.html</a></div><br/></div></div><div id="39008323" class="c"><input type="checkbox" id="c-39008323" checked=""/><div class="controls bullet"><span class="by">eivanov89</span><span>|</span><a href="#39008219">parent</a><span>|</span><a href="#39009222">prev</a><span>|</span><a href="#39008310">next</a><span>|</span><label class="collapse" for="c-39008323">[-]</label><label class="expand" for="c-39008323">[6 more]</label></div><br/><div class="children"><div class="content">I would like to reply with a quote of sir Tony Hoare&#x27;s 1980 ACM Turing Award Lecture: &quot;There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies&quot;.</div><br/><div id="39008372" class="c"><input type="checkbox" id="c-39008372" checked=""/><div class="controls bullet"><span class="by">adra</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008323">parent</a><span>|</span><a href="#39008310">next</a><span>|</span><label class="collapse" for="c-39008372">[-]</label><label class="expand" for="c-39008372">[5 more]</label></div><br/><div class="children"><div class="content">This one was a very large caveat pointed out loudly every time the feature was mentioned to the community. So, yes the limitation&#x2F;flaw was very well known and is ideally going to be addressed in a future JDK release.</div><br/><div id="39009942" class="c"><input type="checkbox" id="c-39009942" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008372">parent</a><span>|</span><a href="#39008310">next</a><span>|</span><label class="collapse" for="c-39009942">[-]</label><label class="expand" for="c-39009942">[4 more]</label></div><br/><div class="children"><div class="content">&gt; This one was a very large caveat pointed out loudly every time the feature was mentioned to the community.<p>It really wasn&#x27;t. There were people on here, including Oracle employees, claiming that the virtual thread implementation was a drop-in replacement that would work (not necessarily perform better, but work) in all cases.</div><br/><div id="39010725" class="c"><input type="checkbox" id="c-39010725" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39009942">parent</a><span>|</span><a href="#39010778">next</a><span>|</span><label class="collapse" for="c-39010725">[-]</label><label class="expand" for="c-39010725">[2 more]</label></div><br/><div class="children"><div class="content">And it indeed does in common usage scenarios. And also in this case once the issue with `synchronized` is resolved. After all, this is a <i>benchmark</i> and it&#x27;s not surprising that one of the limitations of the design was hit.</div><br/><div id="39010908" class="c"><input type="checkbox" id="c-39010908" checked=""/><div class="controls bullet"><span class="by">kelnos</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39010725">parent</a><span>|</span><a href="#39010778">next</a><span>|</span><label class="collapse" for="c-39010908">[-]</label><label class="expand" for="c-39010908">[1 more]</label></div><br/><div class="children"><div class="content">&quot;common usage scenarios&quot; != &quot;in all cases&quot;.<p>I don&#x27;t know if those Oracle employees actually did outright say -- or even imply -- &quot;in all cases&quot; as the GP asserted, but if they did, then &quot;only&quot; working in &quot;common usage scenarios&quot; would definitely be overselling the feature.</div><br/></div></div></div></div><div id="39010778" class="c"><input type="checkbox" id="c-39010778" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39009942">parent</a><span>|</span><a href="#39010725">prev</a><span>|</span><a href="#39008310">next</a><span>|</span><label class="collapse" for="c-39010778">[-]</label><label class="expand" for="c-39010778">[1 more]</label></div><br/><div class="children"><div class="content">If your program was prone to deadlock as is, and is just more easily happening with virt threads, it means that the problem is your code.</div><br/></div></div></div></div></div></div></div></div><div id="39008310" class="c"><input type="checkbox" id="c-39008310" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#39008219">parent</a><span>|</span><a href="#39008323">prev</a><span>|</span><a href="#39008864">next</a><span>|</span><label class="collapse" for="c-39008310">[-]</label><label class="expand" for="c-39008310">[14 more]</label></div><br/><div class="children"><div class="content">Article won’t load for me. My understanding was that the switch to virtual was supposed to be relatively simple, allowing the programmer to be naive. But a user deadlock is a user deadlock, no matter the threading impl.</div><br/><div id="39008357" class="c"><input type="checkbox" id="c-39008357" checked=""/><div class="controls bullet"><span class="by">papercrane</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008310">parent</a><span>|</span><a href="#39008376">next</a><span>|</span><label class="collapse" for="c-39008357">[-]</label><label class="expand" for="c-39008357">[8 more]</label></div><br/><div class="children"><div class="content">The issue here is currently virtual threads don&#x27;t work well with the &#x27;sychronized&#x27; keyword. Right now synchronized will pin the carrier thread. The fix was to switch to a higher-level abstraction that works with virtual threads.<p>My understanding is there is work to make synchronized not pin the carrier thread, but that&#x27;s some pretty complex and important code to change.</div><br/><div id="39008901" class="c"><input type="checkbox" id="c-39008901" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008357">parent</a><span>|</span><a href="#39008376">next</a><span>|</span><label class="collapse" for="c-39008901">[-]</label><label class="expand" for="c-39008901">[7 more]</label></div><br/><div class="children"><div class="content">From a relatively brief skim and past Go and Java experience: synchronized blocks the current <i>normal</i> thread, so that doesn&#x27;t really seem any different to me.  If you starve your threads, you starve your threads.<p>It definitely leaves room to <i>optimize</i> by <i>not</i> pinning that thread, which would be great, but that shouldn&#x27;t change semantics at all.  Or is there something actually screwed up in the implementation of virtual threads that makes this a much bigger issue?</div><br/><div id="39009039" class="c"><input type="checkbox" id="c-39009039" checked=""/><div class="controls bullet"><span class="by">extractionmech</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008901">parent</a><span>|</span><a href="#39009955">next</a><span>|</span><label class="collapse" for="c-39009039">[-]</label><label class="expand" for="c-39009039">[3 more]</label></div><br/><div class="children"><div class="content">It’s a thread that supports n virtual threads. You want synchronized in virtual thread a and not the carrier thread which will block <i>all</i> the virtual threads.<p>Been away from Java land for a while. How did something like that even get into release? That’s like a pretty big loaded shotgun to leave lying around with lots of kids playing, no?</div><br/><div id="39010795" class="c"><input type="checkbox" id="c-39010795" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39009039">parent</a><span>|</span><a href="#39009461">next</a><span>|</span><label class="collapse" for="c-39010795">[-]</label><label class="expand" for="c-39010795">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an explicitly documented shortcoming of the existing implementation that will be fixed soon. I knew <i>immediately</i> from the title of TA what probably happened. The other similar limitations (CPU-bound tasks, native calls) seem much more severe, but are ultimately unsolvable. Meanwhile, the issue with synchronized is regarded as a scalability bottleneck since the JDK is supposed to temporarily spawn additional platform threads. This behavior can be controlled via the system property `jdk.virtualThreadScheduler.maxPoolSize`.<p>Also, this is a <i>benchmark</i>. It&#x27;s not surprising that they managed to produce a situation where more than n_cores virtual threads would actually start waiting.</div><br/></div></div><div id="39009461" class="c"><input type="checkbox" id="c-39009461" checked=""/><div class="controls bullet"><span class="by">jbritton</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39009039">parent</a><span>|</span><a href="#39010795">prev</a><span>|</span><a href="#39009955">next</a><span>|</span><label class="collapse" for="c-39009461">[-]</label><label class="expand" for="c-39009461">[1 more]</label></div><br/><div class="children"><div class="content">I agree. Seems like a huge Java design error.</div><br/></div></div></div></div><div id="39009955" class="c"><input type="checkbox" id="c-39009955" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008901">parent</a><span>|</span><a href="#39009039">prev</a><span>|</span><a href="#39008376">next</a><span>|</span><label class="collapse" for="c-39009955">[-]</label><label class="expand" for="c-39009955">[3 more]</label></div><br/><div class="children"><div class="content">Java&#x27;s virtual threads are supposed to be a drop-in replacement for real threads. But using virtual threads means you get a far smaller number of real threads, and things that were safe back when you had an unlimited number of real threads available (or at least, a larger number than your database connection pool) are no longer safe.</div><br/><div id="39010426" class="c"><input type="checkbox" id="c-39010426" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39009955">parent</a><span>|</span><a href="#39008376">next</a><span>|</span><label class="collapse" for="c-39010426">[-]</label><label class="expand" for="c-39010426">[2 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t you be able to use the same number of real threads though, plus some additional effectively-threads for the virtual threads that are not pinned?  Doesn&#x27;t seem like this should change semantics there, so the risk would be code that changes <i>because</i> of <i>perceived</i> advantages which are not true in edge cases - that&#x27;s new behavior that wasn&#x27;t possible before, there aren&#x27;t really any existing semantics to break.<p>If they&#x27;re, like, limiting to CPU cores * 2 threads: yeah that would be Bad™.  Unambiguously.  I haven&#x27;t been able to find anything conclusive about this though.</div><br/><div id="39010792" class="c"><input type="checkbox" id="c-39010792" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39010426">parent</a><span>|</span><a href="#39008376">next</a><span>|</span><label class="collapse" for="c-39010792">[-]</label><label class="expand" for="c-39010792">[1 more]</label></div><br/><div class="children"><div class="content">That sort of what happens, there is just a configurable hard limit on how much new thread may be created that was hit by this benchmark.<p>As mentioned in another comment: jdk.virtualThreadScheduler.maxPoolSize</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39008376" class="c"><input type="checkbox" id="c-39008376" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008310">parent</a><span>|</span><a href="#39008357">prev</a><span>|</span><a href="#39008649">next</a><span>|</span><label class="collapse" for="c-39008376">[-]</label><label class="expand" for="c-39008376">[4 more]</label></div><br/><div class="children"><div class="content">The adoption guide tells you not to switch to virtual threads just for their own sake. They&#x27;re not meant as a straight replacement for OS threads.<p><a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;21&#x2F;core&#x2F;virtual-threads.html#GUID-8AEDDBE6-F783-4D77-8786-AC5A79F517C0" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;21&#x2F;core&#x2F;virtual-threa...</a></div><br/><div id="39008485" class="c"><input type="checkbox" id="c-39008485" checked=""/><div class="controls bullet"><span class="by">bcrosby95</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008376">parent</a><span>|</span><a href="#39008649">next</a><span>|</span><label class="collapse" for="c-39008485">[-]</label><label class="expand" for="c-39008485">[3 more]</label></div><br/><div class="children"><div class="content">No mentions of deadlocks.  Just this:<p>&gt; Pinning does not make an application incorrect, but it might hinder its scalability.<p>The documentation is wrong.</div><br/><div id="39010811" class="c"><input type="checkbox" id="c-39010811" checked=""/><div class="controls bullet"><span class="by">samus</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008485">parent</a><span>|</span><a href="#39008508">next</a><span>|</span><label class="collapse" for="c-39010811">[-]</label><label class="expand" for="c-39010811">[1 more]</label></div><br/><div class="children"><div class="content">The workaround is to increase the carrier thread pool size.</div><br/></div></div><div id="39008508" class="c"><input type="checkbox" id="c-39008508" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008485">parent</a><span>|</span><a href="#39010811">prev</a><span>|</span><a href="#39008649">next</a><span>|</span><label class="collapse" for="c-39008508">[-]</label><label class="expand" for="c-39008508">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is. That’s because their discussion of pinning is incomplete: it needs to mention forward progress.</div><br/></div></div></div></div></div></div><div id="39008649" class="c"><input type="checkbox" id="c-39008649" checked=""/><div class="controls bullet"><span class="by">koolba</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008310">parent</a><span>|</span><a href="#39008376">prev</a><span>|</span><a href="#39008864">next</a><span>|</span><label class="collapse" for="c-39008649">[-]</label><label class="expand" for="c-39008649">[1 more]</label></div><br/><div class="children"><div class="content">This has nothing to do with postgres though. It’s part of a generic JDBC connection pool:<p>&gt; The problem is that this synchronized code might be deeply embedded within the libraries you use. In our case, it was within the c3p0 library. So, the fix is straightforward: we simply wrapped the connection with a java.util.concurrent.Semaphore.<p>I bet if you just checked out connections and slept a random amount of time you’d have the same problem.</div><br/></div></div></div></div><div id="39008864" class="c"><input type="checkbox" id="c-39008864" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#39008219">parent</a><span>|</span><a href="#39008310">prev</a><span>|</span><a href="#39008993">next</a><span>|</span><label class="collapse" for="c-39008864">[-]</label><label class="expand" for="c-39008864">[2 more]</label></div><br/><div class="children"><div class="content">What was the user error?  Was there something obvious they did or didn&#x27;t do or is it a &quot;you&#x27;re holding it wrong&quot; kind of issue?</div><br/><div id="39008991" class="c"><input type="checkbox" id="c-39008991" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#39008219">root</a><span>|</span><a href="#39008864">parent</a><span>|</span><a href="#39008993">next</a><span>|</span><label class="collapse" for="c-39008991">[-]</label><label class="expand" for="c-39008991">[1 more]</label></div><br/><div class="children"><div class="content">c3p0 appears to have been working under the assumption that their threads can always run when whatever they’re waiting on is done. Their only dependency is the OS giving them cycles.<p>Virtual threads changed the contract a little bit. Now one virtual thread running certain code can prevent a different virtual thread from ever getting any cycles even though they are not dependent on each other in the Java code. It’s a side effect of the current Java implementation.<p>The rules changed, and it tripped up c3p0. Unless they explicitly said somewhere that they were completely ready for virtual threads I’m not sure anyone is at fault here.</div><br/></div></div></div></div><div id="39008993" class="c"><input type="checkbox" id="c-39008993" checked=""/><div class="controls bullet"><span class="by">mattgreenrocks</span><span>|</span><a href="#39008219">parent</a><span>|</span><a href="#39008864">prev</a><span>|</span><a href="#39008330">next</a><span>|</span><label class="collapse" for="c-39008993">[-]</label><label class="expand" for="c-39008993">[1 more]</label></div><br/><div class="children"><div class="content">It is hard to be confident whether the entire dependency tree is free of this issue.</div><br/></div></div></div></div><div id="39008330" class="c"><input type="checkbox" id="c-39008330" checked=""/><div class="controls bullet"><span class="by">otterley</span><span>|</span><a href="#39008219">prev</a><span>|</span><a href="#39008244">next</a><span>|</span><label class="collapse" for="c-39008330">[-]</label><label class="expand" for="c-39008330">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Our PostgreSQL TPC-C implementation utilizes c3p0 for connection pooling...The problem is that...synchronized code might be deeply embedded within the libraries you use. In our case, it was within the c3p0 library. So, the fix is straightforward: we simply wrapped the connection with a java.util.concurrent.Semaphore. With this change, virtual threads are blocked on the semaphore and, crucially, release the carrier thread instead of delving inside c3p0. Thus, we never block inside c3p0 because we enter c3p0 code only when there is a free session available.&quot;</div><br/></div></div><div id="39008244" class="c"><input type="checkbox" id="c-39008244" checked=""/><div class="controls bullet"><span class="by">charleslmunger</span><span>|</span><a href="#39008330">prev</a><span>|</span><a href="#39009189">next</a><span>|</span><label class="collapse" for="c-39008244">[-]</label><label class="expand" for="c-39008244">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Why not to use java virtual threads&quot; -&gt; Fundamental features of the language treated as implementation details in libraries for more than two decades cause deadlock.</div><br/></div></div><div id="39008896" class="c"><input type="checkbox" id="c-39008896" checked=""/><div class="controls bullet"><span class="by">schizofunky</span><span>|</span><a href="#39008368">prev</a><span>|</span><label class="collapse" for="c-39008896">[-]</label><label class="expand" for="c-39008896">[2 more]</label></div><br/><div class="children"><div class="content">I think i have a more elegant solution for this deadlock:<p>&quot;Switch to haskell&quot;.</div><br/><div id="39009154" class="c"><input type="checkbox" id="c-39009154" checked=""/><div class="controls bullet"><span class="by">shermantanktop</span><span>|</span><a href="#39008896">parent</a><span>|</span><label class="collapse" for="c-39009154">[-]</label><label class="expand" for="c-39009154">[1 more]</label></div><br/><div class="children"><div class="content">If serious: that’s dismissive, superior, and a low-effort appeal to Haskell fans.<p>If not serious: it’s still low effort, but while it is framed as a zinger, it’s not funny at all. I don’t even understand what the humor might be, maybe it’s serious after all.</div><br/></div></div></div></div></div></div></div></div></div></body></html>