<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1731056467293" as="style"/><link rel="stylesheet" href="styles.css?v=1731056467293"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://chromium.googlesource.com/linux-syscall-support/">Linux Syscall Support</a> <span class="domain">(<a href="https://chromium.googlesource.com">chromium.googlesource.com</a>)</span></div><div class="subtext"><span>btdmaster</span> | <span>106 comments</span></div><br/><div><div id="42075761" class="c"><input type="checkbox" id="c-42075761" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#42079415">next</a><span>|</span><label class="collapse" for="c-42075761">[-]</label><label class="expand" for="c-42075761">[70 more]</label></div><br/><div class="children"><div class="content">See also Linux&#x27;s nolibc headers, which allows one to write C software that completely bypass libc, but instead directly operate through syscalls.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;tree&#x2F;master&#x2F;tools&#x2F;include&#x2F;nolibc">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;tree&#x2F;master&#x2F;tools&#x2F;include&#x2F;...</a><p>A sample use-case? I was developing an Erlang-like actor platform that should operate under Linux as well as a bare-metal microkernel, and all I needed is a light layer over syscalls instead of pulling the entire glibc. Also it provides a simple implementation for standard C functions (memcpy, printf) so I don&#x27;t have to write them myself.</div><br/><div id="42076225" class="c"><input type="checkbox" id="c-42076225" checked=""/><div class="controls bullet"><span class="by">jlokier</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42083904">next</a><span>|</span><label class="collapse" for="c-42076225">[-]</label><label class="expand" for="c-42076225">[1 more]</label></div><br/><div class="children"><div class="content">Another use-case is when you are writing threaded code that uses the clone() syscall instead of pthreads, usually for something with high performance, unusual clone flags, or a very small stack.<p>Most libc functions, including the syscall wrappers and all pthreads functions, aren&#x27;t safe to call in threads created by raw clone().  Anything that reads or writes errno, for example, is not safe.<p>I&#x27;ve had to do this a couple of times.  One a long time ago was an audio mixing real-time thread for a video game, which had to keep the audio device fed with low-latency frames for sound effects.  In those days, pthreads wasn&#x27;t good enough.  For talking to the audio device, we had to use the Linux syscall wrapper macros, which have been replaced by nolibc now.  More recently, a thread pool for high-performance storage I&#x2F;O, which ran slightly faster than io_uring, and ran well on older kernels and ones with io_uring disabled for security.</div><br/></div></div><div id="42083904" class="c"><input type="checkbox" id="c-42083904" checked=""/><div class="controls bullet"><span class="by">arjvik</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42076225">prev</a><span>|</span><a href="#42081831">next</a><span>|</span><label class="collapse" for="c-42083904">[-]</label><label class="expand" for="c-42083904">[1 more]</label></div><br/><div class="children"><div class="content">Where was this when I needed it!<p>As one of my class projects, I built a Linux compatibility layer for the toy OS we had built, by adding a proper ELF loader and emulating syscalls. I really struggled to get glibc or even musl working, and so I ended up hand-coding some `-nostdlib` programs instead of being able to use coreutils. If nolibc really works as a minimal libc, would have been incredibly cool to be able to run coreutils on my OS!</div><br/></div></div><div id="42079824" class="c"><input type="checkbox" id="c-42079824" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42081831">prev</a><span>|</span><a href="#42076256">next</a><span>|</span><label class="collapse" for="c-42079824">[-]</label><label class="expand" for="c-42079824">[2 more]</label></div><br/><div class="children"><div class="content">nolibc seems kinda neglected, or like a minimal subset of what&#x27;s actually useful. There&#x27;s no pread&#x2F;pwrite etc, only read&#x2F;write, forcing you to use lseek and ruining concurrent use.</div><br/><div id="42080480" class="c"><input type="checkbox" id="c-42080480" checked=""/><div class="controls bullet"><span class="by">pantalaimon</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42079824">parent</a><span>|</span><a href="#42076256">next</a><span>|</span><label class="collapse" for="c-42080480">[-]</label><label class="expand" for="c-42080480">[1 more]</label></div><br/><div class="children"><div class="content">Wasn’t that originally just for integration tests where you wanted to boot a minimal image that just runs your kernel CI test?</div><br/></div></div></div></div><div id="42076256" class="c"><input type="checkbox" id="c-42076256" checked=""/><div class="controls bullet"><span class="by">n_plus_1_acc</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42079824">prev</a><span>|</span><a href="#42075814">next</a><span>|</span><label class="collapse" for="c-42076256">[-]</label><label class="expand" for="c-42076256">[10 more]</label></div><br/><div class="children"><div class="content">Do I understand correctly that nolibc is just another implementation of the C standard library in terms of Linux syscalls? Comparably to, say, musl libc?</div><br/><div id="42076268" class="c"><input type="checkbox" id="c-42076268" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076256">parent</a><span>|</span><a href="#42076378">next</a><span>|</span><label class="collapse" for="c-42076268">[-]</label><label class="expand" for="c-42076268">[8 more]</label></div><br/><div class="children"><div class="content">glibc is a space shuttle, musl is a hatchback, nolibc is a skateboard<p>They all do the same thing (take you from A to B), but offer different levels of comfort, efficiency and utility :)</div><br/><div id="42077258" class="c"><input type="checkbox" id="c-42077258" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076268">parent</a><span>|</span><a href="#42077278">next</a><span>|</span><label class="collapse" for="c-42077258">[-]</label><label class="expand" for="c-42077258">[5 more]</label></div><br/><div class="children"><div class="content">Who can take their space shuttle to work these days, what with the price of rocket fuel‽</div><br/><div id="42077280" class="c"><input type="checkbox" id="c-42077280" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077258">parent</a><span>|</span><a href="#42080603">next</a><span>|</span><label class="collapse" for="c-42077280">[-]</label><label class="expand" for="c-42077280">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit unwieldy, but the good thing is that it comes for free with your copy of GNU&#x2F;Linux!</div><br/></div></div><div id="42080603" class="c"><input type="checkbox" id="c-42080603" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077258">parent</a><span>|</span><a href="#42077280">prev</a><span>|</span><a href="#42081791">next</a><span>|</span><label class="collapse" for="c-42080603">[-]</label><label class="expand" for="c-42080603">[1 more]</label></div><br/><div class="children"><div class="content">Apparently almost every linux app</div><br/></div></div><div id="42079037" class="c"><input type="checkbox" id="c-42079037" checked=""/><div class="controls bullet"><span class="by">nilamo</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077258">parent</a><span>|</span><a href="#42081791">prev</a><span>|</span><a href="#42077278">next</a><span>|</span><label class="collapse" for="c-42079037">[-]</label><label class="expand" for="c-42079037">[1 more]</label></div><br/><div class="children"><div class="content">And parking is always a nightmare for my shuttles</div><br/></div></div></div></div><div id="42077278" class="c"><input type="checkbox" id="c-42077278" checked=""/><div class="controls bullet"><span class="by">wbl</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076268">parent</a><span>|</span><a href="#42077258">prev</a><span>|</span><a href="#42076378">next</a><span>|</span><label class="collapse" for="c-42077278">[-]</label><label class="expand" for="c-42077278">[2 more]</label></div><br/><div class="children"><div class="content">And passenger safety?</div><br/><div id="42078416" class="c"><input type="checkbox" id="c-42078416" checked=""/><div class="controls bullet"><span class="by">fallingsquirrel</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077278">parent</a><span>|</span><a href="#42076378">next</a><span>|</span><label class="collapse" for="c-42078416">[-]</label><label class="expand" for="c-42078416">[1 more]</label></div><br/><div class="children"><div class="content">In a head-on collision, the space shuttle passengers will fare better than the hatchback. Even so, it wouldn&#x27;t be my first choice for most destinations.</div><br/></div></div></div></div></div></div><div id="42076378" class="c"><input type="checkbox" id="c-42076378" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076256">parent</a><span>|</span><a href="#42076268">prev</a><span>|</span><a href="#42075814">next</a><span>|</span><label class="collapse" for="c-42076378">[-]</label><label class="expand" for="c-42076378">[1 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s not comparable to musl libc. Standard I&#x2F;O functions don&#x27;t support buffering and the printf implementation can&#x27;t print floats, for example.</div><br/></div></div></div></div><div id="42075814" class="c"><input type="checkbox" id="c-42075814" checked=""/><div class="controls bullet"><span class="by">guerrilla</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42076256">prev</a><span>|</span><a href="#42075843">next</a><span>|</span><label class="collapse" for="c-42075814">[-]</label><label class="expand" for="c-42075814">[41 more]</label></div><br/><div class="children"><div class="content">&gt; What would be a use-case?<p>Maybe bootstapping a new language with no dependencies.</div><br/><div id="42075826" class="c"><input type="checkbox" id="c-42075826" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075814">parent</a><span>|</span><a href="#42076588">next</a><span>|</span><label class="collapse" for="c-42075826">[-]</label><label class="expand" for="c-42075826">[38 more]</label></div><br/><div class="children"><div class="content">Yes. Go for example doesn&#x27;t use glibc and instead interfaces with syscalls directly.<p><a href="https:&#x2F;&#x2F;pkg.go.dev&#x2F;syscall" rel="nofollow">https:&#x2F;&#x2F;pkg.go.dev&#x2F;syscall</a></div><br/><div id="42077562" class="c"><input type="checkbox" id="c-42077562" checked=""/><div class="controls bullet"><span class="by">boomskats</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075826">parent</a><span>|</span><a href="#42077365">next</a><span>|</span><label class="collapse" for="c-42077562">[-]</label><label class="expand" for="c-42077562">[2 more]</label></div><br/><div class="children"><div class="content">Worth mentioning that the golang.org&#x2F;x&#x2F;sys&#x2F;unix package has better support for syscalls than the og syscall package nowadays, especially for some of the newer ones like  cachestat[0] which was added to the kernel in 6.5. AFAIK the original syscall package was &#x27;frozen&#x27; a while back to preserve backward compatibility, and at one point there was even a bit of drama[1] around it being marked as deprecated instead of frozen.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;61917">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;61917</a>
[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;60797">https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;issues&#x2F;60797</a></div><br/><div id="42079753" class="c"><input type="checkbox" id="c-42079753" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077562">parent</a><span>|</span><a href="#42077365">next</a><span>|</span><label class="collapse" for="c-42079753">[-]</label><label class="expand" for="c-42079753">[1 more]</label></div><br/><div class="children"><div class="content">Undeprecating something is truly a rare sight.<p>So far I only knew about PHP undeprecating &quot;is_a&quot; function, so I guess this puts Go in good company ^^</div><br/></div></div></div></div><div id="42077365" class="c"><input type="checkbox" id="c-42077365" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075826">parent</a><span>|</span><a href="#42077562">prev</a><span>|</span><a href="#42075971">next</a><span>|</span><label class="collapse" for="c-42077365">[-]</label><label class="expand" for="c-42077365">[3 more]</label></div><br/><div class="children"><div class="content">Except there are some platforms where you <i>need</i> to go through libc and the direct syscall interface is considered private, or subject to change. OpenBSD is like this, and I believe Mac is too.</div><br/><div id="42082561" class="c"><input type="checkbox" id="c-42082561" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077365">parent</a><span>|</span><a href="#42075971">next</a><span>|</span><label class="collapse" for="c-42082561">[-]</label><label class="expand" for="c-42082561">[2 more]</label></div><br/><div class="children"><div class="content">Linux is the only one that is <i>not</i> like this. I wrote an article about the subject:<p><a href="https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;linux-system-calls" rel="nofollow">https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;linux-system-calls</a></div><br/><div id="42083499" class="c"><input type="checkbox" id="c-42083499" checked=""/><div class="controls bullet"><span class="by">vetinari</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42082561">parent</a><span>|</span><a href="#42075971">next</a><span>|</span><label class="collapse" for="c-42083499">[-]</label><label class="expand" for="c-42083499">[1 more]</label></div><br/><div class="children"><div class="content">While Linux does have stable syscall interface, unlike other OS-es, you still want to go through glibc. At least for NSS, otherwise your app could be broken.<p>Golang has CGO_ENABLED=1 as the default for this reason.</div><br/></div></div></div></div></div></div><div id="42075971" class="c"><input type="checkbox" id="c-42075971" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075826">parent</a><span>|</span><a href="#42077365">prev</a><span>|</span><a href="#42075851">next</a><span>|</span><label class="collapse" for="c-42075971">[-]</label><label class="expand" for="c-42075971">[12 more]</label></div><br/><div class="children"><div class="content">Didn&#x27;t they go back to Glibc in 2017 after a syscall silently corrupted several of their tightly packed tiny Go stacks? The page you link to seems to refer to a proposal from 2014 as &quot;new&quot;.</div><br/><div id="42077234" class="c"><input type="checkbox" id="c-42077234" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075971">parent</a><span>|</span><a href="#42076328">next</a><span>|</span><label class="collapse" for="c-42077234">[-]</label><label class="expand" for="c-42077234">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Didn&#x27;t they go back to Glibc in 2017 after a syscall silently corrupted several of their tightly packed tiny Go stacks?<p>You must be thinking of <a href="https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;" rel="nofollow">https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;</a> which was about the vDSO (a virtual dynamically linked library which is automatically mapped by the kernel on every process), not system calls. You normally call into the vDSO instead of doing direct system calls, because the vDSO can do some things (like reading the clock) in an optimized way without entering the kernel, but you can always bypass it and do the system calls directly; doing the system calls directly will not use any of the userspace stack (it immediately switches to a kernel stack and does all the work there).</div><br/></div></div><div id="42076328" class="c"><input type="checkbox" id="c-42076328" checked=""/><div class="controls bullet"><span class="by">jsheard</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075971">parent</a><span>|</span><a href="#42077234">prev</a><span>|</span><a href="#42076040">next</a><span>|</span><label class="collapse" for="c-42076328">[-]</label><label class="expand" for="c-42076328">[9 more]</label></div><br/><div class="children"><div class="content">IIRC that was specifically on macOS and other BSDs which don&#x27;t have a stable syscall interface. They still use raw syscalls on Linux, which guarantees syscall stability on pain of Linus Torvalds yelling at you if you break it.</div><br/><div id="42079759" class="c"><input type="checkbox" id="c-42079759" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076328">parent</a><span>|</span><a href="#42076040">next</a><span>|</span><label class="collapse" for="c-42079759">[-]</label><label class="expand" for="c-42079759">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m 100% with Linus on this one.</div><br/><div id="42082448" class="c"><input type="checkbox" id="c-42082448" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42079759">parent</a><span>|</span><a href="#42076040">next</a><span>|</span><label class="collapse" for="c-42082448">[-]</label><label class="expand" for="c-42082448">[7 more]</label></div><br/><div class="children"><div class="content">Linus ships a kernel –– where would his stable interface live if not the syscall ABI?  The *BSD and macOS folks ship operating systems, where they have the option of defining their ABI at a higher level of abstraction.</div><br/><div id="42082578" class="c"><input type="checkbox" id="c-42082578" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42082448">parent</a><span>|</span><a href="#42076040">next</a><span>|</span><label class="collapse" for="c-42082578">[-]</label><label class="expand" for="c-42082578">[6 more]</label></div><br/><div class="children"><div class="content">Linux could have made their own libc and mandated use of it. But they didn&#x27;t. They chose a <i>language agnostic</i> binary interface that&#x27;s documented at the instruction set level.<p>As a result of that brilliant design choice, <i>every single language</i> can make Linux system calls natively. It should be simple for JIT compilers to generate Linux system call code. No need to pull in some huge C library just for this. AOT compilers could have a linux_system_call builtin that just generates the required instructions. I actually posted this proposal to the GCC mailing list.</div><br/><div id="42082964" class="c"><input type="checkbox" id="c-42082964" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42082578">parent</a><span>|</span><a href="#42082620">next</a><span>|</span><label class="collapse" for="c-42082964">[-]</label><label class="expand" for="c-42082964">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Linux could have made their own libc<p>That&#x27;s not what Linux is, though.  It&#x27;s a kernel.  libc is a userspace library.  The Linux developers could also make their own libpng and put their stable interface in there, but that&#x27;s not in scope for their project.<p>&gt; As a result of that brilliant design choice, every single language can make Linux system calls natively.<p>That is like saying it&#x27;s a brilliant design choice for an artist to paint the sky blue on a sunny day.  If Linux is a kernel, and if a kernel&#x27;s interface with userspace is syscalls, and if Linux wants to avoid breaking userspace with kernel updates, then it needs a stable syscall interface.<p>&gt; No need to pull in some huge C library just for this.<p>Again, I&#x27;m not sure why the Linux project would invent this &quot;huge C library&quot; to use as their stable kernel interface.</div><br/><div id="42083406" class="c"><input type="checkbox" id="c-42083406" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42082964">parent</a><span>|</span><a href="#42083472">next</a><span>|</span><label class="collapse" for="c-42083406">[-]</label><label class="expand" for="c-42083406">[2 more]</label></div><br/><div class="children"><div class="content">They could but they didn&#x27;t. At some point, Linux almost got its own klibc. The developers realized such a thing wasn&#x27;t needed in the kernel. Greg Kroah-Hartman told me about it when I asked on his AMA:<p><a href="https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;linux&#x2F;comments&#x2F;fx5e4v&#x2F;im_greg_kroahhartman_linux_kernel_developer_ama&#x2F;fn3rpht&#x2F;" rel="nofollow">https:&#x2F;&#x2F;old.reddit.com&#x2F;r&#x2F;linux&#x2F;comments&#x2F;fx5e4v&#x2F;im_greg_kroah...</a><p>The importance of this design should not be understated. It&#x27;s not really an obvious thing to realize. If it was, every other operating system and kernel out there would be doing it as well. They aren&#x27;t. They all make people link against some library.<p>So Linux is actually pretty special. It&#x27;s the only system where you actually can trash the entire userspace and rewrite the world in Rust. Don&#x27;t need to link against any &quot;core&quot; system libraries. People usually do but it&#x27;s not forced upon them.<p>&gt; if Linux wants to avoid breaking userspace with kernel updates, then it needs a stable syscall interface<p>Every kernel and operating system wants to maximize backwards compatibility and minimize user space breakage. Most of them simply stabilize the system libraries instead. The core libraries are stable, the kernel interfaces used by those core libraries are not.<p>So it doesn&#x27;t follow that it needs a stable syscall interface. They could have solved it via user space impositions. The fact they chose a better solution is one of many things that makes Linux special.</div><br/><div id="42083817" class="c"><input type="checkbox" id="c-42083817" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42083406">parent</a><span>|</span><a href="#42083472">next</a><span>|</span><label class="collapse" for="c-42083817">[-]</label><label class="expand" for="c-42083817">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The importance of this design should not be understated. It&#x27;s not really an obvious thing to realize. If it was, every other operating system and kernel out there would be doing it as well.<p>No, they would not.  I can say this with confidence because at any point in the last several decades, any OS vendor could have started to do so, and they have not.  They have uniformly decided that having a userspace library as their stable kernel interface is easier to maintain, so that&#x27;s what they do.  The idea that the rest of the world hasn&#x27;t &quot;realized&quot; that, in addition to maintaining binary compatibility in their libc, they could also maintain binary compatible syscalls is nonsensical.<p>The Linux kernel, on the other hand, doesn&#x27;t ship a userspace.  If they wanted their stable interface to be a userspace library, they&#x27;d need to invent one!  And that would be more work than providing stable syscalls.<p>&gt; So Linux is actually pretty special. It&#x27;s the only system where you actually can trash the entire userspace and rewrite the world in Rust.<p>That&#x27;s not rewriting the world, that would be a new userspace for the Linux kernel.  You&#x27;re still calling down into C, there&#x27;s just one fewer indirection along the way.<p>&gt; So it doesn&#x27;t follow that it needs a stable syscall interface. They could have solved it via user space impositions.<p>They could have, but as Greg Kroah-Hartman pointed out, that would have just shifted the complexity around.  Stability at the syscall level is the simplest solution to the problem that the Linux project has, so that&#x27;s what they do.<p>It would be pretty funny if the kernel&#x27;s stability strategy was in service of allowing userspace to avoid linking a C library, considering it&#x27;s been 30+ years and the Linux userspace is almost entirely C and C++ anyway.</div><br/></div></div></div></div><div id="42083472" class="c"><input type="checkbox" id="c-42083472" checked=""/><div class="controls bullet"><span class="by">garaetjjte</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42082964">parent</a><span>|</span><a href="#42083406">prev</a><span>|</span><a href="#42082620">next</a><span>|</span><label class="collapse" for="c-42083472">[-]</label><label class="expand" for="c-42083472">[1 more]</label></div><br/><div class="children"><div class="content">I mean they could stuff kernel libc into vDSO.</div><br/></div></div></div></div><div id="42082620" class="c"><input type="checkbox" id="c-42082620" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42082578">parent</a><span>|</span><a href="#42082964">prev</a><span>|</span><a href="#42076040">next</a><span>|</span><label class="collapse" for="c-42082620">[-]</label><label class="expand" for="c-42082620">[1 more]</label></div><br/><div class="children"><div class="content">Exactly, a stable language-agnostic binary ABI is the proper layering choice.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42076040" class="c"><input type="checkbox" id="c-42076040" checked=""/><div class="controls bullet"><span class="by">melodyogonna</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075971">parent</a><span>|</span><a href="#42076328">prev</a><span>|</span><a href="#42075851">next</a><span>|</span><label class="collapse" for="c-42076040">[-]</label><label class="expand" for="c-42076040">[1 more]</label></div><br/><div class="children"><div class="content">That is the documentation for the Go syscall package. If you scroll down to the bottom of the page you&#x27;ll see links to the source files.</div><br/></div></div></div></div><div id="42075851" class="c"><input type="checkbox" id="c-42075851" checked=""/><div class="controls bullet"><span class="by">cyberpunk</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075826">parent</a><span>|</span><a href="#42075971">prev</a><span>|</span><a href="#42076588">next</a><span>|</span><label class="collapse" for="c-42075851">[-]</label><label class="expand" for="c-42075851">[20 more]</label></div><br/><div class="children"><div class="content">I’m aware of this but I really don’t the benefits of this approach; It causes issues in eg openbsd where you can only call syscalls from libc, and it seems like they’re trying to outsmart the os developers and I just don’t see an advantage.<p>Is it faster? More stable?</div><br/><div id="42075936" class="c"><input type="checkbox" id="c-42075936" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075851">parent</a><span>|</span><a href="#42075929">next</a><span>|</span><label class="collapse" for="c-42075936">[-]</label><label class="expand" for="c-42075936">[4 more]</label></div><br/><div class="children"><div class="content">There are several advantages to using kernel syscalls directly:<p>1. No overhead from libc; minimizes syscall cost<p>2. No dependency on libc and C language ABI&#x2F;toolchains<p>3. Reduced attack surface. libc can and does have bugs and potentially ROP or Spectre gadgets.<p>4. Bootstrapping other languages, e.g. Virgil</div><br/><div id="42076065" class="c"><input type="checkbox" id="c-42076065" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075936">parent</a><span>|</span><a href="#42075929">next</a><span>|</span><label class="collapse" for="c-42076065">[-]</label><label class="expand" for="c-42076065">[3 more]</label></div><br/><div class="children"><div class="content">&gt; 1. No overhead from libc; minimizes syscall cost<p>The few nanoseconds of a straight function call are absolutely irrelevant vs the 10s of microseconds of a syscall cost <i>and</i> you lose out on any of the optimizations a libc has that you might not or didn&#x27;t think about (like memoization of getpid() ) <i>and</i> you need to take on keeping up with syscall evolution &#x2F; best practices which a libc generally has a good handle on.<p>&gt; No dependency on libc and C language ABI&#x2F;toolchains<p>This obviously doesn&#x27;t apply to a C syscall header, though, such as the case in OP :)</div><br/><div id="42078471" class="c"><input type="checkbox" id="c-42078471" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076065">parent</a><span>|</span><a href="#42084631">next</a><span>|</span><label class="collapse" for="c-42078471">[-]</label><label class="expand" for="c-42078471">[1 more]</label></div><br/><div class="children"><div class="content">A syscall can be way less than 10us. Especially if it is not doing I&#x2F;O.</div><br/></div></div><div id="42084631" class="c"><input type="checkbox" id="c-42084631" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076065">parent</a><span>|</span><a href="#42078471">prev</a><span>|</span><a href="#42075929">next</a><span>|</span><label class="collapse" for="c-42084631">[-]</label><label class="expand" for="c-42084631">[1 more]</label></div><br/><div class="children"><div class="content">&gt; you lose out on any of the optimizations a libc has that you might not or didn&#x27;t think about (like memoization of getpid() )<p>Not much of a big deal. These &quot;optimizations&quot; caused enough bugs that they actually got reverted.<p><a href="https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;getpid.2.html" rel="nofollow">https:&#x2F;&#x2F;www.man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;getpid.2.html</a><p><pre><code>  Because of the aforementioned problems, since glibc 2.25,
  the PID cache is removed: calls to getpid() always invoke
  the actual system call, rather than returning a cached value.
</code></pre>
Get rid of libc and you gain the ability to have zero global state in exchange. Freestanding C actually makes sense and is a very fun language to program in. No legacy nonsense to worry about. Even errno is gone.</div><br/></div></div></div></div></div></div><div id="42075929" class="c"><input type="checkbox" id="c-42075929" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075851">parent</a><span>|</span><a href="#42075936">prev</a><span>|</span><a href="#42079531">next</a><span>|</span><label class="collapse" for="c-42075929">[-]</label><label class="expand" for="c-42075929">[7 more]</label></div><br/><div class="children"><div class="content">&gt; I just don’t see an advantage.<p>You don’t have to deal with C ABI requirements with respect to stack, or registers management. You also don’t need to do dynamic linking.<p>On the other hand all of that comes back to bone you if you’re trying to benefit from vDSO without going through a libc.</div><br/><div id="42076699" class="c"><input type="checkbox" id="c-42076699" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075929">parent</a><span>|</span><a href="#42076841">next</a><span>|</span><label class="collapse" for="c-42076699">[-]</label><label class="expand" for="c-42076699">[3 more]</label></div><br/><div class="children"><div class="content">&gt; You also don’t need to do dynamic linking.<p>This is a big one. Linking against libc on many platforms also means making your binaries relocatable. It&#x27;s a lot of <i>unnecessary, incidental complexity</i>.</div><br/><div id="42076786" class="c"><input type="checkbox" id="c-42076786" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076699">parent</a><span>|</span><a href="#42076841">next</a><span>|</span><label class="collapse" for="c-42076786">[-]</label><label class="expand" for="c-42076786">[2 more]</label></div><br/><div class="children"><div class="content">It also means giving up ASLR, though.</div><br/><div id="42076868" class="c"><input type="checkbox" id="c-42076868" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076786">parent</a><span>|</span><a href="#42076841">next</a><span>|</span><label class="collapse" for="c-42076868">[-]</label><label class="expand" for="c-42076868">[1 more]</label></div><br/><div class="children"><div class="content">You can still randomize heap allocations (but not with as much entropy), as usually the heap segment is quite large. But you don&#x27;t get randomization of, e.g. the code.<p>ASLR is a weak defense. It&#x27;s akin to randomizing which of the kitchen drawers you&#x27;ll put your jewelry in. Not the same level of security as say, a locked safe.<p>Attacks are increasingly sophisticated, composed of multiple exploits in a chain, one of which is some form of ASLR bypass. It&#x27;s usually one of the easiest links in the chain.</div><br/></div></div></div></div></div></div><div id="42076841" class="c"><input type="checkbox" id="c-42076841" checked=""/><div class="controls bullet"><span class="by">LegionMammal978</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075929">parent</a><span>|</span><a href="#42076699">prev</a><span>|</span><a href="#42079531">next</a><span>|</span><label class="collapse" for="c-42076841">[-]</label><label class="expand" for="c-42076841">[3 more]</label></div><br/><div class="children"><div class="content">&gt; On the other hand all of that comes back to bone you if you’re trying to benefit from vDSO without going through a libc.<p>At least the vDSO functions really don&#x27;t need much in the way of stack space: generally there&#x27;s nothing much there but clock_gettime() and gettimeofday(), which just read some values from the vvar area.<p>The bigger pain, of course, is actually looking up the symbols in the vDSO, which takes at least a minimal ELF parser.</div><br/><div id="42077231" class="c"><input type="checkbox" id="c-42077231" checked=""/><div class="controls bullet"><span class="by">t-8ch</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076841">parent</a><span>|</span><a href="#42077239">next</a><span>|</span><label class="collapse" for="c-42077231">[-]</label><label class="expand" for="c-42077231">[1 more]</label></div><br/><div class="children"><div class="content">The kernel also provides a minimal vdso elf parser:<p><a href="https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;tree&#x2F;tools&#x2F;testing&#x2F;selftests&#x2F;vDSO&#x2F;parse_vdso.c" rel="nofollow">https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;lin...</a></div><br/></div></div><div id="42077239" class="c"><input type="checkbox" id="c-42077239" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076841">parent</a><span>|</span><a href="#42077231">prev</a><span>|</span><a href="#42079531">next</a><span>|</span><label class="collapse" for="c-42077239">[-]</label><label class="expand" for="c-42077239">[1 more]</label></div><br/><div class="children"><div class="content">&gt; At least the vDSO functions really don&#x27;t need much in the way of stack space: generally there&#x27;s nothing much there but clock_gettime() and gettimeofday(), which just read some values from the vvar area.<p>And yet that’s exactly one of the things Go fucked up in the past: <a href="https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;" rel="nofollow">https:&#x2F;&#x2F;marcan.st&#x2F;2017&#x2F;12&#x2F;debugging-an-evil-go-runtime-bug&#x2F;</a></div><br/></div></div></div></div></div></div><div id="42079531" class="c"><input type="checkbox" id="c-42079531" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075851">parent</a><span>|</span><a href="#42075929">prev</a><span>|</span><a href="#42075873">next</a><span>|</span><label class="collapse" for="c-42079531">[-]</label><label class="expand" for="c-42079531">[1 more]</label></div><br/><div class="children"><div class="content">GNU aren&#x27;t the OS developers of the Linux kernel. Think of the Go standard library on Linux as another libc-level library. On the BSDs there is a single libc that&#x27;s part of the OS, on Linux there are several options for libc.</div><br/></div></div><div id="42075873" class="c"><input type="checkbox" id="c-42075873" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075851">parent</a><span>|</span><a href="#42079531">prev</a><span>|</span><a href="#42076588">next</a><span>|</span><label class="collapse" for="c-42075873">[-]</label><label class="expand" for="c-42075873">[7 more]</label></div><br/><div class="children"><div class="content">&gt; It causes issues in eg openbsd where you can only call syscalls from libc<p>OpenBSD allows making syscalls from static binaries as well. If Go binaries are static, it shouldn&#x27;t cause any problems.</div><br/><div id="42076848" class="c"><input type="checkbox" id="c-42076848" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075873">parent</a><span>|</span><a href="#42078503">next</a><span>|</span><label class="collapse" for="c-42076848">[-]</label><label class="expand" for="c-42076848">[5 more]</label></div><br/><div class="children"><div class="content">&gt; OpenBSD allows making syscalls from static binaries as well.<p>Do you have a source for this? My Google searches and personal recollections say that OpenBSD does not have a stable syscall ABI in the way that Linux does and the proper&#x2F;supported way to make syscalls on OpenBSD is through dynamically linked libc; statically linking libc, or invoking the syscall mechanism it uses directly, results in binaries that can be broken on future OpenBSD versions.</div><br/><div id="42077417" class="c"><input type="checkbox" id="c-42077417" checked=""/><div class="controls bullet"><span class="by">cesarb</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076848">parent</a><span>|</span><a href="#42077380">next</a><span>|</span><label class="collapse" for="c-42077417">[-]</label><label class="expand" for="c-42077417">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; OpenBSD allows making syscalls from static binaries as well.<p>&gt; Do you have a source for this?<p>One article from 2019 about this can be found at <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;806776&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;806776&#x2F;</a> (later updates <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;949078&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;949078&#x2F;</a> and <a href="https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;959562&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;959562&#x2F;</a>). Yes, it does not have a stable system call ABI, but as long as your program was statically compiled with the libc from the same OpenBSD release, AFAIK it should work.</div><br/><div id="42078318" class="c"><input type="checkbox" id="c-42078318" checked=""/><div class="controls bullet"><span class="by">kbolino</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077417">parent</a><span>|</span><a href="#42077535">next</a><span>|</span><label class="collapse" for="c-42078318">[-]</label><label class="expand" for="c-42078318">[1 more]</label></div><br/><div class="children"><div class="content">I upvoted for the great links, but I still don&#x27;t think a static binary that will break in the future is meeting the expectations many have when static linking.</div><br/></div></div><div id="42077535" class="c"><input type="checkbox" id="c-42077535" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42077417">parent</a><span>|</span><a href="#42078318">prev</a><span>|</span><a href="#42077380">next</a><span>|</span><label class="collapse" for="c-42077535">[-]</label><label class="expand" for="c-42077535">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. Do you have any information as to how&#x2F;when the OpenBSD system call ABI has changed recently? I wouldn&#x27;t expect that to happen very often.</div><br/></div></div></div></div></div></div><div id="42078503" class="c"><input type="checkbox" id="c-42078503" checked=""/><div class="controls bullet"><span class="by">tolciho</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075873">parent</a><span>|</span><a href="#42076848">prev</a><span>|</span><a href="#42076588">next</a><span>|</span><label class="collapse" for="c-42078503">[-]</label><label class="expand" for="c-42078503">[1 more]</label></div><br/><div class="children"><div class="content">Go recently got run through the wringer to remove syscalls (and various Go ports are probably still broken) due to pinsyscalls.</div><br/></div></div></div></div></div></div></div></div><div id="42076588" class="c"><input type="checkbox" id="c-42076588" checked=""/><div class="controls bullet"><span class="by">jcalabro</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075814">parent</a><span>|</span><a href="#42075826">prev</a><span>|</span><a href="#42082111">next</a><span>|</span><label class="collapse" for="c-42076588">[-]</label><label class="expand" for="c-42076588">[1 more]</label></div><br/><div class="children"><div class="content">Indeed, Zig does this for instance (at least for x86_64 linux [0]) as a way to avoid having to link libc at all<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;ee9f00d673f2bccddc2751c328758a2820d2bb70&#x2F;lib&#x2F;std&#x2F;os&#x2F;linux&#x2F;x86_64.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;ee9f00d673f2bccddc2751c3...</a></div><br/></div></div><div id="42082111" class="c"><input type="checkbox" id="c-42082111" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075814">parent</a><span>|</span><a href="#42076588">prev</a><span>|</span><a href="#42075843">next</a><span>|</span><label class="collapse" for="c-42082111">[-]</label><label class="expand" for="c-42082111">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been working on that language for a while now!<p><a href="https:&#x2F;&#x2F;github.com&#x2F;lone-lang&#x2F;lone">https:&#x2F;&#x2F;github.com&#x2F;lone-lang&#x2F;lone</a><p>It&#x27;s a lisp interpreter with a built in system-call primitive. The plan is to implement everything else from inside the language. Completely freestanding, no libc needed. In the future I expect to be able to boot Linux directly into this thing.<p>Only major feature still needed for kernel support is a binary structure parser for the C structures. I already implemented and tested the primitives for it. I even added support for unaligned memory accesses.<p>Iteration is the only major language feature that&#x27;s still missing. I&#x27;m working on implementing continuations in the interpreter so that I can have elegant Ruby style iteration. This is taking longer than expected.<p>This interpreter can make the Linux kernel load lisp modules before its code even runs. I invented a self-contained ELF loading system that allows embedding arbitrary data into a loadable ELF segment that the kernel automatically maps into memory. Then it&#x27;s just a matter of reaching it via the auxiliary vector, The interpreter uses this to automatically run code, allowing it to become a freestanding lisp executable.<p>I wrote an article about how it works here:<p><a href="https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;self-contained-lone-lisp-applications" rel="nofollow">https:&#x2F;&#x2F;www.matheusmoreira.com&#x2F;articles&#x2F;self-contained-lone-...</a></div><br/></div></div></div></div><div id="42075843" class="c"><input type="checkbox" id="c-42075843" checked=""/><div class="controls bullet"><span class="by">blueflow</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42075814">prev</a><span>|</span><a href="#42075976">next</a><span>|</span><label class="collapse" for="c-42075843">[-]</label><label class="expand" for="c-42075843">[8 more]</label></div><br/><div class="children"><div class="content">&gt; See also Linux&#x27;s nolibc headers<p>Kind of an understatement. The existence of an official interface obsoletes 3rd party projects like the one posted.</div><br/><div id="42076048" class="c"><input type="checkbox" id="c-42076048" checked=""/><div class="controls bullet"><span class="by">bla3</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075843">parent</a><span>|</span><a href="#42079843">next</a><span>|</span><label class="collapse" for="c-42076048">[-]</label><label class="expand" for="c-42076048">[4 more]</label></div><br/><div class="children"><div class="content">Might be a license thing? The Linux headers are probably GPL like the rest of Linux.</div><br/><div id="42076250" class="c"><input type="checkbox" id="c-42076250" checked=""/><div class="controls bullet"><span class="by">unmole</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076048">parent</a><span>|</span><a href="#42076315">next</a><span>|</span><label class="collapse" for="c-42076250">[-]</label><label class="expand" for="c-42076250">[1 more]</label></div><br/><div class="children"><div class="content">The Linux kernel licence explicitly says programs using the syscall interface are not considered derivative works and that GPL does not apply to them: <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;LICENSES&#x2F;exceptions&#x2F;Linux-syscall-note">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;LICENSES&#x2F;excep...</a></div><br/></div></div><div id="42076315" class="c"><input type="checkbox" id="c-42076315" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076048">parent</a><span>|</span><a href="#42076250">prev</a><span>|</span><a href="#42077152">next</a><span>|</span><label class="collapse" for="c-42076315">[-]</label><label class="expand" for="c-42076315">[1 more]</label></div><br/><div class="children"><div class="content">nolibc is NOT under GPL. See first line of each file.<p>&#x2F;* SPDX-License-Identifier: LGPL-2.1 OR MIT *&#x2F;<p>It&#x27;s technically not part Linux&#x27;s headers either. It&#x27;s published under the tools subdirectory, so it&#x27;s something that ships along with the kernel, but not used by the kernel itself. Basically it&#x27;s there as some people might find it useful, but could&#x27;ve as well been a separate repo.</div><br/></div></div></div></div><div id="42079843" class="c"><input type="checkbox" id="c-42079843" checked=""/><div class="controls bullet"><span class="by">yencabulator</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075843">parent</a><span>|</span><a href="#42076048">prev</a><span>|</span><a href="#42075921">next</a><span>|</span><label class="collapse" for="c-42079843">[-]</label><label class="expand" for="c-42079843">[1 more]</label></div><br/><div class="children"><div class="content">nolibc seems very minimal. For example, no pread&#x2F;pwrite just read&#x2F;write, forcing you to lseek and ruining concurrent use.</div><br/></div></div><div id="42075921" class="c"><input type="checkbox" id="c-42075921" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075843">parent</a><span>|</span><a href="#42079843">prev</a><span>|</span><a href="#42075976">next</a><span>|</span><label class="collapse" for="c-42075921">[-]</label><label class="expand" for="c-42075921">[2 more]</label></div><br/><div class="children"><div class="content">Ya totally - those wacky people at chrome must&#x27;ve just never heard of those headers &#x2F;s<p>What you don&#x27;t understand, because you don&#x27;t work on Chrome, or Chrome sized projects, is that generic, lowest common denominator implementations cannot be optimal for all use-cases and at scale (Chrome-sized project) those inefficiencies matter. That&#x27;s why this exists, that&#x27;s why folly exists, that&#x27;s why abseil exists, that&#x27;s why no not everyone can just use boost, etc etc etc</div><br/></div></div></div></div><div id="42075976" class="c"><input type="checkbox" id="c-42075976" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#42075761">parent</a><span>|</span><a href="#42075843">prev</a><span>|</span><a href="#42079415">next</a><span>|</span><label class="collapse" for="c-42075976">[-]</label><label class="expand" for="c-42075976">[5 more]</label></div><br/><div class="children"><div class="content">Well... last time I had a look at the assembly code of syscall entry on x86_64, I was scared away... this piece of &quot;assembly&quot; does require some very niche C compiler options to be compatible (stack alignment and more if I recall properly).<p>Linux &quot;C&quot; code hard dependency on gcc&#x2F;clang&#x2F;(&quot;ultra complex compilers&quot;) is getting worse by the day. It should (very easy to say, I know) have stayed very simple and plain C99+ with smart macro definitions to be replaced with pure assembly or the missing bits for modern hardware programming (atomics&#x2F;memory barriers, explicit unaligned access, etc), but those abominations like _generic (or static assert,__thread,etc) are toxic additions to the C standard (there are too many toxic additions and not enough removal&#x2F;simplification&#x2F;hardening in ISO C, yes, we will have to define a &quot;C profile&quot; which breaks backward compatibility with hardening and simplifications).<p>I don&#x27;t say all extensions are bad, but I think they need more &quot;smart and pertinent pick and choose&quot; (and I know this is a tough call), just because they &quot;cost&quot;. For instance, for a kernel, we know it must have fine grained control of ELF object sections... or we would get much more source files (one per pertinent section) or &quot;many more source configuration macros&quot; (....but there I start to wonder if it was not actually the &quot;right&quot; way instead of requiring a C compiler to support such extension, it moves everything to the linker script... which is &quot;required&quot; anyway for a kernel).<p>Linus T. is not omnipotent and can do only that much and a lot of &quot;official&quot; linux devs are putting really nasty SDK dependency requirements in everyday&#x2F;everywhere kernels.<p>That said, on my side, many of my user apps are now directly using linux syscalls... but are written in RISC-V assembly interpreted on x86_64 (I have a super lean interpreter&#x2F;syscall translater written in x86_64 assembly and a super lean executable format wrapped in ELF executable format), or very plain and simple C99+ (legacy or because I want some apps to be a bit more &#x27;platform crossy&#x27;... for now).</div><br/><div id="42076139" class="c"><input type="checkbox" id="c-42076139" checked=""/><div class="controls bullet"><span class="by">jwatzman</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075976">parent</a><span>|</span><a href="#42076799">next</a><span>|</span><label class="collapse" for="c-42076139">[-]</label><label class="expand" for="c-42076139">[2 more]</label></div><br/><div class="children"><div class="content">Can you elaborate on the complexity here for syscall entry on x86_64? (Or link to what you were reading?) Another commenter linked to Linux&#x27;s own &quot;nolibc&quot; which is similar to, though simpler than, the Google project in the OP. Their x64_64 arch support is here, which looks simple enough, putting things into registers: <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;tools&#x2F;include&#x2F;nolibc&#x2F;arch-x86_64.h">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;tools&#x2F;include&#x2F;...</a><p>The non-arch-specific callers which use this are here, which also look relatively straightforward: <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;tools&#x2F;include&#x2F;nolibc&#x2F;arch-x86_64.h">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;master&#x2F;tools&#x2F;include&#x2F;...</a><p>I don&#x27;t see any complex stack alignment or anything which reads to me like it would require &quot;niche C compiler options&quot;, so I&#x27;m curious if I&#x27;m missing something?</div><br/><div id="42080579" class="c"><input type="checkbox" id="c-42080579" checked=""/><div class="controls bullet"><span class="by">kchr</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42076139">parent</a><span>|</span><a href="#42076799">next</a><span>|</span><label class="collapse" for="c-42080579">[-]</label><label class="expand" for="c-42080579">[1 more]</label></div><br/><div class="children"><div class="content">You linked the same file twice, was that intentional?</div><br/></div></div></div></div><div id="42076799" class="c"><input type="checkbox" id="c-42076799" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075976">parent</a><span>|</span><a href="#42076139">prev</a><span>|</span><a href="#42076126">next</a><span>|</span><label class="collapse" for="c-42076799">[-]</label><label class="expand" for="c-42076799">[1 more]</label></div><br/><div class="children"><div class="content">Linux has literally never been standard C. Linus used as many GCC extensions as he could from day 1.</div><br/></div></div><div id="42076126" class="c"><input type="checkbox" id="c-42076126" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#42075761">root</a><span>|</span><a href="#42075976">parent</a><span>|</span><a href="#42076799">prev</a><span>|</span><a href="#42079415">next</a><span>|</span><label class="collapse" for="c-42076126">[-]</label><label class="expand" for="c-42076126">[1 more]</label></div><br/><div class="children"><div class="content">It is hard to take seriously someone that claims that thread locals are a toxic addition to the standard. (incidentally __thread is a GCC extension that predates the standard by almost a decade).</div><br/></div></div></div></div></div></div><div id="42079415" class="c"><input type="checkbox" id="c-42079415" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42075761">prev</a><span>|</span><a href="#42076903">next</a><span>|</span><label class="collapse" for="c-42079415">[-]</label><label class="expand" for="c-42079415">[5 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t wait for Zig team to adopt this over libc, citing concerns about &quot;libc not existing on certain configurations&quot;[1]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1840">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;1840</a></div><br/><div id="42079989" class="c"><input type="checkbox" id="c-42079989" checked=""/><div class="controls bullet"><span class="by">TUSF</span><span>|</span><a href="#42079415">parent</a><span>|</span><a href="#42080213">next</a><span>|</span><label class="collapse" for="c-42079989">[-]</label><label class="expand" for="c-42079989">[2 more]</label></div><br/><div class="children"><div class="content">Zig on Linux already directly interfaces with syscalls,[0] unless your library or application directly links libc.<p>[0]: <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;#std.os.linux" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&#x2F;std&#x2F;#std.os.linux</a></div><br/><div id="42083046" class="c"><input type="checkbox" id="c-42083046" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42079415">root</a><span>|</span><a href="#42079989">parent</a><span>|</span><a href="#42080213">next</a><span>|</span><label class="collapse" for="c-42083046">[-]</label><label class="expand" for="c-42083046">[1 more]</label></div><br/><div class="children"><div class="content">Oh, there you go :)</div><br/></div></div></div></div><div id="42080213" class="c"><input type="checkbox" id="c-42080213" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#42079415">parent</a><span>|</span><a href="#42079989">prev</a><span>|</span><a href="#42076903">next</a><span>|</span><label class="collapse" for="c-42080213">[-]</label><label class="expand" for="c-42080213">[2 more]</label></div><br/><div class="children"><div class="content">Welcome to 2016. <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;5f0bfcac24036e1fff0b2beda643a60dad465213&#x2F;std&#x2F;syscall.zig">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;blob&#x2F;5f0bfcac24036e1fff0b2bed...</a></div><br/><div id="42083043" class="c"><input type="checkbox" id="c-42083043" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42079415">root</a><span>|</span><a href="#42080213">parent</a><span>|</span><a href="#42076903">next</a><span>|</span><label class="collapse" for="c-42083043">[-]</label><label class="expand" for="c-42083043">[1 more]</label></div><br/><div class="children"><div class="content">:&#x27;(</div><br/></div></div></div></div></div></div><div id="42076903" class="c"><input type="checkbox" id="c-42076903" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#42079415">prev</a><span>|</span><a href="#42077402">next</a><span>|</span><label class="collapse" for="c-42076903">[-]</label><label class="expand" for="c-42076903">[8 more]</label></div><br/><div class="children"><div class="content">Disappointing that errors are still signaled by assigning to `errno` (you can apparently override this to some other global, but it has to be a global or global-like lvalue).<p>The kernel actually signals errors by returning a negative error code (on most arches), which seems like a better calling convention. Storing errors in something like `errno` opens a whole can of worms around thread safety and signal safety, while seemingly providing very little benefit beyond following tradition.</div><br/><div id="42080569" class="c"><input type="checkbox" id="c-42080569" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#42076903">parent</a><span>|</span><a href="#42077077">next</a><span>|</span><label class="collapse" for="c-42080569">[-]</label><label class="expand" for="c-42080569">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a funny circular dependency in glibc sources because errno lives in the TLS block which is allocated using __sbrk which can set the errno before it&#x27;s allocated (see the __libc_setup_tls).<p>The branch that actually touches the errno is unlikely to be executed. However I did experience a puzzling crash with a cross-compiled libc because the compiler was smart enough to inject a speculative load of errno outside of the branch. Fun times.</div><br/></div></div><div id="42077077" class="c"><input type="checkbox" id="c-42077077" checked=""/><div class="controls bullet"><span class="by">sidkshatriya</span><span>|</span><a href="#42076903">parent</a><span>|</span><a href="#42080569">prev</a><span>|</span><a href="#42080338">next</a><span>|</span><label class="collapse" for="c-42077077">[-]</label><label class="expand" for="c-42077077">[4 more]</label></div><br/><div class="children"><div class="content">code that uses errno is also a bit harder to understand. I like the way Rust does it -- if a function can fail, it returns a Result.</div><br/><div id="42077474" class="c"><input type="checkbox" id="c-42077474" checked=""/><div class="controls bullet"><span class="by">dailykoder</span><span>|</span><a href="#42076903">root</a><span>|</span><a href="#42077077">parent</a><span>|</span><a href="#42080338">next</a><span>|</span><label class="collapse" for="c-42077474">[-]</label><label class="expand" for="c-42077474">[3 more]</label></div><br/><div class="children"><div class="content">While that might be true and the industry has evolved and learned about &quot;better&quot; ways, the old systems still exist. I don&#x27;t see any reason to complain about it.<p>Yes, we can do better. Yes, we probably should do better. But in some cases you really have to think through every edge case and in the end someone has to do it. So just be grateful for what we have.</div><br/><div id="42080587" class="c"><input type="checkbox" id="c-42080587" checked=""/><div class="controls bullet"><span class="by">alexey-salmin</span><span>|</span><a href="#42076903">root</a><span>|</span><a href="#42077474">parent</a><span>|</span><a href="#42080574">next</a><span>|</span><label class="collapse" for="c-42080587">[-]</label><label class="expand" for="c-42080587">[1 more]</label></div><br/><div class="children"><div class="content">For old systems -- yes, of course. But designing a new, incompatible API around errno is just backwards.</div><br/></div></div><div id="42080574" class="c"><input type="checkbox" id="c-42080574" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42076903">root</a><span>|</span><a href="#42077474">parent</a><span>|</span><a href="#42080587">prev</a><span>|</span><a href="#42080338">next</a><span>|</span><label class="collapse" for="c-42080574">[-]</label><label class="expand" for="c-42080574">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think this is an &quot;old system&quot; though.</div><br/></div></div></div></div></div></div><div id="42080338" class="c"><input type="checkbox" id="c-42080338" checked=""/><div class="controls bullet"><span class="by">AndyKelley</span><span>|</span><a href="#42076903">parent</a><span>|</span><a href="#42077077">prev</a><span>|</span><a href="#42077402">next</a><span>|</span><label class="collapse" for="c-42080338">[-]</label><label class="expand" for="c-42080338">[2 more]</label></div><br/><div class="children"><div class="content">Disappointing is an understatement. Can&#x27;t believe these people are making a browser. I&#x27;m sure they have some Google-flavored excuse for why to repeat this ridiculous threadlocal errno API.</div><br/><div id="42083219" class="c"><input type="checkbox" id="c-42083219" checked=""/><div class="controls bullet"><span class="by">kentonv</span><span>|</span><a href="#42076903">root</a><span>|</span><a href="#42080338">parent</a><span>|</span><a href="#42077402">next</a><span>|</span><label class="collapse" for="c-42083219">[-]</label><label class="expand" for="c-42083219">[1 more]</label></div><br/><div class="children"><div class="content">That seems a bit harsh. Maybe they just wanted it to be a drop-in replacement for glibc...</div><br/></div></div></div></div></div></div><div id="42077402" class="c"><input type="checkbox" id="c-42077402" checked=""/><div class="controls bullet"><span class="by">Aransentin</span><span>|</span><a href="#42076903">prev</a><span>|</span><a href="#42082637">next</a><span>|</span><label class="collapse" for="c-42077402">[-]</label><label class="expand" for="c-42077402">[4 more]</label></div><br/><div class="children"><div class="content">&gt; We try to hide some of the differences between arches when reasonably feasible. e.g. Newer architectures no longer provide an open syscall, but do provide openat. We will still expose a sys_open helper by default that calls into openat instead.<p>Sometimes you actually want to make sure that the exact syscall is called; e.g. you&#x27;re writing a little program protected by strict seccomp rules. If the layer can magically call some other syscall under the hood this won&#x27;t work anymore.</div><br/><div id="42077579" class="c"><input type="checkbox" id="c-42077579" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#42077402">parent</a><span>|</span><a href="#42082637">next</a><span>|</span><label class="collapse" for="c-42077579">[-]</label><label class="expand" for="c-42077579">[3 more]</label></div><br/><div class="children"><div class="content">musl does this too. glibc may also, I haven&#x27;t checked in a long time. I bet rust, etc., does too. You always need to check.</div><br/><div id="42077705" class="c"><input type="checkbox" id="c-42077705" checked=""/><div class="controls bullet"><span class="by">king_geedorah</span><span>|</span><a href="#42077402">root</a><span>|</span><a href="#42077579">parent</a><span>|</span><a href="#42082637">next</a><span>|</span><label class="collapse" for="c-42077705">[-]</label><label class="expand" for="c-42077705">[2 more]</label></div><br/><div class="children"><div class="content">Glibc definitely does this transparent mapping as well. Calling
    int fd = open(&lt;path&gt;, O_RDONLY)
yields
    openat(AT_FDCWD, &lt;path&gt;, O_RDONLY)
when running through strace.</div><br/><div id="42079046" class="c"><input type="checkbox" id="c-42079046" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#42077402">root</a><span>|</span><a href="#42077705">parent</a><span>|</span><a href="#42082637">next</a><span>|</span><label class="collapse" for="c-42079046">[-]</label><label class="expand" for="c-42079046">[1 more]</label></div><br/><div class="children"><div class="content">This really surprised me when I was digging into Linux tracing technology and noticed no `open` syscalls on my running system. It was all `openat`. I don&#x27;t know when this transition happened, but I totally missed it.</div><br/></div></div></div></div></div></div></div></div><div id="42082637" class="c"><input type="checkbox" id="c-42082637" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42077402">prev</a><span>|</span><a href="#42076534">next</a><span>|</span><label class="collapse" for="c-42082637">[-]</label><label class="expand" for="c-42082637">[1 more]</label></div><br/><div class="children"><div class="content">You have to be pretty careful when using syscalls directly, at least in the presence of some libc. For example, from what I have gathered from random tidbits here and there, it&#x27;s not a good idea to use any of the fork-like calls (fork, clone, etc.) if you have any threads that were created using glibc.</div><br/></div></div><div id="42076534" class="c"><input type="checkbox" id="c-42076534" checked=""/><div class="controls bullet"><span class="by">IAmLiterallyAB</span><span>|</span><a href="#42082637">prev</a><span>|</span><a href="#42080017">next</a><span>|</span><label class="collapse" for="c-42076534">[-]</label><label class="expand" for="c-42076534">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been using my own version of this. Maybe I&#x27;ll switch over, this looks more complete.</div><br/></div></div><div id="42080017" class="c"><input type="checkbox" id="c-42080017" checked=""/><div class="controls bullet"><span class="by">iTokio</span><span>|</span><a href="#42076534">prev</a><span>|</span><a href="#42076326">next</a><span>|</span><label class="collapse" for="c-42080017">[-]</label><label class="expand" for="c-42080017">[1 more]</label></div><br/><div class="children"><div class="content">Using go is a nice way to do that by default as it also directly uses  syscalls (see the <i>sys</i> package)</div><br/></div></div><div id="42076326" class="c"><input type="checkbox" id="c-42076326" checked=""/><div class="controls bullet"><span class="by">jagrsw</span><span>|</span><a href="#42080017">prev</a><span>|</span><a href="#42077282">next</a><span>|</span><label class="collapse" for="c-42076326">[-]</label><label class="expand" for="c-42076326">[12 more]</label></div><br/><div class="children"><div class="content">Just a friendly reminder that syscall() is a vararg function. Meaning, you can&#x27;t just go throwing arguments at it (so maybe it&#x27;s better to use this wrapper to avoid problems instead).<p>For example, on a 64-bit arch, this code would be sus.<p>syscall(__NR_syscall_taking_6_args, 1, 2, 3, 4, 5, 6);<p>Quiz: why<p>PS: it&#x27;s a common mistake, so I thought I&#x27;d save you a trip down the debugging rabbit hole.</div><br/><div id="42076464" class="c"><input type="checkbox" id="c-42076464" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42076326">parent</a><span>|</span><a href="#42078034">next</a><span>|</span><label class="collapse" for="c-42076464">[-]</label><label class="expand" for="c-42076464">[9 more]</label></div><br/><div class="children"><div class="content">A quiz is <i>the opposite</i> of saving someone effort.</div><br/><div id="42076708" class="c"><input type="checkbox" id="c-42076708" checked=""/><div class="controls bullet"><span class="by">eddd-ddde</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42076464">parent</a><span>|</span><a href="#42077123">next</a><span>|</span><label class="collapse" for="c-42076708">[-]</label><label class="expand" for="c-42076708">[6 more]</label></div><br/><div class="children"><div class="content">Exactly, I am now morally bound to figure out the answer instead of going to work.</div><br/><div id="42076823" class="c"><input type="checkbox" id="c-42076823" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42076708">parent</a><span>|</span><a href="#42077123">next</a><span>|</span><label class="collapse" for="c-42076823">[-]</label><label class="expand" for="c-42076823">[5 more]</label></div><br/><div class="children"><div class="content">The last argument would be on the stack instead of in a register which is where the kernel expects to find the arguments. But a proper <i>syscall</i> implementation would handle this just fine (e.g. &lt;<a href="https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;ba60be873554ecd141b55ea82647714933c0dbd4&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;x86_64&#x2F;syscall.S">https:&#x2F;&#x2F;github.com&#x2F;bminor&#x2F;glibc&#x2F;blob&#x2F;ba60be873554ecd141b55ea...</a>&gt;), so I don&#x27;t think there&#x27;s anything <i>sus</i> about it.</div><br/><div id="42077554" class="c"><input type="checkbox" id="c-42077554" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42076823">parent</a><span>|</span><a href="#42077123">next</a><span>|</span><label class="collapse" for="c-42077554">[-]</label><label class="expand" for="c-42077554">[4 more]</label></div><br/><div class="children"><div class="content">&gt; movq 8(%rsp),%r9<p>This is a huge edgecase but is 8(%rsp) guaranteed to be readable memory</div><br/><div id="42079962" class="c"><input type="checkbox" id="c-42079962" checked=""/><div class="controls bullet"><span class="by">achierius</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42077554">parent</a><span>|</span><a href="#42077123">next</a><span>|</span><label class="collapse" for="c-42079962">[-]</label><label class="expand" for="c-42079962">[3 more]</label></div><br/><div class="children"><div class="content">Yes, see <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Red_zone_(computing)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Red_zone_(computing)</a></div><br/><div id="42080927" class="c"><input type="checkbox" id="c-42080927" checked=""/><div class="controls bullet"><span class="by">jagrsw</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42079962">parent</a><span>|</span><a href="#42081943">next</a><span>|</span><label class="collapse" for="c-42080927">[-]</label><label class="expand" for="c-42080927">[1 more]</label></div><br/><div class="children"><div class="content">The problem is something a bit else (jstarks figured it out somewhere below). I&#x27;m not a compiler&#x2F;abi eng, but it seems to depend on a compiler, eg. consider this with clang-16:<p><pre><code>  #include &lt;sys&#x2F;syscall.h&gt;
  #include &lt;unistd.h&gt;
  #include &lt;alloca.h&gt;
  #include &lt;string.h&gt;
  
  void s(long a, long b, long c, long d, long e, long f, long g) {
  }
  
  int main(void) {
   long a = 0xFFFFFFFFFFFFFFFF;
   s(a, a, a, a, a, a, a);
   syscall(9999, 1, 2, 3, 4, 5, 6);
   return 0;
  }

</code></pre>
Now, strace shows:<p><pre><code>  $ strace -e process_vm_readv .&#x2F;a
  process_vm_readv(1, 0x2, 3, 0x4, 5, 18446744069414584326) = -1 EINVAL (Invalid argument)
</code></pre>
objdump -d a<p><pre><code>  117f: 48 c7 45 f0 ff ff ff  movq   $0xffffffffffffffff,-0x10(%rbp)
  1186: ff 
  1187: 48 8b 7d f0           mov    -0x10(%rbp),%rdi
  118b: 48 8b 75 f0           mov    -0x10(%rbp),%rsi
  118f: 48 8b 55 f0           mov    -0x10(%rbp),%rdx
  1193: 48 8b 4d f0           mov    -0x10(%rbp),%rcx
  1197: 4c 8b 45 f0           mov    -0x10(%rbp),%r8
  119b: 4c 8b 4d f0           mov    -0x10(%rbp),%r9
  119f: 48 8b 45 f0           mov    -0x10(%rbp),%rax
  11a3: 48 89 04 24           mov    %rax,(%rsp)
  11a7: e8 94 ff ff ff        call   1140 &lt;s&gt;
  11ac: bf 36 01 00 00        mov    $0x136,%edi
  11b1: be 01 00 00 00        mov    $0x1,%esi
  11b6: ba 02 00 00 00        mov    $0x2,%edx
  11bb: b9 03 00 00 00        mov    $0x3,%ecx
  11c0: 41 b8 04 00 00 00     mov    $0x4,%r8d
  11c6: 41 b9 05 00 00 00     mov    $0x5,%r9d
  11cc: c7 04 24 06 00 00 00  movl   $0x6,(%rsp)
  11d3: b0 00                 mov    $0x0,%al
  11d5: e8 56 fe ff ff        call   1030 &lt;syscall@plt&gt;
</code></pre>
Only 4 bytes are put on the stack, but syscall will read 8.<p>It&#x27;s tricky if one doesn&#x27;t control types of arguments used in vararg.</div><br/></div></div><div id="42081943" class="c"><input type="checkbox" id="c-42081943" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42079962">parent</a><span>|</span><a href="#42080927">prev</a><span>|</span><a href="#42077123">next</a><span>|</span><label class="collapse" for="c-42081943">[-]</label><label class="expand" for="c-42081943">[1 more]</label></div><br/><div class="children"><div class="content">I think you misunderstand. The red zone is on the opposite side of rsp. This line is trying to read an argument that may not exist, relying on the fact that this will put garbage in the register which syscall then ignores. But this only works if the memory is readable.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42077123" class="c"><input type="checkbox" id="c-42077123" checked=""/><div class="controls bullet"><span class="by">Brian_K_White</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42076464">parent</a><span>|</span><a href="#42076708">prev</a><span>|</span><a href="#42078034">next</a><span>|</span><label class="collapse" for="c-42077123">[-]</label><label class="expand" for="c-42077123">[2 more]</label></div><br/><div class="children"><div class="content">I never get people who aren&#x27;t grateful for pointers. Being shown which direction to walk is of no value, they must also be carried there.<p>They didn&#x27;t claim to save work, they claimed to save hitting a bug, and having to debug it.<p>They said the word &quot;vararg&quot;. They gave you everything.</div><br/><div id="42081305" class="c"><input type="checkbox" id="c-42081305" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42077123">parent</a><span>|</span><a href="#42078034">next</a><span>|</span><label class="collapse" for="c-42081305">[-]</label><label class="expand" for="c-42081305">[1 more]</label></div><br/><div class="children"><div class="content">They are not some professor in my school, some valued colleague, or known kernel expert. They are a stranger on the internet. No, I can&#x27;t be bothered to research every person that claim to have some wisdom that they won&#x27;t articulate to cultivate an air of mystery.<p>They gave me everything to dismiss their claim.</div><br/></div></div></div></div></div></div><div id="42078034" class="c"><input type="checkbox" id="c-42078034" checked=""/><div class="controls bullet"><span class="by">jstarks</span><span>|</span><a href="#42076326">parent</a><span>|</span><a href="#42076464">prev</a><span>|</span><a href="#42077282">next</a><span>|</span><label class="collapse" for="c-42078034">[-]</label><label class="expand" for="c-42078034">[2 more]</label></div><br/><div class="children"><div class="content">I guess if the arch’s varargs conventions do something other than put each 32-bit value in a 64-bit “slot” (likely for inputs that end up on the stack, at least), then some of the arguments will not line up. Probably some of the last args will get combined into high&#x2F;low parts of a 64-bit register when moved into registers to pass to the kernel. And then subsequent register inputs will get garbage from the stack.<p>Need to cast them to long or size_t or whatever to prevent this.</div><br/><div id="42081079" class="c"><input type="checkbox" id="c-42081079" checked=""/><div class="controls bullet"><span class="by">jagrsw</span><span>|</span><a href="#42076326">root</a><span>|</span><a href="#42078034">parent</a><span>|</span><a href="#42077282">next</a><span>|</span><label class="collapse" for="c-42081079">[-]</label><label class="expand" for="c-42081079">[1 more]</label></div><br/><div class="children"><div class="content">Yes</div><br/></div></div></div></div></div></div><div id="42077282" class="c"><input type="checkbox" id="c-42077282" checked=""/><div class="controls bullet"><span class="by">wg0</span><span>|</span><a href="#42076326">prev</a><span>|</span><a href="#42078856">next</a><span>|</span><label class="collapse" for="c-42077282">[-]</label><label class="expand" for="c-42077282">[2 more]</label></div><br/><div class="children"><div class="content">So web apps can make Linux sys calls? Or its about Chrome OS?</div><br/><div id="42077362" class="c"><input type="checkbox" id="c-42077362" checked=""/><div class="controls bullet"><span class="by">thinkharderdev</span><span>|</span><a href="#42077282">parent</a><span>|</span><a href="#42078856">next</a><span>|</span><label class="collapse" for="c-42077362">[-]</label><label class="expand" for="c-42077362">[1 more]</label></div><br/><div class="children"><div class="content">The chrome browser itself I would think</div><br/></div></div></div></div><div id="42078856" class="c"><input type="checkbox" id="c-42078856" checked=""/><div class="controls bullet"><span class="by">mcnichol</span><span>|</span><a href="#42077282">prev</a><span>|</span><label class="collapse" for="c-42078856">[-]</label><label class="expand" for="c-42078856">[1 more]</label></div><br/><div class="children"><div class="content">0-Day incoming</div><br/></div></div></div></div></div></div></div></body></html>