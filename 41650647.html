<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html">Eliminating Memory Safety Vulnerabilities at the Source</a> <span class="domain">(<a href="https://security.googleblog.com">security.googleblog.com</a>)</span></div><div class="subtext"><span>coffeeaddict1</span> | <span>96 comments</span></div><br/><div><div id="41651961" class="c"><input type="checkbox" id="c-41651961" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41653596">next</a><span>|</span><label class="collapse" for="c-41651961">[-]</label><label class="expand" for="c-41651961">[14 more]</label></div><br/><div class="children"><div class="content">This is a very interesting post! One takeaway is that you don&#x27;t need to re-write the world. Transitioning <i>new</i> development to a memory safe language can bring meaningful improvements. This is much easier (and cheaper) than needing to port everything over in order to get an effect.</div><br/><div id="41654301" class="c"><input type="checkbox" id="c-41654301" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#41651961">parent</a><span>|</span><a href="#41654386">next</a><span>|</span><label class="collapse" for="c-41654301">[-]</label><label class="expand" for="c-41654301">[3 more]</label></div><br/><div class="children"><div class="content">In fact, these results imply that the benefits of re-writing the world are limited in terms of security. This raises the cost-benefit ratio of keeping mature legacy code and only using memory-safe languages for new code.<p>This also implies that languages and tooling with robust support for integrating with unsafe legacy code are even more desirable.</div><br/><div id="41655981" class="c"><input type="checkbox" id="c-41655981" checked=""/><div class="controls bullet"><span class="by">Xylakant</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654301">parent</a><span>|</span><a href="#41654386">next</a><span>|</span><label class="collapse" for="c-41655981">[-]</label><label class="expand" for="c-41655981">[2 more]</label></div><br/><div class="children"><div class="content">Essentially, this has been Rusts value proposition from the outset - build a language that you can integrate into other codebases seamlessly, hence the choice of no runtime, no garbage collector etc. Bindgen (<a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-bindgen">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-bindgen</a>) and similar tooling were around essentially since day one to assist in that.<p>It’s the only approach that has any chance of transitioning away from unsafe languages for existing, mature codebases. Rewriting entirely in a different language is not a reasonable proposition for every practical real-world project.</div><br/><div id="41656012" class="c"><input type="checkbox" id="c-41656012" checked=""/><div class="controls bullet"><span class="by">dadrian</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41655981">parent</a><span>|</span><a href="#41654386">next</a><span>|</span><label class="collapse" for="c-41656012">[-]</label><label class="expand" for="c-41656012">[1 more]</label></div><br/><div class="children"><div class="content">Rust had to be dragged kicking and screaming into integration with other languages, and its C++ compatibility is a joke compared to Swift.<p>It&#x27;s absolutely true that you need integration and compatibility to enable iterative improvements, but Rust historically has been hostile to anything besides unsafe C ABI FFI, which is not suitable for the vast majority of incremental development that needs to happen.<p>Luckily, this is starting to change.</div><br/></div></div></div></div></div></div><div id="41654386" class="c"><input type="checkbox" id="c-41654386" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41651961">parent</a><span>|</span><a href="#41654301">prev</a><span>|</span><a href="#41653596">next</a><span>|</span><label class="collapse" for="c-41654386">[-]</label><label class="expand" for="c-41654386">[10 more]</label></div><br/><div class="children"><div class="content">From security perspective I agree but what if you want to be rid of GC or just reduce your overall resource consumption?</div><br/><div id="41654812" class="c"><input type="checkbox" id="c-41654812" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654386">parent</a><span>|</span><a href="#41654924">next</a><span>|</span><label class="collapse" for="c-41654812">[-]</label><label class="expand" for="c-41654812">[4 more]</label></div><br/><div class="children"><div class="content">Your engineers are usually your most expensive resource. Developing software in Typescript or even Ruby is a way to get to the revenue faster, having spent less money on development. Development cost and time (that is, the opportunity cost) are usually the most important limitations for a project where the defect rate does not need to be extremely low (like  in aircraft control firmware). Rust saves you development time because less of it is spent fixing bugs, but often would pick it not because it saves you RAM and CPU cycles; Haskell or, well, Ada&#x2F;Spark may be comparably efficient if you can wield them.</div><br/><div id="41655035" class="c"><input type="checkbox" id="c-41655035" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654812">parent</a><span>|</span><a href="#41655753">next</a><span>|</span><label class="collapse" for="c-41655035">[-]</label><label class="expand" for="c-41655035">[2 more]</label></div><br/><div class="children"><div class="content">This is true, but there is a crossover point where engineers spend more time understanding existing code than writing new code.  Crossing it is typically a point where more static languages with more built in checks become cheaper than more dynamic code.  In my experience, it takes about a year to reach this point, less if you hire more people.</div><br/></div></div><div id="41655753" class="c"><input type="checkbox" id="c-41655753" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654812">parent</a><span>|</span><a href="#41655035">prev</a><span>|</span><a href="#41654924">next</a><span>|</span><label class="collapse" for="c-41655753">[-]</label><label class="expand" for="c-41655753">[1 more]</label></div><br/><div class="children"><div class="content">To a point. Let&#x27;s say you&#x27;re optimizing a backend written in TS on Amazon, sure it&#x27;s cheaper to hire guys to optimize it, but at some point it won&#x27;t be. Either you need some really high class talent to start optimizing shit out of TS or you can&#x27;t scale as fast as before.<p>Didn&#x27;t something similar happened at Discord. It was Go if I recall.</div><br/></div></div></div></div><div id="41654924" class="c"><input type="checkbox" id="c-41654924" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654386">parent</a><span>|</span><a href="#41654812">prev</a><span>|</span><a href="#41654500">next</a><span>|</span><label class="collapse" for="c-41654924">[-]</label><label class="expand" for="c-41654924">[3 more]</label></div><br/><div class="children"><div class="content">Learning how to actually use the language features that don&#x27;t rely on GC, like on Swift, D, C#, Linear Haskell, Go, Eiffel, OCaml effects... is already a great step forward.<p>Plenty of people keep putting GC languages on the same basket without understanding what they are talking about.<p>Then if it is a domain where any kind of automatic resource management is impossible due to execution deadlines, or memory availability, Rust is an option.</div><br/><div id="41654992" class="c"><input type="checkbox" id="c-41654992" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654924">parent</a><span>|</span><a href="#41654500">next</a><span>|</span><label class="collapse" for="c-41654992">[-]</label><label class="expand" for="c-41654992">[2 more]</label></div><br/><div class="children"><div class="content">Well Rust also has certain aspects of “automatic resource management”. You can run into execution deadline issues with allocation or reallocated (drop) in Rust. The patterns to avoid this in critical areas is largely the same in any of the languages you listed.<p>Though I like using effect systems like in Nim or Ocaml for preventing allocation in specific areas.</div><br/><div id="41655541" class="c"><input type="checkbox" id="c-41655541" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654992">parent</a><span>|</span><a href="#41654500">next</a><span>|</span><label class="collapse" for="c-41655541">[-]</label><label class="expand" for="c-41655541">[1 more]</label></div><br/><div class="children"><div class="content">You can even run into execution deadlines with malloc()&#x2F;free(), that is why there are companies that made business out of selling specialized versions of them, and nowadays that is only less of a business because there are similar FOSS implementations.<p>The point is not winning micro-benchmarks games, rather there are specific SLAs for resource consumption and execution deadlines, is the language toolchain able to meet them, when the language features are used as they should, or does it run out of juice to meet those targets?<p>The recent Guile performance discussion thread is a good example.<p>If language X does meet the targets, and one still goes for &quot;Rewrite XYZ into ZYW&quot; approach, then we are beyond pure technical considerations.</div><br/></div></div></div></div></div></div><div id="41654500" class="c"><input type="checkbox" id="c-41654500" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654386">parent</a><span>|</span><a href="#41654924">prev</a><span>|</span><a href="#41653596">next</a><span>|</span><label class="collapse" for="c-41654500">[-]</label><label class="expand" for="c-41654500">[2 more]</label></div><br/><div class="children"><div class="content">Then you should use the language that’s memory safe without GC.</div><br/><div id="41654641" class="c"><input type="checkbox" id="c-41654641" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41651961">root</a><span>|</span><a href="#41654500">parent</a><span>|</span><a href="#41653596">next</a><span>|</span><label class="collapse" for="c-41654641">[-]</label><label class="expand" for="c-41654641">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I&#x27;m saying in those cases it does make some sense to rewrite it in Rust.</div><br/></div></div></div></div></div></div></div></div><div id="41653596" class="c"><input type="checkbox" id="c-41653596" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41651961">prev</a><span>|</span><a href="#41654207">next</a><span>|</span><label class="collapse" for="c-41653596">[-]</label><label class="expand" for="c-41653596">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Increasing productivity: Safe Coding improves code correctness and developer productivity by shifting bug finding further left, before the code is even checked in. We see this shift showing up in important metrics such as rollback rates (emergency code revert due to an unanticipated bug).<p>&gt; The Android team has observed that the rollback rate of Rust changes is less than half that of C++.<p>I&#x27;ve been writing high-scale production code in one language or another for 20 years.  But I when I found Rust in 2016 I knew that this was the one.  I was going to double-down on this.   I got Klabnik and Carol&#x27;s book literally the same day.  Still have my dead-tree copy.<p>It&#x27;s honestly re-invigorated my love for programming.</div><br/><div id="41654464" class="c"><input type="checkbox" id="c-41654464" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#41653596">parent</a><span>|</span><a href="#41654496">next</a><span>|</span><label class="collapse" for="c-41654464">[-]</label><label class="expand" for="c-41654464">[1 more]</label></div><br/><div class="children"><div class="content">That makes sense because the #1 reason I have had to roll back my own C++ commits is due to crashes from some dumb failure to check whether a null pointer is null.  If Rust is going to prevent that issue and other similar issues of stupid coding, you would expect whole classes of rollbacks to go away.</div><br/></div></div><div id="41654496" class="c"><input type="checkbox" id="c-41654496" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41653596">parent</a><span>|</span><a href="#41654464">prev</a><span>|</span><a href="#41654207">next</a><span>|</span><label class="collapse" for="c-41654496">[-]</label><label class="expand" for="c-41654496">[3 more]</label></div><br/><div class="children"><div class="content">That’s very kind, thank you.</div><br/><div id="41654628" class="c"><input type="checkbox" id="c-41654628" checked=""/><div class="controls bullet"><span class="by">benwilber0</span><span>|</span><a href="#41653596">root</a><span>|</span><a href="#41654496">parent</a><span>|</span><a href="#41654819">next</a><span>|</span><label class="collapse" for="c-41654628">[-]</label><label class="expand" for="c-41654628">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re a legend.  Thanks for writing The Book.  It really affected my life in a very positive way.</div><br/></div></div><div id="41654819" class="c"><input type="checkbox" id="c-41654819" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#41653596">root</a><span>|</span><a href="#41654496">parent</a><span>|</span><a href="#41654628">prev</a><span>|</span><a href="#41654207">next</a><span>|</span><label class="collapse" for="c-41654819">[-]</label><label class="expand" for="c-41654819">[1 more]</label></div><br/><div class="children"><div class="content">I feel entirely the same. I actively miss Rust when I need to choose another language.</div><br/></div></div></div></div></div></div><div id="41654207" class="c"><input type="checkbox" id="c-41654207" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#41653596">prev</a><span>|</span><a href="#41652762">next</a><span>|</span><label class="collapse" for="c-41654207">[-]</label><label class="expand" for="c-41654207">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d like to acknowledge that the charts in this article are remarkably clear and concise. A great demonstration of how careful data selection and labeling can communicate the intended ideas so effortlessly that they virtually disappear into the prose.<p>So the upshot of the fact that <i>vulnerabilities decay exponentially</i> is that the focus <i>should</i> be on net-new code. And spending effort on vast indiscriminate RiiR projects is a poor use of resources, <i>even for advancing the goal of maximal memory safety</i>. The fact that the easiest strategy, and the strategy recommended by all pragmatic rust experts, is actually also the best strategy to minimize memory vulnerabilities according to the data is notably convergent if not fortuitous.<p>&gt; The Android team has observed that the rollback rate of Rust changes is less than half that of C++.<p>Wow!</div><br/></div></div><div id="41652762" class="c"><input type="checkbox" id="c-41652762" checked=""/><div class="controls bullet"><span class="by">Wowfunhappy</span><span>|</span><a href="#41654207">prev</a><span>|</span><a href="#41652478">next</a><span>|</span><label class="collapse" for="c-41652762">[-]</label><label class="expand" for="c-41652762">[10 more]</label></div><br/><div class="children"><div class="content">&gt; The answer lies in an important observation: vulnerabilities decay exponentially. They have a half-life. [...] A large-scale study of vulnerability lifetimes2 published in 2022 in Usenix Security confirmed this phenomenon. Researchers found that the vast majority of vulnerabilities reside in new or recently modified code.<p>It stands to reason, then, that it would be even <i>better</i> for security to stop adding new features when they aren&#x27;t absolutely necessary. Windows LTSC is presumably the most secure version of Windows.</div><br/><div id="41654775" class="c"><input type="checkbox" id="c-41654775" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41652762">parent</a><span>|</span><a href="#41653292">next</a><span>|</span><label class="collapse" for="c-41654775">[-]</label><label class="expand" for="c-41654775">[3 more]</label></div><br/><div class="children"><div class="content">Individual bugs triggered in normal operation ought to decay over time on software that is maintained. If bugs cause problems, someone may report them and some fraction of them will be fixed. That&#x27;s a decay mechanism.<p>Not-yet exploited <i>vulnerabilities</i>, though, don&#x27;t have that decay mechanism. They don&#x27;t generate user unhappiness and bug reports. They just sit there, until an enemy with sufficient resources and motivation finds and exploits them.<p>There are more enemies in that league than there used to be.</div><br/><div id="41655068" class="c"><input type="checkbox" id="c-41655068" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#41652762">root</a><span>|</span><a href="#41654775">parent</a><span>|</span><a href="#41653292">next</a><span>|</span><label class="collapse" for="c-41655068">[-]</label><label class="expand" for="c-41655068">[2 more]</label></div><br/><div class="children"><div class="content">Your assertions contradict the Usenix research cited in TFA, which found that the lifetime of vulnerabilities _do_ follow an exponential decay. If it takes longer to find a vulnerability, then its lifetime is longer.</div><br/><div id="41655460" class="c"><input type="checkbox" id="c-41655460" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41652762">root</a><span>|</span><a href="#41655068">parent</a><span>|</span><a href="#41653292">next</a><span>|</span><label class="collapse" for="c-41655460">[-]</label><label class="expand" for="c-41655460">[1 more]</label></div><br/><div class="children"><div class="content">What the article calls a &quot;vunerability&quot; is something they found internally.<p>Looking at vulnerabilities that were found from attacks, it looks different. [1]
Most vulnerabilities are fixed in the first weeks or months. But ones that aren&#x27;t fixed within a year hang on for a long time. About 18% of reported vulnerabilities are never fixed.<p>[1] <a href="https:&#x2F;&#x2F;www.tenable.com&#x2F;blog&#x2F;what-is-the-lifespan-of-a-vulnerability" rel="nofollow">https:&#x2F;&#x2F;www.tenable.com&#x2F;blog&#x2F;what-is-the-lifespan-of-a-vulne...</a></div><br/></div></div></div></div></div></div><div id="41653292" class="c"><input type="checkbox" id="c-41653292" checked=""/><div class="controls bullet"><span class="by">wepple</span><span>|</span><a href="#41652762">parent</a><span>|</span><a href="#41654775">prev</a><span>|</span><a href="#41654331">next</a><span>|</span><label class="collapse" for="c-41653292">[-]</label><label class="expand" for="c-41653292">[5 more]</label></div><br/><div class="children"><div class="content">Or an alternative approach: only compile the subset of features you explicitly need.<p>Obviously there’s a ton of variance in how practical this is any place, but it’s less common than it should be.</div><br/><div id="41654304" class="c"><input type="checkbox" id="c-41654304" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41652762">root</a><span>|</span><a href="#41653292">parent</a><span>|</span><a href="#41653697">next</a><span>|</span><label class="collapse" for="c-41654304">[-]</label><label class="expand" for="c-41654304">[1 more]</label></div><br/><div class="children"><div class="content">This can be a really bad idea since it drastically increases the risk of users running a compiled combination of features that was never tested.</div><br/></div></div><div id="41653697" class="c"><input type="checkbox" id="c-41653697" checked=""/><div class="controls bullet"><span class="by">sieabahlpark</span><span>|</span><a href="#41652762">root</a><span>|</span><a href="#41653292">parent</a><span>|</span><a href="#41654304">prev</a><span>|</span><a href="#41654331">next</a><span>|</span><label class="collapse" for="c-41653697">[-]</label><label class="expand" for="c-41653697">[3 more]</label></div><br/><div class="children"><div class="content">Allow me to introduce a whole new suite of bugs that occur when feature A exists but feature B doesn&#x27;t.<p>Congrats you&#x27;re back to square 1!</div><br/><div id="41654558" class="c"><input type="checkbox" id="c-41654558" checked=""/><div class="controls bullet"><span class="by">wolrah</span><span>|</span><a href="#41652762">root</a><span>|</span><a href="#41653697">parent</a><span>|</span><a href="#41654331">next</a><span>|</span><label class="collapse" for="c-41654558">[-]</label><label class="expand" for="c-41654558">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Allow me to introduce a whole new suite of bugs that occur when feature A exists but feature B doesn&#x27;t.<p>Yeah, but are those bugs security bugs?  Memory safety bugs are a big focus because they&#x27;re the most common kind of bugs that can be exploited in a meaningful way.<p>Disabling entire segments of code is unlikely to introduce new memory safety bugs.  It&#x27;s certainly likely to find race conditions, and those can sometimes lead to security bugs, but its not nearly as likely as with memory safety bugs.</div><br/><div id="41655071" class="c"><input type="checkbox" id="c-41655071" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#41652762">root</a><span>|</span><a href="#41654558">parent</a><span>|</span><a href="#41654331">next</a><span>|</span><label class="collapse" for="c-41655071">[-]</label><label class="expand" for="c-41655071">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah, but are those bugs security bugs?<p>If the software is unusable, it doesn&#x27;t matter if it has security bugs too. Or, to rephrase, the safest software is software nobody uses.</div><br/></div></div></div></div></div></div></div></div><div id="41654331" class="c"><input type="checkbox" id="c-41654331" checked=""/><div class="controls bullet"><span class="by">Ygg2</span><span>|</span><a href="#41652762">parent</a><span>|</span><a href="#41653292">prev</a><span>|</span><a href="#41652478">next</a><span>|</span><label class="collapse" for="c-41654331">[-]</label><label class="expand" for="c-41654331">[1 more]</label></div><br/><div class="children"><div class="content">&gt; that it would be even better for security to stop adding new features when they aren&#x27;t absolutely necessary<p>Even if features aren&#x27;t necessary to sell your software, new hardware and better security algorithms or full on deprecation of existing algos will still happen. Which will introduce new code.</div><br/></div></div></div></div><div id="41652478" class="c"><input type="checkbox" id="c-41652478" checked=""/><div class="controls bullet"><span class="by">ievans</span><span>|</span><a href="#41652762">prev</a><span>|</span><a href="#41652181">next</a><span>|</span><label class="collapse" for="c-41652478">[-]</label><label class="expand" for="c-41652478">[1 more]</label></div><br/><div class="children"><div class="content">So the argument is because the vulnerability lifetime is exponentially distributed, focusing on secure defaults like memory safety in <i>new code</i> is disproportionately valuable, both theoretically and now evidentially seen over six years on the Android codebase.<p>Amazing, I&#x27;ve never seen this argument used to support shift&#x2F;left secure guardrails but it&#x27;s great. Especially for those with larger, legacy codebases who might otherwise say &quot;why bother, we&#x27;re never going to benefit from memory-safety on our 100M lines of C++.&quot;<p>I think it also implies any lightweight vulnerability detection has disproportionate benefit -- even if it was to only look at new code &amp; dependencies vs the backlog.</div><br/></div></div><div id="41652181" class="c"><input type="checkbox" id="c-41652181" checked=""/><div class="controls bullet"><span class="by">SkyMarshal</span><span>|</span><a href="#41652478">prev</a><span>|</span><a href="#41652794">next</a><span>|</span><label class="collapse" for="c-41652181">[-]</label><label class="expand" for="c-41652181">[16 more]</label></div><br/><div class="children"><div class="content">They talk about &quot;memory safe languages (MSL)&quot; plural, as if there is more than one, but only explicitly name Rust as the MSL they&#x27;re transitioning to and improving interoperability with.  They also mention Kotlin in the context of improving Rust&lt;&gt;Kotlin interop, which also has some memory-safe features but maybe not to same extent as Rust.  Are those the only two Google uses, or are there others they could be referring to?</div><br/><div id="41652208" class="c"><input type="checkbox" id="c-41652208" checked=""/><div class="controls bullet"><span class="by">steveklabnik</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41652262">next</a><span>|</span><label class="collapse" for="c-41652208">[-]</label><label class="expand" for="c-41652208">[4 more]</label></div><br/><div class="children"><div class="content">A few thoughts:<p>People who care about this issue, especially in the last few years, have been leaning into a &quot;memory safe language&quot; vs &quot;non memory safe language&quot; framing. This is because it gets at the root of the issue, which is safe by default vs not safe by default. It tries to avoid pointing fingers at, or giving recommendations for, particular languages, by instead putting the focus on the root cause.<p>In the specific case of Android, the subject of this post, I&#x27;m not aware of attempts to move into other MSLs than those. But I also don&#x27;t follow Android development generally, but I <i>do</i> follow these posts pretty closely, and I don&#x27;t remember any of them talking about stuff other than Rust or Kotlin.</div><br/><div id="41653704" class="c"><input type="checkbox" id="c-41653704" checked=""/><div class="controls bullet"><span class="by">amluto</span><span>|</span><a href="#41652181">root</a><span>|</span><a href="#41652208">parent</a><span>|</span><a href="#41655010">next</a><span>|</span><label class="collapse" for="c-41653704">[-]</label><label class="expand" for="c-41653704">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t remember any of them talking about stuff other than Rust or Kotlin.<p>Don’t forget the old, boring one: Java.<p>I assume the reason that Go doesn’t show up so much is that most Android processes have their managed, GC’d Java-ish-virtual-machine world and their native C&#x2F;C++ world.  Kotlin fits in with the former and Rust fits in with the latter.  Go is somewhat of its own thing.</div><br/><div id="41653854" class="c"><input type="checkbox" id="c-41653854" checked=""/><div class="controls bullet"><span class="by">vvanders</span><span>|</span><a href="#41652181">root</a><span>|</span><a href="#41653704">parent</a><span>|</span><a href="#41655010">next</a><span>|</span><label class="collapse" for="c-41653854">[-]</label><label class="expand" for="c-41653854">[1 more]</label></div><br/><div class="children"><div class="content">Android has a surprising amount of core OS functionality in boring managed Java code. ART&#x2F;Dalvik are quite impressive combined with a few other clever tricks to make a system that ran in a pretty small footprint.</div><br/></div></div></div></div></div></div><div id="41652262" class="c"><input type="checkbox" id="c-41652262" checked=""/><div class="controls bullet"><span class="by">alpire</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41652208">prev</a><span>|</span><a href="#41652607">next</a><span>|</span><label class="collapse" for="c-41652262">[-]</label><label class="expand" for="c-41652262">[1 more]</label></div><br/><div class="children"><div class="content">Android talked more about the memory-safe languages they&#x27;re using in a previous blog post: <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2022&#x2F;12&#x2F;memory-safe-languages-in-android-13.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2022&#x2F;12&#x2F;memory-safe-language...</a><p>Google also published their perspective on memory safety in <a href="https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;03&#x2F;secure-by-design-googles-perspective-on.html" rel="nofollow">https:&#x2F;&#x2F;security.googleblog.com&#x2F;2024&#x2F;03&#x2F;secure-by-design-goo...</a>, which also goes over some of the memory-safe languages in use like Java, Go and Rust.</div><br/></div></div><div id="41652607" class="c"><input type="checkbox" id="c-41652607" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41652262">prev</a><span>|</span><a href="#41652265">next</a><span>|</span><label class="collapse" for="c-41652607">[-]</label><label class="expand" for="c-41652607">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just Rust—rewriting a C network service into Java or Python or Go is also an example of transitioning to memory safe languages. The point is that you&#x27;re not exposed to memory safety bugs in your own code. Arguably it&#x27;s much better to choose a language <i>without</i> Rust-like manual memory management when you don&#x27;t absolutely need it.</div><br/></div></div><div id="41652265" class="c"><input type="checkbox" id="c-41652265" checked=""/><div class="controls bullet"><span class="by">dgacmu</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41652607">prev</a><span>|</span><a href="#41655317">next</a><span>|</span><label class="collapse" for="c-41652265">[-]</label><label class="expand" for="c-41652265">[1 more]</label></div><br/><div class="children"><div class="content">There are many and google uses several - rust, python, java, and go among them. But low-level code for Android has historically been in c++ and Rust is the primary memory-safe replacement for the stuff they&#x27;re building.</div><br/></div></div><div id="41655317" class="c"><input type="checkbox" id="c-41655317" checked=""/><div class="controls bullet"><span class="by">_ph_</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41652265">prev</a><span>|</span><a href="#41652472">next</a><span>|</span><label class="collapse" for="c-41655317">[-]</label><label class="expand" for="c-41655317">[1 more]</label></div><br/><div class="children"><div class="content">That is the separation between abstract considerations and a given projects constraints. In a given project there might be few choices, but if you talk about fundamental phenomena, you have to reason about arbitrary projects. And of course, there are plenty of alternatives to Rust. Even limited to Android, there are several choices, even if they might be a smaller set.</div><br/></div></div><div id="41652472" class="c"><input type="checkbox" id="c-41652472" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41655317">prev</a><span>|</span><a href="#41653698">next</a><span>|</span><label class="collapse" for="c-41652472">[-]</label><label class="expand" for="c-41652472">[1 more]</label></div><br/><div class="children"><div class="content">Java and Kotlin are used for apps. Rust is used for new system software.<p>Across Google, Go is used for some system software, but I haven&#x27;t seen it used in Android.</div><br/></div></div><div id="41653698" class="c"><input type="checkbox" id="c-41653698" checked=""/><div class="controls bullet"><span class="by">NoahKAndrews</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41652472">prev</a><span>|</span><a href="#41653759">next</a><span>|</span><label class="collapse" for="c-41653698">[-]</label><label class="expand" for="c-41653698">[4 more]</label></div><br/><div class="children"><div class="content">Kotlin is memory-safe. It runs with a GC.</div><br/><div id="41654321" class="c"><input type="checkbox" id="c-41654321" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41652181">root</a><span>|</span><a href="#41653698">parent</a><span>|</span><a href="#41653759">next</a><span>|</span><label class="collapse" for="c-41654321">[-]</label><label class="expand" for="c-41654321">[3 more]</label></div><br/><div class="children"><div class="content">GC is memory-safe.</div><br/><div id="41654523" class="c"><input type="checkbox" id="c-41654523" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41652181">root</a><span>|</span><a href="#41654321">parent</a><span>|</span><a href="#41653759">next</a><span>|</span><label class="collapse" for="c-41654523">[-]</label><label class="expand" for="c-41654523">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what they said.</div><br/><div id="41654529" class="c"><input type="checkbox" id="c-41654529" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41652181">root</a><span>|</span><a href="#41654523">parent</a><span>|</span><a href="#41653759">next</a><span>|</span><label class="collapse" for="c-41654529">[-]</label><label class="expand" for="c-41654529">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t read. oops.</div><br/></div></div></div></div></div></div></div></div><div id="41653759" class="c"><input type="checkbox" id="c-41653759" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41653698">prev</a><span>|</span><a href="#41653855">next</a><span>|</span><label class="collapse" for="c-41653759">[-]</label><label class="expand" for="c-41653759">[1 more]</label></div><br/><div class="children"><div class="content">Google has always tried to use a small set of languages. For Android they try to use C&#x2F;C++, Java&#x2F;Kotlin, and now Rust. The same lessons still apply in rampantly polyglot environments though.</div><br/></div></div><div id="41653855" class="c"><input type="checkbox" id="c-41653855" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#41652181">parent</a><span>|</span><a href="#41653759">prev</a><span>|</span><a href="#41652794">next</a><span>|</span><label class="collapse" for="c-41653855">[-]</label><label class="expand" for="c-41653855">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps they are even considering carbon to be memory safe</div><br/></div></div></div></div><div id="41652794" class="c"><input type="checkbox" id="c-41652794" checked=""/><div class="controls bullet"><span class="by">naming_the_user</span><span>|</span><a href="#41652181">prev</a><span>|</span><a href="#41652198">next</a><span>|</span><label class="collapse" for="c-41652794">[-]</label><label class="expand" for="c-41652794">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little uneasy about the conclusions being drawn here as the obvious counterpoint isn&#x27;t being raised - what if older code isn&#x27;t being looked at as hard and therefore vulnerabilities aren&#x27;t being discovered?<p>It&#x27;s far more common to look at recent commit logs than it is to look at some library that hasn&#x27;t changed for 20 years.</div><br/><div id="41653410" class="c"><input type="checkbox" id="c-41653410" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41652794">parent</a><span>|</span><a href="#41653042">next</a><span>|</span><label class="collapse" for="c-41653410">[-]</label><label class="expand" for="c-41653410">[2 more]</label></div><br/><div class="children"><div class="content">&gt; what if older code isn&#x27;t being looked at as hard and therefore vulnerabilities aren&#x27;t being discovered?<p>It wasn’t being look at as hard before either. I don’t think that’s changed.<p>They don’t give a theory for why older code has fewer bugs, but I’ve got one: they’ve been found.<p>If we assumed that any piece of code has a fixed amount of unknown bugs per 1000 lines, it stands to reason that overtime the sheer number of times the code is run with different inputs in prod makes it more and more likely they will be discovered. Between fixing them and the code reviews while fixing them the hope would be that on average things are being made better.<p>So overtime, there are fewer bugs per thousand lines in existing code. It’s been battle tested.<p>As the post says, if you continue introducing new bugs at the same rate you’re not going to make progress. But if using a memory safe language means you’re introducing fewer bugs in new features then overtime the total number of bugs should be going down.</div><br/><div id="41654203" class="c"><input type="checkbox" id="c-41654203" checked=""/><div class="controls bullet"><span class="by">pacaro</span><span>|</span><a href="#41652794">root</a><span>|</span><a href="#41653410">parent</a><span>|</span><a href="#41653042">next</a><span>|</span><label class="collapse" for="c-41654203">[-]</label><label class="expand" for="c-41654203">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always thought of this as being equivalent to &quot;work hardening&quot;<p>My concern with it is more about legitimately old code (android is 20ish years old, so reasonably falls into this category) which was written using standards and tools of the time (necessarily)<p>It requires a constant engineering effort to keep such code up to date. And the older  code is, typically, less well understood.<p>In addition older code (particularly in systems programming) is often associated with older requirements, some of which may have become niche over time.<p>That long tail of old, less frequently exercised, code feels like it may well have a sting in its tail.<p>The halflife&#x2F;work-hardening model depends on the code being stressed to find bugs</div><br/></div></div></div></div><div id="41653042" class="c"><input type="checkbox" id="c-41653042" checked=""/><div class="controls bullet"><span class="by">SoylentOrange</span><span>|</span><a href="#41652794">parent</a><span>|</span><a href="#41653410">prev</a><span>|</span><a href="#41653313">next</a><span>|</span><label class="collapse" for="c-41653042">[-]</label><label class="expand" for="c-41653042">[2 more]</label></div><br/><div class="children"><div class="content">I don’t understand this point. The project under scrutiny is Android and people are detecting vulnerabilities both manually and automatically based on source code&#x2F;binary, not over commit logs. Why would the commit logs be relevant at all to finding bugs?<p>The commits are just used for attribution. If there was some old lib that hasn’t been changed in 20 years that’s passed fuzzing and manual code inspection for 20 years without updates, chances are it’s solid.</div><br/><div id="41654514" class="c"><input type="checkbox" id="c-41654514" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41652794">root</a><span>|</span><a href="#41653042">parent</a><span>|</span><a href="#41653313">next</a><span>|</span><label class="collapse" for="c-41654514">[-]</label><label class="expand" for="c-41654514">[1 more]</label></div><br/><div class="children"><div class="content">Exploit authors look at commit logs because new features have bugs in them, and it&#x27;s easier to follow that to find vulnerabilities than dive into the codebase to find what&#x27;s already there.</div><br/></div></div></div></div><div id="41653313" class="c"><input type="checkbox" id="c-41653313" checked=""/><div class="controls bullet"><span class="by">e28eta</span><span>|</span><a href="#41652794">parent</a><span>|</span><a href="#41653042">prev</a><span>|</span><a href="#41652198">next</a><span>|</span><label class="collapse" for="c-41653313">[-]</label><label class="expand" for="c-41653313">[1 more]</label></div><br/><div class="children"><div class="content">I wasn’t entirely satisfied with the assertion that older code has fewer vulnerabilities either. It feels like there could be explanations other than age for the discrepancy.<p>For example: maybe the engineers over the last several years have focused on rewriting the riskiest parts in a MSL, and were less likely to change the lower risk old code.<p>Or… maybe there was a process or personnel change that led to more defects.<p>With that said, it does seem plausible to me that any given bug has a probability of detection per unit of time, and as time passes fewer defects remain to be found. And as long as your maintainers fix more vulnerabilities than they introduce, sure, older code will have fewer and the ones that remain are probably hard to find.</div><br/></div></div></div></div><div id="41652198" class="c"><input type="checkbox" id="c-41652198" checked=""/><div class="controls bullet"><span class="by">daft_pink</span><span>|</span><a href="#41652794">prev</a><span>|</span><a href="#41653919">next</a><span>|</span><label class="collapse" for="c-41652198">[-]</label><label class="expand" for="c-41652198">[6 more]</label></div><br/><div class="children"><div class="content">I’m curious how this applies to Mac vs Windows, where most newer Mac code is written in memory safe swift, while Windows still uses primarily uses C or C++.</div><br/><div id="41652291" class="c"><input type="checkbox" id="c-41652291" checked=""/><div class="controls bullet"><span class="by">akyuu</span><span>|</span><a href="#41652198">parent</a><span>|</span><a href="#41652337">next</a><span>|</span><label class="collapse" for="c-41652291">[-]</label><label class="expand" for="c-41652291">[3 more]</label></div><br/><div class="children"><div class="content">Apple is still adding large amounts of new Objective-C code in each new macOS version [0].<p>I haven&#x27;t found any language usage numbers for recent versions of Windows, but Microsoft is using Rust for both new development and rewriting old features [1] [2].<p>[0] Refer to section &quot;Evolution of the programming languages&quot; <a href="https:&#x2F;&#x2F;blog.timac.org&#x2F;2023&#x2F;1128-state-of-appkit-catalyst-swift-swiftui-mac&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.timac.org&#x2F;2023&#x2F;1128-state-of-appkit-catalyst-sw...</a><p>[1] <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2023&#x2F;04&#x2F;27&#x2F;microsoft_windows_rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2023&#x2F;04&#x2F;27&#x2F;microsoft_windows_rus...</a><p>[2] <a href="https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;01&#x2F;31&#x2F;microsoft_seeks_rust_developers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.theregister.com&#x2F;2024&#x2F;01&#x2F;31&#x2F;microsoft_seeks_rust_...</a></div><br/><div id="41653818" class="c"><input type="checkbox" id="c-41653818" checked=""/><div class="controls bullet"><span class="by">TazeTSchnitzel</span><span>|</span><a href="#41652198">root</a><span>|</span><a href="#41652291">parent</a><span>|</span><a href="#41652337">next</a><span>|</span><label class="collapse" for="c-41653818">[-]</label><label class="expand" for="c-41653818">[2 more]</label></div><br/><div class="children"><div class="content">It should be noted that Objective-C code is presumably a lot less prone to memory safety issues than C code on average, especially since Apple introduced Automatic Reference Counting (ARC). For example:<p>• Use-after-frees are avoided by ARC<p>• Null pointer dereferences are usually safe (sending a message to nil returns nil)<p>• Objective-C has a great standard library (Foundation) with safe collections among many other things; most of C&#x27;s dangerous parts are easily avoided in idiomatic Objective-C code that isn&#x27;t performance-critical<p>But a good part of Apple&#x27;s Objective-C code is probably there for implementing the underlying runtime, and that&#x27;s difficult to get right.</div><br/><div id="41654518" class="c"><input type="checkbox" id="c-41654518" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41652198">root</a><span>|</span><a href="#41653818">parent</a><span>|</span><a href="#41652337">next</a><span>|</span><label class="collapse" for="c-41654518">[-]</label><label class="expand" for="c-41654518">[1 more]</label></div><br/><div class="children"><div class="content">Most of Apple&#x27;s Objective-C code is in the application layer just like yours is</div><br/></div></div></div></div></div></div><div id="41652337" class="c"><input type="checkbox" id="c-41652337" checked=""/><div class="controls bullet"><span class="by">munificent</span><span>|</span><a href="#41652198">parent</a><span>|</span><a href="#41652291">prev</a><span>|</span><a href="#41653919">next</a><span>|</span><label class="collapse" for="c-41652337">[-]</label><label class="expand" for="c-41652337">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; while Windows still uses primarily uses C or C++.</i><p>Do you have data for that? My impression is that a large fraction of Windows development is C# these days. Back when I was at EA, nearly fifteen years ago, we were already leaning very heavily towards C# for internal tools.</div><br/><div id="41652519" class="c"><input type="checkbox" id="c-41652519" checked=""/><div class="controls bullet"><span class="by">tsujamin</span><span>|</span><a href="#41652198">root</a><span>|</span><a href="#41652337">parent</a><span>|</span><a href="#41653919">next</a><span>|</span><label class="collapse" for="c-41652519">[-]</label><label class="expand" for="c-41652519">[1 more]</label></div><br/><div class="children"><div class="content">Linking to my thread from yesterday, there’s definitely memory safe systems programming happening over there:  <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41642788">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41642788</a></div><br/></div></div></div></div></div></div><div id="41653919" class="c"><input type="checkbox" id="c-41653919" checked=""/><div class="controls bullet"><span class="by">Stem0037</span><span>|</span><a href="#41652198">prev</a><span>|</span><a href="#41651984">next</a><span>|</span><label class="collapse" for="c-41653919">[-]</label><label class="expand" for="c-41653919">[2 more]</label></div><br/><div class="children"><div class="content">The idea of &quot;Safe Coding&quot; as a fundamental shift in security approach is intriguing. I&#x27;d be interested in hearing more about how this is implemented in practice.</div><br/><div id="41654084" class="c"><input type="checkbox" id="c-41654084" checked=""/><div class="controls bullet"><span class="by">alpire</span><span>|</span><a href="#41653919">parent</a><span>|</span><a href="#41651984">next</a><span>|</span><label class="collapse" for="c-41654084">[-]</label><label class="expand" for="c-41654084">[1 more]</label></div><br/><div class="children"><div class="content">For more information on our safe coding approach, as applied to the web domain, check out this paper (<a href="https:&#x2F;&#x2F;static.googleusercontent.com&#x2F;media&#x2F;research.google.com&#x2F;en&#x2F;&#x2F;pubs&#x2F;archive&#x2F;42934.pdf" rel="nofollow">https:&#x2F;&#x2F;static.googleusercontent.com&#x2F;media&#x2F;research.google.c...</a>) or this talk (<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ccfEu-Jj0as" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ccfEu-Jj0as</a>).</div><br/></div></div></div></div><div id="41651984" class="c"><input type="checkbox" id="c-41651984" checked=""/><div class="controls bullet"><span class="by">cakoose</span><span>|</span><a href="#41653919">prev</a><span>|</span><a href="#41652050">next</a><span>|</span><label class="collapse" for="c-41651984">[-]</label><label class="expand" for="c-41651984">[3 more]</label></div><br/><div class="children"><div class="content"><i>What happens if we gradually transition to memory-safe languages for new features, while leaving existing code mostly untouched except for bug fixes?</i><p>...<p><i>In the final year of our simulation, despite the growth in memory-unsafe code, the number of memory safety vulnerabilities drops significantly, a seemingly counterintuitive result [...]</i><p>Why would this be counterintuitive? If you&#x27;re only touching the memory-unsafe code to fix bugs, it seems obviously that the number of memory-safety bugs will go down.<p>Am I missing something?</div><br/><div id="41652071" class="c"><input type="checkbox" id="c-41652071" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#41651984">parent</a><span>|</span><a href="#41653428">next</a><span>|</span><label class="collapse" for="c-41652071">[-]</label><label class="expand" for="c-41652071">[1 more]</label></div><br/><div class="children"><div class="content">The counter intuitive part is that there is now more code written in memory unsafe languages than there was before.  Even if it&#x27;s just bug fixing.<p>It&#x27;s not as if bug fixes haven&#x27;t resulted in new memory bugs, but apparently that rate is much lower in bug fixes than it is in brand new code.</div><br/></div></div><div id="41653428" class="c"><input type="checkbox" id="c-41653428" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41651984">parent</a><span>|</span><a href="#41652071">prev</a><span>|</span><a href="#41652050">next</a><span>|</span><label class="collapse" for="c-41653428">[-]</label><label class="expand" for="c-41653428">[1 more]</label></div><br/><div class="children"><div class="content">I think the standard assumption would be that you need to start replacing older code with memory safe code to see improvements.<p>Instead they’ve shown that only using memory safe languages for new code is enough for the total bug count to drop.</div><br/></div></div></div></div><div id="41652050" class="c"><input type="checkbox" id="c-41652050" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#41651984">prev</a><span>|</span><a href="#41652673">next</a><span>|</span><label class="collapse" for="c-41652050">[-]</label><label class="expand" for="c-41652050">[12 more]</label></div><br/><div class="children"><div class="content">Half a century since Pascal. Forty years since Ada.  28 years since Java.
Fifteen years since Go. Ten years since Rust. And still unsafe code is in the majority.</div><br/><div id="41652413" class="c"><input type="checkbox" id="c-41652413" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#41652050">parent</a><span>|</span><a href="#41653800">next</a><span>|</span><label class="collapse" for="c-41652413">[-]</label><label class="expand" for="c-41652413">[5 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t libc interface requirement of C&#x2F;C++ use, create massive downstream challenges for other languages to gain super mass adoption (at the OS level).</div><br/><div id="41652708" class="c"><input type="checkbox" id="c-41652708" checked=""/><div class="controls bullet"><span class="by">sanxiyn</span><span>|</span><a href="#41652050">root</a><span>|</span><a href="#41652413">parent</a><span>|</span><a href="#41653800">next</a><span>|</span><label class="collapse" for="c-41652708">[-]</label><label class="expand" for="c-41652708">[4 more]</label></div><br/><div class="children"><div class="content">Yes, but Linux (hence Android) doesn&#x27;t have that problem, because its interface is system call not libc.</div><br/><div id="41655643" class="c"><input type="checkbox" id="c-41655643" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41652050">root</a><span>|</span><a href="#41652708">parent</a><span>|</span><a href="#41653708">next</a><span>|</span><label class="collapse" for="c-41655643">[-]</label><label class="expand" for="c-41655643">[1 more]</label></div><br/><div class="children"><div class="content">The practical interface for Android is Binder, which has an interface that can be made amendable to a richer language.</div><br/></div></div><div id="41653708" class="c"><input type="checkbox" id="c-41653708" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#41652050">root</a><span>|</span><a href="#41652708">parent</a><span>|</span><a href="#41655643">prev</a><span>|</span><a href="#41653800">next</a><span>|</span><label class="collapse" for="c-41653708">[-]</label><label class="expand" for="c-41653708">[2 more]</label></div><br/><div class="children"><div class="content">But don&#x27;t syscalls require C&#x2F;C++ data structures &amp; type definitions.<p>So while not technically &quot;requiring&quot; C&#x2F;C++, if your language cannot map exactly to C&#x2F;C++ data structs &amp; type definitions - it won&#x27;t work.</div><br/><div id="41654603" class="c"><input type="checkbox" id="c-41654603" checked=""/><div class="controls bullet"><span class="by">nineteen999</span><span>|</span><a href="#41652050">root</a><span>|</span><a href="#41653708">parent</a><span>|</span><a href="#41653800">next</a><span>|</span><label class="collapse" for="c-41654603">[-]</label><label class="expand" for="c-41654603">[1 more]</label></div><br/><div class="children"><div class="content">Yes.That&#x27;s a problem for the contenders, Linux&#x2F;UNIX kernel are written in C. Unless we want to add language-specific syscall interfaces for every compiled language out there.<p>Alternative is to, y&#x27;know, write a kernel in your language of choice and choose your own syscall specification suiting that language, and gain mass adoption. Easy!</div><br/></div></div></div></div></div></div></div></div><div id="41653800" class="c"><input type="checkbox" id="c-41653800" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41652050">parent</a><span>|</span><a href="#41652413">prev</a><span>|</span><a href="#41653640">next</a><span>|</span><label class="collapse" for="c-41653800">[-]</label><label class="expand" for="c-41653800">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t really write a library in Java or Go that a C program can use. The real magic is memory safety without GC and a huge runtime. But if you point that out people will call you a fanboy.</div><br/></div></div><div id="41653640" class="c"><input type="checkbox" id="c-41653640" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41652050">parent</a><span>|</span><a href="#41653800">prev</a><span>|</span><a href="#41653450">next</a><span>|</span><label class="collapse" for="c-41653640">[-]</label><label class="expand" for="c-41653640">[2 more]</label></div><br/><div class="children"><div class="content">Neither Pascal nor Ada are memory-safe.</div><br/><div id="41654178" class="c"><input type="checkbox" id="c-41654178" checked=""/><div class="controls bullet"><span class="by">docandrew</span><span>|</span><a href="#41652050">root</a><span>|</span><a href="#41653640">parent</a><span>|</span><a href="#41653450">next</a><span>|</span><label class="collapse" for="c-41654178">[-]</label><label class="expand" for="c-41654178">[1 more]</label></div><br/><div class="children"><div class="content">It’s possible to write unsafe code in either but it’s also much easier to write safe code in both Pascal and Ada than C&#x2F;C++. And it’s easier to write safe code in C++ than C. Memory safety exists in a spectrum, it’s not all or nothing.</div><br/></div></div></div></div><div id="41653450" class="c"><input type="checkbox" id="c-41653450" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41652050">parent</a><span>|</span><a href="#41653640">prev</a><span>|</span><a href="#41652638">next</a><span>|</span><label class="collapse" for="c-41653450">[-]</label><label class="expand" for="c-41653450">[1 more]</label></div><br/><div class="children"><div class="content">Is it?<p>If you add up all the JavaScript, C#, Java, Python, and PHP being written every year, that’s a <i>lot</i> of code.<p>Are we sure that all that combined isn’t more than C&#x2F;C++? Or at least somewhat close?</div><br/></div></div><div id="41652113" class="c"><input type="checkbox" id="c-41652113" checked=""/><div class="controls bullet"><span class="by">mpweiher</span><span>|</span><a href="#41652050">parent</a><span>|</span><a href="#41652638">prev</a><span>|</span><a href="#41652673">next</a><span>|</span><label class="collapse" for="c-41652113">[-]</label><label class="expand" for="c-41652113">[1 more]</label></div><br/><div class="children"><div class="content">Well, that tells us something...</div><br/></div></div></div></div><div id="41653813" class="c"><input type="checkbox" id="c-41653813" checked=""/><div class="controls bullet"><span class="by">0xbadcafebee</span><span>|</span><a href="#41652673">prev</a><span>|</span><label class="collapse" for="c-41653813">[-]</label><label class="expand" for="c-41653813">[15 more]</label></div><br/><div class="children"><div class="content">So there&#x27;s a C program. There&#x27;s a bunch of sub-par programmers, who don&#x27;t use the old, well documented, stable, memory-safe functions and techniques. And they write code with memory safety bugs.<p>They are eventually forced to transition to a new language, which makes the memory safety bugs moot. Without addressing the fact that they&#x27;re still sub-par, or why they were to begin with, why they didn&#x27;t use the memory safe functions, why we let them ship code to begin with.<p>They go on to make more sub-par code, with more avoidable security errors. They&#x27;re just not memory safety related anymore. And the hackers shift their focus to attack a different way.<p>Meanwhile, nobody talks about the pink elephant in the room. That we were, and still are, completely fine with people writing code that is shitty. That we allow people to continuously use the wrong methods, which lead to completely avoidable security holes. Security holes like the injection attacks, which make up 40% of all CVEs now, when memory safety only makes up 25%.<p>Could we have focused on a default solution for the bigger class of security holes? Yes. Did we? No. Why? Because none of this is about security. Programmers just like new toys to play with. Security is a red herring being used to justify the continuation of allowing people to write shitty code, and play with new toys.<p>Security will continue to be bad, because we are not addressing the <i>way</i> we write software. Rather than this one big class of bugs, we will just have the million smaller ones to deal with. And it&#x27;ll actually get harder to deal with it all, because we won&#x27;t have the &quot;memory safety&quot; bogey man to point at anymore.</div><br/><div id="41653896" class="c"><input type="checkbox" id="c-41653896" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41654111">next</a><span>|</span><label class="collapse" for="c-41653896">[-]</label><label class="expand" for="c-41653896">[1 more]</label></div><br/><div class="children"><div class="content">No, this just isn&#x27;t how it works. You&#x27;ll find business logic, domain-specific, and systems programming security errors on every platform, but you don&#x27;t find them with the density and the automatic severity you do memory safety issues. This is not about &quot;language hipsters&quot;.</div><br/></div></div><div id="41654111" class="c"><input type="checkbox" id="c-41654111" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41653896">prev</a><span>|</span><a href="#41654007">next</a><span>|</span><label class="collapse" for="c-41654111">[-]</label><label class="expand" for="c-41654111">[1 more]</label></div><br/><div class="children"><div class="content">People have a finite amount of time and effort they can spend on making the code correct. When the language is full of traps, spec gotchas, antiquated misfeatures, gratuitous platform differences, fragmented build systems, then a lot of effort is wasted just on managing all of that nonsense that is actively working against writing robust code, and it takes away from the effort to make a quality product beyond just the language-wrangling.<p>You can&#x27;t rely on people being perfect all the time. We&#x27;ve been trying that for 50 years, and only got an endless circle of CVEs and calls to find better programmers next time.<p>The difference is how the language reacts to the mistakes that will happen. It could react with &quot;oops, you&#x27;ve made a mistake! Here, fix this&quot;, and let the programmer apply a fix and move on, shipping code without the bug. Or the language could silently amplify smallest mistakes in the least interesting code into corruption that causes catastrophic security failures.<p>When concatenating strings and adding numbers <i>securely</i> is a thing that exists, and a thing that requires top-skilled programmers, you&#x27;re just wasting people&#x27;s talent on dumb things.</div><br/></div></div><div id="41654007" class="c"><input type="checkbox" id="c-41654007" checked=""/><div class="controls bullet"><span class="by">bcoates</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41654111">prev</a><span>|</span><a href="#41655120">next</a><span>|</span><label class="collapse" for="c-41654007">[-]</label><label class="expand" for="c-41654007">[1 more]</label></div><br/><div class="children"><div class="content">I mostly agree with you but take the opposite position: attacking memory safety bugs has been so successful that we should use the same pattern on other large classes of bugs.<p>It&#x27;s absolutely possible to write a reasonably usable language that makes injection&#x2F;escaping&#x2F;pollution&#x2F;datatype confusion errors nearly impossible, but it would involve language support and rewriting most libraries--just like memory safety did. Unfortunately we are moving in the opposite direction (I&#x27;m still angry about javascript backticks, a feature seemingly designed solely to allow the porting of php-style sql injection errors)</div><br/></div></div><div id="41655120" class="c"><input type="checkbox" id="c-41655120" checked=""/><div class="controls bullet"><span class="by">uecker</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41654007">prev</a><span>|</span><a href="#41655646">next</a><span>|</span><label class="collapse" for="c-41655120">[-]</label><label class="expand" for="c-41655120">[1 more]</label></div><br/><div class="children"><div class="content">I think it is somewhat about security.   The &quot;Nobody can write secure C&#x2F;C++ code&quot; nonsense translates to &quot;We are not at fault that are products are broken garbage, because it is simply impossible to write secure code.&quot;  Now we can pretend to fix &quot;a whole class of errors&quot; (as long as there is no &quot;unsafe&quot; anywhere)  by imposing Rust on  programmers (and the open-source community that then will produce memory safe code for free for some to use) and while this may indeed help a bit, one can hope to avoid being really being held responsible for product security for another decade or so.</div><br/></div></div><div id="41655646" class="c"><input type="checkbox" id="c-41655646" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41655120">prev</a><span>|</span><a href="#41654015">next</a><span>|</span><label class="collapse" for="c-41655646">[-]</label><label class="expand" for="c-41655646">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a bunch of sub-par programmers, who don&#x27;t use the old, well documented, stable, memory-safe functions and techniques.<p>…which are?</div><br/></div></div><div id="41654015" class="c"><input type="checkbox" id="c-41654015" checked=""/><div class="controls bullet"><span class="by">alpire</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41655646">prev</a><span>|</span><a href="#41653952">next</a><span>|</span><label class="collapse" for="c-41654015">[-]</label><label class="expand" for="c-41654015">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You have a bunch of sub-par programmers, who don&#x27;t use the old, well documented, stable, memory-safe functions and techniques. They write code with memory safety bugs.<p>We should really stop putting the blame on developers. The issue is not that developers are sub-par, but that they are provided with tools making it virtually impossible to write secure software. <i>Everyone</i> writes memory safety bugs when using memory-unsafe languages.<p>And one helpful insight here is that the security posture of a software application is substantially an emergent property of the developer ecosystem that produced it, and that includes having secure-by-design APIs and languages. <a href="https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=3648601" rel="nofollow">https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=3648601</a> goes into more details on this.</div><br/></div></div><div id="41653952" class="c"><input type="checkbox" id="c-41653952" checked=""/><div class="controls bullet"><span class="by">jnwatson</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41654015">prev</a><span>|</span><a href="#41654435">next</a><span>|</span><label class="collapse" for="c-41653952">[-]</label><label class="expand" for="c-41653952">[1 more]</label></div><br/><div class="children"><div class="content">It is 100-1000 times harder to find application-level security bugs than it is to find memory safety bugs.<p>It is also far easier to apply formal analysis to code if you don&#x27;t have to model arbitrary pointers.<p>Android has hard evidence that just eliminating memory safety makes a significant difference.</div><br/></div></div><div id="41653946" class="c"><input type="checkbox" id="c-41653946" checked=""/><div class="controls bullet"><span class="by">uid65534</span><span>|</span><a href="#41653813">parent</a><span>|</span><a href="#41654435">prev</a><span>|</span><label class="collapse" for="c-41653946">[-]</label><label class="expand" for="c-41653946">[6 more]</label></div><br/><div class="children"><div class="content">Having the tool actively prevent classes of errors is a worthwhile endeavor, but I do agree it gets overly focused on alone when several other _massive_ classes of vulnerabilities continue to be introduced. At a high level though, it is a lot easier to just have a framework enforce &#x27;x&#x27; on all devs to raise the minimum bar. It doesn&#x27;t help that the average Rust-bro, from which a lot of these memory safety arguments come from, is utterly terrible at making that case in reality. Case example: <a href="https:&#x2F;&#x2F;github.com&#x2F;pyca&#x2F;cryptography&#x2F;issues&#x2F;5771">https:&#x2F;&#x2F;github.com&#x2F;pyca&#x2F;cryptography&#x2F;issues&#x2F;5771</a>.<p>I think a lot of the arguments around C++ for example being &#x27;memory unsafe&#x27; is a bit ridiculous because its trivial to write memory safe C++. Just run -Wall and enforce the use of smart pointers, there are nearly zero instances in the modern day where you should be dealing with raw pointers or performing offsets that lead to these bugs directly. The few exceptions are hopefully with devs that are intelligent enough to do so safely with modern language features.
Unfortunately, this rarely gets focused on by security teams it seems since they are instead chasing the newest shiny language like you mention.</div><br/><div id="41654170" class="c"><input type="checkbox" id="c-41654170" checked=""/><div class="controls bullet"><span class="by">alpire</span><span>|</span><a href="#41653813">root</a><span>|</span><a href="#41653946">parent</a><span>|</span><a href="#41654879">next</a><span>|</span><label class="collapse" for="c-41654170">[-]</label><label class="expand" for="c-41654170">[4 more]</label></div><br/><div class="children"><div class="content">&gt; its trivial to write memory safe C++<p>It is not unfortunately. That&#x27;s why we see memory safety being responsible for 70% of severe vulns across many C and C++ projects.<p>Some of the reasons include:
- C++ does little to prevent out-of-bounds vulns
- Preventing use-after-free with smart pointers requires heavy use of shared pointers, which often incurs a performance cost that is unacceptable in the environment C++ is used.</div><br/><div id="41654267" class="c"><input type="checkbox" id="c-41654267" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41653813">root</a><span>|</span><a href="#41654170">parent</a><span>|</span><a href="#41654879">next</a><span>|</span><label class="collapse" for="c-41654267">[-]</label><label class="expand" for="c-41654267">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It is not unfortunately. That&#x27;s why we see memory safety being responsible for 70% of severe vulns across many C and C++ projects.<p>I don&#x27;t think that&#x27;s really a rebuttal to what they&#x27;re trying to say.  If the <i>vast</i> majority of C++ devs don&#x27;t follow those two rules, then that&#x27;s not much evidence against those two rules providing memory safety.</div><br/><div id="41654344" class="c"><input type="checkbox" id="c-41654344" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#41653813">root</a><span>|</span><a href="#41654267">parent</a><span>|</span><a href="#41654879">next</a><span>|</span><label class="collapse" for="c-41654344">[-]</label><label class="expand" for="c-41654344">[2 more]</label></div><br/><div class="children"><div class="content">Right but the reason they don&#x27;t follow those 2 rules is that using them would require not using most C++ libraries that don&#x27;t follow the rules, and would introduce performance regressions that negate the main reason they chose C++ in the first place.</div><br/><div id="41654403" class="c"><input type="checkbox" id="c-41654403" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41653813">root</a><span>|</span><a href="#41654344">parent</a><span>|</span><a href="#41654879">next</a><span>|</span><label class="collapse" for="c-41654403">[-]</label><label class="expand" for="c-41654403">[1 more]</label></div><br/><div class="children"><div class="content">This entire post is about a gradual transition.  You don&#x27;t have to avoid libraries that break the rules, you just have to accept that they&#x27;re outside the safe zone.<p>For performance, you&#x27;ll have to be more specific about your shared pointer claims.  But I bet that it&#x27;s a <i>very</i> small fraction of C++ functions that need the absolute best performance <i>and</i> can&#x27;t avoid those performance problems while following the two rules.</div><br/></div></div></div></div></div></div></div></div><div id="41654879" class="c"><input type="checkbox" id="c-41654879" checked=""/><div class="controls bullet"><span class="by">drivebycomment</span><span>|</span><a href="#41653813">root</a><span>|</span><a href="#41653946">parent</a><span>|</span><a href="#41654170">prev</a><span>|</span><label class="collapse" for="c-41654879">[-]</label><label class="expand" for="c-41654879">[1 more]</label></div><br/><div class="children"><div class="content">&gt; its trivial to write memory safe C++.<p>Very bold claim, and as such, it needs substantial evidence, as there is practically no meaningful evidence to support this. There are some real world non-trivial c++ code that are known to have very few defects, but almost all of them required extremely significant effort to get there.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>