<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694682063342" as="style"/><link rel="stylesheet" href="styles.css?v=1694682063342"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://fly.io/blog/skip-the-api/">Skip the API, ship your database</a> <span class="domain">(<a href="https://fly.io">fly.io</a>)</span></div><div class="subtext"><span>danielskogly</span> | <span>144 comments</span></div><br/><div><div id="37505317" class="c"><input type="checkbox" id="c-37505317" checked=""/><div class="controls bullet"><span class="by">Zvez</span><span>|</span><a href="#37503322">next</a><span>|</span><label class="collapse" for="c-37505317">[-]</label><label class="expand" for="c-37505317">[20 more]</label></div><br/><div class="children"><div class="content">If you give access to your DB directly, your API effectively becomes your API with all the contract obligations of the API. Suddenly you don&#x27;t completely control your schema: you can&#x27;t freely change it, you need to add things there for your clients only. I&#x27;ve seen it done multiple times and it always end up poorly. You save some time now by removing the need to build API, but later you end up spending much more time trying to decouple your internal representation from schema you made public.</div><br/><div id="37506523" class="c"><input type="checkbox" id="c-37506523" checked=""/><div class="controls bullet"><span class="by">qwerty456127</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37505647">next</a><span>|</span><label class="collapse" for="c-37506523">[-]</label><label class="expand" for="c-37506523">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s [another reason] why you use stored procedures and only call them (rather than hardcoded or ORM-generated SQL queries) in your client app code.</div><br/></div></div><div id="37505647" class="c"><input type="checkbox" id="c-37505647" checked=""/><div class="controls bullet"><span class="by">oreilles</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37506523">prev</a><span>|</span><a href="#37506457">next</a><span>|</span><label class="collapse" for="c-37505647">[-]</label><label class="expand" for="c-37505647">[8 more]</label></div><br/><div class="children"><div class="content">Versioned views, materialized views or procedures are the solution to this. It is frequent that even internally, companies don&#x27;t give access to their raw data but rather to a restricted schema containing a formated subset of it.</div><br/><div id="37506432" class="c"><input type="checkbox" id="c-37506432" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37505647">parent</a><span>|</span><a href="#37506266">next</a><span>|</span><label class="collapse" for="c-37506432">[-]</label><label class="expand" for="c-37506432">[2 more]</label></div><br/><div class="children"><div class="content">Views will severely restrict the kinds of changes you might want to do in the future. For example now you can&#x27;t just move some data from your database into S3 or REST service.<p>Stored procedures technically can do anything, I guess, but at that point you would be better with traditional services which will give you more flexibility.</div><br/><div id="37506466" class="c"><input type="checkbox" id="c-37506466" checked=""/><div class="controls bullet"><span class="by">indigo945</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37506432">parent</a><span>|</span><a href="#37506266">next</a><span>|</span><label class="collapse" for="c-37506466">[-]</label><label class="expand" for="c-37506466">[1 more]</label></div><br/><div class="children"><div class="content">A view can also do anything - it could query a REST service, for example. (Not saying that this is necessarily a good idea, though...)</div><br/></div></div></div></div><div id="37506266" class="c"><input type="checkbox" id="c-37506266" checked=""/><div class="controls bullet"><span class="by">tacker2000</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37505647">parent</a><span>|</span><a href="#37506432">prev</a><span>|</span><a href="#37506305">next</a><span>|</span><label class="collapse" for="c-37506266">[-]</label><label class="expand" for="c-37506266">[2 more]</label></div><br/><div class="children"><div class="content">Of course it’s possible, but now you need more people with DB and SQL knowledge.<p>Also, using views and stored procedures with source control is a pain.<p>Deploying these into prod is also much more cumbersome than just normal backend code.<p>Accessing a view will also be slower than accessing an “original” table since the view needs to be aggregated.</div><br/><div id="37506308" class="c"><input type="checkbox" id="c-37506308" checked=""/><div class="controls bullet"><span class="by">_a_a_a_</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37506266">parent</a><span>|</span><a href="#37506305">next</a><span>|</span><label class="collapse" for="c-37506308">[-]</label><label class="expand" for="c-37506308">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Accessing a view will also be slower than accessing an “original” table since the view needs to be aggregated.<p>Where does it say anything needs aggregating. You can have a view that exists just for security.<p>&gt; Also, using views and stored procedures with source control is a pain. Deploying these into prod is also much more cumbersome than just normal backend code.<p>Uh? This is normal backend code.</div><br/></div></div></div></div><div id="37506305" class="c"><input type="checkbox" id="c-37506305" checked=""/><div class="controls bullet"><span class="by">madsbuch</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37505647">parent</a><span>|</span><a href="#37506266">prev</a><span>|</span><a href="#37505969">next</a><span>|</span><label class="collapse" for="c-37506305">[-]</label><label class="expand" for="c-37506305">[1 more]</label></div><br/><div class="children"><div class="content">why would you want to develop your api in sql over a traditional language?<p>versioned views and materialized views are essentially api endpoints in this context. just developed in sql instead of some sane language.</div><br/></div></div><div id="37505969" class="c"><input type="checkbox" id="c-37505969" checked=""/><div class="controls bullet"><span class="by">vmfunction</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37505647">parent</a><span>|</span><a href="#37506305">prev</a><span>|</span><a href="#37506384">next</a><span>|</span><label class="collapse" for="c-37505969">[-]</label><label class="expand" for="c-37505969">[1 more]</label></div><br/><div class="children"><div class="content">In addition if you are using postgres, then there is postgresRest to make api really quick and nice.</div><br/></div></div><div id="37506384" class="c"><input type="checkbox" id="c-37506384" checked=""/><div class="controls bullet"><span class="by">rewmie</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37505647">parent</a><span>|</span><a href="#37505969">prev</a><span>|</span><a href="#37506457">next</a><span>|</span><label class="collapse" for="c-37506384">[-]</label><label class="expand" for="c-37506384">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Versioned views, materialized views or procedures are the solution to this.<p>Wouldn&#x27;t it be far simpler to just create a service providing access to those views with something like OData?</div><br/></div></div></div></div><div id="37506457" class="c"><input type="checkbox" id="c-37506457" checked=""/><div class="controls bullet"><span class="by">londons_explore</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37505647">prev</a><span>|</span><a href="#37506329">next</a><span>|</span><label class="collapse" for="c-37506457">[-]</label><label class="expand" for="c-37506457">[2 more]</label></div><br/><div class="children"><div class="content">You could ship the database together with python&#x2F;JS&#x2F;whatever &#x27;client library&#x27; - and you tell your clients that they need to use your code if they want to be supported.</div><br/><div id="37506531" class="c"><input type="checkbox" id="c-37506531" checked=""/><div class="controls bullet"><span class="by">wmal</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37506457">parent</a><span>|</span><a href="#37506329">next</a><span>|</span><label class="collapse" for="c-37506531">[-]</label><label class="expand" for="c-37506531">[1 more]</label></div><br/><div class="children"><div class="content">This is the worst of both worlds. Not only are you back to square one, as you spent the time to build an API (client libraries), but now, if the API is limiting, the users will find ways of accessing the SQLite db directly.</div><br/></div></div></div></div><div id="37506329" class="c"><input type="checkbox" id="c-37506329" checked=""/><div class="controls bullet"><span class="by">DarkNova6</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37506457">prev</a><span>|</span><a href="#37505441">next</a><span>|</span><label class="collapse" for="c-37506329">[-]</label><label class="expand" for="c-37506329">[2 more]</label></div><br/><div class="children"><div class="content">This 100%.<p>My last customer used an ETL tool to orchestrate their data loads between applications, but the only out of the box solution was a DB-Reader.<p>Eventually, no system could be changed without breaking another system and the central GIS system had to be gradually phased out. This also meant that everybody must had to use Oracle databases, since this was the &quot;best supported platform&quot;.</div><br/><div id="37506390" class="c"><input type="checkbox" id="c-37506390" checked=""/><div class="controls bullet"><span class="by">Dudester230602</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37506329">parent</a><span>|</span><a href="#37505441">next</a><span>|</span><label class="collapse" for="c-37506390">[-]</label><label class="expand" for="c-37506390">[1 more]</label></div><br/><div class="children"><div class="content">On the next iteration some consultancy will replace that with a bunch of microservices using a dynamic language.<p>When that thing fails again they will hopefully settle on a sane monolithic API.</div><br/></div></div></div></div><div id="37505441" class="c"><input type="checkbox" id="c-37505441" checked=""/><div class="controls bullet"><span class="by">MoSattler</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37506329">prev</a><span>|</span><a href="#37506243">next</a><span>|</span><label class="collapse" for="c-37505441">[-]</label><label class="expand" for="c-37505441">[1 more]</label></div><br/><div class="children"><div class="content">I think this point is addressed in the article.</div><br/></div></div><div id="37506243" class="c"><input type="checkbox" id="c-37506243" checked=""/><div class="controls bullet"><span class="by">oldnet</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37505441">prev</a><span>|</span><a href="#37505820">next</a><span>|</span><label class="collapse" for="c-37506243">[-]</label><label class="expand" for="c-37506243">[2 more]</label></div><br/><div class="children"><div class="content">Also you shouldn&#x27;t give up access to your DB for security reasons.<p>That&#x27;s why API exists at first place.</div><br/><div id="37506471" class="c"><input type="checkbox" id="c-37506471" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37506243">parent</a><span>|</span><a href="#37505820">next</a><span>|</span><label class="collapse" for="c-37506471">[-]</label><label class="expand" for="c-37506471">[1 more]</label></div><br/><div class="children"><div class="content">Technically you can create different users with very precise access permissions. Might not be the good idea to provide that kind of API to the general public, but if your clients are trustworthy, it might work.</div><br/></div></div></div></div><div id="37505820" class="c"><input type="checkbox" id="c-37505820" checked=""/><div class="controls bullet"><span class="by">Puts</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37506243">prev</a><span>|</span><a href="#37506357">next</a><span>|</span><label class="collapse" for="c-37505820">[-]</label><label class="expand" for="c-37505820">[2 more]</label></div><br/><div class="children"><div class="content">You can use stored procedures if you want to add another abstraction layer.</div><br/><div id="37505987" class="c"><input type="checkbox" id="c-37505987" checked=""/><div class="controls bullet"><span class="by">Epa095</span><span>|</span><a href="#37505317">root</a><span>|</span><a href="#37505820">parent</a><span>|</span><a href="#37506357">next</a><span>|</span><label class="collapse" for="c-37505987">[-]</label><label class="expand" for="c-37505987">[1 more]</label></div><br/><div class="children"><div class="content">They had stored procedures in the &quot;old days&quot; when they figured out that direct access to the database was a bad idea, so what has changed? (I agree that a DB view often is good enough thoug, but they ALSO had that in the &quot;old days&quot;, IDK what has changed about that:-p )</div><br/></div></div></div></div><div id="37506357" class="c"><input type="checkbox" id="c-37506357" checked=""/><div class="controls bullet"><span class="by">archibaldJ</span><span>|</span><a href="#37505317">parent</a><span>|</span><a href="#37505820">prev</a><span>|</span><a href="#37503322">next</a><span>|</span><label class="collapse" for="c-37506357">[-]</label><label class="expand" for="c-37506357">[1 more]</label></div><br/><div class="children"><div class="content">yeah reminds me of meteor JS</div><br/></div></div></div></div><div id="37503322" class="c"><input type="checkbox" id="c-37503322" checked=""/><div class="controls bullet"><span class="by">EMM_386</span><span>|</span><a href="#37505317">prev</a><span>|</span><a href="#37502988">next</a><span>|</span><label class="collapse" for="c-37503322">[-]</label><label class="expand" for="c-37503322">[38 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been doing this for a long time and all I can say this after reading this multiple times ... &quot;I don&#x27;t get it&quot;.<p>I mean, I get it, from a technical standpoint.  Ok, so you&#x27;re going to send read-only Sqlite databases to everybody.<p>Is it missing <i>what</i> the API (that you still need) is updating when you insert or update something and all client DBs are now stale?  Is there a central database?  How often are you pushing out read-only database replicas across the wire to all clients?  Is that really less &quot;chatty&quot;? If so, how much bandwidth is that saving to push an entire database multiplied by the number of clients?<p>None of this seems logical.  Maybe I&#x27;m missing the real-world use-case.  Are we discussing tiny Sqlite databases that are essentially static?   Because in the last 30 years I&#x27;ve not run into a situation where I needed to have clients execute SQL queries on tiny, static databases let alone still need to potentially update them also.</div><br/><div id="37503543" class="c"><input type="checkbox" id="c-37503543" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37503322">parent</a><span>|</span><a href="#37505144">next</a><span>|</span><label class="collapse" for="c-37503543">[-]</label><label class="expand" for="c-37503543">[7 more]</label></div><br/><div class="children"><div class="content">Author here. We&#x27;re using LiteFS to replicate SQLite databases in real time so the changes sent are only incremental. I think there are several ideal use cases for sharing databases across applications:<p>1. Internal tooling: you&#x27;re able to manage the contract better since you have control of the source &amp; destination applications.<p>2. Reporting &amp; analytics: these tend to need a lot of query flexibility &amp; they tend to use a lot of resources. Offloading the query computation to the client makes it easier on the source application.<p>As for database size, the Corrosion program mentioned in the post is about 8GB and has a continuous write load so this doesn&#x27;t have to just be for tiny databases.</div><br/><div id="37506311" class="c"><input type="checkbox" id="c-37506311" checked=""/><div class="controls bullet"><span class="by">rgavuliak</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503543">parent</a><span>|</span><a href="#37504113">next</a><span>|</span><label class="collapse" for="c-37506311">[-]</label><label class="expand" for="c-37506311">[1 more]</label></div><br/><div class="children"><div class="content">Do you realize most reporting &amp; analytics use cases don&#x27;t use SQLLite Databases?</div><br/></div></div><div id="37504113" class="c"><input type="checkbox" id="c-37504113" checked=""/><div class="controls bullet"><span class="by">pininja</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503543">parent</a><span>|</span><a href="#37506311">prev</a><span>|</span><a href="#37504170">next</a><span>|</span><label class="collapse" for="c-37504113">[-]</label><label class="expand" for="c-37504113">[1 more]</label></div><br/><div class="children"><div class="content">I could imagine this technique being useful for kepler.gl or other data visualization tools</div><br/></div></div><div id="37504170" class="c"><input type="checkbox" id="c-37504170" checked=""/><div class="controls bullet"><span class="by">LispSporks22</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503543">parent</a><span>|</span><a href="#37504113">prev</a><span>|</span><a href="#37505144">next</a><span>|</span><label class="collapse" for="c-37504170">[-]</label><label class="expand" for="c-37504170">[4 more]</label></div><br/><div class="children"><div class="content">Curious if you&#x27;ve tested it with Jepsen. Anytime I come across some distributed system, my stomach ulcers start playing up while I wonder about all the weird failure modes. I kinda looked for a caveats page on the LiteFS web site, didn&#x27;t really see one.</div><br/><div id="37504384" class="c"><input type="checkbox" id="c-37504384" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37504170">parent</a><span>|</span><a href="#37504955">next</a><span>|</span><label class="collapse" for="c-37504384">[-]</label><label class="expand" for="c-37504384">[1 more]</label></div><br/><div class="children"><div class="content">LiteFS doesn&#x27;t try to be a correct distributed system, as you can see from: <a href="https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;how-it-works&#x2F;#cluster-management-using-leases">https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;how-it-works&#x2F;#cluster-management-...</a><p>Basically, the solution they have is:<p>1. There is a single writer. There&#x27;s optional best-effort leader election for the writer.<p>2. If there&#x27;s a network partition, split-brain, etc, availability is chosen over consistency.<p>Jepson&#x27;s testing is focused on databases that pick &quot;consistency&quot;. Since LiteFS didn&#x27;t pick consistency, there&#x27;s really not any point in running Jepson against it. Like, jepson would immediately find &quot;you can lose acknowledged writes&quot;, and LiteFS would say &quot;Yes! That&#x27;s working exactly as intended!&quot;<p>However, another way of running LiteFS is with only a single writer ever (as in one app, one server, one sqlite database only), and all clients as read-only replicas that are not eligible for taking writes ever. In that case, you also don&#x27;t have a proper distributed system, just read only replicas, which is quite easy to get right, and mostly what this post is talking about.</div><br/></div></div><div id="37504955" class="c"><input type="checkbox" id="c-37504955" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37504170">parent</a><span>|</span><a href="#37504384">prev</a><span>|</span><a href="#37504421">next</a><span>|</span><label class="collapse" for="c-37504955">[-]</label><label class="expand" for="c-37504955">[1 more]</label></div><br/><div class="children"><div class="content">LiteFS works similarly to async replication you&#x27;d find in Postgres or MySQL so it doesn&#x27;t try to be as strict as something running a distributed consensus protocol like Raft. The guarantees for async replication are fairly loose so I&#x27;m not sure Jepsen testing would be useful for that per se.<p>On the LiteFS Cloud side, it currently does streaming backups so it has similar guarantees but we are expanding its feature set and I could see running Jepsen testing on that in the future. We worked with Kyle Kingsbury in the past on some distributed systems challenges[1] and he was awesome to work with. Would definitely love to engage with him again.<p>[1]: <a href="https:&#x2F;&#x2F;fly.io&#x2F;dist-sys&#x2F;">https:&#x2F;&#x2F;fly.io&#x2F;dist-sys&#x2F;</a></div><br/></div></div></div></div></div></div><div id="37505144" class="c"><input type="checkbox" id="c-37505144" checked=""/><div class="controls bullet"><span class="by">lawik</span><span>|</span><a href="#37503322">parent</a><span>|</span><a href="#37503543">prev</a><span>|</span><a href="#37503470">next</a><span>|</span><label class="collapse" for="c-37505144">[-]</label><label class="expand" for="c-37505144">[2 more]</label></div><br/><div class="children"><div class="content">I have more interest in this: <a href="https:&#x2F;&#x2F;electric-sql.com&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;electric-sql.com&#x2F;</a><p>They are adding a sync-mechanism for Sqlite so local writes can be synced to a remote location and on into Postgres and so on. CRDT-based eventual consistency.<p>So local write latency, eventually consistent sync and the tools for partial sync and user access are the primary areas of development.<p>Early days but an interesting approach to shipping the db.</div><br/><div id="37506300" class="c"><input type="checkbox" id="c-37506300" checked=""/><div class="controls bullet"><span class="by">anty</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37505144">parent</a><span>|</span><a href="#37503470">next</a><span>|</span><label class="collapse" for="c-37506300">[-]</label><label class="expand" for="c-37506300">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I implemented something like that for my Android app. It seems to work quite well. I don&#x27;t have many users yet, though.<p>I replicate the clients Sqlite DB to a central server (over a REST-API) where it is synced with existing data. I use an CRDT, so changes don&#x27;t get lost and as long as the clocks of all the users devices are accurate, the merges are in the correct order.<p>This enables offline access, but also the use of my app without an account. You can always merge the data later.
Multi-device merge is also possible, if you create an account. Especially the multi-device merge was a big headache until I settled for this approach.<p>Since it is a home-grown solution I still have to do some manual stuff that could be abstracted away, like converting datatypes to and from JSON, Kotlin, PHP, MySQL. There&#x27;s not always an equivalent datatype in those technologies.<p>This approach probably won&#x27;t work well for big databases that share data between multiple users, though.</div><br/></div></div></div></div><div id="37503470" class="c"><input type="checkbox" id="c-37503470" checked=""/><div class="controls bullet"><span class="by">zmmmmm</span><span>|</span><a href="#37503322">parent</a><span>|</span><a href="#37505144">prev</a><span>|</span><a href="#37505148">next</a><span>|</span><label class="collapse" for="c-37503470">[-]</label><label class="expand" for="c-37503470">[5 more]</label></div><br/><div class="children"><div class="content">It probably makes most sense if you have a middle-tier-less application where the UI IS the application, and effectively it just dumps the whole application state out through APIs anyway. We have ended up with this scenario playing out and you eventually just throw up your hands and make the UI hit the server with a giant &quot;send me a huge blob of JSON that is most of the tables in the database on first page load&quot; query anyway.<p>So the assumption that &quot;if anybody changes anything everybody needs to know it&quot; is close to true. In that scenario, putting a bunch of APIs in the way just makes the data less coherent rather than more. In most other scenarios, yeah, it&#x27;s hard to see that it really makes sense.</div><br/><div id="37503602" class="c"><input type="checkbox" id="c-37503602" checked=""/><div class="controls bullet"><span class="by">EMM_386</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503470">parent</a><span>|</span><a href="#37505148">next</a><span>|</span><label class="collapse" for="c-37503602">[-]</label><label class="expand" for="c-37503602">[4 more]</label></div><br/><div class="children"><div class="content">I have never in my career spanning decades have I had to ask a server to send me a dataset so large that it &quot;most tables in the database on first page load&quot;.<p>In what use case do you run into that?<p>I&#x27;m lead and an architect on an enterprise application at the moment that drives the whole company.  It&#x27;s your standard configuration, front-end, APIs, SQL.  The system requests what it needs to fulfill only what functionality the user is dealing with.<p>Earlier in my career I was dealing with large enterprise desktop applications that talked directly to the database, with no centralized API.  Some of them had thousands of individual desktop clients hitting a single multi-tenant SQL server.  No problem, SQL Server would handle it without breaking a sweat.  The bandwidth to an indidual client was fine.  It was fast.  And that was 20 years ago.</div><br/><div id="37504063" class="c"><input type="checkbox" id="c-37504063" checked=""/><div class="controls bullet"><span class="by">mickael-kerjean</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503602">parent</a><span>|</span><a href="#37504152">next</a><span>|</span><label class="collapse" for="c-37504063">[-]</label><label class="expand" for="c-37504063">[1 more]</label></div><br/><div class="children"><div class="content">I did faced this scenario a couple time when working on application that would work offline, a few of those I was involved in:<p>- try to reduce the amount of paper based catalog we were sending out to customers, those were a couple thousands of pages and not cheap to produce, not cheap to send and would get deprecated very quickly. The web app would be pulling the entire catalog at first load so customers could go in remote location and still be able to use the catalog<p>- a web app for sales that was intended to be use on customer site containing all the marketing materials and much more during presentations on site without ever having to connect anywhere</div><br/></div></div><div id="37504152" class="c"><input type="checkbox" id="c-37504152" checked=""/><div class="controls bullet"><span class="by">cj</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503602">parent</a><span>|</span><a href="#37504063">prev</a><span>|</span><a href="#37503678">next</a><span>|</span><label class="collapse" for="c-37504152">[-]</label><label class="expand" for="c-37504152">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In what use case do you run into that?<p>Single-tenant simple sites without permission checks with limited content volume.<p>Of course you can also do the same in a multi-tenant environment but naturally you wouldn’t be returning all rows in the database.</div><br/></div></div><div id="37503678" class="c"><input type="checkbox" id="c-37503678" checked=""/><div class="controls bullet"><span class="by">hobs</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503602">parent</a><span>|</span><a href="#37504152">prev</a><span>|</span><a href="#37505148">next</a><span>|</span><label class="collapse" for="c-37503678">[-]</label><label class="expand" for="c-37503678">[1 more]</label></div><br/><div class="children"><div class="content">This is pretty much what many SPA were&#x2F;is, dump entire app state relevant on first load and then offline is no problem.</div><br/></div></div></div></div></div></div><div id="37505148" class="c"><input type="checkbox" id="c-37505148" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#37503322">parent</a><span>|</span><a href="#37503470">prev</a><span>|</span><a href="#37503363">next</a><span>|</span><label class="collapse" for="c-37505148">[-]</label><label class="expand" for="c-37505148">[1 more]</label></div><br/><div class="children"><div class="content">I have seen some stuff where a streaming tool (Kafka or whatever) is used to just ship all updates to a database to certain clients.  But I think this is a dubious architecture since it comes with basically all the downsides of a database that many applications all want to use besides the write contention one.</div><br/></div></div><div id="37503363" class="c"><input type="checkbox" id="c-37503363" checked=""/><div class="controls bullet"><span class="by">jokethrowaway</span><span>|</span><a href="#37503322">parent</a><span>|</span><a href="#37505148">prev</a><span>|</span><a href="#37505354">next</a><span>|</span><label class="collapse" for="c-37503363">[-]</label><label class="expand" for="c-37503363">[21 more]</label></div><br/><div class="children"><div class="content">Imagine you&#x27;re building a SaaS which allows your users to do create a website, hotel booking platform and channel manaager.<p>User can open the application, get the database, the frontend does all the offline updates the user want to perform. The user can update their website, add bookings they received on the phone, check what prices they set. This is all blazingly fast with no loading time, no matter your internet connection, because no further communication with the server is needed.<p>At some point they press a magic Publish button and the database gets synced with upstream and uploaded. The upstream service can take the data and publish a website for its users, update availabilities, update prices, etc.<p>It would be a better user experience than 99% of the SaaS out there.</div><br/><div id="37503496" class="c"><input type="checkbox" id="c-37503496" checked=""/><div class="controls bullet"><span class="by">q7xvh97o2pDhNrh</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37503534">next</a><span>|</span><label class="collapse" for="c-37503496">[-]</label><label class="expand" for="c-37503496">[8 more]</label></div><br/><div class="children"><div class="content">Most of the Internet spent the last 10-20 years moving away from this because business metrics generally benefit from realtime updates and background autosaves. By and large, users expect systems to autosave their work-in-progress nowadays.<p>You might remember horror stories from the late 1900s when people would lose critical data and documents because they &quot;forgot to hit Save and the computer crashed.&quot; Or, maybe you&#x27;ve never experienced this — because a couple decades of distributed-systems engineers and UX researchers made that problem obsolete.<p>So now we&#x27;ve... reinvented the Save button, but somehow needed a Paxos implementation to do it?<p>Everything old is new again, I guess.</div><br/><div id="37503860" class="c"><input type="checkbox" id="c-37503860" checked=""/><div class="controls bullet"><span class="by">Merad</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503496">parent</a><span>|</span><a href="#37503899">next</a><span>|</span><label class="collapse" for="c-37503860">[-]</label><label class="expand" for="c-37503860">[1 more]</label></div><br/><div class="children"><div class="content">Heh, the last company I worked for had a (very popular, very successful) 20 year old desktop app that worked by downloading the client&#x27;s entire database on login, then doing regular syncs with the back end and sending batch updates as the user made changes.  It was an awful system that everyone hated, and the company was desperately trying to figure out how to move away from it without doing a complete rewrite.  Maybe I should let them know that they&#x27;re actually ahead of the curve if they can just hold out for a few more years...</div><br/></div></div><div id="37503899" class="c"><input type="checkbox" id="c-37503899" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503496">parent</a><span>|</span><a href="#37503860">prev</a><span>|</span><a href="#37504345">next</a><span>|</span><label class="collapse" for="c-37503899">[-]</label><label class="expand" for="c-37503899">[1 more]</label></div><br/><div class="children"><div class="content">Hell, even with <i>word processors</i> we have auto save enabled by default for at least a decade.</div><br/></div></div><div id="37504345" class="c"><input type="checkbox" id="c-37504345" checked=""/><div class="controls bullet"><span class="by">Freedom2</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503496">parent</a><span>|</span><a href="#37503899">prev</a><span>|</span><a href="#37503534">next</a><span>|</span><label class="collapse" for="c-37504345">[-]</label><label class="expand" for="c-37504345">[5 more]</label></div><br/><div class="children"><div class="content">I feel like I&#x27;m taking crazy pills. As HNers, we should want more control, not less over our work. Auto-save means that the company, no matter how nefarious, decides on their terms when my work is saved - regardless of what I&#x27;ve entered into the document (I write documents in a very stream of conscious manner).<p>I want to decide when to save, and how, not the application. I am not a product, I am a user!!!</div><br/><div id="37505306" class="c"><input type="checkbox" id="c-37505306" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37504345">parent</a><span>|</span><a href="#37504373">next</a><span>|</span><label class="collapse" for="c-37505306">[-]</label><label class="expand" for="c-37505306">[1 more]</label></div><br/><div class="children"><div class="content">Seems like on-by-default auto save with the option to disable, and a separate save button, satisfy all your requirements. That’s a pretty common set of customizations on saves from what I’ve seen.</div><br/></div></div><div id="37504373" class="c"><input type="checkbox" id="c-37504373" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37504345">parent</a><span>|</span><a href="#37505306">prev</a><span>|</span><a href="#37503534">next</a><span>|</span><label class="collapse" for="c-37504373">[-]</label><label class="expand" for="c-37504373">[3 more]</label></div><br/><div class="children"><div class="content">This makes me smile, because it&#x27;s satire, right?</div><br/><div id="37506133" class="c"><input type="checkbox" id="c-37506133" checked=""/><div class="controls bullet"><span class="by">porker</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37504373">parent</a><span>|</span><a href="#37503534">next</a><span>|</span><label class="collapse" for="c-37506133">[-]</label><label class="expand" for="c-37506133">[2 more]</label></div><br/><div class="children"><div class="content">No. I value a meaningful &quot;Last updated at&quot; timestamp.<p>If I open a word document, redact a few bits, save to PDF and close it - I don&#x27;t want my changes saved but they are (real scenario from last week. I&#x27;d only just moved the file into Onedrive so autosave had turned itself on)<p>Ditto sorting and filtering spreadsheets.<p>Software engineers: By all means save in the background so I never lose anything, but don&#x27;t assume I want the latest changes.</div><br/><div id="37506436" class="c"><input type="checkbox" id="c-37506436" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37506133">parent</a><span>|</span><a href="#37503534">next</a><span>|</span><label class="collapse" for="c-37506436">[-]</label><label class="expand" for="c-37506436">[1 more]</label></div><br/><div class="children"><div class="content">What you want, then, is versioning of your documents. MS Office and Google Suite do that.<p>This is not trivial to implement, though. Complexity will depend a lot of the application and the data. I&#x27;d say it&#x27;ll only make sense for mature apps. A startup will most likely don&#x27;t consider this in its roadmap.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37503534" class="c"><input type="checkbox" id="c-37503534" checked=""/><div class="controls bullet"><span class="by">EMM_386</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37503496">prev</a><span>|</span><a href="#37503453">next</a><span>|</span><label class="collapse" for="c-37503534">[-]</label><label class="expand" for="c-37503534">[5 more]</label></div><br/><div class="children"><div class="content">&gt; User can open the application, get the database, the frontend does all the offline updates the user want to perform.<p>&quot;get the database&quot;<p>How small do you think these databases are?!<p>You&#x27;re going to download the entire hotel booking platform&#x27;s database?<p>For how many hotels?  One at a time, and then get another databse?  Or are you getting a Sqlite booking database for every hotel in the world?  And you&#x27;re going to send them <i>to each user</i>?  For what date range?<p>And even if that were possible, you then have to commit your offline updates.  What if someone else booked the date range prior to you?  Now your Sqlite copy is stale.  Download the entire thing again?  There could have been countless changes from other users in the time since you last got your copy.<p>This explanation just leaves me even more confused.  It&#x27;s illogical.</div><br/><div id="37504700" class="c"><input type="checkbox" id="c-37504700" checked=""/><div class="controls bullet"><span class="by">yyyk</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503534">parent</a><span>|</span><a href="#37504164">next</a><span>|</span><label class="collapse" for="c-37504700">[-]</label><label class="expand" for="c-37504700">[1 more]</label></div><br/><div class="children"><div class="content">I have some experience with a comparable platform. In a typical CouchDB&#x2F;PouchDB design, syncs and offline work are common and easy, and it&#x27;s pretty close to database-based design if you get fancy with views and javascript-based logic.<p>For this project, I&#x27;d do:<p>* A database for each user (this is natural on CouchDB, one can enable a setting to create the user DB automatically when a user is created. The platform won&#x27;t choke on many databases) - for some per-user data, like comments, if the user has already reserved a booking we can mirror booking data there + some info regarding the hotel.<p>* Common synced databases - some general info regarding the platform and hotels. Preferably not too large (IIRC there&#x27;s no limit to attachments with 3.x, but it sounds risky). Anything too large we&#x27;d do online or use data provided with the application.<p>* A large booking database which isn&#x27;t synced and must be modified online with a REST call - we don&#x27;t have to allow <i>every</i> action offline. Here I wouldn&#x27;t entirely dispense with API. This obviously needs the online component for making sure bookings don&#x27;t conflict. Could even be a regular relational database.<p>I think it is possible to implement this the CouchDB database-way: a provisional offline reservation to the user database followed by some rejection method on the server when syncing, but I don&#x27;t think there&#x27;s much value to the user here. This design however would allow us to not sync all the data but a much smaller portion while supporting offline.<p>---<p>It sounds very doable, rather similar to a project I was involved with, but I miss SQL a lot with that platform (javascript NoSQL not my favorite to work with). A sqlite-based approach is an interesting alternative.</div><br/></div></div><div id="37504164" class="c"><input type="checkbox" id="c-37504164" checked=""/><div class="controls bullet"><span class="by">layoric</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503534">parent</a><span>|</span><a href="#37504700">prev</a><span>|</span><a href="#37505627">next</a><span>|</span><label class="collapse" for="c-37504164">[-]</label><label class="expand" for="c-37504164">[2 more]</label></div><br/><div class="children"><div class="content">Web applications aren&#x27;t going to get bigger just by themselves! &#x2F;s<p>Jokes aside, this extreme optimization for development does have impacts on user experience. The amount of bandwidth&#x2F;storage etc used by a &quot;just ship the whole db&quot; type applications would surely suck for most people outside of the &#x27;I measure my bandwidth in Gbps&#x27; crowd?</div><br/></div></div><div id="37505627" class="c"><input type="checkbox" id="c-37505627" checked=""/><div class="controls bullet"><span class="by">throwaway290</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503534">parent</a><span>|</span><a href="#37504164">prev</a><span>|</span><a href="#37503453">next</a><span>|</span><label class="collapse" for="c-37505627">[-]</label><label class="expand" for="c-37505627">[1 more]</label></div><br/><div class="children"><div class="content">You did not read the use case. It&#x27;s not equivalent of Booking. More like equivalent of Wix for hotels.</div><br/></div></div></div></div><div id="37503453" class="c"><input type="checkbox" id="c-37503453" checked=""/><div class="controls bullet"><span class="by">hx8</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37503534">prev</a><span>|</span><a href="#37503482">next</a><span>|</span><label class="collapse" for="c-37503453">[-]</label><label class="expand" for="c-37503453">[3 more]</label></div><br/><div class="children"><div class="content">Once upon a time, this is how applications worked and this was a pretty good experience.<p>Now, you&#x27;ll introduce a huge amount of user frustration around why their changes never made it to the central database.  If you have users closing a form, especially if it&#x27;s on a webpage, they are going to expect the write to happen at the same time the form closes.  Making a bunch of changes and batching them in a single sync is going to be confusing to a ton of users.</div><br/><div id="37503507" class="c"><input type="checkbox" id="c-37503507" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503453">parent</a><span>|</span><a href="#37503482">next</a><span>|</span><label class="collapse" for="c-37503507">[-]</label><label class="expand" for="c-37503507">[2 more]</label></div><br/><div class="children"><div class="content">What happens if two users want to make changes at the same time? What if their changes conflict? How do you even detect conflicts?</div><br/><div id="37506540" class="c"><input type="checkbox" id="c-37506540" checked=""/><div class="controls bullet"><span class="by">Ambolia</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503507">parent</a><span>|</span><a href="#37503482">next</a><span>|</span><label class="collapse" for="c-37506540">[-]</label><label class="expand" for="c-37506540">[1 more]</label></div><br/><div class="children"><div class="content">It could be done with &quot;select for update&quot; and etags+triggers checking the etag received + triggers generating a new etag on every create&#x2F;update.</div><br/></div></div></div></div></div></div><div id="37503482" class="c"><input type="checkbox" id="c-37503482" checked=""/><div class="controls bullet"><span class="by">vosper</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37503453">prev</a><span>|</span><a href="#37505164">next</a><span>|</span><label class="collapse" for="c-37503482">[-]</label><label class="expand" for="c-37503482">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the example, it helped me understand the idea.<p>The thing that I&#x27;m unclear on is how do I figure out what data to ship to the user? Like if I don&#x27;t already have a database-per-user then I have to extract only the data the user has permission to see, and ship that as a database?<p>That would be the case even if I had database-per-customer - not every user is necessarily able to see all the data owned by the organization they&#x27;re a part of.<p>It seems like a lot of extra work, and error-prone, too (what could be worse than accidentally shipping the wrong data _as an operational database_ to a client?)<p>Edit: the article covers this at the bottom, but IMO it&#x27;s a show-stopper. How many applications of any real complexity can actually implement database-per-user (database-per-tenant is probably not enough, as I mentioned above). As soon as you need any kind of management or permissions functionality in your app then you can&#x27;t ship the database anymore, so you may as well start off not shipping it.</div><br/></div></div><div id="37505164" class="c"><input type="checkbox" id="c-37505164" checked=""/><div class="controls bullet"><span class="by">Takennickname</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37503482">prev</a><span>|</span><a href="#37504104">next</a><span>|</span><label class="collapse" for="c-37505164">[-]</label><label class="expand" for="c-37505164">[1 more]</label></div><br/><div class="children"><div class="content">What is this? A scifi novel?<p>By the time your dude downloads the database half the hotels on your imaginary website have changed status.</div><br/></div></div><div id="37504104" class="c"><input type="checkbox" id="c-37504104" checked=""/><div class="controls bullet"><span class="by">RhysU</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37505164">prev</a><span>|</span><a href="#37503404">next</a><span>|</span><label class="collapse" for="c-37504104">[-]</label><label class="expand" for="c-37504104">[1 more]</label></div><br/><div class="children"><div class="content">Wasn&#x27;t this Lotus Notes?</div><br/></div></div><div id="37503404" class="c"><input type="checkbox" id="c-37503404" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#37503322">root</a><span>|</span><a href="#37503363">parent</a><span>|</span><a href="#37504104">prev</a><span>|</span><a href="#37505354">next</a><span>|</span><label class="collapse" for="c-37503404">[-]</label><label class="expand" for="c-37503404">[1 more]</label></div><br/><div class="children"><div class="content">A lot of SPA’s already operate this by leveraging things like localstorage in the users browser.</div><br/></div></div></div></div><div id="37505354" class="c"><input type="checkbox" id="c-37505354" checked=""/><div class="controls bullet"><span class="by">uoaei</span><span>|</span><a href="#37503322">parent</a><span>|</span><a href="#37503363">prev</a><span>|</span><a href="#37502988">next</a><span>|</span><label class="collapse" for="c-37505354">[-]</label><label class="expand" for="c-37505354">[1 more]</label></div><br/><div class="children"><div class="content">I think the point is basically &quot;unless there&#x27;s a good reason for your API to look different than your DB schema, ontologically speaking, then the schema has already effectively defined your API and just let people interact with the DB&quot;, or, alternatively, &quot;bake in as much of the data constraints as possible into your DB schema, and only when you can&#x27;t enforce them with column constraints or DB extensions should you add APIs on top&quot;.</div><br/></div></div></div></div><div id="37502988" class="c"><input type="checkbox" id="c-37502988" checked=""/><div class="controls bullet"><span class="by">KRAKRISMOTT</span><span>|</span><a href="#37503322">prev</a><span>|</span><a href="#37502833">next</a><span>|</span><label class="collapse" for="c-37502988">[-]</label><label class="expand" for="c-37502988">[22 more]</label></div><br/><div class="children"><div class="content">Is this a true cloud managed SQLite or is this like their PostgreSQL documentation where it&#x27;s just a bunch of pre configured docker containers and the developer is expected to manage everything themselves? If the db goes down for an extended period of time at 3am, does fly.io have an engineer on call?<p>I find that fly.io has been a very disingenuous startup. They position themselves as some sort of Heroku successor and hide behind their developer content marketing while providing very low quality infrastructure. At the end of the day, fancy blog posts may win hearts and minds, but downtime cost businesses actual money.</div><br/><div id="37503099" class="c"><input type="checkbox" id="c-37503099" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#37502988">parent</a><span>|</span><a href="#37503026">next</a><span>|</span><label class="collapse" for="c-37503099">[-]</label><label class="expand" for="c-37503099">[13 more]</label></div><br/><div class="children"><div class="content">I think you are thinking that Fly is like a serverless platform. They aren&#x27;t. They are the opposite. They are a server platform. They provide server for you and you have to manage your server yourself.<p>Nothing they provide is managed by them. You have to do that.<p>LiteFS is just a replication service for your sqlite database so you can keep your database synced across multiple nodes.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;litefs">https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;litefs</a><p>LiteFS Cloud which is the a service they provide just helps you backup and recover sqlite databases. You can do this yourself.<p><a href="https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;backup&#x2F;">https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;backup&#x2F;</a></div><br/><div id="37503142" class="c"><input type="checkbox" id="c-37503142" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503099">parent</a><span>|</span><a href="#37504039">next</a><span>|</span><label class="collapse" for="c-37503142">[-]</label><label class="expand" for="c-37503142">[6 more]</label></div><br/><div class="children"><div class="content">I go into a project folder and can run &quot;fly launch&quot; and then the application is alive in multiple regions around the world. Where exactly am I manging this server?</div><br/><div id="37503189" class="c"><input type="checkbox" id="c-37503189" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503142">parent</a><span>|</span><a href="#37504039">next</a><span>|</span><label class="collapse" for="c-37503189">[-]</label><label class="expand" for="c-37503189">[5 more]</label></div><br/><div class="children"><div class="content">Open up the Dockerfile they generate for you.</div><br/><div id="37503302" class="c"><input type="checkbox" id="c-37503302" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503189">parent</a><span>|</span><a href="#37503325">next</a><span>|</span><label class="collapse" for="c-37503302">[-]</label><label class="expand" for="c-37503302">[3 more]</label></div><br/><div class="children"><div class="content">How does a Dockerfile change things? Your application is packaged into a container. The Fly service runs any application not just web applications or build artifacts. Of course your application is going to get a complete operating system environment to run in.<p>I don&#x27;t think the Dockerfile has anything to do with them pulling your container from their registry and running it on their server.</div><br/><div id="37504528" class="c"><input type="checkbox" id="c-37504528" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503302">parent</a><span>|</span><a href="#37503325">next</a><span>|</span><label class="collapse" for="c-37504528">[-]</label><label class="expand" for="c-37504528">[2 more]</label></div><br/><div class="children"><div class="content">Fly.io does not run containers. They convert your docker image to a VM.</div><br/><div id="37504678" class="c"><input type="checkbox" id="c-37504678" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37504528">parent</a><span>|</span><a href="#37503325">next</a><span>|</span><label class="collapse" for="c-37504678">[-]</label><label class="expand" for="c-37504678">[1 more]</label></div><br/><div class="children"><div class="content">Ah right okay thanks. The point still stands the Dockerfile and image is used as a container for your application and does not imply a manage-it-yourself server is being used.</div><br/></div></div></div></div></div></div><div id="37503325" class="c"><input type="checkbox" id="c-37503325" checked=""/><div class="controls bullet"><span class="by">eddythompson80</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503189">parent</a><span>|</span><a href="#37503302">prev</a><span>|</span><a href="#37504039">next</a><span>|</span><label class="collapse" for="c-37503325">[-]</label><label class="expand" for="c-37503325">[1 more]</label></div><br/><div class="children"><div class="content">So a scaffolding tool?</div><br/></div></div></div></div></div></div><div id="37504039" class="c"><input type="checkbox" id="c-37504039" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503099">parent</a><span>|</span><a href="#37503142">prev</a><span>|</span><a href="#37503374">next</a><span>|</span><label class="collapse" for="c-37504039">[-]</label><label class="expand" for="c-37504039">[5 more]</label></div><br/><div class="children"><div class="content">There is no such thing as &quot;serverless&quot;, that&#x27;s just a higher than normal level of vendor lying.</div><br/><div id="37504662" class="c"><input type="checkbox" id="c-37504662" checked=""/><div class="controls bullet"><span class="by">chrisoverzero</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37504039">parent</a><span>|</span><a href="#37504224">next</a><span>|</span><label class="collapse" for="c-37504662">[-]</label><label class="expand" for="c-37504662">[2 more]</label></div><br/><div class="children"><div class="content">I said nearly the same thing decades ago. Smashed a few friends’ so-called “wireless” telephones and showed them all the wires. Just look out a window; what’re those long, wiry things running between the utility poles, huh?! It’s ridiculous, the level of lying.</div><br/><div id="37506474" class="c"><input type="checkbox" id="c-37506474" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37504662">parent</a><span>|</span><a href="#37504224">next</a><span>|</span><label class="collapse" for="c-37506474">[-]</label><label class="expand" for="c-37506474">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s &quot;lying&quot; if you mislead another person.<p>In those two examples: serverless and wireless phones, it&#x27;s not misleading consumers.<p>Serverless is a way to communicate that the consumer won&#x27;t need to provision and maintain servers. It is true.<p>Wireless phone means you can move for quite long distances while talking without any wire connecting your device to the wall. It is true.<p>You may argue they&#x27;re &quot;misnomers&quot;. But to call it a &quot;lie&quot; is quite a stretch...</div><br/></div></div></div></div><div id="37504224" class="c"><input type="checkbox" id="c-37504224" checked=""/><div class="controls bullet"><span class="by">impulser_</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37504039">parent</a><span>|</span><a href="#37504662">prev</a><span>|</span><a href="#37503374">next</a><span>|</span><label class="collapse" for="c-37504224">[-]</label><label class="expand" for="c-37504224">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Serverless_computing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Serverless_computing</a></div><br/><div id="37504296" class="c"><input type="checkbox" id="c-37504296" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37504224">parent</a><span>|</span><a href="#37503374">next</a><span>|</span><label class="collapse" for="c-37504296">[-]</label><label class="expand" for="c-37504296">[1 more]</label></div><br/><div class="children"><div class="content">The first sentence in your link includes &quot;in which the cloud provider allocates machine resources on demand, taking care of the servers&quot;. =<p>There is NO SUCH THING as serverless. There are always servers.</div><br/></div></div></div></div></div></div></div></div><div id="37503026" class="c"><input type="checkbox" id="c-37503026" checked=""/><div class="controls bullet"><span class="by">nirushiv</span><span>|</span><a href="#37502988">parent</a><span>|</span><a href="#37503099">prev</a><span>|</span><a href="#37503429">next</a><span>|</span><label class="collapse" for="c-37503026">[-]</label><label class="expand" for="c-37503026">[1 more]</label></div><br/><div class="children"><div class="content">Can second this. Tried them out at our startup, came away unimpressed. Their good engineering blog is great marketing though, although this particular post is lacklustre. What about permissions, indirections, versioning or otherwise encapsulating breaking changes?</div><br/></div></div><div id="37503429" class="c"><input type="checkbox" id="c-37503429" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37502988">parent</a><span>|</span><a href="#37503026">prev</a><span>|</span><a href="#37503148">next</a><span>|</span><label class="collapse" for="c-37503429">[-]</label><label class="expand" for="c-37503429">[1 more]</label></div><br/><div class="children"><div class="content">Author here. I think we could have set better expectations with our Postgres docs. It wasn&#x27;t meant to be a managed service but rather some tooling to help streamline setting up a database and replicas. I&#x27;m sorry about the troubles you&#x27;ve had and that it&#x27;s come off as us being disingenuous. We blog about things that we&#x27;re working on and find interesting. It&#x27;s not meant say that we&#x27;ve figured everything out but rather this is what we&#x27;ve tried.<p>As for this post, it&#x27;s not managed SQLite but rather an open source project called LiteFS [1]. You can run it anywhere that runs Linux. We use it in few places in our infrastructure and found that sharing the underlying database for internal tooling was really helpful for that use case.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;litefs">https:&#x2F;&#x2F;github.com&#x2F;superfly&#x2F;litefs</a></div><br/></div></div><div id="37503148" class="c"><input type="checkbox" id="c-37503148" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#37502988">parent</a><span>|</span><a href="#37503429">prev</a><span>|</span><a href="#37502833">next</a><span>|</span><label class="collapse" for="c-37503148">[-]</label><label class="expand" for="c-37503148">[6 more]</label></div><br/><div class="children"><div class="content">I was just setting up a new Fly account and launching a project yesterday. I will say their developer content marketing is very succesful and had me convinced they at least know what they are talking about.<p>Any more stories or knowledge of them being disingenous?</div><br/><div id="37503522" class="c"><input type="checkbox" id="c-37503522" checked=""/><div class="controls bullet"><span class="by">aledalgrande</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503148">parent</a><span>|</span><a href="#37503377">next</a><span>|</span><label class="collapse" for="c-37503522">[-]</label><label class="expand" for="c-37503522">[1 more]</label></div><br/><div class="children"><div class="content">Their DX is good. They just have a lot of reliability&#x2F;availability issues.</div><br/></div></div><div id="37503377" class="c"><input type="checkbox" id="c-37503377" checked=""/><div class="controls bullet"><span class="by">jokethrowaway</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503148">parent</a><span>|</span><a href="#37503522">prev</a><span>|</span><a href="#37502833">next</a><span>|</span><label class="collapse" for="c-37503377">[-]</label><label class="expand" for="c-37503377">[4 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say disingenuous but uptime has been disastrous.<p>I&#x27;m definitely not buying anything there.<p>I run a free service on fly.io.<p>It&#x27;s been ok lately (or maybe my users just stopped complaining), so maybe they got better.</div><br/><div id="37503439" class="c"><input type="checkbox" id="c-37503439" checked=""/><div class="controls bullet"><span class="by">RyeCombinator</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503377">parent</a><span>|</span><a href="#37502833">next</a><span>|</span><label class="collapse" for="c-37503439">[-]</label><label class="expand" for="c-37503439">[3 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s free.</div><br/><div id="37506506" class="c"><input type="checkbox" id="c-37506506" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503439">parent</a><span>|</span><a href="#37504049">next</a><span>|</span><label class="collapse" for="c-37506506">[-]</label><label class="expand" for="c-37506506">[1 more]</label></div><br/><div class="children"><div class="content">If the free juice they give you in the supermarket tastes bad, will you buy it?<p>We assume the free version to have similar quality to the paid one. It&#x27;s in the vendor interest, so that we like it and become a paid customer. If they can&#x27;t convince us of their quality in the free version, how are we supposed to trust the paid one?</div><br/></div></div><div id="37504049" class="c"><input type="checkbox" id="c-37504049" checked=""/><div class="controls bullet"><span class="by">TylerE</span><span>|</span><a href="#37502988">root</a><span>|</span><a href="#37503439">parent</a><span>|</span><a href="#37506506">prev</a><span>|</span><a href="#37502833">next</a><span>|</span><label class="collapse" for="c-37504049">[-]</label><label class="expand" for="c-37504049">[1 more]</label></div><br/><div class="children"><div class="content">Free can be the most expensive price of all.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="37502833" class="c"><input type="checkbox" id="c-37502833" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#37502988">prev</a><span>|</span><a href="#37506468">next</a><span>|</span><label class="collapse" for="c-37502833">[-]</label><label class="expand" for="c-37502833">[20 more]</label></div><br/><div class="children"><div class="content">A very interesting idea to be sure, but IME the biggest downside (which tbf is mentioned in the article) is the contract.  If you have clients with knowledge of and dependency on the schema, you can&#x27;t change it in a breaking way unless you update all the client&#x27;s code.<p>I&#x27;ve tried various patterns in the past like one that just exposes database columns as an API, and this pain point always comes calling and it hurts.  Keeping your data model simple and lean as possible is an important part of limiting complexity, which directly correlates with maintainability.<p>The only pattern&#x2F;approach that I consistently return to is the Rails pattern (I use Elixir&#x2F;Phoenix now but same pattern).  It is certainly not the most sexy, and having a client be able to graphql exactly what they need can be really helpful, but at least for me it has rarely turned out to be worth the tradeoffs.</div><br/><div id="37502902" class="c"><input type="checkbox" id="c-37502902" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#37502833">parent</a><span>|</span><a href="#37503017">next</a><span>|</span><label class="collapse" for="c-37502902">[-]</label><label class="expand" for="c-37502902">[1 more]</label></div><br/><div class="children"><div class="content">This is basically how Firebase is designed and it drives me nuts. I&#x27;ve freelanced with several teams, primarily comprised of front-end devs, who decided to use Firebase for their product. When they first told me they query the database directly from both their website and their mobile app, I immediately was like &quot;so...what happens if you need to change the structure of the database&quot;?<p>Crickets.</div><br/></div></div><div id="37503017" class="c"><input type="checkbox" id="c-37503017" checked=""/><div class="controls bullet"><span class="by">10000truths</span><span>|</span><a href="#37502833">parent</a><span>|</span><a href="#37502902">prev</a><span>|</span><a href="#37503169">next</a><span>|</span><label class="collapse" for="c-37503017">[-]</label><label class="expand" for="c-37503017">[14 more]</label></div><br/><div class="children"><div class="content">The solution to this is the same as with APIs: versioning. Instead of naming your table &quot;my_foo&quot;, you name it &quot;my_foo_v1&quot;. Then, when you want to make a breaking change to the schema, you:<p>1. Create a new table &quot;my_foo_v2&quot; with your desired schema<p>2. Modify write queries for &quot;my_foo_v1&quot; so that they also write to &quot;my_foo_v2&quot;<p>3. Copy over existing data in &quot;my_foo_v1&quot; to &quot;my_foo_v2&quot; with a migration script<p>4. Modify read queries for &quot;my_foo_v1&quot; so that they read from &quot;my_foo_v2&quot; instead<p>5. Remove all write queries to &quot;my_foo_v1&quot;<p>6. Drop the &quot;my_foo_v1&quot; table</div><br/><div id="37503173" class="c"><input type="checkbox" id="c-37503173" checked=""/><div class="controls bullet"><span class="by">JustLurking2022</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503017">parent</a><span>|</span><a href="#37503164">next</a><span>|</span><label class="collapse" for="c-37503173">[-]</label><label class="expand" for="c-37503173">[6 more]</label></div><br/><div class="children"><div class="content">Holy hell does that sound awful. In practice, it doesn&#x27;t even solve the core problem as you&#x27;d have to deploy new versions of all binaries precisely in sync to avoid data incorrect because some clients know about the v2 table and others don&#x27;t. It becomes indistinguishable whether a row is missing because it was intentionally deleted or because it was written by a client who didn&#x27;t know any the new table version. There are ways to account for this but it&#x27;s layers of crap on top of crap.</div><br/><div id="37503266" class="c"><input type="checkbox" id="c-37503266" checked=""/><div class="controls bullet"><span class="by">enragedcacti</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503173">parent</a><span>|</span><a href="#37504448">next</a><span>|</span><label class="collapse" for="c-37503266">[-]</label><label class="expand" for="c-37503266">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  it doesn&#x27;t even solve the core problem as you&#x27;d have to deploy new versions of all binaries precisely in sync to avoid data incorrect because some clients know about the v2 table and others don&#x27;t<p>its painful but this approach does work as long as every client is migrated between each step.<p>after 1: v1 is valid, reading v1, writing v1<p>after 2: v1 is valid, reading v1, writing v1 and v2<p>after 3: v1 and v2 are valid, reading v1, writing v1 and v2<p>after 4: v1 and v2 are valid, reading v2, writing v1 and v2<p>after 5: v2 is valid, reading v2, writing v2<p>after 6: v2 is valid, reading v2, writing v2<p>at each point, both the current and the previous version are reading a valid table and writing to a table whose values will make it into v2.</div><br/><div id="37504525" class="c"><input type="checkbox" id="c-37504525" checked=""/><div class="controls bullet"><span class="by">nevir</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503266">parent</a><span>|</span><a href="#37504448">next</a><span>|</span><label class="collapse" for="c-37504525">[-]</label><label class="expand" for="c-37504525">[1 more]</label></div><br/><div class="children"><div class="content">Good luck migrating every single client in the real world (unless you are willing to disable old clients &amp; force an upgrade if they get too old)</div><br/></div></div></div></div><div id="37504448" class="c"><input type="checkbox" id="c-37504448" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503173">parent</a><span>|</span><a href="#37503266">prev</a><span>|</span><a href="#37503164">next</a><span>|</span><label class="collapse" for="c-37504448">[-]</label><label class="expand" for="c-37504448">[3 more]</label></div><br/><div class="children"><div class="content">Is there really any alternative? Data migrations are always going to be terrible. You need to slowly roll out the incremental changes so that everything is backwards compatible until you the threshold point where you can finally delete the historical route.</div><br/><div id="37504519" class="c"><input type="checkbox" id="c-37504519" checked=""/><div class="controls bullet"><span class="by">nevir</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37504448">parent</a><span>|</span><a href="#37505271">next</a><span>|</span><label class="collapse" for="c-37504519">[-]</label><label class="expand" for="c-37504519">[1 more]</label></div><br/><div class="children"><div class="content">With an API, you can often create facades and other patterns to avoid having to migrate the underlying data</div><br/></div></div><div id="37505271" class="c"><input type="checkbox" id="c-37505271" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37504448">parent</a><span>|</span><a href="#37504519">prev</a><span>|</span><a href="#37503164">next</a><span>|</span><label class="collapse" for="c-37505271">[-]</label><label class="expand" for="c-37505271">[1 more]</label></div><br/><div class="children"><div class="content">In a sensible approach schema migrations are totally decoupled from the API.</div><br/></div></div></div></div></div></div><div id="37503164" class="c"><input type="checkbox" id="c-37503164" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503017">parent</a><span>|</span><a href="#37503173">prev</a><span>|</span><a href="#37506097">next</a><span>|</span><label class="collapse" for="c-37503164">[-]</label><label class="expand" for="c-37503164">[2 more]</label></div><br/><div class="children"><div class="content">With postgres, simple views are updatable, so you can often do this pattern without copying tables or dual writes. It&#x27;s particularly useful for renaming columns, but you can also do some other things. You also don&#x27;t have to use version numbers on all your tables since you only need the view temporarily.<p><pre><code>    ALTER TABLE my_foo RENAME TO my_foo_tmp;
    ALTER TABLE my_foo_tmp &lt;your desired change here&gt;;
    CREATE VIEW my_foo AS SELECT &lt;how you make your new table seem like your old table&gt;;
    COMMIT;
    &lt;update your apps to use my_foo_tmp&gt;
    DROP VIEW my_foo;
    ALTER TABLE my_foo_tmp RENAME TO my_foo;
    CREATE VIEW my_foo_tmp as select * from my_foo;
    COMMIT;
    &lt;update your apps to use my_foo&gt;
    DROP VIEW my_foo_tmp; COMMIT;</code></pre></div><br/><div id="37503285" class="c"><input type="checkbox" id="c-37503285" checked=""/><div class="controls bullet"><span class="by">munk-a</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503164">parent</a><span>|</span><a href="#37506097">next</a><span>|</span><label class="collapse" for="c-37503285">[-]</label><label class="expand" for="c-37503285">[1 more]</label></div><br/><div class="children"><div class="content">We actually used a similar tactic when transitioning our data to supporting soft deletion.  We have a limited number of queries that update data or present data for administrative review and processing - but a lot of wild ones around reporting.  We&#x27;d rename table `foo` to `foowithdeleted` and create a new `foo` view that excludes any soft-deleted rows.  Our reporting queries keep on trucking like normal and read out of the `foo` table (now a view - but they don&#x27;t care) and we only need to adjust the administrative view to show soft-deleted rows for undeletion operations.<p>Shell-gaming tables with views can be incredibly useful in postgres.</div><br/></div></div></div></div><div id="37506097" class="c"><input type="checkbox" id="c-37506097" checked=""/><div class="controls bullet"><span class="by">manmal</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503017">parent</a><span>|</span><a href="#37503164">prev</a><span>|</span><a href="#37503514">next</a><span>|</span><label class="collapse" for="c-37506097">[-]</label><label class="expand" for="c-37506097">[1 more]</label></div><br/><div class="children"><div class="content">Imagine you have Android &amp; iOS apps which some of your users won&#x27;t ever update. You&#x27;ll never be able to drop any old version&#x27;s tables, and you&#x27;ll need to keep all table versions in sync more or less in real-time. Only when the last user has updated from a certain client version will you be able to remove that version&#x27;s tables.</div><br/></div></div><div id="37503514" class="c"><input type="checkbox" id="c-37503514" checked=""/><div class="controls bullet"><span class="by">danielvaughn</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503017">parent</a><span>|</span><a href="#37506097">prev</a><span>|</span><a href="#37505260">next</a><span>|</span><label class="collapse" for="c-37503514">[-]</label><label class="expand" for="c-37503514">[2 more]</label></div><br/><div class="children"><div class="content">You know, I&#x27;ve been toying with this very idea in my head for a while, as a way to make safe schema migrations. But I also know very little about databases so had no idea if this was a stupid idea or not. Glad to know I&#x27;m not alone.<p>One issue I&#x27;ve considered is fk relationships - that could get complicated depending on the approach.</div><br/><div id="37505325" class="c"><input type="checkbox" id="c-37505325" checked=""/><div class="controls bullet"><span class="by">clintonb</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503514">parent</a><span>|</span><a href="#37505260">next</a><span>|</span><label class="collapse" for="c-37505325">[-]</label><label class="expand" for="c-37505325">[1 more]</label></div><br/><div class="children"><div class="content">Schema migrations are a solved problem. You make backward-incompatible changes in multiple steps.<p><a href="https:&#x2F;&#x2F;engineering.edx.org&#x2F;django-migration-donts-f4588fd11b64" rel="nofollow noreferrer">https:&#x2F;&#x2F;engineering.edx.org&#x2F;django-migration-donts-f4588fd11...</a></div><br/></div></div></div></div><div id="37505260" class="c"><input type="checkbox" id="c-37505260" checked=""/><div class="controls bullet"><span class="by">mvdtnz</span><span>|</span><a href="#37502833">root</a><span>|</span><a href="#37503017">parent</a><span>|</span><a href="#37503514">prev</a><span>|</span><a href="#37503116">next</a><span>|</span><label class="collapse" for="c-37505260">[-]</label><label class="expand" for="c-37505260">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry that is insane. That approach wouldn&#x27;t pass the first sniff test of any sensible technical design review.</div><br/></div></div></div></div><div id="37503169" class="c"><input type="checkbox" id="c-37503169" checked=""/><div class="controls bullet"><span class="by">SOLAR_FIELDS</span><span>|</span><a href="#37502833">parent</a><span>|</span><a href="#37503017">prev</a><span>|</span><a href="#37503359">next</a><span>|</span><label class="collapse" for="c-37503169">[-]</label><label class="expand" for="c-37503169">[1 more]</label></div><br/><div class="children"><div class="content">I think about this with Postgrest&#x2F;Supabase which has a similar problem (autogenerated code based on the db schema is inherently going to conflict with api stability guarantees). I think that this approach is just fundamentally at odds with making a stable versioned controlled API.<p>However: I think the best thing to do if you want a setup like this and want to have your cake and eat it too is something like this:<p>Use your autogenned client for your “internal” api. This is for your clients with the autogenned schema that you directly control only so that you can ship changes and not have to worry about versioning&#x2F;backwards compatibility.<p>Then for external users that have their own clients, you have that slimmed down more traditional API that offers less functionality but it’s properly versioned, tested etc<p>I think this kind of hybrid setup can work well for SaaS setups where you have a cloud product that does internal stuff plus things external that end users need to operate on. You get the benefit of being able to iterate quickly without breaking your clients and since your external API is smaller it’s less maintenance overhead to keep it updated and versioned</div><br/></div></div><div id="37503359" class="c"><input type="checkbox" id="c-37503359" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#37502833">parent</a><span>|</span><a href="#37503169">prev</a><span>|</span><a href="#37503203">next</a><span>|</span><label class="collapse" for="c-37503359">[-]</label><label class="expand" for="c-37503359">[1 more]</label></div><br/><div class="children"><div class="content">They mention one partial &quot;solution&quot; to this: have your clients query a view, instead of tables directly.<p>When you need to change the schema, also update the view accordingly.<p>Of course, there are still limitations. For one: you can&#x27;t &quot;massage&quot; data with a view as you could in the backend with a full featured programming language.<p>PS: I don&#x27;t think this is a good solution, just mentioning it.</div><br/></div></div><div id="37503203" class="c"><input type="checkbox" id="c-37503203" checked=""/><div class="controls bullet"><span class="by">floodle</span><span>|</span><a href="#37502833">parent</a><span>|</span><a href="#37503359">prev</a><span>|</span><a href="#37503326">next</a><span>|</span><label class="collapse" for="c-37503203">[-]</label><label class="expand" for="c-37503203">[1 more]</label></div><br/><div class="children"><div class="content">If you are in the situation where you are shipping a web app where one dev team controls the backend and the one and only client and ships both together, is this a big issue?</div><br/></div></div></div></div><div id="37506468" class="c"><input type="checkbox" id="c-37506468" checked=""/><div class="controls bullet"><span class="by">shimst3r</span><span>|</span><a href="#37502833">prev</a><span>|</span><a href="#37502885">next</a><span>|</span><label class="collapse" for="c-37506468">[-]</label><label class="expand" for="c-37506468">[1 more]</label></div><br/><div class="children"><div class="content">As someone who has worked as a data engineer on an organically grown monolith, the last thing you want to do is ceding control over your schema due to the lack of (sensible) abstraction. Everyone will change it, nobody cares about standardization. It’s utter chaos and a data engineering nightmare.<p>This is the same, plus the lack of proper authN&#x2F; authZ. Good luck passing your next audit.</div><br/></div></div><div id="37502885" class="c"><input type="checkbox" id="c-37502885" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#37506468">prev</a><span>|</span><a href="#37505003">next</a><span>|</span><label class="collapse" for="c-37502885">[-]</label><label class="expand" for="c-37502885">[7 more]</label></div><br/><div class="children"><div class="content">I think there are some reasonable ways to avoid the schema brittleness that people are concerned about with this.<p>Firstly, acknowledge that in this model your schema IS your API. Don&#x27;t include anything in the database that is being replicated that isn&#x27;t considered to be documented, tested and stable.<p>With that in place, API changes become the same as changes to a JSON API or similar: you can only make backwards-compatible changes, like adding new columns or adding new tables.<p>If you do need to make a backwards incompatible change there are ways to patch over it. Ship a brand new table with the new design, and include a SQL view that matches the name of the old table and exposes a compatible subset of it.</div><br/><div id="37502984" class="c"><input type="checkbox" id="c-37502984" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37502885">parent</a><span>|</span><a href="#37503808">next</a><span>|</span><label class="collapse" for="c-37502984">[-]</label><label class="expand" for="c-37502984">[3 more]</label></div><br/><div class="children"><div class="content">Maybe it&#x27;s better to have views in the first place, and to require (though it can only be enforced at an administrative level) external services to query against those views.<p>We won&#x27;t have to do this switch to a view, we&#x27;ve paid that upfront.<p>We can then include a version number in the view name, similar to how we do with APIs. So if we introduce changes we can keep services which didn&#x27;t need that change outside the blast radius.<p>And we have a limited ability to enforce contracts and declare some columns internal.</div><br/><div id="37503105" class="c"><input type="checkbox" id="c-37503105" checked=""/><div class="controls bullet"><span class="by">thestepafter</span><span>|</span><a href="#37502885">root</a><span>|</span><a href="#37502984">parent</a><span>|</span><a href="#37503808">next</a><span>|</span><label class="collapse" for="c-37503105">[-]</label><label class="expand" for="c-37503105">[2 more]</label></div><br/><div class="children"><div class="content">Even better, use stored procedures &#x2F; routines on top of views and only query the stored procedures from the frontend.</div><br/><div id="37504425" class="c"><input type="checkbox" id="c-37504425" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37502885">root</a><span>|</span><a href="#37503105">parent</a><span>|</span><a href="#37503808">next</a><span>|</span><label class="collapse" for="c-37504425">[-]</label><label class="expand" for="c-37504425">[1 more]</label></div><br/><div class="children"><div class="content">I like it, but the only benefit we&#x27;ve retained at that point is eliminating round trips. Which is pretty significant. But we&#x27;re still engaging in API design, we&#x27;re just doing it in Sqlite.</div><br/></div></div></div></div></div></div><div id="37503808" class="c"><input type="checkbox" id="c-37503808" checked=""/><div class="controls bullet"><span class="by">jimmytucson</span><span>|</span><a href="#37502885">parent</a><span>|</span><a href="#37502984">prev</a><span>|</span><a href="#37502939">next</a><span>|</span><label class="collapse" for="c-37503808">[-]</label><label class="expand" for="c-37503808">[1 more]</label></div><br/><div class="children"><div class="content">That is an appealing idea but on second thought, haven’t you just shifted the problem to: how do I reliably replicate logical updates from my operational tables (internal, constantly changing) to my clean, public-facing tables?<p>Basically, your public tables become materialized views over the “dirty” tables, and I’ve never met a mature, reliable implementation of materialized views, or even an immature one that is feature complete. (I would love to be wrong on the internet with this one!)</div><br/></div></div><div id="37502939" class="c"><input type="checkbox" id="c-37502939" checked=""/><div class="controls bullet"><span class="by">javajosh</span><span>|</span><a href="#37502885">parent</a><span>|</span><a href="#37503808">prev</a><span>|</span><a href="#37505003">next</a><span>|</span><label class="collapse" for="c-37502939">[-]</label><label class="expand" for="c-37502939">[2 more]</label></div><br/><div class="children"><div class="content">This is correct, but there are very few people with experience with safe database modelling like this, and they may not even realize the technique exists.</div><br/><div id="37503204" class="c"><input type="checkbox" id="c-37503204" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#37502885">root</a><span>|</span><a href="#37502939">parent</a><span>|</span><a href="#37505003">next</a><span>|</span><label class="collapse" for="c-37503204">[-]</label><label class="expand" for="c-37503204">[1 more]</label></div><br/><div class="children"><div class="content">The same is true for APIs, too. Making changes to a JSON API that won&#x27;t break existing clients isn&#x27;t necessarily an obvious skill.<p>But it can be learned, as can backwards-compatible database schemas.</div><br/></div></div></div></div></div></div><div id="37505003" class="c"><input type="checkbox" id="c-37505003" checked=""/><div class="controls bullet"><span class="by">et1337</span><span>|</span><a href="#37502885">prev</a><span>|</span><a href="#37506296">next</a><span>|</span><label class="collapse" for="c-37505003">[-]</label><label class="expand" for="c-37505003">[1 more]</label></div><br/><div class="children"><div class="content">I have been thinking about this a lot lately. We have customers who run automation against us. They’re doing 10,000 API calls. Each one has to do a permission check, request signing, serialization, etc., etc. All just to mutate a blob of data less than say, 100MB. If they just downloaded the whole state, mutated it, and reuploaded it, the whole thing would be done in 2 seconds.<p>We already lock the entirety of each customer’s data when processing a request, in order to avoid data inconsistency from concurrent mutations.<p>One SQLite database per customer is a really appealing idea.</div><br/></div></div><div id="37506296" class="c"><input type="checkbox" id="c-37506296" checked=""/><div class="controls bullet"><span class="by">lambda_garden</span><span>|</span><a href="#37505003">prev</a><span>|</span><a href="#37505668">next</a><span>|</span><label class="collapse" for="c-37506296">[-]</label><label class="expand" for="c-37506296">[1 more]</label></div><br/><div class="children"><div class="content">This is not equivalent to (say) a single Postgres database where we get shared state with transactions between all users - or have I missed something?</div><br/></div></div><div id="37505668" class="c"><input type="checkbox" id="c-37505668" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#37506296">prev</a><span>|</span><a href="#37502844">next</a><span>|</span><label class="collapse" for="c-37505668">[-]</label><label class="expand" for="c-37505668">[2 more]</label></div><br/><div class="children"><div class="content">Sounds like the next step is some way to define a multi-table view over a more traditional RDBMS (e.g. Postgres), serving as a source of truth, that can be continually exported as a read-only SQLite, so that the SQLite file can be pushed to the edge and read from the edge?<p>I&#x27;m not sold on the idea of per-customer databases; businesses still need analytics, so if you&#x27;re not running your analytics on the centralized DB itself, your app needs to write&#x2F;push the data somewhere else, which is an unnecessary complication early in the product lifecycle at best and a recipe for frustration at worst.</div><br/><div id="37505701" class="c"><input type="checkbox" id="c-37505701" checked=""/><div class="controls bullet"><span class="by">vincnetas</span><span>|</span><a href="#37505668">parent</a><span>|</span><a href="#37502844">next</a><span>|</span><label class="collapse" for="c-37505701">[-]</label><label class="expand" for="c-37505701">[1 more]</label></div><br/><div class="children"><div class="content">remember the times when software companies shipped software to users, and users used the software offline. No one from business even dreamed of knowing what each user was doing with the software at any moment in real time. What data users stored etc.  Today it looks like this is MUST have for any software and no bussines is possible without this.</div><br/></div></div></div></div><div id="37502844" class="c"><input type="checkbox" id="c-37502844" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37505668">prev</a><span>|</span><a href="#37503812">next</a><span>|</span><label class="collapse" for="c-37502844">[-]</label><label class="expand" for="c-37502844">[4 more]</label></div><br/><div class="children"><div class="content">A downside I didn&#x27;t see mentioned (it was gestured at with contracts and the mention of backwards compatible schema changes, but not addressed directly) was tight coupling. When you link services with APIs, the downstream changes of a schema migration end at the API boundary. If you are connecting services directly at the database level, the changes will propagate into different services.<p>That would make me very nervous to ship something like this. You can probably cover a lot of this with views as a backwards compatibility shim, though.</div><br/><div id="37503578" class="c"><input type="checkbox" id="c-37503578" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37502844">parent</a><span>|</span><a href="#37503812">next</a><span>|</span><label class="collapse" for="c-37503578">[-]</label><label class="expand" for="c-37503578">[3 more]</label></div><br/><div class="children"><div class="content">Author here. I don&#x27;t see this is a general practice to be used for most applications. It was a side effect that we came across and it allowed us to share data between internal applications in some interesting ways. Internal apps are ideal since you have control of both sides of the contract. It definitely requires some more consideration if you&#x27;re publishing out to end users.</div><br/><div id="37504522" class="c"><input type="checkbox" id="c-37504522" checked=""/><div class="controls bullet"><span class="by">maxbond</span><span>|</span><a href="#37502844">root</a><span>|</span><a href="#37503578">parent</a><span>|</span><a href="#37503812">next</a><span>|</span><label class="collapse" for="c-37504522">[-]</label><label class="expand" for="c-37504522">[2 more]</label></div><br/><div class="children"><div class="content">Hi Ben, thanks for taking the time to respond. It&#x27;s an interesting approach, and I&#x27;m sure that it has it&#x27;s place &amp; you&#x27;ve made the right call for your particular situation.<p>I didn&#x27;t think you meant pushing it out to end users, my point was more that this technique increases the blast radius. If three services are touching this database, and our changes now necessitate three deploys, that&#x27;s much higher risk.<p>But it was an early comment, I hadn&#x27;t gotten to see the suggestions for managing this coupling yet. Each one of those does take us a step closer to designing an API, but perhaps part of the value here is that it allows you to move along a spectrum and to adopt the level of constraint you can afford, given the situation.<p>I&#x27;m curious if this has spread to any other services at fly? Or is it just this Corrosion service?</div><br/><div id="37504994" class="c"><input type="checkbox" id="c-37504994" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37502844">root</a><span>|</span><a href="#37504522">parent</a><span>|</span><a href="#37503812">next</a><span>|</span><label class="collapse" for="c-37504994">[-]</label><label class="expand" for="c-37504994">[1 more]</label></div><br/><div class="children"><div class="content">I think a spectrum is a great way to look at it. If you&#x27;re adding one service then it&#x27;s no big deal but as you add more and more then you get a better sense of the requirements of the API and I think you&#x27;re in a better place to build one out then.<p>We&#x27;ve used this in a few other instances but Corrosion is the largest database we&#x27;ve done it with.</div><br/></div></div></div></div></div></div></div></div><div id="37503812" class="c"><input type="checkbox" id="c-37503812" checked=""/><div class="controls bullet"><span class="by">Supply5411</span><span>|</span><a href="#37502844">prev</a><span>|</span><a href="#37505882">next</a><span>|</span><label class="collapse" for="c-37503812">[-]</label><label class="expand" for="c-37503812">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve written about this solution in the context of running LLM-generated SQL safely. I call it the &quot;cloned database view&quot; solution[1].<p>The author touches on 2 issues that are tangential to this problem, restricting unauthorized data, and mutations, both of which are not really easily solvable with the cloned database solution.<p>However, the underlying theme of skipping the API is extremely compelling. So much code, both FE and BE, are just to serve as an elaborate interface to the database. Simplifying this will be a huge gain in software maintenance. But the challenge is to do it safely.<p>1. <a href="https:&#x2F;&#x2F;docs.heimdallm.ai&#x2F;en&#x2F;main&#x2F;blog&#x2F;posts&#x2F;safe-sql-execution.html#cloned-db-views" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.heimdallm.ai&#x2F;en&#x2F;main&#x2F;blog&#x2F;posts&#x2F;safe-sql-execut...</a></div><br/></div></div><div id="37505882" class="c"><input type="checkbox" id="c-37505882" checked=""/><div class="controls bullet"><span class="by">Hakkin</span><span>|</span><a href="#37503812">prev</a><span>|</span><a href="#37503718">next</a><span>|</span><label class="collapse" for="c-37505882">[-]</label><label class="expand" for="c-37505882">[3 more]</label></div><br/><div class="children"><div class="content">Even if you &quot;skip the API&quot; you still have to think about access patterns for the data, otherwise client-side query performance is going to be abysmal. You would basically have to define your &quot;API&quot; via what indexes you create on the data.</div><br/><div id="37505920" class="c"><input type="checkbox" id="c-37505920" checked=""/><div class="controls bullet"><span class="by">abdullin</span><span>|</span><a href="#37505882">parent</a><span>|</span><a href="#37503718">next</a><span>|</span><label class="collapse" for="c-37505920">[-]</label><label class="expand" for="c-37505920">[2 more]</label></div><br/><div class="children"><div class="content">With a local SQLite database you don’t need to pay cost of network transfers.<p>A dozen of local SQL calls could be way faster than a single API call within a region.</div><br/><div id="37506010" class="c"><input type="checkbox" id="c-37506010" checked=""/><div class="controls bullet"><span class="by">Hakkin</span><span>|</span><a href="#37505882">root</a><span>|</span><a href="#37505920">parent</a><span>|</span><a href="#37503718">next</a><span>|</span><label class="collapse" for="c-37506010">[-]</label><label class="expand" for="c-37506010">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, but low query latency doesn&#x27;t mean much if you have to do a full table scan for your query. Some thought still needs to be put into how the clients will query the data, so it&#x27;s really not as simple as just &quot;ship your entire database to the client and let them figure it out&quot;.</div><br/></div></div></div></div></div></div><div id="37503718" class="c"><input type="checkbox" id="c-37503718" checked=""/><div class="controls bullet"><span class="by">jimmytucson</span><span>|</span><a href="#37505882">prev</a><span>|</span><a href="#37505478">next</a><span>|</span><label class="collapse" for="c-37503718">[-]</label><label class="expand" for="c-37503718">[2 more]</label></div><br/><div class="children"><div class="content">I love this kind of reasoning that forces you to climb out of the comfortable nook in a tree of thought you’ve been occupying for years to see if there’s a better vantage point!<p>So would this work equally well? Use Postgres on some cloud and “spin up” a read-replica that your clients have access to. Let them read from the replica.<p>If yes, I have tried that and I can tell you the problem I had. They don’t want to get to know my database schema. I know, frustrating! “If you would just get to know me better, you would have all the secrets you desire!” Sigh… they just want this overly simplistic Interface that doesn’t change, even when we rewrite things to make them better on the backend.<p>Another thought: if sharing compute is the main problem, you can just egress the data to distributed file storage like S3 and let them write SQL on the files using some Presto, like Athena. Or egress to BigQuery and let them bring their own compute. But the problem there again is getting to know my internal data structure, and also by “egress” I really mean “dump the whole damn thing because once the data is on S3 I can’t just update a single row like I can on an OLTP database” and you can only do that every so often.</div><br/><div id="37503865" class="c"><input type="checkbox" id="c-37503865" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37503718">parent</a><span>|</span><a href="#37505478">next</a><span>|</span><label class="collapse" for="c-37503865">[-]</label><label class="expand" for="c-37503865">[1 more]</label></div><br/><div class="children"><div class="content">Yes, Postgres replication would work as well. I agree that the &quot;getting to know the schema&quot; part is an issue. I think there&#x27;s use cases out there where you have power users that would gladly invest extra time in exchange for query flexibility.<p>Querying to S3 is a good approach too. Those query tools can be somewhat involved to setup but definitely a good option.</div><br/></div></div></div></div><div id="37505478" class="c"><input type="checkbox" id="c-37505478" checked=""/><div class="controls bullet"><span class="by">mkl95</span><span>|</span><a href="#37503718">prev</a><span>|</span><a href="#37503726">next</a><span>|</span><label class="collapse" for="c-37505478">[-]</label><label class="expand" for="c-37505478">[1 more]</label></div><br/><div class="children"><div class="content">In the beginning of my career, I did an internship at a very small company that had been selling a desktop app for 20+ years, among other stuff. Each customer got their own database.<p>The software was pretty stable and the team were part time consultants for that app, which mostly involved helping users perform complicated queries and creating stored procedures (they loved those). Subscription was allegedly quite expensive and had minimal churn over the years.<p>For that kind of hyper stable software where each customer get their own database, I can see it working. In your typical 2023 SaaS where you are serving 1000s of users through a complex API and a database, I&#x27;m not sure a db can give you the level of flexibility and quality of life an API gives you.</div><br/></div></div><div id="37503726" class="c"><input type="checkbox" id="c-37503726" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#37505478">prev</a><span>|</span><a href="#37505179">next</a><span>|</span><label class="collapse" for="c-37503726">[-]</label><label class="expand" for="c-37503726">[1 more]</label></div><br/><div class="children"><div class="content">It sounds like this is essentially database replication, but perhaps cheaper, since it&#x27;s a SQLite file with a schema hopefully designed to contain whatever the client needs rather than random junk. You&#x27;d still have to send writes to one location and they&#x27;d fan out from there, with some latency.<p>It seems like it would be a good fit with edge servers, assuming any node that starts an instance could get a copy of the database when it starts. Most database-as-a-service companies don&#x27;t do that.<p>I doubt I&#x27;d try it if it isn&#x27;t a fully managed system, though. The only one I know of is Cloudflare&#x27;s Durable Objects, and it&#x27;s not in the free tier. For hobbyist programming that&#x27;s kind of a drag, so I haven&#x27;t tried it. Instead I&#x27;ll probably try Deno&#x27;s KV. (This sort of thing is what I hoped KV would be, but apparently it isn&#x27;t.)<p>I wonder what the cold-start performance would be for downloading a small SQLite database from S3, starting it up in memory, and subscribing to a replication log?</div><br/></div></div><div id="37505179" class="c"><input type="checkbox" id="c-37505179" checked=""/><div class="controls bullet"><span class="by">abdullin</span><span>|</span><a href="#37503726">prev</a><span>|</span><a href="#37505697">next</a><span>|</span><label class="collapse" for="c-37505179">[-]</label><label class="expand" for="c-37505179">[1 more]</label></div><br/><div class="children"><div class="content">There also is a productivity boost within this approach.<p>When you have a local DB as an integration point, you could just upload it to ChatGPT Code Interpreter for building extra reports and running analysis on it.<p>Alternatively, upload the schema to ChatGPT and “write these few methods with unit tests for me, please”.<p>I’m not saying that this approach is universal, but it saves me an hour of time now and then.</div><br/></div></div><div id="37505697" class="c"><input type="checkbox" id="c-37505697" checked=""/><div class="controls bullet"><span class="by">k_vi</span><span>|</span><a href="#37505179">prev</a><span>|</span><a href="#37504484">next</a><span>|</span><label class="collapse" for="c-37505697">[-]</label><label class="expand" for="c-37505697">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried doing this read &amp; updates using Postgrest and row-level-security using Supabase. When it works its an amazing experience but even for semi complex stuff you would still need to use Postgres RPC, which is still another &quot;API&quot; layer. I find writing API using SQL a nigtmare.<p>Simple queries like this don&#x27;t work on Postgrest:
`update likes set likes = likes + 1;`</div><br/></div></div><div id="37504484" class="c"><input type="checkbox" id="c-37504484" checked=""/><div class="controls bullet"><span class="by">thyrox</span><span>|</span><a href="#37505697">prev</a><span>|</span><a href="#37504141">next</a><span>|</span><label class="collapse" for="c-37504484">[-]</label><label class="expand" for="c-37504484">[1 more]</label></div><br/><div class="children"><div class="content">I was really excited about fly.io at one point but after reading all the recent posts(1) on HN I don&#x27;t have trust in their services anymore. Hope they are working on improving system stability first.<p>(1) <a href="https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;query=fly.io%20down&amp;sort=byPopularity&amp;type=story" rel="nofollow noreferrer">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=true&amp;que...</a></div><br/></div></div><div id="37504141" class="c"><input type="checkbox" id="c-37504141" checked=""/><div class="controls bullet"><span class="by">tiew9Vii</span><span>|</span><a href="#37504484">prev</a><span>|</span><a href="#37505911">next</a><span>|</span><label class="collapse" for="c-37504141">[-]</label><label class="expand" for="c-37504141">[2 more]</label></div><br/><div class="children"><div class="content">This looks interesting for read heavy distributed apps. I.E fly.io&#x2F;aws lambdas&#x2F;k8s.<p>Each instance gets its own eventually consistent read only copy of the db. So instead of making a network request to go get some data, you query your local cache.<p>Your use case is that you are read heavy for this to fit your needs.<p>If you have a copy of the data local to you, you don’t need to go bug another team to expose it via an API.<p>Reading fly’s blogposts it’d be good to see more on write durability. They’re batched on the client, batched on fly’s side before being compacted to s3 from reading so you can loose writes before your client as sent them to fly, possibly loose them before fly has written to s3 depending on how they implemented.<p>FlyCloud might make a great service for small typical Wordpress type sites or low user services where writes are low. It’s a shame they don’t offer pay as you go for the LiteFS product only. I get why they don’t as they want you to host with them but it’d be great if you could pay as you go on the db only.<p>I currently use DynamoDB for low volume stuff for cost reasons, it costs me cents. Productivity is extremely low though with Dynamo as you need to think very hard about table design and constraints and work around those constraints. It’s a lot more effort than using something like SQLLite for quick simple stuff.</div><br/><div id="37505546" class="c"><input type="checkbox" id="c-37505546" checked=""/><div class="controls bullet"><span class="by">benwaffle</span><span>|</span><a href="#37504141">parent</a><span>|</span><a href="#37505911">next</a><span>|</span><label class="collapse" for="c-37505546">[-]</label><label class="expand" for="c-37505546">[1 more]</label></div><br/><div class="children"><div class="content">You can use LiteFS Cloud without hosting your app on fly.io - <a href="https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;getting-started-docker&#x2F;#litefs-cloud-configuration-optional">https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;getting-started-docker&#x2F;#litefs-cl...</a></div><br/></div></div></div></div><div id="37505911" class="c"><input type="checkbox" id="c-37505911" checked=""/><div class="controls bullet"><span class="by">RamblingCTO</span><span>|</span><a href="#37504141">prev</a><span>|</span><a href="#37504934">next</a><span>|</span><label class="collapse" for="c-37505911">[-]</label><label class="expand" for="c-37505911">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Moving compute to the client<p>I thought we were slowly learning that this was a stupid idea in the first place and moving back to the old ways (tm)?</div><br/></div></div><div id="37504934" class="c"><input type="checkbox" id="c-37504934" checked=""/><div class="controls bullet"><span class="by">collaborative</span><span>|</span><a href="#37505911">prev</a><span>|</span><a href="#37505273">next</a><span>|</span><label class="collapse" for="c-37504934">[-]</label><label class="expand" for="c-37504934">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Moving compute to the client<p>This is a great point and the reason why I think server-side rendering will ultimately fail.<p>I&#x27;ve done something similar for a site I manage (6groups.com). Each client&#x27;s DB log is stored in compressed files on the server and only initialized via sqlite wasm on the client when needed. The trick is to periodically run compaction jobs (also on the client) to make sure DB logs don&#x27;t grow to unreasonable sizes<p>I can&#x27;t imagine the DB consumption I&#x27;d have if all client data was in relational format on the server</div><br/></div></div><div id="37505273" class="c"><input type="checkbox" id="c-37505273" checked=""/><div class="controls bullet"><span class="by">pm90</span><span>|</span><a href="#37504934">prev</a><span>|</span><a href="#37504482">next</a><span>|</span><label class="collapse" for="c-37505273">[-]</label><label class="expand" for="c-37505273">[1 more]</label></div><br/><div class="children"><div class="content">It seems like sqlite is now acting as the API gateway. I think its an interesting idea, especially if you want to share relational data out to consumers, since they now have all the flexibility of sql. The issue though is updating the queries when schema changes are made.</div><br/></div></div><div id="37504482" class="c"><input type="checkbox" id="c-37504482" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#37505273">prev</a><span>|</span><a href="#37505145">next</a><span>|</span><label class="collapse" for="c-37504482">[-]</label><label class="expand" for="c-37504482">[1 more]</label></div><br/><div class="children"><div class="content">Musing about APIs and the constant complaints about &quot;abuse&quot; and &quot;bots&quot;, I think it would be an interesting experiment to set up an API where when a user hits the daily limit, instead of just being &quot;blocked&quot; (which according to complaints does not really work due to use of proxies), the user is sent a link to the database for download.  The daily, updated database could be hosted on something like Backblaze.  Would this satiate the demand for the data in a more efficient way than an &quot;API&quot;.</div><br/></div></div><div id="37505145" class="c"><input type="checkbox" id="c-37505145" checked=""/><div class="controls bullet"><span class="by">emodendroket</span><span>|</span><a href="#37504482">prev</a><span>|</span><a href="#37502933">next</a><span>|</span><label class="collapse" for="c-37505145">[-]</label><label class="expand" for="c-37505145">[2 more]</label></div><br/><div class="children"><div class="content">Surely you will not ever regret exposing all the internal representations of your data to your clients.</div><br/><div id="37505844" class="c"><input type="checkbox" id="c-37505844" checked=""/><div class="controls bullet"><span class="by">tiew9Vii</span><span>|</span><a href="#37505145">parent</a><span>|</span><a href="#37502933">next</a><span>|</span><label class="collapse" for="c-37505844">[-]</label><label class="expand" for="c-37505844">[1 more]</label></div><br/><div class="children"><div class="content">It depends who your clients are. If clients are public&#x2F;external users, probably not.<p>If clients are internal services you own and you control as part of a internal distributed service, it’s a nice pattern</div><br/></div></div></div></div><div id="37502933" class="c"><input type="checkbox" id="c-37502933" checked=""/><div class="controls bullet"><span class="by">chimen</span><span>|</span><a href="#37505145">prev</a><span>|</span><a href="#37502993">next</a><span>|</span><label class="collapse" for="c-37502933">[-]</label><label class="expand" for="c-37502933">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Skip the api&quot; - seems to be stolen from sequin at: <a href="https:&#x2F;&#x2F;docs.sequin.io&#x2F;integrations&#x2F;airtable&#x2F;playbooks&#x2F;metabase" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.sequin.io&#x2F;integrations&#x2F;airtable&#x2F;playbooks&#x2F;metab...</a> (a few scrolls down)</div><br/><div id="37503591" class="c"><input type="checkbox" id="c-37503591" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37502933">parent</a><span>|</span><a href="#37502993">next</a><span>|</span><label class="collapse" for="c-37503591">[-]</label><label class="expand" for="c-37503591">[1 more]</label></div><br/><div class="children"><div class="content">Author here. I hadn&#x27;t heard of Sequin until today. &quot;Skip the API&quot; was just a snappy title so I went with it.</div><br/></div></div></div></div><div id="37502993" class="c"><input type="checkbox" id="c-37502993" checked=""/><div class="controls bullet"><span class="by">Zaheer</span><span>|</span><a href="#37502933">prev</a><span>|</span><a href="#37504549">next</a><span>|</span><label class="collapse" for="c-37502993">[-]</label><label class="expand" for="c-37502993">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious the types of users this has. This feels like something that small to mid size companies may leverage but anything slightly more sophisticated would typically require access controls, merging data with other sources, etc. Doesn&#x27;t feel like a very scalable appraoch.</div><br/><div id="37503626" class="c"><input type="checkbox" id="c-37503626" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#37502993">parent</a><span>|</span><a href="#37504549">next</a><span>|</span><label class="collapse" for="c-37503626">[-]</label><label class="expand" for="c-37503626">[1 more]</label></div><br/><div class="children"><div class="content">Author here. We do this with some internal applications that share internal state -- no customer data. I would expect stricter restrictions depending on the type of data shared and how bureaucratic the company is.</div><br/></div></div></div></div><div id="37504549" class="c"><input type="checkbox" id="c-37504549" checked=""/><div class="controls bullet"><span class="by">zubairq</span><span>|</span><a href="#37502993">prev</a><span>|</span><a href="#37503247">next</a><span>|</span><label class="collapse" for="c-37504549">[-]</label><label class="expand" for="c-37504549">[1 more]</label></div><br/><div class="children"><div class="content">A very interesting idea. At Yazz we don&#x27;t do replication, but if someone creates a report in the tool and exports it as HTML then we actually export the entire app DB into Sqlite embedded in the HTML page, but any changes made to that embedded Sqlite DB don&#x27;t get replicated to the original database, so kind of like a read only copy, only suitable for reports</div><br/></div></div><div id="37503925" class="c"><input type="checkbox" id="c-37503925" checked=""/><div class="controls bullet"><span class="by">throwawaaarrgh</span><span>|</span><a href="#37503247">prev</a><span>|</span><a href="#37504849">next</a><span>|</span><label class="collapse" for="c-37503925">[-]</label><label class="expand" for="c-37503925">[1 more]</label></div><br/><div class="children"><div class="content">A database isn&#x27;t designed to be used this way. You&#x27;ll eventually need it to do something &quot;extra&quot;, and your company will probably find some workaround or hack, but eventually make an API.<p>APIs are an intermediate layer of abstraction needed because their purpose is separate from that of a DDL&#x2F;DML&#x2F;DCL&#x2F;TCL. Having raw database access does not solve the use cases the database doesn&#x27;t account for.</div><br/></div></div><div id="37504849" class="c"><input type="checkbox" id="c-37504849" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#37503925">prev</a><span>|</span><label class="collapse" for="c-37504849">[-]</label><label class="expand" for="c-37504849">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The typical approach to making data available between services is to spend <i>weeks</i> designing an API<p>What?<p>No.</div><br/></div></div></div></div></div></div></div></body></html>