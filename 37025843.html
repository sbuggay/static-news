<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1691398881124" as="style"/><link rel="stylesheet" href="styles.css?v=1691398881124"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://grugq.github.io/docs/ul_exec.txt">The Design and Implementation of Userland Exec (2014)</a> <span class="domain">(<a href="https://grugq.github.io">grugq.github.io</a>)</span></div><div class="subtext"><span>jstrieb</span> | <span>9 comments</span></div><br/><div><div id="37031883" class="c"><input type="checkbox" id="c-37031883" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#37030928">next</a><span>|</span><label class="collapse" for="c-37031883">[-]</label><label class="expand" for="c-37031883">[1 more]</label></div><br/><div class="children"><div class="content">The original date for this is actually 2004. Maybe 2003, but I can’t find an archival link.<p>I wrote the code because someone asked how to do this and it was easier to implement it than to explain it in detail. The whole thing is based on what I learned from “Linkers &amp; Loaders,” a great book. (I still have my copy)<p>Later that year I wrote a wrapper around ul_exec() that used an automated interactive session with gdb to load a process, replace it with another binary (delivered over STDIN) and then execute that. This would prevent the binary ever being written to disk.<p>Remote exec was documented in phrack 62, along with the more advanced theory of counter forensics. Interestingly, the techniques I discussed in rexec() are now common APT tradecraft. Using common tools to limit the chance of detection and reduce evidence, aka living off the land, is now standard practice. I explained why about 20 years ago :)<p><a href="http:&#x2F;&#x2F;phrack.org&#x2F;issues&#x2F;62&#x2F;8.html" rel="nofollow noreferrer">http:&#x2F;&#x2F;phrack.org&#x2F;issues&#x2F;62&#x2F;8.html</a><p>It seems easier to load the whole issue from here: 
<a href="https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;42873" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;42873</a></div><br/></div></div><div id="37030928" class="c"><input type="checkbox" id="c-37030928" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37031883">prev</a><span>|</span><a href="#37031940">next</a><span>|</span><label class="collapse" for="c-37030928">[-]</label><label class="expand" for="c-37030928">[1 more]</label></div><br/><div class="children"><div class="content">QNX always did it that way. One of their basic design decisions was to never process strings or complex data formats in the kernel. That&#x27;s all in user space, which is good for crash prevention. It&#x27;s hard to have kernel buffer overflows when you don&#x27;t have kernel buffers.<p>The boot loader loaded an image into memory which contained the kernel, a utility process called &quot;proc&quot;, and whatever else needed to be available at startup. For an embedded application, that might be the entire program. For a standard desktop environment, it would include a disk driver, a network driver, and a startup program.<p>Shared object files could also be loaded as part of the initial image. One of them was the program loader. The C library for QNX had calls for the various &#x27;exec&#x27; functions, but they were just passed to the program loader shared object. With no special privileges, it allocated the memory for the new program, read in the program image, set up the Unix-type args, and transferred control to the newly loaded program.</div><br/></div></div><div id="37031940" class="c"><input type="checkbox" id="c-37031940" checked=""/><div class="controls bullet"><span class="by">tedunangst</span><span>|</span><a href="#37030928">prev</a><span>|</span><a href="#37030871">next</a><span>|</span><label class="collapse" for="c-37031940">[-]</label><label class="expand" for="c-37031940">[1 more]</label></div><br/><div class="children"><div class="content">The term process hollowing wasn&#x27;t used until around 2010? Or earlier?</div><br/></div></div><div id="37030871" class="c"><input type="checkbox" id="c-37030871" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37031940">prev</a><span>|</span><a href="#37028514">next</a><span>|</span><label class="collapse" for="c-37030871">[-]</label><label class="expand" for="c-37030871">[3 more]</label></div><br/><div class="children"><div class="content">a much simpler way to execute an executable on linux without writing it to disk is to use fexecve, though i&#x27;m not sure if that existed in 02014</div><br/><div id="37031794" class="c"><input type="checkbox" id="c-37031794" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#37030871">parent</a><span>|</span><a href="#37031831">next</a><span>|</span><label class="collapse" for="c-37031794">[-]</label><label class="expand" for="c-37031794">[1 more]</label></div><br/><div class="children"><div class="content">It is actually from 2004. :)</div><br/></div></div></div></div><div id="37028514" class="c"><input type="checkbox" id="c-37028514" checked=""/><div class="controls bullet"><span class="by">bediger4000</span><span>|</span><a href="#37030871">prev</a><span>|</span><label class="collapse" for="c-37028514">[-]</label><label class="expand" for="c-37028514">[2 more]</label></div><br/><div class="children"><div class="content">I seem to recall a much earlier version of this idea, maybe ca 2008, and it came with source code, still by The Grugq.<p>Interesting idea, it shows that Linux execute(2) system call doesn&#x27;t do any magic, except look at setuid bits.<p>Also, isn&#x27;t this pretty much what Windows people call &quot;process hollowing&quot; or some such?</div><br/><div id="37031790" class="c"><input type="checkbox" id="c-37031790" checked=""/><div class="controls bullet"><span class="by">grugq</span><span>|</span><a href="#37028514">parent</a><span>|</span><label class="collapse" for="c-37031790">[-]</label><label class="expand" for="c-37031790">[1 more]</label></div><br/><div class="children"><div class="content">I invented it, as far as I know. There was no publicly available code on doing this and so I wrote it.<p>I’m not sure what the terminology is these days, but I called it userland exec() because it was an implementation of execve in userland…<p>I wrote it in, 2003 or 2004? I can’t find an original link anymore, but I posted it to bugtraq the week after I finished it.</div><br/></div></div></div></div></div></div></div></div></div></body></html>