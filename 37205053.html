<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692608464110" as="style"/><link rel="stylesheet" href="styles.css?v=1692608464110"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://twitter.com/cperciva/status/1693127769901969772">FreeBSD replaces bubblesort with mergesort on SYSINTs</a> <span class="domain">(<a href="https://twitter.com">twitter.com</a>)</span></div><div class="subtext"><span>gslin</span> | <span>119 comments</span></div><br/><div><div id="37206963" class="c"><input type="checkbox" id="c-37206963" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#37205517">next</a><span>|</span><label class="collapse" for="c-37206963">[-]</label><label class="expand" for="c-37206963">[1 more]</label></div><br/><div class="children"><div class="content">Well, it&#x27;s a bit of a embarrassing moment.<p>Bubblesort has been controversial in many cs programs. That memo even reached the President ten years ago.<p>[0]<a href="https:&#x2F;&#x2F;youtu.be&#x2F;koMpGeZpu4Q" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;koMpGeZpu4Q</a></div><br/></div></div><div id="37205517" class="c"><input type="checkbox" id="c-37205517" checked=""/><div class="controls bullet"><span class="by">timmaxw</span><span>|</span><a href="#37206963">prev</a><span>|</span><a href="#37205748">next</a><span>|</span><label class="collapse" for="c-37205517">[-]</label><label class="expand" for="c-37205517">[36 more]</label></div><br/><div class="children"><div class="content">For people (like me) who are wondering why a kernel needs to boot in under 28ms: It&#x27;s for virtual machines that get launched on-demand in services like AWS Lambda. <a href="https:&#x2F;&#x2F;www.daemonology.net&#x2F;blog&#x2F;2022-10-18-FreeBSD-Firecracker.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.daemonology.net&#x2F;blog&#x2F;2022-10-18-FreeBSD-Firecrac...</a></div><br/><div id="37206618" class="c"><input type="checkbox" id="c-37206618" checked=""/><div class="controls bullet"><span class="by">contrarian1234</span><span>|</span><a href="#37205517">parent</a><span>|</span><a href="#37205757">next</a><span>|</span><label class="collapse" for="c-37206618">[-]</label><label class="expand" for="c-37206618">[3 more]</label></div><br/><div class="children"><div class="content">Very naiive question... But why can&#x27;t you &quot;just&quot; memcopy and exec an image of an already booted system?</div><br/><div id="37206653" class="c"><input type="checkbox" id="c-37206653" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206618">parent</a><span>|</span><a href="#37205757">next</a><span>|</span><label class="collapse" for="c-37206653">[-]</label><label class="expand" for="c-37206653">[2 more]</label></div><br/><div class="children"><div class="content">Simplistic answer is because hardware and firmware environment gets configured during boot, even for virtual machines.<p>Some virtual machine environments do have facilities to snapshot the entire state of a machine and resume it (potentially on another machine), but if you look at what is involved with snapshot metadata it&#x27;s more than just the state of memory, you have CPU and device state as well.</div><br/><div id="37206873" class="c"><input type="checkbox" id="c-37206873" checked=""/><div class="controls bullet"><span class="by">PMunch</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206653">parent</a><span>|</span><a href="#37205757">next</a><span>|</span><label class="collapse" for="c-37206873">[-]</label><label class="expand" for="c-37206873">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t hibernating the machine and then copying the hibernation data to another machine do the trick? Sure it wouldn&#x27;t be as instant, but it would skip most of the boot configuration.</div><br/></div></div></div></div></div></div><div id="37205757" class="c"><input type="checkbox" id="c-37205757" checked=""/><div class="controls bullet"><span class="by">atmosx</span><span>|</span><a href="#37205517">parent</a><span>|</span><a href="#37206618">prev</a><span>|</span><a href="#37206371">next</a><span>|</span><label class="collapse" for="c-37205757">[-]</label><label class="expand" for="c-37205757">[29 more]</label></div><br/><div class="children"><div class="content">There was an article about a Linux embedded system handling a car back-camera that had to boot within 3-5 seconds or something along those lines.</div><br/><div id="37205806" class="c"><input type="checkbox" id="c-37205806" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205757">parent</a><span>|</span><a href="#37206945">next</a><span>|</span><label class="collapse" for="c-37205806">[-]</label><label class="expand" for="c-37205806">[6 more]</label></div><br/><div class="children"><div class="content">Very OT, but I concur. I need a DSP for my car audio system. I considered a rpi3 with a DAC attachment.<p>I tried the raspbian OS with some moderate overclocking and removing unneeded startup processes. Couldn’t get it under 25 seconds for boot. Kind of a deal breaker (remote start unit could help, but…)<p>Apparently somebody can start the rpi3 in &lt;3 seconds. I’ll believe it when I try their image myself. Their setup disables USB and networking (maybe audio too who knows) which is a giant pain for configuring my system.<p>Maybe I’ll try again with an RPi 4 and usb3 nvme. or maybe I’ll just pay hundreds of dollars for a dedicated DSP unit.<p>In case anyone cares, my main use case is parametric EQ for phon adjusted low bass frequencies. 90dB 20Hz sounds as loud as 70dB 50Hz (give or take) and subwoofers are generally quieter at lower frequencies. Hence, audio processing unit to cut as you go higher than your lowest decently loud frequency.<p>The lowest cost option for this is about $230USD plus some electrical components (miniDSP 2x4HD). I figure the rpi would cost around $100 including the DAC unit, open source audio software, just need some power source to link the battery to the rpi power cord.<p>Edit: I don’t want to spam thanks comments for helpful replies, so I’ll just say it here (possibly in advance): thanks!!!</div><br/><div id="37206028" class="c"><input type="checkbox" id="c-37206028" checked=""/><div class="controls bullet"><span class="by">JeffeFawkes</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205806">parent</a><span>|</span><a href="#37205862">next</a><span>|</span><label class="collapse" for="c-37206028">[-]</label><label class="expand" for="c-37206028">[1 more]</label></div><br/><div class="children"><div class="content">If you make your own buildroot image, you can get VERY quick boot times - here&#x27;s a random vid I found [1] with 3.5 seconds on a pi zero w (which is considerably less powerful than a Pi3.<p>I&#x27;ve worked with similarly underpowered boards (licheepi zero, only has 64mb ram and uses the cpu from a dashcam!) and those will still boot and start an SDL app in under five seconds.<p>If you can identify the bare minimum that you need for your EQ solution, you can probably get similar boot times.<p>[1]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZehLyumyMvE">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=ZehLyumyMvE</a></div><br/></div></div><div id="37205862" class="c"><input type="checkbox" id="c-37205862" checked=""/><div class="controls bullet"><span class="by">ju-st</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205806">parent</a><span>|</span><a href="#37206028">prev</a><span>|</span><a href="#37206647">next</a><span>|</span><label class="collapse" for="c-37205862">[-]</label><label class="expand" for="c-37205862">[1 more]</label></div><br/><div class="children"><div class="content">You could use a ADAU1701 DSP board (cheaper and shittier minidsp) or do it directly on a modern&#x2F;fast microcontroller, e.g. ESP32. I used an ESP32 to adjust frequency response of a small diy loudspeaker (and added Bluetooth).</div><br/></div></div><div id="37206115" class="c"><input type="checkbox" id="c-37206115" checked=""/><div class="controls bullet"><span class="by">red0point</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205806">parent</a><span>|</span><a href="#37206647">prev</a><span>|</span><a href="#37206744">next</a><span>|</span><label class="collapse" for="c-37206115">[-]</label><label class="expand" for="c-37206115">[1 more]</label></div><br/><div class="children"><div class="content">It doesn‘t always have to be a RPi, sometimes there is dedicated hardware for that use case that is also kinda cheap.<p>Check this thing out, it‘s a programmable audio DSP:<p><a href="https:&#x2F;&#x2F;www.thomannmusic.ch&#x2F;the_t.racks_dsp_4x4_mini.htm" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.thomannmusic.ch&#x2F;the_t.racks_dsp_4x4_mini.htm</a></div><br/></div></div><div id="37206744" class="c"><input type="checkbox" id="c-37206744" checked=""/><div class="controls bullet"><span class="by">SomeoneFromCA</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205806">parent</a><span>|</span><a href="#37206115">prev</a><span>|</span><a href="#37206945">next</a><span>|</span><label class="collapse" for="c-37206744">[-]</label><label class="expand" for="c-37206744">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t you just run on bare metal on rpi? Also a resistor, a capacitor and a realay would work  to filter out the extra bass.</div><br/></div></div></div></div><div id="37206945" class="c"><input type="checkbox" id="c-37206945" checked=""/><div class="controls bullet"><span class="by">hwd</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205757">parent</a><span>|</span><a href="#37205806">prev</a><span>|</span><a href="#37205807">next</a><span>|</span><label class="collapse" for="c-37206945">[-]</label><label class="expand" for="c-37206945">[1 more]</label></div><br/><div class="children"><div class="content">There is an interesting talk from BMW how they did it for their cars: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;_cSTBiwY7HE" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;_cSTBiwY7HE</a>.</div><br/></div></div><div id="37205807" class="c"><input type="checkbox" id="c-37205807" checked=""/><div class="controls bullet"><span class="by">jakear</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205757">parent</a><span>|</span><a href="#37206945">prev</a><span>|</span><a href="#37205957">next</a><span>|</span><label class="collapse" for="c-37205807">[-]</label><label class="expand" for="c-37205807">[18 more]</label></div><br/><div class="children"><div class="content">Wild that people have accepted a 5000ms delay between starting their car and seeing behind them.<p>I suppose I&#x27;m more sensitive to downtime than most - I recently (unsuccessfully) tried to add a ton of capacitance into my head unit&#x27;s power supply and acc-signal lines to keep it from turning off for a few seconds when starting the engine.</div><br/><div id="37205901" class="c"><input type="checkbox" id="c-37205901" checked=""/><div class="controls bullet"><span class="by">cwalv</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205807">parent</a><span>|</span><a href="#37205952">next</a><span>|</span><label class="collapse" for="c-37205901">[-]</label><label class="expand" for="c-37205901">[14 more]</label></div><br/><div class="children"><div class="content">Up until a couple years ago my car didn&#x27;t even have a camera. We just looked out the window, which is still an option.</div><br/><div id="37206958" class="c"><input type="checkbox" id="c-37206958" checked=""/><div class="controls bullet"><span class="by">bbojan</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205901">parent</a><span>|</span><a href="#37205929">next</a><span>|</span><label class="collapse" for="c-37206958">[-]</label><label class="expand" for="c-37206958">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t see small kids right behind your car this way. I believe this was the main reason why rear-view cameras were made mandatory on new cars.</div><br/></div></div><div id="37205929" class="c"><input type="checkbox" id="c-37205929" checked=""/><div class="controls bullet"><span class="by">plorkyeran</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205901">parent</a><span>|</span><a href="#37206958">prev</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37205929">[-]</label><label class="expand" for="c-37205929">[7 more]</label></div><br/><div class="children"><div class="content">It is a much worse option than it used to be. Visibility out of the rear windows from the driver&#x27;s seat has gotten worse over the years.</div><br/><div id="37206122" class="c"><input type="checkbox" id="c-37206122" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205929">parent</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37206122">[-]</label><label class="expand" for="c-37206122">[6 more]</label></div><br/><div class="children"><div class="content">So industrial design with poor usability gets complemented by bad electronic devices. Progress?</div><br/><div id="37206359" class="c"><input type="checkbox" id="c-37206359" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206122">parent</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37206359">[-]</label><label class="expand" for="c-37206359">[5 more]</label></div><br/><div class="children"><div class="content">what are they getting for the poor visibility tradeoff compensated by electronics? I have no idea. If it&#x27;s safety, then yes, that would be progress.</div><br/><div id="37206544" class="c"><input type="checkbox" id="c-37206544" checked=""/><div class="controls bullet"><span class="by">SideburnsOfDoom</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206359">parent</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37206544">[-]</label><label class="expand" for="c-37206544">[4 more]</label></div><br/><div class="children"><div class="content">Safety, and aerodynamics (i.e. energy efficiency).<p>Dismissing it as &quot;design with poor usability&quot; is very facile. It&#x27;s trade-offs between different goals,  all the way down.</div><br/><div id="37206646" class="c"><input type="checkbox" id="c-37206646" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206544">parent</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37206646">[-]</label><label class="expand" for="c-37206646">[3 more]</label></div><br/><div class="children"><div class="content">Or it’s just cheaper to build</div><br/><div id="37206672" class="c"><input type="checkbox" id="c-37206672" checked=""/><div class="controls bullet"><span class="by">SideburnsOfDoom</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206646">parent</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37206672">[-]</label><label class="expand" for="c-37206672">[2 more]</label></div><br/><div class="children"><div class="content">Cost is yet another trade-off.<p>Those pillars that hold the roof up are safer if they&#x27;re sturdy, but sturdy means wider and that obstructs the driver&#x27;s field of vision a bit, and weighs more.  &quot;strong and slender&quot; is possible, but it costs more. It all inter-relates.<p>(strong, narrow, cheap), pick any 2.<p>There does come a point where you start to appreciate what Polestar is doing on one of next years models (the Polestar 4): give up on the idea and change direction; no rear window at all, just a camera.</div><br/><div id="37206978" class="c"><input type="checkbox" id="c-37206978" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206672">parent</a><span>|</span><a href="#37206062">next</a><span>|</span><label class="collapse" for="c-37206978">[-]</label><label class="expand" for="c-37206978">[1 more]</label></div><br/><div class="children"><div class="content">The failure mode is pretty horrible though.<p>And I&#x27;m not only thinking about damaged camera. Humidity, weather etc. often makes these cameras completely useless.<p>You&#x27;d have to have wipers for your camera-lens and probably heating or something as well to even approach the utility of a window - short term.<p>Because none of that is ever going to fail, and it isn&#x27;t cheap either.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="37206062" class="c"><input type="checkbox" id="c-37206062" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205901">parent</a><span>|</span><a href="#37205929">prev</a><span>|</span><a href="#37206026">next</a><span>|</span><label class="collapse" for="c-37206062">[-]</label><label class="expand" for="c-37206062">[3 more]</label></div><br/><div class="children"><div class="content">A large majority of cars in traffic don’t have a back camera. Either because they’re old or because they’re cheap (I don’t think a back camera is usually a standard feature at least where I’m from…)</div><br/><div id="37206529" class="c"><input type="checkbox" id="c-37206529" checked=""/><div class="controls bullet"><span class="by">kalleboo</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206062">parent</a><span>|</span><a href="#37206026">next</a><span>|</span><label class="collapse" for="c-37206529">[-]</label><label class="expand" for="c-37206529">[2 more]</label></div><br/><div class="children"><div class="content">In the US a backup camera is now required by law</div><br/><div id="37206695" class="c"><input type="checkbox" id="c-37206695" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206529">parent</a><span>|</span><a href="#37206026">next</a><span>|</span><label class="collapse" for="c-37206695">[-]</label><label class="expand" for="c-37206695">[1 more]</label></div><br/><div class="children"><div class="content">For new cars, I guess.<p>In the EU, it’s similar. <a href="https:&#x2F;&#x2F;ec.europa.eu&#x2F;info&#x2F;law&#x2F;better-regulation&#x2F;have-your-say&#x2F;initiatives&#x2F;12224-Vehicle-safety-technical-rules-test-procedures-for-advanced-safety-features_en" rel="nofollow noreferrer">https:&#x2F;&#x2F;ec.europa.eu&#x2F;info&#x2F;law&#x2F;better-regulation&#x2F;have-your-sa...</a>:<p><i>All new vehicles sold from May 2022 must be fitted with advanced safety features, including:<p>- monitors that detect when a driver has become drowsy or distracted<p>- emergency stop signal to help prevent rear-end collisions<p>- rear-view camera or parking sensors<p>- alcohol interlock system to prevent drunk driving.<p>These systems will help reduce serious accidents on Europe’s roads.</i></div><br/></div></div></div></div></div></div><div id="37206026" class="c"><input type="checkbox" id="c-37206026" checked=""/><div class="controls bullet"><span class="by">Kiro</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205901">parent</a><span>|</span><a href="#37206062">prev</a><span>|</span><a href="#37205952">next</a><span>|</span><label class="collapse" for="c-37206026">[-]</label><label class="expand" for="c-37206026">[2 more]</label></div><br/><div class="children"><div class="content">I rather have no car at all than go back to that.</div><br/><div id="37206131" class="c"><input type="checkbox" id="c-37206131" checked=""/><div class="controls bullet"><span class="by">usr1106</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206026">parent</a><span>|</span><a href="#37205952">next</a><span>|</span><label class="collapse" for="c-37206131">[-]</label><label class="expand" for="c-37206131">[1 more]</label></div><br/><div class="children"><div class="content">That would be better for the planet anyway.<p>Disclaimer: Not a joke. I&#x27;ve never owned a car.</div><br/></div></div></div></div></div></div><div id="37205952" class="c"><input type="checkbox" id="c-37205952" checked=""/><div class="controls bullet"><span class="by">hnlmorg</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205807">parent</a><span>|</span><a href="#37205901">prev</a><span>|</span><a href="#37206616">next</a><span>|</span><label class="collapse" for="c-37205952">[-]</label><label class="expand" for="c-37205952">[1 more]</label></div><br/><div class="children"><div class="content">It’s probably less than 5 seconds in perceived terms. Eg the car gets power before the engine turns over, and you then need to select reverse after the engine is running. And you’d need to check your blind spots before checking the camera too. So by the time the driver is ready to check the camera, it might feel like a much smaller delay or even no delay at all.<p>The delay that I notice the most is the time it takes to connect to my phone via Bluetooth (usually so I can play music from it). I’m often already pulling out of my parking space before it connects.</div><br/></div></div><div id="37206616" class="c"><input type="checkbox" id="c-37206616" checked=""/><div class="controls bullet"><span class="by">lukevp</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205807">parent</a><span>|</span><a href="#37205952">prev</a><span>|</span><a href="#37205823">next</a><span>|</span><label class="collapse" for="c-37206616">[-]</label><label class="expand" for="c-37206616">[1 more]</label></div><br/><div class="children"><div class="content">What was unsuccessful? I did this in a 2012 Miata with a pioneer head unit (capacitor on the Acc line so it discharges while cranking, which keeps the head unit from turning off). Has a fused line directly to the battery for power. It’s not a huge capacitor either… like a 1500 uF or so? Just tried a couple diff cap values until it had around 5 secs of charge to hold the line open. It also makes it so the music doesn’t cut off immediately when the car is turned off as well… it gives it a few seconds to shut down. Feels more premium.</div><br/></div></div><div id="37205823" class="c"><input type="checkbox" id="c-37205823" checked=""/><div class="controls bullet"><span class="by">chii</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205807">parent</a><span>|</span><a href="#37206616">prev</a><span>|</span><a href="#37205957">next</a><span>|</span><label class="collapse" for="c-37205823">[-]</label><label class="expand" for="c-37205823">[1 more]</label></div><br/><div class="children"><div class="content">probably because it started off as a 1000ms delay, which they begrudgingly accepted. Then it started to slow to 1100ms....</div><br/></div></div></div></div><div id="37205957" class="c"><input type="checkbox" id="c-37205957" checked=""/><div class="controls bullet"><span class="by">CalChris</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205757">parent</a><span>|</span><a href="#37205807">prev</a><span>|</span><a href="#37206443">next</a><span>|</span><label class="collapse" for="c-37205957">[-]</label><label class="expand" for="c-37205957">[1 more]</label></div><br/><div class="children"><div class="content">My 2015 Model S would lose badly in a quarter mile against a good cyclist if you included cold boot time. Worst bank robbery car ever.</div><br/></div></div><div id="37206443" class="c"><input type="checkbox" id="c-37206443" checked=""/><div class="controls bullet"><span class="by">rfmoz</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205757">parent</a><span>|</span><a href="#37205957">prev</a><span>|</span><a href="#37205800">next</a><span>|</span><label class="collapse" for="c-37206443">[-]</label><label class="expand" for="c-37206443">[1 more]</label></div><br/><div class="children"><div class="content">With a custom kernel and without initrd&#x2F;initramfs is possible to boot around 1 second.</div><br/></div></div><div id="37205800" class="c"><input type="checkbox" id="c-37205800" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37205757">parent</a><span>|</span><a href="#37206443">prev</a><span>|</span><a href="#37206371">next</a><span>|</span><label class="collapse" for="c-37205800">[-]</label><label class="expand" for="c-37205800">[1 more]</label></div><br/><div class="children"><div class="content">Yes I remember being surprised that Linux containers were used for that purpose.</div><br/></div></div></div></div><div id="37206371" class="c"><input type="checkbox" id="c-37206371" checked=""/><div class="controls bullet"><span class="by">abwizz</span><span>|</span><a href="#37205517">parent</a><span>|</span><a href="#37205757">prev</a><span>|</span><a href="#37205748">next</a><span>|</span><label class="collapse" for="c-37206371">[-]</label><label class="expand" for="c-37206371">[3 more]</label></div><br/><div class="children"><div class="content">meanwhile our new dishwasher takes between two and four SECONDS from pressing the power button to showing something on the display</div><br/><div id="37206780" class="c"><input type="checkbox" id="c-37206780" checked=""/><div class="controls bullet"><span class="by">moring</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206371">parent</a><span>|</span><a href="#37205748">next</a><span>|</span><label class="collapse" for="c-37206780">[-]</label><label class="expand" for="c-37206780">[2 more]</label></div><br/><div class="children"><div class="content">But you still bought this one and not one of the alternatives that start faster... which is part of the reason things get built this way.</div><br/><div id="37206842" class="c"><input type="checkbox" id="c-37206842" checked=""/><div class="controls bullet"><span class="by">Narretz</span><span>|</span><a href="#37205517">root</a><span>|</span><a href="#37206780">parent</a><span>|</span><a href="#37205748">next</a><span>|</span><label class="collapse" for="c-37206842">[-]</label><label class="expand" for="c-37206842">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately stuff like boot time &#x2F; time to interactive isn&#x27;t in the specifications. You have to check user reviews, and not everybody cares about this.</div><br/></div></div></div></div></div></div></div></div><div id="37205748" class="c"><input type="checkbox" id="c-37205748" checked=""/><div class="controls bullet"><span class="by">xyzelement</span><span>|</span><a href="#37205517">prev</a><span>|</span><a href="#37205440">next</a><span>|</span><label class="collapse" for="c-37205748">[-]</label><label class="expand" for="c-37205748">[13 more]</label></div><br/><div class="children"><div class="content">To sum up what I learned from the comments:<p>Is FreeBSD stupid for having used bubblesort to begin with? NO. It worked well for decades before surfacing as a problem in this extreme and unanticipated use case.<p>Is optimizing this a waste of time? NO. The use case revolves around super frequent bootups to power lambda and for this type of thing every ms matters.</div><br/><div id="37206069" class="c"><input type="checkbox" id="c-37206069" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#37205748">parent</a><span>|</span><a href="#37206668">next</a><span>|</span><label class="collapse" for="c-37206069">[-]</label><label class="expand" for="c-37206069">[4 more]</label></div><br/><div class="children"><div class="content">As is often said, O(n^2) (or even 3) is fine until it stops being fine.</div><br/><div id="37206140" class="c"><input type="checkbox" id="c-37206140" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206069">parent</a><span>|</span><a href="#37206668">next</a><span>|</span><label class="collapse" for="c-37206140">[-]</label><label class="expand" for="c-37206140">[3 more]</label></div><br/><div class="children"><div class="content">Yeah and it almost always stops being fine. The problem with an O(N^2) solution is that you rarely put in an assert that N &lt; 100 or something like that to guard your assumption that big N &quot;doesn&#x27;t happen&quot;. Because after all it&#x27;s better that the process eventually completes than that the process crashes. And if you don&#x27;t dare to put that in, you perhaps shouldn&#x27;t use O(N^2).<p>N^2 or N^3 is fine for things that are fixed size and very unlikely to stop being fixed size, or at least unlikely to grow a lot. But any time you think &quot;oh it&#x27;s just a few files&quot; when there is nothing to stop it from being 1000 files in ten years, or at one rare user: don&#x27;t use an O(N^2) solution.</div><br/><div id="37206699" class="c"><input type="checkbox" id="c-37206699" checked=""/><div class="controls bullet"><span class="by">kortilla</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206140">parent</a><span>|</span><a href="#37206668">next</a><span>|</span><label class="collapse" for="c-37206699">[-]</label><label class="expand" for="c-37206699">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Yeah and it almost always stops being fine.<p>No, it’s just a non-issue in the 99% of cases where it really does stay at small inputs. I come across configuration code all of the time that is stupidly inefficient like this and it’s almost always irrelevant. Tons of stuff works on inputs of &lt;10.</div><br/><div id="37206781" class="c"><input type="checkbox" id="c-37206781" checked=""/><div class="controls bullet"><span class="by">alkonaut</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206699">parent</a><span>|</span><a href="#37206668">next</a><span>|</span><label class="collapse" for="c-37206781">[-]</label><label class="expand" for="c-37206781">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an observation with heavy selection bias: in 100% of the cases where you had to deal with a perf problem it had stopped being fine... Since it also almost invariably is accidentally quadratic and not deliberately quadratic as with BubbleSort, you also have a hard time estimating how many quadratic algorithms you have that haven&#x27;t caused problems, and perhaps never will.<p>Adding complexity because of an anticipation that some input will grow to an unreasonable size (at the time of writing) may or may not be a good idea. But using a different off the shelf function or data structure is usually not a high cost for making sure it&#x27;s not a problem down the line. Of course, that also assumes that there <i>is</i> a good and efficient standard lib of methods and data structures so that &quot;making a more clever choice&quot; isn&#x27;t also a burden or risk in terms of code size, complexity, risk of bugs.</div><br/></div></div></div></div></div></div></div></div><div id="37206668" class="c"><input type="checkbox" id="c-37206668" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37205748">parent</a><span>|</span><a href="#37206069">prev</a><span>|</span><a href="#37205440">next</a><span>|</span><label class="collapse" for="c-37206668">[-]</label><label class="expand" for="c-37206668">[8 more]</label></div><br/><div class="children"><div class="content">yes, it was stupid to use bubble sort to begin with; there is never a good reason to use bubble sort<p><pre><code>    for (size_t i = 0; i &lt; n; i++) {
        for (size_t j = 1; j &lt; n - i; j++) {
            if (a[j-1] &gt; a[j]) {
                item_t tmp = a[j];
                a[j] = a[j-1];
                a[j-1] = tmp;
            }
        }
    }
</code></pre>
when you could use insertion sort<p><pre><code>    for (size_t i = 1; i &lt; n; i++) {
        for (size_t j = i; j &gt; 0; j--) {
            item_t tmp = a[j];
            if (tmp &gt; a[j-1]) break;
            a[j] = a[j-1];
            a[j-1] = tmp;
        }
    }
</code></pre>
which is no more complicated (both are 17 amd64 instructions with -Os), but twice as fast in the random case, and enormously faster in the sorted and almost-sorted cases<p>(above code only minimally tested: <a href="https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;43dqz9Gq8" rel="nofollow noreferrer">https:&#x2F;&#x2F;godbolt.org&#x2F;z&#x2F;43dqz9Gq8</a>)<p>this is not much of a criticism of freebsd; if you polished your codebase until there was nothing stupid in it, you&#x27;d never ship anything.  freebsd&#x27;s code quality is quite high, but probably we can all agree that this was stupid<p>of course it wouldn&#x27;t be nearly as fast as mergesort on large inputs, but mergesort is more complicated<p>(also mergesort is slower on small inputs than insertion sort or bubble sort, but in the case where you&#x27;re only sorting something once at startup time, that probably isn&#x27;t important.  it might matter if you were sorting a million lists of ten items or something)</div><br/><div id="37206950" class="c"><input type="checkbox" id="c-37206950" checked=""/><div class="controls bullet"><span class="by">gpvos</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206668">parent</a><span>|</span><a href="#37206788">next</a><span>|</span><label class="collapse" for="c-37206950">[-]</label><label class="expand" for="c-37206950">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; above code only minimally tested</i><p>There you have your problem: any programmer can write a bubble sort while half asleep and inebriated at the same time, but for an insertion sort you actually have to think a little. There&#x27;s much more chance of errors.</div><br/></div></div><div id="37206788" class="c"><input type="checkbox" id="c-37206788" checked=""/><div class="controls bullet"><span class="by">Closi</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206668">parent</a><span>|</span><a href="#37206950">prev</a><span>|</span><a href="#37206785">next</a><span>|</span><label class="collapse" for="c-37206788">[-]</label><label class="expand" for="c-37206788">[4 more]</label></div><br/><div class="children"><div class="content">I think we have different definitions of stupid - the original implementation was perfectly fine for the time and requirements it was written for.</div><br/><div id="37206823" class="c"><input type="checkbox" id="c-37206823" checked=""/><div class="controls bullet"><span class="by">winternewt</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206788">parent</a><span>|</span><a href="#37206785">next</a><span>|</span><label class="collapse" for="c-37206823">[-]</label><label class="expand" for="c-37206823">[3 more]</label></div><br/><div class="children"><div class="content">But it could have been better for no additional effort. Doing something worse when the better option is just as easy suggests incompetence.</div><br/><div id="37206921" class="c"><input type="checkbox" id="c-37206921" checked=""/><div class="controls bullet"><span class="by">Closi</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206823">parent</a><span>|</span><a href="#37206862">next</a><span>|</span><label class="collapse" for="c-37206921">[-]</label><label class="expand" for="c-37206921">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, but it was working.<p>And maybe it wasn&#x27;t &#x27;no additional effort&#x27; because they were more confident with quickly writing a bubble sort.</div><br/></div></div><div id="37206862" class="c"><input type="checkbox" id="c-37206862" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206823">parent</a><span>|</span><a href="#37206921">prev</a><span>|</span><a href="#37206785">next</a><span>|</span><label class="collapse" for="c-37206862">[-]</label><label class="expand" for="c-37206862">[1 more]</label></div><br/><div class="children"><div class="content">i wouldn&#x27;t go so far as to say <i>incompetence</i><p>even the best of us do stupid things sometimes</div><br/></div></div></div></div></div></div><div id="37206785" class="c"><input type="checkbox" id="c-37206785" checked=""/><div class="controls bullet"><span class="by">SomeoneFromCA</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206668">parent</a><span>|</span><a href="#37206788">prev</a><span>|</span><a href="#37205440">next</a><span>|</span><label class="collapse" for="c-37206785">[-]</label><label class="expand" for="c-37206785">[2 more]</label></div><br/><div class="children"><div class="content">Neither of your code snippets are working, or are an actual implementation of bubble sort.<p>Since what insertion sort is faster that bubble sort on sorted data?</div><br/><div id="37206860" class="c"><input type="checkbox" id="c-37206860" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#37205748">root</a><span>|</span><a href="#37206785">parent</a><span>|</span><a href="#37205440">next</a><span>|</span><label class="collapse" for="c-37206860">[-]</label><label class="expand" for="c-37206860">[1 more]</label></div><br/><div class="children"><div class="content">i tested both of them on some input data and they both sorted it correctly, though of course they could contain bugs (if so i&#x27;d be grateful if you pointed them out)<p>admittedly i probably added the godbolt link showing this after you wrote your comment<p>perhaps you can elaborate; i couldn&#x27;t understand your last sentence or why you think the bubblesort function above doesn&#x27;t bubble-sort</div><br/></div></div></div></div></div></div></div></div><div id="37205440" class="c"><input type="checkbox" id="c-37205440" checked=""/><div class="controls bullet"><span class="by">eitland</span><span>|</span><a href="#37205748">prev</a><span>|</span><a href="#37205511">next</a><span>|</span><label class="collapse" for="c-37205440">[-]</label><label class="expand" for="c-37205440">[1 more]</label></div><br/><div class="children"><div class="content">As two persons have already asked:<p>&gt; When the FreeBSD kernel boots in Firecracker (1 CPU, 128 MB RAM), it now spends 7% of its time running a bubblesort on its SYSINITs.<p>&gt; O(N^2) can bite hard when you&#x27;re sorting over a thousand items.  Time to replace the bubblesort with something faster.</div><br/></div></div><div id="37205511" class="c"><input type="checkbox" id="c-37205511" checked=""/><div class="controls bullet"><span class="by">asicsp</span><span>|</span><a href="#37205440">prev</a><span>|</span><a href="#37205467">next</a><span>|</span><label class="collapse" for="c-37205511">[-]</label><label class="expand" for="c-37205511">[1 more]</label></div><br/><div class="children"><div class="content">Related discussion: &quot;FreeBSD spends 7% of its boot time running a bubblesort on its SYSINITs&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36002574">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=36002574</a> <i>(381 points | 3 months ago | 358 comments)</i></div><br/></div></div><div id="37205467" class="c"><input type="checkbox" id="c-37205467" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37205511">prev</a><span>|</span><a href="#37205526">next</a><span>|</span><label class="collapse" for="c-37205467">[-]</label><label class="expand" for="c-37205467">[5 more]</label></div><br/><div class="children"><div class="content">Small increments add up. Sure, its not 100x faster booting. its 100x less spent in one fragment of overall boot time. Do another 20, and you&#x27;ve made a LOT of difference.</div><br/><div id="37205720" class="c"><input type="checkbox" id="c-37205720" checked=""/><div class="controls bullet"><span class="by">nucleardog</span><span>|</span><a href="#37205467">parent</a><span>|</span><a href="#37205982">next</a><span>|</span><label class="collapse" for="c-37205720">[-]</label><label class="expand" for="c-37205720">[1 more]</label></div><br/><div class="children"><div class="content">Yep. When work started working on boot time, FreeBSD took 30 seconds to boot. It’s now down under 10 seconds. Many have contributed, but Colin’s done a lot of it [0].<p>[0]: <a href="https:&#x2F;&#x2F;wiki.freebsd.org&#x2F;BootTime#Past_Performance_Improvements" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.freebsd.org&#x2F;BootTime#Past_Performance_Improveme...</a></div><br/></div></div><div id="37205982" class="c"><input type="checkbox" id="c-37205982" checked=""/><div class="controls bullet"><span class="by">legulere</span><span>|</span><a href="#37205467">parent</a><span>|</span><a href="#37205720">prev</a><span>|</span><a href="#37205526">next</a><span>|</span><label class="collapse" for="c-37205982">[-]</label><label class="expand" for="c-37205982">[3 more]</label></div><br/><div class="children"><div class="content">This is known as the hotspot or bottleneck model of optimization. It has its flaws:<p><a href="https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;04&#x2F;27&#x2F;hotspot-performance-engineering-fails&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;lemire.me&#x2F;blog&#x2F;2023&#x2F;04&#x2F;27&#x2F;hotspot-performance-engine...</a></div><br/><div id="37206013" class="c"><input type="checkbox" id="c-37206013" checked=""/><div class="controls bullet"><span class="by">ggm</span><span>|</span><a href="#37205467">root</a><span>|</span><a href="#37205982">parent</a><span>|</span><a href="#37206142">next</a><span>|</span><label class="collapse" for="c-37206013">[-]</label><label class="expand" for="c-37206013">[1 more]</label></div><br/><div class="children"><div class="content">Nice article. I didn&#x27;t see it say &quot;don&#x27;t do it&quot; I saw it say &quot;try not to have to&quot;</div><br/></div></div><div id="37206142" class="c"><input type="checkbox" id="c-37206142" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37205467">root</a><span>|</span><a href="#37205982">parent</a><span>|</span><a href="#37206013">prev</a><span>|</span><a href="#37205526">next</a><span>|</span><label class="collapse" for="c-37206142">[-]</label><label class="expand" for="c-37206142">[1 more]</label></div><br/><div class="children"><div class="content">That article is 100% right, but gmm said &quot;do another 20&quot; - that&#x27;s not really what hotspot people expect to do. They think there&#x27;s one or two hotspots that they need to optimise and then they&#x27;ll get a 10x speedup.<p>You can definitely do 20-100 small optimisations and get a 2-3x speedup.<p>The best example I&#x27;ve seen of that is Nicholas Nethercote&#x27;s work on speeding up the Rust compiler. A ton of tiny speed improvements that add up to 2x or 3x speed improvements overall.<p>I&#x27;ve done similar work on optimising a compiler. You&#x27;re never going to get 10x without architectural changes but you can get 3x with a lot of work.<p>Of course the &quot;we&#x27;ll just optimise the hotspots&quot; people have written their code so badly they need at least 10x.</div><br/></div></div></div></div></div></div><div id="37205526" class="c"><input type="checkbox" id="c-37205526" checked=""/><div class="controls bullet"><span class="by">bongobingo1</span><span>|</span><a href="#37205467">prev</a><span>|</span><a href="#37205780">next</a><span>|</span><label class="collapse" for="c-37205526">[-]</label><label class="expand" for="c-37205526">[1 more]</label></div><br/><div class="children"><div class="content">non xitter mirror: <a href="https:&#x2F;&#x2F;nitter.net&#x2F;cperciva&#x2F;status&#x2F;1693127769901969772" rel="nofollow noreferrer">https:&#x2F;&#x2F;nitter.net&#x2F;cperciva&#x2F;status&#x2F;1693127769901969772</a></div><br/></div></div><div id="37205780" class="c"><input type="checkbox" id="c-37205780" checked=""/><div class="controls bullet"><span class="by">rf15</span><span>|</span><a href="#37205526">prev</a><span>|</span><a href="#37205513">next</a><span>|</span><label class="collapse" for="c-37205780">[-]</label><label class="expand" for="c-37205780">[4 more]</label></div><br/><div class="children"><div class="content">Does anyone know why they used bubblesort in the first place? It is known for its bad performance, so what other factors came into play? Number of ops, maybe?</div><br/><div id="37205797" class="c"><input type="checkbox" id="c-37205797" checked=""/><div class="controls bullet"><span class="by">phoenixreader</span><span>|</span><a href="#37205780">parent</a><span>|</span><a href="#37205513">next</a><span>|</span><label class="collapse" for="c-37205797">[-]</label><label class="expand" for="c-37205797">[3 more]</label></div><br/><div class="children"><div class="content">According to the Twitter thread linked, at the beginning there were only 30 items, so using bubblesort didn&#x27;t matter. The number of items has since grown to a thousand.</div><br/><div id="37205962" class="c"><input type="checkbox" id="c-37205962" checked=""/><div class="controls bullet"><span class="by">professoretc</span><span>|</span><a href="#37205780">root</a><span>|</span><a href="#37205797">parent</a><span>|</span><a href="#37205513">next</a><span>|</span><label class="collapse" for="c-37205962">[-]</label><label class="expand" for="c-37205962">[2 more]</label></div><br/><div class="children"><div class="content">For 30 items bubblesort might very well have been faster than mergesort.</div><br/><div id="37206694" class="c"><input type="checkbox" id="c-37206694" checked=""/><div class="controls bullet"><span class="by">harry8</span><span>|</span><a href="#37205780">root</a><span>|</span><a href="#37205962">parent</a><span>|</span><a href="#37205513">next</a><span>|</span><label class="collapse" for="c-37206694">[-]</label><label class="expand" for="c-37206694">[1 more]</label></div><br/><div class="children"><div class="content">Bubble&#x2F;selection sort with early exit can win outright on big lists if they&#x27;re already almost in order. Textbook example years ago was cheque numbers which mostly are presented in order.<p>Know your data. (Which in this case, i don&#x27;t).</div><br/></div></div></div></div></div></div></div></div><div id="37205513" class="c"><input type="checkbox" id="c-37205513" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#37205780">prev</a><span>|</span><a href="#37205857">next</a><span>|</span><label class="collapse" for="c-37205513">[-]</label><label class="expand" for="c-37205513">[10 more]</label></div><br/><div class="children"><div class="content">Why not sort this in a precompile step and not sort the static list every boot?</div><br/><div id="37205541" class="c"><input type="checkbox" id="c-37205541" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37205513">parent</a><span>|</span><a href="#37205624">next</a><span>|</span><label class="collapse" for="c-37205541">[-]</label><label class="expand" for="c-37205541">[6 more]</label></div><br/><div class="children"><div class="content">Two reasons: First, it&#x27;s not worth screwing with the linker to save 20 microseconds.  Second, you need to merge lists anyway because kernel modules.</div><br/><div id="37205556" class="c"><input type="checkbox" id="c-37205556" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37205513">root</a><span>|</span><a href="#37205541">parent</a><span>|</span><a href="#37205624">next</a><span>|</span><label class="collapse" for="c-37205556">[-]</label><label class="expand" for="c-37205556">[5 more]</label></div><br/><div class="children"><div class="content">&gt; First, it&#x27;s not worth screwing with the linker to save 20 microseconds.<p>...yet. Certainly not when boot is 28ms; might be worth it when boot is 1ms.<p>&gt; Second, you need to merge lists anyway because kernel modules.<p>Does FreeBSD have the equivalent of a non-modular kernel build, for kernels where you know every piece of hardware it&#x27;ll ever talk to?</div><br/><div id="37205592" class="c"><input type="checkbox" id="c-37205592" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37205513">root</a><span>|</span><a href="#37205556">parent</a><span>|</span><a href="#37205624">next</a><span>|</span><label class="collapse" for="c-37205592">[-]</label><label class="expand" for="c-37205592">[4 more]</label></div><br/><div class="children"><div class="content">If I get the entire kernel boot down to 1 ms I might take another look at this. ;-)<p>You absolutely can compile everything you need into the kernel -- in fact for Firecracker you have to since you don&#x27;t have a boot loader handing you multiple kernel modules.  But I needed to write the code to support more than just Firecracker.</div><br/><div id="37205614" class="c"><input type="checkbox" id="c-37205614" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37205513">root</a><span>|</span><a href="#37205592">parent</a><span>|</span><a href="#37205624">next</a><span>|</span><label class="collapse" for="c-37205614">[-]</label><label class="expand" for="c-37205614">[3 more]</label></div><br/><div class="children"><div class="content">&gt; If I get the entire kernel boot down to 1 ms I might take another look at this. ;-)<p>I look forward to the upcoming boot-time competitions between FreeBSD and Linux. :)<p>&gt; You absolutely can compile everything you need into the kernel -- in fact for Firecracker you have to since you don&#x27;t have a boot loader handing you multiple kernel modules. But I needed to write the code to support more than just Firecracker.<p>Absolutely. But it seems reasonable to have, for instance, link-time sorting support that <i>only</i> works when building a kernel that doesn&#x27;t support kernel modules.</div><br/><div id="37205645" class="c"><input type="checkbox" id="c-37205645" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37205513">root</a><span>|</span><a href="#37205614">parent</a><span>|</span><a href="#37205624">next</a><span>|</span><label class="collapse" for="c-37205645">[-]</label><label class="expand" for="c-37205645">[2 more]</label></div><br/><div class="children"><div class="content">Maybe.  The tradeoff is that having two different ways of doing something makes it more likely that one will break without anyone noticing.</div><br/><div id="37205678" class="c"><input type="checkbox" id="c-37205678" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#37205513">root</a><span>|</span><a href="#37205645">parent</a><span>|</span><a href="#37205624">next</a><span>|</span><label class="collapse" for="c-37205678">[-]</label><label class="expand" for="c-37205678">[1 more]</label></div><br/><div class="children"><div class="content">Valid. Especially in early boot.<p>Another possibility: <i>always</i> use link-time sorting for the kernel, and for individual modules, and then do runtime merging if and only if you have kernel modules. That way, the link-time sorting path is <i>always</i> tested, and the runtime merging is tested anytime you have kernel modules (which sounds like the more common case).<p>(All of this, though, is gated under &quot;is it worth saving the microseconds yet&quot;.)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37205624" class="c"><input type="checkbox" id="c-37205624" checked=""/><div class="controls bullet"><span class="by">gizmo686</span><span>|</span><a href="#37205513">parent</a><span>|</span><a href="#37205541">prev</a><span>|</span><a href="#37205533">next</a><span>|</span><label class="collapse" for="c-37205624">[-]</label><label class="expand" for="c-37205624">[2 more]</label></div><br/><div class="children"><div class="content">Why not boot as a compilation step, and save a memory instance to be loaded on actual boots.</div><br/><div id="37206513" class="c"><input type="checkbox" id="c-37206513" checked=""/><div class="controls bullet"><span class="by">midoridensha</span><span>|</span><a href="#37205513">root</a><span>|</span><a href="#37205624">parent</a><span>|</span><a href="#37205533">next</a><span>|</span><label class="collapse" for="c-37206513">[-]</label><label class="expand" for="c-37206513">[1 more]</label></div><br/><div class="children"><div class="content">Probably because that would assume far too much about the state of the hardware.</div><br/></div></div></div></div><div id="37205533" class="c"><input type="checkbox" id="c-37205533" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37205513">parent</a><span>|</span><a href="#37205624">prev</a><span>|</span><a href="#37205857">next</a><span>|</span><label class="collapse" for="c-37205533">[-]</label><label class="expand" for="c-37205533">[1 more]</label></div><br/><div class="children"><div class="content">No good reason.  It would just require something fiddly with the linker &#x2F; build process.  This is good enough.</div><br/></div></div></div></div><div id="37205857" class="c"><input type="checkbox" id="c-37205857" checked=""/><div class="controls bullet"><span class="by">benreesman</span><span>|</span><a href="#37205513">prev</a><span>|</span><a href="#37205939">next</a><span>|</span><label class="collapse" for="c-37205857">[-]</label><label class="expand" for="c-37205857">[1 more]</label></div><br/><div class="children"><div class="content">For everyone challenging Colin on this, by all means, but do remember that it’s Colin.<p>If anyone misses less I can’t think of them.</div><br/></div></div><div id="37205939" class="c"><input type="checkbox" id="c-37205939" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#37205857">prev</a><span>|</span><a href="#37205377">next</a><span>|</span><label class="collapse" for="c-37205939">[-]</label><label class="expand" for="c-37205939">[5 more]</label></div><br/><div class="children"><div class="content">Why do you boot the system anyway? Wouldn&#x27;t it be faster dump the memory of an already booted system and just read that in?</div><br/><div id="37206076" class="c"><input type="checkbox" id="c-37206076" checked=""/><div class="controls bullet"><span class="by">hakfoo</span><span>|</span><a href="#37205939">parent</a><span>|</span><a href="#37206261">next</a><span>|</span><label class="collapse" for="c-37206076">[-]</label><label class="expand" for="c-37206076">[1 more]</label></div><br/><div class="children"><div class="content">That paradigm used to be a thing for things like home-computer games-- the game might take 5 minutes for an anemic Commodore 1541 drive to load, so you&#x27;d use a &quot;freeze&quot; cartridge that snapshotted RAM after the load finished and produced something smaller; I suspect a major side appeal was that you bypassed copy-protection that involved the loading process.<p>On a more complex system, with external devices active at all times, this gets a lot harder.  It would be easy to take a snapshot at the &quot;wrong&quot; time when something is deadlocked on a timer or external device that won&#x27;t be in an appropriate state at the next power on.  A &quot;boot&quot; process ensures everything attached has been roused from their slumber and get them back to a known state.<p>OTOH, I could imagine if you were designing to a specific enough use case, you could design a system that relied on a minimal support devices and a CPU that bit-banged almost everything, so you knew if you were in the idle loop, everything was safe to snapshot.</div><br/></div></div><div id="37206261" class="c"><input type="checkbox" id="c-37206261" checked=""/><div class="controls bullet"><span class="by">RetroTechie</span><span>|</span><a href="#37205939">parent</a><span>|</span><a href="#37206076">prev</a><span>|</span><a href="#37206303">next</a><span>|</span><label class="collapse" for="c-37206261">[-]</label><label class="expand" for="c-37206261">[2 more]</label></div><br/><div class="children"><div class="content">Would it?<p>Read in small amount of code (or execute directly from flash) &amp; use that to initialize hardware, might just be faster than read memory dump of already-initialized system.<p>Also the &quot;read memory dump&quot; method would include code &amp; data structures which were used on a previous run, but may not be needed for the next run (or only much later). And not re-initialize hardware which may have gone flaky, or changed configuration in the meanwhile (like USB port with different device plugged vs. state that memory dump reflects).<p>Rebooting is just an all around cleaner method to return system to a known state. But of course it all depends on hardware specifics &amp; what type(s) of initialization is done.</div><br/><div id="37206594" class="c"><input type="checkbox" id="c-37206594" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#37205939">root</a><span>|</span><a href="#37206261">parent</a><span>|</span><a href="#37206303">next</a><span>|</span><label class="collapse" for="c-37206594">[-]</label><label class="expand" for="c-37206594">[1 more]</label></div><br/><div class="children"><div class="content">The context here is starting a vm really fast on aws firecracker, so those concerns about hardware don&#x27;t apply.</div><br/></div></div></div></div><div id="37206303" class="c"><input type="checkbox" id="c-37206303" checked=""/><div class="controls bullet"><span class="by">bux93</span><span>|</span><a href="#37205939">parent</a><span>|</span><a href="#37206261">prev</a><span>|</span><a href="#37205377">next</a><span>|</span><label class="collapse" for="c-37206303">[-]</label><label class="expand" for="c-37206303">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s what windows fast startup does, it starts from a post-boot hibernated state of RAM. Linux mint on the same laptop boots fully in less time.</div><br/></div></div></div></div><div id="37205377" class="c"><input type="checkbox" id="c-37205377" checked=""/><div class="controls bullet"><span class="by">Blikkentrekker</span><span>|</span><a href="#37205939">prev</a><span>|</span><a href="#37205441">next</a><span>|</span><label class="collapse" for="c-37205377">[-]</label><label class="expand" for="c-37205377">[5 more]</label></div><br/><div class="children"><div class="content">Okay, but what exactly is 100 times faster when measured? Simply the sorting algorithm? If it not be a bottleneck to something then it doesn&#x27;t matter much.<p>I assume the entire performance of FreeBSD hasn&#x27;t improved a hundredfold by this small change.</div><br/><div id="37205437" class="c"><input type="checkbox" id="c-37205437" checked=""/><div class="controls bullet"><span class="by">reanimus</span><span>|</span><a href="#37205377">parent</a><span>|</span><a href="#37205435">next</a><span>|</span><label class="collapse" for="c-37205437">[-]</label><label class="expand" for="c-37205437">[1 more]</label></div><br/><div class="children"><div class="content">They explain this further on in the Twitter thread. It&#x27;s the portion of time spent sorting the array of system calls during boot. This didn&#x27;t used to matter when it took longer than a second to boot up, but now that the boot times are in the sub-second range, the amount of time spent sorting the array of system calls ended up taking up a notable chunk of the time spent booting.<p>Might not matter for the things you care about, but some people certainly do care about boot performance.</div><br/></div></div><div id="37205435" class="c"><input type="checkbox" id="c-37205435" checked=""/><div class="controls bullet"><span class="by">Crestwave</span><span>|</span><a href="#37205377">parent</a><span>|</span><a href="#37205437">prev</a><span>|</span><a href="#37205421">next</a><span>|</span><label class="collapse" for="c-37205435">[-]</label><label class="expand" for="c-37205435">[1 more]</label></div><br/><div class="children"><div class="content">The author mentions in the thread that the boot time they measured on the device was 28 ms and 7% of it (2 ms) was spent sorting.</div><br/></div></div><div id="37205421" class="c"><input type="checkbox" id="c-37205421" checked=""/><div class="controls bullet"><span class="by">wkat4242</span><span>|</span><a href="#37205377">parent</a><span>|</span><a href="#37205435">prev</a><span>|</span><a href="#37205461">next</a><span>|</span><label class="collapse" for="c-37205421">[-]</label><label class="expand" for="c-37205421">[1 more]</label></div><br/><div class="children"><div class="content">On the sorting of SYSINIT (not sysint as the title says) calls during bootup. The actual speedup is only a couple milliseconds but that means the old method was in the order of hundreds of milliseconds. Which is indeed a lot for a sorting operation.</div><br/></div></div><div id="37205461" class="c"><input type="checkbox" id="c-37205461" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#37205377">parent</a><span>|</span><a href="#37205421">prev</a><span>|</span><a href="#37205441">next</a><span>|</span><label class="collapse" for="c-37205461">[-]</label><label class="expand" for="c-37205461">[1 more]</label></div><br/><div class="children"><div class="content">100x faster on 7% of Firecracker boot<p>So ~5ms speedup</div><br/></div></div></div></div><div id="37205441" class="c"><input type="checkbox" id="c-37205441" checked=""/><div class="controls bullet"><span class="by">_3u10</span><span>|</span><a href="#37205377">prev</a><span>|</span><a href="#37205374">next</a><span>|</span><label class="collapse" for="c-37205441">[-]</label><label class="expand" for="c-37205441">[28 more]</label></div><br/><div class="children"><div class="content">Boot time was reduced by 2ms, from 28ms to 26ms. Hardly 100x speed.</div><br/><div id="37205475" class="c"><input type="checkbox" id="c-37205475" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37205441">parent</a><span>|</span><a href="#37205479">next</a><span>|</span><label class="collapse" for="c-37205475">[-]</label><label class="expand" for="c-37205475">[18 more]</label></div><br/><div class="children"><div class="content">The mergesort is roughly 100x faster than the bubblesort was.  I made no claim in that tweet about the overall speedup.<p>(But since you mention it, when I started working on speeding up the boot process, the kernel took about 10 seconds to boot, so I have a kernel booting about 400x faster now than I did a few years ago.)</div><br/><div id="37205486" class="c"><input type="checkbox" id="c-37205486" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205475">parent</a><span>|</span><a href="#37205554">next</a><span>|</span><label class="collapse" for="c-37205486">[-]</label><label class="expand" for="c-37205486">[14 more]</label></div><br/><div class="children"><div class="content">Why does <i>any</i> sorting <i>anywhere</i> use bubble sort at all? Aren&#x27;t there sorts out there that are strictly better?</div><br/><div id="37205552" class="c"><input type="checkbox" id="c-37205552" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205486">parent</a><span>|</span><a href="#37205585">next</a><span>|</span><label class="collapse" for="c-37205552">[-]</label><label class="expand" for="c-37205552">[3 more]</label></div><br/><div class="children"><div class="content">Options for sorting algorithms are severely limited when (a) you can&#x27;t use malloc, (b) you don&#x27;t have enough stack to recurse, and (c) you want a stable sort.<p>(The first two limitations are because this happens <i>very</i> early in the boot process.)</div><br/><div id="37205570" class="c"><input type="checkbox" id="c-37205570" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205552">parent</a><span>|</span><a href="#37205733">next</a><span>|</span><label class="collapse" for="c-37205570">[-]</label><label class="expand" for="c-37205570">[1 more]</label></div><br/><div class="children"><div class="content">Thanks! I completely forgot about the malloc&#x2F;in-place aspect.</div><br/></div></div><div id="37205733" class="c"><input type="checkbox" id="c-37205733" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205552">parent</a><span>|</span><a href="#37205570">prev</a><span>|</span><a href="#37205585">next</a><span>|</span><label class="collapse" for="c-37205733">[-]</label><label class="expand" for="c-37205733">[1 more]</label></div><br/><div class="children"><div class="content">Why the hash stack limit? I assume this precludes a fixed-size array.</div><br/></div></div></div></div><div id="37205585" class="c"><input type="checkbox" id="c-37205585" checked=""/><div class="controls bullet"><span class="by">knome</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205486">parent</a><span>|</span><a href="#37205552">prev</a><span>|</span><a href="#37206525">next</a><span>|</span><label class="collapse" for="c-37205585">[-]</label><label class="expand" for="c-37205585">[2 more]</label></div><br/><div class="children"><div class="content">sure, but bubble sort is trivial to write. they may have figured they&#x27;d replace it when they needed to. they may have figured the particular usage was so trivial they would never need to.<p>grabbed the source and git blamed the file before the patch to see when the original code was from.<p><pre><code>    94e9d7c12 (Peter Wemm              1998-10-09 23:42:47 +0000 157)  * The sysinit table itself.  Items are checked off as the are run.
    94e9d7c12 (Peter Wemm              1998-10-09 23:42:47 +0000 158)  * If we want to register new sysinit types, add them to newsysinit.
</code></pre>
So the section was written in 98 and had some bits modified in 2001.<p>The time wasted during boot here was probably irrelevant next to a hundred other things the project has worked on since.<p>the bubble sort was good enough that 25 years later they replaced it to save only 2ms during boot.<p>seems reasonable to me.</div><br/><div id="37205726" class="c"><input type="checkbox" id="c-37205726" checked=""/><div class="controls bullet"><span class="by">naniwaduni</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205585">parent</a><span>|</span><a href="#37206525">next</a><span>|</span><label class="collapse" for="c-37205726">[-]</label><label class="expand" for="c-37205726">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;d still think it&#x27;d be easier to write an insertion sort though, even accidentally! It&#x27;s <i>almost</i> the same algorithm conceptually, except cutting out an odd pessimization.</div><br/></div></div></div></div><div id="37206525" class="c"><input type="checkbox" id="c-37206525" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205486">parent</a><span>|</span><a href="#37205585">prev</a><span>|</span><a href="#37205503">next</a><span>|</span><label class="collapse" for="c-37206525">[-]</label><label class="expand" for="c-37206525">[3 more]</label></div><br/><div class="children"><div class="content">Bubble sort is optimal for sorting data stored on tapes (no random access possible).
If you have RAM, insertion sort is strictly superior (both simpler code + better performance).</div><br/><div id="37206752" class="c"><input type="checkbox" id="c-37206752" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37206525">parent</a><span>|</span><a href="#37206540">next</a><span>|</span><label class="collapse" for="c-37206752">[-]</label><label class="expand" for="c-37206752">[1 more]</label></div><br/><div class="children"><div class="content">On tapes (plural ≥ 3), isn’t merge sort the way to go?<p>I just coarsely checked TAOCP volume 3, and didn’t see bubble sort mentioned in the chapter on external sorting.</div><br/></div></div><div id="37206540" class="c"><input type="checkbox" id="c-37206540" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37206525">parent</a><span>|</span><a href="#37206752">prev</a><span>|</span><a href="#37205503">next</a><span>|</span><label class="collapse" for="c-37206540">[-]</label><label class="expand" for="c-37206540">[1 more]</label></div><br/><div class="children"><div class="content">Fascinating, thanks!</div><br/></div></div></div></div><div id="37205503" class="c"><input type="checkbox" id="c-37205503" checked=""/><div class="controls bullet"><span class="by">_3u10</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205486">parent</a><span>|</span><a href="#37206525">prev</a><span>|</span><a href="#37205554">next</a><span>|</span><label class="collapse" for="c-37205503">[-]</label><label class="expand" for="c-37205503">[5 more]</label></div><br/><div class="children"><div class="content">Because bubble sort is often faster for small sorts and it’s easy to write. This is the kernel, there’s no libc you have to write the sort algo yourself.</div><br/><div id="37206378" class="c"><input type="checkbox" id="c-37206378" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205503">parent</a><span>|</span><a href="#37205554">next</a><span>|</span><label class="collapse" for="c-37206378">[-]</label><label class="expand" for="c-37206378">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s really because C doesn&#x27;t have a proper dependency management system like modern languages do. If it did there&#x27;s no reason you couldn&#x27;t import a third party sorting algorithm in the kernel. You can do that in Rust for example, although you would just use the built in sort in this case.</div><br/><div id="37206605" class="c"><input type="checkbox" id="c-37206605" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37206378">parent</a><span>|</span><a href="#37205554">next</a><span>|</span><label class="collapse" for="c-37206605">[-]</label><label class="expand" for="c-37206605">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not because of that. There exist countless BSD compatible code out there, and many are taken and used in projects like this. CRC codes being an obvious example. There is no reason sort code could not have been grabbed from somewhere, no &quot;dependency management system&quot; required. The FreeBSD kernel has its own existing sort libraries already in the code too -- <a href="https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;sys&#x2F;libkern&#x2F;qsort.c?id=9a7add6d01f3c5f7eba811e794cf860d2bce131d" rel="nofollow noreferrer">https:&#x2F;&#x2F;cgit.freebsd.org&#x2F;src&#x2F;tree&#x2F;sys&#x2F;libkern&#x2F;qsort.c?id=9a7...</a><p>The real reason is because this is an early boot environment with exact constraints that are unusual if not unique to FreeBSD where the facilities to support your general language &#x2F; runtime environment is not up yet.</div><br/><div id="37206746" class="c"><input type="checkbox" id="c-37206746" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37206605">parent</a><span>|</span><a href="#37205554">next</a><span>|</span><label class="collapse" for="c-37206746">[-]</label><label class="expand" for="c-37206746">[2 more]</label></div><br/><div class="children"><div class="content">&gt; the facilities to support your general language &#x2F; runtime environment is not up yet.<p>Rust&#x27;s [T].sort_unstable() is part of core, that is, the code to sort a slice of arbitrary type T doesn&#x27;t need the allocator, operating system etc.<p>Only if you want a fast <i>stable</i> sort do you need to wait for such an environment because their fast <i>stable</i> sort needs an allocator, I doubt that FreeBSD needs a stable sort here.</div><br/><div id="37206845" class="c"><input type="checkbox" id="c-37206845" checked=""/><div class="controls bullet"><span class="by">throwawaylinux</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37206746">parent</a><span>|</span><a href="#37205554">next</a><span>|</span><label class="collapse" for="c-37206845">[-]</label><label class="expand" for="c-37206845">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure what part of my post you are addressing.<p>If you had a kernel written in Rust, you would have to bring up the rust runtime environment as part of the boot process. You don&#x27;t just magically get it because that&#x27;s the language you used, whether it is &quot;core&quot; or not. You can&#x27;t even execute simple functions before you have set up stack, and in this case apparently there is a constraint on stack usage. And evidently they do need a stable sort.<p>In any case my main point is that it&#x27;s not anything to do with dependency management, not quibbling about whether or not some language could support this function at this exact point of the boot.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37205554" class="c"><input type="checkbox" id="c-37205554" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205475">parent</a><span>|</span><a href="#37205486">prev</a><span>|</span><a href="#37205531">next</a><span>|</span><label class="collapse" for="c-37205554">[-]</label><label class="expand" for="c-37205554">[2 more]</label></div><br/><div class="children"><div class="content">Way to go.<p>Do you know how fast Linux starts up? I found the number 125ms but that’s a 4 year old number.<p>Just curious how similar they are. This is the first I’ve heard of Firecracker.</div><br/><div id="37205578" class="c"><input type="checkbox" id="c-37205578" checked=""/><div class="controls bullet"><span class="by">cperciva</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205554">parent</a><span>|</span><a href="#37205531">next</a><span>|</span><label class="collapse" for="c-37205578">[-]</label><label class="expand" for="c-37205578">[1 more]</label></div><br/><div class="children"><div class="content">I believe Linux is at 75-80 ms for the same environment where I have FreeBSD booting in 25 ms.  That comes from a Firecracker benchmark which I <i>think</i> is an apples-to-apples comparison with what I&#x27;m measuring in FreeBSD, but I&#x27;m not 100% certain.  Once FreeBSD support is merged into mainline Firecracker (it&#x27;s currently in a feature branch) I&#x27;m going to see if I can apply their performance tests to FreeBSD.</div><br/></div></div></div></div><div id="37205531" class="c"><input type="checkbox" id="c-37205531" checked=""/><div class="controls bullet"><span class="by">_3u10</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205475">parent</a><span>|</span><a href="#37205554">prev</a><span>|</span><a href="#37205479">next</a><span>|</span><label class="collapse" for="c-37205531">[-]</label><label class="expand" for="c-37205531">[1 more]</label></div><br/><div class="children"><div class="content">Totally agree but the title makes it sound like it’s 100x at init. I know you didn’t write the title…</div><br/></div></div></div></div><div id="37205479" class="c"><input type="checkbox" id="c-37205479" checked=""/><div class="controls bullet"><span class="by">joshu</span><span>|</span><a href="#37205441">parent</a><span>|</span><a href="#37205475">prev</a><span>|</span><a href="#37205374">next</a><span>|</span><label class="collapse" for="c-37205479">[-]</label><label class="expand" for="c-37205479">[9 more]</label></div><br/><div class="children"><div class="content">welcome to amdahl&#x27;s law</div><br/><div id="37205493" class="c"><input type="checkbox" id="c-37205493" checked=""/><div class="controls bullet"><span class="by">ashishgautam0</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205479">parent</a><span>|</span><a href="#37205374">next</a><span>|</span><label class="collapse" for="c-37205493">[-]</label><label class="expand" for="c-37205493">[8 more]</label></div><br/><div class="children"><div class="content">Hey what&#x27;s amdahl&#x27;s law. Can you explain</div><br/><div id="37205635" class="c"><input type="checkbox" id="c-37205635" checked=""/><div class="controls bullet"><span class="by">mumumu</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205493">parent</a><span>|</span><a href="#37205510">next</a><span>|</span><label class="collapse" for="c-37205635">[-]</label><label class="expand" for="c-37205635">[1 more]</label></div><br/><div class="children"><div class="content">Amdahl&#x27;s law is common sense, but also the one of the reasons premature optimization is the root of all evil.<p>A small speedup on the longest (by time) part of the program is usually better than infinite speedup on a short part of the program.</div><br/></div></div><div id="37205510" class="c"><input type="checkbox" id="c-37205510" checked=""/><div class="controls bullet"><span class="by">trostaft</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205493">parent</a><span>|</span><a href="#37205635">prev</a><span>|</span><a href="#37205516">next</a><span>|</span><label class="collapse" for="c-37205510">[-]</label><label class="expand" for="c-37205510">[3 more]</label></div><br/><div class="children"><div class="content">The Wikipedia article is pretty good, but tldr: &quot;the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used.&quot;<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Amdahl%27s_law" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Amdahl%27s_law</a><p>Usually used in the parallel computing context, but works here too.</div><br/><div id="37206604" class="c"><input type="checkbox" id="c-37206604" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205510">parent</a><span>|</span><a href="#37205525">next</a><span>|</span><label class="collapse" for="c-37206604">[-]</label><label class="expand" for="c-37206604">[1 more]</label></div><br/><div class="children"><div class="content">Same thing happens when driving - your trip duration usually depends on the slow bits not the faster parts e.g. in NZ driving through small towns will often be the longest part of your trip time.</div><br/></div></div><div id="37205525" class="c"><input type="checkbox" id="c-37205525" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205510">parent</a><span>|</span><a href="#37206604">prev</a><span>|</span><a href="#37205516">next</a><span>|</span><label class="collapse" for="c-37205525">[-]</label><label class="expand" for="c-37205525">[1 more]</label></div><br/><div class="children"><div class="content">So if you have something that takes 1 second out of 10 seconds, you can&#x27;t improve the overall system more than 1 second (by removing it entirely).</div><br/></div></div></div></div><div id="37205516" class="c"><input type="checkbox" id="c-37205516" checked=""/><div class="controls bullet"><span class="by">_3u10</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205493">parent</a><span>|</span><a href="#37205510">prev</a><span>|</span><a href="#37205374">next</a><span>|</span><label class="collapse" for="c-37205516">[-]</label><label class="expand" for="c-37205516">[3 more]</label></div><br/><div class="children"><div class="content">Something about 5% of things can’t be parallelized which then ends up dominating performance after the 95% of things that can be parallelized are.</div><br/><div id="37205656" class="c"><input type="checkbox" id="c-37205656" checked=""/><div class="controls bullet"><span class="by">mumumu</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205516">parent</a><span>|</span><a href="#37205374">next</a><span>|</span><label class="collapse" for="c-37205656">[-]</label><label class="expand" for="c-37205656">[2 more]</label></div><br/><div class="children"><div class="content">In hardware engineering this is called critical path.</div><br/><div id="37205777" class="c"><input type="checkbox" id="c-37205777" checked=""/><div class="controls bullet"><span class="by">memefrog</span><span>|</span><a href="#37205441">root</a><span>|</span><a href="#37205656">parent</a><span>|</span><a href="#37205374">next</a><span>|</span><label class="collapse" for="c-37205777">[-]</label><label class="expand" for="c-37205777">[1 more]</label></div><br/><div class="children"><div class="content">That is about latency, but Amdahl&#x27;s law is about throughput I think.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37205374" class="c"><input type="checkbox" id="c-37205374" checked=""/><div class="controls bullet"><span class="by">chris_wot</span><span>|</span><a href="#37205441">prev</a><span>|</span><label class="collapse" for="c-37205374">[-]</label><label class="expand" for="c-37205374">[7 more]</label></div><br/><div class="children"><div class="content">100x speed on what though? bootup time?</div><br/><div id="37205472" class="c"><input type="checkbox" id="c-37205472" checked=""/><div class="controls bullet"><span class="by">dpwm</span><span>|</span><a href="#37205374">parent</a><span>|</span><label class="collapse" for="c-37205472">[-]</label><label class="expand" for="c-37205472">[6 more]</label></div><br/><div class="children"><div class="content">&gt; When the FreeBSD kernel boots in Firecracker (1 CPU, 128 MB RAM), it now spends 7% of its time running a bubblesort on its SYSINITs.<p>It’s a 100x speed increase on 7% of the boot time, so it should be approximately a 7% decrease in boot time.</div><br/><div id="37205492" class="c"><input type="checkbox" id="c-37205492" checked=""/><div class="controls bullet"><span class="by">torstenvl</span><span>|</span><a href="#37205374">root</a><span>|</span><a href="#37205472">parent</a><span>|</span><label class="collapse" for="c-37205492">[-]</label><label class="expand" for="c-37205492">[5 more]</label></div><br/><div class="children"><div class="content">EDIT: I misread—please disregard the below comment.<p><i>3.5% decrease.<p>A 100% increase in speed is a 50% reduction in time.<p>E.g., traveling 60km at 30km&#x2F;h takes two hours, but at 60km&#x2F;h takes one hour.</i></div><br/><div id="37205518" class="c"><input type="checkbox" id="c-37205518" checked=""/><div class="controls bullet"><span class="by">dharmab</span><span>|</span><a href="#37205374">root</a><span>|</span><a href="#37205492">parent</a><span>|</span><a href="#37205521">next</a><span>|</span><label class="collapse" for="c-37205518">[-]</label><label class="expand" for="c-37205518">[1 more]</label></div><br/><div class="children"><div class="content">A 100x increase is a 9900% increase, not a 100% increase.</div><br/></div></div><div id="37205521" class="c"><input type="checkbox" id="c-37205521" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#37205374">root</a><span>|</span><a href="#37205492">parent</a><span>|</span><a href="#37205518">prev</a><span>|</span><a href="#37205534">next</a><span>|</span><label class="collapse" for="c-37205521">[-]</label><label class="expand" for="c-37205521">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re misreading 100x as 100%.  100x is 10,000%.</div><br/></div></div><div id="37205534" class="c"><input type="checkbox" id="c-37205534" checked=""/><div class="controls bullet"><span class="by">Finn_</span><span>|</span><a href="#37205374">root</a><span>|</span><a href="#37205492">parent</a><span>|</span><a href="#37205521">prev</a><span>|</span><a href="#37205529">next</a><span>|</span><label class="collapse" for="c-37205534">[-]</label><label class="expand" for="c-37205534">[1 more]</label></div><br/><div class="children"><div class="content">100x not 100%. 3,000 km&#x2F;h takes 1.2 minutes to go 60km.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>