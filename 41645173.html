<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1727341275470" as="style"/><link rel="stylesheet" href="styles.css?v=1727341275470"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://wafris.org/blog/rearchitecting-for-sqlite">Rearchitecting: Redis to SQLite</a> <span class="domain">(<a href="https://wafris.org">wafris.org</a>)</span></div><div class="subtext"><span>thecodemonkey</span> | <span>105 comments</span></div><br/><div><div id="41646775" class="c"><input type="checkbox" id="c-41646775" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41652410">next</a><span>|</span><label class="collapse" for="c-41646775">[-]</label><label class="expand" for="c-41646775">[44 more]</label></div><br/><div class="children"><div class="content">I’m really interested in this model where each application server has a copy of a SQLite database file which is then replaced on a scheduled basis.<p>Here it’s being used for web application firewall rules.<p>Another place I’ve thought about using this is feature flag configuration. Feature flags can be checked dozens of times per request and often need the kind of queries (user is a member of group A and has an IP located in country B) which could be well served by a local SQLite - and feature flags have a tolerance for updates taking a few seconds (or longer) to roll out.</div><br/><div id="41647295" class="c"><input type="checkbox" id="c-41647295" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41648480">next</a><span>|</span><label class="collapse" for="c-41647295">[-]</label><label class="expand" for="c-41647295">[17 more]</label></div><br/><div class="children"><div class="content">&gt; I’m really interested in this model where each application server has a copy of a SQLite database file which is then replaced on a scheduled basis.<p>BTW, this is also the model used by all CDNs, where the global configuration file containing the certificates, HTTP routing rules etc. for all customers will be updated into into a single-file b-tree structure*, and that &quot;bundle&quot; is distributed among all edge locations frequently.<p>* I&#x27;m yet to see someone use sqlite for this purpose, it&#x27;s usually DBM style databases like LMDB or Kyoto Cabinet.</div><br/><div id="41649789" class="c"><input type="checkbox" id="c-41649789" checked=""/><div class="controls bullet"><span class="by">twic</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647295">parent</a><span>|</span><a href="#41649410">next</a><span>|</span><label class="collapse" for="c-41649789">[-]</label><label class="expand" for="c-41649789">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Kyoto Cabinet<p>Now, that&#x27;s a name I&#x27;ve not heard in a long time.<p>Are people still using Kyoto Cabinet in new projects? Are people still using DBM-style storage generally? I thought that whole branch of the evolutionary tree had sort of died out.</div><br/><div id="41650639" class="c"><input type="checkbox" id="c-41650639" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41649789">parent</a><span>|</span><a href="#41652965">next</a><span>|</span><label class="collapse" for="c-41650639">[-]</label><label class="expand" for="c-41650639">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Are people still using Kyoto Cabinet in new projects?<p>Cloudflare used to use Kyoto Cabinet[1] and moved to LMDB[1] in 2020; other implementations that I&#x27;m familiar with (but don&#x27;t have a link to share) also use LMDB.<p>&gt; Are people still using DBM-style storage generally?<p>It&#x27;s fairly common in these scenarios, as well as the underlying key-value store for popular software like Consul[3].<p>[1] <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;kyoto-tycoon-secure-replication&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;kyoto-tycoon-secure-replication&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;introducing-quicksilver-configuration-distribution-at-internet-scale&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;introducing-quicksilver-configur...</a><p>[3] <a href="https:&#x2F;&#x2F;github.com&#x2F;hashicorp&#x2F;consul&#x2F;issues&#x2F;8442">https:&#x2F;&#x2F;github.com&#x2F;hashicorp&#x2F;consul&#x2F;issues&#x2F;8442</a></div><br/><div id="41655110" class="c"><input type="checkbox" id="c-41655110" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41650639">parent</a><span>|</span><a href="#41652965">next</a><span>|</span><label class="collapse" for="c-41655110">[-]</label><label class="expand" for="c-41655110">[1 more]</label></div><br/><div class="children"><div class="content">Cloudflare moved from lmdb to RocksDB for production.<p><a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;moving-quicksilver-into-production&#x2F;" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;moving-quicksilver-into-producti...</a></div><br/></div></div></div></div><div id="41652965" class="c"><input type="checkbox" id="c-41652965" checked=""/><div class="controls bullet"><span class="by">jbverschoor</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41649789">parent</a><span>|</span><a href="#41650639">prev</a><span>|</span><a href="#41649410">next</a><span>|</span><label class="collapse" for="c-41652965">[-]</label><label class="expand" for="c-41652965">[1 more]</label></div><br/><div class="children"><div class="content">Yeah that plus zeromq. Very curious.. I always thought T&#x2F;K cabinet and similar would become more popular with the adaption of ORMs</div><br/></div></div></div></div><div id="41649410" class="c"><input type="checkbox" id="c-41649410" checked=""/><div class="controls bullet"><span class="by">redserk</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647295">parent</a><span>|</span><a href="#41649789">prev</a><span>|</span><a href="#41652810">next</a><span>|</span><label class="collapse" for="c-41649410">[-]</label><label class="expand" for="c-41649410">[1 more]</label></div><br/><div class="children"><div class="content">I’ve worked on a project a long time ago where we did this with BerkeleyDB files. BDB was used to store configuration data that was frequently looked up.<p>Periodically we would run a full sync to replace the database. Between the periodic full syncs, we had a background process keep changes applied on a rolling basis.<p>All-in-all, it worked pretty well at the time! The full database file sync ensured a bad database was timeboxed and we got a bootstrapping mechanism for free.</div><br/></div></div><div id="41652810" class="c"><input type="checkbox" id="c-41652810" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647295">parent</a><span>|</span><a href="#41649410">prev</a><span>|</span><a href="#41650698">next</a><span>|</span><label class="collapse" for="c-41652810">[-]</label><label class="expand" for="c-41652810">[7 more]</label></div><br/><div class="children"><div class="content">The query engine in SQLite can be weak.  In particular where JOINs across multiple columns are concerned.  You really do need to be aware of this when designing indexes into SQLite files.<p>In any case,  SQLite would serve this solution,  but almost certainly with a measurable level of inefficiency built in.</div><br/><div id="41652909" class="c"><input type="checkbox" id="c-41652909" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41652810">parent</a><span>|</span><a href="#41650698">next</a><span>|</span><label class="collapse" for="c-41652909">[-]</label><label class="expand" for="c-41652909">[6 more]</label></div><br/><div class="children"><div class="content">This is the first I&#x27;ve heard of SQLite JOIN performance being &quot;weak&quot;.  I just spent 10 minutes scouring the annals of the web and didn&#x27;t turn up anything relevant.  Are there any additional links or other information you can share about this claim?<p><i>Edit:</i> @akira2501: SQLite comes with different tradeoffs, sometimes superior and other times less so, depending on the use case.  Blanket statements without evidence are unproductive in progressing the conversation..</div><br/><div id="41654200" class="c"><input type="checkbox" id="c-41654200" checked=""/><div class="controls bullet"><span class="by">Groxx</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41652909">parent</a><span>|</span><a href="#41652937">next</a><span>|</span><label class="collapse" for="c-41654200">[-]</label><label class="expand" for="c-41654200">[1 more]</label></div><br/><div class="children"><div class="content">Weeellll... I think it&#x27;s safe to say SQLite&#x27;s planner is <i>simple</i>, and trends towards &quot;you get what you wrote&quot; rather than having more sophisticated runtime monitoring and adjusting.<p>But as with all things SQLite, the answer is generally &quot;it&#x27;s <i>easy to predict</i> so just improve your query&quot; and&#x2F;or &quot;there&#x27;s a plugin for that&quot; so it tends to win in the end with a bit of care.</div><br/></div></div><div id="41652937" class="c"><input type="checkbox" id="c-41652937" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41652909">parent</a><span>|</span><a href="#41654200">prev</a><span>|</span><a href="#41650698">next</a><span>|</span><label class="collapse" for="c-41652937">[-]</label><label class="expand" for="c-41652937">[4 more]</label></div><br/><div class="children"><div class="content">Seriously?<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;optoverview.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;optoverview.html</a><p>Chapter 2.  Chapter 7.  Chapter 8.<p>It should be _zero_ surprise to you that SQLite is not as powerful as other full database query engines.</div><br/><div id="41654689" class="c"><input type="checkbox" id="c-41654689" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41652937">parent</a><span>|</span><a href="#41654077">next</a><span>|</span><label class="collapse" for="c-41654689">[-]</label><label class="expand" for="c-41654689">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you. I&#x27;ve encountered numerous situations where the query planner caused issues. I don&#x27;t know if the alternatives are better, but it&#x27;s definitely an issue. I&#x27;ve written multiple databases wrapping SQLite, and multiple bindings to SQLite. There are dragons.</div><br/></div></div><div id="41654077" class="c"><input type="checkbox" id="c-41654077" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41652937">parent</a><span>|</span><a href="#41654689">prev</a><span>|</span><a href="#41654733">next</a><span>|</span><label class="collapse" for="c-41654077">[-]</label><label class="expand" for="c-41654077">[1 more]</label></div><br/><div class="children"><div class="content">I don’t understand how reading that documentation page makes it clear that other relational engines have better performance for joins.</div><br/></div></div></div></div></div></div></div></div><div id="41650698" class="c"><input type="checkbox" id="c-41650698" checked=""/><div class="controls bullet"><span class="by">d0mine</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647295">parent</a><span>|</span><a href="#41652810">prev</a><span>|</span><a href="#41649520">next</a><span>|</span><label class="collapse" for="c-41650698">[-]</label><label class="expand" for="c-41650698">[1 more]</label></div><br/><div class="children"><div class="content">you can use sqlite as a dbm db 
<a href="https:&#x2F;&#x2F;docs.python.org&#x2F;3.13&#x2F;library&#x2F;dbm.html#module-dbm.sqlite3" rel="nofollow">https:&#x2F;&#x2F;docs.python.org&#x2F;3.13&#x2F;library&#x2F;dbm.html#module-dbm.sql...</a></div><br/></div></div><div id="41649520" class="c"><input type="checkbox" id="c-41649520" checked=""/><div class="controls bullet"><span class="by">Capricorn2481</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647295">parent</a><span>|</span><a href="#41650698">prev</a><span>|</span><a href="#41648480">next</a><span>|</span><label class="collapse" for="c-41649520">[-]</label><label class="expand" for="c-41649520">[3 more]</label></div><br/><div class="children"><div class="content">&gt; will be updated into into a single-file b-tree structure<p>I&#x27;m not knowledgeable on this, but my understanding was a b-tree is a way of sorting values that could be ordered in a certain way. Like this would be a b-tree of IDs<p>```<p><pre><code>            [8]

           &#x2F;   \

      [3, 5]   [10, 12]

     &#x2F; | \     &#x2F; | \  

  [1] [4] [6,7] [9] [11, 13]
</code></pre>
```<p>You traverse by comparing your needle to the root node and going left or right depending on the results.<p>How is that done with configuration options? That seems like it would just be a regular hashmap which is already efficient to read. What would a b-tree of key&#x2F;values even look like that wouldn&#x27;t be less efficient than a hashmap?</div><br/><div id="41650070" class="c"><input type="checkbox" id="c-41650070" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41649520">parent</a><span>|</span><a href="#41649825">next</a><span>|</span><label class="collapse" for="c-41650070">[-]</label><label class="expand" for="c-41650070">[1 more]</label></div><br/><div class="children"><div class="content">Each number in your btree would actually be a key-value pair. So you can find the key fast, and then you have the value.<p>Databases including SQLite usually use b+tree for tables (a variant where only the leaves have data, the interior nodes only have keys) and regular btrees for indexes.</div><br/></div></div><div id="41649825" class="c"><input type="checkbox" id="c-41649825" checked=""/><div class="controls bullet"><span class="by">lucianbr</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41649520">parent</a><span>|</span><a href="#41650070">prev</a><span>|</span><a href="#41648480">next</a><span>|</span><label class="collapse" for="c-41649825">[-]</label><label class="expand" for="c-41649825">[1 more]</label></div><br/><div class="children"><div class="content">A hash table makes sense in memory. If it&#x27;s loaded just right for fast access, it has holes - empty entries. That makes little sense if you are building a file that will be transferred to many places over the internet. Bandwith waste would be significant.<p>So it might seem that simply enumerating the data (sorted or not) would be a better option for a file. (After all, the receiver will read everything anyway.) I guess frequent updates make this inefficient, so a tree helps.</div><br/></div></div></div></div></div></div><div id="41648480" class="c"><input type="checkbox" id="c-41648480" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41647295">prev</a><span>|</span><a href="#41647805">next</a><span>|</span><label class="collapse" for="c-41648480">[-]</label><label class="expand" for="c-41648480">[3 more]</label></div><br/><div class="children"><div class="content">We used this model to distribute translations, feature flags, configuration, search indexes, etc at Airbnb. But instead of SQLite we used Sparkey, a KV file format developed by Spotify. In early years there was a Cron job on every box that pulled that service’s thingies; then once we switched to Kubernetes we used a deamomset &amp; host tagging (taints?) to pull a variety of thingies to each host and then ensure the services that use the thingies only ran on the hosts that had the thingies.<p>In Ruby we called this “hammerspace” <a href="https:&#x2F;&#x2F;github.com&#x2F;airbnb&#x2F;hammerspace">https:&#x2F;&#x2F;github.com&#x2F;airbnb&#x2F;hammerspace</a></div><br/><div id="41651004" class="c"><input type="checkbox" id="c-41651004" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648480">parent</a><span>|</span><a href="#41647805">next</a><span>|</span><label class="collapse" for="c-41651004">[-]</label><label class="expand" for="c-41651004">[2 more]</label></div><br/><div class="children"><div class="content">1. Very cool<p>2. If you were making it today would you just use SQLite?</div><br/><div id="41651067" class="c"><input type="checkbox" id="c-41651067" checked=""/><div class="controls bullet"><span class="by">skevy</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41651004">parent</a><span>|</span><a href="#41647805">next</a><span>|</span><label class="collapse" for="c-41651067">[-]</label><label class="expand" for="c-41651067">[1 more]</label></div><br/><div class="children"><div class="content">Yes, we would. And likely will switch to SQLite at some point in the future. (source, I work adjacent to these systems at Airbnb)</div><br/></div></div></div></div></div></div><div id="41647805" class="c"><input type="checkbox" id="c-41647805" checked=""/><div class="controls bullet"><span class="by">quesera</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41648480">prev</a><span>|</span><a href="#41652675">next</a><span>|</span><label class="collapse" for="c-41647805">[-]</label><label class="expand" for="c-41647805">[5 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Feature flags can be checked dozens of times per request</i><p>My strategy for resolving this is to fetch the flag value once, but to store it in the request object, so that a) you never have to take the expensive lookup hit more than once per request, and b) there&#x27;s no risk of an inconsistent value if the flag is updated mid-request.</div><br/><div id="41648568" class="c"><input type="checkbox" id="c-41648568" checked=""/><div class="controls bullet"><span class="by">jitl</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647805">parent</a><span>|</span><a href="#41648370">next</a><span>|</span><label class="collapse" for="c-41648568">[-]</label><label class="expand" for="c-41648568">[2 more]</label></div><br/><div class="children"><div class="content">Where is the “session object” stored?</div><br/><div id="41648849" class="c"><input type="checkbox" id="c-41648849" checked=""/><div class="controls bullet"><span class="by">quesera</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648568">parent</a><span>|</span><a href="#41648370">next</a><span>|</span><label class="collapse" for="c-41648849">[-]</label><label class="expand" for="c-41648849">[1 more]</label></div><br/><div class="children"><div class="content">Apologies, I meant &quot;request object&quot;. Corrected above.</div><br/></div></div></div></div><div id="41648370" class="c"><input type="checkbox" id="c-41648370" checked=""/><div class="controls bullet"><span class="by">CraigJPerry</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647805">parent</a><span>|</span><a href="#41648568">prev</a><span>|</span><a href="#41652675">next</a><span>|</span><label class="collapse" for="c-41648370">[-]</label><label class="expand" for="c-41648370">[2 more]</label></div><br/><div class="children"><div class="content">What’s the use case for re-checking the same feature flag in a single session?<p>I can see why you need to check multiple different flags in a session and I understand the parent point about looking in SQLite for them (effectively a function call into a library in process address space rather than a call over the network for each flag).</div><br/><div id="41648908" class="c"><input type="checkbox" id="c-41648908" checked=""/><div class="controls bullet"><span class="by">quesera</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648370">parent</a><span>|</span><a href="#41652675">next</a><span>|</span><label class="collapse" for="c-41648908">[-]</label><label class="expand" for="c-41648908">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, s&#x2F;session&#x2F;request&#x2F;g; corrected above.<p>One example is a multistep transaction processing request. The feature flag could gate several branch points.<p>A memory-mapped SQLite file is great too, but the strategy I describe above is less code to write, adds no new dependencies, is quicker to implement, avoids the SQLite file distribution&#x2F;availability issues, and should get you a very similar performance improvement.</div><br/></div></div></div></div></div></div><div id="41652675" class="c"><input type="checkbox" id="c-41652675" checked=""/><div class="controls bullet"><span class="by">adroitboss</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41647805">prev</a><span>|</span><a href="#41646879">next</a><span>|</span><label class="collapse" for="c-41652675">[-]</label><label class="expand" for="c-41652675">[1 more]</label></div><br/><div class="children"><div class="content">You may want to check out LiteFS and LiteStream by benbjohnson. There was a time in 2022 where he was trending every week for his projects. The following snippet is taken from the LiteFS webpage. &quot;LiteFS is a distributed file system that transparently replicates SQLite databases. You can run your application like it’s running against a local on-disk SQLite database but behind the scenes the database is replicated to all the nodes in your cluster.&quot;</div><br/></div></div><div id="41646879" class="c"><input type="checkbox" id="c-41646879" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41652675">prev</a><span>|</span><a href="#41648396">next</a><span>|</span><label class="collapse" for="c-41646879">[-]</label><label class="expand" for="c-41646879">[2 more]</label></div><br/><div class="children"><div class="content">SQLite for distribution is neat. FWIW - this is at least partially inspired by your datasette project which we may still try and do something with later on the reporting and data exploration side of things.</div><br/><div id="41654779" class="c"><input type="checkbox" id="c-41654779" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41646879">parent</a><span>|</span><a href="#41648396">next</a><span>|</span><label class="collapse" for="c-41654779">[-]</label><label class="expand" for="c-41654779">[1 more]</label></div><br/><div class="children"><div class="content">Years ago I had a conversation with a friend of a friend that worked at one of the big chip fabs in their lab dept. He mentioned they made very heavy use of sqlite as a file format for distribution. This was back in the &quot;xml all the things&quot; era and it struck me as such a smart breath of fresh air.<p>I&#x27;m honestly surprised it isn&#x27;t more pervasive.</div><br/></div></div></div></div><div id="41648396" class="c"><input type="checkbox" id="c-41648396" checked=""/><div class="controls bullet"><span class="by">nnf</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41646879">prev</a><span>|</span><a href="#41653299">next</a><span>|</span><label class="collapse" for="c-41648396">[-]</label><label class="expand" for="c-41648396">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve wanted to implement this on a distributed web server environment I manage. Right now there&#x27;s a centralized MySQL database that the web servers read from when rendering a web page, but there can be lots of queries for a single render (page, sections, snippets, attributes, assets, etc.), and sending that all over the wire, while fast, is slower than reading from a database running on the same host. It&#x27;d be great to be able to copy the &quot;master&quot; database onto each web server instance, maybe once per minute, or just on-demand when a change to the data is made. I imagine this would make reads much faster.</div><br/><div id="41650138" class="c"><input type="checkbox" id="c-41650138" checked=""/><div class="controls bullet"><span class="by">pkhuong</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648396">parent</a><span>|</span><a href="#41653299">next</a><span>|</span><label class="collapse" for="c-41650138">[-]</label><label class="expand" for="c-41650138">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s how <a href="https:&#x2F;&#x2F;github.com&#x2F;backtrace-labs&#x2F;verneuil">https:&#x2F;&#x2F;github.com&#x2F;backtrace-labs&#x2F;verneuil</a> &#x27;s read replication is meant to be used. There&#x27;s a command-line tool to recreate a sqlite DB file from a snapshot&#x27;s manifest, with an optional local cache to avoid fetching unchanged pages, or you can directly use a replica in memory, with pragmas for (async) refreshes.<p>The write tracking needs to intercept all writes with a custom VFS, but once registered and configured, it&#x27;s regular in-memory SQLite (no additional daemon).</div><br/></div></div></div></div><div id="41653299" class="c"><input type="checkbox" id="c-41653299" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41648396">prev</a><span>|</span><a href="#41651883">next</a><span>|</span><label class="collapse" for="c-41653299">[-]</label><label class="expand" for="c-41653299">[1 more]</label></div><br/><div class="children"><div class="content">In a past life, I used this pattern in hadoop mapreduce clusters. A job would do &quot;small-data&quot; sql queries locally to pull configs, maps of facts related to the business domain, then pack them into sqlite db files and ship them up with the job. Hadoop already has a process called &quot;job localization&quot; where it can download files sent up with the job down to the PWD of the mapper&#x2F;reducer. And then the mapper&#x2F;reducer can use it read-only while doing big-data things.</div><br/></div></div><div id="41651883" class="c"><input type="checkbox" id="c-41651883" checked=""/><div class="controls bullet"><span class="by">Salgat</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41653299">prev</a><span>|</span><a href="#41649120">next</a><span>|</span><label class="collapse" for="c-41651883">[-]</label><label class="expand" for="c-41651883">[1 more]</label></div><br/><div class="children"><div class="content">We use something similar for our event based databases. We project millions of events into an in-memory object (usually a dictionary), and periodically persist that state as json in S3. It&#x27;s guaranteed to be consistent across all service instances because the persisted state contains the event stream positions to catchup from. The only drawback of course is that it can use up to several GB of memory depending on how big the state is, but it&#x27;s extremely fast and doing in-memory operations is trivial compared to using SQL or a library with api calls.</div><br/></div></div><div id="41649120" class="c"><input type="checkbox" id="c-41649120" checked=""/><div class="controls bullet"><span class="by">otoolep</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41651883">prev</a><span>|</span><a href="#41651938">next</a><span>|</span><label class="collapse" for="c-41649120">[-]</label><label class="expand" for="c-41649120">[3 more]</label></div><br/><div class="children"><div class="content">rqlite[1] could basically do this, if you use read-only nodes[2]. But it&#x27;s not quite a drop-in replacement for SQLite at the write-side. But from point of view of a clients at the edge, they see a SQLite database being updated which they can directly read[3].<p>That said, it may not be practical to have hundreds of read-only nodes, but for moderate-size needs, should work fine.<p>Disclaimer: I&#x27;m the creator of rqlite.<p>[1] <a href="https:&#x2F;&#x2F;rqlite.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rqlite.io&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;rqlite.io&#x2F;docs&#x2F;clustering&#x2F;read-only-nodes&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rqlite.io&#x2F;docs&#x2F;clustering&#x2F;read-only-nodes&#x2F;</a><p>[3] <a href="https:&#x2F;&#x2F;rqlite.io&#x2F;docs&#x2F;guides&#x2F;direct-access&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rqlite.io&#x2F;docs&#x2F;guides&#x2F;direct-access&#x2F;</a></div><br/><div id="41651148" class="c"><input type="checkbox" id="c-41651148" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41649120">parent</a><span>|</span><a href="#41651938">next</a><span>|</span><label class="collapse" for="c-41651148">[-]</label><label class="expand" for="c-41651148">[2 more]</label></div><br/><div class="children"><div class="content">(author here) I had looked at both Rqlite and the different commercial versions of this, but I  didn&#x27;t pursue them as they all seemed to require running an additional service on the host machines.</div><br/><div id="41651464" class="c"><input type="checkbox" id="c-41651464" checked=""/><div class="controls bullet"><span class="by">otoolep</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41651148">parent</a><span>|</span><a href="#41651938">next</a><span>|</span><label class="collapse" for="c-41651464">[-]</label><label class="expand" for="c-41651464">[1 more]</label></div><br/><div class="children"><div class="content">Yes, that is right, it would require a new service running on the host machines.<p>That said, I do think it depends on what you consider important, and what your experience has been in the past. I used to value simplicity above all, so reducing the number of moving pieces was important to my designs. For the purpose of this discussion let&#x27;s count a service as a single moving piece.<p>But over time I&#x27;ve decided that I also value <i>reliability</i>. Operators don&#x27;t necessarily want simplicity. What they want is reliability and ease-of-use. Simplicity sometimes helps you get there, but not always.<p>So, yes, rqlite means another service. But I put a lot of emphasis on reliability when it comes to rqlite, and ease-of-operation. Because often when folks want something &quot;simple&quot; what they really want is &quot;something that just works, works really well, and which I don&#x27;t have to think about&quot;. SQLite certainly meets that requirement, that is true.</div><br/></div></div></div></div></div></div><div id="41651938" class="c"><input type="checkbox" id="c-41651938" checked=""/><div class="controls bullet"><span class="by">TmpstsTrrctta</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41649120">prev</a><span>|</span><a href="#41647988">next</a><span>|</span><label class="collapse" for="c-41651938">[-]</label><label class="expand" for="c-41651938">[1 more]</label></div><br/><div class="children"><div class="content">I’ve utilized this in Lambda@Edge for use case half feature flag-y, half HTTP routing&#x2F;proxy serving rules as mentioned in a sibling comment. Lambdas pick up ~50-200MB of data on first boot, and keep their copy through their lifecycle.<p>As requests come in, gather their features, convert to effectively an int vector, filter for row where match and serve request</div><br/></div></div><div id="41647988" class="c"><input type="checkbox" id="c-41647988" checked=""/><div class="controls bullet"><span class="by">bob1029</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41651938">prev</a><span>|</span><a href="#41649177">next</a><span>|</span><label class="collapse" for="c-41647988">[-]</label><label class="expand" for="c-41647988">[2 more]</label></div><br/><div class="children"><div class="content">&gt; a SQLite database file which is then replaced on a scheduled basis.<p>You could look into WAL replication if you wanted an efficient way to update the copies. Something like Litestream.</div><br/><div id="41651441" class="c"><input type="checkbox" id="c-41651441" checked=""/><div class="controls bullet"><span class="by">er0k</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41647988">parent</a><span>|</span><a href="#41649177">next</a><span>|</span><label class="collapse" for="c-41651441">[-]</label><label class="expand" for="c-41651441">[1 more]</label></div><br/><div class="children"><div class="content">litestream is great. Dead simple and rock solid IME.</div><br/></div></div></div></div><div id="41649177" class="c"><input type="checkbox" id="c-41649177" checked=""/><div class="controls bullet"><span class="by">closeparen</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41647988">prev</a><span>|</span><a href="#41648210">next</a><span>|</span><label class="collapse" for="c-41649177">[-]</label><label class="expand" for="c-41649177">[1 more]</label></div><br/><div class="children"><div class="content">This is the type of architecture we use for feature flagging, but it&#x27;s just a JSON file.</div><br/></div></div><div id="41648210" class="c"><input type="checkbox" id="c-41648210" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41646775">parent</a><span>|</span><a href="#41649177">prev</a><span>|</span><a href="#41652410">next</a><span>|</span><label class="collapse" for="c-41648210">[-]</label><label class="expand" for="c-41648210">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Feature flags can be checked dozens of times per request and often need the kind of queries (user is a member of group A and has an IP located in country B) which could be well served by a local SQLite - and feature flags have a tolerance for updates taking a few seconds (or longer) to roll out.<p>This doesn&#x27;t sound right. A feature flag only requires checking if a request comes from a user that is in a specific feature group. This is a single key:value check.<p>The business logic lies in assigning a user to a specific feature group, which the simplest way means pre assigning the user and in the most complex cases takes place at app start&#x2F;first request to dynamically control dialups.<p>Either way, it&#x27;s a single key: value check where the key is user ID+feature ID, or session ID + feature ID.<p>I mean, I guess you can send a boat load of data to perform the same complex query over and over again. I suppose. But you need to not have invested any thought onto the issue and insisted in making things very hard for you, QAs, and users too. I mean, read your own description: why are you making the exact same complex query over and over and over again, multiple times in the same request? At most, do it once, cache the result, and from therein just do a key:value check. You can use sqlite for that if you&#x27;d like.</div><br/><div id="41650162" class="c"><input type="checkbox" id="c-41650162" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648210">parent</a><span>|</span><a href="#41648347">next</a><span>|</span><label class="collapse" for="c-41650162">[-]</label><label class="expand" for="c-41650162">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked at places where the feature flag system was much more dynamic than that, considering way more than just membership in a group.<p>This meant you could roll features out to:<p>- Specific user IDs<p>- Every user ID in a specific group<p>- Every object owned by a specific user ID (feature flags might apply to nested objects in the system)<p>- Requests from IP addresses in certain countries<p>- Requests served by specific website TLDs<p>- Users who are paid members of a specific plan<p>- etc etc etc<p>It was an enormously complicated system, that had evolved over 5-10 years.<p>Not saying that level of complexity is recommended, but that&#x27;s what we had.<p>Looks like I gave a talk about this back in 2014: <a href="https:&#x2F;&#x2F;speakerdeck.com&#x2F;simon&#x2F;feature-flags" rel="nofollow">https:&#x2F;&#x2F;speakerdeck.com&#x2F;simon&#x2F;feature-flags</a></div><br/></div></div><div id="41648347" class="c"><input type="checkbox" id="c-41648347" checked=""/><div class="controls bullet"><span class="by">nnf</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648210">parent</a><span>|</span><a href="#41650162">prev</a><span>|</span><a href="#41652410">next</a><span>|</span><label class="collapse" for="c-41648347">[-]</label><label class="expand" for="c-41648347">[2 more]</label></div><br/><div class="children"><div class="content">GP&#x27;s comment is talking about checking multiple feature flags, not checking a single feature flag multiple times.</div><br/><div id="41648459" class="c"><input type="checkbox" id="c-41648459" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41646775">root</a><span>|</span><a href="#41648347">parent</a><span>|</span><a href="#41652410">next</a><span>|</span><label class="collapse" for="c-41648459">[-]</label><label class="expand" for="c-41648459">[1 more]</label></div><br/><div class="children"><div class="content">GP referred specifically to queries checking if &quot;user is a member of group A and has an IP located in country B&quot;.<p>The number of feature flags is irrelevant. In fact, the feature flag and A&#x2F;B testing services I used always returned all default treatment overrides in a single request.</div><br/></div></div></div></div></div></div></div></div><div id="41652410" class="c"><input type="checkbox" id="c-41652410" checked=""/><div class="controls bullet"><span class="by">vchynarov</span><span>|</span><a href="#41646775">prev</a><span>|</span><a href="#41647075">next</a><span>|</span><label class="collapse" for="c-41652410">[-]</label><label class="expand" for="c-41652410">[2 more]</label></div><br/><div class="children"><div class="content">Apart from network latency, one of the behaviours I&#x27;ve seen with Redis is that reads&#x2F;write latencies are fairly linearly proportional to the amount of keys queried - which seems to be shown in your chart as well.<p>We had a different problem, where our monolithic app used both Postgres &#x2F; Redis for different use cases and worked relatively well. However - it was a lot easier to shove new functionality in the shared Redis cluster. Because Redis is single-threaded, one inconsiderate feature that does bulk reads (100K+ keys) may start to slow down other things. One of the guidelines I proposed was that Redis is really good when we&#x27;re reading&#x2F;writing a key, or small fixed-cardinality set of keys at a time, because we have a lot of random things using Redis (things like locks and rate limits on popular endpoints, etc).<p>However, in your case, I&#x27;m guessing Redis shines in the case of a naive single-key (IP address) lookup, but also doesn&#x27;t do well with more complicated reads (representing your range query representation?). Cool write up overall, I don&#x27;t have a deeper understanding of how SQLite performs so well when compared to a local Redis instance, so that was unexpected and interesting to observe.</div><br/><div id="41654854" class="c"><input type="checkbox" id="c-41654854" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#41652410">parent</a><span>|</span><a href="#41647075">next</a><span>|</span><label class="collapse" for="c-41654854">[-]</label><label class="expand" for="c-41654854">[1 more]</label></div><br/><div class="children"><div class="content">My experience with Redis is similar, where it often becomes a trap because people misunderstand it&#x27;s strengths and weaknesses.<p>I think it&#x27;s best to consider Redis a cache with richer primitives. It excels at this and used appropriately will be both fast and solid.<p>But then people start wanting to use it for things that don&#x27;t fit into the primary rdbms. Soon you have a job queue, locks of various sorts, etc. And then it just becomes a matter of time until performance crosses a cliff, or the thing falls down for some other reason, and you&#x27;re left with a pretty ugly mess to restore things, usually resulting in just accepting some data loss.<p>It takes some discipline to avoid this, because it happens easily by increments.<p>As for SQLite&#x27;s performance, besides avoiding network overhead, a lot of people underestimate serialization and deserialization costs. Even though Redis uses a pretty minimalist protocol it adds up. With SQLite a lot of things boil down to an in process memcopy.</div><br/></div></div></div></div><div id="41647075" class="c"><input type="checkbox" id="c-41647075" checked=""/><div class="controls bullet"><span class="by">aquilaFiera</span><span>|</span><a href="#41652410">prev</a><span>|</span><a href="#41646518">next</a><span>|</span><label class="collapse" for="c-41647075">[-]</label><label class="expand" for="c-41647075">[1 more]</label></div><br/><div class="children"><div class="content">Somewhat related: for the Neon internal hackathon a few weeks ago I wrote a little Node.js server that turns Redis&#x27;s wire protocol (RESP) into Postgres queries. Very fun hack project: <a href="https:&#x2F;&#x2F;github.com&#x2F;btholt&#x2F;redis-to-postgres">https:&#x2F;&#x2F;github.com&#x2F;btholt&#x2F;redis-to-postgres</a></div><br/></div></div><div id="41646518" class="c"><input type="checkbox" id="c-41646518" checked=""/><div class="controls bullet"><span class="by">matharmin</span><span>|</span><a href="#41647075">prev</a><span>|</span><a href="#41650753">next</a><span>|</span><label class="collapse" for="c-41646518">[-]</label><label class="expand" for="c-41646518">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like a niche use case where SQLite does work quite well server-side without needing any replication, since the database is read-only.<p>Other alternatives may use static files loaded in-memory, but I&#x27;m guessing the data is more than you&#x27;d want to keep in memory in this case, making SQLite a nice alternative.</div><br/><div id="41646597" class="c"><input type="checkbox" id="c-41646597" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41646518">parent</a><span>|</span><a href="#41648342">next</a><span>|</span><label class="collapse" for="c-41646597">[-]</label><label class="expand" for="c-41646597">[1 more]</label></div><br/><div class="children"><div class="content">(article author here) - yes 100% and I hope that came through in the article that this is great solution given our particular use case and that it&#x27;s not a 1:1 swap out of Redis or Postgres.</div><br/></div></div><div id="41648342" class="c"><input type="checkbox" id="c-41648342" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41646518">parent</a><span>|</span><a href="#41646597">prev</a><span>|</span><a href="#41650753">next</a><span>|</span><label class="collapse" for="c-41648342">[-]</label><label class="expand" for="c-41648342">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Other alternatives may use static files loaded in-memory, but I&#x27;m guessing the data is more than you&#x27;d want to keep in memory in this case, making SQLite a nice alternative.<p>Ultimately a RDBMS like SQLite is what you&#x27;d get if you start with loading static files into memory and from that point onward you add the necessary and sufficient features you need to get it to work for the most common usecases. Except it&#x27;s rock solid, very performant, and exceptionally tested out.</div><br/></div></div></div></div><div id="41650753" class="c"><input type="checkbox" id="c-41650753" checked=""/><div class="controls bullet"><span class="by">favorited</span><span>|</span><a href="#41646518">prev</a><span>|</span><a href="#41648182">next</a><span>|</span><label class="collapse" for="c-41650753">[-]</label><label class="expand" for="c-41650753">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Further, when we exhibited at RailsWorld 2023, there was a definite &quot;blood in the water&quot; vibe regarding Redis and the assumption that you&#x27;d automatically need a Redis server running alongside your Rails application.<p>I&#x27;ve only worked on one production Rails application in my career (and it did use Redis!), so I&#x27;m way out of the loop – is the ecosystem turning against Redis from a business perspective (I know there have been some license changes), or is it a YAGNI situation, or something else?<p>IIRC we used it mainly with Rescue to schedule asynchronous jobs like indexing, transcoding, etc., but it seemed like a neat tool at the time.</div><br/><div id="41651180" class="c"><input type="checkbox" id="c-41651180" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41650753">parent</a><span>|</span><a href="#41651108">next</a><span>|</span><label class="collapse" for="c-41651180">[-]</label><label class="expand" for="c-41651180">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a little YAGNI - I think the biggest driver of Redis in community was for exactly what you described aysnc jobs and the tool most folks reached for was Sidekiq.<p>The 2024 Rails community survey just came out and Redis is still listed as the top datastore that people use in their apps.<p>FWIW - we found that while many folks are _using_ Redis in their apps, they&#x27;re just using it for things like Sidekiq and not actually taking advantage of it for holding things like real time leaderboards, vector db functions, etc. so it&#x27;s a little fuzzy the actual usage.</div><br/></div></div><div id="41651108" class="c"><input type="checkbox" id="c-41651108" checked=""/><div class="controls bullet"><span class="by">x0x0</span><span>|</span><a href="#41650753">parent</a><span>|</span><a href="#41651180">prev</a><span>|</span><a href="#41648182">next</a><span>|</span><label class="collapse" for="c-41651108">[-]</label><label class="expand" for="c-41651108">[1 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s purely a simplicity thing.<p>Right now, most rails setups with decent traffic will have frontend boxes, a sql db, a KV store (redis or memcached), and a cache store pointed at the kv store, with, annoyingly, very different usage patterns than typical KV store usage, eg for maintaining api quotas or rate limiting.<p>Disk performance has gotten fast enough and SQL performance has gotten good enough that there&#x27;s a movement to drop the KV store and split the usages (for traditional KV use and also backing a cache) to the sql db and disk, respectively.  Plus new nvme disks are almost as fast and still much cheaper than ram so you can cache more.</div><br/></div></div></div></div><div id="41648182" class="c"><input type="checkbox" id="c-41648182" checked=""/><div class="controls bullet"><span class="by">keybits</span><span>|</span><a href="#41650753">prev</a><span>|</span><a href="#41647246">next</a><span>|</span><label class="collapse" for="c-41648182">[-]</label><label class="expand" for="c-41648182">[8 more]</label></div><br/><div class="children"><div class="content">People reading this might be interested in Redka - Redis re-implemented with SQLite in Go: <a href="https:&#x2F;&#x2F;github.com&#x2F;nalgeon&#x2F;redka">https:&#x2F;&#x2F;github.com&#x2F;nalgeon&#x2F;redka</a></div><br/><div id="41648460" class="c"><input type="checkbox" id="c-41648460" checked=""/><div class="controls bullet"><span class="by">meowface</span><span>|</span><a href="#41648182">parent</a><span>|</span><a href="#41651609">next</a><span>|</span><label class="collapse" for="c-41648460">[-]</label><label class="expand" for="c-41648460">[6 more]</label></div><br/><div class="children"><div class="content">Was interested and considering switching until I saw this part:<p>&gt;According to the benchmarks, Redka is several times slower than Redis.<p>Still a cool project, don&#x27;t get me wrong. But this kind of doesn&#x27;t give me any incentive to switch.</div><br/><div id="41648630" class="c"><input type="checkbox" id="c-41648630" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41648182">root</a><span>|</span><a href="#41648460">parent</a><span>|</span><a href="#41654030">next</a><span>|</span><label class="collapse" for="c-41648630">[-]</label><label class="expand" for="c-41648630">[4 more]</label></div><br/><div class="children"><div class="content">We (keydb users; it&#x27;s <i>much</i> faster than redis for all our cases) use redka for our dev machines; we develop <i>everything</i> on sqlite so there is no install of anything and in prod, we just switch to our mysql, clickhouse, redis etc cluster and it all works while having a light experience for dev.</div><br/><div id="41649353" class="c"><input type="checkbox" id="c-41649353" checked=""/><div class="controls bullet"><span class="by">mikeshi42</span><span>|</span><a href="#41648182">root</a><span>|</span><a href="#41648630">parent</a><span>|</span><a href="#41654030">next</a><span>|</span><label class="collapse" for="c-41649353">[-]</label><label class="expand" for="c-41649353">[3 more]</label></div><br/><div class="children"><div class="content">How are you guys using sqlite in dev instead of clickhouse? (Afaik there&#x27;s a good bit of difference between the two dialects so I&#x27;m surprised it&#x27;s possible without hurting dx through one compromise or another)</div><br/><div id="41651094" class="c"><input type="checkbox" id="c-41651094" checked=""/><div class="controls bullet"><span class="by">anonzzzies</span><span>|</span><a href="#41648182">root</a><span>|</span><a href="#41649353">parent</a><span>|</span><a href="#41654030">next</a><span>|</span><label class="collapse" for="c-41651094">[-]</label><label class="expand" for="c-41651094">[2 more]</label></div><br/><div class="children"><div class="content">We have our own query language based on prolog which compiles to efficient queries depending on the underlying db. We haven&#x27;t caught any cases for about half a decade where humans could do better queries. We are in a niche market so this is not a catch all solution; it is specifically for our market.</div><br/><div id="41651309" class="c"><input type="checkbox" id="c-41651309" checked=""/><div class="controls bullet"><span class="by">pdimitar</span><span>|</span><a href="#41648182">root</a><span>|</span><a href="#41651094">parent</a><span>|</span><a href="#41654030">next</a><span>|</span><label class="collapse" for="c-41651309">[-]</label><label class="expand" for="c-41651309">[1 more]</label></div><br/><div class="children"><div class="content">And I assume you have no intention of open-sourcing that query language and its compiler? Because it sounds pretty awesome...</div><br/></div></div></div></div></div></div></div></div><div id="41654030" class="c"><input type="checkbox" id="c-41654030" checked=""/><div class="controls bullet"><span class="by">eastern</span><span>|</span><a href="#41648182">root</a><span>|</span><a href="#41648460">parent</a><span>|</span><a href="#41648630">prev</a><span>|</span><a href="#41651609">next</a><span>|</span><label class="collapse" for="c-41654030">[-]</label><label class="expand" for="c-41654030">[1 more]</label></div><br/><div class="children"><div class="content">The slowness would be inevitable because the architecture combines the weak point of Redis (network stack) with the weak point of sqlite (disk access).<p>It abandons Redis&#x27; in-memory data and sqlite&#x27;s in-process speed... for what?</div><br/></div></div></div></div><div id="41651609" class="c"><input type="checkbox" id="c-41651609" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#41648182">parent</a><span>|</span><a href="#41648460">prev</a><span>|</span><a href="#41647246">next</a><span>|</span><label class="collapse" for="c-41651609">[-]</label><label class="expand" for="c-41651609">[1 more]</label></div><br/><div class="children"><div class="content">Holy cow this is amazing, I&#x27;ve been looking for something like this for years!!<p>Thanks for sharing.</div><br/></div></div></div></div><div id="41647246" class="c"><input type="checkbox" id="c-41647246" checked=""/><div class="controls bullet"><span class="by">macspoofing</span><span>|</span><a href="#41648182">prev</a><span>|</span><a href="#41652457">next</a><span>|</span><label class="collapse" for="c-41647246">[-]</label><label class="expand" for="c-41647246">[5 more]</label></div><br/><div class="children"><div class="content">&gt;While Redis is &quot;fast&quot; in comparison to traditional RDBMS, it&#x27;s still a database that you have to manage connections, memory, processes, etc., which introduces more brittleness into the stack (the opposite of what we&#x27;re trying to achieve).<p>Every database, Relational or Nonrelational, requires approximately the same level of management and maintenance when you start dealing with non-toy levels of transactions.<p>The &quot;Fast&quot; part is a little funny. If you don&#x27;t care about joins, then row inserts and retrievals are pretty damn fast too =)</div><br/><div id="41648376" class="c"><input type="checkbox" id="c-41648376" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#41647246">parent</a><span>|</span><a href="#41647800">next</a><span>|</span><label class="collapse" for="c-41648376">[-]</label><label class="expand" for="c-41648376">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The &quot;Fast&quot; part is a little funny. If you don&#x27;t care about joins, then row inserts and retrievals are pretty damn fast too =)<p>What makes SQLite exceptionally fast in a server environment is that you do not require a network call to do the query or even retrieve the data. Your remarks about joins and transactions are meaningless once you understand you&#x27;re just reading stuff from your very own local HD, which is already orders of magnitude faster.</div><br/></div></div><div id="41647800" class="c"><input type="checkbox" id="c-41647800" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#41647246">parent</a><span>|</span><a href="#41648376">prev</a><span>|</span><a href="#41647459">next</a><span>|</span><label class="collapse" for="c-41647800">[-]</label><label class="expand" for="c-41647800">[2 more]</label></div><br/><div class="children"><div class="content">SQLite has its vacuum operation, which is kind-of like running a garbage collection. Every time I read the docs about when to run a vacuum, I end up confused.<p>The last time I shipped an application on SQLite, I ended up just using a counter and vacuuming after a large number of write operations.</div><br/><div id="41648320" class="c"><input type="checkbox" id="c-41648320" checked=""/><div class="controls bullet"><span class="by">prirun</span><span>|</span><a href="#41647246">root</a><span>|</span><a href="#41647800">parent</a><span>|</span><a href="#41647459">next</a><span>|</span><label class="collapse" for="c-41648320">[-]</label><label class="expand" for="c-41648320">[1 more]</label></div><br/><div class="children"><div class="content">HashBackup author here, been using SQLite for about 15 years.<p>Doing a vacuum after a large number of <i>deletes</i> might make sense.  The only real purpose of vacuum IMO is to recover free space from a database.  Vacuum <i>may</i> also optimize certain access patterns for a short while, though I have never tested this, and it would be highly dependent on the queries used.  If fragmentation is a bigger concern for you than recovering free space, you can also compute the fragmentation to decide whether to vacuum by using the dbstat table:<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;dbstat.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;dbstat.html</a><p>Then again, computing this will require accessing most of the database pages I&#x27;m guessing, so might take nearly as long as a vacuum.  The other gotcha here is that just because db pages appear to be sequential in a file doesn&#x27;t mean they are sequential on a physical drive, though filesystems do strive for that.<p>SQLite has pragma commands to tell you the number of total and free db pages.  When the percentage of free pages is greater than x% and it&#x27;s a convenient time, do a vacuum.  For a highly volatile db, you can add a table containing this percentage, update it every day, and make your decision based on an average, but IMO it&#x27;s easier just to check for more than 50% free (or whatever) and do the vacuum.<p>Vacuums used to be (circa 2019) pretty slow operations, but the SQLite team has sped them up greatly since then.  Vacuuming a 3GB SQLite db on a SSD takes less than a minute these days.  That&#x27;s with the db 100% full; with only 50% used pages, it would be considerably faster.<p>Vacuums are done in a statement transaction, so you don&#x27;t have to worry about a &quot;half vacuum that runs out of disk space&quot; screwing up your database.</div><br/></div></div></div></div></div></div><div id="41652457" class="c"><input type="checkbox" id="c-41652457" checked=""/><div class="controls bullet"><span class="by">tony-allan</span><span>|</span><a href="#41647246">prev</a><span>|</span><a href="#41651142">next</a><span>|</span><label class="collapse" for="c-41652457">[-]</label><label class="expand" for="c-41652457">[1 more]</label></div><br/><div class="children"><div class="content">Best quote:<p>&quot;SQLite does not compete with client&#x2F;server databases. SQLite competes with fopen().&quot;</div><br/></div></div><div id="41651142" class="c"><input type="checkbox" id="c-41651142" checked=""/><div class="controls bullet"><span class="by">doubleorseven</span><span>|</span><a href="#41652457">prev</a><span>|</span><a href="#41653462">next</a><span>|</span><label class="collapse" for="c-41651142">[-]</label><label class="expand" for="c-41651142">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Benchmarking is a dark art of deceiving yourself with highly precise numbers<p>.</div><br/></div></div><div id="41653462" class="c"><input type="checkbox" id="c-41653462" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#41651142">prev</a><span>|</span><a href="#41648106">next</a><span>|</span><label class="collapse" for="c-41653462">[-]</label><label class="expand" for="c-41653462">[1 more]</label></div><br/><div class="children"><div class="content">The dataset is 1.2 million entries, which looks big, but really is not that much.<p>If this is uncompressed IPv4 addresses, it&#x27;s just 4.8 MB; and with some trival compression (like a 2-level trie), it could be about 2x smaller. Even if it&#x27;s uncompressed IPv6, that&#x27;s still just 32 megabytes.<p>Does Ruby support mmap? If yes, I&#x27;d suggest direct IP list. Lots of fun to write, big speedup over sqlite, and zero startup time.</div><br/></div></div><div id="41648106" class="c"><input type="checkbox" id="c-41648106" checked=""/><div class="controls bullet"><span class="by">codingbot3000</span><span>|</span><a href="#41653462">prev</a><span>|</span><a href="#41654710">next</a><span>|</span><label class="collapse" for="c-41648106">[-]</label><label class="expand" for="c-41648106">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s posts like this explaining architecture decisions in detail I am reading HN for. Thank you!</div><br/><div id="41649428" class="c"><input type="checkbox" id="c-41649428" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41648106">parent</a><span>|</span><a href="#41654710">next</a><span>|</span><label class="collapse" for="c-41649428">[-]</label><label class="expand" for="c-41649428">[1 more]</label></div><br/><div class="children"><div class="content">(author) - It&#x27;s genuinely delightful to know that you liked it.</div><br/></div></div></div></div><div id="41654710" class="c"><input type="checkbox" id="c-41654710" checked=""/><div class="controls bullet"><span class="by">tmaier</span><span>|</span><a href="#41648106">prev</a><span>|</span><a href="#41651583">next</a><span>|</span><label class="collapse" for="c-41654710">[-]</label><label class="expand" for="c-41654710">[1 more]</label></div><br/><div class="children"><div class="content">I visited this site from safari on iOS while being in a Marriott hotel. I am blocked. So the WAF works.</div><br/></div></div><div id="41651583" class="c"><input type="checkbox" id="c-41651583" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#41654710">prev</a><span>|</span><a href="#41653755">next</a><span>|</span><label class="collapse" for="c-41651583">[-]</label><label class="expand" for="c-41651583">[4 more]</label></div><br/><div class="children"><div class="content">I really wish there were a compatibility layer that could sit on top of SQLite and make it pretend to be redis, so we could switch more things to use SQLite. It doesn&#x27;t even need to satisfy all the distributed systems guarantess or even implement proper pub&#x2F;sub, it could just do everything with polling and a single event loop. It would be great for smaller projects that want to run something like celery or any app that depends on redis without needing to install redis.</div><br/><div id="41654477" class="c"><input type="checkbox" id="c-41654477" checked=""/><div class="controls bullet"><span class="by">sundbry</span><span>|</span><a href="#41651583">parent</a><span>|</span><a href="#41651595">next</a><span>|</span><label class="collapse" for="c-41654477">[-]</label><label class="expand" for="c-41654477">[1 more]</label></div><br/><div class="children"><div class="content">You can use smoothmq (SQS over sqlite) for a celery backend: <a href="https:&#x2F;&#x2F;smoothmq.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;smoothmq.com&#x2F;</a></div><br/></div></div><div id="41651595" class="c"><input type="checkbox" id="c-41651595" checked=""/><div class="controls bullet"><span class="by">m_sahaf</span><span>|</span><a href="#41651583">parent</a><span>|</span><a href="#41654477">prev</a><span>|</span><a href="#41653755">next</a><span>|</span><label class="collapse" for="c-41651595">[-]</label><label class="expand" for="c-41651595">[2 more]</label></div><br/><div class="children"><div class="content">There&#x27;s Redka: <a href="https:&#x2F;&#x2F;github.com&#x2F;nalgeon&#x2F;redka&#x2F;">https:&#x2F;&#x2F;github.com&#x2F;nalgeon&#x2F;redka&#x2F;</a></div><br/><div id="41651615" class="c"><input type="checkbox" id="c-41651615" checked=""/><div class="controls bullet"><span class="by">nikisweeting</span><span>|</span><a href="#41651583">root</a><span>|</span><a href="#41651595">parent</a><span>|</span><a href="#41653755">next</a><span>|</span><label class="collapse" for="c-41651615">[-]</label><label class="expand" for="c-41651615">[1 more]</label></div><br/><div class="children"><div class="content">Wow amazing, thank you so much! I&#x27;ve spent many hours over the years looking for a project like this, but it makes sense that I haven&#x27;t seen this yet as it&#x27;s only 6mo old.</div><br/></div></div></div></div></div></div><div id="41653755" class="c"><input type="checkbox" id="c-41653755" checked=""/><div class="controls bullet"><span class="by">prirun</span><span>|</span><a href="#41651583">prev</a><span>|</span><a href="#41646870">next</a><span>|</span><label class="collapse" for="c-41653755">[-]</label><label class="expand" for="c-41653755">[2 more]</label></div><br/><div class="children"><div class="content">Might want to check into this to do your SQLite db copies:<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;draft&#x2F;rsync.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;draft&#x2F;rsync.html</a></div><br/><div id="41654074" class="c"><input type="checkbox" id="c-41654074" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41653755">parent</a><span>|</span><a href="#41646870">next</a><span>|</span><label class="collapse" for="c-41654074">[-]</label><label class="expand" for="c-41654074">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s interesting, but it probably wouldn&#x27;t work for our use case as we&#x27;d need to ship that binary utility to the platforms (unless I&#x27;m missing something).</div><br/></div></div></div></div><div id="41646870" class="c"><input type="checkbox" id="c-41646870" checked=""/><div class="controls bullet"><span class="by">dangoodmanUT</span><span>|</span><a href="#41653755">prev</a><span>|</span><a href="#41645534">next</a><span>|</span><label class="collapse" for="c-41646870">[-]</label><label class="expand" for="c-41646870">[6 more]</label></div><br/><div class="children"><div class="content">I have a hard time believing that Redis local was beat by SQLite local unless the workload was poorly fit for Redis structures, or the integration code wasn&#x27;t well written.<p>But always happy to see a discovery of a better solution. I agree removing the network is a win.</div><br/><div id="41648109" class="c"><input type="checkbox" id="c-41648109" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41646870">parent</a><span>|</span><a href="#41646952">next</a><span>|</span><label class="collapse" for="c-41648109">[-]</label><label class="expand" for="c-41648109">[2 more]</label></div><br/><div class="children"><div class="content">I do agree it is somewhat fishy of the large performance difference not being explained by comparatively fundamentally poor data access patterns.<p>However, Redis runs as an out of process server with marshaling and unmarshaling of data across sockets. SQLite is in process and with a prepared query is basically one library call to a purpose built data access VM. So I’m not sure why it would be hard to believe this cache and TLB friendly setup can beat Redis.</div><br/><div id="41651128" class="c"><input type="checkbox" id="c-41651128" checked=""/><div class="controls bullet"><span class="by">mrl5</span><span>|</span><a href="#41646870">root</a><span>|</span><a href="#41648109">parent</a><span>|</span><a href="#41646952">next</a><span>|</span><label class="collapse" for="c-41651128">[-]</label><label class="expand" for="c-41651128">[1 more]</label></div><br/><div class="children"><div class="content">Thank you. First explanation what might be the root cause :)</div><br/></div></div></div></div><div id="41646952" class="c"><input type="checkbox" id="c-41646952" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41646870">parent</a><span>|</span><a href="#41648109">prev</a><span>|</span><a href="#41652905">next</a><span>|</span><label class="collapse" for="c-41646952">[-]</label><label class="expand" for="c-41646952">[2 more]</label></div><br/><div class="children"><div class="content">In Redis, the data is a sorted-set that we forced into being lexicographically ordered by setting all the scores to 0. We went through a lot of iterations of it and to be clear it&#x27;s not _slow_ it&#x27;s just not as fast as essentially `fopen`<p>1 - Redis sorted sets - <a href="https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;latest&#x2F;develop&#x2F;data-types&#x2F;sorted-sets&#x2F;" rel="nofollow">https:&#x2F;&#x2F;redis.io&#x2F;docs&#x2F;latest&#x2F;develop&#x2F;data-types&#x2F;sorted-sets&#x2F;</a></div><br/></div></div><div id="41652905" class="c"><input type="checkbox" id="c-41652905" checked=""/><div class="controls bullet"><span class="by">cynicalsecurity</span><span>|</span><a href="#41646870">parent</a><span>|</span><a href="#41646952">prev</a><span>|</span><a href="#41645534">next</a><span>|</span><label class="collapse" for="c-41652905">[-]</label><label class="expand" for="c-41652905">[1 more]</label></div><br/><div class="children"><div class="content">Just look at their use case. The have to store a large amount of logs of web-sites visitors or bots. Of course Redis is a very bad choice, because most servers don&#x27;t have that much amount of memory. It&#x27;s really useless to store logs in the RAM.</div><br/></div></div></div></div><div id="41645534" class="c"><input type="checkbox" id="c-41645534" checked=""/><div class="controls bullet"><span class="by">ten13</span><span>|</span><a href="#41646870">prev</a><span>|</span><a href="#41645247">next</a><span>|</span><label class="collapse" for="c-41645534">[-]</label><label class="expand" for="c-41645534">[2 more]</label></div><br/><div class="children"><div class="content">Nice post! I’m curious how the SQLite-per-instance model works for rate-limiting in the scale-out scenario. I took a cursory glance at the docs but nothing jumped out at me about how it works.</div><br/><div id="41646580" class="c"><input type="checkbox" id="c-41646580" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41645534">parent</a><span>|</span><a href="#41645247">next</a><span>|</span><label class="collapse" for="c-41646580">[-]</label><label class="expand" for="c-41646580">[1 more]</label></div><br/><div class="children"><div class="content">Post author and Wafris co-founder here. Conceptually &quot;rate limiting to prevent abuse&quot; (what we&#x27;re doing here) and &quot;rate limiting for API throttling&quot; have different levels for tolerance.<p>With that in mind, it&#x27;s setting higher levels of limiting and doing the math to push that out over many machines&#x2F;instances&#x2F;dynos. That helps for things like scraping prevention, etc.<p>For issues like credential stuffing attacks, you&#x27;d want a lower limit but also coupled with mitigations like IP bans, IP reputation, etc. to deal with underlying issue.</div><br/></div></div></div></div><div id="41645247" class="c"><input type="checkbox" id="c-41645247" checked=""/><div class="controls bullet"><span class="by">rini17</span><span>|</span><a href="#41645534">prev</a><span>|</span><a href="#41652723">next</a><span>|</span><label class="collapse" for="c-41645247">[-]</label><label class="expand" for="c-41645247">[2 more]</label></div><br/><div class="children"><div class="content">If you need writes, can just use second sqlite database.</div><br/><div id="41647483" class="c"><input type="checkbox" id="c-41647483" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#41645247">parent</a><span>|</span><a href="#41652723">next</a><span>|</span><label class="collapse" for="c-41647483">[-]</label><label class="expand" for="c-41647483">[1 more]</label></div><br/><div class="children"><div class="content">It would be a small command log (a batch of requested changes from that client) with a completely different schema from the main database.<p>But if we are sending deltas to a central server performance isn&#x27;t critical: there can be a traditional web service to call, without uploading databases.</div><br/></div></div></div></div><div id="41652723" class="c"><input type="checkbox" id="c-41652723" checked=""/><div class="controls bullet"><span class="by">jszymborski</span><span>|</span><a href="#41645247">prev</a><span>|</span><a href="#41646979">next</a><span>|</span><label class="collapse" for="c-41652723">[-]</label><label class="expand" for="c-41652723">[1 more]</label></div><br/><div class="children"><div class="content">A bit strange they replaced Redis with SQLite rather than LMDB or RocksDB which are key-value stores</div><br/></div></div><div id="41646979" class="c"><input type="checkbox" id="c-41646979" checked=""/><div class="controls bullet"><span class="by">masfoobar</span><span>|</span><a href="#41652723">prev</a><span>|</span><a href="#41647836">next</a><span>|</span><label class="collapse" for="c-41646979">[-]</label><label class="expand" for="c-41646979">[1 more]</label></div><br/><div class="children"><div class="content">NICE!<p>I have not used Redis myself, but have been using Sqlite more and more over the years.. and found a perfect application I wrote using Sqlite under the hood.<p>Powerful and convienient database system!</div><br/></div></div><div id="41647836" class="c"><input type="checkbox" id="c-41647836" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#41646979">prev</a><span>|</span><a href="#41647230">next</a><span>|</span><label class="collapse" for="c-41647836">[-]</label><label class="expand" for="c-41647836">[4 more]</label></div><br/><div class="children"><div class="content">How large is the SQLite database you&#x27;re syncing?<p>Is it even &quot;worth&quot; using SQLite at this point? What about a configuration file, and straight-up code that works with in-memory data structures?</div><br/><div id="41647939" class="c"><input type="checkbox" id="c-41647939" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41647836">parent</a><span>|</span><a href="#41648637">next</a><span>|</span><label class="collapse" for="c-41647939">[-]</label><label class="expand" for="c-41647939">[1 more]</label></div><br/><div class="children"><div class="content">This is something we seriously considered. The SQLite dbs are several hundred megabytes in size (millions of IP ranges) so while it would be technically doable to send around rules files as JSON or something more specifically suited there&#x27;s still a number of wins that SQLite gives us:<p>- Really strong support across multiple platforms (we have clients for most of the major web frameworks)<p>- Efficiency, sure we have lots of RAM on servers nowdays but on some platforms it&#x27;s constrained and if you don&#x27;t have to burn it, we&#x27;d just rather not.<p>- When we started mapping this out, we ended up with something that looked like a JSON format that we were adding indexes to....and then we were re-inventing SQLite.</div><br/></div></div><div id="41648637" class="c"><input type="checkbox" id="c-41648637" checked=""/><div class="controls bullet"><span class="by">wormlord</span><span>|</span><a href="#41647836">parent</a><span>|</span><a href="#41647939">prev</a><span>|</span><a href="#41647230">next</a><span>|</span><label class="collapse" for="c-41648637">[-]</label><label class="expand" for="c-41648637">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know how it works exactly, but I believe you can have a fully in-memory SQLite database. Bun&#x27;s sqlite library and SqlAlchemy both let you operate on in-memory SQLite db&#x27;s which you can then write to disk.<p>Edit: reading the docs it looks like it operates the same way, just reading sections of the db from memory instead of disk<p><a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;atomiccommit.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;atomiccommit.html</a></div><br/><div id="41654058" class="c"><input type="checkbox" id="c-41654058" checked=""/><div class="controls bullet"><span class="by">gwbas1c</span><span>|</span><a href="#41647836">root</a><span>|</span><a href="#41648637">parent</a><span>|</span><a href="#41647230">next</a><span>|</span><label class="collapse" for="c-41654058">[-]</label><label class="expand" for="c-41654058">[1 more]</label></div><br/><div class="children"><div class="content">You can, but that&#x27;s not the point. I basically asked if they should (gasp) write code that did the lookup.<p>See the other response from the article&#x27;s author.</div><br/></div></div></div></div></div></div><div id="41647230" class="c"><input type="checkbox" id="c-41647230" checked=""/><div class="controls bullet"><span class="by">ragu4u</span><span>|</span><a href="#41647836">prev</a><span>|</span><a href="#41647454">next</a><span>|</span><label class="collapse" for="c-41647230">[-]</label><label class="expand" for="c-41647230">[3 more]</label></div><br/><div class="children"><div class="content">So is the sqlite file on disk or in memory somehow?</div><br/><div id="41647393" class="c"><input type="checkbox" id="c-41647393" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41647230">parent</a><span>|</span><a href="#41648329">next</a><span>|</span><label class="collapse" for="c-41647393">[-]</label><label class="expand" for="c-41647393">[1 more]</label></div><br/><div class="children"><div class="content">The sqlite db is on disk sync&#x27;d down to the clients from our service.<p>The client is responsible for checking with our servers and, if rule updates are found, downloading a new database file. To avoid locking and contention issues, these are each uniquely named, and which DB is &quot;current&quot; is just updated.<p>Note: This is only in &quot;managed&quot; mode. If you&#x27;d rather, you can distribute a SQLite database of the rules alongside your app.</div><br/></div></div><div id="41648329" class="c"><input type="checkbox" id="c-41648329" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#41647230">parent</a><span>|</span><a href="#41647393">prev</a><span>|</span><a href="#41647454">next</a><span>|</span><label class="collapse" for="c-41648329">[-]</label><label class="expand" for="c-41648329">[1 more]</label></div><br/><div class="children"><div class="content">&gt; on disk or in memory somehow?<p>Due to the magic of the page cache, the answer to that can be &quot;both&quot;.<p>If the sqlite database is being read often and not being written, the page cache will be valid and reads will pretty much never go to the filesystme.</div><br/></div></div></div></div><div id="41647454" class="c"><input type="checkbox" id="c-41647454" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#41647230">prev</a><span>|</span><a href="#41652842">next</a><span>|</span><label class="collapse" for="c-41647454">[-]</label><label class="expand" for="c-41647454">[5 more]</label></div><br/><div class="children"><div class="content">Wonder if they had indexes on their SQLite tables?<p>Not seeing a mention of that in the article.</div><br/><div id="41647538" class="c"><input type="checkbox" id="c-41647538" checked=""/><div class="controls bullet"><span class="by">michaelbuckbee</span><span>|</span><a href="#41647454">parent</a><span>|</span><a href="#41652842">next</a><span>|</span><label class="collapse" for="c-41647538">[-]</label><label class="expand" for="c-41647538">[4 more]</label></div><br/><div class="children"><div class="content">The answer is &quot;yes.&quot; We had indexes - but it&#x27;s also a little more complicated than that, as we&#x27;re storing IPv4 and IPv6 ranges in a single table in a format _designed_ to be indexed a particular way.<p>In the article, we refer to this as &quot;decimal lexical&quot; formatting, where we&#x27;re taking the IPs and making them integers but actually treating them as strings. We&#x27;re doing this in both Redis with sorted sets and then in a single table in SQLite.<p>I was going to explain all this in the article, but it was too long already, so it will be a future blog post.</div><br/><div id="41647873" class="c"><input type="checkbox" id="c-41647873" checked=""/><div class="controls bullet"><span class="by">filleokus</span><span>|</span><a href="#41647454">root</a><span>|</span><a href="#41647538">parent</a><span>|</span><a href="#41648198">next</a><span>|</span><label class="collapse" for="c-41647873">[-]</label><label class="expand" for="c-41647873">[1 more]</label></div><br/><div class="children"><div class="content">Really great article and I really appreciate seeing this &quot;flavour&quot; of &quot;distributed&quot; sqlite, think it can be useful in many no&#x2F;low-write scenarios.<p>But about the formatting of the data, is it completely inherent to the rest of the system &#x2F; unchangeable? Spontaneously I would have guessed that for example a bitfield in redis would have performed better. Did you test any other formattings?</div><br/></div></div><div id="41648198" class="c"><input type="checkbox" id="c-41648198" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#41647454">root</a><span>|</span><a href="#41647538">parent</a><span>|</span><a href="#41647873">prev</a><span>|</span><a href="#41648160">next</a><span>|</span><label class="collapse" for="c-41648198">[-]</label><label class="expand" for="c-41648198">[1 more]</label></div><br/><div class="children"><div class="content">Curious, what is the advantage of decimal? Why not base-64 or some larger and power of 2 base?</div><br/></div></div><div id="41648160" class="c"><input type="checkbox" id="c-41648160" checked=""/><div class="controls bullet"><span class="by">a12b</span><span>|</span><a href="#41647454">root</a><span>|</span><a href="#41647538">parent</a><span>|</span><a href="#41648198">prev</a><span>|</span><a href="#41652842">next</a><span>|</span><label class="collapse" for="c-41648160">[-]</label><label class="expand" for="c-41648160">[1 more]</label></div><br/><div class="children"><div class="content">You should definitely write an article with all tricks you used to make it fast!</div><br/></div></div></div></div></div></div><div id="41652842" class="c"><input type="checkbox" id="c-41652842" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#41647454">prev</a><span>|</span><a href="#41650046">next</a><span>|</span><label class="collapse" for="c-41652842">[-]</label><label class="expand" for="c-41652842">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Even if the SQLite performance was significantly worse (like 2x worse) in the benchmark, it would still probably be faster in the &quot;real world&quot; because of network latency, even to a Redis that was in the same data center&#x2F;region<p>... Why not run redis on localhost?</div><br/></div></div><div id="41650046" class="c"><input type="checkbox" id="c-41650046" checked=""/><div class="controls bullet"><span class="by">tiffanyh</span><span>|</span><a href="#41652842">prev</a><span>|</span><label class="collapse" for="c-41650046">[-]</label><label class="expand" for="c-41650046">[1 more]</label></div><br/><div class="children"><div class="content">FoundationDB<p>Isn’t “redis to sqlite” effectively what foundationDB?<p><a href="https:&#x2F;&#x2F;www.foundationdb.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.foundationdb.org&#x2F;</a></div><br/></div></div></div></div></div></div></div></body></html>