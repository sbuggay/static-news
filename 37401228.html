<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1694077262812" as="style"/><link rel="stylesheet" href="styles.css?v=1694077262812"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantamagazine.org/alan-turing-and-the-power-of-negative-thinking-20230905/">Proofs based on diagonalization help reveal the limits of algorithms</a> <span class="domain">(<a href="https://www.quantamagazine.org">www.quantamagazine.org</a>)</span></div><div class="subtext"><span>nsoonhui</span> | <span>29 comments</span></div><br/><div><div id="37414169" class="c"><input type="checkbox" id="c-37414169" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#37414878">next</a><span>|</span><label class="collapse" for="c-37414169">[-]</label><label class="expand" for="c-37414169">[11 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a nice video that digs into the general structure of diagonalization arguments:
<a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dwNxVpbEVcc">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=dwNxVpbEVcc</a><p>It&#x27;s a really neat way to see a shared core between seemingly-separate topics:<p><pre><code>    - Gödel&#x27;s Incompleteness Theorems,
    - Cantor&#x27;s Theorem,
    - Russell&#x27;s Paradox,
    - The Halting Problem,
    - The Y Combinator!,
    - etc.</code></pre></div><br/><div id="37415022" class="c"><input type="checkbox" id="c-37415022" checked=""/><div class="controls bullet"><span class="by">ballenf</span><span>|</span><a href="#37414169">parent</a><span>|</span><a href="#37414642">next</a><span>|</span><label class="collapse" for="c-37415022">[-]</label><label class="expand" for="c-37415022">[9 more]</label></div><br/><div class="children"><div class="content">I have a problem with the diagonalization, but I&#x27;m more of a math fan so please forgive my ignorance.<p>The proof of uncountability of real numbers starts with a process of enumerating this infinite list of infinitely long binary numbers. Then says that we construct a number that can&#x27;t be on them by flipping bits the down the diagonal.<p>But hasn&#x27;t this concept already kind of mixed domains? The enumeration was describing a process, but the diagonal flipping move seems to assume or require that the enumeration is complete or at least paused. How could the diagonal construction ever finish to allow a &quot;check&quot; of whether the result of that process is actually on the list.<p>Obviously at any point in time it won&#x27;t be, but aren&#x27;t we just kind of proving that we can construct a number that isn&#x27;t on the list yet? And the first process would certainly eventually get to our constructed number?<p>The diagonal just seems like a shortcut to a number that we know the first process hasn&#x27;t gotten to yet?<p>I just don&#x27;t get how we conclude that Integers are countable and Reals are Uncountable from this proof, even though its obvious in an intuitive sense that Reals have to be much &quot;larger&quot;.</div><br/><div id="37415441" class="c"><input type="checkbox" id="c-37415441" checked=""/><div class="controls bullet"><span class="by">owalt</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415022">parent</a><span>|</span><a href="#37416080">next</a><span>|</span><label class="collapse" for="c-37415441">[-]</label><label class="expand" for="c-37415441">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t quite understand your main concern, but it seems others did and have answered. To elaborate on why Cantor&#x27;s argument doesn&#x27;t go through for the integers:<p>Assume you had a list of every integer. To begin with, you couldn&#x27;t start flipping bits from the left since integers don&#x27;t start from the left. You could however imagine them having a sequence of 0s extending infinitely to the left, e.g. 101 = ...00000101. If you did that, the diagonal argument is possible to perform only starting from the rightmost digit, and you do end up with some string of numbers.<p>The problem is this: If you do walk right-to-left flipping bits in such a list, the integer case has an &quot;out&quot;. You do end up with a string of 0s and 1s, but by assumption it can&#x27;t have 0s extending infinitely to the left because then it would have been on the list. In other words, the thing you end up with never has its &quot;final&quot; 1, and so what you end up with isn&#x27;t an integer.<p>This is really the crux of the argument: Not every string of 0s and 1s actually represents an integer. However, put any string of 0s and 1s after the radix point (&quot;decimal point&quot;) and that does represent a real number. So what you construct in the real version of the argument really is a real number not on the list (i.e. a contradiction).<p>It&#x27;s instructive to do the same thought experiment with an imaginary list of rational numbers written out as decimals and see why the diagonal argument fails in that case too.<p>Now I described the above as a kind of procedure (&quot;walk right-to-left&quot;) but that&#x27;s really just for convenience. There isn&#x27;t any actual iteration going on.</div><br/><div id="37416032" class="c"><input type="checkbox" id="c-37416032" checked=""/><div class="controls bullet"><span class="by">danielheath</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415441">parent</a><span>|</span><a href="#37416080">next</a><span>|</span><label class="collapse" for="c-37416032">[-]</label><label class="expand" for="c-37416032">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Not every string of 0s and 1s actually represents an integer.<p>Is that to say that only the finite ones are? Since an infinitely long string that starts with 1 is infinite in size?<p>Otherwise I can’t make sense of this statement.</div><br/><div id="37416217" class="c"><input type="checkbox" id="c-37416217" checked=""/><div class="controls bullet"><span class="by">owalt</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37416032">parent</a><span>|</span><a href="#37416080">next</a><span>|</span><label class="collapse" for="c-37416217">[-]</label><label class="expand" for="c-37416217">[1 more]</label></div><br/><div class="children"><div class="content">Yes, for instance ...101010 (the pattern 10 repeated infinitely) isn&#x27;t an integer.<p>It&#x27;s maybe easier to think of the argument as working on sequences: From a sequence (x_0, x_1, x_2, ...) with each x_n a binary digit (i.e. 0 or 1) you can always construct a real number x = Sum(x_n &#x2F; 2^n, n = 0, 1, 2, ...).<p>The integer you&#x27;d want to construct from such a sequence would be Sum(x_n * 2^n, n = 0, 1, 2, ...), but this only works if there&#x27;s some N such that x_n = 0 for all n &gt; N. Otherwise you would have an &quot;infinite integer&quot; (whatever that means). Valid positive integers are all on the form Sum(x_n * 2^n, n = 0, 1, 2, ..., N), i.e. the binary expansion is finite.<p>The subtlety of the diagonal argument (why it works for reals but not for integers&#x2F;rationals) is that while it always produces _some_ string of digits, only the real numbers are defined such that the string of digits is itself always a real number. In the integer&#x2F;rational case, you can construct a number &quot;outside&quot; the set you started from. (In fact you always do if the original list really was of all integers&#x2F;rationals. Given any enumeration of the rationals, the diagonal argument can actually be used constructively to produce an irrational number.)</div><br/></div></div></div></div></div></div><div id="37416080" class="c"><input type="checkbox" id="c-37416080" checked=""/><div class="controls bullet"><span class="by">systoll</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415022">parent</a><span>|</span><a href="#37415441">prev</a><span>|</span><a href="#37415073">next</a><span>|</span><label class="collapse" for="c-37416080">[-]</label><label class="expand" for="c-37416080">[1 more]</label></div><br/><div class="children"><div class="content">A set is countable if, and only if, there is a bijection between it and the natural numbers — ie if there can be an enumeration.<p>Cantor is doing a proof by contradiction. He’s assuming that the complete enumeration exists <i>precisely because</i> it is wrong.<p>If you object to making that assumption, you’re just agreeing with Cantor’s conclusion before he’s made the argument.</div><br/></div></div><div id="37415073" class="c"><input type="checkbox" id="c-37415073" checked=""/><div class="controls bullet"><span class="by">vgatherps</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415022">parent</a><span>|</span><a href="#37416080">prev</a><span>|</span><a href="#37415174">next</a><span>|</span><label class="collapse" for="c-37415073">[-]</label><label class="expand" for="c-37415073">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The proof of uncountability of real numbers starts with a process of enumerating this infinite list of infinitely long binary numbers.<p>&gt; How could the diagonal construction ever finish to allow a &quot;check&quot; of whether the result of that process is actually on the list.<p>&gt; The diagonal just seems like a shortcut to a number that we know the first process hasn&#x27;t gotten to yet?<p>I think you are mixing up the enumeration of the (hypothetically countable) reals with the existance of said set of reals, and viewing the construction of the counterexample as an actual process that involves programmatically iterating over the list instead of a description of how the digits of said new real number is created.<p>There is no pause or setp-by-step of this iteration that&#x27;s required, since it&#x27;s only telling you that the i&#x27;th digit of the counterexample will be distinct from the i&#x27;th digit of the i&#x27;th number (thereby creating a real not in your countable set, since you have created a number outside of your 1-1 mapping onto the natural numbers).</div><br/></div></div><div id="37415174" class="c"><input type="checkbox" id="c-37415174" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415022">parent</a><span>|</span><a href="#37415073">prev</a><span>|</span><a href="#37415667">next</a><span>|</span><label class="collapse" for="c-37415174">[-]</label><label class="expand" for="c-37415174">[2 more]</label></div><br/><div class="children"><div class="content">You are confused about the concept of countability and finiteness. The enumeration that you mention requires that a set be countable, not that it is finite. So it&#x27;s wrong to somehow require the enumeration to finish.<p>Countable sets can be finite or infinite. Most interesting countable sets are infinite. The enumeration then means a bijection with the natural numbers. Your definition of enumeration seems to require it to &quot;complete&quot; which is incorrect.<p>(I put &quot;complete&quot; in quotes because that&#x27;s the word you used, but I don&#x27;t want you to further confuse that with the completeness of real numbers which is a whole another thing.)</div><br/><div id="37416319" class="c"><input type="checkbox" id="c-37416319" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415174">parent</a><span>|</span><a href="#37415667">next</a><span>|</span><label class="collapse" for="c-37416319">[-]</label><label class="expand" for="c-37416319">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a bit like saying 0,1... isn&#x27;t a real number because you couldn&#x27;t type all the 1s.</div><br/></div></div></div></div><div id="37415667" class="c"><input type="checkbox" id="c-37415667" checked=""/><div class="controls bullet"><span class="by">Scarblac</span><span>|</span><a href="#37414169">root</a><span>|</span><a href="#37415022">parent</a><span>|</span><a href="#37415174">prev</a><span>|</span><a href="#37414642">next</a><span>|</span><label class="collapse" for="c-37415667">[-]</label><label class="expand" for="c-37415667">[1 more]</label></div><br/><div class="children"><div class="content">Thinking like that no infinite set can be countable, because &quot;at any one point in time&quot; you haven&#x27;t completely enumerated it yet. That&#x27;s not how thinking about infinite sets works.</div><br/></div></div></div></div><div id="37414642" class="c"><input type="checkbox" id="c-37414642" checked=""/><div class="controls bullet"><span class="by">3abiton</span><span>|</span><a href="#37414169">parent</a><span>|</span><a href="#37415022">prev</a><span>|</span><a href="#37414878">next</a><span>|</span><label class="collapse" for="c-37414642">[-]</label><label class="expand" for="c-37414642">[1 more]</label></div><br/><div class="children"><div class="content">Great video, thanks for sharing</div><br/></div></div></div></div><div id="37414878" class="c"><input type="checkbox" id="c-37414878" checked=""/><div class="controls bullet"><span class="by">ballenf</span><span>|</span><a href="#37414169">prev</a><span>|</span><a href="#37413376">next</a><span>|</span><label class="collapse" for="c-37414878">[-]</label><label class="expand" for="c-37414878">[5 more]</label></div><br/><div class="children"><div class="content">Can someone explain this part of Turing&#x27;s proof:<p>&gt; ... we can define an uncomputable problem like the one in Turing’s proof: “Given an input string representing the code of an algorithm, output 1 if that algorithm outputs 0 when its own code is the input; otherwise, output 0.” Every algorithm that tries to solve this problem will produce the wrong output on at least one input — namely, the input corresponding to its own code.<p>Why is this impossible?<p>As I see it, there are two algorithms intermixed in that statement:<p>1. Code that emits a 0 if the input is it&#x27;s own code<p>2. Code that emits a 1 if it receives as input code that behaves according to Algo 1.<p>Feel like I&#x27;m missing something basic or obvious!</div><br/><div id="37414967" class="c"><input type="checkbox" id="c-37414967" checked=""/><div class="controls bullet"><span class="by">ghkbrew</span><span>|</span><a href="#37414878">parent</a><span>|</span><a href="#37414957">next</a><span>|</span><label class="collapse" for="c-37414967">[-]</label><label class="expand" for="c-37414967">[2 more]</label></div><br/><div class="children"><div class="content">Imagine you have an code which does #2. Now give it itself as an argument. What is the result? If it emits 0 then it&#x27;s behaving according to #1, then because we assumed it satisfies #2 it must emit 1, a contradiction. Similarly it can&#x27;t emit 1.<p>Thus it is impossible to have an algorithm which solves #2 for all inputs, because it must fail on at least one input (itself)</div><br/></div></div><div id="37414957" class="c"><input type="checkbox" id="c-37414957" checked=""/><div class="controls bullet"><span class="by">lsy</span><span>|</span><a href="#37414878">parent</a><span>|</span><a href="#37414967">prev</a><span>|</span><a href="#37413376">next</a><span>|</span><label class="collapse" for="c-37414957">[-]</label><label class="expand" for="c-37414957">[2 more]</label></div><br/><div class="children"><div class="content">def unc(algstr) { if (algstr(algstr) == 0) return 1 else return 0 }<p>unc(unc) -&gt; what does this return?</div><br/><div id="37414989" class="c"><input type="checkbox" id="c-37414989" checked=""/><div class="controls bullet"><span class="by">hyperhello</span><span>|</span><a href="#37414878">root</a><span>|</span><a href="#37414957">parent</a><span>|</span><a href="#37413376">next</a><span>|</span><label class="collapse" for="c-37414989">[-]</label><label class="expand" for="c-37414989">[1 more]</label></div><br/><div class="children"><div class="content">Stack overflow exception, since it calls unc(unc) from itself.</div><br/></div></div></div></div></div></div><div id="37413376" class="c"><input type="checkbox" id="c-37413376" checked=""/><div class="controls bullet"><span class="by">est31</span><span>|</span><a href="#37414878">prev</a><span>|</span><a href="#37413672">next</a><span>|</span><label class="collapse" for="c-37413376">[-]</label><label class="expand" for="c-37413376">[1 more]</label></div><br/><div class="children"><div class="content">Gödel also had a short appearance in the Oppenheimer movie, in the scene where Einstein talks about Kurt still being afraid even though they are in the states now.</div><br/></div></div><div id="37413672" class="c"><input type="checkbox" id="c-37413672" checked=""/><div class="controls bullet"><span class="by">ninepoints</span><span>|</span><a href="#37413376">prev</a><span>|</span><label class="collapse" for="c-37413672">[-]</label><label class="expand" for="c-37413672">[11 more]</label></div><br/><div class="children"><div class="content">I would probably refer to this as &quot;Cantor&#x27;s diagonalization&quot; to avoid the ambiguity with &quot;matrix diagonalization&quot; using the matrix eigendecomposition.</div><br/><div id="37414266" class="c"><input type="checkbox" id="c-37414266" checked=""/><div class="controls bullet"><span class="by">xelxebar</span><span>|</span><a href="#37413672">parent</a><span>|</span><a href="#37416144">next</a><span>|</span><label class="collapse" for="c-37414266">[-]</label><label class="expand" for="c-37414266">[1 more]</label></div><br/><div class="children"><div class="content">Hrm... Ambiguity only arises out of context. IMHO, there is ample enough context here to disambiguate, just as you seem to have successfully done.<p>Matrix diagonalization and what you&#x27;re calling Cantor&#x27;s diagonalization can both be seen as instantiations of a more general diagonalization process. This latter process seems to be what the article is obliquely pointing at, cf my top-level comment for a video that introduces those details.</div><br/></div></div><div id="37416144" class="c"><input type="checkbox" id="c-37416144" checked=""/><div class="controls bullet"><span class="by">housecarpenter</span><span>|</span><a href="#37413672">parent</a><span>|</span><a href="#37414266">prev</a><span>|</span><a href="#37413909">next</a><span>|</span><label class="collapse" for="c-37416144">[-]</label><label class="expand" for="c-37416144">[1 more]</label></div><br/><div class="children"><div class="content">The term I&#x27;ve seen most often is &quot;diagonal argument&quot;.</div><br/></div></div><div id="37413909" class="c"><input type="checkbox" id="c-37413909" checked=""/><div class="controls bullet"><span class="by">srcreigh</span><span>|</span><a href="#37413672">parent</a><span>|</span><a href="#37416144">prev</a><span>|</span><label class="collapse" for="c-37413909">[-]</label><label class="expand" for="c-37413909">[8 more]</label></div><br/><div class="children"><div class="content">I’d rather not call it diagonalization at all.<p>Nothing about turings construction enumerates many machines and builds a new machine to flip some aspect of the other machines on the list.<p>It’s more like the liar paradox akin to Gödel first incompleteness theorem.</div><br/><div id="37414031" class="c"><input type="checkbox" id="c-37414031" checked=""/><div class="controls bullet"><span class="by">doomrobo</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37413909">parent</a><span>|</span><a href="#37414037">next</a><span>|</span><label class="collapse" for="c-37414031">[-]</label><label class="expand" for="c-37414031">[3 more]</label></div><br/><div class="children"><div class="content">It turns out that these are all kind of the same, the Liar&#x27;s Paradox, Russell&#x27;s Paradox, the Halting Problem, etc. And indeed the they rely on a &quot;diagonal map&quot; i.e., a map x -&gt; (x, x) in the construction.<p>This was a great read, if you want a mathematical take on it, and some generalization too. <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;math&#x2F;0305282v1" rel="nofollow noreferrer">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;math&#x2F;0305282v1</a></div><br/><div id="37414268" class="c"><input type="checkbox" id="c-37414268" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37414031">parent</a><span>|</span><a href="#37414037">next</a><span>|</span><label class="collapse" for="c-37414268">[-]</label><label class="expand" for="c-37414268">[2 more]</label></div><br/><div class="children"><div class="content">Sure, if you create a larger object it can contain two smaller objects.<p>But that construction is so general that it contains all proofs of the from &quot;There exists X that does not have not property Y&quot; that proceed by constructing something that lacks the property, and stuffs the proof into the diagram.</div><br/><div id="37414908" class="c"><input type="checkbox" id="c-37414908" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37414268">parent</a><span>|</span><a href="#37414037">next</a><span>|</span><label class="collapse" for="c-37414908">[-]</label><label class="expand" for="c-37414908">[1 more]</label></div><br/><div class="children"><div class="content">Its not fully general. Many different types of undecidability proofs are basically proofs by diagonalization, but not all are. See some counter examples:<p><a href="https:&#x2F;&#x2F;mathoverflow.net&#x2F;q&#x2F;454105" rel="nofollow noreferrer">https:&#x2F;&#x2F;mathoverflow.net&#x2F;q&#x2F;454105</a></div><br/></div></div></div></div></div></div><div id="37414037" class="c"><input type="checkbox" id="c-37414037" checked=""/><div class="controls bullet"><span class="by">joaogui1</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37413909">parent</a><span>|</span><a href="#37414031">prev</a><span>|</span><a href="#37414076">next</a><span>|</span><label class="collapse" for="c-37414037">[-]</label><label class="expand" for="c-37414037">[3 more]</label></div><br/><div class="children"><div class="content">So you are listing all TMs + inputs and creating a machine which does the opposite (from a halting perspective), which is like when Cantor lists the reals and creates a new one that has the opposite digit from the other reals</div><br/><div id="37414083" class="c"><input type="checkbox" id="c-37414083" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37414037">parent</a><span>|</span><a href="#37414076">next</a><span>|</span><label class="collapse" for="c-37414083">[-]</label><label class="expand" for="c-37414083">[2 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s not like that at all. It&#x27;s just an algorithm that contradicts itself, like Russell&#x27;s Paradox.</div><br/><div id="37414289" class="c"><input type="checkbox" id="c-37414289" checked=""/><div class="controls bullet"><span class="by">cvoss</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37414083">parent</a><span>|</span><a href="#37414076">next</a><span>|</span><label class="collapse" for="c-37414289">[-]</label><label class="expand" for="c-37414289">[1 more]</label></div><br/><div class="children"><div class="content">Broaden your view of the Halting undecidability proof.<p>Let T_i enumerate all Turing machines. Let E be a function that encodes a Turing machine as a tape.  Suppose Halting is decidable, and let H_i,j be the table of bits such that H_i,j is 1 iff T_i halts on input tape E(T_j). There is some x such that H_x,j = !H_j,j for all j (we can construct&#x2F;find such a machine by hypothesis).<p>Therein lies the diagonalization, you see? We just identified a row such that the bit in column j differs from the jth bit on the the diagonal. The paradox you reference is what happens at bit H_x,x. But, in the bigger context, this argument proceeded by diagonalization.</div><br/></div></div></div></div></div></div><div id="37414076" class="c"><input type="checkbox" id="c-37414076" checked=""/><div class="controls bullet"><span class="by">hgsgm</span><span>|</span><a href="#37413672">root</a><span>|</span><a href="#37413909">parent</a><span>|</span><a href="#37414037">prev</a><span>|</span><label class="collapse" for="c-37414076">[-]</label><label class="expand" for="c-37414076">[1 more]</label></div><br/><div class="children"><div class="content">I tried to comment that on the article. But they use Disqus which is hostile to people making comments.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>