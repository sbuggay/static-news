<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702285263628" as="style"/><link rel="stylesheet" href="styles.css?v=1702285263628"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://mail.openjdk.org/pipermail/panama-dev/2023-October/020095.html">FFM (Foreign Function and Memory API) Goes Final</a> <span class="domain">(<a href="https://mail.openjdk.org">mail.openjdk.org</a>)</span></div><div class="subtext"><span>lichtenberger</span> | <span>48 comments</span></div><br/><div><div id="38595412" class="c"><input type="checkbox" id="c-38595412" checked=""/><div class="controls bullet"><span class="by">jay-barronville</span><span>|</span><a href="#38595712">next</a><span>|</span><label class="collapse" for="c-38595412">[-]</label><label class="expand" for="c-38595412">[2 more]</label></div><br/><div class="children"><div class="content">Some years ago, I wrote a custom JNI wrapper over libuv [0] for a Java&#x2F;Kotlin project I was working on. It’s mind-blowing how much work it took to get cross-compilation and everything else working. That said, as someone who’s been writing C code for years, it wasn’t the worst experience I’ve had; it was mostly just tedious.<p>[0]: <a href="https:&#x2F;&#x2F;github.com&#x2F;1791-labs&#x2F;carlie">https:&#x2F;&#x2F;github.com&#x2F;1791-labs&#x2F;carlie</a></div><br/><div id="38597791" class="c"><input type="checkbox" id="c-38597791" checked=""/><div class="controls bullet"><span class="by">resonious</span><span>|</span><a href="#38595412">parent</a><span>|</span><a href="#38595712">next</a><span>|</span><label class="collapse" for="c-38597791">[-]</label><label class="expand" for="c-38597791">[1 more]</label></div><br/><div class="children"><div class="content">&gt; it was mostly just tedious<p>Sounds like most Java development.</div><br/></div></div></div></div><div id="38595712" class="c"><input type="checkbox" id="c-38595712" checked=""/><div class="controls bullet"><span class="by">zylepe</span><span>|</span><a href="#38595412">prev</a><span>|</span><a href="#38594373">next</a><span>|</span><label class="collapse" for="c-38595712">[-]</label><label class="expand" for="c-38595712">[1 more]</label></div><br/><div class="children"><div class="content">I’m looking forward to be able to memory-map an entire large file without having to split it up into 2gb segments, and to be able to reliably unmap it when done. So many hacks to work around this lack of functionality today…</div><br/></div></div><div id="38594373" class="c"><input type="checkbox" id="c-38594373" checked=""/><div class="controls bullet"><span class="by">Deukhoofd</span><span>|</span><a href="#38595712">prev</a><span>|</span><a href="#38596537">next</a><span>|</span><label class="collapse" for="c-38594373">[-]</label><label class="expand" for="c-38594373">[14 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not a Java dev, so forgive me if I misunderstand it, but is this basically just a different API for calling C functions? Java already was able to do so was it not? How does this improve on it?</div><br/><div id="38594670" class="c"><input type="checkbox" id="c-38594670" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#38594373">parent</a><span>|</span><a href="#38594434">next</a><span>|</span><label class="collapse" for="c-38594670">[-]</label><label class="expand" for="c-38594670">[7 more]</label></div><br/><div class="children"><div class="content">If you want to use JNI to interface with an existing C library, you need to write a thin C or C++ wrapper that is called via JNI and interfaces with that C library. This new Java API allows you to call C functions directly and manipulate data structures on the C side, too. It&#x27;s also possible to create a C function pointer for a Java method, to enable callbacks&#x2F;upcalls from C.</div><br/><div id="38594923" class="c"><input type="checkbox" id="c-38594923" checked=""/><div class="controls bullet"><span class="by">dkersten</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38594670">parent</a><span>|</span><a href="#38594434">next</a><span>|</span><label class="collapse" for="c-38594923">[-]</label><label class="expand" for="c-38594923">[6 more]</label></div><br/><div class="children"><div class="content">JNA exists which already let you do that. What does this change or add over JNA?<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Java_Native_Access" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Java_Native_Access</a></div><br/><div id="38595271" class="c"><input type="checkbox" id="c-38595271" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38594923">parent</a><span>|</span><a href="#38596610">next</a><span>|</span><label class="collapse" for="c-38595271">[-]</label><label class="expand" for="c-38595271">[1 more]</label></div><br/><div class="children"><div class="content">Well for one thing, it is part of OpenJDK, instead of a third party library built on top of JNI, and can thus, at least in theory, integrate better with the runtime.</div><br/></div></div><div id="38596610" class="c"><input type="checkbox" id="c-38596610" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38594923">parent</a><span>|</span><a href="#38595271">prev</a><span>|</span><a href="#38595313">next</a><span>|</span><label class="collapse" for="c-38596610">[-]</label><label class="expand" for="c-38596610">[1 more]</label></div><br/><div class="children"><div class="content">JNA is 10x slower than JNI.<p>FFM should offer the perf of JNI with the usability of JNA.</div><br/></div></div><div id="38595313" class="c"><input type="checkbox" id="c-38595313" checked=""/><div class="controls bullet"><span class="by">MrBuddyCasino</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38594923">parent</a><span>|</span><a href="#38596610">prev</a><span>|</span><a href="#38594434">next</a><span>|</span><label class="collapse" for="c-38595313">[-]</label><label class="expand" for="c-38595313">[3 more]</label></div><br/><div class="children"><div class="content">JNI: fast but tedious<p>JNA: comfortable but slow<p>Panama: comfortable &amp; fast</div><br/><div id="38597897" class="c"><input type="checkbox" id="c-38597897" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38595313">parent</a><span>|</span><a href="#38594434">next</a><span>|</span><label class="collapse" for="c-38597897">[-]</label><label class="expand" for="c-38597897">[2 more]</label></div><br/><div class="children"><div class="content">What is it about JNA that makes it slow? What is it about Panama that makes it fast?<p>Soon I&#x27;ll start working on similar features for my own language. This could give me a massive head start.</div><br/><div id="38598482" class="c"><input type="checkbox" id="c-38598482" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38597897">parent</a><span>|</span><a href="#38594434">next</a><span>|</span><label class="collapse" for="c-38598482">[-]</label><label class="expand" for="c-38598482">[1 more]</label></div><br/><div class="children"><div class="content">Panama is part of the runtime, it can be made to make the best use of that knowledge.<p>JNA relies on JNI, and exposes a better Java interface.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38594434" class="c"><input type="checkbox" id="c-38594434" checked=""/><div class="controls bullet"><span class="by">mwilliamson</span><span>|</span><a href="#38594373">parent</a><span>|</span><a href="#38594670">prev</a><span>|</span><a href="#38595004">next</a><span>|</span><label class="collapse" for="c-38594434">[-]</label><label class="expand" for="c-38594434">[1 more]</label></div><br/><div class="children"><div class="content">The JEP itself has a motivation section, including issues with the existing mechanism for interop with C, JNI: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454</a></div><br/></div></div><div id="38595004" class="c"><input type="checkbox" id="c-38595004" checked=""/><div class="controls bullet"><span class="by">cstrahan</span><span>|</span><a href="#38594373">parent</a><span>|</span><a href="#38594434">prev</a><span>|</span><a href="#38594423">next</a><span>|</span><label class="collapse" for="c-38595004">[-]</label><label class="expand" for="c-38595004">[1 more]</label></div><br/><div class="children"><div class="content">JNI allows one to write C code that bridges the gap between the Java VM and existing C libraries. That C code must be compiled, and must follow some rather tedious patterns (regarding method signatures and other little details). It’s a bit of a pain to write and compile, if all you want to do is quickly call some function from an existing C library.<p>Also, because symbol resolution is done at compile-time, this is a non starter for something like JRuby, wherein one would want to write plain Ruby code to call a C function — rather than writing Ruby, Java <i>and</i> JNI flavored C code. Ruby is an interpreted language, so calling into or out of C requires dynamic symbol resolution, and for the C-&gt;Ruby callback case, a closure must be created on the fly (that is, a C ABI function must be JIT compiled for that method or proc). This isn’t particular to Ruby — any interpreted language will run into this issue on the JVM (picture Python and its ctypes and&#x2F;or cffi libraries).<p>You can see some of the hoops that JRuby had to jump through to support this use case, in order to provide a JRuby implementation of the ‘ffi’ gem interface:<p><a href="https:&#x2F;&#x2F;javadoc.io&#x2F;doc&#x2F;org.jruby&#x2F;jruby-core&#x2F;9.2.13.0&#x2F;org&#x2F;jruby&#x2F;ext&#x2F;ffi&#x2F;FFI.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;javadoc.io&#x2F;doc&#x2F;org.jruby&#x2F;jruby-core&#x2F;9.2.13.0&#x2F;org&#x2F;jru...</a><p><a href="https:&#x2F;&#x2F;www.igvita.com&#x2F;2009&#x2F;01&#x2F;15&#x2F;bridging-mri-jruby-rubinius-with-ffi&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.igvita.com&#x2F;2009&#x2F;01&#x2F;15&#x2F;bridging-mri-jruby-rubiniu...</a><p>It’s been a minute, so my recollection may be wrong, but IIRC JRuby uses Java and JNI to call into a C shim that then calls into libffi to handle things like creating C ABI conforming closures and such on the fly (the ffi gem on CRuby also uses libffi for the same purposes).<p>Correction: I believe JRuby uses JNA, which in turn is Java+JNI to call C that then calls into libffi, which is then leveraged to call whatever other functions (or create C callbacks back into the JVM). So I’m pretty sure FFM would be an officially supported replacement (maybe superset?) of JNA. (I’m on vacation and typed all of this out on my phone, so forgive me if I got some details a bit off)<p>I’m pretty sure that just about all of that complexity can be ripped out once FFM is generally available.</div><br/></div></div><div id="38594423" class="c"><input type="checkbox" id="c-38594423" checked=""/><div class="controls bullet"><span class="by">simtel20</span><span>|</span><a href="#38594373">parent</a><span>|</span><a href="#38595004">prev</a><span>|</span><a href="#38594422">next</a><span>|</span><label class="collapse" for="c-38594423">[-]</label><label class="expand" for="c-38594423">[1 more]</label></div><br/><div class="children"><div class="content">I am not a java dev either, but as it&#x27;s named, this focuses on memory and ffi,and e.g. in the linked message talks about passing heap memory to a foreign function in a zero copy manner, which sounds like a great trick which would make a lot of calling c APIs from java much easier and faster.</div><br/></div></div><div id="38594422" class="c"><input type="checkbox" id="c-38594422" checked=""/><div class="controls bullet"><span class="by">Racing0461</span><span>|</span><a href="#38594373">parent</a><span>|</span><a href="#38594423">prev</a><span>|</span><a href="#38596537">next</a><span>|</span><label class="collapse" for="c-38594422">[-]</label><label class="expand" for="c-38594422">[3 more]</label></div><br/><div class="children"><div class="content">I was interested in why also since there was already JNI. This is what i found<p>&gt;&gt;&gt; The FFM API allows Java programs to interoperate safely and more easily with code and data outside the Java runtime. Unlike JNI, which often involves brittle and error-prone boilerplate code, the FFM API aims to provide a more straightforward and safer method for calling native libraries and manipulating native data.</div><br/><div id="38594787" class="c"><input type="checkbox" id="c-38594787" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38594422">parent</a><span>|</span><a href="#38596537">next</a><span>|</span><label class="collapse" for="c-38594787">[-]</label><label class="expand" for="c-38594787">[2 more]</label></div><br/><div class="children"><div class="content">That sounds like a zero-information marketing blurb, though. The interesting bits would be not the claims, but how they&#x27;re realized - i.e. how FFM is implemented and what&#x27;s the difference between how it works and how the implementation is different from JNI.</div><br/><div id="38595375" class="c"><input type="checkbox" id="c-38595375" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38594373">root</a><span>|</span><a href="#38594787">parent</a><span>|</span><a href="#38596537">next</a><span>|</span><label class="collapse" for="c-38595375">[-]</label><label class="expand" for="c-38595375">[1 more]</label></div><br/><div class="children"><div class="content">They have low-overhead temporal-,  spatial-, and thread- safety guarantees. Spatial in that every “C pointer”=MemorySegment is associated with bounds, which is checked at runtime. Temporal, in that such a MemorySegment has a scope (usually created in a try-with resource block, being closed right afterwards, or alternatively at a random later point, up to the GC), outside of which it can’t be called (also, freeing actions can be associated with these). Thread safety, in that a scope also determines the availability of a given segment to other threads (must be explicitly specified to be accessible mutably from multiple threads).</div><br/></div></div></div></div></div></div></div></div><div id="38596537" class="c"><input type="checkbox" id="c-38596537" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#38594373">prev</a><span>|</span><a href="#38594390">next</a><span>|</span><label class="collapse" for="c-38596537">[-]</label><label class="expand" for="c-38596537">[1 more]</label></div><br/><div class="children"><div class="content">For those of you, like me, who stumbled around looking for a link to something actually <i>definitive</i>:<p>JEP 454: Foreign Function &amp; Memory API
<a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454</a></div><br/></div></div><div id="38594390" class="c"><input type="checkbox" id="c-38594390" checked=""/><div class="controls bullet"><span class="by">SillyUsername</span><span>|</span><a href="#38596537">prev</a><span>|</span><a href="#38594995">next</a><span>|</span><label class="collapse" for="c-38594390">[-]</label><label class="expand" for="c-38594390">[4 more]</label></div><br/><div class="children"><div class="content">Well this might be a fun one to search for when you need to learn the new API at work...</div><br/><div id="38594515" class="c"><input type="checkbox" id="c-38594515" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#38594390">parent</a><span>|</span><a href="#38598160">next</a><span>|</span><label class="collapse" for="c-38594515">[-]</label><label class="expand" for="c-38594515">[1 more]</label></div><br/><div class="children"><div class="content">Search for &quot;Project Panama&quot; if your work has problems with normal terms. That&#x27;s the development name.</div><br/></div></div><div id="38598160" class="c"><input type="checkbox" id="c-38598160" checked=""/><div class="controls bullet"><span class="by">Exoristos</span><span>|</span><a href="#38594390">parent</a><span>|</span><a href="#38594515">prev</a><span>|</span><a href="#38594995">next</a><span>|</span><label class="collapse" for="c-38598160">[-]</label><label class="expand" for="c-38598160">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t get it.</div><br/><div id="38598781" class="c"><input type="checkbox" id="c-38598781" checked=""/><div class="controls bullet"><span class="by">Semaphor</span><span>|</span><a href="#38594390">root</a><span>|</span><a href="#38598160">parent</a><span>|</span><a href="#38594995">next</a><span>|</span><label class="collapse" for="c-38598781">[-]</label><label class="expand" for="c-38598781">[1 more]</label></div><br/><div class="children"><div class="content">Female, Female, Male. Threesome.</div><br/></div></div></div></div></div></div><div id="38594995" class="c"><input type="checkbox" id="c-38594995" checked=""/><div class="controls bullet"><span class="by">stickfigure</span><span>|</span><a href="#38594390">prev</a><span>|</span><label class="collapse" for="c-38594995">[-]</label><label class="expand" for="c-38594995">[25 more]</label></div><br/><div class="children"><div class="content">I have misgivings about making interop with native code easier.<p>In the node, python, and ruby ecosystems, native code dependencies are a horrorshow of brittle builds. The amount of my life that has been wasted on stupid build issues is significant (damn you nokogiri).<p>The JVM has been a relative sea of tranquility. The ecosystem is so large, and JNI so unpleasant, that everything important has been built JVM-native. Builds just work, even when you walk away for two years.<p>I don&#x27;t want native code in my projects, and I fear this will encourage it.</div><br/><div id="38595729" class="c"><input type="checkbox" id="c-38595729" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#38594995">parent</a><span>|</span><a href="#38595274">next</a><span>|</span><label class="collapse" for="c-38595729">[-]</label><label class="expand" for="c-38595729">[5 more]</label></div><br/><div class="children"><div class="content">Note that FFM requires that you explicitly allow the use of native code with --enable-native-access (and soon JNI will, too: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8307341" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8307341</a>). As JEP 454 (<a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;454</a>) states:<p>&gt; To allow code in a module M to use unsafe methods without warnings, specify the --enable-native-access=M option on the java launcher command line. Specify multiple modules with a comma-separated list<p>The warnings will become errors in a later release.<p>This means that no library you&#x27;re using (even some transitive dependency) can call native code without you, the application author, knowing about it. This restriction on native code is part of the work on &quot;integrity by default&quot;: <a href="https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968" rel="nofollow noreferrer">https:&#x2F;&#x2F;openjdk.org&#x2F;jeps&#x2F;8305968</a></div><br/><div id="38598073" class="c"><input type="checkbox" id="c-38598073" checked=""/><div class="controls bullet"><span class="by">josephcsible</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595729">parent</a><span>|</span><a href="#38596089">next</a><span>|</span><label class="collapse" for="c-38598073">[-]</label><label class="expand" for="c-38598073">[1 more]</label></div><br/><div class="children"><div class="content">Oh no, not more command line flags to allow functionality that always worked before! That same decision with modules and reflection in Java 9 is why so much stuff is stuck on Java 8 still.</div><br/></div></div><div id="38596089" class="c"><input type="checkbox" id="c-38596089" checked=""/><div class="controls bullet"><span class="by">nvm0n2</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595729">parent</a><span>|</span><a href="#38598073">prev</a><span>|</span><a href="#38595274">next</a><span>|</span><label class="collapse" for="c-38596089">[-]</label><label class="expand" for="c-38596089">[3 more]</label></div><br/><div class="children"><div class="content">But how is that connected to the concern expressed?<p>Problem: If the JVM ecosystem starts to depend more on native code it gets less pleasant to work with.<p>Answer: There is this command line flag that is used to activate the FFI.<p>There doesn&#x27;t seem to be any relation between these two things, unless you&#x27;re trying to imply that because of the  flag people just won&#x27;t use the FFI at all and will write pure Java instead. Which would be strange, as the justification for investing so much into Panama in the first place is the expectation that it will be used, because native code is getting more important rather than less.<p>There are two ways to avoid the JVM ecosystem becoming crappy due to native code:<p>1. Encourage the development of pure Java libraries.<p>2. Make native code work better.<p>Panama tries to do (2) but it&#x27;s got a lot of missing functionality that the scripting lang ecosystems nail. How do you compile a Java library that uses native code? Python&#x2F;Node&#x2F;Ruby worlds know how, but OpenJDK ignores the question. How do you ship a Java library that uses native code? Python&#x2F;Node&#x2F;Ruby worlds know, but OpenJDK ignores the question. These problems have been pointed out before and Panama guys just say not in scope.<p>The community hasn&#x27;t come together to solve these problems either. Maven&#x2F;Gradle are too disorganized to come up with answers in the absence of any leadership from OpenJDK. Everyone reinvents the wheel when it comes to loading shared libs from JARs. It&#x27;s a mess and nobody is solving it.<p>So that leaves (1), encourage the development of pure Java libs. This also isn&#x27;t working. People write in C&#x2F;C++&#x2F;Rust because that way everyone can access the functionality regardless of what ecosystem they work in, so such projects get the biggest collection of stakeholders. That&#x27;s more important that implementation language, so Java is losing badly everywhere. Pure Java libraries are never best in class anymore (they once sometimes were), which is how you end up with situations like this:<p><a href="https:&#x2F;&#x2F;blogs.oracle.com&#x2F;developers&#x2F;post&#x2F;open-sourcing-jipher" rel="nofollow noreferrer">https:&#x2F;&#x2F;blogs.oracle.com&#x2F;developers&#x2F;post&#x2F;open-sourcing-jiphe...</a><p><i>&gt; We’ve chosen to base our products on OpenSSL because it is the most open and most widely used cryptographic toolkit on the planet. At Oracle, we make extensive use of the OpenSSL 3.0 FIPS 140 provider to operate in regulated markets. We like the OpenSSL FIPS provider so much we decided to build a Java cryptography toolkit on top of it called Jipher. By converging on a single toolkit (OpenSSL) we reduce our attack surface, simplify security patching, achieve assembly-optimized performance, and help our customers meet regulatory compliance requirements.</i><p>It means the first use of Panama in the wild is to replace the built in memory safe Java SSL stack with OpenSSL, a giant pile of C with a long history of memory safety vulns, and it&#x27;s Oracle itself doing this because OpenSSL is &quot;the most widely used&quot; library and nothing else matters. They even say replacing Java SSL with OpenSSL will <i>reduce the attack surface</i>.<p>If even the well funded OpenJDK developers working in Java can&#x27;t outcompete the poorly funded OpenSSL devs working in an unproductive language, then what chance do other Java library devs have? None at all! Native code will always win because it will be faster and have a bigger community, and in the end there&#x27;s safety in numbers.<p>This is very sad. It means Java&#x27;s future is as a collection of thin wrappers around bug-prone C APIs accessed via Panama, which, as you are well aware pron, will make Loom virtually useless as it cannot work with native code by design.<p>A long steady decline is the most likely path here, in which Java libs get hollowed out to try and keep up with the functionality and performance of native libs (e.g. http&#x2F;3), and so Java devs steadily lose the benefits of the JVM. There are things Java could do to avoid this fate but the OpenJDK people are never going to do them.</div><br/><div id="38596811" class="c"><input type="checkbox" id="c-38596811" checked=""/><div class="controls bullet"><span class="by">pron</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38596089">parent</a><span>|</span><a href="#38595274">next</a><span>|</span><label class="collapse" for="c-38596811">[-]</label><label class="expand" for="c-38596811">[2 more]</label></div><br/><div class="children"><div class="content">&gt; How do you compile a Java library that uses native code? Python&#x2F;Node&#x2F;Ruby worlds know how, but OpenJDK ignores the question.<p>Because you compile it like any other Java library.<p>&gt; How do you ship a Java library that uses native code? Python&#x2F;Node&#x2F;Ruby worlds know, but OpenJDK ignores the question.<p>It doesn&#x27;t. jmod files and the jmod tool were added in JDK 9 precisely for that (and other things, too).<p>&gt; If even the well funded OpenJDK developers working in Java can&#x27;t outcompete the poorly funded OpenSSL devs working in an unproductive language, then what chance do other Java library devs have? None at all!<p>People aren&#x27;t really rewriting OpenSSL in Python or JS, either, but high-level languages are many times more popular than low-level ones [1], and you&#x27;re misreading the normal behaviour of a fragmented market, when it&#x27;s worth it to compete and over what. I don&#x27;t think any language today has a healthier library ecosystem than Java. That&#x27;s not to say it&#x27;s as good as wish it would be, but no one seems to do it better.<p>There is, however, a problem with build tools not supporting newer JDK features (that are coming faster now than before) and we&#x27;ll need to do something about that.<p>[1]: <a href="https:&#x2F;&#x2F;www.devjobsscanner.com&#x2F;blog&#x2F;top-8-most-demanded-programming-languages&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.devjobsscanner.com&#x2F;blog&#x2F;top-8-most-demanded-prog...</a></div><br/><div id="38597777" class="c"><input type="checkbox" id="c-38597777" checked=""/><div class="controls bullet"><span class="by">geodel</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38596811">parent</a><span>|</span><a href="#38595274">next</a><span>|</span><label class="collapse" for="c-38597777">[-]</label><label class="expand" for="c-38597777">[1 more]</label></div><br/><div class="children"><div class="content">&gt; There is, however, a problem with build tools not supporting newer JDK features<p>This is important point.<p>From my experience in Enterprise IT the build pipeline is roughly at JDK-8 level in terms of generating deployable artifacts. I have contorted by maven build config to invoke jlink on builder nodes to make standalone artifacts that won&#x27;t need JDK on target machines. But it is not optimal for few reasons 1) I have to manually track what JDK modules I need to include in build. 2) Its hard to get new JDK installed on build machines for ones, forget the dot upgrades to keep it latest bug fix level. Their reasoning is build machine is just to invoke maven build. Only target machines need latest patched JDKs. 3) From JDK-8 they are now directly jumping to make docker&#x2F;kubernetetes builds which are fine but totally different direction if I am just looking to make no-fuss standalone Java application to run on a Linux VM.<p>As one can see some of these are organizational issues not necessarily technical one. But as single developer with no power to force IT infra teams on supporting alternate workflows I am basically stuck with JDK-8 workflows.<p>What is missing in setup is somehow to tell maven <i>I want to generate a standalone Java app using jlink for linux ver.N target so gather up all modules &#x2F; java binary and other tools required based on information in this pom file without relying on JDK version of builder</i> . This should be able to run builder machine so it remains integrated with current build pipleline.</div><br/></div></div></div></div></div></div></div></div><div id="38595274" class="c"><input type="checkbox" id="c-38595274" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#38594995">parent</a><span>|</span><a href="#38595729">prev</a><span>|</span><a href="#38595364">next</a><span>|</span><label class="collapse" for="c-38595274">[-]</label><label class="expand" for="c-38595274">[1 more]</label></div><br/><div class="children"><div class="content">I think Java is just so insanely big, that this Java-pureness will stick, and JNI&#x2F;Panama will only be used, when absolutely necessary. This is a unique trait thanks to the way the language grew.</div><br/></div></div><div id="38595364" class="c"><input type="checkbox" id="c-38595364" checked=""/><div class="controls bullet"><span class="by">dongping</span><span>|</span><a href="#38594995">parent</a><span>|</span><a href="#38595274">prev</a><span>|</span><a href="#38595440">next</a><span>|</span><label class="collapse" for="c-38595364">[-]</label><label class="expand" for="c-38595364">[4 more]</label></div><br/><div class="children"><div class="content">Bazel streamlines the build process with native code (C++&#x2F;Rust) in Python, making the experience a breeze. However, the drawback is that you would need to transition to Bazel.</div><br/><div id="38595446" class="c"><input type="checkbox" id="c-38595446" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595364">parent</a><span>|</span><a href="#38595440">next</a><span>|</span><label class="collapse" for="c-38595446">[-]</label><label class="expand" for="c-38595446">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if it&#x27;s still true, but I believe back at Google the interop with C&#x2F;C++ was even more integrated - if I&#x27;m not mistaken the &quot;java&quot; binary got recompiled from scratch (but thanks for caching, not much hit), and your C&#x2F;C++ code got compiled in with it - so no &quot;.so&quot; loading - you still have single binary (and I think the .jar also went at the end of the file).<p>Or maybe that was for python (e.g. compile CPython along with any ffi modules as one) + .zip file with classes.<p>In any case, even if above was not 100% true, it&#x27;s doable with system like bazel&#x2F;buck&#x2F;etc., and still allow you for smooth incremental development (or say in the default &quot;fastbuild&quot; .so files may still be used - locally, but in &quot;opt&quot; the full static link, or through a --config)</div><br/><div id="38595990" class="c"><input type="checkbox" id="c-38595990" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595446">parent</a><span>|</span><a href="#38595440">next</a><span>|</span><label class="collapse" for="c-38595990">[-]</label><label class="expand" for="c-38595990">[2 more]</label></div><br/><div class="children"><div class="content">My main issue with bazel is that adopting it means giving up good editor integrations for anything besides JVM (maybe C&#x2F;C++ as well, I haven&#x27;t touched that). And even then, only IntelliJ has good support.<p>I think a lot of smaller (read: most) companies adopt bazel without realizing this. You will pay dearly in terms of developer experience in exchange for the benefits bazel purports to offer.</div><br/><div id="38598299" class="c"><input type="checkbox" id="c-38598299" checked=""/><div class="controls bullet"><span class="by">gorset</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595990">parent</a><span>|</span><a href="#38595440">next</a><span>|</span><label class="collapse" for="c-38598299">[-]</label><label class="expand" for="c-38598299">[1 more]</label></div><br/><div class="children"><div class="content">There are some workarounds. In my company we have a script that generated IDE files automatically. It uses `bazel query` and `bazel build` to find all external and non native dependencies, and then generates IDE config and files for rust, java, python, etc.<p>Positives: your IDE experience becomes native and you don&#x27;t need to interact with bazel for normal IDE work flows.
Negatives: need to run the generate script anything non native changes. Also need to deal with bazel build files etc for the git workflow, obviously.<p>We&#x27;re small company, and this method has worked great, and we have a pretty complex build with python accessing rust and java (via jni). Java accessing rust and c (via jni).</div><br/></div></div></div></div></div></div></div></div><div id="38595440" class="c"><input type="checkbox" id="c-38595440" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38594995">parent</a><span>|</span><a href="#38595364">prev</a><span>|</span><a href="#38595328">next</a><span>|</span><label class="collapse" for="c-38595440">[-]</label><label class="expand" for="c-38595440">[5 more]</label></div><br/><div class="children"><div class="content">But native code dependencies in those languages usually work similarly to JNI in java, where you write wrapper code in c or c++ to convert from native apis to the interpretor&#x27;s interface. So interfacing with native code isn&#x27;t fundamentally easier than for java. Python does have ctypes, but that isn&#x27;t what libraries like numpy use, probably because of performance.<p>I think there are a couple of other reasons why Java doesn&#x27;t have the same problems with brittle builds. One is that for python and ruby and to a lesser extent node, it is more often necessary to use native code to get desirable performance, so there are more cases where native code is used. Another is that in the JVM ecosystem, it is more common for packages to be distributed in binary form rather than as sources, so you don&#x27;t run into problems compiling dependencies, because you download a package that already has the compiled library in it.</div><br/><div id="38595700" class="c"><input type="checkbox" id="c-38595700" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595440">parent</a><span>|</span><a href="#38595328">next</a><span>|</span><label class="collapse" for="c-38595700">[-]</label><label class="expand" for="c-38595700">[4 more]</label></div><br/><div class="children"><div class="content">&gt; it is more common for packages to be distributed in binary form rather than as sources, so you don&#x27;t run into problems compiling dependencies<p>Not sure what you mean here. Java bytecode is similar to source code, just easier for machines to parse, also easy to decompile. Mainstream Java is an interpreted language (requires JVM), not compiled.<p>Don&#x27;t see what&#x27;s the difference with packaging, say, python code to a zip archive.</div><br/><div id="38595985" class="c"><input type="checkbox" id="c-38595985" checked=""/><div class="controls bullet"><span class="by">thayne</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595700">parent</a><span>|</span><a href="#38595328">next</a><span>|</span><label class="collapse" for="c-38595985">[-]</label><label class="expand" for="c-38595985">[3 more]</label></div><br/><div class="children"><div class="content">I mean that java libraries that do use native code don&#x27;t ship packages with c source code, that the user is expected to compile locally, as is common in python, ruby, and node. But instead they typically have a jar that includes a pre-compiled binary library, or several to support multiple platforms. So as long as you are using one of the supported platforms, it just works. But if you are on a platform that doesn&#x27;t have a pre-compiled library, you will probably need to build the package yourself.</div><br/><div id="38596124" class="c"><input type="checkbox" id="c-38596124" checked=""/><div class="controls bullet"><span class="by">flakes</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595985">parent</a><span>|</span><a href="#38596168">next</a><span>|</span><label class="collapse" for="c-38596124">[-]</label><label class="expand" for="c-38596124">[1 more]</label></div><br/><div class="children"><div class="content">Its relatively common in Python for C&#x2F;C++ code to be shipped pre-compiled as part of binary wheels (for at least the most common architectures). You do still end up falling back to sdists if your Python version or OS don&#x27;t line up with any of the supplied binary wheels from the author. e.g. take a look at the pre-compiled set for pydantic-core <a href="https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;pydantic-core&#x2F;#files" rel="nofollow noreferrer">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;pydantic-core&#x2F;#files</a></div><br/></div></div><div id="38596168" class="c"><input type="checkbox" id="c-38596168" checked=""/><div class="controls bullet"><span class="by">deepsun</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595985">parent</a><span>|</span><a href="#38596124">prev</a><span>|</span><a href="#38595328">next</a><span>|</span><label class="collapse" for="c-38596168">[-]</label><label class="expand" for="c-38596168">[1 more]</label></div><br/><div class="children"><div class="content">Gotcha, yes, in my experience as long as a python library installs as a prebuilt wheel (.whl), then it&#x27;s ok. If it tries to compile on my machine (setup.py) -- it never is able to.</div><br/></div></div></div></div></div></div></div></div><div id="38595328" class="c"><input type="checkbox" id="c-38595328" checked=""/><div class="controls bullet"><span class="by">geokon</span><span>|</span><a href="#38594995">parent</a><span>|</span><a href="#38595440">prev</a><span>|</span><a href="#38596133">next</a><span>|</span><label class="collapse" for="c-38595328">[-]</label><label class="expand" for="c-38595328">[6 more]</label></div><br/><div class="children"><div class="content">Overall I agree.. I like not having native code.. I run the JVM so I don&#x27;t have to worry about platform specific stuff. But this would be more-so an issue in the Java 8 world where your uberjar needs to have lib blobs for every platform it may be run on<p>In the Java 11+ world you are no longer in the build-once-run-everywhere model and you unfortunately are semi-required to build platform specific bundles. And adding a C++ build step here wouldn&#x27;t be a disaster - in theory. You could actually do it cleanly&#x2F;safely with CMake + Hunter + platform-specific toolchain files. Unfortunately the C++ world hasn&#x27;t converged to CMake&#x2F;Hunter so if you&#x27;re using a uncommon&#x2F;weird lib then it might take work to make it work.<p>But someone could then in theory clone your project in 20 years running BSDinux on a RISC-VI chip and it should build and run</div><br/><div id="38595386" class="c"><input type="checkbox" id="c-38595386" checked=""/><div class="controls bullet"><span class="by">koito17</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595328">parent</a><span>|</span><a href="#38596061">next</a><span>|</span><label class="collapse" for="c-38595386">[-]</label><label class="expand" for="c-38595386">[4 more]</label></div><br/><div class="children"><div class="content">&gt; you unfortunately are semi-required to build platform specific bundles<p>Can you elaborate on this? It seems like a build tool specific issue to me. In Clojure, most projects use Leiningen (a build tool) and uberjars regardless of the target Java version will bundle native libraries for every platform you run on. You can exclude some of the libraries from your uberjar, but it&#x27;s a manual process. This has an obvious drawback (e.g. depending on the SQLite JDBC driver bloats your JAR with dozens of native libraries), but it&#x27;s still very much &quot;build once, run everywhere&quot;.<p>The closest I&#x27;ve been to &quot;platform specific bundles&quot; was dealing with a Gradle project where the developer hard-coded a target platform into a property, thus making it impossible to bundle libraries for multiple platforms.</div><br/><div id="38595603" class="c"><input type="checkbox" id="c-38595603" checked=""/><div class="controls bullet"><span class="by">geokon</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595386">parent</a><span>|</span><a href="#38596061">next</a><span>|</span><label class="collapse" for="c-38595603">[-]</label><label class="expand" for="c-38595603">[3 more]</label></div><br/><div class="children"><div class="content">Right, both lein and depstar (or whatever the latest deps.edn one is) make uberjars. And this works great on Linux - which I&#x27;m pretty sure is the dev platform for almost all Clojurists. Linux distros basically always come with a OpenJDK JRE&#x2F;JVM. But installing a JRE is actually discouraged by the Java people. You will notice on java.com you can&#x27;t actually download a Java 11&#x2F;17&#x2F;+ JRE. You can only get a Java 8 JRE!<p>You&#x27;re supposed to use `jpackage`.  It basically packages up the uberjar with all the necessary pieces of the JRE to run the uberjar (so a pared down JRE) and does platform specific bundling like adding meta data and creating an installer (so your application can have a place to save settings and whatnot between runs, have an icon in the Start menu&#x2F;desktop and stuff like that)<p>You can still do uberjars and get a JRE for Windows&#x2F;Mac from third parties like Adaptium, but it&#x27;s very unergonomic and looks kinda sketch (b&#x2F;c it doesn&#x27;t look official)<p>My own anecdotal experience:<p>I distributed a JavaFX&#x2F;Java-17 app as an uberjar. My rational was:<p>- I didn&#x27;t need any app persistence between runs, so I just wanted a small double-clickage &quot;.exe&#x2F;bin&quot; equivalent that people could download and try out (no one wants install some random app to try out from online).<p>- `jpackage` doesn&#x27;t allow you to make a simple double-clickable .exe (they can make something confusingly called an appimgage, which is not an Linux appimage - but it&#x27;s similar!)<p>- I had no way to do testing on Mac b&#x2F;c I don&#x27;t own an Apple machine. So I don&#x27;t wanna be generating Mac executables I can&#x27;t even test.. At least with the uberjar I can be semi-confident if it runs on my laptop it&#x27;ll run on a Mac later (sorta true)<p>The end result was a disaster.. 90% of user issues were from people that would who would go to java.com, &quot;install Java&quot; (ending up with a Java 8 JRE!) and then the app would just silently not run. The JRE doesn&#x27;t produce any friendly error or warning saying anything about versions - it just silently fails. I have in bold on my landing page YOU NEED A JAVA 17+ JRE. No use.. people would still do it wrong</div><br/><div id="38595849" class="c"><input type="checkbox" id="c-38595849" checked=""/><div class="controls bullet"><span class="by">dtech</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595603">parent</a><span>|</span><a href="#38596061">next</a><span>|</span><label class="collapse" for="c-38595849">[-]</label><label class="expand" for="c-38595849">[2 more]</label></div><br/><div class="children"><div class="content">Yeah java isn&#x27;t really used for Consumer apps and this is one of the reasons. The ones that do evade this problem by bundeling their own JVM.</div><br/><div id="38596040" class="c"><input type="checkbox" id="c-38596040" checked=""/><div class="controls bullet"><span class="by">thfuran</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595849">parent</a><span>|</span><a href="#38596061">next</a><span>|</span><label class="collapse" for="c-38596040">[-]</label><label class="expand" for="c-38596040">[1 more]</label></div><br/><div class="children"><div class="content">No, consumer java desktop applications were already uncommon when java 9 came out.</div><br/></div></div></div></div></div></div></div></div><div id="38596061" class="c"><input type="checkbox" id="c-38596061" checked=""/><div class="controls bullet"><span class="by">folmar</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595328">parent</a><span>|</span><a href="#38595386">prev</a><span>|</span><a href="#38596133">next</a><span>|</span><label class="collapse" for="c-38596061">[-]</label><label class="expand" for="c-38596061">[1 more]</label></div><br/><div class="children"><div class="content">&gt; In the Java 11+ world you are no longer in the build-once-run-everywhere model and you unfortunately are semi-required to build platform specific bundle<p>That feels as an overstatement to me. You only need to build something platform specific if you want to _ship a JRE_, normal JAR works as usual if you expect users to have java or are happy with providing standard JDK. Sure jpackage seems nice but all the commercial end-user software I see bundles JRE only for windows and lands everyone else a nice fat jar.</div><br/></div></div></div></div><div id="38595238" class="c"><input type="checkbox" id="c-38595238" checked=""/><div class="controls bullet"><span class="by">irq-1</span><span>|</span><a href="#38594995">parent</a><span>|</span><a href="#38596133">prev</a><span>|</span><label class="collapse" for="c-38595238">[-]</label><label class="expand" for="c-38595238">[2 more]</label></div><br/><div class="children"><div class="content">Golang followed the same path; no dynamic linking and everything was &#x27;re&#x27;-created in Go. It&#x27;s effective.<p>For FFM won&#x27;t C access be isolated to the JAR? Maybe it&#x27;s not normal to get pre-built JAR files?</div><br/><div id="38595409" class="c"><input type="checkbox" id="c-38595409" checked=""/><div class="controls bullet"><span class="by">malkia</span><span>|</span><a href="#38594995">root</a><span>|</span><a href="#38595238">parent</a><span>|</span><label class="collapse" for="c-38595409">[-]</label><label class="expand" for="c-38595409">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s effective... Until you need sqlite, or lmdb, or something like this.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>