<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1733821280183" as="style"/><link rel="stylesheet" href="styles.css?v=1733821280183"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://sbaziotis.com/compilers/common-misconceptions-about-compilers.html">Common misconceptions about compilers</a>Â <span class="domain">(<a href="https://sbaziotis.com">sbaziotis.com</a>)</span></div><div class="subtext"><span>baziotis</span> | <span>19 comments</span></div><br/><div><div id="42374587" class="c"><input type="checkbox" id="c-42374587" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#42374915">next</a><span>|</span><label class="collapse" for="c-42374587">[-]</label><label class="expand" for="c-42374587">[2 more]</label></div><br/><div class="children"><div class="content">&gt; As an example, in my desktop, it takes ~25min to compile a Debug version of LLVM, but ~23min to compile a Release version.<p>oh I think I know what might cause this: TableGen. The `llvm-tblgen` run time accounts for a good chunk of LLVM build time. In a debug build `llvm-tblgen` is also  unoptimized, hence the long run time generating those <i>.inc &#x2F; </i>.def files. You can enable cmake variable `LLVM_OPTIMIZED_TABLEGEN` to build `llvm-tblgen` in release mode while leaving the rest of the project in debug build (or whatever `CMAKE_BUILD_TYPE` you choose).</div><br/><div id="42375001" class="c"><input type="checkbox" id="c-42375001" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374587">parent</a><span>|</span><a href="#42374915">next</a><span>|</span><label class="collapse" for="c-42375001">[-]</label><label class="expand" for="c-42375001">[1 more]</label></div><br/><div class="children"><div class="content">TIL that LLVM_OPTIMIZED_TABLEGEN exists, thanks! Unfortunately, it didn&#x27;t make the build any faster on my machine.</div><br/></div></div></div></div><div id="42374915" class="c"><input type="checkbox" id="c-42374915" checked=""/><div class="controls bullet"><span class="by">timeforcomputer</span><span>|</span><a href="#42374587">prev</a><span>|</span><a href="#42374534">next</a><span>|</span><label class="collapse" for="c-42374915">[-]</label><label class="expand" for="c-42374915">[2 more]</label></div><br/><div class="children"><div class="content">Why does optimal substructure work for code size? Couldn&#x27;t you take a compiled non-minimal function and break each instruction into a function call (with some assumptions about the ISA maybe), then assuming each single-instruction function is minimal by itself, infer the entirety is minimal, contradicting?</div><br/><div id="42375061" class="c"><input type="checkbox" id="c-42375061" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42374915">parent</a><span>|</span><a href="#42374534">next</a><span>|</span><label class="collapse" for="c-42375061">[-]</label><label class="expand" for="c-42375061">[1 more]</label></div><br/><div class="children"><div class="content">&gt; break each instruction into a function call<p>With values falling into just the right registers magically?<p>&gt; each single-instruction function<p>So the RET is also implicit?<p>Well, in this case taking a non-minimal function and replacing its body with function calls to single-instruction functions would indeed reduce (or leave the same) the code size because some instructions are probably repeated, and now this duplication will be removed. What&#x27;s the contradiction?</div><br/></div></div></div></div><div id="42374534" class="c"><input type="checkbox" id="c-42374534" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#42374915">prev</a><span>|</span><a href="#42374664">next</a><span>|</span><label class="collapse" for="c-42374534">[-]</label><label class="expand" for="c-42374534">[2 more]</label></div><br/><div class="children"><div class="content">&gt; The compiler optimizes for data locality<p>&gt; So, we have a single array in which every entry has the key and the value paired together. But, during lookups, we only care about the keys. The way the data is structured, we keep loading the values into the cache, wasting cache space and cycles. One way to improve that is to split this into two arrays: one for the keys and one for the values.<p>Recently someone proposed this on LLVM: <a href="https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-add-a-new-structure-layout-optimization-pass&#x2F;80596" rel="nofollow">https:&#x2F;&#x2F;discourse.llvm.org&#x2F;t&#x2F;rfc-add-a-new-structure-layout-...</a><p>Also, I think what you meant by data locality here is really optimizing data layout, which, as you also mentioned, is a hard problem. But if it&#x27;s just optimizing (cache&#x27;s) locality, I think the classic loop interchange also qualifies. Though it&#x27;s not enabled by default in LLVM, despite being there for quite a while.</div><br/><div id="42374707" class="c"><input type="checkbox" id="c-42374707" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374534">parent</a><span>|</span><a href="#42374664">next</a><span>|</span><label class="collapse" for="c-42374707">[-]</label><label class="expand" for="c-42374707">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Recently someone proposed this on LLVM<p>Well, to be honest, it&#x27;s not any extraordinary idea and it&#x27;s not even mine. Mike Acton used this exact example in his CppCon video (<a href="https:&#x2F;&#x2F;youtu.be&#x2F;rX0ItVEVjHc?t=1558" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;rX0ItVEVjHc?t=1558</a> at 25:58). I just happened to know that LLVM&#x27;s DenseMap has this problem.<p>On the other comment, data locality is a property (well... it&#x27;s not really a binary thing (i.e, an execution has it or it doesn&#x27;t), but really a spectrum; but ok, it will do) of a program. For example, a simple definition which I like is in the paper &quot;Improving Data Locality with Loop Transformations (<a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;233561.233564" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;233561.233564</a>):<p>&gt; Data locality is the property that references to the same memory location or adjacent locations are reused within a short period of time.<p>Changing the the layout is just a transformation to achieve this property. So, the two things are different in the sense that one is a property while the other is a transformation, but they&#x27;re not different in the sense that data layout transformations are not relevant to data locality.<p>Regarding cache locality, that is also a property that we could define let&#x27;s based on this (<a href="https:&#x2F;&#x2F;doi.org&#x2F;10.1109&#x2F;12.752657" rel="nofollow">https:&#x2F;&#x2F;doi.org&#x2F;10.1109&#x2F;12.752657</a>) say as: &quot;The property that data brought into cache should be reused as much as possible before it is replaced&quot;. Data locality depends on the hardware on which the program is executed. Since we use caches in our hardware, to have data locality you usually need to need have cache locality so these two coincide.<p>Finally, yes you&#x27;re absolutely right (well, last time I checked...). LLVM has a bunch of loop transformations implemented---some relevant to data locality---but they&#x27;re not turned on by default. One reason for that is that LLVM loops are too unstructured while these transformations usually need nice for-loop nests. They&#x27;re unstructured on the one hand because they&#x27;re coming e.g., from C, and OTOH because LLVM doesn&#x27;t have a loop structure, something Chris Lattner has said he regretted.</div><br/></div></div></div></div><div id="42374664" class="c"><input type="checkbox" id="c-42374664" checked=""/><div class="controls bullet"><span class="by">mshockwave</span><span>|</span><a href="#42374534">prev</a><span>|</span><a href="#42374324">next</a><span>|</span><label class="collapse" for="c-42374664">[-]</label><label class="expand" for="c-42374664">[2 more]</label></div><br/><div class="children"><div class="content">Re: Why does link-time optimization (LTO) happen at link-time?<p>I think maybe LLVM&#x27;s ThinLTO is what you&#x27;re looking for where whole-program optimization (more or less) happens in middle end.</div><br/><div id="42374765" class="c"><input type="checkbox" id="c-42374765" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374664">parent</a><span>|</span><a href="#42374324">next</a><span>|</span><label class="collapse" for="c-42374765">[-]</label><label class="expand" for="c-42374765">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know that much about ThinLTO but ThinLTO just works on summaries instead of the full code right? It still seems the linker is the one who reads these summaries (doc: <a href="https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThinLTO.html" rel="nofollow">https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThinLTO.html</a>).</div><br/></div></div></div></div><div id="42374324" class="c"><input type="checkbox" id="c-42374324" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42374664">prev</a><span>|</span><a href="#42374246">next</a><span>|</span><label class="collapse" for="c-42374324">[-]</label><label class="expand" for="c-42374324">[2 more]</label></div><br/><div class="children"><div class="content">About C&#x2F;C++ compilers, mostly.<p>C++ has terrible template and include compilation problems, for historical reasons.</div><br/><div id="42374466" class="c"><input type="checkbox" id="c-42374466" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374324">parent</a><span>|</span><a href="#42374246">next</a><span>|</span><label class="collapse" for="c-42374466">[-]</label><label class="expand" for="c-42374466">[1 more]</label></div><br/><div class="children"><div class="content">Yes, but... First, it is what it is. Second, it&#x27;s not that C++ people made bad decisions in the 80s but the decisions were great afterwards. Let&#x27;s take C++ metaprogramming in general, which templates are part of. Let&#x27;s take if constexpr (or static if) as an example, which C++ took straight from Dlang. It is useful for introspection which is almost indispensable for metaprogramming.<p>Walter Bright and Andrei Alexandrescu introduced static if in Dlang early and around 2012, they co-authored a static if proposal for C++ (<a href="https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2012&#x2F;n3329.pdf" rel="nofollow">https:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2012&#x2F;n33...</a>). Bjarne Stroustrup, in his infinite wisdom, co-authored a rebuttal that rejected it, only to realize long overdue that it&#x27;s an incredibly useful feature and introduce it in C++17.</div><br/></div></div></div></div><div id="42374246" class="c"><input type="checkbox" id="c-42374246" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42374324">prev</a><span>|</span><a href="#42374254">next</a><span>|</span><label class="collapse" for="c-42374246">[-]</label><label class="expand" for="c-42374246">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Knowing which paths are hot in any Javascript bytecode is not enough to produce optimized code; you also need to know the types. And you only know the types at runtime. This is the main reason why JIT compilers compile code at runtime.<p>You can often make good guesses statically.  Especially if your JavaScript was produced from something like a TypeScript source.</div><br/><div id="42374432" class="c"><input type="checkbox" id="c-42374432" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374246">parent</a><span>|</span><a href="#42374643">next</a><span>|</span><label class="collapse" for="c-42374432">[-]</label><label class="expand" for="c-42374432">[3 more]</label></div><br/><div class="children"><div class="content">Well, the truth is there&#x27;s a lot more to JITing than what I wrote in the article, just because JITing didn&#x27;t fit the vibe of the rest of the article that well.<p>Anyway, yes theoretically you can. Recently folks creating Codon (<a href="https:&#x2F;&#x2F;github.com&#x2F;exaloop&#x2F;codon">https:&#x2F;&#x2F;github.com&#x2F;exaloop&#x2F;codon</a>) did it for Python using a cool form of type inference.<p>That said, I don&#x27;t think any mainstream JS VMs do it. Most recent work I know in AOT compilation for JS seems to use some profile-guided optimization and not static type inference. For example, look at the architecture at 6:38 and also discussion about types here: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;pVhcyKf3efM?t=469" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;pVhcyKf3efM?t=469</a>). Something similar seems to be true for the project described here: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_T3s6-C38JI" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_T3s6-C38JI</a><p>The story seems to be a bit different for hopc: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=iY1EXHQ6IeQ" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=iY1EXHQ6IeQ</a>
The video starts by giving good examples of why it is very hard to have good type inference for JS (which agrees with my intuition) but continues to talk about using type inference. However, the benchmark in this talk and in their paper are not super convincing.<p>All that said, JS is not my expertise so I would be interested to know more about what mainstream VMs do in practice and any latest research.</div><br/><div id="42374723" class="c"><input type="checkbox" id="c-42374723" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42374246">root</a><span>|</span><a href="#42374432">parent</a><span>|</span><a href="#42374643">next</a><span>|</span><label class="collapse" for="c-42374723">[-]</label><label class="expand" for="c-42374723">[2 more]</label></div><br/><div class="children"><div class="content">Thanks!<p>I&#x27;m friends with someone working on the &#x27;Faster CPython&#x27; project.  There&#x27;s lots of interesting stuff happening there.  Both in what makes it into CPython, and even more that they are experimenting with.</div><br/><div id="42374829" class="c"><input type="checkbox" id="c-42374829" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374246">root</a><span>|</span><a href="#42374723">parent</a><span>|</span><a href="#42374643">next</a><span>|</span><label class="collapse" for="c-42374829">[-]</label><label class="expand" for="c-42374829">[1 more]</label></div><br/><div class="children"><div class="content">Oh, that&#x27;s cool! I think these are the folks that made the Specializing Adaptive Interpreter which does type specialization at runtime. If these folks have any thoughts on ahead-of-time type inference and&#x2F;or Codon, please let us know! :)</div><br/></div></div></div></div></div></div><div id="42374643" class="c"><input type="checkbox" id="c-42374643" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42374246">parent</a><span>|</span><a href="#42374432">prev</a><span>|</span><a href="#42374254">next</a><span>|</span><label class="collapse" for="c-42374643">[-]</label><label class="expand" for="c-42374643">[2 more]</label></div><br/><div class="children"><div class="content">I wonder if anyone has made a compiler that goes from TypeScript sources to binaries directly, taking advantage of types to create something much faster than Node could?<p>Also, would it be possible to keep types in JS bytecode so that an JIT can take advantage of that (similar to JVM bytecode)?</div><br/><div id="42374718" class="c"><input type="checkbox" id="c-42374718" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374246">root</a><span>|</span><a href="#42374643">parent</a><span>|</span><a href="#42374254">next</a><span>|</span><label class="collapse" for="c-42374718">[-]</label><label class="expand" for="c-42374718">[1 more]</label></div><br/><div class="children"><div class="content">For the first question, check this: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;pVhcyKf3efM?t=447" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;pVhcyKf3efM?t=447</a> at 7:27. I don&#x27;t know any details about Porforr but you may want to look into that.</div><br/></div></div></div></div></div></div><div id="42374254" class="c"><input type="checkbox" id="c-42374254" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#42374246">prev</a><span>|</span><label class="collapse" for="c-42374254">[-]</label><label class="expand" for="c-42374254">[2 more]</label></div><br/><div class="children"><div class="content">If the author is here: the link from the table of contents to &#x27;-O0 gives you fast compilation&#x27; is broken.</div><br/><div id="42374275" class="c"><input type="checkbox" id="c-42374275" checked=""/><div class="controls bullet"><span class="by">baziotis</span><span>|</span><a href="#42374254">parent</a><span>|</span><label class="collapse" for="c-42374275">[-]</label><label class="expand" for="c-42374275">[1 more]</label></div><br/><div class="children"><div class="content">Thanks, I fixed it!</div><br/></div></div></div></div></div></div></div></div></div></body></html>