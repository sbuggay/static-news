<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1728118872792" as="style"/><link rel="stylesheet" href="styles.css?v=1728118872792"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/steelbrain/ffmpeg-over-ip">Show HN: FFmpeg-over-IP – Connect to remote FFmpeg servers</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>steelbrain</span> | <span>60 comments</span></div><br/><div><div id="41748531" class="c"><input type="checkbox" id="c-41748531" checked=""/><div class="controls bullet"><span class="by">mdrzn</span><span>|</span><a href="#41748322">next</a><span>|</span><label class="collapse" for="c-41748531">[-]</label><label class="expand" for="c-41748531">[2 more]</label></div><br/><div class="children"><div class="content">&quot;Your server has a weak GPU so you want to use the GPU from your gaming machine&quot; would be my usecase for this, but it seems overly complicated, having to setup a shared filesystem.<p>I have a VPS on OVH which uses ffmpeg to convert mp3 files from 320kbps to 128kbps, it runs at 32x real speed on the server, but it could run 100x faster on my desktop pc. If there was an <i>easy</i> way to let the VPS &quot;run&quot; ffmpeg from my machine, that&#x27;d be great.</div><br/><div id="41748556" class="c"><input type="checkbox" id="c-41748556" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#41748531">parent</a><span>|</span><a href="#41748322">next</a><span>|</span><label class="collapse" for="c-41748556">[-]</label><label class="expand" for="c-41748556">[1 more]</label></div><br/><div class="children"><div class="content">Use Tailscale (or really just WireGuard) to connect the server to your desktop, run it using this tool or ssh?</div><br/></div></div></div></div><div id="41748322" class="c"><input type="checkbox" id="c-41748322" checked=""/><div class="controls bullet"><span class="by">maxlin</span><span>|</span><a href="#41748531">prev</a><span>|</span><a href="#41745846">next</a><span>|</span><label class="collapse" for="c-41748322">[-]</label><label class="expand" for="c-41748322">[1 more]</label></div><br/><div class="children"><div class="content">I wrote something similar to this. Instead of requiring a shared network drive, dependent files are automatically detected and transferred over with HTTP, and as an advanced feature, it splits the video to chunks to allow 20x+ encode speeds, concurrently utilizing multiple machines to encode a single input file and utilizing NVENC. Video is then concatenated together and API for that mode is identical.<p>Wrote it in C# and it runs both on Windows and Linux. The original need for this actually was to accelerate encodes a system I run on a cloud VM needs when I have either my desktop or laptop available, who then work as encode slaves and pick up jobs, run them and send the output files back. If no slaves are available, the system falls back to local CPU encode. Later I ended up using this using a local Windows server machine as the &quot;client&quot; the slaves also connect to to ask for jobs (actually the system runs inside a Unity project in that case because C# is awesome).<p>Probably a bit of a rare problem I hit with this is that different NVENC generations generate different enough bitstreams that they can&#x27;t be concatenated together. From my pool of machines I found out only my RTX 2070 and RTX 3080 Mobile are compatible. GTX 970 and Quadro P5000 that I had laying around both were incompatible with that pool and with each other.<p>Interestingly I found no similar software to the chunked encoding in my system, but am chalking it up on me not searching hard enough or these being integrated deep in to commercial&#x2F;private systems. It would make sense that big players like YouTube have something like this in place, as reducing latency for individual upload transcodes finishing is beneficial instead of limiting their speed to a single hardware encoding &#x2F; software encoding node. It&#x27;s the same amount of processing that needs to be done in the end anyway, so might as well use 10 nodes to complete single jobs really quickly one after another</div><br/></div></div><div id="41745846" class="c"><input type="checkbox" id="c-41745846" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41748322">prev</a><span>|</span><a href="#41745809">next</a><span>|</span><label class="collapse" for="c-41745846">[-]</label><label class="expand" for="c-41745846">[16 more]</label></div><br/><div class="children"><div class="content">&gt; need a shared filesystem for this to work<p>Oh oof. I thought removing that requirement would be the whole point of something named &quot;FFmpeg-over-IP&quot;. Shared filesystem usually involves full trust between machines, bad network error handling, and setting things up by hand (different config on every distro)</div><br/><div id="41745893" class="c"><input type="checkbox" id="c-41745893" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745846">parent</a><span>|</span><a href="#41746451">next</a><span>|</span><label class="collapse" for="c-41745893">[-]</label><label class="expand" for="c-41745893">[8 more]</label></div><br/><div class="children"><div class="content">I hear you. If your usecase doesn&#x27;t require live streaming of converted file, a sibling comment may fit the usecase: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41745593">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41745593</a></div><br/><div id="41748471" class="c"><input type="checkbox" id="c-41748471" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41745893">parent</a><span>|</span><a href="#41745926">next</a><span>|</span><label class="collapse" for="c-41748471">[-]</label><label class="expand" for="c-41748471">[1 more]</label></div><br/><div class="children"><div class="content">One could write a small Python server in one day which receives a chunked POST request and transcodes the video on the fly.<p>The same server could also offer a download link for the transcoded video, and also receive URL parameters for the transcoding options. Or the transcoded video itself is returned after the subprocess finishes.<p>Something along the lines of:<p>Server<p><pre><code>  import asyncio
  import subprocess
  from aiohttp import web
  async def transcode_video(request):
      cmd = [
          &quot;ffmpeg&quot;,
          &quot;-i&quot;, &quot;pipe:0&quot;,
          &quot;-f&quot;, &quot;mp4&quot;,
          &quot;-preset&quot;, &quot;fast&quot;,
          &quot;output_file.mp4&quot;
      ]
      process = await asyncio.create_subprocess_exec(
          *cmd,
          stdin=subprocess.PIPE,
          stdout=subprocess.PIPE,
          stderr=subprocess.PIPE
      )
      async for chunk in request.content.iter_any():
          process.stdin.write(chunk)
          await process.stdin.drain()
      await process.stdin.close()
      await process.wait()
      return web.Response(text=&quot;Video transcoded successfully!&quot;)
  app = web.Application()
  app.router.add_post(&#x27;&#x2F;upload&#x27;, transcode_video)
  if __name__ == &#x27;__main__&#x27;:
      web.run_app(app, port=8080)
</code></pre>
Client<p><pre><code>  curl -X POST http:&#x2F;&#x2F;&lt;server_ip&gt;:8080&#x2F;upload \
       --header &quot;Content-Type: application&#x2F;octet-stream&quot; \
       --data-binary @video.mp4

</code></pre>
This way no shared filesystem is required.</div><br/></div></div><div id="41745926" class="c"><input type="checkbox" id="c-41745926" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41745893">parent</a><span>|</span><a href="#41748471">prev</a><span>|</span><a href="#41746451">next</a><span>|</span><label class="collapse" for="c-41745926">[-]</label><label class="expand" for="c-41745926">[6 more]</label></div><br/><div class="children"><div class="content">Ah unfortunately my use case is similar to yours: Use Windows desktop to transcode files stored on a Linux NAS. My files are ~100GB so encoding multiple files in parallel would waste a lot of space and unnecessarily burn write cycles</div><br/><div id="41745948" class="c"><input type="checkbox" id="c-41745948" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41745926">parent</a><span>|</span><a href="#41748452">prev</a><span>|</span><a href="#41746451">next</a><span>|</span><label class="collapse" for="c-41745948">[-]</label><label class="expand" for="c-41745948">[4 more]</label></div><br/><div class="children"><div class="content">FWIW, you can run an smb server from within a docker container (on the linux side). I forget which one I used but it makes the setup painless and you can configure different auth strategies as well. Network errors (little bit of packet loss) are generally handled by the underlying OS, and in case of windows, it can use multiple network paths simultaneously to give you the aggregate bandwidth.</div><br/><div id="41746774" class="c"><input type="checkbox" id="c-41746774" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41745948">parent</a><span>|</span><a href="#41746451">next</a><span>|</span><label class="collapse" for="c-41746774">[-]</label><label class="expand" for="c-41746774">[3 more]</label></div><br/><div class="children"><div class="content">You typically don’t even have to go to that length. This is usually supported out of the box.<p>No idea what problem this is trying to solve. Just seems like the user wasn’t familiar enough with how to use a NAS.</div><br/><div id="41747820" class="c"><input type="checkbox" id="c-41747820" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41746774">parent</a><span>|</span><a href="#41747186">next</a><span>|</span><label class="collapse" for="c-41747820">[-]</label><label class="expand" for="c-41747820">[1 more]</label></div><br/><div class="children"><div class="content">&gt; out of the box<p>If you&#x27;re talking about how today&#x27;s open source NAS software has a button for enabling NFS&#x2F;SMB on a directory:<p>1. I built my NAS long before software like that was common. Some of my custom stuff (Eg tiered storage, storing the first few seconds of every video on flash, etc) would be a pain to migrate.<p>2. Some of my Windows machines are untrusted. Unlike the NAS, they have internet access. I can&#x27;t give them read access to the entire NAS, but I still want to use their GPUs and CPUs to run ffmpeg on arbitrary files on the NAS.<p>3. I could spend a day writing more code to move files in and out of a shared directory every time I need to run ffmpeg on them. But I was hoping &quot;FFmpeg-over-IP&quot; would let me run a remote ffmpeg on a local file. Like calling an RPC</div><br/></div></div><div id="41747186" class="c"><input type="checkbox" id="c-41747186" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41746774">parent</a><span>|</span><a href="#41747820">prev</a><span>|</span><a href="#41746451">next</a><span>|</span><label class="collapse" for="c-41747186">[-]</label><label class="expand" for="c-41747186">[1 more]</label></div><br/><div class="children"><div class="content">More like you’re not familiar enough with the video encoding performance of a typical NAS that is not in the thousand dollar range. Or what’s a NAS — it can be anything really.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41746451" class="c"><input type="checkbox" id="c-41746451" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#41745846">parent</a><span>|</span><a href="#41745893">prev</a><span>|</span><a href="#41745809">next</a><span>|</span><label class="collapse" for="c-41746451">[-]</label><label class="expand" for="c-41746451">[7 more]</label></div><br/><div class="children"><div class="content">Couldn&#x27;t you create and share a virtual file system with FUSE?</div><br/><div id="41746681" class="c"><input type="checkbox" id="c-41746681" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41746451">parent</a><span>|</span><a href="#41746461">next</a><span>|</span><label class="collapse" for="c-41746681">[-]</label><label class="expand" for="c-41746681">[4 more]</label></div><br/><div class="children"><div class="content">Mounting anything requires root even if you use FUSE.<p>There are ways to intercept writes without root and send them to another machine. Eg you could use LD_PRELOAD. But that&#x27;s exactly the kind of pain in the ass that I was hoping a project named FFmpeg-over-IP would automate.</div><br/><div id="41747263" class="c"><input type="checkbox" id="c-41747263" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41746681">parent</a><span>|</span><a href="#41746461">next</a><span>|</span><label class="collapse" for="c-41747263">[-]</label><label class="expand" for="c-41747263">[3 more]</label></div><br/><div class="children"><div class="content">mount doesn&#x27;t require root, but even without getting into mount namespaces, this is why fusermount3 exists</div><br/><div id="41747826" class="c"><input type="checkbox" id="c-41747826" checked=""/><div class="controls bullet"><span class="by">NavinF</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41747263">parent</a><span>|</span><a href="#41746461">next</a><span>|</span><label class="collapse" for="c-41747826">[-]</label><label class="expand" for="c-41747826">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, the man page says &quot;To allow mounting and unmounting by unprivileged users, fusermount3 needs to be installed set-uid root&quot;. Is this the default case on any distros?</div><br/><div id="41747880" class="c"><input type="checkbox" id="c-41747880" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41747826">parent</a><span>|</span><a href="#41746461">next</a><span>|</span><label class="collapse" for="c-41747880">[-]</label><label class="expand" for="c-41747880">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the case on all distros that distribute it, because otherwise it&#x27;s useless.</div><br/></div></div></div></div></div></div></div></div><div id="41746461" class="c"><input type="checkbox" id="c-41746461" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41746451">parent</a><span>|</span><a href="#41746681">prev</a><span>|</span><a href="#41745809">next</a><span>|</span><label class="collapse" for="c-41746461">[-]</label><label class="expand" for="c-41746461">[2 more]</label></div><br/><div class="children"><div class="content">Like SSHFS, or something custom? And how much does that help with any of those concerns?</div><br/><div id="41746543" class="c"><input type="checkbox" id="c-41746543" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#41745846">root</a><span>|</span><a href="#41746461">parent</a><span>|</span><a href="#41745809">next</a><span>|</span><label class="collapse" for="c-41746543">[-]</label><label class="expand" for="c-41746543">[1 more]</label></div><br/><div class="children"><div class="content">The primary concern is trust&#x2F;security.<p>User space limits potential security impacts, and a restricted VFS could be used to prevent clients from accessing anything that they shouldn&#x27;t.<p>(Although I&#x27;m not even pretending to know whether or not this is a remotely good idea - my guess is that it isn&#x27;t, but I&#x27;d like to know just how bad an idea it actually is.)</div><br/></div></div></div></div></div></div></div></div><div id="41745809" class="c"><input type="checkbox" id="c-41745809" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#41745846">prev</a><span>|</span><a href="#41745447">next</a><span>|</span><label class="collapse" for="c-41745809">[-]</label><label class="expand" for="c-41745809">[5 more]</label></div><br/><div class="children"><div class="content">IDK, this lacks a lot of examples and explaining what exactly it is for. Is it for remote transcoding only?<p>Because if so, the word <i>transcoding</i> does not appear neither in this Show HN nor in the GitHub README.<p>And I can&#x27;t think of any other use for this than to perform hardware-assisted transcoding on a remote machine.<p>Apparently it has nothing to do with OpenGL or CUDA, which are the primary uses for a GPU. And ffmpeg itself has more use cases than just transcoding files.</div><br/><div id="41746425" class="c"><input type="checkbox" id="c-41746425" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#41745809">parent</a><span>|</span><a href="#41745447">next</a><span>|</span><label class="collapse" for="c-41746425">[-]</label><label class="expand" for="c-41746425">[4 more]</label></div><br/><div class="children"><div class="content">I question for why not just SSH into the more powerful computer to run the ffmpeg command like a normal person. Why would you need to install a server and client? There are plenty of binaries available for ffmpeg to avoid compiling from source difficulties.<p>Solutions like these are the things that just make me tilt my head and make the clueless &quot;huh?&quot; sound.</div><br/><div id="41747241" class="c"><input type="checkbox" id="c-41747241" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41745809">root</a><span>|</span><a href="#41746425">parent</a><span>|</span><a href="#41745447">next</a><span>|</span><label class="collapse" for="c-41747241">[-]</label><label class="expand" for="c-41747241">[3 more]</label></div><br/><div class="children"><div class="content">Because OpenSSH on Windows is a shitshow. Mounted SMB shares can’t be accessed because they’re tied to login sessions, and you can’t mount them from within an SSH session (IIRC in theory you can, but in practice it never worked for me).[1] Which means ffmpeg is practically useless if you need input that you can’t (e.g. livestream) or don’t want to copy in advance, or need output in realtime.<p>At least that’s why I built something similar in Go for myself.<p>Before anyone mentions WSL: it either didn’t support GPU passthrough or was very difficult to configure when I set this up a few years ago, don’t know about current status. And you can’t call Windows executables from WSL when you SSH into it.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;PowerShell&#x2F;Win32-OpenSSH&#x2F;issues&#x2F;139">https:&#x2F;&#x2F;github.com&#x2F;PowerShell&#x2F;Win32-OpenSSH&#x2F;issues&#x2F;139</a></div><br/><div id="41747492" class="c"><input type="checkbox" id="c-41747492" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#41745809">root</a><span>|</span><a href="#41747241">parent</a><span>|</span><a href="#41745447">next</a><span>|</span><label class="collapse" for="c-41747492">[-]</label><label class="expand" for="c-41747492">[2 more]</label></div><br/><div class="children"><div class="content">there are other ways to mount drives. you can even mount drives on a PC like normal computers with a &quot;&#x2F;&quot; mount point instead of ridiculous C:\ stuff that does not require WSL.<p>you can use a URI as an input to ffmpeg which allows for not needing access to a C:\. pretty much any decent NAS will allow access via URI instead of drive letter mounts.<p>if something was learned during the building of the server&#x2F;client app, then great if that&#x27;s why it was done. but it&#x27;s only one of the 99 ways of skinning the cat, and probably not even close to the best one.</div><br/><div id="41747930" class="c"><input type="checkbox" id="c-41747930" checked=""/><div class="controls bullet"><span class="by">oefrha</span><span>|</span><a href="#41745809">root</a><span>|</span><a href="#41747492">parent</a><span>|</span><a href="#41745447">next</a><span>|</span><label class="collapse" for="c-41747930">[-]</label><label class="expand" for="c-41747930">[1 more]</label></div><br/><div class="children"><div class="content">Don’t know why you’re fixated on NAS, I use my program mostly from my Mac laptop and desktop, and it allows me to simply replace ffmpeg with ffmpeg-remote, nothing more, which is not true for ssh (thanks double quoting). The thing took me less than hour to write and has been running for years, I don’t need to learn anything new to justify the trivial amount of investment. I also wrote a simple utility to monitor all my ffmpeg-remote processes, reporting all kinds of statistics, which is more involved if I was running a raw ssh command. And who cares about “the best” way, and who are you to decide my simple solution isn’t the best for me?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41745447" class="c"><input type="checkbox" id="c-41745447" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#41745809">prev</a><span>|</span><a href="#41743932">next</a><span>|</span><label class="collapse" for="c-41745447">[-]</label><label class="expand" for="c-41745447">[10 more]</label></div><br/><div class="children"><div class="content">this is really not much different from ssh-ing to your GPU server and running ffmpeg. Very roundabout way to execute remote bash command on a server<p>I dont meant to discourage you, but it is possible to replace your entire repo with a simple bash alias:<p><pre><code>  alias ffmpeg-over-ip=&#x27;ssh myserver &quot;ffmpeg \&quot;\$@\&quot;&quot;&#x27;</code></pre></div><br/><div id="41745500" class="c"><input type="checkbox" id="c-41745500" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745447">parent</a><span>|</span><a href="#41745921">next</a><span>|</span><label class="collapse" for="c-41745500">[-]</label><label class="expand" for="c-41745500">[5 more]</label></div><br/><div class="children"><div class="content">This comment gave me flashbacks to another comment I read a while ago: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9224">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9224</a><p>If <i>your</i> usecase is solved by an alias, that&#x27;s really good! I am glad you can use an alias. My usecase required a bit more so I wrote this utility and am sharing it with my peers</div><br/><div id="41745525" class="c"><input type="checkbox" id="c-41745525" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#41745447">root</a><span>|</span><a href="#41745500">parent</a><span>|</span><a href="#41745555">next</a><span>|</span><label class="collapse" for="c-41745525">[-]</label><label class="expand" for="c-41745525">[2 more]</label></div><br/><div class="children"><div class="content">Dropbox had a cutting edge file synchronization algorithm, they solved a problem of large file sync over unreliable network. There was a clear engineering IP they developed. (<a href="https:&#x2F;&#x2F;dropbox.tech&#x2F;infrastructure&#x2F;rewriting-the-heart-of-our-sync-engine" rel="nofollow">https:&#x2F;&#x2F;dropbox.tech&#x2F;infrastructure&#x2F;rewriting-the-heart-of-o...</a>)<p>I looked over your source code and just saw a bash wrapper with webserver, so no significant IP. Any potential innovations: like possible distributed transcoding, sharding&#x2F;partitioning transcoding pipeline to speed-up are missing.<p>its just a bash wrapper, thats why I commented about bash alias.<p>I don&#x27;t mean to sound like a jerk, but I was honestly looking for some innovation about ffmpeg</div><br/><div id="41745639" class="c"><input type="checkbox" id="c-41745639" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745447">root</a><span>|</span><a href="#41745525">parent</a><span>|</span><a href="#41745555">next</a><span>|</span><label class="collapse" for="c-41745639">[-]</label><label class="expand" for="c-41745639">[1 more]</label></div><br/><div class="children"><div class="content">This was not meant to offend. I appreciate you explaining your message further.<p>There&#x27;s no significant IP in this utility, it&#x27;s something I wrote for a usecase and it works well for that usecase. I ran the server side on a windows machine, and I did not want to setup a full blown ssh server and expose it over the network for this usecase.<p>Another thing was logging. The way logging is currently setup really hits the sweet spot for debugability for me. Lastly it&#x27;s the rewrites. I&#x27;ve used the config to rewrite incoming codecs to something the machine supports.<p>This is a purpose built utility that does one job and IMO does it fairly well. It&#x27;s definitely not as complex as Dropbox but also not as simple as an ssh alias. I appreciate you sharing the alias code (not just the comment) so if some of our peers have usecases that could be solved by it, they are welcome to use that as well!</div><br/></div></div></div></div><div id="41745555" class="c"><input type="checkbox" id="c-41745555" checked=""/><div class="controls bullet"><span class="by">KolmogorovComp</span><span>|</span><a href="#41745447">root</a><span>|</span><a href="#41745500">parent</a><span>|</span><a href="#41745525">prev</a><span>|</span><a href="#41745921">next</a><span>|</span><label class="collapse" for="c-41745555">[-]</label><label class="expand" for="c-41745555">[2 more]</label></div><br/><div class="children"><div class="content">&gt; My usecase required a bit more so I wrote this utility and am sharing it with my peers<p>Can you expand on that?</div><br/><div id="41745599" class="c"><input type="checkbox" id="c-41745599" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745447">root</a><span>|</span><a href="#41745555">parent</a><span>|</span><a href="#41745921">next</a><span>|</span><label class="collapse" for="c-41745599">[-]</label><label class="expand" for="c-41745599">[1 more]</label></div><br/><div class="children"><div class="content">For sure! One of the software I was working with was hardcoding what codecs it would use based on the operating system it was running on. The rewrites section of the configuration allows more than just file paths, I&#x27;ve used it to rewrite incoming codec requests</div><br/></div></div></div></div></div></div><div id="41745921" class="c"><input type="checkbox" id="c-41745921" checked=""/><div class="controls bullet"><span class="by">asveikau</span><span>|</span><a href="#41745447">parent</a><span>|</span><a href="#41745500">prev</a><span>|</span><a href="#41745538">next</a><span>|</span><label class="collapse" for="c-41745921">[-]</label><label class="expand" for="c-41745921">[1 more]</label></div><br/><div class="children"><div class="content">I would add screen or tmux to that because you may run a long job that you may want to get back to after a connection drop.</div><br/></div></div><div id="41745538" class="c"><input type="checkbox" id="c-41745538" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#41745447">parent</a><span>|</span><a href="#41745921">prev</a><span>|</span><a href="#41743932">next</a><span>|</span><label class="collapse" for="c-41745538">[-]</label><label class="expand" for="c-41745538">[3 more]</label></div><br/><div class="children"><div class="content">I suppose this only works if you have some shared filesystem. Or does this work with piping too?</div><br/><div id="41745593" class="c"><input type="checkbox" id="c-41745593" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#41745447">root</a><span>|</span><a href="#41745538">parent</a><span>|</span><a href="#41743932">next</a><span>|</span><label class="collapse" for="c-41745593">[-]</label><label class="expand" for="c-41745593">[2 more]</label></div><br/><div class="children"><div class="content">the original poster&#x27;s project also requires shared filesystem.<p>as for bash-ssh solution, you don&#x27;t need shared FS, if you don&#x27;t need intermediate results. you can use SCP to get the final result after transcoding has finished. something like:<p><pre><code>  alias ffmpeg-over-ip=&#x27;ssh myserver &quot;ffmpeg \&quot;\$@\&quot; &#x2F;tmp&#x2F;output&#x2F;&quot;&#x27;
  alias download-results=&#x27;scp myserver:&#x2F;tmp&#x2F;output&#x2F;*.* .&#x27;

  ffmpeg-over-ip &lt;args&gt; &amp;&amp; download-results


</code></pre>
my meta point being is, before engineering something with programming language, and handrolling webservers, with auth, and workers - just try to implement your system with bash scripts.<p>Martin Klepmann created an entire database using just bash aliases in his book &quot;Designing Data Intensive Applications&quot;</div><br/><div id="41747924" class="c"><input type="checkbox" id="c-41747924" checked=""/><div class="controls bullet"><span class="by">whoopdedo</span><span>|</span><a href="#41745447">root</a><span>|</span><a href="#41745593">parent</a><span>|</span><a href="#41743932">next</a><span>|</span><label class="collapse" for="c-41747924">[-]</label><label class="expand" for="c-41747924">[1 more]</label></div><br/><div class="children"><div class="content">Even the temporary file is optional. Ffmpeg supports a number of network protocols. For instance, you could read from one port and write to another with<p><pre><code>    ffmpeg -f webm -i tcp:&#x2F;&#x2F;[::]:55601?listen -c copy -f webm tcp:&#x2F;&#x2F;[::]:55602?listen
</code></pre>
There&#x27;s also UDP, SFTP, and more convenient protocols such as SRT or the long-in-the-tooth RTMP. I expect it will eventually add WHIP&#x2F;WHEP as well.</div><br/></div></div></div></div></div></div></div></div><div id="41743932" class="c"><input type="checkbox" id="c-41743932" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745447">prev</a><span>|</span><a href="#41746787">next</a><span>|</span><label class="collapse" for="c-41743932">[-]</label><label class="expand" for="c-41743932">[1 more]</label></div><br/><div class="children"><div class="content">There is an existing solution in the community called rffmpeg[1] but that did not work for me. It seems too heavy weight for what I was trying to do. It requires access to sudo, global configuration files (&#x2F;etc&#x2F;) and most importantly, this, which is a deal-breaker for me:<p>&gt; Note that if hardware acceleration is configured in the calling application, the exact same hardware acceleration modes must be available on all configured hosts, and, for fallback to work, the local host as well, or the ffmpeg commands will fail.<p>I wanted to mix and match windows and linux, and it was clear rffmpeg wasn&#x27;t going to work for me.<p>One plus rffmpeg does have is that it supports multiple target hosts, so it&#x27;s useful if you want some load balancing action. Although you could do the same with ffmpeg-over-ip, just selecting the servers dynamically but rffmpeg does make it easier out of the box.<p>[1]:<a href="https:&#x2F;&#x2F;github.com&#x2F;joshuaboniface&#x2F;rffmpeg">https:&#x2F;&#x2F;github.com&#x2F;joshuaboniface&#x2F;rffmpeg</a></div><br/></div></div><div id="41746787" class="c"><input type="checkbox" id="c-41746787" checked=""/><div class="controls bullet"><span class="by">wwalexander</span><span>|</span><a href="#41743932">prev</a><span>|</span><a href="#41743813">next</a><span>|</span><label class="collapse" for="c-41746787">[-]</label><label class="expand" for="c-41746787">[2 more]</label></div><br/><div class="children"><div class="content">How does this compare with the built-in ffserver? <a href="https:&#x2F;&#x2F;trac.ffmpeg.org&#x2F;wiki&#x2F;ffserver" rel="nofollow">https:&#x2F;&#x2F;trac.ffmpeg.org&#x2F;wiki&#x2F;ffserver</a></div><br/><div id="41748391" class="c"><input type="checkbox" id="c-41748391" checked=""/><div class="controls bullet"><span class="by">qwertox</span><span>|</span><a href="#41746787">parent</a><span>|</span><a href="#41743813">next</a><span>|</span><label class="collapse" for="c-41748391">[-]</label><label class="expand" for="c-41748391">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Warning: ffserver has been removed on 2018-01-06.</div><br/></div></div></div></div><div id="41743813" class="c"><input type="checkbox" id="c-41743813" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41746787">prev</a><span>|</span><a href="#41746600">next</a><span>|</span><label class="collapse" for="c-41743813">[-]</label><label class="expand" for="c-41743813">[2 more]</label></div><br/><div class="children"><div class="content">The latest release[1] on Github should have binaries combinations for almost everybody here. If you don&#x27;t find a binary for your environment, you can probably just run the javascript files and it&#x27;ll be fine.<p>If you are wondering why the binaries are so large, it&#x27;s because they are packaged-up node.js binaries. I tried to learn a compile-to-native language to rewrite this in so you won&#x27;t have to download such bloated binaries but didn&#x27;t get far. I learned Swift and still have a WIP branch up for it[2]. I gave up after learning that there&#x27;s no well maintained windows http server for swift.<p>I&#x27;m currently on my journey to learn Rust. So maybe one day when I do, you&#x27;ll see the binary sizes drop.<p>[1]:<a href="https:&#x2F;&#x2F;github.com&#x2F;steelbrain&#x2F;ffmpeg-over-ip&#x2F;releases&#x2F;tag&#x2F;v3.0.0">https:&#x2F;&#x2F;github.com&#x2F;steelbrain&#x2F;ffmpeg-over-ip&#x2F;releases&#x2F;tag&#x2F;v3...</a>
[2]:<a href="https:&#x2F;&#x2F;github.com&#x2F;steelbrain&#x2F;ffmpeg-over-ip&#x2F;tree&#x2F;swift-lang">https:&#x2F;&#x2F;github.com&#x2F;steelbrain&#x2F;ffmpeg-over-ip&#x2F;tree&#x2F;swift-lang</a></div><br/><div id="41745574" class="c"><input type="checkbox" id="c-41745574" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#41743813">parent</a><span>|</span><a href="#41746600">next</a><span>|</span><label class="collapse" for="c-41745574">[-]</label><label class="expand" for="c-41745574">[1 more]</label></div><br/><div class="children"><div class="content">Go would be a good fit for this kind of application. But Rust is a great choice too.<p>Keep up the good work!</div><br/></div></div></div></div><div id="41746600" class="c"><input type="checkbox" id="c-41746600" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#41743813">prev</a><span>|</span><a href="#41746465">next</a><span>|</span><label class="collapse" for="c-41746600">[-]</label><label class="expand" for="c-41746600">[5 more]</label></div><br/><div class="children"><div class="content">As other comments have suggested it&#x27;s difficult to imagine that this has a lot of advantages to simply using pipes over ssh. And pipes don&#x27;t need a shared filesystem either.<p>I suppose ssh would be tricky if you&#x27;re combining multiple input files.</div><br/><div id="41747198" class="c"><input type="checkbox" id="c-41747198" checked=""/><div class="controls bullet"><span class="by">_hyn3</span><span>|</span><a href="#41746600">parent</a><span>|</span><a href="#41746465">next</a><span>|</span><label class="collapse" for="c-41747198">[-]</label><label class="expand" for="c-41747198">[4 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>   xargs</code></pre></div><br/><div id="41747443" class="c"><input type="checkbox" id="c-41747443" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#41746600">root</a><span>|</span><a href="#41747198">parent</a><span>|</span><a href="#41746465">next</a><span>|</span><label class="collapse" for="c-41747443">[-]</label><label class="expand" for="c-41747443">[3 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t help send multiple files over a single pipe. You can&#x27;t just cat them.</div><br/><div id="41747713" class="c"><input type="checkbox" id="c-41747713" checked=""/><div class="controls bullet"><span class="by">bqmjjx0kac</span><span>|</span><a href="#41746600">root</a><span>|</span><a href="#41747443">parent</a><span>|</span><a href="#41746465">next</a><span>|</span><label class="collapse" for="c-41747713">[-]</label><label class="expand" for="c-41747713">[2 more]</label></div><br/><div class="children"><div class="content">You can `tar` them though :)</div><br/><div id="41747907" class="c"><input type="checkbox" id="c-41747907" checked=""/><div class="controls bullet"><span class="by">LeoPanthera</span><span>|</span><a href="#41746600">root</a><span>|</span><a href="#41747713">parent</a><span>|</span><a href="#41746465">next</a><span>|</span><label class="collapse" for="c-41747907">[-]</label><label class="expand" for="c-41747907">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, although that requires storage on the other end. Not too much of a problem in most cases, perhaps.<p>But with single input, single output, you can just do:<p><pre><code>  ssh destination &quot;ffmpeg -switches&quot; &lt;infile &gt;outfile</code></pre></div><br/></div></div></div></div></div></div></div></div></div></div><div id="41746465" class="c"><input type="checkbox" id="c-41746465" checked=""/><div class="controls bullet"><span class="by">seltzered_</span><span>|</span><a href="#41746600">prev</a><span>|</span><a href="#41745263">next</a><span>|</span><label class="collapse" for="c-41746465">[-]</label><label class="expand" for="c-41746465">[1 more]</label></div><br/><div class="children"><div class="content">Can this possibly be helpful for second-screen (aka extended display) scenarios between a PC and a tablet&#x2F;phone?<p>Thinking of <a href="https:&#x2F;&#x2F;tuxphones.com&#x2F;howto-linux-as-second-wireless-display-for-linux&#x2F;" rel="nofollow">https:&#x2F;&#x2F;tuxphones.com&#x2F;howto-linux-as-second-wireless-display...</a> -&gt; <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;tuxphones&#x2F;side-displays" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;tuxphones&#x2F;side-displays</a> but for those running android or ios</div><br/></div></div><div id="41745263" class="c"><input type="checkbox" id="c-41745263" checked=""/><div class="controls bullet"><span class="by">leshokunin</span><span>|</span><a href="#41746465">prev</a><span>|</span><a href="#41743829">next</a><span>|</span><label class="collapse" for="c-41745263">[-]</label><label class="expand" for="c-41745263">[4 more]</label></div><br/><div class="children"><div class="content">Sounds super interesting. Maybe the people currently using Tdarr would prefer something like this. I could also imagine something like Plex or Jellyfin making use of this tech and offloading transcoding. Hope this takes off.</div><br/><div id="41745280" class="c"><input type="checkbox" id="c-41745280" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745263">parent</a><span>|</span><a href="#41743829">next</a><span>|</span><label class="collapse" for="c-41745280">[-]</label><label class="expand" for="c-41745280">[3 more]</label></div><br/><div class="children"><div class="content">Thanks! I developed this primarily for plex &amp; jellyfin after struggling with Tdarr myself. For people running plex&#x2F;jellyfin in containers, it&#x27;s as simple as mounting the client binary at the ffmpeg path (using docker -v) and adding the config somewhere accessible (also using docker -v? lots of options here).</div><br/><div id="41746071" class="c"><input type="checkbox" id="c-41746071" checked=""/><div class="controls bullet"><span class="by">blue_cookeh</span><span>|</span><a href="#41745263">root</a><span>|</span><a href="#41745280">parent</a><span>|</span><a href="#41745661">next</a><span>|</span><label class="collapse" for="c-41746071">[-]</label><label class="expand" for="c-41746071">[1 more]</label></div><br/><div class="children"><div class="content">Does this work well with Plex and if so, what binary are you replacing? Last I looked they used a customised fork of ffmpeg which meant replacing it was more awkward. It would be a nice way to avoid passing a GPU through to a virtual machine.</div><br/></div></div><div id="41745661" class="c"><input type="checkbox" id="c-41745661" checked=""/><div class="controls bullet"><span class="by">leshokunin</span><span>|</span><a href="#41745263">root</a><span>|</span><a href="#41745280">parent</a><span>|</span><a href="#41746071">prev</a><span>|</span><a href="#41743829">next</a><span>|</span><label class="collapse" for="c-41745661">[-]</label><label class="expand" for="c-41745661">[1 more]</label></div><br/><div class="children"><div class="content">Maybe you could make guides and post it on the various synology and self hosting subreddits. I could see this get traction</div><br/></div></div></div></div></div></div><div id="41743829" class="c"><input type="checkbox" id="c-41743829" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745263">prev</a><span>|</span><a href="#41747201">next</a><span>|</span><label class="collapse" for="c-41743829">[-]</label><label class="expand" for="c-41743829">[2 more]</label></div><br/><div class="children"><div class="content">Here[1] is the original HN comment that inspired me to do a Show HN :)<p>[1]:<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41205253">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=41205253</a></div><br/><div id="41745445" class="c"><input type="checkbox" id="c-41745445" checked=""/><div class="controls bullet"><span class="by">toomuchtodo</span><span>|</span><a href="#41743829">parent</a><span>|</span><a href="#41747201">next</a><span>|</span><label class="collapse" for="c-41745445">[-]</label><label class="expand" for="c-41745445">[1 more]</label></div><br/><div class="children"><div class="content">Thank you for the Show HN!</div><br/></div></div></div></div><div id="41745646" class="c"><input type="checkbox" id="c-41745646" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41747201">prev</a><span>|</span><a href="#41745355">next</a><span>|</span><label class="collapse" for="c-41745646">[-]</label><label class="expand" for="c-41745646">[2 more]</label></div><br/><div class="children"><div class="content">Not to steal thunder (nice! Well done!) but also this reminded me to go check in on <a href="https:&#x2F;&#x2F;kyber.media" rel="nofollow">https:&#x2F;&#x2F;kyber.media</a> (currently a landing page),  a ffmpeg streaming project from me ffmmpeg himself (I think?) Jean-Baptiste Kempf. He had a LinkedIn update two weeks ago, mentioning the effort! Yay! <a href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;posts&#x2F;jbkempf_playruo-the-worlds-first-click-and-play-activity-7241806921547005952-wruW" rel="nofollow">https:&#x2F;&#x2F;www.linkedin.com&#x2F;posts&#x2F;jbkempf_playruo-the-worlds-fi...</a><p>Submission from 6 months ago,
<a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39929602">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39929602</a> <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0RvosCplkCc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0RvosCplkCc</a></div><br/><div id="41745650" class="c"><input type="checkbox" id="c-41745650" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745646">parent</a><span>|</span><a href="#41745355">next</a><span>|</span><label class="collapse" for="c-41745650">[-]</label><label class="expand" for="c-41745650">[1 more]</label></div><br/><div class="children"><div class="content">Very cool! Thank you for sharing!</div><br/></div></div></div></div><div id="41745355" class="c"><input type="checkbox" id="c-41745355" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#41745646">prev</a><span>|</span><a href="#41745885">next</a><span>|</span><label class="collapse" for="c-41745355">[-]</label><label class="expand" for="c-41745355">[1 more]</label></div><br/><div class="children"><div class="content">I used to use dvd::rip [1] (written in perl) that was sort of a similar concept.  Deploy transcode jobs onto a cluster of servers  accessing a shared filesystem (nfs, smb, etc.).  worked really well.  I think it used gstreamer though.  I set up a homelab of a bunch of pentium 3s that I salvaged from a PC recycler behind my work.  They just had a big pile of obsolete computers covered by a tarp.  I grabbed a few chassis with working motherboards, and then scrounged around for the best intel CPUs I could find.  and memory sticks.  I put together a fun little DVD-ripping factory with those machines.<p>[1] <a href="https:&#x2F;&#x2F;www.exit1.org&#x2F;dvdrip&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.exit1.org&#x2F;dvdrip&#x2F;</a></div><br/></div></div><div id="41745885" class="c"><input type="checkbox" id="c-41745885" checked=""/><div class="controls bullet"><span class="by">Am4TIfIsER0ppos</span><span>|</span><a href="#41745355">prev</a><span>|</span><a href="#41745309">next</a><span>|</span><label class="collapse" for="c-41745885">[-]</label><label class="expand" for="c-41745885">[1 more]</label></div><br/><div class="children"><div class="content">I can encode faster than I can upload.  Might be useful if you have gigabit to a computer more powerful than one in your home.</div><br/></div></div><div id="41745309" class="c"><input type="checkbox" id="c-41745309" checked=""/><div class="controls bullet"><span class="by">ptspts</span><span>|</span><a href="#41745885">prev</a><span>|</span><label class="collapse" for="c-41745309">[-]</label><label class="expand" for="c-41745309">[3 more]</label></div><br/><div class="children"><div class="content">What problem does it solve?<p>How to use it? Do you have example commands?<p>How is video data transferred between the client and the server?<p>Would it be possible to connect with SSH to a Linux server, using SFTP with FUSE or Samba with port forwarding for file sharing? This way the server could be zero-configuration (except that ffmpeg has to be installed, but the executable can also be transferred over SSH).</div><br/><div id="41745350" class="c"><input type="checkbox" id="c-41745350" checked=""/><div class="controls bullet"><span class="by">steelbrain</span><span>|</span><a href="#41745309">parent</a><span>|</span><a href="#41745414">next</a><span>|</span><label class="collapse" for="c-41745350">[-]</label><label class="expand" for="c-41745350">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What problem does it solve?<p>For different people it&#x27;s going to solve different problems. For me, most recently, I wanted to use the powerful GPU in my gaming machine for transcoding in my plex server with an integrated GPU.<p>&gt; How to use it? Do you have example commands?<p>The Github repository should have instructions on how to use. The client usage (once you setup the configuration) is the same as ffmpeg, so anything ffmpeg ... becomes ffmpeg-over-ip-client ... -- you need a server running on the machine with the GPU and then client anywhere network-accessible.<p>&gt; How is video data transferred between the client and the server?<p>The server and client only transfer commands, stdout&#x2F;err etc. The data of the transcoded files themselves is transferred over the network mount. The README of the repository has more details here but essentially you&#x27;ll want a shared filesystem between the two.<p>&gt; Would it be possible to connect with SSH to a Linux server, using SFTP with FUSE or Samba with port forwarding for file sharing? This way the server could be zero-configuration (except that ffmpeg has to be installed, but the executable can also be transferred over SSH).<p>Configuration should be pretty straight forward but let me know if you try it and find it difficult. A template configuration file is provided and you can edit your way out of it. You can absolutely do this with port forwarding even over the internet, provided the file system mount over the network can keep up.</div><br/></div></div></div></div></div></div></div></div></div></body></html>