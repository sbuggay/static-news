<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734166872139" as="style"/><link rel="stylesheet" href="styles.css?v=1734166872139"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.daveliepmann.com/articles/idiomatic-clojure-errors.html">Idiomatic Errors in Clojure</a> <span class="domain">(<a href="https://www.daveliepmann.com">www.daveliepmann.com</a>)</span></div><div class="subtext"><span>harperlee</span> | <span>9 comments</span></div><br/><div><div id="42415229" class="c"><input type="checkbox" id="c-42415229" checked=""/><div class="controls bullet"><span class="by">thih9</span><span>|</span><a href="#42414271">next</a><span>|</span><label class="collapse" for="c-42415229">[-]</label><label class="expand" for="c-42415229">[1 more]</label></div><br/><div class="children"><div class="content">A bit off topic, it took me a while to figure out that the article is about “handling errors in clojure in an idiomatic way” and not “error prone clojure code that gets written so often it can be considered idiomatic”. Especially since some of these can be controversial, e.g. error maps.</div><br/></div></div><div id="42414271" class="c"><input type="checkbox" id="c-42414271" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#42415229">prev</a><span>|</span><a href="#42415090">next</a><span>|</span><label class="collapse" for="c-42414271">[-]</label><label class="expand" for="c-42414271">[6 more]</label></div><br/><div class="children"><div class="content">&gt; if something is expected then return either nil or some {:ok false :message &quot;...&quot;} value (and {:ok true :value ...} for success)<p>Maps used in this way are uncomfortable. You end up with a function (foo x y z) and in practice you don&#x27;t know how may values it is about to return. Technically one, but that one might be a map with who-knows-what in it.<p>There is a general API problem here of how to handle operations which really require multiple communication channels to report back with. I&#x27;m not sure if there is a good way to handle it, but complex objects as return value isn&#x27;t very satisfying. Although in practice I find it works great in exceptions because the map is secretly just a string that is about to be logged somewhere and discarded.</div><br/><div id="42414401" class="c"><input type="checkbox" id="c-42414401" checked=""/><div class="controls bullet"><span class="by">MarkMarine</span><span>|</span><a href="#42414271">parent</a><span>|</span><a href="#42415365">next</a><span>|</span><label class="collapse" for="c-42414401">[-]</label><label class="expand" for="c-42414401">[1 more]</label></div><br/><div class="children"><div class="content">Maps used in this way are clojure idiom.<p><a href="https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;272302&#x2F;use-map-instead-of-class-to-represent-data-rich-hickey" rel="nofollow">https:&#x2F;&#x2F;softwareengineering.stackexchange.com&#x2F;questions&#x2F;2723...</a></div><br/></div></div><div id="42415365" class="c"><input type="checkbox" id="c-42415365" checked=""/><div class="controls bullet"><span class="by">MathMonkeyMan</span><span>|</span><a href="#42414271">parent</a><span>|</span><a href="#42414401">prev</a><span>|</span><a href="#42415093">next</a><span>|</span><label class="collapse" for="c-42415365">[-]</label><label class="expand" for="c-42415365">[2 more]</label></div><br/><div class="children"><div class="content">Not idiomatic, but it looks like [core.match][1] could be used to &quot;if error&quot; unpack the map:<p><pre><code>   (let [result (do-thing x y z)]
    (match [result]
      [{:ok false :message msg}]
       {:ok false :message (format &quot;do-thing failed: %s&quot; msg)}
      [{:ok true, :value value}]
       (continue-computation-with value)))
</code></pre>
meh<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.match&#x2F;wiki&#x2F;Overview">https:&#x2F;&#x2F;github.com&#x2F;clojure&#x2F;core.match&#x2F;wiki&#x2F;Overview</a></div><br/><div id="42415565" class="c"><input type="checkbox" id="c-42415565" checked=""/><div class="controls bullet"><span class="by">roenxi</span><span>|</span><a href="#42414271">root</a><span>|</span><a href="#42415365">parent</a><span>|</span><a href="#42415093">next</a><span>|</span><label class="collapse" for="c-42415565">[-]</label><label class="expand" for="c-42415565">[1 more]</label></div><br/><div class="children"><div class="content">What is the advantage there that justifies bringing in another dependency? You&#x27;ve already got a let for binding parts of result and could use cond from clojure.core instead of match. It&#x27;d be effectively identical.</div><br/></div></div></div></div><div id="42415093" class="c"><input type="checkbox" id="c-42415093" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#42414271">parent</a><span>|</span><a href="#42415365">prev</a><span>|</span><a href="#42415090">next</a><span>|</span><label class="collapse" for="c-42415093">[-]</label><label class="expand" for="c-42415093">[2 more]</label></div><br/><div class="children"><div class="content">&gt; but that one might be a map with who-knows-what in it.<p>I think thatthe beauty of maps, you can take the parts you need and discard the rest (I am suddenly reminded of my old shifu).</div><br/><div id="42415635" class="c"><input type="checkbox" id="c-42415635" checked=""/><div class="controls bullet"><span class="by">IceDane</span><span>|</span><a href="#42414271">root</a><span>|</span><a href="#42415093">parent</a><span>|</span><a href="#42415090">next</a><span>|</span><label class="collapse" for="c-42415635">[-]</label><label class="expand" for="c-42415635">[1 more]</label></div><br/><div class="children"><div class="content">In a dynamically typed language, you can&#x27;t even be sure you have the parts you need.</div><br/></div></div></div></div></div></div><div id="42415090" class="c"><input type="checkbox" id="c-42415090" checked=""/><div class="controls bullet"><span class="by">whalesalad</span><span>|</span><a href="#42414271">prev</a><span>|</span><label class="collapse" for="c-42415090">[-]</label><label class="expand" for="c-42415090">[1 more]</label></div><br/><div class="children"><div class="content">Great post this has cleared up a lot of things for me.</div><br/></div></div></div></div></div></div></div></body></html>