<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712739667824" as="style"/><link rel="stylesheet" href="styles.css?v=1712739667824"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tidwall/neco">Show HN: Neco – Coroutine Library for C</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>tidwall</span> | <span>30 comments</span></div><br/><div><div id="39985214" class="c"><input type="checkbox" id="c-39985214" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39988409">next</a><span>|</span><label class="collapse" for="c-39985214">[-]</label><label class="expand" for="c-39985214">[3 more]</label></div><br/><div class="children"><div class="content">These are stackful coroutines, as opposed to stackless.<p>Stackful coroutines create a new stack for each coroutine thread and save and restore the appropriate registers when switching. Stackless coroutines are basically normal C functions that have been hacked to save their local variables between calls and use gotos (or, notoriously, a switch statement) to resume from where they last yielded. Both are very useful in their own way.<p>This is a great project and I&#x27;ll be trying it out in my current work.</div><br/><div id="39988169" class="c"><input type="checkbox" id="c-39988169" checked=""/><div class="controls bullet"><span class="by">styren</span><span>|</span><a href="#39985214">parent</a><span>|</span><a href="#39986000">next</a><span>|</span><label class="collapse" for="c-39988169">[-]</label><label class="expand" for="c-39988169">[1 more]</label></div><br/><div class="children"><div class="content">Would you mind elaborating on the pros and cons of each?</div><br/></div></div><div id="39986000" class="c"><input type="checkbox" id="c-39986000" checked=""/><div class="controls bullet"><span class="by">liuliu</span><span>|</span><a href="#39985214">parent</a><span>|</span><a href="#39988169">prev</a><span>|</span><a href="#39988409">next</a><span>|</span><label class="collapse" for="c-39986000">[-]</label><label class="expand" for="c-39986000">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, at some point, would just say if you want stackful coroutine, go to Go and stackless one, use C++.<p>BTW, here is my macros for stackless coroutine in C: <a href="https:&#x2F;&#x2F;github.com&#x2F;liuliu&#x2F;co&#x2F;blob&#x2F;master&#x2F;example.c">https:&#x2F;&#x2F;github.com&#x2F;liuliu&#x2F;co&#x2F;blob&#x2F;master&#x2F;example.c</a></div><br/></div></div></div></div><div id="39988409" class="c"><input type="checkbox" id="c-39988409" checked=""/><div class="controls bullet"><span class="by">Karellen</span><span>|</span><a href="#39985214">prev</a><span>|</span><a href="#39972334">next</a><span>|</span><label class="collapse" for="c-39988409">[-]</label><label class="expand" for="c-39988409">[1 more]</label></div><br/><div class="children"><div class="content">In &quot;Example 4&quot;, I don&#x27;t understand where the &quot;arg2&quot; in `free(arg2)` is coming from?</div><br/></div></div><div id="39972334" class="c"><input type="checkbox" id="c-39972334" checked=""/><div class="controls bullet"><span class="by">plagiat0r</span><span>|</span><a href="#39988409">prev</a><span>|</span><a href="#39985411">next</a><span>|</span><label class="collapse" for="c-39972334">[-]</label><label class="expand" for="c-39972334">[1 more]</label></div><br/><div class="children"><div class="content">I love how simple and elegant is this to use:
<a href="https:&#x2F;&#x2F;github.com&#x2F;tidwall&#x2F;neco&#x2F;blob&#x2F;main&#x2F;examples&#x2F;echo-server.c">https:&#x2F;&#x2F;github.com&#x2F;tidwall&#x2F;neco&#x2F;blob&#x2F;main&#x2F;examples&#x2F;echo-serv...</a><p>I was going to actually implement an echo server for load balancer health checks with minimal memory usage, but never considered doing it in C but I might just use it! Thank you so much.</div><br/></div></div><div id="39985411" class="c"><input type="checkbox" id="c-39985411" checked=""/><div class="controls bullet"><span class="by">andrekandre</span><span>|</span><a href="#39972334">prev</a><span>|</span><a href="#39972144">next</a><span>|</span><label class="collapse" for="c-39985411">[-]</label><label class="expand" for="c-39985411">[2 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; neco_chan *messages = argv[0];
</code></pre>
neco_chan → neko chan → kitty cat (in japanese)... coincidence? ^_^</div><br/><div id="39987001" class="c"><input type="checkbox" id="c-39987001" checked=""/><div class="controls bullet"><span class="by">ReleaseCandidat</span><span>|</span><a href="#39985411">parent</a><span>|</span><a href="#39972144">next</a><span>|</span><label class="collapse" for="c-39987001">[-]</label><label class="expand" for="c-39987001">[1 more]</label></div><br/><div class="children"><div class="content">Nekochan had been an important SGI (Irix) forum. Important as in &quot;the community built packages of FOSS for Irix&quot;.
<a href="https:&#x2F;&#x2F;wiki.preterhuman.net&#x2F;Nekochan.net" rel="nofollow">https:&#x2F;&#x2F;wiki.preterhuman.net&#x2F;Nekochan.net</a></div><br/></div></div></div></div><div id="39972144" class="c"><input type="checkbox" id="c-39972144" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39985411">prev</a><span>|</span><a href="#39984200">next</a><span>|</span><label class="collapse" for="c-39972144">[-]</label><label class="expand" for="c-39972144">[1 more]</label></div><br/><div class="children"><div class="content">I like how your examples become progressively more comprehensive. What was your thinking going into this? How did you design this library? i think you wanted something this beautiful and perfect to exist, am i right? Or is it also an exercise to develop your own understanding? I wouldn&#x27;t know where to begin with C gens&#x2F;coroutines. Probably I would just fallback on kernel&#x2F;sys calls to suspend and hack from there: yay my function is stopped; yay my code has been called again. Are you using setjmp&#x2F;longjmp?</div><br/></div></div><div id="39984200" class="c"><input type="checkbox" id="c-39984200" checked=""/><div class="controls bullet"><span class="by">dingdingdang</span><span>|</span><a href="#39972144">prev</a><span>|</span><a href="#39986812">next</a><span>|</span><label class="collapse" for="c-39984200">[-]</label><label class="expand" for="c-39984200">[9 more]</label></div><br/><div class="children"><div class="content">Can someone help elucidate why &quot;It&#x27;s a non-goal for Neco to provide a scalable multithreaded runtime, where the coroutine scheduler is shared among multiple cpu cores [...]&quot; this library even makes sense then? When I use coroutines in Go it is invariably in order to make use of more CPU cores when extra performance needs to be extracted.</div><br/><div id="39986072" class="c"><input type="checkbox" id="c-39986072" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39984200">parent</a><span>|</span><a href="#39984350">next</a><span>|</span><label class="collapse" for="c-39986072">[-]</label><label class="expand" for="c-39986072">[1 more]</label></div><br/><div class="children"><div class="content">The library rightly leaves implementation of that up to the user. You&#x27;re talking about mixing cooperative and preemptive threads which have very different safety and execution profiles. There are many ways to arrange and interact the two things. Trying to provide general support for something like that would just end up a complicated mess that no one actually understands properly.</div><br/></div></div><div id="39984350" class="c"><input type="checkbox" id="c-39984350" checked=""/><div class="controls bullet"><span class="by">trebecks</span><span>|</span><a href="#39984200">parent</a><span>|</span><a href="#39986072">prev</a><span>|</span><a href="#39985111">next</a><span>|</span><label class="collapse" for="c-39984350">[-]</label><label class="expand" for="c-39984350">[3 more]</label></div><br/><div class="children"><div class="content">the scheduler is probably simpler if coroutines can&#x27;t bounce between cores. you can have a single thread per core that runs the scheduler to multiplex a bunch of coroutines on the single thread, which lines up with the example linked in the repo to a redis clone. redis runs a single thread (i think technically it has some multithreading stuff now but that was the model for a while) but can concurrently process a bunch of requests like when 1 or more requests are blocked on blpop, a pubsub thing, xread with block arg given, etc. nginx does something similar with forking a process per core that runs single threaded (ignore the threading for stuff that reads from disk).</div><br/><div id="39984574" class="c"><input type="checkbox" id="c-39984574" checked=""/><div class="controls bullet"><span class="by">tidwall</span><span>|</span><a href="#39984200">root</a><span>|</span><a href="#39984350">parent</a><span>|</span><a href="#39985111">next</a><span>|</span><label class="collapse" for="c-39984574">[-]</label><label class="expand" for="c-39984574">[2 more]</label></div><br/><div class="children"><div class="content">Also it is possible to start multiple Neco schedulers in different threads, there’s an example in the readme.</div><br/><div id="39984790" class="c"><input type="checkbox" id="c-39984790" checked=""/><div class="controls bullet"><span class="by">trebecks</span><span>|</span><a href="#39984200">root</a><span>|</span><a href="#39984574">parent</a><span>|</span><a href="#39985111">next</a><span>|</span><label class="collapse" for="c-39984790">[-]</label><label class="expand" for="c-39984790">[1 more]</label></div><br/><div class="children"><div class="content">yeah i like this model. then you can use whatever synchronization junk you prefer to share state between the threads, if you have any.<p>your library looks well written and clean. thanks for sharing.<p>if anyone else wants to go coroutine spelunking, these were interesting to me:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;higan-emu&#x2F;libco&#x2F;tree&#x2F;master">https:&#x2F;&#x2F;github.com&#x2F;higan-emu&#x2F;libco&#x2F;tree&#x2F;master</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;Tencent&#x2F;libco">https:&#x2F;&#x2F;github.com&#x2F;Tencent&#x2F;libco</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;hnes&#x2F;libaco">https:&#x2F;&#x2F;github.com&#x2F;hnes&#x2F;libaco</a><p><a href="https:&#x2F;&#x2F;kernel.googlesource.com&#x2F;pub&#x2F;scm&#x2F;virt&#x2F;kvm&#x2F;qemu-kvm&#x2F;+&#x2F;acd3b6be325a66f8f10f0eed19ed5261ced411cf&#x2F;coroutine-sigaltstack.c" rel="nofollow">https:&#x2F;&#x2F;kernel.googlesource.com&#x2F;pub&#x2F;scm&#x2F;virt&#x2F;kvm&#x2F;qemu-kvm&#x2F;+&#x2F;...</a><p><a href="https:&#x2F;&#x2F;tia.mat.br&#x2F;posts&#x2F;2012&#x2F;09&#x2F;29&#x2F;asynchronous_i_o_in_c_with_coroutines.html" rel="nofollow">https:&#x2F;&#x2F;tia.mat.br&#x2F;posts&#x2F;2012&#x2F;09&#x2F;29&#x2F;asynchronous_i_o_in_c_wi...</a><p><a href="https:&#x2F;&#x2F;www.cs.uml.edu&#x2F;~bill&#x2F;cs516&#x2F;context_paper_rse-pmt.pdf" rel="nofollow">https:&#x2F;&#x2F;www.cs.uml.edu&#x2F;~bill&#x2F;cs516&#x2F;context_paper_rse-pmt.pdf</a></div><br/></div></div></div></div></div></div><div id="39985111" class="c"><input type="checkbox" id="c-39985111" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39984200">parent</a><span>|</span><a href="#39984350">prev</a><span>|</span><a href="#39985332">next</a><span>|</span><label class="collapse" for="c-39985111">[-]</label><label class="expand" for="c-39985111">[1 more]</label></div><br/><div class="children"><div class="content">Goroutines aren&#x27;t coroutines. This isn&#x27;t a nitpick, it&#x27;s pretty essential to understanding the goals and non-goals of Neco.<p>Coroutines are a control-flow primitive which allows for a lot of useful things, including advancing program state while a coroutine waits on a syscall, generators, iterators, producer-consumer patterns with channels, and combinations of these things. They generalize function calls, or structure goto, if you prefer.<p>Some of these applications are glossed as concurrent, particularly their use to free the thread when execution blocks, but all of them are single-threaded. Goroutines are preëmptively scheduled, and can be relocated between threads transparently. That isn&#x27;t really a coroutine, which is why they have a different name.<p>The README has some notes on how to use Neco coroutines in a multithreaded environment. It&#x27;s basically how you&#x27;d run execution paths of multiple function calls on several threads, because coroutines are an orthogonal concern to threads.</div><br/></div></div><div id="39985332" class="c"><input type="checkbox" id="c-39985332" checked=""/><div class="controls bullet"><span class="by">btilly</span><span>|</span><a href="#39984200">parent</a><span>|</span><a href="#39985111">prev</a><span>|</span><a href="#39986704">next</a><span>|</span><label class="collapse" for="c-39985332">[-]</label><label class="expand" for="c-39985332">[1 more]</label></div><br/><div class="children"><div class="content">This library aims to be the simplest and most efficient thing for what it does. And what it does is perfect for is managing communications with things that themselves may be bound by I&#x2F;O.<p>Handling multiple threads to access multiple CPUs would make it far more complex. And frankly a single thread is plenty for handling, say, a chat server.</div><br/></div></div><div id="39986704" class="c"><input type="checkbox" id="c-39986704" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#39984200">parent</a><span>|</span><a href="#39985332">prev</a><span>|</span><a href="#39984762">next</a><span>|</span><label class="collapse" for="c-39986704">[-]</label><label class="expand" for="c-39986704">[1 more]</label></div><br/><div class="children"><div class="content">coroutines as a control flow construct within a thread are quite useful.</div><br/></div></div><div id="39984762" class="c"><input type="checkbox" id="c-39984762" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#39984200">parent</a><span>|</span><a href="#39986704">prev</a><span>|</span><a href="#39986812">next</a><span>|</span><label class="collapse" for="c-39984762">[-]</label><label class="expand" for="c-39984762">[1 more]</label></div><br/><div class="children"><div class="content">Coroutines are still very useful for multitasking even if you&#x27;re not sharing tasks between CPU cores. Other coroutines can just execute whenever something would normally block, removing the need for multiple threads in the first place.</div><br/></div></div></div></div><div id="39986812" class="c"><input type="checkbox" id="c-39986812" checked=""/><div class="controls bullet"><span class="by">comex</span><span>|</span><a href="#39984200">prev</a><span>|</span><a href="#39986092">next</a><span>|</span><label class="collapse" for="c-39986812">[-]</label><label class="expand" for="c-39986812">[2 more]</label></div><br/><div class="children"><div class="content">How does it work on WebAssembly, where there&#x27;s no native support for stack switching?  Does it rely on Emscripten&#x27;s Asyncify transformation?</div><br/><div id="39986851" class="c"><input type="checkbox" id="c-39986851" checked=""/><div class="controls bullet"><span class="by">StayTrue</span><span>|</span><a href="#39986812">parent</a><span>|</span><a href="#39986092">next</a><span>|</span><label class="collapse" for="c-39986851">[-]</label><label class="expand" for="c-39986851">[1 more]</label></div><br/><div class="children"><div class="content">Yes according to the caveats section in the llco subproject:<p>&gt; Webassembly: Must be compiled with Emscripten using the -sASYNCIFY flag.</div><br/></div></div></div></div><div id="39986092" class="c"><input type="checkbox" id="c-39986092" checked=""/><div class="controls bullet"><span class="by">jonhohle</span><span>|</span><a href="#39986812">prev</a><span>|</span><a href="#39985379">next</a><span>|</span><label class="collapse" for="c-39986092">[-]</label><label class="expand" for="c-39986092">[2 more]</label></div><br/><div class="children"><div class="content">I’ve used libaco with a lot of success in the past (mixing uv, curl, and zlib in a way that made the zlib loop easier to manage (since it looked like a normal read, decompress loop with all context stack local).<p>Any notes about why I would try Neco in the future?</div><br/><div id="39986156" class="c"><input type="checkbox" id="c-39986156" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39986092">parent</a><span>|</span><a href="#39985379">next</a><span>|</span><label class="collapse" for="c-39986156">[-]</label><label class="expand" for="c-39986156">[1 more]</label></div><br/><div class="children"><div class="content">This has support for ARM processors.<p>It&#x27;s nice to have multiple options. For instance the interface can be very different.</div><br/></div></div></div></div><div id="39985379" class="c"><input type="checkbox" id="c-39985379" checked=""/><div class="controls bullet"><span class="by">burntcaramel</span><span>|</span><a href="#39986092">prev</a><span>|</span><a href="#39985555">next</a><span>|</span><label class="collapse" for="c-39985379">[-]</label><label class="expand" for="c-39985379">[2 more]</label></div><br/><div class="children"><div class="content">Can someone explain how this works please? How does it prevent this from saturating the CPU?<p><pre><code>    while (1) {
        neco_sleep(NECO_SECOND*2);
        printf(&quot;tock\n&quot;);
    }</code></pre></div><br/><div id="39985754" class="c"><input type="checkbox" id="c-39985754" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#39985379">parent</a><span>|</span><a href="#39985555">next</a><span>|</span><label class="collapse" for="c-39985754">[-]</label><label class="expand" for="c-39985754">[1 more]</label></div><br/><div class="children"><div class="content">I encourage you to dig through the source. There&#x27;s not that much.<p>Either this is a library you might use, so you should obviously review the code before you include it in your own work, or this is something that intrigued you, so you&#x27;ll find clever ideas by digging into its implementation.<p>Here, neco_sleep eventually calls a function that tells the coroutine scheduler to pause the current (calling) and resume the next eligible coroutine in its collection.</div><br/></div></div></div></div><div id="39985555" class="c"><input type="checkbox" id="c-39985555" checked=""/><div class="controls bullet"><span class="by">nialv7</span><span>|</span><a href="#39985379">prev</a><span>|</span><label class="collapse" for="c-39985555">[-]</label><label class="expand" for="c-39985555">[6 more]</label></div><br/><div class="children"><div class="content">These are cooperatively scheduled green threads...<p>I feel the word &quot;coroutine&quot; is slowly losing its original meaning, similar to what happened to &quot;lambda&quot;.</div><br/><div id="39986136" class="c"><input type="checkbox" id="c-39986136" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39985555">parent</a><span>|</span><a href="#39986016">next</a><span>|</span><label class="collapse" for="c-39986136">[-]</label><label class="expand" for="c-39986136">[1 more]</label></div><br/><div class="children"><div class="content">Coroutine is definitely appropriate here. Any implementation that has one function (routine) executing while others are paused is applicable. It always means cooperative multitasking, which this is. No meaning lost whatsoever.</div><br/></div></div><div id="39986016" class="c"><input type="checkbox" id="c-39986016" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#39985555">parent</a><span>|</span><a href="#39986136">prev</a><span>|</span><a href="#39985847">next</a><span>|</span><label class="collapse" for="c-39986016">[-]</label><label class="expand" for="c-39986016">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know where you&#x27;re getting that impression.<p>These are stackful, symmetric coroutines with a build-in scheduler. It implements suspend and resume. You can call that a green thread if you want, or a fiber or whatever. They&#x27;re coroutines.<p>The API docs make all of this clearer than the README. <a href="https:&#x2F;&#x2F;github.com&#x2F;tidwall&#x2F;neco&#x2F;blob&#x2F;main&#x2F;docs&#x2F;API.md">https:&#x2F;&#x2F;github.com&#x2F;tidwall&#x2F;neco&#x2F;blob&#x2F;main&#x2F;docs&#x2F;API.md</a></div><br/></div></div><div id="39985847" class="c"><input type="checkbox" id="c-39985847" checked=""/><div class="controls bullet"><span class="by">wavemode</span><span>|</span><a href="#39985555">parent</a><span>|</span><a href="#39986016">prev</a><span>|</span><label class="collapse" for="c-39985847">[-]</label><label class="expand" for="c-39985847">[3 more]</label></div><br/><div class="children"><div class="content">what was the original meaning of lambda?</div><br/><div id="39985951" class="c"><input type="checkbox" id="c-39985951" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#39985555">root</a><span>|</span><a href="#39985847">parent</a><span>|</span><a href="#39985917">next</a><span>|</span><label class="collapse" for="c-39985951">[-]</label><label class="expand" for="c-39985951">[1 more]</label></div><br/><div class="children"><div class="content">Maybe they mean as in lambda calculus?<p>Although, deep in our hearts we all must know that lambda was already taken, it is an eigenvalue.</div><br/></div></div><div id="39985917" class="c"><input type="checkbox" id="c-39985917" checked=""/><div class="controls bullet"><span class="by">animaomnium</span><span>|</span><a href="#39985555">root</a><span>|</span><a href="#39985847">parent</a><span>|</span><a href="#39985951">prev</a><span>|</span><label class="collapse" for="c-39985917">[-]</label><label class="expand" for="c-39985917">[1 more]</label></div><br/><div class="children"><div class="content">eleventh letter of the greek alphabet, derived from phoenecian &quot;lamed&quot;, etc.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>