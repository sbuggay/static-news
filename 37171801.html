<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1692349258435" as="style"/><link rel="stylesheet" href="styles.css?v=1692349258435"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2023/08/17/typescript-is-surprisingly-ok-for-compilers.html">TypeScript Is Surprisingly OK for Compilers</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>Fudgel</span> | <span>51 comments</span></div><br/><div><div id="37172079" class="c"><input type="checkbox" id="c-37172079" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37172135">next</a><span>|</span><label class="collapse" for="c-37172079">[-]</label><label class="expand" for="c-37172079">[25 more]</label></div><br/><div class="children"><div class="content">Is that really suprising? Typescript is yet another language that has, kicking and screaming, picked up most of the ML featureset. I&#x27;d expect it to be, well, fine; the lack of real pattern matching is a pain, so it&#x27;s going to be inferior to OCaml, but fine, no different from using C# or Swift or Dart or Kotlin or something of that ilk.</div><br/><div id="37172850" class="c"><input type="checkbox" id="c-37172850" checked=""/><div class="controls bullet"><span class="by">jillesvangurp</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172349">next</a><span>|</span><label class="collapse" for="c-37172850">[-]</label><label class="expand" for="c-37172850">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done a bit of typescript and kotlin-js. It always strikes me how close those two languages are. Yes there are lots of differences but they aren&#x27;t that different and you can transition from one to the other pretty easily. I have my preferences (kotlin) but I can work with both.<p>IMHO typescript could just cut loose from its javascript compatibility. Why not compile it to wasm instead of transpiling it to javascript? Kotlin is in the process of adding a wasm compiler and they already have a js transpiler. The same code results in a lot smaller binaries and loads a lot faster in wasm form. Browser Javascript is not a great compilation target. And who cares what the minified crap that loads in the browser looks like? The only reason for backwards compatibility is allowing javascript projects to easily transition to typescript. But that&#x27;s increasingly less relevant now that a lot of projects start out being typescript from day 1.<p>Of course, Assembly script is already a thing. But why not make that a bit more official? It wouldn&#x27;t surprise me to see people doing a lot of web development in languages like that in a few years.</div><br/><div id="37172963" class="c"><input type="checkbox" id="c-37172963" checked=""/><div class="controls bullet"><span class="by">orra</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172850">parent</a><span>|</span><a href="#37172349">next</a><span>|</span><label class="collapse" for="c-37172963">[-]</label><label class="expand" for="c-37172963">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m afraid that&#x27;s wishful thinking. JS compatibility is core to the TypeScript ethos, regardless of TypeScript&#x27;s own popularity.<p>Besides, enums (?) aside, and ignoring typechecking, compiling TS is really easy right now. Switching to WASM is a high ask.</div><br/></div></div></div></div><div id="37172349" class="c"><input type="checkbox" id="c-37172349" checked=""/><div class="controls bullet"><span class="by">moonchrome</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172850">prev</a><span>|</span><a href="#37172944">next</a><span>|</span><label class="collapse" for="c-37172349">[-]</label><label class="expand" for="c-37172349">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s some very high level view - in reality even tough those languages are in similar categories the experience would be vastly different :<p>TypeScript - powerful type system but shit underlying stdlib and language (no pattern matching&#x2F;switch expressions)<p>Dart - worse than TS because the object model is closed - so no dynamic freedom, but the type system and expressions are weaker then the rest. Also 0 meta programming facilities - Java level of boilerplate and code generators<p>C# - closest to ML featureset out of the mentioned, but unlike TS doesn&#x27;t have sum types which will make a lot of things more tedious.</div><br/><div id="37172826" class="c"><input type="checkbox" id="c-37172826" checked=""/><div class="controls bullet"><span class="by">crooked-v</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172349">parent</a><span>|</span><a href="#37172631">next</a><span>|</span><label class="collapse" for="c-37172826">[-]</label><label class="expand" for="c-37172826">[1 more]</label></div><br/><div class="children"><div class="content">&gt; no pattern matching&#x2F;switch expressions<p>They&#x27;re still waiting on the do expression proposal for that (<a href="https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-do-expressions">https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-do-expressions</a>), which has been in the bikeshedding stage for the past five years.</div><br/></div></div><div id="37172631" class="c"><input type="checkbox" id="c-37172631" checked=""/><div class="controls bullet"><span class="by">pja</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172349">parent</a><span>|</span><a href="#37172826">prev</a><span>|</span><a href="#37172944">next</a><span>|</span><label class="collapse" for="c-37172631">[-]</label><label class="expand" for="c-37172631">[1 more]</label></div><br/><div class="children"><div class="content">If you’re going to use C# for a compiler, why not go the whole hog &amp; use F#?</div><br/></div></div></div></div><div id="37172944" class="c"><input type="checkbox" id="c-37172944" checked=""/><div class="controls bullet"><span class="by">xvilka</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172349">prev</a><span>|</span><a href="#37172955">next</a><span>|</span><label class="collapse" for="c-37172944">[-]</label><label class="expand" for="c-37172944">[1 more]</label></div><br/><div class="children"><div class="content">This is why once WebAssembly more polished and more common, languages like JS and TS could become obsolete since proper, more powerful languages will suddenly become a valid choice for Web.</div><br/></div></div><div id="37172955" class="c"><input type="checkbox" id="c-37172955" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172944">prev</a><span>|</span><a href="#37172412">next</a><span>|</span><label class="collapse" for="c-37172955">[-]</label><label class="expand" for="c-37172955">[2 more]</label></div><br/><div class="children"><div class="content">C# and Swift have pattern matching.</div><br/><div id="37172980" class="c"><input type="checkbox" id="c-37172980" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172955">parent</a><span>|</span><a href="#37172412">next</a><span>|</span><label class="collapse" for="c-37172980">[-]</label><label class="expand" for="c-37172980">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more limited than what you&#x27;d ideally want: pattern matching in function definitions. This makes walking ASTs a breeze.<p>Edit: And inline pattern matching for values returned from expressions and function calls (similar to destructuring, but more powerful).</div><br/></div></div></div></div><div id="37172412" class="c"><input type="checkbox" id="c-37172412" checked=""/><div class="controls bullet"><span class="by">dejawu</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172955">prev</a><span>|</span><a href="#37172383">next</a><span>|</span><label class="collapse" for="c-37172412">[-]</label><label class="expand" for="c-37172412">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m quite fond of this library for pattern matching; it&#x27;s a staple in all my new projects.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;gvergnaud&#x2F;ts-pattern">https:&#x2F;&#x2F;github.com&#x2F;gvergnaud&#x2F;ts-pattern</a></div><br/></div></div><div id="37172383" class="c"><input type="checkbox" id="c-37172383" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172412">prev</a><span>|</span><a href="#37172199">next</a><span>|</span><label class="collapse" for="c-37172383">[-]</label><label class="expand" for="c-37172383">[9 more]</label></div><br/><div class="children"><div class="content">The biggest expressivity pain point in practice for me is try&#x2F;catch not being an expression, so I can’t do<p><pre><code>   const c = try { … }</code></pre></div><br/><div id="37172554" class="c"><input type="checkbox" id="c-37172554" checked=""/><div class="controls bullet"><span class="by">jve</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172383">parent</a><span>|</span><a href="#37172664">next</a><span>|</span><label class="collapse" for="c-37172554">[-]</label><label class="expand" for="c-37172554">[1 more]</label></div><br/><div class="children"><div class="content">Yes! This just drives me crazy:<p><pre><code>   string something = null;
   try {
      something = mayThrow();
   } catch (SomeException ex) {
      log.Info(ex);
   } catch (Exception ex) {
      log.Fatal(ex);
      throw;
   }
   if (something != null) {
      ...
   }
</code></pre>
Would be actually nice if it had F#&#x27;s try...with <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;language-reference&#x2F;exception-handling&#x2F;the-try-with-expression" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;fsharp&#x2F;language-ref...</a> and would allow us something like:<p><pre><code>   var something = try {
     mayThrow()
   } with (SomeException ex) {
      log.Info(ex);
   } with (Exception ex) {
      log.Fatal(ex);
      throw;
   }
</code></pre>
Or some way to do pattern matching on exceptions for switch expression.<p><pre><code>   var something = mayThrow() switch {
     (SomeException ex) =&gt; {
       log.Info(ex);
       return null;
     }
     (Exception ex) =&gt; {
       log.Fatal(ex);
       throw;
     }
     var passThru =&gt; passThru
   }</code></pre></div><br/></div></div><div id="37172664" class="c"><input type="checkbox" id="c-37172664" checked=""/><div class="controls bullet"><span class="by">xscott</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172383">parent</a><span>|</span><a href="#37172554">prev</a><span>|</span><a href="#37172478">next</a><span>|</span><label class="collapse" for="c-37172664">[-]</label><label class="expand" for="c-37172664">[2 more]</label></div><br/><div class="children"><div class="content">What does a try expression like this do?  Returns null&#x2F;undefined on a throw?<p>I suspect you could do something like:<p><pre><code>    const c = attempt(() =&gt; ... );
</code></pre>
where attempt invokes the lambda, catches any exceptions, and does what you want</div><br/><div id="37172811" class="c"><input type="checkbox" id="c-37172811" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172664">parent</a><span>|</span><a href="#37172478">next</a><span>|</span><label class="collapse" for="c-37172811">[-]</label><label class="expand" for="c-37172811">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What does a try expression like this do? Returns null&#x2F;undefined on a throw?<p>If an exception is caught, the expression evaluates to what the catch block evaluates to. (Similar to having if&#x2F;else be an expression). Of course if the exception isn&#x27;t caught then it propagates so the expression doesn&#x27;t take a value.</div><br/></div></div></div></div><div id="37172478" class="c"><input type="checkbox" id="c-37172478" checked=""/><div class="controls bullet"><span class="by">lovasoa</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172383">parent</a><span>|</span><a href="#37172664">prev</a><span>|</span><a href="#37172738">next</a><span>|</span><label class="collapse" for="c-37172478">[-]</label><label class="expand" for="c-37172478">[1 more]</label></div><br/><div class="children"><div class="content">With async code, there is<p><pre><code>    const c = myAsyncFun()
               .catch(e =&gt; …)</code></pre></div><br/></div></div><div id="37172738" class="c"><input type="checkbox" id="c-37172738" checked=""/><div class="controls bullet"><span class="by">not_alexb</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172383">parent</a><span>|</span><a href="#37172478">prev</a><span>|</span><a href="#37172593">next</a><span>|</span><label class="collapse" for="c-37172738">[-]</label><label class="expand" for="c-37172738">[1 more]</label></div><br/><div class="children"><div class="content">I use iife for stuff like this.<p>const c = (<p><pre><code>    ()=&gt; {
        try: {...}
    } </code></pre>
)()</div><br/></div></div><div id="37172593" class="c"><input type="checkbox" id="c-37172593" checked=""/><div class="controls bullet"><span class="by">thdespou</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172383">parent</a><span>|</span><a href="#37172738">prev</a><span>|</span><a href="#37172199">next</a><span>|</span><label class="collapse" for="c-37172593">[-]</label><label class="expand" for="c-37172593">[3 more]</label></div><br/><div class="children"><div class="content">Zig can though:<p><pre><code>  const std = @import(&quot;std&quot;);

  pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    try stdout.print(&quot;Hello, {s}!\n&quot;, .{&quot;world&quot;});
  }</code></pre></div><br/><div id="37172688" class="c"><input type="checkbox" id="c-37172688" checked=""/><div class="controls bullet"><span class="by">zkldi</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172593">parent</a><span>|</span><a href="#37172199">next</a><span>|</span><label class="collapse" for="c-37172688">[-]</label><label class="expand" for="c-37172688">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s not using `try` as an expression. can you do `let foo = try &lt;code&gt; (plus some handling for diverging in the other case?)`</div><br/><div id="37172830" class="c"><input type="checkbox" id="c-37172830" checked=""/><div class="controls bullet"><span class="by">kaba0</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172688">parent</a><span>|</span><a href="#37172199">next</a><span>|</span><label class="collapse" for="c-37172830">[-]</label><label class="expand" for="c-37172830">[1 more]</label></div><br/><div class="children"><div class="content">It can and you in fact either have to mark that you return that error when you use try, or you have to provide a default value in a catch block:<p>```
fn potentiallyErrorReturningFunc() !u64 {
  ...
}<p>const foo = potentiallyErrorReturningFunc() catch { 0 };
```<p>One notable difference to most other languages is it being a value only, basically a product type of return value XOR error. These error values get serialized into a number by the compiler that is unique, and on the type system level you deal with sets of these error values. Quite clever in case of a low-level system, in my opinion.</div><br/></div></div></div></div></div></div></div></div><div id="37172199" class="c"><input type="checkbox" id="c-37172199" checked=""/><div class="controls bullet"><span class="by">paddim8</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172383">prev</a><span>|</span><a href="#37172318">next</a><span>|</span><label class="collapse" for="c-37172199">[-]</label><label class="expand" for="c-37172199">[3 more]</label></div><br/><div class="children"><div class="content">I would think C# is easier for this due to having proper (and very convenient) pattern matching.</div><br/><div id="37172755" class="c"><input type="checkbox" id="c-37172755" checked=""/><div class="controls bullet"><span class="by">zkldi</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172199">parent</a><span>|</span><a href="#37172318">next</a><span>|</span><label class="collapse" for="c-37172755">[-]</label><label class="expand" for="c-37172755">[2 more]</label></div><br/><div class="children"><div class="content">C# doesn&#x27;t have anything resembling proper pattern matching. C#s pattern matching is akin to a marginally improved switch or if&#x2F;else-if chain. C#s pattern matches aren&#x27;t exhaustive, and the compiler doesn&#x27;t properly check them at all.[0]<p>There are no proper sum types in C#, so 80% of the point isn&#x27;t even there.<p><pre><code>    enum Season
        {
        Spring,
        Summer,
        Autumn,
        Winter
    }
     </code></pre>
...<p><pre><code>    int PatternMatch(Season season) =&gt;
    season switch {
        Season.Spring =&gt; 1,
        Season.Summer =&gt; 2,
        Season.Autumn =&gt; 3,
        Season.Winter =&gt; 4,
        &#x2F;&#x2F; compiler can&#x27;t prove the above code is exhaustive because no proper sum types
        &#x2F;&#x2F; compiler needs nonsensical branch here that diverges
        _ =&gt; throw new ArgumentException(&quot;Invalid enum value for command&quot;, nameof(command)),
    };</code></pre></div><br/><div id="37172764" class="c"><input type="checkbox" id="c-37172764" checked=""/><div class="controls bullet"><span class="by">hardware2win</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172755">parent</a><span>|</span><a href="#37172318">next</a><span>|</span><label class="collapse" for="c-37172764">[-]</label><label class="expand" for="c-37172764">[1 more]</label></div><br/><div class="children"><div class="content">&gt;compiler can&#x27;t prove the above code is exhaustive because no proper sum types<p>Thats because c#s enum is not &quot;closed&quot;<p><a href="https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;csharplang&#x2F;issues&#x2F;3179">https:&#x2F;&#x2F;github.com&#x2F;dotnet&#x2F;csharplang&#x2F;issues&#x2F;3179</a></div><br/></div></div></div></div></div></div><div id="37172318" class="c"><input type="checkbox" id="c-37172318" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172199">prev</a><span>|</span><a href="#37172097">next</a><span>|</span><label class="collapse" for="c-37172318">[-]</label><label class="expand" for="c-37172318">[2 more]</label></div><br/><div class="children"><div class="content">&gt; picked up most of the ML featureset<p>It really hasn&#x27;t. In this very post he had to use a visitor to work around the fact that switch isn&#x27;t an expression.<p>JavaScript&#x27;s support for iterators is also weirdly shit. It has `.map()` but that only works on arrays. You can&#x27;t map an iterator!</div><br/><div id="37172384" class="c"><input type="checkbox" id="c-37172384" checked=""/><div class="controls bullet"><span class="by">andyferris</span><span>|</span><a href="#37172079">root</a><span>|</span><a href="#37172318">parent</a><span>|</span><a href="#37172097">next</a><span>|</span><label class="collapse" for="c-37172384">[-]</label><label class="expand" for="c-37172384">[1 more]</label></div><br/><div class="children"><div class="content">I think there’s an iterator proposal out there for JS with generic map, filter, etc.</div><br/></div></div></div></div><div id="37172097" class="c"><input type="checkbox" id="c-37172097" checked=""/><div class="controls bullet"><span class="by">thebears5454</span><span>|</span><a href="#37172079">parent</a><span>|</span><a href="#37172318">prev</a><span>|</span><a href="#37172135">next</a><span>|</span><label class="collapse" for="c-37172097">[-]</label><label class="expand" for="c-37172097">[1 more]</label></div><br/><div class="children"><div class="content">Naively, I would have guessed it being harder than C#</div><br/></div></div></div></div><div id="37172135" class="c"><input type="checkbox" id="c-37172135" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#37172079">prev</a><span>|</span><a href="#37172903">next</a><span>|</span><label class="collapse" for="c-37172135">[-]</label><label class="expand" for="c-37172135">[10 more]</label></div><br/><div class="children"><div class="content">TS&#x27;s type system is fun but a part of me always wonders how much faster TS&#x27;s compiler would be if it was written in a compiled language (assuming &quot;good implementation&quot;, which is a big assumption!)</div><br/><div id="37172732" class="c"><input type="checkbox" id="c-37172732" checked=""/><div class="controls bullet"><span class="by">harrygeez</span><span>|</span><a href="#37172135">parent</a><span>|</span><a href="#37172559">next</a><span>|</span><label class="collapse" for="c-37172732">[-]</label><label class="expand" for="c-37172732">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s an answer from TypeScript team for your question :)
<a href="https:&#x2F;&#x2F;twitter.com&#x2F;drosenwasser&#x2F;status&#x2F;1260723846534979584" rel="nofollow noreferrer">https:&#x2F;&#x2F;twitter.com&#x2F;drosenwasser&#x2F;status&#x2F;1260723846534979584</a><p>Basically,<p>&gt; Let&#x27;s say TypeScript takes over 20 seconds to type-check a medium-sized program. That&#x27;s not usually because it&#x27;s JS, it&#x27;s often because of types that cause a combinatorial explosion.<p>Also<p>&gt; A different runtime can afford <i>a lot</i> (it sounds like parallelism and start-up time in this case) but I haven&#x27;t seen a CPU-bound benchmark that supports the idea of a 20x all-up speed-up.</div><br/></div></div><div id="37172559" class="c"><input type="checkbox" id="c-37172559" checked=""/><div class="controls bullet"><span class="by">madarco</span><span>|</span><a href="#37172135">parent</a><span>|</span><a href="#37172732">prev</a><span>|</span><a href="#37172278">next</a><span>|</span><label class="collapse" for="c-37172559">[-]</label><label class="expand" for="c-37172559">[1 more]</label></div><br/><div class="children"><div class="content">PS: swc and esbuild aren&#x27;t good example, because most of the speed improvements comes from the fact that they are just stripping TS-specific syntaxes to generate JS code.<p>Also tsc is slow, sure, but only for the first run. Enabling `incremental` flag or using watch mode with `--transpile-only` usually brings compile time under 100ms, Making it practically indistinguishable from SWC or ESBuild.</div><br/></div></div><div id="37172278" class="c"><input type="checkbox" id="c-37172278" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#37172135">parent</a><span>|</span><a href="#37172559">prev</a><span>|</span><a href="#37172433">next</a><span>|</span><label class="collapse" for="c-37172278">[-]</label><label class="expand" for="c-37172278">[1 more]</label></div><br/><div class="children"><div class="content">There’s <a href="https:&#x2F;&#x2F;swc.rs&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;swc.rs&#x2F;</a>, a Rust implementation (albeit without type checking at this time).</div><br/></div></div><div id="37172433" class="c"><input type="checkbox" id="c-37172433" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#37172135">parent</a><span>|</span><a href="#37172278">prev</a><span>|</span><a href="#37172903">next</a><span>|</span><label class="collapse" for="c-37172433">[-]</label><label class="expand" for="c-37172433">[6 more]</label></div><br/><div class="children"><div class="content">Probably not <i>that</i> much faster. V8 is very good at optimizing JS code. Typescript is slow mostly because of the complexity of its type system (which is required to make it backward compatible with existing JS code).</div><br/><div id="37172640" class="c"><input type="checkbox" id="c-37172640" checked=""/><div class="controls bullet"><span class="by">nikanj</span><span>|</span><a href="#37172135">root</a><span>|</span><a href="#37172433">parent</a><span>|</span><a href="#37172903">next</a><span>|</span><label class="collapse" for="c-37172640">[-]</label><label class="expand" for="c-37172640">[5 more]</label></div><br/><div class="children"><div class="content">Probably quite a bit faster if you do not have to instantiate a new V8 for every single file, considering how many files your average npm project has. I&#x27;m not certain if any contemporary build systems reuse the compiler process for multiple files</div><br/><div id="37172696" class="c"><input type="checkbox" id="c-37172696" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#37172135">root</a><span>|</span><a href="#37172640">parent</a><span>|</span><a href="#37172903">next</a><span>|</span><label class="collapse" for="c-37172696">[-]</label><label class="expand" for="c-37172696">[4 more]</label></div><br/><div class="children"><div class="content">Why would it have to instantiate a new V8 for every file? You can just run &#x27;tsc&#x27; in your project dir to compile all Typescript files.</div><br/><div id="37172750" class="c"><input type="checkbox" id="c-37172750" checked=""/><div class="controls bullet"><span class="by">harrygeez</span><span>|</span><a href="#37172135">root</a><span>|</span><a href="#37172696">parent</a><span>|</span><a href="#37172903">next</a><span>|</span><label class="collapse" for="c-37172750">[-]</label><label class="expand" for="c-37172750">[3 more]</label></div><br/><div class="children"><div class="content">I think people often underestimate how much the TypeScript team does to make TypeScript fast and efficient. They have some of the best people in the field working on the type checker</div><br/><div id="37172905" class="c"><input type="checkbox" id="c-37172905" checked=""/><div class="controls bullet"><span class="by">alexvitkov</span><span>|</span><a href="#37172135">root</a><span>|</span><a href="#37172750">parent</a><span>|</span><a href="#37172773">next</a><span>|</span><label class="collapse" for="c-37172905">[-]</label><label class="expand" for="c-37172905">[1 more]</label></div><br/><div class="children"><div class="content">Yes, because it&#x27;s one of the slowest compilers in the world, and its job is to compile from JavaScript to JavaScript. There are other languages with complex type systems, where the compilers have to do <i>a lot of</i> other additional work on top of typechecking, and are still way faster than TS.<p>And TypeScript is always slow, not only when you do abuse its type system and require it to do complex inference - I mostly use it for &quot;this is a number&quot; and &quot;this is a object with the following 4 fields&quot; and it&#x27;s still by far the slowest component in my builds usually</div><br/></div></div><div id="37172773" class="c"><input type="checkbox" id="c-37172773" checked=""/><div class="controls bullet"><span class="by">foldr</span><span>|</span><a href="#37172135">root</a><span>|</span><a href="#37172750">parent</a><span>|</span><a href="#37172905">prev</a><span>|</span><a href="#37172903">next</a><span>|</span><label class="collapse" for="c-37172773">[-]</label><label class="expand" for="c-37172773">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. I haven&#x27;t checked the implementation, but I suspect that &quot;don&#x27;t spin up a separate process for every file&quot; is an idea that has probably already occurred to them :D</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="37172903" class="c"><input type="checkbox" id="c-37172903" checked=""/><div class="controls bullet"><span class="by">gr__or</span><span>|</span><a href="#37172135">prev</a><span>|</span><a href="#37172533">next</a><span>|</span><label class="collapse" for="c-37172903">[-]</label><label class="expand" for="c-37172903">[1 more]</label></div><br/><div class="children"><div class="content">Very much apropos:<p>Going between Rust and TS it is painfully obvious how much sth like tagged enums are missing, which can also be seen in this post.<p>I know of this [1] proposal for ADT enums which looks like it has stalled. Anyone know of other efforts?<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;Jack-Works&#x2F;proposal-enum&#x2F;discussions&#x2F;19">https:&#x2F;&#x2F;github.com&#x2F;Jack-Works&#x2F;proposal-enum&#x2F;discussions&#x2F;19</a></div><br/></div></div><div id="37172533" class="c"><input type="checkbox" id="c-37172533" checked=""/><div class="controls bullet"><span class="by">domlebo70</span><span>|</span><a href="#37172903">prev</a><span>|</span><a href="#37172757">next</a><span>|</span><label class="collapse" for="c-37172533">[-]</label><label class="expand" for="c-37172533">[1 more]</label></div><br/><div class="children"><div class="content">To OP: You could avoid the visitor by using an IIFE style switch using the run utility fn:<p><pre><code>    export const run = &lt;T&gt;(f: () =&gt; T): T =&gt; f();
</code></pre>
Now you can go:<p><pre><code>    const inferred_type = run(() =&gt; {
      switch(blah) {
        ...
      }
    })</code></pre></div><br/></div></div><div id="37172757" class="c"><input type="checkbox" id="c-37172757" checked=""/><div class="controls bullet"><span class="by">hardware2win</span><span>|</span><a href="#37172533">prev</a><span>|</span><a href="#37172159">next</a><span>|</span><label class="collapse" for="c-37172757">[-]</label><label class="expand" for="c-37172757">[1 more]</label></div><br/><div class="children"><div class="content">Ive been writing compiler in C# and I dont see anything fancy here except union type<p>Ive personally decided to avoid visitor pattern bloat and Im waiting for closed enum feature in order to have compile time exhaustive check</div><br/></div></div><div id="37172159" class="c"><input type="checkbox" id="c-37172159" checked=""/><div class="controls bullet"><span class="by">catsarebetter</span><span>|</span><a href="#37172757">prev</a><span>|</span><a href="#37172629">next</a><span>|</span><label class="collapse" for="c-37172159">[-]</label><label class="expand" for="c-37172159">[2 more]</label></div><br/><div class="children"><div class="content">That is surprising, I would&#x27;ve thought that TS would have more overhead because of the interfaces adding extra weight. Makes me wonder what else TS could apply to. Language parsing, maybe?</div><br/><div id="37172599" class="c"><input type="checkbox" id="c-37172599" checked=""/><div class="controls bullet"><span class="by">recursive</span><span>|</span><a href="#37172159">parent</a><span>|</span><a href="#37172629">next</a><span>|</span><label class="collapse" for="c-37172599">[-]</label><label class="expand" for="c-37172599">[1 more]</label></div><br/><div class="children"><div class="content">At runtime, interfaces have zero weight.  They get completely compiled out.</div><br/></div></div></div></div><div id="37172629" class="c"><input type="checkbox" id="c-37172629" checked=""/><div class="controls bullet"><span class="by">dna_polymerase</span><span>|</span><a href="#37172159">prev</a><span>|</span><a href="#37172285">next</a><span>|</span><label class="collapse" for="c-37172629">[-]</label><label class="expand" for="c-37172629">[1 more]</label></div><br/><div class="children"><div class="content">It sure is. For anyone looking into Compilers and just starting out, I recommend this book: <a href="https:&#x2F;&#x2F;keleshev.com&#x2F;compiling-to-assembly-from-scratch&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;keleshev.com&#x2F;compiling-to-assembly-from-scratch&#x2F;</a><p>The author uses a TypeScript subset to write a compiler to 32bit ARM assembly and explains that it almost looks like Pseudocode, so it is very accessible. A sentiment I can get behind, despite avoiding it in any case possible.</div><br/></div></div><div id="37172285" class="c"><input type="checkbox" id="c-37172285" checked=""/><div class="controls bullet"><span class="by">newusertoday</span><span>|</span><a href="#37172629">prev</a><span>|</span><a href="#37172354">next</a><span>|</span><label class="collapse" for="c-37172285">[-]</label><label class="expand" for="c-37172285">[6 more]</label></div><br/><div class="children"><div class="content">it isn&#x27;t, i have codebase in golang that is much larger than typescript and it is pleasant to work with lsp and compiles smoothly. With typescript i have to turn off lsp and even after that it takes long time too compile. There is a reason why people are writing typescript compiler in rust.</div><br/><div id="37172306" class="c"><input type="checkbox" id="c-37172306" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#37172285">parent</a><span>|</span><a href="#37172368">next</a><span>|</span><label class="collapse" for="c-37172306">[-]</label><label class="expand" for="c-37172306">[4 more]</label></div><br/><div class="children"><div class="content">He&#x27;s talking about compilers for small languages. The Typescript LSP works fine on very big projects like VSCode so I think you&#x27;d need an enormous language like C++ or Rust before you&#x27;d run into those limits.<p>But still, I think I&#x27;d rather use Rust. I&#x27;m pretty sure the code would be nicer (e.g. no need for the explicit tag field or for the visitor hack).</div><br/><div id="37172336" class="c"><input type="checkbox" id="c-37172336" checked=""/><div class="controls bullet"><span class="by">tejinderss</span><span>|</span><a href="#37172285">root</a><span>|</span><a href="#37172306">parent</a><span>|</span><a href="#37172402">next</a><span>|</span><label class="collapse" for="c-37172336">[-]</label><label class="expand" for="c-37172336">[1 more]</label></div><br/><div class="children"><div class="content">The author is no stranger to rust (he’s creator of rust-analyser). The reason why he’s pitching typescript here is due to its high level nature and doesnt have to deal with memory management, low level integer types etc.</div><br/></div></div><div id="37172402" class="c"><input type="checkbox" id="c-37172402" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#37172285">root</a><span>|</span><a href="#37172306">parent</a><span>|</span><a href="#37172336">prev</a><span>|</span><a href="#37172368">next</a><span>|</span><label class="collapse" for="c-37172402">[-]</label><label class="expand" for="c-37172402">[2 more]</label></div><br/><div class="children"><div class="content">I see ‘TS server has been restarted 5 times in 5 minutes’ daily.</div><br/><div id="37172519" class="c"><input type="checkbox" id="c-37172519" checked=""/><div class="controls bullet"><span class="by">iends</span><span>|</span><a href="#37172285">root</a><span>|</span><a href="#37172402">parent</a><span>|</span><a href="#37172368">next</a><span>|</span><label class="collapse" for="c-37172519">[-]</label><label class="expand" for="c-37172519">[1 more]</label></div><br/><div class="children"><div class="content">I don’t see this and I work on large enterprise websocket server with almost a million daily active users. In fact, I think we had 100% up time for the last 12 months except for a few AWS outages. Codebase is 10 years old and was CoffeeScript -&gt; ES6 -&gt; TypeScript.</div><br/></div></div></div></div></div></div></div></div><div id="37172354" class="c"><input type="checkbox" id="c-37172354" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#37172285">prev</a><span>|</span><label class="collapse" for="c-37172354">[-]</label><label class="expand" for="c-37172354">[3 more]</label></div><br/><div class="children"><div class="content">But to what end? For a compiler, there is no need for all the overhead of npm (usually), ts, tsconfig, package.json bundler and bundler configuration, to get something usable, unless one really wants a JS thing at the end to run in the browser. I imagine even some webassembly tool chains may be shorter.</div><br/><div id="37172367" class="c"><input type="checkbox" id="c-37172367" checked=""/><div class="controls bullet"><span class="by">meheleventyone</span><span>|</span><a href="#37172354">parent</a><span>|</span><a href="#37172363">next</a><span>|</span><label class="collapse" for="c-37172367">[-]</label><label class="expand" for="c-37172367">[1 more]</label></div><br/><div class="children"><div class="content">The article answers this question. The author is using deno which is a single binary that uses TypeScript without all of that.</div><br/></div></div></div></div></div></div></div></div></div></body></html>