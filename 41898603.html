<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729501267894" as="style"/><link rel="stylesheet" href="styles.css?v=1729501267894"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://nolanlawson.com/2024/10/20/why-im-skeptical-of-rewriting-javascript-tools-in-faster-languages/">Skeptical of rewriting JavaScript tools in &quot;faster&quot; languages</a> <span class="domain">(<a href="https://nolanlawson.com">nolanlawson.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>172 comments</span></div><br/><div><div id="41901887" class="c"><input type="checkbox" id="c-41901887" checked=""/><div class="controls bullet"><span class="by">steve_adams_86</span><span>|</span><a href="#41901399">next</a><span>|</span><label class="collapse" for="c-41901887">[-]</label><label class="expand" for="c-41901887">[1 more]</label></div><br/><div class="children"><div class="content">I’ve written quite a bit of tooling in JS, and I genuinely enjoy the language, but I feel like Rust and Go are a godsend for these types of tools. I will sometimes prototype with TypeScript, but if something requires massive concurrency and parallelism, it’s unlikely I’ll stick with it.<p>I wonder if the author would feel differently if they spent more time writing in more languages on tooling like this. My life got a lot easier when I stopped trying to write TypeScript everywhere and leveraged other languages for their strengths where it made sense. I really wanted to stick to one language I felt most capable with, but seeing how much easier it could be made me change my mind in an instant.<p>The desire for stronger duck typing is confusing to me, but to each their own. I find Rust allows me to feel far, far more confident in tooling specifically because of its type system. I love that about it. I wish Go’s was a bit more sane, but there are tons of people who disagree with me.</div><br/></div></div><div id="41901399" class="c"><input type="checkbox" id="c-41901399" checked=""/><div class="controls bullet"><span class="by">thomasvogelaar</span><span>|</span><a href="#41901887">prev</a><span>|</span><a href="#41901215">next</a><span>|</span><label class="collapse" for="c-41901399">[-]</label><label class="expand" for="c-41901399">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t buy the argument that a lot of the performance jumps from rewrites comes from developers writing more optimised code.<p>I&#x27;ve worked on multiple rewrites of existing systems in both JS and PHP to Go and those projects were usually re-written strictly 1:1 (bugs becoming features and all that). It was pretty typical to see an 8-10x performance improvement by <i>just switching language</i>.</div><br/><div id="41901538" class="c"><input type="checkbox" id="c-41901538" checked=""/><div class="controls bullet"><span class="by">xandrius</span><span>|</span><a href="#41901399">parent</a><span>|</span><a href="#41901215">next</a><span>|</span><label class="collapse" for="c-41901538">[-]</label><label class="expand" for="c-41901538">[2 more]</label></div><br/><div class="children"><div class="content">Exactly the same experience.<p>For a smallish batch processing script I had written in node, I just fed it to chatgpt and got the golang version. It went from being unusable with over 100K records to handling 1M on exactly the same machine.<p>And only then I started adding things like channels, parallelism, and smart things.</div><br/><div id="41901594" class="c"><input type="checkbox" id="c-41901594" checked=""/><div class="controls bullet"><span class="by">thomasvogelaar</span><span>|</span><a href="#41901399">root</a><span>|</span><a href="#41901538">parent</a><span>|</span><a href="#41901215">next</a><span>|</span><label class="collapse" for="c-41901594">[-]</label><label class="expand" for="c-41901594">[1 more]</label></div><br/><div class="children"><div class="content">Now that there&#x27;s no perfect parity to maintain we&#x27;ve started optimising the Go versions as well. Multiple 2x performance improvements once we started doing this, on top of the original performance improvements. This translates to insane cost savings when you&#x27;re working at scale.</div><br/></div></div></div></div></div></div><div id="41901215" class="c"><input type="checkbox" id="c-41901215" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#41901399">prev</a><span>|</span><a href="#41899671">next</a><span>|</span><label class="collapse" for="c-41901215">[-]</label><label class="expand" for="c-41901215">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One reason for my skepticism is that I just don’t think we’ve exhausted all the possibilities of making JavaScript tools faster.<p>Exhausting is very exhausting, so at a fraction of that effort you could build on better foundations</div><br/></div></div><div id="41899671" class="c"><input type="checkbox" id="c-41899671" checked=""/><div class="controls bullet"><span class="by">cxr</span><span>|</span><a href="#41901215">prev</a><span>|</span><a href="#41898942">next</a><span>|</span><label class="collapse" for="c-41899671">[-]</label><label class="expand" for="c-41899671">[1 more]</label></div><br/><div class="children"><div class="content">This, like most articles dealing with &quot;JS&quot;, is really more about the things you&#x27;ll find yourself futzing around with when you&#x27;re in the NodeJS and NPM ecosystem.<p>You wouldn&#x27;t conflate Windows development with &quot;C&quot; (and completely discount UNIX along the way) just because of Win32.  But that&#x27;s about how bonkers it is when it comes to JS  and people do the same with its relationship to Node—not only was JS not created to serve the Node ecosystem, the prescriptions that NPM and Node programmers insist on often cut against the grain of the language.  And that&#x27;s just when we&#x27;re focused on convention and haven&#x27;t even gotten to the outright incompatibilities between Node and the language standard (or Node&#x27;s proprietary APIs).<p>node_modules, for example?  That has fuck-all to do with ECMA262&#x2F;JS.  Tailwind, Rollup, Prettier, all this other stuff—even the misleadingly named ESLint?  Same.  You&#x27;re having a terrible experience because you&#x27;re interacting with terrible software.  It doesn&#x27;t matter that it&#x27;s written in JS (or quasi-JS).  Rewrite these implementations all in other languages, and the terrible experience will remain.<p>Besides, anyone who&#x27;s staking out a position that <i>a language</i> is slow, and that JS is one of them is wrong two ways, and you don&#x27;t have to listen to or legitimize them.</div><br/></div></div><div id="41898942" class="c"><input type="checkbox" id="c-41898942" checked=""/><div class="controls bullet"><span class="by">sksxihve</span><span>|</span><a href="#41899671">prev</a><span>|</span><a href="#41901506">next</a><span>|</span><label class="collapse" for="c-41898942">[-]</label><label class="expand" for="c-41898942">[6 more]</label></div><br/><div class="children"><div class="content">&gt; Whereas if it’s written in a native language, I’d need to check out the source code and compile it myself – a big barrier to entry.<p>Is it though? Rust&#x2F;Zig&#x2F;Go programs are pretty much all incredibly easy to checkout and compile, it&#x27;s one of the big selling points of those languages. And at the end of the day how often are javascript developers fixing the tooling they use even when it&#x27;s written in javascript?<p>I&#x27;ve always felt learning new languages give me not only new tools to use but shapes the way I think about solving problems.</div><br/><div id="41901026" class="c"><input type="checkbox" id="c-41901026" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41898942">parent</a><span>|</span><a href="#41900897">next</a><span>|</span><label class="collapse" for="c-41901026">[-]</label><label class="expand" for="c-41901026">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s definitely more of a pain to figure out rustup than to use the Node.js environment that&#x27;s already installed. As noted in the article, you can quite literally go edit the source of your NPM packages without downloading or compiling a single thing.<p>Minor speedbumps like installing Rust don&#x27;t stop me now, and probably don&#x27;t stop you either, but they might have at the start of my career. You have to think about the marginal developers here: how many people are able to debug the simple thing who would be unable or unwilling to do it for the complicated thing? As you note, it&#x27;s already quite rare to fix up one&#x27;s tooling, so we can&#x27;t afford to lose too many potential contributors.<p>I like learning new languages too, but not to the extent that I&#x27;d choose to debug my toolchain in Zig while under time pressure. This is something I&#x27;ve actually done before, most notably for FontCustom, which was a lovably janky Ruby tool for generating font icons popular about a decade ago.</div><br/><div id="41901170" class="c"><input type="checkbox" id="c-41901170" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#41898942">root</a><span>|</span><a href="#41901026">parent</a><span>|</span><a href="#41900897">next</a><span>|</span><label class="collapse" for="c-41901170">[-]</label><label class="expand" for="c-41901170">[2 more]</label></div><br/><div class="children"><div class="content">That’s not objectively true at all. I learned to use Rust long before I ever touched a Node setup, and the first time I wanted to run a JS app it took me a lot longer to figure out how to do it than it did to type `cargo run foo`.<p>Neither is easier than the other. Whichever one you already know will be easier for you, and that’s it.</div><br/><div id="41901332" class="c"><input type="checkbox" id="c-41901332" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41898942">root</a><span>|</span><a href="#41901170">parent</a><span>|</span><a href="#41900897">next</a><span>|</span><label class="collapse" for="c-41901332">[-]</label><label class="expand" for="c-41901332">[1 more]</label></div><br/><div class="children"><div class="content">Sorry, I think we might be talking across each other. I am saying <i>from the perspective of someone who is already using a full Node.js environment</i>, adding Rust must necessarily increase complexity. I am taking this perspective because in the article we&#x27;re talking about, the examples are exclusively JavaScript tooling like Rollup, Prettier, and ESLint, where the only people using those tools are JavaScript developers who are already running node.<p>I have absolutely no interest in getting into a pissing match about whose language and ecosystem is better, and I in fact agree that the Rust tooling is less complicated than JS to start with. Nevertheless, the article is not about choosing <i>either</i> JS <i>or</i> Rust, it&#x27;s about rewriting tools for working with JS <i>in</i> Rust, which necessarily makes you learn Rust on top of JS if you want to modify them.</div><br/></div></div></div></div></div></div><div id="41900897" class="c"><input type="checkbox" id="c-41900897" checked=""/><div class="controls bullet"><span class="by">M4v3R</span><span>|</span><a href="#41898942">parent</a><span>|</span><a href="#41901026">prev</a><span>|</span><a href="#41898974">next</a><span>|</span><label class="collapse" for="c-41900897">[-]</label><label class="expand" for="c-41900897">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you on the easy part, but it’s definitely not as fast. In JS you get instant hot code reload and even without that the interpreter starts up pretty fast. In comparison Rust takes a while to recompile even with simple changes, and if you have more changes in many files (eg. switching between branches) then it’s <i>really</i> slow.</div><br/></div></div><div id="41898974" class="c"><input type="checkbox" id="c-41898974" checked=""/><div class="controls bullet"><span class="by">timeon</span><span>|</span><a href="#41898942">parent</a><span>|</span><a href="#41900897">prev</a><span>|</span><a href="#41901506">next</a><span>|</span><label class="collapse" for="c-41898974">[-]</label><label class="expand" for="c-41898974">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if author is aware that Node.js is not written in JavaScript.</div><br/></div></div></div></div><div id="41901506" class="c"><input type="checkbox" id="c-41901506" checked=""/><div class="controls bullet"><span class="by">pzo</span><span>|</span><a href="#41898942">prev</a><span>|</span><a href="#41898959">next</a><span>|</span><label class="collapse" for="c-41901506">[-]</label><label class="expand" for="c-41901506">[1 more]</label></div><br/><div class="children"><div class="content">Here you have benchmark of programming languages:
<a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;</a><p>On top of that some languages don&#x27;t have support for SIMD&#x2F;NEON and parallel libraries or GPU processing libraries - those things can significantly improve performance</div><br/></div></div><div id="41898959" class="c"><input type="checkbox" id="c-41898959" checked=""/><div class="controls bullet"><span class="by">from-nibly</span><span>|</span><a href="#41901506">prev</a><span>|</span><a href="#41898724">next</a><span>|</span><label class="collapse" for="c-41898959">[-]</label><label class="expand" for="c-41898959">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It’s very forgiving of types<p>I lost you here. JavaScript doesn&#x27;t work around type issues, no language really can. It just pushes the type issues to a later time.</div><br/></div></div><div id="41898724" class="c"><input type="checkbox" id="c-41898724" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41898959">prev</a><span>|</span><a href="#41901456">next</a><span>|</span><label class="collapse" for="c-41898724">[-]</label><label class="expand" for="c-41898724">[6 more]</label></div><br/><div class="children"><div class="content">the big issue here is the debuggability by having all your dependencies in the same language, and it&#x27;s not even like these rewrites will all be in the same performant language for you to learn, so essentially if you are using a wasm compiled dependency you are not likely to be able to go into that dependency&#x27;s code and figure out where the library author has messed up or what you have misunderstood from the documentation.</div><br/><div id="41898767" class="c"><input type="checkbox" id="c-41898767" checked=""/><div class="controls bullet"><span class="by">Kinrany</span><span>|</span><a href="#41898724">parent</a><span>|</span><a href="#41901456">next</a><span>|</span><label class="collapse" for="c-41898767">[-]</label><label class="expand" for="c-41898767">[5 more]</label></div><br/><div class="children"><div class="content">The solution to that is dependencies that work</div><br/><div id="41898778" class="c"><input type="checkbox" id="c-41898778" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41898724">root</a><span>|</span><a href="#41898767">parent</a><span>|</span><a href="#41901456">next</a><span>|</span><label class="collapse" for="c-41898778">[-]</label><label class="expand" for="c-41898778">[4 more]</label></div><br/><div class="children"><div class="content">Does the dependency that always works and has no bugs also come with a free rainbow and unicorn?</div><br/><div id="41898814" class="c"><input type="checkbox" id="c-41898814" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41898724">root</a><span>|</span><a href="#41898778">parent</a><span>|</span><a href="#41901456">next</a><span>|</span><label class="collapse" for="c-41898814">[-]</label><label class="expand" for="c-41898814">[3 more]</label></div><br/><div class="children"><div class="content">I sure hope so - otherwise how would I know the dependency I installed was going to always work?</div><br/><div id="41901500" class="c"><input type="checkbox" id="c-41901500" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#41898724">root</a><span>|</span><a href="#41898814">parent</a><span>|</span><a href="#41901456">next</a><span>|</span><label class="collapse" for="c-41901500">[-]</label><label class="expand" for="c-41901500">[2 more]</label></div><br/><div class="children"><div class="content">Ask the unicorn.</div><br/><div id="41901531" class="c"><input type="checkbox" id="c-41901531" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41898724">root</a><span>|</span><a href="#41901500">parent</a><span>|</span><a href="#41901456">next</a><span>|</span><label class="collapse" for="c-41901531">[-]</label><label class="expand" for="c-41901531">[1 more]</label></div><br/><div class="children"><div class="content">exactly, which is why I was hoping I would get one?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="41901456" class="c"><input type="checkbox" id="c-41901456" checked=""/><div class="controls bullet"><span class="by">GianFabien</span><span>|</span><a href="#41898724">prev</a><span>|</span><a href="#41900069">next</a><span>|</span><label class="collapse" for="c-41901456">[-]</label><label class="expand" for="c-41901456">[1 more]</label></div><br/><div class="children"><div class="content">Seems to me that the article and many of the comments conflate JS with Node.  Personally I abhor Node and work with both Bun and Deno. In both cases avoiding the Node compatible bits.</div><br/></div></div><div id="41900069" class="c"><input type="checkbox" id="c-41900069" checked=""/><div class="controls bullet"><span class="by">williamstein</span><span>|</span><a href="#41901456">prev</a><span>|</span><a href="#41898983">next</a><span>|</span><label class="collapse" for="c-41900069">[-]</label><label class="expand" for="c-41900069">[1 more]</label></div><br/><div class="children"><div class="content">I recently discovered Rspack, which is a compatible rewrite of Webpack in Rust by a guy at ByteDance.  It is genuinely 5x-10x faster across the board on my large&#x2F;complicated project.   I&#x27;ve been using Webpack for 8 years, and I was absolutely blown away to be able to easily swap Webpack out for something so similar (written in Rust) and get such a massive performance improvement.  This has made my life so much better.</div><br/></div></div><div id="41898983" class="c"><input type="checkbox" id="c-41898983" checked=""/><div class="controls bullet"><span class="by">porcoda</span><span>|</span><a href="#41900069">prev</a><span>|</span><a href="#41899143">next</a><span>|</span><label class="collapse" for="c-41898983">[-]</label><label class="expand" for="c-41898983">[3 more]</label></div><br/><div class="children"><div class="content">Sometimes it seems that people who write these kinds of pieces forget that not everyone in the world does web or even web-adjacent work, and node.js is something we don’t even consider to be part of our ecosystem.  Rewriting useful things in non-JS has the benefit of letting folks like me who avoid JS like the plague use useful tools.  Stop assuming everyone wants to get anywhere near the JS ecosystem: I’ve gone 30 years without touching it, and plan to continue that streak.  Rewriting stuff is great from my perspective.</div><br/><div id="41899192" class="c"><input type="checkbox" id="c-41899192" checked=""/><div class="controls bullet"><span class="by">namuol</span><span>|</span><a href="#41898983">parent</a><span>|</span><a href="#41899020">next</a><span>|</span><label class="collapse" for="c-41899192">[-]</label><label class="expand" for="c-41899192">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Stop assuming everyone wants to get anywhere near the JS ecosystem<p>The author is writing about JS ecosystem tools.</div><br/></div></div><div id="41899020" class="c"><input type="checkbox" id="c-41899020" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#41898983">parent</a><span>|</span><a href="#41899192">prev</a><span>|</span><a href="#41899143">next</a><span>|</span><label class="collapse" for="c-41899020">[-]</label><label class="expand" for="c-41899020">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Stop assuming everyone wants to get anywhere near the JS ecosystem<p>I have been dragged, through straight misrepresentation, into the Node.js world.<p>OMG, awful hardly begins to touch it.<p>I have not used Go, but as far as I can tell every thing the Node.js people do is done better in Go.<p>I do not recommend Rust.  I have a lot of experience with Rust, and unless you actually need the real time responsiveness it will bog you down.</div><br/></div></div></div></div><div id="41899143" class="c"><input type="checkbox" id="c-41899143" checked=""/><div class="controls bullet"><span class="by">a_wild_dandan</span><span>|</span><a href="#41898983">prev</a><span>|</span><a href="#41898858">next</a><span>|</span><label class="collapse" for="c-41899143">[-]</label><label class="expand" for="c-41899143">[2 more]</label></div><br/><div class="children"><div class="content">I’m continually surprised at JavaScript’s speed. Seeing JS sometimes nipping at the heels of C&#x2F;rust&#x2F;etc in performance benchmarks blows me away. V8 is such an incredible piece of engineering.<p>In my work, it’s hard to justify using something other than JS&#x2F;TS — incredible type system, fast, unified code base for server&#x2F;mobile&#x2F;web&#x2F;desktop, world’s biggest package ecosystem for anything you need, biggest hiring pool from being the best known language,  etc.<p>It’s just such a joy to work with, ime. Full-stack JS has been such a superpower for me, especially on smaller teams.<p>The dissonance between how the silent majority feels about JS (see, e.g the SO yearly survey), vs the animus it receives on platforms like HN is sad. So here’s my attempt at bringing a little positivity and appreciation to the comments haha.</div><br/><div id="41901486" class="c"><input type="checkbox" id="c-41901486" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#41899143">parent</a><span>|</span><a href="#41898858">next</a><span>|</span><label class="collapse" for="c-41901486">[-]</label><label class="expand" for="c-41901486">[1 more]</label></div><br/><div class="children"><div class="content">I want more people to understand how much people are working on JS performance. Google, Apple, Microsoft, Mozilla - all have incentive to make it as fast as possible.<p>Too bad JS is not the best candidate for many optimizations.<p>I wonder if we&#x27;ll get to the point of having a compiled version of JS that allows more static optimizations to be done.<p>WebAssembly might occupy that niche if it gets nice standardized runtime.</div><br/></div></div></div></div><div id="41898858" class="c"><input type="checkbox" id="c-41898858" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41899143">prev</a><span>|</span><a href="#41899074">next</a><span>|</span><label class="collapse" for="c-41898858">[-]</label><label class="expand" for="c-41898858">[20 more]</label></div><br/><div class="children"><div class="content">&gt; I just don’t think we’ve exhausted all the possibilities of making JavaScript tools faster<p>Rewriting in more performant languages spares you from the pain of optimization. These tools written in Rust are somehow 100× as fast despite not being optimized at all.<p>JavaScript is so slow that you <i>have</i> to optimize stuff, with Rust (and other performant languages) you don&#x27;t even need to because performance just doesn&#x27;t bubble up as a problem at all, letting you focus on building the actual tool.</div><br/><div id="41898975" class="c"><input type="checkbox" id="c-41898975" checked=""/><div class="controls bullet"><span class="by">dan-robertson</span><span>|</span><a href="#41898858">parent</a><span>|</span><a href="#41901628">next</a><span>|</span><label class="collapse" for="c-41898975">[-]</label><label class="expand" for="c-41898975">[2 more]</label></div><br/><div class="children"><div class="content">I think there’s a lot of bias in the samples one tends to see:<p>- you’re less likely to hear about a failed rewrite<p>- rewrites often gain from having a much better understanding of the problem&#x2F;requirements than the existing solution which was likely developed more incrementally<p>- if you know you will care about performance a lot, you hopefully will think about how to architect things in a way that is capable of achieving good performance. (Non-cpu example: if you are gluing streams of data with processing steps together, you may not think much about buffering; if you know you will care about throughput, you will probably have to think about batching and maybe also some kind of fan-out-&gt;map-&gt;fan-in; if you know you will care about latency you will probably think about each extra hop or batch-building step)<p>- hopefully people do a bit of napkin math to decide if rewriting something to be faster will achieve the goals, and so you only see the rewrites that people thought would be beneficial (because eg you’re touching a lot of memory so a better memory layout could help)<p>I feel like you’re much more likely to see ‘we found some JavaScript that was too useful for its own good, figured out how to rewrite it with better algorithms&#x2F;data structures, concurrency, and sims instructions, which we used rust to get’ than ‘our service receives one request, sends 10 requests to 5 different services, collects the results and responds; we rewrote it in rust but the performance is the same because it turns out most of what our service did was waiting’.</div><br/><div id="41898997" class="c"><input type="checkbox" id="c-41898997" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898975">parent</a><span>|</span><a href="#41901628">next</a><span>|</span><label class="collapse" for="c-41898997">[-]</label><label class="expand" for="c-41898997">[1 more]</label></div><br/><div class="children"><div class="content">Only semi-relevant, but there&#x27;s also the fact that lower level languages can auto-optimize more deeply -- but that&#x27;s also more my intuition (would love to get learnt if I&#x27;m wrong).<p>For example, I&#x27;d expect that Rust (or rustc I guess) can auto-vectorize more than Node&#x2F;Deno&#x2F;etc.</div><br/></div></div></div></div><div id="41901628" class="c"><input type="checkbox" id="c-41901628" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41898858">parent</a><span>|</span><a href="#41898975">prev</a><span>|</span><a href="#41901141">next</a><span>|</span><label class="collapse" for="c-41901628">[-]</label><label class="expand" for="c-41901628">[1 more]</label></div><br/><div class="children"><div class="content">Javascript should introduce integers and structs and it will have 10-100x the performance it has today without spending another $100 billion on VM optimization.</div><br/></div></div><div id="41901141" class="c"><input type="checkbox" id="c-41901141" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41898858">parent</a><span>|</span><a href="#41901628">prev</a><span>|</span><a href="#41898937">next</a><span>|</span><label class="collapse" for="c-41901141">[-]</label><label class="expand" for="c-41901141">[1 more]</label></div><br/><div class="children"><div class="content">I really don&#x27;t think the problem is JavaScript in all these cases. I&#x27;ve seen codebases using webpack where the JS was being run through babel twice in a row, because webpack is a complicated nuisance and nobody on the team had gotten around to fixing it. You can&#x27;t blame that on V8 or node being slow.</div><br/></div></div><div id="41898937" class="c"><input type="checkbox" id="c-41898937" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#41898858">parent</a><span>|</span><a href="#41901141">prev</a><span>|</span><a href="#41898923">next</a><span>|</span><label class="collapse" for="c-41898937">[-]</label><label class="expand" for="c-41898937">[3 more]</label></div><br/><div class="children"><div class="content">Someday soon I hope webasm gets another decent compiled language targeted for JS speedups. Something interoperable with JS.<p>For analogies, look no further than ASM in the early days and the motivations that brought us C, but with the lessons learned as well.<p>Rust is fine for this, except for interoperability.</div><br/><div id="41898963" class="c"><input type="checkbox" id="c-41898963" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898937">parent</a><span>|</span><a href="#41898923">next</a><span>|</span><label class="collapse" for="c-41898963">[-]</label><label class="expand" for="c-41898963">[2 more]</label></div><br/><div class="children"><div class="content">It looks like Rust can interop with JS via WebASM?<p><a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;65000209&#x2F;how-to-call-rust-from-js-and-back" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;65000209&#x2F;how-to-call-rus...</a></div><br/><div id="41899057" class="c"><input type="checkbox" id="c-41899057" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898963">parent</a><span>|</span><a href="#41898923">next</a><span>|</span><label class="collapse" for="c-41899057">[-]</label><label class="expand" for="c-41899057">[1 more]</label></div><br/><div class="children"><div class="content">Of course that&#x27;s why we&#x27;re discussing it. I&#x27;m referring to stronger interop like how you can embed ASM in C, and therefore CPP.<p>Like a JS&#x2F;TS that can have compiled blocks specified in the same language, preferably inline? I&#x27;m reaching here.</div><br/></div></div></div></div></div></div><div id="41898923" class="c"><input type="checkbox" id="c-41898923" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#41898858">parent</a><span>|</span><a href="#41898937">prev</a><span>|</span><a href="#41898915">next</a><span>|</span><label class="collapse" for="c-41898923">[-]</label><label class="expand" for="c-41898923">[8 more]</label></div><br/><div class="children"><div class="content">Being a statically-typed compiled language has its perks (especially when doing systems programming). Regardless, JS runtimes can and will push forward (like JVM &#x2F; ART did), given there&#x27;s healthy competition for both v8 &amp; Node.</div><br/><div id="41898947" class="c"><input type="checkbox" id="c-41898947" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898923">parent</a><span>|</span><a href="#41898915">next</a><span>|</span><label class="collapse" for="c-41898947">[-]</label><label class="expand" for="c-41898947">[7 more]</label></div><br/><div class="children"><div class="content">JavaScript, Python, Lua, I don&#x27;t see any dynamic language with good performances. Do you have examples?</div><br/><div id="41898999" class="c"><input type="checkbox" id="c-41898999" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898947">parent</a><span>|</span><a href="#41900448">next</a><span>|</span><label class="collapse" for="c-41898999">[-]</label><label class="expand" for="c-41898999">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Good&quot; compared to what?  All the mentioned languages keep getting more performant year-over-year, but in the medium future scripting languages are unlikely to reach the performance levels of C, Rust or other low-level languages.<p>Wouldn&#x27;t it be amazing though?  Maybe some combination of JIT and runtime static analysis could do it.<p>Personally, I never assign different types to the same variable unless it&#x27;s part of a union (e.g. string | HTMLObject | null, in JS).<p>It would probably require getting rid of `eval&#x27; though, which I am fine with.  On average, eval() tends to be naughty and those needs could be better met in other ways than blindly executing a string.</div><br/></div></div><div id="41900448" class="c"><input type="checkbox" id="c-41900448" checked=""/><div class="controls bullet"><span class="by">EasyMark</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898947">parent</a><span>|</span><a href="#41898999">prev</a><span>|</span><a href="#41898978">next</a><span>|</span><label class="collapse" for="c-41900448">[-]</label><label class="expand" for="c-41900448">[1 more]</label></div><br/><div class="children"><div class="content">Javascript is screamingly fast compared to the vast majority of other dynamic languages (scripting type, not something like Objective C). This is with the V8 engine of course. I’m not sure where you’re getting that it’s slow?</div><br/></div></div><div id="41898978" class="c"><input type="checkbox" id="c-41898978" checked=""/><div class="controls bullet"><span class="by">dkersten</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898947">parent</a><span>|</span><a href="#41900448">prev</a><span>|</span><a href="#41899446">next</a><span>|</span><label class="collapse" for="c-41898978">[-]</label><label class="expand" for="c-41898978">[1 more]</label></div><br/><div class="children"><div class="content">Lua with LuaJIT has pretty good performance. With that said, I spent today writing in C++, so I do agree with the overall sentiment.</div><br/></div></div><div id="41899446" class="c"><input type="checkbox" id="c-41899446" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898947">parent</a><span>|</span><a href="#41898978">prev</a><span>|</span><a href="#41898915">next</a><span>|</span><label class="collapse" for="c-41899446">[-]</label><label class="expand" for="c-41899446">[3 more]</label></div><br/><div class="children"><div class="content">Common Lisp (SBCL)?</div><br/><div id="41901006" class="c"><input type="checkbox" id="c-41901006" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41899446">parent</a><span>|</span><a href="#41898915">next</a><span>|</span><label class="collapse" for="c-41901006">[-]</label><label class="expand" for="c-41901006">[2 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t forget Scheme (Gambit, Chez, Racket).</div><br/><div id="41901139" class="c"><input type="checkbox" id="c-41901139" checked=""/><div class="controls bullet"><span class="by">BoingBoomTschak</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41901006">parent</a><span>|</span><a href="#41898915">next</a><span>|</span><label class="collapse" for="c-41901139">[-]</label><label class="expand" for="c-41901139">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s true, though I&#x27;d argue these are not as dynamic.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41898915" class="c"><input type="checkbox" id="c-41898915" checked=""/><div class="controls bullet"><span class="by">evanjrowley</span><span>|</span><a href="#41898858">parent</a><span>|</span><a href="#41898923">prev</a><span>|</span><a href="#41899074">next</a><span>|</span><label class="collapse" for="c-41898915">[-]</label><label class="expand" for="c-41898915">[4 more]</label></div><br/><div class="children"><div class="content">&gt;JavaScript is so slow that you have to optimize stuff<p>This raises the question, is JavaScript more prone to premature optimization?</div><br/><div id="41898925" class="c"><input type="checkbox" id="c-41898925" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898915">parent</a><span>|</span><a href="#41899074">next</a><span>|</span><label class="collapse" for="c-41898925">[-]</label><label class="expand" for="c-41898925">[3 more]</label></div><br/><div class="children"><div class="content">Well, can we really call it premature optimization if it&#x27;s needed?</div><br/><div id="41900223" class="c"><input type="checkbox" id="c-41900223" checked=""/><div class="controls bullet"><span class="by">robinsonrc</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898925">parent</a><span>|</span><a href="#41899013">next</a><span>|</span><label class="collapse" for="c-41900223">[-]</label><label class="expand" for="c-41900223">[1 more]</label></div><br/><div class="children"><div class="content">I guess if folks write JS with the idea that optimisations are needed in mind, then the chances of premature optimisations may go up along with those of the required ones</div><br/></div></div><div id="41899013" class="c"><input type="checkbox" id="c-41899013" checked=""/><div class="controls bullet"><span class="by">dpritchett</span><span>|</span><a href="#41898858">root</a><span>|</span><a href="#41898925">parent</a><span>|</span><a href="#41900223">prev</a><span>|</span><a href="#41899074">next</a><span>|</span><label class="collapse" for="c-41899013">[-]</label><label class="expand" for="c-41899013">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of using Ruby ten years ago and having to contend with folks who wanted to default to using the string literal style over another because it was known to be more performant at scale. That awkward stuff surfaces earlier with some languages than with others.</div><br/></div></div></div></div></div></div></div></div><div id="41899074" class="c"><input type="checkbox" id="c-41899074" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#41898858">prev</a><span>|</span><a href="#41898891">next</a><span>|</span><label class="collapse" for="c-41899074">[-]</label><label class="expand" for="c-41899074">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I should also acknowledge: there is a perf hit from using Wasm versus pure-native tools. So this could be another reason native tools are taking the CLI world by storm, but not necessarily the browser frontend.</i><p>I didn&#x27;t know about this before, I wonder how much overhead?<p>The reason I am reluctant to rely on JS tools for anything CLI is because of Node.js instability due to version sensitivity and impossible-to-fix-without-reinstalling-the-os low level LibC errors.<p>Compared to go, rust, or python, the odds that any given CLI.js program will run across my (small) fleet of machines is very low, by factor or 10x or more compared to alternatives.  Some boxes I don&#x27;t want to reinstall from scratch every 4 years, they&#x27;re not public facing and life is too short.</div><br/><div id="41901638" class="c"><input type="checkbox" id="c-41901638" checked=""/><div class="controls bullet"><span class="by">lenkite</span><span>|</span><a href="#41899074">parent</a><span>|</span><a href="#41898891">next</a><span>|</span><label class="collapse" for="c-41901638">[-]</label><label class="expand" for="c-41901638">[1 more]</label></div><br/><div class="children"><div class="content">Deno is fixing this with their standard library and JSR.</div><br/></div></div></div></div><div id="41898891" class="c"><input type="checkbox" id="c-41898891" checked=""/><div class="controls bullet"><span class="by">qianli_cs</span><span>|</span><a href="#41899074">prev</a><span>|</span><a href="#41900896">next</a><span>|</span><label class="collapse" for="c-41898891">[-]</label><label class="expand" for="c-41898891">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if JavaScript supports it, but some Python libraries allow you to choose whether to install a more optimized binary version or the pure Python implementation.<p>For example, if you install psycopg you&#x27;ll get a pure Python implementation which is easy to debug and hack. But you can also install psycopg[binary] to obtain a faster, compiled version of the library. <a href="https:&#x2F;&#x2F;www.psycopg.org&#x2F;psycopg3&#x2F;docs&#x2F;basic&#x2F;install.html" rel="nofollow">https:&#x2F;&#x2F;www.psycopg.org&#x2F;psycopg3&#x2F;docs&#x2F;basic&#x2F;install.html</a></div><br/><div id="41898977" class="c"><input type="checkbox" id="c-41898977" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41898891">parent</a><span>|</span><a href="#41900896">next</a><span>|</span><label class="collapse" for="c-41898977">[-]</label><label class="expand" for="c-41898977">[1 more]</label></div><br/><div class="children"><div class="content">That typically means two totally different implementations, and pure Python versions are often unusably slow, so it doesn&#x27;t help much to hack that.</div><br/></div></div></div></div><div id="41900896" class="c"><input type="checkbox" id="c-41900896" checked=""/><div class="controls bullet"><span class="by">simultsop</span><span>|</span><a href="#41898891">prev</a><span>|</span><a href="#41899856">next</a><span>|</span><label class="collapse" for="c-41900896">[-]</label><label class="expand" for="c-41900896">[8 more]</label></div><br/><div class="children"><div class="content">While the skeptical&#x27;s stall in decision making, new comers who do not think twice about rewriting. Rewrite software on a smaller budget in experimental attempts. Then management decides to chose the cheaper option available, because lean startup is promising. Then in next 10 years the new comers become the new skepticals. I don&#x27;t know if there&#x27;s a case that this cycle is not repeated, at any time frame.</div><br/><div id="41900957" class="c"><input type="checkbox" id="c-41900957" checked=""/><div class="controls bullet"><span class="by">gwerbret</span><span>|</span><a href="#41900896">parent</a><span>|</span><a href="#41901452">prev</a><span>|</span><a href="#41899856">next</a><span>|</span><label class="collapse" for="c-41900957">[-]</label><label class="expand" for="c-41900957">[6 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve read your comment several times and still don&#x27;t know what it means. Can you clarify?</div><br/><div id="41901064" class="c"><input type="checkbox" id="c-41901064" checked=""/><div class="controls bullet"><span class="by">strken</span><span>|</span><a href="#41900896">root</a><span>|</span><a href="#41900957">parent</a><span>|</span><a href="#41901490">next</a><span>|</span><label class="collapse" for="c-41901064">[-]</label><label class="expand" for="c-41901064">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve rewritten it for clarity: &quot;While the skeptics stall in decision making, newcomers will not think twice about rewriting software on a smaller budget as an experiment. Then management will decide to choose the cheapest option available, because the lean startup was more competitive. Then in the next 10 years, the newcomers become the new skeptics. In my experience this cycle is always repeated, albeit across different time frames.&quot;<p>I made the difficult choice to rewrite it in English again, even though French might have been more performant.</div><br/><div id="41901502" class="c"><input type="checkbox" id="c-41901502" checked=""/><div class="controls bullet"><span class="by">simultsop</span><span>|</span><a href="#41900896">root</a><span>|</span><a href="#41901064">parent</a><span>|</span><a href="#41901225">next</a><span>|</span><label class="collapse" for="c-41901502">[-]</label><label class="expand" for="c-41901502">[1 more]</label></div><br/><div class="children"><div class="content">Thank you so much, you taught me how to express this &quot;albeit across different time frames&quot;. It is difficult to use any language to simplify complex narrations.</div><br/></div></div></div></div><div id="41901490" class="c"><input type="checkbox" id="c-41901490" checked=""/><div class="controls bullet"><span class="by">simultsop</span><span>|</span><a href="#41900896">root</a><span>|</span><a href="#41900957">parent</a><span>|</span><a href="#41901064">prev</a><span>|</span><a href="#41899856">next</a><span>|</span><label class="collapse" for="c-41901490">[-]</label><label class="expand" for="c-41901490">[1 more]</label></div><br/><div class="children"><div class="content">Imagine developers as the choosing (management) part and if you are involved with webdev in last decade. Compare webpack and vite. As pricing parameter consider the time to bundle (faster=cheaper). So, what webpack did not do by not rewriting itself, vite came in offering.</div><br/></div></div></div></div></div></div><div id="41899856" class="c"><input type="checkbox" id="c-41899856" checked=""/><div class="controls bullet"><span class="by">leerob</span><span>|</span><a href="#41900896">prev</a><span>|</span><a href="#41899336">next</a><span>|</span><label class="collapse" for="c-41899856">[-]</label><label class="expand" for="c-41899856">[1 more]</label></div><br/><div class="children"><div class="content">If you want to steel man _for_ writing in Rust or Zig or Go, previous discussion here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35043720">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=35043720</a></div><br/></div></div><div id="41899336" class="c"><input type="checkbox" id="c-41899336" checked=""/><div class="controls bullet"><span class="by">musicale</span><span>|</span><a href="#41899856">prev</a><span>|</span><a href="#41898772">next</a><span>|</span><label class="collapse" for="c-41899336">[-]</label><label class="expand" for="c-41899336">[1 more]</label></div><br/><div class="children"><div class="content">JavaScript is a terrific language: more ubiquitous than BASIC ever was; nearly as easy to learn and use as Python; syntax that is close to Java&#x2F;C&#x2F;C++. And it only uses 10x the CPU and memory of C or C++.</div><br/></div></div><div id="41898772" class="c"><input type="checkbox" id="c-41898772" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41899336">prev</a><span>|</span><a href="#41898871">next</a><span>|</span><label class="collapse" for="c-41898772">[-]</label><label class="expand" for="c-41898772">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, i agree. I think there is a time where rewriting in a faster language is useful (just like how handcrafted assembly is still a thing), but most of the time you are very far away from the point where that is neccesary.<p>I also think there is an element of, &quot;rewrite in rust&quot; is just easy to say, where changing data structures or whatever requires analysis of the problem at hand.</div><br/><div id="41898883" class="c"><input type="checkbox" id="c-41898883" checked=""/><div class="controls bullet"><span class="by">MrHamburger</span><span>|</span><a href="#41898772">parent</a><span>|</span><a href="#41898871">next</a><span>|</span><label class="collapse" for="c-41898883">[-]</label><label class="expand" for="c-41898883">[2 more]</label></div><br/><div class="children"><div class="content">It is analogues discussion to C vs Rust. Sure Rust is memory safe, but whole ecosystem I am using today is C based. Compiler, SDK, drivers, RTOS, ... Nobody sane is going to rewrite it for the sake of rewriting it into a different language.</div><br/><div id="41901128" class="c"><input type="checkbox" id="c-41901128" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#41898772">root</a><span>|</span><a href="#41898883">parent</a><span>|</span><a href="#41898871">next</a><span>|</span><label class="collapse" for="c-41901128">[-]</label><label class="expand" for="c-41901128">[1 more]</label></div><br/><div class="children"><div class="content">I would disagree with that comparison. Rust really does provide an improvement in memory safety that is hard to achieve by other means. That&#x27;s not to say you should always rewrite in rust, there are plenty of situations where that doesn&#x27;t make sense. However its not analgous to the performance situation in my opinion.</div><br/></div></div></div></div></div></div><div id="41898871" class="c"><input type="checkbox" id="c-41898871" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41898772">prev</a><span>|</span><a href="#41900398">next</a><span>|</span><label class="collapse" for="c-41898871">[-]</label><label class="expand" for="c-41898871">[8 more]</label></div><br/><div class="children"><div class="content">The biggest reason to be skeptical is that these tools are not open to extension in the same way that JavaScript is.<p>Webpack has an enormous community of third-party plugins, it would be very hard to do something similar with e.g. Go or Zig.</div><br/><div id="41898951" class="c"><input type="checkbox" id="c-41898951" checked=""/><div class="controls bullet"><span class="by">klabb3</span><span>|</span><a href="#41898871">parent</a><span>|</span><a href="#41899005">next</a><span>|</span><label class="collapse" for="c-41898951">[-]</label><label class="expand" for="c-41898951">[4 more]</label></div><br/><div class="children"><div class="content">Right, because tooling is standardized in eg Go. There’s no custom build pipeline, transpilation hell, or experimental language features that are selectively enabled randomly. I’m not even against JS, like at all, and I think the majority of perf issues can be resolved. However, JS tooling is the prime example of where things get truly nightmarish from a software development perspective. Webpack being a perfect example of this horror.</div><br/><div id="41899009" class="c"><input type="checkbox" id="c-41899009" checked=""/><div class="controls bullet"><span class="by">postalrat</span><span>|</span><a href="#41898871">root</a><span>|</span><a href="#41898951">parent</a><span>|</span><a href="#41899976">next</a><span>|</span><label class="collapse" for="c-41899009">[-]</label><label class="expand" for="c-41899009">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also a breeding ground where the best ideas often end becoming a sort of standard not only for javascript devs but for other langauges as well.</div><br/><div id="41899197" class="c"><input type="checkbox" id="c-41899197" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41898871">root</a><span>|</span><a href="#41899009">parent</a><span>|</span><a href="#41899976">next</a><span>|</span><label class="collapse" for="c-41899197">[-]</label><label class="expand" for="c-41899197">[1 more]</label></div><br/><div class="children"><div class="content">Well curious as to what some of these ideas might be.<p>NPM has done a pretty great job of showing everyone else what to avoid doing.<p>The mere mention of “web pack” sends most of the FE devs I’ve met into borderline trauma flashbacks.<p>There’s seemingly half a dozen package managements tools, some of which also seem to be compilers? There’s also bundlers, but again some of these seem integrated. Half of the frameworks seem to ship their own tools?</div><br/></div></div></div></div><div id="41899976" class="c"><input type="checkbox" id="c-41899976" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#41898871">root</a><span>|</span><a href="#41898951">parent</a><span>|</span><a href="#41899009">prev</a><span>|</span><a href="#41899005">next</a><span>|</span><label class="collapse" for="c-41899976">[-]</label><label class="expand" for="c-41899976">[1 more]</label></div><br/><div class="children"><div class="content">You can ship a 20MB Go program and no one blinks.<p>Go programs <i>start</i> at 20MB. The Go AWS Terraform provider is something like 300MB.<p>A massive amount of the complexity&#x2F;difficulty in webdev build tools space has to with optimizing delivery sizes on the web platform.<p>Node.js tooling is straightforward comparatively.</div><br/></div></div></div></div><div id="41899005" class="c"><input type="checkbox" id="c-41899005" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898871">parent</a><span>|</span><a href="#41898951">prev</a><span>|</span><a href="#41900398">next</a><span>|</span><label class="collapse" for="c-41899005">[-]</label><label class="expand" for="c-41899005">[3 more]</label></div><br/><div class="children"><div class="content">This is funny to me. Go and zig are built with the Unix shell in mind  - the most extensible and modular system around.<p>The webpack ecosystem on the other hand is it’s own OS.</div><br/><div id="41899166" class="c"><input type="checkbox" id="c-41899166" checked=""/><div class="controls bullet"><span class="by">dpritchett</span><span>|</span><a href="#41898871">root</a><span>|</span><a href="#41899005">parent</a><span>|</span><a href="#41900398">next</a><span>|</span><label class="collapse" for="c-41899166">[-]</label><label class="expand" for="c-41899166">[2 more]</label></div><br/><div class="children"><div class="content">Maybe for  some the appeal of JS is in (hopefully) never having to learn Unix?<p>I’ve heard several folks say that about Kubernetes, but in my experience the *nix core always resurfaces the second things get weird.</div><br/><div id="41899181" class="c"><input type="checkbox" id="c-41899181" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898871">root</a><span>|</span><a href="#41899166">parent</a><span>|</span><a href="#41900398">next</a><span>|</span><label class="collapse" for="c-41899181">[-]</label><label class="expand" for="c-41899181">[1 more]</label></div><br/><div class="children"><div class="content">That certainly can be a benefit. But as we see here it also limits your thinking to that ecosystem.</div><br/></div></div></div></div></div></div></div></div><div id="41900398" class="c"><input type="checkbox" id="c-41900398" checked=""/><div class="controls bullet"><span class="by">kristianp</span><span>|</span><a href="#41898871">prev</a><span>|</span><a href="#41899004">next</a><span>|</span><label class="collapse" for="c-41900398">[-]</label><label class="expand" for="c-41900398">[1 more]</label></div><br/><div class="children"><div class="content">Can you now write client and server js code without installing npm?  I guess you&#x27;d be reinventing a lot of wheels that the packages provide.</div><br/></div></div><div id="41899004" class="c"><input type="checkbox" id="c-41899004" checked=""/><div class="controls bullet"><span class="by">cyberax</span><span>|</span><a href="#41900398">prev</a><span>|</span><a href="#41899978">next</a><span>|</span><label class="collapse" for="c-41899004">[-]</label><label class="expand" for="c-41899004">[2 more]</label></div><br/><div class="children"><div class="content">&gt; For another thing: it’s straightforward to modify JavaScript dependencies locally. I’ve often tweaked something in my local node_modules folder when I’m trying to track down a bug or work on a feature in a library I depend on. Whereas if it’s written in a native language, I’d need to check out the source code and compile it myself – a big barrier to entry.<p>Yeah, JavaScript is sloppy, but you can always monkey-patch it by modifying tool-controlled files. Great idea. Not.<p>JS is just not a good language. The JIT and the web of packages made it slightly more usable, but it&#x27;s still Not Good. There&#x27;s no real way to do real parallel processing, async&#x2F;await are hellish to debug, etc.<p>It&#x27;s unavoidable in browsers, but we _can_ avoid using it for tools. Look at Python, a native PIP replacement improved build times for HomeAssistant by an order of magnitude: <a href="https:&#x2F;&#x2F;developers.home-assistant.io&#x2F;blog&#x2F;2024&#x2F;04&#x2F;03&#x2F;build-images-with-uv&#x2F;" rel="nofollow">https:&#x2F;&#x2F;developers.home-assistant.io&#x2F;blog&#x2F;2024&#x2F;04&#x2F;03&#x2F;build-i...</a></div><br/><div id="41901325" class="c"><input type="checkbox" id="c-41901325" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#41899004">parent</a><span>|</span><a href="#41899978">next</a><span>|</span><label class="collapse" for="c-41901325">[-]</label><label class="expand" for="c-41901325">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Whereas if it’s written in a native language, I’d need to check out the source code and compile it myself – a big barrier to entry.<p>Or you could use the source code already downloaded by a package manager and do similar tweaks locally with the build manager picking them up and compiling for you</div><br/></div></div></div></div><div id="41899978" class="c"><input type="checkbox" id="c-41899978" checked=""/><div class="controls bullet"><span class="by">al2o3cr</span><span>|</span><a href="#41899004">prev</a><span>|</span><a href="#41898802">next</a><span>|</span><label class="collapse" for="c-41899978">[-]</label><label class="expand" for="c-41899978">[1 more]</label></div><br/><div class="children"><div class="content">IMO the biggest win when Phoenix switched to esbuild wasn&#x27;t about _speed_ exactly, it was about not having to install&amp;debug things like node-gyp just to get basic asset bundling going.</div><br/></div></div><div id="41898802" class="c"><input type="checkbox" id="c-41898802" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41899978">prev</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41898802">[-]</label><label class="expand" for="c-41898802">[24 more]</label></div><br/><div class="children"><div class="content">&gt; I’ve written a lot of JavaScript. I like JavaScript. And more importantly, I’ve built up a set of skills in understanding, optimizing, and debugging JavaScript that I’m reluctant to give up on.<p>It&#x27;s not that hard to do the same for a less terrible language. Choose something markedly different, i.e. a low level language like rust, and you will learn a lot in the process. More so because now you can see and understand the programming world from two different vantage points. Plus, it never hurts to understand what&#x27;s going on on a lower level, without an interpreter and eco-system abstracting things away so much. This can then feed back into your skills and understanding of JS.</div><br/><div id="41898881" class="c"><input type="checkbox" id="c-41898881" checked=""/><div class="controls bullet"><span class="by">captnObvious</span><span>|</span><a href="#41898802">parent</a><span>|</span><a href="#41898940">next</a><span>|</span><label class="collapse" for="c-41898881">[-]</label><label class="expand" for="c-41898881">[1 more]</label></div><br/><div class="children"><div class="content">I think we’re reading too far into the authors impostor syndrome.<p>He’s making contributions in Rust already. His opinion isn’t invalid just because he has a bias, he opens by acknowledging his bias.</div><br/></div></div><div id="41898940" class="c"><input type="checkbox" id="c-41898940" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41898802">parent</a><span>|</span><a href="#41898881">prev</a><span>|</span><a href="#41898815">next</a><span>|</span><label class="collapse" for="c-41898940">[-]</label><label class="expand" for="c-41898940">[2 more]</label></div><br/><div class="children"><div class="content">Hopefully the lot includes that writing stuff in low level languages isn&#x27;t worth the pain most of the time.</div><br/><div id="41898980" class="c"><input type="checkbox" id="c-41898980" checked=""/><div class="controls bullet"><span class="by">winwang</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898940">parent</a><span>|</span><a href="#41898815">next</a><span>|</span><label class="collapse" for="c-41898980">[-]</label><label class="expand" for="c-41898980">[1 more]</label></div><br/><div class="children"><div class="content">Curious what you mean by &quot;most&quot; (I&#x27;m agnostic&#x2F;unlearned on the statistics tbh). I &quot;feel&quot; like it doesn&#x27;t happen too often when it&#x27;s not either already low-level or the supposed extra performance is likely worth it.<p>Like, I can&#x27;t imagine most people using Javascript would <i>want</i> to rewrite in Rust without some decent reason.</div><br/></div></div></div></div><div id="41898815" class="c"><input type="checkbox" id="c-41898815" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41898802">parent</a><span>|</span><a href="#41898940">prev</a><span>|</span><a href="#41899798">next</a><span>|</span><label class="collapse" for="c-41898815">[-]</label><label class="expand" for="c-41898815">[13 more]</label></div><br/><div class="children"><div class="content">I swear some JS devs will go out of their way to avoid learning anything else, whilst simultaneously and breathlessly espousing that we rewrite everything else in JS.</div><br/><div id="41898850" class="c"><input type="checkbox" id="c-41898850" checked=""/><div class="controls bullet"><span class="by">oneweekwonder</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898815">parent</a><span>|</span><a href="#41898856">next</a><span>|</span><label class="collapse" for="c-41898850">[-]</label><label class="expand" for="c-41898850">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Any application that can be written in JavaScript, will eventually be written in JavaScript. - Jeff Atwood (2007)</div><br/></div></div><div id="41898856" class="c"><input type="checkbox" id="c-41898856" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898815">parent</a><span>|</span><a href="#41898850">prev</a><span>|</span><a href="#41899015">next</a><span>|</span><label class="collapse" for="c-41898856">[-]</label><label class="expand" for="c-41898856">[5 more]</label></div><br/><div class="children"><div class="content">i swear some non js devs will go to extreme lengths to demonstrate solutions that will never run on another machine instead of writing js</div><br/><div id="41898873" class="c"><input type="checkbox" id="c-41898873" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898856">parent</a><span>|</span><a href="#41899015">next</a><span>|</span><label class="collapse" for="c-41898873">[-]</label><label class="expand" for="c-41898873">[4 more]</label></div><br/><div class="children"><div class="content">Why would they never run on another machine? It&#x27;s not that hard to write portable code, and done very often. Nowadays for example, you rarely ever think about whether you&#x27;re on arm or x86.<p>If you write non-portal code, there might be an important reason (like writing OS components, which you won&#x27;t do in JS).</div><br/><div id="41899172" class="c"><input type="checkbox" id="c-41899172" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898873">parent</a><span>|</span><a href="#41899015">next</a><span>|</span><label class="collapse" for="c-41899172">[-]</label><label class="expand" for="c-41899172">[3 more]</label></div><br/><div class="children"><div class="content">almost every time code doesn’t run on my machine, the root cause is a political disagreement with a c-compiler author three layers below my actual problem.<p>javascript doesn’t have a compiler is my main point.</div><br/><div id="41899272" class="c"><input type="checkbox" id="c-41899272" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899172">parent</a><span>|</span><a href="#41899015">next</a><span>|</span><label class="collapse" for="c-41899272">[-]</label><label class="expand" for="c-41899272">[2 more]</label></div><br/><div class="children"><div class="content">Bit rich to complain about that when all the major browsers have just as significant differences, and that’s before we bring node into the equation, let alone talking about a good 30% of websites I visit with any quantity of JS in them are either perpetually broken in some way, or so jank as to be effectively broken.</div><br/><div id="41900318" class="c"><input type="checkbox" id="c-41900318" checked=""/><div class="controls bullet"><span class="by">tylerchilds</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899272">parent</a><span>|</span><a href="#41899015">next</a><span>|</span><label class="collapse" for="c-41900318">[-]</label><label class="expand" for="c-41900318">[1 more]</label></div><br/><div class="children"><div class="content">totally agreed about all of the above and i take credit for none of that code<p>i write plaintext at uris, progressively enhance that to hypertext using a port with a deno service, a runtime that unifies browser js with non browser js.<p>that hypertext can optionally load javascript and at no point was a compiler required aside from the versioned browser i can ask my customers to inspect or a version of deno we get on freebsd using pkg install.<p>node is not javascript would be my biggest  point if i had to conclude why i responded.<p>microsoft failed at killing the web with internet explorer and only switched to google’s engine after securing node’s package manager overtly through github and covertly through typescript.<p>microsoft is not javascript is my final point after circling back to my original point of microsoft is also one of the aforementioned reasoned c-compilers are politically fought over instead of things that just work.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41899015" class="c"><input type="checkbox" id="c-41899015" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898815">parent</a><span>|</span><a href="#41898856">prev</a><span>|</span><a href="#41898880">next</a><span>|</span><label class="collapse" for="c-41899015">[-]</label><label class="expand" for="c-41899015">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s usually the opposite. And the post is specifically about making JavaScript tools, why would you not expect them to be written in JS? I guess not making tools for say, c# devs in c# would also be bad?</div><br/><div id="41899672" class="c"><input type="checkbox" id="c-41899672" checked=""/><div class="controls bullet"><span class="by">rbower</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899015">parent</a><span>|</span><a href="#41899253">next</a><span>|</span><label class="collapse" for="c-41899672">[-]</label><label class="expand" for="c-41899672">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s usually the opposite. And the post is specifically about making JavaScript tools, why would you not expect them to be written in JS?<p>Take a look at rollup, vite, etc. These tools are essentially replacing webpack, which is written in JS.  Modern Rollup (^4) uses SWC (Rust-based bundler), and vite is currently using a mix of esbuild (Go) and Rollup.  I think they&#x27;re switching to SWC in v6 though.<p>The point here is that for certain operations JS is not nearly as fast as lower-level languages like the aforementioned. Bundling is one of those performance-critical areas where every second counts.<p>That said, as a TypeScript developer I agree with the sentiment that JS tools should be written in JS, but this isn&#x27;t a hard and fast rule. Sometimes performance matters more.  I think the reasonable approach is to prefer JS – or TS, same difference – for writing JS tools. If that doesn&#x27;t work, reach for something with more performance like Rust, Go, or C++.  So far I&#x27;ve only had to do the latter for 2 use cases, one of which is hardware profiling.</div><br/></div></div><div id="41899253" class="c"><input type="checkbox" id="c-41899253" checked=""/><div class="controls bullet"><span class="by">FridgeSeal</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899015">parent</a><span>|</span><a href="#41899672">prev</a><span>|</span><a href="#41900862">next</a><span>|</span><label class="collapse" for="c-41899253">[-]</label><label class="expand" for="c-41899253">[2 more]</label></div><br/><div class="children"><div class="content">Presumably because, apart from Python (see Ruff, uv, etc) most languages aren’t running into such major issues with their own “self hosted” tooling that it’s worthwhile to rewrite several of them in a completely different language.</div><br/><div id="41899347" class="c"><input type="checkbox" id="c-41899347" checked=""/><div class="controls bullet"><span class="by">mardifoufs</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899253">parent</a><span>|</span><a href="#41900862">next</a><span>|</span><label class="collapse" for="c-41899347">[-]</label><label class="expand" for="c-41899347">[1 more]</label></div><br/><div class="children"><div class="content">Yes I agree! And JavaScript also isn&#x27;t really at that point yet. Python is really in a class of its own here... sadly enough.<p>Though I don&#x27;t see an issue with tools for JS built without JS. It&#x27;s just that I don&#x27;t think that it&#x27;s a bad thing for a JavaScript dev to want the ecosystem around JavaScript to be written in JS. JS is orders of magnitudes faster than python in any case.</div><br/></div></div></div></div><div id="41900862" class="c"><input type="checkbox" id="c-41900862" checked=""/><div class="controls bullet"><span class="by">atmavatar</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899015">parent</a><span>|</span><a href="#41899253">prev</a><span>|</span><a href="#41898880">next</a><span>|</span><label class="collapse" for="c-41900862">[-]</label><label class="expand" for="c-41900862">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny you mention C# since VS Code is a perfect example of JS devs rewriting existing tools in JS.</div><br/></div></div></div></div><div id="41898880" class="c"><input type="checkbox" id="c-41898880" checked=""/><div class="controls bullet"><span class="by">TacticalCoder</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41898815">parent</a><span>|</span><a href="#41899015">prev</a><span>|</span><a href="#41899798">next</a><span>|</span><label class="collapse" for="c-41898880">[-]</label><label class="expand" for="c-41898880">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I swear some JS devs will go out of their way to avoid learning anything else, whilst simultaneously and breathlessly espousing that we rewrite everything else in JS.<p>The JStockholm syndrome.</div><br/></div></div></div></div><div id="41899798" class="c"><input type="checkbox" id="c-41899798" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41898802">parent</a><span>|</span><a href="#41898815">prev</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41899798">[-]</label><label class="expand" for="c-41899798">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>It&#x27;s not that hard to do the same for a less terrible language.</i><p>I miss that brief era when coding culture had a moment of trying to be nice, of not crudely shooting out mouths off at each other&#x27;s stuff crudely.<p>JS, particularly with typescript, is a pretty fine language. There&#x27;s a lot of bad developers and many bad organizations not doing their part to enable &amp; tend to their codebases, but any very popular language will likely have that problem &amp; it&#x27;s not the languages fault.<p>It&#x27;s a weakness &amp; a strength that JS is so flexible, can be so many different things to different people. Even though the language is so so much the same as it was a decade &amp; even two ago, how we use it gone through multiple cycles of diversification &amp; consolidation. Like perl, it is a post-modern language; adaptable &amp; changing, not prescriptive. <a href="http:&#x2F;&#x2F;www.wall.org&#x2F;~larry&#x2F;pm.html" rel="nofollow">http:&#x2F;&#x2F;www.wall.org&#x2F;~larry&#x2F;pm.html</a><p>If you do have negative words to say, at least have the courage &amp; ownership to say something distinct &amp; specific, with some arguments about what it is you are feeling.</div><br/><div id="41899836" class="c"><input type="checkbox" id="c-41899836" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899798">parent</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41899836">[-]</label><label class="expand" for="c-41899836">[6 more]</label></div><br/><div class="children"><div class="content">I’d normally agree with you, but JS is more or less designed to be terrible. It was hacked together by Brendan Eich in literally 10 days, who originally wanted to do something more Scheme-like. It was a quick and dirty hack that got stretched way beyond what it was even meant for.<p>It then literally had decades of ECMAscript committee effort to shape it into something more useable.<p>I could repeat the numerous criticisms, but there’s enough funny videos about it that make a much better job pointing out its shortcomings and, sometimes, downright craziness of it.<p>&gt; but any very popular language will likely have that problem &amp; it&#x27;s not the languages fault.<p>No, sorry, just no. I get where you are coming from, but in the case of JavaScript, its history and idiosyncrasies alone set it apart from many (most?) other languages.<p>Perl for example was made with love and with purpose, I don’t think it’s comparable.</div><br/><div id="41899881" class="c"><input type="checkbox" id="c-41899881" checked=""/><div class="controls bullet"><span class="by">sswatson</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899836">parent</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41899881">[-]</label><label class="expand" for="c-41899881">[5 more]</label></div><br/><div class="children"><div class="content">JS wasn’t created in 10 days. It was prototyped in 10 days, and the prototype contained very little of the stuff people complain about.<p>Hillel Wayne posted about this recently:<p><a href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;posts&#x2F;hillel-wayne_pet-peeve-people-who-mock-javascript-by-activity-7241815699436793856-kFJS?utm_source=share&amp;utm_medium=member_ios" rel="nofollow">https:&#x2F;&#x2F;www.linkedin.com&#x2F;posts&#x2F;hillel-wayne_pet-peeve-people...</a></div><br/><div id="41900000" class="c"><input type="checkbox" id="c-41900000" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41899881">parent</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41900000">[-]</label><label class="expand" for="c-41900000">[4 more]</label></div><br/><div class="children"><div class="content">Okay, I stand corrected. So this prototype didn’t ship, or did it ship and evolve?<p>Brendan Eich himself calls JS a “rush job” and with many warts though, having had to add aspects that in retrospect he wouldn’t have. This snippet from your link is consistent with that:<p><pre><code>    Also, most of JavaScript&#x27;s modern flaws do *not* come from the prototyping phase. The prototype didn&#x27;t have implicit type conversion (`&quot;1&quot; == 1`), which was added due to user feedback. And it didn&#x27;t have `null`, which was added to 1.0 for better Java Interop.

   Like many people, I find JS super frustrating to use.</code></pre></div><br/><div id="41900334" class="c"><input type="checkbox" id="c-41900334" checked=""/><div class="controls bullet"><span class="by">throwitaway1123</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41900000">parent</a><span>|</span><a href="#41900364">next</a><span>|</span><label class="collapse" for="c-41900334">[-]</label><label class="expand" for="c-41900334">[1 more]</label></div><br/><div class="children"><div class="content">This anecdote about the double equality operator might have originated from Eich&#x27;s chat with Lex Fridman where he states (at about 5 minutes and 26 seconds) that during the original 10 day sprint JavaScript didn&#x27;t support loose equality between numbers and strings: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=S0ZWtsYyX8E&amp;t=326s" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=S0ZWtsYyX8E&amp;t=326s</a><p>The type system was weakened <i>after</i> the 10 day prototyping phase when he was pressured by user feedback to allow implicit conversions for comparisons between numbers and serialized values from a database. So it wasn&#x27;t because he was rushing, it was because he caved to some early user feedback.</div><br/></div></div><div id="41900364" class="c"><input type="checkbox" id="c-41900364" checked=""/><div class="controls bullet"><span class="by">jauntywundrkind</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41900000">parent</a><span>|</span><a href="#41900334">prev</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41900364">[-]</label><label class="expand" for="c-41900364">[2 more]</label></div><br/><div class="children"><div class="content">The implicit type conversion is good for a very funny conference video (&quot;wat&quot;) but man, it&#x27;s just so overplayed as a weakness especially versus how much real world impact it has on anyone.<p>And with TypeScript or linting, many of the strange comparison&#x2F;conversion issues go away.<p>I struggle to find any substantial arguments against the js language, in spite of a lot of strong &amp; vocal disdainful attitudes against it.</div><br/><div id="41901086" class="c"><input type="checkbox" id="c-41901086" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898802">root</a><span>|</span><a href="#41900364">parent</a><span>|</span><a href="#41898801">next</a><span>|</span><label class="collapse" for="c-41901086">[-]</label><label class="expand" for="c-41901086">[1 more]</label></div><br/><div class="children"><div class="content">The implicit coercion and its weird behavior is absolutely a major footgun, not just fodder for the “wat” video. It’s something that can get you into serious trouble quite easily if left unchecked, for example by just looking at a list wrong. For someone to say that it has never caused them surprising pain in plain JavaScript is probably disingenuous. This is something that most other languages plainly don’t have as a problem, at least not as baffling.<p>Other things worth mentioning are the unusual scoping (by default at least), prototypes, “undefined”, and its role versus &quot;null&quot;... the list goes on.<p>I give TypeScript a lot of credit for cleaning up at least some of that mess, maybe more. But TypeScript is effectively another language on top of JS, not everyone in the ecosystem has the luxury of only dealing with it, and across all layers and components.<p>Is my knowledge about JavaScript outdated and obsolete? Certainly. Is the above stuff deprecated and turned off by default now? Probably. I left web development more than 10 years ago and never looked back. I’m a bit of a programming language geek, so I’ve used quite a few languages productively, and looked at many more. But not many serious programming languages have left quite the impression that JavaScript and PHP have.<p>In the meantime, I have always remembered that one conversation I had with someone who was an ECMAscript committee member at that time: They were working really hard to shape this language into something that makes sense and compiles well. Maybe against its will.<p>EDIT: Dear god, I completely forgot about JavaScript’s non-integerness, and its choice of using IEEE 754 as its basic Number type. Is that still a thing?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41898801" class="c"><input type="checkbox" id="c-41898801" checked=""/><div class="controls bullet"><span class="by">jongjong</span><span>|</span><a href="#41898802">prev</a><span>|</span><a href="#41901260">next</a><span>|</span><label class="collapse" for="c-41898801">[-]</label><label class="expand" for="c-41898801">[9 more]</label></div><br/><div class="children"><div class="content">I also love JavaScript.<p>It&#x27;s true, it has some really bad parts but you can avoid them.<p>If I could design the perfect language for myself, it would have the syntax of JavaScript and the portability of JavaScript but it would use Python&#x27;s strong duck typing approach.</div><br/><div id="41898846" class="c"><input type="checkbox" id="c-41898846" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898801">parent</a><span>|</span><a href="#41898893">next</a><span>|</span><label class="collapse" for="c-41898846">[-]</label><label class="expand" for="c-41898846">[6 more]</label></div><br/><div class="children"><div class="content">What have static type systems ever done to you, that you avoid them so much?</div><br/><div id="41899010" class="c"><input type="checkbox" id="c-41899010" checked=""/><div class="controls bullet"><span class="by">dbrueck</span><span>|</span><a href="#41898801">root</a><span>|</span><a href="#41898846">parent</a><span>|</span><a href="#41898943">next</a><span>|</span><label class="collapse" for="c-41899010">[-]</label><label class="expand" for="c-41899010">[1 more]</label></div><br/><div class="children"><div class="content">Not the OP, but the appeal of languages like JS has a lot to do with developer productivity. I write gobs of JS and Python code and the <i>finished</i> programs and libraries can be strongly and statically typed end-to-end. I just don&#x27;t want to be forced to do it in cases when it doesn&#x27;t really make a difference, and I don&#x27;t want to waste time on it when I&#x27;m still figuring out the design.<p>My hope is one of the Next Big Things in programming languages is the widespread adoption of incremental typing systems.<p>So during the early stages of dev you get the productivity benefits of dynamic and loose&#x2F;duck typing as much as you want, and then as the code matures - as the design firms up - you begin layering in the type information on different parts of the program (and hopefully the toolset gives you a jump start by suggesting a lot of this type info for you, or maybe you specify it only in places where the type info can&#x27;t be deduced).<p>Then those parts of the program (and hopefully eventually the entire program) are strongly and statically typed, and you get all of the associated goodies.</div><br/></div></div><div id="41898943" class="c"><input type="checkbox" id="c-41898943" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#41898801">root</a><span>|</span><a href="#41898846">parent</a><span>|</span><a href="#41899010">prev</a><span>|</span><a href="#41898893">next</a><span>|</span><label class="collapse" for="c-41898943">[-]</label><label class="expand" for="c-41898943">[4 more]</label></div><br/><div class="children"><div class="content">most static type systems are verbose, probably due to linguistic verbosity, so one obvious thing that static type systems have probably done to a lot of people is given them pain from typing so much.</div><br/><div id="41900973" class="c"><input type="checkbox" id="c-41900973" checked=""/><div class="controls bullet"><span class="by">ggregoire</span><span>|</span><a href="#41898801">root</a><span>|</span><a href="#41898943">parent</a><span>|</span><a href="#41898960">next</a><span>|</span><label class="collapse" for="c-41900973">[-]</label><label class="expand" for="c-41900973">[1 more]</label></div><br/><div class="children"><div class="content">Not sure what languages you are thinking to with &quot;most static type systems&quot;, but in languages like TypeScript or Rust (and I guess modern Java&#x2F;C#, haven&#x27;t touched those in a while), most of the types are inferred by the system such as you don&#x27;t need to write them. You type your functions arguments (and return values in Rust) and that&#x27;s about it.</div><br/></div></div><div id="41898960" class="c"><input type="checkbox" id="c-41898960" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898801">root</a><span>|</span><a href="#41898943">parent</a><span>|</span><a href="#41900973">prev</a><span>|</span><a href="#41898893">next</a><span>|</span><label class="collapse" for="c-41898960">[-]</label><label class="expand" for="c-41898960">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t feel it&#x27;s so much typing. Especially for the clarity and, most importantly, safety and correctness I get back. I&#x27;d rather type 3 1&#x2F;2 seconds more than debug a dumb type issue for half an hour.<p>It gets <i>really</i> old to get something like &quot;NoneType does not have blah&quot; in a deeply nested, complicated data structure in python, but obviously only at runtime and only in that hard to hit corner case, when all you did is forget to wrap something in the right number of square brackets in some other part of the code.<p>I haven&#x27;t fully given up on python, but I only deal with it using mypy, which adds static typing, anymore.</div><br/><div id="41899089" class="c"><input type="checkbox" id="c-41899089" checked=""/><div class="controls bullet"><span class="by">jwells89</span><span>|</span><a href="#41898801">root</a><span>|</span><a href="#41898960">parent</a><span>|</span><a href="#41898893">next</a><span>|</span><label class="collapse" for="c-41899089">[-]</label><label class="expand" for="c-41899089">[1 more]</label></div><br/><div class="children"><div class="content">A bit of extra verbosity as added by static typing can also be immensely helpful for trawling through and&#x2F;or learning an unfamiliar codebase, especially in the absence of an IDE or debugging environment (e.g. browsing code on GitHub or in a filemanager).<p>For instance, take function definitions. By just adding types to the function&#x27;s arguments, you&#x27;re potentially saving the reader a ton of time and mental overhead since they don&#x27;t have to chase down the right the chain of function calls to figure out what it is exactly (or is supposed to be) that&#x27;s getting passed in.</div><br/></div></div></div></div></div></div></div></div><div id="41898893" class="c"><input type="checkbox" id="c-41898893" checked=""/><div class="controls bullet"><span class="by">singpolyma3</span><span>|</span><a href="#41898801">parent</a><span>|</span><a href="#41898846">prev</a><span>|</span><a href="#41901260">next</a><span>|</span><label class="collapse" for="c-41898893">[-]</label><label class="expand" for="c-41898893">[2 more]</label></div><br/><div class="children"><div class="content">JavaScript isn&#x27;t really all that portable? Heck just making it run on the different JS engines and runtimes is a big pain sometimes</div><br/><div id="41899152" class="c"><input type="checkbox" id="c-41899152" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41898801">root</a><span>|</span><a href="#41898893">parent</a><span>|</span><a href="#41901260">next</a><span>|</span><label class="collapse" for="c-41899152">[-]</label><label class="expand" for="c-41899152">[1 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t even figure out how to write typescript that conditionally uses browser-only or node-only libraries depending on which environment it&#x27;s in. My current best guess is to write 2 completely independent typescript projects that happen to point to the same source files?<p>Let me cross-compile a C++ project any day ...</div><br/></div></div></div></div></div></div><div id="41901260" class="c"><input type="checkbox" id="c-41901260" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#41898801">prev</a><span>|</span><a href="#41898791">next</a><span>|</span><label class="collapse" for="c-41901260">[-]</label><label class="expand" for="c-41901260">[12 more]</label></div><br/><div class="children"><div class="content">This guy is not competent to talk about what he&#x27;s talking about.<p>&gt;&quot;JavaScript is, in my opinion, a working-class language. It’s very forgiving of types (this is one reason I’m not a huge TypeScript fan).&quot;<p>Being &quot;forgiving of types&quot; is not a good thing. There&#x27;s a reason most &quot;type-less&quot; languages have added type hints and the like (Python, Typescript, etc) and it&#x27;s because the job of a programming language is to make it easier for me to tell the CPU what to do. Not having types is detrimental to that.</div><br/><div id="41901822" class="c"><input type="checkbox" id="c-41901822" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#41901260">parent</a><span>|</span><a href="#41901279">next</a><span>|</span><label class="collapse" for="c-41901822">[-]</label><label class="expand" for="c-41901822">[1 more]</label></div><br/><div class="children"><div class="content">Python is not &quot;type-less&quot; it is strongly typed. It will raise a TypeError if you do something like 1 + &quot;1&quot;.</div><br/></div></div><div id="41901279" class="c"><input type="checkbox" id="c-41901279" checked=""/><div class="controls bullet"><span class="by">Doxin</span><span>|</span><a href="#41901260">parent</a><span>|</span><a href="#41901822">prev</a><span>|</span><a href="#41901921">next</a><span>|</span><label class="collapse" for="c-41901279">[-]</label><label class="expand" for="c-41901279">[3 more]</label></div><br/><div class="children"><div class="content">&gt; There&#x27;s a reason most &quot;type-less&quot; languages have added type hints and the like (Python, Typescript, etc)<p>I <i>would</i> like to clarify that even without typing python is a LOT less &quot;forgiving of types&quot; than javascript. It has none of the &quot;One plus object is NaN&quot; shenanigans you run into with javascript.</div><br/><div id="41901348" class="c"><input type="checkbox" id="c-41901348" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#41901260">root</a><span>|</span><a href="#41901279">parent</a><span>|</span><a href="#41901491">next</a><span>|</span><label class="collapse" for="c-41901348">[-]</label><label class="expand" for="c-41901348">[1 more]</label></div><br/><div class="children"><div class="content">Types are guidelines and strictly useful and a good thing. That said, one can wonder why languages like basic, python, scheme or php (dynamic, implicit types) have grown popular. Maybe for bad reasons but there IS an added value for implicit types. C++ (maybe even C !) has grown the auto keyword and other typed language have type inference. Which is not the same as &quot;typeless&quot; (it always is typed) but it defeats one of the &quot;double check&quot; security of types. And it&#x27;s sometimes not needed (yes, if I initialize it with &quot;abc&quot; it may be a string)</div><br/></div></div><div id="41901491" class="c"><input type="checkbox" id="c-41901491" checked=""/><div class="controls bullet"><span class="by">tugberkk</span><span>|</span><a href="#41901260">root</a><span>|</span><a href="#41901279">parent</a><span>|</span><a href="#41901348">prev</a><span>|</span><a href="#41901921">next</a><span>|</span><label class="collapse" for="c-41901491">[-]</label><label class="expand" for="c-41901491">[1 more]</label></div><br/><div class="children"><div class="content">sure. one is strongly typed and the other weakly typed.</div><br/></div></div></div></div><div id="41901921" class="c"><input type="checkbox" id="c-41901921" checked=""/><div class="controls bullet"><span class="by">gagaq</span><span>|</span><a href="#41901260">parent</a><span>|</span><a href="#41901279">prev</a><span>|</span><a href="#41901541">next</a><span>|</span><label class="collapse" for="c-41901921">[-]</label><label class="expand" for="c-41901921">[1 more]</label></div><br/><div class="children"><div class="content">Please, preferring dynamic typing is not a sign of &quot;incompetence&quot;. Stop this nonsense. Also, I won&#x27;t question your competence because you called Python and JavaScript &quot;type-less&quot;. The type-less languages (other than assembly) that were ever used were BCPL and B (predecessors of C).</div><br/></div></div><div id="41901541" class="c"><input type="checkbox" id="c-41901541" checked=""/><div class="controls bullet"><span class="by">camgunz</span><span>|</span><a href="#41901260">parent</a><span>|</span><a href="#41901921">prev</a><span>|</span><a href="#41901590">next</a><span>|</span><label class="collapse" for="c-41901541">[-]</label><label class="expand" for="c-41901541">[1 more]</label></div><br/><div class="children"><div class="content">There are plenty of good things written in languages with weaker type systems than TypeScript (Linux, your browser, HN). Using C&#x2F;C++ or a dynamic language doesn&#x27;t immediately make you incompetent.</div><br/></div></div><div id="41901424" class="c"><input type="checkbox" id="c-41901424" checked=""/><div class="controls bullet"><span class="by">thefroh</span><span>|</span><a href="#41901260">parent</a><span>|</span><a href="#41901590">prev</a><span>|</span><a href="#41902028">next</a><span>|</span><label class="collapse" for="c-41901424">[-]</label><label class="expand" for="c-41901424">[3 more]</label></div><br/><div class="children"><div class="content">while I&#x27;m a fan of TypeScript and using type hints in Python from an autocomplete and linting perspective, I am curious...<p>... has either language leveraged these to better tell the CPU what to do? presumably for perf.</div><br/><div id="41901441" class="c"><input type="checkbox" id="c-41901441" checked=""/><div class="controls bullet"><span class="by">yurishimo</span><span>|</span><a href="#41901260">root</a><span>|</span><a href="#41901424">parent</a><span>|</span><a href="#41901593">next</a><span>|</span><label class="collapse" for="c-41901441">[-]</label><label class="expand" for="c-41901441">[1 more]</label></div><br/><div class="children"><div class="content">PHP does but the types actually mean something. If your types can be stripped out to make the program run, I have a hard time believing that there is any optimization occurring there.</div><br/></div></div><div id="41901593" class="c"><input type="checkbox" id="c-41901593" checked=""/><div class="controls bullet"><span class="by">iforgotmysocks</span><span>|</span><a href="#41901260">root</a><span>|</span><a href="#41901424">parent</a><span>|</span><a href="#41901441">prev</a><span>|</span><a href="#41902028">next</a><span>|</span><label class="collapse" for="c-41901593">[-]</label><label class="expand" for="c-41901593">[1 more]</label></div><br/><div class="children"><div class="content">python ignores type hints</div><br/></div></div></div></div></div></div><div id="41898791" class="c"><input type="checkbox" id="c-41898791" checked=""/><div class="controls bullet"><span class="by">jpalawaga</span><span>|</span><a href="#41901260">prev</a><span>|</span><a href="#41898747">next</a><span>|</span><label class="collapse" for="c-41898791">[-]</label><label class="expand" for="c-41898791">[43 more]</label></div><br/><div class="children"><div class="content">Anyone who has done a programming contest, advent of code, etc knows that the language doesn’t matter so much as your algorithm.<p>Yes, the language can bring a nice speed up, or might give you better control of allocations which can save a lot of time. But in many cases, simply picking the correct algorithm will deliver you most of the performance.<p>As someone who doesn’t JavaScript a lot, I’d definitely prefer a tool written in go and available on brew over something I need to invoke node and its environment for.</div><br/><div id="41901158" class="c"><input type="checkbox" id="c-41901158" checked=""/><div class="controls bullet"><span class="by">xlii</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41898816">next</a><span>|</span><label class="collapse" for="c-41901158">[-]</label><label class="expand" for="c-41901158">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Anyone who has done a programming contest, advent of code, etc knows that the language doesn’t matter so much as your algorithm.<p>This is one of the biggest falsehoods in the software engineering I know.<p>Language is a collaboration glue and influences way of thinking guiding solution development. As an analogy: you can make a statue from a glass or from ice, but while both can be of the same shape and be equally awed upon, the process and qualities will differ.<p>For the prototypes and throwaways context doesn’t matter - That’s why all short lived contests, golfs and puzzles ignore it. Yet, when software is to be developed not over the week but over the decades and (hopefully) delivered to thousands if not millions of computers it’s the technological context (language, architecture, etc.) that matters the most.</div><br/></div></div><div id="41898816" class="c"><input type="checkbox" id="c-41898816" checked=""/><div class="controls bullet"><span class="by">tyree731</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41901158">prev</a><span>|</span><a href="#41899401">next</a><span>|</span><label class="collapse" for="c-41898816">[-]</label><label class="expand" for="c-41898816">[16 more]</label></div><br/><div class="children"><div class="content">Lots of very smart people have worked very hard on Python tools written in Python, yet the rust rewrites of those tools are so much faster. Sometimes it really is the programming language.</div><br/><div id="41898859" class="c"><input type="checkbox" id="c-41898859" checked=""/><div class="controls bullet"><span class="by">charrondev</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898816">parent</a><span>|</span><a href="#41898949">next</a><span>|</span><label class="collapse" for="c-41898859">[-]</label><label class="expand" for="c-41898859">[1 more]</label></div><br/><div class="children"><div class="content">In the JavaScript world a lot of speed up comes from 3 major things as far as I can tell:<p>- easier concurrency.
- the fact that things are actually getting rewritten with the purpose of speeding them up.
- a lot of the JS tooling getting speedups deals with heavily with string parsing, tokenizing, generating and manipulation of ASTs. Being able to have shared references to slices of strings, carefully manage when strings are copied, and have strict typing of the AST nodes you enable things to be much faster than JavaScript.</div><br/></div></div><div id="41898949" class="c"><input type="checkbox" id="c-41898949" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898816">parent</a><span>|</span><a href="#41898859">prev</a><span>|</span><a href="#41898913">next</a><span>|</span><label class="collapse" for="c-41898949">[-]</label><label class="expand" for="c-41898949">[4 more]</label></div><br/><div class="children"><div class="content">Python is really really slow compared to JS though.</div><br/><div id="41901003" class="c"><input type="checkbox" id="c-41901003" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898949">parent</a><span>|</span><a href="#41899014">next</a><span>|</span><label class="collapse" for="c-41901003">[-]</label><label class="expand" for="c-41901003">[1 more]</label></div><br/><div class="children"><div class="content">Node is so slow to start that python script can complete before Javascript even begins to execute.</div><br/></div></div><div id="41899014" class="c"><input type="checkbox" id="c-41899014" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898949">parent</a><span>|</span><a href="#41901003">prev</a><span>|</span><a href="#41899001">next</a><span>|</span><label class="collapse" for="c-41899014">[-]</label><label class="expand" for="c-41899014">[1 more]</label></div><br/><div class="children"><div class="content">I once worked on a Python system that had 50 machines dedicated to it. We were able to rewrite it in a more performant language such that it easily ran on one machine. This also allowed us to avoid all the issues distributed systems have.<p>So yeah, Python is not great for systems programming</div><br/></div></div><div id="41899001" class="c"><input type="checkbox" id="c-41899001" checked=""/><div class="controls bullet"><span class="by">gaganyaan</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898949">parent</a><span>|</span><a href="#41899014">prev</a><span>|</span><a href="#41898913">next</a><span>|</span><label class="collapse" for="c-41899001">[-]</label><label class="expand" for="c-41899001">[1 more]</label></div><br/><div class="children"><div class="content">CPython is (though it&#x27;s slowly getting better). Pypy is amazingly fast</div><br/></div></div></div></div><div id="41898913" class="c"><input type="checkbox" id="c-41898913" checked=""/><div class="controls bullet"><span class="by">jvanderbot</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898816">parent</a><span>|</span><a href="#41898949">prev</a><span>|</span><a href="#41898834">next</a><span>|</span><label class="collapse" for="c-41898913">[-]</label><label class="expand" for="c-41898913">[3 more]</label></div><br/><div class="children"><div class="content">This is a very nice counterexample, but it&#x27;s not actually a counter example without an example.<p>Also, this was a thing before Rust. I&#x27;ve rewritten several things in C or Cpp for python back ends, and most pytbon performance-critical code is already an API to a shared library. You&#x27;d be surprised to run OR tools and find Fortran libraries loaded by your python code.</div><br/><div id="41898995" class="c"><input type="checkbox" id="c-41898995" checked=""/><div class="controls bullet"><span class="by">runesoerensen</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898913">parent</a><span>|</span><a href="#41898834">next</a><span>|</span><label class="collapse" for="c-41898995">[-]</label><label class="expand" for="c-41898995">[2 more]</label></div><br/><div class="children"><div class="content">Ruff is one example <a href="https:&#x2F;&#x2F;astral.sh&#x2F;ruff" rel="nofollow">https:&#x2F;&#x2F;astral.sh&#x2F;ruff</a></div><br/><div id="41902025" class="c"><input type="checkbox" id="c-41902025" checked=""/><div class="controls bullet"><span class="by">aragilar</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898995">parent</a><span>|</span><a href="#41898834">next</a><span>|</span><label class="collapse" for="c-41902025">[-]</label><label class="expand" for="c-41902025">[1 more]</label></div><br/><div class="children"><div class="content">But can I write plugins for it? My understanding it is only implements a subset of the common plugins (and does not do any of the linting that pylint is useful for), so it avoids scanning the filesystem for plugins?</div><br/></div></div></div></div></div></div><div id="41898834" class="c"><input type="checkbox" id="c-41898834" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898816">parent</a><span>|</span><a href="#41898913">prev</a><span>|</span><a href="#41899003">next</a><span>|</span><label class="collapse" for="c-41898834">[-]</label><label class="expand" for="c-41898834">[2 more]</label></div><br/><div class="children"><div class="content">Choosing the right algorithm effectively means optimizing runtime complexity. Then, once runtime complexity is fixed with the right algorithm, you&#x27;re still left with a lot of constant factors that O-notation deliberately ignores (it&#x27;s only about growth of the runtime). Sometimes, optimizing those constant factors can be significant, and then the choice of language matters. And even some details about the CPU you are targeting, and overall system architecture.</div><br/><div id="41898920" class="c"><input type="checkbox" id="c-41898920" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898834">parent</a><span>|</span><a href="#41899003">next</a><span>|</span><label class="collapse" for="c-41898920">[-]</label><label class="expand" for="c-41898920">[1 more]</label></div><br/><div class="children"><div class="content">Often languages like Javascript and Python don&#x27;t <i>allow</i> optimal runtime complexity, because the types baked in to external interfaces fundamentally disallow the desired operation. And these languages are too slow to rewrite the core logic in the language itself.<p>(but of course, the vast majority of the code, even in widely used tools, isn&#x27;t properly designed for optimization in the first place)<p>I only dabble in javascript, but `tsc` is abominable.</div><br/></div></div></div></div><div id="41899003" class="c"><input type="checkbox" id="c-41899003" checked=""/><div class="controls bullet"><span class="by">worik</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898816">parent</a><span>|</span><a href="#41898834">prev</a><span>|</span><a href="#41899226">next</a><span>|</span><label class="collapse" for="c-41899003">[-]</label><label class="expand" for="c-41899003">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Lots of very smart people have worked very hard on Python tools written in Python<p>Yes, I agree that is very sad<p>Python is achingly slow.  I know the Python people want to address this, I do not understand.  Python makes  sense as a scripting&#x2F;job control language, and execution speed does not matter.<p>As an application development language it is diabolical.  For a lot of reasons, not just speed</div><br/></div></div><div id="41899226" class="c"><input type="checkbox" id="c-41899226" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898816">parent</a><span>|</span><a href="#41899003">prev</a><span>|</span><a href="#41899401">next</a><span>|</span><label class="collapse" for="c-41899226">[-]</label><label class="expand" for="c-41899226">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Lots of very smart people have worked very hard on Python tools written in Python, yet the rust rewrites of those tools are so much faster.<p>So?<p>Some tool got written and did its job sufficiently well that it became a bottleneck worth optimizing.<p>That&#x27;s a <i>win</i>.<p>&quot;Finishing the task&quot; is, <i>by far</i>, the most difficult thing in programming.  And the two biggest contributors to that are 1) simplicity of programming language and 2) convenience of ecosystem.<p>Python and Javascript are so popular because they tick both boxes.</div><br/><div id="41899545" class="c"><input type="checkbox" id="c-41899545" checked=""/><div class="controls bullet"><span class="by">tyree731</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899226">parent</a><span>|</span><a href="#41899401">next</a><span>|</span><label class="collapse" for="c-41899545">[-]</label><label class="expand" for="c-41899545">[3 more]</label></div><br/><div class="children"><div class="content">Don’t disagree about finishing the task, but personally I don’t find more performant languages any less productive for the sort of programming I tend to do.</div><br/><div id="41899723" class="c"><input type="checkbox" id="c-41899723" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899545">parent</a><span>|</span><a href="#41899401">next</a><span>|</span><label class="collapse" for="c-41899723">[-]</label><label class="expand" for="c-41899723">[2 more]</label></div><br/><div class="children"><div class="content">Congratulations on being a programming god.  This discussion isn&#x27;t for you.<p>From my point of view, I&#x27;m happy if I can convince my juniors to <i>learn a scripting language</i>.  Okay?  I don&#x27;t care which one--<i>any</i> one.  I&#x27;d prefer that they learn one of the portable ones but even PowerShell is <i>fine</i>.<p>I have seen <i>sooooo</i> many junior folks struggle for days to do something that is 10 lines in <i>any</i> scripting language.<p>Those folks who program but don&#x27;t know a scripting language far outnumber the rest of us.</div><br/><div id="41901234" class="c"><input type="checkbox" id="c-41901234" checked=""/><div class="controls bullet"><span class="by">fredrikholm</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899723">parent</a><span>|</span><a href="#41899401">next</a><span>|</span><label class="collapse" for="c-41901234">[-]</label><label class="expand" for="c-41901234">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I have seen sooooo many junior folks struggle for days to do something that is 10 lines in any scripting language.<p>&gt; Those folks who program but don&#x27;t know a scripting language far outnumber the rest of us.<p>What domain are you in? This sounds like the complete inverse of every company I&#x27;ve ever worked at.<p>Entire products are built on Python, Node ect, and the time after the initial honeymoon phase (if it exists) is spent retrofitting types on top in order to get a handle, any handle, on the complexity that arises without static analysis and compile time errors.<p>At around the same time, services start OOM&#x27;ming left and right, parallellism=1 becomes a giant bottleneck, JIT fails in one path bringing the service performance down an order of magnitude every now and then etc...<p>&gt; Congratulations on being a programming god. This discussion isn&#x27;t for you.<p>On the behalf of mediocre developers everywhere, a lot of us prefer statically typed languages <i>because</i> we are mediocre; I cannot hold thousands of implicit types and heuristics in my head at the same time. Luckily, the type system can.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41899401" class="c"><input type="checkbox" id="c-41899401" checked=""/><div class="controls bullet"><span class="by">Ferret7446</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41898816">prev</a><span>|</span><a href="#41901185">next</a><span>|</span><label class="collapse" for="c-41899401">[-]</label><label class="expand" for="c-41899401">[1 more]</label></div><br/><div class="children"><div class="content">Quite the opposite, for most cases you don&#x27;t hit the scale where asymptotic algorithmic performance really makes a big impact (e.g., for many small set comparisons, iterating over a list is faster than a hash set, but only by 10-50% or so), vs switching to a compiled language which instantly gets you 10x to 100x performance basically for free.<p>Or perhaps another way to look at it, if you care enough about performance to choose a particular algorithm, you shouldn&#x27;t be using a slow language in the first place unless you&#x27;re forced to due to functional requirements.</div><br/></div></div><div id="41901185" class="c"><input type="checkbox" id="c-41901185" checked=""/><div class="controls bullet"><span class="by">eviks</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41899401">prev</a><span>|</span><a href="#41898952">next</a><span>|</span><label class="collapse" for="c-41901185">[-]</label><label class="expand" for="c-41901185">[1 more]</label></div><br/><div class="children"><div class="content">And  anyone who expands the horizon to the real world, instead of focusing on the artificial one of contests, knows that the language matters a great deal</div><br/></div></div><div id="41898952" class="c"><input type="checkbox" id="c-41898952" checked=""/><div class="controls bullet"><span class="by">hawski</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41901185">prev</a><span>|</span><a href="#41899000">next</a><span>|</span><label class="collapse" for="c-41898952">[-]</label><label class="expand" for="c-41898952">[1 more]</label></div><br/><div class="children"><div class="content">In higher level languages your code may allocate memory or trigger a GC pass or other smartness in unexpected places. This may cause slowdowns you may not have control over or may change from version to version or vendor to vendor. It is often easier to manage in &quot;faster&quot; languages. Good algorithm may not be enough.</div><br/></div></div><div id="41899000" class="c"><input type="checkbox" id="c-41899000" checked=""/><div class="controls bullet"><span class="by">zeroonetwothree</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41898952">prev</a><span>|</span><a href="#41901525">next</a><span>|</span><label class="collapse" for="c-41899000">[-]</label><label class="expand" for="c-41899000">[1 more]</label></div><br/><div class="children"><div class="content">The types of problems in those contests are meant to highlight algorithms. In the real world you might have a trivial algorithm but a huge input size, where the constant factor matters much more.</div><br/></div></div><div id="41901525" class="c"><input type="checkbox" id="c-41901525" checked=""/><div class="controls bullet"><span class="by">CrimsonRain</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41899000">prev</a><span>|</span><a href="#41899028">next</a><span>|</span><label class="collapse" for="c-41901525">[-]</label><label class="expand" for="c-41901525">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s why almost every thing important in python is in C</div><br/></div></div><div id="41899028" class="c"><input type="checkbox" id="c-41899028" checked=""/><div class="controls bullet"><span class="by">moomin</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41901525">prev</a><span>|</span><a href="#41898890">next</a><span>|</span><label class="collapse" for="c-41899028">[-]</label><label class="expand" for="c-41899028">[1 more]</label></div><br/><div class="children"><div class="content">Here’s the thing: languages like C#, Java and Rust all have extensive libraries and packages that implement many common data structures and algorithms well. With all due respect to the incredible work that goes into projects like lodash, JavaScript does not. (Nor does C, for that matter.)</div><br/></div></div><div id="41898890" class="c"><input type="checkbox" id="c-41898890" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41899028">prev</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41898890">[-]</label><label class="expand" for="c-41898890">[9 more]</label></div><br/><div class="children"><div class="content">&gt; knows that the language doesn’t matter so much as your algorithm.<p>I know what you’re referring to but these problems have also taught me a lot about language performance. python and JS array access is just 100x slower than C. Some difficult problems become much harder due to this limitation.</div><br/><div id="41898967" class="c"><input type="checkbox" id="c-41898967" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898890">parent</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41898967">[-]</label><label class="expand" for="c-41898967">[8 more]</label></div><br/><div class="children"><div class="content">JS array access is a lot faster than Python array access. JS is easily within magnitude of C and can be even about as fast with typed arrays or well JITable code.</div><br/><div id="41899140" class="c"><input type="checkbox" id="c-41899140" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898967">parent</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41899140">[-]</label><label class="expand" for="c-41899140">[7 more]</label></div><br/><div class="children"><div class="content">&gt; JS is easily within magnitude of C<p>Typed arrays help a lot, but I’m still doubtful. Maybe it all the processing is restrict to idioms in the asm.js subset? And even then you’re getting bounds checking.</div><br/><div id="41899241" class="c"><input type="checkbox" id="c-41899241" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899140">parent</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41899241">[-]</label><label class="expand" for="c-41899241">[6 more]</label></div><br/><div class="children"><div class="content">In benchmarks JS is usually well within magnitude (i.e. under 10x slower).<p>E.g. C++ vs Node.js here: <a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;q6600&#x2F;fastest&#x2F;node-gpp.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a><p>Couldn&#x27;t find C vs JS easily with the new benchmarksgame UI.</div><br/><div id="41899458" class="c"><input type="checkbox" id="c-41899458" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899241">parent</a><span>|</span><a href="#41899295">next</a><span>|</span><label class="collapse" for="c-41899458">[-]</label><label class="expand" for="c-41899458">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Couldn&#x27;t find C vs JS easily<p>Try:<p>A) Find JS in the box plot charts<p><a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;box-plot-summary-charts.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a><p>or<p>B) Find JS in the detail<p><a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;performance&#x2F;fannkuchredux.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a></div><br/></div></div><div id="41899295" class="c"><input type="checkbox" id="c-41899295" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899241">parent</a><span>|</span><a href="#41899458">prev</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41899295">[-]</label><label class="expand" for="c-41899295">[4 more]</label></div><br/><div class="children"><div class="content">I guess so. I clicked on the code for the first one. It’s using a C library to do the computation:<p>&gt; mpzjs. This library wraps around libgmp&#x27;s integer functions to perform infinite-precision arithmetic<p>And then the “array”:<p>&gt; Buffer.allocUnsafe<p>So is this a good JavaScript benchmark?</div><br/><div id="41899418" class="c"><input type="checkbox" id="c-41899418" checked=""/><div class="controls bullet"><span class="by">jampekka</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899295">parent</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41899418">[-]</label><label class="expand" for="c-41899418">[3 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the only benchmark on the page that uses such wrapper.<p>Buffer.allocUnsafe just allocates the memory without zero-initializing it, just like e.g. malloc does. Probably usually not worth it, but in a benchmark it&#x27;s comparable to malloc vs calloc.</div><br/><div id="41899464" class="c"><input type="checkbox" id="c-41899464" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899418">parent</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41899464">[-]</label><label class="expand" for="c-41899464">[2 more]</label></div><br/><div class="children"><div class="content">Yeah and using byte buffers isn’t JavaScript array access. But it is for C.<p>The n-body looks most like canonical JS to me. It’s a small array, but’s it’s accessed many times.<p>Unfortunately the c++ version is simd optimized, so I don’t think that’s a fair comparison.</div><br/><div id="41899515" class="c"><input type="checkbox" id="c-41899515" checked=""/><div class="controls bullet"><span class="by">igouy</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41899464">parent</a><span>|</span><a href="#41898879">next</a><span>|</span><label class="collapse" for="c-41899515">[-]</label><label class="expand" for="c-41899515">[1 more]</label></div><br/><div class="children"><div class="content">There are plain C++ programs: n-body C++ g++ #3<p><a href="https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;performance&#x2F;nbody.html" rel="nofollow">https:&#x2F;&#x2F;benchmarksgame-team.pages.debian.net&#x2F;benchmarksgame&#x2F;...</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41898879" class="c"><input type="checkbox" id="c-41898879" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41898791">parent</a><span>|</span><a href="#41898890">prev</a><span>|</span><a href="#41902030">next</a><span>|</span><label class="collapse" for="c-41898879">[-]</label><label class="expand" for="c-41898879">[9 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not just a matter of “picking the correct algorithm”. Algorithmic-interview exercises are algorithmic-interview exercices. They are barely related to real-world software engineering.</div><br/><div id="41898946" class="c"><input type="checkbox" id="c-41898946" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898879">parent</a><span>|</span><a href="#41898892">next</a><span>|</span><label class="collapse" for="c-41898946">[-]</label><label class="expand" for="c-41898946">[3 more]</label></div><br/><div class="children"><div class="content">While picking the right algorithm seldom comes up in most programmers day-to-day activities, being aware of big-Oh and the performance guarantees&#x2F;characteristics of the libraries you use most certainly <i>should</i>.<p>I don&#x27;t care if you don&#x27;t know how to write a merge sort from scratch. I do care about you knowing not to write an O(n^2) loop when it can be avoided.</div><br/><div id="41901165" class="c"><input type="checkbox" id="c-41901165" checked=""/><div class="controls bullet"><span class="by">lucumo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898946">parent</a><span>|</span><a href="#41898892">next</a><span>|</span><label class="collapse" for="c-41901165">[-]</label><label class="expand" for="c-41901165">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t.<p>Let me rephrase that.<p>I do, but only in very, very rare circumstances. Basically only when you a) know that the typical use case is going to involve large ns, like millions to billions, b) the loop body takes a long time per invocation, or c) have profiled a performance issue and found that improving it would help.<p>If you&#x27;re working with sets of 10 items, just write the damn nested loop and move on. Code jockeying is unlikely to be faster, and even if it is, it doesn&#x27;t help enough to matter anyway.<p>Computer science theory likes to ignore constants. Big-O notation does that explicitly. But in the real world, it&#x27;s usually the constants that kill you. Constants, and time to market.</div><br/><div id="41901249" class="c"><input type="checkbox" id="c-41901249" checked=""/><div class="controls bullet"><span class="by">magicalhippo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41901165">parent</a><span>|</span><a href="#41898892">next</a><span>|</span><label class="collapse" for="c-41901249">[-]</label><label class="expand" for="c-41901249">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re working with sets of 10 items<p>If you are working with a hardcoded 10 items, and you are <i>certain</i> that won&#x27;t change significantly, sure.<p>If not I strongly disagree, because I&#x27;ve seen way too often such cases blow up due to circumstances changing.<p>Now, if it is very difficult to avoid a nested loop then we can discuss.<p>But it can simply be due to being unaware that some indexed library call is in fact O(n) or something like that, and avoiding it by using a dictionary or some other approach is not hard.<p>While constants matter to some degree, the point of big-O is that they don&#x27;t so much if you get handed two orders of magnitude more data than you expected.<p>I&#x27;ll gladly sacrifice a tiny bit of performance for code that doesn&#x27;t suddenly result in the user not being able to use the application.</div><br/></div></div></div></div></div></div><div id="41898892" class="c"><input type="checkbox" id="c-41898892" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898879">parent</a><span>|</span><a href="#41898946">prev</a><span>|</span><a href="#41898965">next</a><span>|</span><label class="collapse" for="c-41898892">[-]</label><label class="expand" for="c-41898892">[3 more]</label></div><br/><div class="children"><div class="content">Choosing the right algorithm is usually the prerequisite for fast code. Optimizing the constant factors is often pretty useless if you pick an algorithm with a runtime that grows quadratically, when there are much better options available.</div><br/><div id="41898918" class="c"><input type="checkbox" id="c-41898918" checked=""/><div class="controls bullet"><span class="by">noname120</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898892">parent</a><span>|</span><a href="#41898965">next</a><span>|</span><label class="collapse" for="c-41898918">[-]</label><label class="expand" for="c-41898918">[2 more]</label></div><br/><div class="children"><div class="content">What makes you think that the sluggishness of these tools is in any way related to not “choosing the right algorithm”?</div><br/><div id="41898933" class="c"><input type="checkbox" id="c-41898933" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898918">parent</a><span>|</span><a href="#41898965">next</a><span>|</span><label class="collapse" for="c-41898933">[-]</label><label class="expand" for="c-41898933">[1 more]</label></div><br/><div class="children"><div class="content">What makes you think they&#x27;re not? I don&#x27;t know why these tools are sluggish, but I disagree with the notion that algorithms don&#x27;t matter for &quot;real-world software engineering&quot;.<p>The world is full of slow software because one chose the wrong algorithm:
<a href="https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2019&#x2F;04&#x2F;21&#x2F;on2-in-createprocess&#x2F;" rel="nofollow">https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2019&#x2F;04&#x2F;21&#x2F;on2-in-createpr...</a>
<a href="https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2019&#x2F;12&#x2F;08&#x2F;on2-again-now-in-wmi&#x2F;" rel="nofollow">https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2019&#x2F;12&#x2F;08&#x2F;on2-again-now-i...</a>
<a href="https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2021&#x2F;02&#x2F;16&#x2F;arranging-invisible-icons-in-quadratic-time&#x2F;" rel="nofollow">https:&#x2F;&#x2F;randomascii.wordpress.com&#x2F;2021&#x2F;02&#x2F;16&#x2F;arranging-invis...</a> ...</div><br/></div></div></div></div></div></div><div id="41898965" class="c"><input type="checkbox" id="c-41898965" checked=""/><div class="controls bullet"><span class="by">tightbookkeeper</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898879">parent</a><span>|</span><a href="#41898892">prev</a><span>|</span><a href="#41902030">next</a><span>|</span><label class="collapse" for="c-41898965">[-]</label><label class="expand" for="c-41898965">[2 more]</label></div><br/><div class="children"><div class="content">Exactly. What do you do when you have the right algorithm and it’s too slow (very typical for linear problems that require visiting each item).</div><br/><div id="41899023" class="c"><input type="checkbox" id="c-41899023" checked=""/><div class="controls bullet"><span class="by">anyfoo</span><span>|</span><a href="#41898791">root</a><span>|</span><a href="#41898965">parent</a><span>|</span><a href="#41902030">next</a><span>|</span><label class="collapse" for="c-41899023">[-]</label><label class="expand" for="c-41899023">[1 more]</label></div><br/><div class="children"><div class="content">You optimize the constant factors, e.g. the runtime of the inner loops. But this requires you to choose a sane algorithm in the first place.<p>Some problems are much more complicated, where you have to take, for example, locality (cache hierarchy etc.) and concurrency considerations like lock contention into account. This may affect your choice of algorithm, but by the time you reach that, you&#x27;ve almost certainly thought about the algorithm a lock already.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>