<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709283672982" as="style"/><link rel="stylesheet" href="styles.css?v=1709283672982"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://gaultier.github.io/blog/you_inherited_a_legacy_cpp_codebase_now_what.html">You&#x27;ve just inherited a legacy C++ codebase, now what?</a> <span class="domain">(<a href="https://gaultier.github.io">gaultier.github.io</a>)</span></div><div class="subtext"><span>broken_broken_</span> | <span>179 comments</span></div><br/><div><div id="39554834" class="c"><input type="checkbox" id="c-39554834" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#39551578">next</a><span>|</span><label class="collapse" for="c-39554834">[-]</label><label class="expand" for="c-39554834">[47 more]</label></div><br/><div class="children"><div class="content">Some good advice here, and some more...controversial advice here.<p>After inheriting quite a few giant C++ projects over the years, there are a few obvious big wins to start with:<p>* Reproducible builds. The sanity you save will be your own. Pro-tip: wrap your build environment with docker (or your favorite packager) so that your tooling and dependencies become both explicit and reproducable. The sanity you save will be your own.<p>* Get the code to build clean with -Wall. This is for a couple of reasons. a) You&#x27;ll turn up some amount of bad code&#x2F;undefined behavior&#x2F;bugs this way. Fix them and make the warning go away. It&#x27;s ok to #pragma away some warnings once you&#x27;ve determined you understand what&#x27;s happening and it&#x27;s &quot;ok&quot; in your situation. But that should be rare. b) Once the build is clean, you&#x27;ll get obvious warnings when YOU do something sketchy and you can fix that shit immediately. Again, the sanity you save will be your own.<p>* Do some early testing with something like valgrind and investigate any read&#x2F;write errors it turns up. This is an easy win from a bugfix&#x2F;stability point of view.<p>* At least initially, keep refactorings localized. If you work on a section and learn what it&#x27;s doing, it&#x27;s fine to clean it up and make it better, but rearchitecting the world before you have a good grasp on what&#x27;s going on globally is just asking for pain and agony.</div><br/><div id="39555280" class="c"><input type="checkbox" id="c-39555280" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39554834">parent</a><span>|</span><a href="#39555623">next</a><span>|</span><label class="collapse" for="c-39555280">[-]</label><label class="expand" for="c-39555280">[23 more]</label></div><br/><div class="children"><div class="content">Step 0: reproducible builds (like you said)<p>Step 1: run all tests, mark all the flaky ones.<p>Step 2: run all tests under sanitizers, mark all the ones that fail.<p>Step 3: fix all the sanitizer failures.<p>Step 4: (the other stuff you wrote)</div><br/><div id="39555983" class="c"><input type="checkbox" id="c-39555983" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555280">parent</a><span>|</span><a href="#39555398">next</a><span>|</span><label class="collapse" for="c-39555983">[-]</label><label class="expand" for="c-39555983">[13 more]</label></div><br/><div class="children"><div class="content">If we&#x27;re going to visit the circles of hell, let&#x27;s do it properly:<p>Step -1: Get it under source control and backed up.<p>Step -2: Find out if the source code corresponds to the executable.  Which of the 7 variants of the source code (if any).<p>Step -3: Do dark rituals over a weekend  with cdparanioa to scrape the source code from the bunch of scratched cd&#x27;s found in someone&#x27;s bottom drawer.  Bonus point if said person died last week, and other eldritch horrors lurk in that bottom drawer.  Build a VM clone of the one machine still capable of compiling it.<p>Yes, I have scars, why do you ask?</div><br/><div id="39558220" class="c"><input type="checkbox" id="c-39558220" checked=""/><div class="controls bullet"><span class="by">skissane</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39556342">next</a><span>|</span><label class="collapse" for="c-39558220">[-]</label><label class="expand" for="c-39558220">[1 more]</label></div><br/><div class="children"><div class="content">Question: Why does some of the product source code look like it is the output of a decompiler?<p>Answer: Our office was in the WTC and was destroyed on 9&#x2F;11. Luckily everyone got out alive, but then we discovered we had no off-site backups of the source code. In order to continue development, we had to retrieve the released binaries from our customers and decompile them to get back source code.</div><br/></div></div><div id="39556342" class="c"><input type="checkbox" id="c-39556342" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39558220">prev</a><span>|</span><a href="#39558047">next</a><span>|</span><label class="collapse" for="c-39556342">[-]</label><label class="expand" for="c-39556342">[2 more]</label></div><br/><div class="children"><div class="content">There was that time when I had to dump the roms off a &#x27;test&#x27; MRI machine because that&#x27;s the only version of the code they had, then decompiled it, and rewrite it from that.<p>I think about that a lot now that I&#x27;m older and spend a fair bit of time in MRI machines...</div><br/><div id="39557429" class="c"><input type="checkbox" id="c-39557429" checked=""/><div class="controls bullet"><span class="by">reactordev</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39556342">parent</a><span>|</span><a href="#39558047">next</a><span>|</span><label class="collapse" for="c-39557429">[-]</label><label class="expand" for="c-39557429">[1 more]</label></div><br/><div class="children"><div class="content">Dang man that’s tough, at least you know they work ;)</div><br/></div></div></div></div><div id="39558047" class="c"><input type="checkbox" id="c-39558047" checked=""/><div class="controls bullet"><span class="by">skipkey</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39556342">prev</a><span>|</span><a href="#39556090">next</a><span>|</span><label class="collapse" for="c-39558047">[-]</label><label class="expand" for="c-39558047">[1 more]</label></div><br/><div class="children"><div class="content">Everyone who has been around this game for long enough has scars.  At one point in the early 90s I was asked to take over maintenance of a vertical market accounting app that had a few hundred users.  It had been written using Lattice C, but at the time was being built with the ultra modern MS C 5.1.<p>The first time I looked at it, I saw that the make file set the warning level to 0 and redirected the output to NUL.  Removing that, I ran nmake and prayed.  About 45 minutes later it finished building, evidently successfully.  It turned out that having the warnings actually print added 10 minutes to the build.<p>It was averaging more than one error per line of code at &#x2F;w3. And it was around 40k lines of code.  Not large by the standards of today but huge back then for MSDOS.  Peeking, it used K&amp;R c and included no header files.  So step 1 for me was to hook up some scaffolding using various tools from mks to make sure as I edited things that the error count didn’t increase.<p>The biggest thing I learned from this project was to not combine other coding with the warning removal or other cleanup.  Makes it much easier to spot when you introduce bugs.</div><br/></div></div><div id="39556090" class="c"><input type="checkbox" id="c-39556090" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39558047">prev</a><span>|</span><a href="#39558465">next</a><span>|</span><label class="collapse" for="c-39556090">[-]</label><label class="expand" for="c-39556090">[4 more]</label></div><br/><div class="children"><div class="content">I was assuming it already had unit and system tests with decent coverage. I forgot how bad stuff gets.<p>Maybe VM clones of various users too, and recordings of their work flows?</div><br/><div id="39556471" class="c"><input type="checkbox" id="c-39556471" checked=""/><div class="controls bullet"><span class="by">Cerium</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39556090">parent</a><span>|</span><a href="#39558465">next</a><span>|</span><label class="collapse" for="c-39556471">[-]</label><label class="expand" for="c-39556471">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m always careful to dump the bash history as soon as I get access to a machine involved in a legacy project.</div><br/><div id="39559955" class="c"><input type="checkbox" id="c-39559955" checked=""/><div class="controls bullet"><span class="by">cqqxo4zV46cp</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39556471">parent</a><span>|</span><a href="#39556920">next</a><span>|</span><label class="collapse" for="c-39559955">[-]</label><label class="expand" for="c-39559955">[1 more]</label></div><br/><div class="children"><div class="content">Yep! Learned this one the easy way! I don’t get to say that often, so I’m taking full advantage.</div><br/></div></div><div id="39556920" class="c"><input type="checkbox" id="c-39556920" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39556471">parent</a><span>|</span><a href="#39559955">prev</a><span>|</span><a href="#39558465">next</a><span>|</span><label class="collapse" for="c-39556920">[-]</label><label class="expand" for="c-39556920">[1 more]</label></div><br/><div class="children"><div class="content">Oooh, smart!</div><br/></div></div></div></div></div></div><div id="39558465" class="c"><input type="checkbox" id="c-39558465" checked=""/><div class="controls bullet"><span class="by">thrwwycbr</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39556090">prev</a><span>|</span><a href="#39556763">next</a><span>|</span><label class="collapse" for="c-39558465">[-]</label><label class="expand" for="c-39558465">[2 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t it be step -3 to -1?</div><br/><div id="39559242" class="c"><input type="checkbox" id="c-39559242" checked=""/><div class="controls bullet"><span class="by">hyperman1</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39558465">parent</a><span>|</span><a href="#39556763">next</a><span>|</span><label class="collapse" for="c-39559242">[-]</label><label class="expand" for="c-39559242">[1 more]</label></div><br/><div class="children"><div class="content">Of course not.  You try to do 0 but that&#x27;s impossible because you need to do -1 first.  So you drop everything, try to do -1 but that&#x27;s ...  It&#x27;s yak shaving&#x27;s evil twin!</div><br/></div></div></div></div><div id="39556763" class="c"><input type="checkbox" id="c-39556763" checked=""/><div class="controls bullet"><span class="by">denkmoon</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39558465">prev</a><span>|</span><a href="#39558303">next</a><span>|</span><label class="collapse" for="c-39556763">[-]</label><label class="expand" for="c-39556763">[1 more]</label></div><br/><div class="children"><div class="content">This gave me a good laugh. I too have been here.</div><br/></div></div><div id="39558303" class="c"><input type="checkbox" id="c-39558303" checked=""/><div class="controls bullet"><span class="by">ta2234234242</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555983">parent</a><span>|</span><a href="#39556763">prev</a><span>|</span><a href="#39555398">next</a><span>|</span><label class="collapse" for="c-39558303">[-]</label><label class="expand" for="c-39558303">[1 more]</label></div><br/><div class="children"><div class="content">Some people believe that if you read the C++ standard recreationally, it should be interpreted as a call for help, and intervention is required, putting the subject under 24&#x2F;7 monitoring and physical restraints.<p>&#x2F;s<p>Step -4:  Get the version of windows and the compiler it was last known to compile with.</div><br/></div></div></div></div><div id="39555398" class="c"><input type="checkbox" id="c-39555398" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555280">parent</a><span>|</span><a href="#39555983">prev</a><span>|</span><a href="#39557546">next</a><span>|</span><label class="collapse" for="c-39555398">[-]</label><label class="expand" for="c-39555398">[2 more]</label></div><br/><div class="children"><div class="content">Just a note on legacy tests: Step 0.5: understand the tests. They need to be examined to see if they&#x27;ve rotted or not. Tests passing&#x2F;failing doesn&#x27;t really mean code under test works or not. The tests might have been abandoned under previous management and don&#x27;t accurately reflect how the code is _supposed_ to be working.</div><br/><div id="39556747" class="c"><input type="checkbox" id="c-39556747" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555398">parent</a><span>|</span><a href="#39557546">next</a><span>|</span><label class="collapse" for="c-39556747">[-]</label><label class="expand" for="c-39556747">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d put that under 2.5 or 3.5, if not later. You only really need to do it before you start modifying code, and it&#x27;s a massive effort to understand a new codebase. Better pick the lower-hanging fruit (like corruption bugs) so you can at least stay sane when you run the tests and try to understand them.</div><br/></div></div></div></div><div id="39557546" class="c"><input type="checkbox" id="c-39557546" checked=""/><div class="controls bullet"><span class="by">groby_b</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555280">parent</a><span>|</span><a href="#39555398">prev</a><span>|</span><a href="#39555846">next</a><span>|</span><label class="collapse" for="c-39557546">[-]</label><label class="expand" for="c-39557546">[6 more]</label></div><br/><div class="children"><div class="content">Step 0 sounds so easy. Until you realize __time__ exists. Then you take that away, and you find out that some compiler heuristics might not be deterministic.<p>Then you discover -frandom-seed - and go ballistic when you read &quot;but it should be a different seed for each sourcefile&quot;<p>Then you figure out your linker likes emitting a timestamp in object files. Then you discover &#x2F;Brepro (if you&#x27;re lucky enough to use lld-link.<p>Then you used to discover that Win7&#x27;s app compat db expected a &quot;real&quot; timestamp, and a hash just won&#x27;t do. (Thank God, that&#x27;s dead now). This is usually the part where you start questioning your life choices.<p>Then somebody comes to your desk and asks if you can also make partial rebuilds deterministic.<p>On the upside, step 1 is usually quick, there will be no tests.</div><br/><div id="39557941" class="c"><input type="checkbox" id="c-39557941" checked=""/><div class="controls bullet"><span class="by">nightpool</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557546">parent</a><span>|</span><a href="#39557688">next</a><span>|</span><label class="collapse" for="c-39557941">[-]</label><label class="expand" for="c-39557941">[1 more]</label></div><br/><div class="children"><div class="content">yeah I don&#x27;t think OP is talking about byte perfect determinism, they just want CI not to explode. that&#x27;s the triage goal, byte perfect determinism is not your first priority when stopping the bleeding on a legacy c++ project</div><br/></div></div><div id="39557688" class="c"><input type="checkbox" id="c-39557688" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557546">parent</a><span>|</span><a href="#39557941">prev</a><span>|</span><a href="#39555846">next</a><span>|</span><label class="collapse" for="c-39557688">[-]</label><label class="expand" for="c-39557688">[4 more]</label></div><br/><div class="children"><div class="content">I <i>think</i> (well, assumed) what they meant by deterministic builds was merely hermetic builds, which are easier. True determinism is overkill for step 0.</div><br/><div id="39558991" class="c"><input type="checkbox" id="c-39558991" checked=""/><div class="controls bullet"><span class="by">rfoo</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557688">parent</a><span>|</span><a href="#39557717">next</a><span>|</span><label class="collapse" for="c-39558991">[-]</label><label class="expand" for="c-39558991">[1 more]</label></div><br/><div class="children"><div class="content">Agreed.<p>Though in the last 6 years I&#x27;ve seen at least one case where truly deterministic builds mattered:<p>A performance bug only happens when a malloc() during init was not aligned to 32 bytes, glibc on x86_64 only guaranteed 16 bytes, but depending on what alloc &#x2F; dealloc happened before it may just land on 32 bytes boundary.<p>The alloc &#x2F; dealloc sequence before that point was pretty deterministic, however there were a few strings containing __FILE__. And gitlab runner checked-out codes to a path with random number (or an index? I don&#x27;t remember) without -ffile-prefix-map or $PWD trick so its length varies.</div><br/></div></div><div id="39557717" class="c"><input type="checkbox" id="c-39557717" checked=""/><div class="controls bullet"><span class="by">groby_b</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557688">parent</a><span>|</span><a href="#39558991">prev</a><span>|</span><a href="#39555846">next</a><span>|</span><label class="collapse" for="c-39557717">[-]</label><label class="expand" for="c-39557717">[2 more]</label></div><br/><div class="children"><div class="content">Often yes. Sometimes, no. You haven&#x27;t enjoyed C++ until you get reports of the app intermittently crashing, and your build at the same version just won&#x27;t.<p>But yes, if the goal is &quot;slap it all in a container&quot;, that&#x27;s probably good and at least somewhat reproducible. We aren&#x27;t Python here! ;)</div><br/><div id="39557952" class="c"><input type="checkbox" id="c-39557952" checked=""/><div class="controls bullet"><span class="by">boolemancer</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557717">parent</a><span>|</span><a href="#39555846">next</a><span>|</span><label class="collapse" for="c-39557952">[-]</label><label class="expand" for="c-39557952">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Often yes. Sometimes, no. You haven&#x27;t enjoyed C++ until you get reports of the app intermittently crashing, and your build at the same version just won&#x27;t.<p>That&#x27;s okay, it&#x27;s probably just some bank in a random country that requires some software package to be installed, presumably in the interest of security, which injects a dll into every process on the machine and unsurprisingly has a bug which causes your process to crash at random in only that part of the world.</div><br/></div></div></div></div></div></div></div></div><div id="39555846" class="c"><input type="checkbox" id="c-39555846" checked=""/><div class="controls bullet"><span class="by">daemin</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555280">parent</a><span>|</span><a href="#39557546">prev</a><span>|</span><a href="#39555623">next</a><span>|</span><label class="collapse" for="c-39555846">[-]</label><label class="expand" for="c-39555846">[1 more]</label></div><br/><div class="children"><div class="content">Probably insert another Step 1: implement tests
Be they simple acceptance tests, integration tests, or even unit tests for some things.</div><br/></div></div></div></div><div id="39555623" class="c"><input type="checkbox" id="c-39555623" checked=""/><div class="controls bullet"><span class="by">microtherion</span><span>|</span><a href="#39554834">parent</a><span>|</span><a href="#39555280">prev</a><span>|</span><a href="#39558147">next</a><span>|</span><label class="collapse" for="c-39555623">[-]</label><label class="expand" for="c-39555623">[19 more]</label></div><br/><div class="children"><div class="content">&gt; Get the code to build clean with -Wall.<p>This is fine, but I would strongly recommend against putting something like -Wall -Werror into production builds. Some of the warnings produced by compilers are opinion based, and new compiler versions may add new warnings, and suddenly the previous &quot;clean&quot; code is no longer accepted. If you must use -Werror, use it in debug builds.</div><br/><div id="39555681" class="c"><input type="checkbox" id="c-39555681" checked=""/><div class="controls bullet"><span class="by">ladberg</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555623">parent</a><span>|</span><a href="#39559372">next</a><span>|</span><label class="collapse" for="c-39555681">[-]</label><label class="expand" for="c-39555681">[16 more]</label></div><br/><div class="children"><div class="content">This is fixed by the suggestion right before it:<p>&gt; * Reproducible builds. The sanity you save will be your own. Pro-tip: wrap your build environment with docker (or your favorite packager) so that your tooling and dependencies become both explicit and reproducable. The sanity you save will be your own.<p>Upgrading compiler versions shouldn&#x27;t be done out-of-band with your normal PR process.</div><br/><div id="39555701" class="c"><input type="checkbox" id="c-39555701" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555681">parent</a><span>|</span><a href="#39559372">next</a><span>|</span><label class="collapse" for="c-39555701">[-]</label><label class="expand" for="c-39555701">[15 more]</label></div><br/><div class="children"><div class="content">I agree that this helps, although I still think that in general, the <i>default</i> build should never do -Werror, since people may use other toolchains and it shouldn&#x27;t surprise-break downstream (I&#x27;m pretty sure this is a problem Linux distros struggle with all the time..) If it does it only in your fully reproducible CI, then it should be totally fine, of course.</div><br/><div id="39555767" class="c"><input type="checkbox" id="c-39555767" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555701">parent</a><span>|</span><a href="#39556015">next</a><span>|</span><label class="collapse" for="c-39555767">[-]</label><label class="expand" for="c-39555767">[7 more]</label></div><br/><div class="children"><div class="content">The scripted, packaged docker with toolchain dependencies and _is_ the build. If someone decides to use a different toolchain, the problems are on them.</div><br/><div id="39555840" class="c"><input type="checkbox" id="c-39555840" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555767">parent</a><span>|</span><a href="#39556015">next</a><span>|</span><label class="collapse" for="c-39555840">[-]</label><label class="expand" for="c-39555840">[6 more]</label></div><br/><div class="children"><div class="content">Yeah that works if you are not dealing with open source. If you are dealing with open source, though, it really won&#x27;t save you that much trouble, if anything it will just lead to unnecessarily hostile interactions. You&#x27;re not really obligated to fix any specific issues that people report, but shrugging and saying &quot;Your problem.&quot; is just non-productive and harms valuable downstreams like Linux distributions. Especially when a lot of new failures actually do indicate bugs and portability issues.</div><br/><div id="39557665" class="c"><input type="checkbox" id="c-39557665" checked=""/><div class="controls bullet"><span class="by">aseipp</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555840">parent</a><span>|</span><a href="#39557269">next</a><span>|</span><label class="collapse" for="c-39557665">[-]</label><label class="expand" for="c-39557665">[2 more]</label></div><br/><div class="children"><div class="content">Supporting every Linux distribution and their small differences isn&#x27;t free, and Linux distributions shipping things you haven&#x27;t tested directly is also a way for users to get bitten by bugs or bad interactions, which they will then report to you directly anyway so you&#x27;re responsible for it. It&#x27;s complicated. It&#x27;s happened plenty of times where e.g. I&#x27;ve run into an obscure and bad bug caused by a packaging issue, or a downstream library that wasn&#x27;t tested -- or there&#x27;s a developer who has to get involved with a specific distro team to solve bugs their users are reporting directly to them but that they can&#x27;t reproduce or pinpoint, because the distro is different from their own environment. Sometimes these point out serious issues, but other times it can be a huge squeeze to only get a little juice.<p>For some things the tradeoffs are much less clear, open-source or not e.g. a complex multi-platform GUI application. If you&#x27;re going to ship a Flatpak to Linux users for example, then the utility of allowing any random build environments is not so clear; users will be running your produced binaries anyway. These are the minority of cases, though. (No, maybe not every user wants a Flatpak, but the developers also need to make decisions that balance many needs, and not everything will be perfect.)<p>Half of the problem, of course, is C and C++&#x27;s lack of consistent build environments&#x2F;build systems&#x2F;build tooling, but that&#x27;s a conversation for another day.<p>That said, I generally agree with you that if you want to be a Good Citizen in the general realm of open-source C and C++ code, you should not use -Werror by default, and you should try (to whatever reasonable extent) to allow and support dependencies your users have. And try to support sanitizers, custom CFLAGS&#x2F;CXXFLAGS, allow PREFIX and DESTDIR installation options, obey the FHS, etc etc. A lot of things have consolidated in the Linux world over the years, so this isn&#x27;t as bad as it used to be -- and sometimes really does find legitimate issues in your code, or even issues in other projects.</div><br/><div id="39558204" class="c"><input type="checkbox" id="c-39558204" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557665">parent</a><span>|</span><a href="#39557269">next</a><span>|</span><label class="collapse" for="c-39558204">[-]</label><label class="expand" for="c-39558204">[1 more]</label></div><br/><div class="children"><div class="content">Again, you don&#x27;t <i>have</i> to fix bugs that are reported, but treating it as invalid to use any compiler versions except for the exact ones that you use is just counterproductive.<p>The &quot;utility&quot; of allowing &quot;any random build environment&quot; is that those random build environments are the ones that exist on your user&#x27;s computers, and absent a particularly good reason why it shouldn&#x27;t work (like, your compiler is too old, or literally broken,) for the most part it should, and usually, it&#x27;s not even that hard to make it work. Adopting practices like defaulting -Werror -Wall on and closing bugs as WONTFIX INVALID because it&#x27;s not any of the blessed toolchains gains you... not sure. I guess piece of mind from having less open issues and one less flag in your CI? But it is sure to be very annoying to users who have fairly standard setups and are trying to build your software; it&#x27;s pretty standard behavior to report your build failures upstream, because again, usually it does actually signal something wrong somewhere.<p>Developers are free to do whatever they want when releasing open source code. That doesn&#x27;t mean that what they are doing is good or makes any sense. There are plenty of perfectly legal things that are utterly stupid to do, like that utterly bizarre spat between Home Assistant and NixOS.</div><br/></div></div></div></div><div id="39557269" class="c"><input type="checkbox" id="c-39557269" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555840">parent</a><span>|</span><a href="#39557665">prev</a><span>|</span><a href="#39556015">next</a><span>|</span><label class="collapse" for="c-39557269">[-]</label><label class="expand" for="c-39557269">[3 more]</label></div><br/><div class="children"><div class="content">C++ is super annoying in this way. Many other languages (e.g Rust) only have one compiler and good portability out of the box which completely avoids this problem. And other ecosystems that do have multiple implementation (e.g. JavaScript) seem to have much better compatibility&#x2F;interop such that it&#x27;s not typically a problem you have to spend much if any time on in practice.</div><br/><div id="39559921" class="c"><input type="checkbox" id="c-39559921" checked=""/><div class="controls bullet"><span class="by">jxramos</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557269">parent</a><span>|</span><a href="#39559808">next</a><span>|</span><label class="collapse" for="c-39559921">[-]</label><label class="expand" for="c-39559921">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious what sort of CPUs and OSes do those languages run on. C++ runs on all sorts of obscure real time OSes, all the standard mainstream ones as well as on embedded equipment and various CPUs, but a lot of that is possible because of the variety of compilers.</div><br/></div></div><div id="39559808" class="c"><input type="checkbox" id="c-39559808" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557269">parent</a><span>|</span><a href="#39559921">prev</a><span>|</span><a href="#39556015">next</a><span>|</span><label class="collapse" for="c-39559808">[-]</label><label class="expand" for="c-39559808">[1 more]</label></div><br/><div class="children"><div class="content">I’ve had rust projects with strict clippy rules break when rustc is upgraded.</div><br/></div></div></div></div></div></div></div></div><div id="39556015" class="c"><input type="checkbox" id="c-39556015" checked=""/><div class="controls bullet"><span class="by">galangalalgol</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555701">parent</a><span>|</span><a href="#39555767">prev</a><span>|</span><a href="#39557532">next</a><span>|</span><label class="collapse" for="c-39556015">[-]</label><label class="expand" for="c-39556015">[1 more]</label></div><br/><div class="children"><div class="content">I would do wall wextra and werror. Again mostly for my own sanity. But I&#x27;d wait to add werror until they were all fixed so regression testing would continue as the warnings got fixed. Cpp_check and clang tidy would also eventually halt the pipeline. And *san on the tests as compiled in both debug and O3 with a couple compilers.</div><br/></div></div><div id="39557532" class="c"><input type="checkbox" id="c-39557532" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555701">parent</a><span>|</span><a href="#39556015">prev</a><span>|</span><a href="#39557106">next</a><span>|</span><label class="collapse" for="c-39557532">[-]</label><label class="expand" for="c-39557532">[5 more]</label></div><br/><div class="children"><div class="content">Changing other dependencies can also cause the build to break. The best thing to do is to use the dependencies the project specifies.</div><br/><div id="39558256" class="c"><input type="checkbox" id="c-39558256" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39557532">parent</a><span>|</span><a href="#39557106">next</a><span>|</span><label class="collapse" for="c-39558256">[-]</label><label class="expand" for="c-39558256">[4 more]</label></div><br/><div class="children"><div class="content">Technically changing literally <i>anything</i>, including the processor microarchitecture that the developer originally tested the code on, could easily cause a real-world breakage. That doesn&#x27;t mean it should, though.<p>Most libraries not written by Google have some kind of backwards compatibility policy. This is for good reasons. For example, if Debian updates libpng because there&#x27;s a new RCE, it&#x27;s ideal if they can update every package to the same new version of libpng all at once. If we go to the extreme of &quot;exact dependencies for every package&quot;, then this would actually mean that you have to update <i>every</i> dependent package to a new release that has the new version of libpng, all at the same time, across all supported versions of the distribution. Not to mention, imagine the number of duplicate libraries. Many Linux distros, including Debian, have adopted a policy of only having one version of any given library across the whole repo. As far as I understand, that even includes banning statically linked copies, requiring potentially invasive patching to make sure that downstream packages use the dynamically linked system version. And trust me, if they want to do this, they *will* do this. If they can do it for Chromium, they sure as hell can do it for literally any package.<p>There&#x27;s a balance, of course. If a distro does invasive patching and it is problematic, I think most people will be reasonable about it and accept that they need to report the issue to their distribution instead. Distros generally do accept bugs for the packages that they manage, and honestly for most packages, by the time a bug gets to you, there is a pretty reasonable chance that it&#x27;s actually a valid issue, so throwing away the issue simply because it came from someone running an &quot;unofficial&quot; build seems really counterproductive and definitely not in the spirit of open source.<p>Reproducibility is good for many reasons. I do not feel it is a good excuse to just throw away potentially valid bug reports though. It&#x27;s not that maintainers are under any obligation to actually act on bug reports, or for that matter, even <i>accept them at all in the first place</i>, but if you do accept bugs, I think that &quot;this is broken in <i>new version of Clang</i>&quot; is a very good and useful bug report that likely signals a problem.</div><br/><div id="39558345" class="c"><input type="checkbox" id="c-39558345" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39558256">parent</a><span>|</span><a href="#39557106">next</a><span>|</span><label class="collapse" for="c-39558345">[-]</label><label class="expand" for="c-39558345">[3 more]</label></div><br/><div class="children"><div class="content">&gt;For example, if Debian updates libpng because there&#x27;s a new RCE, it&#x27;s ideal if they can update every package to the same new version of libpng all at once.<p>It Debian is upgrading a dependency instead of a developer, then Debian should be ready to fix any bugs they introduce.<p>&gt;then this would actually mean that you have to update every dependent package to a new release that has the new version of libpng, all at the same time, across all supported versions of the distribution<p>This is already how it works. All vulnerable programs make an update and try to hold off in releasing it until near an embargo date. You don&#x27;t have to literally update them all at the same time. It&#x27;s okay of some are updated at different times than others.<p>&gt;Not to mention, imagine the number of duplicate libraries.<p>Duplicate libraries are not an issue.<p>&gt;Many Linux distros, including Debian, have adopted a policy of only having one version of any given library across the whole repo.<p>This is a ridiculous policy to me as you are forcing programs to use dependencies they were not designed for. This is something that should be avoided as much as possible.<p>&gt;by the time a bug gets to you, there is a pretty reasonable chance that it&#x27;s actually a valid issue<p>That doesn&#x27;t mean there isn&#x27;t damage done. There are many people who consider kdenlive an unstable program that constantly crashes because of distros shipping it with the incorrect dependencies. This creates reputational damage.</div><br/><div id="39558639" class="c"><input type="checkbox" id="c-39558639" checked=""/><div class="controls bullet"><span class="by">jchw</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39558345">parent</a><span>|</span><a href="#39557106">next</a><span>|</span><label class="collapse" for="c-39558639">[-]</label><label class="expand" for="c-39558639">[2 more]</label></div><br/><div class="children"><div class="content">&gt; It Debian is upgrading a dependency instead of a developer, then Debian should be ready to fix any bugs they introduce.<p>That&#x27;s what the Debian Bug Tracking System is for. However, if the package is actually broken, and it&#x27;s because e.g. it uses the dependency improperly and broke because the update broke a bad assumption, then it would ideally be reported upstream.<p>&gt; This is already how it works. All vulnerable programs make an update and try to hold off in releasing it until near an embargo date. You don&#x27;t have to literally update them all at the same time. It&#x27;s okay of some are updated at different times than others.<p>That&#x27;s not how it works in the vast majority of Linux distributions, for many reasons, such as the common rule of having only one version, or the fact that Debian probably does not want to update Blender to a new major version because libpng bumped. That would just turn all supported branches of Debian effectively into a rolling release distro.<p>&gt; Duplicate libraries are not an issue.<p>In your opinion, anyway. I don&#x27;t really think that there&#x27;s one way of thinking about this, but duplicate libraries certainly are an issue, whether you choose to address them or not.<p>&gt; This is a ridiculous policy to me as you are forcing programs to use dependencies they were not designed for. This is something that should be avoided as much as possible.<p>Honestly, this whole tangent is pointless. Distributions like Debian have been operating like this for like 20+ years. It&#x27;s dramatically too late to argue about it now, but if you&#x27;re going to, this is not exactly the strongest argument.<p>Based on this logic, effectively programs are apparently usually designed for exactly one specific code snapshot in time of each of its dependencies.<p>So let&#x27;s say I want to depend on two libraries, and both of them eventually depend on two different but compatible versions of a library, and only one of them can be loaded into the process space. Is this a made-up problem? No, this exact thing happens constantly, for example with libwayland.<p>Of course you can just pick any newer version of libwayland and it works absolutely perfectly fine, because that&#x27;s why we have shared libraries and semver to begin with. We solved this problem absolutely eons ago. The solution isn&#x27;t perfect, but it&#x27;s not a shocking new thing, it&#x27;s been the status quo for as long as I&#x27;ve been using Linux!<p>&gt; That doesn&#x27;t mean there isn&#x27;t damage done. There are many people who consider kdenlive an unstable program that constantly crashes because of distros shipping it with the incorrect dependencies. This creates reputational damage.<p>If you want your software to work better on Linux distributions, you could always decide to take supporting them more seriously. If your program is segfaulting because of slightly different library versions, this is a serious problem. Note that Chromium is a vastly larger piece of software than Kdenlive, packaged downstream by many Linux distributions using this very same policy, and yet it is quite stable.<p>For particularly complex and large programs, at some point it becomes a matter of, OK, it&#x27;s literally just going to crash sometimes, even if distributions don&#x27;t package unintended versions of packages, how do we make it better? There are tons of avenues for this, like improving crash recovery, introducing fault isolation, and simply, being more defensive when calling into third party libraries in the first place (e.g. against unexpected output.)<p>Maintainers, of course, are free to complain about this situation, mark bugs as WONTFIX INVALID, whatever they want really, but it won&#x27;t fix their problem. If you don&#x27;t want downstreams, then fine: don&#x27;t release open source code. If you don&#x27;t want people to build your software outside of your exact specification because it might damage its reputation, then simply do not release code whose license is literally for the primary purpose of making what Linux distributions do possible. You of course give up access to copyleft code, and that&#x27;s intended. That&#x27;s the system working as intended.<p>I believe that ultimately releasing open source code does indeed not obligate you as a maintainer to do anything at all. You can do all manner of things, foul or otherwise, as you please. However, note that this relationship is mutual. When you release open source code, you relinquish yourself of liability and warranty, but you grant everyone else the right to modify, use and share that code under the terms of the license. Nowhere in the license does it say you can&#x27;t modify it in specific ways that might damage your program&#x27;s reputation, or even yours.</div><br/><div id="39559121" class="c"><input type="checkbox" id="c-39559121" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39558639">parent</a><span>|</span><a href="#39557106">next</a><span>|</span><label class="collapse" for="c-39559121">[-]</label><label class="expand" for="c-39559121">[1 more]</label></div><br/><div class="children"><div class="content">&gt;That&#x27;s what the Debian Bug Tracking System is for.<p>Software should be extensively tested and code review should be done before it gets shipped to users. Most users don&#x27;t know about the Debian Bug Tracking system, but they do know about upstream.<p>&gt;Honestly, this whole tangent is pointless. Distributions like Debian have been operating like this for like 20+ years. It&#x27;s dramatically too late to argue about it now, but if you&#x27;re going to, this is not exactly the strongest argument.<p>It&#x27;s not too late as evidence by the growth of solutions like appimage and flatpak which allows developers to avoid this.<p>&gt;So let&#x27;s say I want to depend on two libraries, and both of them eventually depend on two different but compatible versions of a library, and only one of them can be loaded into the process space. Is this a made-up problem? No, this exact thing happens constantly, for example with libwayland.<p>Multiple versions of a library can be loaded into the same address space. Developers can choose to have their libraries support a range of versions.<p>&gt;that&#x27;s why we have shared libraries and semver to begin with<p>Hyrum&#x27;s Law. Semver doesn&#x27;t prevent breakages on minor bumps.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39557106" class="c"><input type="checkbox" id="c-39557106" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555701">parent</a><span>|</span><a href="#39557532">prev</a><span>|</span><a href="#39559372">next</a><span>|</span><label class="collapse" for="c-39557106">[-]</label><label class="expand" for="c-39557106">[1 more]</label></div><br/><div class="children"><div class="content">I think this depends on a bunch of stuff.<p>- Who are the consumers of the source code, i.e. who will ever check it out and build it? Sometimes, it&#x27;s just one person. Sometimes, it&#x27;s a team of engineers. In that case, -W -Werror is fine.<p>- How does a warning being reported make the engineers on the team feel? If the answer is, &quot;Hold my beer for five minutes while I commit a fix&quot;, then -W -Werror might be the right call. I&#x27;ve been on projects like that and some of them had nontrivial source code consumers.<p>- How easy is it to hack the build system? Some projects have wonderfully laid out build systems. If that&#x27;s the case and -W -Werror is the default, then it&#x27;s not hard to go in there and change the default, if the -Werror creates problems.<p>- Does the project have a facility (in the build system) and policy (as a matter of process) to just simply add -Wno-blah-blah as the immediate fix for any new warning that arises? I&#x27;ve seen that, too.<p>(I&#x27;m using -Werror in some parts of a personal project. If you&#x27;re a solo maintainer of a codebase that can be built that way, then it&#x27;s worth it - IMO much lower cognitive load to never have non-error warnings. The choice of what to do when the compiler complains is a more straightforward choice.)</div><br/></div></div></div></div></div></div><div id="39559372" class="c"><input type="checkbox" id="c-39559372" checked=""/><div class="controls bullet"><span class="by">__d</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39555623">parent</a><span>|</span><a href="#39555681">prev</a><span>|</span><a href="#39558147">next</a><span>|</span><label class="collapse" for="c-39559372">[-]</label><label class="expand" for="c-39559372">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a feature!<p>New warnings added to new compiler versions can identify problems that weren&#x27;t previously detected.  You _want_ those to -Werror when they happen, so you can fix them if they need it.<p>Changing a compiler version is a task that has to be resourced appropriately.  Part of that is dealing with any fallout like this.  Randomly updating your compiler is just asking for trouble.</div><br/><div id="39559791" class="c"><input type="checkbox" id="c-39559791" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39559372">parent</a><span>|</span><a href="#39558147">next</a><span>|</span><label class="collapse" for="c-39559791">[-]</label><label class="expand" for="c-39559791">[1 more]</label></div><br/><div class="children"><div class="content">It is certainly not a feature because it make all infrastructure including just regular old checkout-and-build workflows break for historical versions of the code. It’s so annoying to have to checkout an older version and then have to go disable -Wall -Werror everywhere just to get the damn thing to build.<p>Keep master clean of any warnings, for sure. But don’t put it straight into the build system defaults.</div><br/></div></div></div></div></div></div><div id="39558147" class="c"><input type="checkbox" id="c-39558147" checked=""/><div class="controls bullet"><span class="by">dheera</span><span>|</span><a href="#39554834">parent</a><span>|</span><a href="#39555623">prev</a><span>|</span><a href="#39556142">next</a><span>|</span><label class="collapse" for="c-39558147">[-]</label><label class="expand" for="c-39558147">[2 more]</label></div><br/><div class="children"><div class="content">&gt; wrap your build environment with docker<p>For microservices it is fine, but you can&#x27;t always deploy everything else with docker, especially for people who want to use your app inside a docker. Docker-in-docker is a situation that should never happen.<p>Containers are nice but they&#x27;re a horrible way to pretend the problem doesn&#x27;t exist.<p>Bundle all the dependencies and make sure it doesn&#x27;t depend on 5 billion things being in &#x2F;usr&#x2F;lib and having the correct versions.</div><br/><div id="39558674" class="c"><input type="checkbox" id="c-39558674" checked=""/><div class="controls bullet"><span class="by">cshokie</span><span>|</span><a href="#39554834">root</a><span>|</span><a href="#39558147">parent</a><span>|</span><a href="#39556142">next</a><span>|</span><label class="collapse" for="c-39558674">[-]</label><label class="expand" for="c-39558674">[1 more]</label></div><br/><div class="children"><div class="content">Not the OP, but I don’t think they meant that the build output is in a container. They meant that the thing you use to compile the code is in docker (and you just copy out the result). That would help ensure consistency of builds without having any effect on downstream users.</div><br/></div></div></div></div><div id="39556142" class="c"><input type="checkbox" id="c-39556142" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#39554834">parent</a><span>|</span><a href="#39558147">prev</a><span>|</span><a href="#39555063">next</a><span>|</span><label class="collapse" for="c-39556142">[-]</label><label class="expand" for="c-39556142">[1 more]</label></div><br/><div class="children"><div class="content">Great advice. Almost all of it applies to any programming language.</div><br/></div></div><div id="39555063" class="c"><input type="checkbox" id="c-39555063" checked=""/><div class="controls bullet"><span class="by">SleepyMyroslav</span><span>|</span><a href="#39554834">parent</a><span>|</span><a href="#39556142">prev</a><span>|</span><a href="#39551578">next</a><span>|</span><label class="collapse" for="c-39555063">[-]</label><label class="expand" for="c-39555063">[1 more]</label></div><br/><div class="children"><div class="content">I would not call that &#x27;controversial&#x27;. In the internet days people call this behavior trolling for a reason. The punchline about rewriting code in different language gives an easy hint at where this all going.<p>PS. I have been in the shoes of inheriting old projects before. And I hope i left them in better state than they were before.</div><br/></div></div></div></div><div id="39551578" class="c"><input type="checkbox" id="c-39551578" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39554834">prev</a><span>|</span><a href="#39559893">next</a><span>|</span><label class="collapse" for="c-39551578">[-]</label><label class="expand" for="c-39551578">[28 more]</label></div><br/><div class="children"><div class="content">I&#x27;d swap 2 and 3. Getting CI, linting, auto-formatting, etc. going is a higher priority than tearing things out. Why? Because you don&#x27;t know what to tear out yet or even the consequence of tearing them out. Linting (and other static analysis tools) also give you a lot of insight into where the program needs work.<p>Things that get flagged by a static analysis tool (today) will often be areas where you can tear out entire functions and maybe even classes and files because they&#x27;ll be a re-creation of STL concepts. Like homegrown iterator libraries (with subtle problems) that can be replaced with the STL algorithms library, or homegrown smart pointers that can just be replaced with actual smart pointers, or replacing the C string functions with C++&#x27;s on string class (and related classes) and functions&#x2F;methods.<p>But you won&#x27;t see that as easily until you start scanning the code. And you won&#x27;t be able to evaluate the consequences until you push towards more rapid test builds (at least) if not deployment.</div><br/><div id="39555138" class="c"><input type="checkbox" id="c-39555138" checked=""/><div class="controls bullet"><span class="by">jasonwatkinspdx</span><span>|</span><a href="#39551578">parent</a><span>|</span><a href="#39551880">next</a><span>|</span><label class="collapse" for="c-39555138">[-]</label><label class="expand" for="c-39555138">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve done a fair bit of agency work dropping in to rescue code bases, and the first thing I do is run unit tests and check coverage. I add basic smoke tests anywhere they&#x27;re missing. This actually speeds me up, rather than slowing me down, because once I have reasonably good coverage I can move dramatically faster when refactoring. It&#x27;s a small investment that pays off.</div><br/></div></div><div id="39551880" class="c"><input type="checkbox" id="c-39551880" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#39551578">parent</a><span>|</span><a href="#39555138">prev</a><span>|</span><a href="#39555605">next</a><span>|</span><label class="collapse" for="c-39551880">[-]</label><label class="expand" for="c-39551880">[19 more]</label></div><br/><div class="children"><div class="content">On the flip side, auto-formatting will trash your version history and impede analysis of &quot;when and why was this line added&quot;.</div><br/><div id="39552022" class="c"><input type="checkbox" id="c-39552022" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39551918">next</a><span>|</span><label class="collapse" for="c-39552022">[-]</label><label class="expand" for="c-39552022">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not hardcore on auto-formatters, but I think their impact on code history is negligible in the case of every legacy system I&#x27;ve worked on. The code history just isn&#x27;t there. These aren&#x27;t projects that used git until recently (if at all). Before that they used something else, but when they transitioned they didn&#x27;t preserve the history. And that&#x27;s if they used any version control system. I&#x27;ve tried to help teams whose idea of version control was emailing someone (they termed them &quot;QA&#x2F;CM&quot;) to make a read-only backup of the source directory every few months (usually at a critical review period in the project, so a <i>lot</i> of code was changed between these snapshots).<p>That said, sure, skip them if you&#x27;re worried about the history getting messed up or use them more selectively.</div><br/><div id="39556135" class="c"><input type="checkbox" id="c-39556135" checked=""/><div class="controls bullet"><span class="by">bear8642</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39552022">parent</a><span>|</span><a href="#39554262">next</a><span>|</span><label class="collapse" for="c-39556135">[-]</label><label class="expand" for="c-39556135">[2 more]</label></div><br/><div class="children"><div class="content">&gt;I think their impact on code history is negligible in the case of every legacy system I&#x27;ve worked on. The code history just isn&#x27;t there.<p>Not sure if I agree here or not - whilst yes, the history isn&#x27;t there, if it&#x27;s a small enough team you&#x27;ll have a good guess at who wrote it.<p>Definitely found I&#x27;ve learnt the style of colleages so know who to ask just from the code outline.</div><br/><div id="39556220" class="c"><input type="checkbox" id="c-39556220" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39556135">parent</a><span>|</span><a href="#39554262">next</a><span>|</span><label class="collapse" for="c-39556220">[-]</label><label class="expand" for="c-39556220">[1 more]</label></div><br/><div class="children"><div class="content">Legacy systems that you inherit don&#x27;t have people coming with them very often. That&#x27;s part of the context of this. You often don&#x27;t have people to trace it back to or at least not the people who actually wrote it (maybe someone who worked with them before they got laid off a decade ago), and reformatting the code is not going to make it any harder to get answers from people who aren&#x27;t there.</div><br/></div></div></div></div><div id="39554262" class="c"><input type="checkbox" id="c-39554262" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39552022">parent</a><span>|</span><a href="#39556135">prev</a><span>|</span><a href="#39551918">next</a><span>|</span><label class="collapse" for="c-39554262">[-]</label><label class="expand" for="c-39554262">[7 more]</label></div><br/><div class="children"><div class="content">SVN was a thing by the mid-2000&#x27;s, and history from that is easy to preserve in git. Just how old are the sourcebases in question? (Not to shoot the messenger; just like, wow.)<p>edit:typo</div><br/><div id="39559578" class="c"><input type="checkbox" id="c-39559578" checked=""/><div class="controls bullet"><span class="by">olvy0</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39554262">parent</a><span>|</span><a href="#39554319">next</a><span>|</span><label class="collapse" for="c-39559578">[-]</label><label class="expand" for="c-39559578">[1 more]</label></div><br/><div class="children"><div class="content">I maintain a C++ codebase that was originally written in 1996, and is mission critical for my organization.  Originally maintained in Visual Sourcesafe, then in TFS source control, and now git.  Some parts of it were rewritten (several times) in C#, but the core is still C++.<p>I was very worried when we transitioned to git that history will not be preserved and tried to preserve it, but it proved too much hassle so I dropped it.<p>In fact that proved not to be a problem.  Well, not a problem for me, since I remember all the history of the code and all the half forgotten half baked features and why they are there.  But if I&#x27;m gone then yes, it&#x27;s going to be a problem.  It&#x27;s in a dire need for a rewrite, but this has been postponed again and again.</div><br/></div></div><div id="39554319" class="c"><input type="checkbox" id="c-39554319" checked=""/><div class="controls bullet"><span class="by">varjag</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39554262">parent</a><span>|</span><a href="#39559578">prev</a><span>|</span><a href="#39559078">next</a><span>|</span><label class="collapse" for="c-39554319">[-]</label><label class="expand" for="c-39554319">[1 more]</label></div><br/><div class="children"><div class="content">The first large C++ project I worked on in mid-1990s was basically preserving a bunch of archived copies of the source tree. CVS was a thing but not on Windows, and SourceSafe was creating more problems than it been solving.</div><br/></div></div><div id="39559078" class="c"><input type="checkbox" id="c-39559078" checked=""/><div class="controls bullet"><span class="by">pyuser583</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39554262">parent</a><span>|</span><a href="#39554319">prev</a><span>|</span><a href="#39554615">next</a><span>|</span><label class="collapse" for="c-39559078">[-]</label><label class="expand" for="c-39559078">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had issues doing decent copies from SVN to GIT. They both have different ideas about user identity, and how fragmented it can be.</div><br/></div></div><div id="39554615" class="c"><input type="checkbox" id="c-39554615" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39554262">parent</a><span>|</span><a href="#39559078">prev</a><span>|</span><a href="#39557536">next</a><span>|</span><label class="collapse" for="c-39554615">[-]</label><label class="expand" for="c-39554615">[1 more]</label></div><br/><div class="children"><div class="content">Some of these systems dated back to the 1970s. The worst offenders were from the 1980s and 1990s though.<p>It&#x27;s all about the team or organization and their laziness or non-laziness.</div><br/></div></div><div id="39557536" class="c"><input type="checkbox" id="c-39557536" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39554262">parent</a><span>|</span><a href="#39554615">prev</a><span>|</span><a href="#39554536">next</a><span>|</span><label class="collapse" for="c-39557536">[-]</label><label class="expand" for="c-39557536">[1 more]</label></div><br/><div class="children"><div class="content">I looked at a C++ codebase from 1997 at a previous job - I don&#x27;t know much about the history but comments in one of the old files tracked dates and changes to 2001.
Not sure what happened after that but in 2017 someone copy-pasted the project from TFS to git and obliterated the prior history.</div><br/></div></div><div id="39554536" class="c"><input type="checkbox" id="c-39554536" checked=""/><div class="controls bullet"><span class="by">Pfiffer</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39554262">parent</a><span>|</span><a href="#39557536">prev</a><span>|</span><a href="#39551918">next</a><span>|</span><label class="collapse" for="c-39554536">[-]</label><label class="expand" for="c-39554536">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard a lot of stories about mid-90s codebases for sure</div><br/></div></div></div></div></div></div><div id="39551918" class="c"><input type="checkbox" id="c-39551918" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39552022">prev</a><span>|</span><a href="#39555419">next</a><span>|</span><label class="collapse" for="c-39551918">[-]</label><label class="expand" for="c-39551918">[1 more]</label></div><br/><div class="children"><div class="content">You can ignore commits from git blame by adding them to a .gitattributes file.<p>This is assuming Git of course, which is not a given at all for the average legacy c++ codebase.</div><br/></div></div><div id="39555419" class="c"><input type="checkbox" id="c-39555419" checked=""/><div class="controls bullet"><span class="by">lpapez</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39551918">prev</a><span>|</span><a href="#39556174">next</a><span>|</span><label class="collapse" for="c-39555419">[-]</label><label class="expand" for="c-39555419">[2 more]</label></div><br/><div class="children"><div class="content">You can instruct git to ignore specific commits for blame and diff commands.<p>See &quot;git blame ignore revs file&quot;.<p>Intended use is exactly to ignore bulk changes like auto formatting.</div><br/><div id="39555863" class="c"><input type="checkbox" id="c-39555863" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39555419">parent</a><span>|</span><a href="#39556174">next</a><span>|</span><label class="collapse" for="c-39555863">[-]</label><label class="expand" for="c-39555863">[1 more]</label></div><br/><div class="children"><div class="content">+1<p><pre><code>  man git-blame
  git help blame
</code></pre>
<a href="https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-blame" rel="nofollow">https:&#x2F;&#x2F;git-scm.com&#x2F;docs&#x2F;git-blame</a></div><br/></div></div></div></div><div id="39556174" class="c"><input type="checkbox" id="c-39556174" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39555419">prev</a><span>|</span><a href="#39557203">next</a><span>|</span><label class="collapse" for="c-39556174">[-]</label><label class="expand" for="c-39556174">[1 more]</label></div><br/><div class="children"><div class="content">This is another reason why you should track important information in comments alongside the code instead of trusting VCS to preserve it in logs&#x2F;commit messages, and to reject weird code missing comments from being merged.<p>Not saying that fixes decades of cruft because you shouldn&#x27;t change files without good reason and non-white space formatting is not a good reason, but I&#x27;m mentioning it because I&#x27;ve seen people naively belief bullshit like &quot;code is self explanatory&quot; and &quot;the reason is in the commit message&quot;<p>Just comment your code folks, this becomes less of a problem</div><br/></div></div><div id="39557203" class="c"><input type="checkbox" id="c-39557203" checked=""/><div class="controls bullet"><span class="by">mb7733</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39556174">prev</a><span>|</span><a href="#39553472">next</a><span>|</span><label class="collapse" for="c-39557203">[-]</label><label class="expand" for="c-39557203">[1 more]</label></div><br/><div class="children"><div class="content">How does reformatting trash the history? It&#x27;s one extra commit..<p>I guess if it splits or combines lines that could cause some noise if you really want the history of a single line... But that happens all the time, and I don&#x27;t see how it would really prevent understanding the history. You can always do a blame on a range of lines.<p>Maybe I&#x27;m missing something though, genuinely curious for a concrete example where reformatting makes it hard to understand history!</div><br/></div></div><div id="39553472" class="c"><input type="checkbox" id="c-39553472" checked=""/><div class="controls bullet"><span class="by">PreachSoup</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39557203">prev</a><span>|</span><a href="#39554448">next</a><span>|</span><label class="collapse" for="c-39553472">[-]</label><label class="expand" for="c-39553472">[1 more]</label></div><br/><div class="children"><div class="content">On per file level it&#x27;s just 1 commit. It&#x27;s not really a big deal</div><br/></div></div><div id="39554448" class="c"><input type="checkbox" id="c-39554448" checked=""/><div class="controls bullet"><span class="by">exDM69</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39553472">prev</a><span>|</span><a href="#39555141">next</a><span>|</span><label class="collapse" for="c-39554448">[-]</label><label class="expand" for="c-39554448">[1 more]</label></div><br/><div class="children"><div class="content">clang-format can be applied to new changes only, for this very reason.<p>Adding it will remove white space nitpicking from code review, even if it isn&#x27;t perfect.</div><br/></div></div><div id="39555141" class="c"><input type="checkbox" id="c-39555141" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551880">parent</a><span>|</span><a href="#39554448">prev</a><span>|</span><a href="#39555605">next</a><span>|</span><label class="collapse" for="c-39555141">[-]</label><label class="expand" for="c-39555141">[1 more]</label></div><br/><div class="children"><div class="content">I believe you can configure `git blame` to skip a specific commit. But in my experience it doesn&#x27;t matter anyway for two reasons:<p>1. You&#x27;re going to reformat it eventually anyway. You&#x27;re just delaying things. The best time to plant a tree, etc.<p>2. If it&#x27;s an old codebase and you&#x27;re trying to understand some bit of code you&#x27;re almost always going to have to walk through about 5 commits to get to the original one anyway. One extra formatting commit doesn&#x27;t really make any difference.</div><br/></div></div></div></div><div id="39555605" class="c"><input type="checkbox" id="c-39555605" checked=""/><div class="controls bullet"><span class="by">thrwyexecbrain</span><span>|</span><a href="#39551578">parent</a><span>|</span><a href="#39551880">prev</a><span>|</span><a href="#39552015">next</a><span>|</span><label class="collapse" for="c-39555605">[-]</label><label class="expand" for="c-39555605">[2 more]</label></div><br/><div class="children"><div class="content">I would absolutely not recommend auto-formatting a legacy codebase. In my experience large C++ projects tend to have not only code generation scripts (python&#x2F;perl&#x2F;whatever) but also scripts that parse the code (usually to gather data for code generation). Auto formatting might break that. I have even seen some really cursed projects where the _users_ parsed public header files with rather fragile scripts.</div><br/><div id="39555786" class="c"><input type="checkbox" id="c-39555786" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39555605">parent</a><span>|</span><a href="#39552015">next</a><span>|</span><label class="collapse" for="c-39555786">[-]</label><label class="expand" for="c-39555786">[1 more]</label></div><br/><div class="children"><div class="content">I was listing the items in the original article&#x27;s #3 and saying I&#x27;d move them up to #2 before I&#x27;d go about excising portions of the project, the original #2. I still stand by that. But you can read my other comment where I don&#x27;t really defend auto-formatting to see that I don&#x27;t care either way. I made it about four hours ago so maybe you missed it if you didn&#x27;t refresh the page in the last few hours.</div><br/></div></div></div></div><div id="39552015" class="c"><input type="checkbox" id="c-39552015" checked=""/><div class="controls bullet"><span class="by">btown</span><span>|</span><a href="#39551578">parent</a><span>|</span><a href="#39555605">prev</a><span>|</span><a href="#39551710">next</a><span>|</span><label class="collapse" for="c-39552015">[-]</label><label class="expand" for="c-39552015">[1 more]</label></div><br/><div class="children"><div class="content">CI is different from the others, here! At minimum, building a &quot;happy path(s)&quot; test harness that can run with replicable results, and will run on every one of your commits, is a first step, and also helps to understand the codebase.<p>And you&#x27;re jumping around - and you&#x27;ll have to! - odds are you&#x27;ll have a bunch of things changed locally, and might accidentally create a commit that doesn&#x27;t separate out one concern from another. CI will be a godsend at that point.</div><br/></div></div><div id="39551710" class="c"><input type="checkbox" id="c-39551710" checked=""/><div class="controls bullet"><span class="by">broken_broken_</span><span>|</span><a href="#39551578">parent</a><span>|</span><a href="#39552015">prev</a><span>|</span><a href="#39551963">next</a><span>|</span><label class="collapse" for="c-39551710">[-]</label><label class="expand" for="c-39551710">[1 more]</label></div><br/><div class="children"><div class="content">Fair point!</div><br/></div></div><div id="39551963" class="c"><input type="checkbox" id="c-39551963" checked=""/><div class="controls bullet"><span class="by">politician</span><span>|</span><a href="#39551578">parent</a><span>|</span><a href="#39551710">prev</a><span>|</span><a href="#39559893">next</a><span>|</span><label class="collapse" for="c-39551963">[-]</label><label class="expand" for="c-39551963">[3 more]</label></div><br/><div class="children"><div class="content">Nit: The post scopes &quot;tearing things out&quot; to dead code as guided by compiler warnings and unsupported architectures.<p>If going the route, I&#x27;d recommend commenting out the lines rather than removing them outright to simplify the diffs at least until you&#x27;re ready to squash and merge the branch.</div><br/><div id="39553708" class="c"><input type="checkbox" id="c-39553708" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39551963">parent</a><span>|</span><a href="#39559893">next</a><span>|</span><label class="collapse" for="c-39553708">[-]</label><label class="expand" for="c-39553708">[2 more]</label></div><br/><div class="children"><div class="content">Better to use `#if` or `#ifdef` to prevent compilation. C &amp; C++ don&#x27;t support nested comments, so you can end up with existing comments in the code ending the comment block.</div><br/><div id="39555034" class="c"><input type="checkbox" id="c-39555034" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#39551578">root</a><span>|</span><a href="#39553708">parent</a><span>|</span><a href="#39559893">next</a><span>|</span><label class="collapse" for="c-39555034">[-]</label><label class="expand" for="c-39555034">[1 more]</label></div><br/><div class="children"><div class="content">I think `#if` and `#ifdef` are not good ideas because they prevent the compiler from seeing them in the first place. A better solution is just `if (false)` which is nestable, and the code is still checked by the compiler so it won&#x27;t bit rot.</div><br/></div></div></div></div></div></div></div></div><div id="39559893" class="c"><input type="checkbox" id="c-39559893" checked=""/><div class="controls bullet"><span class="by">jxramos</span><span>|</span><a href="#39551578">prev</a><span>|</span><a href="#39556287">next</a><span>|</span><label class="collapse" for="c-39559893">[-]</label><label class="expand" for="c-39559893">[1 more]</label></div><br/><div class="children"><div class="content">I like to use cppdepend to navigate a large and unfamiliar codebase <a href="https:&#x2F;&#x2F;www.cppdepend.com" rel="nofollow">https:&#x2F;&#x2F;www.cppdepend.com</a>. The interactive dependency graph and integration to the editor to jump back and forth in diagrams to actual code and the many logical constructs in the source certainly accelerates getting a quick sense of the layering and a bit of the architecture of the project.</div><br/></div></div><div id="39556287" class="c"><input type="checkbox" id="c-39556287" checked=""/><div class="controls bullet"><span class="by">vijucat</span><span>|</span><a href="#39559893">prev</a><span>|</span><a href="#39554378">next</a><span>|</span><label class="collapse" for="c-39556287">[-]</label><label class="expand" for="c-39556287">[1 more]</label></div><br/><div class="children"><div class="content">Not mentioned were code comprehension tools &#x2F; techniques:<p>I used to use a tool called Source Navigator (written in Tcl&#x2F;tk!) that was great at indexing code bases. You could then check the Call Hierarchy of the current method, for example, then use that to make UML Sequence Diagrams. A similar one called Source Insight shown below [1].<p>And oh, notes. Writing as if you&#x27;re teaching someone is key.<p>Over the years, I got quite good at comprehending code, even code written by an entire team over years. For a brief period, I was the only person actively supporting and developing an algorithmic trading code base in Java that traded ~$200m per day on 4 or 5 exchanges. I had 35 MB of documentation on that, lol. Loved the responsibility (ignoring the key man risk :|). Honestly, there&#x27;s a lot of overengineering and redundancy in most large code bases.<p>[1] References in &quot;Source Insight&quot; <a href="https:&#x2F;&#x2F;d4.alternativeto.net&#x2F;6S4rr6_0rutCUWnpHNhVq7HMs8GTBs6osGo8uUyXjqk&#x2F;rs:fit:2400:2400:0&#x2F;g:ce:0:0&#x2F;YWJzOi8vZGlzdC9zL3NvdXJjZS1pbnNpZ2h0XzM5MTk4MV9mdWxsLnBuZw.jpg" rel="nofollow">https:&#x2F;&#x2F;d4.alternativeto.net&#x2F;6S4rr6_0rutCUWnpHNhVq7HMs8GTBs6...</a></div><br/></div></div><div id="39554378" class="c"><input type="checkbox" id="c-39554378" checked=""/><div class="controls bullet"><span class="by">mk_chan</span><span>|</span><a href="#39556287">prev</a><span>|</span><a href="#39551683">next</a><span>|</span><label class="collapse" for="c-39554378">[-]</label><label class="expand" for="c-39554378">[6 more]</label></div><br/><div class="children"><div class="content">I’m not sure why there’s so much focus on refactoring or improving it. When a feature needs to be added that can just be tacked onto the code, do it without touching anything else.<p>If it’s a big enough change, export whatever you need out of the legacy code (by calling an external function&#x2F;introducing a network layer&#x2F;pulling the exact same code out into a library&#x2F;other assorted ways of separating code) and do the rest in a fresh environment.<p>I wouldn’t try to do any major refactor unless several people are going to work on the code in the future and the code needs to have certain assumptions and standards so it is easy for the group to work together on it.</div><br/><div id="39554725" class="c"><input type="checkbox" id="c-39554725" checked=""/><div class="controls bullet"><span class="by">dj_mc_merlin</span><span>|</span><a href="#39554378">parent</a><span>|</span><a href="#39555402">next</a><span>|</span><label class="collapse" for="c-39554725">[-]</label><label class="expand" for="c-39554725">[1 more]</label></div><br/><div class="children"><div class="content">The post argues against major refactors. The incremental suggestions it gives progressively make the code easier to work with. What you suggest works until it doesn&#x27;t -- something suddenly breaks when you make a change and there&#x27;s so much disorganized stuff that you can&#x27;t pinpoint the cause for much longer than necessary. The OP is basically arguing for decluttering in order to be able to do changes easier, while still maintaining cohesion and avoiding a major rewrite.</div><br/></div></div><div id="39555402" class="c"><input type="checkbox" id="c-39555402" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39554378">parent</a><span>|</span><a href="#39554725">prev</a><span>|</span><a href="#39556319">next</a><span>|</span><label class="collapse" for="c-39555402">[-]</label><label class="expand" for="c-39555402">[2 more]</label></div><br/><div class="children"><div class="content">The right answer depends on the future.  I&#x27;ve worked on C++ code where the replacement was already in the market but we had to do a couple more releases of the old code.  Sometimes it is adding the same feature to both versions.  There is a big difference in how you treat code that you know the last release is coming soon and code where you expect to maintain and add features for a few more decades.</div><br/><div id="39559196" class="c"><input type="checkbox" id="c-39559196" checked=""/><div class="controls bullet"><span class="by">mk_chan</span><span>|</span><a href="#39554378">root</a><span>|</span><a href="#39555402">parent</a><span>|</span><a href="#39556319">next</a><span>|</span><label class="collapse" for="c-39559196">[-]</label><label class="expand" for="c-39559196">[1 more]</label></div><br/><div class="children"><div class="content">Yes, you have to expect the future (or even better if your manager&#x2F;boss already has expectations you can adopt to begin with) and then choose the right way to tackle the changes required. That&#x27;s why I laid out 3 possible cases the last of which points out that I prefer to refactor primarily when there&#x27;s a lot of work incoming on the codebase.
Personally, I don&#x27;t see much value in refactoring code significantly if you alone are going to be editing it because refactoring for ease of editing + the cost of editing in the refactored codebase is often less than just eating the higher cost of editing in the pre-refactored codebase and you don&#x27;t reap the scaling benefits of refactoring as much. However, like I mentioned in the above paragraph, it depends.
In the end it&#x27;s all about managing the debt to get the most out of it in a _relatively_ fixed time period.</div><br/></div></div></div></div><div id="39556319" class="c"><input type="checkbox" id="c-39556319" checked=""/><div class="controls bullet"><span class="by">FpUser</span><span>|</span><a href="#39554378">parent</a><span>|</span><a href="#39555402">prev</a><span>|</span><a href="#39551683">next</a><span>|</span><label class="collapse" for="c-39556319">[-]</label><label class="expand" for="c-39556319">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&quot;When a feature needs to be added that can just be tacked onto the code, do it without touching anything else.&quot;<p>In few lucky cases. In real life new feature is most likely change in behavior of already existing one and suddenly you have to do some heavy refactoring in numerous places.</div><br/><div id="39557254" class="c"><input type="checkbox" id="c-39557254" checked=""/><div class="controls bullet"><span class="by">convolvatron</span><span>|</span><a href="#39554378">root</a><span>|</span><a href="#39556319">parent</a><span>|</span><a href="#39551683">next</a><span>|</span><label class="collapse" for="c-39557254">[-]</label><label class="expand" for="c-39557254">[1 more]</label></div><br/><div class="children"><div class="content">if you&#x27;re going to own it for the foreseeable future. then own it. learn it, refactor it, test the hell of out of it. otherwise you&#x27;re never going to be able to debug or extend it.<p>one thing I always do is throwaway major refactors. its the fastest way for me to learn what the structure is, what depends on what, and what&#x27;s really kinky. and I might just learn enough to do it for real should it become necessary.</div><br/></div></div></div></div></div></div><div id="39551683" class="c"><input type="checkbox" id="c-39551683" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#39554378">prev</a><span>|</span><a href="#39551164">next</a><span>|</span><label class="collapse" for="c-39551683">[-]</label><label class="expand" for="c-39551683">[14 more]</label></div><br/><div class="children"><div class="content">&gt;worry not, by adding std::cmake to the standard library and you’ll see how it’s absolutely a game changer<p>I&#x27;m pretty sure my stomach did somersaults on that.<p>But as for the advice:<p>&gt;Get out the chainsaw and rip out everything that’s not absolutely required to provide the features your company&#x2F;open source project is advertising and selling<p>I hear you, but this is <i>incredibly</i> dangerous. Might as well take that chainsaw to yourself if you want to try this.<p>It&#x27;s dangerous for multiple reasons. Mainly it&#x27;s a case of Chesterton&#x27;s fence. Unless you fully understand why X was in the software and fully understand how the current version of the software is used, you <i>cannot</i> remove it. A worst case scenario would be that maybe a month or so later you make a release and the users find out an important feature is subtly broken. You&#x27;ll spend days trying to track down exactly how it broke.<p>&gt;Make the project enter the 21st century by adding CI, linters, fuzzing, auto-formatting, etc<p>It&#x27;s a nice idea, but it&#x27;s hard to do. One person is using VIM, another is using emacs, another is using QTCreator, another primarily edits in VSCode.. Trying to get everyone on the same page about all this is very, very hard.<p>If it&#x27;s an optional step that requires that they install something new (like commit hook) it&#x27;s just not going to happen.<p>Linters also won&#x27;t do you any good when you open the project and 2000+ warnings appear.</div><br/><div id="39552045" class="c"><input type="checkbox" id="c-39552045" checked=""/><div class="controls bullet"><span class="by">electroly</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39555620">next</a><span>|</span><label class="collapse" for="c-39552045">[-]</label><label class="expand" for="c-39552045">[3 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a nice idea, but it&#x27;s hard to do. One person is using VIM...<p>The things the author listed there are commonly not IDE integrated. I&#x27;ve never seen a C++ development environment where cpplint&#x2F;clang-tidy and fuzzers are IDE integrated, they&#x27;re too slow to run automatically on keystrokes. Auto-formatting is the only one that is sometimes integrated. All of this stuff you can do from the command line without caring about each user&#x27;s chosen development environment. You should definitely at least try rather than giving up before you start just because you have two different text editors in use. This is C++; if your team won&#x27;t install any tools, you&#x27;re gonna have a bad time. Consider containerizing the tools so it&#x27;s easier.</div><br/><div id="39557368" class="c"><input type="checkbox" id="c-39557368" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39551683">root</a><span>|</span><a href="#39552045">parent</a><span>|</span><a href="#39556459">next</a><span>|</span><label class="collapse" for="c-39557368">[-]</label><label class="expand" for="c-39557368">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve never seen a C++ development environment where cpplint&#x2F;clang-tidy and fuzzers are IDE integrated<p>CLion from JetBrains has clang-tidy integrated (real-time).</div><br/></div></div><div id="39556459" class="c"><input type="checkbox" id="c-39556459" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#39551683">root</a><span>|</span><a href="#39552045">parent</a><span>|</span><a href="#39557368">prev</a><span>|</span><a href="#39555620">next</a><span>|</span><label class="collapse" for="c-39556459">[-]</label><label class="expand" for="c-39556459">[1 more]</label></div><br/><div class="children"><div class="content">Clangd will happily run clang-tidy as part of completion&#x2F;compile-as-you-type&#x2F;refactor&#x2F;auto independent.<p>On the editor&#x2F;IDE of your choose.<p>I wouldn&#x27;t call it fast, but it is quite usable.</div><br/></div></div></div></div><div id="39555620" class="c"><input type="checkbox" id="c-39555620" checked=""/><div class="controls bullet"><span class="by">j-krieger</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39552045">prev</a><span>|</span><a href="#39551921">next</a><span>|</span><label class="collapse" for="c-39555620">[-]</label><label class="expand" for="c-39555620">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a nice idea, but it&#x27;s hard to do. One person is using VIM, another is using emacs, another is using QTCreator, another primarily edits in VSCode.. Trying to get everyone on the same page about all this is very, very hard.<p>I must have missed the memo where I could just say no to basic things my boss requires of me. You know, the guy that pays my salary.</div><br/></div></div><div id="39551921" class="c"><input type="checkbox" id="c-39551921" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39555620">prev</a><span>|</span><a href="#39551820">next</a><span>|</span><label class="collapse" for="c-39551921">[-]</label><label class="expand" for="c-39551921">[5 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; It&#x27;s a nice idea, but it&#x27;s hard to do. One person is using VIM, another is using emacs, another is using QTCreator, another primarily edits in VSCode.. Trying to get everyone on the same page about all this is very, very hard.<p>This is what&#x27;s wrong with our industry, and it&#x27;s  no longer an acceptable answer. We&#x27;re supposed to be fucking professional, and if a job needs to build a tool chain from the IDE up we need to learn to use it and live with it.<p>Built on my machine, with my IDE, the way I like it and it works is not software. It&#x27;s arts and fucking crafts.</div><br/><div id="39559832" class="c"><input type="checkbox" id="c-39559832" checked=""/><div class="controls bullet"><span class="by">otabdeveloper4</span><span>|</span><a href="#39551683">root</a><span>|</span><a href="#39551921">parent</a><span>|</span><a href="#39553728">next</a><span>|</span><label class="collapse" for="c-39559832">[-]</label><label class="expand" for="c-39559832">[1 more]</label></div><br/><div class="children"><div class="content">&gt; every single carpenter in the world should use the exact same make and model of saw, for, uh, professionalism reasons</div><br/></div></div><div id="39553728" class="c"><input type="checkbox" id="c-39553728" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#39551683">root</a><span>|</span><a href="#39551921">parent</a><span>|</span><a href="#39559832">prev</a><span>|</span><a href="#39551820">next</a><span>|</span><label class="collapse" for="c-39553728">[-]</label><label class="expand" for="c-39553728">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re saying everyone should agree on the same IDE and personal development toolset, I disagree, sort of.<p>The GP was suggesting the effort to add CI, linters, fuzzing, auto-formatting, etc was too hard.
If that can be abandoned entirely, perhaps the legacy codebase isn&#x27;t providing enough value,
and the effort to maintain it would be better spent replacing it.
But the implication is that the value outweighs the costs.<p>Put all the linters, fuzzing, and format checking in an automated build toolchain.
Allow individuals to work how they want, except they can&#x27;t break the build.
Usually this will reign in the edge cases using inadequate tools.
The &quot;built on my machine, with my IDE, the way I like it and it works&quot; is no longer the arbiter of correct,
but neither does the organization have to deal with the endless yak shaving over brace style and tool choice.</div><br/><div id="39555887" class="c"><input type="checkbox" id="c-39555887" checked=""/><div class="controls bullet"><span class="by">eropple</span><span>|</span><a href="#39551683">root</a><span>|</span><a href="#39553728">parent</a><span>|</span><a href="#39551820">next</a><span>|</span><label class="collapse" for="c-39555887">[-]</label><label class="expand" for="c-39555887">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; neither does the organization have to deal with the endless yak shaving over brace style and tool choice</i><p>I hear you, but an organization that fears this, instead of Just Pick Something And Deal With It, is an organization that probably doesn&#x27;t have the right people in it to succeed at any task more arduous than that.</div><br/><div id="39558966" class="c"><input type="checkbox" id="c-39558966" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#39551683">root</a><span>|</span><a href="#39555887">parent</a><span>|</span><a href="#39551820">next</a><span>|</span><label class="collapse" for="c-39558966">[-]</label><label class="expand" for="c-39558966">[1 more]</label></div><br/><div class="children"><div class="content">Conversely, and organization that imposes arbitrary choices and isn&#x27;t capable of allowing people do use the tools they know best probably doesn&#x27;t attract the best people. There are many different kinds of hammers, and making everyone who uses hammers use the same kind is, to say the least, counter productive.</div><br/></div></div></div></div></div></div></div></div><div id="39551820" class="c"><input type="checkbox" id="c-39551820" checked=""/><div class="controls bullet"><span class="by">aaronbrethorst</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39551921">prev</a><span>|</span><a href="#39558550">next</a><span>|</span><label class="collapse" for="c-39551820">[-]</label><label class="expand" for="c-39551820">[1 more]</label></div><br/><div class="children"><div class="content">An optional step locally like pre-commit hooks should be backed up by a required step in the CI. In other words: the ability to run tests locally, lint, fuzz, format, verify Yaml format, check for missing EOF new lines, etc, should exist to help a developer prevent a CI failure before they push.<p>As far as linters causing thousands of warnings to appear on opening the project, the developer adding the linter should make sure that the linter returns no warnings before they merge that change. This can be accomplished by disabling the linter for some warnings, some files, making some fixes, or some combination of the above.</div><br/></div></div><div id="39558550" class="c"><input type="checkbox" id="c-39558550" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39551820">prev</a><span>|</span><a href="#39556828">next</a><span>|</span><label class="collapse" for="c-39558550">[-]</label><label class="expand" for="c-39558550">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s dangerous for multiple reasons. Mainly it&#x27;s a case of Chesterton&#x27;s fence. Unless you fully understand why X was in the software...<p>If this is a function that no one links to, and your project does not mess with manual dynamic linking (or the function is not exposed), then it&#x27;s pretty safe to remove it. If it&#x27;s internal utility which does not get packaged into final release package, it is likely be safe to remove too. If it&#x27;s a program which does not compile because it requires Solaris STREAMS and your targets are Linux + MacOS - kill it with fire.<p>(Of course removing function calls, or removing functionality that in-use code depends on, is dangerous. But there is plenty of stuff which has no connection to main code)</div><br/></div></div><div id="39556828" class="c"><input type="checkbox" id="c-39556828" checked=""/><div class="controls bullet"><span class="by">Kamq</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39558550">prev</a><span>|</span><a href="#39555208">next</a><span>|</span><label class="collapse" for="c-39556828">[-]</label><label class="expand" for="c-39556828">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a nice idea, but it&#x27;s hard to do. One person is using VIM, another is using emacs, another is using QTCreator, another primarily edits in VSCode.. Trying to get everyone on the same page about all this is very, very hard.<p>Bullshit, all of these (and additionally C lion) are fairly easy to configure these for, with the possible exception of QTCreator (not a ton of experience on my end).<p>Just make it a CI requirement, and let everyone figure it out for their own tools. If you can&#x27;t figure that out, you get to run it as a shell script before you do your PRs. If you can&#x27;t figure that out, you probably shouldn&#x27;t be on a legacy C++ project.</div><br/></div></div><div id="39555208" class="c"><input type="checkbox" id="c-39555208" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#39551683">parent</a><span>|</span><a href="#39556828">prev</a><span>|</span><a href="#39551164">next</a><span>|</span><label class="collapse" for="c-39555208">[-]</label><label class="expand" for="c-39555208">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One person is using VIM, ...<p>I don&#x27;t get your point. You know you can autoformat outside editors right? Just configure pre-commit and run it in CI. It&#x27;s trivial.<p>&gt; If it&#x27;s an optional step that requires that they install something new (like commit hook) it&#x27;s just not going to happen.<p>It will because if they don&#x27;t then their PRs will fail CI.<p>This is really basic stuff, but knowledge of how to do CI and infra right does seem to vary massively.</div><br/></div></div></div></div><div id="39551164" class="c"><input type="checkbox" id="c-39551164" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39551683">prev</a><span>|</span><a href="#39557642">next</a><span>|</span><label class="collapse" for="c-39551164">[-]</label><label class="expand" for="c-39551164">[23 more]</label></div><br/><div class="children"><div class="content">It&#x27;s funny. My first step would be<p><pre><code>  0. You reach out to the previous maintainers, visit them, buy them tea&#x2F;beer and chat (eventually) about the codebase. Learned Wizards will teach you much.
</code></pre>
But I didn&#x27;t see that anywhere. I think the rest of the suggestions (like get it running across platform, get tests passing) are useful stress tests likely to lead you to robustness and understanding however.<p>But I&#x27;d def be going for that sweeet, sweet low-hangin&#x27; fruit of just talking to the ol&#x27; folks who came that way before. Haha :)</div><br/><div id="39551861" class="c"><input type="checkbox" id="c-39551861" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#39551164">parent</a><span>|</span><a href="#39559431">next</a><span>|</span><label class="collapse" for="c-39551861">[-]</label><label class="expand" for="c-39551861">[3 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t make it the first step. If you do, you will probably waste their time more than anything.<p>Try to work on it a little bit first, and once you get stuck in various places, now you can talk to the previous maintainers, it will be much more productive. They will also appreciate the effort.</div><br/><div id="39558857" class="c"><input type="checkbox" id="c-39558857" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551861">parent</a><span>|</span><a href="#39556280">next</a><span>|</span><label class="collapse" for="c-39558857">[-]</label><label class="expand" for="c-39558857">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, that&#x27;s fair enough. I guess since we&#x27;re already zero-indexed maybe my -1 step is Prep. Hahaha! :)</div><br/></div></div><div id="39556280" class="c"><input type="checkbox" id="c-39556280" checked=""/><div class="controls bullet"><span class="by">guhidalg</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551861">parent</a><span>|</span><a href="#39558857">prev</a><span>|</span><a href="#39559431">next</a><span>|</span><label class="collapse" for="c-39556280">[-]</label><label class="expand" for="c-39556280">[1 more]</label></div><br/><div class="children"><div class="content">There’s a fine balance with no right or wrong answer. Previous maintainers will appreciate if you spent literally more than a second trying to understand before you reach out to them, but for your own sanity you should know when it’s time to stop and call for help.</div><br/></div></div></div></div><div id="39559431" class="c"><input type="checkbox" id="c-39559431" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#39551164">parent</a><span>|</span><a href="#39551861">prev</a><span>|</span><a href="#39552676">next</a><span>|</span><label class="collapse" for="c-39559431">[-]</label><label class="expand" for="c-39559431">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s funny. My first step would be<p>&gt;         0. You reach out to the previous maintainers, visit them, buy them tea&#x2F;beer and chat (eventually) about the codebase. Learned Wizards will teach you much.<p>Have you ever tried that? This is <i>legacy</i> code. Even if the handover was yesterday, they cannot tell you about anything useful they did more than 6m in the past.<p>And that&#x27;s the best-case scenario. The common-case is &quot;That&#x27;s the way I got it when it was handed over to me&quot; answer to every question you ask.</div><br/></div></div><div id="39552676" class="c"><input type="checkbox" id="c-39552676" checked=""/><div class="controls bullet"><span class="by">theamk</span><span>|</span><a href="#39551164">parent</a><span>|</span><a href="#39559431">prev</a><span>|</span><a href="#39551235">next</a><span>|</span><label class="collapse" for="c-39552676">[-]</label><label class="expand" for="c-39552676">[3 more]</label></div><br/><div class="children"><div class="content">Maybe do a quick look at codebase first so you can identify biggest WTF&#x27;s and ask about them.<p>After all, if you have inherited a codebase with no tests, with build process which fails every other time, with unknown dependency info, and which can only be built on a single server with severely outdated OS... are you sure the previous maintainer is a real wizard and all the problems are result of not enough time? Or are they a &quot;wizard&quot; who keep things broken for job security and&#x2F;or because they don&#x27;t want to learn new things?</div><br/><div id="39559939" class="c"><input type="checkbox" id="c-39559939" checked=""/><div class="controls bullet"><span class="by">vaylian</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39552676">parent</a><span>|</span><a href="#39558860">next</a><span>|</span><label class="collapse" for="c-39559939">[-]</label><label class="expand" for="c-39559939">[1 more]</label></div><br/><div class="children"><div class="content">Even if that person is not a great archwizard, they still have more experience in that project than you and you will probably learn some things that will make your life less miserable, because you will better understand what to expect and what kind of failed solutions have been tried before.</div><br/></div></div><div id="39558860" class="c"><input type="checkbox" id="c-39558860" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39552676">parent</a><span>|</span><a href="#39559939">prev</a><span>|</span><a href="#39551235">next</a><span>|</span><label class="collapse" for="c-39558860">[-]</label><label class="expand" for="c-39558860">[1 more]</label></div><br/><div class="children"><div class="content">Yes! Good idea. Locking in at -1. Hahah! :)</div><br/></div></div></div></div><div id="39551235" class="c"><input type="checkbox" id="c-39551235" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#39551164">parent</a><span>|</span><a href="#39552676">prev</a><span>|</span><a href="#39551421">next</a><span>|</span><label class="collapse" for="c-39551235">[-]</label><label class="expand" for="c-39551235">[10 more]</label></div><br/><div class="children"><div class="content">IME, this only works if you can get <i>regular</i> help from them. A one-off won&#x27;t help much at all.</div><br/><div id="39551796" class="c"><input type="checkbox" id="c-39551796" checked=""/><div class="controls bullet"><span class="by">mellutussa</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551235">parent</a><span>|</span><a href="#39551554">next</a><span>|</span><label class="collapse" for="c-39551796">[-]</label><label class="expand" for="c-39551796">[6 more]</label></div><br/><div class="children"><div class="content">&gt; A one-off won&#x27;t help much at all.<p>Monumentally disagree. 
One-off session with a guy who knows the codebase inside out can save you days of research work. Plus telling you all about the problematic&#x2F;historical areas.</div><br/><div id="39552007" class="c"><input type="checkbox" id="c-39552007" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551796">parent</a><span>|</span><a href="#39558864">next</a><span>|</span><label class="collapse" for="c-39552007">[-]</label><label class="expand" for="c-39552007">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m just stating my experience. A single day, <i>if they still have access to the codebase</i> might be able to clear up some top-level concepts.<p>But the devil is in all the tiny details. What is this tiny correction factor that was added 20 years ago? Why was this value cut off to X decimals? Why didn&#x27;t they just do Y here? Why do we override this default behavior?<p>It&#x27;s tens of thousands of tiny questions like that which you can&#x27;t ask until you&#x27;re there.</div><br/><div id="39555820" class="c"><input type="checkbox" id="c-39555820" checked=""/><div class="controls bullet"><span class="by">slingnow</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39552007">parent</a><span>|</span><a href="#39558864">next</a><span>|</span><label class="collapse" for="c-39555820">[-]</label><label class="expand" for="c-39555820">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand what you&#x27;re saying. Clearly both types of meetings (one-off vs recurring) would be helpful. The one-off may save you days&#x2F;weeks of research, but it seems like you&#x27;re not satisfied with that unless you can answer every single minor question you might have across the entire codebase.</div><br/><div id="39558427" class="c"><input type="checkbox" id="c-39558427" checked=""/><div class="controls bullet"><span class="by">Night_Thastus</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39555820">parent</a><span>|</span><a href="#39558864">next</a><span>|</span><label class="collapse" for="c-39558427">[-]</label><label class="expand" for="c-39558427">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m saying that if you&#x27;re maintaining a code base for years, a single day&#x27;s explanations won&#x27;t do much of anything. It&#x27;s a drop in the bucket.<p>It&#x27;s not a bad thing, and it&#x27;s certainly good to do, but it&#x27;s not a solution to the problem.</div><br/><div id="39559476" class="c"><input type="checkbox" id="c-39559476" checked=""/><div class="controls bullet"><span class="by">mellutussa</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39558427">parent</a><span>|</span><a href="#39558864">next</a><span>|</span><label class="collapse" for="c-39559476">[-]</label><label class="expand" for="c-39559476">[1 more]</label></div><br/><div class="children"><div class="content">If your granularity for a task is measured in years then you have a much different and harder problem.<p>Effectively everything becomes a &quot;drop in the bucket&quot;.</div><br/></div></div></div></div></div></div></div></div><div id="39558864" class="c"><input type="checkbox" id="c-39558864" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551796">parent</a><span>|</span><a href="#39552007">prev</a><span>|</span><a href="#39551554">next</a><span>|</span><label class="collapse" for="c-39558864">[-]</label><label class="expand" for="c-39558864">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. Someone to guide you in the right path. Gonna help a lot! Hahaha :)</div><br/></div></div></div></div><div id="39551554" class="c"><input type="checkbox" id="c-39551554" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551235">parent</a><span>|</span><a href="#39551796">prev</a><span>|</span><a href="#39551767">next</a><span>|</span><label class="collapse" for="c-39551554">[-]</label><label class="expand" for="c-39551554">[1 more]</label></div><br/><div class="children"><div class="content">Yeah you need to cultivate those relationships. But with a willing partner that first session will take you from <i>0</i> to <i>1</i> :)</div><br/></div></div><div id="39551767" class="c"><input type="checkbox" id="c-39551767" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551235">parent</a><span>|</span><a href="#39551554">prev</a><span>|</span><a href="#39551421">next</a><span>|</span><label class="collapse" for="c-39551767">[-]</label><label class="expand" for="c-39551767">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always found discussing why former employees left a project incredibly enlightening.  They will usually explain the reality behind the PR given they are no longer involved in the politics. Most importantly they will often tell you your best case future with a firm.<p>Normally, employment agreements specifically restrict contact with former staff, or discussions of sensitive matters like compensation packages.<p>C++ is like any other language, in that it will often take 3 times longer to understand something than re-implement the same.  If you are lucky, than everything is a minimal API lib, and you get repetitive examples of the use cases... but the cooperative OSS breadcrumb model almost never happens in commercial shops...<p>Legacy code bases can be hell to work with, as you end up with the responsibility for 14 years of IT kludges.  Also, the opinions from entrenched lamers on what productivity means will be painful at first.<p>Usually, with C++ it can become its own project specific language variant (STL or Boost may help wrangle the chaos).<p>You have my sympathy, but no checklist can help with naive design inertia. Have a wonderful day. =)</div><br/><div id="39558869" class="c"><input type="checkbox" id="c-39558869" checked=""/><div class="controls bullet"><span class="by">keepamovin</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551767">parent</a><span>|</span><a href="#39551421">next</a><span>|</span><label class="collapse" for="c-39558869">[-]</label><label class="expand" for="c-39558869">[1 more]</label></div><br/><div class="children"><div class="content">Uh, yeah, that&#x27;s a great idea, too! That&#x27;s the big question. What happened to the previous team? Can give you org insights as well as code ones. Info on company strategy, priorities, work cadence. Actually a pretty good open ended conversation opener! Hahaha! :)</div><br/></div></div></div></div></div></div><div id="39551421" class="c"><input type="checkbox" id="c-39551421" checked=""/><div class="controls bullet"><span class="by">raverbashing</span><span>|</span><a href="#39551164">parent</a><span>|</span><a href="#39551235">prev</a><span>|</span><a href="#39557642">next</a><span>|</span><label class="collapse" for="c-39551421">[-]</label><label class="expand" for="c-39551421">[5 more]</label></div><br/><div class="children"><div class="content">Easier said than done<p>My step 0 would be: run it through an UML tool to get a class diagram and other diagrams.<p>This will help you <i>a lot</i>.<p>&gt; Get the tests passing on your machine<p>Tests? On a C++ codebase? I like your optimism, rs</div><br/><div id="39551812" class="c"><input type="checkbox" id="c-39551812" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551421">parent</a><span>|</span><a href="#39557642">next</a><span>|</span><label class="collapse" for="c-39551812">[-]</label><label class="expand" for="c-39551812">[4 more]</label></div><br/><div class="children"><div class="content">No one has time to maintain the UML in production.<p>You may luck out with auto-generated documentation, but few use these tools properly (javadoc or doxygen). =)</div><br/><div id="39552078" class="c"><input type="checkbox" id="c-39552078" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39551812">parent</a><span>|</span><a href="#39557642">next</a><span>|</span><label class="collapse" for="c-39552078">[-]</label><label class="expand" for="c-39552078">[3 more]</label></div><br/><div class="children"><div class="content">The GP said nothing about keeping and maintaining it, only generating it. Use it to understand the codebase, then archive it or throw it out.</div><br/><div id="39552271" class="c"><input type="checkbox" id="c-39552271" checked=""/><div class="controls bullet"><span class="by">Jtsummers</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39552078">parent</a><span>|</span><a href="#39557642">next</a><span>|</span><label class="collapse" for="c-39552271">[-]</label><label class="expand" for="c-39552271">[2 more]</label></div><br/><div class="children"><div class="content">Exactly. You inherited 500k SLOC of C++ that grew together since 1985. You don&#x27;t know the interconnections between the classes that have accumulated in that time. It was also developed by multiple teams, and likely had very different approaches to OO during these past nearly 40 years. The UML diagrams won&#x27;t tell you everything, but they will tell you things like the inheritance hierarchy (if this was a 1990s C++ project it&#x27;s probably pretty nasty), what classes are referenced by others via member variables, etc. This can be hugely informative when you want to transform a program into something saner.</div><br/><div id="39552710" class="c"><input type="checkbox" id="c-39552710" checked=""/><div class="controls bullet"><span class="by">Joel_Mckay</span><span>|</span><a href="#39551164">root</a><span>|</span><a href="#39552271">parent</a><span>|</span><a href="#39557642">next</a><span>|</span><label class="collapse" for="c-39552710">[-]</label><label class="expand" for="c-39552710">[1 more]</label></div><br/><div class="children"><div class="content">I always interpreted most polymorphism as sloppy context-specific state-machine embedding, and fundamentally an unmaintainable abomination from OOP paradigms.<p>OO requires a lot of planning to get right (again, no shop will give your team time to do this properly), and in practice it usually degenerates into spiral development rather quickly (&lt;2 years). Thus, 14 years later what you think you see in documentation may be completely different from the conditional recursive definition some clown left for your team (yes, it happens eventually...)<p>500k lines is not that bad if most of it is encapsulated libraries... =)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39557642" class="c"><input type="checkbox" id="c-39557642" checked=""/><div class="controls bullet"><span class="by">summerlight</span><span>|</span><a href="#39551164">prev</a><span>|</span><a href="#39559002">next</a><span>|</span><label class="collapse" for="c-39557642">[-]</label><label class="expand" for="c-39557642">[2 more]</label></div><br/><div class="children"><div class="content">This thread has lots of good advice. I&#x27;ll add some of mine, not limited to C&#x2F;C++. If you have luxury of using VCS, make a full use of its value. Many teams only use it as a tool merely for collaboration. VCS can be more than that.  Pull the history then build a simple database. It doesn&#x27;t have to be an RDB (it&#x27;s helpful though); a simple JSON file or even a spreadsheet file is a good starter. There are so many valuable information to be fetched with just a simple data driven approach, almost immediately.<p><pre><code>  * You can find out the most relevant files&#x2F;functions for your upcoming works. If some functions&#x2F;files have been frequently changed, then it&#x27;s going to be the hot spot for your works. Focus on them to improve your quality of life. If you want to introduce unit tests? Then focus on the hot spot. Suffer from lots of merge conflicts? The same.
  * You can also figure out correlation among the project and its source files. Some seemingly distant files are frequently changed together? Those might suggest an implicit structure that not might be clear from the code itself. This kind of information from external contexts can be useful to understand the bird&#x27;s eye view.
  * Real ownership models of each module can be inferred from the history. Having a clear ownership model helps, especially if you want to introduce some form of code review. If some code&#x2F;data&#x2F;module seems to have unclear ownership? That might be a signal for refactoring needs.
  * Specific to C&#x2F;C++ contexts, build time improvements could be focused on important modules, in a data driven way. Incremental build time matters a lot. Break down frequently changed modules rather than blindly removing dependencies on random files. You can even combine this with header dependency to score the module with the real build time impact. 
</code></pre>
There could be so many other things if you can integrate other development tools with VCS. In the era of LLM, I guess we can even try to feed the project history and metadata to the model and ask for some interesting insights, though I haven&#x27;t tried this. It might need some dedicated model engineering if we want to do this without a huge context window but my guts tell that this should be something worth try.</div><br/><div id="39558207" class="c"><input type="checkbox" id="c-39558207" checked=""/><div class="controls bullet"><span class="by">bostonvaulter2</span><span>|</span><a href="#39557642">parent</a><span>|</span><a href="#39559002">next</a><span>|</span><label class="collapse" for="c-39558207">[-]</label><label class="expand" for="c-39558207">[1 more]</label></div><br/><div class="children"><div class="content">Nice ideas! Do you have any tips for software to help automate some of those analyses?</div><br/></div></div></div></div><div id="39559002" class="c"><input type="checkbox" id="c-39559002" checked=""/><div class="controls bullet"><span class="by">ilitirit</span><span>|</span><a href="#39557642">prev</a><span>|</span><a href="#39559307">next</a><span>|</span><label class="collapse" for="c-39559002">[-]</label><label class="expand" for="c-39559002">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve had to do this several times in the past. Honestly, my best advice would probably be make several backups, then to do as little as possible. If you need to make a small change, fine. Bigger changes? Consider if you can&#x27;t do the bulk of the work in a technology or stack <i>you understand</i> and only make a small change to the legacy code base.<p>Most of the time I spend with C++ code revolves around figuring out compile&#x2F;link errors. Heaven forbid you need to deal with non-portable `make` files that for some reason work on the old box, but not yours... Oh, and I hope you have a ton of spare space because of some reason building a 500k exe takes 4GB.<p>Keep in mind, this advice only applies to <i>inherited</i> C++ code bases. If you&#x27;ve written your own or are working on an actively maintained project these are non-issues. Sort-of.</div><br/></div></div><div id="39559307" class="c"><input type="checkbox" id="c-39559307" checked=""/><div class="controls bullet"><span class="by">rurban</span><span>|</span><a href="#39559002">prev</a><span>|</span><a href="#39552133">next</a><span>|</span><label class="collapse" for="c-39559307">[-]</label><label class="expand" for="c-39559307">[1 more]</label></div><br/><div class="children"><div class="content">I just went this very same dance with an old project, smart, which evaluates string matching algorithms. Faster strstr(). From 2013. It was in a better shape than zlib, but still.<p>Their shell build script was called makefile, kid me not. So first create a proper dependency management: GNUmakefile. A BSD makefile would have been prettier, but not many are used to this.
dos2unix, chmod -x `find . -name *.c -o name *\.h`, clang-format -i
All in seperate commits.<p>Turns out there was a .h file not a header, but some custom list of algorithm states, broken by fmt. Dontg do that. Either keep it a header file, or rename it to .lst or such.<p>Fix all the warnings, hundreds.
Check with sanitizers.
Check the tests, disable broken algorithms, and mark them as such.<p>Improve the codebase. There are lots of hints of thought about features. write them. Simplify the state handling. Improve the tests.<p>Add make check lint.
Check all the linter warnings.<p>Add a CI. Starting with Linux, Windows mingw, macos and aarch64. Turns out the code is Linux x64 only, ha. Make it compat with sse checks, windows quirks.<p>Waiting for GH actions suck, write Dockerfiles and qemu drivers into your makefile. Maybe automake would have been a better idea after all. Or even proper autoconf.<p>Find the missing algorithms described elsewhere. Add them. Check their limitations.<p>Reproducible builds? Not for this one, sorry. This is luxury. Rather check clang-tidy, and add fuzzing.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;smart">https:&#x2F;&#x2F;github.com&#x2F;rurban&#x2F;smart</a></div><br/></div></div><div id="39552133" class="c"><input type="checkbox" id="c-39552133" checked=""/><div class="controls bullet"><span class="by">bArray</span><span>|</span><a href="#39559307">prev</a><span>|</span><a href="#39555823">next</a><span>|</span><label class="collapse" for="c-39552133">[-]</label><label class="expand" for="c-39552133">[2 more]</label></div><br/><div class="children"><div class="content">&gt; 3. Make the project enter the 21st century by adding CI, linters, fuzzing, auto-formatting, etc<p>I would break this down:<p>a) CI - Ensure not just you can build this, but it can be built elsewhere too. This should prevent compile-based regressions.<p>b) Compiler warnings and static analysers - They are likely both smarter than you. When it says &quot;warning, you&#x27;re doing weird things with a pointer and it scares me&quot;, it&#x27;s a good indication you should go check it out.<p>c) Unit testing - Set up a series of tests for important parts of the code to ensure it performs precisely the task you expect it to, all the way down to the low level. There&#x27;s a really good chance it doesn&#x27;t, and you need to understand why. Fixing something could cause something else to blow up as it was written around this bugged code. You also end up with a series of regression tests for the most important code.<p>n) Auto-formatting - Not a priority. You should adopt the same style as the original maintainer.<p>&gt; 5. If you can, contemplate rewrite some parts in a memory safe language<p>The last step of an inherited C++ codebase is to rewrite it in a memory safe language? A few reasons why this probably won&#x27;t work:<p>1. Getting resources to do additional work on something that isn&#x27;t broken can be difficult.<p>2. Rather than just needing knowledge in C++, you now also need knowledge in an additional language too.<p>3. Your testing potentially becomes more complex.<p>4. Your project likely won&#x27;t lend itself to being written in multiple languages, due to memory&#x2F;performance constraints. It must be a significantly hard problem that you didn&#x27;t just write it yourself.<p>5. You have chosen to inherit a legacy codebase rather than write something from scratch. It&#x27;s an admittance that you don&#x27;t have some resource (time&#x2F;money&#x2F;knowledge&#x2F;etc) to do so.</div><br/><div id="39559755" class="c"><input type="checkbox" id="c-39559755" checked=""/><div class="controls bullet"><span class="by">jpc0</span><span>|</span><a href="#39552133">parent</a><span>|</span><a href="#39555823">next</a><span>|</span><label class="collapse" for="c-39559755">[-]</label><label class="expand" for="c-39559755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The last step of an inherited C++ codebase is to rewrite it in a memory safe language<p>Simply getting rid of any actually memory unsafe C++ and enforcing guidelines will do this for you in the C++ codebase.<p>&quot;Rewrite it in X&quot; only adds complexity because it&#x27;s the flavour of the month as you said in your comment.<p>Author is already doing the work of rewriting large chunks of the codebase in C++, they may as well follow and implement a more restrictive subset of the language, I find High integrity C++ to be good. If I can get my hands on the latest MISRA standard that is likely good as well. These may not be &quot;required&quot; but they specify what is enforced in &lt;enter &quot;safe&quot; language here&gt;. So instead of having to reskill your entire devteam on a new language which has many many sharp edges, how about just having your dev team use the language they already know and enforce guidelines to avoid known footguns.</div><br/></div></div></div></div><div id="39555823" class="c"><input type="checkbox" id="c-39555823" checked=""/><div class="controls bullet"><span class="by">Kon-Peki</span><span>|</span><a href="#39552133">prev</a><span>|</span><a href="#39551934">next</a><span>|</span><label class="collapse" for="c-39555823">[-]</label><label class="expand" for="c-39555823">[1 more]</label></div><br/><div class="children"><div class="content">The article doesn&#x27;t mention anything about global variables, but reducing&#x2F;eliminating them would be a high priority for me.<p>The approach I&#x27;ve taken is, when you do work on a function and find that it uses a global variable, try to add the GV as a function parameter (and update the calling sites).  Even if it&#x27;s just a pointer to the global variable, you now have another function that is more easily testable.  Eventually you can get to the point where the GV can be trivially changed to a local variable somewhere appropriate.</div><br/></div></div><div id="39551934" class="c"><input type="checkbox" id="c-39551934" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39555823">prev</a><span>|</span><a href="#39556547">next</a><span>|</span><label class="collapse" for="c-39551934">[-]</label><label class="expand" for="c-39551934">[6 more]</label></div><br/><div class="children"><div class="content">I enjoyed the article and learned something. But I&#x27;ve been wondering: When people say &quot;rewrite in a memory-safe language&quot;, what languages are they suggesting? Is this author rewriting parts in Go, Java, C#? Or is it just a smirky, plausibly deniable way of saying to rewrite it in Rust?</div><br/><div id="39552917" class="c"><input type="checkbox" id="c-39552917" checked=""/><div class="controls bullet"><span class="by">broken_broken_</span><span>|</span><a href="#39551934">parent</a><span>|</span><a href="#39554882">next</a><span>|</span><label class="collapse" for="c-39552917">[-]</label><label class="expand" for="c-39552917">[2 more]</label></div><br/><div class="children"><div class="content">Author here, thanks! A second article will cover this, but the bottom line is that it entirely depends on the team and the constraints e.g. is a GC an option (then Go is a good option), is security the highest priority, etc.<p>I’d say that most C++ developers will generally have an easy time using Rust and will get equivalent performance.<p>But sometimes the project did not have a good reason to be in C++ in the first place and I’ve seen successful rewrites in Java for example.<p>Apple is rewriting some C++ code in Swift, etc. So, the language the team&#x2F;company is comfortable with is a good rule of thumb.</div><br/><div id="39553325" class="c"><input type="checkbox" id="c-39553325" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39551934">root</a><span>|</span><a href="#39552917">parent</a><span>|</span><a href="#39554882">next</a><span>|</span><label class="collapse" for="c-39553325">[-]</label><label class="expand" for="c-39553325">[1 more]</label></div><br/><div class="children"><div class="content">Makes sense, thanks!</div><br/></div></div></div></div><div id="39554882" class="c"><input type="checkbox" id="c-39554882" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39551934">parent</a><span>|</span><a href="#39552917">prev</a><span>|</span><a href="#39557743">next</a><span>|</span><label class="collapse" for="c-39554882">[-]</label><label class="expand" for="c-39554882">[2 more]</label></div><br/><div class="children"><div class="content">So you saw a post about C++, it didn’t mention “Rust” once, mentioned “memory safe” languages which there are <i>dozens</i> of, and yet found a way to shoehorn in a dismissive comment about a meme. Nice.<p>We’ve reached the rewrite-in-rust meme stage of questioning whether the author is a nefarious crypto-Rust programmer in lieu of not being able to complain about it (since it wasn’t brought up!).</div><br/><div id="39558636" class="c"><input type="checkbox" id="c-39558636" checked=""/><div class="controls bullet"><span class="by">bsdpufferfish</span><span>|</span><a href="#39551934">root</a><span>|</span><a href="#39554882">parent</a><span>|</span><a href="#39557743">next</a><span>|</span><label class="collapse" for="c-39558636">[-]</label><label class="expand" for="c-39558636">[1 more]</label></div><br/><div class="children"><div class="content">(author actually shows up to advocate for rust)</div><br/></div></div></div></div></div></div><div id="39556547" class="c"><input type="checkbox" id="c-39556547" checked=""/><div class="controls bullet"><span class="by">hgs3</span><span>|</span><a href="#39551934">prev</a><span>|</span><a href="#39551795">next</a><span>|</span><label class="collapse" for="c-39556547">[-]</label><label class="expand" for="c-39556547">[1 more]</label></div><br/><div class="children"><div class="content">Rewriting is questionable. Joel Spolsky has a famous blog post about this from two decades ago that&#x27;s still relevant today [1].<p>[1] <a href="https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-never-do-part-i&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.joelonsoftware.com&#x2F;2000&#x2F;04&#x2F;06&#x2F;things-you-should-...</a></div><br/></div></div><div id="39551795" class="c"><input type="checkbox" id="c-39551795" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#39556547">prev</a><span>|</span><a href="#39556428">next</a><span>|</span><label class="collapse" for="c-39551795">[-]</label><label class="expand" for="c-39551795">[6 more]</label></div><br/><div class="children"><div class="content">Been there, done that. Don&#x27;t be a code beauty queen. Make it compile and make it run on your machine. Study the basic control-flow graph starting from the entry point and see the relations between source files. Debug it with step-into and see how deep you go. Only then can you gradually start seeing the big picture and any potential improvements.</div><br/><div id="39555496" class="c"><input type="checkbox" id="c-39555496" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39551795">parent</a><span>|</span><a href="#39551944">next</a><span>|</span><label class="collapse" for="c-39555496">[-]</label><label class="expand" for="c-39555496">[1 more]</label></div><br/><div class="children"><div class="content">In my experience it takes at least a year straight working with code before you can form an opinion on if it is beautiful or not. People who have not worked in a code base for that long do not understand what is a beautiful design corrupted by the real world vs what is ugly code. Most code started out with a beautiful design but the real world forced ugly on it - you might be able to improve this a little with full rewrite but the real world will still force a lot of ugly on you.  However some code really is bad.</div><br/></div></div><div id="39551944" class="c"><input type="checkbox" id="c-39551944" checked=""/><div class="controls bullet"><span class="by">johngossman</span><span>|</span><a href="#39551795">parent</a><span>|</span><a href="#39555496">prev</a><span>|</span><a href="#39556428">next</a><span>|</span><label class="collapse" for="c-39551944">[-]</label><label class="expand" for="c-39551944">[4 more]</label></div><br/><div class="children"><div class="content">Absolutely. Read the code. Step through with a debugger. Fix obvious bugs. If it’s legacy and somebody is still paying to have it worked on, it must mostly work. Changing things for “cleanliness and modernization” is likely to break it.</div><br/><div id="39552095" class="c"><input type="checkbox" id="c-39552095" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#39551795">root</a><span>|</span><a href="#39551944">parent</a><span>|</span><a href="#39556428">next</a><span>|</span><label class="collapse" for="c-39552095">[-]</label><label class="expand" for="c-39552095">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Fix obvious bugs.<p>Be careful about that. Hyrum&#x27;s Law and all.</div><br/><div id="39556972" class="c"><input type="checkbox" id="c-39556972" checked=""/><div class="controls bullet"><span class="by">johngossman</span><span>|</span><a href="#39551795">root</a><span>|</span><a href="#39552095">parent</a><span>|</span><a href="#39556428">next</a><span>|</span><label class="collapse" for="c-39556972">[-]</label><label class="expand" for="c-39556972">[2 more]</label></div><br/><div class="children"><div class="content">Should have been clearer. You’ve probably been put on the project because something isn’t working. Fix the simplest, most obvious of these. Fixing a bug is a good way to learn.</div><br/><div id="39558980" class="c"><input type="checkbox" id="c-39558980" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#39551795">root</a><span>|</span><a href="#39556972">parent</a><span>|</span><a href="#39556428">next</a><span>|</span><label class="collapse" for="c-39558980">[-]</label><label class="expand" for="c-39558980">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  You’ve probably been put on the project because something isn’t working.<p>Perhaps if it&#x27;s a change requested by the organization or the users. Just don&#x27;t go &quot;fixing&quot; things that look like bugs without knowing if it&#x27;s really a bug or expected behavior.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39556428" class="c"><input type="checkbox" id="c-39556428" checked=""/><div class="controls bullet"><span class="by">pvarangot</span><span>|</span><a href="#39551795">prev</a><span>|</span><a href="#39554494">next</a><span>|</span><label class="collapse" for="c-39556428">[-]</label><label class="expand" for="c-39556428">[1 more]</label></div><br/><div class="children"><div class="content">Besides what everyone else told you make sure you are making at least 250k&#x2F;y</div><br/></div></div><div id="39554494" class="c"><input type="checkbox" id="c-39554494" checked=""/><div class="controls bullet"><span class="by">VyseofArcadia</span><span>|</span><a href="#39556428">prev</a><span>|</span><a href="#39556162">next</a><span>|</span><label class="collapse" for="c-39554494">[-]</label><label class="expand" for="c-39554494">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Get out the chainsaw and rip out everything that’s not absolutely required to provide the features your company&#x2F;open source project is advertising and selling<p>Except every legacy C++ codebase I&#x27;ve worked on is decades old. Just enumerating the different &quot;features&quot; is a fool&#x27;s errand. Because of reshuffling and process changes, even marketing doesn&#x27;t have a complete list of our &quot;features&quot;. And even it there was a complete list of features, we have too many customers that rely on spacebar heating[0] to just remove code that we think doesn&#x27;t map to a feature.<p>That&#x27;s <i>if</i> we can even tease apart which bits of code map to a feature. It&#x27;s not like we only added brand new code for each feature. We also relied on and modified existing code. The only code that&#x27;s &quot;safe&quot; to remove is dead code, and sometimes that&#x27;s not as dead as you might think.<p>Even <i>if</i> we had a list of features and even <i>if</i> code mapped cleanly to features, the idea of removing all code not related to &quot;features your company is advertising or selling&quot; is absurd. Sometimes a feature is so widely used that you don&#x27;t advertise it anymore. It&#x27;s just there. Should Microsoft remove boldface text from Word because they&#x27;re not actively advertising it?<p>The only way this makes sense is if the author and I have wildly different ideas about what &quot;legacy&quot; means.<p>[0] <a href="https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;" rel="nofollow">https:&#x2F;&#x2F;xkcd.com&#x2F;1172&#x2F;</a></div><br/><div id="39557338" class="c"><input type="checkbox" id="c-39557338" checked=""/><div class="controls bullet"><span class="by">Palomides</span><span>|</span><a href="#39554494">parent</a><span>|</span><a href="#39556162">next</a><span>|</span><label class="collapse" for="c-39557338">[-]</label><label class="expand" for="c-39557338">[1 more]</label></div><br/><div class="children"><div class="content">hard agree<p>removing a feature is possibly the most politically intractable thing you can try to do with a legacy codebase, almost never worth trying</div><br/></div></div></div></div><div id="39556162" class="c"><input type="checkbox" id="c-39556162" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#39554494">prev</a><span>|</span><a href="#39551468">next</a><span>|</span><label class="collapse" for="c-39556162">[-]</label><label class="expand" for="c-39556162">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So what do I recommend? Well, the good old git submodules and compiling from source approach.=<p>It is strange that the author complains so much about automating BOMs, package versioning, dependency sources, etc, and then proceeds to suggest git submodules as superior to package managers.<p>The author needs to try vcpkg before making these criticisms; almost all of these are straightforwardly satisfied with vcpkg, barring a few sharp edges (updating dependencies is a little harder than with git submodules, but that&#x27;s IMO a feature and not a bug—dependencies are built in individual sandboxes which are then installed to a specified directory. vcpkg can set internal repositories as the registry instead of the official one, thus maintaining the &#x27;vendored in&#x27; aspect. vcpkg can chainload toolchains to compile everything with a fixed set of flags, and allows users to specify per-port customisations.<p>These are useful abstractions and it&#x27;s why package managers are so popular, rather than having everyone deal with veritable bedsheets&#x27; worth of strings containing compile flags, macros, warnings, etc.</div><br/></div></div><div id="39551468" class="c"><input type="checkbox" id="c-39551468" checked=""/><div class="controls bullet"><span class="by">sjc02060</span><span>|</span><a href="#39556162">prev</a><span>|</span><a href="#39551853">next</a><span>|</span><label class="collapse" for="c-39551468">[-]</label><label class="expand" for="c-39551468">[4 more]</label></div><br/><div class="children"><div class="content">A good read. We recently did &quot;Rewrite in a memory safe language?&quot; successfully. It was something that shouldn&#x27;t have been written in C++ in the first place (it was never performance sensitive).</div><br/><div id="39554611" class="c"><input type="checkbox" id="c-39554611" checked=""/><div class="controls bullet"><span class="by">jstimpfle</span><span>|</span><a href="#39551468">parent</a><span>|</span><a href="#39557378">next</a><span>|</span><label class="collapse" for="c-39554611">[-]</label><label class="expand" for="c-39554611">[1 more]</label></div><br/><div class="children"><div class="content">Probably not a project spanning more than 3 decades of development and millions of lines of code?</div><br/></div></div><div id="39557378" class="c"><input type="checkbox" id="c-39557378" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39551468">parent</a><span>|</span><a href="#39554611">prev</a><span>|</span><a href="#39552013">next</a><span>|</span><label class="collapse" for="c-39557378">[-]</label><label class="expand" for="c-39557378">[1 more]</label></div><br/><div class="children"><div class="content">Do you have a public write-up (blog post)?  If yes, you should post it on HN.  It would probably generate lots of interesting conversation.</div><br/></div></div><div id="39552013" class="c"><input type="checkbox" id="c-39552013" checked=""/><div class="controls bullet"><span class="by">tehnub</span><span>|</span><a href="#39551468">parent</a><span>|</span><a href="#39557378">prev</a><span>|</span><a href="#39551853">next</a><span>|</span><label class="collapse" for="c-39552013">[-]</label><label class="expand" for="c-39552013">[1 more]</label></div><br/><div class="children"><div class="content">Would you mind sharing what language you used?</div><br/></div></div></div></div><div id="39551853" class="c"><input type="checkbox" id="c-39551853" checked=""/><div class="controls bullet"><span class="by">sk11001</span><span>|</span><a href="#39551468">prev</a><span>|</span><a href="#39559439">next</a><span>|</span><label class="collapse" for="c-39551853">[-]</label><label class="expand" for="c-39551853">[16 more]</label></div><br/><div class="children"><div class="content">Is it worth getting more into C++ in 2024? Lots of interesting jobs in finance require it but it seems almost impossible to get hired without prior experience (with C++ and in finance).</div><br/><div id="39551916" class="c"><input type="checkbox" id="c-39551916" checked=""/><div class="controls bullet"><span class="by">optimalsolver</span><span>|</span><a href="#39551853">parent</a><span>|</span><a href="#39556274">next</a><span>|</span><label class="collapse" for="c-39551916">[-]</label><label class="expand" for="c-39551916">[14 more]</label></div><br/><div class="children"><div class="content">Yes.<p>I switched from Python to C++ because Cython, Numba, etc. just weren&#x27;t cutting it for my CPU-intensive research needs (program synthesis), and I&#x27;ve never looked back.</div><br/><div id="39552039" class="c"><input type="checkbox" id="c-39552039" checked=""/><div class="controls bullet"><span class="by">sk11001</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39551916">parent</a><span>|</span><a href="#39556274">next</a><span>|</span><label class="collapse" for="c-39552039">[-]</label><label class="expand" for="c-39552039">[13 more]</label></div><br/><div class="children"><div class="content">My question isn&#x27;t whether it&#x27;s a good fit for a specific project, I&#x27;m more interested in whether it&#x27;s a good career choice e.g. can you get a job using C++ without C++ experience; how realistic is it to ramp up on it quickly; whether you&#x27;re likely to end up with some gnarly legacy codebase as described in the OP; is it worth pursuing this direction at all.</div><br/><div id="39555682" class="c"><input type="checkbox" id="c-39555682" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552039">parent</a><span>|</span><a href="#39552561">next</a><span>|</span><label class="collapse" for="c-39555682">[-]</label><label class="expand" for="c-39555682">[2 more]</label></div><br/><div class="children"><div class="content">Modern C++ is the language of choice for high-performance, high-scale data-intensive applications and will remain so for the foreseeable future. This is a class of application for which it is uniquely suited (C and Rust both have significant limitations in this domain). There are other domains like gaming that are also heavily into C++. Avoiding legacy C++ codebases is more about choosing where you work carefully.<p>It goes without saying that if you don&#x27;t like the kinds of applications where C++ excels then it may not be a good career choice because it is not a general purpose language in practice.</div><br/><div id="39557383" class="c"><input type="checkbox" id="c-39557383" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39555682">parent</a><span>|</span><a href="#39552561">next</a><span>|</span><label class="collapse" for="c-39557383">[-]</label><label class="expand" for="c-39557383">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Modern C++ is the language of choice for high-performance, high-scale data-intensive applications<p>&gt; C and Rust both have significant limitations in this domain<p>Rust?  Please provide concrete examples.  I don&#x27;t believe it.</div><br/></div></div></div></div><div id="39552561" class="c"><input type="checkbox" id="c-39552561" checked=""/><div class="controls bullet"><span class="by">TillE</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552039">parent</a><span>|</span><a href="#39555682">prev</a><span>|</span><a href="#39555473">next</a><span>|</span><label class="collapse" for="c-39552561">[-]</label><label class="expand" for="c-39552561">[2 more]</label></div><br/><div class="children"><div class="content">C++ is really a language that you want to specialize in and cultivate years of deep expertise with, rather than having it as one tool in your belt like you can with other languages.<p>That&#x27;s certainly a choice you can make, and modern C++ is generally a pretty good experience to work with. I would hope that there&#x27;s not a ton of active C++ projects which are still mostly using the pre-2011 standard, but who knows.</div><br/><div id="39554624" class="c"><input type="checkbox" id="c-39554624" checked=""/><div class="controls bullet"><span class="by">sgerenser</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552561">parent</a><span>|</span><a href="#39555473">next</a><span>|</span><label class="collapse" for="c-39554624">[-]</label><label class="expand" for="c-39554624">[1 more]</label></div><br/><div class="children"><div class="content">This exactly. It’s a blessing and a curse, because I’d love to move to a “better” language like Rust or even Zig. But with 20+ years of C++ experience I feel like I’d be throwing away too much to avoid C++ completely. Also agreed that modern C++ is pretty decent. Lamenting that I’m back in a codebase that started before C++11 vs my previous job that was greenfield C++14&#x2F;17.</div><br/></div></div></div></div><div id="39555473" class="c"><input type="checkbox" id="c-39555473" checked=""/><div class="controls bullet"><span class="by">stagger87</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552039">parent</a><span>|</span><a href="#39552561">prev</a><span>|</span><a href="#39556727">next</a><span>|</span><label class="collapse" for="c-39555473">[-]</label><label class="expand" for="c-39555473">[1 more]</label></div><br/><div class="children"><div class="content">I would be very surprised if most people actually choose to develop in C++. It&#x27;s a very good language choice for many domains, and I suspect interest and expertise in those domains drives people to C++ more than a desire to program in C++.</div><br/></div></div><div id="39556727" class="c"><input type="checkbox" id="c-39556727" checked=""/><div class="controls bullet"><span class="by">patrick451</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552039">parent</a><span>|</span><a href="#39555473">prev</a><span>|</span><a href="#39552245">next</a><span>|</span><label class="collapse" for="c-39556727">[-]</label><label class="expand" for="c-39556727">[2 more]</label></div><br/><div class="children"><div class="content">IME, c++ was easier to ramp up on than typescript. C++ still a lingua franca in many domains, e.g., robotics, games, finance.</div><br/><div id="39557401" class="c"><input type="checkbox" id="c-39557401" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39556727">parent</a><span>|</span><a href="#39552245">next</a><span>|</span><label class="collapse" for="c-39557401">[-]</label><label class="expand" for="c-39557401">[1 more]</label></div><br/><div class="children"><div class="content">Finance?  No, most of it was rewritten in the 2000s to Java or DotNet.  Sure, a bunch of HNers will reply here that they work on high frequency market making systems that use C++, but they are an extreme minority in the industry at this point.</div><br/></div></div></div></div><div id="39552245" class="c"><input type="checkbox" id="c-39552245" checked=""/><div class="controls bullet"><span class="by">hilux</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552039">parent</a><span>|</span><a href="#39556727">prev</a><span>|</span><a href="#39556274">next</a><span>|</span><label class="collapse" for="c-39552245">[-]</label><label class="expand" for="c-39552245">[5 more]</label></div><br/><div class="children"><div class="content">Did you see yesterday&#x27;s article about the White House Office of the National Cyber Director (ONCD) advising developers to dump C, C++, and other languages with memory-safety issues?</div><br/><div id="39553543" class="c"><input type="checkbox" id="c-39553543" checked=""/><div class="controls bullet"><span class="by">mkipper</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552245">parent</a><span>|</span><a href="#39552291">next</a><span>|</span><label class="collapse" for="c-39553543">[-]</label><label class="expand" for="c-39553543">[1 more]</label></div><br/><div class="children"><div class="content">I still think knowing C++ is pretty valuable to someone&#x27;s career (at least over the next 10 - 15 years) if they&#x27;re looking to work in fields that traditionally use C++ but might be transitioning away from it.<p>The obvious comparison is Rust. There are way more C++ jobs out there than Rust jobs. And even if I&#x27;m hiring for a team developing something in Rust, I&#x27;d generally prefer candidates with similar C++ experience and a basic understanding of Rust over candidates with a strong knowledge of Rust and no domain experience. Modern C++ and Rust aren&#x27;t _that_ dissimilar, and a lot of ideas and techniques carry over from C++ to Rust.<p>Even if the DoD recommends that contractors stop using C++ and tech &#x2F; finance are moving away from it, I&#x27;d say we&#x27;re still years away from the point where Rust catches up to C++ in terms of job opportunities. If your main goal is employment in a certain industry, you&#x27;ll probably have an easier time getting your foot in the door with C++ than Rust. Both paths are viable but the Rust path would be much harder IMO.</div><br/></div></div><div id="39552291" class="c"><input type="checkbox" id="c-39552291" checked=""/><div class="controls bullet"><span class="by">sk11001</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552245">parent</a><span>|</span><a href="#39553543">prev</a><span>|</span><a href="#39554816">next</a><span>|</span><label class="collapse" for="c-39552291">[-]</label><label class="expand" for="c-39552291">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and at the same time I’m seeing ads for jobs that pay more than double what I make that require C++.</div><br/></div></div><div id="39554816" class="c"><input type="checkbox" id="c-39554816" checked=""/><div class="controls bullet"><span class="by">avgcorrection</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39552245">parent</a><span>|</span><a href="#39552291">prev</a><span>|</span><a href="#39556274">next</a><span>|</span><label class="collapse" for="c-39554816">[-]</label><label class="expand" for="c-39554816">[2 more]</label></div><br/><div class="children"><div class="content">We’re still in for another 20 years of hardcore veteran Cxx programmers insisting that either the memory safety issue is overblown or just a theoretical issue if you are experienced enough&#x2F;use a new enough edition of the language.</div><br/><div id="39555693" class="c"><input type="checkbox" id="c-39555693" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39551853">root</a><span>|</span><a href="#39554816">parent</a><span>|</span><a href="#39556274">next</a><span>|</span><label class="collapse" for="c-39555693">[-]</label><label class="expand" for="c-39555693">[1 more]</label></div><br/><div class="children"><div class="content">The C++ committee is looking hard at how to make C++ memory safe.  If you use modern C++ you are already reasonably memory safe - the trick is how do we force developers to not access raw memory (no new&#x2F;malloc, use vector not arrays...).  There are some things that seem like they will come soon.<p>Of course if you really need that non-memory safe stuff - which all your existing code does - then you can&#x27;t take advantage of it.  However you can migrate your C++ to modern C++ and add those features to your code.  This is probably easier than migrating to something like Rust (Rust cannot work with C++ unless you stick with the C subset from what I can tell) since you can work in small chunks at a time in at least some situations.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="39556274" class="c"><input type="checkbox" id="c-39556274" checked=""/><div class="controls bullet"><span class="by">d_sem</span><span>|</span><a href="#39551853">parent</a><span>|</span><a href="#39551916">prev</a><span>|</span><a href="#39559439">next</a><span>|</span><label class="collapse" for="c-39556274">[-]</label><label class="expand" for="c-39556274">[1 more]</label></div><br/><div class="children"><div class="content">Depends on the industry you are interested in entering.<p>My myopic view of the world has seen the general trend from C to C++ for realtime embedded applications. For example: in the Automotive Industry all the interesting  automotive features are written in C++.</div><br/></div></div></div></div><div id="39559439" class="c"><input type="checkbox" id="c-39559439" checked=""/><div class="controls bullet"><span class="by">Jean-Papoulos</span><span>|</span><a href="#39551853">prev</a><span>|</span><a href="#39552510">next</a><span>|</span><label class="collapse" for="c-39559439">[-]</label><label class="expand" for="c-39559439">[1 more]</label></div><br/><div class="children"><div class="content">A lot of this assumes the codebase is testable, but most of those legacy applications rely on global state a lot...</div><br/></div></div><div id="39552510" class="c"><input type="checkbox" id="c-39552510" checked=""/><div class="controls bullet"><span class="by">grandinj</span><span>|</span><a href="#39559439">prev</a><span>|</span><a href="#39551605">next</a><span>|</span><label class="collapse" for="c-39552510">[-]</label><label class="expand" for="c-39552510">[1 more]</label></div><br/><div class="children"><div class="content">This is generally the same path that LibreOffice followed. Works reasonably well.<p>We built our own find-dead-code tool, because the extant ones were imprecise, and boy oh boy did they find lots of dead stuff. And more dead stuff. And more dead stuff. Like peeling an onion, it went on for quite a while. But totally worth it in the end, made various improvements much easier.</div><br/></div></div><div id="39551605" class="c"><input type="checkbox" id="c-39551605" checked=""/><div class="controls bullet"><span class="by">ecshafer</span><span>|</span><a href="#39552510">prev</a><span>|</span><a href="#39555822">next</a><span>|</span><label class="collapse" for="c-39551605">[-]</label><label class="expand" for="c-39551605">[2 more]</label></div><br/><div class="children"><div class="content">This is pretty great advice for any legacy code project. Even outside of C++ there is a huge amount of code bases out there that do not compile&#x2F;run on a dev machine without tons of work. I once worked on a Java project that due to some weird dependencies, the dev mode was to run a junit test which started spring and went into an infinite loop. Getting a standard run to work helped a ton.</div><br/><div id="39555813" class="c"><input type="checkbox" id="c-39555813" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#39551605">parent</a><span>|</span><a href="#39555822">next</a><span>|</span><label class="collapse" for="c-39555813">[-]</label><label class="expand" for="c-39555813">[1 more]</label></div><br/><div class="children"><div class="content">The difference between greenfield and legacy code is just a few years.  So learn to work with legacy code and how to make it better over time.</div><br/></div></div></div></div><div id="39555822" class="c"><input type="checkbox" id="c-39555822" checked=""/><div class="controls bullet"><span class="by">bobnamob</span><span>|</span><a href="#39551605">prev</a><span>|</span><a href="#39557624">next</a><span>|</span><label class="collapse" for="c-39555822">[-]</label><label class="expand" for="c-39555822">[1 more]</label></div><br/><div class="children"><div class="content">This article (and admittedly most comments here) doesn&#x27;t emphasize the value of a comprehensive e2e test suite enough.<p>So much talk about change and large LoC deltas without capturing the expected behavior of the system first</div><br/></div></div><div id="39557624" class="c"><input type="checkbox" id="c-39557624" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#39555822">prev</a><span>|</span><a href="#39554907">next</a><span>|</span><label class="collapse" for="c-39557624">[-]</label><label class="expand" for="c-39557624">[1 more]</label></div><br/><div class="children"><div class="content">Once you have the SCM in order, and before you make any changes:<p>Structure101 is the best way to grok the architecture er tangles of a large code base.  They have a trial period that would give you the overview, but their refactoring support is fantastic (in Java at least).<p><a href="https:&#x2F;&#x2F;structure101.com&#x2F;products&#x2F;workspace&#x2F;" rel="nofollow">https:&#x2F;&#x2F;structure101.com&#x2F;products&#x2F;workspace&#x2F;</a></div><br/></div></div><div id="39554907" class="c"><input type="checkbox" id="c-39554907" checked=""/><div class="controls bullet"><span class="by">sega_sai</span><span>|</span><a href="#39557624">prev</a><span>|</span><a href="#39556049">next</a><span>|</span><label class="collapse" for="c-39554907">[-]</label><label class="expand" for="c-39554907">[1 more]</label></div><br/><div class="children"><div class="content">To be honest a lot of recommendations apply to other languages as well. I.e. start with tests only then change, add autoformatting etc. 
At least I had experience of applying a similar sequence of steps to a python package.</div><br/></div></div><div id="39556049" class="c"><input type="checkbox" id="c-39556049" checked=""/><div class="controls bullet"><span class="by">joshmarinacci</span><span>|</span><a href="#39554907">prev</a><span>|</span><a href="#39552073">next</a><span>|</span><label class="collapse" for="c-39556049">[-]</label><label class="expand" for="c-39556049">[1 more]</label></div><br/><div class="children"><div class="content">You need to install linters and formatters and security checkers. But you need to start using them incrementally. Trying to fix all the issues found at once is a quick recipe for madness. I suggest using clang-tidy with a meta-linter like Trunk Check<p>docs:<p><a href="https:&#x2F;&#x2F;docs.trunk.io&#x2F;check&#x2F;configuration&#x2F;configuring-existing-linters&#x2F;clang-tidy-setup" rel="nofollow">https:&#x2F;&#x2F;docs.trunk.io&#x2F;check&#x2F;configuration&#x2F;configuring-existi...</a>)</div><br/></div></div><div id="39552073" class="c"><input type="checkbox" id="c-39552073" checked=""/><div class="controls bullet"><span class="by">myrmidon</span><span>|</span><a href="#39556049">prev</a><span>|</span><a href="#39557983">next</a><span>|</span><label class="collapse" for="c-39552073">[-]</label><label class="expand" for="c-39552073">[1 more]</label></div><br/><div class="children"><div class="content">Really liked it! Especially the &quot;get buy in&quot; is really good advice-- always stressing how the effort spent on refactoring actually improves things, and WHY its necessary.<p>Something that&#x27;s kinda implied that I would really stress: Establish a &quot;single source of truth&quot; for any release&#x2F;binary that reaches production&#x2F;customers, before even touching ANY code (Ideally CI. And ideally builds are reproducible).<p>If you build from different machines&#x2F;environments&#x2F;toolchains, its only a matter of time before that in itself breaks something, and those kinds of problems can be really &quot;interesting&quot; to find (an obscure race condition that only occurs when using a newer compiler, etc.)</div><br/></div></div><div id="39557983" class="c"><input type="checkbox" id="c-39557983" checked=""/><div class="controls bullet"><span class="by">girafffe_i</span><span>|</span><a href="#39552073">prev</a><span>|</span><a href="#39556084">next</a><span>|</span><label class="collapse" for="c-39557983">[-]</label><label class="expand" for="c-39557983">[1 more]</label></div><br/><div class="children"><div class="content">Rewrite it in Rust.</div><br/></div></div><div id="39556084" class="c"><input type="checkbox" id="c-39556084" checked=""/><div class="controls bullet"><span class="by">dureuill</span><span>|</span><a href="#39557983">prev</a><span>|</span><label class="collapse" for="c-39556084">[-]</label><label class="expand" for="c-39556084">[4 more]</label></div><br/><div class="children"><div class="content">&gt; What do you do now?<p>Look for another job<p>&gt; You’d be amazed at how many C++ codebase in the wild that are a core part of a successful product earning millions and they basically do not compile.<p>Wow I really hope this is hyperbole. I feel like I was lucky to work on a codebase that had CI to test on multiple computers with WError</div><br/><div id="39556180" class="c"><input type="checkbox" id="c-39556180" checked=""/><div class="controls bullet"><span class="by">throwaway71271</span><span>|</span><a href="#39556084">parent</a><span>|</span><label class="collapse" for="c-39556180">[-]</label><label class="expand" for="c-39556180">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Wow I really hope this is hyperbole.<p>I am sure its not, I dont have much experience as I have worked in only 3 companies in the last 25 years, but so far I have found no relation between code quality and company earnings.</div><br/><div id="39557418" class="c"><input type="checkbox" id="c-39557418" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39556084">root</a><span>|</span><a href="#39556180">parent</a><span>|</span><label class="collapse" for="c-39557418">[-]</label><label class="expand" for="c-39557418">[2 more]</label></div><br/><div class="children"><div class="content">&gt; so far I have found no relation between code quality and company earnings.<p>This!  What matters is the market fit and customer experience.  You can deliver a lot of value with average programmers working on a shitty code base.</div><br/><div id="39558257" class="c"><input type="checkbox" id="c-39558257" checked=""/><div class="controls bullet"><span class="by">gmueckl</span><span>|</span><a href="#39556084">root</a><span>|</span><a href="#39557418">parent</a><span>|</span><label class="collapse" for="c-39558257">[-]</label><label class="expand" for="c-39558257">[1 more]</label></div><br/><div class="children"><div class="content">I started to joke that in order to have a successful software startup, you need to essentially write the most godawful program code you can get away with. The money is much better spent on a good&#x2F;aggressive sales strategy.<p>Elegant technology never wins on its own merits.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>