<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1725008476993" as="style"/><link rel="stylesheet" href="styles.css?v=1725008476993"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html">Rust&#x27;s Ugly Syntax (2023)</a> <span class="domain">(<a href="https://matklad.github.io">matklad.github.io</a>)</span></div><div class="subtext"><span>nequo</span> | <span>58 comments</span></div><br/><div><div id="41398239" class="c"><input type="checkbox" id="c-41398239" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#41398912">next</a><span>|</span><label class="collapse" for="c-41398239">[-]</label><label class="expand" for="c-41398239">[20 more]</label></div><br/><div class="children"><div class="content">I think the article makes a good point, but the actual example isn’t Rust’s worst, not even close. It gets really hard to follow code when multiple generic types are combined with lifetime markers. Then it truly becomes a mess.</div><br/><div id="41398877" class="c"><input type="checkbox" id="c-41398877" checked=""/><div class="controls bullet"><span class="by">WhyNotHugo</span><span>|</span><a href="#41398239">parent</a><span>|</span><a href="#41398842">next</a><span>|</span><label class="collapse" for="c-41398877">[-]</label><label class="expand" for="c-41398877">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a nice example of a Trait that has async functions:<p><pre><code>    fn list_items&lt;&#x27;life0, &#x27;life1, &#x27;async_trait&gt;(
        &amp;&#x27;life0 self,
        collection_href: &amp;&#x27;life1 str,
    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Vec&lt;ItemRef&gt;, Error&gt;&gt; + Send + &#x27;async_trait&gt;&gt;
    where
        Self: &#x27;async_trait,
        &#x27;life0: &#x27;async_trait,
        &#x27;life1: &#x27;async_trait,

</code></pre>
Rendered docs: <a href="https:&#x2F;&#x2F;mirror.whynothugo.nl&#x2F;vdirsyncer&#x2F;v2.0.0-beta0&#x2F;vstorage&#x2F;base&#x2F;trait.Storage.html#tymethod.list_items" rel="nofollow">https:&#x2F;&#x2F;mirror.whynothugo.nl&#x2F;vdirsyncer&#x2F;v2.0.0-beta0&#x2F;vstorag...</a><p>Source: <a href="https:&#x2F;&#x2F;git.sr.ht&#x2F;~whynothugo&#x2F;vdirsyncer-rs&#x2F;tree&#x2F;v2.0.0-beta0&#x2F;item&#x2F;vstorage&#x2F;src&#x2F;base.rs#L79" rel="nofollow">https:&#x2F;&#x2F;git.sr.ht&#x2F;~whynothugo&#x2F;vdirsyncer-rs&#x2F;tree&#x2F;v2.0.0-beta...</a></div><br/><div id="41398928" class="c"><input type="checkbox" id="c-41398928" checked=""/><div class="controls bullet"><span class="by">virtualritz</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398877">parent</a><span>|</span><a href="#41398842">next</a><span>|</span><label class="collapse" for="c-41398928">[-]</label><label class="expand" for="c-41398928">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <a href="https:&#x2F;&#x2F;mirror.whynothugo.nl&#x2F;vdirsyncer&#x2F;v2.0.0-beta0&#x2F;vstorage&#x2F;base&#x2F;trait.Storage.html#tymethod.list_items" rel="nofollow">https:&#x2F;&#x2F;mirror.whynothugo.nl&#x2F;vdirsyncer&#x2F;v2.0.0-beta0&#x2F;vstorag...</a><p>Unrelated to parent but maybe relevant to you: Rust API naming guidelines say no `get_` prefix on getters.<p><a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;api-guidelines&#x2F;naming.html#getter-names-follow-rust-convention-c-getter" rel="nofollow">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;api-guidelines&#x2F;naming.html#gette...</a></div><br/></div></div></div></div><div id="41398842" class="c"><input type="checkbox" id="c-41398842" checked=""/><div class="controls bullet"><span class="by">yulaow</span><span>|</span><a href="#41398239">parent</a><span>|</span><a href="#41398877">prev</a><span>|</span><a href="#41398735">next</a><span>|</span><label class="collapse" for="c-41398842">[-]</label><label class="expand" for="c-41398842">[1 more]</label></div><br/><div class="children"><div class="content">throw in some async too and I really lose myself most of the times</div><br/></div></div><div id="41398735" class="c"><input type="checkbox" id="c-41398735" checked=""/><div class="controls bullet"><span class="by">namjh</span><span>|</span><a href="#41398239">parent</a><span>|</span><a href="#41398842">prev</a><span>|</span><a href="#41398254">next</a><span>|</span><label class="collapse" for="c-41398735">[-]</label><label class="expand" for="c-41398735">[4 more]</label></div><br/><div class="children"><div class="content">IMHO the mentioned examples of complexity like multiple type variables and lifetimes with bounds are for who &quot;really&quot; wants compile-time contracts. These are mostly opt-in so higher level use cases(like writing backend business logics) should not care about that, just wrapping everything with Boxes and Arcs.<p>Of course Rust is not perfect; there is some &#x27;leakages&#x27; of low level aspects to high level like async caveats(recursion, pinning, etc.). I&#x27;m not sure how these can be avoided. Maybe just trial-and-errors for all..?</div><br/><div id="41398788" class="c"><input type="checkbox" id="c-41398788" checked=""/><div class="controls bullet"><span class="by">Hamuko</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398735">parent</a><span>|</span><a href="#41398254">next</a><span>|</span><label class="collapse" for="c-41398788">[-]</label><label class="expand" for="c-41398788">[3 more]</label></div><br/><div class="children"><div class="content">I do remember the compiler constantly suggesting lifetimes to me as a newcomer to the language, so it didn&#x27;t really feel that opt-in. Quite a lot of the suggestions also started to look like someone poured alphabet soup all over the code.</div><br/><div id="41398879" class="c"><input type="checkbox" id="c-41398879" checked=""/><div class="controls bullet"><span class="by">namjh</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398788">parent</a><span>|</span><a href="#41398866">next</a><span>|</span><label class="collapse" for="c-41398879">[-]</label><label class="expand" for="c-41398879">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s because the code triggering compilation error is using reference. If you use Rc or Arc (which pays runtime cost) there should be no lifetime at all.<p>Albeit I admit there somewhat exists a community sentiment like &quot;if you use Rust, you should maximize its zero cost abstraction feature so lifetime is good and generics good&quot;, and my (minor) opinion is that, it&#x27;s not always true to all users of Rust.<p>And the clumsy Arc&lt;Mutex&lt;Something&lt;TheOtherThing&gt;&gt;&gt; makes users feel bad about using runtime cost paid types. Maybe we should introduce easy Rust dialect which transpiles into Rc&#x2F;Clone everywhere but I doubt it&#x27;s trivial to transpile.</div><br/></div></div><div id="41398866" class="c"><input type="checkbox" id="c-41398866" checked=""/><div class="controls bullet"><span class="by">scotty79</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398788">parent</a><span>|</span><a href="#41398879">prev</a><span>|</span><a href="#41398254">next</a><span>|</span><label class="collapse" for="c-41398866">[-]</label><label class="expand" for="c-41398866">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s mostly because borrows are a curiosity of Rust that newcommers are quickly introduced to while they are mostly just a perfomance gimmick.<p>If you come to rust from high level language you can just do everything with Rc and cloning.<p>It&#x27;s still hard because Rust, in opposition to every pipular language, is a value oriented language. But at least you won&#x27;t have much contact with alphabet soup.</div><br/></div></div></div></div></div></div><div id="41398254" class="c"><input type="checkbox" id="c-41398254" checked=""/><div class="controls bullet"><span class="by">hckr1292</span><span>|</span><a href="#41398239">parent</a><span>|</span><a href="#41398735">prev</a><span>|</span><a href="#41398409">next</a><span>|</span><label class="collapse" for="c-41398254">[-]</label><label class="expand" for="c-41398254">[6 more]</label></div><br/><div class="children"><div class="content">Agree about the example! I can&#x27;t tell if this article is tongue-in-cheek or earnest. I&#x27;m unclear on the point the author is trying to make.</div><br/><div id="41398337" class="c"><input type="checkbox" id="c-41398337" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398254">parent</a><span>|</span><a href="#41398379">next</a><span>|</span><label class="collapse" for="c-41398337">[-]</label><label class="expand" for="c-41398337">[1 more]</label></div><br/><div class="children"><div class="content">The author explains it in the first sentence, i.e. not the syntax of lifetimes may be your problem, but the feature itself</div><br/></div></div><div id="41398379" class="c"><input type="checkbox" id="c-41398379" checked=""/><div class="controls bullet"><span class="by">zarzavat</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398254">parent</a><span>|</span><a href="#41398337">prev</a><span>|</span><a href="#41398409">next</a><span>|</span><label class="collapse" for="c-41398379">[-]</label><label class="expand" for="c-41398379">[4 more]</label></div><br/><div class="children"><div class="content">My reading is: people use Rust because it’s fast but then they complain about the semantics that make it fast.<p>In other words, be careful what you wish for.<p>Most people would probably be better served by a language that was a tiny bit slower but had better developer productivity. However, once you deviate from the goal of “as fast as possible”, then you have to choose <i>which</i> parts you want to sacrifice speed for productivity. Like Excel, everybody agrees that Rust is too complicated but nobody can agree on which 10% to remove.</div><br/><div id="41398657" class="c"><input type="checkbox" id="c-41398657" checked=""/><div class="controls bullet"><span class="by">sk11001</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398379">parent</a><span>|</span><a href="#41398460">next</a><span>|</span><label class="collapse" for="c-41398657">[-]</label><label class="expand" for="c-41398657">[1 more]</label></div><br/><div class="children"><div class="content">&gt; people use Rust because it’s fast but then they complain about the semantics that make it fast.<p>I don&#x27;t think most people use Rust because it&#x27;s fast - fast is nice but Rust is being thrown at a bunch of use cases (e.g. backend services and APIs) for which it replaces &quot;slower&quot; garbage collected languages (the language being faster doesn&#x27;t always make the overall product&#x2F;service faster but that&#x27;s a separate question).<p>What Rust gives you is a viable potential alternative to C and C++ in places where you absolutely can&#x27;t have a GC language, and that&#x27;s a huge deal, the problems and confusion start when people try to use Rust for everything.<p>&gt; everybody agrees that Rust is too complicated<p>I don&#x27;t think this is true either - a large part of the Rust community seem to think that it&#x27;s as complicated as it needs to be. As a beginner&#x2F;outsider, I found it kind of cumbersome to get started with, but that&#x27;s certainly not everyone&#x27;s opinion.<p>&gt; Most people would probably be better served by a language that was a tiny bit slower but had better developer productivity.<p>True, and such languages already exist and are widely used, Rust doesn&#x27;t need to fit that use case.</div><br/></div></div><div id="41398460" class="c"><input type="checkbox" id="c-41398460" checked=""/><div class="controls bullet"><span class="by">d_tr</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398379">parent</a><span>|</span><a href="#41398657">prev</a><span>|</span><a href="#41398409">next</a><span>|</span><label class="collapse" for="c-41398460">[-]</label><label class="expand" for="c-41398460">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Most people would probably be better served by a language that was a tiny bit slower but had better developer productivity.<p>D maybe? D and Rust are the two languages which come to mind when I think about &quot;possible C++ replacements&quot;.</div><br/><div id="41398715" class="c"><input type="checkbox" id="c-41398715" checked=""/><div class="controls bullet"><span class="by">cdogl</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398460">parent</a><span>|</span><a href="#41398409">next</a><span>|</span><label class="collapse" for="c-41398715">[-]</label><label class="expand" for="c-41398715">[1 more]</label></div><br/><div class="children"><div class="content">When GP said “most”, I interpreted it more broadly. Most applications simply do not require the  guarantees of a non-GC language. When you expand that horizon, list of contenders becomes considerably larger - even when restricted to statically typed languages.</div><br/></div></div></div></div></div></div></div></div><div id="41398409" class="c"><input type="checkbox" id="c-41398409" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41398239">parent</a><span>|</span><a href="#41398254">prev</a><span>|</span><a href="#41398912">next</a><span>|</span><label class="collapse" for="c-41398409">[-]</label><label class="expand" for="c-41398409">[6 more]</label></div><br/><div class="children"><div class="content">I always, <i>always</i> forget what `&#x27;a: &#x27;b` means, because I remember it always being the opposite of what I think it is, but memorizing that obviously doesn&#x27;t work because then it will just flip again the next time. It&#x27;s so annoying.</div><br/><div id="41398459" class="c"><input type="checkbox" id="c-41398459" checked=""/><div class="controls bullet"><span class="by">nrabulinski</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398409">parent</a><span>|</span><a href="#41398818">next</a><span>|</span><label class="collapse" for="c-41398459">[-]</label><label class="expand" for="c-41398459">[1 more]</label></div><br/><div class="children"><div class="content">I always describe it to myself this way - T: Foo means T is a superset of Foo (because it at least implements Foo but most likely more) thus &#x27;a: &#x27;b means &#x27;a is at least as wide as &#x27;b, and possibly wider</div><br/></div></div><div id="41398818" class="c"><input type="checkbox" id="c-41398818" checked=""/><div class="controls bullet"><span class="by">lifthrasiir</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398409">parent</a><span>|</span><a href="#41398459">prev</a><span>|</span><a href="#41398631">next</a><span>|</span><label class="collapse" for="c-41398818">[-]</label><label class="expand" for="c-41398818">[1 more]</label></div><br/><div class="children"><div class="content">It was a good signal to me that you are overthinking into the architecture if that is really required. Rust makes something pretty much impossible in C&#x2F;C++ possible, but not necessarily easy, and that would be one such example.</div><br/></div></div><div id="41398631" class="c"><input type="checkbox" id="c-41398631" checked=""/><div class="controls bullet"><span class="by">delifue</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398409">parent</a><span>|</span><a href="#41398818">prev</a><span>|</span><a href="#41398632">next</a><span>|</span><label class="collapse" for="c-41398631">[-]</label><label class="expand" for="c-41398631">[1 more]</label></div><br/><div class="children"><div class="content">In lifetime, subtype means longer lifetime (it&#x27;s unintuitive). &#x27;a : &#x27;b means &#x27;a is a subtype of &#x27;b, which contains &#x27;b and can be longer.<p>Rust can improve this by introducing syntax like `&#x27;a contains &#x27;b`</div><br/></div></div><div id="41398632" class="c"><input type="checkbox" id="c-41398632" checked=""/><div class="controls bullet"><span class="by">runiq</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398409">parent</a><span>|</span><a href="#41398631">prev</a><span>|</span><a href="#41398912">next</a><span>|</span><label class="collapse" for="c-41398632">[-]</label><label class="expand" for="c-41398632">[2 more]</label></div><br/><div class="children"><div class="content">If you think of it as &#x27;a implements b&#x27;, it makes sense for both lifetimes and (other) subtypes: If lifetime `a` implements `b`, it is obviously valid for `b` (and maybe longer).</div><br/><div id="41398726" class="c"><input type="checkbox" id="c-41398726" checked=""/><div class="controls bullet"><span class="by">LoganDark</span><span>|</span><a href="#41398239">root</a><span>|</span><a href="#41398632">parent</a><span>|</span><a href="#41398912">next</a><span>|</span><label class="collapse" for="c-41398726">[-]</label><label class="expand" for="c-41398726">[1 more]</label></div><br/><div class="children"><div class="content">I always do `&lt;T, U extends T, V extends U&gt;` etc for generics, but for lifetimes it&#x27;s `&lt;&#x27;a: &#x27;b, &#x27;b: &#x27;c, &#x27;c&gt;` which <i>always</i> trips me up...</div><br/></div></div></div></div></div></div></div></div><div id="41398912" class="c"><input type="checkbox" id="c-41398912" checked=""/><div class="controls bullet"><span class="by">mgaunard</span><span>|</span><a href="#41398239">prev</a><span>|</span><a href="#41398438">next</a><span>|</span><label class="collapse" for="c-41398912">[-]</label><label class="expand" for="c-41398912">[1 more]</label></div><br/><div class="children"><div class="content">There are several problems with the C++ variant, which could have been easily avoided by just following the original Rust more closely.</div><br/></div></div><div id="41398438" class="c"><input type="checkbox" id="c-41398438" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#41398912">prev</a><span>|</span><a href="#41398435">next</a><span>|</span><label class="collapse" for="c-41398438">[-]</label><label class="expand" for="c-41398438">[2 more]</label></div><br/><div class="children"><div class="content">For my own situation, the articles present the right way to express all possible performance&#x2F;error handling (which is expected in a standard lib) and then goes on to show how I actually code it in my own softawre where I don&#x27;t really need the level of detail&#x2F;finetuning of the standard lib.<p>Interestingly, my life starts at the end of the article, with the simple verison of the code, and as my understanding of rust widens, I go up to the beginning of the article and better define my function...</div><br/><div id="41398458" class="c"><input type="checkbox" id="c-41398458" checked=""/><div class="controls bullet"><span class="by">awesomebytes</span><span>|</span><a href="#41398438">parent</a><span>|</span><a href="#41398435">next</a><span>|</span><label class="collapse" for="c-41398458">[-]</label><label class="expand" for="c-41398458">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve only learned a tiny bit of Rust, and I feel the same. Going from the bottom up, makes it all make so much sense. (Albeit I still like the Rattlesnake syntax haha)</div><br/></div></div></div></div><div id="41398435" class="c"><input type="checkbox" id="c-41398435" checked=""/><div class="controls bullet"><span class="by">MetricExpansion</span><span>|</span><a href="#41398438">prev</a><span>|</span><a href="#41398852">next</a><span>|</span><label class="collapse" for="c-41398435">[-]</label><label class="expand" for="c-41398435">[1 more]</label></div><br/><div class="children"><div class="content">If I understood all the semantic properties, including the separate compilation requirements, correctly, here’s how I think it would be done in Swift with the proposed nonescapable types features (needed to safely express the AsRef concept here).
 (Note that this doesn’t quite compile today and the syntax for nonescaping types is still a proposal.)<p><pre><code>  @usableFromInline
  func _read(pathView: PathView) throws(IOError) -&gt; [UInt8] {
      var file = try File(pathView)
      var bytes: [UInt8] = []
      try file.readToEnd(into: &amp;bytes)
      return bytes
  }
  
  @inlinable
  public func read&lt;Path&gt;(path: borrowing Path) throws(IOError) -&gt; [UInt8] where Path: PathViewable, Path: ~Copyable {
      try _read(pathView: path.view())
  }
  
  &#x2F;&#x2F; Definitions...
  
  public enum IOError: Error {}
  
  public protocol PathViewable: ~Copyable {
      func view() -&gt; PathView
  }
  
  public struct PathView: ~Escapable {}
  
  public struct File: ~Copyable {
      public init(_ pathView: borrowing PathView) throws(IOError) {
          fatalError(&quot;unimplemented&quot;)
      }
  
      public mutating func readToEnd(into buffer: inout [UInt8]) throws(IOError) {
          fatalError(&quot;unimplemented&quot;)
      }
  }</code></pre></div><br/></div></div><div id="41398852" class="c"><input type="checkbox" id="c-41398852" checked=""/><div class="controls bullet"><span class="by">anonymous2024</span><span>|</span><a href="#41398435">prev</a><span>|</span><a href="#41398260">next</a><span>|</span><label class="collapse" for="c-41398852">[-]</label><label class="expand" for="c-41398852">[1 more]</label></div><br/><div class="children"><div class="content">I wonder. How does Rust syntax compares with <a href="https:&#x2F;&#x2F;www.hylo-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.hylo-lang.org&#x2F;</a> syntax?
That also is memory safe, typesafe, and data-race-free.</div><br/></div></div><div id="41398260" class="c"><input type="checkbox" id="c-41398260" checked=""/><div class="controls bullet"><span class="by">eterps</span><span>|</span><a href="#41398852">prev</a><span>|</span><a href="#41398654">next</a><span>|</span><label class="collapse" for="c-41398260">[-]</label><label class="expand" for="c-41398260">[7 more]</label></div><br/><div class="children"><div class="content">Just give me Rattlesnake or CrabML and I&#x27;ll stop complaining :-)</div><br/><div id="41398736" class="c"><input type="checkbox" id="c-41398736" checked=""/><div class="controls bullet"><span class="by">frankie_t</span><span>|</span><a href="#41398260">parent</a><span>|</span><a href="#41398785">next</a><span>|</span><label class="collapse" for="c-41398736">[-]</label><label class="expand" for="c-41398736">[1 more]</label></div><br/><div class="children"><div class="content">Wanted to say the same. He straight up conjured a good looking code in CrabML as an example of similar level of &quot;ugliness&quot;, while it has about three times less syntax noise.</div><br/></div></div><div id="41398785" class="c"><input type="checkbox" id="c-41398785" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#41398260">parent</a><span>|</span><a href="#41398736">prev</a><span>|</span><a href="#41398733">next</a><span>|</span><label class="collapse" for="c-41398785">[-]</label><label class="expand" for="c-41398785">[1 more]</label></div><br/><div class="children"><div class="content">Choked on my coffee when I got to Rattlesnake. Great name.</div><br/></div></div><div id="41398733" class="c"><input type="checkbox" id="c-41398733" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#41398260">parent</a><span>|</span><a href="#41398785">prev</a><span>|</span><a href="#41398443">next</a><span>|</span><label class="collapse" for="c-41398733">[-]</label><label class="expand" for="c-41398733">[3 more]</label></div><br/><div class="children"><div class="content">What&#x27;s Rattlesnake? I can&#x27;t find anything at all online.</div><br/><div id="41398742" class="c"><input type="checkbox" id="c-41398742" checked=""/><div class="controls bullet"><span class="by">frankie_t</span><span>|</span><a href="#41398260">root</a><span>|</span><a href="#41398733">parent</a><span>|</span><a href="#41398443">next</a><span>|</span><label class="collapse" for="c-41398742">[-]</label><label class="expand" for="c-41398742">[2 more]</label></div><br/><div class="children"><div class="content">I think he&#x27;s referring to Python, just like other made up names probably refer to Java, Js, C++ and OCaml.</div><br/><div id="41398764" class="c"><input type="checkbox" id="c-41398764" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#41398260">root</a><span>|</span><a href="#41398742">parent</a><span>|</span><a href="#41398443">next</a><span>|</span><label class="collapse" for="c-41398764">[-]</label><label class="expand" for="c-41398764">[1 more]</label></div><br/><div class="children"><div class="content">Ahh I see, I didn&#x27;t notice that name in the article, thank you.</div><br/></div></div></div></div></div></div><div id="41398443" class="c"><input type="checkbox" id="c-41398443" checked=""/><div class="controls bullet"><span class="by">awesomebytes</span><span>|</span><a href="#41398260">parent</a><span>|</span><a href="#41398733">prev</a><span>|</span><a href="#41398654">next</a><span>|</span><label class="collapse" for="c-41398443">[-]</label><label class="expand" for="c-41398443">[1 more]</label></div><br/><div class="children"><div class="content">+1</div><br/></div></div></div></div><div id="41398654" class="c"><input type="checkbox" id="c-41398654" checked=""/><div class="controls bullet"><span class="by">jiwangcdi</span><span>|</span><a href="#41398260">prev</a><span>|</span><a href="#41398484">next</a><span>|</span><label class="collapse" for="c-41398654">[-]</label><label class="expand" for="c-41398654">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The next noisy element is the &lt;P: AsRef&lt;Path&gt;&gt; constraint. It is needed because Rust loves exposing physical layout of bytes in memory as an interface, specifically for cases where that brings performance. In particular, the meaning of Path is not that it is some abstract representation of a file path, but that it is just literally a bunch of contiguous bytes in memory.<p>I can&#x27;t understand this. Isn&#x27;t this for polymorphism like what we do this:<p>```rust
fn some_function(a: impl ToString) -&gt; String {
    a.to_string();
}
```<p>What to do with memory layout? Thanks for any explanation.</div><br/><div id="41398712" class="c"><input type="checkbox" id="c-41398712" checked=""/><div class="controls bullet"><span class="by">K0nserv</span><span>|</span><a href="#41398654">parent</a><span>|</span><a href="#41398484">next</a><span>|</span><label class="collapse" for="c-41398712">[-]</label><label class="expand" for="c-41398712">[2 more]</label></div><br/><div class="children"><div class="content">Rust needs to know the exact size, layout, and alignment of every argument passed to a function to determine how it gets passed(register(s) or spilled to stack) and used. For example PathBuf and String can both be turned into a reference to a Path, and while they have the same size their layout and implementation of `as_ref` differ.<p>As for `impl`,<p><pre><code>    fn foo(a: impl ToString)
</code></pre>
is syntactic sugar for<p><pre><code>    fn foo&lt;S: ToString&gt;(a: S)
</code></pre>
The reason the standard library doesn&#x27;t use this is because the code predates the introduction of `impl` in argument position.<p>The reason the function takes `AsRef&lt;Path&gt;` instead of `&amp;Path` is callsite ergonomics. If it took `&amp;Path` all callsites need to be turned into `read(path.as_ref())` or equivalent. With  `AsRef&lt;Path&gt;` it transparently works with any type that can be turned into a `&amp;Path` including `&amp;Path` itself.</div><br/><div id="41398824" class="c"><input type="checkbox" id="c-41398824" checked=""/><div class="controls bullet"><span class="by">jiwangcdi</span><span>|</span><a href="#41398654">root</a><span>|</span><a href="#41398712">parent</a><span>|</span><a href="#41398484">next</a><span>|</span><label class="collapse" for="c-41398824">[-]</label><label class="expand" for="c-41398824">[1 more]</label></div><br/><div class="children"><div class="content">Then if Path is not about abstraction, why not use a raw byte slice like &amp;[u8]</div><br/></div></div></div></div></div></div><div id="41398440" class="c"><input type="checkbox" id="c-41398440" checked=""/><div class="controls bullet"><span class="by">macmac</span><span>|</span><a href="#41398484">prev</a><span>|</span><a href="#41398240">next</a><span>|</span><label class="collapse" for="c-41398440">[-]</label><label class="expand" for="c-41398440">[1 more]</label></div><br/><div class="children"><div class="content">My hot take is that Rust should have been a Lisp. Then it could also have had readable macros.</div><br/></div></div><div id="41398240" class="c"><input type="checkbox" id="c-41398240" checked=""/><div class="controls bullet"><span class="by">AxelLuktarGott</span><span>|</span><a href="#41398440">prev</a><span>|</span><a href="#41398322">next</a><span>|</span><label class="collapse" for="c-41398240">[-]</label><label class="expand" for="c-41398240">[2 more]</label></div><br/><div class="children"><div class="content">Is it really better to remove the error case information from the type signature? Aren&#x27;t we losing vital information here?</div><br/><div id="41398257" class="c"><input type="checkbox" id="c-41398257" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#41398240">parent</a><span>|</span><a href="#41398322">next</a><span>|</span><label class="collapse" for="c-41398257">[-]</label><label class="expand" for="c-41398257">[1 more]</label></div><br/><div class="children"><div class="content">The std::io error type is defined roughly as:<p><pre><code>    type Result&lt;T&gt; = std::result::Result&lt;T, io::Error&gt;;
</code></pre>
So it&#x27;s actually fine, since we&#x27;re specifying it&#x27;s an IO result.  This is a fairly common pattern.</div><br/></div></div></div></div><div id="41398322" class="c"><input type="checkbox" id="c-41398322" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#41398240">prev</a><span>|</span><a href="#41398870">next</a><span>|</span><label class="collapse" for="c-41398322">[-]</label><label class="expand" for="c-41398322">[7 more]</label></div><br/><div class="children"><div class="content">Kinda disingenuous, you don&#x27;t reskin one language in another to make an argument about syntax -- you develop a clear syntax for a given semantics. That&#x27;s what rust <i>did not</i> do -- it copied c++&#x2F;java-ish, and that style did not support the weight.<p>When type signatures are so complex it makes vastly more sense to separate them out,<p>Consider,<p><pre><code>  read :: AsRef(Path) -&gt; IO.Result(Vec(U8))  

  pub fn read(path):
    inner :: &amp;Path -&gt; IO.Result(Vec(U8))

    fn inner(path):
      bytes := Vec.new()

      return? file := File.open(path) 
      return? file.read_to_end(&amp;! bytes)
      return OK(bytes)
    
    inner(path.as_ref())</code></pre></div><br/><div id="41398364" class="c"><input type="checkbox" id="c-41398364" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#41398322">parent</a><span>|</span><a href="#41398648">next</a><span>|</span><label class="collapse" for="c-41398364">[-]</label><label class="expand" for="c-41398364">[2 more]</label></div><br/><div class="children"><div class="content">To me this example is not more clear than normal Rust</div><br/><div id="41398439" class="c"><input type="checkbox" id="c-41398439" checked=""/><div class="controls bullet"><span class="by">mjburgess</span><span>|</span><a href="#41398322">root</a><span>|</span><a href="#41398364">parent</a><span>|</span><a href="#41398648">next</a><span>|</span><label class="collapse" for="c-41398439">[-]</label><label class="expand" for="c-41398439">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;ve programmed a lot in Rust, then that&#x27;s a win -- since its &quot;not more clear&quot;, and yet, you&#x27;ve no experience in <i>this</i> syntax.</div><br/></div></div></div></div><div id="41398648" class="c"><input type="checkbox" id="c-41398648" checked=""/><div class="controls bullet"><span class="by">demurgos</span><span>|</span><a href="#41398322">parent</a><span>|</span><a href="#41398364">prev</a><span>|</span><a href="#41398744">next</a><span>|</span><label class="collapse" for="c-41398648">[-]</label><label class="expand" for="c-41398648">[1 more]</label></div><br/><div class="children"><div class="content">People may disagree on specifics, but you&#x27;re definitely right that being able to separate the function signature from its definition would be very helpful in complex cases.</div><br/></div></div><div id="41398744" class="c"><input type="checkbox" id="c-41398744" checked=""/><div class="controls bullet"><span class="by">degurechaff</span><span>|</span><a href="#41398322">parent</a><span>|</span><a href="#41398648">prev</a><span>|</span><a href="#41398471">next</a><span>|</span><label class="collapse" for="c-41398744">[-]</label><label class="expand" for="c-41398744">[2 more]</label></div><br/><div class="children"><div class="content">Rust target user is C&#x2F;C++ developer. not using brace is out of options.</div><br/><div id="41398890" class="c"><input type="checkbox" id="c-41398890" checked=""/><div class="controls bullet"><span class="by">xigoi</span><span>|</span><a href="#41398322">root</a><span>|</span><a href="#41398744">parent</a><span>|</span><a href="#41398471">next</a><span>|</span><label class="collapse" for="c-41398890">[-]</label><label class="expand" for="c-41398890">[1 more]</label></div><br/><div class="children"><div class="content">Do you think C++ programmers are incapable of learning a language without braces?</div><br/></div></div></div></div><div id="41398471" class="c"><input type="checkbox" id="c-41398471" checked=""/><div class="controls bullet"><span class="by">timeon</span><span>|</span><a href="#41398322">parent</a><span>|</span><a href="#41398744">prev</a><span>|</span><a href="#41398870">next</a><span>|</span><label class="collapse" for="c-41398471">[-]</label><label class="expand" for="c-41398471">[1 more]</label></div><br/><div class="children"><div class="content">Now there are too many colons.</div><br/></div></div></div></div><div id="41398323" class="c"><input type="checkbox" id="c-41398323" checked=""/><div class="controls bullet"><span class="by">remcob</span><span>|</span><a href="#41398870">prev</a><span>|</span><a href="#41398261">next</a><span>|</span><label class="collapse" for="c-41398323">[-]</label><label class="expand" for="c-41398323">[4 more]</label></div><br/><div class="children"><div class="content">Why stop there and not go all the way to<p><pre><code>    pub fn read(path: Path) -&gt; Bytes {
      File::open(path).read_to_end()
    }</code></pre></div><br/><div id="41398362" class="c"><input type="checkbox" id="c-41398362" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#41398323">parent</a><span>|</span><a href="#41398261">next</a><span>|</span><label class="collapse" for="c-41398362">[-]</label><label class="expand" for="c-41398362">[3 more]</label></div><br/><div class="children"><div class="content">How to return an error in your example?</div><br/><div id="41398860" class="c"><input type="checkbox" id="c-41398860" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#41398323">root</a><span>|</span><a href="#41398362">parent</a><span>|</span><a href="#41398368">next</a><span>|</span><label class="collapse" for="c-41398860">[-]</label><label class="expand" for="c-41398860">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    pub fn read(path: Path) -&gt; Result&lt;Bytes&gt; {
      File::open(path)?.read_to_end()
    }
</code></pre>
isn&#x27;t so bad either.</div><br/></div></div><div id="41398368" class="c"><input type="checkbox" id="c-41398368" checked=""/><div class="controls bullet"><span class="by">tcfhgj</span><span>|</span><a href="#41398323">root</a><span>|</span><a href="#41398362">parent</a><span>|</span><a href="#41398860">prev</a><span>|</span><a href="#41398261">next</a><span>|</span><label class="collapse" for="c-41398368">[-]</label><label class="expand" for="c-41398368">[1 more]</label></div><br/><div class="children"><div class="content">Throw an exception<p>proving the point of the article even further</div><br/></div></div></div></div></div></div><div id="41398261" class="c"><input type="checkbox" id="c-41398261" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#41398323">prev</a><span>|</span><label class="collapse" for="c-41398261">[-]</label><label class="expand" for="c-41398261">[6 more]</label></div><br/><div class="children"><div class="content">The final version is still ugly. Why `pub fn&#x27;? Why is public not the default and why do you have to specify that it&#x27;s a function? Why `: type&#x27; and `-&gt; type&#x27;, why can&#x27;t type go before the identifier? Why do you need `File::&#x27; and `Bytes::&#x27;? What is that question mark? Why does the last statement not need a semicolon? It&#x27;s like the opposite of everything people are used to.</div><br/><div id="41398347" class="c"><input type="checkbox" id="c-41398347" checked=""/><div class="controls bullet"><span class="by">pta2002</span><span>|</span><a href="#41398261">parent</a><span>|</span><a href="#41398420">next</a><span>|</span><label class="collapse" for="c-41398347">[-]</label><label class="expand" for="c-41398347">[1 more]</label></div><br/><div class="children"><div class="content">Short answer for the type ordering and `fn`: because C&#x2F;C++&#x2F;Java tried that type of syntax and the result was an ambiguous grammar that is way too hard to parse, not to mention C&#x27;s overly complicated pointer syntax.</div><br/></div></div><div id="41398420" class="c"><input type="checkbox" id="c-41398420" checked=""/><div class="controls bullet"><span class="by">uasi</span><span>|</span><a href="#41398261">parent</a><span>|</span><a href="#41398347">prev</a><span>|</span><a href="#41398289">next</a><span>|</span><label class="collapse" for="c-41398420">[-]</label><label class="expand" for="c-41398420">[2 more]</label></div><br/><div class="children"><div class="content">Your points have nothing to do with ugliness.<p>&gt; Why `pub fn&#x27;? Why is public not the default and why do you have to specify that it&#x27;s a function?<p>If public were the default, you&#x27;d end up having to make other functions `priv fn` instead.<p>&gt; Why `: type&#x27; and `-&gt; type&#x27;, why can&#x27;t type go before the identifier?<p>It&#x27;s easier to parse, and most major typed languages other than C&#x2F;C++&#x2F;C#&#x2F;Java put the type after the identifier.<p>&gt; Why do you need `File::&#x27; and `Bytes::&#x27;?<p>Seriously?<p>&gt; What is that question mark?<p>The final version doesn&#x27;t use a question mark.<p>&gt; Why does the last statement not need a semicolon?<p>This is a legitimate question. In Rust, the last statement without a semicolon becomes the return value.</div><br/><div id="41398684" class="c"><input type="checkbox" id="c-41398684" checked=""/><div class="controls bullet"><span class="by">mFixman</span><span>|</span><a href="#41398261">root</a><span>|</span><a href="#41398420">parent</a><span>|</span><a href="#41398289">next</a><span>|</span><label class="collapse" for="c-41398684">[-]</label><label class="expand" for="c-41398684">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If public were the default, you&#x27;d end up having to make other functions `priv fn` instead.<p>My guilty pleasure is Go&#x27;s visibility system, where all functions that start with lowercase are private to the scope of the current class&#x2F;file and all Functions that start with Uppercase are public.<p>It doesn&#x27;t look but it would work and it&#x27;s a mess when you need acronyms, but it somehow works great and the result looks nice.</div><br/></div></div></div></div><div id="41398289" class="c"><input type="checkbox" id="c-41398289" checked=""/><div class="controls bullet"><span class="by">atoav</span><span>|</span><a href="#41398261">parent</a><span>|</span><a href="#41398420">prev</a><span>|</span><label class="collapse" for="c-41398289">[-]</label><label class="expand" for="c-41398289">[2 more]</label></div><br/><div class="children"><div class="content">As someone who doesn&#x27;t think it is <i>pretty</i>, but knows Rust I went through all your points and let me assure you except for the one where you wonder why the syntax can&#x27;t be more like C&#x2F;C++ where it comes down to taste, <i>all</i> of your questions have an answer that really makes sense if you understand the language.<p>E.g. making pub default is precisely the decision a language would make that values concise code over what the code actually does.</div><br/><div id="41398399" class="c"><input type="checkbox" id="c-41398399" checked=""/><div class="controls bullet"><span class="by">janalsncm</span><span>|</span><a href="#41398261">root</a><span>|</span><a href="#41398289">parent</a><span>|</span><label class="collapse" for="c-41398399">[-]</label><label class="expand" for="c-41398399">[1 more]</label></div><br/><div class="children"><div class="content">Definitely agree, “pub” was one of the design decisions I loved learning Rust. If you forget to add it, you’ll get a compiler error. But if pub was default, I’d be exposing code unnecessarily. And no need for a separate private keyword, the absence of pub is sufficient.<p>The same reasoning works for “mut” as well.<p>That said, I don’t like Rust’s syntax. Especially once you get to lambdas, things get hard to read.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>