<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734253257894" as="style"/><link rel="stylesheet" href="styles.css?v=1734253257894"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://ai.meta.com/research/publications/byte-latent-transformer-patches-scale-better-than-tokens/?_fb_noscript=1">Byte Latent Transformer: Patches Scale Better Than Tokens</a> <span class="domain">(<a href="https://ai.meta.com">ai.meta.com</a>)</span></div><div class="subtext"><span>zxexz</span> | <span>83 comments</span></div><br/><div><div id="42421180" class="c"><input type="checkbox" id="c-42421180" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42417307">next</a><span>|</span><label class="collapse" for="c-42421180">[-]</label><label class="expand" for="c-42421180">[1 more]</label></div><br/><div class="children"><div class="content">The paper: <a href="https:&#x2F;&#x2F;scontent-sjc3-1.xx.fbcdn.net&#x2F;v&#x2F;t39.2365-6&#x2F;470135129_1314438233309836_4712217603129928862_n.pdf?_nc_cat=111&amp;ccb=1-7&amp;_nc_sid=3c67a6&amp;_nc_ohc=WqSN1qsot3oQ7kNvgFWGG4j&amp;_nc_zt=14&amp;_nc_ht=scontent-sjc3-1.xx&amp;_nc_gid=A2yO-vwOF4w2PIUX2gHIbXD&amp;oh=00_AYBAR_B1_9ewVRJM5VYbJbdfm4Uk5INZY0t67hlpNccpAA&amp;oe=676400C8" rel="nofollow">https:&#x2F;&#x2F;scontent-sjc3-1.xx.fbcdn.net&#x2F;v&#x2F;t39.2365-6&#x2F;470135129_...</a></div><br/></div></div><div id="42417307" class="c"><input type="checkbox" id="c-42417307" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42421180">prev</a><span>|</span><a href="#42419115">next</a><span>|</span><label class="collapse" for="c-42417307">[-]</label><label class="expand" for="c-42417307">[8 more]</label></div><br/><div class="children"><div class="content">The summer that BERT came out I was working at a startup that was using character-based CNN models for classification.  We were thinking a lot about alternate representations,  other members of the team were keen on word vectors but I wasn&#x27;t,  particularly because it seemed the documents were were working on frequently had out-of-dictionary words,  because those words were important,  and because discarding them would lead to failure.<p>(We were working on &quot;foundation models&quot; too,  so it&#x27;s not just being out-of-dictionary in the final model that&#x27;s a problem but being out-of-dictionary in the foundation model which is more expensive to train.)<p>We were doing OK with character based models for classification but people believed that storing the &quot;dictionary&quot; inside the neural net was not a good use of the neural net so there was a lot of enthusiasm for tokens.<p>Meanwhile I felt so sure that schemes like Word2Vec were doomed that I had left an earlier project using RNNs where the goal was text understanding with a foundation model made by training an RNN to write fake abstracts for case reports from PubMed.<p>When byte-pair encoding was introduced I remember telling people in a meeting that it was the first tokenization scheme we&#x27;d looked at that I could endorse.<p>I have to admit though that I wish we could work at the character label.</div><br/><div id="42419473" class="c"><input type="checkbox" id="c-42419473" checked=""/><div class="controls bullet"><span class="by">binarymax</span><span>|</span><a href="#42417307">parent</a><span>|</span><a href="#42417964">next</a><span>|</span><label class="collapse" for="c-42419473">[-]</label><label class="expand" for="c-42419473">[1 more]</label></div><br/><div class="children"><div class="content">I was really excited for CANINE [1] but it never really went anywhere.  Tokens are a hack.  They work for the most part, but it’s clear when they don’t.<p>[1] <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2103.06874" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2103.06874</a></div><br/></div></div><div id="42417964" class="c"><input type="checkbox" id="c-42417964" checked=""/><div class="controls bullet"><span class="by">yndoendo</span><span>|</span><a href="#42417307">parent</a><span>|</span><a href="#42419473">prev</a><span>|</span><a href="#42419115">next</a><span>|</span><label class="collapse" for="c-42417964">[-]</label><label class="expand" for="c-42417964">[6 more]</label></div><br/><div class="children"><div class="content">Do you mean that all produced output must be a chain or words found in a dictionary?<p>The real-world for humans has them creating and using non-dictionary words to communicate daily. A good example is &quot;notify&quot;, defined in the dictionary. &quot;notifier&quot;, which is not and is used to describe &quot;a means to notify someone&quot;.  The code to send an email notification is an &quot;email notifier&quot;, then there is text message, voice call, call center call back notifiers ....<p>All industries and organizations have jargon, custom defined words not found in a dictionary and use non distinctive acronyms.<p>How would a ML output be useful if it cannot handle real world commutation and  only lab based sanitization of in-dictionary only responses?</div><br/><div id="42418320" class="c"><input type="checkbox" id="c-42418320" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42417307">root</a><span>|</span><a href="#42417964">parent</a><span>|</span><a href="#42418311">next</a><span>|</span><label class="collapse" for="c-42418320">[-]</label><label class="expand" for="c-42418320">[4 more]</label></div><br/><div class="children"><div class="content">(Author here)<p>If I understand your question right, this is one of the reasons BPE is nice and the parent liked it. For any character sequence, provided the characters are in the alphabet used to create the BPE vocab, there are no unknown words&#x2F;sequences. One downside of some previous tokenization methods is you could have unknown&#x2F;UNK tokens, EG dictionary based methods.<p>In our paper with bytes, we also avoid the UNK issue, since we can have an embedding for every possible byte, since it’s not that many (and for sequences of bytes we use hash embedding, although we did test n-gram lookups for the top K frequent byte n-grams in the training data).</div><br/><div id="42418980" class="c"><input type="checkbox" id="c-42418980" checked=""/><div class="controls bullet"><span class="by">cs702</span><span>|</span><a href="#42417307">root</a><span>|</span><a href="#42418320">parent</a><span>|</span><a href="#42418311">next</a><span>|</span><label class="collapse" for="c-42418980">[-]</label><label class="expand" for="c-42418980">[3 more]</label></div><br/><div class="children"><div class="content">Nice work. Thank you for commenting on HN!<p>Did you guys try using an RNN or some other kind of DNN to encode the patches?</div><br/><div id="42419088" class="c"><input type="checkbox" id="c-42419088" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42417307">root</a><span>|</span><a href="#42418980">parent</a><span>|</span><a href="#42418311">next</a><span>|</span><label class="collapse" for="c-42419088">[-]</label><label class="expand" for="c-42419088">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe so, or at least if someone tried it didn&#x27;t work well enough that I remember :). Some of the motivation for the architecture changes in encoding patches stemmed from finding FLOP efficient ways to express relationships between byte sequences. E.G., having a long context window makes sense when dealing with tokens, but you don&#x27;t need as long as an attention window if you&#x27;re attending byte sequences to make patch representations, since the patch representations will implicitly be part of a longer context window in terms of number of patches.</div><br/><div id="42419554" class="c"><input type="checkbox" id="c-42419554" checked=""/><div class="controls bullet"><span class="by">cs702</span><span>|</span><a href="#42417307">root</a><span>|</span><a href="#42419088">parent</a><span>|</span><a href="#42418311">next</a><span>|</span><label class="collapse" for="c-42419554">[-]</label><label class="expand" for="c-42419554">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the quick reply!<p>Interesting. I would have thought one of those &quot;minimum viable&quot; RNNs (like <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2410.01201" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2410.01201</a>) would have been ideal for this. I might tinker a bit with this :-)</div><br/></div></div></div></div></div></div></div></div><div id="42418311" class="c"><input type="checkbox" id="c-42418311" checked=""/><div class="controls bullet"><span class="by">phh</span><span>|</span><a href="#42417307">root</a><span>|</span><a href="#42417964">parent</a><span>|</span><a href="#42418320">prev</a><span>|</span><a href="#42419115">next</a><span>|</span><label class="collapse" for="c-42418311">[-]</label><label class="expand" for="c-42418311">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the OP&#x27;s point. At the time, the community was split between word-level, which has the shortcomings you&#x27;re describing, and byte-level which is uselessly compute intensive. BPE was the first reasonable in-between. BLT improves on BPE by having the the compression learnable rather than precomputed</div><br/></div></div></div></div></div></div><div id="42419115" class="c"><input type="checkbox" id="c-42419115" checked=""/><div class="controls bullet"><span class="by">modeless</span><span>|</span><a href="#42417307">prev</a><span>|</span><a href="#42421176">next</a><span>|</span><label class="collapse" for="c-42419115">[-]</label><label class="expand" for="c-42419115">[2 more]</label></div><br/><div class="children"><div class="content">I really hope this works out. Death to tokenizers!<p>Interesting that it&#x27;s a hierarchical structure but only two levels of hierarchy. Stacking more levels seems like an obvious direction for further research.<p>Note: I posted this comment on another related story[1] and the author replied:<p>&quot;Author here :), I do think it’s a good direction to look into! That said, aside from it being a bit too much to do at once, you’d also have to be careful about how you distributed your FLOP budget across the hierarchy. With two levels, you can make one level (bytes&#x2F;local encoder) FLOP efficient and the other (patches&#x2F;global encoder) FLOP intensive. You’d also need to find a way to group patches into larger units. But ya, there are many directions to go from here!&quot;<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42413430">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42413430</a></div><br/><div id="42422235" class="c"><input type="checkbox" id="c-42422235" checked=""/><div class="controls bullet"><span class="by">smaddox</span><span>|</span><a href="#42419115">parent</a><span>|</span><a href="#42421176">next</a><span>|</span><label class="collapse" for="c-42422235">[-]</label><label class="expand" for="c-42422235">[1 more]</label></div><br/><div class="children"><div class="content">Agree more levels seems like it could be beneficial. And another Meta paper published a day later shows how that might work: <a href="https:&#x2F;&#x2F;ai.meta.com&#x2F;research&#x2F;publications&#x2F;large-concept-models-language-modeling-in-a-sentence-representation-space&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ai.meta.com&#x2F;research&#x2F;publications&#x2F;large-concept-mode...</a></div><br/></div></div></div></div><div id="42421176" class="c"><input type="checkbox" id="c-42421176" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42419115">prev</a><span>|</span><a href="#42415909">next</a><span>|</span><label class="collapse" for="c-42421176">[-]</label><label class="expand" for="c-42421176">[1 more]</label></div><br/><div class="children"><div class="content">Recent and related:<p><i>Sharing new research, models, and datasets from Meta FAIR</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42412360">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=42412360</a> - Dec 2024 (61 comments)</div><br/></div></div><div id="42415909" class="c"><input type="checkbox" id="c-42415909" checked=""/><div class="controls bullet"><span class="by">flimflamm</span><span>|</span><a href="#42421176">prev</a><span>|</span><a href="#42421712">next</a><span>|</span><label class="collapse" for="c-42415909">[-]</label><label class="expand" for="c-42415909">[10 more]</label></div><br/><div class="children"><div class="content">To create a patch, a small model is used to predict the likelihood for the next character in the input string. Input string: &#x27;Lazy dog jumped over a fence.&#x27; Use the model to predict the likelihood of each character.<p>For example:<p><pre><code>    100% sure the next character is &#x27;a&#x27;.
    Or maybe it&#x27;s 10% sure it&#x27;s &#x27;a&#x27;, 10% sure it&#x27;s &#x27;b&#x27;, and so on.
</code></pre>
Then we chunk character estimates together.
How many characters?
Enough characters so that the total uncertainty (entropy) in each chunk is about the same.
And there you have your &#x27;patch&#x27; (or &#x27;token&#x27;).</div><br/><div id="42416018" class="c"><input type="checkbox" id="c-42416018" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#42415909">parent</a><span>|</span><a href="#42418140">next</a><span>|</span><label class="collapse" for="c-42416018">[-]</label><label class="expand" for="c-42416018">[8 more]</label></div><br/><div class="children"><div class="content">&gt; How many characters? Enough characters so that the total uncertainty (entropy) in each chunk is about the same.<p>That&#x27;s not how it&#x27;s described in Section 2.3 of the paper. They only use the entropy of the next byte and whether it exceeds a threshold (Global Constraint) or is larger than the preceding byte&#x27;s entropy by another threshold (Approx. Monotonic Constraint).<p>That does mean that long repetitive sequences can result in pathologically long patches, as demonstrated in Appendix E.<p>But what I&#x27;m really curious about is the &quot;small CNN byte-level model with 2-byte context&quot; in Figure 3 (f), because it&#x27;s never mentioned in any other part of the paper.</div><br/><div id="42417582" class="c"><input type="checkbox" id="c-42417582" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42416018">parent</a><span>|</span><a href="#42416323">next</a><span>|</span><label class="collapse" for="c-42417582">[-]</label><label class="expand" for="c-42417582">[6 more]</label></div><br/><div class="children"><div class="content">(Author Here)<p>Good description! Maybe what parent got mixed up on is an alternate way to view this is trying to chunk bytes to have roughly similar information. EG we initially tried a bunch of patching schemes, EG, keep a running total of entropy until the total exceeds a threshold, but ended up finding simple things worked better.<p>I’ll see if we can add more information about the small CNN in a next update to arXiv paper.</div><br/><div id="42418998" class="c"><input type="checkbox" id="c-42418998" checked=""/><div class="controls bullet"><span class="by">cschmidt</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42417582">parent</a><span>|</span><a href="#42418915">next</a><span>|</span><label class="collapse" for="c-42418998">[-]</label><label class="expand" for="c-42418998">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious if you&#x27;re aware of some papers from around 2005 on using contextual entropy to do unsupervised word segmentation on Chinese, and other languages that don&#x27;t use spaces for word boundaries.<p><a href="https:&#x2F;&#x2F;aclanthology.org&#x2F;Y03-1017&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aclanthology.org&#x2F;Y03-1017&#x2F;</a>
<a href="https:&#x2F;&#x2F;aclanthology.org&#x2F;I05-1009&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aclanthology.org&#x2F;I05-1009&#x2F;</a>
<a href="https:&#x2F;&#x2F;aclanthology.org&#x2F;P06-2056&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aclanthology.org&#x2F;P06-2056&#x2F;</a><p>Exactly the same approach of segmenting a word when the entropy goes up compared to the previous byte.</div><br/><div id="42419097" class="c"><input type="checkbox" id="c-42419097" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42418998">parent</a><span>|</span><a href="#42419701">next</a><span>|</span><label class="collapse" for="c-42419097">[-]</label><label class="expand" for="c-42419097">[1 more]</label></div><br/><div class="children"><div class="content">At least I wasn&#x27;t aware of this work, but thanks for the refs! I&#x27;m always curious to read papers from 10-20+ years ago that have similarly inspired ideas. If it makes sense, we&#x27;ll mention those in the next related work update.</div><br/></div></div><div id="42419701" class="c"><input type="checkbox" id="c-42419701" checked=""/><div class="controls bullet"><span class="by">ted_dunning</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42418998">parent</a><span>|</span><a href="#42419097">prev</a><span>|</span><a href="#42418915">next</a><span>|</span><label class="collapse" for="c-42419701">[-]</label><label class="expand" for="c-42419701">[1 more]</label></div><br/><div class="children"><div class="content">It is also quite similar to Carl de Marcken&#x27;s work for segmenting text and speech. He phrased everything in terms of minimum description length (MDL), but that is trivially the same thing as local entropy.<p><a href="https:&#x2F;&#x2F;dspace.mit.edu&#x2F;handle&#x2F;1721.1&#x2F;7191?show=full" rel="nofollow">https:&#x2F;&#x2F;dspace.mit.edu&#x2F;handle&#x2F;1721.1&#x2F;7191?show=full</a></div><br/></div></div></div></div><div id="42418915" class="c"><input type="checkbox" id="c-42418915" checked=""/><div class="controls bullet"><span class="by">psb217</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42417582">parent</a><span>|</span><a href="#42418998">prev</a><span>|</span><a href="#42416323">next</a><span>|</span><label class="collapse" for="c-42418915">[-]</label><label class="expand" for="c-42418915">[2 more]</label></div><br/><div class="children"><div class="content">One way of thinking about the &quot;Approximate Monotonic Constraint&quot; is that you&#x27;re running a quick and dirty edge detector on the entropy. Ie, you&#x27;re clipping based on the gradient of per-byte entropy wrt timestep compared to detecting an edge based on gradient of per-pixel intensity wrt pixel coordinates. It would be interesting to look at the raw sequences of per-byte entropies to see how strongly these sorts of &quot;edges&quot; correlate with human interpretable boundaries (words, prefixes, suffixes, etc).</div><br/><div id="42419390" class="c"><input type="checkbox" id="c-42419390" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42418915">parent</a><span>|</span><a href="#42416323">next</a><span>|</span><label class="collapse" for="c-42419390">[-]</label><label class="expand" for="c-42419390">[1 more]</label></div><br/><div class="children"><div class="content">Figure 4 plots the entropy of each byte in &quot;Daenerys Targeryen is in Game of Thrones, a fantasy epic
by George R.R. Martin.&quot;</div><br/></div></div></div></div></div></div><div id="42416323" class="c"><input type="checkbox" id="c-42416323" checked=""/><div class="controls bullet"><span class="by">flimflamm</span><span>|</span><a href="#42415909">root</a><span>|</span><a href="#42416018">parent</a><span>|</span><a href="#42417582">prev</a><span>|</span><a href="#42418140">next</a><span>|</span><label class="collapse" for="c-42416323">[-]</label><label class="expand" for="c-42416323">[1 more]</label></div><br/><div class="children"><div class="content">&quot;That&#x27;s not how it&#x27;s described&quot; - Thanks for the correction!</div><br/></div></div></div></div><div id="42418140" class="c"><input type="checkbox" id="c-42418140" checked=""/><div class="controls bullet"><span class="by">dv_dt</span><span>|</span><a href="#42415909">parent</a><span>|</span><a href="#42416018">prev</a><span>|</span><a href="#42421712">next</a><span>|</span><label class="collapse" for="c-42418140">[-]</label><label class="expand" for="c-42418140">[1 more]</label></div><br/><div class="children"><div class="content">So a variant might be to try using a some standard compression algorithm to train with?</div><br/></div></div></div></div><div id="42421712" class="c"><input type="checkbox" id="c-42421712" checked=""/><div class="controls bullet"><span class="by">RandyOrion</span><span>|</span><a href="#42415909">prev</a><span>|</span><a href="#42418905">next</a><span>|</span><label class="collapse" for="c-42421712">[-]</label><label class="expand" for="c-42421712">[1 more]</label></div><br/><div class="children"><div class="content">An interesting read on alternative tokenization methods.<p>Questions:<p>1. What&#x27;s the goal of entropy based byte token grouping as tokenization? Is this tokenization method best suited for the goal?<p>2. What about simply using byte level sequence to sequence autoencoder with down sampling for tokenization?</div><br/></div></div><div id="42418905" class="c"><input type="checkbox" id="c-42418905" checked=""/><div class="controls bullet"><span class="by">nodja</span><span>|</span><a href="#42421712">prev</a><span>|</span><a href="#42421172">next</a><span>|</span><label class="collapse" for="c-42418905">[-]</label><label class="expand" for="c-42418905">[2 more]</label></div><br/><div class="children"><div class="content">From my understanding this not only removes tokenization but also sampling correct?<p>Sampling can be a pain point of LLMs, but they also can enable interesting usages, like forcing grammar so the model always outputs valid JSON or tuning temperature to get more varied distribution, XTC sampling, etc.<p>What would be the equivalent of these in a BLT?<p>I can only think of providing the decoder an extra input of allowed&#x2F;prohibited bytes and run the decode over and over until it outputs something valid, maybe there&#x27;s a simpler and more obvious approach.</div><br/><div id="42419427" class="c"><input type="checkbox" id="c-42419427" checked=""/><div class="controls bullet"><span class="by">yorwba</span><span>|</span><a href="#42418905">parent</a><span>|</span><a href="#42421172">next</a><span>|</span><label class="collapse" for="c-42419427">[-]</label><label class="expand" for="c-42419427">[1 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t remove sampling, and forcing grammar by specifying allowed&#x2F;prohibited bytes doesn&#x27;t require running the decoder over and over, you just compute the softmax at the output layer over allowed bytes only and sample from those accordingly, same as with BPE-based models.</div><br/></div></div></div></div><div id="42421172" class="c"><input type="checkbox" id="c-42421172" checked=""/><div class="controls bullet"><span class="by">boulos</span><span>|</span><a href="#42418905">prev</a><span>|</span><a href="#42416347">next</a><span>|</span><label class="collapse" for="c-42421172">[-]</label><label class="expand" for="c-42421172">[1 more]</label></div><br/><div class="children"><div class="content">This is neat work, but I also love the (presumably intentional?) backronym of BLT.</div><br/></div></div><div id="42416347" class="c"><input type="checkbox" id="c-42416347" checked=""/><div class="controls bullet"><span class="by">dr_dshiv</span><span>|</span><a href="#42421172">prev</a><span>|</span><a href="#42417206">next</a><span>|</span><label class="collapse" for="c-42416347">[-]</label><label class="expand" for="c-42416347">[7 more]</label></div><br/><div class="children"><div class="content">Does this mean AI can pre-train on binaries?</div><br/><div id="42417906" class="c"><input type="checkbox" id="c-42417906" checked=""/><div class="controls bullet"><span class="by">bloomingkales</span><span>|</span><a href="#42416347">parent</a><span>|</span><a href="#42417206">next</a><span>|</span><label class="collapse" for="c-42417906">[-]</label><label class="expand" for="c-42417906">[6 more]</label></div><br/><div class="children"><div class="content">Some believe AI can now output compiled binaries (e.g update Notepad.exe with this feature).<p>We all think AI writing code for us will be the end, but it might be an even simpler take over.</div><br/><div id="42418610" class="c"><input type="checkbox" id="c-42418610" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42416347">root</a><span>|</span><a href="#42417906">parent</a><span>|</span><a href="#42418323">next</a><span>|</span><label class="collapse" for="c-42418610">[-]</label><label class="expand" for="c-42418610">[4 more]</label></div><br/><div class="children"><div class="content">That just sounds worse though? We can&#x27;t validate the change is correct if we can&#x27;t read the code. It is interesting though</div><br/><div id="42420893" class="c"><input type="checkbox" id="c-42420893" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42416347">root</a><span>|</span><a href="#42418610">parent</a><span>|</span><a href="#42418894">next</a><span>|</span><label class="collapse" for="c-42420893">[-]</label><label class="expand" for="c-42420893">[2 more]</label></div><br/><div class="children"><div class="content">Idk what they mean, I&#x27;ve never seen anyone claim, or come close to claiming, it could alter an executable binary by itself. Chose to interpret it as &quot;some people think an llm can code well enough to add features on top of a ~50KLOC codebase automatically&quot;</div><br/><div id="42421513" class="c"><input type="checkbox" id="c-42421513" checked=""/><div class="controls bullet"><span class="by">og_kalu</span><span>|</span><a href="#42416347">root</a><span>|</span><a href="#42420893">parent</a><span>|</span><a href="#42418894">next</a><span>|</span><label class="collapse" for="c-42421513">[-]</label><label class="expand" for="c-42421513">[1 more]</label></div><br/><div class="children"><div class="content">I think he&#x27;s saying people believe a LLM trained with this architecture would be able to do something like that.</div><br/></div></div></div></div><div id="42418894" class="c"><input type="checkbox" id="c-42418894" checked=""/><div class="controls bullet"><span class="by">hackernewds</span><span>|</span><a href="#42416347">root</a><span>|</span><a href="#42418610">parent</a><span>|</span><a href="#42420893">prev</a><span>|</span><a href="#42418323">next</a><span>|</span><label class="collapse" for="c-42418894">[-]</label><label class="expand" for="c-42418894">[1 more]</label></div><br/><div class="children"><div class="content">at some point you can&#x27;t or won&#x27;t be allowed to do any validations</div><br/></div></div></div></div></div></div></div></div><div id="42417206" class="c"><input type="checkbox" id="c-42417206" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#42416347">prev</a><span>|</span><a href="#42416425">next</a><span>|</span><label class="collapse" for="c-42417206">[-]</label><label class="expand" for="c-42417206">[3 more]</label></div><br/><div class="children"><div class="content">Why can&#x27;t the tokenization be implicit, so we only feed bytes (or characters) to the model?</div><br/><div id="42417428" class="c"><input type="checkbox" id="c-42417428" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42417206">parent</a><span>|</span><a href="#42417423">next</a><span>|</span><label class="collapse" for="c-42417428">[-]</label><label class="expand" for="c-42417428">[1 more]</label></div><br/><div class="children"><div class="content">(Author Here)<p>Not sure what you mean by implicit? If you mean just treat bytes as tokens, one issue you run into is your sequence lengths get quite long, so compared to a regular token LLM, you can’t pack as many bytes in a batch, which means you’re pretty FLOP inefficient so scale worse. You could make the model smaller to compensate, but then the model isn’t as good.</div><br/></div></div><div id="42417423" class="c"><input type="checkbox" id="c-42417423" checked=""/><div class="controls bullet"><span class="by">killerstorm</span><span>|</span><a href="#42417206">parent</a><span>|</span><a href="#42417428">prev</a><span>|</span><a href="#42416425">next</a><span>|</span><label class="collapse" for="c-42417423">[-]</label><label class="expand" for="c-42417423">[1 more]</label></div><br/><div class="children"><div class="content">It can work, but you have more tokens &#x2F; weaker performance.<p>People tested it and it was worse.</div><br/></div></div></div></div><div id="42416425" class="c"><input type="checkbox" id="c-42416425" checked=""/><div class="controls bullet"><span class="by">dewijones92</span><span>|</span><a href="#42417206">prev</a><span>|</span><a href="#42415641">next</a><span>|</span><label class="collapse" for="c-42416425">[-]</label><label class="expand" for="c-42416425">[11 more]</label></div><br/><div class="children"><div class="content">notebooklm <a href="https:&#x2F;&#x2F;notebooklm.google.com&#x2F;notebook&#x2F;77fe83ee-35b3-4a9a-a3d9-e2f1395a3a0f&#x2F;audio" rel="nofollow">https:&#x2F;&#x2F;notebooklm.google.com&#x2F;notebook&#x2F;77fe83ee-35b3-4a9a-a3...</a></div><br/><div id="42416653" class="c"><input type="checkbox" id="c-42416653" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#42416425">parent</a><span>|</span><a href="#42418277">next</a><span>|</span><label class="collapse" for="c-42416653">[-]</label><label class="expand" for="c-42416653">[9 more]</label></div><br/><div class="children"><div class="content">Interesting, this is one of the worst NotebookLM examples I&#x27;ve seen so far. They are interjecting way too often and breaking the rhythm. Is generation quality going down due to the popularity of the service?</div><br/><div id="42418152" class="c"><input type="checkbox" id="c-42418152" checked=""/><div class="controls bullet"><span class="by">stuartjohnson12</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42416653">parent</a><span>|</span><a href="#42417558">next</a><span>|</span><label class="collapse" for="c-42418152">[-]</label><label class="expand" for="c-42418152">[7 more]</label></div><br/><div class="children"><div class="content">Big successful launch, hype for the product lead, product lead moves on, product goes to shit. Another classic for the Google graveyard.</div><br/><div id="42418252" class="c"><input type="checkbox" id="c-42418252" checked=""/><div class="controls bullet"><span class="by">throwaway20222</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42418152">parent</a><span>|</span><a href="#42418210">next</a><span>|</span><label class="collapse" for="c-42418252">[-]</label><label class="expand" for="c-42418252">[2 more]</label></div><br/><div class="children"><div class="content">We are working directly with the Notebook team from the outside, and while they have lost the original product lead, the team in general is seemingly really well supported, staffed with talented folks, and actively trying to understand what the end user wants from the product. Hardly a day goes by that they are not actively trying to get more feedback and share where they are heading.<p>I do think it is fair to say they had been caught off guard by the success of the program and are trying to catch up. Maybe this is just a bit of drift as they are figuring it all out? Or maybe I am too charitable.</div><br/><div id="42418818" class="c"><input type="checkbox" id="c-42418818" checked=""/><div class="controls bullet"><span class="by">mrbungie</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42418252">parent</a><span>|</span><a href="#42418210">next</a><span>|</span><label class="collapse" for="c-42418818">[-]</label><label class="expand" for="c-42418818">[1 more]</label></div><br/><div class="children"><div class="content">&gt; and while they have lost the original product lead<p>Doesn&#x27;t matter how talented the team is, that is a massive red flag as not even six months have passed since the launch.</div><br/></div></div></div></div><div id="42418210" class="c"><input type="checkbox" id="c-42418210" checked=""/><div class="controls bullet"><span class="by">marviel</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42418152">parent</a><span>|</span><a href="#42418252">prev</a><span>|</span><a href="#42418327">next</a><span>|</span><label class="collapse" for="c-42418210">[-]</label><label class="expand" for="c-42418210">[3 more]</label></div><br/><div class="children"><div class="content">Core team just moved on to something else: <a href="https:&#x2F;&#x2F;werebuilding.ai&#x2F;" rel="nofollow">https:&#x2F;&#x2F;werebuilding.ai&#x2F;</a></div><br/><div id="42418622" class="c"><input type="checkbox" id="c-42418622" checked=""/><div class="controls bullet"><span class="by">8n4vidtmkvmk</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42418210">parent</a><span>|</span><a href="#42418327">next</a><span>|</span><label class="collapse" for="c-42418622">[-]</label><label class="expand" for="c-42418622">[2 more]</label></div><br/><div class="children"><div class="content">That has to be the worst landing page ever</div><br/><div id="42418944" class="c"><input type="checkbox" id="c-42418944" checked=""/><div class="controls bullet"><span class="by">marviel</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42418622">parent</a><span>|</span><a href="#42418327">next</a><span>|</span><label class="collapse" for="c-42418944">[-]</label><label class="expand" for="c-42418944">[1 more]</label></div><br/><div class="children"><div class="content">no comment; not my site, just sharing</div><br/></div></div></div></div></div></div><div id="42418327" class="c"><input type="checkbox" id="c-42418327" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42418152">parent</a><span>|</span><a href="#42418210">prev</a><span>|</span><a href="#42417558">next</a><span>|</span><label class="collapse" for="c-42418327">[-]</label><label class="expand" for="c-42418327">[1 more]</label></div><br/><div class="children"><div class="content">Uh, the product manager left last week.</div><br/></div></div></div></div><div id="42417558" class="c"><input type="checkbox" id="c-42417558" checked=""/><div class="controls bullet"><span class="by">bratao</span><span>|</span><a href="#42416425">root</a><span>|</span><a href="#42416653">parent</a><span>|</span><a href="#42418152">prev</a><span>|</span><a href="#42418277">next</a><span>|</span><label class="collapse" for="c-42417558">[-]</label><label class="expand" for="c-42417558">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, super strange. One cannot finish a sentence without the other interjecting.</div><br/></div></div></div></div><div id="42418277" class="c"><input type="checkbox" id="c-42418277" checked=""/><div class="controls bullet"><span class="by">yeahwhatever10</span><span>|</span><a href="#42416425">parent</a><span>|</span><a href="#42416653">prev</a><span>|</span><a href="#42415641">next</a><span>|</span><label class="collapse" for="c-42418277">[-]</label><label class="expand" for="c-42418277">[1 more]</label></div><br/><div class="children"><div class="content">People like this?</div><br/></div></div></div></div><div id="42415641" class="c"><input type="checkbox" id="c-42415641" checked=""/><div class="controls bullet"><span class="by">qouteall</span><span>|</span><a href="#42416425">prev</a><span>|</span><a href="#42415951">next</a><span>|</span><label class="collapse" for="c-42415641">[-]</label><label class="expand" for="c-42415641">[21 more]</label></div><br/><div class="children"><div class="content">Related quote from Karpathy:<p>Tokenization is at the heart of much weirdness of LLMs. Do not brush it off.<p>• Why can&#x27;t LLM spell words? Tokenization.<p>• Why can&#x27;t LLM do super simple string processing tasks like reversing a string? Tokenization.<p>• Why is LLM worse at non-English languages (e.g. Japanese)? Tokenization.<p>• Why is LLM bad at simple arithmetic? Tokenization.<p>• Why did GPT-2 have more than necessary trouble coding in Python? Tokenization.<p>• Why did my LLM abruptly halt when it sees the string &quot;&lt;|endoftext|&gt;&quot;? Tokenization.<p>• What is this weird warning I get about a &quot;trailing whitespace&quot;? Tokenization.<p>• Why the LLM break if I ask it about &quot;SolidGoldMagikarp&quot;? Tokenization.<p>• Why should I prefer to use YAML over JSON with LLMs? Tokenization.<p>• Why is LLM not actually end-to-end language modeling? Tokenization.<p>• What is the real root of suffering? Tokenization.</div><br/><div id="42415874" class="c"><input type="checkbox" id="c-42415874" checked=""/><div class="controls bullet"><span class="by">withinboredom</span><span>|</span><a href="#42415641">parent</a><span>|</span><a href="#42416206">next</a><span>|</span><label class="collapse" for="c-42415874">[-]</label><label class="expand" for="c-42415874">[9 more]</label></div><br/><div class="children"><div class="content">It’s weird because I’m pretty sure my brain does something similar when I speed read. I don’t actually, usually, read the words; instead I recognize the shape of the words (most common words) then I jump to the subject of the paragraphs and break down the meaning of the whole page in a second or so.</div><br/><div id="42417463" class="c"><input type="checkbox" id="c-42417463" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42415874">parent</a><span>|</span><a href="#42416082">next</a><span>|</span><label class="collapse" for="c-42417463">[-]</label><label class="expand" for="c-42417463">[1 more]</label></div><br/><div class="children"><div class="content">(Author Here)<p>In editing we couldn’t find a good place for this so cut it in the current version, but at one point had discussed a parallel with information density of speech as described by one paper. Essentially the paper found that in languages that were less information dense per syllable, speakers spoke faster to achieve similar information density as languages with higher density per syllable. You could see patching by entropy paralleling this if you consider that low entropy bytes in terms of Shannon entropy are less information dense.</div><br/></div></div><div id="42416082" class="c"><input type="checkbox" id="c-42416082" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42415874">parent</a><span>|</span><a href="#42417463">prev</a><span>|</span><a href="#42416341">next</a><span>|</span><label class="collapse" for="c-42416082">[-]</label><label class="expand" for="c-42416082">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s generally true, but you also have the ability to stop and look closer if you want to. If someone asks you to count the letters in a word, you will stop to look at the letters individually. If you see an unfamiliar word like SolidGoldMagikarp, you can stop and break it apart. Tokenization prevents LLMs from doing this.</div><br/><div id="42416412" class="c"><input type="checkbox" id="c-42416412" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42416082">parent</a><span>|</span><a href="#42417331">next</a><span>|</span><label class="collapse" for="c-42416412">[-]</label><label class="expand" for="c-42416412">[4 more]</label></div><br/><div class="children"><div class="content">Generally the current crop of LLMs seem pretty good analogues of the &quot;scan reading&quot; immediate instinctual response to stimulus, but seems to completely lack the higher level that can then go &quot;Wait, that doesn&#x27;t seem right, let&#x27;s go back over that again&quot;. Like hallucinations and seeing &quot;Faces&quot; in dark shadows until you look again, it&#x27;s like it&#x27;s doing a pretty good emulation of some level of consciousness.<p>Is that a fundamental difference to the level of processing? I haven&#x27;t seen that sort of second-tier logic pop up from any emergence behaviors from increasing scale yet, but will that come with time? I&#x27;m not sure.</div><br/><div id="42417536" class="c"><input type="checkbox" id="c-42417536" checked=""/><div class="controls bullet"><span class="by">visarga</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42416412">parent</a><span>|</span><a href="#42417331">next</a><span>|</span><label class="collapse" for="c-42417536">[-]</label><label class="expand" for="c-42417536">[3 more]</label></div><br/><div class="children"><div class="content">You can prompt the model to do that kind of &quot;stream of mind&quot; process. It will maximize modeling uncertainty. This is my prompt:<p>&gt; Write in a raw, real-time stream-of-consciousness style, as if actively solving a problem. Your response should feel like unpolished notes—messy, exploratory, and authentic. Show your full thought process, including missteps, dead ends, and course corrections. Use markers to signal mental states:
Insights: &quot;Wait -&quot;, &quot;Hold on -&quot;, &quot;Oh -&quot;, &quot;Suddenly seeing -&quot;, &quot;This connects to -&quot;. Testing: &quot;Testing with -&quot;, &quot;Breaking this down -&quot;, &quot;Running an example -&quot;, &quot;Checking if -&quot;. Problems: &quot;Stuck on -&quot;, &quot;This doesn’t work because -&quot;, &quot;Need to figure out -&quot;, &quot;Not quite adding up -&quot;. Progress: &quot;Making headway -&quot;, &quot;Starting to see the pattern -&quot;, &quot;Explains why -&quot;, &quot;Now it makes sense -&quot;. Process: &quot;Tracing the logic -&quot;, &quot;Following this thread -&quot;, &quot;Unpacking this idea -&quot;, &quot;Exploring implications -&quot;. Uncertainty: &quot;Maybe -&quot;, &quot;Could be -&quot;, &quot;Not sure yet -&quot;, &quot;Might explain -&quot;. Transitions: &quot;This leads to -&quot;, &quot;Which means -&quot;, &quot;Building on that -&quot;, &quot;Connecting back to -&quot;. Lean into real-time realizations: &quot;Wait, that won&#x27;t work because…&quot; or &quot;Ah, I missed this…&quot; Show evolving understanding through short paragraphs, with natural pauses where ideas shift.
Structure your thought evolution as follows: Begin with an initial take: &quot;This might work because…&quot; or &quot;At first glance…&quot; Identify problems or angles: &quot;Actually, this doesn’t hold up because…&quot; Test examples or counterexamples: &quot;Let me try -&quot;, &quot;What happens if -&quot;. Seek deeper patterns: &quot;I’m seeing a connection -&quot;, &quot;This ties back to -&quot;. Link broader implications: &quot;This means -&quot;, &quot;If this holds, then -&quot;. Admit confusion openly: &quot;I don’t get this yet&quot;, &quot;Something’s missing here&quot;. Reveal partial understanding: &quot;I see why X, but not Y&quot;. Show failures and iterations: &quot;Still not right - trying another approach&quot;. Embrace a debugging mindset, treating ideas like code—break them into steps, test logic, reveal failure modes, and iterate. Skip introductions and conclusions. Stop when you solve the problem or find clear next steps. Use short, direct sentences to mimic real-time thinking. The goal is to capture the messy, evolving nature of problem-solving and thought refinement.<p>Just try this, you can insert at any point in a LLM chat session. I built it by reverse engineering the QwQ-32B model responses with Claude. QwQ itself is based on the GPT-o1 method.</div><br/><div id="42421822" class="c"><input type="checkbox" id="c-42421822" checked=""/><div class="controls bullet"><span class="by">rattray</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42417536">parent</a><span>|</span><a href="#42419947">next</a><span>|</span><label class="collapse" for="c-42421822">[-]</label><label class="expand" for="c-42421822">[1 more]</label></div><br/><div class="children"><div class="content">FWIW this gave more entertaining but ultimately worse results than without on Claude for me, using the prompt:<p>&gt; How many chickens can fit on a 747?</div><br/></div></div><div id="42419947" class="c"><input type="checkbox" id="c-42419947" checked=""/><div class="controls bullet"><span class="by">astrange</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42417536">parent</a><span>|</span><a href="#42421822">prev</a><span>|</span><a href="#42417331">next</a><span>|</span><label class="collapse" for="c-42419947">[-]</label><label class="expand" for="c-42419947">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve tried prompts like this with Claude, but it can get so nitpicky of itself that it runs out of space for the actual answer. It seems it does help to train the model to do it.</div><br/></div></div></div></div></div></div><div id="42417331" class="c"><input type="checkbox" id="c-42417331" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42416082">parent</a><span>|</span><a href="#42416412">prev</a><span>|</span><a href="#42416341">next</a><span>|</span><label class="collapse" for="c-42417331">[-]</label><label class="expand" for="c-42417331">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve often wanted to talk with an LLM about its tokenization (e.g. how many tokens are there in &quot;the simplest of phrases&quot;)  I wonder if you fed it information about its tokenization (text like &quot;rabbit is spelled r, a, b, b, i, t&quot;) if it could talk about it.</div><br/></div></div></div></div><div id="42416341" class="c"><input type="checkbox" id="c-42416341" checked=""/><div class="controls bullet"><span class="by">dr_dshiv</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42415874">parent</a><span>|</span><a href="#42416082">prev</a><span>|</span><a href="#42416206">next</a><span>|</span><label class="collapse" for="c-42416341">[-]</label><label class="expand" for="c-42416341">[1 more]</label></div><br/><div class="children"><div class="content">Well said!!<p>I’m waiting for reading studies on AI generated text, that’s a different kind of speed read</div><br/></div></div></div></div><div id="42416206" class="c"><input type="checkbox" id="c-42416206" checked=""/><div class="controls bullet"><span class="by">orbital-decay</span><span>|</span><a href="#42415641">parent</a><span>|</span><a href="#42415874">prev</a><span>|</span><a href="#42416580">next</a><span>|</span><label class="collapse" for="c-42416206">[-]</label><label class="expand" for="c-42416206">[1 more]</label></div><br/><div class="children"><div class="content">Meta&#x27;s approach doesn&#x27;t seem to throw out character grouping entirely, it just makes it dynamic.</div><br/></div></div><div id="42416580" class="c"><input type="checkbox" id="c-42416580" checked=""/><div class="controls bullet"><span class="by">rjtavares</span><span>|</span><a href="#42415641">parent</a><span>|</span><a href="#42416206">prev</a><span>|</span><a href="#42417567">next</a><span>|</span><label class="collapse" for="c-42416580">[-]</label><label class="expand" for="c-42416580">[1 more]</label></div><br/><div class="children"><div class="content">Goodbye tokenization problems, hello encoding problems!</div><br/></div></div><div id="42417567" class="c"><input type="checkbox" id="c-42417567" checked=""/><div class="controls bullet"><span class="by">Vetch</span><span>|</span><a href="#42415641">parent</a><span>|</span><a href="#42416580">prev</a><span>|</span><a href="#42416629">next</a><span>|</span><label class="collapse" for="c-42417567">[-]</label><label class="expand" for="c-42417567">[1 more]</label></div><br/><div class="children"><div class="content">!Long post warning!<p>Tokenization is often scapegoated for many transformer limitations. I suppose it&#x27;s because reading about the many limitations of the transformer architecture is harder than dumping everything on tokenization (which to be fair, is often indirectly involved with or exacerbating some deeper issue).<p>&gt; Why can&#x27;t LLM spell words? Tokenization.<p>LLMs can spell if you ask them to though. And there have been investigations into this capability (ref:2). Tokenization makes computations that involve spelling more difficult, but this is downstream of deeper computational limitations of the architecture.<p>&gt; Why can&#x27;t LLM do super simple string processing tasks like reversing a string?<p>Ditto.<p>&gt; Why is LLM worse at non-English languages (e.g. Japanese)? Tokenization.<p>Tokenization is also implicitly performing compression. If your tokenizer&#x27;s corpus is focused only on english, basic information theory explains why it&#x27;ll be less efficient for other languages. The net effect is longer sequences where tokens are less information dense for non-english languages on average.<p>&gt; Why is LLM bad at simple arithmetic? Tokenization.<p>Tokenization could treat digits separately and I believe, llama2 did this. But OpenAI built tiktoken which does not do this. llama3 uses tiktoken.<p>The transformer architecture also has limitations that make (default) arithmetic computations involving carries difficult to learn. You can read more about this in (ref:1).<p>&gt; Why did my LLM abruptly halt when it sees the string &quot;&lt;|endoftext|&gt;&quot;? Tokenization.<p>Why should it not? Either way, it doesn&#x27;t have to halt, as the sampler can just ignore this. But the distribution will still condition on this as a change of topic switch. The question should probably be, why did the LLM suddenly assign high probability to a stop token before finishing whatever it was writing?<p>&gt; What is this weird warning I get about a &quot;trailing whitespace&quot;? Tokenization.<p>Modeling decisions for how to treat whitespace is upstream of tokenization. These choices affect how the LLM models word boundaries. Things can be fine most of the time until they aren&#x27;t.<p>There&#x27;s also the issue of softmax. The way softmax is typically applied forces the model to always assign importance to some tokens, even when no strong relationships exist between them. This in turn leads to the model disproportionately dumping its focus on often semantically unimportant tokens like whitespace or punctuation. Misallocating attention in this manner can lead to wasting representational capacity due to overemphasizing unimportant tokens, perhaps inducing spurious correlations on whitespace. This issue propagates through the model, possibly leading to unexpected negative downstream effects.<p>&gt; Why the LLM break if I ask it about &quot;SolidGoldMagikarp&quot;? Tokenization.<p>One step down, it&#x27;s really a result of high dimensional random vectors.<p>&gt; Why should I prefer to use YAML over JSON with LLMs? Tokenization.<p>&gt; Why did GPT-2 have more than necessary trouble coding in Python? Tokenization.<p>Tokenization does make counting more difficult but the net benefit to programming languages where whitespace can be semantically meaningful is a strong positive. Even when whitespace is not meaningful, long strings of them can often be encountered. Not being careful about devoting tokenization effort on whitespace will significantly degrade code modeling ability in LLMs.<p>&gt; Why is LLM not actually end-to-end language modeling? Tokenization.<p>This is correct, but it is not necessarily the case that a character or byte based model will automatically be better. The issue is that LLMs as currently devised spend the same amount of computation per token. This creates the immediate problem of making meaningful sequences, which will now be substantially longer, substantially more expensive to compute, generate and store in memory. This is what the posted paper seeks to address over naive byte level modeling. Although it&#x27;s unclear from the provided tables if what&#x27;s claimed is actually what&#x27;s occurring.<p>Character level modeling will also make learning long ranged dependencies harder. Subword tokenization also aids in memorization, which can be useful in learning from the tail of the distribution. The following idea is based on (ref:5).<p>Next-token prediction can be modeled as a hierarchical sampling process where problem instances (topics, natural language tasks), which are mixture distributions, are drawn from a metadistribution, and then data points (eg various strings) are sampled from specific subpopulations (ie clusters of task types) within those instances. Here, memorization is a key strategy since there&#x27;s initial uncertainty about which features are relevant for predicting the next token. Particularly for rare examples, memorizing their details acts as a starting point for associating particular patterns with specific subpopulations, in turn allowing more accurate prediction of new points.<p>From that starting point, the model can eventually refine its associations as it encounters more data. This is key for example, when sampling from the tail of the distribution where data about subpopulations will be more limited. Making memorization and learning longer dependencies more challenging can lead to final models that face more difficulty during ICL inference, which depends, among other things, on the ability to infer which task from a mixture distribution.<p>&gt; What is the real root of suffering? Tokenization.<p>A better candidate is over-generalization.<p>1: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2310.16028" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2310.16028</a><p>2: What do tokens know about their characters and how do they know it? (<a href="https:&#x2F;&#x2F;aclanthology.org&#x2F;2022.naacl-" rel="nofollow">https:&#x2F;&#x2F;aclanthology.org&#x2F;2022.naacl-</a>
main.179.pdf)<p>3: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2406.10851" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2406.10851</a><p>4: Between words and characters: A Brief History of Open-Vocabulary Modeling and Tokenization in NLP (<a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2112.10508" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2112.10508</a>)<p>5: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2012.06421" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2012.06421</a></div><br/></div></div><div id="42416497" class="c"><input type="checkbox" id="c-42416497" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42415641">parent</a><span>|</span><a href="#42416629">prev</a><span>|</span><a href="#42415951">next</a><span>|</span><label class="collapse" for="c-42416497">[-]</label><label class="expand" for="c-42416497">[7 more]</label></div><br/><div class="children"><div class="content">In all seriousness: why has it been years now and it feels like there is no incremental engineering-level progress on these issues? Like, it seems like doing some manual intervention to the tokenization to at least remove exceptional tokens and add some semantics to how they break up numbers seem like quick wins.</div><br/><div id="42417504" class="c"><input type="checkbox" id="c-42417504" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42416497">parent</a><span>|</span><a href="#42417321">next</a><span>|</span><label class="collapse" for="c-42417504">[-]</label><label class="expand" for="c-42417504">[1 more]</label></div><br/><div class="children"><div class="content">(Author Here)<p>There is at least some work on character based modeling, but it hasn’t scaled well before. The challenge I think with something more adhoc for exceptional tokens is that it’s hard to see gains since they are by definition, infrequent. If the text is rare enough, BPE should produce many single byte tokens, so current models actually expend more compute on these rare sequences.<p>BLT scales well because it expends less compute (by patching) on more predictable (low entropy) byte sequences. Current models only to some degree get this benefit, if it’s a larger BPE token, but that only goes so far.<p>So it’s really two related, but different motivations.</div><br/></div></div><div id="42417321" class="c"><input type="checkbox" id="c-42417321" checked=""/><div class="controls bullet"><span class="by">falcor84</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42416497">parent</a><span>|</span><a href="#42417504">prev</a><span>|</span><a href="#42415951">next</a><span>|</span><label class="collapse" for="c-42417321">[-]</label><label class="expand" for="c-42417321">[5 more]</label></div><br/><div class="children"><div class="content">&gt;In all seriousness: why has it been years now and it feels like there is no incremental engineering-level progress on these issues?<p>From where I&#x27;m standing, LLMs appear to be the fastest moving technological field in history.</div><br/><div id="42417518" class="c"><input type="checkbox" id="c-42417518" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42417321">parent</a><span>|</span><a href="#42419441">next</a><span>|</span><label class="collapse" for="c-42417518">[-]</label><label class="expand" for="c-42417518">[3 more]</label></div><br/><div class="children"><div class="content">A field can seem to be going quickly and going nowhere at the same time. Or rather a new technique can be invented and then exhausted in the time it takes somebody to get a PhD.  (See <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Renormalization_group" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Renormalization_group</a> applied to phase transitions, which turned up just in time for the physics job crisis of 1970)<p>I didn&#x27;t ever believe that there was going to be a GPT-5 trained with exponentially more text and resources.  Not only is there not enough text,  but that&#x27;s the path to ruin.  Why?<p>Cycle time.  Two years ago we had little idea of how those models work so I knew there was a huge room in improving performance.  It gets the cost down,  it lets you put the models on your device,  and it speeds up development.  If I can train 10 models in the time it takes you to train 1 model I can make much faster progress.<p>However even a GPT-15 trained with a Dyson sphere is going to struggle to sort things.  (Structurally a pure LLM can&#x27;t do that!) My #1 beef with Microsoft&#x27;s Copilot is that you can ask it if it can sort a certain list of items (either a list you are discussing with it or say &quot;states of the United States ordered by percent water area&quot;) it will say yes and if you ask it what it thinks the probability is that it will get it in the right order it will say &quot;very high&quot; but when you try it the list comes out totally wrong.<p>It is equally unable to &quot;help me make an atom bomb&quot; except in the bomb case it will say that it can&#x27;t but in the sorting case it says it can.<p>The obvious answer is that it should use tools to sort.  That&#x27;s right but the problem of &quot;knowing what you can really do with your tools&quot; is philosophically challenged.  (With problems so intractable it leads people like Roger Penrose to conclude &quot;I couldn&#x27;t do math if I wasn&#x27;t a thetan&quot;)</div><br/><div id="42417822" class="c"><input type="checkbox" id="c-42417822" checked=""/><div class="controls bullet"><span class="by">JustAndy</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42417518">parent</a><span>|</span><a href="#42419441">next</a><span>|</span><label class="collapse" for="c-42417822">[-]</label><label class="expand" for="c-42417822">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really sure I understand your sorting example, maybe try it out in gpt and post the link to show exactly what you mean.<p>The refusal of the model is something trained into the model by the process of rlhf, and it can also be untrained, by the process of abliteration [1].<p>Also, LLMs are capable of using tools in this very moment [2].<p>[1]: <a href="https:&#x2F;&#x2F;huggingface.co&#x2F;blog&#x2F;mlabonne&#x2F;abliteration" rel="nofollow">https:&#x2F;&#x2F;huggingface.co&#x2F;blog&#x2F;mlabonne&#x2F;abliteration</a>
[2]: <a href="https:&#x2F;&#x2F;www.anthropic.com&#x2F;news&#x2F;analysis-tool" rel="nofollow">https:&#x2F;&#x2F;www.anthropic.com&#x2F;news&#x2F;analysis-tool</a></div><br/><div id="42418979" class="c"><input type="checkbox" id="c-42418979" checked=""/><div class="controls bullet"><span class="by">PaulHoule</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42417822">parent</a><span>|</span><a href="#42419441">next</a><span>|</span><label class="collapse" for="c-42418979">[-]</label><label class="expand" for="c-42418979">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m deliberately blurring refusal with having an accurate picture of its own abilities and,  past that,  having an accurate picture of of what it can do given tools.  Both are tested by<p><pre><code>   &quot;Can you X?&quot;
</code></pre>
With refusal you find just how shallow it is because it really will answer all sorts of questions that are &quot;helpful&quot; in making a nuclear bomb but when you ask it directly it shuts up.  In another sense nothing it does is &quot;helpful&quot; because it&#x27;s not going to hunt down some people in central asia who have 50kg of U235 burning a hole in their pocket for you,  which is what would actually &quot;help&quot;.<p>I use tool using LLMs frequently,  but I find they frequently need help using their tools,  it is a lot of fun to talk to Windsurf about the struggles it has with its tools and it feels strangely satisfying to help it out.</div><br/></div></div></div></div></div></div><div id="42419441" class="c"><input type="checkbox" id="c-42419441" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#42415641">root</a><span>|</span><a href="#42417321">parent</a><span>|</span><a href="#42417518">prev</a><span>|</span><a href="#42415951">next</a><span>|</span><label class="collapse" for="c-42419441">[-]</label><label class="expand" for="c-42419441">[1 more]</label></div><br/><div class="children"><div class="content">You totally ignored &quot;on these issues&quot; and are essentially saying there is no need to work on that as they worked on something else, which is extremely strange for a thing which feels like a really trivial win, and should be shocking.<p>Whether you like it or not, it is entirely fair to look at an entire ecosystem and ask why some trivial thing that everyone talks about all the time hasn&#x27;t seen any attention even if the entire ecosystem is getting widespread advancement.<p>Like, I think it would also be fair to complain about how bad the hinge on AirPods are, causing the case to explode when dropped and your earbuds to fly everywhere (potentially getting very dirty) as well as wear out and cause spurious activation (leading to audio routing issues and rapid battery drain).<p>To then point out that this is one of the most successful consumer devices in recent years and was a remarkable improvement to what came before as well as a continuing achievement of engineering as they do in fact get better in amazing ways every couple years is more than just a non sequitur: it is frankly just annoying.</div><br/></div></div></div></div></div></div></div></div><div id="42415951" class="c"><input type="checkbox" id="c-42415951" checked=""/><div class="controls bullet"><span class="by">paraschopra</span><span>|</span><a href="#42415641">prev</a><span>|</span><a href="#42415587">next</a><span>|</span><label class="collapse" for="c-42415951">[-]</label><label class="expand" for="c-42415951">[6 more]</label></div><br/><div class="children"><div class="content">My notes:<p>It&#x27;s a 3 component model.<p>- Encoder: Takes byte groupings and outputs a hidden state&#x2F;encoding called patches<p>- Transformer: Takes these encodings of patches in autoregressive fashion<p>- Decoder: Takes processed encodings by transformers and outputs bytes<p>Loss is on byte to byte crossentropy (Next byte prediction)<p>How they group bytes.<p>- Use entropy thresholds: If a sequence of bytes have entropy lower than a threshold, group them<p>- This is a learned model (from data)<p>Why this helps over current byte-pair tokenization in LLMs.<p>- Encoder&#x2F;decoder essentially act as “learnable” tokenization scheme<p>- Better efficiency tradeoffs (as for highly predictable sequence of bytes, encoder can “offload” computation effort from the main transformer)<p>- History teaches us that end to end learned system beats human designed mechanisms</div><br/><div id="42416125" class="c"><input type="checkbox" id="c-42416125" checked=""/><div class="controls bullet"><span class="by">CuriousSkeptic</span><span>|</span><a href="#42415951">parent</a><span>|</span><a href="#42416410">next</a><span>|</span><label class="collapse" for="c-42416125">[-]</label><label class="expand" for="c-42416125">[2 more]</label></div><br/><div class="children"><div class="content">&gt; History teaches us that end to end learned system beats human designed mechanisms<p>I think this may need some qualifiers<p>Even byte representations are human designed encodings. I would think a human designed decoder of such encodings must be more efficient than learning. Sure bytes encoding a stream of unicode code points maps fairly easy to useful information. But bytes representing a zip compressed collection of PDF files?<p>I did wonder though, training on text encoding vs pixel encoding, perhaps brute forcing OCR, like humans, will be more flexible in the end then being limited to text encodings.</div><br/><div id="42416729" class="c"><input type="checkbox" id="c-42416729" checked=""/><div class="controls bullet"><span class="by">paraschopra</span><span>|</span><a href="#42415951">root</a><span>|</span><a href="#42416125">parent</a><span>|</span><a href="#42416410">next</a><span>|</span><label class="collapse" for="c-42416729">[-]</label><label class="expand" for="c-42416729">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Even byte representations are human designed encodings<p>The point is that it can model any sequence of bytes. It&#x27;s what-follows-what that matters, not how we&#x27;re encoding it.</div><br/></div></div></div></div><div id="42416410" class="c"><input type="checkbox" id="c-42416410" checked=""/><div class="controls bullet"><span class="by">hiddencost</span><span>|</span><a href="#42415951">parent</a><span>|</span><a href="#42416125">prev</a><span>|</span><a href="#42416631">next</a><span>|</span><label class="collapse" for="c-42416410">[-]</label><label class="expand" for="c-42416410">[2 more]</label></div><br/><div class="children"><div class="content">&gt; History teaches us that end to end learned system beats human designed mechanisms<p>Depends how far back you go. History teaches us that everything is a trade off between model size, inference time, training time, and training data size, Once you&#x27;re at the pareto frontier. And that cheap approximations can allow you to trade for more expensive computation elsewhere.<p>That lesson has been obscured for the last decade because (1) &quot;the bitter lesson&quot; of scaling, and, (2), we&#x27;re blowing past benchmarks too quickly.<p>I do agree that learned models are better if they&#x27;re free (compare the distribution of filter banks learned by a neutral acoustic model to those approximated by mel frequency cepstral coefficients), but once you start hitting scaling limits, cheap heuristics start creeping back in.<p>BPE was a huge advancement over fixed vocab, e.g.</div><br/><div id="42417550" class="c"><input type="checkbox" id="c-42417550" checked=""/><div class="controls bullet"><span class="by">entilzha</span><span>|</span><a href="#42415951">root</a><span>|</span><a href="#42416410">parent</a><span>|</span><a href="#42416631">next</a><span>|</span><label class="collapse" for="c-42417550">[-]</label><label class="expand" for="c-42417550">[1 more]</label></div><br/><div class="children"><div class="content">(Author Here)<p>Related thought, I think BPE is quite a good, cheap inductive bias to have in a model, which is part of what made it challenging to scale better against. I also suspect this is part of why with less training FLOPs BPE is better (left side of figure 1), BLT has to expend some of its FLOPs budget to recover&#x2F;learn some of this useful bias. With more training FLOPs this becomes a smaller fraction of the budget though leading to better scaling.</div><br/></div></div></div></div></div></div><div id="42415587" class="c"><input type="checkbox" id="c-42415587" checked=""/><div class="controls bullet"><span class="by">bloomingkales</span><span>|</span><a href="#42415951">prev</a><span>|</span><a href="#42415906">next</a><span>|</span><label class="collapse" for="c-42415587">[-]</label><label class="expand" for="c-42415587">[5 more]</label></div><br/><div class="children"><div class="content">I thought we’re supposed to be plateauing!?</div><br/><div id="42416010" class="c"><input type="checkbox" id="c-42416010" checked=""/><div class="controls bullet"><span class="by">ArnoVW</span><span>|</span><a href="#42415587">parent</a><span>|</span><a href="#42419745">next</a><span>|</span><label class="collapse" for="c-42416010">[-]</label><label class="expand" for="c-42416010">[3 more]</label></div><br/><div class="children"><div class="content">We are. Plateauing doesnt mean you don&#x27;t book progress. Arguably that is what you would call &quot;plateaud&quot;.<p>The argument of plateauing is not that AI is fundamentally impossible. The argument is that just dumping more data and more compute on the problem, using the same approach, has diminishing returns.<p>It&#x27;s that statistical inference is not how the human mind works (not exclusively) and thus that we are not <i>guaranteed</i> to be able to replicate all traits of human intelligence by brute forcing.<p>Of course we can and will still improve the algorithms. But the question remains whether tweaks like these, as cool and useful they may be to solve certain issues, will be enough by themselves.<p>Since it remains statistical in nature, my position is &quot;no&quot;.</div><br/><div id="42416301" class="c"><input type="checkbox" id="c-42416301" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#42415587">root</a><span>|</span><a href="#42416010">parent</a><span>|</span><a href="#42419745">next</a><span>|</span><label class="collapse" for="c-42416301">[-]</label><label class="expand" for="c-42416301">[2 more]</label></div><br/><div class="children"><div class="content">&gt; that we are not guaranteed to be able to replicate all traits of human intelligence by brute forcing.<p>We know from complexity theory that transformers with chain of thought are guaranteed to be able to reproduce a significant fraction of human reasoning, anything in the complexity class PTIME: <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2310.07923" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2310.07923</a></div><br/><div id="42417276" class="c"><input type="checkbox" id="c-42417276" checked=""/><div class="controls bullet"><span class="by">fl0id</span><span>|</span><a href="#42415587">root</a><span>|</span><a href="#42416301">parent</a><span>|</span><a href="#42419745">next</a><span>|</span><label class="collapse" for="c-42417276">[-]</label><label class="expand" for="c-42417276">[1 more]</label></div><br/><div class="children"><div class="content">I don’t think this paper says what you claim. It says chain of reasoning and its length can improve transformer performance. Not that this represent a significant fraction of human reasoning or that it’s even reasoning</div><br/></div></div></div></div></div></div><div id="42419745" class="c"><input type="checkbox" id="c-42419745" checked=""/><div class="controls bullet"><span class="by">random3</span><span>|</span><a href="#42415587">parent</a><span>|</span><a href="#42416010">prev</a><span>|</span><a href="#42415906">next</a><span>|</span><label class="collapse" for="c-42419745">[-]</label><label class="expand" for="c-42419745">[1 more]</label></div><br/><div class="children"><div class="content">who&#x27;s &quot;we&quot;?</div><br/></div></div></div></div><div id="42415906" class="c"><input type="checkbox" id="c-42415906" checked=""/><div class="controls bullet"><span class="by">fabmilo</span><span>|</span><a href="#42415587">prev</a><span>|</span><label class="collapse" for="c-42415906">[-]</label><label class="expand" for="c-42415906">[3 more]</label></div><br/><div class="children"><div class="content">I am gonna read this paper and the other latent sentence later today. I always advocated for this kind of solutions together with latent sentence search should get to the next level of AI. Amazing work from Meta</div><br/><div id="42416057" class="c"><input type="checkbox" id="c-42416057" checked=""/><div class="controls bullet"><span class="by">CuriousSkeptic</span><span>|</span><a href="#42415906">parent</a><span>|</span><label class="collapse" for="c-42416057">[-]</label><label class="expand" for="c-42416057">[2 more]</label></div><br/><div class="children"><div class="content">Sentence thing being this one? <a href="https:&#x2F;&#x2F;ai.meta.com&#x2F;research&#x2F;publications&#x2F;large-concept-models-language-modeling-in-a-sentence-representation-space&#x2F;" rel="nofollow">https:&#x2F;&#x2F;ai.meta.com&#x2F;research&#x2F;publications&#x2F;large-concept-mode...</a><p>I don’t get it, isn’t this concept modelling exactly whats going on in the deeper layers of current LLMs?</div><br/><div id="42417274" class="c"><input type="checkbox" id="c-42417274" checked=""/><div class="controls bullet"><span class="by">kmacdough</span><span>|</span><a href="#42415906">root</a><span>|</span><a href="#42416057">parent</a><span>|</span><label class="collapse" for="c-42417274">[-]</label><label class="expand" for="c-42417274">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps it does some similar grouping of content, but this more directly incentivizes longer term gripping of tokens into abstract concepts. I agree that it&#x27;s not obvious this would perform better than letting the model build it&#x27;s own structures for grouping tokens, but the proof is in the pudding; the technique led to improved results for a given model &amp; training size. This newer approach gives the model the freedom to build it&#x27;s own breakpoints, but still bakes the idea into the algorithm itself.<p>What it means is a harder question. Perhaps transformers are simply an inefficient computational structure for this process? Perhaps a more flexible computational structure would integrate this step more efficiently? Perhaps Transformers are efficient enough, but our learning&#x2F;densifying isn&#x27;t? Or perhaps it&#x27;s such a core powerful step that it might as well be built into the algo regardless? Much to learn.</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>