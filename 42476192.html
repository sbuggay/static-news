<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1734771666194" as="style"/><link rel="stylesheet" href="styles.css?v=1734771666194"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://arxiv.org/abs/2412.15042">Compiling C to Safe Rust, Formalized</a> <span class="domain">(<a href="https://arxiv.org">arxiv.org</a>)</span></div><div class="subtext"><span>love2read</span> | <span>72 comments</span></div><br/><div><div id="42476523" class="c"><input type="checkbox" id="c-42476523" checked=""/><div class="controls bullet"><span class="by">wffurr</span><span>|</span><a href="#42477991">next</a><span>|</span><label class="collapse" for="c-42476523">[-]</label><label class="expand" for="c-42476523">[11 more]</label></div><br/><div class="children"><div class="content">Note that this is done for “existing formally verified C codebases” which is a lot different from typical systems C code which is not formally verified.</div><br/><div id="42478051" class="c"><input type="checkbox" id="c-42478051" checked=""/><div class="controls bullet"><span class="by">safercplusplus</span><span>|</span><a href="#42476523">parent</a><span>|</span><a href="#42477360">next</a><span>|</span><label class="collapse" for="c-42478051">[-]</label><label class="expand" for="c-42478051">[1 more]</label></div><br/><div class="children"><div class="content">And even then, not completely reliably it seems (from Section 2.2):<p>&gt; The coercions introduced by conversion rules can however lead to subtle semantic differences<p>The example they give is this C code:<p><pre><code>    1 uint8_t x[1] = { 0 };
    2 uint8_t *y = x;
    3 *y = 1;
    4 assert(*x == 1); &#x2F;* SUCCESS *&#x2F;
</code></pre>
getting translated to this (safe) Rust code:<p><pre><code>    1 let x: [u8; 1] = [0; 1];
    2 let mut y: Box&lt;[u8]&gt; = Box::new(x);
    3 y[0] = 1;
    4 assert!(x[0] == 1) &#x2F;* failure *&#x2F;
</code></pre>
So the pointer (iterator) targeting an existing (stack-allocated) array declared on line 2 gets translated to an owning pointer&#x2F;Box) targeting a (heap-allocated) new copy of the array. So if the original code was somehow counting on the fact that the pointer iterator was actually targeting the array it was assigned to, the translated code may (quietly) not behave correctly.<p>For comparison, the scpptool (my project) auto-translation (to a memory safe subset of C++) feature would translate it to something like:<p><pre><code>    1 mse::lh::TNativeArrayReplacement&lt;uint8_t, 1&gt; x = { 0 };
    2 mse::lh::TNativeArrayReplacement&lt;uint8_t, 1&gt;::iterator y = x; &#x2F;&#x2F; implicit conversion from array to iterator
    3 *y = 1;
    4 assert(*x == 1); &#x2F;* SUCCESS *&#x2F; &#x2F;&#x2F; dereferencing of array supported for compatibility
</code></pre>
or if y is subsequently retargeted at another type of array, then line 2 may end up as something like:<p><pre><code>    2 mse::TAnyRandomAccessIterator&lt;uint8_t&gt; y = x; &#x2F;&#x2F; implicit conversion from array to iterator
</code></pre>
So the OP project may only be converting C code that is already amenable to being converted to safe Rust. But given the challenge of the problem, I can respect the accomplishment and see some potential utility in it.<p>edit: added translation for line 2 in an alternate hypothetical situation.</div><br/></div></div><div id="42477360" class="c"><input type="checkbox" id="c-42477360" checked=""/><div class="controls bullet"><span class="by">tonetegeatinst</span><span>|</span><a href="#42476523">parent</a><span>|</span><a href="#42478051">prev</a><span>|</span><a href="#42476623">next</a><span>|</span><label class="collapse" for="c-42477360">[-]</label><label class="expand" for="c-42477360">[8 more]</label></div><br/><div class="children"><div class="content">What is the main difference? Can compiler flags force compliance?</div><br/><div id="42477464" class="c"><input type="checkbox" id="c-42477464" checked=""/><div class="controls bullet"><span class="by">LPisGood</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42477360">parent</a><span>|</span><a href="#42478005">next</a><span>|</span><label class="collapse" for="c-42477464">[-]</label><label class="expand" for="c-42477464">[2 more]</label></div><br/><div class="children"><div class="content">My understanding is that formal verification is a tough goal to achieve and that it usually requires designing the program or the language to be a specific way.<p>The problem with transpiling C to rust is that unsafe and unverified behavior can be a key property of the behavior resulting program, so there isn’t an obvious way to spit out a sort of rustified (CRustified?) binary that matches the behavior of the C program.</div><br/><div id="42477806" class="c"><input type="checkbox" id="c-42477806" checked=""/><div class="controls bullet"><span class="by">thunkingdeep</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42477464">parent</a><span>|</span><a href="#42478005">next</a><span>|</span><label class="collapse" for="c-42477806">[-]</label><label class="expand" for="c-42477806">[1 more]</label></div><br/><div class="children"><div class="content">Typical term is “Oxidized”. I think they feel clever when they do the RiiR thing and say that.</div><br/></div></div></div></div><div id="42478005" class="c"><input type="checkbox" id="c-42478005" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42477360">parent</a><span>|</span><a href="#42477464">prev</a><span>|</span><a href="#42477457">next</a><span>|</span><label class="collapse" for="c-42478005">[-]</label><label class="expand" for="c-42478005">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Formally verified&quot; means someone has written a correct mathematical proof that the code has no bugs (the proof is checked by a computer program to make sure it is correct). This is a very high bar.<p>I&#x27;m not sure what it has to do with translating the code to Rust.</div><br/><div id="42478118" class="c"><input type="checkbox" id="c-42478118" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42478005">parent</a><span>|</span><a href="#42478080">next</a><span>|</span><label class="collapse" for="c-42478118">[-]</label><label class="expand" for="c-42478118">[1 more]</label></div><br/><div class="children"><div class="content">In this case specifically, two separate aspects are being referred to with regard to &quot;formal verification&quot;.<p>The first is that the translation function (from C to Rust) has itself been formally verified. In other words: if you give it a C program that obeys certain necessary pre-conditions, it will give you a safe Rust program. I believe the title of the paper is primarily using &quot;Formalized&quot; with regard to this characteristic.<p>The second is that the set of programs the authors evaluate their tool on are C programs that have themselves been formally verified. I only barely skimmed the introduction and didn&#x27;t see it addressed directly there, but I would assume that this is because the pre-conditions necessary for their translation to work are most easily (only?) met by formally verified C programs, where of course the verification has been rendered with respect to properties that would be relevant here (e.g., memory use).</div><br/></div></div><div id="42478080" class="c"><input type="checkbox" id="c-42478080" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42478005">parent</a><span>|</span><a href="#42478118">prev</a><span>|</span><a href="#42477457">next</a><span>|</span><label class="collapse" for="c-42478080">[-]</label><label class="expand" for="c-42478080">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure what it has to do with translating the code to Rust.<p>Formally verified C programs typically have had all their undefined behaviour already stamped out during the verification process. That makes mapping it over to Rust a lot simpler.</div><br/><div id="42478334" class="c"><input type="checkbox" id="c-42478334" checked=""/><div class="controls bullet"><span class="by">tjoff</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42478080">parent</a><span>|</span><a href="#42477457">next</a><span>|</span><label class="collapse" for="c-42478334">[-]</label><label class="expand" for="c-42478334">[1 more]</label></div><br/><div class="children"><div class="content">Translating undefined behavior is the easy part.</div><br/></div></div></div></div></div></div><div id="42477457" class="c"><input type="checkbox" id="c-42477457" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#42476523">root</a><span>|</span><a href="#42477360">parent</a><span>|</span><a href="#42478005">prev</a><span>|</span><a href="#42476623">next</a><span>|</span><label class="collapse" for="c-42477457">[-]</label><label class="expand" for="c-42477457">[1 more]</label></div><br/><div class="children"><div class="content">Formal verification often requires simplified code in a restrictive style. You might not even be able to use C features or structures that have the performance you want. How theorem provers and brains work are also different enough that making something easy for one often makes it harder for the other.<p>You can also see this effect in the article on the history of Coverity’s analyzer. Real-world code was horrible to deal with vs the academic examples they started with.<p><a href="https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-few-billion-lines-of-code-later&#x2F;" rel="nofollow">https:&#x2F;&#x2F;cacm.acm.org&#x2F;research&#x2F;a-few-billion-lines-of-code-la...</a></div><br/></div></div></div></div></div></div><div id="42477991" class="c"><input type="checkbox" id="c-42477991" checked=""/><div class="controls bullet"><span class="by">zoom6628</span><span>|</span><a href="#42476523">prev</a><span>|</span><a href="#42476714">next</a><span>|</span><label class="collapse" for="c-42477991">[-]</label><label class="expand" for="c-42477991">[7 more]</label></div><br/><div class="children"><div class="content">I wonder how this compares to the zig-to-C translate  function.<p>Zig seems to be awesome at creating mixed environs of zig for new code and C for old, and translating or interop, plus being a C compiler.<p>There must be some very good reasons why Linux kernel maintainers aren&#x27;t looking to zig as a C replacement rather than Rust.<p>I don&#x27;t know enough to even speculate so would appreciate those with more knowledge and experiencing weighing in.</div><br/><div id="42478047" class="c"><input type="checkbox" id="c-42478047" checked=""/><div class="controls bullet"><span class="by">ChristianJacobs</span><span>|</span><a href="#42477991">parent</a><span>|</span><a href="#42478054">next</a><span>|</span><label class="collapse" for="c-42478047">[-]</label><label class="expand" for="c-42478047">[4 more]</label></div><br/><div class="children"><div class="content">&gt; looking to zig as a C replacement rather than Rust<p>Rust isn&#x27;t a &quot;replacement for C&quot;, but an addition to it. It&#x27;s a tool that Torvalds et. al. has recognised the value of and thus it&#x27;s been allowed in the kernel. The majority of the kernel code will still be written in C.<p>I&#x27;m no kernel maintainer, but I can speculate that two of the main reasons for Rust over Zig are the compile time guarantees that the language provides being better as well as the rate of adoption. There is a lot of work done by many leading companies in the industry to provide Rust native code or maintained Rust bindings for their APIs. Windows devs are re-writing parts of _their_ kernel in Rust. There&#x27;s a &quot;movement&quot; going on that has been going on for a while. I only hope it doesn&#x27;t stop.<p>Maybe the maintainers feel like Zig doesn&#x27;t give them enough over C to be worth the change? Many of them are still opposed to Rust as well.</div><br/><div id="42478139" class="c"><input type="checkbox" id="c-42478139" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#42477991">root</a><span>|</span><a href="#42478047">parent</a><span>|</span><a href="#42478241">next</a><span>|</span><label class="collapse" for="c-42478139">[-]</label><label class="expand" for="c-42478139">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Rust isn&#x27;t a &quot;replacement for C&quot;<p>Hmm I think to clarify I would say that Rust _is_ intended as a replacement for C in general, but that this isn&#x27;t how the Linux kernel developers are choosing to use it.<p>As for why the kernel developers would choose Rust, I would think another one of the primary benefits is that the type system guarantees the absence of a wide class of memory-related errors that are prevalent in C, and this type system (as well as those of its predecessors) has been subjected to significant scrutiny by the academic community over the last couple of decades to help iron out problems. I suspect this is also part of why Rust has a relatively large and passionate community compared to other C alternatives.</div><br/><div id="42478360" class="c"><input type="checkbox" id="c-42478360" checked=""/><div class="controls bullet"><span class="by">burakemir</span><span>|</span><a href="#42477991">root</a><span>|</span><a href="#42478139">parent</a><span>|</span><a href="#42478241">next</a><span>|</span><label class="collapse" for="c-42478360">[-]</label><label class="expand" for="c-42478360">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. The large and passionate community may have multiple factors but &quot;things actually work&quot; is probably a factor.<p>It is hard to get a full picture of how academic research influenced Rust and vice versa. Two examples:<p>- The use of linearity for tracking ownership in types has been known to academics but had never found its way into a mainstream language.<p>- researchers in programming language semantics pick Rust as a target of formalization, which was only possible because of design choices around type system. They  were able to apply techniques that resulted from decades of trying to get a certified C. They have formalized parts of the standard library, including unsafe Rust, and found and fixed bugs.<p>So it seems fair to say that academic research on safety for C has contributed much to what makes Rust work today, and in ways that are not possible for C and C++ because these languages do not offer static guarantees where types Transport information about exclusive access to some part of memory.</div><br/></div></div></div></div><div id="42478241" class="c"><input type="checkbox" id="c-42478241" checked=""/><div class="controls bullet"><span class="by">josefx</span><span>|</span><a href="#42477991">root</a><span>|</span><a href="#42478047">parent</a><span>|</span><a href="#42478139">prev</a><span>|</span><a href="#42478054">next</a><span>|</span><label class="collapse" for="c-42478241">[-]</label><label class="expand" for="c-42478241">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s a tool that Torvalds et. al. has recognised the value of and thus it&#x27;s been allowed in the kernel.<p>Has there actually been a successfull contribution to the mainline kernel? The last two big projects I heard of (ext2 &#x2F; Apple drivers) seemed to have issues getting their code accepted.</div><br/></div></div></div></div><div id="42478054" class="c"><input type="checkbox" id="c-42478054" checked=""/><div class="controls bullet"><span class="by">spiffyk</span><span>|</span><a href="#42477991">parent</a><span>|</span><a href="#42478047">prev</a><span>|</span><a href="#42478032">next</a><span>|</span><label class="collapse" for="c-42478054">[-]</label><label class="expand" for="c-42478054">[1 more]</label></div><br/><div class="children"><div class="content">Zig is nowhere near mature enough to be considered for the kernel yet. There are breaking changes to it regularly still - which is a good thing for Zig now, but not so good for huge, long-lived codebases like Linux. Also compiler bugs happen.<p>Saying this as someone who generally likes Zig&#x27;s direction.</div><br/></div></div><div id="42478032" class="c"><input type="checkbox" id="c-42478032" checked=""/><div class="controls bullet"><span class="by">capitol_</span><span>|</span><a href="#42477991">parent</a><span>|</span><a href="#42478054">prev</a><span>|</span><a href="#42476714">next</a><span>|</span><label class="collapse" for="c-42478032">[-]</label><label class="expand" for="c-42478032">[1 more]</label></div><br/><div class="children"><div class="content">Maybe because zig isn&#x27;t memory safe.</div><br/></div></div></div></div><div id="42476714" class="c"><input type="checkbox" id="c-42476714" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42477991">prev</a><span>|</span><a href="#42477506">next</a><span>|</span><label class="collapse" for="c-42476714">[-]</label><label class="expand" for="c-42476714">[29 more]</label></div><br/><div class="children"><div class="content">Compiling a tiny subset of C, that is. It might be so tiny as to be useless in practice.<p>I have low hopes for this kind of approach; it’s sure to hit the limits of what’s possible with static analysis of C code. Also, choosing Rust as the target makes the problem unnecessarily hard because Rust’s ownership model is so foreign to how real C programs work.</div><br/><div id="42476961" class="c"><input type="checkbox" id="c-42476961" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#42476714">parent</a><span>|</span><a href="#42476809">next</a><span>|</span><label class="collapse" for="c-42476961">[-]</label><label class="expand" for="c-42476961">[24 more]</label></div><br/><div class="children"><div class="content">Rust&#x27;s ownership model is close enough for translating C. It&#x27;s just more explicit and strongly typed, so the translation needs to figure out what a more free-form C code is trying to do, and map that to Rust&#x27;s idioms.<p>For example, C&#x27;s buffers obviously have lengths, but in C the length isn&#x27;t explicitly tied to a pointer, so the translator has to deduce how the C program tracks the length to convert that into a slice. It&#x27;s non-trivial even if the length is an explicit variable, and even trickier if it&#x27;s calculated or changes representations (e.g. sometimes used in the form of one-past-the-end pointer).<p>Other C patterns like `bool should_free_this_pointer` can be translated to Rust&#x27;s enum of `Owned`&#x2F;`Borrowed`, but again it requires deducing which allocation is tied to which boolean, and what&#x27;s the true safe scope of the borrowed variant.</div><br/><div id="42477145" class="c"><input type="checkbox" id="c-42477145" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42476961">parent</a><span>|</span><a href="#42477822">next</a><span>|</span><label class="collapse" for="c-42477145">[-]</label><label class="expand" for="c-42477145">[19 more]</label></div><br/><div class="children"><div class="content">Rust’s ownership model forbids things like doubly linked lists, which C programs use a lot.<p>That’s just one example of how C code is nowhere near meeting Rust’s requirements. There are lots of others.</div><br/><div id="42477256" class="c"><input type="checkbox" id="c-42477256" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477145">parent</a><span>|</span><a href="#42477615">next</a><span>|</span><label class="collapse" for="c-42477256">[-]</label><label class="expand" for="c-42477256">[17 more]</label></div><br/><div class="children"><div class="content">&gt; Rust’s ownership model forbids things like doubly linked lists, which C programs use a lot.<p>It’s literally in the standard library<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;struct.LinkedList.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;collections&#x2F;struct.LinkedList....</a></div><br/><div id="42477424" class="c"><input type="checkbox" id="c-42477424" checked=""/><div class="controls bullet"><span class="by">quuxplusone</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477256">parent</a><span>|</span><a href="#42477337">next</a><span>|</span><label class="collapse" for="c-42477424">[-]</label><label class="expand" for="c-42477424">[8 more]</label></div><br/><div class="children"><div class="content">But it&#x27;s not in C&#x27;s standard library. So the exercise isn&#x27;t merely to auto-translate one language&#x27;s standard library to another language&#x27;s standard library (say, replacing C++ std::list with Rust LinkedList) — which would already be very hard. The exercise here is to auto-identify-and-refactor idioms open-coded in one language, into idioms suited for the other language&#x27;s already-written standard library.<p>Imagine refactoring your average C program to use GLib for all (all!) of its data structures. Now imagine doing that, but <i>also</i> translating it into Rust at the same time.</div><br/><div id="42477633" class="c"><input type="checkbox" id="c-42477633" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477424">parent</a><span>|</span><a href="#42477337">next</a><span>|</span><label class="collapse" for="c-42477633">[-]</label><label class="expand" for="c-42477633">[7 more]</label></div><br/><div class="children"><div class="content">&gt; The exercise here is to auto-identify-and-refactor idioms open-coded in one language, into idioms suited for the other language&#x27;s already-written standard library.<p>That&#x27;s what LLMs are for - idiom translation. You can&#x27;t trust them to do it right, though.<p><i>[Pan et al . 2024] find that while GPT-4 generates code that is more idiomatic than C2Rust, only 61% of it is correct (i.e., compiles and produces the expected result), compared to 95% for C2Rust.</i><p>This problem needs both AI-type methods to help with the idioms and formal methods to insure that the guessed idioms correctly capture the semantics.<p>A big advance in this project is that they can usually translate C pointer arithmetic into Rust slices. That&#x27;s progress on of one of the hardest parts of the problem. C2Rust did not do that. That system just generates unsafe raw pointer arithmetic, yielding ugly Rust code that replicates C pointer semantics using function calls.<p>DARPA is funding research in this area under the TRACTOR program. Program awards in April 2025, so this is just getting started. It&#x27;s encouraging to see so much progress already. This looks do-able.</div><br/><div id="42477849" class="c"><input type="checkbox" id="c-42477849" checked=""/><div class="controls bullet"><span class="by">fuhsnn</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477633">parent</a><span>|</span><a href="#42477825">next</a><span>|</span><label class="collapse" for="c-42477849">[-]</label><label class="expand" for="c-42477849">[2 more]</label></div><br/><div class="children"><div class="content">&gt;That&#x27;s what LLMs are for - idiom translation. You can&#x27;t trust them to do it right, though.<p>Optimizing C compilers also happened to be good at idiom recognition, and we can probably trust them a little more. The OP paper does mention future plan to use clang as well: &gt;We have plans for a libclang-based frontend that consume actual C syntax.<p>If such transformation can be done at IR level it might be more efficient to be to C-IR &gt; idiom transform to Rust-IR &gt; run safe-checks in Rust-IR &gt; continue compilation in C-IR or Rust-IR or combining both for better optimization properties.</div><br/><div id="42478090" class="c"><input type="checkbox" id="c-42478090" checked=""/><div class="controls bullet"><span class="by">swiftcoder</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477849">parent</a><span>|</span><a href="#42477825">next</a><span>|</span><label class="collapse" for="c-42478090">[-]</label><label class="expand" for="c-42478090">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m definitely bullish on this angle of compiling C down to LLVM assembly, and then &quot;decompiling&quot; it back to Rust (with some reference to the original C to reconstruct high-level idioms like for loops)</div><br/></div></div></div></div><div id="42477825" class="c"><input type="checkbox" id="c-42477825" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477633">parent</a><span>|</span><a href="#42477849">prev</a><span>|</span><a href="#42478009">next</a><span>|</span><label class="collapse" for="c-42477825">[-]</label><label class="expand" for="c-42477825">[2 more]</label></div><br/><div class="children"><div class="content">Oh god, I can&#x27;t even imagine trying to have formally-verified LLM-generated code. It&#x27;s not surprising that even incremental progress for that would require quite a lot of ingenuity.</div><br/></div></div><div id="42478009" class="c"><input type="checkbox" id="c-42478009" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477633">parent</a><span>|</span><a href="#42477825">prev</a><span>|</span><a href="#42477337">next</a><span>|</span><label class="collapse" for="c-42478009">[-]</label><label class="expand" for="c-42478009">[2 more]</label></div><br/><div class="children"><div class="content">Actually, LLMs are for generating humorous nonsense. Putting them in charge of the world economy was not intended, but we did it anyway.</div><br/><div id="42478092" class="c"><input type="checkbox" id="c-42478092" checked=""/><div class="controls bullet"><span class="by">dhosek</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42478009">parent</a><span>|</span><a href="#42477337">next</a><span>|</span><label class="collapse" for="c-42478092">[-]</label><label class="expand" for="c-42478092">[1 more]</label></div><br/><div class="children"><div class="content">Given that in my (small, employer-mandated) explorations with Copilot autocompletions it’s offered incorrect suggestions about a third of the time and seems to like to also suggest deprecated APIs, I’m skeptical about the current generation’s ability to be useful at even this small task.</div><br/></div></div></div></div></div></div></div></div><div id="42477337" class="c"><input type="checkbox" id="c-42477337" checked=""/><div class="controls bullet"><span class="by">singron</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477256">parent</a><span>|</span><a href="#42477424">prev</a><span>|</span><a href="#42477296">next</a><span>|</span><label class="collapse" for="c-42477337">[-]</label><label class="expand" for="c-42477337">[6 more]</label></div><br/><div class="children"><div class="content">This implementation uses unsafe. You can write a linked list in safe rust (e.g. using Rc), but it probably wouldn&#x27;t resemble the one you write in C.<p>In practice, a little unsafe is usually fine. I only bring it up since the article is about translating to safe rust.</div><br/><div id="42477355" class="c"><input type="checkbox" id="c-42477355" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477337">parent</a><span>|</span><a href="#42477984">next</a><span>|</span><label class="collapse" for="c-42477355">[-]</label><label class="expand" for="c-42477355">[4 more]</label></div><br/><div class="children"><div class="content">Safe rust isn’t “rust code with absolutely 0 unsafe blocks in any possible code path, ever”. Rc uses unsafe code every time you construct one, for example.<p>Unsafe blocks are an escape hatch where you promise that some invariants the compiler cannot verify are in fact true. If the translated code were to use that collection, via its safe interfaces, it would still be “safe rust”.<p>More generally: it’s incorrect to say that the rust ownership model forbids X when it ships with an implementation of X, regardless of if and how it uses “unsafe” - especially if “unsafe” is a feature of the ownership model that helps implement it.</div><br/><div id="42477462" class="c"><input type="checkbox" id="c-42477462" checked=""/><div class="controls bullet"><span class="by">andrewflnr</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477355">parent</a><span>|</span><a href="#42477984">next</a><span>|</span><label class="collapse" for="c-42477462">[-]</label><label class="expand" for="c-42477462">[3 more]</label></div><br/><div class="children"><div class="content">No one here is confused about what unsafe means. The point is, they&#x27;re not implemented by following Rust&#x27;s ownership model, because Rust&#x27;s ownership model does in fact forbid that kind of thing.<p>You can nitpick the meaning of &quot;forbids&quot;, but as far as the current context is concerned, if you translate code that <i>implements</i> a doubly linked list (as opposed to using one from a library) into Rust, it&#x27;s not going to work without unsafe. Or an index-based graph or something.</div><br/><div id="42477635" class="c"><input type="checkbox" id="c-42477635" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477462">parent</a><span>|</span><a href="#42477984">next</a><span>|</span><label class="collapse" for="c-42477635">[-]</label><label class="expand" for="c-42477635">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to implement doubly linked lists in safe Rust. Just ensure that every element has one OWNER, to avoid «use after free» bugs, or use a garbage collector, like a reference counter.<p>Unlike C++ or Rust, C has no references, only pointers, so developer must release memory manually at some arbitrary point. This is the problem and source of bugs.</div><br/><div id="42477850" class="c"><input type="checkbox" id="c-42477850" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477635">parent</a><span>|</span><a href="#42477984">next</a><span>|</span><label class="collapse" for="c-42477850">[-]</label><label class="expand" for="c-42477850">[1 more]</label></div><br/><div class="children"><div class="content">While I might agree that it&#x27;s easy if you use a reference counter, this is not going to be as performant as the typical linked list written in C, which is why the standard library uses unsafe for its implementation of stuff like this. If it were &quot;easy&quot; to just write correct `unsafe`, then it would be easy to do it in C as well.<p>Note that the converse to this isn&#x27;t necessarily true! People I trust way more to write unsafe Rust code than me than me have argued that unsafe Rust can be harder than writing C in some ways due to having to uphold certain invariants that don&#x27;t come up in C. While there are a number of blog posts on the topic that anyone interested can probably find fairly easily by googling &quot;unsafe Rust harder than C&quot;, I&#x27;ll break my usual rule of strongly preferring articles to video content to link a talk from youtube because the speaker is one of those people I mention who I&#x27;d trust more than me to write unsafe code and I remember seeing him give this talk at the meetup: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QAz-maaH0KM" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=QAz-maaH0KM</a></div><br/></div></div></div></div></div></div></div></div><div id="42477984" class="c"><input type="checkbox" id="c-42477984" checked=""/><div class="controls bullet"><span class="by">oconnor663</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477337">parent</a><span>|</span><a href="#42477355">prev</a><span>|</span><a href="#42477296">next</a><span>|</span><label class="collapse" for="c-42477984">[-]</label><label class="expand" for="c-42477984">[1 more]</label></div><br/><div class="children"><div class="content">More important than whether you use a little unsafe or a lot, is whether you can find a clean boundary above which everything can be safe. Something like a hash function or a block cipher can be piles and piles of assembly under the covers, but since the API is bytes-in-bytes-out, the safety concerns are minimal. On the other hand, memory-mapping a file is just one FFI function call, but the uncontrollable mutability of the whole thing tends to poison everything above it with unsafety.</div><br/></div></div></div></div><div id="42477565" class="c"><input type="checkbox" id="c-42477565" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477256">parent</a><span>|</span><a href="#42477296">prev</a><span>|</span><a href="#42477615">next</a><span>|</span><label class="collapse" for="c-42477565">[-]</label><label class="expand" for="c-42477565">[1 more]</label></div><br/><div class="children"><div class="content">Good luck inferring how to use that from some C programmer’s deranged custom linked list.<p>C programmers don’t do linked lists by using libraries, they hand roll them, and often they are more complex than “just” a linked list. Lots of complex stuff out there.</div><br/></div></div></div></div><div id="42477615" class="c"><input type="checkbox" id="c-42477615" checked=""/><div class="controls bullet"><span class="by">oneshtein</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477145">parent</a><span>|</span><a href="#42477256">prev</a><span>|</span><a href="#42477822">next</a><span>|</span><label class="collapse" for="c-42477615">[-]</label><label class="expand" for="c-42477615">[1 more]</label></div><br/><div class="children"><div class="content">Rus&#x27;s ownership model doesn&#x27;t forbid doubly linked lists. It forbids doubly owned lists, or, in other words, «use after free» bug.</div><br/></div></div></div></div><div id="42477822" class="c"><input type="checkbox" id="c-42477822" checked=""/><div class="controls bullet"><span class="by">smolder</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42476961">parent</a><span>|</span><a href="#42477145">prev</a><span>|</span><a href="#42477477">next</a><span>|</span><label class="collapse" for="c-42477822">[-]</label><label class="expand" for="c-42477822">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that simple. In fact it&#x27;s impossible in some cases if you don&#x27;t sprinkle unsafe everywhere and defeat the purpose. Rusts restrictions are so that it can be statically analyzed to guarantee safety. The superset of all allowable C program behaviors includes lots of things that are impossible to guarantee the safety of through static analysis.<p>Formally verified C involves sticking to a strict subset of the capabilities of C that is verifiable, much like Rust enforces, so it makes sense that programs meeting that standard could be translated.</div><br/></div></div><div id="42477477" class="c"><input type="checkbox" id="c-42477477" checked=""/><div class="controls bullet"><span class="by">jerf</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42476961">parent</a><span>|</span><a href="#42477822">prev</a><span>|</span><a href="#42477151">next</a><span>|</span><label class="collapse" for="c-42477477">[-]</label><label class="expand" for="c-42477477">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s a classic example of an argument that looks really good from the 30,000 foot view, but when you&#x27;re actually on the ground... no, basically none of that beautiful idea can actually be manifested into reality.</div><br/></div></div><div id="42477151" class="c"><input type="checkbox" id="c-42477151" checked=""/><div class="controls bullet"><span class="by">bloppe</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42476961">parent</a><span>|</span><a href="#42477477">prev</a><span>|</span><a href="#42476809">next</a><span>|</span><label class="collapse" for="c-42477151">[-]</label><label class="expand" for="c-42477151">[2 more]</label></div><br/><div class="children"><div class="content">Is this sarcastic? There&#x27;s a reason why the lifetime checker is so annoying to people with a lot of C experience. You absolutely cannot just use your familiar C coding styles in Rust.</div><br/><div id="42477272" class="c"><input type="checkbox" id="c-42477272" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477151">parent</a><span>|</span><a href="#42476809">next</a><span>|</span><label class="collapse" for="c-42477272">[-]</label><label class="expand" for="c-42477272">[1 more]</label></div><br/><div class="children"><div class="content">You’ve misread the comment.<p>The <i>ownership model</i> is close enough, but the way that model is <i>expressed</i> by the developer is completely arbitrary (and thus completely nuts).</div><br/></div></div></div></div></div></div><div id="42476809" class="c"><input type="checkbox" id="c-42476809" checked=""/><div class="controls bullet"><span class="by">whatisyourwork</span><span>|</span><a href="#42476714">parent</a><span>|</span><a href="#42476961">prev</a><span>|</span><a href="#42477236">next</a><span>|</span><label class="collapse" for="c-42476809">[-]</label><label class="expand" for="c-42476809">[1 more]</label></div><br/><div class="children"><div class="content">It can be good as an interface language. Good for bindings.</div><br/></div></div><div id="42477236" class="c"><input type="checkbox" id="c-42477236" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#42476714">parent</a><span>|</span><a href="#42476809">prev</a><span>|</span><a href="#42477085">next</a><span>|</span><label class="collapse" for="c-42477236">[-]</label><label class="expand" for="c-42477236">[2 more]</label></div><br/><div class="children"><div class="content">Meh, you know people are just going to throw LLMs at it and they&#x27;ll be fine with it hallucinating correctish code by the ton-load. But I agree that they are going to have tough time making idiomatic Rust from random C. Like I said, correct-ish.</div><br/><div id="42477570" class="c"><input type="checkbox" id="c-42477570" checked=""/><div class="controls bullet"><span class="by">pizlonator</span><span>|</span><a href="#42476714">root</a><span>|</span><a href="#42477236">parent</a><span>|</span><a href="#42477085">next</a><span>|</span><label class="collapse" for="c-42477570">[-]</label><label class="expand" for="c-42477570">[1 more]</label></div><br/><div class="children"><div class="content">Great way to introduce novel security vulnerabilities!<p>If that’s the Rust way, then I’m all for it. Will make it easier for Fil-C to have some epic kill shots.</div><br/></div></div></div></div></div></div><div id="42477506" class="c"><input type="checkbox" id="c-42477506" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#42476714">prev</a><span>|</span><a href="#42476729">next</a><span>|</span><label class="collapse" for="c-42477506">[-]</label><label class="expand" for="c-42477506">[2 more]</label></div><br/><div class="children"><div class="content">The thing I wonder about is why we would do this. The technology to <i>really</i> convert industrial-grade apps from C to Rust could probably bullet proof the C apps more easily. They’d just have to do some analyses that fed into existing tooling, like static analyzers and test generators.<p>Similarly, it they might generate safe wrappers that let teams write new code in Rust side by side with the field-proven C. New code has the full benefits, old code is proven safe, and the interfaces are safer.<p>A full on translator might be an ideal option. We’d want one language for the codebase in the future. Push-button safety with low, false positives for existing C and C++ is still the greatest need, though. Maybe auto-correcting bad structure right in the C, too, like Google’s compiler tool and ForAllSecure’s Mayhem do.</div><br/><div id="42478166" class="c"><input type="checkbox" id="c-42478166" checked=""/><div class="controls bullet"><span class="by">DonaldPShimoda</span><span>|</span><a href="#42477506">parent</a><span>|</span><a href="#42476729">next</a><span>|</span><label class="collapse" for="c-42478166">[-]</label><label class="expand" for="c-42478166">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The technology to really convert industrial-grade apps from C to Rust could probably bullet proof the C apps more easily.<p>No, some C programs cannot be made safe. This can be due to dependency on undefined or unspecified behaviors, or it can be because introducing proper safety checks would limit the domain of possible inputs too much to be useful, or other things.<p>Translating to a safe language can maintain the expressive capabilities of the inputs while statically guaranteeing correct operation at run-time. It is objectively better in these cases.<p>&gt; field-proven C<p>I don&#x27;t think this exists, as the numerous critical vulnerabilities over the years have shown. All we have is C that seems to work pretty well often enough to be useful.<p>&gt; old code is proven safe<p>Old code is <i>assumed to be</i> safe <i>due to luck</i>, actually. &quot;Prove&quot; has a specific meaning (especially on a post for a paper about proving things), and the overwhelming majority of C code is not proven to any rigorous mathematical standard. In contrast, the Rust type system has been mathematically proven to be correct.<p>&gt; A full on translator might be an ideal option.<p>It depends on what you&#x27;re willing to give up. If you don&#x27;t mind losing performance, limiting your domain of inputs or range of outputs, giving up code legibility, and so on, then sure, this can probably be done to some extent. But when you start wanting your translator to be both sound and complete over all of these concerns, you run into problems.</div><br/></div></div></div></div><div id="42476729" class="c"><input type="checkbox" id="c-42476729" checked=""/><div class="controls bullet"><span class="by">jtrueb</span><span>|</span><a href="#42477506">prev</a><span>|</span><a href="#42476421">next</a><span>|</span><label class="collapse" for="c-42476729">[-]</label><label class="expand" for="c-42476729">[3 more]</label></div><br/><div class="children"><div class="content">Interesting how higher optimization levels didn’t really help speed up rust in the O level comparison</div><br/><div id="42476747" class="c"><input type="checkbox" id="c-42476747" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42476729">parent</a><span>|</span><a href="#42476421">next</a><span>|</span><label class="collapse" for="c-42476747">[-]</label><label class="expand" for="c-42476747">[2 more]</label></div><br/><div class="children"><div class="content">As they say it’s likely that the code they’re outputting is pessimizing rustc’s ability. Namely it sounds like they’re inlining code as part of the conversion</div><br/><div id="42476893" class="c"><input type="checkbox" id="c-42476893" checked=""/><div class="controls bullet"><span class="by">jtrueb</span><span>|</span><a href="#42476729">root</a><span>|</span><a href="#42476747">parent</a><span>|</span><a href="#42476421">next</a><span>|</span><label class="collapse" for="c-42476893">[-]</label><label class="expand" for="c-42476893">[1 more]</label></div><br/><div class="children"><div class="content">Yes, I’m just saying how it kicks in basically immediately (O1).</div><br/></div></div></div></div></div></div><div id="42476421" class="c"><input type="checkbox" id="c-42476421" checked=""/><div class="controls bullet"><span class="by">ljlolel</span><span>|</span><a href="#42476729">prev</a><span>|</span><a href="#42476456">next</a><span>|</span><label class="collapse" for="c-42476421">[-]</label><label class="expand" for="c-42476421">[7 more]</label></div><br/><div class="children"><div class="content">I wonder how well O3 can do just compiling C to rust in one shot</div><br/><div id="42476600" class="c"><input type="checkbox" id="c-42476600" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42476421">parent</a><span>|</span><a href="#42476636">next</a><span>|</span><label class="collapse" for="c-42476600">[-]</label><label class="expand" for="c-42476600">[3 more]</label></div><br/><div class="children"><div class="content">Probably pretty bad.</div><br/></div></div><div id="42476636" class="c"><input type="checkbox" id="c-42476636" checked=""/><div class="controls bullet"><span class="by">ojosilva</span><span>|</span><a href="#42476421">parent</a><span>|</span><a href="#42476600">prev</a><span>|</span><a href="#42476456">next</a><span>|</span><label class="collapse" for="c-42476636">[-]</label><label class="expand" for="c-42476636">[3 more]</label></div><br/><div class="children"><div class="content">Funny, I came here to say just the opposite, that I&#x27;m glad algorithmic computing is still a thing in research and that not everything is AI.<p>Ironically, AI is able to produce research-grade algorithms and will probably become an authority on the subject, helping take more traditional CS to the next level.</div><br/><div id="42477181" class="c"><input type="checkbox" id="c-42477181" checked=""/><div class="controls bullet"><span class="by">Garlef</span><span>|</span><a href="#42476421">root</a><span>|</span><a href="#42476636">parent</a><span>|</span><a href="#42477358">next</a><span>|</span><label class="collapse" for="c-42477181">[-]</label><label class="expand" for="c-42477181">[1 more]</label></div><br/><div class="children"><div class="content">I think it would make sense to evaluate if the the &#x27;surgical&#x27; rewrites mentioned in the article can be carried out by or assisted by an LLM based process.</div><br/></div></div><div id="42477358" class="c"><input type="checkbox" id="c-42477358" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#42476421">root</a><span>|</span><a href="#42476636">parent</a><span>|</span><a href="#42477181">prev</a><span>|</span><a href="#42476456">next</a><span>|</span><label class="collapse" for="c-42477358">[-]</label><label class="expand" for="c-42477358">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a lot of code in the world where correctness is a requirement. :)<p>I agree with the sibling -- I think LLMs may be able to help automate some parts of it, but humans are still 95% of it. At least for now.</div><br/></div></div></div></div></div></div><div id="42476456" class="c"><input type="checkbox" id="c-42476456" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#42476421">prev</a><span>|</span><a href="#42477522">next</a><span>|</span><label class="collapse" for="c-42476456">[-]</label><label class="expand" for="c-42476456">[3 more]</label></div><br/><div class="children"><div class="content">c2rust.com, but it uses things like libc::c_int</div><br/><div id="42476478" class="c"><input type="checkbox" id="c-42476478" checked=""/><div class="controls bullet"><span class="by">love2read</span><span>|</span><a href="#42476456">parent</a><span>|</span><a href="#42477522">next</a><span>|</span><label class="collapse" for="c-42476478">[-]</label><label class="expand" for="c-42476478">[2 more]</label></div><br/><div class="children"><div class="content">C2Rust is mentioned in the second paragraph of the related work section.</div><br/><div id="42478012" class="c"><input type="checkbox" id="c-42478012" checked=""/><div class="controls bullet"><span class="by">rat87</span><span>|</span><a href="#42476456">root</a><span>|</span><a href="#42476478">parent</a><span>|</span><a href="#42477522">next</a><span>|</span><label class="collapse" for="c-42478012">[-]</label><label class="expand" for="c-42478012">[1 more]</label></div><br/><div class="children"><div class="content">How is c2rust doing these days? For practical codebases?</div><br/></div></div></div></div></div></div><div id="42477522" class="c"><input type="checkbox" id="c-42477522" checked=""/><div class="controls bullet"><span class="by">dboreham</span><span>|</span><a href="#42476456">prev</a><span>|</span><a href="#42476430">next</a><span>|</span><label class="collapse" for="c-42477522">[-]</label><label class="expand" for="c-42477522">[2 more]</label></div><br/><div class="children"><div class="content">Exactly the opposite of what we need :)</div><br/><div id="42477649" class="c"><input type="checkbox" id="c-42477649" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#42477522">parent</a><span>|</span><a href="#42476430">next</a><span>|</span><label class="collapse" for="c-42477649">[-]</label><label class="expand" for="c-42477649">[1 more]</label></div><br/><div class="children"><div class="content">Maybe so, but please don&#x27;t post unsubstantive comments to Hacker News.<p>Edit: it looks like you&#x27;ve been doing this a lot lately. Can you please not? We&#x27;re trying for something more interesting here.</div><br/></div></div></div></div><div id="42477322" class="c"><input type="checkbox" id="c-42477322" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#42476430">prev</a><span>|</span><label class="collapse" for="c-42477322">[-]</label><label class="expand" for="c-42477322">[6 more]</label></div><br/><div class="children"><div class="content">I love how Rust community is repeating all the steps Haskell community did, right down to flexing with lambda calculus notation.<p>Personally i give rust like 5 more years till something new comes along and people abandon it.</div><br/><div id="42477684" class="c"><input type="checkbox" id="c-42477684" checked=""/><div class="controls bullet"><span class="by">zxvkhkxvdvbdxz</span><span>|</span><a href="#42477322">parent</a><span>|</span><a href="#42477655">next</a><span>|</span><label class="collapse" for="c-42477684">[-]</label><label class="expand" for="c-42477684">[1 more]</label></div><br/><div class="children"><div class="content">With rust having recently entered the Linux kernel, Windows 11, qemu among others where Haskell never took a hold, I really fail to see where you feel the wind is blowing.<p>The thing is, rust is used today in more and more places because it&#x27;s reliable. We&#x27;re not going to switch out the ground we are standing on every time something shiny comes along and that&#x27;s why this is such an interesting development.</div><br/></div></div><div id="42477655" class="c"><input type="checkbox" id="c-42477655" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#42477322">parent</a><span>|</span><a href="#42477684">prev</a><span>|</span><a href="#42478128">next</a><span>|</span><label class="collapse" for="c-42477655">[-]</label><label class="expand" for="c-42477655">[1 more]</label></div><br/><div class="children"><div class="content">Would you mind expanding on this?<p>It sounds interesting, but I&#x27;m not tuned into either community enough to know what parallels you see.</div><br/></div></div><div id="42478128" class="c"><input type="checkbox" id="c-42478128" checked=""/><div class="controls bullet"><span class="by">keybored</span><span>|</span><a href="#42477322">parent</a><span>|</span><a href="#42477655">prev</a><span>|</span><a href="#42477907">next</a><span>|</span><label class="collapse" for="c-42478128">[-]</label><label class="expand" for="c-42478128">[1 more]</label></div><br/><div class="children"><div class="content">I can’t believe that a PL research paper would use lambda calculus notation...?<p>Get a clue.</div><br/></div></div><div id="42477907" class="c"><input type="checkbox" id="c-42477907" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#42477322">parent</a><span>|</span><a href="#42478128">prev</a><span>|</span><a href="#42477487">next</a><span>|</span><label class="collapse" for="c-42477907">[-]</label><label class="expand" for="c-42477907">[1 more]</label></div><br/><div class="children"><div class="content">What steps are you talking about? lambda calculus is one particular way to formalize program semantics, which is appropriate when talking about... program formalization</div><br/></div></div><div id="42477487" class="c"><input type="checkbox" id="c-42477487" checked=""/><div class="controls bullet"><span class="by">jedisct1</span><span>|</span><a href="#42477322">parent</a><span>|</span><a href="#42477907">prev</a><span>|</span><label class="collapse" for="c-42477487">[-]</label><label class="expand" for="c-42477487">[1 more]</label></div><br/><div class="children"><div class="content">This.</div><br/></div></div></div></div></div></div></div></div></div></body></html>