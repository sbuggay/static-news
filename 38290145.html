<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1700211657985" as="style"/><link rel="stylesheet" href="styles.css?v=1700211657985"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/SubscriberLink/951337/e9139cdb65a9cb93/">The real realtime preemption end game</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>chmaynard</span> | <span>233 comments</span></div><br/><div><div id="38294148" class="c"><input type="checkbox" id="c-38294148" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#38294545">next</a><span>|</span><label class="collapse" for="c-38294148">[-]</label><label class="expand" for="c-38294148">[35 more]</label></div><br/><div class="children"><div class="content">QNX had this right decades ago. The microkernel has upper bounds on everything it does. There are only a few tens of thousands of lines of microkernel code. 
All the microkernel does is allocate memory, dispatch the CPU, and pass messages between processes. Everything else, including drivers and loggers, is in user space and can be preempted by higher priority threads.<p>The QNX kernel doesn&#x27;t do anything with strings. No parsing, no formatting, no messages.<p>Linux suffers from being too bloated for real time. Millions of lines of kernel, all of which have to be made preemptable. It&#x27;s the wrong architecture for real time. So it took two decades to try to fix this.</div><br/><div id="38294319" class="c"><input type="checkbox" id="c-38294319" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">parent</a><span>|</span><a href="#38295438">next</a><span>|</span><label class="collapse" for="c-38294319">[-]</label><label class="expand" for="c-38294319">[13 more]</label></div><br/><div class="children"><div class="content">For a modern example, there&#x27;s seL4. I believe it does no dynamic memory allocation. It&#x27;s also formally verified for various properties. (Arguably?) its biggest contribution to kernel design is the pervasive usage of capabilities to securely but flexibly export control to userspace.</div><br/><div id="38297438" class="c"><input type="checkbox" id="c-38297438" checked=""/><div class="controls bullet"><span class="by">_kb</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38294319">parent</a><span>|</span><a href="#38294708">next</a><span>|</span><label class="collapse" for="c-38297438">[-]</label><label class="expand" for="c-38297438">[1 more]</label></div><br/><div class="children"><div class="content">And unfortunately had its funding dumped because it wasn’t shiny AI.</div><br/></div></div><div id="38294708" class="c"><input type="checkbox" id="c-38294708" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38294319">parent</a><span>|</span><a href="#38297438">prev</a><span>|</span><a href="#38295438">next</a><span>|</span><label class="collapse" for="c-38294708">[-]</label><label class="expand" for="c-38294708">[11 more]</label></div><br/><div class="children"><div class="content">Capabilities are important, but I don’t think that was introduced by seL4. Mach (which underlies macOS) has the same capability-based system.</div><br/><div id="38295825" class="c"><input type="checkbox" id="c-38295825" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38294708">parent</a><span>|</span><a href="#38295438">next</a><span>|</span><label class="collapse" for="c-38295825">[-]</label><label class="expand" for="c-38295825">[10 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t say seL4 introduced capabilities. However, to my knowledge, seL4 was the first kernel to show that <i>pervasive</i> usage of capabilities is both feasible and beneficial.</div><br/><div id="38297847" class="c"><input type="checkbox" id="c-38297847" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295825">parent</a><span>|</span><a href="#38297543">next</a><span>|</span><label class="collapse" for="c-38297847">[-]</label><label class="expand" for="c-38297847">[7 more]</label></div><br/><div class="children"><div class="content">There&#x27;s quite a history of capabilities-based research OS&#x27;s that culminated in, but did not start with L4 (of which seL4 is a later variant).</div><br/><div id="38297979" class="c"><input type="checkbox" id="c-38297979" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297847">parent</a><span>|</span><a href="#38297543">next</a><span>|</span><label class="collapse" for="c-38297979">[-]</label><label class="expand" for="c-38297979">[6 more]</label></div><br/><div class="children"><div class="content">Yes, but I believe seL4 took it to the max. I may be wrong on that count, but I think seL4 is unique in that it leverages capabilities for pretty much everything except the scheduler. (There was work in that area, but it&#x27;s incomplete.)</div><br/><div id="38298322" class="c"><input type="checkbox" id="c-38298322" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297979">parent</a><span>|</span><a href="#38298971">next</a><span>|</span><label class="collapse" for="c-38298322">[-]</label><label class="expand" for="c-38298322">[1 more]</label></div><br/><div class="children"><div class="content">L4 was developed in the 90&#x27;s. Operating Systems like Amoeba, which were fundamentally capability-based to a degree that even exceeds L4, were a hot research topic in the 80&#x27;s.<p>L4&#x27;s contribution was speed. It was assumed that microkernels, and especially capability-based microkernels were fundamentally slower than monolithic kernels. This is why Linux (1991) is monolithic. Yet L4 (1994) was the fastest operating system in existence at the time, despite being a microkernel and capability based. It&#x27;s too bad those dates aren&#x27;t reversed, or we might have had a fast, capability-based, microkernel Linux :(</div><br/></div></div><div id="38298971" class="c"><input type="checkbox" id="c-38298971" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297979">parent</a><span>|</span><a href="#38298322">prev</a><span>|</span><a href="#38297543">next</a><span>|</span><label class="collapse" for="c-38298971">[-]</label><label class="expand" for="c-38298971">[4 more]</label></div><br/><div class="children"><div class="content">IIRC the KeyKOS&#x2F;EROS&#x2F;CapROS tradition used capabilities for everything <i>including</i> the scheduler. Of course, pervasive persistence makes those systems somewhat esoteric (barring fresh builds, they never shut down or boot up, only go to sleep and wake up in new bodies; compare Smalltalk, etc.).</div><br/><div id="38300342" class="c"><input type="checkbox" id="c-38300342" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38298971">parent</a><span>|</span><a href="#38299014">next</a><span>|</span><label class="collapse" for="c-38300342">[-]</label><label class="expand" for="c-38300342">[2 more]</label></div><br/><div class="children"><div class="content">Amoeba was my favorite, as it was a homogeneous, decentralized operating system. Different CPU architectures spread across different data centers, and it was all homogenized together into a single system image. You had a shell prompt where you typed commands and the OS could decide to spawn your process on your local device, in the server room rack, or in some connected datacenter in Amsterdam, it didn&#x27;t make a difference. From the perspective of you, your program, or the shell, it&#x27;s just a giant many-core machine with weird memory and peripheral access latencies that the OS manages.<p>Oh, and anytime as needed the OS could serialize out your process, pipe it across the network to another machine, and resume. Useful for load balancing, or relocating a program to be near the data it is accessing. Unless your program pays special attention to the clock, it wouldn&#x27;t notice.<p>I still think about Amoeba from time to time, and imagine what could have been if we had gone down that route instead.</div><br/><div id="38300586" class="c"><input type="checkbox" id="c-38300586" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38300342">parent</a><span>|</span><a href="#38299014">next</a><span>|</span><label class="collapse" for="c-38300586">[-]</label><label class="expand" for="c-38300586">[1 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t there be issues following from distributed systems and CAP? Admittedly, I know nothing about Amoeba.<p>E.g. You spawn a process on another computer and then the connection drops.</div><br/></div></div></div></div><div id="38299014" class="c"><input type="checkbox" id="c-38299014" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38298971">parent</a><span>|</span><a href="#38300342">prev</a><span>|</span><a href="#38297543">next</a><span>|</span><label class="collapse" for="c-38299014">[-]</label><label class="expand" for="c-38299014">[1 more]</label></div><br/><div class="children"><div class="content">Guess I&#x27;m too ignorant. I need to read up on these. I did know about the persistence feature. I think it&#x27;s not terrible but also not great, and systems should be <i>designed</i> for being shut down and apps being closed.</div><br/></div></div></div></div></div></div></div></div><div id="38297543" class="c"><input type="checkbox" id="c-38297543" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295825">parent</a><span>|</span><a href="#38297847">prev</a><span>|</span><a href="#38295438">next</a><span>|</span><label class="collapse" for="c-38297543">[-]</label><label class="expand" for="c-38297543">[2 more]</label></div><br/><div class="children"><div class="content">The other L4s before it showed that caps are useful and can be implemented efficiently.</div><br/><div id="38298069" class="c"><input type="checkbox" id="c-38298069" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297543">parent</a><span>|</span><a href="#38295438">next</a><span>|</span><label class="collapse" for="c-38298069">[-]</label><label class="expand" for="c-38298069">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;2517349.2522720" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;2517349.2522720</a><p>&quot;
We took a substantially different approach with seL4;
its model for managing kernel memory is seL4’s main
contribution to OS design. Motivated by the desire to
reason about resource usage and isolation, we subject
all kernel memory to authority conveyed by capabili-
ties (except for the ﬁxed amount used by the kernel to
boot up, including its strictly bounded stack).
&quot;<p>I guess I should&#x27;ve said seL4 took capabilities to the extreme.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38295438" class="c"><input type="checkbox" id="c-38295438" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#38294148">parent</a><span>|</span><a href="#38294319">prev</a><span>|</span><a href="#38295328">next</a><span>|</span><label class="collapse" for="c-38295438">[-]</label><label class="expand" for="c-38295438">[9 more]</label></div><br/><div class="children"><div class="content">QNX is used in vehicle infotainment systems no? Where else?<p>I&#x27;m not bothered by the kernel bloat. There&#x27;s a lot of dev time being invested in Linux and while the desktop is not as much of a priority as say the server space a performant kernel on handhelds and other such devices and the dev work to get it there will benefit the desktop users like myself.</div><br/><div id="38297093" class="c"><input type="checkbox" id="c-38297093" checked=""/><div class="controls bullet"><span class="by">notrom</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38298137">next</a><span>|</span><label class="collapse" for="c-38297093">[-]</label><label class="expand" for="c-38297093">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve worked with it in industrial automation systems in large scale manufacturing plants where it was pretty rock solid. And I&#x27;m aware of it&#x27;s use in TV production and transmissions systems.</div><br/></div></div><div id="38298137" class="c"><input type="checkbox" id="c-38298137" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38297093">prev</a><span>|</span><a href="#38295860">next</a><span>|</span><label class="collapse" for="c-38298137">[-]</label><label class="expand" for="c-38298137">[1 more]</label></div><br/><div class="children"><div class="content">Railroads&#x2F;Positive Train Control, emergency call centers, etc. QNX is used all over the place. If you want an even more impressive Microkernel RTOS, then Green Hills INTEGRITY is a great example. It&#x27;s the RTOS behind the B-2, F-{16,22,35}, Boeing 787, Airbus A380, Sikorsky S-92, etc.</div><br/></div></div><div id="38295860" class="c"><input type="checkbox" id="c-38295860" checked=""/><div class="controls bullet"><span class="by">bkallus</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38298137">prev</a><span>|</span><a href="#38296187">next</a><span>|</span><label class="collapse" for="c-38295860">[-]</label><label class="expand" for="c-38295860">[1 more]</label></div><br/><div class="children"><div class="content">I went to a conference at GE Research where I spoke to some QNX reps from Blackberry for a while. Seemed like they were hinting that some embedded computers in some of GE&#x27;S aerospace and energy stuff relies on QNX.</div><br/></div></div><div id="38296187" class="c"><input type="checkbox" id="c-38296187" checked=""/><div class="controls bullet"><span class="by">tyfon</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38295860">prev</a><span>|</span><a href="#38295862">next</a><span>|</span><label class="collapse" for="c-38296187">[-]</label><label class="expand" for="c-38296187">[1 more]</label></div><br/><div class="children"><div class="content">It was used in my old toyota avensis from 2012. The infotainment was so slow you could measure performance in seconds pr frame instead of frames pr second :)<p>In the end, all I could practically use it for was as a bluetooth audio connector.</div><br/></div></div><div id="38295862" class="c"><input type="checkbox" id="c-38295862" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38296187">prev</a><span>|</span><a href="#38298418">next</a><span>|</span><label class="collapse" for="c-38295862">[-]</label><label class="expand" for="c-38295862">[1 more]</label></div><br/><div class="children"><div class="content">&gt; QNX is used in vehicle infotainment systems no? Where else?<p>A bunch of similar embedded systems. And blackberry, if anyone&#x27;s still using them.</div><br/></div></div><div id="38298418" class="c"><input type="checkbox" id="c-38298418" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38295862">prev</a><span>|</span><a href="#38297252">next</a><span>|</span><label class="collapse" for="c-38298418">[-]</label><label class="expand" for="c-38298418">[1 more]</label></div><br/><div class="children"><div class="content">Routers, airplanes, satellites, nuclear power stations, lots of good stuff</div><br/></div></div><div id="38297252" class="c"><input type="checkbox" id="c-38297252" checked=""/><div class="controls bullet"><span class="by">Cyph0n</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295438">parent</a><span>|</span><a href="#38298418">prev</a><span>|</span><a href="#38296137">next</a><span>|</span><label class="collapse" for="c-38297252">[-]</label><label class="expand" for="c-38297252">[1 more]</label></div><br/><div class="children"><div class="content">Cisco routers running IOS-XR, until relatively recently.</div><br/></div></div></div></div><div id="38295328" class="c"><input type="checkbox" id="c-38295328" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#38294148">parent</a><span>|</span><a href="#38295438">prev</a><span>|</span><a href="#38295464">next</a><span>|</span><label class="collapse" for="c-38295328">[-]</label><label class="expand" for="c-38295328">[1 more]</label></div><br/><div class="children"><div class="content">The current (SDP 8) kernel has 15331 lines of code, including comments and Makefiles.</div><br/></div></div><div id="38295464" class="c"><input type="checkbox" id="c-38295464" checked=""/><div class="controls bullet"><span class="by">gigatexal</span><span>|</span><a href="#38294148">parent</a><span>|</span><a href="#38295328">prev</a><span>|</span><a href="#38297351">next</a><span>|</span><label class="collapse" for="c-38295464">[-]</label><label class="expand" for="c-38295464">[8 more]</label></div><br/><div class="children"><div class="content">&gt; QNX had this right decades ago. The microkernel has upper bounds on everything it does. There are only a few tens of thousands of lines of microkernel code. All the microkernel does is allocate memory, dispatch the CPU, and pass messages between processes. Everything else, including drivers and loggers, is in user space and can be preempted by higher priority threads.<p>So much like a well structured main method in a C program or other C like language where main just orchestrates the calling of other functions and such. In this case main might initialize different things where the QNX kernel doesn&#x27;t but the idea or general concept remains.<p>I&#x27;m no kernel dev but this sounds good to me. Keeps things simple.</div><br/><div id="38295926" class="c"><input type="checkbox" id="c-38295926" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295464">parent</a><span>|</span><a href="#38297351">next</a><span>|</span><label class="collapse" for="c-38295926">[-]</label><label class="expand" for="c-38295926">[7 more]</label></div><br/><div class="children"><div class="content">Recently, I&#x27;ve been thinking that we need a microkernel design in applications. You have the core and then services that can integrate amongst each other and the core that provide flexibility. Like the &quot;browser as an OS&quot; kind of things but applied more generally.</div><br/><div id="38301080" class="c"><input type="checkbox" id="c-38301080" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295926">parent</a><span>|</span><a href="#38296807">next</a><span>|</span><label class="collapse" for="c-38301080">[-]</label><label class="expand" for="c-38301080">[1 more]</label></div><br/><div class="children"><div class="content">That’s pretty much what Erlang&#x2F;OTP is, and it’s like a whole OS. Though it lacks capabilities.</div><br/></div></div><div id="38296807" class="c"><input type="checkbox" id="c-38296807" checked=""/><div class="controls bullet"><span class="by">galdosdi</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295926">parent</a><span>|</span><a href="#38301080">prev</a><span>|</span><a href="#38297117">next</a><span>|</span><label class="collapse" for="c-38296807">[-]</label><label class="expand" for="c-38296807">[1 more]</label></div><br/><div class="children"><div class="content">Yes! This reminds me strongly of the core&#x2F;modules architecture of the apache httpd, as described by the excellent O&#x27;Reilly book on it.<p>The process of serving an HTTP request is broken into a large number of fine grained stages and plugin modules may hook into any or all of these to modify the input and output to each stage.<p>The same basic idea makes it easy to turn any application concept into a modules-and-core architecture. From the day I read (skimmed) that book a decade or two ago this pattern has been burned into my brain</div><br/></div></div><div id="38297117" class="c"><input type="checkbox" id="c-38297117" checked=""/><div class="controls bullet"><span class="by">blackth0rn</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295926">parent</a><span>|</span><a href="#38296807">prev</a><span>|</span><a href="#38299913">next</a><span>|</span><label class="collapse" for="c-38297117">[-]</label><label class="expand" for="c-38297117">[3 more]</label></div><br/><div class="children"><div class="content">ECS systems for the gaming world are somewhat like this. There is the core ECS framework and then the systems and entity&#x27;s integrate with each other</div><br/><div id="38297228" class="c"><input type="checkbox" id="c-38297228" checked=""/><div class="controls bullet"><span class="by">spookie</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297117">parent</a><span>|</span><a href="#38299913">next</a><span>|</span><label class="collapse" for="c-38297228">[-]</label><label class="expand" for="c-38297228">[2 more]</label></div><br/><div class="children"><div class="content">ECS is incredible. Other areas should take notice</div><br/><div id="38297473" class="c"><input type="checkbox" id="c-38297473" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297228">parent</a><span>|</span><a href="#38299913">next</a><span>|</span><label class="collapse" for="c-38297473">[-]</label><label class="expand" for="c-38297473">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. I find that we&#x27;re going in this direction in many areas, games just got there much faster.<p>Pretty much everywhere there is some undercurrent of &quot;use this ultra-small generic interface for everything and life will be easier&quot;. With games and ECS, microkernels and IPC-for-everything, with frontend frameworks and components that only communicate between themselves via props and events, with event sourcing and CQRS backends, Actors in Erlang, with microservices only communicating via the network to enforce encapsulation... Perhaps even Haskell&#x27;s functional-core-imperative-shell could count as that?<p>I feel like OOP _tried_ to get to this point, with dependency injection and interface segregation, but didn&#x27;t quite get there due to bad ergonomics, verbosity and because it was still too easy to break the rules. But it was definitely an attempt at improving things.</div><br/></div></div></div></div></div></div><div id="38299913" class="c"><input type="checkbox" id="c-38299913" checked=""/><div class="controls bullet"><span class="by">vbezhenar</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38295926">parent</a><span>|</span><a href="#38297117">prev</a><span>|</span><a href="#38297351">next</a><span>|</span><label class="collapse" for="c-38299913">[-]</label><label class="expand" for="c-38299913">[1 more]</label></div><br/><div class="children"><div class="content">COM, OSGI, Service architecture, microservice architecture and countless other approaches. This is correct way to build applications, because it gets reinvented over and over again.</div><br/></div></div></div></div></div></div><div id="38297351" class="c"><input type="checkbox" id="c-38297351" checked=""/><div class="controls bullet"><span class="by">js2</span><span>|</span><a href="#38294148">parent</a><span>|</span><a href="#38295464">prev</a><span>|</span><a href="#38295447">next</a><span>|</span><label class="collapse" for="c-38297351">[-]</label><label class="expand" for="c-38297351">[2 more]</label></div><br/><div class="children"><div class="content">VxWorks is what&#x27;s used on Mars and it&#x27;s a monolithic kernel, so there&#x27;s more than one way to do it. :-)</div><br/><div id="38298445" class="c"><input type="checkbox" id="c-38298445" checked=""/><div class="controls bullet"><span class="by">dilyevsky</span><span>|</span><a href="#38294148">root</a><span>|</span><a href="#38297351">parent</a><span>|</span><a href="#38295447">next</a><span>|</span><label class="collapse" for="c-38298445">[-]</label><label class="expand" for="c-38298445">[1 more]</label></div><br/><div class="children"><div class="content">I think RT build also had to disable mmu</div><br/></div></div></div></div></div></div><div id="38294545" class="c"><input type="checkbox" id="c-38294545" checked=""/><div class="controls bullet"><span class="by">the8472</span><span>|</span><a href="#38294148">prev</a><span>|</span><a href="#38290939">next</a><span>|</span><label class="collapse" for="c-38294545">[-]</label><label class="expand" for="c-38294545">[1 more]</label></div><br/><div class="children"><div class="content">For an example how far the kernel goes to get log messages out even on a dying system and how that&#x27;s used in real deployments:<p><a href="https:&#x2F;&#x2F;netflixtechblog.com&#x2F;kubernetes-and-kernel-panics-ed620b9c6225#2965" rel="nofollow noreferrer">https:&#x2F;&#x2F;netflixtechblog.com&#x2F;kubernetes-and-kernel-panics-ed6...</a></div><br/></div></div><div id="38290939" class="c"><input type="checkbox" id="c-38290939" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#38294545">prev</a><span>|</span><a href="#38297273">next</a><span>|</span><label class="collapse" for="c-38290939">[-]</label><label class="expand" for="c-38290939">[73 more]</label></div><br/><div class="children"><div class="content">I wonder if this being fixed will result in it displacing some notable amount of made-for-realtime hardware&#x2F;software combos.  Especially since there&#x27;s now lots of cheap, relatively low power, and high clock rate ARM and x86 chips to choose from. With the clock rates so high, perfect real-time becomes less important as you would often have many cycles to spare for misses.<p>I understand it&#x27;s less elegant, efficient, etc. But sometimes commodity wins over correctness.</div><br/><div id="38291210" class="c"><input type="checkbox" id="c-38291210" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#38290939">parent</a><span>|</span><a href="#38291226">next</a><span>|</span><label class="collapse" for="c-38291210">[-]</label><label class="expand" for="c-38291210">[18 more]</label></div><br/><div class="children"><div class="content">The thing is, stuff that require hard realtime cannot satisfy with &quot;many cycles to spare for misses&quot;. And CPU cycles is not the whole story. A badly made task could lock down the kernel not doing anything useful. The point of hard realtime is &quot;nothing cannot prevent this critical task from running&quot;.<p>For automotive and aerospace, you really want the control systems to be able to run no matter what.</div><br/><div id="38291253" class="c"><input type="checkbox" id="c-38291253" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291210">parent</a><span>|</span><a href="#38291716">next</a><span>|</span><label class="collapse" for="c-38291253">[-]</label><label class="expand" for="c-38291253">[11 more]</label></div><br/><div class="children"><div class="content">Yes, there are parts of the space that can&#x27;t be displaced with this.<p>I&#x27;m unclear on why you put &quot;many cycles to spare for misses&quot; in quotes, as if it&#x27;s unimportant.  If a linux&#x2F;arm (or x86) solution is displacing a much lower speed &quot;real real time&quot; solution, that&#x27;s the situation...the extra cycles mean you can tolerate some misses while still being as granular as what you&#x27;re replacing.  Not for every use case, but for many.</div><br/><div id="38291743" class="c"><input type="checkbox" id="c-38291743" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291253">parent</a><span>|</span><a href="#38294032">next</a><span>|</span><label class="collapse" for="c-38291743">[-]</label><label class="expand" for="c-38291743">[5 more]</label></div><br/><div class="children"><div class="content">You won&#x27;t be saved from two tasks deadlocking with cycles&#x2F;second. <i>this</i> is what hard realtime systems are about. However, I do agree that not all systems have a real hard realtime requirements. But those usually can handle a non-rt kernel.<p>As for the quotes, it was a direct citation, not a way to dismiss what you said.</div><br/><div id="38292034" class="c"><input type="checkbox" id="c-38292034" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291743">parent</a><span>|</span><a href="#38294032">next</a><span>|</span><label class="collapse" for="c-38292034">[-]</label><label class="expand" for="c-38292034">[4 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think realtime anything has much to do with mutex deadlocks, those are pretty much orthogonal concepts. In fact, I would make a stronger claim: if your &quot;realtime&quot; system can deadlock, it&#x27;s either not really realtime or it has a design flaw and should be sent back to the drawing board. It&#x27;s not like you can say &quot;oh, we have a realtime kernel now, so deadlocks are the kernel&#x27;s problem&quot;.<p>Actual realtime systems are about workload scheduling that takes into account processing deadlines. Hard realtime systems can make guarantees about processing latencies, and can preemptively kill or skip tasks if the result would arrive too late. But this is not something that the Linux kernel can provide, because it is a system property rather than about just the kernel: you can&#x27;t provide any hard guarantees if you have no time bounds for your data processing workload. So any discussion about -rt in the context of the Linux kernel will always be about soft realtime only.</div><br/><div id="38292201" class="c"><input type="checkbox" id="c-38292201" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292034">parent</a><span>|</span><a href="#38297529">next</a><span>|</span><label class="collapse" for="c-38292201">[-]</label><label class="expand" for="c-38292201">[1 more]</label></div><br/><div class="children"><div class="content">much agreed. I used deadlocks as an extreme example that&#x27;s easy to reason about and straight to the point of &quot;something independent of cpu cycles&quot;. something more realistic would be IO operations taking more time than expected. you would not want this to be blocking execution for hard rt tasks.<p>In the case of the kernel, it is indeed too large to be considered hard realtime. Best case we can make it into a firmer realtime than it currently is. But I would place it nowhere near avionics flight calculators (like fly-by-wire systems).</div><br/></div></div><div id="38297529" class="c"><input type="checkbox" id="c-38297529" checked=""/><div class="controls bullet"><span class="by">hamilyon2</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292034">parent</a><span>|</span><a href="#38292201">prev</a><span>|</span><a href="#38294032">next</a><span>|</span><label class="collapse" for="c-38297529">[-]</label><label class="expand" for="c-38297529">[2 more]</label></div><br/><div class="children"><div class="content">I had an introductory course on OS and learned about hard real-time systems. I had impression hard real-time is about memory, deadlocks, livelocks, starvation, and so on. And in general about how to design system that moves forward even in presence of serious bugs and unplanned-for circumstances.</div><br/><div id="38298320" class="c"><input type="checkbox" id="c-38298320" checked=""/><div class="controls bullet"><span class="by">syntheweave</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38297529">parent</a><span>|</span><a href="#38294032">next</a><span>|</span><label class="collapse" for="c-38298320">[-]</label><label class="expand" for="c-38298320">[1 more]</label></div><br/><div class="children"><div class="content">Bugs related to concurrency - which is where you get race conditions and deadlocks - tend to pop up wherever there&#x27;s an implied sequence of dependencies to complete the computation, and the sequence is determined dynamically by an algorithm.<p>For example, if I have a video game where there&#x27;s collision against the walls, I can understand this as potentially colliding against &quot;multiple things simultaneously&quot;, since I&#x27;m likely to describe the scene as a composite of bounding boxes, polygons, etc.<p>But to get an answer for what to do in response when I contact a wall, I have to come up with an algorithm that tests all the relevant shapes or volumes.<p>The concurrency bug that appears when doing this in a naive way is that I test one, give an answer to that, then modify the answer when testing the others. That can lead to losing information and &quot;popping through&quot; a wall. And the direction in which I pop through depends on which one is tested first.<p>The conventional gamedev solution to that is to define down the solution set so that it no longer matters which order I test the walls in: with axis aligned boxes, I can say &quot;move only the X axis first, then move only the Y axis&quot;. Now there is a fixed order, and a built-in bias to favor one or the other axis. But this is enough for the gameplay of your average platforming game.<p>The generalization on that is to describe it as a constraint optimization problem: there are some number of potential solutions, and they can be ranked relative to the &quot;unimpeded movement&quot; heuristic, which is usually desirable when clipping around walls. That solution set is then filtered down through the collision tests, and the top ranked one becomes the answer for that timestep.<p>Problems of this nature come up with resource allocation, scheduling, etc. Some kind of coordinating mechanism is needed, and OS kernels tend to shoulder a lot of the burden for this.<p>It&#x27;s different from real-time in that real-time is a specification of what kind of performance constraint you are solving for, vs allowing any kind of performance outcome that returns acceptable concurrent answers.</div><br/></div></div></div></div></div></div></div></div><div id="38294032" class="c"><input type="checkbox" id="c-38294032" checked=""/><div class="controls bullet"><span class="by">nine_k</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291253">parent</a><span>|</span><a href="#38291743">prev</a><span>|</span><a href="#38291574">next</a><span>|</span><label class="collapse" for="c-38294032">[-]</label><label class="expand" for="c-38294032">[2 more]</label></div><br/><div class="children"><div class="content">How much more expensive and power-hungry an ARM core would be, if it displaces a lower-specced core?<p>I bet there are hard-realtime (commercial) OSes running on ARM, and the ability to use a lower-specced (cheaper, simpler, consuming less power) core may be seen as an advantage enough to pay for the OS license.</div><br/><div id="38296071" class="c"><input type="checkbox" id="c-38296071" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38294032">parent</a><span>|</span><a href="#38291574">next</a><span>|</span><label class="collapse" for="c-38296071">[-]</label><label class="expand" for="c-38296071">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How much more expensive and power-hungry an ARM core would be, if it displaces a lower-specced core?<p>The power issue is real, but it might well be the same price or cheaper - a standard ARM that gets stamped out by the million can cost less than a &quot;simpler&quot; microcontroller with a smaller production run.</div><br/></div></div></div></div><div id="38291574" class="c"><input type="checkbox" id="c-38291574" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291253">parent</a><span>|</span><a href="#38294032">prev</a><span>|</span><a href="#38291608">next</a><span>|</span><label class="collapse" for="c-38291574">[-]</label><label class="expand" for="c-38291574">[2 more]</label></div><br/><div class="children"><div class="content">It is sort of funny that language has changed to the point where quotes are assumed to be dismissive or sarcastic.<p>Maybe they used the quotes because they were quoting you, haha.</div><br/><div id="38291699" class="c"><input type="checkbox" id="c-38291699" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291574">parent</a><span>|</span><a href="#38291608">next</a><span>|</span><label class="collapse" for="c-38291699">[-]</label><label class="expand" for="c-38291699">[1 more]</label></div><br/><div class="children"><div class="content">it&#x27;s precisely why I quoted the text, to quote :)</div><br/></div></div></div></div><div id="38291608" class="c"><input type="checkbox" id="c-38291608" checked=""/><div class="controls bullet"><span class="by">archgoon</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291253">parent</a><span>|</span><a href="#38291574">prev</a><span>|</span><a href="#38291716">next</a><span>|</span><label class="collapse" for="c-38291608">[-]</label><label class="expand" for="c-38291608">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m pretty sure they were just putting it in quotes because it was the expression you used, and they thus were referencing it.</div><br/></div></div></div></div><div id="38291716" class="c"><input type="checkbox" id="c-38291716" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291210">parent</a><span>|</span><a href="#38291253">prev</a><span>|</span><a href="#38291226">next</a><span>|</span><label class="collapse" for="c-38291716">[-]</label><label class="expand" for="c-38291716">[6 more]</label></div><br/><div class="children"><div class="content">What’s an example of a system that requires hard real time and couldn’t cope with soft real time on a 3GHz system having 1000 cycle misses costing 0.3us?</div><br/><div id="38293102" class="c"><input type="checkbox" id="c-38293102" checked=""/><div class="controls bullet"><span class="by">LeifCarrotson</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291716">parent</a><span>|</span><a href="#38297387">next</a><span>|</span><label class="collapse" for="c-38293102">[-]</label><label class="expand" for="c-38293102">[3 more]</label></div><br/><div class="children"><div class="content">We&#x27;ve successfully used a Delta Tau real-time Linux motion controller to run a 24 kHz laser galvo system. It&#x27;s ostensibly good for 25 microsecond loop rates, and pretty intolerant of jitter (you could delay a measurement by a full loop period if you&#x27;re early). And the processor is a fixed frequency Arm industrial deal that only runs at 1.2 GHz.<p>Perhaps even that&#x27;s not an example of such a system, 0.3 microseconds is close to the allowable real-time budget, and QC would probably not scrap a $20k part if you were off by that much once.<p>But in practice, every time I&#x27;ve heard &quot;soft real time&quot; suggested, the failure mode is not a sub-microsecond miss but a 100 millisecond plus deadlock, where a hardware watchdog would be needed to drop the whole system offline and probably crash the tool (hopefully fusing at the tool instead of destroying spindle bearings, axis ball screws, or motors and gearboxes) and scrap the part.</div><br/><div id="38300383" class="c"><input type="checkbox" id="c-38300383" checked=""/><div class="controls bullet"><span class="by">zmgsabst</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38293102">parent</a><span>|</span><a href="#38297387">next</a><span>|</span><label class="collapse" for="c-38300383">[-]</label><label class="expand" for="c-38300383">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the detailed reply!<p>I’m trying to understand where the roadblock on a rPi + small FPGA hybrid board for $50 fails at the task… and it sounds like the OS&#x2F;firmware doesn’t suffice. (Or a SoC, like a Zynq.)<p>Eg, if we could guarantee that the 1.5GHz core won’t “be off” by more than 1us on responding and the FPGA can manage IO directly to buffer out (some of) the jitter, then the cost of many hobby systems with “(still not quite) hard” real time systems would come down to reasonable.</div><br/><div id="38300988" class="c"><input type="checkbox" id="c-38300988" checked=""/><div class="controls bullet"><span class="by">rmu09</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38300383">parent</a><span>|</span><a href="#38297387">next</a><span>|</span><label class="collapse" for="c-38300988">[-]</label><label class="expand" for="c-38300988">[1 more]</label></div><br/><div class="children"><div class="content">You can get pretty far nowadays with preempt rt and an FPGA. Maybe you even can get near 1µs max jitter. One problem with the older RPis was unpredictable (to me) behaviour of the hardware, i.e. &quot;randomly&quot; changing SPI clocks, and limited bandwidth.<p>Hobby systems like a small CNC mill or lathe usually don&#x27;t need anything near 1µs (or better) max jitter. LinuxCNC (derived from NIST&#x27;s Enhanced Machine Controller, name changed due to legal threats) runs fine on preempt-rt with control loops around 1kHz, with some systems you can also run a &quot;fast&quot; thread with say 20kHz and more to generate stepper motor signals, but that job is best left for the FPGA or an additional µC IMHO.</div><br/></div></div></div></div></div></div><div id="38297387" class="c"><input type="checkbox" id="c-38297387" checked=""/><div class="controls bullet"><span class="by">krylon</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291716">parent</a><span>|</span><a href="#38293102">prev</a><span>|</span><a href="#38291792">next</a><span>|</span><label class="collapse" for="c-38297387">[-]</label><label class="expand" for="c-38297387">[1 more]</label></div><br/><div class="children"><div class="content">I suspect a fair amount of hard real time applications are not running on 3GHz CPUs. A 100MHz CPU (or lower) without an MMU or FPU is probably more representative.<p>But it&#x27;s not really so much about being fast, it&#x27;s about being able to <i>guarantee</i> that your system can respond to an event within a given amount of time <i>every time</i>. (At least that is how a friend who works in embedded&#x2F;real time explained it to me.)</div><br/></div></div><div id="38291792" class="c"><input type="checkbox" id="c-38291792" checked=""/><div class="controls bullet"><span class="by">lelanthran</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291716">parent</a><span>|</span><a href="#38297387">prev</a><span>|</span><a href="#38291226">next</a><span>|</span><label class="collapse" for="c-38291792">[-]</label><label class="expand" for="c-38291792">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What’s an example of a system that requires hard real time and couldn’t cope with soft real time on a 3GHz system having 1000 cycle misses costing 0.3us?<p>Any system that deadlocks.</div><br/></div></div></div></div></div></div><div id="38291226" class="c"><input type="checkbox" id="c-38291226" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38290939">parent</a><span>|</span><a href="#38291210">prev</a><span>|</span><a href="#38291988">next</a><span>|</span><label class="collapse" for="c-38291226">[-]</label><label class="expand" for="c-38291226">[50 more]</label></div><br/><div class="children"><div class="content">I get the sense that applications with true realtime requirements generally have hard enough requirements that they cannot allow even the remote possibility of failure.  Think avionics, medical devices, automotive, military applications.<p>If you really need realtime, then you <i>really need</i> it and &quot;close enough&quot; doesn&#x27;t really exist.<p>This is just my perception as an outsider though.</div><br/><div id="38291730" class="c"><input type="checkbox" id="c-38291730" checked=""/><div class="controls bullet"><span class="by">abe_m</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38296245">next</a><span>|</span><label class="collapse" for="c-38291730">[-]</label><label class="expand" for="c-38291730">[6 more]</label></div><br/><div class="children"><div class="content">Having worked on a number of &quot;real time&quot; machine control applications:<p>1)  There is always a possibility that something fails to run by its due date.  Planes crash sometimes. Cars won&#x27;t start some times.  Factory machinery makes scrap parts sometimes.   In a great many applications, missing a real time deadline results in degraded quality, not end of life, or regional catastrophy.  The care that must be taken to lower the probability of failure needs to be in proportion to the consequence of the failure.  Airplanes have redundant systems to reduce (but not eliminate) possibility of failure, while cars and trucks generally don&#x27;t.<p>2) Even in properly working real time systems, there is a tolerance window on execution time.  As machines change modes of operation, the amount of calculation effort to complete a cycle changes.  If the machine is in a warm up phase, it may be doing minimal calculations, and the scan cycle is fast.  Later it may be doing a quality control function that needs to do calculations on inputs from numerous sensors, and the scan cycle slows down.  So long as the scan cycle doesn&#x27;t exceed the limit for the process, the variation doesn&#x27;t cause problems.</div><br/><div id="38291796" class="c"><input type="checkbox" id="c-38291796" checked=""/><div class="controls bullet"><span class="by">mlsu</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291730">parent</a><span>|</span><a href="#38295058">next</a><span>|</span><label class="collapse" for="c-38291796">[-]</label><label class="expand" for="c-38291796">[2 more]</label></div><br/><div class="children"><div class="content">That is true, but generally not acceptable to a regulating body for these critical applications. You would need to design and implement a validation test to prove timing in your system.<p>Much easier to just use an RTOS and save the expensive testing.</div><br/><div id="38295088" class="c"><input type="checkbox" id="c-38295088" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291796">parent</a><span>|</span><a href="#38295058">next</a><span>|</span><label class="collapse" for="c-38295088">[-]</label><label class="expand" for="c-38295088">[1 more]</label></div><br/><div class="children"><div class="content">But you still need to implement the validation test to prove that the RTOS has these requirements…</div><br/></div></div></div></div><div id="38295058" class="c"><input type="checkbox" id="c-38295058" checked=""/><div class="controls bullet"><span class="by">blt</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291730">parent</a><span>|</span><a href="#38291796">prev</a><span>|</span><a href="#38296245">next</a><span>|</span><label class="collapse" for="c-38295058">[-]</label><label class="expand" for="c-38295058">[3 more]</label></div><br/><div class="children"><div class="content">How is your point 2) a response to any of the earlier points? Hard realtime systems don&#x27;t care about variation, only the worst case. If your code does a single multiply-add most of the time but calls `log` every now and then, hard realtime requirement is perfectly satisfied if the bound on the worst-case runtime of `log` is small enough.</div><br/><div id="38295802" class="c"><input type="checkbox" id="c-38295802" checked=""/><div class="controls bullet"><span class="by">abe_m</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38295058">parent</a><span>|</span><a href="#38296245">next</a><span>|</span><label class="collapse" for="c-38295802">[-]</label><label class="expand" for="c-38295802">[2 more]</label></div><br/><div class="children"><div class="content">I suppose it isn&#x27;t, but I bristle when I see someone tossing around statements like &quot;close enough doesn&#x27;t really exist&quot;.  In my experience when statements like that start up, there are people involved that don&#x27;t understand variation is a part of every real process.  My point is that if you&#x27;re going to get into safety critical systems, there is always going to be some amount of variation, and there is always a &quot;close enough&quot;, as there is never an &quot;exact&quot; in real systems.</div><br/><div id="38298489" class="c"><input type="checkbox" id="c-38298489" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38295802">parent</a><span>|</span><a href="#38296245">next</a><span>|</span><label class="collapse" for="c-38298489">[-]</label><label class="expand" for="c-38298489">[1 more]</label></div><br/><div class="children"><div class="content">The point is to care about the <i>worst case</i> within that variation.<p>Most software cares about the average case, or, in the case of the Windows 10&#x2F;11 start menu animation, the average across all supported machines apparently going 20 years into the future.</div><br/></div></div></div></div></div></div></div></div><div id="38296245" class="c"><input type="checkbox" id="c-38296245" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38291730">prev</a><span>|</span><a href="#38291592">next</a><span>|</span><label class="collapse" for="c-38296245">[-]</label><label class="expand" for="c-38296245">[1 more]</label></div><br/><div class="children"><div class="content">Like many binary distinctions, when you zoom in on the details hard-versus-soft realtime is really more of a spectrum. There&#x27;s &quot;people will die if it&#x27;s late&quot;. &quot;The line will have to stop for a day if it&#x27;s late&quot;. &quot;If it&#x27;s late, it&#x27;ll wreck the part currently being made&quot;. Etc.<p>Even hard-realtime systems have a failure rate, in practice if not in theory - even a formally verified system might encounter a hardware bug. So it&#x27;s always a case of tradeoffs between failure rate and other factors (like cost). If commodity operating systems can push their failure rate down a few orders of magnitude, that moves the needle, at least for some applications.</div><br/></div></div><div id="38291592" class="c"><input type="checkbox" id="c-38291592" checked=""/><div class="controls bullet"><span class="by">dripton</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38296245">prev</a><span>|</span><a href="#38291693">next</a><span>|</span><label class="collapse" for="c-38291592">[-]</label><label class="expand" for="c-38291592">[11 more]</label></div><br/><div class="children"><div class="content">You can divide realtime applications into safety-critical and non-safety-critical ones.  For safety-critical apps, you&#x27;re totally right.  For non-critical apps, if it&#x27;s late and therefore buggy once in a while, that sucks but nobody dies.<p>Examples of the latter include audio and video playback and video games.  Nobody wants pauses or glitches, but if you get one once in a while, nobody dies.  So people deliver these on non-RT operating systems for cost reasons.</div><br/><div id="38295509" class="c"><input type="checkbox" id="c-38295509" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291592">parent</a><span>|</span><a href="#38295510">next</a><span>|</span><label class="collapse" for="c-38295509">[-]</label><label class="expand" for="c-38295509">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You can divide realtime applications into safety-critical and non-safety-critical ones.<p>No. This is a common misconception. The distinction between a hard realtime system and a soft realtime system is simply whether missing a timing deadline leads to a) failure of the system or b) degradation of the system (but the system continues to operate). Safety is not part of it.<p>Interacting with the real physical world often imposes “hard realtime” constraints (think signal processing). Whether this has safety implications simply depends on the application.</div><br/></div></div><div id="38295510" class="c"><input type="checkbox" id="c-38295510" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291592">parent</a><span>|</span><a href="#38295509">prev</a><span>|</span><a href="#38291777">next</a><span>|</span><label class="collapse" for="c-38295510">[-]</label><label class="expand" for="c-38295510">[3 more]</label></div><br/><div class="children"><div class="content">Your division puts audio <i>performance</i> applications in a grey area.<p>On the one hand they aren&#x27;t safety critical.<p>On the other, I can imagine someone getting chewed out or even fired for a pause or a glitch in a professional performance.<p>Probably the same with live commercial video compositing.</div><br/><div id="38297170" class="c"><input type="checkbox" id="c-38297170" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38295510">parent</a><span>|</span><a href="#38291777">next</a><span>|</span><label class="collapse" for="c-38297170">[-]</label><label class="expand" for="c-38297170">[2 more]</label></div><br/><div class="children"><div class="content">Audio is definitely hard realtime. The slightest delays are VERY noticeable.</div><br/><div id="38298530" class="c"><input type="checkbox" id="c-38298530" checked=""/><div class="controls bullet"><span class="by">jancsika</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38297170">parent</a><span>|</span><a href="#38291777">next</a><span>|</span><label class="collapse" for="c-38298530">[-]</label><label class="expand" for="c-38298530">[1 more]</label></div><br/><div class="children"><div class="content">I mean, it should be.<p>But there are plenty of performers who apparently rely on Linux boxes and gumption.</div><br/></div></div></div></div></div></div><div id="38291777" class="c"><input type="checkbox" id="c-38291777" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291592">parent</a><span>|</span><a href="#38295510">prev</a><span>|</span><a href="#38291693">next</a><span>|</span><label class="collapse" for="c-38291777">[-]</label><label class="expand" for="c-38291777">[6 more]</label></div><br/><div class="children"><div class="content">This kind of makes the same point I made though -- apps without hard realtime requirements aren&#x27;t &quot;really realtime&quot; applications</div><br/><div id="38292596" class="c"><input type="checkbox" id="c-38292596" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291777">parent</a><span>|</span><a href="#38291847">next</a><span>|</span><label class="collapse" for="c-38292596">[-]</label><label class="expand" for="c-38292596">[2 more]</label></div><br/><div class="children"><div class="content">No -- soft realtime applications are things like video conferencing, where you care mostly about low latency in the audio&#x2F;video stream but it&#x27;s ok to drop the occasional frame. These are still realtime requirements, different from what your typical browser does (for example): who cares if a webpage is rendered in 100ms or 2s? Hard realtime is more like professional audio&#x2F;video recording where you want hard guarantees that each captured frame is stored and processed within the alotted time.</div><br/><div id="38298363" class="c"><input type="checkbox" id="c-38298363" checked=""/><div class="controls bullet"><span class="by">atq2119</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292596">parent</a><span>|</span><a href="#38291847">next</a><span>|</span><label class="collapse" for="c-38298363">[-]</label><label class="expand" for="c-38298363">[1 more]</label></div><br/><div class="children"><div class="content">&gt; who cares if a webpage is rendered in 100ms or 2s?<p>Do you really stand by the statement of this rhetorical question? Because if yes: this attitude is a big reason for why web apps are so unpleasant to work with compared to locally running applications. Depending on the application, even 16ms vs 32ms can make a big difference.</div><br/></div></div></div></div><div id="38291847" class="c"><input type="checkbox" id="c-38291847" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291777">parent</a><span>|</span><a href="#38292596">prev</a><span>|</span><a href="#38291863">next</a><span>|</span><label class="collapse" for="c-38291847">[-]</label><label class="expand" for="c-38291847">[2 more]</label></div><br/><div class="children"><div class="content">The traditional language is &quot;hard&quot; vs &quot;soft&quot; realtime</div><br/><div id="38294692" class="c"><input type="checkbox" id="c-38294692" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291847">parent</a><span>|</span><a href="#38291863">next</a><span>|</span><label class="collapse" for="c-38294692">[-]</label><label class="expand" for="c-38294692">[1 more]</label></div><br/><div class="children"><div class="content">RTOS means hard realtime.</div><br/></div></div></div></div><div id="38291863" class="c"><input type="checkbox" id="c-38291863" checked=""/><div class="controls bullet"><span class="by">pluto_modadic</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291777">parent</a><span>|</span><a href="#38291847">prev</a><span>|</span><a href="#38291693">next</a><span>|</span><label class="collapse" for="c-38291863">[-]</label><label class="expand" for="c-38291863">[1 more]</label></div><br/><div class="children"><div class="content">I sense that people will insist on their requirements being hard unnecessarily... and that the bug is the fault of it being on a near-realtime system instead of it being faulty even on a realtime one.</div><br/></div></div></div></div></div></div><div id="38291693" class="c"><input type="checkbox" id="c-38291693" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38291592">prev</a><span>|</span><a href="#38291560">next</a><span>|</span><label class="collapse" for="c-38291693">[-]</label><label class="expand" for="c-38291693">[1 more]</label></div><br/><div class="children"><div class="content">There is some amount of realtime in factory control where infrequent misses will just increase your reject rate in QA.</div><br/></div></div><div id="38292872" class="c"><input type="checkbox" id="c-38292872" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38291560">prev</a><span>|</span><a href="#38291575">next</a><span>|</span><label class="collapse" for="c-38292872">[-]</label><label class="expand" for="c-38292872">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Think avionics, medical devices, automotive, military applications.<p>FWIW by-device&#x2F;by-transistor-count, the bulk of &quot;hard realtime systems&quot; with millisecond-scale latency requirements are just audio.<p>The sexy stuff are all real applications too.  But mostly we need this just so we don&#x27;t hear pops and echos in our video calls.</div><br/><div id="38294711" class="c"><input type="checkbox" id="c-38294711" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292872">parent</a><span>|</span><a href="#38291575">next</a><span>|</span><label class="collapse" for="c-38294711">[-]</label><label class="expand" for="c-38294711">[2 more]</label></div><br/><div class="children"><div class="content">Nobody thinks Teams is a realtime application</div><br/><div id="38295696" class="c"><input type="checkbox" id="c-38295696" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38294711">parent</a><span>|</span><a href="#38291575">next</a><span>|</span><label class="collapse" for="c-38295696">[-]</label><label class="expand" for="c-38295696">[1 more]</label></div><br/><div class="children"><div class="content">No[1], but the people writing the audio drivers and DSP firmware absolutely do.  Kernel preemption isn&#x27;t a feature for top-level apps.<p>[1] Actually even that&#x27;s wrong: for sure there are teams of people within MS (and Apple, and anyone else in this space) measuring latency behavior at the top-level app layer and doing tuning all the way through the stack.  App latency excursions can impact streams too, though ideally you have some layer of insulation there.</div><br/></div></div></div></div></div></div><div id="38291575" class="c"><input type="checkbox" id="c-38291575" checked=""/><div class="controls bullet"><span class="by">cptaj</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38292872">prev</a><span>|</span><a href="#38291284">next</a><span>|</span><label class="collapse" for="c-38291575">[-]</label><label class="expand" for="c-38291575">[9 more]</label></div><br/><div class="children"><div class="content">Unless its just music</div><br/><div id="38291869" class="c"><input type="checkbox" id="c-38291869" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291575">parent</a><span>|</span><a href="#38291713">next</a><span>|</span><label class="collapse" for="c-38291869">[-]</label><label class="expand" for="c-38291869">[4 more]</label></div><br/><div class="children"><div class="content">Unless that music is being played through a multi kW amplifier into a stadium and an xrun causes damage to the drivers and&#x2F;or audience (although, they should have hearing protection anyway).</div><br/><div id="38292112" class="c"><input type="checkbox" id="c-38292112" checked=""/><div class="controls bullet"><span class="by">beiller</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291869">parent</a><span>|</span><a href="#38291713">next</a><span>|</span><label class="collapse" for="c-38292112">[-]</label><label class="expand" for="c-38292112">[3 more]</label></div><br/><div class="children"><div class="content">Your talk of xrun is giving me anxiety. When I was younger I dreamed of having a linux audio effects stack with cheap hardware on stage and xruns brought my dreams crashing down.</div><br/><div id="38295974" class="c"><input type="checkbox" id="c-38295974" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292112">parent</a><span>|</span><a href="#38291713">next</a><span>|</span><label class="collapse" for="c-38295974">[-]</label><label class="expand" for="c-38295974">[2 more]</label></div><br/><div class="children"><div class="content">xrun definition: <a href="https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;199498&#x2F;what-are-xruns" rel="nofollow noreferrer">https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;199498&#x2F;what-are-xru...</a><p>(I didn&#x27;t know the term, trying to be helpful if others don&#x27;t)</div><br/><div id="38298905" class="c"><input type="checkbox" id="c-38298905" checked=""/><div class="controls bullet"><span class="by">tinix</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38295974">parent</a><span>|</span><a href="#38291713">next</a><span>|</span><label class="collapse" for="c-38298905">[-]</label><label class="expand" for="c-38298905">[1 more]</label></div><br/><div class="children"><div class="content">just a buffer under&#x2F;overrun</div><br/></div></div></div></div></div></div></div></div><div id="38291713" class="c"><input type="checkbox" id="c-38291713" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291575">parent</a><span>|</span><a href="#38291869">prev</a><span>|</span><a href="#38291845">next</a><span>|</span><label class="collapse" for="c-38291713">[-]</label><label class="expand" for="c-38291713">[3 more]</label></div><br/><div class="children"><div class="content">It may not be safety critical, but remember that people can and will purchase $14k power chords to (ostensibly) improve the experience of listening to &quot;just music&quot;.<p><a href="https:&#x2F;&#x2F;www.audioadvice.com&#x2F;audioquest-nrg-dragon-high-current-ac-power-cable" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.audioadvice.com&#x2F;audioquest-nrg-dragon-high-curre...</a></div><br/><div id="38294119" class="c"><input type="checkbox" id="c-38294119" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291713">parent</a><span>|</span><a href="#38291845">next</a><span>|</span><label class="collapse" for="c-38294119">[-]</label><label class="expand" for="c-38294119">[2 more]</label></div><br/><div class="children"><div class="content">FWIW, a power chord is a _very_ different thing than a power cord.</div><br/><div id="38294730" class="c"><input type="checkbox" id="c-38294730" checked=""/><div class="controls bullet"><span class="by">itishappy</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38294119">parent</a><span>|</span><a href="#38291845">next</a><span>|</span><label class="collapse" for="c-38294730">[-]</label><label class="expand" for="c-38294730">[1 more]</label></div><br/><div class="children"><div class="content">LOL, what a typo! Good catch!</div><br/></div></div></div></div></div></div><div id="38291845" class="c"><input type="checkbox" id="c-38291845" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291575">parent</a><span>|</span><a href="#38291713">prev</a><span>|</span><a href="#38291284">next</a><span>|</span><label class="collapse" for="c-38291845">[-]</label><label class="expand" for="c-38291845">[1 more]</label></div><br/><div class="children"><div class="content">what if your analog sampler ruins the only good take you can get?  What if it&#x27;s recording a historically important speech?  Starting to get philosophical here...</div><br/></div></div></div></div><div id="38291284" class="c"><input type="checkbox" id="c-38291284" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38291575">prev</a><span>|</span><a href="#38292637">next</a><span>|</span><label class="collapse" for="c-38291284">[-]</label><label class="expand" for="c-38291284">[15 more]</label></div><br/><div class="children"><div class="content">If you really need realtime, and you really actually need it, should you be using a system like Linux at all?</div><br/><div id="38291505" class="c"><input type="checkbox" id="c-38291505" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291284">parent</a><span>|</span><a href="#38297204">next</a><span>|</span><label class="collapse" for="c-38291505">[-]</label><label class="expand" for="c-38291505">[2 more]</label></div><br/><div class="children"><div class="content">no you don&#x27;t, you use a true RTOS instead.<p>linux RTOS is at microseconds granularity but it still can not 100% guarantee it, anything in cache nature (L2 cache, TLB miss) are hard for hard real time.<p>a dual kernel with xenomai could improve it, but it is not widely used somehow, only used in industrial controls I think.<p>linux RT is great for audio, multimedia etc as well, where real-time is crucial, but not a MUST.</div><br/><div id="38295160" class="c"><input type="checkbox" id="c-38295160" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291505">parent</a><span>|</span><a href="#38297204">next</a><span>|</span><label class="collapse" for="c-38295160">[-]</label><label class="expand" for="c-38295160">[1 more]</label></div><br/><div class="children"><div class="content">&gt; anything in cache nature (L2 cache, TLB miss) are hard for hard real time<p>yup that&#x27;s why you&#x27;d pin the memory and the core for the critical task.  which, alas, will affect performance of the other cores and all other tasks.  and whoosh there goes the BOM...<p>which again as we both probably are familiar with leads to the SoC  designs with a real time core microcontroller and a HPC microprocessor on the same package.  which leads to the question how to architect the combined system of real-time microcontroller and compute power but soft real time  microprocessor such that the overall system remains sufficiently reliable...<p>oh joy and fun!</div><br/></div></div></div></div><div id="38297204" class="c"><input type="checkbox" id="c-38297204" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291284">parent</a><span>|</span><a href="#38291505">prev</a><span>|</span><a href="#38291395">next</a><span>|</span><label class="collapse" for="c-38297204">[-]</label><label class="expand" for="c-38297204">[1 more]</label></div><br/><div class="children"><div class="content">The beauty of multicore&#x2F;multi-cpu systems is that you can dedicate cores to running realtime OSs and leave the non-hard realtime stuff to an embedded linux on it&#x27;s own core.</div><br/></div></div><div id="38291395" class="c"><input type="checkbox" id="c-38291395" checked=""/><div class="controls bullet"><span class="by">tyingq</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291284">parent</a><span>|</span><a href="#38297204">prev</a><span>|</span><a href="#38294158">next</a><span>|</span><label class="collapse" for="c-38291395">[-]</label><label class="expand" for="c-38291395">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m guessing it&#x27;s not that technical experts will be choosing this path, but rather companies.  Once it&#x27;s &quot;good enough&quot;, and much easier to hire for, etc...you hire non-experts because it works <i>most</i> of the time. I&#x27;m not saying it&#x27;s good, just that it&#x27;s a somewhat likely outcome. And not for everything, just the places where they can get away with it.</div><br/><div id="38295182" class="c"><input type="checkbox" id="c-38295182" checked=""/><div class="controls bullet"><span class="by">froh</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291395">parent</a><span>|</span><a href="#38294158">next</a><span>|</span><label class="collapse" for="c-38295182">[-]</label><label class="expand" for="c-38295182">[2 more]</label></div><br/><div class="children"><div class="content">nah.  when functional safety enters the room (as it does for hard real time) then engineers go to jail if they sign off something unsafe and people die because of that.  since the challenger disaster there is an awareness that not listening to engineers can be expensive and cost lifes.</div><br/></div></div></div></div><div id="38294158" class="c"><input type="checkbox" id="c-38294158" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291284">parent</a><span>|</span><a href="#38291395">prev</a><span>|</span><a href="#38292848">next</a><span>|</span><label class="collapse" for="c-38294158">[-]</label><label class="expand" for="c-38294158">[1 more]</label></div><br/><div class="children"><div class="content">really depends on your paranoia level and the consequences for failure. soft to hard realtime is a bit of a spectrum in terms of how hard of a failure missing a deadline actually is, and therefore how much you try to verify that you will actually meet that deadline.</div><br/></div></div><div id="38292848" class="c"><input type="checkbox" id="c-38292848" checked=""/><div class="controls bullet"><span class="by">snickerbockers</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291284">parent</a><span>|</span><a href="#38294158">prev</a><span>|</span><a href="#38291378">next</a><span>|</span><label class="collapse" for="c-38292848">[-]</label><label class="expand" for="c-38292848">[1 more]</label></div><br/><div class="children"><div class="content">Pretty sure most people who think they need a real-time thread actually don&#x27;t tbh.</div><br/></div></div><div id="38291378" class="c"><input type="checkbox" id="c-38291378" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291284">parent</a><span>|</span><a href="#38292848">prev</a><span>|</span><a href="#38292637">next</a><span>|</span><label class="collapse" for="c-38291378">[-]</label><label class="expand" for="c-38291378">[6 more]</label></div><br/><div class="children"><div class="content">...yes, after realtime support lands</div><br/><div id="38291449" class="c"><input type="checkbox" id="c-38291449" checked=""/><div class="controls bullet"><span class="by">lumb63</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291378">parent</a><span>|</span><a href="#38292637">next</a><span>|</span><label class="collapse" for="c-38291449">[-]</label><label class="expand" for="c-38291449">[5 more]</label></div><br/><div class="children"><div class="content">A lot of realtime systems don’t have sufficient resources to run Linux. Their hardware is much less powerful than Linux requires.<p>Even if a system can run (RT-)Linux, it doesn’t mean it’s suitable for real-time. Hardware for real-time projects needs much lower interrupt latency than a lot of hardware provides. Preemption isn’t the only thing necessary to support real-time requirements.</div><br/><div id="38294190" class="c"><input type="checkbox" id="c-38294190" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291449">parent</a><span>|</span><a href="#38293250">next</a><span>|</span><label class="collapse" for="c-38294190">[-]</label><label class="expand" for="c-38294190">[1 more]</label></div><br/><div class="children"><div class="content">realtime just means execution time is bounded. It doesn&#x27;t necessarily mean the latency is low. Though, in this sense RT-linux should probably be mostly thought of as low-latency linux, and the improvement in realtime guarantees is mostly in reducing the amount of things that can cause you to miss a deadline as opposed to allowing you to guarantee any particular deadline, even a long one.</div><br/></div></div><div id="38293250" class="c"><input type="checkbox" id="c-38293250" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291449">parent</a><span>|</span><a href="#38294190">prev</a><span>|</span><a href="#38292376">next</a><span>|</span><label class="collapse" for="c-38293250">[-]</label><label class="expand" for="c-38293250">[1 more]</label></div><br/><div class="children"><div class="content">Sure but that was already mentioned before the comment I was replying to. Standard hardware not being great for realtime has nothing to do with hypothetical realtime Linux.</div><br/></div></div><div id="38292376" class="c"><input type="checkbox" id="c-38292376" checked=""/><div class="controls bullet"><span class="by">skyde</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291449">parent</a><span>|</span><a href="#38293250">prev</a><span>|</span><a href="#38292637">next</a><span>|</span><label class="collapse" for="c-38292376">[-]</label><label class="expand" for="c-38292376">[2 more]</label></div><br/><div class="children"><div class="content">what kind of Hardware is considered to have &quot;lower interrupt latency&quot;?
Is there some kind of Arduino board I could get that fit those lower interrupt latency required for real-time but still support things like Bluetooth?</div><br/><div id="38295310" class="c"><input type="checkbox" id="c-38295310" checked=""/><div class="controls bullet"><span class="by">lumb63</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292376">parent</a><span>|</span><a href="#38292637">next</a><span>|</span><label class="collapse" for="c-38295310">[-]</label><label class="expand" for="c-38295310">[1 more]</label></div><br/><div class="children"><div class="content">Take a look at the Cortex R series. The Cortex M series still has lower interrupt latency than the A series, but lower processing power. I imagine for something like Bluetooth that an M is more than sufficient.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38292637" class="c"><input type="checkbox" id="c-38292637" checked=""/><div class="controls bullet"><span class="by">moffkalast</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38291226">parent</a><span>|</span><a href="#38291284">prev</a><span>|</span><a href="#38291988">next</a><span>|</span><label class="collapse" for="c-38292637">[-]</label><label class="expand" for="c-38292637">[2 more]</label></div><br/><div class="children"><div class="content">I feel like at this point we have enough cores (or will soon, anyway) that you could dedicate one entirely to one process and have it run realtime.</div><br/><div id="38292704" class="c"><input type="checkbox" id="c-38292704" checked=""/><div class="controls bullet"><span class="by">KWxIUElW8Xt0tD9</span><span>|</span><a href="#38290939">root</a><span>|</span><a href="#38292637">parent</a><span>|</span><a href="#38291988">next</a><span>|</span><label class="collapse" for="c-38292704">[-]</label><label class="expand" for="c-38292704">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s one way to run DPDK processes under LINUX -- you get the whole processor for doing whatever network processing you want to do -- no interruptions from anything.</div><br/></div></div></div></div></div></div><div id="38291988" class="c"><input type="checkbox" id="c-38291988" checked=""/><div class="controls bullet"><span class="by">JohnFen</span><span>|</span><a href="#38290939">parent</a><span>|</span><a href="#38291226">prev</a><span>|</span><a href="#38298858">next</a><span>|</span><label class="collapse" for="c-38291988">[-]</label><label class="expand" for="c-38291988">[1 more]</label></div><br/><div class="children"><div class="content">When I&#x27;m doing realtime applications using cheap, low-power, high-clockrate ARM chips (I don&#x27;t consider x86 chips for those sorts of applications), I&#x27;m not using an operating system at all. An OS interferes too much, even an RTOS. I don&#x27;t see how this changes anything.<p>But it all depends on what your application is. There are a lot of applications that are &quot;almost real-time&quot; in need. For those, this might be useful.</div><br/></div></div><div id="38298858" class="c"><input type="checkbox" id="c-38298858" checked=""/><div class="controls bullet"><span class="by">PaulDavisThe1st</span><span>|</span><a href="#38290939">parent</a><span>|</span><a href="#38291988">prev</a><span>|</span><a href="#38291147">next</a><span>|</span><label class="collapse" for="c-38298858">[-]</label><label class="expand" for="c-38298858">[1 more]</label></div><br/><div class="children"><div class="content">CPU speed and clock rate has absolutely nothing to do with realtime anything.</div><br/></div></div><div id="38291147" class="c"><input type="checkbox" id="c-38291147" checked=""/><div class="controls bullet"><span class="by">foobarian</span><span>|</span><a href="#38290939">parent</a><span>|</span><a href="#38298858">prev</a><span>|</span><a href="#38291220">next</a><span>|</span><label class="collapse" for="c-38291147">[-]</label><label class="expand" for="c-38291147">[1 more]</label></div><br/><div class="children"><div class="content">Ethernet nods in vigorous agreement</div><br/></div></div><div id="38291220" class="c"><input type="checkbox" id="c-38291220" checked=""/><div class="controls bullet"><span class="by">imtringued</span><span>|</span><a href="#38290939">parent</a><span>|</span><a href="#38291147">prev</a><span>|</span><a href="#38297273">next</a><span>|</span><label class="collapse" for="c-38291220">[-]</label><label class="expand" for="c-38291220">[1 more]</label></div><br/><div class="children"><div class="content">Sure, but this won&#x27;t magically remove the need for dedicated cores. What will probably happen is that people will tell the scheduler to exclusively put non-premptible real time tasks on one of the LITTLE cores.</div><br/></div></div></div></div><div id="38297273" class="c"><input type="checkbox" id="c-38297273" checked=""/><div class="controls bullet"><span class="by">pardoned_turkey</span><span>|</span><a href="#38290939">prev</a><span>|</span><a href="#38291289">next</a><span>|</span><label class="collapse" for="c-38297273">[-]</label><label class="expand" for="c-38297273">[1 more]</label></div><br/><div class="children"><div class="content">The conversation here focuses on a distinction between &quot;hard&quot; real-time applications, where you probably don&#x27;t want a general-purpose OS like Linux no matter what; and &quot;soft&quot; real-time applications like videoconferencing or audio playback, where you nothing terrible happens if you get a bit of stuttering or drop a couple of frames every now and then. The argument is that RT Linux would be a killer solution for that.<p>But you can do all these proposed &quot;soft&quot; use cases with embedded Linux today. It&#x27;s not like low-latency software video or audio playback is not possible, or wasn&#x27;t possible twenty years ago. You only run into problems on busy systems where non-preemptible I&#x2F;O could regularly get in the way. That&#x27;s seldom a concern in embedded environments.<p>I think there are compelling reasons for making the kernel fully-preemptible, giving people more control over scheduling, and so forth. But these reasons have relatively little to do with wanting Linux to supersede minimalistic realtime OSes or bare-metal code. It&#x27;s just good hygiene that will result in an OS that, even in non-RT applications, behaves better under load.</div><br/></div></div><div id="38291289" class="c"><input type="checkbox" id="c-38291289" checked=""/><div class="controls bullet"><span class="by">eisbaw</span><span>|</span><a href="#38297273">prev</a><span>|</span><a href="#38290922">next</a><span>|</span><label class="collapse" for="c-38291289">[-]</label><label class="expand" for="c-38291289">[15 more]</label></div><br/><div class="children"><div class="content">Great to hear. However even if Linux the kernel is real-time, likely the hardware won&#x27;t be due to caches and internal magic CPU trickery.<p>Big complex hardware is a no-no for true real-time.<p>That&#x27;s why AbsInt and WCET tools mainly has simple CPU architectures. 8051 will truly live forever.<p>btw, Zephyr RTOS.</div><br/><div id="38291433" class="c"><input type="checkbox" id="c-38291433" checked=""/><div class="controls bullet"><span class="by">wholesomepotato</span><span>|</span><a href="#38291289">parent</a><span>|</span><a href="#38291520">next</a><span>|</span><label class="collapse" for="c-38291433">[-]</label><label class="expand" for="c-38291433">[7 more]</label></div><br/><div class="children"><div class="content">Features of modern CPUs don&#x27;t really prevent them from real time usage, afaik. As long as something is bounded and can be reasoned about it can be used to build a real time system. You can always assume no cache hits and alikes, maximum load etc and as long as you can put a bound on the time it will take, you&#x27;re good to go.</div><br/><div id="38291866" class="c"><input type="checkbox" id="c-38291866" checked=""/><div class="controls bullet"><span class="by">bloak</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291433">parent</a><span>|</span><a href="#38291694">next</a><span>|</span><label class="collapse" for="c-38291866">[-]</label><label class="expand" for="c-38291866">[1 more]</label></div><br/><div class="children"><div class="content">So the things that might prevent you are:<p>1. Suppliers have not given you sufficient information for you to be able to prove an upper bound on the time taken. (That must happen a lot.)<p>2. The system is so complicated that you are not totally confident of the correctness of your proof of the upper bound.<p>3. The only upper bound that can prove with reasonable confidence is so amazingly bad that you&#x27;d be better off with cheaper, simpler hardware.<p>4. There really isn&#x27;t a worst case. There might, for example, be a situation equivalent to &quot;roll the dice until you don&#x27;t get snake eyes&quot;. In networking, for example, sometimes after a collision both parties try again after a random delay so the situation is resolved eventually with probability one but there&#x27;s no actual upper bound. A complex CPU and memory system might have something like that? Perhaps you&#x27;d be happy with &quot;the probability of this operation taking more than 2000 clock cycles is less than 10^-13&quot; but perhaps not.</div><br/></div></div><div id="38291694" class="c"><input type="checkbox" id="c-38291694" checked=""/><div class="controls bullet"><span class="by">SAI_Peregrinus</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291433">parent</a><span>|</span><a href="#38291866">prev</a><span>|</span><a href="#38293246">next</a><span>|</span><label class="collapse" for="c-38291694">[-]</label><label class="expand" for="c-38291694">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. &quot;Real-time&quot; is a misnomer, it should be called &quot;bounded-time&quot;. As long as the bound is deterministic, known in advance, and guaranteed, it&#x27;s &quot;real-time&quot;. For it to be useful it also must be under some application-specific duration.<p>The bounds are usually in CPU cycles, so a faster CPU can sometimes be used even if it takes more cycles. CPUs capable of running Linux usually have higher latency (in cycles) than microcontrollers, but as long as that can be kept under the (wall clock) duration limits with bounded-time it&#x27;s fine. There will still be cases where the worst-case latency to fetch from DRAM in an RT-Linux system will be higher than a slower MCU fetching from internal SRAM, so RT-Linux won&#x27;t take over all these systems.</div><br/></div></div><div id="38293246" class="c"><input type="checkbox" id="c-38293246" checked=""/><div class="controls bullet"><span class="by">dooglius</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291433">parent</a><span>|</span><a href="#38291694">prev</a><span>|</span><a href="#38291541">next</a><span>|</span><label class="collapse" for="c-38293246">[-]</label><label class="expand" for="c-38293246">[1 more]</label></div><br/><div class="children"><div class="content">System management mode is one example of a feature on modern CPUs that prevents real-time usage
<a href="https:&#x2F;&#x2F;wiki.linuxfoundation.org&#x2F;realtime&#x2F;documentation&#x2F;howto&#x2F;debugging&#x2F;smi-latency&#x2F;smi" rel="nofollow noreferrer">https:&#x2F;&#x2F;wiki.linuxfoundation.org&#x2F;realtime&#x2F;documentation&#x2F;howt...</a></div><br/></div></div><div id="38291541" class="c"><input type="checkbox" id="c-38291541" checked=""/><div class="controls bullet"><span class="by">synergy20</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291433">parent</a><span>|</span><a href="#38293246">prev</a><span>|</span><a href="#38291520">next</a><span>|</span><label class="collapse" for="c-38291541">[-]</label><label class="expand" for="c-38291541">[3 more]</label></div><br/><div class="children"><div class="content">mlock your memory, test with cache miss and cache invalidation scenarios will help, using no heap for memory allocation, but it&#x27;s a bit hard</div><br/><div id="38295271" class="c"><input type="checkbox" id="c-38295271" checked=""/><div class="controls bullet"><span class="by">jeffreygoesto</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291541">parent</a><span>|</span><a href="#38297221">next</a><span>|</span><label class="collapse" for="c-38295271">[-]</label><label class="expand" for="c-38295271">[1 more]</label></div><br/><div class="children"><div class="content">Right. But still possible.<p><a href="https:&#x2F;&#x2F;www.etas.com&#x2F;en&#x2F;applications&#x2F;etas-middleware-solution.php" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.etas.com&#x2F;en&#x2F;applications&#x2F;etas-middleware-solutio...</a></div><br/></div></div><div id="38297221" class="c"><input type="checkbox" id="c-38297221" checked=""/><div class="controls bullet"><span class="by">eschneider</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291541">parent</a><span>|</span><a href="#38295271">prev</a><span>|</span><a href="#38291520">next</a><span>|</span><label class="collapse" for="c-38297221">[-]</label><label class="expand" for="c-38297221">[1 more]</label></div><br/><div class="children"><div class="content">Does anyone use paged memory in hard realtime systems?</div><br/></div></div></div></div></div></div><div id="38291520" class="c"><input type="checkbox" id="c-38291520" checked=""/><div class="controls bullet"><span class="by">nraynaud</span><span>|</span><a href="#38291289">parent</a><span>|</span><a href="#38291433">prev</a><span>|</span><a href="#38293540">next</a><span>|</span><label class="collapse" for="c-38291520">[-]</label><label class="expand" for="c-38291520">[2 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s really useful on &#x27;big&#x27; MCU, like the raspberry pi. There exists an entire real time spirit there, where you don&#x27;t really use the CPU to do any bit banging but everything is on time as seen from the outside. You have timers that receive the quadrature encoders inputs, and they just send interrupt when they wrap, the GPIO system can be plugged to the DMA, so you can stream the memory to the output pins without involving the CPU (again, interrupts at mid-buffer and empty buffer).
You can stream to a DAC, stream from a ADC to memory with the DMA.
A lot of that stuff bypasses the caches to get a predictable latency.</div><br/><div id="38291842" class="c"><input type="checkbox" id="c-38291842" checked=""/><div class="controls bullet"><span class="by">stefan_</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291520">parent</a><span>|</span><a href="#38293540">next</a><span>|</span><label class="collapse" for="c-38291842">[-]</label><label class="expand" for="c-38291842">[1 more]</label></div><br/><div class="children"><div class="content">Nice idea but big chip design strikes again: on the latest Raspberry Pi, GPIO pins are handled by the separate IO chip connected over PCI Express. So now all your GPIO stuff needs to traverse a shared serial bus (that is also doing bulk stuff like say raw camera images).<p>And already on many bigger MCUs, GPIOs are just separate blocks on a shared internal bus like AHB&#x2F;APB that connects together all the chip IP, causing unpredictable latencies.</div><br/></div></div></div></div><div id="38293540" class="c"><input type="checkbox" id="c-38293540" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#38291289">parent</a><span>|</span><a href="#38291520">prev</a><span>|</span><a href="#38291858">next</a><span>|</span><label class="collapse" for="c-38293540">[-]</label><label class="expand" for="c-38293540">[1 more]</label></div><br/><div class="children"><div class="content"><i>Big complex hardware is a no-no for true real-time.</i><p>There are advanced real time cores like the Arm Coretex-R82. In fact many real time systems are becoming quite powerful due to the need to process and aggregate ever increasing amounts of sensor data.</div><br/></div></div><div id="38291858" class="c"><input type="checkbox" id="c-38291858" checked=""/><div class="controls bullet"><span class="by">0xDEF</span><span>|</span><a href="#38291289">parent</a><span>|</span><a href="#38293540">prev</a><span>|</span><a href="#38290922">next</a><span>|</span><label class="collapse" for="c-38291858">[-]</label><label class="expand" for="c-38291858">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Big complex hardware is a no-no for true real-time.<p>SpaceX uses x86 processors for their rockets. That small drone copter NASA put on Mars uses &quot;big-ish&quot; ARM cores that can probably run older versions of Android.</div><br/><div id="38292861" class="c"><input type="checkbox" id="c-38292861" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38291858">parent</a><span>|</span><a href="#38290922">next</a><span>|</span><label class="collapse" for="c-38292861">[-]</label><label class="expand" for="c-38292861">[3 more]</label></div><br/><div class="children"><div class="content">Does everything runs on those CPUs though?  Hard realtime control is often done on much simpler MCU at the lowest level, with oversight&#x2F;planning for a high level system....</div><br/><div id="38293596" class="c"><input type="checkbox" id="c-38293596" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38292861">parent</a><span>|</span><a href="#38290922">next</a><span>|</span><label class="collapse" for="c-38293596">[-]</label><label class="expand" for="c-38293596">[2 more]</label></div><br/><div class="children"><div class="content">In short, no. For Ingenuity (the Mars2020 helicopter) the flight computer runs on pair of hard-realtime Cortex R5 MCUs paired with a FPGA. The non-realtime Snapdragon SoC handles navigation&#x2F;image processing duties.<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26907669">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=26907669</a></div><br/><div id="38294615" class="c"><input type="checkbox" id="c-38294615" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38291289">root</a><span>|</span><a href="#38293596">parent</a><span>|</span><a href="#38290922">next</a><span>|</span><label class="collapse" for="c-38294615">[-]</label><label class="expand" for="c-38294615">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s basically what I expected, thanks.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38290922" class="c"><input type="checkbox" id="c-38290922" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38291289">prev</a><span>|</span><a href="#38291817">next</a><span>|</span><label class="collapse" for="c-38290922">[-]</label><label class="expand" for="c-38290922">[56 more]</label></div><br/><div class="children"><div class="content">Synchronous logging strikes again!  We ran into this some at work with GLOG (Google&#x27;s logging library), which can, e.g., block on disk IO if stdout is a file or whatever.  GLOG was like, 90-99% of culprits when our service stalled for over 100ms.</div><br/><div id="38291214" class="c"><input type="checkbox" id="c-38291214" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#38290922">parent</a><span>|</span><a href="#38291232">next</a><span>|</span><label class="collapse" for="c-38291214">[-]</label><label class="expand" for="c-38291214">[41 more]</label></div><br/><div class="children"><div class="content">I have discussions with cow-orkers around logging;<p>&quot;We have Best-Effort and Guaranteed-Delivery APIs&quot;<p>&quot;I want Guaranteed Delivery!!!&quot;<p>&quot;If the GD logging interface is offline or slow, you&#x27;ll take downtime; is that okay?&quot;<p>&quot;NO NO Must not take downtime!&quot;<p>&quot;If you need it logged, and can&#x27;t log it, what do you do?&quot;<p>These days I just point to the CAP theorem and suggest that logging is the same as any other distributed system.  Because there&#x27;s a wikipedia article with a triangle and the word &quot;theorem&quot; people seem to accept that.<p>[edit: added &quot;GD&quot; to clarify that I was referring to the guaranteed delivery logging api, not the best effort logging API]</div><br/><div id="38291624" class="c"><input type="checkbox" id="c-38291624" checked=""/><div class="controls bullet"><span class="by">msm_</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291214">parent</a><span>|</span><a href="#38292277">next</a><span>|</span><label class="collapse" for="c-38291624">[-]</label><label class="expand" for="c-38291624">[23 more]</label></div><br/><div class="children"><div class="content">Interesting, I&#x27;d think logging is one of the clearest situations when you want best effort. Logging is, almost by definition, not the &quot;core&quot; of your application, so failure to log properly should not prevent the core of the program from working. Killing the whole program because logging server is clearly throwing the baby out with the bathwater.<p>What people probably mean is &quot;logging is important, let&#x27;s avoid losing log messages if possible&quot;, which is what &quot;best&quot; in &quot;best effort&quot; stands for. For example it&#x27;s often a good idea to have a local log queue, to avoid data loss in case of a temporary log server downtime.</div><br/><div id="38292716" class="c"><input type="checkbox" id="c-38292716" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291624">parent</a><span>|</span><a href="#38291719">next</a><span>|</span><label class="collapse" for="c-38292716">[-]</label><label class="expand" for="c-38292716">[9 more]</label></div><br/><div class="children"><div class="content">It depends.<p>Some systems the logs are journaled records for the business or are discoverable artifacts for compliance. In highly secure environments logs are not only durable but measures are taken to fingerprint them and their ordering (like ratchet hashing) to ensure integrity is invariant.<p>I would note that using disk based logging is generally harmful in these situations IMO. Network based logging is less likely to cause blocking at some OS level or other sorts of jitter that’s harder to mask. Typically I develop logging as an in memory thing that offloads to a remote service over the network. The durability of the memory store can be an issue in highly sensitive workloads, and you’ll want to do synchronous disk IO for that case to ensure durability and consistent time budgets, but for almost all application disk less logging is preferable.</div><br/><div id="38292886" class="c"><input type="checkbox" id="c-38292886" checked=""/><div class="controls bullet"><span class="by">shawnz</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292716">parent</a><span>|</span><a href="#38293150">next</a><span>|</span><label class="collapse" for="c-38292886">[-]</label><label class="expand" for="c-38292886">[6 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re not waiting for the remote log server to write the messages to its disk before proceeding, then it seems like that&#x27;s not guaranteed to me? And if you are, then you suffer all the problems of local disk logging but also all the extra failure modes introduced by the network, too</div><br/><div id="38296268" class="c"><input type="checkbox" id="c-38296268" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292886">parent</a><span>|</span><a href="#38294256">next</a><span>|</span><label class="collapse" for="c-38296268">[-]</label><label class="expand" for="c-38296268">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If you&#x27;re not waiting for the remote log server to write the messages to its disk before proceeding, then it seems like that&#x27;s not guaranteed to me?<p>Depends on your failure model. I&#x27;d consider e.g. &quot;received in memory by at least 3&#x2F;5 remote servers in separate datacenters&quot; to be safer than &quot;committed to local disk&quot;.</div><br/><div id="38297701" class="c"><input type="checkbox" id="c-38297701" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38296268">parent</a><span>|</span><a href="#38294256">next</a><span>|</span><label class="collapse" for="c-38297701">[-]</label><label class="expand" for="c-38297701">[3 more]</label></div><br/><div class="children"><div class="content">You&#x27;re still on one side or another of the CAP triangle.<p>In a network partition, you are either offline or your data is not consistent.<p>If you&#x27;re writing local to your system, you&#x27;re losing data if there&#x27;s a single device failure.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CAP_theorem" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CAP_theorem</a></div><br/><div id="38297747" class="c"><input type="checkbox" id="c-38297747" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38297701">parent</a><span>|</span><a href="#38299040">next</a><span>|</span><label class="collapse" for="c-38297747">[-]</label><label class="expand" for="c-38297747">[1 more]</label></div><br/><div class="children"><div class="content">For logs, which are immutable time series journals, any copy is entirely sufficient. The first write is a quorum.  Also from a systems POV reads are not a feature of logs.</div><br/></div></div><div id="38299040" class="c"><input type="checkbox" id="c-38299040" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38297701">parent</a><span>|</span><a href="#38297747">prev</a><span>|</span><a href="#38294256">next</a><span>|</span><label class="collapse" for="c-38299040">[-]</label><label class="expand" for="c-38299040">[1 more]</label></div><br/><div class="children"><div class="content">CAP is irrelevant, consistency does not matter for logs.</div><br/></div></div></div></div></div></div><div id="38294256" class="c"><input type="checkbox" id="c-38294256" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292886">parent</a><span>|</span><a href="#38296268">prev</a><span>|</span><a href="#38293150">next</a><span>|</span><label class="collapse" for="c-38294256">[-]</label><label class="expand" for="c-38294256">[1 more]</label></div><br/><div class="children"><div class="content">The difference is that network IO can be more easily masked by the operating system than block device IO. When you offload your logging to another thread the story isn’t over because your disk logging can interfere at a system level.  Network IO isn’t as noisy. If durability is important you might still need to wait for an ACK before freeing the buffer for the message which might lead to more overall memory use, all the operations play nicely in a preemptable scheduling system.<p>Also, the failure modes of <i>systems</i> are very tied to durable storage devices attached to the system and very rarely to network devices. By reducing the number of things that need a disk (ideally to zero) you can remove disks from the system and its availability story. Once you get to fully disk less systems the system failure modes are actually almost nothing. But even with disks attached reducing the times you interact with the disk (especially for chatty things like logs!) reduces the likelihood the entire system fails due to a disk issue.</div><br/></div></div></div></div><div id="38293150" class="c"><input type="checkbox" id="c-38293150" checked=""/><div class="controls bullet"><span class="by">ReactiveJelly</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292716">parent</a><span>|</span><a href="#38292886">prev</a><span>|</span><a href="#38291719">next</a><span>|</span><label class="collapse" for="c-38293150">[-]</label><label class="expand" for="c-38293150">[2 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s a journaled record for the business then I think I&#x27;d write it to SQLite or something with good transactions and not mix it in the debug logs</div><br/><div id="38294274" class="c"><input type="checkbox" id="c-38294274" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38293150">parent</a><span>|</span><a href="#38291719">next</a><span>|</span><label class="collapse" for="c-38294274">[-]</label><label class="expand" for="c-38294274">[1 more]</label></div><br/><div class="children"><div class="content">There are more logs than debug logs, and using SQLite as the encoding store for your logs doesn’t make it not logging.</div><br/></div></div></div></div></div></div><div id="38291719" class="c"><input type="checkbox" id="c-38291719" checked=""/><div class="controls bullet"><span class="by">cduzz</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291624">parent</a><span>|</span><a href="#38292716">prev</a><span>|</span><a href="#38292432">next</a><span>|</span><label class="collapse" for="c-38291719">[-]</label><label class="expand" for="c-38291719">[1 more]</label></div><br/><div class="children"><div class="content">People use logging (appropriately or inappropriately; not my bucket of monkeys) for a variety of things including audit and billing records, which are likely a good case for a guaranteed delivery API.<p>People often don&#x27;t think precisely about what they say or want, and also often don&#x27;t think through corner cases such as &quot;what if XYZ breaks or gets slow?&quot;<p>And don&#x27;t get me started on &quot;log&quot; messages that are 300mb events.  Per log.  Sigh.</div><br/></div></div><div id="38292432" class="c"><input type="checkbox" id="c-38292432" checked=""/><div class="controls bullet"><span class="by">linuxdude314</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291624">parent</a><span>|</span><a href="#38291719">prev</a><span>|</span><a href="#38292141">next</a><span>|</span><label class="collapse" for="c-38292432">[-]</label><label class="expand" for="c-38292432">[1 more]</label></div><br/><div class="children"><div class="content">It’s not the core of the application, but it can be the core of the business.<p>For companies that sell API access logs in one form or another are how bills are reconciled and usage metered.</div><br/></div></div><div id="38292141" class="c"><input type="checkbox" id="c-38292141" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291624">parent</a><span>|</span><a href="#38292432">prev</a><span>|</span><a href="#38292669">next</a><span>|</span><label class="collapse" for="c-38292141">[-]</label><label class="expand" for="c-38292141">[8 more]</label></div><br/><div class="children"><div class="content">If you lose logs when your service crashes you&#x27;re losing logs at the time they are most important.</div><br/><div id="38292442" class="c"><input type="checkbox" id="c-38292442" checked=""/><div class="controls bullet"><span class="by">tremon</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292141">parent</a><span>|</span><a href="#38292378">next</a><span>|</span><label class="collapse" for="c-38292442">[-]</label><label class="expand" for="c-38292442">[2 more]</label></div><br/><div class="children"><div class="content">But if your service has downtime because the logs could not be written, that seems strictly inferior. As someone else wrote upthread, you only want guaranteed delivery for logs if they&#x27;re required under a strict audit regime and the cost of noncompliance is higher than the cost of a service outage.</div><br/><div id="38295333" class="c"><input type="checkbox" id="c-38295333" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292442">parent</a><span>|</span><a href="#38292378">next</a><span>|</span><label class="collapse" for="c-38295333">[-]</label><label class="expand" for="c-38295333">[1 more]</label></div><br/><div class="children"><div class="content">FWIW I agree, I&#x27;m just trying to be clear that you are choosing one or the other, as the grandparent was stating.</div><br/></div></div></div></div><div id="38292378" class="c"><input type="checkbox" id="c-38292378" checked=""/><div class="controls bullet"><span class="by">tux1968</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292141">parent</a><span>|</span><a href="#38292442">prev</a><span>|</span><a href="#38292402">next</a><span>|</span><label class="collapse" for="c-38292378">[-]</label><label class="expand" for="c-38292378">[4 more]</label></div><br/><div class="children"><div class="content">That&#x27;s unavoidable if the logging service is down when your server crashes.<p>Having a local queue doesn&#x27;t mean logging to the service is delayed, it can be sent immediately.  All the local queue does is give you some resiliency, by being able to retry if the first logging attempt fails.</div><br/><div id="38294644" class="c"><input type="checkbox" id="c-38294644" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292378">parent</a><span>|</span><a href="#38292402">next</a><span>|</span><label class="collapse" for="c-38294644">[-]</label><label class="expand" for="c-38294644">[3 more]</label></div><br/><div class="children"><div class="content">If your logging service is down all bets are off. But by buffering logs you&#x27;re now accepting that problems <i>not</i> related to the logging service will also cause you to drop logs  - as I mentioned, your service crashing, or being OOM&#x27;d, would be one example.</div><br/><div id="38297019" class="c"><input type="checkbox" id="c-38297019" checked=""/><div class="controls bullet"><span class="by">tux1968</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38294644">parent</a><span>|</span><a href="#38292402">next</a><span>|</span><label class="collapse" for="c-38297019">[-]</label><label class="expand" for="c-38297019">[2 more]</label></div><br/><div class="children"><div class="content">What&#x27;s more likely?  An intermittent network issue, the logging service being momentarily down, or a local crash that only affects your buffering queue?<p>If an OOM happens, all bets are off anyway, since it has as much likelihood of taking out your application as it does your buffering code.   The local buffering code might very well be part of the application in the first place, so the fate of the buffering code is the same as the application anyway.<p>It seems you&#x27;re trying very hard to contrive a situation where doing nothing is better than taking reasonable steps to counter occasional network hiccups.</div><br/><div id="38298002" class="c"><input type="checkbox" id="c-38298002" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38297019">parent</a><span>|</span><a href="#38292402">next</a><span>|</span><label class="collapse" for="c-38298002">[-]</label><label class="expand" for="c-38298002">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It seems you&#x27;re trying very hard to contrive a situation where doing nothing is better than taking reasonable steps to counter occasional network hiccups.<p>I think you&#x27;ve completely misunderstood me then. I haven&#x27;t taken a stance at all on what should be done. I&#x27;m only trying to agree with the grandparent poster about logging ultimately reflecting CAP Theorem.</div><br/></div></div></div></div></div></div></div></div><div id="38292402" class="c"><input type="checkbox" id="c-38292402" checked=""/><div class="controls bullet"><span class="by">andreasmetsala</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292141">parent</a><span>|</span><a href="#38292378">prev</a><span>|</span><a href="#38292669">next</a><span>|</span><label class="collapse" for="c-38292402">[-]</label><label class="expand" for="c-38292402">[1 more]</label></div><br/><div class="children"><div class="content">No, you’re losing client logs when your logging service crashes. Your logging service should probably not be logging through calls to itself.</div><br/></div></div></div></div><div id="38292669" class="c"><input type="checkbox" id="c-38292669" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291624">parent</a><span>|</span><a href="#38292141">prev</a><span>|</span><a href="#38292277">next</a><span>|</span><label class="collapse" for="c-38292669">[-]</label><label class="expand" for="c-38292669">[3 more]</label></div><br/><div class="children"><div class="content">Logging can be essential to security (to auditing). It&#x27;s your record of what happened. If an attacker can cause logging to fail, they can cover their tracks more easily.</div><br/><div id="38292968" class="c"><input type="checkbox" id="c-38292968" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292669">parent</a><span>|</span><a href="#38292277">next</a><span>|</span><label class="collapse" for="c-38292968">[-]</label><label class="expand" for="c-38292968">[2 more]</label></div><br/><div class="children"><div class="content">To me audit logs aren&#x27;t &quot;logs&quot; (in the normal sense), despite the name. They tend to have different requirements; e.g., in my industry, they must be retained, by law, and for far longer than our normal logs.<p>To me, those different requirements imply that they <i>should</i> be treated differently by the code, probably even under distinct flows: synchronously, and ideally to somewhere that I can later compress like hell and store in some very cheap long term storage.<p>Whereas the debug logs that I use for debugging? Rotate out after 30 to 90d, … and yeah, best effort is fine.<p>(The audit logs might also end up in one&#x27;s normal logs too, for convenience.)</div><br/><div id="38293080" class="c"><input type="checkbox" id="c-38293080" checked=""/><div class="controls bullet"><span class="by">wolverine876</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292968">parent</a><span>|</span><a href="#38292277">next</a><span>|</span><label class="collapse" for="c-38293080">[-]</label><label class="expand" for="c-38293080">[1 more]</label></div><br/><div class="children"><div class="content">While I generally agree, I&#x27;ll add that the debug logs can be useful in security incidents.</div><br/></div></div></div></div></div></div></div></div><div id="38292277" class="c"><input type="checkbox" id="c-38292277" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291214">parent</a><span>|</span><a href="#38291624">prev</a><span>|</span><a href="#38293953">next</a><span>|</span><label class="collapse" for="c-38292277">[-]</label><label class="expand" for="c-38292277">[3 more]</label></div><br/><div class="children"><div class="content">&gt; &quot;If the GD logging interface is offline or slow, you&#x27;ll take downtime; is that okay?&quot;<p>&gt; [edit: added &quot;GD&quot; to clarify that I was referring to the guaranteed delivery logging api, not the best effort logging API]<p>i read GD as god-damned :-)</div><br/><div id="38292514" class="c"><input type="checkbox" id="c-38292514" checked=""/><div class="controls bullet"><span class="by">salamanderman</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292277">parent</a><span>|</span><a href="#38293127">next</a><span>|</span><label class="collapse" for="c-38292514">[-]</label><label class="expand" for="c-38292514">[1 more]</label></div><br/><div class="children"><div class="content">me too [EDIT: and I totally empathized]</div><br/></div></div></div></div><div id="38293953" class="c"><input type="checkbox" id="c-38293953" checked=""/><div class="controls bullet"><span class="by">Zondartul</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291214">parent</a><span>|</span><a href="#38292277">prev</a><span>|</span><a href="#38292007">next</a><span>|</span><label class="collapse" for="c-38293953">[-]</label><label class="expand" for="c-38293953">[2 more]</label></div><br/><div class="children"><div class="content">I have some wishfull thinking ideas on this, but it should be possible to have both at least in an imaginary, theoretical scenario.<p>You can have both guaranteed delivery and no downtime if your whole system is so deterministic that anything that normally would result in blocking just will not, cannot happen. In other words it should be a hard real-time system that is formally verified top to bottom, down to the last transistor. Does anyone actually do that? Verify the program and the hardware to prove that it will never run out of memory for logs and such?<p>Continuing this thought, logs are probably generated endlessly, so either whoever wants them has to also guarantee that that they are processedand disposed of right after being logged... or there is a finite ammount of log messages that can be stored (arbitrary number like 10 000) but the user (of logs) has to guarantee that they will take the &quot;mail&quot; out of the box sooner than it overfills (at some predictable, deterministic rate). So really that means even if OUR system is mathematically perfect, we&#x27;re just making the downtime someone elses problem - namely, the consumer of the infinite logs.<p>That, or we guarantee that the final resources of our self-contained, verified system will last longer than the finite shelf life of the system as a whole (like maybe 5 years for another arbitrary number)</div><br/><div id="38294018" class="c"><input type="checkbox" id="c-38294018" checked=""/><div class="controls bullet"><span class="by">morelisp</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38293953">parent</a><span>|</span><a href="#38292007">next</a><span>|</span><label class="collapse" for="c-38294018">[-]</label><label class="expand" for="c-38294018">[1 more]</label></div><br/><div class="children"><div class="content">PACELC says you get blocking or unavailability or inconsistency.</div><br/></div></div></div></div><div id="38292007" class="c"><input type="checkbox" id="c-38292007" checked=""/><div class="controls bullet"><span class="by">supriyo-biswas</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291214">parent</a><span>|</span><a href="#38293953">prev</a><span>|</span><a href="#38291443">next</a><span>|</span><label class="collapse" for="c-38292007">[-]</label><label class="expand" for="c-38292007">[9 more]</label></div><br/><div class="children"><div class="content">The better way to do this is to write the logs to a file or an in-memory ring buffer and have a separate thread&#x2F;process push logs from the file&#x2F;ring-buffer to the logging service, allowing for retries if the logging service is down or slow (for moderately short values of down&#x2F;slow).<p>Promtail[1] can do this if you&#x27;re using Loki for logging.<p>[1] <a href="https:&#x2F;&#x2F;grafana.com&#x2F;docs&#x2F;loki&#x2F;latest&#x2F;send-data&#x2F;promtail&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;grafana.com&#x2F;docs&#x2F;loki&#x2F;latest&#x2F;send-data&#x2F;promtail&#x2F;</a></div><br/><div id="38292136" class="c"><input type="checkbox" id="c-38292136" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292007">parent</a><span>|</span><a href="#38292194">next</a><span>|</span><label class="collapse" for="c-38292136">[-]</label><label class="expand" for="c-38292136">[6 more]</label></div><br/><div class="children"><div class="content">But that&#x27;s still not guaranteed delivery. You&#x27;re doing what the OP presented - choosing to drop logs under some circumstances when the system is down.<p>a) If your service crashes and it&#x27;s in-memory, you lose logs<p>b) If your service can&#x27;t push logs off (upstream service is down or slow) you either drop logs, run out of memory, or block</div><br/><div id="38292628" class="c"><input type="checkbox" id="c-38292628" checked=""/><div class="controls bullet"><span class="by">kbenson</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292136">parent</a><span>|</span><a href="#38292546">next</a><span>|</span><label class="collapse" for="c-38292628">[-]</label><label class="expand" for="c-38292628">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, what the &quot;best effort&quot; actually means in practice is usually a result of how much resources you want to throw at the problem.  Those give you runway on how much of a problem you can withstand and perhaps recover from without any loss of data (logs), but in the end you&#x27;re usually still just buying time.  That&#x27;s usually enough though.</div><br/></div></div><div id="38292546" class="c"><input type="checkbox" id="c-38292546" checked=""/><div class="controls bullet"><span class="by">hgfghui7</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292136">parent</a><span>|</span><a href="#38292628">prev</a><span>|</span><a href="#38294221">next</a><span>|</span><label class="collapse" for="c-38292546">[-]</label><label class="expand" for="c-38292546">[3 more]</label></div><br/><div class="children"><div class="content">You are thinking too much in terms of the stated requirements instead of what people actually want: good uptime and good debugability. Falling back to local logging means a blip in logging availability doesn&#x27;t turn into all hands on deck everything is on fire. And it means that logs will very likely be available for any failures.<p>In other words it&#x27;s good enough.</div><br/><div id="38292775" class="c"><input type="checkbox" id="c-38292775" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292546">parent</a><span>|</span><a href="#38294653">next</a><span>|</span><label class="collapse" for="c-38292775">[-]</label><label class="expand" for="c-38292775">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Good uptime and good reliability but no guarantees&quot; is just a good best effort system.</div><br/></div></div><div id="38294653" class="c"><input type="checkbox" id="c-38294653" checked=""/><div class="controls bullet"><span class="by">insanitybit</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292546">parent</a><span>|</span><a href="#38292775">prev</a><span>|</span><a href="#38294221">next</a><span>|</span><label class="collapse" for="c-38294653">[-]</label><label class="expand" for="c-38294653">[1 more]</label></div><br/><div class="children"><div class="content">Good enough is literally &quot;best effort delivery&quot;, you&#x27;re just agreeing with them that this is ultimately a distributed systems problem and you either choose CP or AP.</div><br/></div></div></div></div><div id="38294221" class="c"><input type="checkbox" id="c-38294221" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292136">parent</a><span>|</span><a href="#38292546">prev</a><span>|</span><a href="#38292194">next</a><span>|</span><label class="collapse" for="c-38294221">[-]</label><label class="expand" for="c-38294221">[1 more]</label></div><br/><div class="children"><div class="content">Logging to `mmap`ed files is resilient to service crashes, just not hardware crashes.</div><br/></div></div></div></div><div id="38292194" class="c"><input type="checkbox" id="c-38292194" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292007">parent</a><span>|</span><a href="#38292136">prev</a><span>|</span><a href="#38291443">next</a><span>|</span><label class="collapse" for="c-38292194">[-]</label><label class="expand" for="c-38292194">[2 more]</label></div><br/><div class="children"><div class="content">We did something like this at Weebly for stats. The app sent the stats to a local service via UDP, so shoot and forget. That service aggregated for 1s and then sent off server.</div><br/><div id="38292662" class="c"><input type="checkbox" id="c-38292662" checked=""/><div class="controls bullet"><span class="by">laurencerowe</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292194">parent</a><span>|</span><a href="#38291443">next</a><span>|</span><label class="collapse" for="c-38292662">[-]</label><label class="expand" for="c-38292662">[1 more]</label></div><br/><div class="children"><div class="content">Why UDP for a local service rather than a unix socket?</div><br/></div></div></div></div></div></div><div id="38291443" class="c"><input type="checkbox" id="c-38291443" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291214">parent</a><span>|</span><a href="#38292007">prev</a><span>|</span><a href="#38293318">next</a><span>|</span><label class="collapse" for="c-38291443">[-]</label><label class="expand" for="c-38291443">[2 more]</label></div><br/><div class="children"><div class="content">I read GD as “god damn,” which also seems to fit.</div><br/><div id="38292318" class="c"><input type="checkbox" id="c-38292318" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291443">parent</a><span>|</span><a href="#38293318">next</a><span>|</span><label class="collapse" for="c-38292318">[-]</label><label class="expand" for="c-38292318">[1 more]</label></div><br/><div class="children"><div class="content">aw you beat me to it</div><br/></div></div></div></div></div></div><div id="38291232" class="c"><input type="checkbox" id="c-38291232" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#38290922">parent</a><span>|</span><a href="#38291214">prev</a><span>|</span><a href="#38293209">next</a><span>|</span><label class="collapse" for="c-38291232">[-]</label><label class="expand" for="c-38291232">[4 more]</label></div><br/><div class="children"><div class="content">We had prod halt once when the syslog server hanged. Logs were pushed through TCP which propagated the blocking to the whole of prod. We switched to UDP transport since: better to lose some logs than the whole of prod.</div><br/><div id="38293042" class="c"><input type="checkbox" id="c-38293042" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291232">parent</a><span>|</span><a href="#38291326">next</a><span>|</span><label class="collapse" for="c-38293042">[-]</label><label class="expand" for="c-38293042">[2 more]</label></div><br/><div class="children"><div class="content">TCP vs. UDP and async best-effort vs. synchronous are <i>completely</i> orthogonal…<p>E.g., a service I wrote wrote logs to an ELK setup; we logged over TCP. But the logging was async: we didn&#x27;t wait for logs to make it to ELK, and if the logging services went down, we just queued up logs locally. (To a point; at some point, the buffer fills up, and logs were discarded. The process would make a note of this if it happened, locally.)</div><br/><div id="38293486" class="c"><input type="checkbox" id="c-38293486" checked=""/><div class="controls bullet"><span class="by">tuetuopay</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38293042">parent</a><span>|</span><a href="#38291326">next</a><span>|</span><label class="collapse" for="c-38293486">[-]</label><label class="expand" for="c-38293486">[1 more]</label></div><br/><div class="children"><div class="content">&gt; TCP vs. UDP and async best-effort vs. synchronous are completely orthogonal…<p>I agree, when stuff is properly written. I don&#x27;t remember the exact details, but at least with UDP the asyncness is built-in: there is no backpressure whatsoever. So poorly written software can just send udp to heart&#x27;s end.</div><br/></div></div></div></div><div id="38291326" class="c"><input type="checkbox" id="c-38291326" checked=""/><div class="controls bullet"><span class="by">tetha</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38291232">parent</a><span>|</span><a href="#38293042">prev</a><span>|</span><a href="#38293209">next</a><span>|</span><label class="collapse" for="c-38291326">[-]</label><label class="expand" for="c-38291326">[1 more]</label></div><br/><div class="children"><div class="content">Especially if some system is unhappy enough to log enough volume to blow up the local log disk... you&#x27;ll usually have enough messages and clues in the bazillion other messages that have been logged.</div><br/></div></div></div></div><div id="38293209" class="c"><input type="checkbox" id="c-38293209" checked=""/><div class="controls bullet"><span class="by">RobertVDB</span><span>|</span><a href="#38290922">parent</a><span>|</span><a href="#38291232">prev</a><span>|</span><a href="#38293176">next</a><span>|</span><label class="collapse" for="c-38293209">[-]</label><label class="expand" for="c-38293209">[1 more]</label></div><br/><div class="children"><div class="content">Ah, the classic GLOG-induced service stall - brings back memories! I&#x27;ve seen similar scenarios where logging, meant to be a safety net, turns into a trap. Your 90-99% figure resonates with my experience. It&#x27;s like opening a small window for fresh air and having a storm barrel in. We eventually had to balance between logging verbosity and system performance, kind of like a tightrope walk over a sea of unpredictable IO delays. Makes one appreciate the delicate art of designing logging systems that don&#x27;t end up hogging the spotlight (and resources) themselves, doesn&#x27;t it?</div><br/></div></div><div id="38293176" class="c"><input type="checkbox" id="c-38293176" checked=""/><div class="controls bullet"><span class="by">oneepic</span><span>|</span><a href="#38290922">parent</a><span>|</span><a href="#38293209">prev</a><span>|</span><a href="#38294630">next</a><span>|</span><label class="collapse" for="c-38293176">[-]</label><label class="expand" for="c-38293176">[2 more]</label></div><br/><div class="children"><div class="content">Oh, we had this type of issue (&quot;logging lib breaks everything&quot;) with a $MSFT logging library. Imagine having 100 threads each with their own logging buffer of 300MB. Needless to say it <i>annihilated</i> our memory and our server crashed, even on the most expensive sku of Azure App Service.</div><br/><div id="38294511" class="c"><input type="checkbox" id="c-38294511" checked=""/><div class="controls bullet"><span class="by">pests</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38293176">parent</a><span>|</span><a href="#38294630">next</a><span>|</span><label class="collapse" for="c-38294511">[-]</label><label class="expand" for="c-38294511">[1 more]</label></div><br/><div class="children"><div class="content">Brilliant strategy.<p>Reminds me a litte of the oldtimers trick of adding a sleep(1000) somewhere so they could later come back and have some resources later, or if they needed a quick win with the client.<p>Now cloud companies are using malloc(300000000) it to fake resource usage. &#x2F;s</div><br/></div></div></div></div><div id="38292331" class="c"><input type="checkbox" id="c-38292331" checked=""/><div class="controls bullet"><span class="by">lopkeny12ko</span><span>|</span><a href="#38290922">parent</a><span>|</span><a href="#38294630">prev</a><span>|</span><a href="#38291817">next</a><span>|</span><label class="collapse" for="c-38292331">[-]</label><label class="expand" for="c-38292331">[6 more]</label></div><br/><div class="children"><div class="content">I would posit that if your product&#x27;s availability hinges on +&#x2F;- 100ms, you are doing something deeply wrong, and it&#x27;s not your logging library&#x27;s fault. Users are not going to care if a button press takes 100 more ms to complete.</div><br/><div id="38292629" class="c"><input type="checkbox" id="c-38292629" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292331">parent</a><span>|</span><a href="#38299880">next</a><span>|</span><label class="collapse" for="c-38292629">[-]</label><label class="expand" for="c-38292629">[2 more]</label></div><br/><div class="children"><div class="content">100ms for something like say API authorization on a high volume data plane service would be unacceptable.  Exceeding latencies like that can degrade bandwidth and cause workers to exhaust connection counts. Likewise, even in humans response space, 100ms is an enormous part of a budget for responsiveness. Taking again authorization, if you spend 100ms, you’re exhausting the perceptible threshold for a humans sense of responsiveness to do something that’s of no practical value but is entirely necessary. Your UI developers will be literally camped outside your zoom room with virtual pitch forks night and day.</div><br/><div id="38294011" class="c"><input type="checkbox" id="c-38294011" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292629">parent</a><span>|</span><a href="#38299880">next</a><span>|</span><label class="collapse" for="c-38294011">[-]</label><label class="expand" for="c-38294011">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and in fact the service I am talking about is a high volume data plane service.</div><br/></div></div></div></div><div id="38299880" class="c"><input type="checkbox" id="c-38299880" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292331">parent</a><span>|</span><a href="#38292629">prev</a><span>|</span><a href="#38292664">next</a><span>|</span><label class="collapse" for="c-38299880">[-]</label><label class="expand" for="c-38299880">[1 more]</label></div><br/><div class="children"><div class="content">Core libraries at, say, Google, are supposed to be reliable to several nines. If they go down for long enough for a human to notice, they’re failing SLA.</div><br/></div></div><div id="38292664" class="c"><input type="checkbox" id="c-38292664" checked=""/><div class="controls bullet"><span class="by">hamandcheese</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292331">parent</a><span>|</span><a href="#38299880">prev</a><span>|</span><a href="#38294008">next</a><span>|</span><label class="collapse" for="c-38292664">[-]</label><label class="expand" for="c-38292664">[1 more]</label></div><br/><div class="children"><div class="content">Not every API is a simple CRUD app with a user at the other end.</div><br/></div></div><div id="38294008" class="c"><input type="checkbox" id="c-38294008" checked=""/><div class="controls bullet"><span class="by">kccqzy</span><span>|</span><a href="#38290922">root</a><span>|</span><a href="#38292331">parent</a><span>|</span><a href="#38292664">prev</a><span>|</span><a href="#38291817">next</a><span>|</span><label class="collapse" for="c-38294008">[-]</label><label class="expand" for="c-38294008">[1 more]</label></div><br/><div class="children"><div class="content">Add some fan out and 100ms could suddenly become 1s, 10s…</div><br/></div></div></div></div></div></div><div id="38291817" class="c"><input type="checkbox" id="c-38291817" checked=""/><div class="controls bullet"><span class="by">deepsquirrelnet</span><span>|</span><a href="#38290922">prev</a><span>|</span><a href="#38292648">next</a><span>|</span><label class="collapse" for="c-38291817">[-]</label><label class="expand" for="c-38291817">[4 more]</label></div><br/><div class="children"><div class="content">What a blast from the past. I compiled a kernel for Debian with RT_PREEMPT about 17-18 years ago to use with scientific equipment that needed tighter timings. I was very impressed at the latencies and jitter.<p>I haven’t really thought about it since then, but I can imagine lots of used cases for something like an embedded application with raspberry pi where you don’t quite want to make the leap into a microcontroller running an RTOS.</div><br/><div id="38297950" class="c"><input type="checkbox" id="c-38297950" checked=""/><div class="controls bullet"><span class="by">HankB99</span><span>|</span><a href="#38291817">parent</a><span>|</span><a href="#38292648">next</a><span>|</span><label class="collapse" for="c-38297950">[-]</label><label class="expand" for="c-38297950">[3 more]</label></div><br/><div class="children"><div class="content">Interesting to mention the Raspberry Pi. I saw an article just a day or two ago that claimed that the RpiOS was stated by and ran on top of RTOS. That&#x27;s particularly interesting because at one time years ago, I saw suggestions that Linux could run as a task on an RTOS. Things that required hard real time deadlines could run on the RTOS and not be subject to the delays that a virtual memory system could entail.<p>I don&#x27;t recall if this was just an idea or was actually implemented. I also have seen only the one mention of RpiOS on an RTOS so I&#x27;m curious about that.</div><br/><div id="38298779" class="c"><input type="checkbox" id="c-38298779" checked=""/><div class="controls bullet"><span class="by">rsaxvc</span><span>|</span><a href="#38291817">root</a><span>|</span><a href="#38297950">parent</a><span>|</span><a href="#38292648">next</a><span>|</span><label class="collapse" for="c-38298779">[-]</label><label class="expand" for="c-38298779">[2 more]</label></div><br/><div class="children"><div class="content">&gt;That&#x27;s particularly interesting because at one time years ago, I saw suggestions that Linux could run as a task on an RTOS.<p>I&#x27;ve worked with systems that ran Linux as a task of uITRON as well as threadX, both on somewhat obscure ARM hardware. Linux managed the MMU but had a large carveout for the RTOS code. They had some strange interrupt management so that Linux could &#x27;disable interrupts&#x27; but while Linux IRQs were disabled, an RTOS IRQ could still fire and context switch back to an RTOS task. I haven&#x27;t seen anything like this on RPi though, but it&#x27;s totally doable.</div><br/><div id="38299901" class="c"><input type="checkbox" id="c-38299901" checked=""/><div class="controls bullet"><span class="by">HankB99</span><span>|</span><a href="#38291817">root</a><span>|</span><a href="#38298779">parent</a><span>|</span><a href="#38292648">next</a><span>|</span><label class="collapse" for="c-38299901">[-]</label><label class="expand" for="c-38299901">[1 more]</label></div><br/><div class="children"><div class="content">Interesting to know that it was more than just an idea - thanks!</div><br/></div></div></div></div></div></div></div></div><div id="38292648" class="c"><input type="checkbox" id="c-38292648" checked=""/><div class="controls bullet"><span class="by">salamanderman</span><span>|</span><a href="#38291817">prev</a><span>|</span><a href="#38291474">next</a><span>|</span><label class="collapse" for="c-38292648">[-]</label><label class="expand" for="c-38292648">[3 more]</label></div><br/><div class="children"><div class="content">I had a frustrating number of job interviews in my early career where the interviewers didn&#x27;t know what realtime actually was. That &quot;and predictable delay&quot; concept from the article frequently seemed to be lost on many folks, who seemed to think realtime just meant fast, whatever that means.</div><br/><div id="38292702" class="c"><input type="checkbox" id="c-38292702" checked=""/><div class="controls bullet"><span class="by">mort96</span><span>|</span><a href="#38292648">parent</a><span>|</span><a href="#38292890">next</a><span>|</span><label class="collapse" for="c-38292702">[-]</label><label class="expand" for="c-38292702">[1 more]</label></div><br/><div class="children"><div class="content">I would even remove the &quot;minimum&quot; part altogether; the point of realtime is that operations have predictable upper bounds. That might even mean slower average cases than in non-realtime systems. If you&#x27;re controlling a car&#x27;s braking system, &quot;the average delay is 50ms but might take up to 80ms&quot; might be acceptable, whereas &quot;the average delay is 1ms but it might take arbitrarily long, possibly multiple seconds&quot; isn&#x27;t.</div><br/></div></div><div id="38292890" class="c"><input type="checkbox" id="c-38292890" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38292648">parent</a><span>|</span><a href="#38292702">prev</a><span>|</span><a href="#38291474">next</a><span>|</span><label class="collapse" for="c-38292890">[-]</label><label class="expand" for="c-38292890">[1 more]</label></div><br/><div class="children"><div class="content">The old saying &quot;real time&quot; &#x2F;= &quot;real fast&quot;.     Hard vs &quot;soft&quot; realtime muddies things a bit, but I think it&#x27;s probably the majority of software developers don&#x27;t really understand what realtime actually is either.</div><br/></div></div></div></div><div id="38291474" class="c"><input type="checkbox" id="c-38291474" checked=""/><div class="controls bullet"><span class="by">Aaargh20318</span><span>|</span><a href="#38292648">prev</a><span>|</span><a href="#38297640">next</a><span>|</span><label class="collapse" for="c-38291474">[-]</label><label class="expand" for="c-38291474">[9 more]</label></div><br/><div class="children"><div class="content">What does this mean for the common user? Is this something you would only enable in very specific circumstances or can it also bring a more responsive system to the general public?</div><br/><div id="38291938" class="c"><input type="checkbox" id="c-38291938" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#38291474">parent</a><span>|</span><a href="#38291577">next</a><span>|</span><label class="collapse" for="c-38291938">[-]</label><label class="expand" for="c-38291938">[1 more]</label></div><br/><div class="children"><div class="content">My understanding is that real-time makes a system <i>slower</i>. To be real-time, you have to put a time allocation on everything. Each operation is allowed X budget, and will not deviate. This means if the best-case operation is fast, but the worst case is slow, the system has to always assume worst case.</div><br/></div></div><div id="38291577" class="c"><input type="checkbox" id="c-38291577" checked=""/><div class="controls bullet"><span class="by">ravingraven</span><span>|</span><a href="#38291474">parent</a><span>|</span><a href="#38291938">prev</a><span>|</span><a href="#38292370">next</a><span>|</span><label class="collapse" for="c-38291577">[-]</label><label class="expand" for="c-38291577">[1 more]</label></div><br/><div class="children"><div class="content">If by &quot;common&quot; user you mean the desktop user, not much. But this is a huge deal for embedded devices like industrial control and communication equipment, as their devs will be able to use the latest mainline kernel if they need real-time scheduling.</div><br/></div></div><div id="38292370" class="c"><input type="checkbox" id="c-38292370" checked=""/><div class="controls bullet"><span class="by">andrewaylett</span><span>|</span><a href="#38291474">parent</a><span>|</span><a href="#38291577">prev</a><span>|</span><a href="#38291526">next</a><span>|</span><label class="collapse" for="c-38292370">[-]</label><label class="expand" for="c-38292370">[1 more]</label></div><br/><div class="children"><div class="content">RT doesn&#x27;t necessarily improve latency, it gives it a fixed upper bound for <i>some</i> operations.  But the work needed to allow RT can definitely improve latency in the general case -- the example of avoiding synchronous printk() calls is a case in point.  It should improve latency under load even when RT isn&#x27;t even enabled.<p>I think I&#x27;m right in asserting that a fully-upstreamed RT kernel won&#x27;t actually do anything different from a normal one unless you&#x27;re actually running RT processes on it.  The reason it&#x27;s taken so long to upstream has been the trade-offs that have been needed to enable RT, and (per the article) there aren&#x27;t many of those left.</div><br/></div></div><div id="38291526" class="c"><input type="checkbox" id="c-38291526" checked=""/><div class="controls bullet"><span class="by">stavros</span><span>|</span><a href="#38291474">parent</a><span>|</span><a href="#38292370">prev</a><span>|</span><a href="#38294240">next</a><span>|</span><label class="collapse" for="c-38291526">[-]</label><label class="expand" for="c-38291526">[3 more]</label></div><br/><div class="children"><div class="content">As far as I can understand, this is for Linux becoming an option when you need an RTOS, so for critical things like aviation, medical devices, and other such systems. It doesn&#x27;t do anything for the common user.</div><br/><div id="38293003" class="c"><input type="checkbox" id="c-38293003" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38291474">root</a><span>|</span><a href="#38291526">parent</a><span>|</span><a href="#38291712">next</a><span>|</span><label class="collapse" for="c-38293003">[-]</label><label class="expand" for="c-38293003">[1 more]</label></div><br/><div class="children"><div class="content">For the parts of such systems that you would need an RTOS for this isn&#x27;t really a likely replacement because the OS is way too complex.<p>The sort of thing it could help with is servicing hardware that <i>does</i> run hard realtime.  For example, you have an RTOS doing direct control of a robot or medical device or whatever, and you have a UI pendant or the like that a user is interacting with.  If linux on that pendant can make some realtime latency guarantees, you may be able to simplify communication between the two without risking dropping bits on the floor.<p>Conversely, for the common user it could improve things like audio&#x2F;video streaming, in theory but I haven&#x27;t looked into details or how much trouble there is currently.</div><br/></div></div><div id="38291712" class="c"><input type="checkbox" id="c-38291712" checked=""/><div class="controls bullet"><span class="by">SubjectToChange</span><span>|</span><a href="#38291474">root</a><span>|</span><a href="#38291526">parent</a><span>|</span><a href="#38293003">prev</a><span>|</span><a href="#38294240">next</a><span>|</span><label class="collapse" for="c-38291712">[-]</label><label class="expand" for="c-38291712">[1 more]</label></div><br/><div class="children"><div class="content">The Linux kernel, real-time or not, is simply too large and too complex to realistically certify for anything safety critical.</div><br/></div></div></div></div><div id="38294240" class="c"><input type="checkbox" id="c-38294240" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38291474">parent</a><span>|</span><a href="#38291526">prev</a><span>|</span><a href="#38292330">next</a><span>|</span><label class="collapse" for="c-38294240">[-]</label><label class="expand" for="c-38294240">[1 more]</label></div><br/><div class="children"><div class="content">the most common desktop end-user that might benefit from this is those doing audio work: latency and especially jitter can be quite a pain there.</div><br/></div></div><div id="38292330" class="c"><input type="checkbox" id="c-38292330" checked=""/><div class="controls bullet"><span class="by">dist-epoch</span><span>|</span><a href="#38291474">parent</a><span>|</span><a href="#38294240">prev</a><span>|</span><a href="#38297640">next</a><span>|</span><label class="collapse" for="c-38292330">[-]</label><label class="expand" for="c-38292330">[1 more]</label></div><br/><div class="children"><div class="content">It could allow very low latency audio (1-2 ms). Not a huge thing, but nice for some audio people.</div><br/></div></div></div></div><div id="38297640" class="c"><input type="checkbox" id="c-38297640" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38291474">prev</a><span>|</span><a href="#38294773">next</a><span>|</span><label class="collapse" for="c-38297640">[-]</label><label class="expand" for="c-38297640">[5 more]</label></div><br/><div class="children"><div class="content">I feel like focusing on the kernel side misses CPU level issues.<p>Is there any known upper bound on, say, how long a memory access instruction takes on x86?</div><br/><div id="38298972" class="c"><input type="checkbox" id="c-38298972" checked=""/><div class="controls bullet"><span class="by">rsaxvc</span><span>|</span><a href="#38297640">parent</a><span>|</span><a href="#38299893">next</a><span>|</span><label class="collapse" for="c-38298972">[-]</label><label class="expand" for="c-38298972">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know for x86.<p>But for things that really matter, I&#x27;ve tested by configuring the MMU to disable caching for the memory that the realtime code lives in and uses to emulate 0% hitrate. And there&#x27;s usually still a fair amount of variance on top of that depending on if the memory controller has a small cache, and where the memory controller is in its refresh cycle.</div><br/><div id="38299030" class="c"><input type="checkbox" id="c-38299030" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38297640">root</a><span>|</span><a href="#38298972">parent</a><span>|</span><a href="#38299893">next</a><span>|</span><label class="collapse" for="c-38299030">[-]</label><label class="expand" for="c-38299030">[1 more]</label></div><br/><div class="children"><div class="content">Yeah. And I&#x27;m not sure that even <i>that</i> would give you the worst case as far as the cache is concerned. Of course I don&#x27;t know how these implementations work, but it seems plausible that code that directly uses memory could run faster than code that encounters a cache miss beforehand (or contention, if you&#x27;re using multiple cores). Moreover there&#x27;s also the instruction cache, and I&#x27;m not sure if you can disable caching for that in a meaningful way?<p>For soft real time, I don&#x27;t see a problem. But for hard real time, it seems a bit scary.</div><br/></div></div></div></div><div id="38299893" class="c"><input type="checkbox" id="c-38299893" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#38297640">parent</a><span>|</span><a href="#38298972">prev</a><span>|</span><a href="#38294773">next</a><span>|</span><label class="collapse" for="c-38299893">[-]</label><label class="expand" for="c-38299893">[2 more]</label></div><br/><div class="children"><div class="content">You can continually take page faults in a Turing complete way without executing any code, so I would guess this is unbounded?</div><br/><div id="38299903" class="c"><input type="checkbox" id="c-38299903" checked=""/><div class="controls bullet"><span class="by">dataflow</span><span>|</span><a href="#38297640">root</a><span>|</span><a href="#38299893">parent</a><span>|</span><a href="#38294773">next</a><span>|</span><label class="collapse" for="c-38299903">[-]</label><label class="expand" for="c-38299903">[1 more]</label></div><br/><div class="children"><div class="content">I almost mentioned page faults, but that&#x27;s something the kernel has control over. It could just make sure everything is in memory so there aren&#x27;t any faults. So it&#x27;s not really an issue I think.</div><br/></div></div></div></div></div></div><div id="38294773" class="c"><input type="checkbox" id="c-38294773" checked=""/><div class="controls bullet"><span class="by">rwmj</span><span>|</span><a href="#38297640">prev</a><span>|</span><a href="#38292941">next</a><span>|</span><label class="collapse" for="c-38294773">[-]</label><label class="expand" for="c-38294773">[1 more]</label></div><br/><div class="children"><div class="content">About printk, the backported RT implementation of printk added to the RHEL 9.3 kernel has deadlocks ...  <a href="https:&#x2F;&#x2F;issues.redhat.com&#x2F;browse&#x2F;RHEL-15897" rel="nofollow noreferrer">https:&#x2F;&#x2F;issues.redhat.com&#x2F;browse&#x2F;RHEL-15897</a> &amp; <a href="https:&#x2F;&#x2F;issues.redhat.com&#x2F;browse&#x2F;RHEL-9380" rel="nofollow noreferrer">https:&#x2F;&#x2F;issues.redhat.com&#x2F;browse&#x2F;RHEL-9380</a></div><br/></div></div><div id="38292941" class="c"><input type="checkbox" id="c-38292941" checked=""/><div class="controls bullet"><span class="by">alangibson</span><span>|</span><a href="#38294773">prev</a><span>|</span><a href="#38292854">next</a><span>|</span><label class="collapse" for="c-38292941">[-]</label><label class="expand" for="c-38292941">[1 more]</label></div><br/><div class="children"><div class="content">Very exiting news for those of us building CNC machines with LinuxCNC. The end of kernel patches is nigh!</div><br/></div></div><div id="38292854" class="c"><input type="checkbox" id="c-38292854" checked=""/><div class="controls bullet"><span class="by">NalNezumi</span><span>|</span><a href="#38292941">prev</a><span>|</span><a href="#38297157">next</a><span>|</span><label class="collapse" for="c-38292854">[-]</label><label class="expand" for="c-38292854">[2 more]</label></div><br/><div class="children"><div class="content">Slightly tangential, but does anyone know good learning material to understand real-time (Linux) kernel more? For someone with rudimentary Linux knowledge.<p>I&#x27;ve had to compile&amp;install real-time kernel as a requirement for a robot arm (franka) control computer. It would be nice to know a bit more than just how to install the kernel.</div><br/><div id="38292945" class="c"><input type="checkbox" id="c-38292945" checked=""/><div class="controls bullet"><span class="by">ActorNightly</span><span>|</span><a href="#38292854">parent</a><span>|</span><a href="#38297157">next</a><span>|</span><label class="collapse" for="c-38292945">[-]</label><label class="expand" for="c-38292945">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;www.freertos.org&#x2F;implementation&#x2F;a00002.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.freertos.org&#x2F;implementation&#x2F;a00002.html</a><p>Generally, having experience with Greenhills in a previous job, for personal projects like robotics or control systems I would recommend programming a microcontroller directly rather than dealing with SoC with RTOS. Modern STM32s with Cortex chips have enough processing power to run pretty much anything.</div><br/></div></div></div></div><div id="38297157" class="c"><input type="checkbox" id="c-38297157" checked=""/><div class="controls bullet"><span class="by">sesm</span><span>|</span><a href="#38292854">prev</a><span>|</span><a href="#38290872">next</a><span>|</span><label class="collapse" for="c-38297157">[-]</label><label class="expand" for="c-38297157">[1 more]</label></div><br/><div class="children"><div class="content">IMO if you really care about certain process being responsive, you should allocate dedicated CPU cores and a contiguous region of memory to it, that shouldn’t be touched by the rest of OS. Oh, and also give a it direct access to a separate network card. I’m not sure if Linux supports this.</div><br/></div></div><div id="38290872" class="c"><input type="checkbox" id="c-38290872" checked=""/><div class="controls bullet"><span class="by">andy_ppp</span><span>|</span><a href="#38297157">prev</a><span>|</span><a href="#38294038">next</a><span>|</span><label class="collapse" for="c-38290872">[-]</label><label class="expand" for="c-38290872">[10 more]</label></div><br/><div class="children"><div class="content">What do other realtime OS kernels do when printing from various places? It almost seems like this should be done in hardware because it&#x27;s such a difficult problem to not lose messages but also have them on a different OS thread in most cases.</div><br/><div id="38296365" class="c"><input type="checkbox" id="c-38296365" checked=""/><div class="controls bullet"><span class="by">xenadu02</span><span>|</span><a href="#38290872">parent</a><span>|</span><a href="#38290962">next</a><span>|</span><label class="collapse" for="c-38296365">[-]</label><label class="expand" for="c-38296365">[1 more]</label></div><br/><div class="children"><div class="content">In many problem spaces you can optimize for the common success and failure paths if you accept certain losses on long-tail failure scenarios.<p>A common logging strategy is to use a ring buffer with a separate isolated process reading from the ring. The vast majority of the time the ring buffer handles temporary disruptions (eg slow disk I&#x2F;O to write messages to disk) but in the rare failure scenarios you simply overwrite events in the buffer and increment an atomic overwritten event counter. Events do not get silently dropped but you prioritize forward progress at the cost of data loss in rare scenarios.<p>Microkernels and pushing everything to userspace just moves the tradeoffs around. If your driver is in userspace and blocks writing a log message because the log daemon is blocked or the I&#x2F;O device it is writing the log to is overloaded it does the same thing. Your realtime thread won&#x27;t get what it needs from the driver within your time limit.<p>It all comes down to CAP theorem stuff. If you always want the kernel (or any other software) to be able to make forward progress within specific time limits then you must be willing to tolerate some data loss in failure scenarios. How much and how often it happens depends on specific design factors, memory usage, etc.</div><br/></div></div><div id="38290962" class="c"><input type="checkbox" id="c-38290962" checked=""/><div class="controls bullet"><span class="by">EdSchouten</span><span>|</span><a href="#38290872">parent</a><span>|</span><a href="#38296365">prev</a><span>|</span><a href="#38291162">next</a><span>|</span><label class="collapse" for="c-38290962">[-]</label><label class="expand" for="c-38290962">[4 more]</label></div><br/><div class="children"><div class="content">Another option is simply to print less, but expose more events in the form of counters.<p>Unfortunately, within a kernel that’s as big as Linux, that would leave you with many, many, many counters. All of which need to be exported and monitored somehow.</div><br/><div id="38291148" class="c"><input type="checkbox" id="c-38291148" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#38290872">root</a><span>|</span><a href="#38290962">parent</a><span>|</span><a href="#38291162">next</a><span>|</span><label class="collapse" for="c-38291148">[-]</label><label class="expand" for="c-38291148">[3 more]</label></div><br/><div class="children"><div class="content">This seems to imply you would have more counters than messages?  Why would that be?<p>That is, I would expect moving to counters to be less information, period.  That not the case?</div><br/><div id="38291227" class="c"><input type="checkbox" id="c-38291227" checked=""/><div class="controls bullet"><span class="by">nraynaud</span><span>|</span><a href="#38290872">root</a><span>|</span><a href="#38291148">parent</a><span>|</span><a href="#38291162">next</a><span>|</span><label class="collapse" for="c-38291227">[-]</label><label class="expand" for="c-38291227">[2 more]</label></div><br/><div class="children"><div class="content">My guess is that each counter would need to have a discovery point, a regular update mechanism and a documentation, while you can send obscure messages willy-nilly in the log? And also they become an Application Interface with a life cycle while (hopefully) not too many people will go parse the log as an API.</div><br/><div id="38291614" class="c"><input type="checkbox" id="c-38291614" checked=""/><div class="controls bullet"><span class="by">taeric</span><span>|</span><a href="#38290872">root</a><span>|</span><a href="#38291227">parent</a><span>|</span><a href="#38291162">next</a><span>|</span><label class="collapse" for="c-38291614">[-]</label><label class="expand" for="c-38291614">[1 more]</label></div><br/><div class="children"><div class="content">I think that makes sense, though I would still expect counters to be more dense than logs.  I&#x27;m definitely interested in any case studies on this.</div><br/></div></div></div></div></div></div></div></div><div id="38291162" class="c"><input type="checkbox" id="c-38291162" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38290872">parent</a><span>|</span><a href="#38290962">prev</a><span>|</span><a href="#38293382">next</a><span>|</span><label class="collapse" for="c-38291162">[-]</label><label class="expand" for="c-38291162">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s just hard, and there&#x27;s no single answer.<p>In Zephyr, we have a synchronous printk() too, as for low-level debugging and platform bringup that&#x27;s usually <i>desirable</i> (i.e. I&#x27;d like to see the dump from just before the panic please!).<p>For production logging use, though, there is a fancier log system[1] designed around latency boundaries that essentially logs a minimally processed stream to a buffer than then gets flushed from a low priority thread.  And this works, and avoids the kinds of problems detailed in the linked article.  But it&#x27;s fiddly to configure, expensive in an RTOS environment (you need RAM for that thread stack and the buffer), depends on having a I&#x2F;O backend that is itself async&#x2F;low-latency, and has the mentioned misfeature where when things blow up, it&#x27;s usually failed to flush the information you need out of its buffer.<p>[1] Somewhat but not completely orthogonal with printk.  Both can be implemented in terms of each others, mostly.  Sometimes.</div><br/><div id="38293101" class="c"><input type="checkbox" id="c-38293101" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38290872">root</a><span>|</span><a href="#38291162">parent</a><span>|</span><a href="#38293382">next</a><span>|</span><label class="collapse" for="c-38293101">[-]</label><label class="expand" for="c-38293101">[2 more]</label></div><br/><div class="children"><div class="content">What if the lower priority thread is starved and the buffer is full? Do you start dropping messages? Or overwrite the oldest ones and skip messages?</div><br/><div id="38293284" class="c"><input type="checkbox" id="c-38293284" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38290872">root</a><span>|</span><a href="#38293101">parent</a><span>|</span><a href="#38293382">next</a><span>|</span><label class="collapse" for="c-38293284">[-]</label><label class="expand" for="c-38293284">[1 more]</label></div><br/><div class="children"><div class="content">It drops messages.  That&#x27;s almost always the desired behavior: you never want your logging system to be doing work when the system is productively tasked with other things.<p>I know there was some level of argument about whether it&#x27;s best to overwrite older content (ring-buffer-style, probably keeps the most important stuff) or drop messages at input time (faster, probably fewer messages dropped overall).  But logging isn&#x27;t my area of expertise and I forget the details.<p>But again, the general point being that this is a complicated problem with tradeoffs, where most developers up the stack tend to think of it as a fixed facility that shouldn&#x27;t ever fail or require developer bandwidth.  And it&#x27;s not, it&#x27;s hard.</div><br/></div></div></div></div></div></div></div></div><div id="38294038" class="c"><input type="checkbox" id="c-38294038" checked=""/><div class="controls bullet"><span class="by">Tomte</span><span>|</span><a href="#38290872">prev</a><span>|</span><a href="#38291539">next</a><span>|</span><label class="collapse" for="c-38294038">[-]</label><label class="expand" for="c-38294038">[1 more]</label></div><br/><div class="children"><div class="content">OSADL runs a cool QA farm: <a href="https:&#x2F;&#x2F;www.osadl.org&#x2F;OSADL-QA-Farm-Real-time.linux-real-time.0.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.osadl.org&#x2F;OSADL-QA-Farm-Real-time.linux-real-tim...</a></div><br/></div></div><div id="38291539" class="c"><input type="checkbox" id="c-38291539" checked=""/><div class="controls bullet"><span class="by">knorker</span><span>|</span><a href="#38294038">prev</a><span>|</span><a href="#38290880">next</a><span>|</span><label class="collapse" for="c-38291539">[-]</label><label class="expand" for="c-38291539">[1 more]</label></div><br/><div class="children"><div class="content">I just want SCHED_IDLEPRIO to actually do what it says.</div><br/></div></div><div id="38290880" class="c"><input type="checkbox" id="c-38290880" checked=""/><div class="controls bullet"><span class="by">TeeMassive</span><span>|</span><a href="#38291539">prev</a><span>|</span><a href="#38297425">next</a><span>|</span><label class="collapse" for="c-38290880">[-]</label><label class="expand" for="c-38290880">[5 more]</label></div><br/><div class="children"><div class="content">It&#x27;s kind of crazy that a feature necessitated 20 years of active development to be somewhat called complete.<p>I hope it will be ready soon. I&#x27;m working in a project that has strict serial communication requirements and it has caused us a lot of headaches.</div><br/><div id="38291416" class="c"><input type="checkbox" id="c-38291416" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#38290880">parent</a><span>|</span><a href="#38291237">next</a><span>|</span><label class="collapse" for="c-38291416">[-]</label><label class="expand" for="c-38291416">[3 more]</label></div><br/><div class="children"><div class="content">Can you expand on this, as I&#x27;m a little naive in this area, say you isolated the cpus (isolcpus parameter) and then taskset your task onto the isolated cpu, would not the scheduler no longer be involved, and your task be the only thing serviced by that CPU ?<p>Is it other interrupts on the CPU that break your process out of the &quot;real time&quot; requirement, I find this all so interesting.</div><br/><div id="38291558" class="c"><input type="checkbox" id="c-38291558" checked=""/><div class="controls bullet"><span class="by">TeeMassive</span><span>|</span><a href="#38290880">root</a><span>|</span><a href="#38291416">parent</a><span>|</span><a href="#38291237">next</a><span>|</span><label class="collapse" for="c-38291558">[-]</label><label class="expand" for="c-38291558">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s an embedded system with two logical cores with at least 4 other critical processes running. Doing that will only displace the problem.</div><br/><div id="38300476" class="c"><input type="checkbox" id="c-38300476" checked=""/><div class="controls bullet"><span class="by">worthless-trash</span><span>|</span><a href="#38290880">root</a><span>|</span><a href="#38291558">parent</a><span>|</span><a href="#38291237">next</a><span>|</span><label class="collapse" for="c-38300476">[-]</label><label class="expand" for="c-38300476">[1 more]</label></div><br/><div class="children"><div class="content">I (incorrectly) assumed that serial port control was the highly sensitive time problem that was being dealt with here.</div><br/></div></div></div></div></div></div><div id="38291237" class="c"><input type="checkbox" id="c-38291237" checked=""/><div class="controls bullet"><span class="by">eisbaw</span><span>|</span><a href="#38290880">parent</a><span>|</span><a href="#38291416">prev</a><span>|</span><a href="#38297425">next</a><span>|</span><label class="collapse" for="c-38291237">[-]</label><label class="expand" for="c-38291237">[1 more]</label></div><br/><div class="children"><div class="content">Zephyr RTOS.</div><br/></div></div></div></div><div id="38297425" class="c"><input type="checkbox" id="c-38297425" checked=""/><div class="controls bullet"><span class="by">jovial_cavalier</span><span>|</span><a href="#38290880">prev</a><span>|</span><a href="#38291963">next</a><span>|</span><label class="collapse" for="c-38297425">[-]</label><label class="expand" for="c-38297425">[1 more]</label></div><br/><div class="children"><div class="content">does HN have any thoughts on Xenomai[1]? I&#x27;ve been using it for years without issue.<p>On a BeagleBone Black, it typically gives jitter on the order of hundreds of nanoseconds. I would consider it &quot;hard&quot; real-time (as do they). I&#x27;m able to schedule tasks periodically on the scale of tens of microseconds, and they never get missed.<p>It differs from this in that Real-Time Linux attempts to make Linux itself preemptive, whereas Xenomai is essentially its own kernel, running Linux as a task on top. It provides an ABI which allows you to run your own tasks alongside or at higher prio than Linux. This sidesteps the `printk()` issue, for instance, since Xenomai doesn&#x27;t care. It will gladly context switch out of printk in order to run your tasks.<p>The downside is that you can&#x27;t make normal syscalls while inside of the Xenomai context. Well... you can, but obviously this invalidates the realtime model. For example, calling `printf()` or `malloc()` inside of a xenomai task is not preemptable. The Xenomai ABI does its best to replicate everything you may need as far as syscalls, which works great as long as you&#x27;re happy doing your own heap allocations.<p>[1]: <a href="https:&#x2F;&#x2F;xenomai.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;xenomai.org&#x2F;</a></div><br/></div></div><div id="38291963" class="c"><input type="checkbox" id="c-38291963" checked=""/><div class="controls bullet"><span class="by">0xDEF</span><span>|</span><a href="#38297425">prev</a><span>|</span><a href="#38294461">next</a><span>|</span><label class="collapse" for="c-38291963">[-]</label><label class="expand" for="c-38291963">[3 more]</label></div><br/><div class="children"><div class="content">What do embedded real-time Linux people use for bootloader, init system, utilities, and C standard library implementation? Even Android that does not have real-time constraints ended up using Toybox for utilities and rolling their own C standard library (Bionic).</div><br/><div id="38294298" class="c"><input type="checkbox" id="c-38294298" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38291963">parent</a><span>|</span><a href="#38297207">next</a><span>|</span><label class="collapse" for="c-38294298">[-]</label><label class="expand" for="c-38294298">[1 more]</label></div><br/><div class="children"><div class="content">You aren&#x27;t likely to need to change a lot of these: the whole point is basically making it so that all that can run as normal but won&#x27;t really get in the way of your high-priority process. It&#x27;s just that your high-priority process needs to be careful not to block on anything that might take too long due to some other stuff running. In which case you may need to avoid certain C standard library calls, but not replace it entirely.</div><br/></div></div><div id="38297207" class="c"><input type="checkbox" id="c-38297207" checked=""/><div class="controls bullet"><span class="by">jovial_cavalier</span><span>|</span><a href="#38291963">parent</a><span>|</span><a href="#38294298">prev</a><span>|</span><a href="#38294461">next</a><span>|</span><label class="collapse" for="c-38297207">[-]</label><label class="expand" for="c-38297207">[1 more]</label></div><br/><div class="children"><div class="content">I use u-boot for a boot loader. As for init and libc, I just use systemd and glibc.<p>Boot time is not a bottleneck for my application (however long it takes, the client will take longer…), and I’m sure there’s some more optimal libc to use, but I’m not sure the juice is worth the squeeze.<p>I’m also interested in what others are doing.</div><br/></div></div></div></div><div id="38294873" class="c"><input type="checkbox" id="c-38294873" checked=""/><div class="controls bullet"><span class="by">w10-1</span><span>|</span><a href="#38292700">prev</a><span>|</span><label class="collapse" for="c-38294873">[-]</label><label class="expand" for="c-38294873">[1 more]</label></div><br/><div class="children"><div class="content">There is no end game until there are end users beating on the system. That would put the &#x27;real&#x27; in &#x27;real-time&#x27;.<p>But who using a RTOS now would take the systems-integration cost&#x2F;risk of switching?  Would this put Android closer to Metal performance?</div><br/></div></div></div></div></div></div></div></body></html>