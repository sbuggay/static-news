<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1736240477098" as="style"/><link rel="stylesheet" href="styles.css?v=1736240477098"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.scottredig.com/blog/bonkers_comptime/">Zig&#x27;s Comptime Is Bonkers Good</a> <span class="domain">(<a href="https://www.scottredig.com">www.scottredig.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>65 comments</span></div><br/><div><div id="42620112" class="c"><input type="checkbox" id="c-42620112" checked=""/><div class="controls bullet"><span class="by">noelwelsh</span><span>|</span><a href="#42620154">next</a><span>|</span><label class="collapse" for="c-42620112">[-]</label><label class="expand" for="c-42620112">[10 more]</label></div><br/><div class="children"><div class="content">It would be nice to have a more indepth discussion of the issues that have been found with compile-time programming, rather than uncritical acclaim. Staged programming is not new, and people have run into many issues and design tradeoffs in that time. (E.g. the same stuff has been done in Lisps for decades, though most Lisps don&#x27;t have a type system, which makes things a bit more complicated.)<p>Some of the issues that come to mind:<p>* Implementing generics in this way breaks parametricity. Simply put, parametricity means being able to reason about functions just from their type signature. You can&#x27;t do this when the function can do arbitrary computation based on the concrete type a generic type is instantiated with.<p>* It&#x27;s not clear to me how Zig handles recursive generic types. Generally, type systems are lazy to allow recursion. So I can write something like<p>type Example = Something[Example]<p>(Yes, this is useful.)<p>* Type checking and compile-time computation can interact in interesting ways. Does type checking take place before compile-time code runs, after it runs, or can they be interleaved? Different choices give different trade-offs. It&#x27;s not clear to me what Zig does and hence what tradeoffs it makes.<p>* The article suggests that compile-time code can generate code (not just values) but doesn&#x27;t discuss hygiene.<p>There is a good discussion of some issues here: <a href="https:&#x2F;&#x2F;typesanitizer.com&#x2F;blog&#x2F;zig-generics.html" rel="nofollow">https:&#x2F;&#x2F;typesanitizer.com&#x2F;blog&#x2F;zig-generics.html</a></div><br/><div id="42620297" class="c"><input type="checkbox" id="c-42620297" checked=""/><div class="controls bullet"><span class="by">marhee</span><span>|</span><a href="#42620112">parent</a><span>|</span><a href="#42620470">next</a><span>|</span><label class="collapse" for="c-42620297">[-]</label><label class="expand" for="c-42620297">[3 more]</label></div><br/><div class="children"><div class="content">Interesting points.<p>&gt; Implementing generics in this way breaks parametricity. Simply put, parametricity means being 
able to reason about functions just from their type signature. You can&#x27;t do this when the function can do arbitrary computation based on the concrete type a generic type is instantiated with.<p>Do you mean reasoning about a function in the sense of just understanding what a functions does (or can do), i.e. in the view of the practical programmer, or reasoning about the function in a typed theoretical system (e.g. typed lambda calculus or maybe even more exotic)? Or maybe a bit of both? There is certainly a concern from the theoretical viewpoint but how important is that for a practical programming language?<p>For example, I believe C++ template programming also breaks &quot;parametricity&quot; by supporting template specialisation. While there are many mundane issues with C++ templates, breaking parametricity is not a very big deal in practice. In contrast, it enables optimisations that are not otherwise possible (for templates). Consider for example std::vector&lt;bool&gt;: implementations can be made that actually store a single bit per vector element (instead of how a bool normally is represented using an int or char). Maybe this is even required by the standard, I don&#x27;t recall. My point is that in makes sense for C++ to allow this, I think.</div><br/><div id="42620409" class="c"><input type="checkbox" id="c-42620409" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42620112">root</a><span>|</span><a href="#42620297">parent</a><span>|</span><a href="#42620466">next</a><span>|</span><label class="collapse" for="c-42620409">[-]</label><label class="expand" for="c-42620409">[1 more]</label></div><br/><div class="children"><div class="content">&gt; For example, I believe C++ template programming also breaks &quot;parametricity&quot; by supporting template specialisation.<p>C++ breaks parametricity even with normal templates, since you can e.g. call a method that exists&#x2F;is valid only on some instantiations of the template.<p>The issue is that the compiler can&#x27;t help you check whether your template type checks or not, you will only figure out when you instantiate it with a concrete type. Things get worse when you call a templated function from within another templated function, since the error can then be arbitrarily levels deep.<p>&gt; My point is that in makes sense for C++ to allow this, I think.<p>Whether it makes sense or not it&#x27;s a big pain point and some are trying to move away from it (see e.g. Carbon&#x27;s approach to generics)</div><br/></div></div><div id="42620466" class="c"><input type="checkbox" id="c-42620466" checked=""/><div class="controls bullet"><span class="by">Quekid5</span><span>|</span><a href="#42620112">root</a><span>|</span><a href="#42620297">parent</a><span>|</span><a href="#42620409">prev</a><span>|</span><a href="#42620470">next</a><span>|</span><label class="collapse" for="c-42620466">[-]</label><label class="expand" for="c-42620466">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Consider for example std::vector&lt;bool&gt;: implementations can be made that actually store a single bit per vector element (instead of how a bool normally is represented using an int or char).<p>Your example is considered a misfeature and demonstrates why breaking parametricity is a problem: the specialized vector&lt;bool&gt; is not a standard STL container even though vector&lt;anythingelse&gt; is. That&#x27;s at best confusing -- and can leads to very confusing problems in generic code. (In this specific case, C++11&#x27;s &quot;auto&quot; and AAA lessens some of the issues, but even then it can cause hard-to-diagnose performance problems even when the code compiles)<p>See <a href="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;17797560" rel="nofollow">https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;17797560</a> for more details.</div><br/></div></div></div></div><div id="42620470" class="c"><input type="checkbox" id="c-42620470" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#42620112">parent</a><span>|</span><a href="#42620297">prev</a><span>|</span><a href="#42620503">next</a><span>|</span><label class="collapse" for="c-42620470">[-]</label><label class="expand" for="c-42620470">[2 more]</label></div><br/><div class="children"><div class="content">&gt; type Example = Something[Example]<p>You can&#x27;t use the binding early like this, but inside of the type definition you can use the @This() builtin to get a value that&#x27;s the type you&#x27;re in, and you can presumably do whatever you like with it.<p>The type system barely does anything, so it&#x27;s not very interesting when type checking runs. comptime code is type checked and executed. Normal code is typechecked and not executed.<p>comptime is not a macro system. It doesn&#x27;t have the ability to be unhygienic. It can cleverly monomorphize code, or it can unroll code, or it can omit code, but I don&#x27;t think it can generate code.</div><br/><div id="42620616" class="c"><input type="checkbox" id="c-42620616" checked=""/><div class="controls bullet"><span class="by">shakna</span><span>|</span><a href="#42620112">root</a><span>|</span><a href="#42620470">parent</a><span>|</span><a href="#42620503">next</a><span>|</span><label class="collapse" for="c-42620616">[-]</label><label class="expand" for="c-42620616">[1 more]</label></div><br/><div class="children"><div class="content">Until version 0.12.0 (April 2024), you could make arbitrary syscalls, allowing you to generate code at comptime, and promote vars between comptime and runtime. [0] Before then, you could do some rather funky things with pointers and memory, and was very much not hygienic.<p>[0] <a href="https:&#x2F;&#x2F;ziglang.org&#x2F;download&#x2F;0.12.0&#x2F;release-notes.html#Comptime-Memory-Changes" rel="nofollow">https:&#x2F;&#x2F;ziglang.org&#x2F;download&#x2F;0.12.0&#x2F;release-notes.html#Compt...</a></div><br/></div></div></div></div><div id="42620503" class="c"><input type="checkbox" id="c-42620503" checked=""/><div class="controls bullet"><span class="by">ScottRedig</span><span>|</span><a href="#42620112">parent</a><span>|</span><a href="#42620470">prev</a><span>|</span><a href="#42620290">next</a><span>|</span><label class="collapse" for="c-42620503">[-]</label><label class="expand" for="c-42620503">[1 more]</label></div><br/><div class="children"><div class="content">Hi, article author here.  I was motivated to write this post after having trouble articulating some of its points while at a meetup, so that&#x27;s why the goal of this post was focused on explaining things, and not being critical.<p>So at least address your points here:<p>* I do agree this is a direct trade-off with Zig style comptime, versus more statically defined function signatures.  I don&#x27;t think this affects all code, only code which does such reasoning with types, so it&#x27;s a trade-off between reasoning and expressivity that you can make depending on your needs.  On the other hand, per the post&#x27;s view 0, I have found that just going in and reading the source code easily answers the questions I have when the type signature doesn&#x27;t.  I don&#x27;t think I&#x27;ve ever been confused about how to use something for more than the time it takes to read a few dozen lines of code.<p>* Your specific example for recursive generic types poses a problem because a name being used in the declaration causes a &quot;dependency loop detected&quot; error.  There are ways around this.  The generics example in the post for example references itself.  If you had a concrete example showing a case where this does something, I could perhaps show you the zig code that does it.<p>* Type checking happens during comptime.  Eg, this code:<p><pre><code>  pub fn main() void {
      @compileLog(&quot;Hi&quot;);
      const a: u32 = &quot;42&quot;;
      _ = a;
      @compileLog(&quot;Bye&quot;);
  }
</code></pre>
Gives this error:<p><pre><code>  when_typecheck.zig:3:17: error: expected type &#x27;u32&#x27;, found &#x27;*const [2:0]u8&#x27;
   const a: u32 = &quot;42&quot;;
                  ^~~~
  Compile Log Output:
  @as(*const [2:0]u8, &quot;Hi&quot;)
</code></pre>
So the first @compileLog statement was run by comptime, but then the type check error stopped it from continuing to the second @compileLog statement.  If you dig into the Zig issues, there are some subtle ways the type checking between comptime and runtime can cause problems.  However it takes some pretty esoteric code to hit them, and they&#x27;re easily resolved.  Also, they&#x27;re well known by the core team and I expect them to be addressed before 1.0.<p>* I&#x27;m not sure what you mean by hygiene, can you elaborate?</div><br/></div></div><div id="42620290" class="c"><input type="checkbox" id="c-42620290" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42620112">parent</a><span>|</span><a href="#42620503">prev</a><span>|</span><a href="#42620379">next</a><span>|</span><label class="collapse" for="c-42620290">[-]</label><label class="expand" for="c-42620290">[2 more]</label></div><br/><div class="children"><div class="content">I think most of those points one only stumbles over after a few thousand lines of Zig and going really deep into the comptime features.<p>And some features in your list are of questionable value IMHO (e.g. the &quot;reasoning over a function type signature&quot; - Rust could be a much more ergonomic language if the compiler wouldn&#x27;t have to rely on function signatures alone but instead could peek into called function bodies).<p>There are definitely some tradeoffs in Zig&#x27;s comptime system, but I think the more important point is that nothing about it is surprising when working with it, it&#x27;s only when coming from languages like Rust or C++ where Zig&#x27;s comptime, generics and reflection might look &#x27;weird&#x27;.</div><br/><div id="42620460" class="c"><input type="checkbox" id="c-42620460" checked=""/><div class="controls bullet"><span class="by">eptcyka</span><span>|</span><a href="#42620112">root</a><span>|</span><a href="#42620290">parent</a><span>|</span><a href="#42620379">next</a><span>|</span><label class="collapse" for="c-42620460">[-]</label><label class="expand" for="c-42620460">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rust could be a much more ergonomic language if the compiler wouldn&#x27;t have to rely on function signatures alone but instead could peek into called function bodies<p>This path leads to unbounded runtime for the type checker&#x2F;borrow checker. We’re not happy about build times as is.</div><br/></div></div></div></div></div></div><div id="42620154" class="c"><input type="checkbox" id="c-42620154" checked=""/><div class="controls bullet"><span class="by">koe123</span><span>|</span><a href="#42620112">prev</a><span>|</span><a href="#42620476">next</a><span>|</span><label class="collapse" for="c-42620154">[-]</label><label class="expand" for="c-42620154">[5 more]</label></div><br/><div class="children"><div class="content">Another interesting pattern is the ability to generate structs at compile time.<p>Ive ran experiments where a neural net is implemented by creating a json file from pytorch, reading it in using @embedFile, and generating the subsequent a struct with a specific “run” method.<p>This in theory allows the compiler to optimize the neural network directly (I havent proven a great benefit from this though). Also the whole network lived on the stack, which is means not having any dynamic allocation (not sure if this is good?).</div><br/><div id="42620492" class="c"><input type="checkbox" id="c-42620492" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#42620154">parent</a><span>|</span><a href="#42620172">next</a><span>|</span><label class="collapse" for="c-42620492">[-]</label><label class="expand" for="c-42620492">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done this sort of thing by writing a code generator in python instead of using comptime. I&#x27;m not confident that comptime zig is particularly fast, and I don&#x27;t want to run the json parser that generates the struct all the time.</div><br/></div></div><div id="42620172" class="c"><input type="checkbox" id="c-42620172" checked=""/><div class="controls bullet"><span class="by">0x1ceb00da</span><span>|</span><a href="#42620154">parent</a><span>|</span><a href="#42620492">prev</a><span>|</span><a href="#42620476">next</a><span>|</span><label class="collapse" for="c-42620172">[-]</label><label class="expand" for="c-42620172">[3 more]</label></div><br/><div class="children"><div class="content">How does this affect the compile times?</div><br/><div id="42620194" class="c"><input type="checkbox" id="c-42620194" checked=""/><div class="controls bullet"><span class="by">koe123</span><span>|</span><a href="#42620154">root</a><span>|</span><a href="#42620172">parent</a><span>|</span><a href="#42620184">next</a><span>|</span><label class="collapse" for="c-42620194">[-]</label><label class="expand" for="c-42620194">[1 more]</label></div><br/><div class="children"><div class="content">They become quite long, but it was surprisingly tolerable. I recall it vaguely but a 100MB neural network was on the order of minutes with all optimizations turned on. I guess it would be fair to say it scaled more or less linearly with the file size (from what I saw). Moreover I work in essentially a tinyml field so my neural networks are on the order of 1 to 2 MB for the most part. For me it wouldve been reasonable!<p>I guess in theory you could compile once into a static library and just link that into a main program. Also there will be incremental compilation in zig I believe, maybe that helps? Not sure on the details there.</div><br/></div></div><div id="42620184" class="c"><input type="checkbox" id="c-42620184" checked=""/><div class="controls bullet"><span class="by">erichocean</span><span>|</span><a href="#42620154">root</a><span>|</span><a href="#42620172">parent</a><span>|</span><a href="#42620194">prev</a><span>|</span><a href="#42620476">next</a><span>|</span><label class="collapse" for="c-42620184">[-]</label><label class="expand" for="c-42620184">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s nothing like C++ templates.</div><br/></div></div></div></div></div></div><div id="42620476" class="c"><input type="checkbox" id="c-42620476" checked=""/><div class="controls bullet"><span class="by">elcritch</span><span>|</span><a href="#42620154">prev</a><span>|</span><a href="#42620092">next</a><span>|</span><label class="collapse" for="c-42620476">[-]</label><label class="expand" for="c-42620476">[1 more]</label></div><br/><div class="children"><div class="content">Ah ‘fieldNames’, looks very similar to Nim’s ‘fieldPairs’. It’s an incredibly handy construct! It makes doing efficient serialization a breeze. I recently implemented a compile time check for thread safety checks on types using ‘fieldPairs’ in about 20 lines.<p>This needs to become a standard feature of programming languages IMHO.<p>It’s actually one of the biggest things I find lacking in Rust which is limited to non-typed macros (last I tried). It’s so limiting not to have it. You just have to hope serde is implemented on the structs in a crate. You can’t even make your own structs with the same fields in Rust programmatically.</div><br/></div></div><div id="42620092" class="c"><input type="checkbox" id="c-42620092" checked=""/><div class="controls bullet"><span class="by">Tiberium</span><span>|</span><a href="#42620476">prev</a><span>|</span><a href="#42619925">next</a><span>|</span><label class="collapse" for="c-42620092">[-]</label><label class="expand" for="c-42620092">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re surprised by Zig&#x27;s comptime, you should definitely take a look at Nim which also has compile-time code evaluation, plus a full AST macro system.</div><br/></div></div><div id="42619925" class="c"><input type="checkbox" id="c-42619925" checked=""/><div class="controls bullet"><span class="by">SMP-UX</span><span>|</span><a href="#42620092">prev</a><span>|</span><a href="#42620266">next</a><span>|</span><label class="collapse" for="c-42619925">[-]</label><label class="expand" for="c-42619925">[1 more]</label></div><br/><div class="children"><div class="content">Zig is overall pretty good as a language and it does what it needs to: staying in the lane of the purpose is very important. It is why I do not particularly care for some languages being used just because.</div><br/></div></div><div id="42620266" class="c"><input type="checkbox" id="c-42620266" checked=""/><div class="controls bullet"><span class="by">pakkarde</span><span>|</span><a href="#42619925">prev</a><span>|</span><a href="#42620104">next</a><span>|</span><label class="collapse" for="c-42620266">[-]</label><label class="expand" for="c-42620266">[3 more]</label></div><br/><div class="children"><div class="content">After having written a somewhat complete C parser library I don&#x27;t really get the big deal about needing meta programming in the language itself.
If I want to generate structs, serialization, properties, instrumentation, etc, I just write a regular C program that processes some source files and output source files and run that first in by build script.<p>How do you people debug and test these meta programs?
Mine are just regular C programs that uses the exact same debuggers and tools as anything else.</div><br/><div id="42620402" class="c"><input type="checkbox" id="c-42620402" checked=""/><div class="controls bullet"><span class="by">modernerd</span><span>|</span><a href="#42620266">parent</a><span>|</span><a href="#42620302">next</a><span>|</span><label class="collapse" for="c-42620402">[-]</label><label class="expand" for="c-42620402">[1 more]</label></div><br/><div class="children"><div class="content">Yes, this is the same approach Ryan Fleury and others advocate, and it&#x27;s perfectly good:<p>&gt; Arbitrary compile-time execution in C:<p>&gt; cl &#x2F;nologo &#x2F;Zi metaprogram.c &amp;&amp; metaprogram.exe<p>&gt; cl &#x2F;nologo &#x2F;Zi program.c<p>&gt; Compile-time code runs at native speed, can be debugged, and is completely procedural &amp; arbitrary<p>&gt; You do not need your compiler to execute code for you<p><a href="https:&#x2F;&#x2F;x.com&#x2F;ryanjfleury&#x2F;status&#x2F;1875824288487571873" rel="nofollow">https:&#x2F;&#x2F;x.com&#x2F;ryanjfleury&#x2F;status&#x2F;1875824288487571873</a></div><br/></div></div><div id="42620302" class="c"><input type="checkbox" id="c-42620302" checked=""/><div class="controls bullet"><span class="by">nox101</span><span>|</span><a href="#42620266">parent</a><span>|</span><a href="#42620402">prev</a><span>|</span><a href="#42620104">next</a><span>|</span><label class="collapse" for="c-42620302">[-]</label><label class="expand" for="c-42620302">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about zig bit the power of lisp is that youre manipulating the s-expressions or to put it another way, you&#x27;re manipulating the ast. To do that in C you&#x27;d need to write a full C parser for your C program that processes source files.</div><br/></div></div></div></div><div id="42620104" class="c"><input type="checkbox" id="c-42620104" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42620266">prev</a><span>|</span><a href="#42619981">next</a><span>|</span><label class="collapse" for="c-42620104">[-]</label><label class="expand" for="c-42620104">[1 more]</label></div><br/><div class="children"><div class="content">While interesting, this is one of the cases, where I agree with &quot;D did it first&quot; kind of comments.</div><br/></div></div><div id="42619981" class="c"><input type="checkbox" id="c-42619981" checked=""/><div class="controls bullet"><span class="by">bryango</span><span>|</span><a href="#42620104">prev</a><span>|</span><a href="#42619526">next</a><span>|</span><label class="collapse" for="c-42619981">[-]</label><label class="expand" for="c-42619981">[1 more]</label></div><br/><div class="children"><div class="content">I hope we can have something that combines the meta-programming capabilities of Zig with the vast ecosystem, community and safety of Rust.<p>Looking at the language design, I really prefer Zig to Rust, but as an incompetent, amateur programmer, I couldn&#x27;t write anything in Zig that&#x27;s actually useful (or reliable), at least for now.</div><br/></div></div><div id="42619526" class="c"><input type="checkbox" id="c-42619526" checked=""/><div class="controls bullet"><span class="by">HeliumHydride</span><span>|</span><a href="#42619981">prev</a><span>|</span><a href="#42620140">next</a><span>|</span><label class="collapse" for="c-42619526">[-]</label><label class="expand" for="c-42619526">[29 more]</label></div><br/><div class="children"><div class="content">With reflection and code generation coming to C++26, and the already existing constexpr&#x2F;consteval machinery, C++ will be able to do all of this.</div><br/><div id="42619633" class="c"><input type="checkbox" id="c-42619633" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42620243">next</a><span>|</span><label class="collapse" for="c-42619633">[-]</label><label class="expand" for="c-42619633">[12 more]</label></div><br/><div class="children"><div class="content">Bash scripts and (optionally) an assembler can do this. That&#x27;s not really the point.</div><br/><div id="42619759" class="c"><input type="checkbox" id="c-42619759" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619633">parent</a><span>|</span><a href="#42619646">next</a><span>|</span><label class="collapse" for="c-42619759">[-]</label><label class="expand" for="c-42619759">[6 more]</label></div><br/><div class="children"><div class="content">That&#x27;s something different, code generation. The point is that C++26 will have compile-time reflection without any need for an external code generation tool, similar to Zig.</div><br/><div id="42620449" class="c"><input type="checkbox" id="c-42620449" checked=""/><div class="controls bullet"><span class="by">int_19h</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619759">parent</a><span>|</span><a href="#42619994">next</a><span>|</span><label class="collapse" for="c-42620449">[-]</label><label class="expand" for="c-42620449">[1 more]</label></div><br/><div class="children"><div class="content">Ergonomics matters, though. In C++, this feature is bolted onto the language decades after it was originally designed. Zig is designed around this from the get go (which is why it doesn&#x27;t have e.g. templates as a distinct feature).</div><br/></div></div><div id="42619994" class="c"><input type="checkbox" id="c-42619994" checked=""/><div class="controls bullet"><span class="by">kstrauser</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619759">parent</a><span>|</span><a href="#42620449">prev</a><span>|</span><a href="#42620267">next</a><span>|</span><label class="collapse" for="c-42619994">[-]</label><label class="expand" for="c-42619994">[3 more]</label></div><br/><div class="children"><div class="content">With the main difference being that if you start Zig today, you’ll get to use that a good decade before it’s reliably available in C++.<p>Hmm. Actually, now that makes me want to learn Zig.</div><br/><div id="42620067" class="c"><input type="checkbox" id="c-42620067" checked=""/><div class="controls bullet"><span class="by">kevin_thibedeau</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619994">parent</a><span>|</span><a href="#42620267">next</a><span>|</span><label class="collapse" for="c-42620067">[-]</label><label class="expand" for="c-42620067">[2 more]</label></div><br/><div class="children"><div class="content">Consteval is usable today for a lot of scenarios that would require code generation tooling in years past.</div><br/><div id="42620144" class="c"><input type="checkbox" id="c-42620144" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620067">parent</a><span>|</span><a href="#42620267">next</a><span>|</span><label class="collapse" for="c-42620144">[-]</label><label class="expand" for="c-42620144">[1 more]</label></div><br/><div class="children"><div class="content">How does consteval interact with thread_local? Defined (although I&#x27;m not sure what definition could make sense), error, or the dreaded &quot;No diagnostic required&quot;?</div><br/></div></div></div></div></div></div><div id="42620267" class="c"><input type="checkbox" id="c-42620267" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619759">parent</a><span>|</span><a href="#42619994">prev</a><span>|</span><a href="#42619646">next</a><span>|</span><label class="collapse" for="c-42620267">[-]</label><label class="expand" for="c-42620267">[1 more]</label></div><br/><div class="children"><div class="content">In the end, generics, comptime and code generation are just different steps on the &#x27;stamping out specialized code and data&#x27; ladder though (e.g. all three are useful).</div><br/></div></div></div></div><div id="42619646" class="c"><input type="checkbox" id="c-42619646" checked=""/><div class="controls bullet"><span class="by">pipeline_peak</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619633">parent</a><span>|</span><a href="#42619759">prev</a><span>|</span><a href="#42620243">next</a><span>|</span><label class="collapse" for="c-42619646">[-]</label><label class="expand" for="c-42619646">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Bash scripts and (optionally) an assembler<p>What do you mean by that ?</div><br/><div id="42619672" class="c"><input type="checkbox" id="c-42619672" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619646">parent</a><span>|</span><a href="#42619673">next</a><span>|</span><label class="collapse" for="c-42619672">[-]</label><label class="expand" for="c-42619672">[2 more]</label></div><br/><div class="children"><div class="content">In much the same way as &quot;being Turing complete means you can do anything&quot;, it just being possible to do compile-time execution isn&#x27;t the reason Zig is exciting here.<p>C++ adding the same features means it&#x27;ll be possible, but it has a much larger intersection of alternative features to introduce edge cases with, and _many_ implementations that will have this feature with varying quirks: all of this means C++ will have to do a _much_ better job than Zig does here to achieve nearly the same result.</div><br/><div id="42619792" class="c"><input type="checkbox" id="c-42619792" checked=""/><div class="controls bullet"><span class="by">rowbin</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619672">parent</a><span>|</span><a href="#42619673">next</a><span>|</span><label class="collapse" for="c-42619792">[-]</label><label class="expand" for="c-42619792">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for that. I loathe replys like &quot;but lang&#x2F;framework&#x2F;... can do&#x2F;will be able to do something similar&#x2F;does something else which I like better&#x2F;...&quot;. Well, it&#x27;s not about that. It&#x27;s about how easy it is to use, how good it is from preventing you to shoot yourself in the foot, sometimes how performant it is, ...</div><br/></div></div></div></div><div id="42619673" class="c"><input type="checkbox" id="c-42619673" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619646">parent</a><span>|</span><a href="#42619672">prev</a><span>|</span><a href="#42620243">next</a><span>|</span><label class="collapse" for="c-42619673">[-]</label><label class="expand" for="c-42619673">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s suggesting that Zig is convenient and that C&#x2F;C++ won&#x27;t be.<p>I think both will be nice.</div><br/><div id="42619971" class="c"><input type="checkbox" id="c-42619971" checked=""/><div class="controls bullet"><span class="by">carlos22</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619673">parent</a><span>|</span><a href="#42620243">next</a><span>|</span><label class="collapse" for="c-42619971">[-]</label><label class="expand" for="c-42619971">[1 more]</label></div><br/><div class="children"><div class="content">Well C++ has a history of not really being convenient and makes it easy to shoot you in the foot.</div><br/></div></div></div></div></div></div></div></div><div id="42620243" class="c"><input type="checkbox" id="c-42620243" checked=""/><div class="controls bullet"><span class="by">katzenversteher</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42619633">prev</a><span>|</span><a href="#42620259">next</a><span>|</span><label class="collapse" for="c-42620243">[-]</label><label class="expand" for="c-42620243">[2 more]</label></div><br/><div class="children"><div class="content">Reminds me of &quot;Der Untergang&quot;. Mit dem Angriff C++26 wird das alles in Ordnung kommen!</div><br/><div id="42620261" class="c"><input type="checkbox" id="c-42620261" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620243">parent</a><span>|</span><a href="#42620259">next</a><span>|</span><label class="collapse" for="c-42620261">[-]</label><label class="expand" for="c-42620261">[1 more]</label></div><br/><div class="children"><div class="content">Interesting, I had the <i>exact</i> same image in my mind :D</div><br/></div></div></div></div><div id="42620259" class="c"><input type="checkbox" id="c-42620259" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42620243">prev</a><span>|</span><a href="#42620099">next</a><span>|</span><label class="collapse" for="c-42620259">[-]</label><label class="expand" for="c-42620259">[1 more]</label></div><br/><div class="children"><div class="content">C++ could do generic programming long before Zig even was an idea, but writing generic code in Zig is still much more straightforward - also Zig is usable now, while C++26 features will probably land in real world C++ compilers around 2036 ;)</div><br/></div></div><div id="42620099" class="c"><input type="checkbox" id="c-42620099" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42620259">prev</a><span>|</span><a href="#42619724">next</a><span>|</span><label class="collapse" for="c-42620099">[-]</label><label class="expand" for="c-42620099">[7 more]</label></div><br/><div class="children"><div class="content">With a much better ecosystem, 40 years of IDE tooling, frameworks, OS support.<p>Which is what people always forget when comparing language grammars.</div><br/><div id="42620165" class="c"><input type="checkbox" id="c-42620165" checked=""/><div class="controls bullet"><span class="by">9dev</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620099">parent</a><span>|</span><a href="#42620358">next</a><span>|</span><label class="collapse" for="c-42620165">[-]</label><label class="expand" for="c-42620165">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure if you actually want to call &quot;copy these header files into your local file system&quot; an ecosystem at all. The last 40 years have brought <i>heaps</i> of improvements in software development ergonomics. Zig is growing just fine, as other languages like Rust or Go.</div><br/><div id="42620320" class="c"><input type="checkbox" id="c-42620320" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620165">parent</a><span>|</span><a href="#42620358">next</a><span>|</span><label class="collapse" for="c-42620320">[-]</label><label class="expand" for="c-42620320">[3 more]</label></div><br/><div class="children"><div class="content">That is what script kiddies do when using compiled languages.<p>Rust has had an almost usable implementation for affine types, and being the second coming of Ada, to win the hearths of the industry, including all major OS vendors and hyperscallers.<p>Go got lucky with Docker and Kubernetes rewrites, and their adoption across the industry.<p>So far Zig is basically Modula-2 with C like syntax, and compile time execution, relies on the same tooling that C and C++ have had for decades for use-after-free, doesn&#x27;t support a binary libraries ecosystem by design, and really Bun isn&#x27;t going to be the killer project that triggers a Rewrite in Zig movement.<p>It remains to be seen if Zig 1.0 happens, and how its adoption story at scale will be like.</div><br/><div id="42620418" class="c"><input type="checkbox" id="c-42620418" checked=""/><div class="controls bullet"><span class="by">vkazanov</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620320">parent</a><span>|</span><a href="#42620358">next</a><span>|</span><label class="collapse" for="c-42620418">[-]</label><label class="expand" for="c-42620418">[2 more]</label></div><br/><div class="children"><div class="content">I agree that zig is taking too long to be finalised. And rust has made certain questionable life choices.<p>But people really, REALLY want  to get off c and c++ for all the numerous reasons everybody knows.</div><br/><div id="42620483" class="c"><input type="checkbox" id="c-42620483" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620418">parent</a><span>|</span><a href="#42620358">next</a><span>|</span><label class="collapse" for="c-42620483">[-]</label><label class="expand" for="c-42620483">[1 more]</label></div><br/><div class="children"><div class="content">They might want, yet while Khronos keeps publishing standards using C and C++, GCC&#x2F;LLVM&#x2F;CUDA&#x2F;.NET&#x2F;Java&#x2F;V8&#x2F;Metal make use of C++, Nintendo&#x2F;PlayStation&#x2F;XBox rely on C++, ... they are going to stay around no matter what.</div><br/></div></div></div></div></div></div></div></div><div id="42620358" class="c"><input type="checkbox" id="c-42620358" checked=""/><div class="controls bullet"><span class="by">flohofwoe</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620099">parent</a><span>|</span><a href="#42620165">prev</a><span>|</span><a href="#42619724">next</a><span>|</span><label class="collapse" for="c-42620358">[-]</label><label class="expand" for="c-42620358">[2 more]</label></div><br/><div class="children"><div class="content">There has been an awful amount of stagnation in those 40 years though. The Visual Studio debugger is still the best overall debugger but has hardly advanced since the late 90s. While the Debug Adapter Protocol and Language Server Protocol invented by the VSCode team are not perfect, they both make debugger and &#x27;Intellisense&#x27; support in IDEs for new languages quite trivial and easily get into the 80% &#x27;good enough&#x27; area of what a &#x27;proper&#x27; IDE offers.</div><br/><div id="42620469" class="c"><input type="checkbox" id="c-42620469" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42620358">parent</a><span>|</span><a href="#42619724">next</a><span>|</span><label class="collapse" for="c-42620469">[-]</label><label class="expand" for="c-42620469">[1 more]</label></div><br/><div class="children"><div class="content">It has advanced quite a lot, but people don&#x27;t care to learn about debuggers are they care about low level details of their programming languages.<p>Also it is quite telling that outside IDE friendly languages, debbugers are kind of stuck in the 80&#x27;s, so no wonder that many think 80% of Visual Studio and friends is good enough.</div><br/></div></div></div></div></div></div><div id="42619724" class="c"><input type="checkbox" id="c-42619724" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42620099">prev</a><span>|</span><a href="#42619947">next</a><span>|</span><label class="collapse" for="c-42619724">[-]</label><label class="expand" for="c-42619724">[1 more]</label></div><br/><div class="children"><div class="content">comptime simplifies and unifies much of that machinery into a clean, conceptual framework.</div><br/></div></div><div id="42619947" class="c"><input type="checkbox" id="c-42619947" checked=""/><div class="controls bullet"><span class="by">brabel</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42619724">prev</a><span>|</span><a href="#42619757">next</a><span>|</span><label class="collapse" for="c-42619947">[-]</label><label class="expand" for="c-42619947">[1 more]</label></div><br/><div class="children"><div class="content">The examples in thist post seem very similar to how you do metaprogramming in the D language. That has existed for years yet you rarely hear about that.</div><br/></div></div><div id="42619757" class="c"><input type="checkbox" id="c-42619757" checked=""/><div class="controls bullet"><span class="by">rochak</span><span>|</span><a href="#42619526">parent</a><span>|</span><a href="#42619947">prev</a><span>|</span><a href="#42620140">next</a><span>|</span><label class="collapse" for="c-42619757">[-]</label><label class="expand" for="c-42619757">[4 more]</label></div><br/><div class="children"><div class="content">Good. Keep on adding stuff to an already bloated language.</div><br/><div id="42620059" class="c"><input type="checkbox" id="c-42620059" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619757">parent</a><span>|</span><a href="#42619858">next</a><span>|</span><label class="collapse" for="c-42620059">[-]</label><label class="expand" for="c-42620059">[1 more]</label></div><br/><div class="children"><div class="content">All programming languages either die, or become bloated, as any software product.<p>I bet a Fortran 77 developer will think the same of Fortran 2023, a COBOL 60 developer of COBOL 2023, a K&amp;R C developer from C23, a 1975 Scheme developer from R7RS, a Python 1.0 developer from Python 3.13,... even Go 1.0 developers from 1.24 with generics, generators,...</div><br/></div></div><div id="42619858" class="c"><input type="checkbox" id="c-42619858" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619757">parent</a><span>|</span><a href="#42620059">prev</a><span>|</span><a href="#42620140">next</a><span>|</span><label class="collapse" for="c-42619858">[-]</label><label class="expand" for="c-42619858">[2 more]</label></div><br/><div class="children"><div class="content">Compile-time reflection will remove countless of lines of bloat from real C++ code bases due to eliminating the need to manually write formatting, hashing and serialisation implementations for classes.</div><br/><div id="42619920" class="c"><input type="checkbox" id="c-42619920" checked=""/><div class="controls bullet"><span class="by">riwsky</span><span>|</span><a href="#42619526">root</a><span>|</span><a href="#42619858">parent</a><span>|</span><a href="#42620140">next</a><span>|</span><label class="collapse" for="c-42619920">[-]</label><label class="expand" for="c-42619920">[1 more]</label></div><br/><div class="children"><div class="content">…10 years from now</div><br/></div></div></div></div></div></div></div></div><div id="42620140" class="c"><input type="checkbox" id="c-42620140" checked=""/><div class="controls bullet"><span class="by">bilekas</span><span>|</span><a href="#42619526">prev</a><span>|</span><a href="#42619926">next</a><span>|</span><label class="collapse" for="c-42620140">[-]</label><label class="expand" for="c-42620140">[1 more]</label></div><br/><div class="children"><div class="content">I see a lot of people in the comments basically saying &quot;well X did it first&quot; and that it&#x27;s not worth talking about. This missed the point for me, zig is an interesting one personally and not out of semantics of std lib or anything really, it&#x27;s just something nice to play around with so far. I think with the above attitude we probably could have stopped systems programming at c++, that wouldn&#x27;t be too fun at all, what we all do without java to laugh at?</div><br/></div></div><div id="42619926" class="c"><input type="checkbox" id="c-42619926" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#42620140">prev</a><span>|</span><a href="#42619770">next</a><span>|</span><label class="collapse" for="c-42619926">[-]</label><label class="expand" for="c-42619926">[10 more]</label></div><br/><div class="children"><div class="content">Comptime to replace macros is indeed good, comptime to replace generics on the other hand isn&#x27;t and that really makes me think of the “when all you have is a hammer” quote.</div><br/><div id="42619986" class="c"><input type="checkbox" id="c-42619986" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42619926">parent</a><span>|</span><a href="#42619942">next</a><span>|</span><label class="collapse" for="c-42619986">[-]</label><label class="expand" for="c-42619986">[8 more]</label></div><br/><div class="children"><div class="content">The problem is that the alternatives to comptime for generics generally seems to have a hideous effect on compile times (see: C++ and Rust).<p>Is there a language that does generics in such a way that doesn&#x27;t send compile times to the moon?</div><br/><div id="42620018" class="c"><input type="checkbox" id="c-42620018" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42619986">parent</a><span>|</span><a href="#42620522">next</a><span>|</span><label class="collapse" for="c-42620018">[-]</label><label class="expand" for="c-42620018">[5 more]</label></div><br/><div class="children"><div class="content">Shouldn&#x27;t comptime have the same compile time implications as templates? In both cases you&#x27;re essentially recompiling the code for every distinct set of comptime args&#x2F;template parameters.</div><br/><div id="42620142" class="c"><input type="checkbox" id="c-42620142" checked=""/><div class="controls bullet"><span class="by">hansvm</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42620018">parent</a><span>|</span><a href="#42620083">next</a><span>|</span><label class="collapse" for="c-42620142">[-]</label><label class="expand" for="c-42620142">[1 more]</label></div><br/><div class="children"><div class="content">Zig is lazy, and C++ is eager. I can define an infinite set of mutually recursive types in Zig, and only the ones I actually use will be instantiated (not an everyday need, but occasionally interesting -- I had fun building an autodiff package that way with no virtual function overhead, and the set of type descriptors being closed under VJP meant that you could support arbitrary (still only finite) derivative-like tensors, not just first and second order).</div><br/></div></div><div id="42620083" class="c"><input type="checkbox" id="c-42620083" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42620018">parent</a><span>|</span><a href="#42620142">prev</a><span>|</span><a href="#42620522">next</a><span>|</span><label class="collapse" for="c-42620083">[-]</label><label class="expand" for="c-42620083">[3 more]</label></div><br/><div class="children"><div class="content">Zig doesn&#x27;t instantiate anything the doesn&#x27;t get called.  So, it doesn&#x27;t have to generate a whole bunch of templated functions and then optimize down to the ones that actually get used.<p>The upside is that if you only call a generic function with a u32, you don&#x27;t instantiate an f32 as well.  The downside is that when you do decide to call that function with an f32, all the comptime stuff suddenly gets compiled for the f32 and might have an error.<p>In practice, I feel that I gain way more from the fast compile than I lose from having a path that accidentally never got compiled as my unit tests almost always force those paths to be compiled at least once.</div><br/><div id="42620181" class="c"><input type="checkbox" id="c-42620181" checked=""/><div class="controls bullet"><span class="by">dwattttt</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42620083">parent</a><span>|</span><a href="#42620522">next</a><span>|</span><label class="collapse" for="c-42620181">[-]</label><label class="expand" for="c-42620181">[2 more]</label></div><br/><div class="children"><div class="content">&gt; it doesn&#x27;t have to generate a whole bunch of templated functions and then optimize down to the ones that actually get used.<p>It&#x27;s been a long time since I&#x27;ve dealt with templated C++, but I thought this was how C++ does it too.<p>C++ will only generate functions for template parameters that are actually used, because it compiles a version of the templated function for each unique template parameters.</div><br/><div id="42620545" class="c"><input type="checkbox" id="c-42620545" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42620181">parent</a><span>|</span><a href="#42620522">next</a><span>|</span><label class="collapse" for="c-42620545">[-]</label><label class="expand" for="c-42620545">[1 more]</label></div><br/><div class="children"><div class="content">C++ is at the very least less lazy than Zig. As an example, if you write some constexpr expression that evaluates a ternary and instantiates a function differently in the two prongs, both will be instantiated, even the one that doesn&#x27;t end up in the final program. Yes, there are workarounds, but I didn&#x27;t end up using them. I just moved the offending assert from compile time to runtime because this particular code was not that important.</div><br/></div></div></div></div></div></div></div></div><div id="42620522" class="c"><input type="checkbox" id="c-42620522" checked=""/><div class="controls bullet"><span class="by">anonymoushn</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42619986">parent</a><span>|</span><a href="#42620018">prev</a><span>|</span><a href="#42620095">next</a><span>|</span><label class="collapse" for="c-42620522">[-]</label><label class="expand" for="c-42620522">[1 more]</label></div><br/><div class="children"><div class="content">comptime for generics is a superset of the things that C++ and Rust do for generics</div><br/></div></div><div id="42620095" class="c"><input type="checkbox" id="c-42620095" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42619926">root</a><span>|</span><a href="#42619986">parent</a><span>|</span><a href="#42620522">prev</a><span>|</span><a href="#42619942">next</a><span>|</span><label class="collapse" for="c-42620095">[-]</label><label class="expand" for="c-42620095">[1 more]</label></div><br/><div class="children"><div class="content">As proven by C++ with modules and binary libraries, compile times can be better in C++.<p>Rust suffers because they compile everything from source, and the frontend sends piles of unprocessed LLVM IR to the traditional slow backend.<p>This can be improved with better tooling, one example is the Cranelift backend, there could be an interpreter, and so on.<p>Examples of languages that don&#x27;t send compile times to the moon with similar polymorphic power, Standard ML, OCaml, Haskell, D, Ada.</div><br/></div></div></div></div><div id="42619942" class="c"><input type="checkbox" id="c-42619942" checked=""/><div class="controls bullet"><span class="by">edflsafoiewq</span><span>|</span><a href="#42619926">parent</a><span>|</span><a href="#42619986">prev</a><span>|</span><a href="#42619770">next</a><span>|</span><label class="collapse" for="c-42619942">[-]</label><label class="expand" for="c-42619942">[1 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/></div></div></div></div><div id="42619770" class="c"><input type="checkbox" id="c-42619770" checked=""/><div class="controls bullet"><span class="by">diimdeep</span><span>|</span><a href="#42619926">prev</a><span>|</span><label class="collapse" for="c-42619770">[-]</label><label class="expand" for="c-42619770">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it&#x27;s good, and tech evangelism is just marketing.</div><br/></div></div></div></div></div></div></div></body></html>