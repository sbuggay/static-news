<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1722070848590" as="style"/><link rel="stylesheet" href="styles.css?v=1722070848590"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://chipsandcheese.com/2024/07/26/zen-5s-2-ahead-branch-predictor-unit-how-30-year-old-idea-allows-for-new-tricks/">Zen 5&#x27;s 2-ahead branch predictor: how a 30 year old idea allows for new tricks</a> <span class="domain">(<a href="https://chipsandcheese.com">chipsandcheese.com</a>)</span></div><div class="subtext"><span>matt_d</span> | <span>111 comments</span></div><br/><div><div id="41082810" class="c"><input type="checkbox" id="c-41082810" checked=""/><div class="controls bullet"><span class="by">gary_0</span><span>|</span><a href="#41084456">next</a><span>|</span><label class="collapse" for="c-41082810">[-]</label><label class="expand" for="c-41082810">[2 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s a great explanation of branch prediction, starting from the earliest implementations: <a href="https:&#x2F;&#x2F;danluu.com&#x2F;branch-prediction&#x2F;" rel="nofollow">https:&#x2F;&#x2F;danluu.com&#x2F;branch-prediction&#x2F;</a></div><br/><div id="41084630" class="c"><input type="checkbox" id="c-41084630" checked=""/><div class="controls bullet"><span class="by">skywal_l</span><span>|</span><a href="#41082810">parent</a><span>|</span><a href="#41084456">next</a><span>|</span><label class="collapse" for="c-41084630">[-]</label><label class="expand" for="c-41084630">[1 more]</label></div><br/><div class="children"><div class="content">Godbolt recently did an ELI5 on computerphile about everything CPU[0] and about branch prediction in particular[1].<p>[0]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nhXevKMm3JI&amp;list=PLzH6n4zXuckpwdGMHgRH5N9xNHzVGCxwf" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nhXevKMm3JI&amp;list=PLzH6n4zXuc...</a><p>[1]: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nczJ58WvtYo&amp;list=PLzH6n4zXuckpwdGMHgRH5N9xNHzVGCxwf&amp;index=3" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nczJ58WvtYo&amp;list=PLzH6n4zXuc...</a></div><br/></div></div></div></div><div id="41084456" class="c"><input type="checkbox" id="c-41084456" checked=""/><div class="controls bullet"><span class="by">ksec</span><span>|</span><a href="#41082810">prev</a><span>|</span><a href="#41082310">next</a><span>|</span><label class="collapse" for="c-41084456">[-]</label><label class="expand" for="c-41084456">[6 more]</label></div><br/><div class="children"><div class="content">It will be interesting to see the SMT performance, I am expecting this would provide benefits and be further refined in future generation. With Zen5c we get 192 Core or 384vCPU. We should be getting 256 Core with Zen 6c next year. Which means on a Dual Socket 1U Server, that is a potential of 512 Core with 1024 vCPU.<p>Whatever Web App Scaling issues we had in 2014 could now fit into a single server, assuming we somehow manage to cool the thing. Even at 1 RPS per vCPU that is 1000 RPS, excluding cache hit. Even on HN front-page dont hit the server at 1000 Page View per second.</div><br/><div id="41084922" class="c"><input type="checkbox" id="c-41084922" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#41084456">parent</a><span>|</span><a href="#41085015">next</a><span>|</span><label class="collapse" for="c-41084922">[-]</label><label class="expand" for="c-41084922">[1 more]</label></div><br/><div class="children"><div class="content">Serving web pages is cheap. You’ll probably hit network I&#x2F;O limits before you saturate the cores.<p>I wonder what about its HPC performance. I think cooling this won’t be big problem, but might be wet one, requiring DLC after a certain point.</div><br/></div></div><div id="41085015" class="c"><input type="checkbox" id="c-41085015" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41084456">parent</a><span>|</span><a href="#41084922">prev</a><span>|</span><a href="#41085104">next</a><span>|</span><label class="collapse" for="c-41085015">[-]</label><label class="expand" for="c-41085015">[1 more]</label></div><br/><div class="children"><div class="content">SMT could use a lot more benchmarking investigations.<p>Intuitively having more tasks working on the same problem at half speed should have a memory usage cost, are apps commonly using more memory for no speed gain when using SMT?<p>In a lot of published benchmarks it seems most apps don&#x27;t noticeably benefit in executions peed.</div><br/></div></div><div id="41085104" class="c"><input type="checkbox" id="c-41085104" checked=""/><div class="controls bullet"><span class="by">WithinReason</span><span>|</span><a href="#41084456">parent</a><span>|</span><a href="#41085015">prev</a><span>|</span><a href="#41085272">next</a><span>|</span><label class="collapse" for="c-41085104">[-]</label><label class="expand" for="c-41085104">[1 more]</label></div><br/><div class="children"><div class="content">The opposite might be true, the better you are at utilising the CPU pipeline the less space you have to run a 2nd thread so SMT&#x27;s benefits might diminish</div><br/></div></div><div id="41085272" class="c"><input type="checkbox" id="c-41085272" checked=""/><div class="controls bullet"><span class="by">andrepd</span><span>|</span><a href="#41084456">parent</a><span>|</span><a href="#41085104">prev</a><span>|</span><a href="#41084748">next</a><span>|</span><label class="collapse" for="c-41085272">[-]</label><label class="expand" for="c-41085272">[1 more]</label></div><br/><div class="children"><div class="content">Man I sure hope that your server does more than 1 RPS :)</div><br/></div></div><div id="41084748" class="c"><input type="checkbox" id="c-41084748" checked=""/><div class="controls bullet"><span class="by">teaearlgraycold</span><span>|</span><a href="#41084456">parent</a><span>|</span><a href="#41085272">prev</a><span>|</span><a href="#41082310">next</a><span>|</span><label class="collapse" for="c-41084748">[-]</label><label class="expand" for="c-41084748">[1 more]</label></div><br/><div class="children"><div class="content">Web app scaling issues are usually around database latency.</div><br/></div></div></div></div><div id="41082310" class="c"><input type="checkbox" id="c-41082310" checked=""/><div class="controls bullet"><span class="by">IvanAchlaqullah</span><span>|</span><a href="#41084456">prev</a><span>|</span><a href="#41083317">next</a><span>|</span><label class="collapse" for="c-41082310">[-]</label><label class="expand" for="c-41082310">[30 more]</label></div><br/><div class="children"><div class="content">It&#x27;s always interesting to see decades old papers, sometimes published with little to no fanfares, suddenly becomes &quot;state of the art&quot; because hardware have become powerful enough.<p>For example Z-buffers[1]. It&#x27;s used by 3d video games. When it&#x27;s first published on paper, it&#x27;s not even the main topic of the paper, just some side notes because it requires expensive amount of memory to run.<p>Turn out megabytes is quite cheap few decades latter, and every realtime 3d renderer ended up using it.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Z-buffering" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Z-buffering</a></div><br/><div id="41085043" class="c"><input type="checkbox" id="c-41085043" checked=""/><div class="controls bullet"><span class="by">abainbridge</span><span>|</span><a href="#41082310">parent</a><span>|</span><a href="#41084430">next</a><span>|</span><label class="collapse" for="c-41085043">[-]</label><label class="expand" for="c-41085043">[1 more]</label></div><br/><div class="children"><div class="content">Another example is Low Density Parity Check Codes [1]. Discovered in 1962 by Robert Gallager but abandoned and forgotten about for decades due to being computationally impractical. It looks like there was a 38 year gap in the literature until rediscovered by David MacKay [2].<p>The first mainstream use was in 2003. It is now used in WiFi, Ethernet and 5G.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Low-density_parity-check_code" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Low-density_parity-check_code</a><p>[2] <a href="https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?q=%22low+density+parity+check+codes%22&amp;hl=en&amp;as_sdt=0%2C5&amp;as_ylo=1960&amp;as_yhi=1999" rel="nofollow">https:&#x2F;&#x2F;scholar.google.com&#x2F;scholar?q=%22low+density+parity+c...</a></div><br/></div></div><div id="41084430" class="c"><input type="checkbox" id="c-41084430" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41082310">parent</a><span>|</span><a href="#41085043">prev</a><span>|</span><a href="#41082376">next</a><span>|</span><label class="collapse" for="c-41084430">[-]</label><label class="expand" for="c-41084430">[1 more]</label></div><br/><div class="children"><div class="content">&gt; suddenly becomes &quot;state of the art&quot; because hardware have become powerful enough.<p>I&#x27;d rather say that we were capable of such a design for several decades, but only now the set of trade-offs currently in-place made this attractive. Single core performance was stifled in the last 2 decades by prioritizing horizontal scaling (more cores), thus the complexity &#x2F; die area of each individual core became a concern. I imagine if this trend did not take place for some reason, and the CPU designers primarily pursued single core performance, we&#x27;d see implementation much sooner.<p>Regarding the Z-buffer, I kind of get that this would appear as a side note, it&#x27;s a simple concept. Perhaps even better example is ray tracing - the concept is even quite obvious to people without 3D graphics background, but it was just impractical (for real-time rendering) in terms of performance until recently. What I find interesting is that we haven&#x27;t found a simpler approach to approximate true to life rendering and need to fallback on this old, sort of naive (and expensive) solution.</div><br/></div></div><div id="41082376" class="c"><input type="checkbox" id="c-41082376" checked=""/><div class="controls bullet"><span class="by">bee_rider</span><span>|</span><a href="#41082310">parent</a><span>|</span><a href="#41084430">prev</a><span>|</span><a href="#41084614">next</a><span>|</span><label class="collapse" for="c-41082376">[-]</label><label class="expand" for="c-41082376">[20 more]</label></div><br/><div class="children"><div class="content">I sometimes wonder if there’s an academic career hidden in there for an engineer: go to the library and read what the CS folks were publishing on physical papers, maybe there are some ideas that can actually be implemented now that weren’t practical back then.</div><br/><div id="41083069" class="c"><input type="checkbox" id="c-41083069" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41083921">next</a><span>|</span><label class="collapse" for="c-41083069">[-]</label><label class="expand" for="c-41083069">[6 more]</label></div><br/><div class="children"><div class="content">In a series of books by David Brin [0] there is a galaxy-wide institution known as the library, and civilizations regularly mine its millions of years of data for suddenly-relevant-again techniques and technologies.<p>I remember one bit where a species had launched some tricky fleet-destroying weapon to surprise their enemies with esoteric physics, only to have it reversed against them, possibly because the Librarian that once helped their research-agent wasn&#x27;t entirely unbiased.<p>[0] <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Uplift_Universe" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Uplift_Universe</a></div><br/><div id="41083214" class="c"><input type="checkbox" id="c-41083214" checked=""/><div class="controls bullet"><span class="by">AceJohnny2</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083069">parent</a><span>|</span><a href="#41083348">next</a><span>|</span><label class="collapse" for="c-41083214">[-]</label><label class="expand" for="c-41083214">[3 more]</label></div><br/><div class="children"><div class="content">Also in Vinge&#x27;s Deepness in the Sky, there aren&#x27;t really &quot;programmers&quot; as we know them anymore, but &quot;programmer-archeologists&quot; that just search the archives for code components to reuse.</div><br/><div id="41084460" class="c"><input type="checkbox" id="c-41084460" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083214">parent</a><span>|</span><a href="#41083367">next</a><span>|</span><label class="collapse" for="c-41084460">[-]</label><label class="expand" for="c-41084460">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s pretty much what any (decent) programmer does today as well. You first search your code base to see if the application already does something like it, if not, whether there is a published library. Where this starts to fail is the idea that connecting those already written peaces together is easy.</div><br/></div></div><div id="41083367" class="c"><input type="checkbox" id="c-41083367" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083214">parent</a><span>|</span><a href="#41084460">prev</a><span>|</span><a href="#41083348">next</a><span>|</span><label class="collapse" for="c-41083367">[-]</label><label class="expand" for="c-41083367">[1 more]</label></div><br/><div class="children"><div class="content">Also: In the Destiny mythic sci-fi franchise, the human golden age ended with a mysterious apocalypse, leaving &quot;cryptarchs&quot; (crypto-archeologists) to try to rebuild from arcane fragments of encrypted data or unknown formats.</div><br/></div></div></div></div><div id="41083348" class="c"><input type="checkbox" id="c-41083348" checked=""/><div class="controls bullet"><span class="by">CoastalCoder</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083069">parent</a><span>|</span><a href="#41083214">prev</a><span>|</span><a href="#41083921">next</a><span>|</span><label class="collapse" for="c-41083348">[-]</label><label class="expand" for="c-41083348">[2 more]</label></div><br/><div class="children"><div class="content">Mind editing that to give a spoiler alert?</div><br/><div id="41083381" class="c"><input type="checkbox" id="c-41083381" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083348">parent</a><span>|</span><a href="#41083921">next</a><span>|</span><label class="collapse" for="c-41083381">[-]</label><label class="expand" for="c-41083381">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t worry, it&#x27;s nowhere near the main plot or characters, just a small &quot;meanwhile, elsewhere&quot; vignette. Basically emphasizing the &quot;why bother everything&#x27;s already invented&quot; mentality of most client-races, and how deep access and query-secrecy have big impacts.</div><br/></div></div></div></div></div></div><div id="41083921" class="c"><input type="checkbox" id="c-41083921" checked=""/><div class="controls bullet"><span class="by">kvemkon</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41083069">prev</a><span>|</span><a href="#41082492">next</a><span>|</span><label class="collapse" for="c-41083921">[-]</label><label class="expand" for="c-41083921">[1 more]</label></div><br/><div class="children"><div class="content">Academic? Perhaps, applied:<p>&quot;When Soviets Won the Cold War: Wading Through Pyotr Ufimstev&#x27;s Work on Stealth&quot; (26.03.2024)<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39830671">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39830671</a><p>&gt; In the early 1970s, Lockheed Martin engineer Denys Overholser discovered the key to stealth technology hidden in a stack of translated Soviet technical papers. Disregarded by the Soviet academic elite, and unheard of in the United States, Pyotr Ufimstev had worked out calculations that would help win ...<p>Not sure of the details of this story, but in general having there enough people to grant them time just to search for something interesting seems not unrealistic.</div><br/></div></div><div id="41082492" class="c"><input type="checkbox" id="c-41082492" checked=""/><div class="controls bullet"><span class="by">findthewords</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41083921">prev</a><span>|</span><a href="#41084660">next</a><span>|</span><label class="collapse" for="c-41082492">[-]</label><label class="expand" for="c-41082492">[3 more]</label></div><br/><div class="children"><div class="content">Yes, &quot;read 10 year old papers as a source of ideas ripe for commercialization&quot; IS common advice in universities.</div><br/><div id="41082673" class="c"><input type="checkbox" id="c-41082673" checked=""/><div class="controls bullet"><span class="by">chrisbrandow</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082492">parent</a><span>|</span><a href="#41083009">next</a><span>|</span><label class="collapse" for="c-41082673">[-]</label><label class="expand" for="c-41082673">[1 more]</label></div><br/><div class="children"><div class="content">A post-doc in my chemistry lab had the saying, “two weeks in the lab will save you a day in the library”</div><br/></div></div></div></div><div id="41084660" class="c"><input type="checkbox" id="c-41084660" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41082492">prev</a><span>|</span><a href="#41084462">next</a><span>|</span><label class="collapse" for="c-41084660">[-]</label><label class="expand" for="c-41084660">[1 more]</label></div><br/><div class="children"><div class="content">Heck. Look at 10 year old product launch PRs from big tech. Anything that Google launched 10 years ago and killed, but seems like a good idea today is probably also easier to do. And if you look 5-10 years before that, you can find the Yahoo launch PR where they did the same thing ;p</div><br/></div></div><div id="41084462" class="c"><input type="checkbox" id="c-41084462" checked=""/><div class="controls bullet"><span class="by">fragmede</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41084660">prev</a><span>|</span><a href="#41082712">next</a><span>|</span><label class="collapse" for="c-41084462">[-]</label><label class="expand" for="c-41084462">[2 more]</label></div><br/><div class="children"><div class="content">The whole AI trend is in part due to things that are now possible on GPU supercomputers with gigabytes of RAM backed by petabytes of data and at the top speed of GPUs. Some of the algorithms date back to before the ai winter and it&#x27;s just that we can now do the same thing with a ton more data and faster.</div><br/><div id="41084507" class="c"><input type="checkbox" id="c-41084507" checked=""/><div class="controls bullet"><span class="by">zaptrem</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41084462">parent</a><span>|</span><a href="#41082712">next</a><span>|</span><label class="collapse" for="c-41084507">[-]</label><label class="expand" for="c-41084507">[1 more]</label></div><br/><div class="children"><div class="content">All of the main algorithms do (multi-layer perceptrons and stochastic gradient descent are from the 50s and 60s!). Basically the only thing that changed is we decided to multiply some of the outputs of the multi-layer perceptrons by each other and softmax it (attention) before passing them back into more layers. Almost all of the other stuff is just gravy to make it converge faster (and run faster on modern hardware).</div><br/></div></div></div></div><div id="41082712" class="c"><input type="checkbox" id="c-41082712" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41084462">prev</a><span>|</span><a href="#41084076">next</a><span>|</span><label class="collapse" for="c-41082712">[-]</label><label class="expand" for="c-41082712">[4 more]</label></div><br/><div class="children"><div class="content">Image and video compression are like that. Ideas for mainframes in the &#x27;80s are realtime algorithms now.</div><br/><div id="41084079" class="c"><input type="checkbox" id="c-41084079" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082712">parent</a><span>|</span><a href="#41084076">next</a><span>|</span><label class="collapse" for="c-41084079">[-]</label><label class="expand" for="c-41084079">[3 more]</label></div><br/><div class="children"><div class="content">I guess they are _soft_ realtime algorithms now?</div><br/><div id="41084516" class="c"><input type="checkbox" id="c-41084516" checked=""/><div class="controls bullet"><span class="by">taneq</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41084079">parent</a><span>|</span><a href="#41084076">next</a><span>|</span><label class="collapse" for="c-41084516">[-]</label><label class="expand" for="c-41084516">[2 more]</label></div><br/><div class="children"><div class="content">&#x27;Realtime&#x27; isn&#x27;t a specific thing, there&#x27;s just &#x27;fast enough&#x27;. Oldschool &quot;render each frame during the scan line staying ahead of the electron beam&quot; graphics was pretty hardcore though.</div><br/><div id="41084671" class="c"><input type="checkbox" id="c-41084671" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41084516">parent</a><span>|</span><a href="#41084076">next</a><span>|</span><label class="collapse" for="c-41084671">[-]</label><label class="expand" for="c-41084671">[1 more]</label></div><br/><div class="children"><div class="content">&#x27;Realtime&#x27; actually has multiple meanings.<p>At least one of them is very, very specific and is the one that Wikipedia uses in <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real-time_computing" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real-time_computing</a><p>&gt; Real-time computing (RTC) is the computer science term for hardware and software systems subject to a &quot;real-time constraint&quot;, for example from event to system response.[1] Real-time programs must guarantee response within specified time constraints, often referred to as &quot;deadlines&quot;.[2]<p>Strictly speaking, this definition doesn&#x27;t say anything about how tight those deadlines are, as long as you can guarantee some deadlines.<p>There&#x27;s also &#x27;soft&#x27; real time where you try to hit your deadlines often-enough, but there&#x27;s no guarantees and a missed deadline is not the end of the world. Games are good example of that, including the example of chasing the electron beam.<p>ABS brakes are an example of a &#x27;hard&#x27; real time system: the deadlines aren&#x27;t nearly as tight as for video game frames, but you really, really can&#x27;t afford to miss them.</div><br/></div></div></div></div></div></div></div></div><div id="41084076" class="c"><input type="checkbox" id="c-41084076" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41082376">parent</a><span>|</span><a href="#41082712">prev</a><span>|</span><a href="#41082906">next</a><span>|</span><label class="collapse" for="c-41084076">[-]</label><label class="expand" for="c-41084076">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if current AI training&#x27;s effort to hover up all the training data they can find will accidentally give us most of the benefits of that?<p>A human can only read so much, so has to discriminate.  But our machines are omnivorous readers.</div><br/></div></div></div></div><div id="41084614" class="c"><input type="checkbox" id="c-41084614" checked=""/><div class="controls bullet"><span class="by">pcwalton</span><span>|</span><a href="#41082310">parent</a><span>|</span><a href="#41082376">prev</a><span>|</span><a href="#41084729">next</a><span>|</span><label class="collapse" for="c-41084614">[-]</label><label class="expand" for="c-41084614">[2 more]</label></div><br/><div class="children"><div class="content">Another example is Rust&#x27;s borrow checker, which has roots in substructural type system papers from decades earlier. Many academics considered substructural type systems dead (killed by GC, more or less) until Rust resurrected the idea by combining it with some new ideas from C++ of the time.</div><br/><div id="41085080" class="c"><input type="checkbox" id="c-41085080" checked=""/><div class="controls bullet"><span class="by">protomolecule</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41084614">parent</a><span>|</span><a href="#41084729">next</a><span>|</span><label class="collapse" for="c-41085080">[-]</label><label class="expand" for="c-41085080">[1 more]</label></div><br/><div class="children"><div class="content">&quot;with some new ideas from C++ of the time&quot;<p>Could you elaborate on that?</div><br/></div></div></div></div><div id="41084729" class="c"><input type="checkbox" id="c-41084729" checked=""/><div class="controls bullet"><span class="by">BitPirate</span><span>|</span><a href="#41082310">parent</a><span>|</span><a href="#41084614">prev</a><span>|</span><a href="#41083527">next</a><span>|</span><label class="collapse" for="c-41084729">[-]</label><label class="expand" for="c-41084729">[1 more]</label></div><br/><div class="children"><div class="content">The EEVDF scheduling algorithm is also a good example. Designed back in 1995 and it&#x27;s the default process scheduler of Linux now.</div><br/></div></div><div id="41083527" class="c"><input type="checkbox" id="c-41083527" checked=""/><div class="controls bullet"><span class="by">twoodfin</span><span>|</span><a href="#41082310">parent</a><span>|</span><a href="#41084729">prev</a><span>|</span><a href="#41083317">next</a><span>|</span><label class="collapse" for="c-41083527">[-]</label><label class="expand" for="c-41083527">[4 more]</label></div><br/><div class="children"><div class="content">On the software side, garbage collection was well explored by academia for more than two decades before the JVM brought it to wide commercial adoption ca. 1995.</div><br/><div id="41085263" class="c"><input type="checkbox" id="c-41085263" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083527">parent</a><span>|</span><a href="#41083765">next</a><span>|</span><label class="collapse" for="c-41085263">[-]</label><label class="expand" for="c-41085263">[1 more]</label></div><br/><div class="children"><div class="content">Not academia, GC (and lots of other PLT) was mature and productized then, just missed by the majority of the industry living the dark ages. In the 90s, enterprisey architecture astronaut cultures went Java&#x2F;C++ and hackerish cultures went Perl&#x2F;Python seasoned with C.</div><br/></div></div><div id="41083765" class="c"><input type="checkbox" id="c-41083765" checked=""/><div class="controls bullet"><span class="by">bhouston</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083527">parent</a><span>|</span><a href="#41085263">prev</a><span>|</span><a href="#41083317">next</a><span>|</span><label class="collapse" for="c-41083765">[-]</label><label class="expand" for="c-41083765">[2 more]</label></div><br/><div class="children"><div class="content">Lisp and Smalltalk and BASIC (to name a few) were popular languages before the JVM that used GC.</div><br/><div id="41084289" class="c"><input type="checkbox" id="c-41084289" checked=""/><div class="controls bullet"><span class="by">tasty_freeze</span><span>|</span><a href="#41082310">root</a><span>|</span><a href="#41083765">parent</a><span>|</span><a href="#41083317">next</a><span>|</span><label class="collapse" for="c-41084289">[-]</label><label class="expand" for="c-41084289">[1 more]</label></div><br/><div class="children"><div class="content">When I was in high school, I wrote a Z80 disassembler in BASIC and printed out the entire TRS-80 Model 3 ROM on a thick stack of fan folded greenline paper. I spent a lot of free time figuring out what was what and commenting the code by pen in the right margin.<p>The (string) garbage collector was amazingly frugal and correspondingly slow. Because the garbage collector typically ran only when memory was critically low it used almost no memory, just 4 bytes I think. (it was also possible to invoke it any time with the FRE(0) function call IIRC)<p>The routine would sweep all of the symbol table and expression stack looking for string pointers, and would remember the lowest (highest? I forget which) string base address which hadn&#x27;t already been compacted. After each pass it would move that one string and fix the symbol table pointer (or expression stack str pointer) then do another pass. As a result, is was quadratic with the number of live strings -- so if you had a large number of small strings, it was possible for your program to lock solidly for 30 seconds or more.</div><br/></div></div></div></div></div></div></div></div><div id="41083317" class="c"><input type="checkbox" id="c-41083317" checked=""/><div class="controls bullet"><span class="by">mrlonglong</span><span>|</span><a href="#41082310">prev</a><span>|</span><a href="#41084745">next</a><span>|</span><label class="collapse" for="c-41083317">[-]</label><label class="expand" for="c-41083317">[8 more]</label></div><br/><div class="children"><div class="content">Speculative predictors have been subjected to a number of attacks to weasel out private data. Given that so many of the common ISAs are vulnerable, are they taking steps to reduce the impact of such attacks?</div><br/><div id="41084082" class="c"><input type="checkbox" id="c-41084082" checked=""/><div class="controls bullet"><span class="by">kmeisthax</span><span>|</span><a href="#41083317">parent</a><span>|</span><a href="#41083689">next</a><span>|</span><label class="collapse" for="c-41084082">[-]</label><label class="expand" for="c-41084082">[4 more]</label></div><br/><div class="children"><div class="content">The vulnerability is speculative execution, not branch prediction. The branch predictor is the thing you have to trick to force the processor to speculatively execute code in the victim program. Furthermore you also need a valid timing source to read out the results of the speculative execution.<p>As for how to stop that, short of boiling the ocean[0], you don&#x27;t. Speculative execution is so valuable for performance that a computer without it is completely unusable. If you really want a processor without it, buy an old first-gen Pentium.<p>Actual practical mitigations for speculative execution vulnerabilities are varied, but <i>at a minimum</i> you have to ensure process separation between a victim process holding secrets and any potential attackers that may have the opportunity to influence victim process execution. Intel was caught with their hands in their pants speculating across rings, which is why you could read kernel or hypervisor memory from userspace, but on not-poorly-designed CPUs the main victim you have to worry about is HTML iframes. Different origins aren&#x27;t allowed to make HTTP requests to one another[1], but they <i>can</i> transclude[2] one another without permission. That traditionally loaded information from the origin into the attacker&#x27;s process, which could be exfiltrated with timing attacks.<p>The web&#x27;s solution to this was actually <i>not</i> to process-separate iframes, at least not initially, but to take away shared-memory multithreading entirely. If you deny the attacker a timing reference then it doesn&#x27;t matter what they can make the victim speculatively execute. But to do this you have to take away multithreading because otherwise a thread can just repeatedly write known data in a loop to create a clock.<p>[0] <a href="https:&#x2F;&#x2F;hackaday.com&#x2F;2013&#x2F;08&#x2F;02&#x2F;the-mill-cpu-architecture&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hackaday.com&#x2F;2013&#x2F;08&#x2F;02&#x2F;the-mill-cpu-architecture&#x2F;</a><p>[1] At least not without the target origin allowing it via CORS<p>[2] e.g. hotlink images or embed iframes</div><br/><div id="41084976" class="c"><input type="checkbox" id="c-41084976" checked=""/><div class="controls bullet"><span class="by">topspin</span><span>|</span><a href="#41083317">root</a><span>|</span><a href="#41084082">parent</a><span>|</span><a href="#41084711">next</a><span>|</span><label class="collapse" for="c-41084976">[-]</label><label class="expand" for="c-41084976">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Speculative execution is so valuable for performance that a computer without it is completely unusable.<p>Jim Keller&#x27;s view aligns with this and goes further.  My interpretation of his thinking is that predictors and speculation are the only meaningful features of CPUs today.  ISA doesn&#x27;t matter anymore because the power of modern compilers makes high performance software highly portable and all CPUs end up bottlenecked on the quality and capacity of the predictors, regardless of the ISA.  For example, the burden of x86 complexity no longer matters because it amounts to a &quot;tax&quot; small enough to be lost in the noise.<p>That&#x27;s from a designer making high performance RISC-V CPUs.</div><br/><div id="41085294" class="c"><input type="checkbox" id="c-41085294" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41083317">root</a><span>|</span><a href="#41084976">parent</a><span>|</span><a href="#41084711">next</a><span>|</span><label class="collapse" for="c-41085294">[-]</label><label class="expand" for="c-41085294">[1 more]</label></div><br/><div class="children"><div class="content">This is so annoying about the hype around ARM, for which even smart people fall. Yes, Apple Silicon is good, but it&#x27;s not because of ARM ISA. I still keep hearing that ARM is RISC which is wrong since the 1990s.</div><br/></div></div></div></div><div id="41084711" class="c"><input type="checkbox" id="c-41084711" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41083317">root</a><span>|</span><a href="#41084082">parent</a><span>|</span><a href="#41084976">prev</a><span>|</span><a href="#41083689">next</a><span>|</span><label class="collapse" for="c-41084711">[-]</label><label class="expand" for="c-41084711">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Speculative execution is so valuable for performance that a computer without it is completely unusable. If you really want a processor without it, buy an old first-gen Pentium.<p>Pentiums have branch prediction and speculative execution. You need to go back to i486 if you don&#x27;t want speculative execution. Most of the socket 5&#x2F;7 processors from other makers also had branch predictors and speculative execution, but not the Centaur Winchip. The Cyrix 5x86 for socket 3 (486) had speculative execution, but it was disabled by default and is reported to be buggy (but helps performance on published benchmarks).</div><br/></div></div></div></div><div id="41083689" class="c"><input type="checkbox" id="c-41083689" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41083317">parent</a><span>|</span><a href="#41084082">prev</a><span>|</span><a href="#41084745">next</a><span>|</span><label class="collapse" for="c-41083689">[-]</label><label class="expand" for="c-41083689">[3 more]</label></div><br/><div class="children"><div class="content">Interactions between speculative execution and virtual memory translation and caches are exploitable.  It&#x27;s not an inherent vulnerability in prediction.</div><br/><div id="41083703" class="c"><input type="checkbox" id="c-41083703" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#41083317">root</a><span>|</span><a href="#41083689">parent</a><span>|</span><a href="#41084745">next</a><span>|</span><label class="collapse" for="c-41083703">[-]</label><label class="expand" for="c-41083703">[2 more]</label></div><br/><div class="children"><div class="content">Sure, as long as it’s not observable in any way, it’s not observable. But the problem is that speculation has been repeatedly been found to be observable in unexpected ways from both brands.<p>Amd, for example, has observability issues in all zen1&#x2F;2&#x2F;3 processors that leaks enough data to break KASLR that remain unpatched in all chips except for Milan (specifically epyc only, not ryzen). They didn’t expect cache ways to be visible in that fashion, and it’s observable that the model is incorrectly implemented.<p>the idea cannot fail, only be failed, because if it’s observable then obviously you just did it wrong.</div><br/><div id="41083723" class="c"><input type="checkbox" id="c-41083723" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#41083317">root</a><span>|</span><a href="#41083703">parent</a><span>|</span><a href="#41084745">next</a><span>|</span><label class="collapse" for="c-41083723">[-]</label><label class="expand" for="c-41083723">[1 more]</label></div><br/><div class="children"><div class="content">The point was,  you can engineer around problems that aren&#x27;t _inherent_ in the design,  but arise as an interaction between systems.  You just change the rules of interaction between systems to mitigate the vulnerabilities.<p>So,  to your original question,  we&#x27;re always going to have prediction,  and we&#x27;re going to have to solve any vulnerabilities that arise downstream.  Which,  thankfully,  is always an available option.</div><br/></div></div></div></div></div></div></div></div><div id="41084745" class="c"><input type="checkbox" id="c-41084745" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#41083317">prev</a><span>|</span><a href="#41082274">next</a><span>|</span><label class="collapse" for="c-41084745">[-]</label><label class="expand" for="c-41084745">[1 more]</label></div><br/><div class="children"><div class="content">We would need more branch hints? <a href="https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;5177">https:&#x2F;&#x2F;github.com&#x2F;ziglang&#x2F;zig&#x2F;issues&#x2F;5177</a><p>Cold, warm, warmer, omit hot as it is the default? Sometimes you would set all branches to be cold except one</div><br/></div></div><div id="41082274" class="c"><input type="checkbox" id="c-41082274" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41084745">prev</a><span>|</span><a href="#41082284">next</a><span>|</span><label class="collapse" for="c-41082274">[-]</label><label class="expand" for="c-41082274">[15 more]</label></div><br/><div class="children"><div class="content">As a novice in this area, it&#x27;s not clear to me after reading this what exactly the 2-ahead branch predictor is.</div><br/><div id="41082504" class="c"><input type="checkbox" id="c-41082504" checked=""/><div class="controls bullet"><span class="by">cpldcpu</span><span>|</span><a href="#41082274">parent</a><span>|</span><a href="#41083331">next</a><span>|</span><label class="collapse" for="c-41082504">[-]</label><label class="expand" for="c-41082504">[8 more]</label></div><br/><div class="children"><div class="content">My understanding is that they do not predict the target of the next branch but of the one after the next (2-ahead). This is probably much harder than next-branch prediction but does allows to initiate code fetch much earlier to feed even deeper pipelines.</div><br/><div id="41084699" class="c"><input type="checkbox" id="c-41084699" checked=""/><div class="controls bullet"><span class="by">flamedoge</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082504">parent</a><span>|</span><a href="#41082984">next</a><span>|</span><label class="collapse" for="c-41084699">[-]</label><label class="expand" for="c-41084699">[1 more]</label></div><br/><div class="children"><div class="content">I wonder what they need before this change. Branch predictor hardware may not have accounted for depth beyond single conditional branch? but pipeline was probably always filled, unpredicted.</div><br/></div></div><div id="41082984" class="c"><input type="checkbox" id="c-41082984" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082504">parent</a><span>|</span><a href="#41084699">prev</a><span>|</span><a href="#41082859">next</a><span>|</span><label class="collapse" for="c-41082984">[-]</label><label class="expand" for="c-41082984">[5 more]</label></div><br/><div class="children"><div class="content">Surely you must also predict the next branch to predict the one after. Otherwise you wouldn’t know which is the one after.<p>Given that, I still don’t understand how predicting the next two branches is different from predicting the next branch and then the next after that, i.e. two times the same thing.</div><br/><div id="41083173" class="c"><input type="checkbox" id="c-41083173" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082984">parent</a><span>|</span><a href="#41084761">next</a><span>|</span><label class="collapse" for="c-41083173">[-]</label><label class="expand" for="c-41083173">[1 more]</label></div><br/><div class="children"><div class="content">Interestingly you can build a branch predictor that predicts the second branch without predicting the first.<p>A branch predictor result is just a tuple of (&quot;branch instruction address&quot;, &quot;branch target address&quot;) that hints the processor that when the CPU will encounter a given branch instructions in the future (at &quot;branch instruction address&quot;) it will likely branch to the branch target and so it would make sense to start fetching that address and filling the instruction pipeline with whatever steps are safe to perform before the jump will be actually performed.<p>Now, commonly this branch happens to be at the end of the current basic block and I assume some branch predictors may also leverage this fact in order to encode only  offsets from the current instruction pointer.<p>But there is no reason why the branch location might be after some other branches may be taken. As long as the cpu eventually gets to that branch location the prediction will be useful. If the IP never reaches that location it&#x27;s like the branch was never actually taken.</div><br/></div></div><div id="41084761" class="c"><input type="checkbox" id="c-41084761" checked=""/><div class="controls bullet"><span class="by">toast0</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082984">parent</a><span>|</span><a href="#41083173">prev</a><span>|</span><a href="#41084945">next</a><span>|</span><label class="collapse" for="c-41084761">[-]</label><label class="expand" for="c-41084761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Given that, I still don’t understand how predicting the next two branches is different from predicting the next branch and then the next after that, i.e. two times the same thing.<p>I&#x27;m not involved in CPU design, I just read a lot, but...<p>I think you need to do something special to have a second prediction, because you have to track three windows of out of order execution:<p>Window 0: code you&#x27;re definitely running but is still being completed.<p>Window 1: code from the branch you think will be taken<p>Window 2: code from the 2-ahead branch you think will be taken.<p>If you figure out that the window 1 branch isn&#x27;t taken, you have to drop the whole pipeline (pipeline bubble). But if you figure out that window 1 is taken, then window 1 becomes window 0 and window 2 bcomes window 1.<p>With a 1 ahead predictor, the pipeline stalls if you get to a conditional branch while speculating in window 1, because the processor can&#x27;t manage three instruction windows.<p>IMHO, it sounds like if the core is doing SMT and both threads are active, each thread only gets 1-ahead prediction because the two windows are statically divided between the cpu threads. This may mean a) a significant boost for some loads when SMT is not in use and b) SMT can branch predict in both threads in the same cycle, I don&#x27;t think that was possible on AMD before (no idea for other vendors)</div><br/></div></div><div id="41084945" class="c"><input type="checkbox" id="c-41084945" checked=""/><div class="controls bullet"><span class="by">fulafel</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082984">parent</a><span>|</span><a href="#41084761">prev</a><span>|</span><a href="#41083463">next</a><span>|</span><label class="collapse" for="c-41084945">[-]</label><label class="expand" for="c-41084945">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Surely you must also predict the next branch to predict the one after. Otherwise you wouldn’t know which is the one after.<p>I&#x27;d think if you are at PC N and there are branches at N+1 and N+2, predicting just branch N+2 is fine because you predicted the N+1 branch previously, at PC N-1.</div><br/></div></div><div id="41083463" class="c"><input type="checkbox" id="c-41083463" checked=""/><div class="controls bullet"><span class="by">Filligree</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082984">parent</a><span>|</span><a href="#41084945">prev</a><span>|</span><a href="#41082859">next</a><span>|</span><label class="collapse" for="c-41083463">[-]</label><label class="expand" for="c-41083463">[1 more]</label></div><br/><div class="children"><div class="content">Building on the sibling comment:<p><pre><code>  if (a) { ... }

  if (b) { return x; } else { return y; }
</code></pre>
The two branches can be wholly independent, but predicting the second is still a two-ahed prediction.</div><br/></div></div></div></div><div id="41082859" class="c"><input type="checkbox" id="c-41082859" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082504">parent</a><span>|</span><a href="#41082984">prev</a><span>|</span><a href="#41083331">next</a><span>|</span><label class="collapse" for="c-41082859">[-]</label><label class="expand" for="c-41082859">[1 more]</label></div><br/><div class="children"><div class="content">Ah, that makes sense in the context of the article - thanks!</div><br/></div></div></div></div><div id="41083331" class="c"><input type="checkbox" id="c-41083331" checked=""/><div class="controls bullet"><span class="by">hmry</span><span>|</span><a href="#41082274">parent</a><span>|</span><a href="#41082504">prev</a><span>|</span><a href="#41084336">next</a><span>|</span><label class="collapse" for="c-41083331">[-]</label><label class="expand" for="c-41083331">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not alone. Non-novice, same here. Article spends a lot of time explaining the absolute basics of branch prediction but then when it gets to 2-ahead it just skips over explaining it...</div><br/></div></div><div id="41084336" class="c"><input type="checkbox" id="c-41084336" checked=""/><div class="controls bullet"><span class="by">sillywalk</span><span>|</span><a href="#41082274">parent</a><span>|</span><a href="#41083331">prev</a><span>|</span><a href="#41083423">next</a><span>|</span><label class="collapse" for="c-41084336">[-]</label><label class="expand" for="c-41084336">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s from around 30 years ago, my guess is it&#x27;s referring to this[0] paper from 1996. It&#x27;s above my head, but it seems to help with branch prediction issues arising with both many instruction units and high-clock speed, which were sort of either or in the &#x27;90s, but I think most modern processors are both.<p>Multiple-block ahead branch predictors<p>Abstract:<p>A basic rule in computer architecture is that a processor cannot execute an application faster than it fetches its instructions. This paper presents a novel cost-effective mechanism called the two-block ahead branch predictor. Information from the current instruction block is not used for predicting the address of the next instruction block, but rather for predicting the block following the next instruction block. This approach overcomes the instruction fetch bottle-neck exhibited by wide-dispatch &quot;brainiac&quot; processors by enabling them to efficiently predict addresses of two instruction blocks in a single cycle. Furthermore, pipelining the branch prediction process can also be done by means of our predictor for &quot;speed demon&quot; processors to achieve higher clock rate or to improve the prediction accuracy by means of bigger prediction structures. Moreover, and unlike the previously-proposed multiple predictor schemes, multiple-block ahead branch predictors can use any of the branch prediction schemes to perform the very accurate predictions required to achieve high-performance on superscalar processors.&quot;<p>[0] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;237090.237169" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;237090.237169</a><p>EDIT: oops. Looks like eyegor posted the link earlier. Oh well, enjoy the abstract.</div><br/></div></div><div id="41083423" class="c"><input type="checkbox" id="c-41083423" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#41082274">parent</a><span>|</span><a href="#41084336">prev</a><span>|</span><a href="#41082346">next</a><span>|</span><label class="collapse" for="c-41083423">[-]</label><label class="expand" for="c-41083423">[2 more]</label></div><br/><div class="children"><div class="content">I think it just predicts 2 branches per cycle instead of 1. So it can evaluate the result of n+2 ahead of time instead of only n+1 (typical branch prediction). How this works without wrecking the L1 cache, I&#x27;m not sure. It seems like the lookahead past n+1 would make cache evictions much more likely, so maybe I&#x27;m missing something here.<p>&gt; Zen 5 can look farther forward in the instruction stream beyond the 2nd taken branch and as a result Zen 5 can have 3 prediction windows where all 3 windows are useful in producing instructions for decoding.<p>The original paper is open access but I haven&#x27;t read far into it: <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;237090.237169" rel="nofollow">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;10.1145&#x2F;237090.237169</a></div><br/><div id="41084924" class="c"><input type="checkbox" id="c-41084924" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41083423">parent</a><span>|</span><a href="#41082346">next</a><span>|</span><label class="collapse" for="c-41084924">[-]</label><label class="expand" for="c-41084924">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; It seems like the lookahead past n+1 would make cache evictions much more likely, so maybe I&#x27;m missing something here.</i><p>The frontend is already predicting dozens of branches ahead of what the backend can actually confirm. Looking ahead by one extra branch ahead doesn&#x27;t really hurt.<p>Also, modern TAGE branch predictors are scary accurate, well above 99% on most code (including unpredictable indirect jumps). Besides, the majority of branch prediction targets are already in the L1 cache, it only predicts them because it saw them recently.<p>The branch predictor in Apple&#x27;s M1 actually takes advantage of the latter fact. It doesn&#x27;t predict what address to fetch next, it predicts which cacheline in L1 holds the target. So you only actually get branch predictions for targets in L1.</div><br/></div></div></div></div><div id="41082346" class="c"><input type="checkbox" id="c-41082346" checked=""/><div class="controls bullet"><span class="by">deadmutex</span><span>|</span><a href="#41082274">parent</a><span>|</span><a href="#41083423">prev</a><span>|</span><a href="#41082284">next</a><span>|</span><label class="collapse" for="c-41082346">[-]</label><label class="expand" for="c-41082346">[2 more]</label></div><br/><div class="children"><div class="content">You can check out the seminal paper linked in the article. Or start by summarizing the paper with Gemini, Claude, ChatGPT, etc. to get a high level overview (and then confirm the answer by reading the paper).</div><br/><div id="41082703" class="c"><input type="checkbox" id="c-41082703" checked=""/><div class="controls bullet"><span class="by">coherentpony</span><span>|</span><a href="#41082274">root</a><span>|</span><a href="#41082346">parent</a><span>|</span><a href="#41082284">next</a><span>|</span><label class="collapse" for="c-41082703">[-]</label><label class="expand" for="c-41082703">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;link.springer.com&#x2F;article&#x2F;10.1007&#x2F;s10676-024-09775-5" rel="nofollow">https:&#x2F;&#x2F;link.springer.com&#x2F;article&#x2F;10.1007&#x2F;s10676-024-09775-5</a></div><br/></div></div></div></div></div></div><div id="41082284" class="c"><input type="checkbox" id="c-41082284" checked=""/><div class="controls bullet"><span class="by">Szpadel</span><span>|</span><a href="#41082274">prev</a><span>|</span><a href="#41083221">next</a><span>|</span><label class="collapse" for="c-41082284">[-]</label><label class="expand" for="c-41082284">[27 more]</label></div><br/><div class="children"><div class="content">that&#x27;s probably bad idea but I would like to learn why:<p>why when we have a conditional branch we cannot just fetch and prepare instructions for both possible branches and then discard the incorrect one?<p>is this that much harder or there are other reasons that makes this not worth it</div><br/><div id="41082615" class="c"><input type="checkbox" id="c-41082615" checked=""/><div class="controls bullet"><span class="by">swatcoder</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082392">next</a><span>|</span><label class="collapse" for="c-41082615">[-]</label><label class="expand" for="c-41082615">[11 more]</label></div><br/><div class="children"><div class="content">Because it&#x27;s rare for a branch result to be random. The compiler&#x2F;runtime&#x2F;cpu&#x2F;etc can often guess which result is more likely, and correctly not do the extra work in the first place, and so that&#x27;s usually the better strategy than spending silicon and heat on the wrong answer just in case.<p>I think a lot of people don&#x27;t have an intuition about how accurate branch prediction can be, but if you look at your own code, you&#x27;ll quickly realize &quot;well, yeah, control flow is almost always going to go this way and we just have  this branch so we can handle the exceptional case&quot; -- compilers can often deduce this pretty well themselves now, and cpus&#x2F;jits&#x2F;runtimes can develop some pretty impressive heuristics as well, and when all those fail you can often add explicit hints in your code that tell your compiler&#x2F;etc what <i>you</i> expect if they can&#x27;t guess.</div><br/><div id="41082777" class="c"><input type="checkbox" id="c-41082777" checked=""/><div class="controls bullet"><span class="by">branko_d</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082615">parent</a><span>|</span><a href="#41082392">next</a><span>|</span><label class="collapse" for="c-41082777">[-]</label><label class="expand" for="c-41082777">[10 more]</label></div><br/><div class="children"><div class="content">&gt; it&#x27;s rare for a branch result to be random<p>How rare, though?<p>QuickSort has fundamentally unpredictable branches, and it’s a pretty widely used algorithm. Binary search, B-trees also come to mind.</div><br/><div id="41082843" class="c"><input type="checkbox" id="c-41082843" checked=""/><div class="controls bullet"><span class="by">kllrnohj</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082777">parent</a><span>|</span><a href="#41083398">next</a><span>|</span><label class="collapse" for="c-41082843">[-]</label><label class="expand" for="c-41082843">[6 more]</label></div><br/><div class="children"><div class="content">Binary searching is quite slow and should be used sparingly but not because of branch misprediction necessarily but because of memory stalls - you&#x27;re almost always guaranteed to have a cache miss during the search. Similarly for B-trees it&#x27;s going to be memory stalls that you&#x27;re probably more focused on addressing, not branch mispredicts.</div><br/><div id="41082959" class="c"><input type="checkbox" id="c-41082959" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082843">parent</a><span>|</span><a href="#41083144">next</a><span>|</span><label class="collapse" for="c-41082959">[-]</label><label class="expand" for="c-41082959">[4 more]</label></div><br/><div class="children"><div class="content">This probably depends on the size of the area to be searched, and just how hot that region is. After all, if it&#x27;s fairly small, there won&#x27;t be any cache misses, and the data structure does use less memory than a typical hash table, which is itself an advantage.</div><br/><div id="41083002" class="c"><input type="checkbox" id="c-41083002" checked=""/><div class="controls bullet"><span class="by">orf</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082959">parent</a><span>|</span><a href="#41083144">next</a><span>|</span><label class="collapse" for="c-41083002">[-]</label><label class="expand" for="c-41083002">[3 more]</label></div><br/><div class="children"><div class="content">If the size of the data is small, a linear search through a contiguous array is going to be far faster than anything more complex.</div><br/><div id="41083392" class="c"><input type="checkbox" id="c-41083392" checked=""/><div class="controls bullet"><span class="by">emn13</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41083002">parent</a><span>|</span><a href="#41084085">next</a><span>|</span><label class="collapse" for="c-41083392">[-]</label><label class="expand" for="c-41083392">[1 more]</label></div><br/><div class="children"><div class="content">Yep; though we&#x27;d have to test a few cases to figure out what the cutoffs are here, and if there&#x27;s any middle ground left for a divide-and-conquer strategy.<p>It&#x27;s also definitely going to depend on the cost of the hash function and comparison function - for something like strings, where those can be quite expensive, binary search probably has a better chance of applicability than for guid&#x27;s say.</div><br/></div></div><div id="41084085" class="c"><input type="checkbox" id="c-41084085" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41083002">parent</a><span>|</span><a href="#41083392">prev</a><span>|</span><a href="#41083144">next</a><span>|</span><label class="collapse" for="c-41084085">[-]</label><label class="expand" for="c-41084085">[1 more]</label></div><br/><div class="children"><div class="content">Well, it depends on how expensive your comparison is compared to a cache miss.</div><br/></div></div></div></div></div></div><div id="41083144" class="c"><input type="checkbox" id="c-41083144" checked=""/><div class="controls bullet"><span class="by">barrkel</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082843">parent</a><span>|</span><a href="#41082959">prev</a><span>|</span><a href="#41083398">next</a><span>|</span><label class="collapse" for="c-41083144">[-]</label><label class="expand" for="c-41083144">[1 more]</label></div><br/><div class="children"><div class="content">B-trees are cache friendly, spending more time doing linear scans at each level to keep the tree shallow, and thus indirection less frequent. They&#x27;re designed for high latency indirection - loading pages from spinning rust.</div><br/></div></div></div></div><div id="41083398" class="c"><input type="checkbox" id="c-41083398" checked=""/><div class="controls bullet"><span class="by">eyegor</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082777">parent</a><span>|</span><a href="#41082843">prev</a><span>|</span><a href="#41084350">next</a><span>|</span><label class="collapse" for="c-41083398">[-]</label><label class="expand" for="c-41083398">[1 more]</label></div><br/><div class="children"><div class="content">Also happens to be why quicksort loses to almost anything else on small arrays, even bubble sort</div><br/></div></div><div id="41084350" class="c"><input type="checkbox" id="c-41084350" checked=""/><div class="controls bullet"><span class="by">sjburt</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082777">parent</a><span>|</span><a href="#41083398">prev</a><span>|</span><a href="#41083658">next</a><span>|</span><label class="collapse" for="c-41084350">[-]</label><label class="expand" for="c-41084350">[1 more]</label></div><br/><div class="children"><div class="content">In benchmarks, branch predictors guess correctly 90-95% of the time.</div><br/></div></div><div id="41083658" class="c"><input type="checkbox" id="c-41083658" checked=""/><div class="controls bullet"><span class="by">jayd16</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082777">parent</a><span>|</span><a href="#41084350">prev</a><span>|</span><a href="#41082392">next</a><span>|</span><label class="collapse" for="c-41083658">[-]</label><label class="expand" for="c-41083658">[1 more]</label></div><br/><div class="children"><div class="content">Loops are usually much more one way than the other.</div><br/></div></div></div></div></div></div><div id="41082392" class="c"><input type="checkbox" id="c-41082392" checked=""/><div class="controls bullet"><span class="by">sapiogram</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082615">prev</a><span>|</span><a href="#41084991">next</a><span>|</span><label class="collapse" for="c-41082392">[-]</label><label class="expand" for="c-41082392">[1 more]</label></div><br/><div class="children"><div class="content">Disclaimer: I don&#x27;t work in this field, just an enthusiast.<p>As far as I can tell, branch predictors have always been too good for it to be worth it. Moderns CPUs have instruction reorder buffers that are hundreds of instructions deep, so even if only 8 of those instructions are conditional jumps, there&#x27;s 256 different paths your program could take. If your branch predictor predicts all 8 correctly &gt;50% of the time (It does), doing 256x the work to cover your ass is not worth it.</div><br/></div></div><div id="41084991" class="c"><input type="checkbox" id="c-41084991" checked=""/><div class="controls bullet"><span class="by">phire</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082392">prev</a><span>|</span><a href="#41083128">next</a><span>|</span><label class="collapse" for="c-41084991">[-]</label><label class="expand" for="c-41084991">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a sub-optimal strategy.<p>A modern TAGE branch predictor is correct well over 99% of the time. So those extra instructions for the other side of the branch are almost always discarded.<p>Worse, the frontend is fetching dozens of branches ahead of where the backend can actually confirm which direction to take. What are you going to do at the next branch, start decoding four possible branches? then 8, 16, 32 possible branches? Remember, most of the time you are going to throw it away.<p>If you actually have the hardware to fetch from multiple instruction streams in parallel (which Intel&#x27;s Gracemont&#x2F;Goldmont&#x2F;Skymont and now AMDs Zen 5 do), the better strategy is to assume your branch predictor is actually correct 100% of the time. Follow one side of the branch, then the one after it.<p>Intel&#x27;s Skymont actually decodes the next 3 branch targets in parallel because it has three decoders, each 3-wide. Intel actually introduce fake branches to break up large blocks of code, so that all three decoders are always active decoding different part of the upcoming instruction stream. The three uop streams are later merged, allowing Skymont to maintain an effect decode bandwidth of 9 instructions per cycle.<p>If you executed both sides of the branch, you are only slightly reducing the branch misspredit delay in the rare case the branch prediction was wrong. Instead, by executing one side the next two or three predictions, Intel and AMD can make multiple decoders do work in parallel. Intel are doing 9-wide with three simpler 3-wide decoders, and AMD can do 8-wide with two simpler 4-wide decoders.</div><br/></div></div><div id="41083128" class="c"><input type="checkbox" id="c-41083128" checked=""/><div class="controls bullet"><span class="by">ithkuil</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41084991">prev</a><span>|</span><a href="#41082786">next</a><span>|</span><label class="collapse" for="c-41083128">[-]</label><label class="expand" for="c-41083128">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s called speculative execution and IIRC all modern CPUs are doing it.<p>It requires more silicon to hold more microarchitectural state and more execution units to fully exploit the technique, but superscalar CPUs already have those since they are essential to exploit instruction level parallelism in non-branchy code. The rest is &quot;just&quot; a lot of headaches to handle complicated stuff such as aliasing, interrupts, ... But hardware engineers are such wizards they can do these things too.<p>Turns out however that speculative execution opens up a possibility of abusing a cache timing side channel to extract information from data touched by branches of code that has been only speculatively executed but whose architectural side effects were not committed (i.e. not &quot;really&quot; executed).<p>Which includes code that had been explicitly not executed because of a conditional check (e.g. permissions, ...)<p>A familiar instance of such an attack is Spectre [1]<p>1: <a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Spectre_(security_vulnerability)" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Spectre_(security_vulnerabil...</a></div><br/></div></div><div id="41082786" class="c"><input type="checkbox" id="c-41082786" checked=""/><div class="controls bullet"><span class="by">MBCook</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41083128">prev</a><span>|</span><a href="#41082372">next</a><span>|</span><label class="collapse" for="c-41082786">[-]</label><label class="expand" for="c-41082786">[1 more]</label></div><br/><div class="children"><div class="content">We reached 90% accuracy decades ago. Depending on workload modern chips can do way better.<p>So basically it’s just nowhere near worth it. Much better to use those chip resources for another thread or core.</div><br/></div></div><div id="41082372" class="c"><input type="checkbox" id="c-41082372" checked=""/><div class="controls bullet"><span class="by">wmf</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082786">prev</a><span>|</span><a href="#41082746">next</a><span>|</span><label class="collapse" for="c-41082372">[-]</label><label class="expand" for="c-41082372">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a huge waste of energy and in some cases it would even be slower because you&#x27;d execute more instructions overall. If the branch mispredict rate is around 1% it&#x27;s simply not worth paying a penalty 99% of the time to get a gain 1% of the time. Maybe it would be worth doing on low-confidence branches.</div><br/><div id="41083605" class="c"><input type="checkbox" id="c-41083605" checked=""/><div class="controls bullet"><span class="by">kolbe</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082372">parent</a><span>|</span><a href="#41082549">next</a><span>|</span><label class="collapse" for="c-41083605">[-]</label><label class="expand" for="c-41083605">[1 more]</label></div><br/><div class="children"><div class="content">The vast vast vast majority of instruction pipelines are sparse. You can pack in non-dependent instructions essentially for free.</div><br/></div></div></div></div><div id="41082746" class="c"><input type="checkbox" id="c-41082746" checked=""/><div class="controls bullet"><span class="by">eigenform</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082372">prev</a><span>|</span><a href="#41083479">next</a><span>|</span><label class="collapse" for="c-41082746">[-]</label><label class="expand" for="c-41082746">[1 more]</label></div><br/><div class="children"><div class="content">Most branches are biased one way or the other. &quot;Fetching down both paths&quot; means not exploiting any information you might have gathered about a branch being biased - I think that would be equivalent to randomly predicting the branch (except for it would cost <i>more</i> than a random predictor because you&#x27;re actually fetching both ways instead of just one).</div><br/></div></div><div id="41082688" class="c"><input type="checkbox" id="c-41082688" checked=""/><div class="controls bullet"><span class="by">0x000xca0xfe</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41083479">prev</a><span>|</span><a href="#41082302">next</a><span>|</span><label class="collapse" for="c-41082688">[-]</label><label class="expand" for="c-41082688">[2 more]</label></div><br/><div class="children"><div class="content">- Side effects; how do you handle two different writes to memory?<p>- Double the execution units; very expensive for wide vector units<p>- Massive waste of energy as half the resources will always be wasted no matter what<p>- Bad scaling, i.e. four branches ahead would require 16x the resources</div><br/><div id="41082966" class="c"><input type="checkbox" id="c-41082966" checked=""/><div class="controls bullet"><span class="by">isotypic</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082688">parent</a><span>|</span><a href="#41082302">next</a><span>|</span><label class="collapse" for="c-41082966">[-]</label><label class="expand" for="c-41082966">[1 more]</label></div><br/><div class="children"><div class="content">Handling two different writes to memory is not really a concern - existing speculative&#x2F;out of order processors already solve this issue by completing (perform architectural side effects) instructions in-order. So even if two writes are made, one in each branch, by the time the write is meant to be completed, the prior branch is resolved and we know which write is actually meant to be made and the bad one can be discarded.<p>Doubling the execution units also isn&#x27;t strictly needed - you can use the existing out-of-order core to send two sets of instructions through the same functional units. There will be more contention for the resources, possibly causing stalls, but you don&#x27;t need to fully double everything.<p>Things similar to this idea are already done in processors - simultaneous multithreading, early branch resolution, conditional instructions, are all ideas that have similar implementation difficulties. So the reason this specific idea is not done is more in line with your last two points rather than the first two.</div><br/></div></div></div></div><div id="41082302" class="c"><input type="checkbox" id="c-41082302" checked=""/><div class="controls bullet"><span class="by">dymk</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082688">prev</a><span>|</span><a href="#41082755">next</a><span>|</span><label class="collapse" for="c-41082302">[-]</label><label class="expand" for="c-41082302">[3 more]</label></div><br/><div class="children"><div class="content">Transistor count; now you have to duplicate all the decode and speculative execution circuitry for both possible branches</div><br/><div id="41082625" class="c"><input type="checkbox" id="c-41082625" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082302">parent</a><span>|</span><a href="#41082755">next</a><span>|</span><label class="collapse" for="c-41082625">[-]</label><label class="expand" for="c-41082625">[2 more]</label></div><br/><div class="children"><div class="content">No, the same circuits would execute them interleaved just like they execute multiple hardware threads now</div><br/><div id="41082893" class="c"><input type="checkbox" id="c-41082893" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#41082284">root</a><span>|</span><a href="#41082625">parent</a><span>|</span><a href="#41082755">next</a><span>|</span><label class="collapse" for="c-41082893">[-]</label><label class="expand" for="c-41082893">[1 more]</label></div><br/><div class="children"><div class="content">With the SMT core count having to be one less.</div><br/></div></div></div></div></div></div><div id="41082755" class="c"><input type="checkbox" id="c-41082755" checked=""/><div class="controls bullet"><span class="by">bsder</span><span>|</span><a href="#41082284">parent</a><span>|</span><a href="#41082302">prev</a><span>|</span><a href="#41083221">next</a><span>|</span><label class="collapse" for="c-41082755">[-]</label><label class="expand" for="c-41082755">[1 more]</label></div><br/><div class="children"><div class="content">&gt; why when we have a conditional branch we cannot just fetch and prepare instructions for both possible branches and then discard the incorrect one?<p>We actually do that.  It&#x27;s called a GPU.  And it sucks for general code.</div><br/></div></div></div></div><div id="41083221" class="c"><input type="checkbox" id="c-41083221" checked=""/><div class="controls bullet"><span class="by">phkahler</span><span>|</span><a href="#41082284">prev</a><span>|</span><a href="#41083756">next</a><span>|</span><label class="collapse" for="c-41083221">[-]</label><label class="expand" for="c-41083221">[8 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Now when Zen 5 has two threads active, the decode clusters and the accompanying fetch pipes are statically partitioned.<p>This sounds like a big boost for hyper threading performance. My Zen1 gets about 25 percent faster due to HT. Has anyone tested the newer ones in this regard?</div><br/><div id="41083731" class="c"><input type="checkbox" id="c-41083731" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#41083221">parent</a><span>|</span><a href="#41083756">next</a><span>|</span><label class="collapse" for="c-41083731">[-]</label><label class="expand" for="c-41083731">[7 more]</label></div><br/><div class="children"><div class="content">High SMT speedups aren’t a good thing, because those are pipeline bubbles - resources that can’t be saturated by the first thread.<p>The ideal speedup from SMT is 0% because you’d be getting full output for a single thread. Like if you got a 50% speedup from SMT, in an ideal world that means a single thread could run 50% faster than it is, but it’s being stalled by pipeline bubbles.</div><br/><div id="41084975" class="c"><input type="checkbox" id="c-41084975" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41083221">root</a><span>|</span><a href="#41083731">parent</a><span>|</span><a href="#41083917">next</a><span>|</span><label class="collapse" for="c-41084975">[-]</label><label class="expand" for="c-41084975">[1 more]</label></div><br/><div class="children"><div class="content">Yes, while in my older tests on Intel Skylake derivatives I have also obtained SMT speedups around 25%, on the newer Zen 3 (a 5900X) I have obtained at most a 20% speedup in the most SMT friendly task that I have ever encountered, i.e. the compilation of a big software project (the comparison being done between optimal parameters for SMT disabled vs. SMT enabled, which for a 5900X have been determined to be &quot;make -j13&quot; vs. &quot;make -j24&quot;).<p>An example of a multithreaded benchmark that is not SMT friendly is the GeekBench 6 multithreaded test, where Zen 3 with SMT disabled (12 threads on a 5900X) is slightly faster than with SMT enabled (24 threads on a 5900X).</div><br/></div></div><div id="41083917" class="c"><input type="checkbox" id="c-41083917" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#41083221">root</a><span>|</span><a href="#41083731">parent</a><span>|</span><a href="#41084975">prev</a><span>|</span><a href="#41083756">next</a><span>|</span><label class="collapse" for="c-41083917">[-]</label><label class="expand" for="c-41083917">[5 more]</label></div><br/><div class="children"><div class="content">For a fully compute-bound workload, you&#x27;re certainly correct.<p>That&#x27;s rare though. All it takes is a couple stalls waiting on memory where a second thread is able to make progress to make that &quot;ideal speedup&quot; certainly be nonzero.</div><br/><div id="41083948" class="c"><input type="checkbox" id="c-41083948" checked=""/><div class="controls bullet"><span class="by">paulmd</span><span>|</span><a href="#41083221">root</a><span>|</span><a href="#41083917">parent</a><span>|</span><a href="#41083756">next</a><span>|</span><label class="collapse" for="c-41083948">[-]</label><label class="expand" for="c-41083948">[4 more]</label></div><br/><div class="children"><div class="content">Regardless though why would it potentially being higher in newer architectures be viewed as a good thing?</div><br/><div id="41084401" class="c"><input type="checkbox" id="c-41084401" checked=""/><div class="controls bullet"><span class="by">Remnant44</span><span>|</span><a href="#41083221">root</a><span>|</span><a href="#41083948">parent</a><span>|</span><a href="#41085238">next</a><span>|</span><label class="collapse" for="c-41084401">[-]</label><label class="expand" for="c-41084401">[2 more]</label></div><br/><div class="children"><div class="content">Because most code is not running anywhere near saturation of the available resources, and the problem is only getting worse as cores get wider. I mean, look at the Zen5 block diagram - there are 6 ALUs and 4 AGUs on the integer side alone! That&#x27;s almost two entire Zen1 cores worth of execution resources, which is pretty amazing. Very, very little real world code is going to be able to get anywhere near saturating that every cycle. SMT helps improve the utilization of the execution resources that have already been paid for in the core.<p>I&#x27;ll give another example from my own experience. I write a lot of code in the computer graphics domain. Some of the more numeric-oriented routines are able to saturate the execution resources, and get approximately 0% speedup from SMT.<p>Importantly though, there are other routines that make heavy use of lookup tables. Even though the tables reside completely within L1 cache, there are some really long dependency chains where the 3&#x2F;4 cycle wait for L1 chains and causes some really low utilization of ALUs. Or at least, that&#x27;s my theory. :) Regardless in that code running SMT provides about a 30% speedup &quot;for free&quot; which is quite impressive.<p>I was uncertain of if SMT had a future for a while, but I think for x86 in general it provides some pretty significant gains, for a design complexity that has already been &#x27;paid&#x27; for.</div><br/><div id="41085021" class="c"><input type="checkbox" id="c-41085021" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41083221">root</a><span>|</span><a href="#41084401">parent</a><span>|</span><a href="#41085238">next</a><span>|</span><label class="collapse" for="c-41085021">[-]</label><label class="expand" for="c-41085021">[1 more]</label></div><br/><div class="children"><div class="content">With the continuous improvement of out-of-order execution, the SMT gains have been diminishing from Zen 1 to Zen 4.<p>However you are right that Zen 5, like also the Intel Lion Cove core, has a jump in the number of available execution resources and it is likely that out-of-order execution will not be enough to keep them busy.<p>This may lead to a higher SMT gain on Zen 5, perhaps on average around 30% (from typically under 20% with Zen 3 or Zen 4), like in the Intel presentation where they compared a Lion Cove without SMT with a Lion Cove with SMT. In the context of a hybrid CPU, where the MT-performance can be better provided by efficient cores than by SMT, Intel has chosen to omit SMT, for better PPA (performance per power and area), but in the context of their future server CPU with big cores, they will use cores with SMT (and with wider SIMD execution units, to increase the energy efficiency).</div><br/></div></div></div></div><div id="41085238" class="c"><input type="checkbox" id="c-41085238" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#41083221">root</a><span>|</span><a href="#41083948">parent</a><span>|</span><a href="#41084401">prev</a><span>|</span><a href="#41083756">next</a><span>|</span><label class="collapse" for="c-41085238">[-]</label><label class="expand" for="c-41085238">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Regardless though why would it potentially being higher in newer architectures be viewed as a good thing?<p>Because SMT getting faster is a nearly free side-effect.  We didn&#x27;t add extra units to speed up SMT at the cost of single-thread speed.  We added extra units to speed up the single thread, and they just happened to speed up SMT even more (at least for the purpose of this theoretical).  That&#x27;s better than speeding up SMT the same percent, or not speeding up SMT at all.<p>Imagine if I took a CPU and just made SMT slower, no other changes.  That would be a bad thing even though it gets the speedup closer to 0%, right?  And then if I undo that it&#x27;s a good thing, right?</div><br/></div></div></div></div></div></div></div></div></div></div><div id="41083756" class="c"><input type="checkbox" id="c-41083756" checked=""/><div class="controls bullet"><span class="by">vegabook</span><span>|</span><a href="#41083221">prev</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41083756">[-]</label><label class="expand" for="c-41083756">[8 more]</label></div><br/><div class="children"><div class="content">Now all it needs is more memory bandwidth, because those two memory channels on the consumer AM5 socket are pathetic given the compute this will deliver, and especially in comparison with even the most basic ASi.<p>I moved to an M2 Max from a chunky Zen setup and it&#x27;s a revelation how much the memory bandwidth improvement accelerates intensive data work. Also for heavy-ish multitasking the Zen setup&#x27;s narrow memory pipe would often choke.</div><br/><div id="41084437" class="c"><input type="checkbox" id="c-41084437" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#41083756">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084437">[-]</label><label class="expand" for="c-41084437">[7 more]</label></div><br/><div class="children"><div class="content">There are very few applications that are actually memory bandwidth bound but aren&#x27;t more suited to a GPU than a CPU.<p>The reason people have been looking at Apple Silicon for LLMs in particular is that even though they <i>are</i> more suited to GPUs, they also require a lot of VRAM and NVIDIA charges an extortionate amount of money for GPUs with a lot of VRAM.<p>What AMD should really do if they want to steal NVIDIA&#x27;s thunder is to sell consumer GPUs with 64-128GB of VRAM.</div><br/><div id="41084473" class="c"><input type="checkbox" id="c-41084473" checked=""/><div class="controls bullet"><span class="by">The_Colonel</span><span>|</span><a href="#41083756">root</a><span>|</span><a href="#41084437">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084473">[-]</label><label class="expand" for="c-41084473">[6 more]</label></div><br/><div class="children"><div class="content">&gt; What AMD should really do if they want to steal NVIDIA&#x27;s thunder is to sell consumer GPUs with 64-128GB of VRAM.<p>For gaming, it&#x27;s an overkill (esp. given the price), it would be useful only for LLM enthusiasts which isn&#x27;t that big of a market.</div><br/><div id="41084621" class="c"><input type="checkbox" id="c-41084621" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#41083756">root</a><span>|</span><a href="#41084473">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084621">[-]</label><label class="expand" for="c-41084621">[5 more]</label></div><br/><div class="children"><div class="content">Then how come so many people are buying GPUs with that amount of VRAM for extraordinary amounts of money?<p>Nobody said it was for gaming. Though of course consumers could use it for both.</div><br/><div id="41084722" class="c"><input type="checkbox" id="c-41084722" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#41083756">root</a><span>|</span><a href="#41084621">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084722">[-]</label><label class="expand" for="c-41084722">[4 more]</label></div><br/><div class="children"><div class="content">But AMD already offer GPUs with that amount of VRAM for extraordinary amounts of money, so there&#x27;ll be no change?<p>And from what I hear they&#x27;re selling every one they&#x27;re producing, even to the level where there&#x27;s a ~6 month waiting list. So even if they reduced the price, the only difference would be that the list would get longer and AMD got less money. No more devices would actually make into people&#x27;s hands, being production limited.</div><br/><div id="41084817" class="c"><input type="checkbox" id="c-41084817" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#41083756">root</a><span>|</span><a href="#41084722">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084817">[-]</label><label class="expand" for="c-41084817">[3 more]</label></div><br/><div class="children"><div class="content">The production limit isn&#x27;t in the amount of VRAM. They could offer any of their existing consumer GPUs in versions with more VRAM with prices that add twice their own cost for the extra VRAM (but still far less than the datacenter versions) and thereby sell the same GPUs for higher margins.<p>This might even leave gamers with <i>more</i> GPUs, because right now there are people buying e.g. four 24GB consumer GPUs to run a large model, and they could instead buy one 96GB GPU and leave three more for gamers.</div><br/><div id="41084958" class="c"><input type="checkbox" id="c-41084958" checked=""/><div class="controls bullet"><span class="by">kimixa</span><span>|</span><a href="#41083756">root</a><span>|</span><a href="#41084817">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084958">[-]</label><label class="expand" for="c-41084958">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re not really saying &quot;They&#x27;re not offering a product&quot; - so much &quot;They&#x27;re not offering a product at a price I want&quot;, which is really a very different statement.<p>They&#x27;re intentionally differentiated in the market and marked up due to the relatively higher R&amp;D costs from targeting a <i>much</i> smaller market niche, with it&#x27;s own demands on development. I doubt you&#x27;ll just be running games on them, after all.<p>If that is your niche, AMD is effectively saying they don&#x27;t want your custom at that price. No point selling products that lose money, after all. AMD have done it before - arguably are doing it right now as their graphics BU <i>lost</i> money last year if you exclude APUs and consoles - and it went badly each time (despite what some people say about &quot;Market Share!&quot; on some internet forums).</div><br/><div id="41084968" class="c"><input type="checkbox" id="c-41084968" checked=""/><div class="controls bullet"><span class="by">AnthonyMouse</span><span>|</span><a href="#41083756">root</a><span>|</span><a href="#41084958">parent</a><span>|</span><a href="#41083805">next</a><span>|</span><label class="collapse" for="c-41084968">[-]</label><label class="expand" for="c-41084968">[1 more]</label></div><br/><div class="children"><div class="content">That strategy doesn&#x27;t win though. The enterprise is going to buy the enterprise GPU anyway because they&#x27;re spending someone else&#x27;s money and it&#x27;s a tax write off and the enterprise GPUs are faster and have ECC memory in addition to having more VRAM. But giving something for hobbyists to play with is how you build an ecosystem. So not only do they get higher margins on their consumer GPUs, they get more code written for their architecture, which lets them sell more of the <i>expensive</i> GPUs.<p>Not doing that is making a mistake.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="41083805" class="c"><input type="checkbox" id="c-41083805" checked=""/><div class="controls bullet"><span class="by">im3w1l</span><span>|</span><a href="#41083756">prev</a><span>|</span><a href="#41083748">next</a><span>|</span><label class="collapse" for="c-41083805">[-]</label><label class="expand" for="c-41083805">[2 more]</label></div><br/><div class="children"><div class="content">I still ahve no idea what a 2-ahead branch predictor is.</div><br/><div id="41085076" class="c"><input type="checkbox" id="c-41085076" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41083805">parent</a><span>|</span><a href="#41083748">next</a><span>|</span><label class="collapse" for="c-41085076">[-]</label><label class="expand" for="c-41085076">[1 more]</label></div><br/><div class="children"><div class="content">You can better start by reading the old research papers linked in the article.<p>In general, the older research papers suppose that the reader knows much less about such subjects, because they were still much more niche knowledge at that time.</div><br/></div></div></div></div><div id="41083748" class="c"><input type="checkbox" id="c-41083748" checked=""/><div class="controls bullet"><span class="by">ryukoposting</span><span>|</span><a href="#41083805">prev</a><span>|</span><a href="#41083962">next</a><span>|</span><label class="collapse" for="c-41083748">[-]</label><label class="expand" for="c-41083748">[1 more]</label></div><br/><div class="children"><div class="content">4 years after graduating college, my decision to dive into computer architecture classes has borne no fruit except my ability to loosely understand what writeups like this are talking about. But, I guess that&#x27;s the point, isn&#x27;t it? This is fascinating stuff, whether or not I need to know it.</div><br/></div></div><div id="41083962" class="c"><input type="checkbox" id="c-41083962" checked=""/><div class="controls bullet"><span class="by">brcmthrowaway</span><span>|</span><a href="#41083748">prev</a><span>|</span><label class="collapse" for="c-41083962">[-]</label><label class="expand" for="c-41083962">[2 more]</label></div><br/><div class="children"><div class="content">Did the paper author get a cut from AMD?</div><br/><div id="41085114" class="c"><input type="checkbox" id="c-41085114" checked=""/><div class="controls bullet"><span class="by">adrian_b</span><span>|</span><a href="#41083962">parent</a><span>|</span><label class="collapse" for="c-41085114">[-]</label><label class="expand" for="c-41085114">[1 more]</label></div><br/><div class="children"><div class="content">They have no reason to give him any cut.<p>On the contrary, he points that one of their most important innovations is not that innovative, because it was analyzed in detail almost 30 years ago.<p>Before AMD, Intel had started to use such multiple decoders in their Atom cores, now rebranded as E-cores (efficient cores). The multiple decoders have been first used in Tremont (2020), then in Gracemont (2021) and Crestmont (2023), and now in Skymont (2024).<p>It is hard to predict which of the decoders of Skymont (triple 3-instruction decoder) or of Zen 5 (double 4-instruction decoder) is better. AMD has made the choice of the double decoder because their core uses SMT, and a double decoder is easy to be partitioned into two decoders when both simultaneous threads are active.</div><br/></div></div></div></div></div></div></div></div></div></body></html>