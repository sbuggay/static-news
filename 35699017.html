<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="apple-mobile-web-app-capable" content="yes"/><link rel="preload" href="styles.css?v=1682567893686" as="style"/><link rel="stylesheet" href="styles.css?v=1682567893686"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/bradleyboy/tuql">Tuql: Automatically create a GraphQL server from a SQLite database</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>29 comments</span></div><br/><div><div id="35718889" class="c"><input type="checkbox" id="c-35718889" checked=""/><div class="controls bullet"><span class="by">davidmccabe</span><span>|</span><a href="#35716118">next</a><span>|</span><label class="collapse" for="c-35718889">[-]</label><label class="expand" for="c-35718889">[6 more]</label></div><br/><div class="children"><div class="content">GraphQL is really intended to model UI concepts rather than directly exposing your database schema.<p>First of all, your GraphQL schema is basically append-only due to older clients that may remain in the wild. So you don&#x27;t want to expose implementation details that may change.<p>Second, you want to write client code that handles mutations. This is easier if the data the client receives is organized in a UI-centric way. I&#x27;ll give you a simple example that came up at work recently: a single conceptual category (a &quot;user account&quot;) that, due to implementation details, was spread across two different tables with different columns. Because the GraphQL schema in this case mapped each table to its own GraphQL type, somebody was then able to write client code that only handled one type and not the other, causing an inconsistent UI.<p>I would suggest thinking carefully about your GraphQL schema, treating it as an API, and not auto-generating it. Of course, you want it to be convenient to construct, just not fully automatic and thoughtless.</div><br/><div id="35721394" class="c"><input type="checkbox" id="c-35721394" checked=""/><div class="controls bullet"><span class="by">ricardobeat</span><span>|</span><a href="#35718889">parent</a><span>|</span><a href="#35720937">next</a><span>|</span><label class="collapse" for="c-35721394">[-]</label><label class="expand" for="c-35721394">[3 more]</label></div><br/><div class="children"><div class="content">I imagine a lot of people don&#x27;t share this particular opinion. The problem GraphQL was created to solve is precisely the ability to compose ad-hoc queries to feed into UI, without being tied to a particular data model or mapping. It allows applications to change at a faster pace without requiring centralized API modifications.<p>If you create those UI-centric models when exposing data through your GraphQL schemas, you just moved the modelling work elsewhere but haven&#x27;t actually facilitated anything, and it&#x27;s still centralized. At this point you&#x27;re better off embracing the &#x27;BFF&#x27; architecture and skipping GraphQL altogether.<p>There may be a useful middle ground (for example, ensuring a single User type), but it&#x27;s a slippery slope to stand on.</div><br/><div id="35721454" class="c"><input type="checkbox" id="c-35721454" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#35718889">root</a><span>|</span><a href="#35721394">parent</a><span>|</span><a href="#35722137">next</a><span>|</span><label class="collapse" for="c-35721454">[-]</label><label class="expand" for="c-35721454">[1 more]</label></div><br/><div class="children"><div class="content">I think if you look at it from the otherside it makes more sense.<p>A problem that is common is that we send these JSON blobs over the wire that aren&#x27;t purpose fit. So, with GraphQL, we can construct a query graph that makes the JSON blobs slimmer and more purpose fit, by constructing the queries to return the data we desire for some particular business reasons we need to represent in the UI, for instance.<p>I got the argument with mutations need to match things more closely, but I&#x27;d argue you can cross compose mutations w&#x2F; resolvers too.<p>I think this is what they&#x27;re getting at. Just throwing the database schema over the wall via GraphQL isn&#x27;t that much better than REST, and takes zero advantage of abilty to use revolvers to construct purpose built queries</div><br/></div></div></div></div><div id="35720937" class="c"><input type="checkbox" id="c-35720937" checked=""/><div class="controls bullet"><span class="by">no_wizard</span><span>|</span><a href="#35718889">parent</a><span>|</span><a href="#35721394">prev</a><span>|</span><a href="#35719768">next</a><span>|</span><label class="collapse" for="c-35720937">[-]</label><label class="expand" for="c-35720937">[1 more]</label></div><br/><div class="children"><div class="content">This is what I constantly tell people. Use GraphQL to efficiently create permutations of access so the data is shaped for the client more or less exactly how they need it. To that end, I often recommend that at least one UI developer is involved in approving schema changes and regularly dogfoods the GQL setup before its deployed.<p>I have been met with a lot of resistance around this notion for some reason.<p>To be honest, I fought the same argument with OpenAPI (Swagger) too.<p>API developers seemingly just want to chuck their schema over the wall and walk away</div><br/></div></div><div id="35719768" class="c"><input type="checkbox" id="c-35719768" checked=""/><div class="controls bullet"><span class="by">TheNewsIsHere</span><span>|</span><a href="#35718889">parent</a><span>|</span><a href="#35720937">prev</a><span>|</span><a href="#35716118">next</a><span>|</span><label class="collapse" for="c-35719768">[-]</label><label class="expand" for="c-35719768">[1 more]</label></div><br/><div class="children"><div class="content">I’ve been kicking around a project idea for years that would be a niche fit for these considerations. It’s effectively an extremely niche reference corpus of very field-specific data, effectively represented by JSON documents and having a few relationships that don’t require transactions. It wouldn’t be editable by clients at all. Every client would be nothing more than a consumer, and the database would be versioned and only edited by the maintainer.<p>That is certainly not a common use of web based APIs, to have an application that is read only every client, but the reason I came to this thread was because I’ve considered SQLite for this idea in the past.</div><br/></div></div></div></div><div id="35716118" class="c"><input type="checkbox" id="c-35716118" checked=""/><div class="controls bullet"><span class="by">minhazm</span><span>|</span><a href="#35718889">prev</a><span>|</span><a href="#35716813">next</a><span>|</span><label class="collapse" for="c-35716118">[-]</label><label class="expand" for="c-35716118">[6 more]</label></div><br/><div class="children"><div class="content">If your use case is read-only I suggest taking a look at roapi[1]. It supports multiple read frontends (GraphQL, SQL, REST) and many backends like SQLite, JSON, google sheets, MySQL, etc.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;roapi&#x2F;roapi">https:&#x2F;&#x2F;github.com&#x2F;roapi&#x2F;roapi</a></div><br/><div id="35716766" class="c"><input type="checkbox" id="c-35716766" checked=""/><div class="controls bullet"><span class="by">ewuhic</span><span>|</span><a href="#35716118">parent</a><span>|</span><a href="#35716813">next</a><span>|</span><label class="collapse" for="c-35716766">[-]</label><label class="expand" for="c-35716766">[5 more]</label></div><br/><div class="children"><div class="content">Is there anything similar that I could deploy to vercel? My usecase is API produced from JSON source, and I dont want a server for it, only static  assets.</div><br/><div id="35717295" class="c"><input type="checkbox" id="c-35717295" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#35716118">root</a><span>|</span><a href="#35716766">parent</a><span>|</span><a href="#35721064">next</a><span>|</span><label class="collapse" for="c-35717295">[-]</label><label class="expand" for="c-35717295">[1 more]</label></div><br/><div class="children"><div class="content">Datasette was designed for Vercel from the start. It&#x27;s a really great way of turning data into a read-only API, with both JSON and GraphQL endpoints.<p><a href="https:&#x2F;&#x2F;datasette.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;datasette.io&#x2F;</a><p>Demo here: <a href="https:&#x2F;&#x2F;datasette.simonwillison.net&#x2F;simonwillisonblog" rel="nofollow">https:&#x2F;&#x2F;datasette.simonwillison.net&#x2F;simonwillisonblog</a><p>GraphQL demo here: <a href="https:&#x2F;&#x2F;datasette.simonwillison.net&#x2F;graphql?query=%7B%0A%20%20blog_entry(sort_desc%3A%20created)%20%7B%0A%20%20%20%20nodes%20%7B%0A%20%20%20%20%20%20title%2C%0A%20%20%20%20%20%20created%2C%0A%20%20%20%20%20%20blog_entry_tags_list%20%7B%0A%20%20%20%20%20%20%20%20nodes%20%7B%0A%20%20%20%20%20%20%20%20%20%20tag_id%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20tag%0A%20%20%20%20%20%20%20%20%20%20%20%20blog_entry_tags_list%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20totalCount%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D" rel="nofollow">https:&#x2F;&#x2F;datasette.simonwillison.net&#x2F;graphql?query=%7B%0A%20%...</a><p>To deploy a SQLite database to Vercel with a GraphQL API:<p><pre><code>    brew install datasette
    datasette install datasette-publish-vercel
    datasette publish vercel mydatabase.db \
      --project my-new-vercel-project-name \
      --install datasette-graphql
</code></pre>
Here&#x27;s a tutorial on how to get data into that SQLite database in the first place: <a href="https:&#x2F;&#x2F;datasette.io&#x2F;tutorials&#x2F;clean-data" rel="nofollow">https:&#x2F;&#x2F;datasette.io&#x2F;tutorials&#x2F;clean-data</a></div><br/></div></div><div id="35721064" class="c"><input type="checkbox" id="c-35721064" checked=""/><div class="controls bullet"><span class="by">chatmasta</span><span>|</span><a href="#35716118">root</a><span>|</span><a href="#35716766">parent</a><span>|</span><a href="#35717295">prev</a><span>|</span><a href="#35717235">next</a><span>|</span><label class="collapse" for="c-35721064">[-]</label><label class="expand" for="c-35721064">[1 more]</label></div><br/><div class="children"><div class="content">You might like what we&#x27;re building with Seafowl [0], which is an open-source, single binary database you can deploy to the edge for executing cache-friendly queries (so e.g. you can deploy to fly.io free tier, load your data into it, and put Cloudflare in front of it to cache query results like any other HTTP response).<p>Here&#x27;s an example [1] multi-page site with Next.js and Seafowl.<p>[0] <a href="https:&#x2F;&#x2F;seafowl.io&#x2F;docs&#x2F;getting-started&#x2F;introduction" rel="nofollow">https:&#x2F;&#x2F;seafowl.io&#x2F;docs&#x2F;getting-started&#x2F;introduction</a><p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;splitgraph&#x2F;madatdata&#x2F;tree&#x2F;main&#x2F;examples&#x2F;react-nextjs-seafowl">https:&#x2F;&#x2F;github.com&#x2F;splitgraph&#x2F;madatdata&#x2F;tree&#x2F;main&#x2F;examples&#x2F;r...</a></div><br/></div></div><div id="35717235" class="c"><input type="checkbox" id="c-35717235" checked=""/><div class="controls bullet"><span class="by">MuffinFlavored</span><span>|</span><a href="#35716118">root</a><span>|</span><a href="#35716766">parent</a><span>|</span><a href="#35721064">prev</a><span>|</span><a href="#35716813">next</a><span>|</span><label class="collapse" for="c-35717235">[-]</label><label class="expand" for="c-35717235">[2 more]</label></div><br/><div class="children"><div class="content">Devil&#x27;s advocate: why can&#x27;t you deploy Dockerfile of roapi to Vercel (or fly.io)?<p>What is the defacto &quot;hobbyist tinker-er&quot; standard for &quot;I want to deploy this Docker thing into the cloud and play with it on the Internet&quot;? There&#x27;s got to be some one-click deploy solution where it goes to a Github repo, picks up a Helm chart, deploys it to a k8s cluster or something?</div><br/><div id="35717680" class="c"><input type="checkbox" id="c-35717680" checked=""/><div class="controls bullet"><span class="by">stepbeek</span><span>|</span><a href="#35716118">root</a><span>|</span><a href="#35717235">parent</a><span>|</span><a href="#35716813">next</a><span>|</span><label class="collapse" for="c-35717680">[-]</label><label class="expand" for="c-35717680">[1 more]</label></div><br/><div class="children"><div class="content">You can deploy a docker container to heroku, digitalocean app platform etc. no helm config required.</div><br/></div></div></div></div></div></div></div></div><div id="35716813" class="c"><input type="checkbox" id="c-35716813" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#35716118">prev</a><span>|</span><a href="#35719121">next</a><span>|</span><label class="collapse" for="c-35716813">[-]</label><label class="expand" for="c-35716813">[1 more]</label></div><br/><div class="children"><div class="content">Impressive how little code is involved here! This is really neat.<p>The biggest feature I can see that&#x27;s missing is pagination - it looks like this doesn&#x27;t have a way to retrieve e.g. ten results, then pass a next token to get back the next set.<p>Here&#x27;s how I implemented pagination in my similar datasette-graphql plugin (which also gives you a GraphQL API for an existing SQLite database): <a href="https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;datasette-graphql#pagination">https:&#x2F;&#x2F;github.com&#x2F;simonw&#x2F;datasette-graphql#pagination</a></div><br/></div></div><div id="35719121" class="c"><input type="checkbox" id="c-35719121" checked=""/><div class="controls bullet"><span class="by">ElectricalUnion</span><span>|</span><a href="#35716813">prev</a><span>|</span><a href="#35714534">next</a><span>|</span><label class="collapse" for="c-35719121">[-]</label><label class="expand" for="c-35719121">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The primary key column is named id or thing_id or thingId, where thing is the singular form of the table name.<p>Is it naming relations a plural word a common thing in practice?<p>I thought best-practice was to name relations either singular (as each tuple represents one entry) or uninflected (still singular for most words), specially when you&#x27;re not a fluent speaker of the language being used to name the relations of the database.<p>Plurals are often irregular for commonly used words, and the fact that this requires a external dependency ( <a href="https:&#x2F;&#x2F;github.com&#x2F;plurals&#x2F;pluralize">https:&#x2F;&#x2F;github.com&#x2F;plurals&#x2F;pluralize</a> ) to cover for some &quot;common plurals&quot; is telling that supporting this feature is a complex thing indeed - that would not be required in the first place with singular everywhere.</div><br/></div></div><div id="35714534" class="c"><input type="checkbox" id="c-35714534" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#35719121">prev</a><span>|</span><a href="#35714046">next</a><span>|</span><label class="collapse" for="c-35714534">[-]</label><label class="expand" for="c-35714534">[3 more]</label></div><br/><div class="children"><div class="content">I took a quick peek at the code and, unless I missed looking at big file somewhere, looks like it’s only around 550 lines of code.<p>That’s great if so. I haven’t looked at lines of code in any other graphql library but I’d guess there’d be far more.</div><br/><div id="35714872" class="c"><input type="checkbox" id="c-35714872" checked=""/><div class="controls bullet"><span class="by">VWWHFSfQ</span><span>|</span><a href="#35714534">parent</a><span>|</span><a href="#35714046">next</a><span>|</span><label class="collapse" for="c-35714872">[-]</label><label class="expand" for="c-35714872">[2 more]</label></div><br/><div class="children"><div class="content">pretty sure this is wrapping other libraries.   sequelize and graphql</div><br/><div id="35717301" class="c"><input type="checkbox" id="c-35717301" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#35714534">root</a><span>|</span><a href="#35714872">parent</a><span>|</span><a href="#35714046">next</a><span>|</span><label class="collapse" for="c-35717301">[-]</label><label class="expand" for="c-35717301">[1 more]</label></div><br/><div class="children"><div class="content">Aha, yes, you&#x27;re right. I see those in the package.json.</div><br/></div></div></div></div></div></div><div id="35714046" class="c"><input type="checkbox" id="c-35714046" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#35714534">prev</a><span>|</span><a href="#35718586">next</a><span>|</span><label class="collapse" for="c-35714046">[-]</label><label class="expand" for="c-35714046">[8 more]</label></div><br/><div class="children"><div class="content">Very cool, though I&#x27;m not sure how production-ready this is, given that there doesn&#x27;t seem to be a way to add authorization for certain fields &#x2F; queries.<p>Also, does the generated schema include the primary keys? Otherwise caching in the frontend might turn out to be difficult.</div><br/><div id="35714758" class="c"><input type="checkbox" id="c-35714758" checked=""/><div class="controls bullet"><span class="by">bradleyboy</span><span>|</span><a href="#35714046">parent</a><span>|</span><a href="#35714565">next</a><span>|</span><label class="collapse" for="c-35714758">[-]</label><label class="expand" for="c-35714758">[1 more]</label></div><br/><div class="children"><div class="content">Hey - I&#x27;m the author of tuql (if you can still call it authorship, I haven&#x27;t updated this library in a long time :) )<p>I originally wrote this to speed up prototyping &#x2F; development projects, I&#x27;d never recommend shipping this anywhere near production.</div><br/></div></div><div id="35714565" class="c"><input type="checkbox" id="c-35714565" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#35714046">parent</a><span>|</span><a href="#35714758">prev</a><span>|</span><a href="#35718586">next</a><span>|</span><label class="collapse" for="c-35714565">[-]</label><label class="expand" for="c-35714565">[6 more]</label></div><br/><div class="children"><div class="content">Which graphql frameworks do handle auth? It’s a genuine question, I don’t know the space but had to rule out graphql in its early days for a seeming lack in this area. But I’ve got a project now where it might be a great fit.</div><br/><div id="35714908" class="c"><input type="checkbox" id="c-35714908" checked=""/><div class="controls bullet"><span class="by">amichal</span><span>|</span><a href="#35714046">root</a><span>|</span><a href="#35714565">parent</a><span>|</span><a href="#35714682">next</a><span>|</span><label class="collapse" for="c-35714908">[-]</label><label class="expand" for="c-35714908">[1 more]</label></div><br/><div class="children"><div class="content">Hasura has authz this (but ive only used it it toy situations) authn is jwt or custom integration <a href="https:&#x2F;&#x2F;hasura.io&#x2F;docs&#x2F;latest&#x2F;auth&#x2F;authorization&#x2F;permissions&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hasura.io&#x2F;docs&#x2F;latest&#x2F;auth&#x2F;authorization&#x2F;permissions...</a><p>Edit: roles via jwt token <a href="https:&#x2F;&#x2F;hasura.io&#x2F;docs&#x2F;latest&#x2F;auth&#x2F;authentication&#x2F;jwt&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hasura.io&#x2F;docs&#x2F;latest&#x2F;auth&#x2F;authentication&#x2F;jwt&#x2F;</a></div><br/></div></div><div id="35714682" class="c"><input type="checkbox" id="c-35714682" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#35714046">root</a><span>|</span><a href="#35714565">parent</a><span>|</span><a href="#35714908">prev</a><span>|</span><a href="#35716831">next</a><span>|</span><label class="collapse" for="c-35714682">[-]</label><label class="expand" for="c-35714682">[3 more]</label></div><br/><div class="children"><div class="content">Authorization is usually not handled by a GraphQL framework. You typically have a business layer between your GraphQL API and your database. (And probably some basic JWT <i>authentication</i> layer in front of your API. Notice the difference between authorization &amp; authentication.)</div><br/><div id="35717274" class="c"><input type="checkbox" id="c-35717274" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#35714046">root</a><span>|</span><a href="#35714682">parent</a><span>|</span><a href="#35716831">next</a><span>|</span><label class="collapse" for="c-35717274">[-]</label><label class="expand" for="c-35717274">[2 more]</label></div><br/><div class="children"><div class="content">Sorry, yes, I meant authorization. So you&#x27;re saying to just effectively run a filter in the business layer based on allowed role&#x2F;user&#x2F;whatever. Seems pretty straightforward but I wonder if I&#x27;m missing something.</div><br/><div id="35718122" class="c"><input type="checkbox" id="c-35718122" checked=""/><div class="controls bullet"><span class="by">codethief</span><span>|</span><a href="#35714046">root</a><span>|</span><a href="#35717274">parent</a><span>|</span><a href="#35716831">next</a><span>|</span><label class="collapse" for="c-35718122">[-]</label><label class="expand" for="c-35718122">[1 more]</label></div><br/><div class="children"><div class="content">&gt; run a filter in the business layer based on allowed role&#x2F;user&#x2F;whatever<p>Yup, this is the way I&#x27;ve seen it implemented everywhere so far.</div><br/></div></div></div></div></div></div><div id="35716831" class="c"><input type="checkbox" id="c-35716831" checked=""/><div class="controls bullet"><span class="by">jensneuse</span><span>|</span><a href="#35714046">root</a><span>|</span><a href="#35714565">parent</a><span>|</span><a href="#35714682">prev</a><span>|</span><a href="#35718586">next</a><span>|</span><label class="collapse" for="c-35716831">[-]</label><label class="expand" for="c-35716831">[1 more]</label></div><br/><div class="children"><div class="content">You could use WunderGraph in front of your GraphQL and REST APIs to add auth, e.g. using OpenID Connect: <a href="https:&#x2F;&#x2F;docs.wundergraph.com&#x2F;docs&#x2F;auth&#x2F;cookie-based-auth&#x2F;openid-connect" rel="nofollow">https:&#x2F;&#x2F;docs.wundergraph.com&#x2F;docs&#x2F;auth&#x2F;cookie-based-auth&#x2F;ope...</a></div><br/></div></div></div></div></div></div><div id="35718586" class="c"><input type="checkbox" id="c-35718586" checked=""/><div class="controls bullet"><span class="by">cratermoon</span><span>|</span><a href="#35714046">prev</a><span>|</span><a href="#35714500">next</a><span>|</span><label class="collapse" for="c-35718586">[-]</label><label class="expand" for="c-35718586">[2 more]</label></div><br/><div class="children"><div class="content">I knew GraphQL would eventually come down to this, it was already apparent in the idea. Instead of replacement for REST services, GraphQL is really more like a way to expose a database schema from any relational database in a standard way. Regardless of whether the database is SQLite, Postgres, or a proprietary product like Oracle or DB2, slap a generate GraphQL front end on it now it&#x27;s available remotely without needing a client driver.</div><br/><div id="35720930" class="c"><input type="checkbox" id="c-35720930" checked=""/><div class="controls bullet"><span class="by">eurasiantiger</span><span>|</span><a href="#35718586">parent</a><span>|</span><a href="#35714500">next</a><span>|</span><label class="collapse" for="c-35720930">[-]</label><label class="expand" for="c-35720930">[1 more]</label></div><br/><div class="children"><div class="content">Slap them into entity-normalized subgraphs and now you can compose all your databases, indexes, queues, etc. into one supergraph where you can seamlessly resolve entity fields across all your data stores.</div><br/></div></div></div></div><div id="35714500" class="c"><input type="checkbox" id="c-35714500" checked=""/><div class="controls bullet"><span class="by">Chinni95</span><span>|</span><a href="#35718586">prev</a><span>|</span><label class="collapse" for="c-35714500">[-]</label><label class="expand" for="c-35714500">[1 more]</label></div><br/><div class="children"><div class="content">Good one</div><br/></div></div></div></div></div></div></div></body></html>