<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1729674074069" as="style"/><link rel="stylesheet" href="styles.css?v=1729674074069"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bernsteinbear.com/blog/row-poly/">Adding row polymorphism to Damas-Hindley-Milner</a> <span class="domain">(<a href="https://bernsteinbear.com">bernsteinbear.com</a>)</span></div><div class="subtext"><span>surprisetalk</span> | <span>10 comments</span></div><br/><div><div id="41922308" class="c"><input type="checkbox" id="c-41922308" checked=""/><div class="controls bullet"><span class="by">rtpg</span><span>|</span><a href="#41922780">next</a><span>|</span><label class="collapse" for="c-41922308">[-]</label><label class="expand" for="c-41922308">[3 more]</label></div><br/><div class="children"><div class="content">Row polymorphism is excellent. I was intro&#x27;d to it in Purescript, but I would like to say that Typescript gives you some things that rhyme with it through its combinations of records at the type level.<p>Highly recommend people mess around with Purescript, you can feel how much pressure is relieved thanks to the row polymorphism tooling almost instantly. Truly, all we wanted as an industry is an easy way to bundle together various tags into our types, and row polymorphism gets you there.<p>I think row polymorphism is a fairly straightforward thing compared to dependent types in general, but can let you crush a whole class of errors and pay almost nothing in terms of expression costs.</div><br/><div id="41923132" class="c"><input type="checkbox" id="c-41923132" checked=""/><div class="controls bullet"><span class="by">tmountain</span><span>|</span><a href="#41922308">parent</a><span>|</span><a href="#41922961">next</a><span>|</span><label class="collapse" for="c-41923132">[-]</label><label class="expand" for="c-41923132">[1 more]</label></div><br/><div class="children"><div class="content">PureScript is such a cool language. I wish it would get more traction, but it feels like it&#x27;s competing in the same space as TypeScript, and TypeScript seems to solve the category of problems it addresses well enough for most people.</div><br/></div></div><div id="41922961" class="c"><input type="checkbox" id="c-41922961" checked=""/><div class="controls bullet"><span class="by">enugu</span><span>|</span><a href="#41922308">parent</a><span>|</span><a href="#41923132">prev</a><span>|</span><a href="#41922780">next</a><span>|</span><label class="collapse" for="c-41922961">[-]</label><label class="expand" for="c-41922961">[1 more]</label></div><br/><div class="children"><div class="content">Somtime ago, there was a debate on the ability of a static type system to model an &#x27;open-world situation&#x27; where fields are added to records as model changes. (based on a post[1] which responded to a Rich Hickey talk).<p>The crucial point was that structural typing on which row-polymorphism is based can model such open-world situations.<p>Also, having such a system can free you from having overly nested types.<p>It would be great if Purescript or row-polymorphism became more popular.<p>[1] <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22090700">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=22090700</a></div><br/></div></div></div></div><div id="41922780" class="c"><input type="checkbox" id="c-41922780" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#41922308">prev</a><span>|</span><a href="#41922783">next</a><span>|</span><label class="collapse" for="c-41922780">[-]</label><label class="expand" for="c-41922780">[4 more]</label></div><br/><div class="children"><div class="content"><i>&quot;A record is an unordered collection of name to value mappings&quot;</i><p>If there is one thing that is for sure, it is that we have too many names for <i>&quot;collection of name to value mappings&quot;</i>.<p>In my book the term <i>record</i> is not what first comes to mind when thinking of <i>unordered</i> mappings. All of the usages of the word I can think of imply the possibility of access by name while retaining order. Sometimes this allows easy indexed access (database rows used to be called records) sometimes it doesn&#x27;t (C structs which also used to be called record types).</div><br/><div id="41923094" class="c"><input type="checkbox" id="c-41923094" checked=""/><div class="controls bullet"><span class="by">RandomThoughts3</span><span>|</span><a href="#41922780">parent</a><span>|</span><a href="#41922859">next</a><span>|</span><label class="collapse" for="c-41923094">[-]</label><label class="expand" for="c-41923094">[1 more]</label></div><br/><div class="children"><div class="content">Yes, it is a very unusual definition of a record. As you rightfully noted, typically, a record is defined as a composite data structure mixing data types (indeed something more or less equivalent to a C struct basically).<p>Access by name is not even truly necessary and the difference between tuples and records is minimal (you could build something looking exactly like field access on top of tuples with functions and would get as a result something indistinguishable from an actual record).<p>The existence or not of an order is then totally accessory and it&#x27;s generally straightforward to build an order on both provided the data types they contain is orderable by ordering the field and then using a lexicographic order.</div><br/></div></div><div id="41922859" class="c"><input type="checkbox" id="c-41922859" checked=""/><div class="controls bullet"><span class="by">yazaddaruvala</span><span>|</span><a href="#41922780">parent</a><span>|</span><a href="#41923094">prev</a><span>|</span><a href="#41922783">next</a><span>|</span><label class="collapse" for="c-41922859">[-]</label><label class="expand" for="c-41922859">[2 more]</label></div><br/><div class="children"><div class="content">I tend to agree with you. “Unordered” is very strange when clearly it is consistently “ordered” by some function(name, insertion_id) to facilitate low latency lookup.<p>The iteration order seems arbitrary to a human, but that is exclusively because function(name, insertion_id) is not optimized for a human. It seems strange to call the collection “unordered” because of how it appears to a human.</div><br/><div id="41923014" class="c"><input type="checkbox" id="c-41923014" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#41922780">root</a><span>|</span><a href="#41922859">parent</a><span>|</span><a href="#41922783">next</a><span>|</span><label class="collapse" for="c-41923014">[-]</label><label class="expand" for="c-41923014">[1 more]</label></div><br/><div class="children"><div class="content">Unordered simply means the order isn’t exposed, not that the bits have somehow literally fallen out of the computer and are scattered on the floor.</div><br/></div></div></div></div></div></div><div id="41922783" class="c"><input type="checkbox" id="c-41922783" checked=""/><div class="controls bullet"><span class="by">choeger</span><span>|</span><a href="#41922780">prev</a><span>|</span><label class="collapse" for="c-41922783">[-]</label><label class="expand" for="c-41922783">[2 more]</label></div><br/><div class="children"><div class="content">Well written!<p>I wonder if there&#x27;s a way to efficiently implement it without resorting to monomorphization?<p>A function that&#x27;s polymorphic can be transformed into a more primitive (say C or assembly) function that gets extra arguments that carry the &quot;shape&quot; of the type variable (think of sizes, pointers vs. values, etc.). Is there a similar strategy for these polymorphic records?<p>I see two issues:<p>1. The offset of any particular field in the record is unknown at compile time<p>2. The size of the record itself is unknown at compile time (but this should be trivial as an extra argument.)</div><br/><div id="41922870" class="c"><input type="checkbox" id="c-41922870" checked=""/><div class="controls bullet"><span class="by">pistoleer</span><span>|</span><a href="#41922783">parent</a><span>|</span><label class="collapse" for="c-41922870">[-]</label><label class="expand" for="c-41922870">[1 more]</label></div><br/><div class="children"><div class="content">Swift solves this by using witness tables. Witness table is a skeleton of the desired record shape. It records offsets of desired fields as found in the actual supplied record. Each function call the actual record is not passed, but its corresponding witness table instead.<p>For instance, if the &quot;prototype&quot; of the argument is {int foo, float bar}, and I supply {int foo, int baz, float bar}, the table will be {foo: base+0 bytes, bar: base+8 bytes}.</div><br/></div></div></div></div></div></div></div></div></div></body></html>