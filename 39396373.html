<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708333270017" as="style"/><link rel="stylesheet" href="styles.css?v=1708333270017"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://taylor.town/compress-code">Clean your codebase with basic information theory</a> <span class="domain">(<a href="https://taylor.town">taylor.town</a>)</span></div><div class="subtext"><span>surprisetalk</span> | <span>31 comments</span></div><br/><div><div id="39426823" class="c"><input type="checkbox" id="c-39426823" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#39426895">next</a><span>|</span><label class="collapse" for="c-39426823">[-]</label><label class="expand" for="c-39426823">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  &gt; group related concepts together
  &gt; The hardest part of this process is deciding what “related concepts” mean.
</code></pre>
The article talks about &quot;readability&quot;, but arguably the unnamed hard problem it is dancing around is how to structure an application or system by decomposing it into modules.<p>I&#x27;d argue the baseline reasonable approach to structuring applications or systems is the one given in Parnas&#x27; 1972 paper &quot;On the Criteria To Be Used in Decomposing Systems into Modules&quot;:<p><pre><code>  &gt; We propose instead that one begins with a list of difficult design decisions or design decisions which are likely to change. Each module is then designed to hide such a decision from the others.
</code></pre>
<a href="http:&#x2F;&#x2F;sunnyday.mit.edu&#x2F;16.355&#x2F;parnas-criteria.html" rel="nofollow">http:&#x2F;&#x2F;sunnyday.mit.edu&#x2F;16.355&#x2F;parnas-criteria.html</a><p>Parnas&#x27; criterion embeds the understanding that code and systems are not static but need to evolve over time as requirements change or decisions are made, and that different decompositions can be inferior or superior to accommodating that change.<p>&quot;Don&#x27;t repeat yourself&quot; refactoring rules of thumb can give poor results if blindly applied. Suppose two sections of application logic just so happen to look similar at this moment in time and get refactored to &quot;remove the duplication&quot; coupling them together, when the two sections of code are subject to different constraints and reasons for change, and will need to evolve separately.</div><br/><div id="39427182" class="c"><input type="checkbox" id="c-39427182" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39426823">parent</a><span>|</span><a href="#39426895">next</a><span>|</span><label class="collapse" for="c-39427182">[-]</label><label class="expand" for="c-39427182">[2 more]</label></div><br/><div class="children"><div class="content">People forget that readability isn&#x27;t a function of specific program - there is no one optimal readability. On the contrary, it&#x27;s a function of the program <i>and the goals of the reader</i>. So after fixing and DRYing all the generally bad&#x2F;inefficient decision, what is readable code becomes solely the issue of why you&#x27;re reading it - trying to debug or add an entirely new feature will have <i>opposite</i> readability criteria to extending some high-level feature.<p>Even in the best case, readability just becomes a Pareto frontier[0], given by expressive limits of the dominant programming paradigm - same single plaintext source code for all. There&#x27;s only so much complexity, so much cross-cutting concerns, we can cram into the same piece of plaintext, until something gives, until the same code is beatiful to you one week, and incomprehensible the next week, with the only thing that changed is the type of work you&#x27;re doing on it.<p>So, beyond evolving over time, I&#x27;d also consider the orthogonal aspect of different decompositions being good for different purposes, and that you can&#x27;t have it all <i>and</i> work on the same, single, high-level plaintext code.<p>EDIT: And I believe the solution to this, <i>the</i> step forward beyond the Pareto frontier, is what &#x27;valty described here: <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39426895">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=39426895</a> - not coding directly in the same plaintext, but treating the single-source-of-truth code as a database, which you query and update through views&#x2F;lenses that best fit whatever work you&#x27;re doing at the moment.<p>--<p>[0] - <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pareto_front" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pareto_front</a></div><br/><div id="39427505" class="c"><input type="checkbox" id="c-39427505" checked=""/><div class="controls bullet"><span class="by">UweSchmidt</span><span>|</span><a href="#39426823">root</a><span>|</span><a href="#39427182">parent</a><span>|</span><a href="#39426895">next</a><span>|</span><label class="collapse" for="c-39427505">[-]</label><label class="expand" for="c-39427505">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s not too much trouble, could you create a minimal demonstration of a simple piece of code, structured for various goals - easy to extend, easy to debug etc.? I can&#x27;t defend my code form the best-practice-people with a Pareto Front wikipedia article.</div><br/></div></div></div></div></div></div><div id="39426895" class="c"><input type="checkbox" id="c-39426895" checked=""/><div class="controls bullet"><span class="by">valty</span><span>|</span><a href="#39426823">prev</a><span>|</span><a href="#39426357">next</a><span>|</span><label class="collapse" for="c-39426895">[-]</label><label class="expand" for="c-39426895">[4 more]</label></div><br/><div class="children"><div class="content">&gt; In my experience, the key to maintaining readability is developing a healthy respect for locality<p>I think this pursuit of &quot;locality&quot; is what actually causes more complexity. And I think its mainly around our obsession with representing our code as text files in folder hierarchies.<p>&gt; coarsely structure codebases around CPU timelines and dataflow<p>This is why I would prefer code to be in a database, instead of files and folders, so that structure doesn&#x27;t matter, and the tree view UI can be organized based on runtime code paths, and data flow - via value tracing.<p>&gt; don’t pollute your namespace – use blocks to restrict variables&#x2F;functions to the smallest possible scope<p>Everyone likes to be all modular and develop in tiny little pieces that they assemble together. Relying on modularization means that when stuff changes upstream in the call stack, we just hack around these changes adding some conditionals to handle these changes instead of resorting to larger refactors. People like this because things can keep moving instead of everything breaking.<p>Instead, what we need to do is make it easier to trace all the data dependencies in our programs so that when we make a change to anything, we can instantly see what depends on it and needs updating.<p>I have actually started to think that, against conventional wisdom, everything should be a global variable. All the issues with global variables can be solved with better tracing tooling.<p>Instead we end up with all these little mini-databases spread all over our code, when what we should have is one central one from which we can clearly see all the data dependencies.<p>&gt; group related concepts together<p>Instead, we should query a database of code as needed...just like we do with our normalized data.</div><br/><div id="39427285" class="c"><input type="checkbox" id="c-39427285" checked=""/><div class="controls bullet"><span class="by">hnben</span><span>|</span><a href="#39426895">parent</a><span>|</span><a href="#39426357">next</a><span>|</span><label class="collapse" for="c-39427285">[-]</label><label class="expand" for="c-39427285">[3 more]</label></div><br/><div class="children"><div class="content">Your ideas sound intriguing. Are they original, or can I read up on them somewhere?</div><br/><div id="39427503" class="c"><input type="checkbox" id="c-39427503" checked=""/><div class="controls bullet"><span class="by">hcs</span><span>|</span><a href="#39426895">root</a><span>|</span><a href="#39427285">parent</a><span>|</span><a href="#39427412">next</a><span>|</span><label class="collapse" for="c-39427503">[-]</label><label class="expand" for="c-39427503">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div><div id="39427412" class="c"><input type="checkbox" id="c-39427412" checked=""/><div class="controls bullet"><span class="by">elbear</span><span>|</span><a href="#39426895">root</a><span>|</span><a href="#39427285">parent</a><span>|</span><a href="#39427503">prev</a><span>|</span><a href="#39426357">next</a><span>|</span><label class="collapse" for="c-39427412">[-]</label><label class="expand" for="c-39427412">[1 more]</label></div><br/><div class="children"><div class="content">As far as I&#x27;m aware, the Unison Language implements some of his ideas:
<a href="https:&#x2F;&#x2F;www.unison-lang.org" rel="nofollow">https:&#x2F;&#x2F;www.unison-lang.org</a></div><br/></div></div></div></div></div></div><div id="39426357" class="c"><input type="checkbox" id="c-39426357" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#39426895">prev</a><span>|</span><a href="#39425952">next</a><span>|</span><label class="collapse" for="c-39426357">[-]</label><label class="expand" for="c-39426357">[4 more]</label></div><br/><div class="children"><div class="content">To my mind the conclusion is backwards. A file with a high compressed size might be doing something useful; a file with a low compressed size but a high uncompressed size is a file that&#x27;s full of repetitive junk, and those are the files that should be a target for refactoring.</div><br/><div id="39426698" class="c"><input type="checkbox" id="c-39426698" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39426357">parent</a><span>|</span><a href="#39426813">next</a><span>|</span><label class="collapse" for="c-39426698">[-]</label><label class="expand" for="c-39426698">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. As ways to differentiate between &quot;essential complexity&quot; and &quot;accidental complexity&quot; go, the idea of looking at what compresses well sounds quite good - but it&#x27;s the accidental complexity that will compress the best, and essential the worst. And latter is <i>not</i> the problem, the former is.</div><br/></div></div><div id="39426855" class="c"><input type="checkbox" id="c-39426855" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39426357">parent</a><span>|</span><a href="#39426813">prev</a><span>|</span><a href="#39425952">next</a><span>|</span><label class="collapse" for="c-39426855">[-]</label><label class="expand" for="c-39426855">[1 more]</label></div><br/><div class="children"><div class="content">In other words, the compression <i>ratio</i> is what&#x27;s important.</div><br/></div></div></div></div><div id="39425952" class="c"><input type="checkbox" id="c-39425952" checked=""/><div class="controls bullet"><span class="by">aappleby</span><span>|</span><a href="#39426357">prev</a><span>|</span><a href="#39426909">next</a><span>|</span><label class="collapse" for="c-39425952">[-]</label><label class="expand" for="c-39425952">[9 more]</label></div><br/><div class="children"><div class="content">The article is somewhat silly, but there&#x27;s a kernel of good advice here -<p>To estimate the &quot;complexity&quot; of a codebase:<p>1. Remove all comments<p>2. Replace all spans of whitespace with a single space<p>3. Concatenate all source together into a single file<p>4. Compress the resulting text file using gzip -9 (or your favorite compression engine)<p>The size of the resulting file is a good proxy for overall complexity. It&#x27;s not heavily affected by naming conventions, and a refactoring that reduces the number is probably good for overall complexity.<p>It&#x27;s not a perfect metric as it doesn&#x27;t include any notion of cyclomatic complexity, but it&#x27;s a good start and useful to track over time.</div><br/><div id="39426536" class="c"><input type="checkbox" id="c-39426536" checked=""/><div class="controls bullet"><span class="by">sltkr</span><span>|</span><a href="#39425952">parent</a><span>|</span><a href="#39426182">next</a><span>|</span><label class="collapse" for="c-39426536">[-]</label><label class="expand" for="c-39426536">[6 more]</label></div><br/><div class="children"><div class="content">I think the value of metrics like this is limited, since code base size only very roughly corresponds to implementation complexity.<p>Here are some examples where you would increase the compressed code size while not making the project more complex:<p>1. Adding unit tests to code that was previously untested. Unit tests add little complexity because they don&#x27;t introduce new interfaces.<p>2. Splitting a God class up into multiple independent classes. Usually this improves readability thanks to separation of concerns, but it often increases raw code size because each new class adds some boiler plate.<p>etc.</div><br/><div id="39427209" class="c"><input type="checkbox" id="c-39427209" checked=""/><div class="controls bullet"><span class="by">TeMPOraL</span><span>|</span><a href="#39425952">root</a><span>|</span><a href="#39426536">parent</a><span>|</span><a href="#39426609">next</a><span>|</span><label class="collapse" for="c-39427209">[-]</label><label class="expand" for="c-39427209">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Usually this improves readability thanks to separation of concerns, but it often increases raw code size because each new class adds some boiler plate.</i><p>That is why <i>compression</i> is mentioned. Boilerplate is something that disappears under good enough compression. It&#x27;s literally why we call it boilerplate and generally dislike it - because once we spot the pattern, we can mentally compress it away, and then are annoyed that we <i>have to</i> do that mental compression whenever reading or modifying that code. Feels like pointless work, which it is.</div><br/></div></div><div id="39426609" class="c"><input type="checkbox" id="c-39426609" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#39425952">root</a><span>|</span><a href="#39426536">parent</a><span>|</span><a href="#39427209">prev</a><span>|</span><a href="#39427133">next</a><span>|</span><label class="collapse" for="c-39426609">[-]</label><label class="expand" for="c-39426609">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  I think the value of metrics like this is limited, since code base size only very roughly corresponds to implementation complexity.<p>This sounds a lot like the &quot;your model is wrong because nuance X&quot; argument. I want to remind you that <i>all</i> models are wrong, but some of them are useful anyway. In particular, I have found the size of source code to be a highly useful predictor of complexity. It has helped me predict where bugs are, where changes are made, where developers point out areas of large technical debt, and many other variables associated with complexity.<p>The test of a model is not whether it accounts for all theoretical nuances, but rather whether it&#x27;s empirically useful – and critically, has higher return-on-investment than alternative models. What model do you suggest for implementation complexity that you have verified to be better than code size? Genuinely interested!<p>(Additionally, I have also successfully used the compressed size of input data to predict the resource requirements of processing that data, without actually having to process it first. This is useful because the compressed size can be approximated on-line rather cheaply.)</div><br/><div id="39426704" class="c"><input type="checkbox" id="c-39426704" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#39425952">root</a><span>|</span><a href="#39426609">parent</a><span>|</span><a href="#39427133">next</a><span>|</span><label class="collapse" for="c-39426704">[-]</label><label class="expand" for="c-39426704">[2 more]</label></div><br/><div class="children"><div class="content">The GP’s point isn’t that the model is wrong “because nuance X”, it’s that the model directly contradicts good practice.<p>You also changed the model under consideration (GP said compressed code size; you said just code size), disagreeing with a point the GP didn’t make.</div><br/><div id="39427363" class="c"><input type="checkbox" id="c-39427363" checked=""/><div class="controls bullet"><span class="by">kqr</span><span>|</span><a href="#39425952">root</a><span>|</span><a href="#39426704">parent</a><span>|</span><a href="#39427133">next</a><span>|</span><label class="collapse" for="c-39427363">[-]</label><label class="expand" for="c-39427363">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The GP’s point isn’t that the model is wrong “because nuance X”, it’s that the model directly contradicts good practice.<p>&quot;Doesn&#x27;t matter; had predictive value&quot; is what comes to mind. &quot;Good practise&quot; isn&#x27;t a defense against empirical evidence.<p>That said, you&#x27;re right that I missed the compressed part. I haven&#x27;t tried compressing the source code before analysis, but I do suspect it would improve accuracy rather than decrease it. That&#x27;s not a rigorous argument though, and I&#x27;m willing to accept that uncompressed code size might be a better model than compressed code size.</div><br/></div></div></div></div></div></div><div id="39427133" class="c"><input type="checkbox" id="c-39427133" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#39425952">root</a><span>|</span><a href="#39426536">parent</a><span>|</span><a href="#39426609">prev</a><span>|</span><a href="#39426182">next</a><span>|</span><label class="collapse" for="c-39427133">[-]</label><label class="expand" for="c-39427133">[1 more]</label></div><br/><div class="children"><div class="content">Why would you include unit tests in the code size or complexity calculations?</div><br/></div></div></div></div><div id="39426182" class="c"><input type="checkbox" id="c-39426182" checked=""/><div class="controls bullet"><span class="by">CapsAdmin</span><span>|</span><a href="#39425952">parent</a><span>|</span><a href="#39426536">prev</a><span>|</span><a href="#39426011">next</a><span>|</span><label class="collapse" for="c-39426182">[-]</label><label class="expand" for="c-39426182">[1 more]</label></div><br/><div class="children"><div class="content">Sometimes I&#x27;ve scanned code bases of my own for all user definable variable names and just levenshtein distanced them. It&#x27;s kind of useful, but the hurdle for me at least is that I need to run something in a terminal to get the results. Maybe I&#x27;d use it more if it was a plugin in my ide of choice.<p>Something else you could maybe do is to simplify the code and compare sequences of statements and expressions to each other.<p>ie the 2 statements &quot;foo <i>= bar; foo += 20&quot; is identical to &quot;zoo </i>= war; zoo += 20&quot;</div><br/></div></div><div id="39426011" class="c"><input type="checkbox" id="c-39426011" checked=""/><div class="controls bullet"><span class="by">smburdick</span><span>|</span><a href="#39425952">parent</a><span>|</span><a href="#39426182">prev</a><span>|</span><a href="#39426909">next</a><span>|</span><label class="collapse" for="c-39426011">[-]</label><label class="expand" for="c-39426011">[1 more]</label></div><br/><div class="children"><div class="content">This is what a minifier does, and those go even further to rename variables.<p>Another thing that should be pruned away entirely are data files, including all constant strings within the code, since humans should avoid those when focusing on algorithms<p>At that point you pretty much have a highly compressed version of what you&#x27;d find in CLRS or any other algorithmic text.</div><br/></div></div></div></div><div id="39426909" class="c"><input type="checkbox" id="c-39426909" checked=""/><div class="controls bullet"><span class="by">crq-yml</span><span>|</span><a href="#39425952">prev</a><span>|</span><a href="#39425903">next</a><span>|</span><label class="collapse" for="c-39426909">[-]</label><label class="expand" for="c-39426909">[1 more]</label></div><br/><div class="children"><div class="content">Many of the issues that come up with applied information theory to  practical code are of the form &quot;oh, but it won&#x27;t be fast if we do it that way&quot;. The end of the article links Alan Kay discussing STEPS and how it solves many computing. fundamentals needed for a desktop in miniscule amounts of code. One of the comments to that video, made five years ago, dismisses it as unrealistic ivory tower nonsense that can&#x27;t run fast enough. (Notwithstanding, the presentation was given on a running system demonstrating the proof of concept)<p>But there is a <i>similar</i> sentiment to Kay&#x27;s from the bottom-up viewpoint. The Forth community, who have made livings on implementing this kind of succinct design in commercial settings, tend to point to hardware manufacturers themselves as the primary difficulty. Their business is to sell you more hardware than you need, and that leads them towards doing nothing to help with the software crisis, but rather, to encourage processing and I&#x2F;O to be complex things to reason about, with complex protocols and mystery-meat drivers. If you have to use USB, Bluetooth, TCP&#x2F;IP...you&#x27;re stuck. Nobody wants to deal with those hot potatoes. You can&#x27;t address it properly by running up the abstraction stack and doing &quot;everything in the browser&quot;. That&#x27;s playing nicely with the standards instead of attacking them. When  software companies play along and say &quot;well, it&#x27;s the standard so we have to use it,&quot; their problem gets deeper.<p>Some room could be conceded to say that some of that complexity is essential, but one of the ways in which we describe progress in science and technology is to find solutions that are lighter and simpler to understand, e.g. instead of astronomical tables describing &quot;Earth at the center of the universe&quot; epicycles, smaller equations describing orbits around the Sun.</div><br/></div></div><div id="39425903" class="c"><input type="checkbox" id="c-39425903" checked=""/><div class="controls bullet"><span class="by">nighthawk454</span><span>|</span><a href="#39426909">prev</a><span>|</span><a href="#39427341">next</a><span>|</span><label class="collapse" for="c-39425903">[-]</label><label class="expand" for="c-39425903">[1 more]</label></div><br/><div class="children"><div class="content">Bit of roundabout way to say ‘DRY’. Information isn’t a universal context-free quantity, it depends on the models involved. In this case the target is removing repeated words&#x2F;code symbols and being concise.</div><br/></div></div><div id="39427341" class="c"><input type="checkbox" id="c-39427341" checked=""/><div class="controls bullet"><span class="by">AriedK</span><span>|</span><a href="#39425903">prev</a><span>|</span><a href="#39427382">next</a><span>|</span><label class="collapse" for="c-39427341">[-]</label><label class="expand" for="c-39427341">[1 more]</label></div><br/><div class="children"><div class="content">I like how <a href="https:&#x2F;&#x2F;hemingwayapp.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hemingwayapp.com&#x2F;</a> approached this for text. 
It highlights complex sentences, unnecessary adverbs and voicing issues.</div><br/></div></div><div id="39427382" class="c"><input type="checkbox" id="c-39427382" checked=""/><div class="controls bullet"><span class="by">wiz21c</span><span>|</span><a href="#39427341">prev</a><span>|</span><a href="#39425935">next</a><span>|</span><label class="collapse" for="c-39427382">[-]</label><label class="expand" for="c-39427382">[1 more]</label></div><br/><div class="children"><div class="content">At least the article proposes an easy to grasp application of entropy (which is not an easy to grasp concept)</div><br/></div></div><div id="39425935" class="c"><input type="checkbox" id="c-39425935" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#39427382">prev</a><span>|</span><a href="#39426817">next</a><span>|</span><label class="collapse" for="c-39425935">[-]</label><label class="expand" for="c-39425935">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also thought of the idea of using some LZ-based compression on source code files to determine which ones have the most redundancy (the ones that have the best ratios) and could be simplified by refactoring, which is not too different from the entropy-based approach described here. It&#x27;s worth noting that this also identifies languages that trend towards boilerplate and egregious verbosity --- for example, I&#x27;ve noticed that the average C# or Java codebase will compress much better than C, while (much) denser stuff like APL-family languages don&#x27;t compress as much.</div><br/></div></div><div id="39426817" class="c"><input type="checkbox" id="c-39426817" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39425935">prev</a><span>|</span><a href="#39425995">next</a><span>|</span><label class="collapse" for="c-39426817">[-]</label><label class="expand" for="c-39426817">[2 more]</label></div><br/><div class="children"><div class="content">I feel the approach could have some merit, but the article unfortunately stops short of demonstrating it. Also the problem of analytically finding similar code sub-trees seems highly non-trivial. As baseline you want to parse the code, but really you&#x27;d also want to somehow &quot;normalize&quot; identifiers, as usually it is the common structure rather than specific identifiers that matter.</div><br/><div id="39426880" class="c"><input type="checkbox" id="c-39426880" checked=""/><div class="controls bullet"><span class="by">zem</span><span>|</span><a href="#39426817">parent</a><span>|</span><a href="#39425995">next</a><span>|</span><label class="collapse" for="c-39426880">[-]</label><label class="expand" for="c-39426880">[1 more]</label></div><br/><div class="children"><div class="content">take a look at <a href="https:&#x2F;&#x2F;pmd.github.io&#x2F;#about" rel="nofollow">https:&#x2F;&#x2F;pmd.github.io&#x2F;#about</a></div><br/></div></div></div></div><div id="39425995" class="c"><input type="checkbox" id="c-39425995" checked=""/><div class="controls bullet"><span class="by">whynotmaybe</span><span>|</span><a href="#39426817">prev</a><span>|</span><a href="#39426317">next</a><span>|</span><label class="collapse" for="c-39425995">[-]</label><label class="expand" for="c-39425995">[2 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t it another way of expressing the Halstead complexity measure ?<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Halstead_complexity_measures" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Halstead_complexity_measures</a></div><br/><div id="39426270" class="c"><input type="checkbox" id="c-39426270" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#39425995">parent</a><span>|</span><a href="#39426317">next</a><span>|</span><label class="collapse" for="c-39426270">[-]</label><label class="expand" for="c-39426270">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is similar to the identification of measurable properties of matter (like the volume, mass, and pressure of a gas) and the relationships between them (analogous to the gas equation). Thus his metrics are actually not just complexity metrics.<p>I thought I was familiar with halstead but this perspective was new to me.  Interesting</div><br/></div></div></div></div><div id="39426317" class="c"><input type="checkbox" id="c-39426317" checked=""/><div class="controls bullet"><span class="by">photonthug</span><span>|</span><a href="#39425995">prev</a><span>|</span><label class="collapse" for="c-39426317">[-]</label><label class="expand" for="c-39426317">[1 more]</label></div><br/><div class="children"><div class="content">For related topics filed under complexity&#x2F;compressibility see also Kolmogorov complexity, algorithmic information theory, and the hutter prize</div><br/></div></div></div></div></div></div></div></body></html>