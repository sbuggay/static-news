<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701680458663" as="style"/><link rel="stylesheet" href="styles.css?v=1701680458663"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/tomnomnom/gron">Gron: Make JSON greppable</a>Â <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>47 comments</span></div><br/><div><div id="38511636" class="c"><input type="checkbox" id="c-38511636" checked=""/><div class="controls bullet"><span class="by">salted-fry</span><span>|</span><a href="#38511607">next</a><span>|</span><label class="collapse" for="c-38511636">[-]</label><label class="expand" for="c-38511636">[21 more]</label></div><br/><div class="children"><div class="content">I use gron a lot, because I can never remember how to use jq to do anything fancy but can usually make awk work. (I may be unusual in that department, in that I actually like awk)<p>One warning to note is that gron <i>burns</i> RAM. I&#x27;ve killed 32GB servers working with 15MB JSON files. (I think gron -u is even worse, but my memory is a bit fuzzy here).<p><a href="https:&#x2F;&#x2F;github.com&#x2F;adamritter&#x2F;fastgron">https:&#x2F;&#x2F;github.com&#x2F;adamritter&#x2F;fastgron</a> as an alternative has been pretty good to me in terms of performance, I think both in speed and RAM usage.</div><br/><div id="38512422" class="c"><input type="checkbox" id="c-38512422" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#38511636">parent</a><span>|</span><a href="#38514410">next</a><span>|</span><label class="collapse" for="c-38512422">[-]</label><label class="expand" for="c-38512422">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for mentioning my project (fastgron).<p>It reads the file into memory once, then just goes through it only once, so it shouldn&#x27;t need much more memory than the file size.<p>Also I put a lot of work into making fastgron -u fast, but you can grep the file directly as well.</div><br/></div></div><div id="38514410" class="c"><input type="checkbox" id="c-38514410" checked=""/><div class="controls bullet"><span class="by">Alifatisk</span><span>|</span><a href="#38511636">parent</a><span>|</span><a href="#38512422">prev</a><span>|</span><a href="#38514363">next</a><span>|</span><label class="collapse" for="c-38514410">[-]</label><label class="expand" for="c-38514410">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One warning to note is that gron burns RAM. I&#x27;ve killed 32GB servers working with 15MB JSON files.<p>That sounds seriously like there is something wrong with the tool</div><br/></div></div><div id="38514363" class="c"><input type="checkbox" id="c-38514363" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#38511636">parent</a><span>|</span><a href="#38514410">prev</a><span>|</span><a href="#38512341">next</a><span>|</span><label class="collapse" for="c-38514363">[-]</label><label class="expand" for="c-38514363">[3 more]</label></div><br/><div class="children"><div class="content">I have a version of `gron` which uses almost no RAM to parse files (uses the streaming JSON parser rather than loading the file.)  Processed a 4GB JSON file on a Pi using it (admittedly, it took forever) taking, IIRC, about 64MB RAM tops.<p>`gron -u` is basically impossible to optimise <i>unless</i> you know the input is in &quot;sorted&quot; order (ie the order it comes out of `gron`, including the `json.a = {};` bits) in which case my code can handle that in almost no RAM also.  But if it&#x27;s not sorted or you&#x27;re missing the `json.a = {};` lines, there&#x27;s not a lot you can do since you have to hold the whole data structure in RAM.</div><br/><div id="38514442" class="c"><input type="checkbox" id="c-38514442" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38514363">parent</a><span>|</span><a href="#38512341">next</a><span>|</span><label class="collapse" for="c-38514442">[-]</label><label class="expand" for="c-38514442">[2 more]</label></div><br/><div class="children"><div class="content">&gt; you have to hold the whole data structure in RAM<p>Sure, but something is seriously wrong if a 15 MB JSON data structure uses more than 32 GB of RAM.</div><br/><div id="38514683" class="c"><input type="checkbox" id="c-38514683" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38514442">parent</a><span>|</span><a href="#38512341">next</a><span>|</span><label class="collapse" for="c-38514683">[-]</label><label class="expand" for="c-38514683">[1 more]</label></div><br/><div class="children"><div class="content">That 15MB JSON expands when piped through `gron` - my 7MB pathological test file is 143MB and 2M lines after going through `gron` (which is lines like `json[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][1][1][0][0] = &quot;x&quot;;`)<p>Which is 20 levels of unknown-sized and unknown-typed slices of slices of `any` in Go and that is not super-efficient, alas.  It gets worse when you have maps of slices of maps etc.  `fastgron` gets around this by being able to manage its own memory.<p>(`gron` can, however, reconstruct the output correctly if you shuffle the input.  `fastgron` cannot.  Which suggests to me it&#x27;s maybe using the same &#x27;output as we go&#x27; trick that my `gron` fork uses for its &quot;input is sorted&quot; mode which uses almost no RAM but cannot deal with disordered input.)<p>(`gron` could&#x2F;should maybe indicate the maximum size of the slices and if they&#x27;re a single type which would make things more efficient and I might add that to my fork.)</div><br/></div></div></div></div></div></div><div id="38511670" class="c"><input type="checkbox" id="c-38511670" checked=""/><div class="controls bullet"><span class="by">treyd</span><span>|</span><a href="#38511636">parent</a><span>|</span><a href="#38512341">prev</a><span>|</span><a href="#38511607">next</a><span>|</span><label class="collapse" for="c-38511670">[-]</label><label class="expand" for="c-38511670">[14 more]</label></div><br/><div class="children"><div class="content">What could possibly be so memory-intensive about gron?  I suppose it could make sense for ungronning, but not in the forward direction.</div><br/><div id="38511711" class="c"><input type="checkbox" id="c-38511711" checked=""/><div class="controls bullet"><span class="by">haileys</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511670">parent</a><span>|</span><a href="#38511735">next</a><span>|</span><label class="collapse" for="c-38511711">[-]</label><label class="expand" for="c-38511711">[8 more]</label></div><br/><div class="children"><div class="content">It buffers all of its output statements in memory before writing to stdout:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron&#x2F;blob&#x2F;master&#x2F;main.go#L204">https:&#x2F;&#x2F;github.com&#x2F;tomnomnom&#x2F;gron&#x2F;blob&#x2F;master&#x2F;main.go#L204</a></div><br/><div id="38512496" class="c"><input type="checkbox" id="c-38512496" checked=""/><div class="controls bullet"><span class="by">xiphias2</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511711">parent</a><span>|</span><a href="#38511818">next</a><span>|</span><label class="collapse" for="c-38512496">[-]</label><label class="expand" for="c-38512496">[1 more]</label></div><br/><div class="children"><div class="content">Here&#x27;s the fastgron printer if you want to compare:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;adamritter&#x2F;fastgron&#x2F;blob&#x2F;main&#x2F;src&#x2F;print_gron.cpp">https:&#x2F;&#x2F;github.com&#x2F;adamritter&#x2F;fastgron&#x2F;blob&#x2F;main&#x2F;src&#x2F;print_g...</a></div><br/></div></div><div id="38511818" class="c"><input type="checkbox" id="c-38511818" checked=""/><div class="controls bullet"><span class="by">codetrotter</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511711">parent</a><span>|</span><a href="#38512496">prev</a><span>|</span><a href="#38511735">next</a><span>|</span><label class="collapse" for="c-38511818">[-]</label><label class="expand" for="c-38511818">[6 more]</label></div><br/><div class="children"><div class="content">Why?</div><br/><div id="38511979" class="c"><input type="checkbox" id="c-38511979" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511818">parent</a><span>|</span><a href="#38511735">next</a><span>|</span><label class="collapse" for="c-38511979">[-]</label><label class="expand" for="c-38511979">[5 more]</label></div><br/><div class="children"><div class="content">It appears to be so it can sort the lines. Not sure how useful that is however.</div><br/><div id="38513789" class="c"><input type="checkbox" id="c-38513789" checked=""/><div class="controls bullet"><span class="by">CGamesPlay</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511979">parent</a><span>|</span><a href="#38512373">next</a><span>|</span><label class="collapse" for="c-38513789">[-]</label><label class="expand" for="c-38513789">[2 more]</label></div><br/><div class="children"><div class="content">An ironic near-miss on the UNIX philosophy. There&#x27;s a great UNIX tool that will handle sorting arbitrarily large files!</div><br/><div id="38514228" class="c"><input type="checkbox" id="c-38514228" checked=""/><div class="controls bullet"><span class="by">tgv</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38513789">parent</a><span>|</span><a href="#38512373">next</a><span>|</span><label class="collapse" for="c-38514228">[-]</label><label class="expand" for="c-38514228">[1 more]</label></div><br/><div class="children"><div class="content">It will mess up array indices, though.</div><br/></div></div></div></div><div id="38512373" class="c"><input type="checkbox" id="c-38512373" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511979">parent</a><span>|</span><a href="#38513789">prev</a><span>|</span><a href="#38511735">next</a><span>|</span><label class="collapse" for="c-38512373">[-]</label><label class="expand" for="c-38512373">[2 more]</label></div><br/><div class="children"><div class="content">It shouldn&#x27;t need to buffer the output to do that, right?</div><br/><div id="38512917" class="c"><input type="checkbox" id="c-38512917" checked=""/><div class="controls bullet"><span class="by">swsieber</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38512373">parent</a><span>|</span><a href="#38511735">next</a><span>|</span><label class="collapse" for="c-38512917">[-]</label><label class="expand" for="c-38512917">[1 more]</label></div><br/><div class="children"><div class="content">Correct.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38511735" class="c"><input type="checkbox" id="c-38511735" checked=""/><div class="controls bullet"><span class="by">salted-fry</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511670">parent</a><span>|</span><a href="#38511711">prev</a><span>|</span><a href="#38511707">next</a><span>|</span><label class="collapse" for="c-38511735">[-]</label><label class="expand" for="c-38511735">[3 more]</label></div><br/><div class="children"><div class="content">I remembered where some of my old files are and re-tested; forward-gron was &quot;only&quot; about 7GB for the 15MB file. gron -u was the real killer, clocking in around 53GB.</div><br/><div id="38514454" class="c"><input type="checkbox" id="c-38514454" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511735">parent</a><span>|</span><a href="#38511707">next</a><span>|</span><label class="collapse" for="c-38514454">[-]</label><label class="expand" for="c-38514454">[2 more]</label></div><br/><div class="children"><div class="content">Yeah that&#x27;s a bug, no amount of buffering can justify that amount of memory.<p>And gron -u in theory should use <i>less</i> memory than gron-ifying a JSON, as you just have to fill a data structure in memory as you go.</div><br/><div id="38514739" class="c"><input type="checkbox" id="c-38514739" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38514454">parent</a><span>|</span><a href="#38511707">next</a><span>|</span><label class="collapse" for="c-38514739">[-]</label><label class="expand" for="c-38514739">[1 more]</label></div><br/><div class="children"><div class="content">&gt; as you just have to fill a data structure in memory as you go<p>You don&#x27;t know the size, shape, or type of any of the levels in the data structure until you get to a line specifying one part of it.  If you did, yep, it would be trivial!</div><br/></div></div></div></div></div></div><div id="38511707" class="c"><input type="checkbox" id="c-38511707" checked=""/><div class="controls bullet"><span class="by">nojs</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511670">parent</a><span>|</span><a href="#38511735">prev</a><span>|</span><a href="#38512371">next</a><span>|</span><label class="collapse" for="c-38511707">[-]</label><label class="expand" for="c-38511707">[1 more]</label></div><br/><div class="children"><div class="content">Deeply nested structures would get expanded a lot</div><br/></div></div><div id="38512371" class="c"><input type="checkbox" id="c-38512371" checked=""/><div class="controls bullet"><span class="by">1letterunixname</span><span>|</span><a href="#38511636">root</a><span>|</span><a href="#38511670">parent</a><span>|</span><a href="#38511707">prev</a><span>|</span><a href="#38511607">next</a><span>|</span><label class="collapse" for="c-38512371">[-]</label><label class="expand" for="c-38512371">[1 more]</label></div><br/><div class="children"><div class="content">What happens when you ignore software engineering.</div><br/></div></div></div></div></div></div><div id="38511607" class="c"><input type="checkbox" id="c-38511607" checked=""/><div class="controls bullet"><span class="by">omeid2</span><span>|</span><a href="#38511636">prev</a><span>|</span><a href="#38512626">next</a><span>|</span><label class="collapse" for="c-38511607">[-]</label><label class="expand" for="c-38511607">[5 more]</label></div><br/><div class="children"><div class="content">As someone who has been using jq for years, my first instinct was why not jq? and while it answers it in the README as well, it is not very clear until you compare the output to jq.<p><pre><code>   $ gron &quot;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;tomnomnom&#x2F;gron&#x2F;commits?per_page=1&quot; | fgrep &quot;commit.author&quot;
   json[0].commit.author = {};
   json[0].commit.author.date = &quot;2016-07-02T10:51:21Z&quot;;
   json[0].commit.author.email = &quot;mail@tomnomnom.com&quot;;
   json[0].commit.author.name = &quot;Tom Hudson&quot;;
</code></pre>
And with jq:<p><pre><code>    $ curl &quot;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;tomnomnom&#x2F;gron&#x2F;commits?per_page=1&quot; | jq &quot;.[].commit.author&quot; 
    {
      &quot;name&quot;: &quot;Tom Hudson&quot;,
      &quot;email&quot;: &quot;mail@tomnomnom.com&quot;,
      &quot;date&quot;: &quot;2022-04-13T14:23:37Z&quot;
    }
</code></pre>
The jq version isn&#x27;t greppable, as you can&#x27;t do `| grep &#x27;.author.email&#x27;` for example.</div><br/><div id="38514376" class="c"><input type="checkbox" id="c-38514376" checked=""/><div class="controls bullet"><span class="by">zimpenfish</span><span>|</span><a href="#38511607">parent</a><span>|</span><a href="#38512465">next</a><span>|</span><label class="collapse" for="c-38514376">[-]</label><label class="expand" for="c-38514376">[1 more]</label></div><br/><div class="children"><div class="content">`gron` is super useful when you don&#x27;t directly know the structure of some JSON - gives you a nice simple path to locate things you can then construct a `jq` query to deal with (since e.g. dealing with multiple items in the same list can be a faff with `gron`.)</div><br/></div></div><div id="38512465" class="c"><input type="checkbox" id="c-38512465" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#38511607">parent</a><span>|</span><a href="#38514376">prev</a><span>|</span><a href="#38512024">next</a><span>|</span><label class="collapse" for="c-38512465">[-]</label><label class="expand" for="c-38512465">[1 more]</label></div><br/><div class="children"><div class="content">Flattening facilitates arbitrary <i>ad hoc</i> transformation.</div><br/></div></div><div id="38512024" class="c"><input type="checkbox" id="c-38512024" checked=""/><div class="controls bullet"><span class="by">inferiorhuman</span><span>|</span><a href="#38511607">parent</a><span>|</span><a href="#38512465">prev</a><span>|</span><a href="#38512666">next</a><span>|</span><label class="collapse" for="c-38512024">[-]</label><label class="expand" for="c-38512024">[1 more]</label></div><br/><div class="children"><div class="content">Theoretically jq can be coerced into printing similar output.  Realistically though if you&#x27;ve already written that jq query and you wanted the email field you&#x27;d just append .email.<p><a href="https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;561460&#x2F;how-to-print-path-and-key-values-of-json-file#answer-760188" rel="nofollow noreferrer">https:&#x2F;&#x2F;unix.stackexchange.com&#x2F;questions&#x2F;561460&#x2F;how-to-print...</a></div><br/></div></div><div id="38512666" class="c"><input type="checkbox" id="c-38512666" checked=""/><div class="controls bullet"><span class="by">ivanhoe</span><span>|</span><a href="#38511607">parent</a><span>|</span><a href="#38512024">prev</a><span>|</span><a href="#38512626">next</a><span>|</span><label class="collapse" for="c-38512666">[-]</label><label class="expand" for="c-38512666">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The jq version isn&#x27;t greppable, as you can&#x27;t do `| grep &#x27;.author.email&#x27;` for example.<p>Truth to be told with jq you don&#x27;t need to grap it, you can grab just emails directly. I find gron a lot more useful for grep -v, that is for filtering out the parts that you don&#x27;t need. Super easy to clean up data.</div><br/></div></div></div></div><div id="38512626" class="c"><input type="checkbox" id="c-38512626" checked=""/><div class="controls bullet"><span class="by">loadzero</span><span>|</span><a href="#38511607">prev</a><span>|</span><a href="#38512591">next</a><span>|</span><label class="collapse" for="c-38512626">[-]</label><label class="expand" for="c-38512626">[1 more]</label></div><br/><div class="children"><div class="content">I use this in my `~&#x2F;.jq` when I have a problem like this.<p><pre><code>    def flat_json_keys:
        [leaf_paths as $path | {&quot;key&quot;: $path | map(if (type==&quot;string&quot;) then (if (test(&quot;([?:\\W]+)&quot;)) then &quot;[&#x27;&quot;+.+&quot;&#x27;]&quot;  else . end) else &quot;[&quot;+tostring+&quot;]&quot; end) | join(&quot;.&quot;) | gsub(&quot;.\\[&quot;;&quot;[&quot;) , &quot;value&quot;: getpath($path)}] | from_entries;

    def ukeys:
        keys_unsorted;
</code></pre>
Use like so:<p><pre><code>    cat wat.json | jq flat_json_keys</code></pre></div><br/></div></div><div id="38512591" class="c"><input type="checkbox" id="c-38512591" checked=""/><div class="controls bullet"><span class="by">markbnj</span><span>|</span><a href="#38512626">prev</a><span>|</span><a href="#38511547">next</a><span>|</span><label class="collapse" for="c-38512591">[-]</label><label class="expand" for="c-38512591">[1 more]</label></div><br/><div class="children"><div class="content">Thumbs up for gron. Been using it for a couple of years to get the jsonpath to a property I need. It&#x27;s super handy with kubectl and other ctls of the sort.</div><br/></div></div><div id="38511547" class="c"><input type="checkbox" id="c-38511547" checked=""/><div class="controls bullet"><span class="by">rauljara</span><span>|</span><a href="#38512591">prev</a><span>|</span><a href="#38511886">next</a><span>|</span><label class="collapse" for="c-38511547">[-]</label><label class="expand" for="c-38511547">[2 more]</label></div><br/><div class="children"><div class="content">Hmmmâ¦ at first glance, this feels like Iâd use it for the same sorts of things Iâd use jq for, only easier to use but also way less powerful.  Jq does have a little bit of a learning curve necessary to get good use out of it, so I could see this being a nice quick tool for people who donât want to make that investment. Having already learned jq, Iâm not sure why I would reach for gron, but maybe Iâm missing something.</div><br/><div id="38512484" class="c"><input type="checkbox" id="c-38512484" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#38511547">parent</a><span>|</span><a href="#38511886">next</a><span>|</span><label class="collapse" for="c-38512484">[-]</label><label class="expand" for="c-38512484">[1 more]</label></div><br/><div class="children"><div class="content">Not missing, retaining something: the details of jq.  Many developers find this difficult for usual and rarely used tools.  See also bash.</div><br/></div></div></div></div><div id="38511886" class="c"><input type="checkbox" id="c-38511886" checked=""/><div class="controls bullet"><span class="by">mongol</span><span>|</span><a href="#38511547">prev</a><span>|</span><a href="#38512077">next</a><span>|</span><label class="collapse" for="c-38511886">[-]</label><label class="expand" for="c-38511886">[1 more]</label></div><br/><div class="children"><div class="content">The idea is pretty brilliant, but it is not a new one.  I remember a similar program about 20 years ago when XML was all the rage. I don&#x27;t recall the name but something like &quot;py*&quot; I think.<p>Edit: I found it. It was called pyx. 
<a href="https:&#x2F;&#x2F;www.xml.com&#x2F;pub&#x2F;2000&#x2F;03&#x2F;15&#x2F;feature&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.xml.com&#x2F;pub&#x2F;2000&#x2F;03&#x2F;15&#x2F;feature&#x2F;index.html</a>
<a href="https:&#x2F;&#x2F;xmlstar.sourceforge.net&#x2F;doc&#x2F;UG&#x2F;ch04s07.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;xmlstar.sourceforge.net&#x2F;doc&#x2F;UG&#x2F;ch04s07.html</a></div><br/></div></div><div id="38512077" class="c"><input type="checkbox" id="c-38512077" checked=""/><div class="controls bullet"><span class="by">xonix</span><span>|</span><a href="#38511886">prev</a><span>|</span><a href="#38511613">next</a><span>|</span><label class="collapse" for="c-38512077">[-]</label><label class="expand" for="c-38512077">[2 more]</label></div><br/><div class="children"><div class="content">My pure-AWK variant: <a href="https:&#x2F;&#x2F;github.com&#x2F;xonixx&#x2F;gron.awk">https:&#x2F;&#x2F;github.com&#x2F;xonixx&#x2F;gron.awk</a> (features complete JSON parser in AWK).</div><br/><div id="38512454" class="c"><input type="checkbox" id="c-38512454" checked=""/><div class="controls bullet"><span class="by">kermatt</span><span>|</span><a href="#38512077">parent</a><span>|</span><a href="#38511613">next</a><span>|</span><label class="collapse" for="c-38512454">[-]</label><label class="expand" for="c-38512454">[1 more]</label></div><br/><div class="children"><div class="content">Has this been tested against Mawk? I often see performance benefits with Mawk, when the Awk script does not need any Gawk specific functions.<p>I&#x27;m looking at the test suite, trying to figure out how to get it to emit test failure details:<p><pre><code>  .&#x2F;makesure test_suite
  mawk -f run_json_test_suit.awk
  ...
  Successes: 186
  Fails:     152</code></pre></div><br/></div></div></div></div><div id="38511613" class="c"><input type="checkbox" id="c-38511613" checked=""/><div class="controls bullet"><span class="by">slt2021</span><span>|</span><a href="#38512077">prev</a><span>|</span><a href="#38511757">next</a><span>|</span><label class="collapse" for="c-38511613">[-]</label><label class="expand" for="c-38511613">[1 more]</label></div><br/><div class="children"><div class="content">This is awesome!<p>I am going to try to use it to make surgical edits to the terraform state file, in rare cases when I have to.<p>Some terraform providers would rather delete and recreate resource, while a simple edit would do the trick for me</div><br/></div></div><div id="38511757" class="c"><input type="checkbox" id="c-38511757" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38511613">prev</a><span>|</span><a href="#38512516">next</a><span>|</span><label class="collapse" for="c-38511757">[-]</label><label class="expand" for="c-38511757">[1 more]</label></div><br/><div class="children"><div class="content">Related:<p><i>Gron â Make JSON Greppable</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25006277">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=25006277</a> - Nov 2020 (91 comments)<p><i>Gron: A command line tool that makes JSON greppable</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16727665">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=16727665</a> - April 2018 (51 comments)</div><br/></div></div><div id="38512516" class="c"><input type="checkbox" id="c-38512516" checked=""/><div class="controls bullet"><span class="by">hyperthesis</span><span>|</span><a href="#38511757">prev</a><span>|</span><a href="#38512162">next</a><span>|</span><label class="collapse" for="c-38512516">[-]</label><label class="expand" for="c-38512516">[1 more]</label></div><br/><div class="children"><div class="content">Could a jq have a more C-like syntax?<p>JSON is already C-like <a href="https:&#x2F;&#x2F;www.json.org&#x2F;json-en.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.json.org&#x2F;json-en.html</a> and jq uses  dot-separated paths for chaining name&#x2F;value accesses.</div><br/></div></div><div id="38512162" class="c"><input type="checkbox" id="c-38512162" checked=""/><div class="controls bullet"><span class="by">LVB</span><span>|</span><a href="#38512516">prev</a><span>|</span><a href="#38511528">next</a><span>|</span><label class="collapse" for="c-38512162">[-]</label><label class="expand" for="c-38512162">[1 more]</label></div><br/><div class="children"><div class="content">gron is one of my favorite tools because I don&#x27;t do this type of searching as much anymore and can&#x27;t remember the options for more advanced tools (jq, etc). I can easily and confidently compose from gron -&gt; grep though.</div><br/></div></div><div id="38511528" class="c"><input type="checkbox" id="c-38511528" checked=""/><div class="controls bullet"><span class="by">blcknight</span><span>|</span><a href="#38512162">prev</a><span>|</span><a href="#38512963">next</a><span>|</span><label class="collapse" for="c-38511528">[-]</label><label class="expand" for="c-38511528">[1 more]</label></div><br/><div class="children"><div class="content">This is brilliant, I can&#x27;t wait to have a json problem to try it out.</div><br/></div></div><div id="38512963" class="c"><input type="checkbox" id="c-38512963" checked=""/><div class="controls bullet"><span class="by">tanelpoder</span><span>|</span><a href="#38511528">prev</a><span>|</span><a href="#38511567">next</a><span>|</span><label class="collapse" for="c-38512963">[-]</label><label class="expand" for="c-38512963">[1 more]</label></div><br/><div class="children"><div class="content">I like how the description is just 3 words and clearly communicates what this tool  is about.</div><br/></div></div><div id="38511567" class="c"><input type="checkbox" id="c-38511567" checked=""/><div class="controls bullet"><span class="by">derwildemomo</span><span>|</span><a href="#38512963">prev</a><span>|</span><a href="#38513796">next</a><span>|</span><label class="collapse" for="c-38511567">[-]</label><label class="expand" for="c-38511567">[1 more]</label></div><br/><div class="children"><div class="content">Great idea, definitely makes sense when you have that kind of problem.<p>Also the username of the author made me chuckle, bonus points for that.</div><br/></div></div><div id="38513796" class="c"><input type="checkbox" id="c-38513796" checked=""/><div class="controls bullet"><span class="by">wonnage</span><span>|</span><a href="#38511567">prev</a><span>|</span><a href="#38511652">next</a><span>|</span><label class="collapse" for="c-38513796">[-]</label><label class="expand" for="c-38513796">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if you could accomplish the same with structural search tools like Comby (<a href="https:&#x2F;&#x2F;comby.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;comby.dev&#x2F;</a>) - with the bonus that you can target specific levels of beating since it&#x27;s syntax-aware</div><br/></div></div><div id="38511652" class="c"><input type="checkbox" id="c-38511652" checked=""/><div class="controls bullet"><span class="by">Eumenes</span><span>|</span><a href="#38513796">prev</a><span>|</span><a href="#38511505">next</a><span>|</span><label class="collapse" for="c-38511652">[-]</label><label class="expand" for="c-38511652">[1 more]</label></div><br/><div class="children"><div class="content">can see this being useful for pentesting, jq is fine but always have to look at documentation and relearn it every few weeks&#x2F;months</div><br/></div></div><div id="38511505" class="c"><input type="checkbox" id="c-38511505" checked=""/><div class="controls bullet"><span class="by">g105b</span><span>|</span><a href="#38511652">prev</a><span>|</span><a href="#38511874">next</a><span>|</span><label class="collapse" for="c-38511505">[-]</label><label class="expand" for="c-38511505">[1 more]</label></div><br/><div class="children"><div class="content">Looks like an interesting tool. I use jq for any JSON related task, but it can often be finicky and complex when I just need to get at a value or search for something.<p>Looks like gron would be a nice addition to my workflow with JSON tasks.</div><br/></div></div><div id="38511874" class="c"><input type="checkbox" id="c-38511874" checked=""/><div class="controls bullet"><span class="by">okbrown</span><span>|</span><a href="#38511505">prev</a><span>|</span><a href="#38512757">next</a><span>|</span><label class="collapse" for="c-38511874">[-]</label><label class="expand" for="c-38511874">[2 more]</label></div><br/><div class="children"><div class="content">So what&#x27;s the issue with jq?</div><br/><div id="38512137" class="c"><input type="checkbox" id="c-38512137" checked=""/><div class="controls bullet"><span class="by">mplewis</span><span>|</span><a href="#38511874">parent</a><span>|</span><a href="#38512757">next</a><span>|</span><label class="collapse" for="c-38512137">[-]</label><label class="expand" for="c-38512137">[1 more]</label></div><br/><div class="children"><div class="content">You can&#x27;t grep a deep keypath using jq.</div><br/></div></div></div></div></div></div></div></div></div></body></html>