<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1708506072825" as="style"/><link rel="stylesheet" href="styles.css?v=1708506072825"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.hillelwayne.com/post/picat/">Planner programming blows my mind</a> <span class="domain">(<a href="https://www.hillelwayne.com">www.hillelwayne.com</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>34 comments</span></div><br/><div><div id="39448114" class="c"><input type="checkbox" id="c-39448114" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#39448248">next</a><span>|</span><label class="collapse" for="c-39448114">[-]</label><label class="expand" for="c-39448114">[17 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually used Picat&#x27;s planning mode at work!<p>I prototyped a system to orchestrate maintenance on fleets of devices. The idea was that, rather than telling the system <i>how</i> to do it (e.g. workflows to roll out an update), you&#x27;d tell the system what you wanted (e.g. up to date machines), what actions were available (e.g. pull a machine from rotation, apply an update), and what constraints to obey (e.g. X of Y machines must be online, don&#x27;t work in more than two regions simultaneously.)<p>I modeled a few scenarios like that in Picat and had it generate optimal plans. It worked swimmingly for pet problems, but predictably fell over scaling to cattle sizes. Planning is EXPTIME after all (e.g. Towers of Hanoi).*<p>Picat does have an escape hatch - you can define heuristics - so I built a random forest of state predicates and trained a naive Bayes classifier to predict fruitful paths. But even with that, and symmetry breaking constraints, and even some hierarchical planning, I couldn&#x27;t make it work without too much handholding.<p>It&#x27;s still AI winter for the classic GOFAI problem domains, apparently. :&#x2F;<p>* <i>maybe not, actually, if you reformulate the planning problem as returning a polynomial-time generator of a potentially exponentially long plan</i></div><br/><div id="39449187" class="c"><input type="checkbox" id="c-39449187" checked=""/><div class="controls bullet"><span class="by">7thaccount</span><span>|</span><a href="#39448114">parent</a><span>|</span><a href="#39448394">next</a><span>|</span><label class="collapse" for="c-39449187">[-]</label><label class="expand" for="c-39449187">[13 more]</label></div><br/><div class="children"><div class="content">There are plenty of commercial solvers out there that beat the pants off the open source options in terms of performance and in terms of depleting one&#x27;s wallet :)<p>CPLEX, Xpress, GUROBI, and Hexaly all come to mind. Hexaly is really good for scheduling problems and things like vehicle routing. You typically access these via an API they offer you for the popular industry languages. This approach seems to make a lot more sense to me than having a dedicated solver language that isn&#x27;t as good for all the general purpose stuff. Calling GUROBI from Python is a breeze as is all the standard stuff in Python. Mosek is a lot cheaper than GUROBI, but both of it&#x27;s APIs are extremely low level and the performance isn&#x27;t as good as GUROBI either.</div><br/><div id="39451591" class="c"><input type="checkbox" id="c-39451591" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449187">parent</a><span>|</span><a href="#39449356">next</a><span>|</span><label class="collapse" for="c-39451591">[-]</label><label class="expand" for="c-39451591">[1 more]</label></div><br/><div class="children"><div class="content">If any of these had reasonable pricing I’d be happy to pay, but if the first price you see is ‘contact us’ you can be certain it’s too much for hobby use…</div><br/></div></div><div id="39449356" class="c"><input type="checkbox" id="c-39449356" checked=""/><div class="controls bullet"><span class="by">shoo</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449187">parent</a><span>|</span><a href="#39451591">prev</a><span>|</span><a href="#39449391">next</a><span>|</span><label class="collapse" for="c-39449356">[-]</label><label class="expand" for="c-39449356">[1 more]</label></div><br/><div class="children"><div class="content">Yup. &amp; when you get a model that works matched up with an industrial scale decision problem that&#x27;s valuable to solve, arguably it&#x27;s only of academic interest if you can solve it &quot;optimally&quot;. The problem is only a simplified model of reality anyway -- it&#x27;s often better to get a quick close-enough approximate solution to a problem that&#x27;s a good approximation of the situation than an exact optimal solution to a simpler problem that&#x27;s a poorer approximation.<p>If you&#x27;re lucky enough to get a problem that&#x27;s basically stable over time, where the problem structure doesn&#x27;t change, then maybe you can get improved solutions rapidly at industrial scale replacing use of a black-box MIP solver like Gurobi&#x2F;CPLEX with a decomposition that exploits the problem structure, where sub-problems can be solved by some specialized graph algorithm or heuristic or brute force (if they all have bounded size), and the general purpose MIP&#x2F;LP solver can be left with the job of figuring out how to deal with the shared resources and constraints that bind the subproblems together.  The downside to a highly specialised custom solver is that it usually isn&#x27;t flexible to changing requirements (unless you get very lucky) -- a slight change in business rule can break the problem structure that underpins the entire solution approach.</div><br/></div></div><div id="39449391" class="c"><input type="checkbox" id="c-39449391" checked=""/><div class="controls bullet"><span class="by">polivier</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449187">parent</a><span>|</span><a href="#39449356">prev</a><span>|</span><a href="#39449850">next</a><span>|</span><label class="collapse" for="c-39449391">[-]</label><label class="expand" for="c-39449391">[4 more]</label></div><br/><div class="children"><div class="content">&gt; There are plenty of commercial solvers out there that beat the pants off the open source options in terms of performance and in terms of depleting one&#x27;s wallet :)<p>While this is generally true, there are some exceptions. I recently compared the performance of CP-SAT vs CPLEX for a problem (linear constraints and objective). For large instances where proving optimality in a reasonable time was out of the question, CP-SAT had much faster convergence to near-optimal solutions than CPLEX when the time limit was small enough (~30s to a few minutes). This is with the CPLEX solver tuned towards improving the upper bound as much as possible (it was a minimization problem).</div><br/><div id="39449565" class="c"><input type="checkbox" id="c-39449565" checked=""/><div class="controls bullet"><span class="by">whatever1</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449391">parent</a><span>|</span><a href="#39449850">next</a><span>|</span><label class="collapse" for="c-39449565">[-]</label><label class="expand" for="c-39449565">[3 more]</label></div><br/><div class="children"><div class="content">If feasibility is your goal then cp&#x2F;sat solvers&#x2F;heuristics should be your tool of choice.<p>I you have optimality requirements (aka from the feasible solutions find the absolutely best) then optimization is the way to go</div><br/><div id="39451168" class="c"><input type="checkbox" id="c-39451168" checked=""/><div class="controls bullet"><span class="by">polivier</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449565">parent</a><span>|</span><a href="#39450541">next</a><span>|</span><label class="collapse" for="c-39451168">[-]</label><label class="expand" for="c-39451168">[1 more]</label></div><br/><div class="children"><div class="content">I think that you&#x27;ve misunderstood what I said. For large instances of this specific problem (and when the time limit is too short to allow either CP-SAT or CPLEX to prove optimality) the best integer feasible solution found by CP-SAT is generally of better quality (w.r.t. the objective value) than the best integer feasible solution found by CPLEX. Furthermore, in some cases, CP-SAT can offer a certificate of optimality faster than CPLEX.</div><br/></div></div><div id="39450541" class="c"><input type="checkbox" id="c-39450541" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449565">parent</a><span>|</span><a href="#39451168">prev</a><span>|</span><a href="#39449850">next</a><span>|</span><label class="collapse" for="c-39450541">[-]</label><label class="expand" for="c-39450541">[1 more]</label></div><br/><div class="children"><div class="content">can&#x27;t you just use the strong duality theorem to reframe an integral optimization problem as a system of integer inequalities? I thought you usually don&#x27;t do that because the satisfaction problem is harder in practice.</div><br/></div></div></div></div></div></div><div id="39449850" class="c"><input type="checkbox" id="c-39449850" checked=""/><div class="controls bullet"><span class="by">TimTheTinker</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449187">parent</a><span>|</span><a href="#39449391">prev</a><span>|</span><a href="#39450497">next</a><span>|</span><label class="collapse" for="c-39449850">[-]</label><label class="expand" for="c-39449850">[3 more]</label></div><br/><div class="children"><div class="content">Are the commercial offerings you mentioned better than TimeFold? [0] (formerly known as OptaPlanner before the main developers forked it)<p>TimeFold&#x27;s heuristics-based approach makes fast solutions to even highly-complex scenarios within the reach of anyone who can write Java or Python expressions that evaluate to true when constraints are satisfied.<p>[0] <a href="https:&#x2F;&#x2F;timefold.ai&#x2F;" rel="nofollow">https:&#x2F;&#x2F;timefold.ai&#x2F;</a></div><br/><div id="39451610" class="c"><input type="checkbox" id="c-39451610" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449850">parent</a><span>|</span><a href="#39451603">next</a><span>|</span><label class="collapse" for="c-39451610">[-]</label><label class="expand" for="c-39451610">[1 more]</label></div><br/><div class="children"><div class="content">[delayed]</div><br/></div></div><div id="39451603" class="c"><input type="checkbox" id="c-39451603" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449850">parent</a><span>|</span><a href="#39451610">prev</a><span>|</span><a href="#39450497">next</a><span>|</span><label class="collapse" for="c-39451603">[-]</label><label class="expand" for="c-39451603">[1 more]</label></div><br/><div class="children"><div class="content">I found Optaplanner to be nice, but supremely unergonomic to use. I could replicate their example problems and not much else.</div><br/></div></div></div></div><div id="39450497" class="c"><input type="checkbox" id="c-39450497" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449187">parent</a><span>|</span><a href="#39449850">prev</a><span>|</span><a href="#39449961">next</a><span>|</span><label class="collapse" for="c-39450497">[-]</label><label class="expand" for="c-39450497">[1 more]</label></div><br/><div class="children"><div class="content">Gurobi is a MIP solver right, not a planner? I use Gurobi at work for a certain kind of bi-level programming and it&#x27;s amazing, like literally ~500x faster than CBC. Picat&#x27;s planner is more like a Prolog flavor of PDDL (e.g. fast-downward and its ilk.)</div><br/></div></div><div id="39449961" class="c"><input type="checkbox" id="c-39449961" checked=""/><div class="controls bullet"><span class="by">eigenvalue</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449187">parent</a><span>|</span><a href="#39450497">prev</a><span>|</span><a href="#39448394">next</a><span>|</span><label class="collapse" for="c-39449961">[-]</label><label class="expand" for="c-39449961">[2 more]</label></div><br/><div class="children"><div class="content">What about this one:<p><a href="https:&#x2F;&#x2F;www.cvxpy.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.cvxpy.org&#x2F;</a><p>If you can convert your problem into a convex one (which I believe is often possible if you’re clever about how you express it), that would seem to be a pretty good option, no?</div><br/><div id="39451284" class="c"><input type="checkbox" id="c-39451284" checked=""/><div class="controls bullet"><span class="by">mlsu</span><span>|</span><a href="#39448114">root</a><span>|</span><a href="#39449961">parent</a><span>|</span><a href="#39448394">next</a><span>|</span><label class="collapse" for="c-39451284">[-]</label><label class="expand" for="c-39451284">[1 more]</label></div><br/><div class="children"><div class="content">CVXpy is a frontend that transforms problems into a form that different solvers can understand.<p>It does make it very easy to format problems in Python but you still need a solver like Gurobi on the backend. You can use a variety of solvers on the same problem though, which is nice:<p><a href="https:&#x2F;&#x2F;www.cvxpy.org&#x2F;tutorial&#x2F;advanced&#x2F;index.html#choosing-a-solver" rel="nofollow">https:&#x2F;&#x2F;www.cvxpy.org&#x2F;tutorial&#x2F;advanced&#x2F;index.html#choosing-...</a><p>My understanding is that Gurobi the best -- but also the most expensive.</div><br/></div></div></div></div></div></div><div id="39448394" class="c"><input type="checkbox" id="c-39448394" checked=""/><div class="controls bullet"><span class="by">polivier</span><span>|</span><a href="#39448114">parent</a><span>|</span><a href="#39449187">prev</a><span>|</span><a href="#39449143">next</a><span>|</span><label class="collapse" for="c-39448394">[-]</label><label class="expand" for="c-39448394">[1 more]</label></div><br/><div class="children"><div class="content">It is possible that something like CP-SAT (<a href="https:&#x2F;&#x2F;developers.google.com&#x2F;optimization&#x2F;cp" rel="nofollow">https:&#x2F;&#x2F;developers.google.com&#x2F;optimization&#x2F;cp</a>) would have scaled well in your case. This solver easily handles an absurd amount of variables and constraints, and has excellent heuristics built-in.</div><br/></div></div><div id="39449143" class="c"><input type="checkbox" id="c-39449143" checked=""/><div class="controls bullet"><span class="by">OJFord</span><span>|</span><a href="#39448114">parent</a><span>|</span><a href="#39448394">prev</a><span>|</span><a href="#39449137">next</a><span>|</span><label class="collapse" for="c-39449143">[-]</label><label class="expand" for="c-39449143">[1 more]</label></div><br/><div class="children"><div class="content">So it&#x27;s not actually different (in result&#x2F;performance) from the depth-first search you&#x27;d get naïvely mashing some keys dimly recalling prolog?</div><br/></div></div><div id="39449137" class="c"><input type="checkbox" id="c-39449137" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#39448114">parent</a><span>|</span><a href="#39449143">prev</a><span>|</span><a href="#39448248">next</a><span>|</span><label class="collapse" for="c-39449137">[-]</label><label class="expand" for="c-39449137">[1 more]</label></div><br/><div class="children"><div class="content">&quot;Planning is EXPTIME after all (e.g. Towers of Hanoi).*&quot;<p>The old planners would include meta-rules, or heuristics, that decided which rules to apply. That would cut the search space. Some split the problem into different representations with specialized, automated solvers. Jahob Analysis System and Cyc come to mind.<p>Far as for real-world use, the neatest design I remember from classic A.I. was the Procedural Reasoning System. I&#x27;ve always wanted to see a version of it rebuilt with modern methods supplementing its weaknesses. Just for kicks and to see what it could do.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Procedural_reasoning_system" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Procedural_reasoning_system</a></div><br/></div></div></div></div><div id="39448248" class="c"><input type="checkbox" id="c-39448248" checked=""/><div class="controls bullet"><span class="by">polivier</span><span>|</span><a href="#39448114">prev</a><span>|</span><a href="#39450670">next</a><span>|</span><label class="collapse" for="c-39448248">[-]</label><label class="expand" for="c-39448248">[1 more]</label></div><br/><div class="children"><div class="content">For those interested, HN user hakank (Hakan Kjellerstrand), who is a very active member of the constraint programming community (among others), has a ton of Picat resources and examples on his website: <a href="http:&#x2F;&#x2F;www.hakank.org&#x2F;picat&#x2F;" rel="nofollow">http:&#x2F;&#x2F;www.hakank.org&#x2F;picat&#x2F;</a></div><br/></div></div><div id="39450670" class="c"><input type="checkbox" id="c-39450670" checked=""/><div class="controls bullet"><span class="by">asciimike</span><span>|</span><a href="#39448248">prev</a><span>|</span><a href="#39451520">next</a><span>|</span><label class="collapse" for="c-39450670">[-]</label><label class="expand" for="c-39450670">[1 more]</label></div><br/><div class="children"><div class="content">Pleasantly surprised to see Predrag show up as a reviewer, but at the same time not at all surprised:<p>- The [Firebase technical screen](<a href="https:&#x2F;&#x2F;startupandrew.com&#x2F;posts&#x2F;how-firebase-interviewed-software-engineers&#x2F;" rel="nofollow">https:&#x2F;&#x2F;startupandrew.com&#x2F;posts&#x2F;how-firebase-interviewed-sof...</a>) would have been much easier with something like this, as it was Just Another Optimization Problem™. Part of me wants to try it again with Picat!<p>- He&#x27;s doing other very interesting things with programming languages, e.g.: <a href="https:&#x2F;&#x2F;github.com&#x2F;obi1kenobi&#x2F;trustfall">https:&#x2F;&#x2F;github.com&#x2F;obi1kenobi&#x2F;trustfall</a></div><br/></div></div><div id="39451520" class="c"><input type="checkbox" id="c-39451520" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#39450670">prev</a><span>|</span><a href="#39449188">next</a><span>|</span><label class="collapse" for="c-39451520">[-]</label><label class="expand" for="c-39451520">[1 more]</label></div><br/><div class="children"><div class="content">Really hating the trend of putting half of the document behind series of “click here to unhide the content” dropdowns.</div><br/></div></div><div id="39449188" class="c"><input type="checkbox" id="c-39449188" checked=""/><div class="controls bullet"><span class="by">pcthrowaway</span><span>|</span><a href="#39451520">prev</a><span>|</span><a href="#39450378">next</a><span>|</span><label class="collapse" for="c-39449188">[-]</label><label class="expand" for="c-39449188">[1 more]</label></div><br/><div class="children"><div class="content">My first thought was, this looks like a type system, except you need to solve it yourself. In Typesecript, naively:<p><pre><code>    const main = &lt;a extends any, b extends any, c extends any&gt;([a_, b_, c_]: [a, b, c, a]) =&gt; {
      type SomeTuple = [a, b, c, a];
      const X: a = a_;
      const Y: Exclude&lt;SomeTuple, a&gt; &#x2F;&#x2F; = &lt;put solved value here, get a type error if the value does not satisfy the constraints&gt;
      console.log(X, Y);
    }
</code></pre>
Except nothing solves this because a, b, and c can all be the same. After trying to express this correctly, I ended up with something that <i>appears</i> useable (but that still uses assertions and doesn&#x27;t really express the type of Y correctly).<p><pre><code>    type Narrowable = string | number | bigint | boolean;
    &#x2F;*
      Express the type of a value in a tuple that is not the type of the second parameter
      For example:
      - ValOfTupleExceptFor&lt;[1,1,6,2,3], 1&gt; -&gt; 6
      - ValOfTupleExceptFor&lt;[1,1,6,2,3], 6&gt; -&gt; 1
    *&#x2F;
    type ValOfTupleExceptFor&lt;
      Tup extends readonly Narrowable[],
      Val extends Tup[number]
    &gt; = Tup extends [infer First, ...(infer Rest extends Narrowable[])]
      ? First extends Val
        ? Rest extends []
          ? never
          : ValOfTupleExceptFor&lt;Rest, Val&gt;
        : First
      : never;
    
    const NO_SOLUTION: unique symbol = Symbol(&#x27;NO_SOLUTION&#x27;)
    const getValOfTupleExcluding = (tup: readonly Narrowable[], val: (typeof tup)[number]): ValOfTupleExceptFor&lt;typeof tup, typeof val&gt; =&gt; {
      const [first, ...rest] = tup;
      if (!first) {
        return NO_SOLUTION as never;
      }
      if (first === val) {
        return getValOfTupleExcluding(rest, val);
      }
      return first as ValOfTupleExceptFor&lt;typeof tup, typeof val&gt;;
    }
    
    const main = &lt;a extends Narrowable, b extends Narrowable, c extends Narrowable&gt;([a_, b_, c_]: [a, b, c, a]) =&gt; {
      const someTuple = [a_, b_, c_, a_] as const;
      const X: a = a_;
      &#x2F;&#x2F; This still resolves to type &#x27;never&#x27;
      const Y: ValOfTupleExceptFor&lt;typeof someTuple, a&gt; = getValOfTupleExcluding(someTuple, a_);
      console.log(X, Y);
    }
</code></pre>
Which really highlights how powerful the &#x27;planner&#x27; style program is in terms of simplicity and conciseness. I guess Typescript isn&#x27;t even powerful enough to express this kind of constraint.<p>edit: TS playground link with some experiments if anyone&#x27;s interested: <a href="http:&#x2F;&#x2F;tinyurl.com&#x2F;3p2pzdtn" rel="nofollow">http:&#x2F;&#x2F;tinyurl.com&#x2F;3p2pzdtn</a></div><br/></div></div><div id="39450378" class="c"><input type="checkbox" id="c-39450378" checked=""/><div class="controls bullet"><span class="by">crabmusket</span><span>|</span><a href="#39449188">prev</a><span>|</span><a href="#39448042">next</a><span>|</span><label class="collapse" for="c-39450378">[-]</label><label class="expand" for="c-39450378">[1 more]</label></div><br/><div class="children"><div class="content">Nice to see GOAP being referenced again. It was the secret sauce that made F.E.A.R.&#x27;s enemies so fun. And Jeff Orkin&#x27;s paper on how it works is very readable and entertaining.</div><br/></div></div><div id="39448042" class="c"><input type="checkbox" id="c-39448042" checked=""/><div class="controls bullet"><span class="by">rad_gruchalski</span><span>|</span><a href="#39450378">prev</a><span>|</span><a href="#39449882">next</a><span>|</span><label class="collapse" for="c-39448042">[-]</label><label class="expand" for="c-39448042">[3 more]</label></div><br/><div class="children"><div class="content">Looks Prolog-ish. Interesting, thanks for sharing.</div><br/><div id="39448680" class="c"><input type="checkbox" id="c-39448680" checked=""/><div class="controls bullet"><span class="by">hwayne</span><span>|</span><a href="#39448042">parent</a><span>|</span><a href="#39449882">next</a><span>|</span><label class="collapse" for="c-39448680">[-]</label><label class="expand" for="c-39448680">[2 more]</label></div><br/><div class="children"><div class="content">AFAICT Picat is a direct descendant of B-Prolog and shares a lot of idioms (like tabling) with it. <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;B-Prolog" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;B-Prolog</a></div><br/><div id="39449870" class="c"><input type="checkbox" id="c-39449870" checked=""/><div class="controls bullet"><span class="by">OhMeadhbh</span><span>|</span><a href="#39448042">root</a><span>|</span><a href="#39448680">parent</a><span>|</span><a href="#39449882">next</a><span>|</span><label class="collapse" for="c-39449870">[-]</label><label class="expand" for="c-39449870">[1 more]</label></div><br/><div class="children"><div class="content">THX for the reference.  I used Prolog a fair amount in the 90s, but didn&#x27;t know about B-Prolog.  Now I do.<p>And I came here to make @rad_gruchalski&#x27;s comment. So... thx for making that comment so I don&#x27;t have to.</div><br/></div></div></div></div></div></div><div id="39449882" class="c"><input type="checkbox" id="c-39449882" checked=""/><div class="controls bullet"><span class="by">fumeux_fume</span><span>|</span><a href="#39448042">prev</a><span>|</span><a href="#39449121">next</a><span>|</span><label class="collapse" for="c-39449882">[-]</label><label class="expand" for="c-39449882">[3 more]</label></div><br/><div class="children"><div class="content">Is this related to Answer Set Programming? Seems like there’s an overlap.</div><br/><div id="39450642" class="c"><input type="checkbox" id="c-39450642" checked=""/><div class="controls bullet"><span class="by">sterlind</span><span>|</span><a href="#39449882">parent</a><span>|</span><a href="#39449121">next</a><span>|</span><label class="collapse" for="c-39450642">[-]</label><label class="expand" for="c-39450642">[2 more]</label></div><br/><div class="children"><div class="content">they&#x27;re syntactically related in that both come from the Prolog world, and you can indeed use ASP to do planning (there&#x27;s examples of Towers of Hanoi and Blockworld in the ASP guidebook), and you can incorporate heuristics into ASP.<p>...but actually they&#x27;re really different!<p>ASP isn&#x27;t Turing-complete - it&#x27;s a lot more like an SMT solver. crucially, there&#x27;s a <i>grounding</i> stage, where the set of every expressible term in the model (its Herbrand universe) is explicitly written down. so if you have e.g. `f(a;b). g(X,Y) :- f(X),f(Y).` then it will write out every expansion of g during pre-processing.<p>this makes ASP very powerful, and very fast even at complex problems, but it dooms the solver if the universe is large.<p>in contrast, Picat is basically a souped up Prolog. it&#x27;s a full programming language, and it doesn&#x27;t require grounding so infinite state spaces are okay. it leverages its tabling mechanism to memo-ize predicates evaluation, and it automatically manages the time&#x2F;space tradeoff with search, which is nifty. but at the end of the day it&#x27;s brute force, not deep witchcraft like Z3.</div><br/><div id="39451150" class="c"><input type="checkbox" id="c-39451150" checked=""/><div class="controls bullet"><span class="by">fumeux_fume</span><span>|</span><a href="#39449882">root</a><span>|</span><a href="#39450642">parent</a><span>|</span><a href="#39449121">next</a><span>|</span><label class="collapse" for="c-39451150">[-]</label><label class="expand" for="c-39451150">[1 more]</label></div><br/><div class="children"><div class="content">I see, thanks for your explanation!</div><br/></div></div></div></div></div></div><div id="39449253" class="c"><input type="checkbox" id="c-39449253" checked=""/><div class="controls bullet"><span class="by">bloaf</span><span>|</span><a href="#39449121">prev</a><span>|</span><a href="#39451390">next</a><span>|</span><label class="collapse" for="c-39449253">[-]</label><label class="expand" for="c-39449253">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a little confused about how planning is different from vector reachability, which, from what I understand, has Ackermann complexity rather than EXPTIME.  Can anyone help me out with the constraints on &quot;planning&quot; that allow it to be solved in a sane amount of time?<p><a href="https:&#x2F;&#x2F;www.quantamagazine.org&#x2F;an-easy-sounding-problem-yields-numbers-too-big-for-our-universe-20231204&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.quantamagazine.org&#x2F;an-easy-sounding-problem-yiel...</a></div><br/><div id="39449971" class="c"><input type="checkbox" id="c-39449971" checked=""/><div class="controls bullet"><span class="by">eru</span><span>|</span><a href="#39449253">parent</a><span>|</span><a href="#39449502">next</a><span>|</span><label class="collapse" for="c-39449971">[-]</label><label class="expand" for="c-39449971">[1 more]</label></div><br/><div class="children"><div class="content">&gt; [...] from what I understand, has Ackermann complexity rather than EXPTIME.<p>Really bad worst case times aren&#x27;t necessarily bad in practice, if most instances you actually encounter can be solved quickly (especially if you are happy to be satisfied with worse than proven-optimal solutions.)<p>Compare how Hindley-Milner type inference, which forms the basis of Rust&#x27;s or Haskell&#x27;s type systems, is double-exponential in the worst case (or something like that), but typically fast in practice.</div><br/></div></div><div id="39449502" class="c"><input type="checkbox" id="c-39449502" checked=""/><div class="controls bullet"><span class="by">nickpsecurity</span><span>|</span><a href="#39449253">parent</a><span>|</span><a href="#39449971">prev</a><span>|</span><a href="#39451390">next</a><span>|</span><label class="collapse" for="c-39449502">[-]</label><label class="expand" for="c-39449502">[1 more]</label></div><br/><div class="children"><div class="content">We normally pick up stuff like that in papers, blog posts, etc. The only heuristics book I remember was How to Solve It. I also found a survey paper on heuristics. Here they are in case they help:<p><a href="https:&#x2F;&#x2F;www.amazon.com&#x2F;How-Solve-Heuristics-Zbigniew-Michalewicz&#x2F;dp&#x2F;3540224947" rel="nofollow">https:&#x2F;&#x2F;www.amazon.com&#x2F;How-Solve-Heuristics-Zbigniew-Michale...</a><p><a href="https:&#x2F;&#x2F;www.jsoftware.us&#x2F;vol7&#x2F;jsw0709-23.pdf" rel="nofollow">https:&#x2F;&#x2F;www.jsoftware.us&#x2F;vol7&#x2F;jsw0709-23.pdf</a></div><br/></div></div></div></div><div id="39451390" class="c"><input type="checkbox" id="c-39451390" checked=""/><div class="controls bullet"><span class="by">Guthur</span><span>|</span><a href="#39449253">prev</a><span>|</span><label class="collapse" for="c-39451390">[-]</label><label class="expand" for="c-39451390">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve actually been using Prolog professionally including some CLPFD, and I love it. I want it everywhere.   Or more precisely i want a logical core with emphasis on purity and push imperative action to the edges.<p>It so sad that as an industry we seemed locked into really bad tools.</div><br/></div></div></div></div></div></div></div></body></html>