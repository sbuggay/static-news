<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1732352514043" as="style"/><link rel="stylesheet" href="styles.css?v=1732352514043"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.quantum-machines.co/blog/understanding-googles-quantum-error-correction-breakthrough/">Understanding Google&#x27;s Quantum Error Correction Breakthrough</a> <span class="domain">(<a href="https://www.quantum-machines.co">www.quantum-machines.co</a>)</span></div><div class="subtext"><span>GavCo</span> | <span>71 comments</span></div><br/><div><div id="42216693" class="c"><input type="checkbox" id="c-42216693" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42218162">next</a><span>|</span><label class="collapse" for="c-42216693">[-]</label><label class="expand" for="c-42216693">[31 more]</label></div><br/><div class="children"><div class="content">Is this an actually good explanation? The introduction immediately made me pause:<p>&gt; In classical computers, error-resistant memory is achieved by duplicating bits to detect and correct errors. A method called majority voting is often used, where multiple copies of a bit are compared, and the majority value is taken as the correct bit<p>No in classical computers memory is corrected for using error correction not duplicating bits and majority voting. Duplicating bits would be a very wasteful strategy if you can add significantly fewer bits and achieve the same result which is what you get with error correction techniques like ECC. Maybe they got it confused with logic circuits where there’s not any more efficient strategy?</div><br/><div id="42218088" class="c"><input type="checkbox" id="c-42218088" checked=""/><div class="controls bullet"><span class="by">ziofill</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42218476">next</a><span>|</span><label class="collapse" for="c-42218088">[-]</label><label class="expand" for="c-42218088">[4 more]</label></div><br/><div class="children"><div class="content">Physicist here. Classical error correction may not always be a straight up repetition code, but the concept of redundancy of information still applies (like parity checks).<p>In a nutshell, in quantum error correction you cannot use redundancy because of the no-cloning theorem, so instead you embed the qubit subspace in a larger space (using more qubits) such that when correctable errors happen the embedded subspace moves to a different &quot;location&quot; in the larger space. When this happens it can be detected and the subspace can be brought back without affecting the states within the subspace, so the quantum information is preserved.</div><br/><div id="42219241" class="c"><input type="checkbox" id="c-42219241" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42218088">parent</a><span>|</span><a href="#42219587">next</a><span>|</span><label class="collapse" for="c-42219241">[-]</label><label class="expand" for="c-42219241">[1 more]</label></div><br/><div class="children"><div class="content">You are correct in the details, but not the distinction. This is exactly how classical error correction works as well.</div><br/></div></div><div id="42219587" class="c"><input type="checkbox" id="c-42219587" checked=""/><div class="controls bullet"><span class="by">jessriedel</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42218088">parent</a><span>|</span><a href="#42219241">prev</a><span>|</span><a href="#42219127">next</a><span>|</span><label class="collapse" for="c-42219587">[-]</label><label class="expand" for="c-42219587">[1 more]</label></div><br/><div class="children"><div class="content">Just an example to expand on what others are saying: in the N^2-qubit Shor code, the X information is recorded redundantly in N disjoint sets of N qubits each, and the Z information is recorded redundantly in a different partitioning of N disjoint sets of N qubits each.  You could literally have N observers each make separate measurements on disjoint regions of space and all access the X information about the qubit.  And likewise for Z.  In that sense it&#x27;s a repetition code.</div><br/></div></div><div id="42219127" class="c"><input type="checkbox" id="c-42219127" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42218088">parent</a><span>|</span><a href="#42219587">prev</a><span>|</span><a href="#42218476">next</a><span>|</span><label class="collapse" for="c-42219127">[-]</label><label class="expand" for="c-42219127">[1 more]</label></div><br/><div class="children"><div class="content">This happens to be the same way that classical error correction works, but quantum.</div><br/></div></div></div></div><div id="42218476" class="c"><input type="checkbox" id="c-42218476" checked=""/><div class="controls bullet"><span class="by">abdullahkhalids</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42218088">prev</a><span>|</span><a href="#42217498">next</a><span>|</span><label class="collapse" for="c-42218476">[-]</label><label class="expand" for="c-42218476">[1 more]</label></div><br/><div class="children"><div class="content">While you are correct, here is a fun side fact.<p>The electric signals inside a (classical) processor or digital logic chip are made up of many electrons. Electrons are not fully well behaved and there are often deviations from ideal behavior. Whether a signal gets interpreted as 0 or 1 depends on which way the majority of the electrons are going. The lower the power you operate at, the fewer electrons there are per signal, and the more errors you will see.<p>So in a way, there is a a repetition code in a classical computer (or other similar devices such as an optical fiber). Just in the hardware substrate, not in software.</div><br/></div></div><div id="42217498" class="c"><input type="checkbox" id="c-42217498" checked=""/><div class="controls bullet"><span class="by">abtinf</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42218476">prev</a><span>|</span><a href="#42218657">next</a><span>|</span><label class="collapse" for="c-42217498">[-]</label><label class="expand" for="c-42217498">[5 more]</label></div><br/><div class="children"><div class="content">This seems like the kind of error an LLM would make.<p>It is essentially impossible for a human to confuse error correction and “majority voting”&#x2F;consensus.</div><br/><div id="42217754" class="c"><input type="checkbox" id="c-42217754" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217498">parent</a><span>|</span><a href="#42217836">next</a><span>|</span><label class="collapse" for="c-42217754">[-]</label><label class="expand" for="c-42217754">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe it is the result of a LLM, more like an oversimplification, or maybe a minor fuckup on the part of the author as simple majority voting is often used in redundant systems, just not for memories as there are better ways.<p>And for a LLM result, this is what ChatGPT says when asked &quot;How does memory error correction differ from quantum error correction?&quot;, among other things.<p>&gt; Relies on redundancy by encoding extra bits into the data using techniques like parity bits, Hamming codes, or Reed-Solomon codes.<p>And when asked for a simplified answer<p>&gt; Classical memory error correction fixes mistakes in regular computer data (0s and 1s) by adding extra bits to check for and fix any errors, like a safety net catching flipped bits. Quantum error correction, on the other hand, protects delicate quantum bits (qubits), which can hold more complex information (like being 0 and 1 at the same time), from errors caused by noise or interference. Because qubits are fragile and can’t be directly measured without breaking their state, quantum error correction uses clever techniques involving multiple qubits and special rules of quantum physics to detect and fix errors without ruining the quantum information.<p>Absolutely no mention of majority voting here.<p>EDIT: GPT-4o mini does mention majority voting as an example of a memory error correction scheme but not as <i>the</i> way to do it. The explanation is overall more clumsy, but generally correct, I don&#x27;t know enough about quantum error correction to fact-check.</div><br/></div></div><div id="42217836" class="c"><input type="checkbox" id="c-42217836" checked=""/><div class="controls bullet"><span class="by">mmooss</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217498">parent</a><span>|</span><a href="#42217754">prev</a><span>|</span><a href="#42218657">next</a><span>|</span><label class="collapse" for="c-42217836">[-]</label><label class="expand" for="c-42217836">[3 more]</label></div><br/><div class="children"><div class="content">People always have made bad assumptions or had misunderstandings. Maybe the author just doesn&#x27;t understand ECC and always assumed it was consensus-based. I do things like that (I try not to write about them without verifying); I&#x27;m confident that so do you and everyone reading this.</div><br/><div id="42217978" class="c"><input type="checkbox" id="c-42217978" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217836">parent</a><span>|</span><a href="#42218657">next</a><span>|</span><label class="collapse" for="c-42217978">[-]</label><label class="expand" for="c-42217978">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Maybe the author just doesn&#x27;t understand ECC and always assumed it was consensus-based.<p>That&#x27;s likely, or it was LLM output and the author didn&#x27;t know enough to know it was wrong. We&#x27;ve seen that in a lot of tech articles lately where authors assume that something that is true-ish in one area is also true in another, and it&#x27;s obvious they just don&#x27;t understand other area they are writing about.</div><br/><div id="42218326" class="c"><input type="checkbox" id="c-42218326" checked=""/><div class="controls bullet"><span class="by">fnordpiglet</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217978">parent</a><span>|</span><a href="#42218657">next</a><span>|</span><label class="collapse" for="c-42218326">[-]</label><label class="expand" for="c-42218326">[1 more]</label></div><br/><div class="children"><div class="content">Frankly every state of the art LLM would not make this error. Perhaps GPT3.5 would have, but the space of errors they tend to make now is in areas of ambiguity or things that require deductive reasoning, math, etc. Areas that are well described in literature they tend to not make mistakes.</div><br/></div></div></div></div></div></div></div></div><div id="42218657" class="c"><input type="checkbox" id="c-42218657" checked=""/><div class="controls bullet"><span class="by">Karliss</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42217498">prev</a><span>|</span><a href="#42216741">next</a><span>|</span><label class="collapse" for="c-42218657">[-]</label><label class="expand" for="c-42218657">[2 more]</label></div><br/><div class="children"><div class="content">By a somewhat generous interpretation classical computer memory depends on implicit duplication&#x2F;majority vote in the form of increased cell size of each bit instead of discrete duplication. Same way as repetition of signal sent over the wire can mean using lower baudrate and holding the signal level for longer time. A bit isn&#x27;t stored in single atom or electron. A cell storing single bit can be considered a group of smaller cells connected in parallel storing duplicate value. And the majority vote happens automatically in analog form as you read total sum of the charge within memory cell.<p>Depending on how abstractly you talk about computers (which can be the case when contrasting quantum computing with classical computing), memory can refer not just to RAM but anything holding state and classical computer refer to any computing device including simple logic circuits not your desktop computer. Fundamentally desktop computers are one giant logic circuits.<p>Also RAID-1 is a thing.<p>At higher level backups are a thing.<p>So I would say there enough examples of practically used duplication for the purpose of error resistance in classical computers.</div><br/><div id="42218833" class="c"><input type="checkbox" id="c-42218833" checked=""/><div class="controls bullet"><span class="by">mathgenius</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42218657">parent</a><span>|</span><a href="#42216741">next</a><span>|</span><label class="collapse" for="c-42218833">[-]</label><label class="expand" for="c-42218833">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and it&#x27;s worth pointing out these examples because they don&#x27;t work as quantum memories. Two more: magnetic memory based on magnets which are magnetic because they are build from many tiny (atomic) magnets, all (mostly) in agreement. Optical storage is similar, much like parent&#x27;s example of a signal being slowly sent over a wire.<p>So the next question is why doesn&#x27;t this work for quantum information? And this is a really great question which gets at the heart of quantum versus classical.  Classical information is just so fantastically easy to duplicate that normally we don&#x27;t even notice this, it&#x27;s just too obvious a fact... until we get to quantum.</div><br/></div></div></div></div><div id="42216741" class="c"><input type="checkbox" id="c-42216741" checked=""/><div class="controls bullet"><span class="by">outworlder</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42218657">prev</a><span>|</span><a href="#42217616">next</a><span>|</span><label class="collapse" for="c-42216741">[-]</label><label class="expand" for="c-42216741">[1 more]</label></div><br/><div class="children"><div class="content">That threw me off as well. Majority voting works for industries like aviation, but that&#x27;s still about checking results of computations, not all memory addresses.</div><br/></div></div><div id="42217616" class="c"><input type="checkbox" id="c-42217616" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42216741">prev</a><span>|</span><a href="#42217651">next</a><span>|</span><label class="collapse" for="c-42217616">[-]</label><label class="expand" for="c-42217616">[1 more]</label></div><br/><div class="children"><div class="content">Maybe they were thinking of control systems where duplicating memory, lockstep cores and majority voting are used. You don&#x27;t even have to go to space to encounter such a system, you likely have one in your car.</div><br/></div></div><div id="42217651" class="c"><input type="checkbox" id="c-42217651" checked=""/><div class="controls bullet"><span class="by">bramathon</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42217616">prev</a><span>|</span><a href="#42217206">next</a><span>|</span><label class="collapse" for="c-42217651">[-]</label><label class="expand" for="c-42217651">[1 more]</label></div><br/><div class="children"><div class="content">The explanation of Google&#x27;s error correction experiment is basic but fine. People should keep in mind that Quantum Machines sells control electronics for quantum computers which is why they focus on the control and timing aspects of the experiment. I think a more general introduction to quantum error correction would be more relevant to the Hackernews audience.</div><br/></div></div><div id="42217206" class="c"><input type="checkbox" id="c-42217206" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42217651">prev</a><span>|</span><a href="#42216971">next</a><span>|</span><label class="collapse" for="c-42217206">[-]</label><label class="expand" for="c-42217206">[4 more]</label></div><br/><div class="children"><div class="content">I think it&#x27;s fundamentally misleading, even on the central quantum stuff:<p>I missed what you saw, that&#x27;s certainly a massive oof. It&#x27;s not even wrong, in the Pauli sense, i.e. it&#x27;s not just a simplistic rendering of ECC.<p>It also strongly tripped my internal GPT detector.<p>Also, it goes on and on about realtime decoding, the foundation of the article is Google&#x27;s breakthrough <i>is</i> real time, and the Google article was quite clear that it isn&#x27;t real time.*<p>I&#x27;m a bit confused, because it seems completely wrong, yet they published it, and there&#x27;s enough phrasing that definitely <i>doesn&#x27;t</i> trip my GPT detector. My instinct is someone who doesn&#x27;t have years of background knowledge &#x2F; formal comp sci &amp; physics education made a valiant effort.<p>I&#x27;m reminded that my throughly &#x2F;r&#x2F;WSB-ified MD friend brings up &quot;quantum computing is gonna be big what stonks should I buy&quot; every 6 months, and a couple days ago he sent me a screenshot of my AI app that had a few conversations with him hunting for opportunities.<p>* &quot;While AlphaQubit is great at accurately identifying errors, it’s still too slow to correct errors in a superconducting processor in real time&quot;</div><br/><div id="42217576" class="c"><input type="checkbox" id="c-42217576" checked=""/><div class="controls bullet"><span class="by">bramathon</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217206">parent</a><span>|</span><a href="#42217288">next</a><span>|</span><label class="collapse" for="c-42217576">[-]</label><label class="expand" for="c-42217576">[2 more]</label></div><br/><div class="children"><div class="content">This is not about AlphaQubit. It&#x27;s about a different paper, <a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2408.13687" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2408.13687</a> and they do demonstrate real-time decoding.<p>&gt; we show that we can maintain below-threshold operation on the 72-qubit processor even when decoding in real time, meeting the strict timing requirements imposed by the processor’s fast 1.1 μs cycle duration</div><br/><div id="42218255" class="c"><input type="checkbox" id="c-42218255" checked=""/><div class="controls bullet"><span class="by">refulgentis</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217576">parent</a><span>|</span><a href="#42217288">next</a><span>|</span><label class="collapse" for="c-42218255">[-]</label><label class="expand" for="c-42218255">[1 more]</label></div><br/><div class="children"><div class="content">Oh my, I really jumped to a conclusion. And what fantastic news to hear. Thank you!</div><br/></div></div></div></div><div id="42217288" class="c"><input type="checkbox" id="c-42217288" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217206">parent</a><span>|</span><a href="#42217576">prev</a><span>|</span><a href="#42216971">next</a><span>|</span><label class="collapse" for="c-42217288">[-]</label><label class="expand" for="c-42217288">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I didn&#x27;t want to just accuse the article of being AI generated since quantum isn&#x27;t my specialty, but this kind of error instantly tripped my &quot;it doesn&#x27;t sound like this person knows what they&#x27;re talking about alarm&quot; which likely indicates a bad LLM helped summarize the quantum paper for the author.</div><br/></div></div></div></div><div id="42216971" class="c"><input type="checkbox" id="c-42216971" checked=""/><div class="controls bullet"><span class="by">UniverseHacker</span><span>|</span><a href="#42216693">parent</a><span>|</span><a href="#42217206">prev</a><span>|</span><a href="#42218162">next</a><span>|</span><label class="collapse" for="c-42216971">[-]</label><label class="expand" for="c-42216971">[11 more]</label></div><br/><div class="children"><div class="content">ECC is not easy to explain, and sounds like a tautology rather than an explanation &quot;error correction is done with error correction&quot;- unless you give a full technical explanation of exactly what ECC is doing.</div><br/><div id="42217093" class="c"><input type="checkbox" id="c-42217093" checked=""/><div class="controls bullet"><span class="by">marcellus23</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42216971">parent</a><span>|</span><a href="#42218162">next</a><span>|</span><label class="collapse" for="c-42217093">[-]</label><label class="expand" for="c-42217093">[10 more]</label></div><br/><div class="children"><div class="content">Regardless of whether the parent&#x27;s sentence is a tautology, the explanation in the article is categorically wrong.</div><br/><div id="42217342" class="c"><input type="checkbox" id="c-42217342" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217093">parent</a><span>|</span><a href="#42217454">next</a><span>|</span><label class="collapse" for="c-42217342">[-]</label><label class="expand" for="c-42217342">[4 more]</label></div><br/><div class="children"><div class="content">Categorically might be a bit much. Duplicating bits with majority voting is an error correction code, its just not a very efficient one.<p>Like its wrong, but its not like its totally out of this world wrong. Or more speciglficly its in the correct category.</div><br/><div id="42217632" class="c"><input type="checkbox" id="c-42217632" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217342">parent</a><span>|</span><a href="#42217454">next</a><span>|</span><label class="collapse" for="c-42217632">[-]</label><label class="expand" for="c-42217632">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s categorically wrong to say that that&#x27;s how memory is error corrected in classical computers because it is not and never has been how it was done. Even for systems like S3 that replicate, there&#x27;s no error correction happening in the replicas and the replicas are eventually converted to erasure codes.</div><br/><div id="42218213" class="c"><input type="checkbox" id="c-42218213" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217632">parent</a><span>|</span><a href="#42217454">next</a><span>|</span><label class="collapse" for="c-42218213">[-]</label><label class="expand" for="c-42218213">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m being a bit pedantic here, but it is not categorically wrong. Categorically wrong doesn&#x27;t just mean &quot;very wrong&quot; it is a specific type of being wrong, a type that this isn&#x27;t.<p>Repetition codes are a type of error correction code. It is thus in the category of error correction codes. Even if it is not the right error correction codes, it is in the correct category, so it is not a categorical error.</div><br/><div id="42218459" class="c"><input type="checkbox" id="c-42218459" checked=""/><div class="controls bullet"><span class="by">cycomanic</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42218213">parent</a><span>|</span><a href="#42217454">next</a><span>|</span><label class="collapse" for="c-42218459">[-]</label><label class="expand" for="c-42218459">[1 more]</label></div><br/><div class="children"><div class="content">Well it&#x27;s about as categorically wrong as saying quantum computers use similar error correction algorithms as classical computers. Categorically both are are error correction algorithms.</div><br/></div></div></div></div></div></div></div></div><div id="42217454" class="c"><input type="checkbox" id="c-42217454" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217093">parent</a><span>|</span><a href="#42217342">prev</a><span>|</span><a href="#42217297">next</a><span>|</span><label class="collapse" for="c-42217454">[-]</label><label class="expand" for="c-42217454">[4 more]</label></div><br/><div class="children"><div class="content">Eh, I don’t think it is categorically wrong… ECCs are based on the idea of sacrificing some capacity by adding redundant bits that can be used to correct for some number of errors. The simplest ECC would be just duplicating the data, and it isn’t categorically different than real ECCs used.</div><br/><div id="42217709" class="c"><input type="checkbox" id="c-42217709" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217454">parent</a><span>|</span><a href="#42217297">next</a><span>|</span><label class="collapse" for="c-42217709">[-]</label><label class="expand" for="c-42217709">[3 more]</label></div><br/><div class="children"><div class="content">Then you&#x27;re replicating and not error correcting. I&#x27;ve not seen any replication systems that use the replicas to detect errors. Even RAID 1 which is a pure mirroring solution only fetches one of the copies when reading &amp; will ignore corruption on one of the disks unless you initiate a manual verification. There are technical reasons why that is related to read amplification as well as what it does to your storage cost.</div><br/><div id="42217921" class="c"><input type="checkbox" id="c-42217921" checked=""/><div class="controls bullet"><span class="by">cortesoft</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217709">parent</a><span>|</span><a href="#42217297">next</a><span>|</span><label class="collapse" for="c-42217921">[-]</label><label class="expand" for="c-42217921">[2 more]</label></div><br/><div class="children"><div class="content">I guess that is true, pure replication would not allow you to correct errors, only detect them.<p>However, I think explaining the concept as duplicating some data isn’t horrible wrong for non technical people. It is close enough to allow the person to understand the concept.</div><br/><div id="42218143" class="c"><input type="checkbox" id="c-42218143" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217921">parent</a><span>|</span><a href="#42217297">next</a><span>|</span><label class="collapse" for="c-42218143">[-]</label><label class="expand" for="c-42218143">[1 more]</label></div><br/><div class="children"><div class="content">To be clear. A hypothetical replication system with 3 copies could be used to correct errors using majority voting.<p>However, there&#x27;s no replication system I&#x27;ve ever seen (memory, local storage, or distributed storage) that detects or corrects for errors using replication because of the read amplification problem.</div><br/></div></div></div></div></div></div></div></div><div id="42217297" class="c"><input type="checkbox" id="c-42217297" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#42216693">root</a><span>|</span><a href="#42217093">parent</a><span>|</span><a href="#42217454">prev</a><span>|</span><a href="#42218162">next</a><span>|</span><label class="collapse" for="c-42217297">[-]</label><label class="expand" for="c-42217297">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I couldn&#x27;t quite remember if ECC is just hamming codes or is using something more modern like fountain codes although those are technically FEC. So in the absence of stating something incorrectly I went with the tautology.</div><br/></div></div></div></div></div></div></div></div><div id="42218162" class="c"><input type="checkbox" id="c-42218162" checked=""/><div class="controls bullet"><span class="by">cwillu</span><span>|</span><a href="#42216693">prev</a><span>|</span><a href="#42216447">next</a><span>|</span><label class="collapse" for="c-42218162">[-]</label><label class="expand" for="c-42218162">[6 more]</label></div><br/><div class="children"><div class="content">Wow, they managed to make a website that scales everything <i>except</i> the main text when adjusting the browser&#x27;s zoom setting.</div><br/><div id="42218936" class="c"><input type="checkbox" id="c-42218936" checked=""/><div class="controls bullet"><span class="by">essentia0</span><span>|</span><a href="#42218162">parent</a><span>|</span><a href="#42219316">next</a><span>|</span><label class="collapse" for="c-42218936">[-]</label><label class="expand" for="c-42218936">[3 more]</label></div><br/><div class="children"><div class="content">They set the root font size relative to the total width of the screen (1.04vw) with the rest of the styling using rem units<p>Ive never seen anyone do that before.. It may well be the only way to circumvent browser zoom</div><br/><div id="42219031" class="c"><input type="checkbox" id="c-42219031" checked=""/><div class="controls bullet"><span class="by">rendaw</span><span>|</span><a href="#42218162">root</a><span>|</span><a href="#42218936">parent</a><span>|</span><a href="#42219316">next</a><span>|</span><label class="collapse" for="c-42219031">[-]</label><label class="expand" for="c-42219031">[2 more]</label></div><br/><div class="children"><div class="content">Why don&#x27;t browsers reduce the screen width when you zoom in, as they adjust every other unit (cm, px)?</div><br/><div id="42219170" class="c"><input type="checkbox" id="c-42219170" checked=""/><div class="controls bullet"><span class="by">zamadatix</span><span>|</span><a href="#42218162">root</a><span>|</span><a href="#42219031">parent</a><span>|</span><a href="#42219316">next</a><span>|</span><label class="collapse" for="c-42219170">[-]</label><label class="expand" for="c-42219170">[1 more]</label></div><br/><div class="children"><div class="content">They effectively do. All css absolute units are effectively defined as ratios of each other and zoom*DPI*physicalPixels sets the ratio of how many physical pixels each absolute unit will end up turning into. Increase zoom and the screen seems to have shrunk to some smaller &#x27;cm&#x27; and so on.<p>For things like &#x27;vh&#x27; and &#x27;vw&#x27; it just doesn&#x27;t matter &quot;how many cm&quot; the screen is as 20% of the viewing space always comes out to 20% of the viewing space regardless how many &#x27;cm&#x27; that is said to be equivalent to.</div><br/></div></div></div></div></div></div><div id="42219316" class="c"><input type="checkbox" id="c-42219316" checked=""/><div class="controls bullet"><span class="by">hiisukun</span><span>|</span><a href="#42218162">parent</a><span>|</span><a href="#42218936">prev</a><span>|</span><a href="#42218779">next</a><span>|</span><label class="collapse" for="c-42219316">[-]</label><label class="expand" for="c-42219316">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s interesting how this (and other css?) means the website is readable in a phone in portrait, but the text is tiny in landscape!</div><br/></div></div><div id="42218779" class="c"><input type="checkbox" id="c-42218779" checked=""/><div class="controls bullet"><span class="by">rezonant</span><span>|</span><a href="#42218162">parent</a><span>|</span><a href="#42219316">prev</a><span>|</span><a href="#42216447">next</a><span>|</span><label class="collapse" for="c-42218779">[-]</label><label class="expand" for="c-42218779">[1 more]</label></div><br/><div class="children"><div class="content">There should be a law for this. Who in their right mind wants this?</div><br/></div></div></div></div><div id="42216447" class="c"><input type="checkbox" id="c-42216447" checked=""/><div class="controls bullet"><span class="by">terminalbraid</span><span>|</span><a href="#42218162">prev</a><span>|</span><a href="#42216581">next</a><span>|</span><label class="collapse" for="c-42216447">[-]</label><label class="expand" for="c-42216447">[1 more]</label></div><br/><div class="children"><div class="content">Note the paper they are referring to was published August 27, 2024<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2408.13687" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2408.13687</a></div><br/></div></div><div id="42216581" class="c"><input type="checkbox" id="c-42216581" checked=""/><div class="controls bullet"><span class="by">xscott</span><span>|</span><a href="#42216447">prev</a><span>|</span><a href="#42216468">next</a><span>|</span><label class="collapse" for="c-42216581">[-]</label><label class="expand" for="c-42216581">[14 more]</label></div><br/><div class="children"><div class="content">While I&#x27;m still eager to see where Quantum Computing leads, I&#x27;ve got a new threshold for &quot;breakthrough&quot;:  Until a quantum computer can factor products of primes larger than a few bits, I&#x27;ll consider it a work in progress at best.</div><br/><div id="42219388" class="c"><input type="checkbox" id="c-42219388" checked=""/><div class="controls bullet"><span class="by">Strilanc</span><span>|</span><a href="#42216581">parent</a><span>|</span><a href="#42218173">next</a><span>|</span><label class="collapse" for="c-42219388">[-]</label><label class="expand" for="c-42219388">[1 more]</label></div><br/><div class="children"><div class="content">If qubit count increased by 2x per year, largest-number-factored would show no progress for ~8 years. Then the largest number factored would double in size each year, with RSA2048 broken after a total of ~15 years. The initial lull is because the cost of error correction is so front loaded.<p>Depending on your interests, the initial insensitivity of largest-number-factored as a metric is either great (it reduces distractions) or terrible (it fails to accurately report progress). For example, if the actual improvement rate were 10x per year instead of 2x per year, it&#x27;d be 3 years until you realized RSA2048 was going to break after 2 more years instead of 12 more years.</div><br/></div></div><div id="42218173" class="c"><input type="checkbox" id="c-42218173" checked=""/><div class="controls bullet"><span class="by">mrandish</span><span>|</span><a href="#42216581">parent</a><span>|</span><a href="#42219388">prev</a><span>|</span><a href="#42217331">next</a><span>|</span><label class="collapse" for="c-42218173">[-]</label><label class="expand" for="c-42218173">[1 more]</label></div><br/><div class="children"><div class="content">&gt; While I&#x27;m still eager to see where Quantum Computing leads<p>Agreed. Although I&#x27;m no expert in this domain, I&#x27;ve been watching it a long time as a hopeful fan. Recently I&#x27;ve been increasing my (currently small) estimated probability that quantum computing may not ever (or at least not in my lifetime), become a commercially viable replacement for SOTA classical computing to solve valuable real-world problems.<p>I wish I knew enough to have a detailed argument but I don&#x27;t. It&#x27;s more of a concern triggered by reading media reports that seem to just assume &quot;sure it&#x27;s hard, but there&#x27;s no doubt we&#x27;ll get there eventually.&quot;<p>While I agree quantum algorithms can solve valuable real-world problems <i>in theory</i>, it&#x27;s pretty clear there are still a lot of unknown unknowns in getting all the way to &quot;commercially viable replacement solving valuable real-world problems.&quot; It seems at least possible we may still discover some fundamental limit(s) preventing us from engineering a solution that&#x27;s reliable enough and cost-effective enough to reach commercial viability at scale. I&#x27;d actually be interested in hearing counter-arguments that we now know enough to be reasonably confident it&#x27;s mostly just &quot;really hard engineering&quot; left to solve.</div><br/></div></div><div id="42217331" class="c"><input type="checkbox" id="c-42217331" checked=""/><div class="controls bullet"><span class="by">UberFly</span><span>|</span><a href="#42216581">parent</a><span>|</span><a href="#42218173">prev</a><span>|</span><a href="#42218684">next</a><span>|</span><label class="collapse" for="c-42217331">[-]</label><label class="expand" for="c-42217331">[2 more]</label></div><br/><div class="children"><div class="content">I guess like most of these kinds of projects, it&#x27;ll be smaller, less flashy breakthroughs or milestones along the way.</div><br/><div id="42218322" class="c"><input type="checkbox" id="c-42218322" checked=""/><div class="controls bullet"><span class="by">Terr_</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42217331">parent</a><span>|</span><a href="#42218684">next</a><span>|</span><label class="collapse" for="c-42218322">[-]</label><label class="expand" for="c-42218322">[1 more]</label></div><br/><div class="children"><div class="content">People dramatically underestimate how important incremental unsung progress is, perhaps because it just doesn&#x27;t make for a nice memorable story compared to Suddenly Great Person Has Amazing Idea Nobody Had Before.</div><br/></div></div></div></div><div id="42218684" class="c"><input type="checkbox" id="c-42218684" checked=""/><div class="controls bullet"><span class="by">ashleyn</span><span>|</span><a href="#42216581">parent</a><span>|</span><a href="#42217331">prev</a><span>|</span><a href="#42217166">next</a><span>|</span><label class="collapse" for="c-42218684">[-]</label><label class="expand" for="c-42218684">[2 more]</label></div><br/><div class="children"><div class="content">My first question any time I see another quantum computing breakthrough: is my cryptography still safe? Answer seems like yes for now.</div><br/><div id="42219252" class="c"><input type="checkbox" id="c-42219252" checked=""/><div class="controls bullet"><span class="by">xscott</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42218684">parent</a><span>|</span><a href="#42217166">next</a><span>|</span><label class="collapse" for="c-42219252">[-]</label><label class="expand" for="c-42219252">[1 more]</label></div><br/><div class="children"><div class="content">I have a pseudo-theory that the universe will never allow quantum physics to provide an answer to a problem where you didn&#x27;t already know the result from some deterministic means.  This will be some bizarre consequence of information theory colliding with the measurement problem.<p>:-)</div><br/></div></div></div></div><div id="42217166" class="c"><input type="checkbox" id="c-42217166" checked=""/><div class="controls bullet"><span class="by">kridsdale1</span><span>|</span><a href="#42216581">parent</a><span>|</span><a href="#42218684">prev</a><span>|</span><a href="#42217334">next</a><span>|</span><label class="collapse" for="c-42217166">[-]</label><label class="expand" for="c-42217166">[3 more]</label></div><br/><div class="children"><div class="content">There will be a thousand breakthroughs before that point.</div><br/><div id="42217597" class="c"><input type="checkbox" id="c-42217597" checked=""/><div class="controls bullet"><span class="by">xscott</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42217166">parent</a><span>|</span><a href="#42217334">next</a><span>|</span><label class="collapse" for="c-42217597">[-]</label><label class="expand" for="c-42217597">[2 more]</label></div><br/><div class="children"><div class="content">That just means that the word &quot;breakthrough&quot; has lost it&#x27;s meaning.  I would suggest the word &quot;advancement&quot;, but I know this is a losing battle.</div><br/><div id="42217995" class="c"><input type="checkbox" id="c-42217995" checked=""/><div class="controls bullet"><span class="by">Suppafly</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42217597">parent</a><span>|</span><a href="#42217334">next</a><span>|</span><label class="collapse" for="c-42217995">[-]</label><label class="expand" for="c-42217995">[1 more]</label></div><br/><div class="children"><div class="content">&gt;That just means that the word &quot;breakthrough&quot; has lost it&#x27;s meaning.<p>This. Small, incremental and predictable advances aren&#x27;t breakthroughs.</div><br/></div></div></div></div></div></div><div id="42217334" class="c"><input type="checkbox" id="c-42217334" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#42216581">parent</a><span>|</span><a href="#42217166">prev</a><span>|</span><a href="#42216468">next</a><span>|</span><label class="collapse" for="c-42217334">[-]</label><label class="expand" for="c-42217334">[4 more]</label></div><br/><div class="children"><div class="content">quantum computers can (should be able to; do not currently) solve many useful problems without ever being able to factor primes.</div><br/><div id="42217625" class="c"><input type="checkbox" id="c-42217625" checked=""/><div class="controls bullet"><span class="by">xscott</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42217334">parent</a><span>|</span><a href="#42217573">next</a><span>|</span><label class="collapse" for="c-42217625">[-]</label><label class="expand" for="c-42217625">[2 more]</label></div><br/><div class="children"><div class="content">What are some good examples?<p>The one a few years ago where Google declared &quot;quantum supremacy&quot; sounded a lot like simulating a noisy circuit by implementing a noisy circuit.  And that seems a lot like <i>simulating</i> the falling particles and their collisions in an hour glass by using a physical hour glass.</div><br/><div id="42218186" class="c"><input type="checkbox" id="c-42218186" checked=""/><div class="controls bullet"><span class="by">dekhn</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42217625">parent</a><span>|</span><a href="#42217573">next</a><span>|</span><label class="collapse" for="c-42218186">[-]</label><label class="expand" for="c-42218186">[1 more]</label></div><br/><div class="children"><div class="content">The only one I can think of is simulating physical systems, especially quantum ones.<p>Google&#x27;s supremacy claim didn&#x27;t impress me; besides being a computationally uninteresting problem, it really just motivated the supercomputer people to improve their algorithms.<p>To really establish this field as a viable going concern probably needs somebody to do &quot;something&quot; with quantum that is experimentally verifiable but not computable classically, <i>and</i> is a useful computation.</div><br/></div></div></div></div><div id="42217573" class="c"><input type="checkbox" id="c-42217573" checked=""/><div class="controls bullet"><span class="by">Eji1700</span><span>|</span><a href="#42216581">root</a><span>|</span><a href="#42217334">parent</a><span>|</span><a href="#42217625">prev</a><span>|</span><a href="#42216468">next</a><span>|</span><label class="collapse" for="c-42217573">[-]</label><label class="expand" for="c-42217573">[1 more]</label></div><br/><div class="children"><div class="content">Yeah I think that&#x27;s the issue that makes it hard to assess quantum computing.<p>My very layman understanding is that there are certain things it will be several orders of magnitude better at, but &quot;simple&quot; things for a normal machine quantum will be just as bad if not massively worse.<p>It really should be treated as a different tool for right now.  Maybe some day in the very far future if it becomes easier to make quantum computers an abstraction layer will be arrived at in some manner that means the end user thinks it&#x27;s just like a normal computer, but from a &quot;looking at series of 1&#x2F;0&#x27;s&quot; or &quot;looking at a series of superimposed particles&quot; it&#x27;s extremely different in function.</div><br/></div></div></div></div></div></div><div id="42216468" class="c"><input type="checkbox" id="c-42216468" checked=""/><div class="controls bullet"><span class="by">dangerlibrary</span><span>|</span><a href="#42216581">prev</a><span>|</span><a href="#42216480">next</a><span>|</span><label class="collapse" for="c-42216468">[-]</label><label class="expand" for="c-42216468">[10 more]</label></div><br/><div class="children"><div class="content">I&#x27;m someone not really aware of the consequences of each quantum of progress in quantum computing. But, I know that I&#x27;m exposed to QC risks in that at some point I&#x27;ll need to change every security key I&#x27;ve ever generated and every crypto algorithm every piece of software uses.<p>How much closer does this work bring us to the Quantum Crypto Apocalypse? How much time do I have left before I need to start budgeting it into my quarterly engineering plan?</div><br/><div id="42217383" class="c"><input type="checkbox" id="c-42217383" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42216468">parent</a><span>|</span><a href="#42216595">next</a><span>|</span><label class="collapse" for="c-42217383">[-]</label><label class="expand" for="c-42217383">[1 more]</label></div><br/><div class="children"><div class="content">&gt; But, I know that I&#x27;m exposed to QC risks in that at some point I&#x27;ll need to change every security key I&#x27;ve ever generated and every crypto algorithm every piece of software uses.<p>Probably not. Unless a real sudden unexpected breakthrough happens, best practise will be to use crypto-resistant algorithms long before this becones a relavent issue.<p>And practically speaking its only public-key crypto that is an issue, your symmetric keys are fine (oversimplifying slightly, but practically speaking this is true)</div><br/></div></div><div id="42216595" class="c"><input type="checkbox" id="c-42216595" checked=""/><div class="controls bullet"><span class="by">griomnib</span><span>|</span><a href="#42216468">parent</a><span>|</span><a href="#42217383">prev</a><span>|</span><a href="#42216598">next</a><span>|</span><label class="collapse" for="c-42216595">[-]</label><label class="expand" for="c-42216595">[3 more]</label></div><br/><div class="children"><div class="content">The primary threat model is data collected <i>today</i> via mass surveillance that is <i>currently</i> unbreakable will <i>become</i> breakable.<p>There are already new “quantum-proof” security mechanisms being developed for that reason.</div><br/><div id="42217401" class="c"><input type="checkbox" id="c-42217401" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42216468">root</a><span>|</span><a href="#42216595">parent</a><span>|</span><a href="#42216647">next</a><span>|</span><label class="collapse" for="c-42217401">[-]</label><label class="expand" for="c-42217401">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but you got to ask yourself how valuable will your data be 20-30 years in the future. For some people that is a big deal maybe. For most people that is a very low risk threat. Most private data has a shelf life where it is no longer valuable.</div><br/></div></div><div id="42216647" class="c"><input type="checkbox" id="c-42216647" checked=""/><div class="controls bullet"><span class="by">sroussey</span><span>|</span><a href="#42216468">root</a><span>|</span><a href="#42216595">parent</a><span>|</span><a href="#42217401">prev</a><span>|</span><a href="#42216598">next</a><span>|</span><label class="collapse" for="c-42216647">[-]</label><label class="expand" for="c-42216647">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and people are recording encrypted conversations communications now for this reason.</div><br/></div></div></div></div><div id="42216598" class="c"><input type="checkbox" id="c-42216598" checked=""/><div class="controls bullet"><span class="by">er4hn</span><span>|</span><a href="#42216468">parent</a><span>|</span><a href="#42216595">prev</a><span>|</span><a href="#42216596">next</a><span>|</span><label class="collapse" for="c-42216598">[-]</label><label class="expand" for="c-42216598">[4 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll need to focus on asym and DH stuff. If your symmetric keys are 256 bits you should be fine there.<p>The hope is that most of this should just be: Update to the latest version of openssl &#x2F; openssh &#x2F; golang-crypto &#x2F; what have you and make sure you have the handshake settings use the latest crypto algorithms. This is all kind of far flung because there is very little consensus around how to change protocols for various human reasons.<p>At some point you&#x27;ll need to generate new asym keys as well, which is where I think things will get interesting. HW based solutions just don&#x27;t exist today and will probably take a long time due to the inevitable cycle of: companies want to meet us fed gov standards due to regulations &#x2F; selling to fedgov, fedgov is taking their sweet time to standardize protocols and seem to be interested in wanting to add more certified algorithms as well, actually getting something approved for FIPS 140 (the relevant standard) takes over a year at this point just to get your paperwork processed, everyone wants to move faster. Software can move quicker in terms of development, but you have the normal tradeoffs there with keys being easier to exfiltrate and the same issue with formal certification.</div><br/><div id="42217360" class="c"><input type="checkbox" id="c-42217360" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#42216468">root</a><span>|</span><a href="#42216598">parent</a><span>|</span><a href="#42216596">next</a><span>|</span><label class="collapse" for="c-42217360">[-]</label><label class="expand" for="c-42217360">[3 more]</label></div><br/><div class="children"><div class="content">Maybe my tinfoil hat is a bit too tight, but every time fedgov wants a new algo certified I question how strong it is and if they&#x27;ve already figured out a weakness. Once bitten twice shy or something????</div><br/><div id="42217671" class="c"><input type="checkbox" id="c-42217671" checked=""/><div class="controls bullet"><span class="by">jiggawatts</span><span>|</span><a href="#42216468">root</a><span>|</span><a href="#42217360">parent</a><span>|</span><a href="#42216596">next</a><span>|</span><label class="collapse" for="c-42217671">[-]</label><label class="expand" for="c-42217671">[2 more]</label></div><br/><div class="children"><div class="content">The NSA has definitely weakened or back-doored crypto. It’s not a conspiracy or even a secret! It was a matter of (public) law in the 90s, such as “export grade” crypto.<p>Most recently Dual_EC_DRBG was forced on American vendors by the NSA, but the backdoor private key was replaced by Chinese hackers in some Juniper devices and used by them to spy on westerners.<p>Look up phrase likes “nobody but us” (NOBUS), which is the aspirational goal of these approaches, but often fails, leaving everyone including Americans and their allies exposed.</div><br/><div id="42217737" class="c"><input type="checkbox" id="c-42217737" checked=""/><div class="controls bullet"><span class="by">dylan604</span><span>|</span><a href="#42216468">root</a><span>|</span><a href="#42217671">parent</a><span>|</span><a href="#42216596">next</a><span>|</span><label class="collapse" for="c-42217737">[-]</label><label class="expand" for="c-42217737">[1 more]</label></div><br/><div class="children"><div class="content">You should look up the phrase &quot;once bitten twice shy&quot; as I think you missed the gist of my comment. We&#x27;ve already been bitten at least once by incidents as you&#x27;ve described. From then on, it will always be in the back of my mind that friendly little suggestions on crypto algos from fedgov will always be received with suspicion. Accepting that, most people that are unawares will assume someone is wearing a tinfoil hat.</div><br/></div></div></div></div></div></div></div></div><div id="42216596" class="c"><input type="checkbox" id="c-42216596" checked=""/><div class="controls bullet"><span class="by">bdamm</span><span>|</span><a href="#42216468">parent</a><span>|</span><a href="#42216598">prev</a><span>|</span><a href="#42216480">next</a><span>|</span><label class="collapse" for="c-42216596">[-]</label><label class="expand" for="c-42216596">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure anyone really knows this although there is no shortage of wild speculation.<p>If you have keys that need to be robust for 20 years you should probably be looking into trying out some of the newly NIST approved standard algorithms.</div><br/></div></div></div></div><div id="42216480" class="c"><input type="checkbox" id="c-42216480" checked=""/><div class="controls bullet"><span class="by">computerdork</span><span>|</span><a href="#42216468">prev</a><span>|</span><a href="#42217362">next</a><span>|</span><label class="collapse" for="c-42216480">[-]</label><label class="expand" for="c-42216480">[6 more]</label></div><br/><div class="children"><div class="content">Does anyone on HN have a understanding how close this achievement brings us to useful quantum computers?</div><br/><div id="42216650" class="c"><input type="checkbox" id="c-42216650" checked=""/><div class="controls bullet"><span class="by">kittikitti</span><span>|</span><a href="#42216480">parent</a><span>|</span><a href="#42217700">next</a><span>|</span><label class="collapse" for="c-42216650">[-]</label><label class="expand" for="c-42216650">[4 more]</label></div><br/><div class="children"><div class="content">This is another hype piece from Google&#x27;s research and development arm. This is a theoretical application to increase the number of logical qubits in a system by decreasing the error caused by quantum circuts. They just didn&#x27;t do the last part yet so the application is yet to be seen.<p><a href="https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2408.13687" rel="nofollow">https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2408.13687</a><p>&quot;Our results present device performance that, if scaled, could realize the operational requirements of large scale fault-tolerant quantum algorithms.&quot;<p>Google forgot to test if it scales I guess?</div><br/><div id="42218227" class="c"><input type="checkbox" id="c-42218227" checked=""/><div class="controls bullet"><span class="by">wasabi991011</span><span>|</span><a href="#42216480">root</a><span>|</span><a href="#42216650">parent</a><span>|</span><a href="#42219351">next</a><span>|</span><label class="collapse" for="c-42218227">[-]</label><label class="expand" for="c-42218227">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the opposite of a theoretical application, and it&#x27;s not a hype piece. It&#x27;s more like an experimental confirmation of a theoretical result mixed with an engineering progress report.<p>They show that a certain milestone was achieved (error rate below the threshold), show experimentally that this milestone implies what theorists predicted, talk about how this milestone was achieved, and characterize the sources of error that could hinder further scaling.<p>They certainly tested how it scales up to the scale that they can build. A major part of the paper is how it scales.<p>&gt;&gt; &quot;Our results present device performance that, if scaled, could realize the operational requirements of large scale fault-tolerant quantum algorithms.&quot;<p>&gt; Google forgot to test if it scales I guess?<p>Remember that quantum computers are still being built. The paper is the equivalent of<p>&gt; We tested the scaling by comparing how our algorithm runs on a chromebook, a server rack, and google&#x27;s largest supercomputing cluster and found it scales well.<p>The sentence you tried to interpret was, continuing this analogy, the equivalent of<p>&gt;Google&#x27;s largest supercomputing cluster is not large enough for us, we are currently building an even bigger supercomputing cluster, and when we finish, our algorithm should (to the best of our knowledge) continue along this good scaling law.</div><br/></div></div><div id="42219351" class="c"><input type="checkbox" id="c-42219351" checked=""/><div class="controls bullet"><span class="by">Strilanc</span><span>|</span><a href="#42216480">root</a><span>|</span><a href="#42216650">parent</a><span>|</span><a href="#42218227">prev</a><span>|</span><a href="#42217060">next</a><span>|</span><label class="collapse" for="c-42219351">[-]</label><label class="expand" for="c-42219351">[1 more]</label></div><br/><div class="children"><div class="content">The experiment is literally all about scaling. It tests scaling from distance 3 to 5 to 7. It shows the logical qubit lifetime doubles each time the distance is increased. The sentence you quoted is describing an expectation that this doubling will continue to larger distances, when larger chips are built.<p>This is the first quantum error correction experiment showing actual improvement as size is increased (without any cheating such as postselection or only running for a single step). It was always believed in theory that bigger codes should have more protection, but there are have been various skeptics over the years saying you&#x27;d never actually see these improvements in practice due to the engineering difficulty or due to quantum mechanics breaking down or something.<p>Make no mistake; much remains to be done. But this experiment is a clear indication of progress. It demonstrates that error correction actually works. It says that quantum computers should be able to solve qubit quality with qubit quantity.<p>disclaimer: worked on this experiment</div><br/></div></div><div id="42217060" class="c"><input type="checkbox" id="c-42217060" checked=""/><div class="controls bullet"><span class="by">wholinator2</span><span>|</span><a href="#42216480">root</a><span>|</span><a href="#42216650">parent</a><span>|</span><a href="#42219351">prev</a><span>|</span><a href="#42217700">next</a><span>|</span><label class="collapse" for="c-42217060">[-]</label><label class="expand" for="c-42217060">[1 more]</label></div><br/><div class="children"><div class="content">Lol yeah the whole problem with quantum computation is the scaling, that&#x27;s literally the entire problem. It&#x27;s trivial to make a qbit, harder to make 5, impossible to make 1000. &quot;If it scales&quot; is just wishy washy language to cover, &quot;in the ideal scenario where everything works perfectly and nothing goes wrong, it will work perfectly&quot;</div><br/></div></div></div></div><div id="42217700" class="c"><input type="checkbox" id="c-42217700" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42216480">parent</a><span>|</span><a href="#42216650">prev</a><span>|</span><a href="#42217362">next</a><span>|</span><label class="collapse" for="c-42217700">[-]</label><label class="expand" for="c-42217700">[1 more]</label></div><br/><div class="children"><div class="content">The fact that there is a forward-looking subsection about “the <i>vision</i> for fault tolerance” (emphasis mine) almost entirely composed of empty words and concluding in “we are just starting this exciting journey, so stay tuned for what’s to come!” tells you “not close at all”.</div><br/></div></div></div></div><div id="42217362" class="c"><input type="checkbox" id="c-42217362" checked=""/><div class="controls bullet"><span class="by">bawolff</span><span>|</span><a href="#42216480">prev</a><span>|</span><label class="collapse" for="c-42217362">[-]</label><label class="expand" for="c-42217362">[2 more]</label></div><br/><div class="children"><div class="content">Doesn&#x27;t feel like a breakthrough. A positive engineering step forward, sure, but not a breakthrough.<p>And wtf does AI have to do with this?</div><br/><div id="42218257" class="c"><input type="checkbox" id="c-42218257" checked=""/><div class="controls bullet"><span class="by">wasabi991011</span><span>|</span><a href="#42217362">parent</a><span>|</span><label class="collapse" for="c-42218257">[-]</label><label class="expand" for="c-42218257">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not a major part of the paper, but Google tested a neural network decoder (which had the highest accuracy), and some of their other decoders used priors that were found using reinforcement learning (again for greater accuracy).</div><br/></div></div></div></div></div></div></div></div></div></body></html>