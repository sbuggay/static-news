<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687424459210" as="style"/><link rel="stylesheet" href="styles.css?v=1687424459210"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://claytonwramsey.github.io/2023/06/20/fiddler-const-magic.html">Blowing up my compile times for dubious benefits</a> <span class="domain">(<a href="https://claytonwramsey.github.io">claytonwramsey.github.io</a>)</span></div><div class="subtext"><span>Tyrubias</span> | <span>15 comments</span></div><br/><div><div id="36427586" class="c"><input type="checkbox" id="c-36427586" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#36427574">next</a><span>|</span><label class="collapse" for="c-36427586">[-]</label><label class="expand" for="c-36427586">[6 more]</label></div><br/><div class="children"><div class="content">While this post has a good amount of substance, I found it rather hard to understand due to small mistakes (or hidden assumptions, or something else?). All of which seem easily fixed&#x2F;clarified, but these sorts of things are unnecessary friction for readers.<p>Edit: Thanks to Jasper for stating the big hidden assumption made by the author - that he is only considering the case of being blocked by enemy pieces, not one&#x27;s own pieces. This is motivated by the fact that one can use the same side occupancy board to trivially remove all moves that are illegal due to self-blocking. This resolves many of the technical issues, although again, it should be be made explicit. The typos&#x2F;silly errors and pedagogical mistakes remain.<p>Some examples:<p>- According to the first bitboard (and the convention stated in the OP), A2 has index 8, not 1.<p>- In the second bitboard, the rook on e4 should be able to move to e1,a4,e8,h4.<p>- max of 9 relevant occupancy bits for a bishop - how? A bishop on e4 for example would have to check b1,c2,d3,f5,g6,h7 and a8,b7,c6,d5,f3,g2,h1 for a total of 13 bits. Similar mistake for a the rook.<p>- The so called &quot;original&quot; masked occupancy bitboard was not mentioned previously<p>- That same bitboard has variables b1,b2,b3,b4,b5 on it, a notational collision with the squares b1-b5.
- The variables b1-b5 are in the wrong place (presumably they were meant to be on c3,d4,e5,f6,g7 since the bishop is on b2, and again there is the question of why not h8 and the other missing squares).<p>- Magic number comes out of nowhere. What is it doing? Presumably the purpose is to extract the relevant positional bits to be the most significant ones while keeping the order, done through the multiplication + bitmasking, but this should be explicitly stated. We also have no idea how it is derived.<p>- What are the &quot;collisions&quot; actually collisions of? It would be nice to see an example of this.</div><br/><div id="36427926" class="c"><input type="checkbox" id="c-36427926" checked=""/><div class="controls bullet"><span class="by">JoshTriplett</span><span>|</span><a href="#36427586">parent</a><span>|</span><a href="#36427778">next</a><span>|</span><label class="collapse" for="c-36427926">[-]</label><label class="expand" for="c-36427926">[2 more]</label></div><br/><div class="children"><div class="content">&gt; - max of 9 relevant occupancy bits for a bishop - how? A bishop on e4 for example would have to check b1,c2,d3,f5,g6,h7 and a8,b7,c6,d5,f3,g2,h1 for a total of 13 bits. Similar mistake for a the rook.<p>If I&#x27;m understanding correctly: it&#x27;s trivial to use a mask with the occupancy bitmap for white&#x2F;black to eliminate moves atop your own pieces, and generate captures for moves atop your opponent&#x27;s pieces. The sliding move handling needs to look up whether a piece is <i>in the way</i> of your destination. So, the sliding move handling doesn&#x27;t need to handle spaces on the <i>edge</i> of the board, because they&#x27;ll never be in the way of another square.</div><br/><div id="36427968" class="c"><input type="checkbox" id="c-36427968" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#36427586">root</a><span>|</span><a href="#36427926">parent</a><span>|</span><a href="#36427778">next</a><span>|</span><label class="collapse" for="c-36427968">[-]</label><label class="expand" for="c-36427968">[1 more]</label></div><br/><div class="children"><div class="content">This makes a lot of sense and gives context to the assumption that we only need to handle the case where an opponent&#x27;s piece is in the way. Would be great if the author took the 2 sentences to explain this near the beginning of the article.</div><br/></div></div></div></div><div id="36427778" class="c"><input type="checkbox" id="c-36427778" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#36427586">parent</a><span>|</span><a href="#36427926">prev</a><span>|</span><a href="#36427574">next</a><span>|</span><label class="collapse" for="c-36427778">[-]</label><label class="expand" for="c-36427778">[3 more]</label></div><br/><div class="children"><div class="content">&gt; - In the second bitboard, the rook on e4 should be able to move to e1,a4,e8,h4.<p>It&#x27;s trying to find the set of legal moves. Or, rather, it&#x27;s trying to find the set of <i>illegal</i> moves that it can exclude from the subset of possible moves. The only thing determining whether a move is legal is whether there&#x27;s a piece in the way of that move, aka whether a piece is occupying a square, that&#x27;s what the bitboard check is about. If E1 is occupied, the set of legal moves is the same as if it is unoccupied, so it is irrelevant to check the bitboard for E1. I agree the article could be clearer about this.</div><br/><div id="36427882" class="c"><input type="checkbox" id="c-36427882" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#36427586">root</a><span>|</span><a href="#36427778">parent</a><span>|</span><a href="#36427574">next</a><span>|</span><label class="collapse" for="c-36427882">[-]</label><label class="expand" for="c-36427882">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m clearly misunderstanding something here. Assuming the rest of the board is empty, if e1 is occupied, the rook can&#x27;t move to e1, whereas if it isn&#x27;t occupied, the rook can move to e1, so there is at least one position in which we must check e1. What am I misunderstanding here?</div><br/><div id="36427889" class="c"><input type="checkbox" id="c-36427889" checked=""/><div class="controls bullet"><span class="by">Jasper_</span><span>|</span><a href="#36427586">root</a><span>|</span><a href="#36427882">parent</a><span>|</span><a href="#36427574">next</a><span>|</span><label class="collapse" for="c-36427889">[-]</label><label class="expand" for="c-36427889">[1 more]</label></div><br/><div class="children"><div class="content">Oh, I was assuming it was occupied by an enemy piece, and would capture it. You&#x27;re right that if it was occupied by an allied piece, it&#x27;s not a legal move.</div><br/></div></div></div></div></div></div></div></div><div id="36427574" class="c"><input type="checkbox" id="c-36427574" checked=""/><div class="controls bullet"><span class="by">evmar</span><span>|</span><a href="#36427586">prev</a><span>|</span><a href="#36428508">next</a><span>|</span><label class="collapse" for="c-36427574">[-]</label><label class="expand" for="c-36427574">[3 more]</label></div><br/><div class="children"><div class="content">&gt; to make all the constants known at compile time, everything has to be written in a const function. This means: No allocations [...] No for loops<p>These constants are relatively unchanging relative to the rest of your program.  Why not write a code generator (without the above weird restrictions) to compute them once and save the result?</div><br/><div id="36427612" class="c"><input type="checkbox" id="c-36427612" checked=""/><div class="controls bullet"><span class="by">harerazer</span><span>|</span><a href="#36427574">parent</a><span>|</span><a href="#36428508">next</a><span>|</span><label class="collapse" for="c-36427612">[-]</label><label class="expand" for="c-36427612">[2 more]</label></div><br/><div class="children"><div class="content">I was also confused by this. I was wondering if he was going to use #embed or something of the like.</div><br/><div id="36427894" class="c"><input type="checkbox" id="c-36427894" checked=""/><div class="controls bullet"><span class="by">thehappypm</span><span>|</span><a href="#36427574">root</a><span>|</span><a href="#36427612">parent</a><span>|</span><a href="#36428508">next</a><span>|</span><label class="collapse" for="c-36427894">[-]</label><label class="expand" for="c-36427894">[1 more]</label></div><br/><div class="children"><div class="content">I’m not a Rustacean, but it seems much easier to pre compute, store in a file, then load the file at startup</div><br/></div></div></div></div></div></div><div id="36428508" class="c"><input type="checkbox" id="c-36428508" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#36427574">prev</a><span>|</span><a href="#36427474">next</a><span>|</span><label class="collapse" for="c-36428508">[-]</label><label class="expand" for="c-36428508">[1 more]</label></div><br/><div class="children"><div class="content">The <i>bitboard</i> approach is similar to how graphics cards used to organize their memory in the heyday. It wasn&#x27;t one big buffer per screen with one or more consecutive bytes representing on pixel and one pixel after another. There were as many buffers as required by the bit depth, e.g. one for black and white, two for 4-colors and so on. Every bit was a pixel, so the top left corner was the MSB of the first byte of any buffer. We called this <i>bitplanes</i>.</div><br/></div></div><div id="36427474" class="c"><input type="checkbox" id="c-36427474" checked=""/><div class="controls bullet"><span class="by">liquidise</span><span>|</span><a href="#36428508">prev</a><span>|</span><a href="#36428730">next</a><span>|</span><label class="collapse" for="c-36427474">[-]</label><label class="expand" for="c-36427474">[1 more]</label></div><br/><div class="children"><div class="content">While i enjoyed the article, the title and opening sentence really deserve credit for being genuinely fun to read.</div><br/></div></div><div id="36428730" class="c"><input type="checkbox" id="c-36428730" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#36427474">prev</a><span>|</span><a href="#36429183">next</a><span>|</span><label class="collapse" for="c-36428730">[-]</label><label class="expand" for="c-36428730">[2 more]</label></div><br/><div class="children"><div class="content">Mathematical representation of A-bar &#x2F; A&#x27; - this is the complement of the set A?  That should probably be `~A` and not `!A` for the bitboard operation.  The logical negation would not give you the desired results, instead you want the bitwise negation (`~A`).</div><br/><div id="36429524" class="c"><input type="checkbox" id="c-36429524" checked=""/><div class="controls bullet"><span class="by">Sharlin</span><span>|</span><a href="#36428730">parent</a><span>|</span><a href="#36429183">next</a><span>|</span><label class="collapse" for="c-36429524">[-]</label><label class="expand" for="c-36429524">[1 more]</label></div><br/><div class="children"><div class="content">The article should have clarified it, but this is Rust so !A is correct (having a real boolean type, and no implicit casts to int, you don’t need a separate bitwise and logical not. Conceptually, ! always does a bitwise not, which in the case of a single-bit value <i>is</i> also the logical not.)</div><br/></div></div></div></div><div id="36429183" class="c"><input type="checkbox" id="c-36429183" checked=""/><div class="controls bullet"><span class="by">littlestymaar</span><span>|</span><a href="#36428730">prev</a><span>|</span><label class="collapse" for="c-36429183">[-]</label><label class="expand" for="c-36429183">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I suspect that the constant evaluator in Rust is just plain slow.<p>IIRC, it&#x27;s using the <i>miri</i> interpreter, which is indeed very slow.</div><br/></div></div></div></div></div></div></div></body></html>