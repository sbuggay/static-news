<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712653274363" as="style"/><link rel="stylesheet" href="styles.css?v=1712653274363"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://jvns.ca/blog/2014/12/21/fear-makes-you-a-worse-programmer/">Fear makes you a worse programmer (2014)</a> <span class="domain">(<a href="https://jvns.ca">jvns.ca</a>)</span></div><div class="subtext"><span>thunderbong</span> | <span>87 comments</span></div><br/><div><div id="39973962" class="c"><input type="checkbox" id="c-39973962" checked=""/><div class="controls bullet"><span class="by">tibbar</span><span>|</span><a href="#39973918">next</a><span>|</span><label class="collapse" for="c-39973962">[-]</label><label class="expand" for="c-39973962">[21 more]</label></div><br/><div class="children"><div class="content">Early on in my engineering career, there are a handful of times I was assigned to a project where I was set up to fail. I didn&#x27;t understand the situation until far too late. There are a few tell-tale symptoms: I didn&#x27;t quite understand what I was supposed to do; I didn&#x27;t really know how to do it; and I didn&#x27;t understand how the assigned work actually solved a higher-level problem. No one else did, either (these situations usually represent a failure of management.)<p>As those projects dragged on and I was unable to make &quot;progress&quot;, whatever that meant, I felt shame and a mounting dread of returning to the console each day. Eventually, fortunately, I was able to roll off them (not having accomplished much in the preceding month or two) and got back to doing useful things.<p>These days I can usually recognize such projects in advance, but it&#x27;s still not always possible to avoid them.</div><br/><div id="39974146" class="c"><input type="checkbox" id="c-39974146" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39975367">next</a><span>|</span><label class="collapse" for="c-39974146">[-]</label><label class="expand" for="c-39974146">[9 more]</label></div><br/><div class="children"><div class="content">As a senior person, these are some of my favorite types of projects, because I feel like it&#x27;s where I&#x27;m the most useful, and where I can have the most impact: understand the need, then implement the <i>need</i> rather than the request.<p>When I see people struggling with these, it&#x27;s usually from a lack of information seeking&#x2F;gathering, where they first sit down and code rather than spend the first few weeks talking, reviewing understanding, and, most importantly, finding those few A-team people that have meaningful input.<p>Definitely not something someone early in their career should be given, but these types of problems usually benefit from <i>devaluing</i> manager input, since they have a disconnected&#x2F;warped perception of reality. I take these projects only if the understanding is that I&#x27;ll be solving a problem, taking input from all involved, rather than implementing a specific solution.</div><br/><div id="39976102" class="c"><input type="checkbox" id="c-39976102" checked=""/><div class="controls bullet"><span class="by">gryn</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974146">parent</a><span>|</span><a href="#39975742">next</a><span>|</span><label class="collapse" for="c-39976102">[-]</label><label class="expand" for="c-39976102">[2 more]</label></div><br/><div class="children"><div class="content">that&#x27;s assuming you have somewhat cooperative people, in which case I don&#x27;t think it&#x27;s a setup to fail situation.<p>my reading of it was more like some past experience where I tried to do what you described only to be reprimanded for &quot;overstepping boundaries&quot; and that not being my job function, especially when the manager&#x2F;PO&#x2F;etc insist on being an exclusive gateway to information despite repeatedly failing to do that job correctly.<p>I think we all agree on the importance on your last part where you need to suss out whether they want an obedient code monkey or someone to solve the problem. probably through an iterative dialog where the parties involved get to explore and update their understanding of the problem, the technical and non technical constraints and the solution space.</div><br/><div id="39976303" class="c"><input type="checkbox" id="c-39976303" checked=""/><div class="controls bullet"><span class="by">robocat</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39976102">parent</a><span>|</span><a href="#39975742">next</a><span>|</span><label class="collapse" for="c-39976303">[-]</label><label class="expand" for="c-39976303">[1 more]</label></div><br/><div class="children"><div class="content">&gt; especially when the manager&#x2F;PO&#x2F;etc insist on being an exclusive gateway to information<p>A strong signal to leave a sinking ship. I suspect even if you somehow pull a rabbit out of the bag you wouldn&#x27;t be rewarded for it. I stuck with one project like that when I shouldn&#x27;t: I finished the work however the useless salesperson was screwing up the communications with the client and didn&#x27;t get the project across the line to them.<p>One of the most demotivating environments to suffer.</div><br/></div></div></div></div><div id="39975742" class="c"><input type="checkbox" id="c-39975742" checked=""/><div class="controls bullet"><span class="by">pdonis</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974146">parent</a><span>|</span><a href="#39976102">prev</a><span>|</span><a href="#39976970">next</a><span>|</span><label class="collapse" for="c-39975742">[-]</label><label class="expand" for="c-39975742">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I take these projects only if the understanding is that I&#x27;ll be solving a problem, taking input from all involved, rather than implementing a specific solution.</i><p>If this is the case, I would say you&#x27;re <i>not</i> being &quot;set up to fail&quot;, which was the explicit description the GP gave. &quot;Set up to fail&quot;, to me, implies that whoever is tasking you is not tasking you to actually solve the problem, either because they&#x27;re too clueless to know that what they&#x27;re specifically tasking you to do won&#x27;t work, or because there is some other hidden agenda in play.</div><br/></div></div><div id="39976970" class="c"><input type="checkbox" id="c-39976970" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974146">parent</a><span>|</span><a href="#39975742">prev</a><span>|</span><a href="#39974323">next</a><span>|</span><label class="collapse" for="c-39976970">[-]</label><label class="expand" for="c-39976970">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you but there are two prerequisites for this to work :<p>- as you said, this can’t be too soon in your career : gathering requirements and knowledge is something that you can’t do without experience<p>- you need to be 100% confident that you are working in an environment where you will be rewarded accordingly. Working hard on those projects just to see your manager be promoted will be an absolute emotional disaster.<p>If one of those requirements aren’t met, you are good for burning out.</div><br/><div id="39977517" class="c"><input type="checkbox" id="c-39977517" checked=""/><div class="controls bullet"><span class="by">whstl</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39976970">parent</a><span>|</span><a href="#39974323">next</a><span>|</span><label class="collapse" for="c-39977517">[-]</label><label class="expand" for="c-39977517">[1 more]</label></div><br/><div class="children"><div class="content">I agree, and I also find that it&#x27;s mostly developers with experience that are able to do it... but it&#x27;s not because of seniority: it&#x27;s because people with 10+ years of experience simply had to learn it in the past.<p>In the past there was no choice: developers would talk to users and stakeholders and collect information.<p>Today there are few opportunities for a junior developer to do this.</div><br/></div></div></div></div><div id="39974323" class="c"><input type="checkbox" id="c-39974323" checked=""/><div class="controls bullet"><span class="by">softfalcon</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974146">parent</a><span>|</span><a href="#39976970">prev</a><span>|</span><a href="#39974157">next</a><span>|</span><label class="collapse" for="c-39974323">[-]</label><label class="expand" for="c-39974323">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, these types of projects can turn out to be a real gift. They are essentially a &quot;folks here have an initiative they want to fund but don&#x27;t know how&quot; and if you direct the conversations well, you can create something incredible out of it.<p>Things being up in the air and vague is often an opportunity to step in a tame a wild forest of ideas into a real application.<p>It definitely takes a certain type of mindset to harness that energy and herd the cats though.</div><br/></div></div><div id="39974157" class="c"><input type="checkbox" id="c-39974157" checked=""/><div class="controls bullet"><span class="by">j45</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974146">parent</a><span>|</span><a href="#39974323">prev</a><span>|</span><a href="#39975367">next</a><span>|</span><label class="collapse" for="c-39974157">[-]</label><label class="expand" for="c-39974157">[2 more]</label></div><br/><div class="children"><div class="content">Getting the need right, in lockstep with the audiences realization of it is an important soft and hard skill that should be better taught.</div><br/><div id="39974260" class="c"><input type="checkbox" id="c-39974260" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974157">parent</a><span>|</span><a href="#39975367">next</a><span>|</span><label class="collapse" for="c-39974260">[-]</label><label class="expand" for="c-39974260">[1 more]</label></div><br/><div class="children"><div class="content">&gt; in lockstep with the audiences realization<p>Perfect wording! I tell people the hardest problem, in my work, is getting people to see there is a problem. The crazy workarounds that people will come up with, to avoid the root issue, are really <i>incredible</i>.</div><br/></div></div></div></div></div></div><div id="39975367" class="c"><input type="checkbox" id="c-39975367" checked=""/><div class="controls bullet"><span class="by">ChrisMarshallNY</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39974146">prev</a><span>|</span><a href="#39974261">next</a><span>|</span><label class="collapse" for="c-39975367">[-]</label><label class="expand" for="c-39975367">[2 more]</label></div><br/><div class="children"><div class="content">One of my first programming assignments was to fix bugs in a 100KLoC+ FORTRAN 4 codebase.<p>All one text file (300 baud VT-100 CLI). The line printer saw <i>lots</i> of use.<p>No comments.<p>No subroutines (just <i>lots</i> of GOTOs).<p>Helpful variable names, like <i>A32Q3</i><p>It was mid-1970s vintage. The original developer was a Bob Ross-looking guy that I wasn&#x27;t allowed to bother.<p>I was on my own.<p>My most effective tool was a magic 8-ball. Lots of guessing.<p>It helped me to ensure that I would <i>never</i> do that to anyone, ever.<p>It did help me to be better, in the long run. Once you have seen Hell, everywhere else is Heaven.</div><br/><div id="39976104" class="c"><input type="checkbox" id="c-39976104" checked=""/><div class="controls bullet"><span class="by">globalnode</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39975367">parent</a><span>|</span><a href="#39974261">next</a><span>|</span><label class="collapse" for="c-39976104">[-]</label><label class="expand" for="c-39976104">[1 more]</label></div><br/><div class="children"><div class="content">similar thing happened to me straight out of uni -- i was less interested however and quit my job. in fact i quit the entire industry.</div><br/></div></div></div></div><div id="39974261" class="c"><input type="checkbox" id="c-39974261" checked=""/><div class="controls bullet"><span class="by">ElevenLathe</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39975367">prev</a><span>|</span><a href="#39974516">next</a><span>|</span><label class="collapse" for="c-39974261">[-]</label><label class="expand" for="c-39974261">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve rarely had a task assigned to me that was well-defined enough to even know if I completed it. Usually there is good intentions, but the people above you just don&#x27;t have time to dig into the details of what it is they think they are assigning to you. This also means that they can&#x27;t really check up on you too well, either. The trick is to just dig in, do some research, do stuff (ideally stuff that genuinely needs doing, that you can accomplish, and is related to the &quot;task&quot; you have been given), and report on it confidently. Eventually people will consider you an expert on that issue&#x2F;area and will defer to you about what needs to be done. Once you hit this point, you can make a list of &quot;nice to haves&quot; in this area, throw them on the backlog, and declare yourself done. If you&#x27;re recognized as the main expert on that subject, it will be tough for people to argue with you.</div><br/><div id="39974332" class="c"><input type="checkbox" id="c-39974332" checked=""/><div class="controls bullet"><span class="by">tibbar</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974261">parent</a><span>|</span><a href="#39974516">next</a><span>|</span><label class="collapse" for="c-39974332">[-]</label><label class="expand" for="c-39974332">[1 more]</label></div><br/><div class="children"><div class="content">I think the difference here is that a &#x27;bad&#x27; project will often be very specific. You will have a very particular outcome that you must achieve to finish, and you know what it is. (&quot;Migrate our database from NoSQL to a relational database!&quot; etc.) But you don&#x27;t actually have the skills to perform the task, or the support to even get started in the right direction. You don&#x27;t even know what questions to ask, or who to ask them to. You&#x27;re just ... lost.<p>It&#x27;s also possible the project is simply too hard -- maybe doing it right would take an experienced engineer two years; but since that approach seems like obviously too much work, you flail around assuming there must be some alternative.<p>This is, sadly, pretty common for junior programmers and people who are new to a team.</div><br/></div></div></div></div><div id="39974516" class="c"><input type="checkbox" id="c-39974516" checked=""/><div class="controls bullet"><span class="by">nestorD</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39974261">prev</a><span>|</span><a href="#39974577">next</a><span>|</span><label class="collapse" for="c-39974516">[-]</label><label class="expand" for="c-39974516">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Early on in my engineering career, there are a handful of times I was assigned to a project where I was set up to fail. I didn&#x27;t understand the situation until far too late. There are a few tell-tale symptoms: I didn&#x27;t quite understand what I was supposed to do; I didn&#x27;t really know how to do it; and I didn&#x27;t understand how the assigned work actually solved a higher-level problem. No one else did, either (these situations usually represent a failure of management.)<p>Yes! I have been in such a situation once (I didn&#x27;t quite understand what I was supposed to do <i>and</i> no one else did, either) and, to this day, I remember it as a cautionary tale when I think of moving to a new position.<p>The people who think that they can shine in this situation by being proactive underestimate the lack of understanding: it is not a blurry task, it is a task where you are told to do X and no one knows what X actually means. You can do great things, but they will not be able to deliver on the requirements.</div><br/><div id="39975926" class="c"><input type="checkbox" id="c-39975926" checked=""/><div class="controls bullet"><span class="by">XorNot</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974516">parent</a><span>|</span><a href="#39974577">next</a><span>|</span><label class="collapse" for="c-39975926">[-]</label><label class="expand" for="c-39975926">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of when I was hired as an SRE, then told you can&#x27;t log on to any of the customer systems until you&#x27;ve committed code to the main infrastructure codebase and you&#x27;re &quot;trusted&quot;. This was the only thing the other members of the SRE team actually did though - the job itself was basically &quot;figure out why things go weird sometimes in the customer systems and then fix underlying automation issues&quot;.<p>But there was an actual developer team as well, including all the original founders - who knew the system perfectly. So things would get posted and you&#x27;d be like &quot;oh, that&#x27;s a good starter task...&quot; and instead a &quot;core&quot; developer would pick it, do the one line fix, and then just push it straight to the master branch (or PR it but it would get approved within minutes in their timezone) while I was still trying to get my bearings in the code and tests.<p>Within a month or two the manager who hired me had &quot;resigned&quot;, and then I was let go near the end of my probationary period. The whole time I never had any solid work assigned beyond &quot;oh figure out where you can be useful&quot;.</div><br/></div></div></div></div><div id="39974577" class="c"><input type="checkbox" id="c-39974577" checked=""/><div class="controls bullet"><span class="by">yarg</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39974516">prev</a><span>|</span><a href="#39974608">next</a><span>|</span><label class="collapse" for="c-39974577">[-]</label><label class="expand" for="c-39974577">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been in a situation where I was set to fail despite the fact that I was actually performing a vital task for the company.<p>Every damned time I set out to implement changes necessary to ensure the maintainability of the project, the boss would bring in an architect (who otherwise never even looked at the project) and he would pull the rug out from under my feet.<p>Every damned time. By the time they realised I was actually useful and regretted the situation I was checked out and ready to walk out the door.</div><br/><div id="39975194" class="c"><input type="checkbox" id="c-39975194" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39973962">root</a><span>|</span><a href="#39974577">parent</a><span>|</span><a href="#39974608">next</a><span>|</span><label class="collapse" for="c-39975194">[-]</label><label class="expand" for="c-39975194">[1 more]</label></div><br/><div class="children"><div class="content">Hmm, was your architect also allergic to any kind of risk? E.g. any change was by default undesireable because any change carried more risk than not changing anything.</div><br/></div></div></div></div><div id="39974608" class="c"><input type="checkbox" id="c-39974608" checked=""/><div class="controls bullet"><span class="by">ww520</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39974577">prev</a><span>|</span><a href="#39976939">next</a><span>|</span><label class="collapse" for="c-39974608">[-]</label><label class="expand" for="c-39974608">[1 more]</label></div><br/><div class="children"><div class="content">This brings back memory of one of my projects.  After I had couple years of professional development under my bell, I started contract work on the side.  I&#x27;ve done a project with a client and it was a success.  They wanted me to tackle a bigger problem, porting their app server from Unix to Windows.  I thought how hard could it be, and took on the job.  Turned out their server was written in Perl scripts and Perl was not running on Windows back then.  After couple days of looking at their code and build system, I told them to either rewrite their server in Microsoft IIS Web server or Perl had to be ported to Windows to run their Perl scripts.  They said port Perl to Windows.  The naive me didn&#x27;t comprehend the gravity of such task and took it on.  I struggled for couple weekends and realized it&#x27;s not just the Perl interpreter needed to be ported but the whole Perl ecosystem.  It&#x27;s not a task a weekend contractor could take on.  I gave up and told the client the bad news.  They just shrugged and said they just wanted how far I could get.</div><br/></div></div><div id="39976939" class="c"><input type="checkbox" id="c-39976939" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#39973962">parent</a><span>|</span><a href="#39974608">prev</a><span>|</span><a href="#39975835">next</a><span>|</span><label class="collapse" for="c-39976939">[-]</label><label class="expand" for="c-39976939">[1 more]</label></div><br/><div class="children"><div class="content">Same here, and that’s how you start your career with an authentic burnout.</div><br/></div></div></div></div><div id="39973918" class="c"><input type="checkbox" id="c-39973918" checked=""/><div class="controls bullet"><span class="by">bluefirebrand</span><span>|</span><a href="#39973962">prev</a><span>|</span><a href="#39975173">next</a><span>|</span><label class="collapse" for="c-39973918">[-]</label><label class="expand" for="c-39973918">[39 more]</label></div><br/><div class="children"><div class="content">&gt; Even with good design, w&#x2F;o tests you will fear change and so the code will rot. With good tests, there’s no fear, so you’ll clean the code<p>Has anyone ever actually found this to be true?<p>I work in a place with 99% test coverage requirements and it&#x27;s honestly still a super brittle system that everyone is afraid to make big changes to<p>In my experience, automated tests don&#x27;t promote quality engineering, they just calcify whatever quality exists<p>And before you get into it, TDD is not a panacea for this problem</div><br/><div id="39974061" class="c"><input type="checkbox" id="c-39974061" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974317">next</a><span>|</span><label class="collapse" for="c-39974061">[-]</label><label class="expand" for="c-39974061">[7 more]</label></div><br/><div class="children"><div class="content">Test-a-single-function style, what most people default to when they hear &quot;unit test&quot;, is probably the thing that most leads into that situation.<p>I&#x27;ve been occasionally pushing coworkers to restructure code and tests into a higher level style, defining an API boundary and calling it from the rest of the code (as if you&#x27;re writing a library except it&#x27;s inside your codebase instead of installed), then writing tests to that API.  That does make for some easily refactorable code where the tests don&#x27;t need to change at all.<p>That pseudo-library style is kind of what &quot;unit test&quot; originally meant: a business unit, not a code unit. Examples simplified it too much and people copied the style instead of the substance, and the original meaning was lost.<p>For another example, some of our recent projects have been on updating daemons, those have also been really good candidates for this since there are clear entry and exit points.</div><br/><div id="39976810" class="c"><input type="checkbox" id="c-39976810" checked=""/><div class="controls bullet"><span class="by">mythhabit</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974061">parent</a><span>|</span><a href="#39974621">next</a><span>|</span><label class="collapse" for="c-39976810">[-]</label><label class="expand" for="c-39976810">[1 more]</label></div><br/><div class="children"><div class="content">I believe that the original definition, way back before most of us were born, was a test of the smallest possible unit, i.e a single function ect. At least according to Wikipedia, in 1969, it was defined at unit tests, component tests and integration tests.<p>In todays development world, the unittest is primarily a developer tool to help speed up development. One should not be afraid to delete unittests if they are doing refactorings. But the long term value is always in the integration tests.</div><br/></div></div><div id="39974621" class="c"><input type="checkbox" id="c-39974621" checked=""/><div class="controls bullet"><span class="by">maw</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974061">parent</a><span>|</span><a href="#39976810">prev</a><span>|</span><a href="#39974766">next</a><span>|</span><label class="collapse" for="c-39974621">[-]</label><label class="expand" for="c-39974621">[1 more]</label></div><br/><div class="children"><div class="content">&gt; That pseudo-library style is kind of what &quot;unit test&quot; originally meant: a business unit, not a code unit. Examples simplified it too much and people copied the style instead of the substance, and the original meaning was lost.<p>Very interesting.  It sounds a bit like what happened with the term &quot;Hungarian notation&quot;.</div><br/></div></div><div id="39974766" class="c"><input type="checkbox" id="c-39974766" checked=""/><div class="controls bullet"><span class="by">GuB-42</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974061">parent</a><span>|</span><a href="#39974621">prev</a><span>|</span><a href="#39974317">next</a><span>|</span><label class="collapse" for="c-39974766">[-]</label><label class="expand" for="c-39974766">[4 more]</label></div><br/><div class="children"><div class="content">But you probably won&#x27;t get 99% coverage doing that. Some conditions are just too difficult to get from a higher level, and you still need to take them in consideration: hardware-related problems, race conditions, etc...<p>I don&#x27;t consider it a problem, but it is to those who want to see big numbers.</div><br/><div id="39975574" class="c"><input type="checkbox" id="c-39975574" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974766">parent</a><span>|</span><a href="#39976513">next</a><span>|</span><label class="collapse" for="c-39975574">[-]</label><label class="expand" for="c-39975574">[2 more]</label></div><br/><div class="children"><div class="content">I feel like if you&#x27;re unable to get 99% coverage with that then there&#x27;s probably some dead code that needs pruned.<p>As for hardware-related problems and race conditions, testing at a higher level of abstraction seems like it&#x27;d help more than it&#x27;d hurt - in the former case ensuring graceful handling as part of the tests, and in the latter case making the race conditions more likely to hit (and hopefully fix).</div><br/><div id="39976220" class="c"><input type="checkbox" id="c-39976220" checked=""/><div class="controls bullet"><span class="by">lll-o-lll</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39975574">parent</a><span>|</span><a href="#39976513">next</a><span>|</span><label class="collapse" for="c-39976220">[-]</label><label class="expand" for="c-39976220">[1 more]</label></div><br/><div class="children"><div class="content">I see the OP as talking about “integration” style tests (say testing against an api) and not being able to capture all of the OS and similar edge case errors in the test. I do think this is a hard problem, particularly if you don’t design for it from the outset.<p>It’s a bit of the old classic “reading from the file never returns an ‘access denied’ error, until it does”. There’s ways and means, but let’s not pretend this is simple.</div><br/></div></div></div></div><div id="39976513" class="c"><input type="checkbox" id="c-39976513" checked=""/><div class="controls bullet"><span class="by">jval43</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974766">parent</a><span>|</span><a href="#39975574">prev</a><span>|</span><a href="#39974317">next</a><span>|</span><label class="collapse" for="c-39976513">[-]</label><label class="expand" for="c-39976513">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t need 99% coverage. You just need enough coverage to be able to refactor the thing without breaking it.</div><br/></div></div></div></div></div></div><div id="39974317" class="c"><input type="checkbox" id="c-39974317" checked=""/><div class="controls bullet"><span class="by">vineyardmike</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974061">prev</a><span>|</span><a href="#39976613">next</a><span>|</span><label class="collapse" for="c-39974317">[-]</label><label class="expand" for="c-39974317">[1 more]</label></div><br/><div class="children"><div class="content">Just to re-iterate another commenter, I had a positive experience before.<p>When I was at BigCompanyA, we had 95% coverage requirements as a management fiat. The company generally was very management-decree-driven. People would unit test individual methods and helper functions and each “unit” of code. If you wanted to change an API, you had to dig through a sea of broken tests because each little bit of code was individually tested. We literally had unit tests that validated one line methods for string concatenation of a prefix (in Java). Management said add tests with each commit so everyone added tests without thinking about what is valuable.<p>At BigCompanyB, our testing was engineering driven, not some management metric being tracked. The goal was to test “public interfaces” and ensure that these tests captured all the helper methods along the way. This helped catch dead or extraneous code if you couldn’t write a test to exercise a particular path. Changing an API didn’t require changing a bunch of silly tests. We still had equal &gt;95% coverage, and it was very useful.<p>Basically you need to actually think about what makes sense to test and write logical tests.</div><br/></div></div><div id="39976613" class="c"><input type="checkbox" id="c-39976613" checked=""/><div class="controls bullet"><span class="by">PaulStatezny</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974317">prev</a><span>|</span><a href="#39974045">next</a><span>|</span><label class="collapse" for="c-39976613">[-]</label><label class="expand" for="c-39976613">[4 more]</label></div><br/><div class="children"><div class="content">You need mostly integration tests, not unit tests.<p>Unit tests which dependency-inject mocks of other parts of your codebase are 99% <i>worthless</i>.<p>Source: Spent many years writing the latter and they caught close to 0 bugs. Moved to Elixir ecosystem where integration tests are the norm, and they catch bugs on a regular basis.</div><br/><div id="39976915" class="c"><input type="checkbox" id="c-39976915" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39976613">parent</a><span>|</span><a href="#39977022">next</a><span>|</span><label class="collapse" for="c-39976915">[-]</label><label class="expand" for="c-39976915">[2 more]</label></div><br/><div class="children"><div class="content">Bingo!<p>I never understood the fascination with Unit Tests. For Testing to be useful the code being tested should have a certain degree of Complexity (algorithmic&#x2F;behavioural&#x2F;state-transition&#x2F;etc.). But what i see from most unit tests is mere &quot;busy work&quot; as if mock-testing a trivial class&#x2F;api&#x2F;etc. would somehow make your code better. A similar criticism is also applicable to TDD based programming.</div><br/><div id="39977313" class="c"><input type="checkbox" id="c-39977313" checked=""/><div class="controls bullet"><span class="by">hitchstory</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39976915">parent</a><span>|</span><a href="#39977022">next</a><span>|</span><label class="collapse" for="c-39977313">[-]</label><label class="expand" for="c-39977313">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;busy work&quot; of low level unit tests is perfectly valid, but TDD still works extremely well with high level integration tests so I don&#x27;t think a similar criticism necessarily applies.</div><br/></div></div></div></div><div id="39977022" class="c"><input type="checkbox" id="c-39977022" checked=""/><div class="controls bullet"><span class="by">pjerem</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39976613">parent</a><span>|</span><a href="#39976915">prev</a><span>|</span><a href="#39974045">next</a><span>|</span><label class="collapse" for="c-39977022">[-]</label><label class="expand" for="c-39977022">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, Unit tests are interesting when they are inlined with the function they test, i.e. in the same file (like python doctests). Of course it’s harder to set the testing environment but that may in fact be encouraging you to write stateless code so there is that.</div><br/></div></div></div></div><div id="39974045" class="c"><input type="checkbox" id="c-39974045" checked=""/><div class="controls bullet"><span class="by">jasonpeacock</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39976613">prev</a><span>|</span><a href="#39974004">next</a><span>|</span><label class="collapse" for="c-39974045">[-]</label><label class="expand" for="c-39974045">[1 more]</label></div><br/><div class="children"><div class="content">I have, and it was amazing.<p>You could quickly make the changes you want not worry about what else breaks, then run the tests. The tests that you expect to fail would fail, and you fix them. Then you find other tests that you didn&#x27;t expect also failed; you&#x27;d review the impact of your changes on those parts of the system and make appropriate changes until the tests were happy.<p>Because the testing was so thorough (and quality), you had high confidence that nothing unexpected was broken.<p>It was &quot;move fast &amp; break [tests], then fix them and deploy&quot; :)</div><br/></div></div><div id="39974004" class="c"><input type="checkbox" id="c-39974004" checked=""/><div class="controls bullet"><span class="by">nickjj</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974045">prev</a><span>|</span><a href="#39974085">next</a><span>|</span><label class="collapse" for="c-39974004">[-]</label><label class="expand" for="c-39974004">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Has anyone ever actually found this to be true?<p>It depends.<p>I&#x27;ve written a number of apps where I&#x27;m fearless with making changes because I trust the tests I wrote. One of the apps has been running for 7 years and it&#x27;s had a lot of big updates, refactors, etc.. I&#x27;m breaking every rule there is on jinxing things but there hasn&#x27;t been a single bug introduced due to those updates and there&#x27;s ~85% coverage. It&#x27;s only a ~3k line Flask app though, but it does get deployed straight to production with no staging environment and gets hundreds of requests per day. It writes to a DB, Redis, interacts with multiple 3rd party APIs and sends out webhooks so it does quite a few &quot;external&quot; things.<p>I&#x27;ve never been a fan of TDD and personally I think tests that really hit your DB, Redis, etc. help a lot more than mocked out unit tests or a billion unit tests and nothing else. I tend to write more tests that really test things together. Not full blown Selenium style tests, but I do really write to the DB and other data stores in tests and often use a framework&#x27;s built-in test client for making HTTP calls. Everything can still be really fast too (~100 tests in 2 seconds is my usual rough guide for having an assortment of &quot;real&quot; tests with Flask).</div><br/><div id="39974132" class="c"><input type="checkbox" id="c-39974132" checked=""/><div class="controls bullet"><span class="by">solraph</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974004">parent</a><span>|</span><a href="#39974085">next</a><span>|</span><label class="collapse" for="c-39974132">[-]</label><label class="expand" for="c-39974132">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve never been a fan of TDD and personally I think tests that really hit your DB, Redis, etc. help a lot more than mocked out unit tests or a billion unit tests and nothing else...  ...but I do really write to the DB and other data stores in tests<p>I&#x27;ve come to the conclusion that the idea that &quot;unit tests&quot; should test functions&#x2F;objects in isolation with completely mocked dependencies is based more on the slow speed of those dependencies in the past than what actually makes for good tests. Now that we have faster computers and storage devices, and easy&#x2F;fast store creation, we should move past this.<p>Obviously, this is very dependant (no pun intended) on the dependency in question, but as a minimum, anything with SQL should have a test that hits a real SQL DB (PG in docker for example) at some point.</div><br/><div id="39974689" class="c"><input type="checkbox" id="c-39974689" checked=""/><div class="controls bullet"><span class="by">arp242</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974132">parent</a><span>|</span><a href="#39974085">next</a><span>|</span><label class="collapse" for="c-39974689">[-]</label><label class="expand" for="c-39974689">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not even about faster computers and storage, but just about better test techniques, and better written tests. You don&#x27;t actually need very fast hardware for fast tests; you just need to spend some time on it. And roughly know what you&#x27;re doing.<p>External dependencies (such as PostgreSQL, Redis, what-have-you) are a pain though. I feel pretty strongly that just a single command (&quot;go test&quot;, &quot;cargo test&quot;, &quot;npm test&quot;, etc.) should run all the tests on all platforms, reliably, with a minimal of fuss and messing about. Things like docker-compose or whatnot quality as &quot;a fuss and messing about&quot;.</div><br/></div></div></div></div></div></div><div id="39974085" class="c"><input type="checkbox" id="c-39974085" checked=""/><div class="controls bullet"><span class="by">furstenheim</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974004">prev</a><span>|</span><a href="#39976589">next</a><span>|</span><label class="collapse" for="c-39974085">[-]</label><label class="expand" for="c-39974085">[1 more]</label></div><br/><div class="children"><div class="content">Take a look at hexagon pattern from Spotify. Once you start testing the user contract of your services against real databases (testcontainners is a good option), then you can change all the internals and be sure that the externals will work.<p><a href="https:&#x2F;&#x2F;engineering.atspotify.com&#x2F;2018&#x2F;01&#x2F;testing-of-microservices&#x2F;" rel="nofollow">https:&#x2F;&#x2F;engineering.atspotify.com&#x2F;2018&#x2F;01&#x2F;testing-of-microse...</a></div><br/></div></div><div id="39976589" class="c"><input type="checkbox" id="c-39976589" checked=""/><div class="controls bullet"><span class="by">onion2k</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974085">prev</a><span>|</span><a href="#39974724">next</a><span>|</span><label class="collapse" for="c-39976589">[-]</label><label class="expand" for="c-39976589">[1 more]</label></div><br/><div class="children"><div class="content"><i>I work in a place with 99% test coverage requirements and it&#x27;s honestly still a super brittle system that everyone is afraid to make big changes to.</i><p>Obviously tests are going to break when you change the code&#x27;s APIs and functionality. That&#x27;s expected, and does nothing to boost your confidence in the part of the code you&#x27;re working in. The point of tests is to improve your confidence that you&#x27;re not doing things that have an unexpected impact somewhere else (hence the Bob Martin quote in the article about tests being useful even if you have good design).<p>Tests aren&#x27;t an alternative to thinking. You still have to consider what changes you&#x27;re making, and what tests <i>should</i> break as a result. That&#x27;s just part of your code change. When tests that <i>shouldn&#x27;t</i> have broken start failing that&#x27;s when they show their value.</div><br/></div></div><div id="39974724" class="c"><input type="checkbox" id="c-39974724" checked=""/><div class="controls bullet"><span class="by">dimal</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39976589">prev</a><span>|</span><a href="#39975211">next</a><span>|</span><label class="collapse" for="c-39974724">[-]</label><label class="expand" for="c-39974724">[1 more]</label></div><br/><div class="children"><div class="content">Only for limited areas of a server codebase on a small team who understood what tests were meant to accomplish and wrote excellent tests. Basically, about a year and a half out of a twenty five year career. I’ve never seen them useful on front end code except in extremely limited circumstances.<p>In most other cases, we had tests that only covered the happy path and did little more than slow down builds and make refactoring more difficult. In other words, they made things worse. E2E tests, in particular, are the Afghanistan of web development. I’ve seen more time wasted getting useless tests green than I’ve seen wasted on any other programming exercise.</div><br/></div></div><div id="39975211" class="c"><input type="checkbox" id="c-39975211" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974724">prev</a><span>|</span><a href="#39977105">next</a><span>|</span><label class="collapse" for="c-39975211">[-]</label><label class="expand" for="c-39975211">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Has anyone ever actually found this to be true?<p>We have a 300kloc monster, and I find that going up from 0 to 60% test coverage has given me  appreciably more confidence that the system still works after any change.<p>Sure, the test code is almost twice that size, and breaks almost as often as the code, but my confidence in the system itself is definitely higher.<p>To prevent people from writing tests that need too many mocks we now have explicit dependency injection. So much easier to reason about stuff, and prevent’s people from not testing the important bits.</div><br/></div></div><div id="39977105" class="c"><input type="checkbox" id="c-39977105" checked=""/><div class="controls bullet"><span class="by">lijok</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39975211">prev</a><span>|</span><a href="#39974013">next</a><span>|</span><label class="collapse" for="c-39977105">[-]</label><label class="expand" for="c-39977105">[1 more]</label></div><br/><div class="children"><div class="content">&gt; With good tests<p>&gt; I work in a place with 99% test coverage requirements<p>Sounds like your problem is bad tests. In fact, I guarantee they’re bad tests because that’s exactly what coverage requirements lead to</div><br/></div></div><div id="39974013" class="c"><input type="checkbox" id="c-39974013" checked=""/><div class="controls bullet"><span class="by">vidugavia</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39977105">prev</a><span>|</span><a href="#39974073">next</a><span>|</span><label class="collapse" for="c-39974013">[-]</label><label class="expand" for="c-39974013">[2 more]</label></div><br/><div class="children"><div class="content">99% coverage does not mean you have good tests. Yes, I have experienced that good tests, combined with a good understanding which parts are critical and which are not, create a great comfort about introducing changes, whether it&#x27;s Friday afternoon or Monday morning.</div><br/></div></div><div id="39974073" class="c"><input type="checkbox" id="c-39974073" checked=""/><div class="controls bullet"><span class="by">solraph</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974013">prev</a><span>|</span><a href="#39976560">next</a><span>|</span><label class="collapse" for="c-39974073">[-]</label><label class="expand" for="c-39974073">[1 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; Even with good design, w&#x2F;o tests you will fear change and so the code will rot. With good tests, there’s no fear, so you’ll clean the code<p>&gt; Has anyone ever actually found this to be true?<p>Yes, but you have to have the right kind of test coverage, and that&#x27;s the tricky part.<p>Yesterday, I refactored a bunch of functions that changed a bunch of unit tests. However, since we also have integration&#x2F;system tests on that code, I&#x27;m confident that I haven&#x27;t broken the code as a whole. Without those system tests, I would not have confidence that the change would be successful, and probably would not have refactored.<p>In another codebase that hadn&#x27;t been touched for a year, as part of a feature change I refactored an SQL statement to what I thought was a more optimal design and immediately broke a bunch of tests. Based on that, I was able to understand the original intent of the SQL, and updated it in line with the feature change. I added test scenarios for the new feature, but left the existing scenarios as is.<p>Without those tests, would have broken the system in a subtle way.</div><br/></div></div><div id="39976560" class="c"><input type="checkbox" id="c-39976560" checked=""/><div class="controls bullet"><span class="by">bazoom42</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974073">prev</a><span>|</span><a href="#39974366">next</a><span>|</span><label class="collapse" for="c-39976560">[-]</label><label class="expand" for="c-39976560">[1 more]</label></div><br/><div class="children"><div class="content">It is easy to create bad tests. I have seen an over-reliance on mocking giving high code coverage but still quite useless tests.</div><br/></div></div><div id="39974366" class="c"><input type="checkbox" id="c-39974366" checked=""/><div class="controls bullet"><span class="by">zelphirkalt</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39976560">prev</a><span>|</span><a href="#39974031">next</a><span>|</span><label class="collapse" for="c-39974366">[-]</label><label class="expand" for="c-39974366">[2 more]</label></div><br/><div class="children"><div class="content">At some point you start to fear changing too much, because of all the tests you will have to rewrite, which can be tedious, especially, when the code mutates things all over the place and you have to mock 5 things per unit test.</div><br/><div id="39976574" class="c"><input type="checkbox" id="c-39976574" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974366">parent</a><span>|</span><a href="#39974031">next</a><span>|</span><label class="collapse" for="c-39976574">[-]</label><label class="expand" for="c-39976574">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; because of all the tests you will have to rewrite</i><p>If you have to rewrite tests that means you&#x27;ve changed the user experience in ways that are not backwards compatible.<p>Which is sometimes valid, but not exactly what is being talked about here. The discussion here is more about changing the code in ways that makes the code better, but still delivers the same user experience – possibly with new features added, but not where anything is taken away.</div><br/></div></div></div></div><div id="39974031" class="c"><input type="checkbox" id="c-39974031" checked=""/><div class="controls bullet"><span class="by">lukev</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974366">prev</a><span>|</span><a href="#39974053">next</a><span>|</span><label class="collapse" for="c-39974031">[-]</label><label class="expand" for="c-39974031">[5 more]</label></div><br/><div class="children"><div class="content">This is why I&#x27;m neutral on the value of unit tests. Sometimes they are helpful, other times less so.<p>I am always in favor of tests around the boundaries between system components (regardless of what you call them; integration tests, API tests, etc.) The more robust the better.<p>If I&#x27;m working on a system with robust (ideally generative) integration tests covering the interface of a component, I feel I have near-complete freedom to rewrite any aspect of the component I want with high confidence.</div><br/><div id="39976055" class="c"><input type="checkbox" id="c-39976055" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974031">parent</a><span>|</span><a href="#39974125">next</a><span>|</span><label class="collapse" for="c-39976055">[-]</label><label class="expand" for="c-39976055">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; I am always in favor of tests around the boundaries between system components (regardless of what you call them; integration tests, API tests, etc.)</i><p>Funnily enough, &quot;unit tests&quot; is what this was called originally. The boundary is what &quot;unit&quot; referred to. In my experience, these days most people just call them &quot;tests&quot;. That they happen at the boundary is implied as by this point it is generally agreed upon that testing anything else is a waste of time at best and sometimes even detrimental.<p>Which is why nobody in fake internet argument land can settle on what &quot;unit&quot;, &quot;integration&quot;, etc. mean in the modern age. There is nothing related to testing in need of additional qualification to communicate to other developers what isn&#x27;t already communicated with &quot;tests&quot; alone.</div><br/></div></div><div id="39974125" class="c"><input type="checkbox" id="c-39974125" checked=""/><div class="controls bullet"><span class="by">adonovan</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974031">parent</a><span>|</span><a href="#39976055">prev</a><span>|</span><a href="#39974205">next</a><span>|</span><label class="collapse" for="c-39974125">[-]</label><label class="expand" for="c-39974125">[1 more]</label></div><br/><div class="children"><div class="content">Unit tests are good when there are clear and durable units, but what many people seem to mean by a unit test is one that exercises the internal functions of a package, or the API of an internal package that evolves as fast as your product.<p>Stable interfaces that the user cares about (e.g. CLI, public API, RPCs) make for the highest-value tests.</div><br/></div></div><div id="39974205" class="c"><input type="checkbox" id="c-39974205" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974031">parent</a><span>|</span><a href="#39974125">prev</a><span>|</span><a href="#39974053">next</a><span>|</span><label class="collapse" for="c-39974205">[-]</label><label class="expand" for="c-39974205">[2 more]</label></div><br/><div class="children"><div class="content">&gt; ideally generative<p>How have you seen this done well? In my experience, this usually ends up being some hello-world type simplicity that doesn&#x27;t really represent the real world use corner cases.</div><br/><div id="39974338" class="c"><input type="checkbox" id="c-39974338" checked=""/><div class="controls bullet"><span class="by">lukev</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974205">parent</a><span>|</span><a href="#39974053">next</a><span>|</span><label class="collapse" for="c-39974338">[-]</label><label class="expand" for="c-39974338">[1 more]</label></div><br/><div class="children"><div class="content">I have, on multiple occasions. Unfortunately mostly on contracting gigs so I can&#x27;t cite specifics but I&#x27;ve worked on a major ecommerce platform&#x27;s api, and two separate databases using this approach.<p>For public examples, I&#x27;d point you to (e.g.) Jepsen.<p>I&#x27;m not going to deny it requires a pretty high level of time&#x2F;money to implement. But done well it&#x27;s super powerful.</div><br/></div></div></div></div></div></div><div id="39974053" class="c"><input type="checkbox" id="c-39974053" checked=""/><div class="controls bullet"><span class="by">sealeck</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974031">prev</a><span>|</span><a href="#39974319">next</a><span>|</span><label class="collapse" for="c-39974053">[-]</label><label class="expand" for="c-39974053">[1 more]</label></div><br/><div class="children"><div class="content">I think if you evolve your testing system to feed random numbers into your program and ensure that various correctness properties hold for all these random inputs you are likely to get a pretty robust program. You can make this slightly efficient by using a fuzzer (essentially uses feedback from running previous inputs to see how running new inputs works). See for example <a href="https:&#x2F;&#x2F;propertesting.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;propertesting.com&#x2F;</a> or <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;American_Fuzzy_Lop_(software)" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;American_Fuzzy_Lop_(software)</a><p>Of course if you need a higher standard of guarantee you can try model checking or other formal verification techniques.</div><br/></div></div><div id="39974319" class="c"><input type="checkbox" id="c-39974319" checked=""/><div class="controls bullet"><span class="by">agumonkey</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974053">prev</a><span>|</span><a href="#39974249">next</a><span>|</span><label class="collapse" for="c-39974319">[-]</label><label class="expand" for="c-39974319">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;re both right. TDD is no panacea, and having no test is being blind. There&#x27;s a black art into estimating what angles to test and how deep to avoid calcification.</div><br/><div id="39976899" class="c"><input type="checkbox" id="c-39976899" checked=""/><div class="controls bullet"><span class="by">randomdata</span><span>|</span><a href="#39973918">root</a><span>|</span><a href="#39974319">parent</a><span>|</span><a href="#39974249">next</a><span>|</span><label class="collapse" for="c-39976899">[-]</label><label class="expand" for="c-39976899">[1 more]</label></div><br/><div class="children"><div class="content"><i>&gt; There&#x27;s a black art into estimating what angles to test and how deep to avoid calcification.</i><p>There may be a black art to recognizing what you overlooked, but otherwise it is pretty straightforward. Tests are your documentation. The angles needed to be covered are exactly what the user needs to know to use your software – how to use it and, when using it, what happens both in the expected case and when failure occurs (especially what happens when failure occurs!).<p>Calcification is of little concern as the inverse is breaking changes, and the user does not want to deal with your breaking changes. You can put your mind at ease knowing that once you commit to a documented feature, it should remain there until the end of time.</div><br/></div></div></div></div><div id="39974249" class="c"><input type="checkbox" id="c-39974249" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974319">prev</a><span>|</span><a href="#39974369">next</a><span>|</span><label class="collapse" for="c-39974249">[-]</label><label class="expand" for="c-39974249">[1 more]</label></div><br/><div class="children"><div class="content">I’ve experienced it.<p>But only at companies that don’t give a shit about test coverage %. The percent kills the purpose of the tests, which is certainty.</div><br/></div></div><div id="39974369" class="c"><input type="checkbox" id="c-39974369" checked=""/><div class="controls bullet"><span class="by">elliottkember</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974249">prev</a><span>|</span><a href="#39974149">next</a><span>|</span><label class="collapse" for="c-39974369">[-]</label><label class="expand" for="c-39974369">[1 more]</label></div><br/><div class="children"><div class="content">I think you missed a word. &quot;Good&quot; tests is a crucial part of the statement. It&#x27;s totally possible to write bad tests, the same way it&#x27;s possible to write bad code.</div><br/></div></div><div id="39974149" class="c"><input type="checkbox" id="c-39974149" checked=""/><div class="controls bullet"><span class="by">barfard</span><span>|</span><a href="#39973918">parent</a><span>|</span><a href="#39974369">prev</a><span>|</span><a href="#39975173">next</a><span>|</span><label class="collapse" for="c-39974149">[-]</label><label class="expand" for="c-39974149">[1 more]</label></div><br/><div class="children"><div class="content">could still get 99% test coverage with useless tests</div><br/></div></div></div></div><div id="39975173" class="c"><input type="checkbox" id="c-39975173" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#39973918">prev</a><span>|</span><a href="#39975786">next</a><span>|</span><label class="collapse" for="c-39975173">[-]</label><label class="expand" for="c-39975173">[1 more]</label></div><br/><div class="children"><div class="content">The proper way to fear in programming is to fear:<p>1. Your input will be incorrect&#x2F;corrupt&#x2F;malicious. Sanitize the crap out of your input. Think of every possible way your parser could go off the rails and fail.<p>2. Your code will hit pathologically slow cases. Thread the needle between the overly complicated but linear thing and the simplistic but straightforward to implement, debug and test O(nlogn) thing.<p>3. Your code will fail in production in a way that is hard to debug. Put in logging, monitoring, and dashboards. Check them. Alert on them.<p>4. You&#x27;ll have to debug your code. Put in tracing modes, use good names, divide things up to separately debug them.<p>5. You&#x27;ll have to explain your code. Make it easier to understand for future, drunk, or stupid you.</div><br/></div></div><div id="39975786" class="c"><input type="checkbox" id="c-39975786" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#39975173">prev</a><span>|</span><a href="#39977026">next</a><span>|</span><label class="collapse" for="c-39975786">[-]</label><label class="expand" for="c-39975786">[1 more]</label></div><br/><div class="children"><div class="content">Fear <i>also</i> makes you a better programmer: people these days are way too willing to take on cavalier amounts of risk and then offload deciding whether it worked or not onto others in code review, onto a stifling number of unit tests, and even--most frustratingly--onto the ability to scope or roll back changes before they affect &quot;too many&quot; users. The reality is that the number of people whose photo library or <i>bank account</i>--or even merely whose birthday party--it is &quot;acceptable&quot; to ruin is 0, not a supposedly-negligible 0.0001% of your billion users :(... that&#x27;s a <i>thousand</i> people whose lives you have affected, and at least they deserve some kind of personal apology from the engineers who failed them! My entire job and most of the money I have made in my life is following behind &quot;fearless&quot; programmers and picking up after them: tearing open holes, protecting user funds, and even winning a (giant) bug bounty from a company that trusted their tests too much and leaned heavily into &quot;move fast and break things&quot; :&#x2F;. You should have courage to stand up to fear, but you should never discard it or think you have somehow outsmarted it: that fear is your best defense from hubris and it also shows you have empathy for those who rely on the correctness of your work.</div><br/></div></div><div id="39977026" class="c"><input type="checkbox" id="c-39977026" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#39975786">prev</a><span>|</span><a href="#39976420">next</a><span>|</span><label class="collapse" for="c-39977026">[-]</label><label class="expand" for="c-39977026">[2 more]</label></div><br/><div class="children"><div class="content">No, Fear (within bounds) is very much a necessity for a good programmer. It makes him&#x2F;her think hard before doing anything. As the saying goes; &quot;there is a fine line between bravery and stupidity&quot;. There is nothing worse than some smart-aleck programmer being all gung-ho and willy-nilly refactoring&#x2F;rewriting code as they see fit when they don&#x27;t understand the complete system yet. Only if the entire system design can be held in your head (possible if you were part of the original design team and stayed with the product through its evolution) can you afford to be truly &quot;Fearless&quot;.</div><br/><div id="39977074" class="c"><input type="checkbox" id="c-39977074" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#39977026">parent</a><span>|</span><a href="#39976420">next</a><span>|</span><label class="collapse" for="c-39977074">[-]</label><label class="expand" for="c-39977074">[1 more]</label></div><br/><div class="children"><div class="content">Especially true if you are going to be touching prod. Part of being a junior I think is hearing a few horror stories, hopefully enough to make you stop and think before pressing enter on that rm command.</div><br/></div></div></div></div><div id="39976420" class="c"><input type="checkbox" id="c-39976420" checked=""/><div class="controls bullet"><span class="by">hiAndrewQuinn</span><span>|</span><a href="#39977026">prev</a><span>|</span><a href="#39973863">next</a><span>|</span><label class="collapse" for="c-39976420">[-]</label><label class="expand" for="c-39976420">[1 more]</label></div><br/><div class="children"><div class="content">I wouldn&#x27;t say I have no fear reflex at all, but I&#x27;ve definitely noticed I have far less of it than is average in this industry. My reasoning is that, even if what I try fails utterly, I myself probably learned a lot trying to pull it off, and since my aim has always been to maximize mechanical sympathy, that&#x27;s hard to write off as an unmitigated loss.</div><br/></div></div><div id="39973863" class="c"><input type="checkbox" id="c-39973863" checked=""/><div class="controls bullet"><span class="by">atomicnumber3</span><span>|</span><a href="#39976420">prev</a><span>|</span><a href="#39976617">next</a><span>|</span><label class="collapse" for="c-39973863">[-]</label><label class="expand" for="c-39973863">[3 more]</label></div><br/><div class="children"><div class="content">At an org I worked at, we (the whole org) were notorious (internally) for just not being able to execute big projects. In late 2022 2 of the top-level big priority initiatives got &quot;pivoted&quot; (eyeroll) because they just weren&#x27;t &quot;going&quot;. And allegedly a big part of the problem was that nobody wanted to admit that things weren&#x27;t going just swell on these big projects, so they gussied up their status reports, and then when this was done systemically across every person in the entire project, you got a project that looked real good until it mysteriously missed deadlines, and after enough of that, finally the curtain pulls back.<p>Now, management and leadership were most affronted by the state of affairs, I assure you, and many words were spent extolling virtues and lambasting vices and sin. But let me assure you, it&#x27;s not that they love eloquent speech, they were simply not allowed to say the real reason for any of it because the real reason was a trait of the org that the founder thought was a key to their success.<p>They run a meritocracy, you see, and a pay for performance comp philosophy. They run performance reviews very tight, and getting a passing mark is publicly said to be something to be proud of. The natural result being that everyone lives in constant fear, and being put on a big risky project is a great way to not get to vest your whole equity grant. So everyone plays defensively, the smartest people dodge the hard&#x2F;big projects, and so on and so on.<p>And they&#x27;ll never fix it because they are not allowed to. How tragic.</div><br/><div id="39974775" class="c"><input type="checkbox" id="c-39974775" checked=""/><div class="controls bullet"><span class="by">epolanski</span><span>|</span><a href="#39973863">parent</a><span>|</span><a href="#39974237">next</a><span>|</span><label class="collapse" for="c-39974775">[-]</label><label class="expand" for="c-39974775">[1 more]</label></div><br/><div class="children"><div class="content">The organization has the worst of two worlds:<p>- metrics gamification<p>- wrong incentives</div><br/></div></div><div id="39974237" class="c"><input type="checkbox" id="c-39974237" checked=""/><div class="controls bullet"><span class="by">nomel</span><span>|</span><a href="#39973863">parent</a><span>|</span><a href="#39974775">prev</a><span>|</span><a href="#39976617">next</a><span>|</span><label class="collapse" for="c-39974237">[-]</label><label class="expand" for="c-39974237">[1 more]</label></div><br/><div class="children"><div class="content">It seems the issue is the metric used for performance is incorrect, along with the compensation for the hard&#x2F;big projects.</div><br/></div></div></div></div><div id="39976617" class="c"><input type="checkbox" id="c-39976617" checked=""/><div class="controls bullet"><span class="by">spintin</span><span>|</span><a href="#39973863">prev</a><span>|</span><a href="#39974095">next</a><span>|</span><label class="collapse" for="c-39976617">[-]</label><label class="expand" for="c-39976617">[1 more]</label></div><br/><div class="children"><div class="content">As with all tools the goal is to be able to use the tool without fear.<p>Remember the first weeks of coding C? It took me 4 years to not get cold sweat just thinking about using it when the compiler didn&#x27;t inform you about a typo and you have to rollback the code all the time to fix problems and learn assembly (in X86, ARM and now Risc-V).<p>And that was without deadlines or any delivery pressure.<p>Today I realize C is for mad people, but I learned to respect the thing while no longer being afraid to use it in a real scenario.</div><br/></div></div><div id="39974095" class="c"><input type="checkbox" id="c-39974095" checked=""/><div class="controls bullet"><span class="by">Attummm</span><span>|</span><a href="#39976617">prev</a><span>|</span><a href="#39975961">next</a><span>|</span><label class="collapse" for="c-39974095">[-]</label><label class="expand" for="c-39974095">[1 more]</label></div><br/><div class="children"><div class="content">In my experience, fear serves as a double-edged sword in software development. While it can inhibit us from making necessary changes, it also acts as a powerful motivator. The fear of introducing new bugs drives us to conduct thorough testing and think critically about our code. Moreover, the fear of burdening others or causing system outages reinforces the importance of careful consideration and caution<p>The article reminded me of the military&#x27;s emphasis on maintaining a healthy level of fear to prevent complacency.<p>When working on new projects, there&#x27;s room for bold moves and experimentation.
However, in existing large-scale systems, the impact of our actions extends beyond ourselves to the entire team and company. Let&#x27;s avoid cowboy coding and prioritize stability and reliability.</div><br/></div></div><div id="39975961" class="c"><input type="checkbox" id="c-39975961" checked=""/><div class="controls bullet"><span class="by">throwiforgtnlzy</span><span>|</span><a href="#39974095">prev</a><span>|</span><a href="#39974344">next</a><span>|</span><label class="collapse" for="c-39975961">[-]</label><label class="expand" for="c-39975961">[1 more]</label></div><br/><div class="children"><div class="content">While some languages are safe or safer now, the concerns of correctness and robustness are not solvable by unit testing or code coverage alone. Other holistic layers of smoke testing, property testing&#x2F;fuzzing, integration testing, and user acceptance testing (UAT) must be included. Robustness means making the code defensible and easy to understand, test, refactor, and modify.<p>Where there is most deafening silence in the area of proving correctness of the codebase and of the resulting binaries. seL4, klee, fp, and coq ran in the right direction with this in some aspects, formal verification still hasn&#x27;t become a standard practice because the level of effort is still costly and tools to accomplish this aren&#x27;t readily available.</div><br/></div></div><div id="39974344" class="c"><input type="checkbox" id="c-39974344" checked=""/><div class="controls bullet"><span class="by">DustinBrett</span><span>|</span><a href="#39975961">prev</a><span>|</span><a href="#39974171">next</a><span>|</span><label class="collapse" for="c-39974344">[-]</label><label class="expand" for="c-39974344">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard it&#x27;s even the mind killer.</div><br/></div></div><div id="39974171" class="c"><input type="checkbox" id="c-39974171" checked=""/><div class="controls bullet"><span class="by">kevmo314</span><span>|</span><a href="#39974344">prev</a><span>|</span><a href="#39974222">next</a><span>|</span><label class="collapse" for="c-39974171">[-]</label><label class="expand" for="c-39974171">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you’re scared of making changes, you can’t make something dramatically better, or do that big code cleanup.<p>Funny, reading the headline I thought the article was going to be about the polar opposite. Over time, I&#x27;ve found the headline to be absolutely true, but I have also found that many invest in tooling and overabundant testing out of fear.<p>eg, &quot;What if we need to recreate our entire stack from absolute scratch?&quot;<p>I mean yeah, from that perspective terraform is totally useful, but what&#x27;s next, automate the entire creation of the company, including customer acquisition and hiring? How often do you really need to recreate everything from scratch?<p>As a more junior engineer I used to have the confidence that things just wouldn&#x27;t break, or at least if they broke it wouldn&#x27;t be such a big deal. More often than not I was right. As a senior engineer, I find myself just pushing my junior engineer tenets. Usually everything will be fine, and even if it does break, we can fix it.<p>Write tests and invest in tooling if they&#x27;re helpful. If they&#x27;re not, don&#x27;t be afraid to just write code by ssh&#x27;ing into a server.</div><br/></div></div><div id="39974458" class="c"><input type="checkbox" id="c-39974458" checked=""/><div class="controls bullet"><span class="by">ketanmaheshwari</span><span>|</span><a href="#39974222">prev</a><span>|</span><a href="#39974309">next</a><span>|</span><label class="collapse" for="c-39974458">[-]</label><label class="expand" for="c-39974458">[1 more]</label></div><br/><div class="children"><div class="content">I think 2014 should be added to the title.</div><br/></div></div><div id="39974309" class="c"><input type="checkbox" id="c-39974309" checked=""/><div class="controls bullet"><span class="by">kevingadd</span><span>|</span><a href="#39974458">prev</a><span>|</span><a href="#39974295">next</a><span>|</span><label class="collapse" for="c-39974309">[-]</label><label class="expand" for="c-39974309">[1 more]</label></div><br/><div class="children"><div class="content">A fear not mentioned directly in this post that definitely makes you a worse programmer is fear of (perceived) individual failure. I&#x27;ve dealt with (usually junior, but not always) programmers who shied away from difficult tasks or complex parts of a codebase. It seemed like they were afraid of failing and being seen failing, and preferred to select tasks they knew they could handle. A natural outcome of this is that you end up with big important parts of your codebase that are only understood by a handful of people, because they&#x27;re scary. The fact that we had tons of automated tests didn&#x27;t fix this.<p>You can partly address this by trying to make sure every part of your codebase is easy to understand, but sometimes your code is just going to be complex. That becomes an education problem, you have to work with these developers and coax them into confronting difficult chunks of code and help them develop the skills they need for understanding.<p>The same applies for development&#x2F;debugging techniques. I walked one developer of equal seniority through using WinDbg once, because javascript he wrote was causing IE6 to crash. It was <i>my</i> first time doing it, so the role I had to play was the &quot;let&#x27;s just try things and see if we can get anywhere, there&#x27;s no harm in failing&quot; facilitator. Better to try something new than to give up. We didn&#x27;t come away from the exercise with clear answers, but we had learned some useful information in the process by exploring.</div><br/></div></div><div id="39974295" class="c"><input type="checkbox" id="c-39974295" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#39974309">prev</a><span>|</span><a href="#39976674">next</a><span>|</span><label class="collapse" for="c-39974295">[-]</label><label class="expand" for="c-39974295">[4 more]</label></div><br/><div class="children"><div class="content">The Rust community, ecosystem and its advocacy and advancement depend critically on fear.</div><br/><div id="39975290" class="c"><input type="checkbox" id="c-39975290" checked=""/><div class="controls bullet"><span class="by">Aeolun</span><span>|</span><a href="#39974295">parent</a><span>|</span><a href="#39976674">next</a><span>|</span><label class="collapse" for="c-39975290">[-]</label><label class="expand" for="c-39975290">[3 more]</label></div><br/><div class="children"><div class="content">Or maybe it’s just more pleasant to write than C?</div><br/><div id="39976060" class="c"><input type="checkbox" id="c-39976060" checked=""/><div class="controls bullet"><span class="by">bitwize</span><span>|</span><a href="#39974295">root</a><span>|</span><a href="#39975290">parent</a><span>|</span><a href="#39976674">next</a><span>|</span><label class="collapse" for="c-39976060">[-]</label><label class="expand" for="c-39976060">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s more pleasant to write than C because Rust <i>removes</i> fear.</div><br/></div></div></div></div></div></div><div id="39976674" class="c"><input type="checkbox" id="c-39976674" checked=""/><div class="controls bullet"><span class="by">jaimex2</span><span>|</span><a href="#39974295">prev</a><span>|</span><a href="#39974441">next</a><span>|</span><label class="collapse" for="c-39976674">[-]</label><label class="expand" for="c-39976674">[2 more]</label></div><br/><div class="children"><div class="content">I loved Julia&#x27;s blogs as a young dev, they were like watching Star Trek TNG episodes. All hope and naive solutions. I remember reading this one especially back then.<p>Then you learn the tests are a monster stack themselves, often taking more effort than the actual features they are guarding.<p>Then you are part of one of these &#x27;blameless postmortems&#x27; and realise everyone has an opinion and there are now 80 outcome actions, half of them complete horse shit but they are high priority now and jammed into your sprints for the next 6 weeks.</div><br/><div id="39977079" class="c"><input type="checkbox" id="c-39977079" checked=""/><div class="controls bullet"><span class="by">rramadass</span><span>|</span><a href="#39976674">parent</a><span>|</span><a href="#39974441">next</a><span>|</span><label class="collapse" for="c-39977079">[-]</label><label class="expand" for="c-39977079">[1 more]</label></div><br/><div class="children"><div class="content">&gt; All hope and naive solutions.<p>Funny, but quite true.</div><br/></div></div></div></div><div id="39974441" class="c"><input type="checkbox" id="c-39974441" checked=""/><div class="controls bullet"><span class="by">jt2190</span><span>|</span><a href="#39976674">prev</a><span>|</span><a href="#39974652">next</a><span>|</span><label class="collapse" for="c-39974441">[-]</label><label class="expand" for="c-39974441">[1 more]</label></div><br/><div class="children"><div class="content">(2014)</div><br/></div></div></div></div></div></div></div></body></html>