<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715850055887" as="style"/><link rel="stylesheet" href="styles.css?v=1715850055887"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://rachelbythebay.com/w/2024/05/15/ro/">SSD death, tricky read-only filesystems, and systemd magic?</a> <span class="domain">(<a href="https://rachelbythebay.com">rachelbythebay.com</a>)</span></div><div class="subtext"><span>ingve</span> | <span>59 comments</span></div><br/><div><div id="40373302" class="c"><input type="checkbox" id="c-40373302" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#40373866">next</a><span>|</span><label class="collapse" for="c-40373302">[-]</label><label class="expand" for="c-40373302">[26 more]</label></div><br/><div class="children"><div class="content">I know they mean well, but if you have a filesystem you want to preserve on questionable media... don&#x27;t interact with <i>(mount&#x2F;repair)</i> it until you&#x27;ve made your copy.<p>With journaling and the like <i>(soft-RAID)</i>... mounting <i>at all</i> can induce more writes than you expect; yes, even read-only. That&#x27;s probably not what you want. Consistency is key.<p>&#x27;Just&#x27; <i>(I know)</i> use <i>&quot;dd&quot;</i>, <i>&quot;ddrescue&quot;</i>, or simply <i>pv&#x2F;cat&#x2F;shell</i> in+out redirects <i>(some limitations apply)</i> to evacuate it first. This gets you two things:<p><pre><code>    1) infinite tries: files&#x2F;loop devices are cheap and can be copied for free
    2) better odds: the new home isn&#x27;t questionable, right?
</code></pre>
Stop thinking in terms of devices. You can write this drive to a file. You can write files to drives. Same for reading&#x2F;checksums. It&#x27;s all made up, yet it works. Magic.<p>By skipping past the block level to the filesystem, one is limited in what they can recover. You&#x27;re at the mercy of it being more sane than truly necessary.<p>By mounting it, and potentially&#x2F;indirectly writing <i>[with bad media&#x2F;connectors&#x2F;whatever]</i>, you may be irrevocably breaking the filesystem.<p>Perhaps they get into this, but <i>wow.</i> I know I&#x27;m not <i>&#x27;The One&#x27;</i>. I hate to pretend to be; but this is day one data-preservation stuff. I&#x27;m almost certain we&#x27;ve all taken compliance training that covers this.<p>Cutting corners like this is pretending to be The One; you don&#x27;t know better. Nobody is perfect, I&#x27;m on my soap box because I&#x27;ve done the same thing - and want to save others. It hurts.<p>I had to post when I got to <i>&quot;LOL it went RO, it&#x27;s probably fine&quot; (my words)</i>... when no, the kernel interjecting to protect the data is <i>not</i> a reasonable first line of defense.<p>Aside from what they chose to do... damage well-and-truly could already be done by their <i>inaction</i>. Having left it running&#x2F;hoping for re-allocation.<p>I <i>wish</i> I could have as much faith as they&#x27;ve shown in what little I&#x27;ve read so far. I close my rant with this: a little mechanical sympathy goes a long way. Now back to reading.</div><br/><div id="40374483" class="c"><input type="checkbox" id="c-40374483" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#40373302">parent</a><span>|</span><a href="#40376129">next</a><span>|</span><label class="collapse" for="c-40374483">[-]</label><label class="expand" for="c-40374483">[4 more]</label></div><br/><div class="children"><div class="content">I can&#x27;t edit now... but one thing I&#x27;d like to change - it&#x27;s not fair to call this their first line of defense.<p>Rachel did the most important thing right: taking backups at the first sign of trouble, presumably beforehand too.<p>I just feel they&#x27;re off the mark foregoing block devices and having a strange process as a result... <i>&quot;because images are big&quot;</i>. Speeding up doesn&#x27;t normally quiet a squeaky wheel. Not to say it can&#x27;t... but let&#x27;s place bets :)<p>There are options for this concern without compromising the efficacy of the whole process; for example, <i>{de,}</i>compression.<p>Yes, you care about the files, but to recover them... you don&#x27;t get to ignore the details of the filesystem - or the constraints you&#x27;re allowing it <i>(and yourself)</i> to operate under.<p>The takeaway from this isn&#x27;t <i>&quot;substitute well-established recovery processes...&quot;</i> but, make sure you have backups so you can afford two perks:<p><pre><code>    * ignore a failing drive for weeks
    * not care *at all* about your attempts to recover the source filesystem
</code></pre>
The filesystem, your storage, <i>everything</i> will lie.<p>Prepare for it; make copies and accept this will take time. This chestnut still applies: <i>&quot;If you don&#x27;t have time to do it right, you must have time to do it again.&quot;</i><p>The recovery or your data?</div><br/><div id="40375123" class="c"><input type="checkbox" id="c-40375123" checked=""/><div class="controls bullet"><span class="by">oceanplexian</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40374483">parent</a><span>|</span><a href="#40376129">next</a><span>|</span><label class="collapse" for="c-40375123">[-]</label><label class="expand" for="c-40375123">[3 more]</label></div><br/><div class="children"><div class="content">The right thing is not storing data on a single 2.5 consumer SSD because the endurance on those devices are trash and the fail at super high rates.<p>They aren’t designed for a linux server, they’re designed for a disposable Windows laptop that will be chucked in the bin after a year or two. I’ve learned this lesson the hard way over, and over, and over again with these little cheap SSDs.</div><br/><div id="40375561" class="c"><input type="checkbox" id="c-40375561" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40375123">parent</a><span>|</span><a href="#40376191">next</a><span>|</span><label class="collapse" for="c-40375561">[-]</label><label class="expand" for="c-40375561">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The right thing is not storing data on a single 2.5 consumer SSD because the endurance on those devices are trash and the fail at super high rates.<p>What do you mean by &quot;endurance&quot;?<p>The only definition I found was the number of writes during the warranty time, and you&#x27;re talking about a use case involving a very low volume of writes (i.e., save a file, keep it up for eternity).<p>This means that warranty time (more specifically, any failure mode at all beyond excess writes) is the most likely failure mode. Not writes, just the SSD being old.<p>Samsung advertises between 3 years and 10 years of warranty. The typical warranty of HDDs is between 3 and 5 years. Doesn&#x27;t this suggest that buying you a decent SSD buys you at worst the same reliability?<p><a href="https:&#x2F;&#x2F;semiconductor.samsung.com&#x2F;consumer-storage&#x2F;support&#x2F;warranty&#x2F;" rel="nofollow">https:&#x2F;&#x2F;semiconductor.samsung.com&#x2F;consumer-storage&#x2F;support&#x2F;w...</a></div><br/></div></div><div id="40376191" class="c"><input type="checkbox" id="c-40376191" checked=""/><div class="controls bullet"><span class="by">numpad0</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40375123">parent</a><span>|</span><a href="#40375561">prev</a><span>|</span><a href="#40376129">next</a><span>|</span><label class="collapse" for="c-40376191">[-]</label><label class="expand" for="c-40376191">[1 more]</label></div><br/><div class="children"><div class="content">Most consumer 1TB SSDs with 600TBW should last at least within 10% or so of 600 days at 1 DWPD. If your ZQQTIAN or KingDonxi Amazon specials, populated with Micron QA rejects or SpecTek super economy grade or random e-waste upcycling chips failed in a month, that&#x27;s on you.</div><br/></div></div></div></div></div></div><div id="40376129" class="c"><input type="checkbox" id="c-40376129" checked=""/><div class="controls bullet"><span class="by">guenthert</span><span>|</span><a href="#40373302">parent</a><span>|</span><a href="#40374483">prev</a><span>|</span><a href="#40373501">next</a><span>|</span><label class="collapse" for="c-40376129">[-]</label><label class="expand" for="c-40376129">[2 more]</label></div><br/><div class="children"><div class="content">Dunno, man.  It&#x27;s an old Mac-mini, single disk (the SSD is explicitly called out) fairly obviously used for private stuff.  You can wring it.<p>In a production environment you cut you losses and restore from back-up.  No-one wants to deal with half-baked recovery operations which might or might not yield a consistent state with (a little) less, but unknown, data loss.</div><br/><div id="40376400" class="c"><input type="checkbox" id="c-40376400" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40376129">parent</a><span>|</span><a href="#40373501">next</a><span>|</span><label class="collapse" for="c-40376400">[-]</label><label class="expand" for="c-40376400">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not lost on me that this is a low stakes situation, they had backups and could afford being artful in their process.<p>That&#x27;s what makes this wheel-spinning so confounding.</div><br/></div></div></div></div><div id="40373501" class="c"><input type="checkbox" id="c-40373501" checked=""/><div class="controls bullet"><span class="by">hun3</span><span>|</span><a href="#40373302">parent</a><span>|</span><a href="#40376129">prev</a><span>|</span><a href="#40374366">next</a><span>|</span><label class="collapse" for="c-40373501">[-]</label><label class="expand" for="c-40373501">[1 more]</label></div><br/><div class="children"><div class="content">Right, you need at least some dm-linear device mapper device in between to ensure a device is RO I think. Also, ext4 has separate &quot;noload&quot; option that <i>actually</i> instructs it not to touch the disk (ofc relying solely on &quot;ro,noload&quot; to not mess with your broken FS is a bad idea)</div><br/></div></div><div id="40373451" class="c"><input type="checkbox" id="c-40373451" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40373302">parent</a><span>|</span><a href="#40374366">prev</a><span>|</span><a href="#40374008">next</a><span>|</span><label class="collapse" for="c-40373451">[-]</label><label class="expand" for="c-40373451">[6 more]</label></div><br/><div class="children"><div class="content">&gt; mounting read only can induce more writes than you expect.<p>Have you got a source for that? I can only find speculation on various sites, but nothing that explicitly confirms that outstanding journal entries would be written at RO mount time.</div><br/><div id="40373506" class="c"><input type="checkbox" id="c-40373506" checked=""/><div class="controls bullet"><span class="by">mrob</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373451">parent</a><span>|</span><a href="#40373468">next</a><span>|</span><label class="collapse" for="c-40373506">[-]</label><label class="expand" for="c-40373506">[2 more]</label></div><br/><div class="children"><div class="content">From the util-linux &quot;mount&quot; man page:<p>&quot;Note that, depending on the filesystem type, state and kernel behavior, the system may still write to the device. For example, ext3 and ext4 will replay the journal if the filesystem is dirty. To prevent this kind of write access, you may want to mount an ext3 or ext4 filesystem with the ro,noload mount options or set the block device itself to read-only mode, see the blockdev(8) command.&quot;</div><br/><div id="40373549" class="c"><input type="checkbox" id="c-40373549" checked=""/><div class="controls bullet"><span class="by">viraptor</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373506">parent</a><span>|</span><a href="#40373468">next</a><span>|</span><label class="collapse" for="c-40373549">[-]</label><label class="expand" for="c-40373549">[1 more]</label></div><br/><div class="children"><div class="content">This seems to be the relevant behaviour from ext4: <a href="https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;8c06da67d0bd3139a97f301b4aa9c482b9d4f29e&#x2F;fs&#x2F;ext4&#x2F;super.c#L6019">https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&#x2F;blob&#x2F;8c06da67d0bd3139a97f3...</a></div><br/></div></div></div></div><div id="40373468" class="c"><input type="checkbox" id="c-40373468" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373451">parent</a><span>|</span><a href="#40373506">prev</a><span>|</span><a href="#40375782">next</a><span>|</span><label class="collapse" for="c-40373468">[-]</label><label class="expand" for="c-40373468">[2 more]</label></div><br/><div class="children"><div class="content">Nothing readily available, can I be a source?<p>The remaining nugget&#x2F;memory on this I have is a fairly open ended... <i>&quot;it depends [on the filesystem]&quot;</i>. It&#x27;s been a while since I dove into this earnestly.<p>IIRC there&#x27;s no single journal mechanism - they all choose to do it <i>(or not)</i> in their own way.<p>Journaling was just one example, too.<p>Let&#x27;s not ignore other quirks, like how BTRFS conflates volume&#x2F;filesystem management... and may exhibit behavior impossible with XFS&#x2F;ext{2,3,4} <i>[under N failure conditions]</i> WRT soft-RAID.<p>By not mounting it, you&#x27;re avoiding the <i>&quot;kernel&#x2F;software filter&quot;</i> that adds entropy to an already-rich process.<p>Side note: you caught me in a series of edits for phrasing :D</div><br/></div></div><div id="40375782" class="c"><input type="checkbox" id="c-40375782" checked=""/><div class="controls bullet"><span class="by">tryauuum</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373451">parent</a><span>|</span><a href="#40373468">prev</a><span>|</span><a href="#40374008">next</a><span>|</span><label class="collapse" for="c-40375782">[-]</label><label class="expand" for="c-40375782">[1 more]</label></div><br/><div class="children"><div class="content">ext4 read only mount can still replay journal, see the &quot;noload&quot; mount option</div><br/></div></div></div></div><div id="40374008" class="c"><input type="checkbox" id="c-40374008" checked=""/><div class="controls bullet"><span class="by">_wire_</span><span>|</span><a href="#40373302">parent</a><span>|</span><a href="#40373451">prev</a><span>|</span><a href="#40373813">next</a><span>|</span><label class="collapse" for="c-40374008">[-]</label><label class="expand" for="c-40374008">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I know they mean well, but if you have a filesystem you want to preserve on questionable media... don&#x27;t interact with (mount) it until you&#x27;ve made your copy.<p>A further clarification of your point...<p>If you are a wearing a forensics hat and engaged in formal recovery effort, your point is significant good advice.<p>But when you are a regular joe trying to deal with a failing device, it&#x27;s usually not clear when you&#x27;ve put on the forensics hat; you just find yourself struggling with a device that is not returning your data.<p>And while you are in this moment of discovery the failure mode, the system is trying to do all its normal stuff, including maintaining the journal.<p>So if playing the journal is a hazard to your data, it has likely already been encountered and any corruption as a result of journal processing been done.<p>At some point the regular joe may decide to put on the forensic hat and formally rescue the device.<p>In my experience, this is not necessarily the most productive next step. It depends on the device, its failure mode, the data and the usage scenario. Too many variables to generalize about tactics.<p>No matter the value of your data, it&#x27;s wise to begin a disciplined recovery as soon as possible. Where backups are the best place to start any recovery effort.<p>However, once you decide to rescue the device — as opposed to nurse it along to gain access to something — that&#x27;s the clear threshold to become scrupulous about read-only access: It&#x27;s important to keep both the source and the destination devices in a read-only state from the beginning to end of the rescue to avoid further corruption of the copy.<p>In this light, any journal processing that occurs for read-only mounts, presents a possibility hazardous condition with implications beyond the scope of casual system operation. This is the province of a proper forensics regime, with a rescue system configuration and protocol designed to prevent tainting the target, and also beyond the scope of a user comments on a help thread.<p>Given all the other uncertainties, getting to the bottom of what a read-only mount actually does with the journal on your system at hand is probably not productive. But arranging for read-only mounts is given the uncertainty is certainly productive, so prevent auto-mounts while rescuing.<p>If you want to use GNU ddescue,
I&#x27;ve written a bash script to help with preventing auto-mount for Linux and macOS.<p>github @c-o-pr ddrescue-helper<p>Basically the script just writes &#x2F;etc&#x2F;fstab with the UUID of the filesystem and &quot;noauto&quot; option and unmounts the device. But there&#x27;s other logic in the script that may be useful.</div><br/></div></div><div id="40373813" class="c"><input type="checkbox" id="c-40373813" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#40373302">parent</a><span>|</span><a href="#40374008">prev</a><span>|</span><a href="#40373866">next</a><span>|</span><label class="collapse" for="c-40373813">[-]</label><label class="expand" for="c-40373813">[10 more]</label></div><br/><div class="children"><div class="content">There&#x27;s nothing special about dd. You can, and should, simply use `cp`</div><br/><div id="40373852" class="c"><input type="checkbox" id="c-40373852" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373813">parent</a><span>|</span><a href="#40373845">next</a><span>|</span><label class="collapse" for="c-40373852">[-]</label><label class="expand" for="c-40373852">[1 more]</label></div><br/><div class="children"><div class="content">There is, however, something special about `ddrescue` (note that there are 2 different projects named thus; I don&#x27;t remember the difference) - it does all the okay sectors, then goes back and retries bad sectors.<p>Just be sure to store the ddrescue state file somewhere persistent.</div><br/></div></div><div id="40373845" class="c"><input type="checkbox" id="c-40373845" checked=""/><div class="controls bullet"><span class="by">bravetraveler</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373813">parent</a><span>|</span><a href="#40373852">prev</a><span>|</span><a href="#40373856">next</a><span>|</span><label class="collapse" for="c-40373845">[-]</label><label class="expand" for="c-40373845">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the least important part about my post. I mentioned several things, one being the shell you probably already have running, that all will do a perfectly fine job - to hopefully demonstrate that.<p>&#x27;cp&#x27; is sparse aware. Yay. Is that a good thing, actually? If the source has zeroes, I want to write zeroes. Not sure... probably fine. I&#x27;ve been awake too long.<p><i>&#x27;ddrescue&#x27;</i> is special, but again, consistency is key. I don&#x27;t <i>really</i> care how it&#x27;s copied. I just question <i>&#x27;should&#x27;</i> - there are advantages elsewhere.<p>edit: My main gist is this - living off the land applies here, too! Whatever option is available. Make the copy, check the checksums. Pull out the bigger gun if necessary.<p>Never know when you have to rely on some binary that&#x27;s surviving only in caches. Stuck with a broken system and no live environment in sight.</div><br/></div></div><div id="40373856" class="c"><input type="checkbox" id="c-40373856" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373813">parent</a><span>|</span><a href="#40373845">prev</a><span>|</span><a href="#40373866">next</a><span>|</span><label class="collapse" for="c-40373856">[-]</label><label class="expand" for="c-40373856">[7 more]</label></div><br/><div class="children"><div class="content">Please show me how you cp a raw device without the concept of files. I’d love to learn.<p>$ cp &#x2F;dev&#x2F;nvme0n1p1 &#x2F;mnt&#x2F;my-special-backup<p>?</div><br/><div id="40375917" class="c"><input type="checkbox" id="c-40375917" checked=""/><div class="controls bullet"><span class="by">m463</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373856">parent</a><span>|</span><a href="#40374663">next</a><span>|</span><label class="collapse" for="c-40375917">[-]</label><label class="expand" for="c-40375917">[1 more]</label></div><br/><div class="children"><div class="content">dd can copy block by block from one block device to another<p>ddrescue can do the same, but will handle errors better<p>e2image understands ext2&#x2F;3&#x2F;4 filesystems and can copy only the blocks in use, which can really help (though don&#x27;t know how it works if it encounters an error)</div><br/></div></div><div id="40374663" class="c"><input type="checkbox" id="c-40374663" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373856">parent</a><span>|</span><a href="#40375917">prev</a><span>|</span><a href="#40373938">next</a><span>|</span><label class="collapse" for="c-40374663">[-]</label><label class="expand" for="c-40374663">[2 more]</label></div><br/><div class="children"><div class="content">A device is a file. That&#x27;s the power and elegance of Unix-like systems.</div><br/><div id="40374715" class="c"><input type="checkbox" id="c-40374715" checked=""/><div class="controls bullet"><span class="by">immibis</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40374663">parent</a><span>|</span><a href="#40373938">next</a><span>|</span><label class="collapse" for="c-40374715">[-]</label><label class="expand" for="c-40374715">[1 more]</label></div><br/><div class="children"><div class="content">The correct abstraction is that a file is a device. A file is a section of a hard disk which behaves like a whole disk. It also happens to be expandable.<p>cp&#x27;s default behaviour for device files also happens to be very stupid.</div><br/></div></div></div></div><div id="40373938" class="c"><input type="checkbox" id="c-40373938" checked=""/><div class="controls bullet"><span class="by">jeffbee</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373856">parent</a><span>|</span><a href="#40374663">prev</a><span>|</span><a href="#40373866">next</a><span>|</span><label class="collapse" for="c-40373938">[-]</label><label class="expand" for="c-40373938">[3 more]</label></div><br/><div class="children"><div class="content">Yes</div><br/><div id="40374055" class="c"><input type="checkbox" id="c-40374055" checked=""/><div class="controls bullet"><span class="by">mrcode007</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40373938">parent</a><span>|</span><a href="#40373866">next</a><span>|</span><label class="collapse" for="c-40374055">[-]</label><label class="expand" for="c-40374055">[2 more]</label></div><br/><div class="children"><div class="content">Ha. Today I learned. Is this a portable approach across macOS, Linux and BSD family ?</div><br/><div id="40375638" class="c"><input type="checkbox" id="c-40375638" checked=""/><div class="controls bullet"><span class="by">chipdart</span><span>|</span><a href="#40373302">root</a><span>|</span><a href="#40374055">parent</a><span>|</span><a href="#40373866">next</a><span>|</span><label class="collapse" for="c-40375638">[-]</label><label class="expand" for="c-40375638">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is this a portable approach across macOS, Linux and BSD family ?<p>I think that feature relies in the concept of a device file, which is a direct reflection of the UNIX trait of everything being a file.<p><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Device_file" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Device_file</a></div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="40373866" class="c"><input type="checkbox" id="c-40373866" checked=""/><div class="controls bullet"><span class="by">snvzz</span><span>|</span><a href="#40373302">prev</a><span>|</span><a href="#40373891">next</a><span>|</span><label class="collapse" for="c-40373866">[-]</label><label class="expand" for="c-40373866">[4 more]</label></div><br/><div class="children"><div class="content">Consider rsync over tar.<p>rsync has the (important) advantage it can generally be stopped and resumed.<p>If the source drive&#x27;s actually failing, I would instead ddrescue asap, and work with the (make it a read-only file) image.<p>Should the filesystem need fsck, qemu-img can create a read-write image that is an overlay backed by a read-only file, and qemu-nbd can expose that through nbd, so that your kernel can use it.</div><br/><div id="40374273" class="c"><input type="checkbox" id="c-40374273" checked=""/><div class="controls bullet"><span class="by">throw0101c</span><span>|</span><a href="#40373866">parent</a><span>|</span><a href="#40374985">prev</a><span>|</span><a href="#40373891">next</a><span>|</span><label class="collapse" for="c-40374273">[-]</label><label class="expand" for="c-40374273">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Consider rsync over tar.</i><p>I forget the exact details now, but in the past I found that <i>cpio</i> was the best option at times.<p>It may have been circumstances when I didn&#x27;t want the entire tree, but rather files that met specific criteria, and I was able to combine <i>find</i> and <i>cpio</i> (<i>-o</i> option) together.</div><br/><div id="40375016" class="c"><input type="checkbox" id="c-40375016" checked=""/><div class="controls bullet"><span class="by">NewJazz</span><span>|</span><a href="#40373866">root</a><span>|</span><a href="#40374273">parent</a><span>|</span><a href="#40373891">next</a><span>|</span><label class="collapse" for="c-40375016">[-]</label><label class="expand" for="c-40375016">[1 more]</label></div><br/><div class="children"><div class="content">Rsync has a nice glob based inclusion and exclusion rule system.</div><br/></div></div></div></div></div></div><div id="40373891" class="c"><input type="checkbox" id="c-40373891" checked=""/><div class="controls bullet"><span class="by">userbinator</span><span>|</span><a href="#40373866">prev</a><span>|</span><a href="#40372971">next</a><span>|</span><label class="collapse" for="c-40373891">[-]</label><label class="expand" for="c-40373891">[1 more]</label></div><br/><div class="children"><div class="content">I assume the only reason for not turning off and taking the drive out to image &quot;offline&quot; is because SSDs have been known to permanently brick themselves when power-cycled, but I agree with the others here that trying to interact with the filesystem on a dying storage device is a <i>really</i> bad idea.<p>Incidentally, having experienced an SSD and HDD death within the past few months, the HDD definitely gave far more early warning signs (including some very audible ones) than the SSD, and failed in a &quot;softer&quot; fashion.</div><br/></div></div><div id="40372971" class="c"><input type="checkbox" id="c-40372971" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#40373891">prev</a><span>|</span><a href="#40373868">next</a><span>|</span><label class="collapse" for="c-40372971">[-]</label><label class="expand" for="c-40372971">[3 more]</label></div><br/><div class="children"><div class="content">journald also logs to &#x2F;run&#x2F;log&#x2F;journal&#x2F; (a tmpfs) so until reboot you can still extract logs from  it even if it didn&#x27;t manage to write them to disk. See the &#x27;storage&#x27; option in `man journald.conf`</div><br/><div id="40373276" class="c"><input type="checkbox" id="c-40373276" checked=""/><div class="controls bullet"><span class="by">drycabinet</span><span>|</span><a href="#40372971">parent</a><span>|</span><a href="#40373868">next</a><span>|</span><label class="collapse" for="c-40373276">[-]</label><label class="expand" for="c-40373276">[2 more]</label></div><br/><div class="children"><div class="content">That part of the man page sounds confusing. Is it unconditional and enabled by default?</div><br/><div id="40375927" class="c"><input type="checkbox" id="c-40375927" checked=""/><div class="controls bullet"><span class="by">zokier</span><span>|</span><a href="#40372971">root</a><span>|</span><a href="#40373276">parent</a><span>|</span><a href="#40373868">next</a><span>|</span><label class="collapse" for="c-40375927">[-]</label><label class="expand" for="c-40375927">[1 more]</label></div><br/><div class="children"><div class="content">You have also<p><pre><code>     RuntimeMaxUse=, RuntimeKeepFree=, RuntimeMaxFileSize=, RuntimeMaxFiles= 
</code></pre>
options if you are concerned about journald overusing tmpfs. But yes, it seems unconditional that it writes the logs always <i>somewhere</i>, which is not unreasonable design imho.</div><br/></div></div></div></div></div></div><div id="40373868" class="c"><input type="checkbox" id="c-40373868" checked=""/><div class="controls bullet"><span class="by">benlivengood</span><span>|</span><a href="#40372971">prev</a><span>|</span><a href="#40373079">next</a><span>|</span><label class="collapse" for="c-40373868">[-]</label><label class="expand" for="c-40373868">[1 more]</label></div><br/><div class="children"><div class="content">Obligatory recommendation to use ddrescue as a first pass.  Personally I&#x27;ve been helped in at least three ways by this:<p>* ddrescue doesn&#x27;t retry immediately; it tries to get as many readable sectors&#x2F;blocks as possible first and then goes back and retries.  When there are many bad sectors this is way more efficient than retrying N times at each bad sector while additional readable data is sitting on the bad device.<p>* ddrescue has configurable retries and its map file to perform rescue over any interruptions.  If a device loses power or overheats and stops responding or for whatever other reason you don&#x27;t have to get everything off the failing device in one pass.<p>* If you have two failing RAID1 devices you can ddrescue from one and then from the other to get as much data as possible.<p>If you need to recover audio CDs, use cdparanoia which takes a similar approach but uses a lot of speculative re-reads to avoid bad reconstruction efforts by some CD drives as much as possible.</div><br/></div></div><div id="40373079" class="c"><input type="checkbox" id="c-40373079" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40373868">prev</a><span>|</span><a href="#40375146">next</a><span>|</span><label class="collapse" for="c-40373079">[-]</label><label class="expand" for="c-40373079">[14 more]</label></div><br/><div class="children"><div class="content">&gt;Even though I was using tar (and not dd, thank you very much)<p>And from that linked article ( <a href="https:&#x2F;&#x2F;rachelbythebay.com&#x2F;w&#x2F;2011&#x2F;12&#x2F;11&#x2F;cloning&#x2F;" rel="nofollow">https:&#x2F;&#x2F;rachelbythebay.com&#x2F;w&#x2F;2011&#x2F;12&#x2F;11&#x2F;cloning&#x2F;</a> ):<p>&gt;Even if you tell it to continue after read errors (&quot;noerror&quot;), you&#x27;ve just silently corrupted something on the target disk.<p>The idea of using `dd` &#x2F; `ddrescue` is to get the contents of the drive off it ASAP before it fails. You don&#x27;t want to mount it. You don&#x27;t even know if the filesystem on it is sane. The priority right now is to get all the bytes off that you can, then analyze it at your leisure to recover what you can. For the same reason you would also not `dd` directly to the new disk. You&#x27;d do it to a storage area where you can inspect and manipulate it first.<p>And:<p>&gt;Finally, there is the whole matter of geometry. [...] Will the partition table wind up in the right place? What about the boot sector data and secondary stuff like the locations where your boot loader might be looking?<p>... is not a problem for the same reason. Once you have the disk image off the failing drive, you&#x27;re welcome to inspect it and copy individual files off it to the target drive at the filesystem layer (rsync, cp, etc).<p>And so:<p>&gt;Second, you&#x27;re dealing with individual files. If your tar or rsync (or whatever) fails to read a file due to some disk issue, you&#x27;ll know about it.<p>This is the right idea. It&#x27;s just not optimal to do it from the failing drive itself.</div><br/><div id="40373198" class="c"><input type="checkbox" id="c-40373198" checked=""/><div class="controls bullet"><span class="by">djbusby</span><span>|</span><a href="#40373079">parent</a><span>|</span><a href="#40373192">next</a><span>|</span><label class="collapse" for="c-40373198">[-]</label><label class="expand" for="c-40373198">[4 more]</label></div><br/><div class="children"><div class="content">I generally dd to an image file. (dd of=&#x2F;data&#x2F;bad-drive.dump) Then try tools to inspect fix the partition and FS, mount that and then rsync.<p>That&#x27;s what you&#x27;re saying too, right?</div><br/><div id="40374955" class="c"><input type="checkbox" id="c-40374955" checked=""/><div class="controls bullet"><span class="by">fencepost</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373198">parent</a><span>|</span><a href="#40373200">next</a><span>|</span><label class="collapse" for="c-40374955">[-]</label><label class="expand" for="c-40374955">[1 more]</label></div><br/><div class="children"><div class="content">ddrescue might be a good change for you, in particular specifying to not retry (because you&#x27;re going to come back later) and to specify the &#x27;log&#x27; file that&#x27;s actually a map of every sector on the source drive and whether it&#x27;s been successfully imaged.<p>I don&#x27;t think I&#x27;ve ever imaged an SSD, but for HDDs your ideal is a single pass through with no retries on bad blocks, possibly skipping ahead if you hit a bad block, and a log file writing to the destination drive where you&#x27;re also storing the image in a file (NOT doing direct output of the input disk). This gets you everything you can get with minimal disruption of the source.<p>After that first run you&#x27;ll specify the same log file for every time you run it, and (on HDDs) you can tell it to do things like trying to read the higher-numbered sectors first (so if you got an error on block 10,000 and told it to skip 100 on errors, now you start at 10,099 and work backwards, perhaps getting down to 10,005 before you get another error. Basically, get the dropped fruit, then the low-hanging fruit, then work harder for anything remaining.<p>Before you do those followup runs though, it&#x27;s a good idea to look at things with the &#x27;ddrutility&#x27; tools to see if you even need to bother. ddru_findbad will let you use the image file and &#x27;log&#x27; file to identify what files might have pieces missing so you can decide if you need to progress further; ddru_ntfsfindbad does basically the same thing for NTFS volumes. It&#x27;s always nice to determine that 1) yes there&#x27;s a chunk of bad blocks and 2) we don&#x27;t have to care because they&#x27;re all in the Hibernation file so we can restore that image to a new drive, boot, disable and re-enable hibernation just to be cautious, and have no concerns about lost data on the old drive without having to beat the crap out of the drive hoping that on the 1000th attempt it&#x27;s finally going to read that one failing sector.<p>sorry if the latter part of that got preachy, I&#x27;ve seen some bad advice in the past on imaging failing drives and it&#x27;s made me sensitive....</div><br/></div></div><div id="40373200" class="c"><input type="checkbox" id="c-40373200" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373198">parent</a><span>|</span><a href="#40374955">prev</a><span>|</span><a href="#40373192">next</a><span>|</span><label class="collapse" for="c-40373200">[-]</label><label class="expand" for="c-40373200">[2 more]</label></div><br/><div class="children"><div class="content">Yes, exactly.</div><br/><div id="40373299" class="c"><input type="checkbox" id="c-40373299" checked=""/><div class="controls bullet"><span class="by">MadnessASAP</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373200">parent</a><span>|</span><a href="#40373192">next</a><span>|</span><label class="collapse" for="c-40373299">[-]</label><label class="expand" for="c-40373299">[1 more]</label></div><br/><div class="children"><div class="content">Nevermind trying to copy off of a failed drive that&#x27;s still in use.<p>Madness! Madness I say!</div><br/></div></div></div></div></div></div><div id="40373192" class="c"><input type="checkbox" id="c-40373192" checked=""/><div class="controls bullet"><span class="by">Sakos</span><span>|</span><a href="#40373079">parent</a><span>|</span><a href="#40373198">prev</a><span>|</span><a href="#40375146">next</a><span>|</span><label class="collapse" for="c-40373192">[-]</label><label class="expand" for="c-40373192">[9 more]</label></div><br/><div class="children"><div class="content">My god, that article is actually filled with terrible advice. I hope they don&#x27;t do this professionally. It&#x27;s bad enough they&#x27;re misinforming people and directing them to do things in a worse, more fraught failure-prone way.<p>&gt; First of all, &#x27;dd&#x27; is going to try to read the entire drive, including the parts which currently do not contain any useful data. This happens because you have probably told it to read &#x2F;dev&#x2F;hdc. That refers to the entire readable portion of the disk, including the partition table and the parts which are not associated with living files.<p>Make a sparse image with dd. Then you have a 1:1 copy while skipping all the unused sectors to save space. You can then mount the image read-only or write it to a new disk for recovery. That means that you have all the time in the world <i>and</i> you can start over if need be without affecting the source data.<p>Doing all this on a possibly actively failing drive, particulary an SSD which can literally die 100% into an unrecoverable state without access to a lab in the blink of an eye? That&#x27;s insanity. And it&#x27;s even worse SUGGESTING that to random people who don&#x27;t know any better. You want to read everything off the SSD or HDD <i>once</i>. As fast as possible. As completely as possible.<p>In fact, make sure you do a non-trim pass first, so you can be sure you have as much as possible before you try retrying sectors which might actually kill the drive dead.<p>Once all the recoverable data is off the failing drive as an image, you&#x27;re free to do whatever you want however you want without fear of any data loss caused by possible mistakes, oversights, hardware issues, etc.</div><br/><div id="40373562" class="c"><input type="checkbox" id="c-40373562" checked=""/><div class="controls bullet"><span class="by">upon_drumhead</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373192">parent</a><span>|</span><a href="#40373278">next</a><span>|</span><label class="collapse" for="c-40373562">[-]</label><label class="expand" for="c-40373562">[5 more]</label></div><br/><div class="children"><div class="content">&gt; Make a sparse image with dd. Then you have a 1:1 copy while skipping all the unused sectors to save space.<p>Filesystems don&#x27;t zero out deleted data and dd isn&#x27;t aware of the filesystem mapping, so unless it&#x27;s a completely fresh drive, you&#x27;ll still pull off garbage data.<p>ddrescue is one tool that combines dd with the ability to read the filesystem metadata to only extract out the allocated filesystem blocks.</div><br/><div id="40374757" class="c"><input type="checkbox" id="c-40374757" checked=""/><div class="controls bullet"><span class="by">lmm</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373562">parent</a><span>|</span><a href="#40375384">next</a><span>|</span><label class="collapse" for="c-40374757">[-]</label><label class="expand" for="c-40374757">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Filesystems don&#x27;t zero out deleted data and dd isn&#x27;t aware of the filesystem mapping, so unless it&#x27;s a completely fresh drive, you&#x27;ll still pull off garbage data.<p>Sure, but if there&#x27;s unused space left zeroed, such as partitions that you didn&#x27;t use, then you get to skip it. It&#x27;s not a huge priority but it doesn&#x27;t hurt.</div><br/></div></div><div id="40375384" class="c"><input type="checkbox" id="c-40375384" checked=""/><div class="controls bullet"><span class="by">kalleboo</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373562">parent</a><span>|</span><a href="#40374757">prev</a><span>|</span><a href="#40375880">next</a><span>|</span><label class="collapse" for="c-40375384">[-]</label><label class="expand" for="c-40375384">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Filesystems don&#x27;t zero out deleted data</i><p>It&#x27;s an SSD, shouldn&#x27;t it be running TRIM?</div><br/></div></div><div id="40375880" class="c"><input type="checkbox" id="c-40375880" checked=""/><div class="controls bullet"><span class="by">ssl-3</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373562">parent</a><span>|</span><a href="#40375384">prev</a><span>|</span><a href="#40373781">next</a><span>|</span><label class="collapse" for="c-40375880">[-]</label><label class="expand" for="c-40375880">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Filesystems don&#x27;t zero out deleted data and dd isn&#x27;t aware of the filesystem mapping, so unless it&#x27;s a completely fresh drive, you&#x27;ll still pull off garbage data.<p>That may have been true a very long time ago.<p>Today, some filesystems such as ZFS can effectively, and automatically, zero out deleted data using trim on devices that support that.  (I say &quot;effectively&quot; here because we don&#x27;t actually know if the data is literally zero&#x27;d by the underlying device, and I say this even though that distinction doesn&#x27;t actually matter in this context.  Once trimmed, those logical sectors will always read as zeros until something new is written to them, and this is the functionality that is important in this context.)<p>This function is useful for SSDs, and is also useful for SMR spinny-disks.<p>Tons of other combinations of filesystems and operating systems also deal quite well with trimming of unused space, though this more-often happens as a scheduled task instead of something that is taken care of by the filesystem itself.<p>Trim (in various implementations) has been broadly used for well over a decade, and a trim&#x27;d device can lead dd to be able to produce sparse files.<p>---<p>Now, that said:  It probably doesn&#x27;t matter much if a particular dd-esque tool is set to create sparse output files or not.  Sure, some space may be saved, and sparse files sure are cute and cuddly.<p>But it&#x27;s probably a fool&#x27;s errand to even plan such an operation on a machine that has less free space than the total maximum capacity of the thing being rescued:  Either there&#x27;s enough room to write a non-sparse image, or there isn&#x27;t enough room to even think about starting the process since it might not be able to complete.<p>(If space becomes an issue later on down the road, the output file can be &quot;sparsified&quot; in-place using &quot;fallocate --dig-holes&quot; in instances where that makes sense.)<p>And I <i>definitely</i> want the whole disk imaged, which means that I definitely <i>do not</i> want ddrescue&#x27;s interpretation of metadata to determine filesystem allocation and limit the scope of that image:  This is the first step of a data rescue operation, and that makes it the worst place for data to be intentionally thrown away or disregarded.<p>If things are failing hard enough that any of this work is on the table, then obviously the combination of the source disk and filesystem is untrustworthy -- along with the metadata.<p>Getting all of the bits backed up -- regardless of their apparent lack of importance -- should always be the prime directive here.  Any extra bits can always be tossed later if they&#x27;re eventually deemed to be actually-unimportant.</div><br/></div></div><div id="40373781" class="c"><input type="checkbox" id="c-40373781" checked=""/><div class="controls bullet"><span class="by">Dylan16807</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373562">parent</a><span>|</span><a href="#40375880">prev</a><span>|</span><a href="#40373278">next</a><span>|</span><label class="collapse" for="c-40373781">[-]</label><label class="expand" for="c-40373781">[1 more]</label></div><br/><div class="children"><div class="content">If it&#x27;s an SSD then it should be zeroing out deleted data.</div><br/></div></div></div></div><div id="40373278" class="c"><input type="checkbox" id="c-40373278" checked=""/><div class="controls bullet"><span class="by">1992spacemovie</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373192">parent</a><span>|</span><a href="#40373562">prev</a><span>|</span><a href="#40373338">next</a><span>|</span><label class="collapse" for="c-40373278">[-]</label><label class="expand" for="c-40373278">[1 more]</label></div><br/><div class="children"><div class="content">&gt; My god, that article is actually filled with terrible advice. I hope they don&#x27;t do this professionally.<p>That’s pretty par for Rachel by the bay. Her blog is basically just HN-endorsed ramblings at this point.</div><br/></div></div><div id="40373338" class="c"><input type="checkbox" id="c-40373338" checked=""/><div class="controls bullet"><span class="by">derefr</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373192">parent</a><span>|</span><a href="#40373278">prev</a><span>|</span><a href="#40375146">next</a><span>|</span><label class="collapse" for="c-40373338">[-]</label><label class="expand" for="c-40373338">[2 more]</label></div><br/><div class="children"><div class="content">&gt; You want to read everything off the SSD or HDD once.<p>I mean, no, not really. You want to read everything off <i>at least</i> once. Because a &quot;corrupt sector&quot; is actually often in a <i>non-deterministic</i> state, reading differently with each read — but that state may still be floating just far enough toward logical 0 or 1, that you <i>can</i> get a bit-pattern out of it through <i>statistical analysis</i>, over multiple reads.<p>You <i>do</i> want to capture the whole disk once <i>first</i>, in case the disk spindle motor is about to die. (This isn&#x27;t <i>usually</i> the problem with a dying disk... save for certain old known-faulty disk models — the &quot;DeathStar&quot; et al. But it&#x27;s good to be safe!)<p>But after that, you want to read it again, and again, and again. And save the outputs of those reads. And then throw them into a tool like ddrescue that will put the results together.<p>Basically, it&#x27;s the same principle that applies to archival preservation of floppy disks (see e.g. <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UxsRpMdmlGo" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=UxsRpMdmlGo</a>). Magnetic flux is magnetic flux! (And even NAND cells can end up with approximately the same &quot;weak bits&quot; problems.)<p>---<p>Mind you, it&#x27;d be even better if we could get several <i>analogue</i> dumps of the disk, and then merge <i>those</i> together using analogue-domain tools, like the ones used for floppy preservation mentioned in the video above.<p>Sadly, unlike with floppy preservation, it&#x27;d be very difficult to get an analogue dump of an HDD or SSD. With floppies, the flux is right there for the reading; you just need a special drive. HDDs and SSDs, meanwhile, are far more self-contained. For an HDD, there might be a path to doing it, at least on a disk-specific basis... it would likely involve tapping some signal lines between the disk controller and the read head. But for an SSD, I don&#x27;t think it would be possible — IIRC with most NAND&#x2F;NOR flash packages, the signal is already digitized by the time it comes off the chip.<p>---<p>Also, I should mention that if your HDD disk spindle motor <i>is</i> about to die, then you&#x27;re actually on a bit of a ticking clock. You want to get your data off that disk as quickly as possible, before the motor locks up and the head crashes on the platter.<p>Tools like ddrescue have the option to first read a disk&#x27;s filesystem metadata to build a <i>map</i>; and then <i>use</i> that map to only bother to read filesystem-allocated sectors, seeking past any unallocated ones.<p>Doing this <i>can</i> greatly speed up the time it takes to make a complete copy of &quot;any potentially-useful data on the disk&quot; (as opposed to &quot;the entire disk&quot;.) Which means you might be able to get a capture done on a disk &quot;just under the wire&quot; using this method — where otherwise the disk would have died in the middle of reading some unused sectors, with some good data stored further down the disk left un-captured.<p>But of course, there&#x27;s the counterpoint that the filesystem metadata itself might have holes in it, where that would mean that the map made by the tool will fail to capture some of the data.<p>I think this isn&#x27;t a weighing-pros-and-cons situation, though, but pretty clearly a &quot;right tool for the job&quot; situation:<p>• If you&#x27;re getting fsck errors, weird data corruptions, or files are just disappearing — and it&#x27;s clear that you&#x27;re going to need to run one of those forensic data recovery programs against the disk image to extract what you can from it — then you&#x27;ll need the whole disk, including the &quot;seemingly unallocated&quot; parts.<p>• If all your data <i>seems</i> fine, but you&#x27;re getting SMART errors, writes are slowing down, and your disk is making funny noises... then you&#x27;re probably better off grabbing just the filesystem-allocated sectors ASAP, before your drive stops talking to you.</div><br/><div id="40373560" class="c"><input type="checkbox" id="c-40373560" checked=""/><div class="controls bullet"><span class="by">_wire_</span><span>|</span><a href="#40373079">root</a><span>|</span><a href="#40373338">parent</a><span>|</span><a href="#40375146">next</a><span>|</span><label class="collapse" for="c-40373560">[-]</label><label class="expand" for="c-40373560">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Tools like ddrescue have the option to first read a disk&#x27;s filesystem metadata to build a map; and then use that map to only bother to read used sectors, skipping the unused ones.<p>I don&#x27;t know how many versions of &quot;ddrescue&quot; there might be, but GNU ddrescue doesn&#x27;t know anything about filesystems.<p>The &quot;map&quot; file is just a list of device LBAs (extents) and recovery status.<p>I&#x27;ve seen a tool for NFTS that can pre-populate a GNU ddrescue map file with unused extents to avoid ddrescue reads of unused areas, but you have to find this tool and manage it yourself.</div><br/></div></div></div></div></div></div></div></div><div id="40372994" class="c"><input type="checkbox" id="c-40372994" checked=""/><div class="controls bullet"><span class="by">ciupicri</span><span>|</span><a href="#40375146">prev</a><span>|</span><a href="#40372882">next</a><span>|</span><label class="collapse" for="c-40372994">[-]</label><label class="expand" for="c-40372994">[7 more]</label></div><br/><div class="children"><div class="content">WTF, it&#x27;s 2024. systemd uses tmpfs for &#x2F;tmp</div><br/><div id="40375713" class="c"><input type="checkbox" id="c-40375713" checked=""/><div class="controls bullet"><span class="by">mhitza</span><span>|</span><a href="#40372994">parent</a><span>|</span><a href="#40374863">next</a><span>|</span><label class="collapse" for="c-40375713">[-]</label><label class="expand" for="c-40375713">[1 more]</label></div><br/><div class="children"><div class="content">Debian doesn&#x27;t seem to use tmpfs for &#x2F;tmp by default.</div><br/></div></div><div id="40374863" class="c"><input type="checkbox" id="c-40374863" checked=""/><div class="controls bullet"><span class="by">KyleSanderson</span><span>|</span><a href="#40372994">parent</a><span>|</span><a href="#40375713">prev</a><span>|</span><a href="#40373174">next</a><span>|</span><label class="collapse" for="c-40374863">[-]</label><label class="expand" for="c-40374863">[1 more]</label></div><br/><div class="children"><div class="content">same reaction, and the author not using ddrescue just makes this a tale about not following any sort of documentation when installing their distribution. There&#x27;s really nothing in there that anyone should take away besides making sure they didn&#x27;t hack up fstab and remove tmpfs.</div><br/></div></div><div id="40373174" class="c"><input type="checkbox" id="c-40373174" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40372994">parent</a><span>|</span><a href="#40374863">prev</a><span>|</span><a href="#40372882">next</a><span>|</span><label class="collapse" for="c-40373174">[-]</label><label class="expand" for="c-40373174">[4 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the default, but TFA might&#x27;ve masked it since they&#x27;re dealing with an old laptop where they can upgrade the drive but not the RAM.</div><br/><div id="40373229" class="c"><input type="checkbox" id="c-40373229" checked=""/><div class="controls bullet"><span class="by">ciupicri</span><span>|</span><a href="#40372994">root</a><span>|</span><a href="#40373174">parent</a><span>|</span><a href="#40374875">next</a><span>|</span><label class="collapse" for="c-40373229">[-]</label><label class="expand" for="c-40373229">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, but this was introduced around 2012 [1] when that old laptop was manufactured.
Also no one is forcing you to store GBs of data on it and indeed in practice most programs use only a couple of MBs.<p>[1]: <a href="https:&#x2F;&#x2F;fedoraproject.org&#x2F;wiki&#x2F;Features&#x2F;tmp-on-tmpfs" rel="nofollow">https:&#x2F;&#x2F;fedoraproject.org&#x2F;wiki&#x2F;Features&#x2F;tmp-on-tmpfs</a></div><br/></div></div><div id="40374875" class="c"><input type="checkbox" id="c-40374875" checked=""/><div class="controls bullet"><span class="by">ojbyrne</span><span>|</span><a href="#40372994">root</a><span>|</span><a href="#40373174">parent</a><span>|</span><a href="#40373229">prev</a><span>|</span><a href="#40372882">next</a><span>|</span><label class="collapse" for="c-40374875">[-]</label><label class="expand" for="c-40374875">[2 more]</label></div><br/><div class="children"><div class="content">I’m confused. The article talks about a Mac Mini, which is not a laptop. And an old enough one that the RAM is probably user-replaceable.</div><br/><div id="40375724" class="c"><input type="checkbox" id="c-40375724" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40372994">root</a><span>|</span><a href="#40374875">parent</a><span>|</span><a href="#40372882">next</a><span>|</span><label class="collapse" for="c-40375724">[-]</label><label class="expand" for="c-40375724">[1 more]</label></div><br/><div class="children"><div class="content">Apparently I&#x27;m illiterate. Indeed, not only is the Mac Mini a desktop, but also the author says in that same paragraph how they did in fact upgrade its RAM once in the past.</div><br/></div></div></div></div></div></div></div></div><div id="40372882" class="c"><input type="checkbox" id="c-40372882" checked=""/><div class="controls bullet"><span class="by">db48x</span><span>|</span><a href="#40372994">prev</a><span>|</span><label class="collapse" for="c-40372882">[-]</label><label class="expand" for="c-40372882">[1 more]</label></div><br/><div class="children"><div class="content">Spooky.</div><br/></div></div></div></div></div></div></div></body></html>