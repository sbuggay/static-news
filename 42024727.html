<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1730624464106" as="style"/><link rel="stylesheet" href="styles.css?v=1730624464106"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://justine.lol/lex/">Weird Lexical Syntax</a> <span class="domain">(<a href="https://justine.lol">justine.lol</a>)</span></div><div class="subtext"><span>jart</span> | <span>155 comments</span></div><br/><div><div id="42031338" class="c"><input type="checkbox" id="c-42031338" checked=""/><div class="controls bullet"><span class="by">petters</span><span>|</span><a href="#42026536">next</a><span>|</span><label class="collapse" for="c-42031338">[-]</label><label class="expand" for="c-42031338">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;m not sure who wants to be able to syntax highlight C at 35 MB per second, but I am now able to do so<p>Fast, but tcc *compiles* C to binary code at 29 MB&#x2F;s on a really old computer: <a href="https:&#x2F;&#x2F;bellard.org&#x2F;tcc&#x2F;#speed" rel="nofollow">https:&#x2F;&#x2F;bellard.org&#x2F;tcc&#x2F;#speed</a>
Should be possible to go much faster but probably not needed</div><br/></div></div><div id="42026536" class="c"><input type="checkbox" id="c-42026536" checked=""/><div class="controls bullet"><span class="by">TomatoCo</span><span>|</span><a href="#42031338">prev</a><span>|</span><a href="#42026377">next</a><span>|</span><label class="collapse" for="c-42026536">[-]</label><label class="expand" for="c-42026536">[7 more]</label></div><br/><div class="children"><div class="content">I think my favorite C trigraph was something like<p><pre><code>  do_action() ??!??! handle_error()
</code></pre>
It almost looks like special error handling syntax but still remains satisfying once you realize it&#x27;s an || logical-or statement and it&#x27;s using short circuiting rules to execute handle error if the action returns a non-zero value.</div><br/><div id="42026614" class="c"><input type="checkbox" id="c-42026614" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42026536">parent</a><span>|</span><a href="#42026377">next</a><span>|</span><label class="collapse" for="c-42026614">[-]</label><label class="expand" for="c-42026614">[6 more]</label></div><br/><div class="children"><div class="content">Did you choose the legacy C trigraphs over || for aesthetic purposes?</div><br/><div id="42028918" class="c"><input type="checkbox" id="c-42028918" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42026536">root</a><span>|</span><a href="#42026614">parent</a><span>|</span><a href="#42026377">next</a><span>|</span><label class="collapse" for="c-42028918">[-]</label><label class="expand" for="c-42028918">[5 more]</label></div><br/><div class="children"><div class="content">Could you review my comment on HN? Please educate me if there is something I haven’t understood, rather than downvoting my question.</div><br/><div id="42029131" class="c"><input type="checkbox" id="c-42029131" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42026536">root</a><span>|</span><a href="#42028918">parent</a><span>|</span><a href="#42026377">next</a><span>|</span><label class="collapse" for="c-42029131">[-]</label><label class="expand" for="c-42029131">[4 more]</label></div><br/><div class="children"><div class="content">The grandparent post is specifically about trigraphs. Saying something about trigraphs was the end-in-itself, trigraphs were chosen to illustrate something about trigraphs.  So your question made no sense.  Hope that helps.</div><br/><div id="42030877" class="c"><input type="checkbox" id="c-42030877" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42026536">root</a><span>|</span><a href="#42029131">parent</a><span>|</span><a href="#42031692">next</a><span>|</span><label class="collapse" for="c-42030877">[-]</label><label class="expand" for="c-42030877">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the confusion was the other way, more like &quot;why is that funny&#x2F;interesting?&quot;<p>An attempt to answer that:  In English, mixing ?! at the end of a question is a way of indicating bewilderment.  Like &quot;What was that?!&quot;</div><br/></div></div><div id="42031692" class="c"><input type="checkbox" id="c-42031692" checked=""/><div class="controls bullet"><span class="by">wslh</span><span>|</span><a href="#42026536">root</a><span>|</span><a href="#42029131">parent</a><span>|</span><a href="#42030877">prev</a><span>|</span><a href="#42026377">next</a><span>|</span><label class="collapse" for="c-42031692">[-]</label><label class="expand" for="c-42031692">[2 more]</label></div><br/><div class="children"><div class="content">My question was precisely about why the user like trigraphs over using just || on this case. It is a very clear question and makes all the sense.</div><br/><div id="42031905" class="c"><input type="checkbox" id="c-42031905" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42026536">root</a><span>|</span><a href="#42031692">parent</a><span>|</span><a href="#42026377">next</a><span>|</span><label class="collapse" for="c-42031905">[-]</label><label class="expand" for="c-42031905">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t downvote your comment but understand why it looks &quot;wrong&quot;: it&#x27;s like, in a thread on English oddities, you replied to someone bringing up the &quot;buffalo buffalo buffalo&quot; example with the question &quot;why are you so fond of bovines&quot;?</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42026377" class="c"><input type="checkbox" id="c-42026377" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42026536">prev</a><span>|</span><a href="#42026212">next</a><span>|</span><label class="collapse" for="c-42026377">[-]</label><label class="expand" for="c-42026377">[16 more]</label></div><br/><div class="children"><div class="content">This was a fun read, but it left me a bit more sympathetic to the lisp perspective, which (if I&#x27;ve understood it) is that syntax, being not an especially important part of a language, is more of a hurdle than a help, and should be as simple and uniform as possible so we can focus on other things.<p>Which is sort of ironic because learning how to do structural editing on lisps has absolutely been more hurdle than help so far, but I&#x27;m sure it&#x27;ll pay off eventually.</div><br/><div id="42026539" class="c"><input type="checkbox" id="c-42026539" checked=""/><div class="controls bullet"><span class="by">mqus</span><span>|</span><a href="#42026377">parent</a><span>|</span><a href="#42026878">next</a><span>|</span><label class="collapse" for="c-42026539">[-]</label><label class="expand" for="c-42026539">[8 more]</label></div><br/><div class="children"><div class="content">Having a simple syntax might be fine for computers but syntax is mainly designed to be read and written by humans. Having a simple one like lisp then just makes syntactic discussions a semantic problem, just shifting the layers.<p>And I think an complex syntax is far easier to read and write than a simple syntax with complex semantics. You also get a faster feedback loop in case the syntax of your code is wrong vs the semantics (which might be undiscovered until runtime).</div><br/><div id="42027060" class="c"><input type="checkbox" id="c-42027060" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026539">parent</a><span>|</span><a href="#42026889">next</a><span>|</span><label class="collapse" for="c-42027060">[-]</label><label class="expand" for="c-42027060">[4 more]</label></div><br/><div class="children"><div class="content">Jury&#x27;s out re: whether I feel this in my gut. Need more time with the lisps for that. But re: cognitive load maybe it goes like:<p>1. 1 language to rule them all, fancy syntax<p>2. Many languages, 1 simple syntax to rule them all<p>3. Many languages and many fancy syntaxes<p>Here in the wreckage of the tower of babel, 1. isn&#x27;t really on the table. But 2. might have benefits because the inhumanity of the syntax need only be confronted once.  The cumulative cost of all the competing opinionated fancy syntaxes may be the worst option. Think of all the hours lost to tabs vs spaces or braces vs whitespace.</div><br/><div id="42027353" class="c"><input type="checkbox" id="c-42027353" checked=""/><div class="controls bullet"><span class="by">dartos</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42027060">parent</a><span>|</span><a href="#42026889">next</a><span>|</span><label class="collapse" for="c-42027353">[-]</label><label class="expand" for="c-42027353">[3 more]</label></div><br/><div class="children"><div class="content">I think 3 is not only a natural state, but the best state.<p>I don’t think we can have 1 language that satisfies the needs of all people who write code, and thus, we can’t have 1 syntax that does that either.<p>3 seems the only sensible solution to me, and we have it.</div><br/><div id="42027477" class="c"><input type="checkbox" id="c-42027477" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42027353">parent</a><span>|</span><a href="#42026889">next</a><span>|</span><label class="collapse" for="c-42027477">[-]</label><label class="expand" for="c-42027477">[2 more]</label></div><br/><div class="children"><div class="content">I dunno, here in 3 the hardest part of learning a language has little to do with the language itself and more to do with the ecosystem of tooling around that language.  I think we could more easily get on to the business of using the right language for the job if more of that tooling was shared.  If each language, for instance did not have it&#x27;s own package manager, its own IDE, its own linters and language servers all with their own idiosyncrasies arising not from deep philosophical differences of the associated language but instead from accidental quirks of perspective from whoever decided that their favorite language needed a new widget.<p>I admire the widget makers, especially those wrangling the gaps between languages. I just wish their work could be made easier.</div><br/><div id="42027862" class="c"><input type="checkbox" id="c-42027862" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42027477">parent</a><span>|</span><a href="#42026889">next</a><span>|</span><label class="collapse" for="c-42027862">[-]</label><label class="expand" for="c-42027862">[1 more]</label></div><br/><div class="children"><div class="content">I really like the Linux package managers. If you&#x27;re going to write an application that will run on some system, it&#x27;s better to bake dependencies into it. And with virtualization and containerization, the system is not tied to a physical machine. I&#x27;ve been using containers (incus) more and more for real development purposes as I can use almost the same environment to deploy. I don&#x27;t care much about the IDE, but I&#x27;m glad we have LSP, Tree-sitter, and DAP. The one thing I do not like is the proliferation of tooling version manager (NVM,..) instead of managing the environment itself (tied to the project).</div><br/></div></div></div></div></div></div></div></div><div id="42026889" class="c"><input type="checkbox" id="c-42026889" checked=""/><div class="controls bullet"><span class="by">drewr</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026539">parent</a><span>|</span><a href="#42027060">prev</a><span>|</span><a href="#42026878">next</a><span>|</span><label class="collapse" for="c-42026889">[-]</label><label class="expand" for="c-42026889">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t understand your distinction between syntax and semantics. If the semantics are complex, wouldn&#x27;t that mean the syntax is thus complex?</div><br/><div id="42027592" class="c"><input type="checkbox" id="c-42027592" checked=""/><div class="controls bullet"><span class="by">SuperCuber</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026889">parent</a><span>|</span><a href="#42027999">next</a><span>|</span><label class="collapse" for="c-42027592">[-]</label><label class="expand" for="c-42027592">[1 more]</label></div><br/><div class="children"><div class="content">lisp&#x27;s syntax is simple - its just parenthesis to define a list, first element of a list is executed as a function.<p>but for example a language like C has many different syntaxes for different operations, like function declaration or variable or array syntax, or if&#x2F;switch-case etc etc.<p>so to know C syntax you need to learn all these different ways to do different things, but in lisp you just need to know how to match parenthesis.<p>But of course you still want to declare variables, or have if&#x2F;else and switch case. So you instead need to learn the builtin macros (what GP means by semantics) and their &quot;syntax&quot; that is technically not part of the language&#x27;s syntax but actually is since you still need all those operations enough that they are included in the standard library and defining your own is frowned upon.</div><br/></div></div><div id="42027999" class="c"><input type="checkbox" id="c-42027999" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026889">parent</a><span>|</span><a href="#42027592">prev</a><span>|</span><a href="#42026878">next</a><span>|</span><label class="collapse" for="c-42027999">[-]</label><label class="expand" for="c-42027999">[1 more]</label></div><br/><div class="children"><div class="content">Most languages&#x27; abstract machines expose a very simple API, it&#x27;s up to the language to add useful constructs to help us write code more efficiently. Languages like Lisp start with a very simple syntax, then add those constructs with the language itself (even though those can be fixed using a standard), others just add it through the syntax. These constructs plus the abstract machine&#x27;s operations form the semantics, syntax is however the language designer decided to present them.</div><br/></div></div></div></div></div></div><div id="42026878" class="c"><input type="checkbox" id="c-42026878" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42026377">parent</a><span>|</span><a href="#42026539">prev</a><span>|</span><a href="#42026621">next</a><span>|</span><label class="collapse" for="c-42026878">[-]</label><label class="expand" for="c-42026878">[2 more]</label></div><br/><div class="children"><div class="content">Lisp has reader macros which allow you to reprogram its lexer. Lisp macros allow you to program the translation from the visible structure to the parse tree.<p>For example, <a href="https:&#x2F;&#x2F;pyret.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;pyret.org&#x2F;</a><p>It really isn’t simple or necessarily uniform.</div><br/><div id="42029259" class="c"><input type="checkbox" id="c-42029259" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026878">parent</a><span>|</span><a href="#42026621">next</a><span>|</span><label class="collapse" for="c-42029259">[-]</label><label class="expand" for="c-42029259">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve heard that certain lisps (Common Lisp comes up when I search for reader macros) allow for all kinds of tinkering with themselves.  But the ability of one to make itself not a lisp anymore, while interesting, doesn&#x27;t seem to say much about the merits of sticking to s-expressions, except maybe to point out that somebody once decided not to.</div><br/></div></div></div></div><div id="42026621" class="c"><input type="checkbox" id="c-42026621" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#42026377">parent</a><span>|</span><a href="#42026878">prev</a><span>|</span><a href="#42026212">next</a><span>|</span><label class="collapse" for="c-42026621">[-]</label><label class="expand" for="c-42026621">[5 more]</label></div><br/><div class="children"><div class="content">I am surprised to hear that structural editing has been a hurdle for you, and I think I can offer a piece of advice. I also used to be terrified by its apparent complexity, but later found out that one just needs to use parinfer and to know key bindings for only three commands: slurp, barf, and raise.<p>With just these four things you will be 95% there, enjoying the fruits of paredit without any complexity — all the remaining tricks you can learn later when you feel like you’re fluent.</div><br/><div id="42026758" class="c"><input type="checkbox" id="c-42026758" checked=""/><div class="controls bullet"><span class="by">__MatrixMan__</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026621">parent</a><span>|</span><a href="#42026212">next</a><span>|</span><label class="collapse" for="c-42026758">[-]</label><label class="expand" for="c-42026758">[4 more]</label></div><br/><div class="children"><div class="content">Thanks very much for the advice, it&#x27;s timely.<p>&lt;rant&gt; It&#x27;s not so much the editing itself but the unfamiliarity of the ecosystem.  It seems it&#x27;s a square-peg I&#x27;ve been crafting a round hole of habits for it:<p>I guess I should use emacs? How to even configure it such that these actions are available?  Or maybe I should write a plugin for helix so that I can be in a familiar environment.  Oh, but the helix plugin language is a scheme, so I guess I&#x27;ll use emacs until I can learn scheme better and then write that plugin.  Oh but emacs keybinds are conflicting with what I&#x27;ve configured for zellij, maybe I can avoid conflicts by using evil mode?  Oh ok, emacs-lisp, that&#x27;s a thing.  Hey symex seems like it aligns with my modal brain, oh but there goes another afternoon of fussing with emacs.  Found and reported a symex &quot;bug&quot; but apparently it only appears in nix-governed environments so I guess I gotta figure out how to report the packaging bug (still todo).  Also, I guess I might as well figure out how to get emacs to evaluate expressions based on which ones are selected, since that&#x27;s one of the fun things you can do in lisps, but there&#x27;s no plugin for the scheme that helix is using for its plugin language (which is why I&#x27;m learning scheme in the first place), but it turns out that AI is weirdly good at configuring emacs so now my emacs config contains most that that plugin would entail.  Ok, now I&#x27;m finally ready to learn scheme, I&#x27;ve got this big list of new actions to learn: <a href="https:&#x2F;&#x2F;countvajhula.com&#x2F;2021&#x2F;09&#x2F;25&#x2F;the-animated-guide-to-symex&#x2F;" rel="nofollow">https:&#x2F;&#x2F;countvajhula.com&#x2F;2021&#x2F;09&#x2F;25&#x2F;the-animated-guide-to-sy...</a>. Slurp, barf, and raise you say? excellent, I&#x27;ll focus on those.<p>I&#x27;m not actually trying to critique the unfamiliar space. These are all self inflicted wounds: me being persnickety about having it my way. It&#x27;s just usually not so difficult to use something new and also have it my way.&lt;&#x2F;rant&gt;</div><br/><div id="42029507" class="c"><input type="checkbox" id="c-42029507" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026758">parent</a><span>|</span><a href="#42027828">next</a><span>|</span><label class="collapse" for="c-42029507">[-]</label><label class="expand" for="c-42029507">[1 more]</label></div><br/><div class="children"><div class="content">&gt;  Oh but emacs keybinds are conflicting with what I&#x27;ve configured for zellij,<p>Don&#x27;t do that. ;)<p>Emacs is a graphical application! Don&#x27;t use it in the terminal unless you really have to (i.e., you&#x27;re using it on a remote machine and TRAMP will not do).<p>&gt; it turns out that AI is weirdly good at configuring emacs<p>I was just chatting with a friend about this. ChatGPT seems to be much better at writing ELisp than many other languages I&#x27;ve asked it to work with.<p>Also while you&#x27;re playing with it, you might be interested in checking out kakoune.el or meow, which provide modal editing in Emacs but with the selection-first ordering for commands, like in Kakoune and Helix rather than the old vi way.<p>PS: symex looks really interesting! Hadn&#x27;t been that one</div><br/></div></div><div id="42027828" class="c"><input type="checkbox" id="c-42027828" checked=""/><div class="controls bullet"><span class="by">nlitened</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026758">parent</a><span>|</span><a href="#42029507">prev</a><span>|</span><a href="#42027508">next</a><span>|</span><label class="collapse" for="c-42027828">[-]</label><label class="expand" for="c-42027828">[1 more]</label></div><br/><div class="children"><div class="content">To be fair, I am not a &quot;lisper&quot; and I don&#x27;t know Emacs at all. I am just a Clojure enjoyer who uses IntelliJ + Cursive with its built-in parinfer&#x2F;paredit.</div><br/></div></div><div id="42027508" class="c"><input type="checkbox" id="c-42027508" checked=""/><div class="controls bullet"><span class="by">xenophonf</span><span>|</span><a href="#42026377">root</a><span>|</span><a href="#42026758">parent</a><span>|</span><a href="#42027828">prev</a><span>|</span><a href="#42026212">next</a><span>|</span><label class="collapse" for="c-42027508">[-]</label><label class="expand" for="c-42027508">[1 more]</label></div><br/><div class="children"><div class="content">I never bothered with structural editing on Emacs.  I just use the sentence&#x2F;paragraph movement commands.  M-a, M-e, M-n, M-p, M-T, M-space, etc.</div><br/></div></div></div></div></div></div></div></div><div id="42026212" class="c"><input type="checkbox" id="c-42026212" checked=""/><div class="controls bullet"><span class="by">pdw</span><span>|</span><a href="#42026377">prev</a><span>|</span><a href="#42026136">next</a><span>|</span><label class="collapse" for="c-42026212">[-]</label><label class="expand" for="c-42026212">[39 more]</label></div><br/><div class="children"><div class="content">Some random things that the author seem to have missed:<p>&gt; but TypeScript, Swift, Kotlin, and Scala take string interpolation to the furthest extreme of encouraging actual code being embedded inside strings<p>Many more languages support that:<p><pre><code>    C#             $&quot;{x} plus {y} equals {x + y}&quot;
    Python         f&quot;{x} plus {y} equals {x + y}&quot;
    JavaScript     `${x} plus ${y} equals ${x + y}`
    Ruby           &quot;#{x} plus #{y} equals #{x + y}&quot;
    Shell          &quot;$x plus $y equals $(echo &quot;$x+$y&quot; | bc)&quot;
    Make :)        echo &quot;$(x) plus $(y) equals $(shell echo &quot;$x+$y&quot; | bc)&quot;
</code></pre>
&gt; Tcl<p>Tcl is funny because comments are only recognized in code, and since it&#x27;s a homoiconic, it&#x27;s very hard to distinguish code and data. { } are just funny string delimiters. E.g.:<p><pre><code>    xyzzy {#hello world}
</code></pre>
Is xyzzy a command that takes a code block or a string? There&#x27;s no way to tell. (Yes, that means that the Tcl tokenizer&#x2F;parser cannot discard comments: only at evaluation time it&#x27;s possible to tell if something is a comment or not.)<p>&gt; SQL<p>PostgreSQL has the very convenient dollar-quoted strings: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;sql-syntax-lexical.h...</a>
E.g. these are equivalent:<p><pre><code>    &#x27;Dianne&#x27;&#x27;s horse&#x27;
    $$Dianne&#x27;s horse$$
    $SomeTag$Dianne&#x27;s horse$SomeTag$</code></pre></div><br/><div id="42027001" class="c"><input type="checkbox" id="c-42027001" checked=""/><div class="controls bullet"><span class="by">autarch</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42031761">next</a><span>|</span><label class="collapse" for="c-42027001">[-]</label><label class="expand" for="c-42027001">[9 more]</label></div><br/><div class="children"><div class="content">Perl lets you do this too:<p><pre><code>    my $foo = 5;
    my $bar = &#x27;x&#x27;;
    my $quux = &quot;I have $foo $bar\&#x27;s: @{[$bar x $foo]}&quot;;
    print &quot;$quux\n&quot;;
</code></pre>
This prints out:<p><pre><code>    I have 5 x&#x27;s: xxxxx
</code></pre>
The &quot;@{[...]}&quot; syntax is abusing Perl&#x27;s ability to interpolate an _array_ as well as a scalar. The inner &quot;[...]&quot; creates an array reference and the outer &quot;@{...}&quot; dereferences it.<p>For reasons I don&#x27;t remember, the Perl interpreter allows arbitrary code in the inner &quot;[...]&quot; expression that creates the array reference.</div><br/><div id="42028623" class="c"><input type="checkbox" id="c-42028623" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027001">parent</a><span>|</span><a href="#42029070">next</a><span>|</span><label class="collapse" for="c-42028623">[-]</label><label class="expand" for="c-42028623">[4 more]</label></div><br/><div class="children"><div class="content">&gt; For reasons I don&#x27;t remember, the Perl interpreter allows arbitrary code in the inner &quot;[...]&quot; expression that creates the array reference.<p>...because it&#x27;s an array value? Aside from how the languages handle references, how is that part any different from, for example, this in python:<p><pre><code>  &gt;&gt;&gt; [5 * &#x27;x&#x27;]
  [&#x27;xxxxx&#x27;]
</code></pre>
You can put (almost) anything there, as long as it&#x27;s an expression that evaluates to a value. The resulting value is what goes into the array.</div><br/><div id="42028690" class="c"><input type="checkbox" id="c-42028690" checked=""/><div class="controls bullet"><span class="by">autarch</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028623">parent</a><span>|</span><a href="#42029070">next</a><span>|</span><label class="collapse" for="c-42028690">[-]</label><label class="expand" for="c-42028690">[3 more]</label></div><br/><div class="children"><div class="content">I understand that&#x27;s constructing an array. What&#x27;s a bit odd is that the interpreter allows you to string interpolate any expression when constructing the array reference inside the string.</div><br/><div id="42028829" class="c"><input type="checkbox" id="c-42028829" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028690">parent</a><span>|</span><a href="#42031103">next</a><span>|</span><label class="collapse" for="c-42028829">[-]</label><label class="expand" for="c-42028829">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not...? Well, not directly: It&#x27;s string interpolating an array of values, and the array is constructed using values from the results of expressions. These are separate features that compose nicely.</div><br/></div></div><div id="42031103" class="c"><input type="checkbox" id="c-42031103" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028690">parent</a><span>|</span><a href="#42028829">prev</a><span>|</span><a href="#42029070">next</a><span>|</span><label class="collapse" for="c-42031103">[-]</label><label class="expand" for="c-42031103">[1 more]</label></div><br/><div class="children"><div class="content">&gt; What&#x27;s a bit odd is that the interpreter allows you to string interpolate any expression when constructing the array reference inside the string.<p>Why?  Surely it is easier for both the language and the programmer to have a rule for what you can do when constructing references to anonymous arrays, without having to special case whether that anonymous array is or is not in a string (or in any one of the many other contexts in which such a construct may appear in Perl).</div><br/></div></div></div></div></div></div><div id="42029070" class="c"><input type="checkbox" id="c-42029070" checked=""/><div class="controls bullet"><span class="by">weinzierl</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027001">parent</a><span>|</span><a href="#42028623">prev</a><span>|</span><a href="#42031761">next</a><span>|</span><label class="collapse" for="c-42029070">[-]</label><label class="expand" for="c-42029070">[4 more]</label></div><br/><div class="children"><div class="content">You also don&#x27;t need quotes around strings (barewords). So<p><pre><code>    my $bar = x;
</code></pre>
should give the same result.<p>Good luck with lexing that properly.<p><a href="https:&#x2F;&#x2F;perlmaven.com&#x2F;barewords-in-perl" rel="nofollow">https:&#x2F;&#x2F;perlmaven.com&#x2F;barewords-in-perl</a></div><br/><div id="42029994" class="c"><input type="checkbox" id="c-42029994" checked=""/><div class="controls bullet"><span class="by">shawn_w</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42029070">parent</a><span>|</span><a href="#42031761">next</a><span>|</span><label class="collapse" for="c-42029994">[-]</label><label class="expand" for="c-42029994">[3 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re writing anything approaching decent perl that won&#x27;t be accepted.</div><br/><div id="42030668" class="c"><input type="checkbox" id="c-42030668" checked=""/><div class="controls bullet"><span class="by">emmelaich</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42029994">parent</a><span>|</span><a href="#42031761">next</a><span>|</span><label class="collapse" for="c-42030668">[-]</label><label class="expand" for="c-42030668">[2 more]</label></div><br/><div class="children"><div class="content">&quot;use strict&quot; will prevent it and I think strict will be assumed&#x2F;default soon.</div><br/><div id="42031110" class="c"><input type="checkbox" id="c-42031110" checked=""/><div class="controls bullet"><span class="by">JadeNB</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42030668">parent</a><span>|</span><a href="#42031761">next</a><span>|</span><label class="collapse" for="c-42031110">[-]</label><label class="expand" for="c-42031110">[1 more]</label></div><br/><div class="children"><div class="content">As of Perl 5.12, `use`ing a version (necessary to ensure availability of some of the newer features) automatically implies `use strict`.<p><a href="https:&#x2F;&#x2F;perldoc.perl.org&#x2F;strict#HISTORY" rel="nofollow">https:&#x2F;&#x2F;perldoc.perl.org&#x2F;strict#HISTORY</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="42031761" class="c"><input type="checkbox" id="c-42031761" checked=""/><div class="controls bullet"><span class="by">mbo</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42027001">prev</a><span>|</span><a href="#42027690">next</a><span>|</span><label class="collapse" for="c-42031761">[-]</label><label class="expand" for="c-42031761">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Scala<p>Note about Scala&#x27;s string interpolation. They can be used as pattern match targets.<p><pre><code>  val s&quot;${a} + ${b}&quot; = &quot;1 + 2&quot;;
  println(a) &#x2F;&#x2F; 1
  println(b) &#x2F;&#x2F; 2</code></pre></div><br/></div></div><div id="42027690" class="c"><input type="checkbox" id="c-42027690" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42031761">prev</a><span>|</span><a href="#42030855">next</a><span>|</span><label class="collapse" for="c-42027690">[-]</label><label class="expand" for="c-42027690">[15 more]</label></div><br/><div class="children"><div class="content">&gt; actual code being embedded inside strings<p>My view on this is that it shouldn’t be interpreted as code being embedded inside strings, but as a special form of string concatenation syntax. In turn, this would mean that you can nest the syntax, for example:<p><pre><code>    &quot;foo { toUpper(&quot;bar { x + y } bar&quot;) } foo&quot;
</code></pre>
The individual tokens being (one per line):<p><pre><code>    &quot;foo {
    toUpper
    (
    &quot;bar {
    x
    +
    y
    } bar&quot;
    )
    } foo&quot;
</code></pre>
If `+` does string concatenation, the above would effectively be equivalent to:<p><pre><code>    &quot;foo &quot; + toUpper(&quot;bar &quot; + (x + y) + &quot; bar&quot;) + &quot; foo&quot;
</code></pre>
I don’t know if there is a language that actually works that way.</div><br/><div id="42028345" class="c"><input type="checkbox" id="c-42028345" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027690">parent</a><span>|</span><a href="#42027840">next</a><span>|</span><label class="collapse" for="c-42028345">[-]</label><label class="expand" for="c-42028345">[3 more]</label></div><br/><div class="children"><div class="content">&gt;  &quot;foo { …<p>That should probably not be one token.<p>&gt; My view on this is that it shouldn’t be interpreted as code being embedded inside strings<p>I’m not sure exactly what you’re proposing and how it is different. You still can’t parse it as a regular lexical grammar.<p>How does this change how you highlight either?<p>Whatever you call it, to the lexer it is a special string, it has to know how to match it, the delimiters are materially different than concatenation.<p>I might be being dense but I’m not sure what’s formally distinct.</div><br/><div id="42030975" class="c"><input type="checkbox" id="c-42030975" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028345">parent</a><span>|</span><a href="#42027840">next</a><span>|</span><label class="collapse" for="c-42030975">[-]</label><label class="expand" for="c-42030975">[2 more]</label></div><br/><div class="children"><div class="content">&gt; &gt; &quot;foo { …<p>&gt; That should probably not be one token.<p>It&#x27;s exactly the point that this is one token. It&#x27;s a string literal with opening delimiter `&quot;` and closing delimiter `{`, and that whole token itself serves as a kind of opening &quot;brace&quot;. Alternatively, you can see `{` as a contraction of `&quot; +`. Meaning, aside from the brace balancing requirement, `&quot;foo {` does the same a `&quot;foo &quot; +` would.<p>Still alternatively, you could imagine a language that concatenates around string literals by default, similar to how C behaves for sequences of string literals. In C,<p><pre><code>    &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;
</code></pre>
is equivalent to<p><pre><code>    &quot;foobarbaz&quot;
</code></pre>
Similarly, you could imagine a language where<p><pre><code>    &quot;foo&quot; some_variable &quot;bar&quot;
</code></pre>
would perform implicit concatenation, without needing an explicit operator (as in `&quot;foo&quot; + x + &quot;bar&quot;`). And then people might write it without the inner whitespace, as:<p><pre><code>    &quot;foo&quot;some_variable&quot;bar&quot;
</code></pre>
My point is that<p><pre><code>    &quot;foo{some_variable}bar&quot;
</code></pre>
is really just that (plus a condition requiring balanced pairs of braces). You can also re-insert the spaces for emphasis:<p><pre><code>    &quot;foo{ some_variable }bar&quot;
</code></pre>
The fact that people tend to think of `{some_variable}` as an entity is sort-of an illusion.<p>&gt; How does this change how you highlight either?<p>You would highlight the `&quot;...{`, `}...{`, and `}...&quot;` parts like normal string literals (they just use curly braces instead of double quotes at one or both ends), and highlight the inner expressions the same as if they weren&#x27;t surrounded by such literals.</div><br/><div id="42031178" class="c"><input type="checkbox" id="c-42031178" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42030975">parent</a><span>|</span><a href="#42027840">next</a><span>|</span><label class="collapse" for="c-42031178">[-]</label><label class="expand" for="c-42031178">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s exactly the point that this is one token.<p>Fair enough. The point, as you have acknowledged, being that unlike + you have to treat { specially for balancing (and separately from the “).<p>&gt; The fact that people tend to think of `{some_variable}` as an entity is sort-of an illusion.<p>I guess. I just don’t know what being an illusion means formally. It’s not an illusion to the person that has to implement the state machine that balances the delimiters.<p>&gt; You would highlight the `&quot;...{`, `}...{`, and `}...&quot;` parts like normal string literals (they just use curly braces instead of double quotes at one or both ends), and highlight the inner expressions the same as if they weren&#x27;t surrounded by such literals<p>Emacs does it this way FWIW. But I’m not sure how important it is to dictate that the brace can’t be a different color.<p>In any event, I can agree your design is valid (Kotlin works this way), but I don’t necessarily agree it is any more valid than say how Python does it where there can format specifiers, implicit conversion to string is performed whereas not with concatenation. I’m not seeing the clear definitive advantage of interpolated strings being an equivalent to concatenation vs some other type of method call.<p>The other detail is order of evaluation or sequencing. String concat may behave differently. Not sure I agree it is wrong, because at the end of the day it is distinct looking syntax. Illusion or not, it looks like a neatly enclosed expression, and concatenation looks like something else. That they might parse, evaluate or behave different isn&#x27;t unreasonable.</div><br/></div></div></div></div></div></div><div id="42027840" class="c"><input type="checkbox" id="c-42027840" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027690">parent</a><span>|</span><a href="#42028345">prev</a><span>|</span><a href="#42030855">next</a><span>|</span><label class="collapse" for="c-42027840">[-]</label><label class="expand" for="c-42027840">[11 more]</label></div><br/><div class="children"><div class="content">Indeed in some of the listed languages you can nest it like that, but in others (e.g. Python) you can&#x27;t. I would guess they deliberately don&#x27;t want to enable that and it&#x27;s not a problem in their parser or something.</div><br/><div id="42027980" class="c"><input type="checkbox" id="c-42027980" checked=""/><div class="controls bullet"><span class="by">Tarean</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027840">parent</a><span>|</span><a href="#42027969">next</a><span>|</span><label class="collapse" for="c-42027980">[-]</label><label class="expand" for="c-42027980">[3 more]</label></div><br/><div class="children"><div class="content">As of python 3.6 you can nest fstrings. Not all formatters and highlighters have caught up, though.<p>Which is fun, because correct highlighting depends on language version. Haskell has similar problems where different compiler flags require different parsers. Close enough is sufficient for syntax highlighting, though.<p>Python is also a bit weird because it calls the format methods, so objects can intercept and react to the format specifiers in the f-string while being formatted.</div><br/><div id="42028586" class="c"><input type="checkbox" id="c-42028586" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027980">parent</a><span>|</span><a href="#42027969">next</a><span>|</span><label class="collapse" for="c-42028586">[-]</label><label class="expand" for="c-42028586">[2 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t mean nested f-strings. I mean this is a syntax error:<p><pre><code>    &gt;&gt;&gt; print(f&quot;foo {&quot;bar&quot;}&quot;)
    SyntaxError: f-string: expecting &#x27;}&#x27;
</code></pre>
Only this works:<p><pre><code>    &gt;&gt;&gt; print(f&quot;foo {&#x27;bar&#x27;}&quot;)
    foo bar</code></pre></div><br/><div id="42029015" class="c"><input type="checkbox" id="c-42029015" checked=""/><div class="controls bullet"><span class="by">pdw</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028586">parent</a><span>|</span><a href="#42027969">next</a><span>|</span><label class="collapse" for="c-42029015">[-]</label><label class="expand" for="c-42029015">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re using an old Python version. On recent versions, it&#x27;s perfectly fine:<p><pre><code>    Python 3.12.7 (main, Oct  3 2024, 15:15:22) [GCC 14.2.0] on linux
    Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
    &gt;&gt;&gt; print(f&quot;foo {&quot;bar&quot;}&quot;)
    foo bar</code></pre></div><br/></div></div></div></div></div></div><div id="42027969" class="c"><input type="checkbox" id="c-42027969" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027840">parent</a><span>|</span><a href="#42027980">prev</a><span>|</span><a href="#42030855">next</a><span>|</span><label class="collapse" for="c-42027969">[-]</label><label class="expand" for="c-42027969">[7 more]</label></div><br/><div class="children"><div class="content">Even when nesting is disallowed, my point is that I find it preferable to not view it (and syntax-highlight it) as a “special string” with embedded magic, but as multiple string literals with just different delimiters that allow omitting the explicit concatenation operator, and normal expressions interspersed in between. I think it’s important to realize that it is really just very simple syntactic sugar for normal string concatenation.</div><br/><div id="42030916" class="c"><input type="checkbox" id="c-42030916" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027969">parent</a><span>|</span><a href="#42030376">next</a><span>|</span><label class="collapse" for="c-42030916">[-]</label><label class="expand" for="c-42030916">[2 more]</label></div><br/><div class="children"><div class="content">If it’s treated strictly as simple concatenation syntactic sugar then you are allowing something like print(“foo { func() );
Which seems janky af.<p>&gt;  just very simple syntactic sugar for normal string concatenation.<p>Maybe. There’s also possibly a string conversion. It seems reasonable to want to disallow implicit string conversion in a concatenation operator context (especially if overloading +) while allowing it in the interpolation case.</div><br/><div id="42031021" class="c"><input type="checkbox" id="c-42031021" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42030916">parent</a><span>|</span><a href="#42030376">next</a><span>|</span><label class="collapse" for="c-42031021">[-]</label><label class="expand" for="c-42031021">[1 more]</label></div><br/><div class="children"><div class="content">I failed to mention the balancing requirement, that should of course remain. But it&#x27;s an artificial requirement, so to speak, that is merely there to double-check the programmer&#x27;s intent. The compiler&#x2F;parser wouldn&#x27;t actually care (unlike for an arithmetic expression with unbalanced parentheses, or scope blocks with unbalanced braces), the condition is only checked for the programmer&#x27;s benefit.<p>&gt; here’s also possibly a string conversion. It seems reasonable to want to disallow implicit string conversion in a concatenation operator context (especially if overloading +) while allowing it in the interpolation case.<p>Many languages have a string contenation operator that does implicit conversion to string, while still having a string interpolation syntax like the above. It&#x27;s kind of my point that both are much more similar to each other than many people seem to realize.</div><br/></div></div></div></div><div id="42030376" class="c"><input type="checkbox" id="c-42030376" checked=""/><div class="controls bullet"><span class="by">Timwi</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027969">parent</a><span>|</span><a href="#42030916">prev</a><span>|</span><a href="#42030855">next</a><span>|</span><label class="collapse" for="c-42030376">[-]</label><label class="expand" for="c-42030376">[4 more]</label></div><br/><div class="children"><div class="content">While you&#x27;re conceptually right, in practice I think it bears mentioning that in C# the two syntaxes compile differently. This is because C#’s target platform, the .NET Framework, has always had a function called `string.Format` that lets you write this:<p><pre><code>  var str = string.Format(&quot;{0} is {1} years old.&quot;, name, age);
</code></pre>
When interpolated strings were introduced later, it was natural to have them compile to this instead of concatenation.</div><br/><div id="42031038" class="c"><input type="checkbox" id="c-42031038" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42030376">parent</a><span>|</span><a href="#42030855">next</a><span>|</span><label class="collapse" for="c-42031038">[-]</label><label class="expand" for="c-42031038">[3 more]</label></div><br/><div class="children"><div class="content">There&#x27;s no reason in principle why<p><pre><code>    name + &quot; is &quot; + age + &quot; years old.&quot;
</code></pre>
couldn&#x27;t compile to exactly the same. (Other than maybe `string.Format` having some additional customizable behavior, I don&#x27;t know C# that well.)</div><br/><div id="42031786" class="c"><input type="checkbox" id="c-42031786" checked=""/><div class="controls bullet"><span class="by">ygra</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42031038">parent</a><span>|</span><a href="#42031273">next</a><span>|</span><label class="collapse" for="c-42031786">[-]</label><label class="expand" for="c-42031786">[1 more]</label></div><br/><div class="children"><div class="content">When not using the format specifiers or alignment it will indeed compile to just string.Concat (which is also what the + operator for strings compiles to). Similar to C compilers choosing to call pits instead of printf if there is nothing to be formatted.</div><br/></div></div><div id="42031273" class="c"><input type="checkbox" id="c-42031273" checked=""/><div class="controls bullet"><span class="by">epcoa</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42031038">parent</a><span>|</span><a href="#42031786">prev</a><span>|</span><a href="#42030855">next</a><span>|</span><label class="collapse" for="c-42031273">[-]</label><label class="expand" for="c-42031273">[1 more]</label></div><br/><div class="children"><div class="content">Like python, and Rust with the format! macro (which doesn&#x27;t even support arbitrary expressions), C# the full syntax for interpolated&#x2F;formatted strings is this: {&lt;interpolationExpression&gt;[,&lt;alignment&gt;][:&lt;formatString&gt;]}, ie there is more going on then just a simple wrapper around concat or StringBuilder.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42030855" class="c"><input type="checkbox" id="c-42030855" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42027690">prev</a><span>|</span><a href="#42027808">next</a><span>|</span><label class="collapse" for="c-42030855">[-]</label><label class="expand" for="c-42030855">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  Make :)        echo &quot;$(x) plus $(y) equals $(shell echo &quot;$x+$y&quot; | bc)&quot;
</code></pre>
I&#x27;m guessing this is the reason for the :) but to be clear for anyone else:  Make is only doing half of the work, whatever comes after &quot;shell&quot; is being passed to another executable, then make captures its stdout and interpolates that.  The other executable is &quot;sh&quot; by default but can be changed to whatever.</div><br/></div></div><div id="42027808" class="c"><input type="checkbox" id="c-42027808" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42030855">prev</a><span>|</span><a href="#42029443">next</a><span>|</span><label class="collapse" for="c-42027808">[-]</label><label class="expand" for="c-42027808">[7 more]</label></div><br/><div class="children"><div class="content">Is this a bash-ism?<p><pre><code>    &quot;$x plus $y equals $((x+y))&quot;</code></pre></div><br/><div id="42028408" class="c"><input type="checkbox" id="c-42028408" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027808">parent</a><span>|</span><a href="#42029112">next</a><span>|</span><label class="collapse" for="c-42028408">[-]</label><label class="expand" for="c-42028408">[1 more]</label></div><br/><div class="children"><div class="content">No, it&#x27;s portable shell syntax.</div><br/></div></div><div id="42029112" class="c"><input type="checkbox" id="c-42029112" checked=""/><div class="controls bullet"><span class="by">LukeShu</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027808">parent</a><span>|</span><a href="#42028408">prev</a><span>|</span><a href="#42028388">next</a><span>|</span><label class="collapse" for="c-42029112">[-]</label><label class="expand" for="c-42029112">[1 more]</label></div><br/><div class="children"><div class="content">&quot;$((&quot; arithmetic expansion is POSIX (XCU 2.6.4 &quot;Arithmetic Expansion&quot;).<p>But if I&#x27;m not mistaken, it originated in csh.</div><br/></div></div><div id="42028388" class="c"><input type="checkbox" id="c-42028388" checked=""/><div class="controls bullet"><span class="by">jonahx</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027808">parent</a><span>|</span><a href="#42029112">prev</a><span>|</span><a href="#42029301">next</a><span>|</span><label class="collapse" for="c-42028388">[-]</label><label class="expand" for="c-42028388">[3 more]</label></div><br/><div class="children"><div class="content">This works in &quot;sh&quot; as well for me.</div><br/><div id="42028556" class="c"><input type="checkbox" id="c-42028556" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028388">parent</a><span>|</span><a href="#42029301">next</a><span>|</span><label class="collapse" for="c-42028556">[-]</label><label class="expand" for="c-42028556">[2 more]</label></div><br/><div class="children"><div class="content">On some systems (like on mine) sh is just a link to bash, so I couldn&#x27;t test it.</div><br/><div id="42030865" class="c"><input type="checkbox" id="c-42030865" checked=""/><div class="controls bullet"><span class="by">Izkata</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42028556">parent</a><span>|</span><a href="#42029301">next</a><span>|</span><label class="collapse" for="c-42030865">[-]</label><label class="expand" for="c-42030865">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t bash supposed to act like sh when executed with that name?</div><br/></div></div></div></div></div></div><div id="42029301" class="c"><input type="checkbox" id="c-42029301" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#42026212">root</a><span>|</span><a href="#42027808">parent</a><span>|</span><a href="#42028388">prev</a><span>|</span><a href="#42029443">next</a><span>|</span><label class="collapse" for="c-42029301">[-]</label><label class="expand" for="c-42029301">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is this a bash-ism?<p>&gt; &quot;$x plus $y equals $((x+y))&quot;<p>No, it is specified in POSIX: <a href="https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;V3_chap02.html#tag_18_06_04" rel="nofollow">https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;9699919799&#x2F;utilities&#x2F;V...</a></div><br/></div></div></div></div><div id="42029443" class="c"><input type="checkbox" id="c-42029443" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42027808">prev</a><span>|</span><a href="#42029695">next</a><span>|</span><label class="collapse" for="c-42029443">[-]</label><label class="expand" for="c-42029443">[1 more]</label></div><br/><div class="children"><div class="content">VHDL<p>There is a record constructor syntax in VHDL using attribute invocation syntax: RECORD_TYPE&#x27;(field1expr, ..., fieldNexpr). This means that if your record has a first field a subtype of a character type, you can get record construction expression like this one: REC&#x27;(&#x27;0&#x27;,1,&quot;10101&quot;).<p>Good luck distinguishing between &#x27;(&#x27; as a character literal and &quot;&#x27;&quot;, &quot;(&quot; and &quot;&#x27;0&#x27;&quot; at lexical level.<p>Haskell.<p>Haskell has context-free syntax for bracketed (&quot;{-&quot; ... &quot;-}&quot;) comments. Lexer has to keep bracketed comment syntax balanced (for every &quot;{-&quot; there should be accompanying &quot;-}&quot; somewhere).</div><br/></div></div><div id="42029695" class="c"><input type="checkbox" id="c-42029695" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42029443">prev</a><span>|</span><a href="#42029185">next</a><span>|</span><label class="collapse" for="c-42029695">[-]</label><label class="expand" for="c-42029695">[1 more]</label></div><br/><div class="children"><div class="content">Shell &quot;$x plus $y equals $((x+y))&quot;<p>Shell &quot;$x plus $y equals $((expr $x + $y))&quot;</div><br/></div></div><div id="42029185" class="c"><input type="checkbox" id="c-42029185" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42029695">prev</a><span>|</span><a href="#42028462">next</a><span>|</span><label class="collapse" for="c-42029185">[-]</label><label class="expand" for="c-42029185">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Many more languages support that:<p>Julia as well:<p><pre><code>    Julia    &quot;$x plus $y equals $(x+y)&quot;</code></pre></div><br/></div></div><div id="42028462" class="c"><input type="checkbox" id="c-42028462" checked=""/><div class="controls bullet"><span class="by">therein</span><span>|</span><a href="#42026212">parent</a><span>|</span><a href="#42029185">prev</a><span>|</span><a href="#42026277">next</a><span>|</span><label class="collapse" for="c-42028462">[-]</label><label class="expand" for="c-42028462">[1 more]</label></div><br/><div class="children"><div class="content">&gt; PostgreSQL has the very convenient dollar-quoted strings<p>I did not know that. Today I learned.</div><br/></div></div></div></div><div id="42026136" class="c"><input type="checkbox" id="c-42026136" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42026212">prev</a><span>|</span><a href="#42026050">next</a><span>|</span><label class="collapse" for="c-42026136">[-]</label><label class="expand" for="c-42026136">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Of all the languages, I&#x27;ve saved the best for last, which is Ruby. Now here&#x27;s a language whose syntax evades all attempts at understanding.<p>TeX with its arbitrarily reprogrammable lexer: how adorable</div><br/><div id="42026851" class="c"><input type="checkbox" id="c-42026851" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42026136">parent</a><span>|</span><a href="#42026050">next</a><span>|</span><label class="collapse" for="c-42026851">[-]</label><label class="expand" for="c-42026851">[2 more]</label></div><br/><div class="children"><div class="content">Lisp reader macros allow you to program its lexer too.</div><br/><div id="42028016" class="c"><input type="checkbox" id="c-42028016" checked=""/><div class="controls bullet"><span class="by">skydhash</span><span>|</span><a href="#42026136">root</a><span>|</span><a href="#42026851">parent</a><span>|</span><a href="#42026050">next</a><span>|</span><label class="collapse" for="c-42028016">[-]</label><label class="expand" for="c-42028016">[1 more]</label></div><br/><div class="children"><div class="content">You can basically define a new language with a few lines of code in Racket.</div><br/></div></div></div></div></div></div><div id="42026050" class="c"><input type="checkbox" id="c-42026050" checked=""/><div class="controls bullet"><span class="by">skitter</span><span>|</span><a href="#42026136">prev</a><span>|</span><a href="#42026160">next</a><span>|</span><label class="collapse" for="c-42026050">[-]</label><label class="expand" for="c-42026050">[6 more]</label></div><br/><div class="children"><div class="content">Another syntax oddity (not mentioned here) that breaks most highlighters: In Java, unicode escapes can be anywhere, not just in strings. For example, the following is a valid class:<p><pre><code>    class Foo\u007b}
</code></pre>
and this assert will not trigger:<p><pre><code>    assert
        &#x2F;&#x2F; String literals can have unicode escapes like \u000A!
        &quot;Hello World&quot;.equals(&quot;\u00E4&quot;);</code></pre></div><br/><div id="42026781" class="c"><input type="checkbox" id="c-42026781" checked=""/><div class="controls bullet"><span class="by">mistercow</span><span>|</span><a href="#42026050">parent</a><span>|</span><a href="#42026431">next</a><span>|</span><label class="collapse" for="c-42026781">[-]</label><label class="expand" for="c-42026781">[1 more]</label></div><br/><div class="children"><div class="content">I also argue that failing to syntax highlight this correctly is a security issue. You can terminate block comments with Unicode escapes, so if you wanted to hide some malicious code in a Java source file, you just need an excuse for there to be a block of Unicode escapes in a comment. A dev who doesn’t know about this quirk is likely to just skip over it, assuming it’s commented out.</div><br/></div></div><div id="42026431" class="c"><input type="checkbox" id="c-42026431" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#42026050">parent</a><span>|</span><a href="#42026781">prev</a><span>|</span><a href="#42026160">next</a><span>|</span><label class="collapse" for="c-42026431">[-]</label><label class="expand" for="c-42026431">[4 more]</label></div><br/><div class="children"><div class="content">I have never seen this in Java! Is there any use cases where it could be useful?</div><br/><div id="42026516" class="c"><input type="checkbox" id="c-42026516" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#42026050">root</a><span>|</span><a href="#42026431">parent</a><span>|</span><a href="#42028178">next</a><span>|</span><label class="collapse" for="c-42026516">[-]</label><label class="expand" for="c-42026516">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about usefulness but it does let us write identifiers using Unicode characters.  For example:<p><pre><code>  public class Foo {
      public static void main(String[] args) {
          double \u03c0 = 3.14159265;
          System.out.println(&quot;\u03c0 = &quot; + \u03c0);
      }
  }
</code></pre>
Output:<p><pre><code>  $ javac Foo.java &amp;&amp; java Foo
  π = 3.14159265
</code></pre>
Of course, nowadays we can simply write this with any decent editor:<p><pre><code>  public class Foo {
      public static void main(String[] args) {
          double π = 3.14159265;
          System.out.println(&quot;π = &quot; + π);
      }
  }
</code></pre>
Support for Unicode escape sequences is a result of how the Java Language Specification (JLS) defines InputCharacter.  Quoting from Section 3.4 of JLS &lt;<a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jls&#x2F;se23&#x2F;jls23.pdf" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;jls&#x2F;se23&#x2F;jls23.pdf</a>&gt;:<p><pre><code>  InputCharacter:
    UnicodeInputCharacter but not CR or LF
</code></pre>
UnicodeInputCharacter is defined as the following in section 3.3:<p><pre><code>  UnicodeInputCharacter:
    UnicodeEscape
    RawInputCharacter

  UnicodeEscape:
    \ UnicodeMarker HexDigit HexDigit HexDigit HexDigit

  UnicodeMarker:
    u {u}

  HexDigit:
    (one of)
    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F

  RawInputCharacter:
    any Unicode character
</code></pre>
As a result the lexical analyser honours Unicode escape sequences absolutely anywhere in the program text.  For example, this is a valid Java program:<p><pre><code>  public class Bar {
      public static void \u006d\u0061\u0069\u006e(String[] args) {
          System.out.println(&quot;hello, world&quot;);
      }
  }
</code></pre>
Here is the output:<p><pre><code>  $ javac Bar.java &amp;&amp; java Bar
  hello, world
</code></pre>
However, this is an incorrect Java program:<p><pre><code>  public class Baz {
      &#x2F;&#x2F; This comment contains \u6d.
      public static void main(String[] args) {
          System.out.println(&quot;hello, world&quot;);
      }
  }
</code></pre>
Here is the error:<p><pre><code>  $ javac Baz.java
  Baz.java:2: error: illegal unicode escape
      &#x2F;&#x2F; This comment contains \u6d.
                                   ^
  1 error
</code></pre>
Yes, this is an error even if the illegal Unicode escape sequence occurs in a comment!</div><br/><div id="42027484" class="c"><input type="checkbox" id="c-42027484" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#42026050">root</a><span>|</span><a href="#42026516">parent</a><span>|</span><a href="#42028178">next</a><span>|</span><label class="collapse" for="c-42027484">[-]</label><label class="expand" for="c-42027484">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if full unicode range was accepted because some companies are writing code in non-english.</div><br/></div></div></div></div><div id="42028178" class="c"><input type="checkbox" id="c-42028178" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026050">root</a><span>|</span><a href="#42026431">parent</a><span>|</span><a href="#42026516">prev</a><span>|</span><a href="#42026160">next</a><span>|</span><label class="collapse" for="c-42028178">[-]</label><label class="expand" for="c-42028178">[1 more]</label></div><br/><div class="children"><div class="content">Javac uses the platform encoding [0] by default to interpret Java source files. This means that Java source code files are inherently non-portable. When Java was first developed (and for a long time after), this was the default situation for any kind of plain text files. The escape sequence syntax allows to transform [1] Java source code into a portable (that is, ASCII-only) representation that is completely equivalent to the original, and also to convert it back to any platform encoding.<p>Source control clients could apply this automatically upon checkin&#x2F;checkout, so that clients with different platform encodings can work together. Alternatively, IDEs could do this when saving&#x2F;loading Java source files. That never quite caught on, and the general advice was to stick to ASCII, at least outside comments.<p>[0] Since JDK 18, the default encoding defaults to UTF-8. This probably also extends to <i>javac</i>, though I haven’t verified it.<p>[1] <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;tools&#x2F;windows&#x2F;native2ascii.html" rel="nofollow">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;tools&#x2F;window...</a></div><br/></div></div></div></div></div></div><div id="42026160" class="c"><input type="checkbox" id="c-42026160" checked=""/><div class="controls bullet"><span class="by">irdc</span><span>|</span><a href="#42026050">prev</a><span>|</span><a href="#42028425">next</a><span>|</span><label class="collapse" for="c-42026160">[-]</label><label class="expand" for="c-42026160">[4 more]</label></div><br/><div class="children"><div class="content">I’d be interested to see a re-usable implementation of joe&#x27;s[0] syntax highlighting.[1] The format is powerful enough to allow for the proper highlighting of Python f-strings.[2]<p>0. <a href="https:&#x2F;&#x2F;joe-editor.sf.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;joe-editor.sf.net&#x2F;</a><p>1. <a href="https:&#x2F;&#x2F;github.com&#x2F;cmur2&#x2F;joe-syntax&#x2F;blob&#x2F;joe-4.4&#x2F;misc&#x2F;HowItWorks.md">https:&#x2F;&#x2F;github.com&#x2F;cmur2&#x2F;joe-syntax&#x2F;blob&#x2F;joe-4.4&#x2F;misc&#x2F;HowItW...</a><p>2. <a href="https:&#x2F;&#x2F;gist.github.com&#x2F;irdc&#x2F;6188f11b1e699d615ce2520f03f1d0da" rel="nofollow">https:&#x2F;&#x2F;gist.github.com&#x2F;irdc&#x2F;6188f11b1e699d615ce2520f03f1d0d...</a></div><br/><div id="42026294" class="c"><input type="checkbox" id="c-42026294" checked=""/><div class="controls bullet"><span class="by">pama</span><span>|</span><a href="#42026160">parent</a><span>|</span><a href="#42028425">next</a><span>|</span><label class="collapse" for="c-42026294">[-]</label><label class="expand" for="c-42026294">[3 more]</label></div><br/><div class="children"><div class="content">Interestingly, python f-strings changed their syntax at version 3.12, so highlighting should depend on the version.</div><br/><div id="42026340" class="c"><input type="checkbox" id="c-42026340" checked=""/><div class="controls bullet"><span class="by">irdc</span><span>|</span><a href="#42026160">root</a><span>|</span><a href="#42026294">parent</a><span>|</span><a href="#42028425">next</a><span>|</span><label class="collapse" for="c-42026340">[-]</label><label class="expand" for="c-42026340">[2 more]</label></div><br/><div class="children"><div class="content">It’s just that nesting them arbitrarily is now allowed, right? That shouldn’t matter much for a mere syntax highlighter then. And one could even argue that code that relies on this too much is not really for human consumption.</div><br/><div id="42026410" class="c"><input type="checkbox" id="c-42026410" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42026160">root</a><span>|</span><a href="#42026340">parent</a><span>|</span><a href="#42028425">next</a><span>|</span><label class="collapse" for="c-42026410">[-]</label><label class="expand" for="c-42026410">[1 more]</label></div><br/><div class="children"><div class="content">Also, you can now use the same quote character that encloses an f-string within the {} expressions. That could make them harder to tokenize, because it makes it harder to recognise the end of the string.</div><br/></div></div></div></div></div></div></div></div><div id="42028425" class="c"><input type="checkbox" id="c-42028425" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#42026160">prev</a><span>|</span><a href="#42026421">next</a><span>|</span><label class="collapse" for="c-42028425">[-]</label><label class="expand" for="c-42028425">[5 more]</label></div><br/><div class="children"><div class="content">Author hasn’t tried to highlight TeX. Which is good for their mental health, I suppose, as it’s generally impossible to fully highlight TeX without interpreting it.<p>Even parsing is not enough, as it’s possible to redefine what each character does. You can make it do things like “and now K means { and C means }”.<p>Yes, you can find papers on arXiv that use this god-forsaken feature.</div><br/><div id="42028460" class="c"><input type="checkbox" id="c-42028460" checked=""/><div class="controls bullet"><span class="by">jart</span><span>|</span><a href="#42028425">parent</a><span>|</span><a href="#42029398">next</a><span>|</span><label class="collapse" for="c-42028460">[-]</label><label class="expand" for="c-42028460">[2 more]</label></div><br/><div class="children"><div class="content">I wrote <a href="https:&#x2F;&#x2F;github.com&#x2F;Mozilla-Ocho&#x2F;llamafile&#x2F;blob&#x2F;main&#x2F;llamafile&#x2F;highlight_tex.cpp">https:&#x2F;&#x2F;github.com&#x2F;Mozilla-Ocho&#x2F;llamafile&#x2F;blob&#x2F;main&#x2F;llamafil...</a> and it does a reasonable job highlighting without breaking for all the .tex files I could find on my hard drive. My goal is to hopefully cover 99.9% of real world usage, since that&#x27;ll likely cover everything an LLM might output. Esoteric syntax also usually isn&#x27;t a problem, so long as it doesn&#x27;t cause strings and comments to extend forever, eclipsing the rest of the source code in a file.</div><br/><div id="42031229" class="c"><input type="checkbox" id="c-42031229" checked=""/><div class="controls bullet"><span class="by">murkt</span><span>|</span><a href="#42028425">root</a><span>|</span><a href="#42028460">parent</a><span>|</span><a href="#42029398">next</a><span>|</span><label class="collapse" for="c-42031229">[-]</label><label class="expand" for="c-42031229">[1 more]</label></div><br/><div class="children"><div class="content">Yes, when goal isn’t to support 100% of all the weird stuff, then it’s orders of magnitude easier!</div><br/></div></div></div></div><div id="42029398" class="c"><input type="checkbox" id="c-42029398" checked=""/><div class="controls bullet"><span class="by">bobbylarrybobby</span><span>|</span><a href="#42028425">parent</a><span>|</span><a href="#42028460">prev</a><span>|</span><a href="#42028772">next</a><span>|</span><label class="collapse" for="c-42029398">[-]</label><label class="expand" for="c-42029398">[1 more]</label></div><br/><div class="children"><div class="content">I couldn&#x27;t believe it when I learned that \makeatletter does not “make (something) at a letter (character)” but rather “treats the &#x27;@&#x27; character as a letter when parsing”.</div><br/></div></div><div id="42028772" class="c"><input type="checkbox" id="c-42028772" checked=""/><div class="controls bullet"><span class="by">nathell</span><span>|</span><a href="#42028425">parent</a><span>|</span><a href="#42029398">prev</a><span>|</span><a href="#42026421">next</a><span>|</span><label class="collapse" for="c-42028772">[-]</label><label class="expand" for="c-42028772">[1 more]</label></div><br/><div class="children"><div class="content">Same with Common Lisp (you can redefine the read table), although that’s likely abused less often on arXiv.</div><br/></div></div></div></div><div id="42026421" class="c"><input type="checkbox" id="c-42026421" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#42028425">prev</a><span>|</span><a href="#42026417">next</a><span>|</span><label class="collapse" for="c-42026421">[-]</label><label class="expand" for="c-42026421">[16 more]</label></div><br/><div class="children"><div class="content">&gt; Every C programmers (sic) knows you can&#x27;t embed a multi-line comment in a multi-line comment.<p>And every Standard ML programmer might find this to be a surprising limitation.  The following is a valid Standard ML program:<p><pre><code>  (* (* Nested (**) *) comment *)
  val _ = print &quot;hello, world\n&quot;
</code></pre>
Here is the output:<p><pre><code>  $ sml &lt; hello.sml           
  Standard ML of New Jersey (64-bit) v110.99.5 [built: Thu Mar 14 17:56:03 2024]
  - = hello, world

  $ mlton hello.sml &amp;&amp; .&#x2F;hello
  hello, world
</code></pre>
Given how C was considered one of the &quot;expressive&quot; languages when it arrived, it&#x27;s curious that nested comments were never part of the language.</div><br/><div id="42026503" class="c"><input type="checkbox" id="c-42026503" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42026421">parent</a><span>|</span><a href="#42027739">next</a><span>|</span><label class="collapse" for="c-42026503">[-]</label><label class="expand" for="c-42026503">[8 more]</label></div><br/><div class="children"><div class="content">There are 3 things I find funny about that comment: ML didn’t have single-line comments, so same level of surprising limitation. I’ve never heard someone refer to C as “expressive”, but maybe it was in 1972 when compared to assembly. And what bearing does the comment syntax have on the expressiveness of a language? I would argue absolutely none at all, by <i>definition</i>. :P</div><br/><div id="42026931" class="c"><input type="checkbox" id="c-42026931" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42026503">parent</a><span>|</span><a href="#42027739">next</a><span>|</span><label class="collapse" for="c-42026931">[-]</label><label class="expand" for="c-42026931">[7 more]</label></div><br/><div class="children"><div class="content">&gt; ML didn’t have single-line comments, so same level of surprising limitation.<p>It is not quite clear to me why the lack of single-line comments is such a surprising limitation.  After all, a single-line block comment can easily serve as a substitute. However, there is no straightforward workaround for the lack of nested block comments.<p>&gt; I’ve never heard someone refer to C as “expressive”, but maybe it was in 1972 when compared to assembly.<p>I was thinking of Fortran in this context.  For instance, Fortran 77 lacked function pointers and offered a limited set of control flow structures, along with cumbersome support for recursion.  I know Fortran, with its native support for multidimensional arrays, excelled in numerical and scientific computing but C quickly became the preferred language for general purpose computing.<p>While very few today would consider C a pinnacle of expressiveness, when I was learning C, the landscape of mainstream programming languages was much more restricted.  In fact, the preface to the first edition of K&amp;R notes the following:<p><i>&quot;In our experience, C has proven to be a pleasant, expressive and versatile language for a wide
variety of programs.&quot;</i><p>C, Pascal, etc. stood out as some of the few mainstream programming languages that offered a reasonable level of expressiveness.  Of course, Lisp was exceptionally expressive in its own right, but it wasn&#x27;t always the best fit for certain applications or environments.<p>&gt; And what bearing does the comment syntax have on the expressiveness of a language?<p>Nothing at all.  I agree.  The expressiveness of C comes from its grammar, which the language parser handles.  Support for nested comments, in the context of C, is a concern for the lexer, so indeed one does not directly influence the other.  However, it is still curious that a language with such a sophisticated grammar and parser could not allocate a bit of its complexity budget to support nested comments in its lexer.  This is a trivial matter, I know, but I still couldn&#x27;t help but wonder about it.</div><br/><div id="42027636" class="c"><input type="checkbox" id="c-42027636" checked=""/><div class="controls bullet"><span class="by">pklausler</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42026931">parent</a><span>|</span><a href="#42027031">next</a><span>|</span><label class="collapse" for="c-42027636">[-]</label><label class="expand" for="c-42027636">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Fortran 77 lacked function pointers<p>But we did have dummy procedures, which covered one of the important use cases directly, and which could be abused to fake function&#x2F;subroutine pointers stored in data.</div><br/></div></div><div id="42027031" class="c"><input type="checkbox" id="c-42027031" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42026931">parent</a><span>|</span><a href="#42027636">prev</a><span>|</span><a href="#42027739">next</a><span>|</span><label class="collapse" for="c-42027031">[-]</label><label class="expand" for="c-42027031">[5 more]</label></div><br/><div class="children"><div class="content">Fair enough. From my perspective, lack of single line comments is a little surprising because most other languages had it at the time (1973, when ML was introduced). Lack of nested comments doesn’t seem surprising, because it isn’t an important feature for a language, and because most other languages did not have it at the time (1972, when C was introduced).<p>I can imagine both pro and con arguments for supporting nested comments, but regardless of what I think, C certainly could have added support for nested comments at any time, and hasn’t, which suggests that there isn’t sufficient need for it. That might be the entire explanation: not even worth a little complexity.</div><br/><div id="42029044" class="c"><input type="checkbox" id="c-42029044" checked=""/><div class="controls bullet"><span class="by">susam</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027031">parent</a><span>|</span><a href="#42027332">next</a><span>|</span><label class="collapse" for="c-42029044">[-]</label><label class="expand" for="c-42029044">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C certainly could have added support for nested comments at any time<p>After C89 was ratified, adding nested comments to C would have risked breaking existing code.  For instance, this is a valid program in C89:<p><pre><code>  #include &lt;stdio.h&gt;

  int main() {
      &#x2F;* &#x2F;* Comment *&#x2F;
      printf(&quot;hello *&#x2F; world&quot;);
      return 0;
  }
</code></pre>
However, if a later C standard were to introduce nested comments, it would break the above program because then the following part of the program would be recognised as a comment:<p><pre><code>      &#x2F;* &#x2F;* Comment *&#x2F;
      printf(&quot;hello *&#x2F;
</code></pre>
The above text would be ignored.  Then the compiler would encounter the following:<p><pre><code>      world&quot;);
</code></pre>
This would lead to errors like <i>undeclared identifier &#x27;world&#x27;</i>, <i>missing terminating &quot; character</i>, etc.</div><br/></div></div><div id="42027332" class="c"><input type="checkbox" id="c-42027332" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027031">parent</a><span>|</span><a href="#42029044">prev</a><span>|</span><a href="#42027739">next</a><span>|</span><label class="collapse" for="c-42027332">[-]</label><label class="expand" for="c-42027332">[3 more]</label></div><br/><div class="children"><div class="content">AFAIK, C didn&#x27;t get single line comments until C99.  They were a C++ feature originally.</div><br/><div id="42027403" class="c"><input type="checkbox" id="c-42027403" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027332">parent</a><span>|</span><a href="#42027739">next</a><span>|</span><label class="collapse" for="c-42027403">[-]</label><label class="expand" for="c-42027403">[2 more]</label></div><br/><div class="children"><div class="content">Oh wow, I didn’t remember that, and I did start writing C before 99. I stand corrected. I guess that is a little surprising. ;)<p>Is true that many languages had single line comments? Maybe I’m forgetting more, but I remember everything else having single line comments… asm, basic, shell. I used Pascal in the 80s and apparently forgot it didn’t have line comments either?</div><br/><div id="42027458" class="c"><input type="checkbox" id="c-42027458" checked=""/><div class="controls bullet"><span class="by">masfuerte</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027403">parent</a><span>|</span><a href="#42027739">next</a><span>|</span><label class="collapse" for="c-42027458">[-]</label><label class="expand" for="c-42027458">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s my recollection, that most languages had single line comments.  Some had multi-line comments but C++ is the first I remember having syntaxes for both.  That said, I&#x27;m not terribly familiar with pre-80s stuff.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="42027739" class="c"><input type="checkbox" id="c-42027739" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026421">parent</a><span>|</span><a href="#42026503">prev</a><span>|</span><a href="#42026835">next</a><span>|</span><label class="collapse" for="c-42027739">[-]</label><label class="expand" for="c-42027739">[1 more]</label></div><br/><div class="children"><div class="content">Lexing nested comments requires maintaining a stack (or at least a nesting-level counter). That wasn’t traditionally seen as being within the realm of lexical analysis, which would only use a finite-state automaton, like regular expressions.</div><br/></div></div><div id="42026835" class="c"><input type="checkbox" id="c-42026835" checked=""/><div class="controls bullet"><span class="by">gsliepen</span><span>|</span><a href="#42026421">parent</a><span>|</span><a href="#42027739">prev</a><span>|</span><a href="#42027529">next</a><span>|</span><label class="collapse" for="c-42026835">[-]</label><label class="expand" for="c-42026835">[5 more]</label></div><br/><div class="children"><div class="content">Well there is one way to nest comments in C, and that&#x27;s by using #if 0:<p><pre><code>  #if 0
  This is a
  #if 0
  nested comment!
  #endif
  #endif</code></pre></div><br/><div id="42027100" class="c"><input type="checkbox" id="c-42027100" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42026835">parent</a><span>|</span><a href="#42027529">next</a><span>|</span><label class="collapse" for="c-42027100">[-]</label><label class="expand" for="c-42027100">[4 more]</label></div><br/><div class="children"><div class="content">Except that text inside #if 0 still has to lex correctly.<p>(unifdef has some evil code to support using C-style preprocessor directives with non-C source, which mostly boils down to ignoring comments. I don’t recommend it!)</div><br/><div id="42027435" class="c"><input type="checkbox" id="c-42027435" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027100">parent</a><span>|</span><a href="#42027529">next</a><span>|</span><label class="collapse" for="c-42027435">[-]</label><label class="expand" for="c-42027435">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Except that text inside #if 0 still has to lex correctly.<p>Are you sure? I just tried on godbolt and that’s not true with gcc 14.2. I’ve definitely put syntax errors intentionally into #if 0 blocks and had it compile. Are you thinking of some older version or something? I thought the pre-processor ran before the lexer since always…</div><br/><div id="42027792" class="c"><input type="checkbox" id="c-42027792" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027435">parent</a><span>|</span><a href="#42027529">next</a><span>|</span><label class="collapse" for="c-42027792">[-]</label><label class="expand" for="c-42027792">[2 more]</label></div><br/><div class="children"><div class="content">There are three (relevant) phases (see “translation phases” in section 5 of the standard):<p>• program is lexed into preprocessing tokens; comments turn into whitespace<p>• preprocessor does its thing<p>• preprocessor tokens are turned into proper tokens; different kinds of number are disambiguated; keywords and identifiers are disambiguated<p>If you put an unclosed comment inside #if 0 then it won’t work as you might expect.</div><br/><div id="42028166" class="c"><input type="checkbox" id="c-42028166" checked=""/><div class="controls bullet"><span class="by">dahart</span><span>|</span><a href="#42026421">root</a><span>|</span><a href="#42027792">parent</a><span>|</span><a href="#42027529">next</a><span>|</span><label class="collapse" for="c-42028166">[-]</label><label class="expand" for="c-42028166">[1 more]</label></div><br/><div class="children"><div class="content">Ah, I see. You’re right!</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42027529" class="c"><input type="checkbox" id="c-42027529" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42026421">parent</a><span>|</span><a href="#42026835">prev</a><span>|</span><a href="#42026417">next</a><span>|</span><label class="collapse" for="c-42027529">[-]</label><label class="expand" for="c-42027529">[1 more]</label></div><br/><div class="children"><div class="content">This is not just true of Standard ML; it&#x27;s also true of regular ML.</div><br/></div></div></div></div><div id="42026417" class="c"><input type="checkbox" id="c-42026417" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42026421">prev</a><span>|</span><a href="#42027870">next</a><span>|</span><label class="collapse" for="c-42026417">[-]</label><label class="expand" for="c-42026417">[6 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think it&#x27;s easy to write a good syntax coloring engine like the one in Vim.<p>Syntax coloring has to handle context: different rules for material nested in certain ways.<p>Vim&#x27;s syntax higlighter lets you declare two kinds of items: matches and regions. Matches are simpler lexical rules, whereas regions have separate expressions for matching the start and end and middle.  There are ways to exclude leading and trailing material from a region.<p>Matches and regions can declare that they are contained. In that case they are not active unless they occur in a containing region.<p>Contained matches declare which regions contain them.<p>Regions declare which other regions they contain.<p>That&#x27;s the basic semantic architecture; there are bells and whistles in the system due to situations that arise.<p>I don&#x27;t think even Justine could develop that in an interview, other than as an overnight take home.</div><br/><div id="42026476" class="c"><input type="checkbox" id="c-42026476" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#42026417">parent</a><span>|</span><a href="#42030126">next</a><span>|</span><label class="collapse" for="c-42026476">[-]</label><label class="expand" for="c-42026476">[1 more]</label></div><br/><div class="children"><div class="content">Here is an example of something hard to handle: TXR language with embedded TXR Lisp.<p>This is the &quot;genman&quot; script which takes the raw output of a manpage to HTML converter, and massages it to form the HTML version of the TXR manual:<p><a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;tree&#x2F;genman.txr" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;tree&#x2F;genman.txr</a><p>Everything that is white (not colored) is literal template material. Lisp code is embedded in directives, like @(do ...).  In this scheme, TXR keywords appear purple, TXR Lisp ones green. They can be the same; see the (and ...) in line 149, versus numerous occurrences of @(and).<p>Quasistrings contain nested syntax: see 130 where `&lt;a href ..&gt; ... &lt;&#x2F;a&gt;` contains an embedded (if ...). That could itself contain a quasistring with more embedded code.<p>TXR&#x27;s <i>txr.vim&quot; and </i>tl.vim* syntax definition files are both generated by this:<p><a href="https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;tree&#x2F;genvim.txr" rel="nofollow">https:&#x2F;&#x2F;www.kylheku.com&#x2F;cgit&#x2F;txr&#x2F;tree&#x2F;genvim.txr</a></div><br/></div></div><div id="42029237" class="c"><input type="checkbox" id="c-42029237" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#42026417">parent</a><span>|</span><a href="#42030126">prev</a><span>|</span><a href="#42030212">next</a><span>|</span><label class="collapse" for="c-42029237">[-]</label><label class="expand" for="c-42029237">[2 more]</label></div><br/><div class="children"><div class="content">Naively, I would have assumed that the &quot;correct&quot; way to write a syntax highlighter would be to parse into an AST and then iterate over the tokens and update the color of a token based on the type of node (and maybe just tracking a diff to avoid needing to recolor things that haven&#x27;t changed). I&#x27;m guessing that if this isn&#x27;t done, it&#x27;s for efficiency reasons (e.g. due to requiring parsing the whole file to highlight rather than just the part currently visible on the screen)?</div><br/><div id="42029579" class="c"><input type="checkbox" id="c-42029579" checked=""/><div class="controls bullet"><span class="by">Someone</span><span>|</span><a href="#42026417">root</a><span>|</span><a href="#42029237">parent</a><span>|</span><a href="#42030212">next</a><span>|</span><label class="collapse" for="c-42029579">[-]</label><label class="expand" for="c-42029579">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I would have assumed that the &quot;correct&quot; way to write a syntax highlighter would be to parse into an AST and then […] I&#x27;m guessing that if this isn&#x27;t done, it&#x27;s for efficiency reasons<p>It’s not only running time, but also ease of implementation.<p>A good syntax highlighter should do a decent job highlighting both valid and invalid programs (rationale: in most (editor, language) pairs, writing a program involves going through moments where the program being written isn’t a valid program)<p>If you decide to use an AST, that means you need to have good heuristics for turning invalid programs into valid ones that best mimic what the programmer intended. That can be difficult to achieve (good compilers have such heuristics, but even if you have such a compiler, chances are it isn’t possible to reuse them for syntax coloring)<p>If this simpler approach gives you most of what you can get with the AST approach, why bother writing that?<p>Also, there are languages where some programs can’t be perfectly parsed or syntax colored without running them. For those, you need this approach.</div><br/></div></div></div></div><div id="42030212" class="c"><input type="checkbox" id="c-42030212" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#42026417">parent</a><span>|</span><a href="#42029237">prev</a><span>|</span><a href="#42027870">next</a><span>|</span><label class="collapse" for="c-42030212">[-]</label><label class="expand" for="c-42030212">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I don&#x27;t think even Justine could develop that in an interview<p>Not so sure I’d put money on that opinion ;)</div><br/></div></div></div></div><div id="42027870" class="c"><input type="checkbox" id="c-42027870" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026417">prev</a><span>|</span><a href="#42026177">next</a><span>|</span><label class="collapse" for="c-42027870">[-]</label><label class="expand" for="c-42027870">[7 more]</label></div><br/><div class="children"><div class="content">The author may have missed that lexing C is actually context-sensitive, i.e. you need a symbol table: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lexer_hack" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lexer_hack</a><p>Of course, for syntax highlighting this is only relevant if you want to highlight the multiplication operator differently from the dereferencing operator, or declarations differently from expressions.<p>More generally, however, I find it useful to highlight (say) types differently from variables or functions, which in some (most?) popular languages requires full parsing and symbol table information. Some IDEs therefore implement two levels of syntax highlighting, a basic one that only requires lexical information, and an extended one that kicks in when full grammar and type information becomes available.</div><br/><div id="42031788" class="c"><input type="checkbox" id="c-42031788" checked=""/><div class="controls bullet"><span class="by">teo_zero</span><span>|</span><a href="#42027870">parent</a><span>|</span><a href="#42030664">next</a><span>|</span><label class="collapse" for="c-42031788">[-]</label><label class="expand" for="c-42031788">[1 more]</label></div><br/><div class="children"><div class="content">&gt; this is only relevant if you want to highlight the multiplication operator differently from the dereferencing operator<p>Can you mention one editor which does that?</div><br/></div></div><div id="42030664" class="c"><input type="checkbox" id="c-42030664" checked=""/><div class="controls bullet"><span class="by">alekratz</span><span>|</span><a href="#42027870">parent</a><span>|</span><a href="#42031788">prev</a><span>|</span><a href="#42028075">next</a><span>|</span><label class="collapse" for="c-42030664">[-]</label><label class="expand" for="c-42030664">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think the lexer hack is relevant in this instance. The lexer hack just refers to the ambiguity of `A * B` and whether that should be parsed as a variable declaration or an expression. If you&#x27;re building a syntax tree, then this matters, but AFAICT all the author needs is a sequence of tokens and not a syntax tree. Maybe &quot;parser hack&quot; would be a better name for it.</div><br/></div></div><div id="42028075" class="c"><input type="checkbox" id="c-42028075" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#42027870">parent</a><span>|</span><a href="#42030664">prev</a><span>|</span><a href="#42026177">next</a><span>|</span><label class="collapse" for="c-42028075">[-]</label><label class="expand" for="c-42028075">[4 more]</label></div><br/><div class="children"><div class="content">I’d be shocked if jart didn’t know this, but it seems unlikely that an LLM would generate one of these most vexing parses, unless explicitly asked</div><br/><div id="42028659" class="c"><input type="checkbox" id="c-42028659" checked=""/><div class="controls bullet"><span class="by">quietbritishjim</span><span>|</span><a href="#42027870">root</a><span>|</span><a href="#42028075">parent</a><span>|</span><a href="#42028284">next</a><span>|</span><label class="collapse" for="c-42028659">[-]</label><label class="expand" for="c-42028659">[1 more]</label></div><br/><div class="children"><div class="content">I think you&#x27;re thinking of something different to the issue in the parent comment. The most vexing parse is, as the name suggests, a problem at the parsing stage rather than the earlier lexing phase. Unlike the referenced lexing problem, it does&#x27;t require any hack for compilers to deal with it. That&#x27;s because it&#x27;s not really a problem for the compiler; it&#x27;s humans that find it surprising.</div><br/></div></div><div id="42028284" class="c"><input type="checkbox" id="c-42028284" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42027870">root</a><span>|</span><a href="#42028075">parent</a><span>|</span><a href="#42028659">prev</a><span>|</span><a href="#42026177">next</a><span>|</span><label class="collapse" for="c-42028284">[-]</label><label class="expand" for="c-42028284">[2 more]</label></div><br/><div class="children"><div class="content">Given all the things that were new to the author in the article, I wouldn’t be shocked at all. There’s just a huge number of things to know, or to have come across.</div><br/><div id="42031139" class="c"><input type="checkbox" id="c-42031139" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#42027870">root</a><span>|</span><a href="#42028284">parent</a><span>|</span><a href="#42026177">next</a><span>|</span><label class="collapse" for="c-42031139">[-]</label><label class="expand" for="c-42031139">[1 more]</label></div><br/><div class="children"><div class="content">Justine is proficient in C, she is the author of a libc (cosmopolitan) among other things, like Actually Portable Executables [1].<p>I would expect her to know C quite well, and that&#x27;s probably an understatement.<p>[1] <a href="https:&#x2F;&#x2F;justine.lol&#x2F;ape.html" rel="nofollow">https:&#x2F;&#x2F;justine.lol&#x2F;ape.html</a></div><br/></div></div></div></div></div></div></div></div><div id="42026177" class="c"><input type="checkbox" id="c-42026177" checked=""/><div class="controls bullet"><span class="by">rererereferred</span><span>|</span><a href="#42027870">prev</a><span>|</span><a href="#42026154">next</a><span>|</span><label class="collapse" for="c-42026177">[-]</label><label class="expand" for="c-42026177">[5 more]</label></div><br/><div class="children"><div class="content">In the C# multiquoted strings, how does it know this:<p><pre><code>   Console.WriteLine(&quot;&quot;&quot;&quot;&quot;&quot;);
   Console.WriteLine(&quot;&quot;&quot;&quot;&quot;&quot;);
</code></pre>
Are 2 triplequoted empty strings and not one &quot;\nConsole.WriteLine(&quot; sixtuplequoted string?</div><br/><div id="42026272" class="c"><input type="checkbox" id="c-42026272" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#42026177">parent</a><span>|</span><a href="#42026250">next</a><span>|</span><label class="collapse" for="c-42026272">[-]</label><label class="expand" for="c-42026272">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a syntax error!<p><pre><code>  Unterminated raw string literal.
</code></pre>
<a href="https:&#x2F;&#x2F;replit.com&#x2F;@Wei-YenYen&#x2F;DistantAdmirableCareware#main.cs" rel="nofollow">https:&#x2F;&#x2F;replit.com&#x2F;@Wei-YenYen&#x2F;DistantAdmirableCareware#main...</a></div><br/><div id="42026352" class="c"><input type="checkbox" id="c-42026352" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42026177">root</a><span>|</span><a href="#42026272">parent</a><span>|</span><a href="#42026250">next</a><span>|</span><label class="collapse" for="c-42026352">[-]</label><label class="expand" for="c-42026352">[1 more]</label></div><br/><div class="children"><div class="content">Ah, so there is no backtracking in lexer for this case. Makes sense.</div><br/></div></div></div></div><div id="42026250" class="c"><input type="checkbox" id="c-42026250" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#42026177">parent</a><span>|</span><a href="#42026272">prev</a><span>|</span><a href="#42026228">next</a><span>|</span><label class="collapse" for="c-42026250">[-]</label><label class="expand" for="c-42026250">[1 more]</label></div><br/><div class="children"><div class="content">If the opening quotes are followed by anything that is not a whitespace before the next new-line (or EOF), then it&#x27;s a single-line string.<p>I imagine implementing those things took several iterations :)</div><br/></div></div><div id="42026228" class="c"><input type="checkbox" id="c-42026228" checked=""/><div class="controls bullet"><span class="by">ygra</span><span>|</span><a href="#42026177">parent</a><span>|</span><a href="#42026250">prev</a><span>|</span><a href="#42026154">next</a><span>|</span><label class="collapse" for="c-42026228">[-]</label><label class="expand" for="c-42026228">[1 more]</label></div><br/><div class="children"><div class="content">The former, I&#x27;d say.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-guide&#x2F;strings&#x2F;#raw-string-literals" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;programming-...</a><p>For a multi-line string the quotes have to be on their own line.</div><br/></div></div></div></div><div id="42026154" class="c"><input type="checkbox" id="c-42026154" checked=""/><div class="controls bullet"><span class="by">pansa2</span><span>|</span><a href="#42026177">prev</a><span>|</span><a href="#42026106">next</a><span>|</span><label class="collapse" for="c-42026154">[-]</label><label class="expand" for="c-42026154">[4 more]</label></div><br/><div class="children"><div class="content">&gt; <i>TypeScript, Swift, Kotlin, and Scala take string interpolation to the furthest extreme of encouraging actual code being embedded inside strings. So to highlight a string, one must count curly brackets and maintain a stack of parser states.</i><p>Presumably this is also true in Python - IIRC the brace-delimited fields within f-strings may contain arbitrary expressions.<p>More generally, this must mean that the lexical grammar of those languages isn&#x27;t regular. &quot;Maintaining a stack&quot; isn&#x27;t part of a finite-state machine for a regular grammar - instead we&#x27;re in the realm of pushdown automata and context-free grammars.<p>Is it even possible to support generalized string interpolation within a strictly regular lexical grammar?</div><br/><div id="42027151" class="c"><input type="checkbox" id="c-42027151" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42026154">parent</a><span>|</span><a href="#42026612">next</a><span>|</span><label class="collapse" for="c-42027151">[-]</label><label class="expand" for="c-42027151">[1 more]</label></div><br/><div class="children"><div class="content">Complicated interpolation can be lexed as a regular language if you treat strings as three separate lexical things, eg in JavaScript template literals there are,<p><pre><code>    `stuff${
    }stuff${
    }stuff`
</code></pre>
so the ${ and } are extra closing and opening string delimiters, leaving the nesting to be handled by the parser.<p>You need a lexer hack so that the lexer does not treat } as the start of a string literal, except when the parser is inside an interpolation but all nested {} have been closed.</div><br/></div></div><div id="42026612" class="c"><input type="checkbox" id="c-42026612" checked=""/><div class="controls bullet"><span class="by">aphantastic</span><span>|</span><a href="#42026154">parent</a><span>|</span><a href="#42027151">prev</a><span>|</span><a href="#42026192">next</a><span>|</span><label class="collapse" for="c-42026612">[-]</label><label class="expand" for="c-42026612">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is it even possible to support generalized string interpolation within a strictly regular lexical grammar?<p>Almost certainly not, a fun exercise is to attempt to devise a Pumping tactic for your proposed language. If it doesn’t exist, it’s not regular.<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Pumping_lemma_for_regular_languages" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Pumping_lemma_for_regular_la...</a></div><br/></div></div></div></div><div id="42026106" class="c"><input type="checkbox" id="c-42026106" checked=""/><div class="controls bullet"><span class="by">yen223</span><span>|</span><a href="#42026154">prev</a><span>|</span><a href="#42027030">next</a><span>|</span><label class="collapse" for="c-42026106">[-]</label><label class="expand" for="c-42026106">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>  select&#x27;select&#x27;select
</code></pre>
is a perfectly valid SQL query, at least for Postgres.<p>Languages&#x27; approach to whitespace between tokens is all over the place</div><br/></div></div><div id="42027030" class="c"><input type="checkbox" id="c-42027030" checked=""/><div class="controls bullet"><span class="by">metadat</span><span>|</span><a href="#42026106">prev</a><span>|</span><a href="#42030197">next</a><span>|</span><label class="collapse" for="c-42027030">[-]</label><label class="expand" for="c-42027030">[2 more]</label></div><br/><div class="children"><div class="content"><i>&gt; The languages I decided to support are Ada, Assembly, BASIC, C, C#, C++, COBOL, CSS, D, FORTH, FORTRAN, Go, Haskell, HTML, Java, JavaScript, Julia, JSON, Kotlin, ld, LISP, Lua, m4, Make, Markdown, MATLAB, Pascal, Perl, PHP, Python, R, Ruby, Rust, Scala, Shell, SQL, Swift, Tcl, TeX, TXT, TypeScript, and Zig.</i><p>A few (admittedly silly) questions about the list:<p>1. Why no Erlang, Elixir, or Crystal?<p>Erlang appears to be just at the author&#x27;s boundary at #47 on the TIOBE index.
<a href="https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.tiobe.com&#x2F;tiobe-index&#x2F;</a><p>2. What is <i>&quot;Shell&quot;</i>?  Sh, Bash, Zsh, Windows Cmd, PowerShell..?<p>3. Perl but no Awk?  Curious why, because Awk is a similar but comparatively trivial language.  Widely used, too.<p>To be fair, Awk, Erlang, and Elixir rank low on popularity.  Yet m4, Tcl, TeX, and Zig aren&#x27;t registered in the top 50 at all.<p>What&#x27;s the methodology &#x2F; criteria?  Only things the author is already familiar with?<p>Still a fun article.</div><br/><div id="42027791" class="c"><input type="checkbox" id="c-42027791" checked=""/><div class="controls bullet"><span class="by">Yasuraka</span><span>|</span><a href="#42027030">parent</a><span>|</span><a href="#42030197">next</a><span>|</span><label class="collapse" for="c-42027791">[-]</label><label class="expand" for="c-42027791">[1 more]</label></div><br/><div class="children"><div class="content">Tiobes&#x27;s index is quite literally worthless, especially with regards to its stated purpose, let alone as a general point of orientation.<p>I&#x27;d wish that purple would stop lending it any credibility.</div><br/></div></div></div></div><div id="42030197" class="c"><input type="checkbox" id="c-42030197" checked=""/><div class="controls bullet"><span class="by">tomcam</span><span>|</span><a href="#42027030">prev</a><span>|</span><a href="#42026607">next</a><span>|</span><label class="collapse" for="c-42030197">[-]</label><label class="expand" for="c-42030197">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If you ever want to confuse your coworkers, then one great way to abuse this syntax is by replacing the heredoc marker with an empty string<p>Maybe I am in favor of the death penalty after all</div><br/></div></div><div id="42026607" class="c"><input type="checkbox" id="c-42026607" checked=""/><div class="controls bullet"><span class="by">SonOfLilit</span><span>|</span><a href="#42030197">prev</a><span>|</span><a href="#42029176">next</a><span>|</span><label class="collapse" for="c-42026607">[-]</label><label class="expand" for="c-42026607">[7 more]</label></div><br/><div class="children"><div class="content">Justine gets very close to the hairiest parsing issue in any language without encountering it:<p>Perl&#x27;s syntax is undecidable, because the difference between treating some characters as a comment or as a regex can depend on the type of a variable that is only determined e.g. based on whether a search for a Collatz counterexample terminates, or just, you know, user input.<p><a href="https:&#x2F;&#x2F;perlmonks.org&#x2F;?node_id=663393" rel="nofollow">https:&#x2F;&#x2F;perlmonks.org&#x2F;?node_id=663393</a><p>C++ templates have a
similar issue, I think.</div><br/><div id="42027059" class="c"><input type="checkbox" id="c-42027059" checked=""/><div class="controls bullet"><span class="by">fanf2</span><span>|</span><a href="#42026607">parent</a><span>|</span><a href="#42027063">next</a><span>|</span><label class="collapse" for="c-42027059">[-]</label><label class="expand" for="c-42027059">[2 more]</label></div><br/><div class="children"><div class="content">I think possibly the most hilariously complicated instance of this is in perl’s tokenizer, toke.c  (which starts with a Tolkien quote, &#x27;It all comes from here, the stench and the peril.&#x27; — Frodo).<p>There’s a function called intuit_more which works out if $var[stuff] inside a regex is a variable interpolation followed by a character class, or an array element interpolation. Its result can depend on whether something in the stuff has been declared as a variable or not.<p>But even if you ignore the undecidability, the rest is still ridiculously complicated.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;Perl&#x2F;perl5&#x2F;blob&#x2F;blead&#x2F;toke.c#L4502">https:&#x2F;&#x2F;github.com&#x2F;Perl&#x2F;perl5&#x2F;blob&#x2F;blead&#x2F;toke.c#L4502</a></div><br/><div id="42030051" class="c"><input type="checkbox" id="c-42030051" checked=""/><div class="controls bullet"><span class="by">ufo</span><span>|</span><a href="#42026607">root</a><span>|</span><a href="#42027059">parent</a><span>|</span><a href="#42027063">next</a><span>|</span><label class="collapse" for="c-42030051">[-]</label><label class="expand" for="c-42030051">[1 more]</label></div><br/><div class="children"><div class="content">Wow. I wonder how that function came to be in the first place. Surely it couldn&#x27;t have started out that complicated?</div><br/></div></div></div></div><div id="42027063" class="c"><input type="checkbox" id="c-42027063" checked=""/><div class="controls bullet"><span class="by">swolchok</span><span>|</span><a href="#42026607">parent</a><span>|</span><a href="#42027059">prev</a><span>|</span><a href="#42030965">next</a><span>|</span><label class="collapse" for="c-42027063">[-]</label><label class="expand" for="c-42027063">[1 more]</label></div><br/><div class="children"><div class="content">&gt; C++ templates have a similar issue<p>TIL! I went and dug up a citation: <a href="https:&#x2F;&#x2F;blog.reverberate.org&#x2F;2013&#x2F;08&#x2F;parsing-c-is-literally-undecidable.html" rel="nofollow">https:&#x2F;&#x2F;blog.reverberate.org&#x2F;2013&#x2F;08&#x2F;parsing-c-is-literally-...</a></div><br/></div></div><div id="42030965" class="c"><input type="checkbox" id="c-42030965" checked=""/><div class="controls bullet"><span class="by">chubot</span><span>|</span><a href="#42026607">parent</a><span>|</span><a href="#42027063">prev</a><span>|</span><a href="#42028246">next</a><span>|</span><label class="collapse" for="c-42030965">[-]</label><label class="expand" for="c-42030965">[2 more]</label></div><br/><div class="children"><div class="content">Yup,  bash and GNU Make have the same issue as Perl does, and I mention the C++ issue here too:<p><i>Parsing Bash is Undecidable</i> - <a href="https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2016&#x2F;10&#x2F;20.html" rel="nofollow">https:&#x2F;&#x2F;www.oilshell.org&#x2F;blog&#x2F;2016&#x2F;10&#x2F;20.html</a><p>I remember a talk from Larry Wall on Perl 6 (now Raku), where he says this type of thing is a mistake.  Raku can be statically parsed, as far as I know.</div><br/><div id="42031613" class="c"><input type="checkbox" id="c-42031613" checked=""/><div class="controls bullet"><span class="by">jwilk</span><span>|</span><a href="#42026607">root</a><span>|</span><a href="#42030965">parent</a><span>|</span><a href="#42028246">next</a><span>|</span><label class="collapse" for="c-42031613">[-]</label><label class="expand" for="c-42031613">[1 more]</label></div><br/><div class="children"><div class="content">Parsing POSIX shell in undecidable too:<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30362718">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=30362718</a></div><br/></div></div></div></div><div id="42028246" class="c"><input type="checkbox" id="c-42028246" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#42026607">parent</a><span>|</span><a href="#42030965">prev</a><span>|</span><a href="#42029176">next</a><span>|</span><label class="collapse" for="c-42028246">[-]</label><label class="expand" for="c-42028246">[1 more]</label></div><br/><div class="children"><div class="content">How could a search for a Collatz counterexample possibly terminate? ;)</div><br/></div></div></div></div><div id="42029176" class="c"><input type="checkbox" id="c-42029176" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#42026607">prev</a><span>|</span><a href="#42026132">next</a><span>|</span><label class="collapse" for="c-42029176">[-]</label><label class="expand" for="c-42029176">[2 more]</label></div><br/><div class="children"><div class="content">The final line number count is missing Julia. Based on the file in the repo, it would be at the bottom of the first column: between ld and R.<p>Among the niceties listed here, the one I&#x27;d wish for Julia to have would be C#&#x27;s &quot;However many quotes you put on the lefthand side, that&#x27;s what&#x27;ll be used to terminate the string at the other end&quot;. Documentation that talks about quoting would be so much easier to read (in source form) with something like that.</div><br/><div id="42030629" class="c"><input type="checkbox" id="c-42030629" checked=""/><div class="controls bullet"><span class="by">sundarurfriend</span><span>|</span><a href="#42029176">parent</a><span>|</span><a href="#42026132">next</a><span>|</span><label class="collapse" for="c-42030629">[-]</label><label class="expand" for="c-42030629">[1 more]</label></div><br/><div class="children"><div class="content">One nicety that Julia does have that I didn&#x27;t know about (or had forgotten) is nested multi-line comments.<p><pre><code>    #= this one
       has a #= nested
       comment =# inside of it
       and that works fine! =#</code></pre></div><br/></div></div></div></div><div id="42026132" class="c"><input type="checkbox" id="c-42026132" checked=""/><div class="controls bullet"><span class="by">notsylver</span><span>|</span><a href="#42029176">prev</a><span>|</span><a href="#42026459">next</a><span>|</span><label class="collapse" for="c-42026132">[-]</label><label class="expand" for="c-42026132">[4 more]</label></div><br/><div class="children"><div class="content">As soon as I saw this was part of llamafile I was hoping that it would be used to limit LLM output to always be &quot;valid&quot; code as soon as it saw the backticks, but I suppose most LLMs don&#x27;t have problems with that anyway. And I&#x27;m not sure you&#x27;d want something like that automatically forcing valid code anyway</div><br/><div id="42026262" class="c"><input type="checkbox" id="c-42026262" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#42026132">parent</a><span>|</span><a href="#42026459">next</a><span>|</span><label class="collapse" for="c-42026262">[-]</label><label class="expand" for="c-42026262">[3 more]</label></div><br/><div class="children"><div class="content">llama.cpp does support something like this -- you can give it a grammar which restricts the set of available next tokens that are sampled over<p>so in theory you could notice &quot;```python&quot; or whatever and then start restricting to valid python code. (in least in theory, not sure how feasible&#x2F;possible it would be in practice w&#x2F; their grammar format.)<p>for code i&#x27;m not sure how useful it would be since likely any model that is giving you working code wouldn&#x27;t be struggling w&#x2F; syntax errors anyway?<p>but i have had success experimentally using the feature to drive fiction content for a game from a smaller llm to be in a very specific format.</div><br/><div id="42027046" class="c"><input type="checkbox" id="c-42027046" checked=""/><div class="controls bullet"><span class="by">notsylver</span><span>|</span><a href="#42026132">root</a><span>|</span><a href="#42026262">parent</a><span>|</span><a href="#42026459">next</a><span>|</span><label class="collapse" for="c-42027046">[-]</label><label class="expand" for="c-42027046">[2 more]</label></div><br/><div class="children"><div class="content">yeah, ive used llama.cpp grammars before, which is why i was thinking about it. i just think it&#x27;d be cool for llamafile to do basically that, but with included defaults so you could eg, require JSON output. it could be cool for prototyping or something. but i dont think that would be too useful anyway, most of the time i think you would want to restrict it to a specific schema, so i can only see it being useful for something like a tiny local LLM for code completion, but that would just encourage valid-looking but incorrect code.<p>i think i just like the idea of restricting LLM output, it has a lot of interesting use cases</div><br/><div id="42027215" class="c"><input type="checkbox" id="c-42027215" checked=""/><div class="controls bullet"><span class="by">dilap</span><span>|</span><a href="#42026132">root</a><span>|</span><a href="#42027046">parent</a><span>|</span><a href="#42026459">next</a><span>|</span><label class="collapse" for="c-42027215">[-]</label><label class="expand" for="c-42027215">[1 more]</label></div><br/><div class="children"><div class="content">gotchya. i do think that is a cool idea actually -- LLMs tiny enough to do useful things with formally structured output but not big enough to nail the structure ~100% is probably not an empty set.</div><br/></div></div></div></div></div></div></div></div><div id="42026459" class="c"><input type="checkbox" id="c-42026459" checked=""/><div class="controls bullet"><span class="by">playingalong</span><span>|</span><a href="#42026132">prev</a><span>|</span><a href="#42025949">next</a><span>|</span><label class="collapse" for="c-42026459">[-]</label><label class="expand" for="c-42026459">[1 more]</label></div><br/><div class="children"><div class="content">Nice read.<p>I guess the article could be called Falsehoods Programmers Assume of Programming Language Syntaxes.</div><br/></div></div><div id="42025949" class="c"><input type="checkbox" id="c-42025949" checked=""/><div class="controls bullet"><span class="by">skrebbel</span><span>|</span><a href="#42026459">prev</a><span>|</span><a href="#42029276">next</a><span>|</span><label class="collapse" for="c-42025949">[-]</label><label class="expand" for="c-42025949">[1 more]</label></div><br/><div class="children"><div class="content">This was a delightful read, thanks!</div><br/></div></div><div id="42029276" class="c"><input type="checkbox" id="c-42029276" checked=""/><div class="controls bullet"><span class="by">nusaru</span><span>|</span><a href="#42025949">prev</a><span>|</span><a href="#42027557">next</a><span>|</span><label class="collapse" for="c-42029276">[-]</label><label class="expand" for="c-42029276">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Ruby is the union of all earlier languages, and it&#x27;s not even formally documented.<p>It&#x27;s documented, but you need $250 to spare: <a href="https:&#x2F;&#x2F;www.iso.org&#x2F;standard&#x2F;59579.html" rel="nofollow">https:&#x2F;&#x2F;www.iso.org&#x2F;standard&#x2F;59579.html</a></div><br/><div id="42029486" class="c"><input type="checkbox" id="c-42029486" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42029276">parent</a><span>|</span><a href="#42027557">next</a><span>|</span><label class="collapse" for="c-42029486">[-]</label><label class="expand" for="c-42029486">[1 more]</label></div><br/><div class="children"><div class="content">Well, according to (ahem) <i>a copy</i> that I found, it only goes up to MRI 1.9 and goes out of its way to say &quot;welp, the world is changing, so we&#x27;re just going to punt until Ruby stabilizes&quot; which is damn cheating for a <i>standard</i> IMHO<p>Also, while doing some digging I found there actually are a number of the standards that are legitimately publicly available <a href="https:&#x2F;&#x2F;standards.iso.org&#x2F;ittf&#x2F;PubliclyAvailableStandards&#x2F;index.html" rel="nofollow">https:&#x2F;&#x2F;standards.iso.org&#x2F;ittf&#x2F;PubliclyAvailableStandards&#x2F;in...</a></div><br/></div></div></div></div><div id="42027557" class="c"><input type="checkbox" id="c-42027557" checked=""/><div class="controls bullet"><span class="by">dakiol</span><span>|</span><a href="#42029276">prev</a><span>|</span><a href="#42026555">next</a><span>|</span><label class="collapse" for="c-42027557">[-]</label><label class="expand" for="c-42027557">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn’t be possible to let the LLM do the highlighting? Instead of returning code in plain text, it could return code within html with the appropriate tags. Maybe it’s harder than it sounds… but if it’s just for highlighting the code the LLM returns, I wouldn’t mind the highlighting not being 100% accurate.</div><br/><div id="42027577" class="c"><input type="checkbox" id="c-42027577" checked=""/><div class="controls bullet"><span class="by">trashburger</span><span>|</span><a href="#42027557">parent</a><span>|</span><a href="#42026555">next</a><span>|</span><label class="collapse" for="c-42027577">[-]</label><label class="expand" for="c-42027577">[1 more]</label></div><br/><div class="children"><div class="content">Would be much slower and eat up precious context window.</div><br/></div></div></div></div><div id="42026555" class="c"><input type="checkbox" id="c-42026555" checked=""/><div class="controls bullet"><span class="by">jim_lawless</span><span>|</span><a href="#42027557">prev</a><span>|</span><a href="#42025850">next</a><span>|</span><label class="collapse" for="c-42026555">[-]</label><label class="expand" for="c-42026555">[1 more]</label></div><br/><div class="children"><div class="content">Forth has a default syntax, but Forth code can execute during the compilation process allowing it to accept&#x2F;compile custom syntaxes.</div><br/></div></div><div id="42025850" class="c"><input type="checkbox" id="c-42025850" checked=""/><div class="controls bullet"><span class="by">llm_trw</span><span>|</span><a href="#42026555">prev</a><span>|</span><a href="#42031544">next</a><span>|</span><label class="collapse" for="c-42025850">[-]</label><label class="expand" for="c-42025850">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve done a fair bit of forth and I&#x27;ve not seen c&quot; used. The usual string printing operator is .&quot; .</div><br/><div id="42026017" class="c"><input type="checkbox" id="c-42026017" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42025850">parent</a><span>|</span><a href="#42025976">next</a><span>|</span><label class="collapse" for="c-42026017">[-]</label><label class="expand" for="c-42026017">[1 more]</label></div><br/><div class="children"><div class="content">Right, <i>c&quot;</i> is for when you want to pass a literal string to some other word, not print it.  But I agree that it&#x27;s not very common, because you normally use <i>s&quot;</i> for that, which leaves the address and length on the stack, while <i>c&quot;</i> leaves just an address on the stack, pointing to a one-byte count field followed by the bytes.  I think adding <i>c&quot;</i> in Forth-83 (and renaming <i>&quot;</i> to <i>s&quot;</i>) was a mistake, and it would have been better to deprecate the standard words that expect or produce such counted strings, other than <i>count</i> itself.  See <a href="https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;alpha" rel="nofollow">https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;alpha</a>, <a href="https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;Cq" rel="nofollow">https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;Cq</a>, <a href="https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;COUNT" rel="nofollow">https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;COUNT</a>, and <a href="https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;Sq" rel="nofollow">https:&#x2F;&#x2F;forth-standard.org&#x2F;standard&#x2F;core&#x2F;Sq</a>.<p>You can easily add new string and comment syntaxes to Forth, though.  For example, you can add BCPL-style &#x2F;&#x2F; comments to end of line with this line of code in, I believe, all standard Forths, though I&#x27;ve only tested it in GForth:<p><pre><code>    : &#x2F;&#x2F; 10 word drop ; immediate
</code></pre>
Getting it to work in block files requires more work but is still only a few lines of code.  The standard word <i>\ </i>does this, and <i>see \ </i>decompiles the GForth implementation as<p><pre><code>  : \
    blk @
    IF     &gt;in @ c&#x2F;l &#x2F; 1+ c&#x2F;l * &gt;in ! EXIT
    THEN
    source &gt;in ! drop ; immediate
</code></pre>
This kind of thing was commonly done for text editor commands, for example; you might define <i>i</i> as a word that reads text until the end of the line and inserts it at the current position in the editor, rather than discarding it like my &#x2F;&#x2F; above.  Among other things, the screen editor in F83 does exactly that.<p>So, as with Perl, PostScript, TeX, m4, and Lisps that support readmacros, you can&#x27;t lex Forth without executing it.</div><br/></div></div><div id="42025976" class="c"><input type="checkbox" id="c-42025976" checked=""/><div class="controls bullet"><span class="by">mananaysiempre</span><span>|</span><a href="#42025850">parent</a><span>|</span><a href="#42026017">prev</a><span>|</span><a href="#42031544">next</a><span>|</span><label class="collapse" for="c-42025976">[-]</label><label class="expand" for="c-42025976">[1 more]</label></div><br/><div class="children"><div class="content">Counted (“Pascal”) strings are rare nowadays so C&quot; is not often used. Its addr len equivalent is S&quot; and that one is fairly common in string manipulation code.</div><br/></div></div></div></div><div id="42031544" class="c"><input type="checkbox" id="c-42031544" checked=""/><div class="controls bullet"><span class="by">transfire</span><span>|</span><a href="#42025850">prev</a><span>|</span><a href="#42026211">next</a><span>|</span><label class="collapse" for="c-42031544">[-]</label><label class="expand" for="c-42031544">[1 more]</label></div><br/><div class="children"><div class="content">Impressive work!<p>I am surprised Smalltalk and Prolog are in there though.</div><br/></div></div><div id="42026211" class="c"><input type="checkbox" id="c-42026211" checked=""/><div class="controls bullet"><span class="by">ygra</span><span>|</span><a href="#42031544">prev</a><span>|</span><a href="#42026051">next</a><span>|</span><label class="collapse" for="c-42026211">[-]</label><label class="expand" for="c-42026211">[1 more]</label></div><br/><div class="children"><div class="content">As for C#&#x27;s triple-quoted strings, they actually came from Java before and C# ended up adopting the same or almost the same semantics. Including stripping leading whitespace.</div><br/></div></div><div id="42026051" class="c"><input type="checkbox" id="c-42026051" checked=""/><div class="controls bullet"><span class="by">mcphage</span><span>|</span><a href="#42026211">prev</a><span>|</span><a href="#42026782">next</a><span>|</span><label class="collapse" for="c-42026051">[-]</label><label class="expand" for="c-42026051">[1 more]</label></div><br/><div class="children"><div class="content">At one point there was an open source project to formally specify Ruby, but I don’t know if it’s still alive: <a href="https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;spec">https:&#x2F;&#x2F;github.com&#x2F;ruby&#x2F;spec</a><p>Hmm, it seems to be alive, but based more on behavior than syntax.</div><br/></div></div><div id="42026782" class="c"><input type="checkbox" id="c-42026782" checked=""/><div class="controls bullet"><span class="by">petesergeant</span><span>|</span><a href="#42026051">prev</a><span>|</span><a href="#42026422">next</a><span>|</span><label class="collapse" for="c-42026782">[-]</label><label class="expand" for="c-42026782">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Perl also has this goofy convention for writing man pages in your source code<p>The world corpus of software would be much better documented if everywhere else had stolen this from Perl. Inline POD is great.</div><br/><div id="42027556" class="c"><input type="checkbox" id="c-42027556" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42026782">parent</a><span>|</span><a href="#42026422">next</a><span>|</span><label class="collapse" for="c-42027556">[-]</label><label class="expand" for="c-42027556">[3 more]</label></div><br/><div class="children"><div class="content">Perl and Python stole it from Emacs Lisp, though Perl took it further.  I&#x27;m not sure where Java stole it from, but nowadays Doxygen is pretty common for C code.  Unfortunately this results in people thinking that Javadoc and Doxygen are substitutes for actual documentation like the Emacs Lisp Reference Manual, which cannot be generated from docstrings, because the organization of the source code is hopelessly inadequate for a reference manual.</div><br/><div id="42029582" class="c"><input type="checkbox" id="c-42029582" checked=""/><div class="controls bullet"><span class="by">mdaniel</span><span>|</span><a href="#42026782">root</a><span>|</span><a href="#42027556">parent</a><span>|</span><a href="#42026422">next</a><span>|</span><label class="collapse" for="c-42029582">[-]</label><label class="expand" for="c-42029582">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Emacs Lisp Reference Manual, which cannot be generated from docstrings, because the organization of the source code is hopelessly inadequate for a reference manual.<p>Well, they&#x27;re not doing themselves any favors by just willy nilly mixing C with &quot;user-facing&quot; defuns &lt;<a href="https:&#x2F;&#x2F;emba.gnu.org&#x2F;emacs&#x2F;emacs&#x2F;-&#x2F;blob&#x2F;ed1d691184df4b50da6b8e1a207e9ccd88aa9ffb&#x2F;src&#x2F;process.c#L1003-1004" rel="nofollow">https:&#x2F;&#x2F;emba.gnu.org&#x2F;emacs&#x2F;emacs&#x2F;-&#x2F;blob&#x2F;ed1d691184df4b50da6b...</a>&gt;. I was curious if they could benefit from &quot;literate programming&quot; since OrgMode is <i>the bee&#x27;s knees</i> but not with that style coding they can&#x27;t</div><br/><div id="42030379" class="c"><input type="checkbox" id="c-42030379" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#42026782">root</a><span>|</span><a href="#42029582">parent</a><span>|</span><a href="#42026422">next</a><span>|</span><label class="collapse" for="c-42030379">[-]</label><label class="expand" for="c-42030379">[1 more]</label></div><br/><div class="children"><div class="content">I didn&#x27;t mean that specifically the Emacs source code was not organized in the right way for a reference manual. I meant that C and Java source code in general isn&#x27;t.  And C++, which is actually where people use Doxygen more.<p>The Python standard library manual is also exemplary, and also necessarily organized differently from the source code.</div><br/></div></div></div></div></div></div></div></div><div id="42026422" class="c"><input type="checkbox" id="c-42026422" checked=""/><div class="controls bullet"><span class="by">lupire</span><span>|</span><a href="#42026782">prev</a><span>|</span><label class="collapse" for="c-42026422">[-]</label><label class="expand" for="c-42026422">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You&#x27;ll notice its hash function only needs to consider a single character in in a string. That&#x27;s what makes it perfect,<p>Is that a joke?<p><a href="https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Perfect_hash_function" rel="nofollow">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Perfect_hash_function</a></div><br/></div></div></div></div></div></div></div></body></html>