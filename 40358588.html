<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1715763670889" as="style"/><link rel="stylesheet" href="styles.css?v=1715763670889"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://blog.jak-linux.org/2024/05/14/solver3/">The new APT 3.0 solver</a> <span class="domain">(<a href="https://blog.jak-linux.org">blog.jak-linux.org</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>88 comments</span></div><br/><div><div id="40358930" class="c"><input type="checkbox" id="c-40358930" checked=""/><div class="controls bullet"><span class="by">amelius</span><span>|</span><a href="#40359210">next</a><span>|</span><label class="collapse" for="c-40358930">[-]</label><label class="expand" for="c-40358930">[48 more]</label></div><br/><div class="children"><div class="content">Can anyone explain why libc versions are so often a problem when installing software? I understand that all libraries in an executable need to use the same version of malloc. But otherwise I don&#x27;t understand the reason for these clashes. Even malloc can be swapped out for another function with the same functionality. And I also don&#x27;t understand why libc needs to be updated so frequently, anyway.</div><br/><div id="40359283" class="c"><input type="checkbox" id="c-40359283" checked=""/><div class="controls bullet"><span class="by">codexon</span><span>|</span><a href="#40358930">parent</a><span>|</span><a href="#40362921">next</a><span>|</span><label class="collapse" for="c-40359283">[-]</label><label class="expand" for="c-40359283">[44 more]</label></div><br/><div class="children"><div class="content">They are a problem because gcc automatically links to the latest version of glibc.<p>As to why they don&#x27;t add an option to specify an older version? I don&#x27;t know either and it is rather annoying to have to use docker images of older OSes to target older glibc versions. It&#x27;s just one of many things that prevents linux from being as popular as windows for desktop users.</div><br/><div id="40360852" class="c"><input type="checkbox" id="c-40360852" checked=""/><div class="controls bullet"><span class="by">zX41ZdbW</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40359485">next</a><span>|</span><label class="collapse" for="c-40360852">[-]</label><label class="expand" for="c-40360852">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve made a library named &quot;glibc-compatibility&quot;: <a href="https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;tree&#x2F;master&#x2F;base&#x2F;glibc-compatibility">https:&#x2F;&#x2F;github.com&#x2F;ClickHouse&#x2F;ClickHouse&#x2F;tree&#x2F;master&#x2F;base&#x2F;gl...</a><p>When linking with this library before glibc, the resulting binary will not depend on the new symbol versions. It will run on glibc 2.4 and on systems as old as Ubuntu 8.04 and CentOS 5 even when built on the most modern system.</div><br/><div id="40361194" class="c"><input type="checkbox" id="c-40361194" checked=""/><div class="controls bullet"><span class="by">thrtythreeforty</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360852">parent</a><span>|</span><a href="#40362181">next</a><span>|</span><label class="collapse" for="c-40361194">[-]</label><label class="expand" for="c-40361194">[2 more]</label></div><br/><div class="children"><div class="content">How does this work?</div><br/><div id="40362150" class="c"><input type="checkbox" id="c-40362150" checked=""/><div class="controls bullet"><span class="by">threecheese</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40361194">parent</a><span>|</span><a href="#40362181">next</a><span>|</span><label class="collapse" for="c-40362150">[-]</label><label class="expand" for="c-40362150">[1 more]</label></div><br/><div class="children"><div class="content">In case parent didn’t see your q: <a href="https:&#x2F;&#x2F;www.lightofdawn.org&#x2F;wiki&#x2F;wiki.cgi&#x2F;NewAppsOnOldGlibc" rel="nofollow">https:&#x2F;&#x2F;www.lightofdawn.org&#x2F;wiki&#x2F;wiki.cgi&#x2F;NewAppsOnOldGlibc</a></div><br/></div></div></div></div><div id="40362181" class="c"><input type="checkbox" id="c-40362181" checked=""/><div class="controls bullet"><span class="by">adastra22</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360852">parent</a><span>|</span><a href="#40361194">prev</a><span>|</span><a href="#40359485">next</a><span>|</span><label class="collapse" for="c-40362181">[-]</label><label class="expand" for="c-40362181">[1 more]</label></div><br/><div class="children"><div class="content">You are a hero.</div><br/></div></div></div></div><div id="40359485" class="c"><input type="checkbox" id="c-40359485" checked=""/><div class="controls bullet"><span class="by">bregma</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40360852">prev</a><span>|</span><a href="#40360349">next</a><span>|</span><label class="collapse" for="c-40359485">[-]</label><label class="expand" for="c-40359485">[23 more]</label></div><br/><div class="children"><div class="content">Hmm. The MSVCRT.DLL&#x2F;MSVCRTD.DLL not being binary compatible between releases of Visual Studio is the same thing, except of course you can&#x27;t even combine some modules compiled for debug with modules compiled without debug in the same executable. The Windows problem has always been so so much worse that pretty much all developers simple resorted to shipping the OS system runtime with every package and it&#x27;s just expected nowadays. It&#x27;s where the phrase &quot;DLL hell&quot; originated, after all.<p>Not to say the ABI problem isn&#x27;t real if you want to combine binary packages from different Linux-based OSes. Plenty of solutions for that have cropped up as well: containers, flatpacks, snaps, the list goes on.</div><br/><div id="40359870" class="c"><input type="checkbox" id="c-40359870" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359485">parent</a><span>|</span><a href="#40359657">next</a><span>|</span><label class="collapse" for="c-40359870">[-]</label><label class="expand" for="c-40359870">[13 more]</label></div><br/><div class="children"><div class="content">This comment is full of inaccuracies and mistakes, and is a terrible travesty of the Windows situation.<p>&gt; except of course you can&#x27;t even combine some modules compiled for debug with modules compiled without debug in the same executable.<p>There&#x27;s a good reason for this, which IMO Unix-like compilers and system libraries should start adopting, too. Debug and Release binaries like the standard C and C++ runtimes and libraries cannot be inter-mixed because they have have different ABIs. They have different ABIs because the former set of binaries have different type layouts, many of which come with debug-specific assertions and tests like bounds-checking, exception try-catch, null-dereference tests, etc.<p>&gt; The Windows problem has always been so so much worse that pretty much all developers simple resorted to shipping the OS system runtime with every package and it&#x27;s just expected nowadays.<p>This is not true at all. There are several layers to the counterargument.<p>Firstly, UCRT has supplanted MSVCRT since Visual Studio 2015, which is a decade old this year. Additionally, UCRT can be statically linked: use `&#x2F;MT` instead of `&#x2F;MD`. And linking back to the previous quote, to statically link a debug CRT, use `&#x2F;MTd`. Set this up in MSBuild or CMake using release&#x2F;debug build configurations. UCRT is available for install (and maintained with Windows Update) in older versions of Windows going back to Vista.<p>Next, Windows by default comes with several versions of C++ redistributables going back to Visual Studio 2005. All of these redistributables are also regularly maintained with Windows Update.<p>Finally, Windows SDK versions targeting various versions of Windows are available for all supported Visual Studio developer environments. The oldest currently available in Visual Studio 2022 is Windows XP SP3[1].<p>These all serve to thoroughly solve both combinations of backward-forward compatibility, where (a) the runtime environment is newer than the developer environment, and (b), the runtime environment is older than the developer environment.<p>It is perfectly possible to compile a single `.exe` on Visual Studio 2022 in Windows 11, and expect it to run on Windows XP SP3, and the vice versa: compile a single `.exe` on Visual Studio 6, and expect it to run on Windows 11. No dynamic libraries, no DLLs, nothing; just a naked `.exe`. Download from website, double-click to run. That&#x27;s <i>it</i>. No git clone, no GNU Autotools, no configure, no make, no make install (and then f*cking with rpaths), nothing. Prioritising binary-only software distribution means Windows has prioritised the end-user experience.<p>&gt; It&#x27;s where the phrase &quot;DLL hell&quot; originated, after all.<p>This is also incorrect. &#x27;DLL hell&#x27; is a pre-NT problem that originated when packagers decided it was a good idea to overwrite system binaries by installing their own versions into system directories[2]. Sure, the versioning problem was there too, but this is itself a result of the aforementioned DLL stomping.<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;configuring-programs-for-windows-xp?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;configuring-prog...</a>
[2]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DLL_Hell#DLL_stomping" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DLL_Hell#DLL_stomping</a><p>I fully daresay writing C and C++ for Windows is an easier matter than targeting <i>any</i> Unix-like. For context, see what video game developers and Valve have done to check off the &#x27;works on Linux&#x27; checkbox: glibc updates are so ridiculously painful that Valve resorted to simply patching WINE and releasing it as Proton, and WINE is the ABI target for video games on Linux.</div><br/><div id="40360682" class="c"><input type="checkbox" id="c-40360682" checked=""/><div class="controls bullet"><span class="by">jraph</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359870">parent</a><span>|</span><a href="#40359657">next</a><span>|</span><label class="collapse" for="c-40360682">[-]</label><label class="expand" for="c-40360682">[12 more]</label></div><br/><div class="children"><div class="content">That Windows is generally better at handling compatibility is one thing, but I&#x27;m curious about the following part:<p>&gt; There&#x27;s a good reason for this, which IMO Unix-like compilers and system libraries should start adopting, too.<p>Why? I&#x27;m understanding from your comment that you can&#x27;t mix debug and release objects on Windows because the ABI is different. That&#x27;s not a feature, that&#x27;s a limitation. If it works on Linux to mix debug-enabled objects with &quot;release&quot;, what use would it have to make it not work anymore?<p>IIUC debug symbols can be totally separated from the object code, such that you can debug the release if you download the debug symbols. A well configured GDB on distros that offer this feature is able to do it automatically for you. It seems very useful and elegant. Why can&#x27;t Windows do something like this and how is it an advantage?<p>(Genuine question, I have a remote idea on how ELF works (wrote a toy linker), not much how DWARF works, and not the slightest idea on how all this stuff works on Windows)</div><br/><div id="40362702" class="c"><input type="checkbox" id="c-40362702" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360682">parent</a><span>|</span><a href="#40360915">next</a><span>|</span><label class="collapse" for="c-40362702">[-]</label><label class="expand" for="c-40362702">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  If it works on Linux to mix debug-enabled objects with &quot;release&quot;<p>it definitely does not. MSVC&#x27;s debug mode is akin to for instance using libstdc++ with -D_GLIBCXX_DEBUG which <i>does</i> change the ABI. Just passing &quot;-g&quot; which enable debug symbols is very different from what Microsoft calls Debug mode, which adds very extensive checks at all levels of the standard library (for instance, iterators become fat objects which track provenance, algorithms check preconditions such as &quot;the input data is sorted&quot;, etc.)</div><br/><div id="40364202" class="c"><input type="checkbox" id="c-40364202" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40362702">parent</a><span>|</span><a href="#40360915">next</a><span>|</span><label class="collapse" for="c-40364202">[-]</label><label class="expand" for="c-40364202">[1 more]</label></div><br/><div class="children"><div class="content">Note tough that libstdc++ has an ABI compatible debug mode that still adds a significant amount debug checks (and it is meant for production deployment).</div><br/></div></div></div></div><div id="40360915" class="c"><input type="checkbox" id="c-40360915" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360682">parent</a><span>|</span><a href="#40362702">prev</a><span>|</span><a href="#40361096">next</a><span>|</span><label class="collapse" for="c-40360915">[-]</label><label class="expand" for="c-40360915">[4 more]</label></div><br/><div class="children"><div class="content">Yes, I wonder that too. The comment says that debug and release builds have ABIs because they have different type layouts. But why do they have different type layouts? Bounds checking and assertions shouldn’t change the type layout. It seems to me that debug flags should generally only modify code generation &amp; asserts. This is usually the case on Linux, and it’s extremely convenient.<p>If windows is going to insist on different libraries in debug and release mode, I wish the development version of the library bundled debug and release builds together so I could just say “link with library X” and the compiler, linker and runtime would just figure it out. (Like framework bundles on the Mac). Windows could start by having a standard for library file naming - foo.obj&#x2F;dll for release and foo-debug.obj&#x2F;dll for debug builds or something. Then make the compiler smart enough to pick the right file automatically.<p>Seriously. It’s 2024. We know how to make good compiler tooling (look at go, Swift, rust, etc). There’s no sane reason that C++ has to be so unbelievably complex and horrible to work with.</div><br/><div id="40364262" class="c"><input type="checkbox" id="c-40364262" checked=""/><div class="controls bullet"><span class="by">tlb</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360915">parent</a><span>|</span><a href="#40361201">next</a><span>|</span><label class="collapse" for="c-40364262">[-]</label><label class="expand" for="c-40364262">[1 more]</label></div><br/><div class="children"><div class="content">Windows debug builds add extra sanity checks for which it needs extra members in types. For instance, a vector&lt;T&gt;::iterator is just a T* in a regular build, but in a debug build it also keeps a pointer to the vector so it can check bounds on every access.<p>But yes, C++ punts a lot of things to the build system, partly because the standard has to work on embedded systems where shared libraries don’t exist. A better build system could fix most of these things, but every build system that tries ends up massively complicated and slow, like Bazel.</div><br/></div></div><div id="40361201" class="c"><input type="checkbox" id="c-40361201" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360915">parent</a><span>|</span><a href="#40364262">prev</a><span>|</span><a href="#40361731">next</a><span>|</span><label class="collapse" for="c-40361201">[-]</label><label class="expand" for="c-40361201">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I wish the development version of the library bundled debug and release builds together<p>Almost all do. Look for binary library releases; they almost always supply Debug and Release binaries together.<p>&gt; Windows could start by having a standard for library file naming - foo.obj&#x2F;dll for release and foo-debug.obj&#x2F;dll for debug builds or something.<p>Funnily enough, it does. foo.lib for Release; food.lib for Debug.</div><br/></div></div><div id="40361731" class="c"><input type="checkbox" id="c-40361731" checked=""/><div class="controls bullet"><span class="by">DHowett</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360915">parent</a><span>|</span><a href="#40361201">prev</a><span>|</span><a href="#40361096">next</a><span>|</span><label class="collapse" for="c-40361731">[-]</label><label class="expand" for="c-40361731">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Bounds checking and assertions shouldn’t change the type layout.<p>Any bounds checks and assertions that rely on storing additional data such as valid iterator ranges or mutation counters would need to change the type layout, wouldn&#x27;t they?<p>Even if the STL were purely a header-only library (and influenced only by code generation changes for debug builds), there&#x27;s still the problem of ABI compatibility across different translation units--or different libraries--which might be built with different options.<p>EDIT: One of your sibling comments goes into greater detail!</div><br/></div></div></div></div><div id="40361096" class="c"><input type="checkbox" id="c-40361096" checked=""/><div class="controls bullet"><span class="by">delta_p_delta_x</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360682">parent</a><span>|</span><a href="#40360915">prev</a><span>|</span><a href="#40360920">next</a><span>|</span><label class="collapse" for="c-40361096">[-]</label><label class="expand" for="c-40361096">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a bit of a conflation here; partially my fault. Allow me to clarify...<p>To generate debug symbols for a given binary (whether executable or library) on Windows and MSVC&#x27;s cl.exe (and Clang on Windows), compile with `&#x2F;DEBUG`[1] and one of `&#x2F;Z7`, `&#x2F;Zi`, or `&#x2F;ZI`[2]. This is equivalent to `-g` on Linux gcc&#x2F;clang. In particular, `&#x2F;Z7` generates separate `.pdb` files, which contain debug symbols for the binary in question.<p>The options that the parent commenter and I were discussing, i.e. `&#x2F;MD`, `&#x2F;MDd`, &#x2F;MT`, and `&#x2F;MTd`[3] have to do with the <i>C and C++ runtime</i> link configuration. These correspond to multithreaded dynamic, multithreaded dynamic debug, multithreaded static, and multithreaded static debug respectively. Therefore, the small `d` refers to debug versions of the C and C++ runtimes. The differences between the debug and release versions of the C and C++ runtimes are listed in the following links[4][5][6][7][8]. The last link in particular demonstrates the debug CRT&#x27;s functionality.<p>Conventionally on Windows, debug binaries are linked to the debug versions of the C and C++ runtimes; ergo the requirement that &#x27;Release and Debug binaries on Windows cannot be combined&#x27;. This convention is respected by all maintainers who release binary libraries on Windows.<p>There is <i>no equivalent</i> on Unix-likes: it&#x27;d be like having &#x27;debug&#x27; versions of libc.so.6&#x2F;libstdc++.so&#x2F;libc++.so&#x2F;libpthread.so with different ABIs. If you wanted to change between release&#x2F;debug here, you <i>would</i> have to at least re-link (if not re-compile) everything. Imagine having `-cstdlib=libc-debug` and `stdlib=libc++-debug` options.<p>Both sets of options (debug symbol options and C runtime link options) are orthogonal, and may be freely combined. Hence, it is perfectly possible to link the debug versions of the C and C++ runtimes to a &#x27;release&#x27; executable, although it would be pretty weird. For instance, `&#x2F;O2 &#x2F;LTCG &#x2F;arch:AVX2 &#x2F;MTd`. Equivalent imaginary GNU-style command: `-O3 -flto=thin -march=x86-64-v3 -cstdlib=libc-debug stdlib=libc++-debug -static`. You can see what I mean, I hope.<p>[1]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;debug-generate-debug-info?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;debug-...</a><p>[2]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;z7-zi-zi-debug-information-format?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;z7-zi-...</a><p>[3]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;md-mt-ld-use-run-time-library?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;md-mt-...</a><p>[4]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;c-run-time-library-reference?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;c-ru...</a><p>[5]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;crt-library-features?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;crt-...</a><p>[6]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;debug-routines?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;debu...</a><p>[7]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;run-time-error-checking?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;run-...</a><p>[8]: <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;crt-debugging-techniques?view=msvc-170" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-gb&#x2F;cpp&#x2F;c-runtime-library&#x2F;crt-...</a></div><br/></div></div><div id="40360920" class="c"><input type="checkbox" id="c-40360920" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360682">parent</a><span>|</span><a href="#40361096">prev</a><span>|</span><a href="#40359657">next</a><span>|</span><label class="collapse" for="c-40360920">[-]</label><label class="expand" for="c-40360920">[4 more]</label></div><br/><div class="children"><div class="content">&gt; If it works on Linux to mix debug-enabled objects with &quot;release&quot;, what use would it have to make it not work anymore?<p>There is no difference between Linux and Windows here. The debug&#x2F;release issue is ultimately up to the API developer.<p>C++ has has the standard template library (STL). libstdc++, libc++, and MSVC STL are three different implementations. STL defines various iterators. A common choice is for a release-mode iterator to be a raw pointer, just 8 bytes on 64-bit. But the debug-mode iterator is a struct with some extra information for runtime validation, so it&#x27;s 24 bytes!<p>The end result is that if you pass an iterator to a function that iterator is effectively two completely different types with different memory layouts on debug and release. This is a common issue with C++. Less so with C. But it&#x27;s not a platform choice per se.<p>&gt; IUC debug symbols can be totally separated from the object code, such that you can debug the release if you download the debug symbols. A well configured GDB on distros that offer this feature is able to do it automatically for you. It seems very useful and elegant. Why can&#x27;t Windows do something like this and how is it an advantage?<p>MSVC always generates separate .pdb files for debug symbols. Windows tooling has spectacular tooling support for symbol servers (download symbols) and source indexing (download source code). It&#x27;s great.</div><br/><div id="40361593" class="c"><input type="checkbox" id="c-40361593" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360920">parent</a><span>|</span><a href="#40359657">next</a><span>|</span><label class="collapse" for="c-40361593">[-]</label><label class="expand" for="c-40361593">[3 more]</label></div><br/><div class="children"><div class="content">The difference is that on Linux, &quot;compile my program in debug mode&quot; does not enable libstdc++&#x27;s expensive (and incompatible) mode.</div><br/><div id="40362716" class="c"><input type="checkbox" id="c-40362716" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40361593">parent</a><span>|</span><a href="#40361883">next</a><span>|</span><label class="collapse" for="c-40362716">[-]</label><label class="expand" for="c-40362716">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The difference is that on Linux, &quot;compile my program in debug mode&quot;<p>&quot;Linux&quot; does not have a &quot;compile my program in debug mode&quot; magic toggle (or Release or whatever for what it&#x27;s worth). Different IDEs and toolchains may have different defaults and expectations. &quot;g++ -g&quot; is not debug mode, it&#x27;s debug symbols.</div><br/></div></div><div id="40361883" class="c"><input type="checkbox" id="c-40361883" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40361593">parent</a><span>|</span><a href="#40362716">prev</a><span>|</span><a href="#40359657">next</a><span>|</span><label class="collapse" for="c-40361883">[-]</label><label class="expand" for="c-40361883">[1 more]</label></div><br/><div class="children"><div class="content">My point is the real difference is the implementation of the three libraries. It&#x27;s not a fundamental platform difference.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="40359657" class="c"><input type="checkbox" id="c-40359657" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359485">parent</a><span>|</span><a href="#40359870">prev</a><span>|</span><a href="#40360349">next</a><span>|</span><label class="collapse" for="c-40359657">[-]</label><label class="expand" for="c-40359657">[9 more]</label></div><br/><div class="children"><div class="content">&gt; The Windows problem has always been so so much worse<p>Hard, hard disagree. The problems are somewhat comparable. But if any platform is more painful it&#x27;s Linux. Although they&#x27;re similar if you exclude glibc pain. At least in my personal experience of writing lots of code that needs to run on win&#x2F;mac&#x2F;linux&#x2F;android.<p>&gt; pretty much all developers simple resorted to shipping the OS system runtime with every package<p>Meanwhile Linux developers have resorted to shipping an entire OS via docker to run every program. Because managing Linux environment dependencies is so painful you have to package the whole system.<p>Needing to docker to simply launch a program is so embarrassing.<p>&gt; except of course you can&#x27;t even combine some modules compiled for debug with modules compiled without debug in the same executable<p>That&#x27;s not any different on Linux. That has more to do with C++.</div><br/><div id="40360045" class="c"><input type="checkbox" id="c-40360045" checked=""/><div class="controls bullet"><span class="by">graemep</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359657">parent</a><span>|</span><a href="#40360243">next</a><span>|</span><label class="collapse" for="c-40360045">[-]</label><label class="expand" for="c-40360045">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Meanwhile Linux developers have resorted to shipping an entire OS via docker to run every program.
&gt; Needing to docker to simply launch a program is so embarrassing.<p>I have never needed docker &quot;just to launch a program&quot;. Docker makes it easy to provide multiple containerised copies of an identical environment. Containers are a light alternative to VM images.<p>I assume you find the existence of Windows containers just as embarrassing? <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;virtualization&#x2F;windowscontainers&#x2F;about&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;virtualization&#x2F;windowscont...</a></div><br/><div id="40360167" class="c"><input type="checkbox" id="c-40360167" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360045">parent</a><span>|</span><a href="#40360243">next</a><span>|</span><label class="collapse" for="c-40360167">[-]</label><label class="expand" for="c-40360167">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Docker makes it easy to provide multiple containerised copies of an identical environment.<p>Correct. The Linux architecture around a global of dependencies is, imho, bad and wrong. The thesis is it&#x27;s good because you can deploy a security fix to libfoo.so just once for the whole system. However we now live in a world where you actually need to deploy the updated libfoo.so to all your various hierarchical Docker images. <i>sad trombone</i><p>&gt; Containers are a light alternative to VM images.<p>A light alternative to Docker is simply deploy your dependencies and not rely on a fragile, complicated global environment.<p>&gt; I assume you find the existence of Windows containers just as embarrassing?<p>Yes.<p>I know my opinion is deeply unpopular. But I stand by it! Running a program should be as simple as downloading a zip, extracting, and running the executable. It&#x27;s not hard!</div><br/><div id="40363171" class="c"><input type="checkbox" id="c-40363171" checked=""/><div class="controls bullet"><span class="by">rixed</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360167">parent</a><span>|</span><a href="#40361054">next</a><span>|</span><label class="collapse" for="c-40363171">[-]</label><label class="expand" for="c-40363171">[1 more]</label></div><br/><div class="children"><div class="content">I wish you all had experienced the golden age when running a program was as simple as apt-get install program and run it.<p>I find it hard to discuss the merits of Linux va windows with regard to deploying software without addressing the elephant in the room which is the replacement of a collectively maintained system that ensure software cohabitation by the modern compartmentalised collection of independent programs.</div><br/></div></div><div id="40361054" class="c"><input type="checkbox" id="c-40361054" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360167">parent</a><span>|</span><a href="#40363171">prev</a><span>|</span><a href="#40360243">next</a><span>|</span><label class="collapse" for="c-40361054">[-]</label><label class="expand" for="c-40361054">[1 more]</label></div><br/><div class="children"><div class="content">I guess your software is not libre, right?<p>In that case, I think you should stick to snap and flatpak.</div><br/></div></div></div></div></div></div><div id="40360243" class="c"><input type="checkbox" id="c-40360243" checked=""/><div class="controls bullet"><span class="by">fullspectrumdev</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359657">parent</a><span>|</span><a href="#40360045">prev</a><span>|</span><a href="#40360349">next</a><span>|</span><label class="collapse" for="c-40360243">[-]</label><label class="expand" for="c-40360243">[4 more]</label></div><br/><div class="children"><div class="content">Instead of Docker, static linking is a <i>much</i> more elegant solution if library&#x2F;dep management is painful.<p>Switching to static linking using a sane libc (not glibc) can be a pain initially but you end up with way less overhead IMO.</div><br/><div id="40360961" class="c"><input type="checkbox" id="c-40360961" checked=""/><div class="controls bullet"><span class="by">munchler</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360243">parent</a><span>|</span><a href="#40362722">next</a><span>|</span><label class="collapse" for="c-40360961">[-]</label><label class="expand" for="c-40360961">[2 more]</label></div><br/><div class="children"><div class="content">Static linking is a good way to avoid the problem, but I’d hardly call it “elegant” to replicate the same runtime library in every executable. It’s very wasteful - we’re just fortunate to have enough storage these days to get away with it.</div><br/><div id="40361655" class="c"><input type="checkbox" id="c-40361655" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360961">parent</a><span>|</span><a href="#40362722">next</a><span>|</span><label class="collapse" for="c-40361655">[-]</label><label class="expand" for="c-40361655">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I’d hardly call it “elegant” to replicate the same runtime library in every executable. It’s very wasteful - we’re just fortunate to have enough storage these days to get away with it.<p>I think you need to quantify &quot;very wasteful&quot;. Quite frankly it&#x27;s actually just fine. Totally fine. Especially when the alternative has turned out to be massive Docker images! So the alternative isn&#x27;t actually any better. Womp womp.<p>An actually elegant solution would be a copy-on-write filesystem that can deduplicate. It&#x27;d be the best of both worlds.</div><br/></div></div></div></div><div id="40362722" class="c"><input type="checkbox" id="c-40362722" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360243">parent</a><span>|</span><a href="#40360961">prev</a><span>|</span><a href="#40360349">next</a><span>|</span><label class="collapse" for="c-40362722">[-]</label><label class="expand" for="c-40362722">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Switching to static linking using a sane libc (not glibc) can be a pain initially but you end up with way less overhead IMO.<p>how does that work when you app needs access to the gpu drivers ?</div><br/></div></div></div></div></div></div></div></div><div id="40360349" class="c"><input type="checkbox" id="c-40360349" checked=""/><div class="controls bullet"><span class="by">Sesse__</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40359485">prev</a><span>|</span><a href="#40363663">next</a><span>|</span><label class="collapse" for="c-40360349">[-]</label><label class="expand" for="c-40360349">[3 more]</label></div><br/><div class="children"><div class="content">Linking to the latest version of glibc is, in itself, not a problem -- glibc hasn&#x27;t bumped its soname in ages, it is using symbol versioning instead. So you only get a problem if you use a symbol that doesn&#x27;t exist in older glibc (i.e., some specific interface that you are using changed).<p>As for using an older version of glibc, _linking_ isn&#x27;t the problem -- swapping out the header files would be. You can probably install an old version of the header files somewhere else and just -I that directory, but I&#x27;ve never tried. libstdc++ would probably be harder, if you&#x27;re in C++ land.</div><br/><div id="40360518" class="c"><input type="checkbox" id="c-40360518" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360349">parent</a><span>|</span><a href="#40363663">next</a><span>|</span><label class="collapse" for="c-40360518">[-]</label><label class="expand" for="c-40360518">[2 more]</label></div><br/><div class="children"><div class="content">Recent libstdc++ has a _dl_find_object@GLIBC_2.35 dependency, so it&#x27;s not exactly trivial anymore to link a C++ program against a older, side-installed glibc version because it won&#x27;t have that symbol. It&#x27;s possible to work around that (link against a stub that has _dl_find_object@GLIBC_2.35 as a compat symbol, so that libstdc++ isn&#x27;t rejected), but linking statically is much more difficult because libstc++.a (actually, libgcc_eh.a) does not have the old code anymore that _dl_find_object replaces (once GCC is built against a glibc version that has _dl_find_object).<p>This applies to other libraries as well because there are new(ish) math functions, strlcpy, posix_spawn extensions etc. that seem to be quite widely used already.</div><br/><div id="40364489" class="c"><input type="checkbox" id="c-40364489" checked=""/><div class="controls bullet"><span class="by">ynik</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360518">parent</a><span>|</span><a href="#40363663">next</a><span>|</span><label class="collapse" for="c-40364489">[-]</label><label class="expand" for="c-40364489">[1 more]</label></div><br/><div class="children"><div class="content">I find it&#x27;s best to treat this as a case of &quot;cross-compilation to old glibc version&quot;.
That is, you don&#x27;t want to just link against an old glibc version, you want a full cross-compilation toolchain where the compiler does not pick up headers from `&#x2F;usr&#x2F;include` by default (but instead has its own copy of the system headers), and where libstdc++ is also linked against that old glibc version.<p>We used <a href="https:&#x2F;&#x2F;crosstool-ng.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;crosstool-ng.github.io&#x2F;</a> to create such a &quot;cross-compiler&quot;. Now it doesn&#x27;t matter which distribution our developers use, the same source code will always turn into the same binary (reproducible builds, yay!) and those binaries will work on older distributions than the developers are using. This allows us to ship dynamically linked linux executables; our linux customers can just unzip + run, same as our windows customers, no need to mess with docker containers.<p>The downside is that we can&#x27;t just use a library by `apt install`ing it, everything needs to be built with the cross compilation toolchain.</div><br/></div></div></div></div></div></div><div id="40363663" class="c"><input type="checkbox" id="c-40363663" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40360349">prev</a><span>|</span><a href="#40359436">next</a><span>|</span><label class="collapse" for="c-40363663">[-]</label><label class="expand" for="c-40363663">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re building Rust, check out cargo zigbuild (yes, zigbuild) which lets you target old glibc.</div><br/></div></div><div id="40359436" class="c"><input type="checkbox" id="c-40359436" checked=""/><div class="controls bullet"><span class="by">forrestthewoods</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40363663">prev</a><span>|</span><a href="#40359385">next</a><span>|</span><label class="collapse" for="c-40359436">[-]</label><label class="expand" for="c-40359436">[4 more]</label></div><br/><div class="children"><div class="content">&gt; They are a problem because gcc automatically links to the latest version of glibc. As to why they don&#x27;t add an option to specify an older version?<p>Because glibc and ld&#x2F;lld are badly designed. glibc is stuck in the 80s with awful and unnecessary automagic configure steps. ld&#x2F;lld expect a full and complete shared library to exist when compiling even though it expects a different shared library to exist in the future.<p>Zig solves the glibc linking issue. You can trivially target any old version for any supported target platform. The only thing you actually need are headers and a thin, implementation free lib that contains stub functions. Unfortunately glibc is not architected to make this trivial. But this is just because glibc is stuck with decades of historic cruft, not because it&#x27;s actually a hard problem.</div><br/><div id="40360479" class="c"><input type="checkbox" id="c-40360479" checked=""/><div class="controls bullet"><span class="by">einpoklum</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359436">parent</a><span>|</span><a href="#40359385">next</a><span>|</span><label class="collapse" for="c-40360479">[-]</label><label class="expand" for="c-40360479">[3 more]</label></div><br/><div class="children"><div class="content">&gt; awful and unnecessary automagic configure steps<p>Steps taken when? When building glibc? And - what steps?<p>&gt; ld&#x2F;lld expect a full and complete shared library to exist when compiling ...<p>But ld and lld are linkers...<p>&gt; Zig solves the glibc linking issue.<p>But Zig is a language. Do you mean the Zig standard library? The Zig compiler?<p>&gt; The only thing you actually need are headers and a thin, implementation free lib that contains stub functions.<p>Why do you need stub functions at all, if you&#x27;re not actually using them?</div><br/><div id="40362928" class="c"><input type="checkbox" id="c-40362928" checked=""/><div class="controls bullet"><span class="by">ploxiln</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360479">parent</a><span>|</span><a href="#40360730">next</a><span>|</span><label class="collapse" for="c-40362928">[-]</label><label class="expand" for="c-40362928">[1 more]</label></div><br/><div class="children"><div class="content">The zig compiler can compile C and C++, using llvm, and it also packages various libc implementations, including glibc, musl, mingw, and msvc, and more for other OSes. Some people use it as a more convenient golang-like cross-compiler. And this whole combination is a smaller download and install than most other toolchains out there. It just took some inspiration and grunt work, to dissect the necessary (processed) headers and other bits of each libc ... hats of to the zig devs.<p>Random blog post I just found about it: <a href="https:&#x2F;&#x2F;ruoyusun.com&#x2F;2022&#x2F;02&#x2F;27&#x2F;zig-cc.html" rel="nofollow">https:&#x2F;&#x2F;ruoyusun.com&#x2F;2022&#x2F;02&#x2F;27&#x2F;zig-cc.html</a></div><br/></div></div></div></div></div></div><div id="40359385" class="c"><input type="checkbox" id="c-40359385" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40359436">prev</a><span>|</span><a href="#40361040">next</a><span>|</span><label class="collapse" for="c-40359385">[-]</label><label class="expand" for="c-40359385">[7 more]</label></div><br/><div class="children"><div class="content">I think the main reason they don&#x27;t offer a `--make-my-binary-compatible-with-the-ancient-linux-versions-users-often-have` is that GCC&#x2F;glibc is a GNU project and the are philosophically against distributing software as binaries.<p>I don&#x27;t think there&#x27;s any technical reason why it couldn&#x27;t be done.<p>To be fair to them though, Mac has the same problem. I worked at a company where we had to keep old Mac machines to produce compatible binaries, and Apple makes it hard to even download old versions of MacOS and Xcode.<p>I guess the difference is MacOS is easy to upgrade so you don&#x27;t have to support versions from 13 years ago or whatever like you do with glibc.</div><br/><div id="40360437" class="c"><input type="checkbox" id="c-40360437" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359385">parent</a><span>|</span><a href="#40359480">next</a><span>|</span><label class="collapse" for="c-40360437">[-]</label><label class="expand" for="c-40360437">[2 more]</label></div><br/><div class="children"><div class="content">I used to think that binary compatibility benefits proprietary applications, but I&#x27;m not so sure anymore. From a commercial perspective, when we break binary compatibility (not that we want to), it&#x27;s an opportunity for selling more stuff.<p>Many distributions do periodic mass rebuilds anyway and do not need that much long-term ABI compatibility. Binary compatibility seems mostly for people who compile their own software, but have not automated that and therefore couldn&#x27;t keep up with updates if there wasn&#x27;t ABI compatibility.</div><br/><div id="40363640" class="c"><input type="checkbox" id="c-40363640" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40360437">parent</a><span>|</span><a href="#40359480">next</a><span>|</span><label class="collapse" for="c-40363640">[-]</label><label class="expand" for="c-40363640">[1 more]</label></div><br/><div class="children"><div class="content">I agree. It&#x27;s annoying for closed source apps but they generally have the resources to deal with it anyway. E.g. with Questa I can just unzip it and run it. No trouble.<p>It&#x27;s disproportionately annoying for open source projects who don&#x27;t want to waste their time dealing with this.</div><br/></div></div></div></div><div id="40359480" class="c"><input type="checkbox" id="c-40359480" checked=""/><div class="controls bullet"><span class="by">codexon</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359385">parent</a><span>|</span><a href="#40360437">prev</a><span>|</span><a href="#40361040">next</a><span>|</span><label class="collapse" for="c-40359480">[-]</label><label class="expand" for="c-40359480">[4 more]</label></div><br/><div class="children"><div class="content">&gt; I think the main reason they don&#x27;t offer a `--make-my-binary-compatible-with-the-ancient-linux-versions-users-often-have` is that GCC&#x2F;glibc is a GNU project and the are philosophically against distributing software as binaries.<p>You don&#x27;t have to statically compile glibc, gcc just needs an option to tell the compiler to target say, version 2.14 instead of the latest one.<p>The newest glibc has all the older versions in it. That&#x27;s why you can compile on say ubuntu 14 and have it run on ubuntu 24.</div><br/><div id="40359742" class="c"><input type="checkbox" id="c-40359742" checked=""/><div class="controls bullet"><span class="by">saurik</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359480">parent</a><span>|</span><a href="#40360459">next</a><span>|</span><label class="collapse" for="c-40359742">[-]</label><label class="expand" for="c-40359742">[2 more]</label></div><br/><div class="children"><div class="content">No like, the point is that the only reason you (and I: I do this all the time, including with my open source software... like: no judgment) want to target some old version of glibc is so you can distribute that binary to people without caring as much about what version of the OS they have; but that would be unnecessary if you just gave them the source code and have them compile their own copy for their system targeting the exact libraries they have.</div><br/><div id="40359796" class="c"><input type="checkbox" id="c-40359796" checked=""/><div class="controls bullet"><span class="by">codexon</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359742">parent</a><span>|</span><a href="#40360459">next</a><span>|</span><label class="collapse" for="c-40359796">[-]</label><label class="expand" for="c-40359796">[1 more]</label></div><br/><div class="children"><div class="content">Unfortunately most people don&#x27;t want to bother compiling, myself included. I tried gentoo one time and it took 1 hour to compile 5 minutes worth of apt-get on ubuntu.</div><br/></div></div></div></div><div id="40360459" class="c"><input type="checkbox" id="c-40360459" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359480">parent</a><span>|</span><a href="#40359742">prev</a><span>|</span><a href="#40361040">next</a><span>|</span><label class="collapse" for="c-40360459">[-]</label><label class="expand" for="c-40360459">[1 more]</label></div><br/><div class="children"><div class="content">Only the dynamically linked bits, the statically linked startup code and libc_nonshared.a are missing from newer versions. Most programs don&#x27;t need them (who needs working ELF constructors in the main program?). The libc_nonshared.a bits can be reimplemented from scratch easily enough (but we should switch them over to header-only implementations eventually).</div><br/></div></div></div></div></div></div><div id="40361040" class="c"><input type="checkbox" id="c-40361040" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#40358930">root</a><span>|</span><a href="#40359283">parent</a><span>|</span><a href="#40359385">prev</a><span>|</span><a href="#40362921">next</a><span>|</span><label class="collapse" for="c-40361040">[-]</label><label class="expand" for="c-40361040">[1 more]</label></div><br/><div class="children"><div class="content">chroot has existed for many years.</div><br/></div></div></div></div><div id="40362921" class="c"><input type="checkbox" id="c-40362921" checked=""/><div class="controls bullet"><span class="by">cookiengineer</span><span>|</span><a href="#40358930">parent</a><span>|</span><a href="#40359283">prev</a><span>|</span><a href="#40360587">next</a><span>|</span><label class="collapse" for="c-40362921">[-]</label><label class="expand" for="c-40362921">[1 more]</label></div><br/><div class="children"><div class="content">The problem is actually: nobody adhering to semantic versioning.<p>Hence the reason why there is a separate API&#x2F;ABI level embedded into a shared object file, which is pretty much always completely different from the library&#x27;s package version because they broke compatibility so often.<p>Additionally there&#x27;s lots of libraries that break their symbols and hash tables on every subminor update. (Usually when they use LLVM, but I&#x27;m not saying it&#x27;s LLVM&#x27;s fault)<p>For example, harfbuzz and libicu are a regular offender of this, meaning they fuck up every downstream project because the method signatures contain a randomized chunk which changes on every single subminor version.</div><br/></div></div><div id="40360587" class="c"><input type="checkbox" id="c-40360587" checked=""/><div class="controls bullet"><span class="by">fweimer</span><span>|</span><a href="#40358930">parent</a><span>|</span><a href="#40362921">prev</a><span>|</span><a href="#40361706">next</a><span>|</span><label class="collapse" for="c-40360587">[-]</label><label class="expand" for="c-40360587">[1 more]</label></div><br/><div class="children"><div class="content">You don&#x27;t have to update, it&#x27;s just that developers seem to like to run the latest stuff, and many appear to build production binaries on their laptops (rather than in a controlled build environment, where dependencies are tightly managed, and you could deliberately stick to an older distribution easily enough).<p>The dependency errors indicate real issues because of the way most distributions handle backwards compatibility: you have to build on the oldest version you want to support. Those errors happen if this rule is violated. For glibc-based systems, the effect is amplified because package managers have become quite good at modeling glibc run-time requirements in the package-level dependencies, and mismatches result in install-time dependency errors. Admittedly, I&#x27;m biased, but I strongly suspect that if we magically waved away the glibc dependency issues, most applications still wouldn&#x27;t work because they depend on other distribution components, something that&#x27;s just not visible today.</div><br/></div></div><div id="40361706" class="c"><input type="checkbox" id="c-40361706" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40358930">parent</a><span>|</span><a href="#40360587">prev</a><span>|</span><a href="#40359210">next</a><span>|</span><label class="collapse" for="c-40361706">[-]</label><label class="expand" for="c-40361706">[1 more]</label></div><br/><div class="children"><div class="content">Because:<p>* Developers like to be on the latest-and-greatest distro, and rarely perform builds in a chroot. Sometimes this is sheer apathy; other times it is because backporting library dependencies is annoying.<p>* End-users can&#x27;t even be assumed to be on the latest LTS.<p>Related, almost nobody understands `rpath` and why it should always be used instead of static linking (assuming normal dynamic linking doesn&#x27;t work of course). There&#x27;s some common FUD going around but unless you&#x27;re a setuid or similar program it&#x27;s not actually true (and even then, it&#x27;s only an issue with <i>some</i> uses of rpath).</div><br/></div></div></div></div><div id="40359210" class="c"><input type="checkbox" id="c-40359210" checked=""/><div class="controls bullet"><span class="by">david_draco</span><span>|</span><a href="#40358930">prev</a><span>|</span><a href="#40361486">next</a><span>|</span><label class="collapse" for="c-40359210">[-]</label><label class="expand" for="c-40359210">[1 more]</label></div><br/><div class="children"><div class="content">After reading so many GPT news item, I was confused what APT is, no explanation on the page, no link ... took me a while to realise it is about debian linux&#x27; packaging tool apt.</div><br/></div></div><div id="40361486" class="c"><input type="checkbox" id="c-40361486" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40359210">prev</a><span>|</span><a href="#40359232">next</a><span>|</span><label class="collapse" for="c-40361486">[-]</label><label class="expand" for="c-40361486">[2 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Solver3 is a fully backtracking dependency solving algorithm that defers choices to as late as possible. It starts with an empty set of packages, then adds the manually installed packages, and then installs packages automatically as necessary to satisfy the dependencies.</i> [...]<p>&gt; <i>If you have studied SAT solver design, you’ll find that essentially this is a DPLL solver without pure literal elimination</i><p>DPLL algorithm: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DPLL_algorithm" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DPLL_algorithm</a></div><br/><div id="40361710" class="c"><input type="checkbox" id="c-40361710" checked=""/><div class="controls bullet"><span class="by">westurner</span><span>|</span><a href="#40361486">parent</a><span>|</span><a href="#40359232">next</a><span>|</span><label class="collapse" for="c-40361710">[-]</label><label class="expand" for="c-40361710">[1 more]</label></div><br/><div class="children"><div class="content">prefix-dev&#x2F;pixi is a successor to Mamba and Conda which wraps libsolv like dnf. <a href="https:&#x2F;&#x2F;github.com&#x2F;prefix-dev&#x2F;pixi">https:&#x2F;&#x2F;github.com&#x2F;prefix-dev&#x2F;pixi</a><p>OpenSUSE&#x2F;libsolv: <a href="https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;libsolv">https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;libsolv</a><p>OpenSUSE&#x2F;zypper may have wrapped or may still wrap libsolv?<p>TIL libsolv also supports arch .apk and .deb; there&#x27;s a deb2solv utility to create libsolv .solv files: <a href="https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;libsolv&#x2F;blob&#x2F;master&#x2F;tools&#x2F;deb2solv.c">https:&#x2F;&#x2F;github.com&#x2F;openSUSE&#x2F;libsolv&#x2F;blob&#x2F;master&#x2F;tools&#x2F;deb2so...</a><p>&quot;[mamba-org&#x2F;rattler:] A new memory-safe SAT solver for package management in Rust (port of libsolv)&quot; (2024) 
<a href="https:&#x2F;&#x2F;prefix.dev&#x2F;blog&#x2F;the_new_rattler_resolver" rel="nofollow">https:&#x2F;&#x2F;prefix.dev&#x2F;blog&#x2F;the_new_rattler_resolver</a> <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37101862">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=37101862</a><p>Pixi is integrating uv: <a href="https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;uv&#x2F;issues&#x2F;1572#issuecomment-1949979306">https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;uv&#x2F;issues&#x2F;1572#issuecomment-194...</a><p>astral-sh&#x2F;uv [1] solves versions with PubGrub [2], which was written for Dart: [1] <a href="https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;uv">https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;uv</a> [2] <a href="https:&#x2F;&#x2F;github.com&#x2F;pubgrub-rs&#x2F;pubgrub">https:&#x2F;&#x2F;github.com&#x2F;pubgrub-rs&#x2F;pubgrub</a><p>uv&#x27;s benchmarks are run with hyperfine, a CLI benchmarking tool: <a href="https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;hyperfine">https:&#x2F;&#x2F;github.com&#x2F;sharkdp&#x2F;hyperfine</a><p>astral-sh&#x2F;rye was mitsuhiko&#x2F;rye, and rye wraps uv with &quot;fallback to unearth [resolvelib] and pip-tools&quot;: <a href="https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;rye">https:&#x2F;&#x2F;github.com&#x2F;astral-sh&#x2F;rye</a> <a href="https:&#x2F;&#x2F;lucumr.pocoo.org&#x2F;2024&#x2F;2&#x2F;15&#x2F;rye-grows-with-uv&#x2F;" rel="nofollow">https:&#x2F;&#x2F;lucumr.pocoo.org&#x2F;2024&#x2F;2&#x2F;15&#x2F;rye-grows-with-uv&#x2F;</a><p>So, TIL it looks like rye for python and pixi for conda (python, r, rust, go,) are the latest tools for python packaging, not apt packaging.<p>fpm is one way to create deb packages from python virtualenvs for install with the new APT solver, which resulted in this research.</div><br/></div></div></div></div><div id="40359232" class="c"><input type="checkbox" id="c-40359232" checked=""/><div class="controls bullet"><span class="by">gsich</span><span>|</span><a href="#40361486">prev</a><span>|</span><a href="#40359180">next</a><span>|</span><label class="collapse" for="c-40359232">[-]</label><label class="expand" for="c-40359232">[9 more]</label></div><br/><div class="children"><div class="content">From the guy that brought you the keepassxc downgrade.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;keepassxreboot&#x2F;keepassxc&#x2F;issues&#x2F;10725">https:&#x2F;&#x2F;github.com&#x2F;keepassxreboot&#x2F;keepassxc&#x2F;issues&#x2F;10725</a></div><br/><div id="40360595" class="c"><input type="checkbox" id="c-40360595" checked=""/><div class="controls bullet"><span class="by">j1elo</span><span>|</span><a href="#40359232">parent</a><span>|</span><a href="#40359971">next</a><span>|</span><label class="collapse" for="c-40360595">[-]</label><label class="expand" for="c-40360595">[3 more]</label></div><br/><div class="children"><div class="content">Wait so this guy decided to fork the project, and seemingly abused his position to supplant the previous version with his own opinionated fork? All this while disregarding the opinion of upstream devs themselves and being arrogant and stubborn in his replies.<p>What an spectacular way to break things for end users.<p>If there&#x27;s one thing to learn and apply from Linus, IMHO, is his attitude about NEVER breaking userspace in the Kernel. This lesson can be adapted to most software, and we really should strive to more of it, not less (obviously adjusting to each case; here, replace &quot;userspace&quot; with &quot;user setups&quot;)</div><br/><div id="40361111" class="c"><input type="checkbox" id="c-40361111" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40359232">root</a><span>|</span><a href="#40360595">parent</a><span>|</span><a href="#40359971">next</a><span>|</span><label class="collapse" for="c-40361111">[-]</label><label class="expand" for="c-40361111">[2 more]</label></div><br/><div class="children"><div class="content">First, this is not in Debian <i>stable</i> (yet). Issues like this is one reason why Debian <i>testing</i>&#x2F;<i>unstable</i> exist. Secondly, it is common and expected for distributions to select the feature flags they deem appropriate. It is not a fork. The mistake here was not to provide a compatible upgrade option in addition to the new default.</div><br/><div id="40362977" class="c"><input type="checkbox" id="c-40362977" checked=""/><div class="controls bullet"><span class="by">Spivak</span><span>|</span><a href="#40359232">root</a><span>|</span><a href="#40361111">parent</a><span>|</span><a href="#40359971">next</a><span>|</span><label class="collapse" for="c-40362977">[-]</label><label class="expand" for="c-40362977">[1 more]</label></div><br/><div class="children"><div class="content">When I found out that it was just in unstable my position flipped on it. The guy has
no business being as crass as he is in the comments section of the GH issue but lack of tact from an opinionated software dev in internet discourse is nothing new. And the point behind the petty of switching to package&#x2F;package-full, which is pretty standard in the Debian world, is perfectly reasonable so long as it happens on a major version bump.<p>I don&#x27;t disagree that it&#x27;s annoying to the upstream devs but c&#x27;est la vie when you have a bunch of 3rd parties repackaging your code. They won&#x27;t be the first to have a &quot;uninstall your distro&#x27;s package and install the upstream version before reporting a bug&quot; in their issue template.</div><br/></div></div></div></div></div></div><div id="40359971" class="c"><input type="checkbox" id="c-40359971" checked=""/><div class="controls bullet"><span class="by">bjoli</span><span>|</span><a href="#40359232">parent</a><span>|</span><a href="#40360595">prev</a><span>|</span><a href="#40359239">next</a><span>|</span><label class="collapse" for="c-40359971">[-]</label><label class="expand" for="c-40359971">[1 more]</label></div><br/><div class="children"><div class="content">I never thought I would say this but: I am a pretty recent flatpak convert. This thing just made me more convinced about how it is a good thing to let the Devs deliver the apps themselves and let the distro people do the distro stuff.<p>After accepting flatpak I started using fedora silverblue and then switched to opensuse aeon and I have been very happy. The only pain point was getting Emacs working properly.</div><br/></div></div><div id="40359239" class="c"><input type="checkbox" id="c-40359239" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#40359232">parent</a><span>|</span><a href="#40359971">prev</a><span>|</span><a href="#40362215">next</a><span>|</span><label class="collapse" for="c-40359239">[-]</label><label class="expand" for="c-40359239">[3 more]</label></div><br/><div class="children"><div class="content">What downgrade are you referring to?</div><br/><div id="40359267" class="c"><input type="checkbox" id="c-40359267" checked=""/><div class="controls bullet"><span class="by">gsich</span><span>|</span><a href="#40359232">root</a><span>|</span><a href="#40359239">parent</a><span>|</span><a href="#40362215">next</a><span>|</span><label class="collapse" for="c-40359267">[-]</label><label class="expand" for="c-40359267">[2 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;github.com&#x2F;keepassxreboot&#x2F;keepassxc&#x2F;issues&#x2F;10725">https:&#x2F;&#x2F;github.com&#x2F;keepassxreboot&#x2F;keepassxc&#x2F;issues&#x2F;10725</a></div><br/><div id="40359351" class="c"><input type="checkbox" id="c-40359351" checked=""/><div class="controls bullet"><span class="by">k8sToGo</span><span>|</span><a href="#40359232">root</a><span>|</span><a href="#40359267">parent</a><span>|</span><a href="#40362215">next</a><span>|</span><label class="collapse" for="c-40359351">[-]</label><label class="expand" for="c-40359351">[1 more]</label></div><br/><div class="children"><div class="content">Thanks. I love opensource drama.</div><br/></div></div></div></div></div></div><div id="40362215" class="c"><input type="checkbox" id="c-40362215" checked=""/><div class="controls bullet"><span class="by">noisy_boy</span><span>|</span><a href="#40359232">parent</a><span>|</span><a href="#40359239">prev</a><span>|</span><a href="#40359180">next</a><span>|</span><label class="collapse" for="c-40362215">[-]</label><label class="expand" for="c-40362215">[1 more]</label></div><br/><div class="children"><div class="content">Seems like another Pottering in making - my way or highway developer.</div><br/></div></div></div></div><div id="40359180" class="c"><input type="checkbox" id="c-40359180" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40359232">prev</a><span>|</span><label class="collapse" for="c-40359180">[-]</label><label class="expand" for="c-40359180">[27 more]</label></div><br/><div class="children"><div class="content">&gt; The most striking difference to the classic APT solver is that solver3 always keeps manually installed packages around, it never offers to remove them.<p>Y&#x27;know, when you put it like that it does seem rather obvious, doesn&#x27;t it? Principle of least surprise and all that.<p>Edit: To be clear, not knocking anyone for it; hindsight is 20&#x2F;20 and I&#x27;ve never written a dependency solving algorithm so I&#x27;m in no position to judge.</div><br/><div id="40360061" class="c"><input type="checkbox" id="c-40360061" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40359180">parent</a><span>|</span><a href="#40360021">next</a><span>|</span><label class="collapse" for="c-40360061">[-]</label><label class="expand" for="c-40360061">[24 more]</label></div><br/><div class="children"><div class="content">It’s not that clearcut, because sometimes you forget all the packages you installed manually over the years and aren’t using anymore, and it can make sense to be offered to remove one when it helps resolving a conflict with a newer package that you actually want to use now.</div><br/><div id="40360562" class="c"><input type="checkbox" id="c-40360562" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360061">parent</a><span>|</span><a href="#40361431">next</a><span>|</span><label class="collapse" for="c-40360562">[-]</label><label class="expand" for="c-40360562">[14 more]</label></div><br/><div class="children"><div class="content">The healthy choice is to rebuild rather than upgrade any long-lived OS installation (e.g. your desktop) on distro release.<p>Corollary: make it easy on yourself: mount &#x2F;home separately (and maybe &#x2F;var too), and keep &#x2F;etc in scm.</div><br/><div id="40360994" class="c"><input type="checkbox" id="c-40360994" checked=""/><div class="controls bullet"><span class="by">layer8</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360562">parent</a><span>|</span><a href="#40360826">next</a><span>|</span><label class="collapse" for="c-40360994">[-]</label><label class="expand" for="c-40360994">[4 more]</label></div><br/><div class="children"><div class="content">I’ve been upgrading Debian in-place for almost two decades now and prefer that approach. Security updates are automated (daily), major-version upgrades have almost no downtime, and only very rarely is there a critical configuration that needs to be adjusted.<p>The installed packages can be listed with `dpkg --get-selections`, and that list can be replayed should it be necessary to recreate the installation, plus a backup of &#x2F;etc&#x2F;. But I never had to do this, Debian just works.</div><br/><div id="40361083" class="c"><input type="checkbox" id="c-40361083" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360994">parent</a><span>|</span><a href="#40361050">next</a><span>|</span><label class="collapse" for="c-40361083">[-]</label><label class="expand" for="c-40361083">[2 more]</label></div><br/><div class="children"><div class="content">I was previously a maintainer of certain Debian packages, and of similar vintage, so this advice comes with the extra salt of having seen how the sausage is made. I shudder to think how many abandoned files, orphan packages, and obsolete&#x2F;bad-practice configurations might be lurking in a system that has only been release-upgraded for decades. Yes, no doubt it functions. By the same token, people can live in their own filth. Should they? I choose not to.<p>That said, I may do a speculative dist-upgrade on a snapshot to reveal &amp; prepare for conflicted conffiles in advance, but I&#x27;ll throw that away, I won&#x27;t rely on the merged result across a release upgrade.</div><br/><div id="40361900" class="c"><input type="checkbox" id="c-40361900" checked=""/><div class="controls bullet"><span class="by">calvinmorrison</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40361083">parent</a><span>|</span><a href="#40361050">next</a><span>|</span><label class="collapse" for="c-40361900">[-]</label><label class="expand" for="c-40361900">[1 more]</label></div><br/><div class="children"><div class="content">But when there&#x27;s a configuration change dpkg-configure asks you if you want the upstream one, no?</div><br/></div></div></div></div><div id="40361050" class="c"><input type="checkbox" id="c-40361050" checked=""/><div class="controls bullet"><span class="by">hsbauauvhabzb</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360994">parent</a><span>|</span><a href="#40361083">prev</a><span>|</span><a href="#40360826">next</a><span>|</span><label class="collapse" for="c-40361050">[-]</label><label class="expand" for="c-40361050">[1 more]</label></div><br/><div class="children"><div class="content">Debian releases are somewhat slower than Ubuntu or similar - given infinite time, esoteric configurations will break on update due to some edge case 4 dist-upgrades ago.</div><br/></div></div></div></div><div id="40360826" class="c"><input type="checkbox" id="c-40360826" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360562">parent</a><span>|</span><a href="#40360994">prev</a><span>|</span><a href="#40361725">next</a><span>|</span><label class="collapse" for="c-40360826">[-]</label><label class="expand" for="c-40360826">[4 more]</label></div><br/><div class="children"><div class="content">&gt; The healthy choice is to rebuild rather than upgrade any long-lived OS installation (e.g. your desktop) on distro release.<p>I wish there was more rigor (and testing) with this sort of thing. Generally systems should have the invariant that “install old” + “upgrade” == “install new”. This property can be fuzz tested with a bit of work - just make an automated distribution installer, install random sets of packages (or all of them), upgrade and see if the files all match.<p>&#x2F;etc makes this harder, since you’d want to migrate old configuration files rather than resetting configuration to the defaults. But I feel like this should be way more reliable in general. And people want that reliability - if the popularity of docker and nix are anything to go by.</div><br/><div id="40361135" class="c"><input type="checkbox" id="c-40361135" checked=""/><div class="controls bullet"><span class="by">inopinatus</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360826">parent</a><span>|</span><a href="#40361035">next</a><span>|</span><label class="collapse" for="c-40361135">[-]</label><label class="expand" for="c-40361135">[2 more]</label></div><br/><div class="children"><div class="content">Alas that many packages will not upgrade conffiles gracefully when their structure&#x2F;semantics change, and many are beyond the ability of any package manager&#x27;s built-in diffing tools to apprehend. That is why I place &#x2F;etc under scm for long-lived hosts, because what happens next instead looks an awful lot like doing a conflicted three-way code merge following a breaking-change vendor release. The greatest OMFGFFS in this realm, by far, came with the big lurch over to systemd.</div><br/><div id="40362128" class="c"><input type="checkbox" id="c-40362128" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40361135">parent</a><span>|</span><a href="#40361035">next</a><span>|</span><label class="collapse" for="c-40362128">[-]</label><label class="expand" for="c-40362128">[1 more]</label></div><br/><div class="children"><div class="content">related: <a href="https:&#x2F;&#x2F;etckeeper.branchable.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;etckeeper.branchable.com&#x2F;</a><p>&gt; The greatest OMFGFFS in this realm, by far, came with the big lurch over to systemd.<p>I think by the time I started with it, NixOS was already on systems, but reportedly that transition went off without a hitch. Before the transition, NixOS configs were in charge of generating OpenRC scripts or whatever, then afterwards the same configs generated systemd units instead. When the system has total control over the config files like that you get to bypass certain challenges!<p>You might notice that the old announcement for that feature includes no special care other than the requisite reboot to change init systems: <a href="https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20200423143059&#x2F;https:&#x2F;&#x2F;releases.nixos.org&#x2F;nix-dev&#x2F;2013-January&#x2F;010482.html" rel="nofollow">https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20200423143059&#x2F;https:&#x2F;&#x2F;releases....</a></div><br/></div></div></div></div><div id="40361035" class="c"><input type="checkbox" id="c-40361035" checked=""/><div class="controls bullet"><span class="by">LtWorf</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360826">parent</a><span>|</span><a href="#40361135">prev</a><span>|</span><a href="#40361725">next</a><span>|</span><label class="collapse" for="c-40361035">[-]</label><label class="expand" for="c-40361035">[1 more]</label></div><br/><div class="children"><div class="content">In theory yes, but this hits with the fact that defaults change.<p>For example a new system won&#x27;t have pulseaudio, but it won&#x27;t be removed and replaced automatically because that would be potentially disruptive to existing users.</div><br/></div></div></div></div><div id="40361725" class="c"><input type="checkbox" id="c-40361725" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360562">parent</a><span>|</span><a href="#40360826">prev</a><span>|</span><a href="#40361417">next</a><span>|</span><label class="collapse" for="c-40361725">[-]</label><label class="expand" for="c-40361725">[2 more]</label></div><br/><div class="children"><div class="content">The even healthier choice is to store all your system state in a config, you can then just occasionally clean up the config. This also lets you put extensive comments on why a package is needed or even create a submodule for a specific project.<p>Shame that the only bistro that lets you do this is extremely arcane and difficult to learn if you do not have a PhD in mathematics.</div><br/><div id="40362069" class="c"><input type="checkbox" id="c-40362069" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40361725">parent</a><span>|</span><a href="#40361417">next</a><span>|</span><label class="collapse" for="c-40362069">[-]</label><label class="expand" for="c-40362069">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Shame that the only distro that lets you do this is extremely arcane and difficult to learn if you do not have a PhD in mathematics.<p>Hey, there are two! Remember GuixSD</div><br/></div></div></div></div><div id="40361417" class="c"><input type="checkbox" id="c-40361417" checked=""/><div class="controls bullet"><span class="by">firewolf34</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360562">parent</a><span>|</span><a href="#40361725">prev</a><span>|</span><a href="#40361431">next</a><span>|</span><label class="collapse" for="c-40361417">[-]</label><label class="expand" for="c-40361417">[3 more]</label></div><br/><div class="children"><div class="content">What do you use to &quot;keep &#x2F;etc in scm&quot;?</div><br/><div id="40362198" class="c"><input type="checkbox" id="c-40362198" checked=""/><div class="controls bullet"><span class="by">pxc</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40361417">parent</a><span>|</span><a href="#40361431">next</a><span>|</span><label class="collapse" for="c-40362198">[-]</label><label class="expand" for="c-40362198">[2 more]</label></div><br/><div class="children"><div class="content">etckeeper was the standard tool last time I really ran the kind of distro that benefits from it</div><br/><div id="40363620" class="c"><input type="checkbox" id="c-40363620" checked=""/><div class="controls bullet"><span class="by">firewolf34</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40362198">parent</a><span>|</span><a href="#40361431">next</a><span>|</span><label class="collapse" for="c-40363620">[-]</label><label class="expand" for="c-40363620">[1 more]</label></div><br/><div class="children"><div class="content">Thanks for the recommendation! :)</div><br/></div></div></div></div></div></div></div></div><div id="40361431" class="c"><input type="checkbox" id="c-40361431" checked=""/><div class="controls bullet"><span class="by">dylan-m</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360061">parent</a><span>|</span><a href="#40360562">prev</a><span>|</span><a href="#40360780">next</a><span>|</span><label class="collapse" for="c-40361431">[-]</label><label class="expand" for="c-40361431">[1 more]</label></div><br/><div class="children"><div class="content">This is one of my favourite things about Fedora Silverblue and rpm-ostree. If I run `rpm-ostree status`, I get a list of all  the packages I’ve installed or removed compared to the base image. Makes it really easy to keep track of what’s different in my system compared to the current default.</div><br/></div></div><div id="40360780" class="c"><input type="checkbox" id="c-40360780" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360061">parent</a><span>|</span><a href="#40361431">prev</a><span>|</span><a href="#40361576">next</a><span>|</span><label class="collapse" for="c-40360780">[-]</label><label class="expand" for="c-40360780">[6 more]</label></div><br/><div class="children"><div class="content">I don’t know if other distributions do this, but I quite like gentoo’s “world” file. Its a text file listing all the manually installed packages. Everything in the list is pinned in the dependency tree, and kept up to date when you “emerge update”. I constantly install random stuff for random projects then forget about it. The world list lets me easily do spring cleaning. I’ll scroll through the list, delete everything I don’t recognise and let the package manager auto remove unused stuff.<p>I think nix has something similar. I wish Debian&#x2F;ubuntu had something like that - maybe it does - but I’ve never figured it out.</div><br/><div id="40362325" class="c"><input type="checkbox" id="c-40362325" checked=""/><div class="controls bullet"><span class="by">adgjlsfhk1</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360780">parent</a><span>|</span><a href="#40360982">next</a><span>|</span><label class="collapse" for="c-40362325">[-]</label><label class="expand" for="c-40362325">[2 more]</label></div><br/><div class="children"><div class="content">I think OSes really should take inspiration from the newest generation of programming languages here. Rust and Julia (as well as a few others) do a lot better than the OS. Features like environments (e.g. for installing per user packages), and a clean separation of a project and an environment would be very nice.</div><br/><div id="40363964" class="c"><input type="checkbox" id="c-40363964" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40362325">parent</a><span>|</span><a href="#40360982">next</a><span>|</span><label class="collapse" for="c-40363964">[-]</label><label class="expand" for="c-40363964">[1 more]</label></div><br/><div class="children"><div class="content">I hesitate to say it because it comes up in approximately every single conversation about package management, but... NixOS does all of those things. Whole list of packages in configuration.nix, whole of &#x2F;etc encoded into configuration.nix, flakes let you pin everything, (therefore) it&#x27;s trivial to check the whole OS config (packages, versions, configurations) into version control, home manager lets you do all this per-user (or you can do it in the system-wide configuration.nix if you really want), and you can drop a flake.nix+flake.lock in any project directory and scope things that way.</div><br/></div></div></div></div><div id="40361218" class="c"><input type="checkbox" id="c-40361218" checked=""/><div class="controls bullet"><span class="by">stock_toaster</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360780">parent</a><span>|</span><a href="#40360982">prev</a><span>|</span><a href="#40361171">next</a><span>|</span><label class="collapse" for="c-40361218">[-]</label><label class="expand" for="c-40361218">[1 more]</label></div><br/><div class="children"><div class="content">Alpine has a similar &#x2F;etc&#x2F;apk&#x2F;world file. Further, you can edit this file and then `apk fix` will update the system to reflect any changes.</div><br/></div></div><div id="40361171" class="c"><input type="checkbox" id="c-40361171" checked=""/><div class="controls bullet"><span class="by">skrause</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360780">parent</a><span>|</span><a href="#40361218">prev</a><span>|</span><a href="#40361576">next</a><span>|</span><label class="collapse" for="c-40361171">[-]</label><label class="expand" for="c-40361171">[1 more]</label></div><br/><div class="children"><div class="content">Debian has debfoster.</div><br/></div></div></div></div><div id="40361576" class="c"><input type="checkbox" id="c-40361576" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360061">parent</a><span>|</span><a href="#40360780">prev</a><span>|</span><a href="#40360293">next</a><span>|</span><label class="collapse" for="c-40361576">[-]</label><label class="expand" for="c-40361576">[1 more]</label></div><br/><div class="children"><div class="content">On Debian-derived systems, the list can be found with:<p><pre><code>  aptitude search &#x27;?installed ?not(?automatic)&#x27;
</code></pre>
(or filter with that within the program, etc.)<p>There&#x27;s probably a way without aptitude, but using Debian without aptitude is like riding a bicycle without gears.</div><br/></div></div><div id="40360293" class="c"><input type="checkbox" id="c-40360293" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40359180">root</a><span>|</span><a href="#40360061">parent</a><span>|</span><a href="#40361576">prev</a><span>|</span><a href="#40360021">next</a><span>|</span><label class="collapse" for="c-40360293">[-]</label><label class="expand" for="c-40360293">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, I&#x27;ve hit that exact situation on one of my machines running Void Linux (so obviously completely different package manager). I personally think it&#x27;s best to tell the user that it can&#x27;t make the given constraints work and suggest which package(s) are the problem, and then if the user is willing to part with them then they can `apt remove foo &amp;&amp; apt upgrade` or w&#x2F;e (which is more or less my experience of how Void&#x27;s xbps does it).</div><br/></div></div></div></div><div id="40360021" class="c"><input type="checkbox" id="c-40360021" checked=""/><div class="controls bullet"><span class="by">giancarlostoro</span><span>|</span><a href="#40359180">parent</a><span>|</span><a href="#40360061">prev</a><span>|</span><a href="#40362033">next</a><span>|</span><label class="collapse" for="c-40360021">[-]</label><label class="expand" for="c-40360021">[1 more]</label></div><br/><div class="children"><div class="content">I love when this happens when I find a new product, I think to myself would be even better if they did this really simple tweak. Then a week or two later they do the same exact change.<p>Apt probably moves a little slower on “big” changes, since theres many implications. I cant even imagine the number of obscure scripts that something like this breaks because the output and behavior is slightly off somehow.</div><br/></div></div></div></div></div></div></div></div></div></body></html>