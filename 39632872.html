<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1709888451440" as="style"/><link rel="stylesheet" href="styles.css?v=1709888451440"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a>Launch HN: SiLogy (YC W24) – Chip design and verification in the cloud</a> </div><div class="subtext"><span>pkkim</span> | <span>34 comments</span></div><br/><div><div id="39633201" class="c"><input type="checkbox" id="c-39633201" checked=""/><div class="controls bullet"><span class="by">zachbee</span><span>|</span><a href="#39637618">next</a><span>|</span><label class="collapse" for="c-39633201">[-]</label><label class="expand" for="c-39633201">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a professional chip designer. And as somebody who&#x27;s had to build this sort of internal tooling myself, I think this sort of product is desperately needed!<p>It makes sense to start with Verilator, because it&#x27;s fast, easy, and open source, but it seems like it&#x27;ll fall short on a lot of metrics. It seems like the big challenge is going to be making sure your tool can do everything that chip designers actually need to do. I remember spending almost a week bringing up gate-level simulation, which was a huge pain in the ass because our design used an ILM-based hierarchy. Handling things like X-propagation, timing constraints, mixed-language designs, and non-synthesizable models for mixed-signal IP is going to be really tricky, especially because they work differently in every simulator.<p>Is there any reason why you&#x27;re not starting by targeting FPGA developers instead of semiconductor developers? It seems like the Verilator flow will do a much better job of fulfilling their needs, which are generally simpler, than fulfilling the needs of an ASIC team. Obviously in the long run, semiconductor developers are the bigger market, but you need far more features to be able to sell to ASIC teams.</div><br/><div id="39634212" class="c"><input type="checkbox" id="c-39634212" checked=""/><div class="controls bullet"><span class="by">pwarner</span><span>|</span><a href="#39633201">parent</a><span>|</span><a href="#39638543">next</a><span>|</span><label class="collapse" for="c-39634212">[-]</label><label class="expand" for="c-39634212">[3 more]</label></div><br/><div class="children"><div class="content">I worked with some chip design and verification folks.
They were very tolerant of slow results, waiting for licenses or infrastructure. Their processes were just built around those constraints.  They didn&#x27;t seem to have interest in removing them.<p>As an impatient software developer it was very interesting.</div><br/><div id="39635028" class="c"><input type="checkbox" id="c-39635028" checked=""/><div class="controls bullet"><span class="by">bgnn</span><span>|</span><a href="#39633201">root</a><span>|</span><a href="#39634212">parent</a><span>|</span><a href="#39634552">next</a><span>|</span><label class="collapse" for="c-39635028">[-]</label><label class="expand" for="c-39635028">[1 more]</label></div><br/><div class="children"><div class="content">Project cycles are long. We are typically doing 1 tapeout&#x2F;quarter. Chips are incredibly complex, and the physical design is a by definition slow process. Of couse everyone wants quicker tools&#x2F;turnaround but bottleneck isn&#x27;t RTL development, physical design and verification is.</div><br/></div></div><div id="39634552" class="c"><input type="checkbox" id="c-39634552" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633201">root</a><span>|</span><a href="#39634212">parent</a><span>|</span><a href="#39635028">prev</a><span>|</span><a href="#39638543">next</a><span>|</span><label class="collapse" for="c-39634552">[-]</label><label class="expand" for="c-39634552">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, our team has experience in both hardware and software. DV engineers have a really hard time and we&#x27;re trying to make it better.</div><br/></div></div></div></div><div id="39638543" class="c"><input type="checkbox" id="c-39638543" checked=""/><div class="controls bullet"><span class="by">Taniwha</span><span>|</span><a href="#39633201">parent</a><span>|</span><a href="#39634212">prev</a><span>|</span><a href="#39633295">next</a><span>|</span><label class="collapse" for="c-39638543">[-]</label><label class="expand" for="c-39638543">[1 more]</label></div><br/><div class="children"><div class="content">I use verilator all the time for open source stuff, but it has a real problem not supporting Xs - I use them to detect uninitialised variables and taken undefined case statements (with full_case) etc allows me to force faults at the same time as giving clues for better synthesis.<p>I think that FPGA flows are different, because you can test stuff without a tapeout, a lot of debug stuff gets short circuited when you can design something bug and test it on an FPGA in minutes (or in my rather big case 12 hours and then testing on an AWS FPGA instance)</div><br/></div></div><div id="39633295" class="c"><input type="checkbox" id="c-39633295" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633201">parent</a><span>|</span><a href="#39638543">prev</a><span>|</span><a href="#39633271">next</a><span>|</span><label class="collapse" for="c-39633295">[-]</label><label class="expand" for="c-39633295">[2 more]</label></div><br/><div class="children"><div class="content">Thank you! In fact we&#x27;ll be helping our first customer with FPGA development. I don&#x27;t know if we put a lot of thought into FPGAs vs semiconductors in terms of marketing but you raise good points, we&#x27;ll discuss it.</div><br/><div id="39633627" class="c"><input type="checkbox" id="c-39633627" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633201">root</a><span>|</span><a href="#39633295">parent</a><span>|</span><a href="#39633271">next</a><span>|</span><label class="collapse" for="c-39633627">[-]</label><label class="expand" for="c-39633627">[1 more]</label></div><br/><div class="children"><div class="content">Just to clarify though, we are targeting both ASICs and FPGAs.</div><br/></div></div></div></div><div id="39633271" class="c"><input type="checkbox" id="c-39633271" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#39633201">parent</a><span>|</span><a href="#39633295">prev</a><span>|</span><a href="#39637618">next</a><span>|</span><label class="collapse" for="c-39633271">[-]</label><label class="expand" for="c-39633271">[1 more]</label></div><br/><div class="children"><div class="content">I wonder if FPGA developers are as likely to spend as much on tools? They&#x27;re kind of used to having most of their tools from the FPGA vendors be free or if not free fairly inexpensive.</div><br/></div></div></div></div><div id="39637618" class="c"><input type="checkbox" id="c-39637618" checked=""/><div class="controls bullet"><span class="by">doix</span><span>|</span><a href="#39633201">prev</a><span>|</span><a href="#39633981">next</a><span>|</span><label class="collapse" for="c-39637618">[-]</label><label class="expand" for="c-39637618">[1 more]</label></div><br/><div class="children"><div class="content">I used to work at a fairly large fabless semiconductor company on the team that developed the internal tools for doing almost exactly what you were doing.<p>&gt; Tooling hasn’t kept up. The state of the art in collaborative debugging is to walk to a coworker’s desk and point to an error in a log file or waveform file. Each chip company rolls out its own tooling and infra to deal with this—this was Kay’s (one of our cofounders) entire job at his last gig.<p>This is definitely an exaggeration, the tooling has always been a bit &quot;dated&quot; but vManager from Cadence has all the features you are describing (and more). I think nowadays they offer a fully managed cloud service as well. I&#x27;m guessing other vendors have similar offerings but we were primarily a Cadence shop.<p>On the topic of web viewing, do you know that engineers want this? In my experience, managers liked it because they could get an overview quickly, but the engineers hated it because it involved copy-pasting paths from the browser to their local tools.<p>We had vManager but some teams used their own test runner&#x2F;manager with a web viewer(similar to your tool) and I ended up building a little TUI that the engineers could use instead. It worked almost the same, except it let you directly relaunch failing tests in an interactive simvision session for debugging, open log files in vim and open the coverage report for the regression.<p>Anyway, good luck! I always thought that the EDA industry was ripe for disruption, wish you guys all the best!</div><br/></div></div><div id="39633981" class="c"><input type="checkbox" id="c-39633981" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39637618">prev</a><span>|</span><a href="#39634296">next</a><span>|</span><label class="collapse" for="c-39633981">[-]</label><label class="expand" for="c-39633981">[8 more]</label></div><br/><div class="children"><div class="content">I&#x27;m about to pull a &quot;dropbox&quot; here, but I am aware of many companies that already do this inside their Git infrastructure.  It&#x27;s not that hard to do when you combine verilator, testbenches in software languages, and cloud CI intended for software.  This is one of the big advantages of greenfield designs (and FPGA companies): you can set things up for Verilator and&#x2F;or CocoTB natively, and then you get to use things like Github actions to do continuous verification.<p>If you can get the commercial simulators and full support for the awful, ass-backwards, industry-standard verification frameworks (eg UVM), there&#x27;s a great business here, but the trouble is going to be in getting there.</div><br/><div id="39634130" class="c"><input type="checkbox" id="c-39634130" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633981">parent</a><span>|</span><a href="#39636264">next</a><span>|</span><label class="collapse" for="c-39634130">[-]</label><label class="expand" for="c-39634130">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for the observations. It&#x27;s true that every company that needs this eventually figures something out.<p>The difference is (a) our customers don&#x27;t want to be in the devops business, and for startups especially it&#x27;s a severe barrier to entry that we can make disappear, and (b) we are going to keep investing in our products (especially collaboration tools and integrations with waveforms, logs, etc) long past the point where a chip company would decide their internal tools are &quot;good enough&quot; (hint: they&#x27;re generally not).<p>UVM support is one of the next items on our priority list.</div><br/><div id="39634379" class="c"><input type="checkbox" id="c-39634379" checked=""/><div class="controls bullet"><span class="by">imakwana</span><span>|</span><a href="#39633981">root</a><span>|</span><a href="#39634130">parent</a><span>|</span><a href="#39636264">next</a><span>|</span><label class="collapse" for="c-39634379">[-]</label><label class="expand" for="c-39634379">[1 more]</label></div><br/><div class="children"><div class="content">I noticed there are some GitHub Repos actively working on enabling UVM on Verilator:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;MikeCovrado&#x2F;GettingVerilatorStartedWithUVM">https:&#x2F;&#x2F;github.com&#x2F;MikeCovrado&#x2F;GettingVerilatorStartedWithUV...</a><p>It would be an amazing leap to enable UVM fully on Verilator. Looking forward to it.</div><br/></div></div></div></div><div id="39636264" class="c"><input type="checkbox" id="c-39636264" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#39633981">parent</a><span>|</span><a href="#39634130">prev</a><span>|</span><a href="#39637364">next</a><span>|</span><label class="collapse" for="c-39636264">[-]</label><label class="expand" for="c-39636264">[3 more]</label></div><br/><div class="children"><div class="content">This is my feeling too, it&#x27;s pretty trivial to do this stuff in any CI infrastructure.<p>At NYU we have this entire process built into very trivial CMake and Github Actions stuff.<p>Here&#x27;s an example: <a href="https:&#x2F;&#x2F;github.com&#x2F;NYU-Processor-Design&#x2F;PurdNyUart">https:&#x2F;&#x2F;github.com&#x2F;NYU-Processor-Design&#x2F;PurdNyUart</a><p>You can see we have 100% test coverage, illustrated by CodeCov, and our CI runs the test suite on each PR. This is very normal in the software world and I guess I don&#x27;t understand why the hardware world would need a specialized provider just to run Verilator for you.</div><br/><div id="39636330" class="c"><input type="checkbox" id="c-39636330" checked=""/><div class="controls bullet"><span class="by">pclmulqdq</span><span>|</span><a href="#39633981">root</a><span>|</span><a href="#39636264">parent</a><span>|</span><a href="#39637364">next</a><span>|</span><label class="collapse" for="c-39636330">[-]</label><label class="expand" for="c-39636330">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not in gitlab&#x27;s CI infrastructure, but I have continuous integration set up in a private server for <a href="https:&#x2F;&#x2F;gitlab.com&#x2F;specbranch&#x2F;r5lite" rel="nofollow">https:&#x2F;&#x2F;gitlab.com&#x2F;specbranch&#x2F;r5lite</a> and also for my company&#x27;s proprietary hardware.</div><br/><div id="39636368" class="c"><input type="checkbox" id="c-39636368" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#39633981">root</a><span>|</span><a href="#39636330">parent</a><span>|</span><a href="#39637364">next</a><span>|</span><label class="collapse" for="c-39636368">[-]</label><label class="expand" for="c-39636368">[1 more]</label></div><br/><div class="children"><div class="content">Ya and I&#x27;ve seen similarly basic support in small IP houses that support Verilator alongside whichever proprietary suite the house uses.<p>Is there a need here? Are there IP design houses that are so bad at CI infrastructure that &quot;we run Verilator for you&quot; is a value add?<p>I don&#x27;t mean to denigrate the OP, just wondering what the market is. Undergrads build this stuff and let me tell you my undergrads are not a particularly talented group.</div><br/></div></div></div></div></div></div><div id="39637364" class="c"><input type="checkbox" id="c-39637364" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#39633981">parent</a><span>|</span><a href="#39636264">prev</a><span>|</span><a href="#39634296">next</a><span>|</span><label class="collapse" for="c-39637364">[-]</label><label class="expand" for="c-39637364">[2 more]</label></div><br/><div class="children"><div class="content">The thing is too: Gitlab and GitHub CI are still kind of crap unless you put a bunch of work into them (gitlab in particular really don&#x27;t what they&#x27;re doing; they&#x27;re not dumb but they aren&#x27;t good enough).<p>Sell a workflow, not a prison.</div><br/><div id="39637547" class="c"><input type="checkbox" id="c-39637547" checked=""/><div class="controls bullet"><span class="by">nickelpro</span><span>|</span><a href="#39633981">root</a><span>|</span><a href="#39637364">parent</a><span>|</span><a href="#39634296">next</a><span>|</span><label class="collapse" for="c-39637547">[-]</label><label class="expand" for="c-39637547">[1 more]</label></div><br/><div class="children"><div class="content">The functionality on offer here is equivalent to about 30 lines of Github Actions YAML to install verilator, run the tests, and upload the coverage information. [1]<p>Generating waveforms is free, Verilator already does that if you pass it the appropriate argument, either --trace or --trace-fst. We usually control that with a single CMake option.<p>Complex workflows can get nutty, but what&#x27;s illustrated here is not a complex workflow.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;NYU-Processor-Design&#x2F;component-template&#x2F;blob&#x2F;main&#x2F;.github&#x2F;workflows&#x2F;main.yaml">https:&#x2F;&#x2F;github.com&#x2F;NYU-Processor-Design&#x2F;component-template&#x2F;b...</a></div><br/></div></div></div></div></div></div><div id="39634296" class="c"><input type="checkbox" id="c-39634296" checked=""/><div class="controls bullet"><span class="by">reflexe</span><span>|</span><a href="#39633981">prev</a><span>|</span><a href="#39636057">next</a><span>|</span><label class="collapse" for="c-39634296">[-]</label><label class="expand" for="c-39634296">[4 more]</label></div><br/><div class="children"><div class="content">Not sure i am following, what problem your product is trying to solve? helping to write tests&#x2F;run the tests&#x2F;just organizing tests as a part of the CI pipeline? How is it different than just running tests? (Or is it the platform to run tests on?)
If you are trying to do CI for silicon, then what is your target market? From my experience, companies that design their own silicon are usually big enough to have their own custom pipeline for testing and verification and it would be quite difficult to convince them to switch. Smaller companies get help from larger companies in development and verification.<p>Do you have any tooling that won’t require the developer to write tests? (E.g. something that will ‘work’ with no effort from the developer’s POV - kind of sonarqube for vhdl&#x2F;verilog)<p>In any case, good luck. Glad to see some HW-related startups.</div><br/><div id="39634424" class="c"><input type="checkbox" id="c-39634424" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39634296">parent</a><span>|</span><a href="#39636057">next</a><span>|</span><label class="collapse" for="c-39634424">[-]</label><label class="expand" for="c-39634424">[3 more]</label></div><br/><div class="children"><div class="content">Hey, thanks!<p>CI is one component of our platform. Most other CI tools are pretty agnostic about how tests are structured, though. We also integrate a way to structure your tests into groups so you can control when each test is called. For example, if one test out of 500 fails, it&#x27;s super easy to rerun that one test with verbose logging and wave dumping enabled. We then also track test pass&#x2F;fails over time, have tools to leave comments for coworkers on waveforms and logs in the browser like in Google Docs, etc.<p>Out of curiosity, what do you mean by &quot;Smaller companies get help from larger companies in development and verification&quot;?</div><br/><div id="39634684" class="c"><input type="checkbox" id="c-39634684" checked=""/><div class="controls bullet"><span class="by">reflexe</span><span>|</span><a href="#39634296">root</a><span>|</span><a href="#39634424">parent</a><span>|</span><a href="#39636057">next</a><span>|</span><label class="collapse" for="c-39634684">[-]</label><label class="expand" for="c-39634684">[2 more]</label></div><br/><div class="children"><div class="content">In my experience in two HW companies that developed their own ASICs (one as a startup and one as a publicity traded company), we never developed any chip fully by ourself. In all of the cases there was another large company who helped to make the project work so we will actually end up with wafers.<p>If you are not at the scale of NVIDIA&#x2F;intel and release a new silicon every other month, it is not worth it to recruit so many people for a relatively short period. However, I am not fully sure how involved they were in the pre-silicon verification process, but at least in some cases they were very involved in the development.</div><br/><div id="39635059" class="c"><input type="checkbox" id="c-39635059" checked=""/><div class="controls bullet"><span class="by">bgnn</span><span>|</span><a href="#39634296">root</a><span>|</span><a href="#39634684">parent</a><span>|</span><a href="#39636057">next</a><span>|</span><label class="collapse" for="c-39635059">[-]</label><label class="expand" for="c-39635059">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s not correct. I&#x27;ve worked from start-ups to semiconductor giants. Always the first option to develop everything in house, if you can find the talent. This is pretty much industry standard.</div><br/></div></div></div></div></div></div></div></div><div id="39636057" class="c"><input type="checkbox" id="c-39636057" checked=""/><div class="controls bullet"><span class="by">iron2disulfide</span><span>|</span><a href="#39634296">prev</a><span>|</span><a href="#39633232">next</a><span>|</span><label class="collapse" for="c-39636057">[-]</label><label class="expand" for="c-39636057">[2 more]</label></div><br/><div class="children"><div class="content">I find your company fascinating, having also worked on chips (and chip dev tooling) for much of my career.<p>&gt; But they want to work on chips, not devtools!<p>I have long had a gut feeling that there&#x27;s an entire industry of frustrating tools specifically to keep that industry alive. I once was shocked to learn that my company had bought licenses for a tool specifically to combine multiple IP-XACT specs into one... basically just parsing several XML files and combining their data! Outrageous.<p>RE orchestration: It&#x27;s easy-ish now since it sounds like you&#x27;re starting out with (free) open source tools, but once you start looking at things like license fair-share, you might find yourself starting to build yet-another-Slurm&#x2F;LSF.<p>Any reason for buck2 vs bazel? Bazel seems more active (O(thousands) questions on StackOverflow for Bazel vs O(hundreds) for buck).</div><br/><div id="39636349" class="c"><input type="checkbox" id="c-39636349" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39636057">parent</a><span>|</span><a href="#39633232">next</a><span>|</span><label class="collapse" for="c-39636349">[-]</label><label class="expand" for="c-39636349">[1 more]</label></div><br/><div class="children"><div class="content">Yeah, you make some good points, orchestration has been historically painful -- we&#x27;ve personally seen the headaches that come with scheduling on slurm and lsf;  I&#x27;d guess some of the most thorough bikeshedding in history  has been around tinkering with slurm&#x27;s multifactor scheduling logic. We&#x27;re trying to not to re-invent the wheel with orchestration, and we&#x27;re in the midst of building interfaces to hook into slurm, instead of replacing it entirely :)<p>As for buck2, we decided to go with it for a few reasons:<p>More forgiving with gradual adoption, from our experience -- running non-sandboxed actions in bazel is a pain, buck2 has been much easier to plug into existing flows.<p>Buck2 installation is easier, and by extension, is simpler to embed into our test runner.<p>Respectfully, bazel&#x27;s implementation is a monolith beyond comprehension -- if we want to modify buck2, and package our own fork, we have confidence that we could do that.</div><br/></div></div></div></div><div id="39633232" class="c"><input type="checkbox" id="c-39633232" checked=""/><div class="controls bullet"><span class="by">UncleOxidant</span><span>|</span><a href="#39636057">prev</a><span>|</span><a href="#39633622">next</a><span>|</span><label class="collapse" for="c-39633232">[-]</label><label class="expand" for="c-39633232">[2 more]</label></div><br/><div class="children"><div class="content">&quot;design verification powered by Verilator&quot;<p>Nice, coincidentally saw this as I was about to fire up Verilator for the first time in a long time this morning. Good to see a chip development&#x2F;EDA type company getting funding from YC. It seems like the sector was seriously underfunded during the social media funding frenzy of the late aughts and until recently. Given how things have turned out, I&#x27;m pretty sure we would&#x27;ve been a lot better off funding chip development&#x2F;EDA instead of social media.</div><br/><div id="39633340" class="c"><input type="checkbox" id="c-39633340" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633232">parent</a><span>|</span><a href="#39633622">next</a><span>|</span><label class="collapse" for="c-39633340">[-]</label><label class="expand" for="c-39633340">[1 more]</label></div><br/><div class="children"><div class="content">Thank you! Yes, we&#x27;re very excited for the new chips that will be developed in the coming years, and we&#x27;d love to help them be born.</div><br/></div></div></div></div><div id="39633622" class="c"><input type="checkbox" id="c-39633622" checked=""/><div class="controls bullet"><span class="by">SiliconCowboy</span><span>|</span><a href="#39633232">prev</a><span>|</span><a href="#39633618">next</a><span>|</span><label class="collapse" for="c-39633622">[-]</label><label class="expand" for="c-39633622">[2 more]</label></div><br/><div class="children"><div class="content">When do you anticipate supporting UVM based testbenches? Verilator is definitely very fast, and SV assertions and coverage are powerful, however the lack of native UVM will require existing ASIC teams to develop new stimulus and checkers that they already have developed.</div><br/><div id="39633709" class="c"><input type="checkbox" id="c-39633709" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633622">parent</a><span>|</span><a href="#39633618">next</a><span>|</span><label class="collapse" for="c-39633709">[-]</label><label class="expand" for="c-39633709">[1 more]</label></div><br/><div class="children"><div class="content">UVM support is a high priority for us, and our current infrastructure should make it basically drop-in once it&#x27;s ready. Drop me an email if you are interested (email in bio), we will be sure to let you know when it&#x27;s ready! :)</div><br/></div></div></div></div><div id="39633618" class="c"><input type="checkbox" id="c-39633618" checked=""/><div class="controls bullet"><span class="by">karthityrion</span><span>|</span><a href="#39633622">prev</a><span>|</span><a href="#39636663">next</a><span>|</span><label class="collapse" for="c-39633618">[-]</label><label class="expand" for="c-39633618">[4 more]</label></div><br/><div class="children"><div class="content">I might be missing something but how does the product reduce verification time? Isn&#x27;t it just Verilator running on a cloud server? How does it help with debugging?</div><br/><div id="39634314" class="c"><input type="checkbox" id="c-39634314" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633618">parent</a><span>|</span><a href="#39636663">next</a><span>|</span><label class="collapse" for="c-39634314">[-]</label><label class="expand" for="c-39634314">[3 more]</label></div><br/><div class="children"><div class="content">Hey, good question, thanks.<p>We speed up developers in two ways:
For debugging individual tests, we have a web based log viewer and web based waveform viewer, so you can share test results or look at waves via a URL, instead of opening VNC.
More holistically, we&#x27;re building a chip focused workflow that will make tests first class -- infrastructure to track tests, and by extension measure design health, will be in one place, instead of implemented with a bunch of handrolled, bespoke tooling.</div><br/><div id="39634585" class="c"><input type="checkbox" id="c-39634585" checked=""/><div class="controls bullet"><span class="by">karthityrion</span><span>|</span><a href="#39633618">root</a><span>|</span><a href="#39634314">parent</a><span>|</span><a href="#39636663">next</a><span>|</span><label class="collapse" for="c-39634585">[-]</label><label class="expand" for="c-39634585">[2 more]</label></div><br/><div class="children"><div class="content">Thank you! So will it be a web-based wave viewer and debugger?</div><br/><div id="39634773" class="c"><input type="checkbox" id="c-39634773" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39633618">root</a><span>|</span><a href="#39634585">parent</a><span>|</span><a href="#39636663">next</a><span>|</span><label class="collapse" for="c-39634773">[-]</label><label class="expand" for="c-39634773">[1 more]</label></div><br/><div class="children"><div class="content">Those will certainly be a big part of it. But we’ll also be adding a lot more dev friendly tooling around it as well.</div><br/></div></div></div></div></div></div></div></div><div id="39636663" class="c"><input type="checkbox" id="c-39636663" checked=""/><div class="controls bullet"><span class="by">gsmecher</span><span>|</span><a href="#39633618">prev</a><span>|</span><label class="collapse" for="c-39636663">[-]</label><label class="expand" for="c-39636663">[2 more]</label></div><br/><div class="children"><div class="content">You should talk with Metrics (metrics.ca), who are walking a similar path and have a few years&#x27; head start. They are a solid team and are likely to be open and friendly about their direction and challenges. Metrics has an independently developed mixed-language simulator that claims decent standards compliance with both VHDL and SystemVerilog. It&#x27;s an impressive feat that puts them in a different class from Verilator (for now - Verilator is moving fast these days, thanks to Antmicro&#x27;s excellent work.)<p>In my opinion, the extraordinarily poor design productivity associated with RTL designs is unlikely to change much until we can change the languages themselves. Yes, EDA vendors&#x27; tendency to extract maximum revenue for minimum tooling is a cherry on top, but solving that problem alone does not resolve the underlying productivity crisis.<p>For example: when I implement a complex datapath in VHDL, I become responsible for verifying every nook and cranny of both the signal path and the scheduled design that implements it. If I can effectively do design entry in HLS, I no longer need to verify the scheduled design by hand. That&#x27;s a very big win.</div><br/><div id="39636788" class="c"><input type="checkbox" id="c-39636788" checked=""/><div class="controls bullet"><span class="by">pkkim</span><span>|</span><a href="#39636663">parent</a><span>|</span><label class="collapse" for="c-39636788">[-]</label><label class="expand" for="c-39636788">[1 more]</label></div><br/><div class="children"><div class="content">Hey, we&#x27;d love to talk to them. We&#x27;ve heard about them a bit but not from their customers so far. If you have an intro we&#x27;d appreciate it, otherwise we&#x27;ll reach out.<p>Verilog is not the best language, totally agreed on that. Right now we&#x27;re not in a place to change that, but maybe one day!</div><br/></div></div></div></div></div></div></div></div></div></body></html>