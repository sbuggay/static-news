<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1702976459616" as="style"/><link rel="stylesheet" href="styles.css?v=1702976459616"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lwn.net/SubscriberLink/954787/41470c731eda02a4/">Progress toward a GCC-based Rust compiler</a> <span class="domain">(<a href="https://lwn.net">lwn.net</a>)</span></div><div class="subtext"><span>askl</span> | <span>206 comments</span></div><br/><div><div id="38684413" class="c"><input type="checkbox" id="c-38684413" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38685214">next</a><span>|</span><label class="collapse" for="c-38684413">[-]</label><label class="expand" for="c-38684413">[119 more]</label></div><br/><div class="children"><div class="content">The claims in the article feel kinda weak as to the motivation.<p>&gt; Cohen&#x27;s EuroRust talk highlighted that one of the major reasons gccrs is being developed is to be able to take advantage of GCC&#x27;s security plugins. There is a wide range of existing GCC plugins that can aid in debugging, static analysis, or hardening; these work on the GCC intermediate representation<p>&gt; One more reason for gccrs to exist is Rust for Linux, the initiative to add Rust support to the Linux kernel. Cohen said the Linux kernel is a key motivator for the project because there are a lot of kernel people who would prefer the kernel to be compiled only by the GNU toolchain.<p>That explains why you’d want GCC as the backend but not why you need a duplicate front end. I think it’s a bad idea to have multiple front ends and Rust should learn from the mistakes of C++ which even with a standards body has to deal with a mess of switches, differing levels of language support for each compiler making cross-platform development harder, platform-specific language bugs etc etc.<p>&gt; A lot of care is being put into gccrs not becoming a &quot;superset&quot; of Rust, as Cohen put it. The project wants to make sure that it does not create a special &quot;GNU Rust&quot; language, but is trying instead to replicate the output of rustc — bugs, quirks, and all. Both the Rust and GCC test suites are being used to accomplish this.<p>In other words, I’d love gccrs folks to explain why their approach is a better one than rustc_codegen_gcc considering the latter is able to achieve this with far less effort and risk.</div><br/><div id="38685238" class="c"><input type="checkbox" id="c-38685238" checked=""/><div class="controls bullet"><span class="by">ndiddy</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38685029">next</a><span>|</span><label class="collapse" for="c-38685238">[-]</label><label class="expand" for="c-38685238">[33 more]</label></div><br/><div class="children"><div class="content">Having another Rust implementation allows for an &quot;audit&quot; to help validate the Rust spec and get rid of any unspecified behavior. It would also give users options. If I hit a compiler bug in MSVC, I can file a report, switch to GCC and keep working on my project until the bug is fixed. With Rust, that&#x27;s not currently possible.</div><br/><div id="38689546" class="c"><input type="checkbox" id="c-38689546" checked=""/><div class="controls bullet"><span class="by">nindalf</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38685695">next</a><span>|</span><label class="collapse" for="c-38689546">[-]</label><label class="expand" for="c-38689546">[12 more]</label></div><br/><div class="children"><div class="content">Your sentiment is a commonly expressed one, but not usually by people who have adopted Rust. It’s usually Clang&#x2F;MSVC&#x2F;GCC users who have decided this is the optimal flow and want to replicate it in all future codebases they work in, regardless of language.<p>In reality if you hit a compiler bug in Rust or Go (or any other language with one main impl like Python, Ruby…) you would file a report and do one of two things - downgrade the compiler (if it’s an option) or write the code a different way. Compiler bugs in these languages are rare enough that this approach works well.<p>That said, for people who are really keen on a spec, there is one being worked on (<a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-vision.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-visio...</a>).<p>But this GCCRS effort doesn’t get you any closer to your ideal C&#x2F;C++ style workflow because they are committing to matching the semantics of the main compiler exactly. Bugs and all. And that’s the way it should be.<p>The Rust ecosystem becomes worse if I have to install a different toolchain and learn a different build system with a different compiler for every new project I interact with. And after all that extra effort it turns out there are subtle differences between implementations. My developer experience is just worse at that point. If I wanted to code like this, I would code in C++ but I don’t.</div><br/><div id="38690069" class="c"><input type="checkbox" id="c-38690069" checked=""/><div class="controls bullet"><span class="by">moregrist</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38689546">parent</a><span>|</span><a href="#38690656">next</a><span>|</span><label class="collapse" for="c-38690069">[-]</label><label class="expand" for="c-38690069">[7 more]</label></div><br/><div class="children"><div class="content">&gt; Your sentiment is a commonly expressed one, but not usually by people who have adopted Rust.<p>Perhaps because it’s currently not possible in Rust, so users don’t really see the advantages yet.<p>Multiple implementation are always a good thing. They bring in diversity of thought and allow for some competition in the implementation. Having multiple slightly different implementations also gives more clarity to a spec.<p>This isn’t the kind of stuff that users tend to think about until it’s already there.</div><br/><div id="38690756" class="c"><input type="checkbox" id="c-38690756" checked=""/><div class="controls bullet"><span class="by">MindSpunk</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690069">parent</a><span>|</span><a href="#38692473">next</a><span>|</span><label class="collapse" for="c-38690756">[-]</label><label class="expand" for="c-38690756">[2 more]</label></div><br/><div class="children"><div class="content">I agree there is value to multiple implementations. We wouldn&#x27;t be where we are today with open compilers and efficient machine code if it weren&#x27;t for the competing implementations of LLVM and GCC.<p>However there isn&#x27;t enough benefit to multiple language _frontends_ that I can see that outweighs the many downsides.<p>Not only do you have to contend with the duplication of effort for implementing two or more language frontend projects, you now create ecosystem splits when inevitably the implementations do not match their behavior.<p>The biggest example of multiple frontends, C++, is not one language. C++ is Clang-C++, GNU-C++, MSVC-C++, and so-on. All of these implementations have subtle incompatibilities with how they handle identical code, or they have disjoint feature matrices, or they have bugs, and so on. Multiple frontends is IMO one of the _worst_ parts of C++ because it makes writing truly portable code almost impossible. How many new C++ features are unusable in practice because one of the main 3 toolchains hasn&#x27;t implemented it yet?<p>Rust, on the other hand, everything is portable by default. No #ifdef CLANG, no wrangling with subtly incompatible toolchains. If I write code I can trust it will just work on any architecture Rust can build for, ignoring implementation bugs and explicitly platform specific code.<p>I have a hobby game engine I work on in my spare time that was developed exclusively on x86-64 for years and I ported it to run on Apple Silicon ARM in two afternoons. Rust just _worked_, all the time was spent on my C&#x2F;C++ dependencies and new code needed for MacOS support.<p>I simply don&#x27;t see how nebulous, difficult to quantify benefits of competing implementations can outweigh the practical advantages of truly portable code that comes from a single implementation. The ecosystem benefits to a uniform language, and the benefits to my sanity with being able to trust my code while compile everywhere I need it to.</div><br/><div id="38692593" class="c"><input type="checkbox" id="c-38692593" checked=""/><div class="controls bullet"><span class="by">adrianN</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690756">parent</a><span>|</span><a href="#38692473">next</a><span>|</span><label class="collapse" for="c-38692593">[-]</label><label class="expand" for="c-38692593">[1 more]</label></div><br/><div class="children"><div class="content">Writing truly portable C++ it’s not all that hard. In the worst case you need a handful of ifdefs even if you write systems code.</div><br/></div></div></div></div><div id="38692473" class="c"><input type="checkbox" id="c-38692473" checked=""/><div class="controls bullet"><span class="by">ilayn</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690069">parent</a><span>|</span><a href="#38690756">prev</a><span>|</span><a href="#38690527">next</a><span>|</span><label class="collapse" for="c-38692473">[-]</label><label class="expand" for="c-38692473">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s only true if you are not distributing your code. If you want to kill portability just involve MSVC in anything.</div><br/></div></div><div id="38690527" class="c"><input type="checkbox" id="c-38690527" checked=""/><div class="controls bullet"><span class="by">rblatz</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690069">parent</a><span>|</span><a href="#38692473">prev</a><span>|</span><a href="#38691709">next</a><span>|</span><label class="collapse" for="c-38690527">[-]</label><label class="expand" for="c-38690527">[2 more]</label></div><br/><div class="children"><div class="content">All i hear is fragmented ecosystem.</div><br/><div id="38690665" class="c"><input type="checkbox" id="c-38690665" checked=""/><div class="controls bullet"><span class="by">crotchfire</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690527">parent</a><span>|</span><a href="#38691709">next</a><span>|</span><label class="collapse" for="c-38690665">[-]</label><label class="expand" for="c-38690665">[1 more]</label></div><br/><div class="children"><div class="content">Have you had your ears checked lately?</div><br/></div></div></div></div><div id="38691709" class="c"><input type="checkbox" id="c-38691709" checked=""/><div class="controls bullet"><span class="by">newZWhoDis</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690069">parent</a><span>|</span><a href="#38690527">prev</a><span>|</span><a href="#38690656">next</a><span>|</span><label class="collapse" for="c-38691709">[-]</label><label class="expand" for="c-38691709">[1 more]</label></div><br/><div class="children"><div class="content">That is dumb and counterproductive. Your entire scenario presupposes unlimited labor capacity and funding (monetary or otherwise), so “diversity is better!”<p>In reality, the people wasting their time to produce a redundant ground-up rewrite of existing functionally <i>could</i> have spent their time and effort on something else that actually moves the world forward.</div><br/></div></div></div></div><div id="38690656" class="c"><input type="checkbox" id="c-38690656" checked=""/><div class="controls bullet"><span class="by">crotchfire</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38689546">parent</a><span>|</span><a href="#38690069">prev</a><span>|</span><a href="#38685695">next</a><span>|</span><label class="collapse" for="c-38690656">[-]</label><label class="expand" for="c-38690656">[4 more]</label></div><br/><div class="children"><div class="content">Monopoly is never the optimal flow.<p>Sincerely,<p>- Rust adopter</div><br/><div id="38691538" class="c"><input type="checkbox" id="c-38691538" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690656">parent</a><span>|</span><a href="#38685695">next</a><span>|</span><label class="collapse" for="c-38691538">[-]</label><label class="expand" for="c-38691538">[3 more]</label></div><br/><div class="children"><div class="content">Monopoly rings hollow when it comes to a community open source project.<p>Monopolies are bad when they stifle progress, but rust&#x27;s written under a free software license. At any point, anyone can take the project and fork it into a new one, can carry on the progress under a new flag.<p>Unlike traditional monopolies, the rust project&#x27;s priorities aren&#x27;t extracting profits or holding power, but rather in improving the language, and they&#x27;re open to anyone (well, anyone who&#x27;s tolerant of others) joining and helping.<p>The argument here is that we will end up with a better outcome if we work together as a community, rather than if we fragment just for some perceived ideal of multiple implementations.<p>While you&#x27;re criticizing the rust monopoly, you might as well go and also yell at the group of friends voluntarily picking up trash off the sidewalk for free since they&#x27;re working together as one monopoly of friends instead of creating two competing cleaning groups.</div><br/><div id="38693063" class="c"><input type="checkbox" id="c-38693063" checked=""/><div class="controls bullet"><span class="by">imadj</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691538">parent</a><span>|</span><a href="#38692651">next</a><span>|</span><label class="collapse" for="c-38693063">[-]</label><label class="expand" for="c-38693063">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Monopoly rings hollow when it comes to a community open source project.<p>Last I heard `open source` was used to refer to code not projects.<p>Every project has its &quot;decision makers&quot; (no matter the structure or titles) that have the power to dictate the direction and vision. You can literally see it every day in many projects, not trying to single out Rust or anything. The power is not distributed evenly, not even within the elite inner circle.<p>There&#x27;s no &#x27;together as a community` when it&#x27;s followed by a clause like `we need to follow the one direction (X) has set`.<p>What power does `the community` exactly have? to open a PR and get denied? is to fork? Can the community ellect leaders and change course? You said it yourself, anyone that want to have their voice heard, they have to climb up the ladder and join the inner circle. You&#x27;re descriping `Power elite` and not `community`. Even forks don&#x27;t work in real life, what happens is the project usually die slowly and everyone move to the next thing.<p>I&#x27;m not dismissing the structure itself, it&#x27;s a good pragmatic approach that offer stability and practicality, it&#x27;s just that you&#x27;re twisting and polishing it. In short:<p><pre><code>  You: Everyone is welcome. No need to fragment.

  Rust&#x27;s governance: Decisions are made by teams. New members are picked by the team members themselves.
</code></pre>
So pursuing efforts like the one in the post is exactly how the community is empowered and what enable Rust to survive any challenges it might face in the future. People doing their own things is how the open source ecosystem began and continue to flourish. So can you just welcome their effort and let them be?</div><br/></div></div><div id="38692651" class="c"><input type="checkbox" id="c-38692651" checked=""/><div class="controls bullet"><span class="by">fsckboy</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691538">parent</a><span>|</span><a href="#38693063">prev</a><span>|</span><a href="#38685695">next</a><span>|</span><label class="collapse" for="c-38692651">[-]</label><label class="expand" for="c-38692651">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>rust&#x27;s written under a free software license</i><p>the way you are using &quot;free&quot; is undefined behavior. &quot;Free&quot; as in speech software, the F in FOSS, is associated with copyleft FSF and GNU, and not like BSD, MIT, and Apache, the open source in fOSs, which is what Rust is.</div><br/></div></div></div></div></div></div></div></div><div id="38685695" class="c"><input type="checkbox" id="c-38685695" checked=""/><div class="controls bullet"><span class="by">VBprogrammer</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38689546">prev</a><span>|</span><a href="#38689445">next</a><span>|</span><label class="collapse" for="c-38685695">[-]</label><label class="expand" for="c-38685695">[11 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t have a lot of experience in C or C++ but I wonder if this ever works in practice for a non-trivial codebase? I&#x27;d be really surprised if, without diligently committing to maintaining compatibility with the two compilers, it was easy to up sticks and move between them.</div><br/><div id="38687393" class="c"><input type="checkbox" id="c-38687393" checked=""/><div class="controls bullet"><span class="by">jandrewrogers</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38687100">next</a><span>|</span><label class="collapse" for="c-38687393">[-]</label><label class="expand" for="c-38687393">[2 more]</label></div><br/><div class="children"><div class="content">Many complex C++ codebases have full parallel CI pipelines for GCC and LLVM. It encourages good code hygiene and occasionally identifies bugs in the compiler toolchain.<p>If you are using intrinsics or other architecture-specific features, there is a similar practice of requiring full CI pipelines for at least two CPU architectures. Again, it occasionally finds interesting bugs.<p>For systems I work on we usually have 4 CI pipelines for the combo of GCC&#x2F;LLVM and ARM&#x2F;x86 for these purposes. It costs a bit more but is generally worth it from a code quality perspective.</div><br/><div id="38688932" class="c"><input type="checkbox" id="c-38688932" checked=""/><div class="controls bullet"><span class="by">izacus</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687393">parent</a><span>|</span><a href="#38687100">next</a><span>|</span><label class="collapse" for="c-38688932">[-]</label><label class="expand" for="c-38688932">[1 more]</label></div><br/><div class="children"><div class="content">Adding CI pipeline running compiles on MSVC was one of the big shakeouts of undefined behaviour and bugs in our C++ codebase - while making that compiler happy is annoying if you come from Unixy land, it did force us to shed quite a few bad habits and even find several bugs in that endeavor.<p>(And then we could ship the product on Windows, so that was nice.)</div><br/></div></div></div></div><div id="38687100" class="c"><input type="checkbox" id="c-38687100" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38687393">prev</a><span>|</span><a href="#38685907">next</a><span>|</span><label class="collapse" for="c-38687100">[-]</label><label class="expand" for="c-38687100">[1 more]</label></div><br/><div class="children"><div class="content">Our codebase works on all three, we compile on MSVC for Windows, GCC for Linux, and Clang for Mac.<p>It isn&#x27;t easy and honestly the idea of &quot;just don&#x27;t use MSVC for a while&quot; is strange to me. Sure you can compile with any of them but almost certainly you are going to stick to one for a given use case.<p>&quot;This release is on a different compiler&quot; isn&#x27;t something you do because of a bug. Instead your roll back a version or avoid using the unsupported feature until a fix is released.<p>The reason is as much as they are supposed to do the same thing the reality is bugs are bugs, e.g. if you invoke undefined behavior you will generally get consistent results with a given compiler but all bets are off if you swap. Similarly it is hard not to rely on implementation defined behavior without building your own standard library which specifically defines that behavior across compilers.</div><br/></div></div><div id="38685907" class="c"><input type="checkbox" id="c-38685907" checked=""/><div class="controls bullet"><span class="by">logicchains</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38687100">prev</a><span>|</span><a href="#38685858">next</a><span>|</span><label class="collapse" for="c-38685907">[-]</label><label class="expand" for="c-38685907">[1 more]</label></div><br/><div class="children"><div class="content">&gt;I&#x27;d be really surprised if, without diligently committing to maintaining compatibility with the two compilers, it was easy to up sticks and move between them<p>Many places deliberately compile with multiple compilers as part of the build&#x2F;test pipeline, to benefit from more compiler warnings, diagnostics etc.</div><br/></div></div><div id="38685858" class="c"><input type="checkbox" id="c-38685858" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38685907">prev</a><span>|</span><a href="#38686380">next</a><span>|</span><label class="collapse" for="c-38685858">[-]</label><label class="expand" for="c-38685858">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s pretty easy to move between gcc&#x2F;clang&#x2F;icc for most codebases. Though there are some useful features still that are gcc only. (And probably some that are clang only, though I pretty much only use gcc...)</div><br/></div></div><div id="38686380" class="c"><input type="checkbox" id="c-38686380" checked=""/><div class="controls bullet"><span class="by">ska</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38685858">prev</a><span>|</span><a href="#38691669">next</a><span>|</span><label class="collapse" for="c-38686380">[-]</label><label class="expand" for="c-38686380">[1 more]</label></div><br/><div class="children"><div class="content">It works but you have to keep it at least &quot;semi-active&quot;.  Some shops have CI services setup to cross compile etc. already.  Mainly I&#x27;ve seen this not as a tool to maintain a &quot;backup&quot; but as a way to shake out bugs and keep non-portable stuff from creeping into the codebase.<p>You could probably do most of it with conservative linting and some in-house knowledge of portability issues, non-standard compiler extensions, etc.<p>It&#x27;s typically a  <i>lot</i> easier to do this for different compiler, same target, than different targets.</div><br/></div></div><div id="38691669" class="c"><input type="checkbox" id="c-38691669" checked=""/><div class="controls bullet"><span class="by">jamesfinlayson</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38686380">prev</a><span>|</span><a href="#38690275">next</a><span>|</span><label class="collapse" for="c-38691669">[-]</label><label class="expand" for="c-38691669">[1 more]</label></div><br/><div class="children"><div class="content">In a presentation a few years ago Valve Software said that getting the Source engine working on Linux and Mac helped them find some issues in their Windows code (I don&#x27;t remember the exact timeline though - I assume they had an Xbox 360 build pipeline at the same time, but maybe not yet a PlayStation 3 build pipeline).</div><br/></div></div><div id="38690275" class="c"><input type="checkbox" id="c-38690275" checked=""/><div class="controls bullet"><span class="by">zik</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38691669">prev</a><span>|</span><a href="#38687163">next</a><span>|</span><label class="collapse" for="c-38690275">[-]</label><label class="expand" for="c-38690275">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s easy to write C or C++ code which works with both gcc and clang. Generally if there&#x27;s a problem it&#x27;s a standards compliance issue in your code so it&#x27;s good to know and fix.<p>MSVC is a bit more quirky... At times its standards compliance has been patchy but I think it&#x27;s ok right now.</div><br/></div></div><div id="38687163" class="c"><input type="checkbox" id="c-38687163" checked=""/><div class="controls bullet"><span class="by">gpderetta</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38690275">prev</a><span>|</span><a href="#38686222">next</a><span>|</span><label class="collapse" for="c-38687163">[-]</label><label class="expand" for="c-38687163">[1 more]</label></div><br/><div class="children"><div class="content">It is quite common. In most places I have worked we did GCC and clang builds. Some did GCC&#x2F;clang&#x2F;msvc&#x2F;ICC.<p>And of course plenty of OSS libraries support many compilers even beyond the main three.</div><br/></div></div><div id="38686222" class="c"><input type="checkbox" id="c-38686222" checked=""/><div class="controls bullet"><span class="by">jupp0r</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685695">parent</a><span>|</span><a href="#38687163">prev</a><span>|</span><a href="#38689445">next</a><span>|</span><label class="collapse" for="c-38686222">[-]</label><label class="expand" for="c-38686222">[1 more]</label></div><br/><div class="children"><div class="content">There are lots of libraries that need to compile on a variety of platforms (ie different versions of LLVM for Android and MacOS, MSVC for Windows and GCC for some embedded targets not well supported by LLVM).</div><br/></div></div></div></div><div id="38689445" class="c"><input type="checkbox" id="c-38689445" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38685695">prev</a><span>|</span><a href="#38687415">next</a><span>|</span><label class="collapse" for="c-38689445">[-]</label><label class="expand" for="c-38689445">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Having another Rust implementation allows for an &quot;audit&quot; to help validate the Rust spec and get rid of any unspecified behavior. It would also give users options. If I hit a compiler bug in MSVC, I can file a report, switch to GCC and keep working on my project until the bug is fixed. With Rust, that&#x27;s not currently possible.<p>Theory is cool, but in practice other compiler has its own quirks too<p>How about having one compiler which is used by all developers, which increases chances of bugs getting caught faster and fixed faster meanwhile you just use workaround?</div><br/></div></div><div id="38687415" class="c"><input type="checkbox" id="c-38687415" checked=""/><div class="controls bullet"><span class="by">KolmogorovComp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38689445">prev</a><span>|</span><a href="#38690188">next</a><span>|</span><label class="collapse" for="c-38687415">[-]</label><label class="expand" for="c-38687415">[4 more]</label></div><br/><div class="children"><div class="content">Rust has currently no formal specification, so what would you use as an arbiter?<p>Also the article says otherwise
&gt; The project wants to make sure that it does not create a special &quot;GNU Rust&quot; language, but is trying instead to replicate the output of rustc — bugs, quirks, and all</div><br/><div id="38687534" class="c"><input type="checkbox" id="c-38687534" checked=""/><div class="controls bullet"><span class="by">lambda</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687415">parent</a><span>|</span><a href="#38690188">next</a><span>|</span><label class="collapse" for="c-38687534">[-]</label><label class="expand" for="c-38687534">[3 more]</label></div><br/><div class="children"><div class="content">You use the same process as for deciding if changes to rustc are compliant or not; the judgement of the language and compiler teams.<p>And running into these kinds of questions, both in a single project that evolves over time (rustc) and a separate project, help to feed information back into what you need for a formal specification; which is something that is being planned out. Having a second implementation can help find these areas where you might need to be narrower or broader in your specification, in order to clarify enough for it to be implementable or broaden it enough to accommodate reasonable implementation differences.<p>They are not trying to diverge in language implementation, but there will always be simple compiler bugs, which may crop up in one implementation but not another. For instance, some LLVM optimization pass may miscompile some code; gccrs wouldn&#x27;t necessarily be trying to recreate that exact bug. I think that &quot;bugs, quirks, and all&quot; really means that they aren&#x27;t trying to fix major limitations of rustc, such as introducing a whole different borrow checker model which might allow some programs that current rustc does not. They&#x27;re trying to fairly faithfully recreate the language that rustc implements, even if some aspects might be considered sub-optimal, but they aren&#x27;t going to re-implement every ICE and miscompilation, those are places where there could be differences.</div><br/><div id="38688277" class="c"><input type="checkbox" id="c-38688277" checked=""/><div class="controls bullet"><span class="by">KolmogorovComp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687534">parent</a><span>|</span><a href="#38690188">next</a><span>|</span><label class="collapse" for="c-38688277">[-]</label><label class="expand" for="c-38688277">[2 more]</label></div><br/><div class="children"><div class="content">I agree with you it has benefits, what I’m wondering about is if not more bugs (though not the same ones) would be fixed by contributing directly to rustc compared to the massive effort of building a new compiler.</div><br/><div id="38689320" class="c"><input type="checkbox" id="c-38689320" checked=""/><div class="controls bullet"><span class="by">Narishma</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688277">parent</a><span>|</span><a href="#38690188">next</a><span>|</span><label class="collapse" for="c-38689320">[-]</label><label class="expand" for="c-38689320">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s about finding those bugs in the first place. Working on a different implementation is one way of doing that.</div><br/></div></div></div></div></div></div></div></div><div id="38690188" class="c"><input type="checkbox" id="c-38690188" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38687415">prev</a><span>|</span><a href="#38690487">next</a><span>|</span><label class="collapse" for="c-38690188">[-]</label><label class="expand" for="c-38690188">[1 more]</label></div><br/><div class="children"><div class="content">That works until you have a popular project that needs to support all the compilers. Then you need you need to work around n sets of bugs and incompatibilities.</div><br/></div></div><div id="38690487" class="c"><input type="checkbox" id="c-38690487" checked=""/><div class="controls bullet"><span class="by">justinclift</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38690188">prev</a><span>|</span><a href="#38688688">next</a><span>|</span><label class="collapse" for="c-38690487">[-]</label><label class="expand" for="c-38690487">[1 more]</label></div><br/><div class="children"><div class="content">Not sure about that, as the article has this:<p>&gt; The project wants to ... replicate the output of rustc — bugs, quirks, and all.</div><br/></div></div><div id="38688688" class="c"><input type="checkbox" id="c-38688688" checked=""/><div class="controls bullet"><span class="by">slashdev</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38690487">prev</a><span>|</span><a href="#38685904">next</a><span>|</span><label class="collapse" for="c-38688688">[-]</label><label class="expand" for="c-38688688">[1 more]</label></div><br/><div class="children"><div class="content">I hit a compiler bug in rust and downgraded it to an earlier stable version. That’s usually enough.</div><br/></div></div><div id="38685904" class="c"><input type="checkbox" id="c-38685904" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685238">parent</a><span>|</span><a href="#38688688">prev</a><span>|</span><a href="#38685029">next</a><span>|</span><label class="collapse" for="c-38685904">[-]</label><label class="expand" for="c-38685904">[1 more]</label></div><br/><div class="children"><div class="content">The C++ spec regularly has all sorts of errata and misdesigns. Not sure I buy this argument.</div><br/></div></div></div></div><div id="38685029" class="c"><input type="checkbox" id="c-38685029" checked=""/><div class="controls bullet"><span class="by">bryanlarsen</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38685238">prev</a><span>|</span><a href="#38692109">next</a><span>|</span><label class="collapse" for="c-38685029">[-]</label><label class="expand" for="c-38685029">[11 more]</label></div><br/><div class="children"><div class="content">&gt; Rust should learn from the mistakes of C++<p>They are.   You quoted them doing it, the care taken not to become a superset.  The problem with C&#x2F;C++ stemmed from compiler vendors competing with each other to  be &quot;better&quot; than their peers.<p>Multiple front ends of an implementation of a language usually shakes out a bunch of bugs and misimplementations.   That&#x27;s the primary benefit of having multiple front ends IMO.</div><br/><div id="38690422" class="c"><input type="checkbox" id="c-38690422" checked=""/><div class="controls bullet"><span class="by">schuyler2d</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685029">parent</a><span>|</span><a href="#38685097">next</a><span>|</span><label class="collapse" for="c-38690422">[-]</label><label class="expand" for="c-38690422">[1 more]</label></div><br/><div class="children"><div class="content">I worry that once gssrs is marginally used, it implicitly gives permission for Microsoft to create some MSVRust and then we really do descend into standard-body hell.</div><br/></div></div><div id="38685097" class="c"><input type="checkbox" id="c-38685097" checked=""/><div class="controls bullet"><span class="by">delfinom</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685029">parent</a><span>|</span><a href="#38690422">prev</a><span>|</span><a href="#38692109">next</a><span>|</span><label class="collapse" for="c-38685097">[-]</label><label class="expand" for="c-38685097">[9 more]</label></div><br/><div class="children"><div class="content">&gt;The problem with C&#x2F;C++ stemmed from compiler vendors competing with each other to be &quot;better&quot; than their peers.<p>Yea but this is Linux and OSS. NIHisms are fucking rampant everywhere.<p>I give it a year before gccrs announces a new &quot;gnurs&quot; mode with language extensions.</div><br/><div id="38685281" class="c"><input type="checkbox" id="c-38685281" checked=""/><div class="controls bullet"><span class="by">saghm</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685097">parent</a><span>|</span><a href="#38687158">next</a><span>|</span><label class="collapse" for="c-38685281">[-]</label><label class="expand" for="c-38685281">[4 more]</label></div><br/><div class="children"><div class="content">I&#x27;d be surprised about this mostly because I can&#x27;t imagine anyone using gcc-specific Rust extensions. Not only does rustc have an extraordinary amount of traction by being basically the only choice up until this point, Rust doesn&#x27;t really have the reputation of moving slowly to adopt new features; if anything, there&#x27;s been as much skepticism about new features added over the years as excitement. I can honestly imagine more people adopting a Rust implementation with a commitment _not_ to add new features that are added to rustc than one that adds its own separate features.<p>Even as someone who probably will never use gccrs, I think having more than one implementation of Rust is a good thing for the language (for all the usual reasons that get cited). In the long term, I&#x27;d love for Rust to eventually to be able to specify its semantics in a way that isn&#x27;t tied to rustc, which is a moving target and gets murky when you consider implementation-specific bugs.</div><br/><div id="38685526" class="c"><input type="checkbox" id="c-38685526" checked=""/><div class="controls bullet"><span class="by">nequo</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685281">parent</a><span>|</span><a href="#38687158">next</a><span>|</span><label class="collapse" for="c-38685526">[-]</label><label class="expand" for="c-38685526">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Rust doesn&#x27;t really have the reputation of moving slowly to adopt new features<p>There are some exceptions to this. Although there are possibly good reasons for such features moving slowly, a competing compiler could popularize them before they are stabilized in rustc. One example is generators[1] but there&#x27;s a longer list in The Unstable Book.[2]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;43122">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;43122</a><p>[2] <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;unstable-book&#x2F;language-features&#x2F;generators.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;unstable-book&#x2F;language-feat...</a></div><br/><div id="38686417" class="c"><input type="checkbox" id="c-38686417" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685526">parent</a><span>|</span><a href="#38687497">next</a><span>|</span><label class="collapse" for="c-38686417">[-]</label><label class="expand" for="c-38686417">[1 more]</label></div><br/><div class="children"><div class="content">Prevalent use of nightly Rust purely for specific unstable features would do the same. It&#x27;s been a while since there has been a &quot;must have&quot; feature has kept people confined to nightly, though.</div><br/></div></div><div id="38687497" class="c"><input type="checkbox" id="c-38687497" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685526">parent</a><span>|</span><a href="#38686417">prev</a><span>|</span><a href="#38687158">next</a><span>|</span><label class="collapse" for="c-38687497">[-]</label><label class="expand" for="c-38687497">[1 more]</label></div><br/><div class="children"><div class="content">I feel like having a distinct implementation that is unstable is more likely.<p>Stabilizing things from rustc is a recipe for disaster as if rustc builds something new you are in a bad place.</div><br/></div></div></div></div></div></div><div id="38687158" class="c"><input type="checkbox" id="c-38687158" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685097">parent</a><span>|</span><a href="#38685281">prev</a><span>|</span><a href="#38692109">next</a><span>|</span><label class="collapse" for="c-38687158">[-]</label><label class="expand" for="c-38687158">[4 more]</label></div><br/><div class="children"><div class="content">NIHI is usually &quot;using product X is almost as hard (or expensive )as building it&quot;<p>Linux tends to shun unfree software which is a very different take. Buy or build is roughly money vs time (aka money). Software freedom is not the same thing.<p>Also why does software freedom lead to divergences? Certainly GCC partook in the arms race around C++ but recently they have been pretty good about aiming for full standard support as the goal. (The exception being proposed features but that is unavoidable when C++ prefers battle tested proposals)</div><br/><div id="38687313" class="c"><input type="checkbox" id="c-38687313" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687158">parent</a><span>|</span><a href="#38692109">next</a><span>|</span><label class="collapse" for="c-38687313">[-]</label><label class="expand" for="c-38687313">[3 more]</label></div><br/><div class="children"><div class="content">Actually one of the problems we are having with compilers catching up with ISO is that since C++11, features aren&#x27;t battle tested, rather designed in paper or some special compiler branch, and eventually adopted by everyone.</div><br/><div id="38687560" class="c"><input type="checkbox" id="c-38687560" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687313">parent</a><span>|</span><a href="#38692109">next</a><span>|</span><label class="collapse" for="c-38687560">[-]</label><label class="expand" for="c-38687560">[2 more]</label></div><br/><div class="children"><div class="content">Honestly depending on the feature that might be for the best. If all three compilers have distinct on by default divergent settings that would be terrible.<p>My point is outside of instances where everyone agrees something has to change you need a compiler branch at the minimum. This means the compiler you changed will get that feature first.<p>Given it takes years to implement the full standard this leads to divergence between the compilers in standards compliance.<p>Honestly all totally workable but makes talking about &quot;standard C++&quot; hard.</div><br/><div id="38688773" class="c"><input type="checkbox" id="c-38688773" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687560">parent</a><span>|</span><a href="#38692109">next</a><span>|</span><label class="collapse" for="c-38688773">[-]</label><label class="expand" for="c-38688773">[1 more]</label></div><br/><div class="children"><div class="content">There are more than three compilers, and many of the changes if done at all in an existing compiler, are a mix between private branches and ongoing unstable features, hardly battle tested as the first standards were, when existing practice is what came into the standard.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38692109" class="c"><input type="checkbox" id="c-38692109" checked=""/><div class="controls bullet"><span class="by">cbmuser</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38685029">prev</a><span>|</span><a href="#38688211">next</a><span>|</span><label class="collapse" for="c-38692109">[-]</label><label class="expand" for="c-38692109">[1 more]</label></div><br/><div class="children"><div class="content">I don’t understand why this question is kept being asked.<p>Is Rust holy in some sense that’s it’s not allowed to rewrite the frontend?<p>It’s still a PITA to bootstrap Rust on a new architecture and there is also no working Rust compiler for architectures not supported by LLVM.<p>I know that there is codegen_rust_gcc but that one has the same bootstrap problems as the original Rust compiler and also requires architecture support to be landed in various Rust part which Rust maintainers have beem hesitant about (been there, done that).<p>So, I am absolutely glad that there will be an out of the box usable Rust compiler in the near future which will finally allow me to build rustified libraries again on architectures such as alpha without much pain.</div><br/></div></div><div id="38688211" class="c"><input type="checkbox" id="c-38688211" checked=""/><div class="controls bullet"><span class="by">edelsohn</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38692109">prev</a><span>|</span><a href="#38684699">next</a><span>|</span><label class="collapse" for="c-38688211">[-]</label><label class="expand" for="c-38688211">[5 more]</label></div><br/><div class="children"><div class="content">Based on that logic, why did the LLVM community develop Clang, Clang++, libc++, etc. instead of continuing with DragonEgg?  There already were GCC, G++, libstdc++ , as well as EDG C++ front-end.<p>GCC, Clang, MSVC, and other compilers complement each other, serve different purposes, and serve different markets.  They also ensure that the language is robust and conforms to a specification, not whatever quirks a single implementation happens to provide.  And multiple implementations avoids the dangers of relying on a single implementation, which could have future problems with security, governance, etc.<p>The GNU Toolchain Project, the LLVM Project, the Rust project all have experienced issues and it&#x27;s good to not rely on a single point of failure.  Redundancy and anti-fragility is your friend.</div><br/><div id="38688746" class="c"><input type="checkbox" id="c-38688746" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688211">parent</a><span>|</span><a href="#38684699">next</a><span>|</span><label class="collapse" for="c-38688746">[-]</label><label class="expand" for="c-38688746">[4 more]</label></div><br/><div class="children"><div class="content">LLVM saw growth for a number of reasons, but nothing to do because it was actually beneficial for the C++ ecosystem:<p>* A C++ codebase. At the time GCC was written in C which slowed development (it’s now a C++ codebase adopting the lessons LLVM provided)<p>* It had a friendlier license than GCC which switched to GPLv3 and thus Google &amp; Apple moved their compiler teams to work on LLVM over time.<p>* Libc++ is a combination of friendlier license + avoiding the hot garbage that was (maybe still is?) libstdc++ (e.g. there were incompatible design decisions in libstdc++ that inhibited implementing the C++ spec like SSO). There were also build time improvements if I recall correctly.<p>* LLVM provided a fresher architecture which made it more convenient as a research platform (indeed most compiler academics target LLVM rather than GCC for new research ideas).<p>Basically, the reason LLVM was invested in instead of DragonEgg was a mixture of license &amp; the GCC community being quite difficult to work with causing huge amounts of investments by industry and academia into LLVM. Once those projects took off, even after GCC fixed their community issues they still had the license problem and the LLVM community was strongly independent.<p>Compilers don’t typically generate security issues so that’s not a problem. There are questions of governance but due to the permissive license that Rust uses governance problems can be rectified by forking without building a new compiler from the ground up (e.g. what happened with NodeJS until the governance issues were resolved and the fork reabsorbed).<p>It’s funny you mention the different C++ compilers consider that Clang is well on its way of becoming the dominant compiler. It’s already targeting to be a full drop-in replacement for MSVC and it’s fully capable of replacing GCC on Linux unless you’re on a rarer platform where GCC has a bit richer history in the embedded space). I think over the long term GCC is likely to die and it’s entirely possible that MSVC will abandon their in-house and instead use clang (same as they did abandoning IE &amp; adopting Blink). It will be interesting to see if ICC starts porting their optimizations to LLVM and making them freely available - I can’t imagine ICC licenses really bring in enough money to justify things.</div><br/><div id="38690249" class="c"><input type="checkbox" id="c-38690249" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688746">parent</a><span>|</span><a href="#38691756">next</a><span>|</span><label class="collapse" for="c-38690249">[-]</label><label class="expand" for="c-38690249">[1 more]</label></div><br/><div class="children"><div class="content">I think I read somewhere that recent ICC is LLVM based, just not freely available because of course the LLVM licence doesn’t require that. Can’t remember the source though, so take it with a pinch of salt.</div><br/></div></div><div id="38691756" class="c"><input type="checkbox" id="c-38691756" checked=""/><div class="controls bullet"><span class="by">girvo</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688746">parent</a><span>|</span><a href="#38690249">prev</a><span>|</span><a href="#38690269">next</a><span>|</span><label class="collapse" for="c-38691756">[-]</label><label class="expand" for="c-38691756">[1 more]</label></div><br/><div class="children"><div class="content">&gt; GCC has a bit richer history in the embedded space<p>Yeah as someone who works in the embedded space, I do wish that LLVM had more microcontroller support. Maybe one day! It was weirdly hard to get up and running with the STM32L4 and LLVM, whereas GCC was easy as, just for a recent example. Apparently I can pay ARM for a specific LLVM implementation?</div><br/></div></div><div id="38690269" class="c"><input type="checkbox" id="c-38690269" checked=""/><div class="controls bullet"><span class="by">naasking</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688746">parent</a><span>|</span><a href="#38691756">prev</a><span>|</span><a href="#38684699">next</a><span>|</span><label class="collapse" for="c-38690269">[-]</label><label class="expand" for="c-38690269">[1 more]</label></div><br/><div class="children"><div class="content">I doubt very much that using C slowed development. To my recollection it was more that for years the FSF pushed for a GCC architecture that resisted plugins to avoid proprietary extensions. LLVM showed the advantages of a more extensible archite and they followed suit to remain competitive.</div><br/></div></div></div></div></div></div><div id="38684699" class="c"><input type="checkbox" id="c-38684699" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38688211">prev</a><span>|</span><a href="#38685424">next</a><span>|</span><label class="collapse" for="c-38684699">[-]</label><label class="expand" for="c-38684699">[49 more]</label></div><br/><div class="children"><div class="content">&gt; Rust should learn from the mistakes of C++<p>Rust should learn from the mistakes of C++ and C, which are one of the longest lasting, biggest impact, widely deployed languages of all time?<p>It&#x27;s confusing when people think language standards are bad, and instead of saying this code is C99 or C++11, they like saying &quot;this code works with the Rustc binary &#x2F; source code with the SHA256 hash e49d560cd008344edf745b8052ef714b07595808898c835f17f962a10012f964&quot;.</div><br/><div id="38684865" class="c"><input type="checkbox" id="c-38684865" checked=""/><div class="controls bullet"><span class="by">pornel</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38684889">next</a><span>|</span><label class="collapse" for="c-38684865">[-]</label><label class="expand" for="c-38684865">[25 more]</label></div><br/><div class="children"><div class="content">C and C++ are widely used <i>despite</i> their language, compiler, and build system fragmentation. Each platform&#x2F;compiler combo needs ifdefs and workarounds that have been done for so long they’re considered a normal thing (or people say MSVC and others don’t count, and C is just GCC+POSIX).<p>There’s value in multiple implementations ensuring code isn’t bug-compatible, but at the same time in C and C++ there’s plenty of unnecessary differences and unspecified details due to historical reasons, and the narrow scope of their specs.</div><br/><div id="38684998" class="c"><input type="checkbox" id="c-38684998" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684865">parent</a><span>|</span><a href="#38684889">next</a><span>|</span><label class="collapse" for="c-38684998">[-]</label><label class="expand" for="c-38684998">[24 more]</label></div><br/><div class="children"><div class="content">Yes, that&#x27;s how the story goes. Languages with specs are widely deployed despite being fragmented and bad, not because people find value in multiple implementations. Must be a coincidence that C, C++, Javascript and C# and Java all fall under this umbrella.</div><br/><div id="38685237" class="c"><input type="checkbox" id="c-38685237" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684998">parent</a><span>|</span><a href="#38685082">next</a><span>|</span><label class="collapse" for="c-38685237">[-]</label><label class="expand" for="c-38685237">[7 more]</label></div><br/><div class="children"><div class="content">C# has multiple compilers and runtimes? Mono used to be a separate thing but if I recall correctly mono has been adopted by MS &amp; a lot merged between the two.<p>JavaScript itself is a very simple language with most of the complexity living in disparate runtimes and that there are multiple runtime implementations is a very real problem requiring complex polyfills that age poorly that are maintained by the community. For what it’s worth TypeScript has a single implementation and it’s extremely popular in this community.<p>Java is probably the “best” here but really there’s still only the Sun &amp; OpenJDK implementations and the OpenJDK and Oracle are basically the same if I recall correctly with the main difference being the inclusion of proprietary “enterprise” components that Oracle can charge money for. There are other implementations of the standard but they’re much more niche (e.g. Azul systems). A point against disparate implementations is how Java on Android is now basically a fork &amp; a different language from modern-day Java (although I believe that’s mostly because of the Oracle lawsuit).<p>Python is widely deployed &amp; CPython remains the version that most people deploy. Forks find it difficult to keep up with the changes (e.g. PyPy for the longest time lagged quite badly although it seems like they’re doing a better job keeping up these days). The forks have significantly less adoption than CPython though.<p>It seems unlikely that independent Rust front end implementations will benefit it’s popularity. Having GCC code gen is valuable but integrating that behind the Rust front-end sounds like a better idea and is way further along. gccrs is targeting a 3 year old version of Rust that still isn’t complete while the GCC backend is being used to successfully compile the Linux kernel. My bet is that gccrs will end up closer to gcj because it is difficult to keep up.</div><br/><div id="38685970" class="c"><input type="checkbox" id="c-38685970" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685237">parent</a><span>|</span><a href="#38685790">next</a><span>|</span><label class="collapse" for="c-38685970">[-]</label><label class="expand" for="c-38685970">[4 more]</label></div><br/><div class="children"><div class="content">&gt; C# has multiple compilers and runtimes?<p>Yes. Roslyn, Mono and some Mono-like thing from Unity to compile it into C++.<p>&gt; Mono used to be a separate thing<p>Mono is still a thing. The last commit was around 3 months ago.<p>&gt; multiple runtime implementations is a very real problem requiring complex polyfills<p>You can target a version of the spec and any implementation that supports that version will run your code. If you go off-spec, that&#x27;s really on you, and if the implementation has bugs, that&#x27;s on the implementation.<p>&gt; TypeScript has a single implementation<p>esbuild can build typescript code. I use it instead of tsc in my build pipeline, and only use tsc for type-checking.<p>&gt; [Typescript is] extremely popular in this community<p>esbuild is extremely popular in the JS&#x2F;TS community too. The second most-popular TS compiler probably.<p>&gt; [Java has] only the Sun &amp; OpenJDK implementations<p>That&#x27;s not true. There are multiple JDKs and even more JVMs.<p>&gt; Java on Android is now basically a fork &amp; a different language from modern-day Java<p>Good thing Java has specs with multiple versions, so you can target a version that is implemented by your target platform and it will run on any implementation that supports that version.<p>&gt; Python is widely deployed &amp; CPython remains the version that most people deploy.
&gt; The forks have significantly less adoption than CPython though.<p>That is because Python doesn&#x27;t have a real spec or standard, at least nothing solid compared to the other languages with specs or standards.<p>&gt; It seems unlikely that independent Rust front end implementations will benefit it’s popularity.<p>It seems unlikely that people working on an open-source project will only have the popularity of another open-source project in mind when they spend their time.</div><br/><div id="38686181" class="c"><input type="checkbox" id="c-38686181" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685970">parent</a><span>|</span><a href="#38689414">next</a><span>|</span><label class="collapse" for="c-38686181">[-]</label><label class="expand" for="c-38686181">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Yes. Roslyn, Mono and some Mono-like thing from Unity to compile it into C++.<p>Roslyn is more like the next gen compiler and will be included in Mono once it’s ready to replace msc. I view it as closer to polonius because it’s an evolutionary step to upgrade the previous compiler into a new implementation. It’s still a single reference implementation.<p>&gt; Mono is still a thing<p>I think you misunderstood my point. It had started as a fork but then Microsoft adopted it by buying Xamarin. It’s not totally clear to me if it’s actually a fork at this point or if it’s merged and shares a lot of code with .NET core. I could be mistaken but Mono and .Net core these days also share quite a bit of code.<p>&gt; rebuild can build typescript code<p>Yes, there are plenty of transpilers because the language is easy to desugar into JavaScript (intentionally so - TS stopped accepting any language syntax extensions and follows ES 1:1 now and all the development is in the typing layer). That’s very different from a forked implementation of the type checker which is the real meat of the TS language compiler.<p>&gt; The second most popular TS compiler probably<p>It’s a transpiler and not a compiler. If TS had substantial language extensions on top of JS that it was regularly adding, all these forks would be dead in the water.<p>&gt; That’s not true. There are multiple JDKs and even more JVMs<p>I meant to say they’re the only ones with any meaningful adoption. All the other JDKs and JVMs are much more niche and often benefit from living in a niche that is often behind on the adoption curve (i.e. still running Java 8 or something or are willing to stay on older Java versions because there’s some key benefit in the other version that is operationally critical).<p>&gt; Good thing Java has specs with multiple versions, so that you can target a version…<p>Good for people implementing forks, less good for people living within the ecosystem in terms of having to worry about which version of the compiler to support with their library. For what it’s worth Rust also has language versions but it’s more like an LTS version of the language whereas Java versions come out more frequently &amp; each implementation is on whatever year they wanted to snapshot against.</div><br/><div id="38687196" class="c"><input type="checkbox" id="c-38687196" checked=""/><div class="controls bullet"><span class="by">Rohansi</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686181">parent</a><span>|</span><a href="#38689414">next</a><span>|</span><label class="collapse" for="c-38687196">[-]</label><label class="expand" for="c-38687196">[1 more]</label></div><br/><div class="children"><div class="content">FYI Mono has been shipping Roslyn as its C# compiler for a few years now. Mono&#x27;s C# compiler only fully supports up to C# 6 while Roslyn supports C# 12, the latest version.<p>Mono shares a lot of code with .NET (Core) but is mostly limited to the standard libraries and compiler. Mono is still its own separate implementation of the CLR (runtime&#x2F;&quot;JVM&quot;) and supports much more platforms than .NET (Core) today.</div><br/></div></div></div></div><div id="38689414" class="c"><input type="checkbox" id="c-38689414" checked=""/><div class="controls bullet"><span class="by">tester756</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685970">parent</a><span>|</span><a href="#38686181">prev</a><span>|</span><a href="#38685790">next</a><span>|</span><label class="collapse" for="c-38689414">[-]</label><label class="expand" for="c-38689414">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Yes. Roslyn, Mono and some Mono-like thing from Unity to compile it into C++.<p>Mono has approx. 0.x% market share outside Unity. Also Mono is used by .NET Core for Blazor WASM iirc.<p>Let&#x27;s don&#x27;t compare this scenario of sane world with the mess that exists in C++ world.</div><br/></div></div></div></div><div id="38685790" class="c"><input type="checkbox" id="c-38685790" checked=""/><div class="controls bullet"><span class="by">lioeters</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685237">parent</a><span>|</span><a href="#38685970">prev</a><span>|</span><a href="#38685082">next</a><span>|</span><label class="collapse" for="c-38685790">[-]</label><label class="expand" for="c-38685790">[2 more]</label></div><br/><div class="children"><div class="content">&gt; TypeScript has a single implementation<p>It&#x27;s probably a matter of time until there&#x27;s a TypeScript compiler implemented in Rust. But the surface area of the language is pretty big, and I imagine it will always lag behind the official compiler.<p>&gt; Forks find it difficult to keep up with the changes<p>That&#x27;s interesting to think of multiple implementation of a language as &quot;forks&quot; rather than spec-compliant compilers and runtimes. But the problem remains the same, the time and effort necessary to constantly keep up with the reference implementation, the upstream.</div><br/><div id="38685971" class="c"><input type="checkbox" id="c-38685971" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685790">parent</a><span>|</span><a href="#38685082">next</a><span>|</span><label class="collapse" for="c-38685971">[-]</label><label class="expand" for="c-38685971">[1 more]</label></div><br/><div class="children"><div class="content">There’s been plenty of attempts to implement TS in another language or whatnot. They all struggle with keeping up with the pace of change cause the team behind TS is quite large. There was an effort to do a fairly straight port into Rust which actually turned out quite well, but then the “why” question comes up - the reason would be to do better performance but improving performance requires changing the design which a transliteration approach can’t give you &amp; the more of the design you change, the harder it is to keep up with incoming changes putting you back at square 1. I think Rust rewrites of TS compilers (as long as TS is seeing substantial changes which it has been) will be worse than PyPy which is basically a neat party trick without serious adoption.</div><br/></div></div></div></div></div></div><div id="38685082" class="c"><input type="checkbox" id="c-38685082" checked=""/><div class="controls bullet"><span class="by">legobmw99</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684998">parent</a><span>|</span><a href="#38685237">prev</a><span>|</span><a href="#38685134">next</a><span>|</span><label class="collapse" for="c-38685082">[-]</label><label class="expand" for="c-38685082">[15 more]</label></div><br/><div class="children"><div class="content">Java and C# seem to have actually gotten the idea of multiple implementations correct, in the sense that I have never needed to worry about the specific runtime being used as long as I get my language version correct. I have basically never seen a C&#x2F;C++ program of more than a few hundred lines that doesn’t include something like #ifdef WIN32 …</div><br/><div id="38685200" class="c"><input type="checkbox" id="c-38685200" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685082">parent</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38685200">[-]</label><label class="expand" for="c-38685200">[13 more]</label></div><br/><div class="children"><div class="content">Is there more than one Java implementation that is usable?  All I can find are obsolete products that never got very far.</div><br/><div id="38685371" class="c"><input type="checkbox" id="c-38685371" checked=""/><div class="controls bullet"><span class="by">hansjorg</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685200">parent</a><span>|</span><a href="#38685314">next</a><span>|</span><label class="collapse" for="c-38685371">[-]</label><label class="expand" for="c-38685371">[1 more]</label></div><br/><div class="children"><div class="content">Eclipse OpenJ9 (previously IBM J9) is in active development and supports Java 21.</div><br/></div></div><div id="38685314" class="c"><input type="checkbox" id="c-38685314" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685200">parent</a><span>|</span><a href="#38685371">prev</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38685314">[-]</label><label class="expand" for="c-38685314">[11 more]</label></div><br/><div class="children"><div class="content">Here are a few Java implementations that I&#x27;ve used recently.<p>- My Android phone<p>- OpenJDK on my laptop<p>- leJOS for a university robotics course to run on Lego robots<p>- Smart cards, I have a couple in my wallet<p>Perhaps I&#x27;d call the Lego robot stuff obsolete, certainly not the Android userspace or smart cards though.</div><br/><div id="38686038" class="c"><input type="checkbox" id="c-38686038" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685314">parent</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38686038">[-]</label><label class="expand" for="c-38686038">[10 more]</label></div><br/><div class="children"><div class="content">Your Android phone and the latest Java share very little commonality. It only recently supports Java 11 which is 5 years old at this point. The other non-OpenJDK implementations you mentioned are much more niche (I imagine the smart cards run JavaCard which is still probably going to be running an OpenJDK offshoot).</div><br/><div id="38687374" class="c"><input type="checkbox" id="c-38687374" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686038">parent</a><span>|</span><a href="#38686127">next</a><span>|</span><label class="collapse" for="c-38687374">[-]</label><label class="expand" for="c-38687374">[5 more]</label></div><br/><div class="children"><div class="content">Java 17 LTS is supported from Android 12 onwards.<p>PTC, Aicas, microEJ, OpenJ9, Azul, GraalVM are a couple of alternative JVM implementations.</div><br/><div id="38688792" class="c"><input type="checkbox" id="c-38688792" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687374">parent</a><span>|</span><a href="#38686127">next</a><span>|</span><label class="collapse" for="c-38688792">[-]</label><label class="expand" for="c-38688792">[4 more]</label></div><br/><div class="children"><div class="content">Again. I’m not claiming that alternative implementations don’t exist, just that they’re not particularly common&#x2F;popular compared with OpenJDK&#x2F;Oracle (which is largely the same codebase). Android is the only alternative implementation with serious adoption and it lags quite heavily.<p>BTW GraalVM is based on OpenJDK so I don’t really understand your point there. It’s not a ground-up reimplementation of the spec.</div><br/><div id="38688866" class="c"><input type="checkbox" id="c-38688866" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688792">parent</a><span>|</span><a href="#38686127">next</a><span>|</span><label class="collapse" for="c-38688866">[-]</label><label class="expand" for="c-38688866">[3 more]</label></div><br/><div class="children"><div class="content">GraalVM uses another complete infrastructure, JIT and GC compilers, which affect runtime execution, and existing tooling.<p>Doesn&#x27;t matter how popular they are, they exist because there is a business need, and several people are willing to pay for them, in some cases lots of money bags, because they fulfill needs not available in OpenJDK.</div><br/><div id="38690463" class="c"><input type="checkbox" id="c-38690463" checked=""/><div class="controls bullet"><span class="by">the-smug-one</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688866">parent</a><span>|</span><a href="#38686127">next</a><span>|</span><label class="collapse" for="c-38690463">[-]</label><label class="expand" for="c-38690463">[2 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t think what you&#x27;re describing here is accurate re: GraalVM. GraalVM is Hotspot but with C1&#x2F;C2 not being used, using a generic compiler interface to call out to Graal instead AFAIK.</div><br/><div id="38692375" class="c"><input type="checkbox" id="c-38692375" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690463">parent</a><span>|</span><a href="#38686127">next</a><span>|</span><label class="collapse" for="c-38692375">[-]</label><label class="expand" for="c-38692375">[1 more]</label></div><br/><div class="children"><div class="content">Only if you are describing the plugable OpenJDK interfaces for GraalVM, that have been removed a couple of releases after being introduced, as almost no one used them.<p>I have been following GraalVM since it started as MaximeVM on Sun Research Labs.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38686127" class="c"><input type="checkbox" id="c-38686127" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686038">parent</a><span>|</span><a href="#38687374">prev</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38686127">[-]</label><label class="expand" for="c-38686127">[4 more]</label></div><br/><div class="children"><div class="content">Who said anything about the latest Java. Since Java has versioned specs, platform X can support one version, and you can target it based on that information even if other versions come out and get supported by other platforms.<p>For example C89 and C99 are pretty old, and modern C has a lot that is different from them. But they still get targeted and deployed, and enjoy a decent following. Because even in 2024, you can write a new C89 compiler and people&#x27;s existing and new C89 code will compile on it if you implement it right.</div><br/><div id="38687218" class="c"><input type="checkbox" id="c-38687218" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686127">parent</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38687218">[-]</label><label class="expand" for="c-38687218">[3 more]</label></div><br/><div class="children"><div class="content">But as a developer I do want to use (some of) the latest features as soon as they become available. That&#x27;s why most of my crates have an N-2 stable version policy.</div><br/><div id="38688803" class="c"><input type="checkbox" id="c-38688803" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687218">parent</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38688803">[-]</label><label class="expand" for="c-38688803">[2 more]</label></div><br/><div class="children"><div class="content">And since Rust does a release every 6 weeks, we’re talking a ~4 month lag. That’s unheard of for C&#x2F;C++.</div><br/><div id="38692016" class="c"><input type="checkbox" id="c-38692016" checked=""/><div class="controls bullet"><span class="by">lanstin</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688803">parent</a><span>|</span><a href="#38687351">next</a><span>|</span><label class="collapse" for="c-38692016">[-]</label><label class="expand" for="c-38692016">[1 more]</label></div><br/><div class="children"><div class="content">It is the sort of thing that people aimed for in the 90s, when there was more velocity in c and c++. If rust lives long enough the rate of change will also slow down.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="38687351" class="c"><input type="checkbox" id="c-38687351" checked=""/><div class="controls bullet"><span class="by">vintermann</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685082">parent</a><span>|</span><a href="#38685200">prev</a><span>|</span><a href="#38685134">next</a><span>|</span><label class="collapse" for="c-38687351">[-]</label><label class="expand" for="c-38687351">[1 more]</label></div><br/><div class="children"><div class="content">Well, there&#x27;s Android... and Unity, which as I recall is stuck on an old version of C# and its own way of doing things. I also had the interesting experience of working with OSGI at work a couple of years.</div><br/></div></div></div></div><div id="38685134" class="c"><input type="checkbox" id="c-38685134" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684998">parent</a><span>|</span><a href="#38685082">prev</a><span>|</span><a href="#38684889">next</a><span>|</span><label class="collapse" for="c-38685134">[-]</label><label class="expand" for="c-38685134">[1 more]</label></div><br/><div class="children"><div class="content">Or do languages get specs because they are widespread and becoming fragmented?  That clearly apples to C and C++ - both were implemented first and then a formal spec was written in response to fragmentation.</div><br/></div></div></div></div></div></div><div id="38684889" class="c"><input type="checkbox" id="c-38684889" checked=""/><div class="controls bullet"><span class="by">ragnese</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38684865">prev</a><span>|</span><a href="#38684798">next</a><span>|</span><label class="collapse" for="c-38684889">[-]</label><label class="expand" for="c-38684889">[4 more]</label></div><br/><div class="children"><div class="content">&gt; It&#x27;s confusing when people think language standards are bad, and instead of saying this code is C99 or C++11, they like saying &quot;this code works with the Rustc binary &#x2F; source code with the SHA256 hash e49d560cd008344edf745b8052ef714b07595808898c835f17f962a10012f964&quot;.<p>I don&#x27;t know if that&#x27;s totally fair. I remember that it took quite a while for C++ compilers to actually implement all of C++11. So, it was totally normal at the time to change what subset of C++11 we were using to appease whatever version of GCC was in RHEL at the time.</div><br/><div id="38688040" class="c"><input type="checkbox" id="c-38688040" checked=""/><div class="controls bullet"><span class="by">staunton</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684889">parent</a><span>|</span><a href="#38690451">next</a><span>|</span><label class="collapse" for="c-38688040">[-]</label><label class="expand" for="c-38688040">[2 more]</label></div><br/><div class="children"><div class="content">Technically, no compiler ever implemented &quot;all&quot; of c++11... You&#x27;d have to implement garbage collection, for example :D</div><br/><div id="38689119" class="c"><input type="checkbox" id="c-38689119" checked=""/><div class="controls bullet"><span class="by">the_why_of_y</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38688040">parent</a><span>|</span><a href="#38690451">next</a><span>|</span><label class="collapse" for="c-38689119">[-]</label><label class="expand" for="c-38689119">[1 more]</label></div><br/><div class="children"><div class="content">Not to mention &quot;export&quot;, which was in C++98 but only ever supported by Comeau C++.</div><br/></div></div></div></div><div id="38690451" class="c"><input type="checkbox" id="c-38690451" checked=""/><div class="controls bullet"><span class="by">schuyler2d</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684889">parent</a><span>|</span><a href="#38688040">prev</a><span>|</span><a href="#38684798">next</a><span>|</span><label class="collapse" for="c-38690451">[-]</label><label class="expand" for="c-38690451">[1 more]</label></div><br/><div class="children"><div class="content">standards are good. Canonical implementations managed&#x2F;organized by a single project are also good (python, go, ruby, ...).</div><br/></div></div></div></div><div id="38684798" class="c"><input type="checkbox" id="c-38684798" checked=""/><div class="controls bullet"><span class="by">flooow</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38684889">prev</a><span>|</span><a href="#38684909">next</a><span>|</span><label class="collapse" for="c-38684798">[-]</label><label class="expand" for="c-38684798">[14 more]</label></div><br/><div class="children"><div class="content">Or, y&#x27;know, &quot;rustc 1.74.0&quot; like a normal person.</div><br/><div id="38684898" class="c"><input type="checkbox" id="c-38684898" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684798">parent</a><span>|</span><a href="#38687038">next</a><span>|</span><label class="collapse" for="c-38684898">[-]</label><label class="expand" for="c-38684898">[2 more]</label></div><br/><div class="children"><div class="content">And in the rare instances where you&#x27;re using in-development features &quot;rust nightly-2023-12-18&quot;<p>Literally the only reason to specify via a hash* would be if you were using such a bleeding edge feature that it was only merged in the last 48 hours or so and no nightly versions had been cut.<p>*Or I suppose you don&#x27;t trust the supply chain, and you either aren&#x27;t satisfied with or can&#x27;t create tooling that checks the hash against a lockfile, but then you have the same problem with literally any other compiler for any language.</div><br/><div id="38684935" class="c"><input type="checkbox" id="c-38684935" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684898">parent</a><span>|</span><a href="#38687038">next</a><span>|</span><label class="collapse" for="c-38684935">[-]</label><label class="expand" for="c-38684935">[1 more]</label></div><br/><div class="children"><div class="content">Indeed. If I&#x27;m specifying a hash for anything I&#x27;m definitely not leaving things up to the very, very wide range of behaviours covered by the C and C++ standards.</div><br/></div></div></div></div><div id="38687038" class="c"><input type="checkbox" id="c-38687038" checked=""/><div class="controls bullet"><span class="by">legends2k</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684798">parent</a><span>|</span><a href="#38684898">prev</a><span>|</span><a href="#38684909">next</a><span>|</span><label class="collapse" for="c-38687038">[-]</label><label class="expand" for="c-38687038">[11 more]</label></div><br/><div class="children"><div class="content">That&#x27;s besides the point.  Adhering to a language standard is much clearer than specifying it by a language compiler&#x27;s version.  Behaviour is documented in the former while one has to observe the output of a binary (and hope that side effects are understood with their full gravity).</div><br/><div id="38687952" class="c"><input type="checkbox" id="c-38687952" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687038">parent</a><span>|</span><a href="#38688568">next</a><span>|</span><label class="collapse" for="c-38687952">[-]</label><label class="expand" for="c-38687952">[9 more]</label></div><br/><div class="children"><div class="content">But no-one writes code against the standard. We all write code against the reality of the compiler(s) we use. If there&#x27;s a compiler bug, you either use a different version, a different vendor, or we side step the code triggering the issue. The spec only tells you that the vendor might fix this in the future.</div><br/><div id="38690623" class="c"><input type="checkbox" id="c-38690623" checked=""/><div class="controls bullet"><span class="by">_gabe_</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687952">parent</a><span>|</span><a href="#38688568">next</a><span>|</span><label class="collapse" for="c-38690623">[-]</label><label class="expand" for="c-38690623">[8 more]</label></div><br/><div class="children"><div class="content">This is definitely not true. Whenever I have a question about a C++ language feature I typically go here first[0], and then if I’m looking for compiler specific info I go to the applicable compiler docs second. Likewise, for Java I go here[1]. For JavaScript I typically reference Mozilla since those docs are usually well written, but they reference the spec where applicable and I dig deeper if needed[2].<p>Now, none of these links are the specifications for the languages listed, but they all copiously link to the specification where applicable. In rare situations, I have gone directly to the specification. That’s usually if I’m trying to parse a subset of the language or understand an obscure language feature.<p>I would argue no one writes code against a compiler. Sure we all validate our code with a compiler, but a compiler does not tell you how the language works or interacts with itself. I write my code and look for answers to my questions in the specification for my respective languages, and I suspect most programmers do as well.<p>[0]: <a href="https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;</a><p>[1]: <a href="https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;specs&#x2F;index.html</a><p>[2]: <a href="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript" rel="nofollow noreferrer">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript</a></div><br/><div id="38691381" class="c"><input type="checkbox" id="c-38691381" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690623">parent</a><span>|</span><a href="#38688568">next</a><span>|</span><label class="collapse" for="c-38691381">[-]</label><label class="expand" for="c-38691381">[7 more]</label></div><br/><div class="children"><div class="content">If the compiler you use and the spec of your language disagree, what do you do?<p>The Project is working on a specification. The Foundation hired someone for it.<p>A Rust spec done purely on paper ahead of time would be the contents of the accepted RFCs. The final implementation almost never matches what was described because during the lengthy implementation and stabilization process we encounter multitude of unknown unknowns. The work of the spec writers will be to go back and document the result of that process.<p>For what is worth the seeming dragging of feet on this is because the people that would be qualified and inclined to doing that work were working on other, more pressing matters. If we had had a spec back in, let&#x27;s say, Rust 1.31, what would have that changed, in practice?</div><br/><div id="38691520" class="c"><input type="checkbox" id="c-38691520" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691381">parent</a><span>|</span><a href="#38691472">next</a><span>|</span><label class="collapse" for="c-38691520">[-]</label><label class="expand" for="c-38691520">[4 more]</label></div><br/><div class="children"><div class="content">Can you articulate what a spec for a programming language entails in your mind. I am sure it is a niche opinion&#x2F;position, but I base any discussions of formal specification of a language on ‘The Definition of ML’. With that as a starting point I don’t see how the implementation process of a compiler would do anything that could force a change to the spec. Once the formal syntax is defined, the static and dynamic semantics of the language laid out and those semantics proved approximately consistent and possessing ‘type safety’ (for some established meaning of the words). Any divergence or disagreement is a failing of the implementation. I’m genuinely interested in what you expect a specification of Rust to be if, as your comment suggests, you have a different point of view?</div><br/><div id="38691587" class="c"><input type="checkbox" id="c-38691587" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691520">parent</a><span>|</span><a href="#38691472">next</a><span>|</span><label class="collapse" for="c-38691587">[-]</label><label class="expand" for="c-38691587">[3 more]</label></div><br/><div class="children"><div class="content">A specification can be prescriptive (stating how things should work) or descriptive (stating the observable behavior of a specific version of software). For example earlier in Rust&#x27;s post-1.0 life the borrow checker changed behavior a few times, some to fix soundness bugs, some to enable more correct code to work (NLL). An earlier spec would have described different behavior to what Rust is today (but of course, the spec can be updated over time as well).<p>How should the Rust Specification represent the type inference algorithm that rustc uses? Is an implementation that <i>can</i> figure out types in more cases than described by the specification conformant? This is the &quot;split ecosystem concern&quot; some have with the introduction of multiple front ends: code that works on gccrs but not rustc. There&#x27;s no evidence that this will be a problem in practice, everyone involved seems to be aligned on that being a bad idea.<p>&gt; Any divergence or disagreement is a failing of the implementation.<p>Specs can have bugs too, not just software.</div><br/><div id="38691886" class="c"><input type="checkbox" id="c-38691886" checked=""/><div class="controls bullet"><span class="by">throwaway17_17</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691587">parent</a><span>|</span><a href="#38691472">next</a><span>|</span><label class="collapse" for="c-38691886">[-]</label><label class="expand" for="c-38691886">[2 more]</label></div><br/><div class="children"><div class="content">I think it was probably a rhetorical question, but with regards to type checking, as with ML, type inference is an elaboration step in the compiler that produces the correct syntax of the formal language defined in the language definition. Specifying the actual implemented algorithm that translates from concrete syntax to abstract syntax (and the accompanying elaboration to explicit type annotations) is a separate component of the specification document that does not exert any control or guidance to the definition of the formal language of the ‘language’ in question.<p>I think this may be a large point of divergence with regard to my understanding and position on language specifications. I assume when posts have said Rust is getting a spec, that that included a formal, ‘mathematically’ proven language definition of the core language. I am aware that is not what C or C++ or JS includes in a spec (and I don’t know if that is true for Ada), but I was operating under the assumption the Rust’s inspiration from Ocaml and limited functional-esque stylings that the language would follow the more formalized definition style I am used to.</div><br/><div id="38692008" class="c"><input type="checkbox" id="c-38692008" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691886">parent</a><span>|</span><a href="#38691472">next</a><span>|</span><label class="collapse" for="c-38692008">[-]</label><label class="expand" for="c-38692008">[1 more]</label></div><br/><div class="children"><div class="content">Look at Goals and Scope in <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-vision.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-visio...</a> for what the Rust spec will be.</div><br/></div></div></div></div></div></div></div></div><div id="38691472" class="c"><input type="checkbox" id="c-38691472" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691381">parent</a><span>|</span><a href="#38691520">prev</a><span>|</span><a href="#38688568">next</a><span>|</span><label class="collapse" for="c-38691472">[-]</label><label class="expand" for="c-38691472">[2 more]</label></div><br/><div class="children"><div class="content">&gt; If the compiler you use and the spec of your language disagree, what do you do?<p>If the compiler claims to follow the specified version of the spec, and it doesn&#x27;t, you file a compiler bug.<p>And then use the subset that it supports, perhaps by using an older spec if it supports that fully. Perhaps looking for alternative compilers that have better&#x2F;full coverage of a spec.<p>&quot;Supports the spec minus these differences&quot; is still miles better than &quot;any behaviour can change because the Rust 2.1.0 compiler compiles code that the Rust 2.1.0 compiler compiles&quot;.</div><br/><div id="38691660" class="c"><input type="checkbox" id="c-38691660" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691472">parent</a><span>|</span><a href="#38688568">next</a><span>|</span><label class="collapse" for="c-38691660">[-]</label><label class="expand" for="c-38691660">[1 more]</label></div><br/><div class="children"><div class="content">&gt; If the compiler claims to follow the specified version of the spec, and it doesn&#x27;t, you file a compiler bug.<p>&gt; And then use the subset that it supports, perhaps by using an older spec if it supports that fully. Perhaps looking for alternative compilers that have better&#x2F;full coverage of a spec.<p>If you encounter rustc behavior that seems unintentional, you can always file a bug in the issue tracker against the compiler or language teams[1]. Humans end up making a determination whether the behavior of the compiler is in line with the RFC that introduced the feature.<p>&gt; &quot;Supports the spec minus these differences&quot; is still miles better than &quot;any behaviour can change because the Rust 2.1.0 compiler compiles code that the Rust 2.1.0 compiler compiles&quot;.<p>You can look at the Rust Reference[2] for guidance on what the language is supposed to be. It is explicitly <i>not</i> a spec[3], but the project is working on one[4].<p>1: <a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues?q=is%3Aopen+is%3Aissue+label%3At-lang">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues?q=is%3Aopen+is%3Ais...</a><p>2: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;introduction.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;introduction.html</a><p>3: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;introduction.html#what-the-reference-is-not" rel="nofollow noreferrer">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;introduction.html#what-t...</a><p>4: <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-vision.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-visio...</a></div><br/></div></div></div></div></div></div></div></div></div></div><div id="38688568" class="c"><input type="checkbox" id="c-38688568" checked=""/><div class="controls bullet"><span class="by">wongarsu</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687038">parent</a><span>|</span><a href="#38687952">prev</a><span>|</span><a href="#38684909">next</a><span>|</span><label class="collapse" for="c-38688568">[-]</label><label class="expand" for="c-38688568">[1 more]</label></div><br/><div class="children"><div class="content">But barely anyone gets to write C++11. You write C++11 for MSVC2022, or C++11 that compiles with LLVM 15+ and GCC 8+, and maybe MSVC if you invest a couple hours of effort into it. That&#x27;s really not that different from saying you require a minimum compiler version of Rust 1.74.0.</div><br/></div></div></div></div></div></div><div id="38684909" class="c"><input type="checkbox" id="c-38684909" checked=""/><div class="controls bullet"><span class="by">rcxdude</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38684798">prev</a><span>|</span><a href="#38687194">next</a><span>|</span><label class="collapse" for="c-38684909">[-]</label><label class="expand" for="c-38684909">[1 more]</label></div><br/><div class="children"><div class="content">The long-lasting and widespread nature of C and C++ is <i>why</i> their mistakes are the ones most worth learning from.</div><br/></div></div><div id="38687194" class="c"><input type="checkbox" id="c-38687194" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38684909">prev</a><span>|</span><a href="#38685027">next</a><span>|</span><label class="collapse" for="c-38687194">[-]</label><label class="expand" for="c-38687194">[1 more]</label></div><br/><div class="children"><div class="content">I think people generally specify their MSRVs as version numbers for libraries, and often a pinned toolchain file for applications. I haven&#x27;t seen anyone use a hash for this, though I&#x27;m sure I might have missed something.<p>I don&#x27;t think language standards are &quot;bad&quot;.</div><br/></div></div><div id="38685027" class="c"><input type="checkbox" id="c-38685027" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38687194">prev</a><span>|</span><a href="#38687532">next</a><span>|</span><label class="collapse" for="c-38685027">[-]</label><label class="expand" for="c-38685027">[2 more]</label></div><br/><div class="children"><div class="content">&gt;  the longest lasting, biggest impact, widely deployed languages of all time<p>Can be true at the same time as:<p>c and c++ have made mistakes, and have had issues as a result of bad choices<p>The later should be learned from by any language in a place to not make those same mistakes. We call this technological progress, and its OK.</div><br/><div id="38685250" class="c"><input type="checkbox" id="c-38685250" checked=""/><div class="controls bullet"><span class="by">bluGill</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685027">parent</a><span>|</span><a href="#38687532">next</a><span>|</span><label class="collapse" for="c-38685250">[-]</label><label class="expand" for="c-38685250">[1 more]</label></div><br/><div class="children"><div class="content">C and C++ both learn from the mistakes of others too.  Of course as mature languages they have a lot they cannot change.  However when they do propose new features it is common to look at what other languages have done.  C++&#x27;s thread model is better than Java&#x27;s because they were able to look at the things Java got wrong (in hindsight, those choices looked good at the time to smart people - lets not pick on Java for not predicting how modern hardware would evolve in the future.  Indeed it is possible in a few years hardware will evolve differently again and C++&#x27;s thread model will then be just as wrong despite me today calling it good)</div><br/></div></div></div></div><div id="38687532" class="c"><input type="checkbox" id="c-38687532" checked=""/><div class="controls bullet"><span class="by">Guvante</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38684699">parent</a><span>|</span><a href="#38685027">prev</a><span>|</span><a href="#38685424">next</a><span>|</span><label class="collapse" for="c-38687532">[-]</label><label class="expand" for="c-38687532">[1 more]</label></div><br/><div class="children"><div class="content">That phrase doesn&#x27;t mean what you think it is.<p>&quot;Learn from the mistakes of X&quot; doesn&#x27;t mean X is bad, it means X made mistakes.</div><br/></div></div></div></div><div id="38685424" class="c"><input type="checkbox" id="c-38685424" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38684699">prev</a><span>|</span><a href="#38685361">next</a><span>|</span><label class="collapse" for="c-38685424">[-]</label><label class="expand" for="c-38685424">[8 more]</label></div><br/><div class="children"><div class="content">The main motivation is having a GPL licensed, independently developed complete Rust compiler which is not dependent on LLVM.</div><br/><div id="38685798" class="c"><input type="checkbox" id="c-38685798" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685424">parent</a><span>|</span><a href="#38685361">next</a><span>|</span><label class="collapse" for="c-38685798">[-]</label><label class="expand" for="c-38685798">[7 more]</label></div><br/><div class="children"><div class="content">Yes this is important. Otherwise in the future you&#x27;ll see proprietary rust distributions for various devices or with specific features</div><br/><div id="38687833" class="c"><input type="checkbox" id="c-38687833" checked=""/><div class="controls bullet"><span class="by">swsieber</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685798">parent</a><span>|</span><a href="#38686657">next</a><span>|</span><label class="collapse" for="c-38687833">[-]</label><label class="expand" for="c-38687833">[2 more]</label></div><br/><div class="children"><div class="content">You&#x27;ll still see those though? A fully GPL implementation doesn&#x27;t prevent the current implementation from being used in a proprietary rust distribution... unless of course the GPL implementation were to fork from the current implementation... which is the main thing people against the GPL implementation are worried about</div><br/><div id="38688559" class="c"><input type="checkbox" id="c-38688559" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687833">parent</a><span>|</span><a href="#38686657">next</a><span>|</span><label class="collapse" for="c-38688559">[-]</label><label class="expand" for="c-38688559">[1 more]</label></div><br/><div class="children"><div class="content">I think, the GCCRS project takes the rustc implementation as reference, and targets 100% compatibility with them as a fundamental goal and requirement. There is no schism involved.</div><br/></div></div></div></div><div id="38686657" class="c"><input type="checkbox" id="c-38686657" checked=""/><div class="controls bullet"><span class="by">GrumpySloth</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685798">parent</a><span>|</span><a href="#38687833">prev</a><span>|</span><a href="#38685361">next</a><span>|</span><label class="collapse" for="c-38686657">[-]</label><label class="expand" for="c-38686657">[4 more]</label></div><br/><div class="children"><div class="content">C++ and Java, which have many implementations, also have proprietary distributions, see Apple’s fork of Clang, Microsoft’s MSVC, Azul VM, Jamaica VM, ...<p>And some of them are pretty nice. Life is good.</div><br/><div id="38686951" class="c"><input type="checkbox" id="c-38686951" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686657">parent</a><span>|</span><a href="#38685361">next</a><span>|</span><label class="collapse" for="c-38686951">[-]</label><label class="expand" for="c-38686951">[3 more]</label></div><br/><div class="children"><div class="content">When you don’t have a GPL implementation, the only good implementation might be closed source fork of the LLVM version, effectively forking Rust into Rust and Rustium. Will life be good then?</div><br/><div id="38687239" class="c"><input type="checkbox" id="c-38687239" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686951">parent</a><span>|</span><a href="#38685361">next</a><span>|</span><label class="collapse" for="c-38687239">[-]</label><label class="expand" for="c-38687239">[2 more]</label></div><br/><div class="children"><div class="content">This seems like an astoundingly remote possibility.</div><br/><div id="38688585" class="c"><input type="checkbox" id="c-38688585" checked=""/><div class="controls bullet"><span class="by">bayindirh</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38687239">parent</a><span>|</span><a href="#38685361">next</a><span>|</span><label class="collapse" for="c-38688585">[-]</label><label class="expand" for="c-38688585">[1 more]</label></div><br/><div class="children"><div class="content">Given the companies backing LLVM and the surrounding ecosystem, I think it’s an astounding possibility.<p>Companies love permissive licenses for a reason.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="38685361" class="c"><input type="checkbox" id="c-38685361" checked=""/><div class="controls bullet"><span class="by">rhdunn</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38685424">prev</a><span>|</span><a href="#38686283">next</a><span>|</span><label class="collapse" for="c-38685361">[-]</label><label class="expand" for="c-38685361">[5 more]</label></div><br/><div class="children"><div class="content">So by that definition you would only want one web browser as there are currently multiple HTML+CSS+JavaScript &quot;front ends&quot;. In which case, you end up with a Chrome monopoly where Google gets to decide what the web looks like!</div><br/><div id="38689681" class="c"><input type="checkbox" id="c-38689681" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685361">parent</a><span>|</span><a href="#38689341">next</a><span>|</span><label class="collapse" for="c-38689681">[-]</label><label class="expand" for="c-38689681">[3 more]</label></div><br/><div class="children"><div class="content">A monopoly where a party with conflicting interests to the users being the sole arbiter is obviously problematic. A monopoly which is run by a group of individuals that do not have obvious conflicts of interest, and work for different organizations to mitigate the chance of non-obvious conflicts of interest, is far more interesting. Rust has the latter.<p>It&#x27;s not plausible that that will that a similar entity will take over the HTML&#x2F;CSS&#x2F;JS space, because of the amount of money competing with users interests in the space due to things like advertising, the desire to invade users privacy, etc. Still, if somehow we could magic up this monopolizing organization without conflicts of interest that would be far superior to the current state of affairs...</div><br/><div id="38690634" class="c"><input type="checkbox" id="c-38690634" checked=""/><div class="controls bullet"><span class="by">edelsohn</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38689681">parent</a><span>|</span><a href="#38689341">next</a><span>|</span><label class="collapse" for="c-38690634">[-]</label><label class="expand" for="c-38690634">[2 more]</label></div><br/><div class="children"><div class="content">The Rust community is not perfect.  Neither is the LLVM community nor the GCC community, not any Open Source community.  Consider the recent drama &#x2F; growing pains that has occurred within the Rust community.  Everyone has biases and conflicts of interest.  Anyone who doesn&#x27;t recognize the benefit of alternatives will learn the hard way.<p>The Rust community rationalization that they don&#x27;t need &#x2F; want alternatives for &quot;reason&quot; is self-serving and all about control.  I don&#x27;t care if someone is the BDFL, they aren&#x27;t right 100% of the time and not always doing things for altruistic reasons.  The Rust community has imbued the leadership with some godlike omniscience and altruism because it makes them feel good, not because it&#x27;s sound policy.</div><br/><div id="38690776" class="c"><input type="checkbox" id="c-38690776" checked=""/><div class="controls bullet"><span class="by">gpm</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38690634">parent</a><span>|</span><a href="#38689341">next</a><span>|</span><label class="collapse" for="c-38690776">[-]</label><label class="expand" for="c-38690776">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s a long distance between &quot;perfect&quot; and &quot;conflicts of interest&quot;, the latter bears more resemblance to corruption than imperfection.<p>Of course rust leadership is going to make and has made mistakes, I&#x27;m confident every BDFL ever has also made and will continue to make mistakes, the same goes for the &#x27;herd&#x27; of clang&#x2F;gcc&#x2F;msvc&#x2F;... and the herd of browser makers. The target is not perfection, but merely being better than the alternative.<p>I think that, in the absence of conflicts of interests, single source of truth models (e.g. what rust rust&#x2F;python&#x2F;java&#x2F;... does) are likely to do better than &#x27;herd&#x27; of competing implementation models (C&#x2F;C++&#x2F;javascript) at making a good language. The latter probably does better at working despite conflicts of interest, but that&#x27;s not a problem with most programming languages where there is relatively (compared to the browser ecosystem) little opportunity for a powerful corporation to push their interest to the detriment of others.<p>I think the rust community is quite clear that the rust leadership is flawed, but that&#x27;s not very interesting without a way to make leadership better. If you can convince people you have that way - you&#x27;ll get a lot of interest.</div><br/></div></div></div></div></div></div><div id="38689341" class="c"><input type="checkbox" id="c-38689341" checked=""/><div class="controls bullet"><span class="by">mtrower</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38685361">parent</a><span>|</span><a href="#38689681">prev</a><span>|</span><a href="#38686283">next</a><span>|</span><label class="collapse" for="c-38689341">[-]</label><label class="expand" for="c-38689341">[1 more]</label></div><br/><div class="children"><div class="content">A goodly number of people appear to want just that.<p>I don’t agree, mind you, but someone reading your comment with this mindset will probably be reinforced rather than swayed.</div><br/></div></div></div></div><div id="38686283" class="c"><input type="checkbox" id="c-38686283" checked=""/><div class="controls bullet"><span class="by">mhh__</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38685361">prev</a><span>|</span><a href="#38685230">next</a><span>|</span><label class="collapse" for="c-38686283">[-]</label><label class="expand" for="c-38686283">[2 more]</label></div><br/><div class="children"><div class="content">There are arguments for and against but for colour: D in GCC uses a shared frontend, which means it&#x27;s not hard to maintain the frontend aspects — but that also means the frontend is a monoculture which is not very healthy at the moment.<p>If someone will pay you to do it I would do a new frontend — it&#x27;s surprisingly little work to get something you can bootstrap with.</div><br/><div id="38689164" class="c"><input type="checkbox" id="c-38689164" checked=""/><div class="controls bullet"><span class="by">p0nce</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38686283">parent</a><span>|</span><a href="#38685230">next</a><span>|</span><label class="collapse" for="c-38689164">[-]</label><label class="expand" for="c-38689164">[1 more]</label></div><br/><div class="children"><div class="content">Having maintained both C++ and D for different compilers, it&#x27;s way easier to do it in D since the front-end features are the same (modulo builtins) and the stdlib is 99% the same.</div><br/></div></div></div></div><div id="38685230" class="c"><input type="checkbox" id="c-38685230" checked=""/><div class="controls bullet"><span class="by">neuromanser</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38686283">prev</a><span>|</span><a href="#38691744">next</a><span>|</span><label class="collapse" for="c-38685230">[-]</label><label class="expand" for="c-38685230">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think it’s a bad idea to have multiple front ends and Rust should learn from the mistakes of C++ which even with a standards body has to deal with a mess of switches<p>I do not disagree, yet at the same time, having the same set of switches across different languages is nice, too.</div><br/></div></div><div id="38691744" class="c"><input type="checkbox" id="c-38691744" checked=""/><div class="controls bullet"><span class="by">matheusmoreira</span><span>|</span><a href="#38684413">parent</a><span>|</span><a href="#38685230">prev</a><span>|</span><a href="#38685214">next</a><span>|</span><label class="collapse" for="c-38691744">[-]</label><label class="expand" for="c-38691744">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The project wants to make sure that it does not create a special &quot;GNU Rust&quot; language<p>That&#x27;s disappointing. GNU&#x27;s extensions to the C language are extremely valuable features. I&#x27;d like to see what sort of contributions they would make.</div><br/><div id="38692732" class="c"><input type="checkbox" id="c-38692732" checked=""/><div class="controls bullet"><span class="by">Kwpolska</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691744">parent</a><span>|</span><a href="#38692590">next</a><span>|</span><label class="collapse" for="c-38692732">[-]</label><label class="expand" for="c-38692732">[1 more]</label></div><br/><div class="children"><div class="content">They may be valuable C features, but Rust isn&#x27;t designed by committee, and if it&#x27;s missing some useful feature, you could probably convince the Rust team to include it, without having to invent GCC-specific extensions.</div><br/></div></div><div id="38692590" class="c"><input type="checkbox" id="c-38692590" checked=""/><div class="controls bullet"><span class="by">awestroke</span><span>|</span><a href="#38684413">root</a><span>|</span><a href="#38691744">parent</a><span>|</span><a href="#38692732">prev</a><span>|</span><a href="#38685214">next</a><span>|</span><label class="collapse" for="c-38692590">[-]</label><label class="expand" for="c-38692590">[1 more]</label></div><br/><div class="children"><div class="content">Hah</div><br/></div></div></div></div></div></div><div id="38685214" class="c"><input type="checkbox" id="c-38685214" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38684413">prev</a><span>|</span><a href="#38684485">next</a><span>|</span><label class="collapse" for="c-38685214">[-]</label><label class="expand" for="c-38685214">[35 more]</label></div><br/><div class="children"><div class="content">Rust needs a language standard:<p><a href="https:&#x2F;&#x2F;blog.m-ou.se&#x2F;rust-standard&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.m-ou.se&#x2F;rust-standard&#x2F;</a><p><a href="https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;3355-rust-spec.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;3355-rust-spec.html</a><p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3355">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3355</a><p>There are many organizations and industries that will not adopt Rust until it has a standard.<p>C, C++, C#, and even JavaScript (ECMAScript) have language standards.  Why shouldn&#x27;t Rust have one too?<p>C:  <a href="https:&#x2F;&#x2F;www.iso.org&#x2F;standard&#x2F;74528.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.iso.org&#x2F;standard&#x2F;74528.html</a><p>C++:  <a href="https:&#x2F;&#x2F;isocpp.org&#x2F;std&#x2F;the-standard" rel="nofollow noreferrer">https:&#x2F;&#x2F;isocpp.org&#x2F;std&#x2F;the-standard</a><p>C#:  <a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-reference&#x2F;language-specification&#x2F;introduction" rel="nofollow noreferrer">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;dotnet&#x2F;csharp&#x2F;language-ref...</a><p>JavaScript &#x2F; ECMAScript:  <a href="https:&#x2F;&#x2F;ecma-international.org&#x2F;publications-and-standards&#x2F;standards&#x2F;ecma-262&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ecma-international.org&#x2F;publications-and-standards&#x2F;st...</a></div><br/><div id="38685486" class="c"><input type="checkbox" id="c-38685486" checked=""/><div class="controls bullet"><span class="by">mjw1007</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38686986">next</a><span>|</span><label class="collapse" for="c-38685486">[-]</label><label class="expand" for="c-38685486">[5 more]</label></div><br/><div class="children"><div class="content">That RFC is accepted, and this is starting to happen.<p>Progress has been disappointingly slow, but the project is alive, and has potential to speed up next year.<p><a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-vision.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-visio...</a></div><br/><div id="38688571" class="c"><input type="checkbox" id="c-38688571" checked=""/><div class="controls bullet"><span class="by">starlevel003</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685486">parent</a><span>|</span><a href="#38686986">next</a><span>|</span><label class="collapse" for="c-38688571">[-]</label><label class="expand" for="c-38688571">[4 more]</label></div><br/><div class="children"><div class="content">&gt; That RFC is accepted, and this is starting to happen.<p>&gt; Progress has been disappointingly slow,<p>I don&#x27;t think there&#x27;s ever been a more concise summary of Rust.</div><br/><div id="38689981" class="c"><input type="checkbox" id="c-38689981" checked=""/><div class="controls bullet"><span class="by">Ar-Curunir</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38688571">parent</a><span>|</span><a href="#38686986">next</a><span>|</span><label class="collapse" for="c-38689981">[-]</label><label class="expand" for="c-38689981">[3 more]</label></div><br/><div class="children"><div class="content">LOL some people complain that Rust is moving too slow, and others that Rust is moving too fast and adds too many features. Can never make everyone happy...</div><br/><div id="38691890" class="c"><input type="checkbox" id="c-38691890" checked=""/><div class="controls bullet"><span class="by">scottlamb</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38689981">parent</a><span>|</span><a href="#38692409">next</a><span>|</span><label class="collapse" for="c-38691890">[-]</label><label class="expand" for="c-38691890">[1 more]</label></div><br/><div class="children"><div class="content">I just filled out the Rust survey [1] and may have done both—iirc there were checkboxes for missing features and concerns the language is getting too complicated. It&#x27;s a hard balance to find.<p>[1] <a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2023&#x2F;12&#x2F;18&#x2F;survey-launch.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2023&#x2F;12&#x2F;18&#x2F;survey-launch.html</a></div><br/></div></div><div id="38692409" class="c"><input type="checkbox" id="c-38692409" checked=""/><div class="controls bullet"><span class="by">SV_BubbleTime</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38689981">parent</a><span>|</span><a href="#38691890">prev</a><span>|</span><a href="#38686986">next</a><span>|</span><label class="collapse" for="c-38692409">[-]</label><label class="expand" for="c-38692409">[1 more]</label></div><br/><div class="children"><div class="content">Depending on the scenario, I don’t hear mutual exclusion there.<p>It can be moving too slow on important things, and too fast on unimportant or volatile things.</div><br/></div></div></div></div></div></div></div></div><div id="38686986" class="c"><input type="checkbox" id="c-38686986" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38685486">prev</a><span>|</span><a href="#38687641">next</a><span>|</span><label class="collapse" for="c-38686986">[-]</label><label class="expand" for="c-38686986">[8 more]</label></div><br/><div class="children"><div class="content">Mara’s blog post (your first link) says essentially that Rust does not need a standard since it already has means for adding features and maintaining compatibility.</div><br/><div id="38687399" class="c"><input type="checkbox" id="c-38687399" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38686986">parent</a><span>|</span><a href="#38687641">next</a><span>|</span><label class="collapse" for="c-38687399">[-]</label><label class="expand" for="c-38687399">[7 more]</label></div><br/><div class="children"><div class="content">Mara&#x27;s blog post also describes the benefits of standardizing Rust.<p>Since she created the RFC for standardizing Rust (<a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3355">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;3355</a>) and is also on the team that is working on Rust standardization (<a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-vision.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-visio...</a>), I think she was making the point that Rust has good controls in place for adding features while compatibility, not that &quot;Rust does not need a standard&quot;.<p>If she really believed that Rust does not need a standard, why would she create the RFC and join the team working on the effort?<p>Rust is a great language.  There is no reason why it should not have a standard to better formalize its requirements and behaviors.</div><br/><div id="38687924" class="c"><input type="checkbox" id="c-38687924" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38687399">parent</a><span>|</span><a href="#38689971">next</a><span>|</span><label class="collapse" for="c-38687924">[-]</label><label class="expand" for="c-38687924">[5 more]</label></div><br/><div class="children"><div class="content">Yes, it’s a nuanced blog post. But that also means it doesn’t coming out swinging hard for needing a standard, either. It seems like there is as strong an argument to be made that “Rust is a great language. There is no reason why it needs a standard.”<p>See the Ferrocene compiler which has been qualified for ISO standards. It’s essentially a standard Rust 1.68 compiler with a lot of added documentation. If you need a Rust compiler for safety critical environments, it’s reasonably priced and requires essentially zero changes to the Rust compiler that they didn’t just upstream. Without a standard.<p>Yes, it would be nice to have a standard for reducing ambiguity. But does the language <i>need</i> a standard? And if so, then for what purpose?</div><br/><div id="38688595" class="c"><input type="checkbox" id="c-38688595" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38687924">parent</a><span>|</span><a href="#38689971">next</a><span>|</span><label class="collapse" for="c-38688595">[-]</label><label class="expand" for="c-38688595">[4 more]</label></div><br/><div class="children"><div class="content">They created a specification for Ferrocene because Rust does not <i>yet</i> have a language standard:<p><a href="https:&#x2F;&#x2F;spec.ferrocene.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;spec.ferrocene.dev&#x2F;</a><p>&gt;&gt; But does the language need a standard?<p>Yes, Rust needs a standard.<p>&gt;&gt; And if so, then for what purpose?<p>For the same purpose that all standards have--to formally define it in writing.<p>Ferrocene&#x27;s web site (<a href="https:&#x2F;&#x2F;ferrous-systems.com&#x2F;ferrocene&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ferrous-systems.com&#x2F;ferrocene&#x2F;</a>) shows that it meets the ISO 26262 standard (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_26262" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_26262</a>).<p>Why does ISO 26262 matter?  What purpose does it serve?  Couldn&#x27;t a vehicle manufacturer just say &quot;our vehicles are safe&quot;?<p>Which would you trust more:  a vehicle that is verified to meet ISO 26262 standards, or a vehicle whose manufacturer tells you &quot;it&#x27;s safe&quot; without formally defining what &quot;safe&quot; means?<p>I stated it above, but I will re-state it here:  Without a language standard, there are many organizations and industries that <i>will not</i> use Rust.  Not because Rust is not a fantastic tool for the job, but because laws, regulations, etc. <i>require</i> standardization and qualification of components.<p>This means that I <i>can</i> use a qualified C compiler and toolchain to write safety-critical code, but I <i>can&#x27;t</i> use Rust despite the fact that Rust is a better choice and will help to prevent problems.  Standards <i>do</i> matter.  Rust needs a language standard.</div><br/><div id="38688789" class="c"><input type="checkbox" id="c-38688789" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38688595">parent</a><span>|</span><a href="#38689971">next</a><span>|</span><label class="collapse" for="c-38688789">[-]</label><label class="expand" for="c-38688789">[3 more]</label></div><br/><div class="children"><div class="content">&gt; For the same purpose that all standards have--to formally define it in writing.<p>This is tautological. It&#x27;s equivalent to saying &quot;it needs a standard to be written because it needs a written standard.&quot;<p>I mean what use case is there for Rust language users that isn&#x27;t already met by the Ferrocene project? And the Ferrocene project is not a standard as in &quot;other implementations will be found lacking,&quot; but a description of the 1.68 compiler as-is. That is a specification, not a standard. Ferrous Systems did not need Rust to have a standard in order to qualify the compiler for ISO 26262 and IEC 61508.</div><br/><div id="38688913" class="c"><input type="checkbox" id="c-38688913" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38688789">parent</a><span>|</span><a href="#38689971">next</a><span>|</span><label class="collapse" for="c-38688913">[-]</label><label class="expand" for="c-38688913">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; &quot;it needs a standard to be written because it needs a written standard.&quot;<p>Yes.  And if the law in your country requires it to be standardized for specific use cases, then a language standard is needed.<p>&gt;&gt; what use case is there for Rust language users that isn&#x27;t already met by the Ferrocene project?<p>Can you legally use Rust for the control software in aircraft?  (<a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DO-178C" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DO-178C</a>)<p>What about the safety systems for railroads? (<a href="https:&#x2F;&#x2F;ldra.com&#x2F;ldra-blog&#x2F;software-safety-and-security-standards-for-gts-and-rail-applications&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ldra.com&#x2F;ldra-blog&#x2F;software-safety-and-security-stan...</a>)<p>What about the control systems for nuclear reactors? (<a href="https:&#x2F;&#x2F;www.nrc.gov&#x2F;docs&#x2F;ML1300&#x2F;ML13007A173.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.nrc.gov&#x2F;docs&#x2F;ML1300&#x2F;ML13007A173.pdf</a>)</div><br/><div id="38688944" class="c"><input type="checkbox" id="c-38688944" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38688913">parent</a><span>|</span><a href="#38689971">next</a><span>|</span><label class="collapse" for="c-38688944">[-]</label><label class="expand" for="c-38688944">[1 more]</label></div><br/><div class="children"><div class="content">And if you need a ISO 26262 qualified Rust compiler, one exists. Hurrah.<p>Since you edited your post…simply having a standard won’t immediately qualify the language for those industries. There is only a tenuous link between having a standard and qualifying the language for industrial use.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38689971" class="c"><input type="checkbox" id="c-38689971" checked=""/><div class="controls bullet"><span class="by">3836293648</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38687399">parent</a><span>|</span><a href="#38687924">prev</a><span>|</span><a href="#38687641">next</a><span>|</span><label class="collapse" for="c-38689971">[-]</label><label class="expand" for="c-38689971">[1 more]</label></div><br/><div class="children"><div class="content">Spec ≠ Standard<p>Rust absolutely does not need a standard. Having a standard is a completely outdated way to design software in the internet era. Having a specification is a great idea and is what most people actually mean.</div><br/></div></div></div></div></div></div><div id="38687641" class="c"><input type="checkbox" id="c-38687641" checked=""/><div class="controls bullet"><span class="by">pie_flavor</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38686986">prev</a><span>|</span><a href="#38685768">next</a><span>|</span><label class="collapse" for="c-38687641">[-]</label><label class="expand" for="c-38687641">[1 more]</label></div><br/><div class="children"><div class="content">The Ferrocene spec permits Rust to be used in those industries.</div><br/></div></div><div id="38685768" class="c"><input type="checkbox" id="c-38685768" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38687641">prev</a><span>|</span><a href="#38689512">next</a><span>|</span><label class="collapse" for="c-38685768">[-]</label><label class="expand" for="c-38685768">[3 more]</label></div><br/><div class="children"><div class="content">Go has a really nice spec and multiple implementations too.<p><a href="https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec" rel="nofollow noreferrer">https:&#x2F;&#x2F;go.dev&#x2F;ref&#x2F;spec</a></div><br/><div id="38687674" class="c"><input type="checkbox" id="c-38687674" checked=""/><div class="controls bullet"><span class="by">loeg</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685768">parent</a><span>|</span><a href="#38689512">next</a><span>|</span><label class="collapse" for="c-38687674">[-]</label><label class="expand" for="c-38687674">[2 more]</label></div><br/><div class="children"><div class="content">Does any other go implementation support the full language? I thought gccgo lagged significantly.</div><br/><div id="38688378" class="c"><input type="checkbox" id="c-38688378" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38687674">parent</a><span>|</span><a href="#38689512">next</a><span>|</span><label class="collapse" for="c-38688378">[-]</label><label class="expand" for="c-38688378">[1 more]</label></div><br/><div class="children"><div class="content">The official GCC releases tend to lag a bit as they are released on a longer cadence than the standard Go compiler but upstream. The current release is a bit further behind than normal due to the complexities around implementing the generics back end, but it is being worked on (<a href="https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-dev&#x2F;c&#x2F;5ZKcPsDo1fg" rel="nofollow noreferrer">https:&#x2F;&#x2F;groups.google.com&#x2F;g&#x2F;golang-dev&#x2F;c&#x2F;5ZKcPsDo1fg</a>).</div><br/></div></div></div></div></div></div><div id="38685397" class="c"><input type="checkbox" id="c-38685397" checked=""/><div class="controls bullet"><span class="by">jen20</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38689512">prev</a><span>|</span><a href="#38685306">next</a><span>|</span><label class="collapse" for="c-38685397">[-]</label><label class="expand" for="c-38685397">[11 more]</label></div><br/><div class="children"><div class="content">&gt; There are many organizations and industries that will not adopt Rust until it has a standard.<p>Counterpoint: rust is doing fine without those organizations and industries. Why change what is working well?</div><br/><div id="38685641" class="c"><input type="checkbox" id="c-38685641" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685397">parent</a><span>|</span><a href="#38685540">next</a><span>|</span><label class="collapse" for="c-38685641">[-]</label><label class="expand" for="c-38685641">[4 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; Counterpoint: rust is doing fine without those organizations and industries. Why change what is working well?<p>Because Rust is a game changer.<p>Wouldn&#x27;t it be better to have Rust used for the code that runs on automobiles and aircraft?  Or you would prefer that they keep using (subsets of) C and C++?<p>Is the security of your Internet-of-Things (IoT) devices good enough or could they be better?<p>What do you have against Rust being used in more places and for more purposes?</div><br/><div id="38686909" class="c"><input type="checkbox" id="c-38686909" checked=""/><div class="controls bullet"><span class="by">faitswulff</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685641">parent</a><span>|</span><a href="#38688640">next</a><span>|</span><label class="collapse" for="c-38686909">[-]</label><label class="expand" for="c-38686909">[2 more]</label></div><br/><div class="children"><div class="content">Ferrous Systems has a basically bog standard Rust 1.68 compiler that’s been certified for use in the most safety critical environments: <a href="https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;officially-qualified-ferrocene&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;ferrous-systems.com&#x2F;blog&#x2F;officially-qualified-ferroc...</a><p>This happened without a standard.</div><br/><div id="38687298" class="c"><input type="checkbox" id="c-38687298" checked=""/><div class="controls bullet"><span class="by">thesuperbigfrog</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38686909">parent</a><span>|</span><a href="#38688640">next</a><span>|</span><label class="collapse" for="c-38687298">[-]</label><label class="expand" for="c-38687298">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; This happened without a standard.<p>They created a specification for Ferrocene:<p><a href="https:&#x2F;&#x2F;spec.ferrocene.dev&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;spec.ferrocene.dev&#x2F;</a><p>While it is technically not a Rust language standard, it serves a similar purpose for Ferrocene.</div><br/></div></div></div></div></div></div><div id="38685540" class="c"><input type="checkbox" id="c-38685540" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685397">parent</a><span>|</span><a href="#38685641">prev</a><span>|</span><a href="#38685728">next</a><span>|</span><label class="collapse" for="c-38685540">[-]</label><label class="expand" for="c-38685540">[4 more]</label></div><br/><div class="children"><div class="content">If rust wants to replace memory-unsafe languages, it needs to cover their use cases.</div><br/><div id="38689622" class="c"><input type="checkbox" id="c-38689622" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685540">parent</a><span>|</span><a href="#38685728">next</a><span>|</span><label class="collapse" for="c-38689622">[-]</label><label class="expand" for="c-38689622">[3 more]</label></div><br/><div class="children"><div class="content">Which usecases does it not cover?</div><br/><div id="38690403" class="c"><input type="checkbox" id="c-38690403" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38689622">parent</a><span>|</span><a href="#38685728">next</a><span>|</span><label class="collapse" for="c-38690403">[-]</label><label class="expand" for="c-38690403">[2 more]</label></div><br/><div class="children"><div class="content">&gt;&gt;&gt; There are many organizations and industries that will not adopt Rust until it has a standard.<p>So if you want those orgs&#x2F;industries to get memory safety via rust, you either need a standard, or to convince them to not require that.</div><br/><div id="38692974" class="c"><input type="checkbox" id="c-38692974" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38690403">parent</a><span>|</span><a href="#38685728">next</a><span>|</span><label class="collapse" for="c-38692974">[-]</label><label class="expand" for="c-38692974">[1 more]</label></div><br/><div class="children"><div class="content">Those are bureaucratic reasons, not anything specifically lacking in Rust.</div><br/></div></div></div></div></div></div></div></div><div id="38685728" class="c"><input type="checkbox" id="c-38685728" checked=""/><div class="controls bullet"><span class="by">gkbrk</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685397">parent</a><span>|</span><a href="#38685540">prev</a><span>|</span><a href="#38685306">next</a><span>|</span><label class="collapse" for="c-38685728">[-]</label><label class="expand" for="c-38685728">[2 more]</label></div><br/><div class="children"><div class="content">Is it doing fine without those? It seems like every time someone makes a personal or professional project in C&#x2F;C++, the Rust community floods the comments section and talks about how it&#x27;s irresponsible to use C&#x2F;C++ and how the author should just throw away the whole project and re-write it in Rust.<p>It happens so often it became a meme at this point.</div><br/><div id="38686499" class="c"><input type="checkbox" id="c-38686499" checked=""/><div class="controls bullet"><span class="by">sgift</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685728">parent</a><span>|</span><a href="#38685306">next</a><span>|</span><label class="collapse" for="c-38686499">[-]</label><label class="expand" for="c-38686499">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It happens so often it became a meme at this point.<p>No, the meme is kept alive by C++ people who say that this happens without it actually happen. It happened a long time ago a few times, since then it&#x27;s either an active discussion about languages, where for some reason talking about Rust is a problem, but every other language is okay or it&#x27;s someone feeling attacked by the mere idea that projects which only could be done in C++ could now also be done by another language and starts crying about how the Rust community would flood every topic.<p>There&#x27;s no longer an area where C++ is the only available option. Get over it. The rest of the world did a long time ago.</div><br/></div></div></div></div></div></div><div id="38685306" class="c"><input type="checkbox" id="c-38685306" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38685397">prev</a><span>|</span><a href="#38687140">next</a><span>|</span><label class="collapse" for="c-38685306">[-]</label><label class="expand" for="c-38685306">[3 more]</label></div><br/><div class="children"><div class="content">Yeah.  The culture crash here is shocking dissonant.  The people you&#x27;d normally expect to be the biggest voices for documentation robustness are...<p>... suddenly finding themselves in the &quot;Actually, language standards are bad&quot; camp, all because of a tribal opposition to the FSF?<p>Write the standard.  Then argue that gccrust doesn&#x27;t do it right.  Don&#x27;t refuse to document the language just to hamstring a competitor.<p>Also, please start with the borrow checker semantics.  I don&#x27;t think I&#x27;ve ever met anyone who could explain exactly what the rules are regarding what it can&#x2F;can&#x27;t prove.</div><br/><div id="38685962" class="c"><input type="checkbox" id="c-38685962" checked=""/><div class="controls bullet"><span class="by">Rusky</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685306">parent</a><span>|</span><a href="#38685918">next</a><span>|</span><label class="collapse" for="c-38685962">[-]</label><label class="expand" for="c-38685962">[1 more]</label></div><br/><div class="children"><div class="content">What culture crash? The Rust project has a language reference, is working on expanding it into a more formal spec, and there are efforts like Ferrocene&#x27;s to qualify the existing compiler for use in safety critical environments.<p>The argument is not that language standards are bad, it&#x27;s that a C++-like ISO standard is unnecessary (when the quality documentation can exist in another form) and C++-like implementation fragmentation is bad.<p>(Have you read the NLL RFC? The Polonius work?)</div><br/></div></div><div id="38685918" class="c"><input type="checkbox" id="c-38685918" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38685306">parent</a><span>|</span><a href="#38685962">prev</a><span>|</span><a href="#38687140">next</a><span>|</span><label class="collapse" for="c-38685918">[-]</label><label class="expand" for="c-38685918">[1 more]</label></div><br/><div class="children"><div class="content">There&#x27;s been active work on a Rust specification for a while now. It&#x27;ll happen.<p><a href="https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-vision.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;inside-rust&#x2F;2023&#x2F;11&#x2F;15&#x2F;spec-visio...</a></div><br/></div></div></div></div><div id="38687140" class="c"><input type="checkbox" id="c-38687140" checked=""/><div class="controls bullet"><span class="by">ivanjermakov</span><span>|</span><a href="#38685214">parent</a><span>|</span><a href="#38685306">prev</a><span>|</span><a href="#38684485">next</a><span>|</span><label class="collapse" for="c-38687140">[-]</label><label class="expand" for="c-38687140">[2 more]</label></div><br/><div class="children"><div class="content">This is really odd to me. Language design should start with specification. Your compiler is just a reference implementation.</div><br/><div id="38687251" class="c"><input type="checkbox" id="c-38687251" checked=""/><div class="controls bullet"><span class="by">sunshowers</span><span>|</span><a href="#38685214">root</a><span>|</span><a href="#38687140">parent</a><span>|</span><a href="#38684485">next</a><span>|</span><label class="collapse" for="c-38687251">[-]</label><label class="expand" for="c-38687251">[1 more]</label></div><br/><div class="children"><div class="content">Rust language design does start from specifications, namely RFCs. What is being discussed here is producing a more formal specification than the ones that currently exist.</div><br/></div></div></div></div></div></div><div id="38684485" class="c"><input type="checkbox" id="c-38684485" checked=""/><div class="controls bullet"><span class="by">rayiner</span><span>|</span><a href="#38685214">prev</a><span>|</span><a href="#38690578">next</a><span>|</span><label class="collapse" for="c-38684485">[-]</label><label class="expand" for="c-38684485">[13 more]</label></div><br/><div class="children"><div class="content">I’m surprised at the negative reaction to GCC-RS. If a language doesn’t have multiple implementations, it’s a pretty sad excuse for a language.</div><br/><div id="38684813" class="c"><input type="checkbox" id="c-38684813" checked=""/><div class="controls bullet"><span class="by">PoignardAzur</span><span>|</span><a href="#38684485">parent</a><span>|</span><a href="#38685410">next</a><span>|</span><label class="collapse" for="c-38684813">[-]</label><label class="expand" for="c-38684813">[7 more]</label></div><br/><div class="children"><div class="content">&gt; <i>I’m surprised at the negative reaction to GCC-RS. If a language doesn’t have multiple implementations, it’s a pretty sad excuse for a language.</i><p>That used to be the common wisdom (especially because of C&#x2F;C++), but it&#x27;s a lot more debated these days.<p>The consensus in the Rust community is that the current situation (one canonical-by-definition compiler, lots of documentation, a minimal spec for safety-critical industries, and specs for some modular sub-parts) get most of the advantages of multiple implementations without the drawbacks.</div><br/><div id="38685017" class="c"><input type="checkbox" id="c-38685017" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38684813">parent</a><span>|</span><a href="#38688281">next</a><span>|</span><label class="collapse" for="c-38685017">[-]</label><label class="expand" for="c-38685017">[4 more]</label></div><br/><div class="children"><div class="content">I think that the people who are debating it are missing some things. It often happens that only when a second implementation is attempted, unspecified holes in the documentation are exposed and standards are tightened up. Any differences in the two compilers will either mean that there&#x27;s a bug in the new implementation (most likely), a bug or unclear issue in the documentation, or a bug in the mature implementation (it happens).<p>And no, the official compiler isn&#x27;t canonical by definition. If it were, it would mean it has no bugs, and if there&#x27;s a crash or a wrong result that&#x27;s what the language is supposed to do.</div><br/><div id="38685347" class="c"><input type="checkbox" id="c-38685347" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38685017">parent</a><span>|</span><a href="#38688281">next</a><span>|</span><label class="collapse" for="c-38685347">[-]</label><label class="expand" for="c-38685347">[3 more]</label></div><br/><div class="children"><div class="content">Everything in engineering is trade offs. A single front end ends up in a stronger position for the <i>community</i> (i.e. the users of the language) because bug reports are easier (only one project to report them to), collaboration is easier&#x2F;simpler for OSS maintainers (no issues where “crate foo works fine on rustc but doesn’t on gccrs” to triage&#x2F;maintain), and language features come quicker (no need to synchronize&#x2F;debate with other implementations). The downsides of underspecification are much smaller by comparison. As far as documentation goes that’s a red herring because gccrs is reusing the single standard library implementation which means that any documentation issues would still exist (I don’t think I’ve even once needed to lookup documentation for the compiler &amp; language docs issues would be shared as well since rustc in this model still remains the canonical ground truth).</div><br/><div id="38686693" class="c"><input type="checkbox" id="c-38686693" checked=""/><div class="controls bullet"><span class="by">not2b</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38685347">parent</a><span>|</span><a href="#38688281">next</a><span>|</span><label class="collapse" for="c-38686693">[-]</label><label class="expand" for="c-38686693">[2 more]</label></div><br/><div class="children"><div class="content">At this point, gccrs is quite immature, so you can simply ignore it. If we get to the point where its quality is good enough, this will change, but the likelihood is that any problems found will result in improvements to documentation (if something is underspecified). There could also be optimization bugs in LLVM that aren&#x27;t present in GCC, so we could find bugs in rustc that aren&#x27;t in gccrs at some point, but I think that will only be significant if gccrs greatly improves.<p>For now, anyone who finds that “crate foo works fine on rustc but doesn’t on gccrs” can just report a bug to gccrs.</div><br/><div id="38688604" class="c"><input type="checkbox" id="c-38688604" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38686693">parent</a><span>|</span><a href="#38688281">next</a><span>|</span><label class="collapse" for="c-38688604">[-]</label><label class="expand" for="c-38688604">[1 more]</label></div><br/><div class="children"><div class="content">I’m not saying that gccrs contributors should stop. If they want to invest their time &amp; energy into it kudos. I happen to think the costs outweighs the benefits but you’re right that I can just ignore it to no ill effect right now. Where I would caution that though is when the Rust project starts needing to making accommodations to help gccrs (which is something described in the article). It’s possible that some accommodations help Rust anyway &#x2F; there’s no harm, but it’s also useful to be mindful that more &amp; more of these accommodations can start to have a negative cost over time &amp; thus impact Rust as a whole &amp; these costs are obnoxiously hard to quantify and because people like to get along there’s a general preference to be more accommodating. That’s the real danger that gccrs poses and the intangible benefits that you lay out are likely not that significant in the long term compared with the cost to build gccrs &#x2F; modify Rust to accommodate gccrs. Of course, we’re just arguing over opinions since it’s so hard to quantify any of this.</div><br/></div></div></div></div></div></div></div></div><div id="38688281" class="c"><input type="checkbox" id="c-38688281" checked=""/><div class="controls bullet"><span class="by">Longlius</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38684813">parent</a><span>|</span><a href="#38685017">prev</a><span>|</span><a href="#38685022">next</a><span>|</span><label class="collapse" for="c-38688281">[-]</label><label class="expand" for="c-38688281">[1 more]</label></div><br/><div class="children"><div class="content">&gt;it&#x27;s a lot more debated these days<p>By who specifically? I only ever see arguments against standardization and multiple implementations from the Rust community.</div><br/></div></div><div id="38685022" class="c"><input type="checkbox" id="c-38685022" checked=""/><div class="controls bullet"><span class="by">binary132</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38684813">parent</a><span>|</span><a href="#38688281">prev</a><span>|</span><a href="#38685410">next</a><span>|</span><label class="collapse" for="c-38685022">[-]</label><label class="expand" for="c-38685022">[1 more]</label></div><br/><div class="children"><div class="content">sounds like cope for the fact that there is not a good spec (a &quot;Standard&quot;, perhaps?) tbh</div><br/></div></div></div></div><div id="38685410" class="c"><input type="checkbox" id="c-38685410" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#38684485">parent</a><span>|</span><a href="#38684813">prev</a><span>|</span><a href="#38684638">next</a><span>|</span><label class="collapse" for="c-38685410">[-]</label><label class="expand" for="c-38685410">[3 more]</label></div><br/><div class="children"><div class="content">Just personally I can see the virtue of multiple&#x2F;different implementations. But the issue is building on top of gcc. The GNU toolchain is a dumpster fire, and I legitimately don&#x27;t know how anyone can develop on it.<p>Not just ideologically, I mean literally - I don&#x27;t understand how one sets up a development environment for GCC itself. I&#x27;ve had the misfortune of bootstrapping it a handful of times and it&#x27;s the single worst behaved piece of software I&#x27;ve ever seen.</div><br/><div id="38690724" class="c"><input type="checkbox" id="c-38690724" checked=""/><div class="controls bullet"><span class="by">crotchfire</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38685410">parent</a><span>|</span><a href="#38690740">next</a><span>|</span><label class="collapse" for="c-38690724">[-]</label><label class="expand" for="c-38690724">[1 more]</label></div><br/><div class="children"><div class="content">Bootstrapping GCC is not hard at all:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;development&#x2F;compilers&#x2F;gcc&#x2F;default.nix">https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;blob&#x2F;master&#x2F;pkgs&#x2F;developmen...</a><p>(there are a ton of infrequently-used options in there; if you ignore them what&#x27;s left is quite simple.  replace all the options with `false` and do the dead-code elimination.)<p>Hint: don&#x27;t use glibc.  The real problem comes from <i>glibc</i> and the way it depends on gcc internals, which depend on libc (i.e. circularly).  Bootstrapping GCC on Musl is quite easy.<p>glibc is the real dumpster fire.</div><br/></div></div></div></div><div id="38684638" class="c"><input type="checkbox" id="c-38684638" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#38684485">parent</a><span>|</span><a href="#38685410">prev</a><span>|</span><a href="#38690578">next</a><span>|</span><label class="collapse" for="c-38684638">[-]</label><label class="expand" for="c-38684638">[2 more]</label></div><br/><div class="children"><div class="content">The problem is on the long run: syntax stability, avoiding feature creeps with extensions&#x2F;attributes, like we actually have with C (c++ is beyond saving due to its absurd and grotesque complexity).<p>Without that, you won&#x27;t have real-life alternatives.</div><br/><div id="38687468" class="c"><input type="checkbox" id="c-38687468" checked=""/><div class="controls bullet"><span class="by">ajross</span><span>|</span><a href="#38684485">root</a><span>|</span><a href="#38684638">parent</a><span>|</span><a href="#38690578">next</a><span>|</span><label class="collapse" for="c-38687468">[-]</label><label class="expand" for="c-38687468">[1 more]</label></div><br/><div class="children"><div class="content">&gt; avoiding feature creeps with extensions&#x2F;attributes,<p>That seems like a purely semantic argument?  Rust is adding features <i>extremely</i> rapidly!  You&#x27;re just saying it&#x27;s &quot;development&quot; if it&#x27;s done by one entity but &quot;creep&quot; if it&#x27;s done by someone else?</div><br/></div></div></div></div></div></div><div id="38690578" class="c"><input type="checkbox" id="c-38690578" checked=""/><div class="controls bullet"><span class="by">dj_gitmo</span><span>|</span><a href="#38684485">prev</a><span>|</span><a href="#38685887">next</a><span>|</span><label class="collapse" for="c-38690578">[-]</label><label class="expand" for="c-38690578">[2 more]</label></div><br/><div class="children"><div class="content">&gt; Cohen listed a few things that gccrs is already useful for. According to him, the Sega Dreamcast homebrew community uses gccrs to create new games for the Dreamcast gaming console, and GCC plugins can already be used to perform static analysis on unsafe Rust code. The Dreamcast community&#x27;s interest stems from the fact that rustc&#x27;s LLVM backend does not support the Hitachi SH-4 architecture of the console, whereas GCC does; even in its incomplete state, gccrs is helpful for this embedded use case.<p>This is delightful.</div><br/><div id="38692688" class="c"><input type="checkbox" id="c-38692688" checked=""/><div class="controls bullet"><span class="by">habitue</span><span>|</span><a href="#38690578">parent</a><span>|</span><a href="#38685887">next</a><span>|</span><label class="collapse" for="c-38692688">[-]</label><label class="expand" for="c-38692688">[1 more]</label></div><br/><div class="children"><div class="content">This is a little misleading. You don&#x27;t need to have a gcc frontend for this, just a gcc backend</div><br/></div></div></div></div><div id="38685887" class="c"><input type="checkbox" id="c-38685887" checked=""/><div class="controls bullet"><span class="by">johnklos</span><span>|</span><a href="#38690578">prev</a><span>|</span><a href="#38686845">next</a><span>|</span><label class="collapse" for="c-38685887">[-]</label><label class="expand" for="c-38685887">[8 more]</label></div><br/><div class="children"><div class="content">So we&#x27;ll finally see Rust support for all the architectures that gcc supports that LLVM doesn&#x27;t, like Alpha, SuperH and VAX, for starters. That&#x27;ll be nice!</div><br/><div id="38690790" class="c"><input type="checkbox" id="c-38690790" checked=""/><div class="controls bullet"><span class="by">crotchfire</span><span>|</span><a href="#38685887">parent</a><span>|</span><a href="#38686987">next</a><span>|</span><label class="collapse" for="c-38690790">[-]</label><label class="expand" for="c-38690790">[3 more]</label></div><br/><div class="children"><div class="content">And mips64, which rustc recently dumped support for after their attempt to extort funding&#x2F;resources from Loongson failed:<p><a href="https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;compiler-team&#x2F;issues&#x2F;648">https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;compiler-team&#x2F;issues&#x2F;648</a><p>This is the biggest problem with the LLVM mentality: they use architecture support as a means to extract support (i.e. salaried dev positions) from hardware companies.<p>GNU may have annoyingly-higher standards for merging changes, but once it&#x27;s in there and supported they will keep it for the long haul.  It&#x27;s like buying vs renting.  It takes a lot more dev hours to get support into GCC, but once it&#x27;s there, it <i>stays</i> there.</div><br/><div id="38690900" class="c"><input type="checkbox" id="c-38690900" checked=""/><div class="controls bullet"><span class="by">khuey</span><span>|</span><a href="#38685887">root</a><span>|</span><a href="#38690790">parent</a><span>|</span><a href="#38691475">next</a><span>|</span><label class="collapse" for="c-38690900">[-]</label><label class="expand" for="c-38690900">[1 more]</label></div><br/><div class="children"><div class="content">&gt; This is the biggest problem with the LLVM mentality: they use architecture support as a means to extract support (i.e. salaried dev positions) from hardware companies.<p>I have a hard time seeing this as a bad thing. Hardware companies seem like the most logical people to pay for maintaining support for the architectures they sell.</div><br/></div></div><div id="38691475" class="c"><input type="checkbox" id="c-38691475" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38685887">root</a><span>|</span><a href="#38690790">parent</a><span>|</span><a href="#38690900">prev</a><span>|</span><a href="#38686987">next</a><span>|</span><label class="collapse" for="c-38691475">[-]</label><label class="expand" for="c-38691475">[1 more]</label></div><br/><div class="children"><div class="content">Support wasn&#x27;t dumped, it was demoted from Tier 2 to Tier 3 to better reflect the level of support that backend effectively already had. As mentioned in that thread, if someone steps up to maintain it, it can be bumped again to Tier 2.<p>Be aware that GCC doesn&#x27;t have a similar level of specificity about the state of each platform they support. There are packages in Debian that &quot;compile&quot; but when trying to execute them on &quot;exotic&quot; platforms you encounter bugs immediately. Supporting a platform in a static codebase of a compiler is easy, but in codebases actively being worked on, like GCC and LLVM, keeping things working is not trivial.</div><br/></div></div></div></div><div id="38686987" class="c"><input type="checkbox" id="c-38686987" checked=""/><div class="controls bullet"><span class="by">Asraelite</span><span>|</span><a href="#38685887">parent</a><span>|</span><a href="#38690790">prev</a><span>|</span><a href="#38687015">next</a><span>|</span><label class="collapse" for="c-38686987">[-]</label><label class="expand" for="c-38686987">[3 more]</label></div><br/><div class="children"><div class="content">I would assume it also means additional configuration options for already-supported architectures.<p>For example, I recently discovered that with RISC-V, GCC supports the RV32E target but LLVM doesn&#x27;t.</div><br/><div id="38687868" class="c"><input type="checkbox" id="c-38687868" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#38685887">root</a><span>|</span><a href="#38686987">parent</a><span>|</span><a href="#38687015">next</a><span>|</span><label class="collapse" for="c-38687868">[-]</label><label class="expand" for="c-38687868">[2 more]</label></div><br/><div class="children"><div class="content">Are you sure about that?<p>I was pretty sure that llvm has supported RV32E for years now.  <a href="https:&#x2F;&#x2F;reviews.llvm.org&#x2F;D70401?id=395048" rel="nofollow noreferrer">https:&#x2F;&#x2F;reviews.llvm.org&#x2F;D70401?id=395048</a></div><br/><div id="38688361" class="c"><input type="checkbox" id="c-38688361" checked=""/><div class="controls bullet"><span class="by">Asraelite</span><span>|</span><a href="#38685887">root</a><span>|</span><a href="#38687868">parent</a><span>|</span><a href="#38687015">next</a><span>|</span><label class="collapse" for="c-38688361">[-]</label><label class="expand" for="c-38688361">[1 more]</label></div><br/><div class="children"><div class="content">Oh, last time I checked clang didn&#x27;t support it.<p>In any case, there are a lot of other compiler flags that are exclusive to gcc.</div><br/></div></div></div></div></div></div><div id="38687015" class="c"><input type="checkbox" id="c-38687015" checked=""/><div class="controls bullet"><span class="by">segfaultbuserr</span><span>|</span><a href="#38685887">parent</a><span>|</span><a href="#38686987">prev</a><span>|</span><a href="#38686845">next</a><span>|</span><label class="collapse" for="c-38687015">[-]</label><label class="expand" for="c-38687015">[1 more]</label></div><br/><div class="children"><div class="content">Can&#x27;t wait to see some PDP-11 machine code from Rust (the last time I checked, freestanding C compiling still worked on GCC).</div><br/></div></div></div></div><div id="38686845" class="c"><input type="checkbox" id="c-38686845" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38685887">prev</a><span>|</span><a href="#38687144">next</a><span>|</span><label class="collapse" for="c-38686845">[-]</label><label class="expand" for="c-38686845">[5 more]</label></div><br/><div class="children"><div class="content">&gt; A lot of care is being put into gccrs not becoming a &quot;superset&quot; of Rust, as Cohen put it. The project wants to make sure that it does not create a special &quot;GNU Rust&quot; language, <i>but is trying instead to replicate the output of rustc — bugs, quirks, and all</i>.<p>In my experience, the part in italics is a significant mistake.<p>Rust does not have a specification; there is a reference but it is explicitly not normative.  A language udocumented except for a single reference implementation (as is tpday&#x27;s fashion) have a long term weakness.  What is the motivation for slavishly trying to maintain compatibility with the bugs and accidental quirks of another implementation?  To guarantee that existing code will work in both implementations, which sounds sensible.  And it is a sensible goal, but it does so at enormous cost by enforcing it in the wrong place.<p>The problem is that sometimes decisions are wrong, and sometimes bugs are written.  But when you promise that all implementations will be bug compatible as part of compatibility you are also signing up to fossilize these bugs whether you want to or not.<p>A good example of someone who embraced this (to their credit!) is Microsoft: they spend a lot of person-power making sure that old programs continue to run while trying to fix security and reliability bugs.  Rust need not and should not sign up for this burden so early in its lifespan.  They should learn from history.<p>If they want the language to evolve they should embrace QA and QC.  Famously &quot;you cannot test quality into a product&quot;.  You need QA: architecture, design, design and code reviews, etc to ensure that things will work properly and when not, that &quot;failure heads in the appropriate direction&quot;.  Then later in the development cycle QC (test cases) tries to see if you missed.  This doesn&#x27;t just apply to product development -- it applies to language development especially.<p>The strong standards (e.g. ComonLisp, C++, FORTRAN) embraced this belief.  The weak, de facto ones (Most notably Python, but plenty of others) can still become popular, but change is difficult.  Look at how long the Python 2-&gt;3 transition took, and how few python implementations there are.</div><br/><div id="38690303" class="c"><input type="checkbox" id="c-38690303" checked=""/><div class="controls bullet"><span class="by">nicoburns</span><span>|</span><a href="#38686845">parent</a><span>|</span><a href="#38687144">next</a><span>|</span><label class="collapse" for="c-38690303">[-]</label><label class="expand" for="c-38690303">[4 more]</label></div><br/><div class="children"><div class="content">If they find a big then presumably they’ll report it upstream and both implementations can be changed.</div><br/><div id="38690781" class="c"><input type="checkbox" id="c-38690781" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38686845">root</a><span>|</span><a href="#38690303">parent</a><span>|</span><a href="#38691166">next</a><span>|</span><label class="collapse" for="c-38690781">[-]</label><label class="expand" for="c-38690781">[2 more]</label></div><br/><div class="children"><div class="content">The point is that fixing that bug may break existing, running code that depends on it.</div><br/><div id="38691319" class="c"><input type="checkbox" id="c-38691319" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#38686845">root</a><span>|</span><a href="#38690781">parent</a><span>|</span><a href="#38691166">next</a><span>|</span><label class="collapse" for="c-38691319">[-]</label><label class="expand" for="c-38691319">[1 more]</label></div><br/><div class="children"><div class="content">Thats why we run crater against all of crates.io: there are changes that should be allowed that we hold off on because 9f breakage, and fixes we assumed we couldn&#x27;t land that in reality had no real world impact. As time goes on the confidence a &quot;clean&quot; crater run gives us goes down, due to adoption in closed source environments, but it is still invaluable signal. Depending on the bug, we can keep the current behavior around for prior editions but fix it for future ones.</div><br/></div></div></div></div><div id="38691166" class="c"><input type="checkbox" id="c-38691166" checked=""/><div class="controls bullet"><span class="by">akira2501</span><span>|</span><a href="#38686845">root</a><span>|</span><a href="#38690303">parent</a><span>|</span><a href="#38690781">prev</a><span>|</span><a href="#38687144">next</a><span>|</span><label class="collapse" for="c-38691166">[-]</label><label class="expand" for="c-38691166">[1 more]</label></div><br/><div class="children"><div class="content">Presumably they&#x27;ll both agree 100% of the time as well.</div><br/></div></div></div></div></div></div><div id="38687144" class="c"><input type="checkbox" id="c-38687144" checked=""/><div class="controls bullet"><span class="by">mkesper</span><span>|</span><a href="#38686845">prev</a><span>|</span><a href="#38684679">next</a><span>|</span><label class="collapse" for="c-38687144">[-]</label><label class="expand" for="c-38687144">[2 more]</label></div><br/><div class="children"><div class="content">Thanks for posting the lwn.net link, reminded me of renewing my subscription!</div><br/><div id="38688143" class="c"><input type="checkbox" id="c-38688143" checked=""/><div class="controls bullet"><span class="by">sophacles</span><span>|</span><a href="#38687144">parent</a><span>|</span><a href="#38684679">next</a><span>|</span><label class="collapse" for="c-38688143">[-]</label><label class="expand" for="c-38688143">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a good subscription to have. I&#x27;ve gotten far more value from my LWN subscription than I spent, and recommend everyone that does lowish level work get one.</div><br/></div></div></div></div><div id="38684679" class="c"><input type="checkbox" id="c-38684679" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38687144">prev</a><span>|</span><a href="#38684588">next</a><span>|</span><label class="collapse" for="c-38684679">[-]</label><label class="expand" for="c-38684679">[4 more]</label></div><br/><div class="children"><div class="content">&gt;the Linux kernel is a key motivator for the project because there are a lot of kernel people who would prefer the kernel to be compiled only by the GNU toolchain.<p>Linux can already be compiled with clang if you want an all LLVM based toolchain. The duplicate effort of developing and maintaining this does not sound worth it to have GNU &quot;purity.&quot;</div><br/><div id="38689436" class="c"><input type="checkbox" id="c-38689436" checked=""/><div class="controls bullet"><span class="by">mtrower</span><span>|</span><a href="#38684679">parent</a><span>|</span><a href="#38690660">next</a><span>|</span><label class="collapse" for="c-38689436">[-]</label><label class="expand" for="c-38689436">[2 more]</label></div><br/><div class="children"><div class="content">I think you may be misunderstanding here. They aren’t trying to keep the kennel GNU exclusive —— they merely want the option for a pre GNU toolchain.</div><br/><div id="38689947" class="c"><input type="checkbox" id="c-38689947" checked=""/><div class="controls bullet"><span class="by">charcircuit</span><span>|</span><a href="#38684679">root</a><span>|</span><a href="#38689436">parent</a><span>|</span><a href="#38690660">next</a><span>|</span><label class="collapse" for="c-38689947">[-]</label><label class="expand" for="c-38689947">[1 more]</label></div><br/><div class="children"><div class="content">What is a pre GNU toolchain?</div><br/></div></div></div></div><div id="38690660" class="c"><input type="checkbox" id="c-38690660" checked=""/><div class="controls bullet"><span class="by">edelsohn</span><span>|</span><a href="#38684679">parent</a><span>|</span><a href="#38689436">prev</a><span>|</span><a href="#38684588">next</a><span>|</span><label class="collapse" for="c-38690660">[-]</label><label class="expand" for="c-38690660">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not about purity, it&#x27;s about options.  The ClangBuiltLinux community advocated that Linux should not be dependent upon a single compiler.  But when Rust came along, suddenly many of the same people suddently decided that a single compiler was okay.</div><br/></div></div></div></div></div></div></div></div></div></body></html>