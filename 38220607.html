<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1699693265330" as="style"/><link rel="stylesheet" href="styles.css?v=1699693265330"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://bernsteinbear.com/blog/ddcg/">A quick look at destination-driven code generation</a> <span class="domain">(<a href="https://bernsteinbear.com">bernsteinbear.com</a>)</span></div><div class="subtext"><span>tekknolagi</span> | <span>6 comments</span></div><br/><div><div id="38226905" class="c"><input type="checkbox" id="c-38226905" checked=""/><div class="controls bullet"><span class="by">lboasso</span><span>|</span><a href="#38226334">next</a><span>|</span><label class="collapse" for="c-38226905">[-]</label><label class="expand" for="c-38226905">[2 more]</label></div><br/><div class="children"><div class="content">It is interesting to see that this approach has been used by Niklaus Wirth in most of his compilers, see &quot;Compiler Construction - The Art of Niklaus Wirth&quot; by Hanspeter Mössenböck [0]. 
This technique was also described by David R. Hanson in &quot;Code Improvement via Lazy Evaluation&quot;, 1980 [1] and &quot;Simple Code Optimizations&quot;, 1983 [2].<p>[0] <a href="https:&#x2F;&#x2F;github.com&#x2F;lboasso&#x2F;oberonc&#x2F;blob&#x2F;master&#x2F;doc&#x2F;Moe00b.pdf">https:&#x2F;&#x2F;github.com&#x2F;lboasso&#x2F;oberonc&#x2F;blob&#x2F;master&#x2F;doc&#x2F;Moe00b.pd...</a><p>[1] <a href="http:&#x2F;&#x2F;storage.webhop.net&#x2F;documents&#x2F;lazyevaluation.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;storage.webhop.net&#x2F;documents&#x2F;lazyevaluation.pdf</a><p>[2] <a href="http:&#x2F;&#x2F;storage.webhop.net&#x2F;documents&#x2F;simpleopt.pdf" rel="nofollow noreferrer">http:&#x2F;&#x2F;storage.webhop.net&#x2F;documents&#x2F;simpleopt.pdf</a></div><br/><div id="38228550" class="c"><input type="checkbox" id="c-38228550" checked=""/><div class="controls bullet"><span class="by">i_don_t_know</span><span>|</span><a href="#38226905">parent</a><span>|</span><a href="#38226334">next</a><span>|</span><label class="collapse" for="c-38228550">[-]</label><label class="expand" for="c-38228550">[1 more]</label></div><br/><div class="children"><div class="content">Wirth’s book on Compiler Construction is available at <a href="https:&#x2F;&#x2F;people.inf.ethz.ch&#x2F;wirth&#x2F;CompilerConstruction&#x2F;index.html" rel="nofollow noreferrer">https:&#x2F;&#x2F;people.inf.ethz.ch&#x2F;wirth&#x2F;CompilerConstruction&#x2F;index....</a><p>The relevant section is 10.2. But its mechanism is the “inverse” of destination driven code generation as I understand it. In Wirth’s Item approach the callee picks a location and tells the caller where to look. Whereas in destination driven code generation the caller tells the callee where to put the result.</div><br/></div></div></div></div><div id="38226334" class="c"><input type="checkbox" id="c-38226334" checked=""/><div class="controls bullet"><span class="by">Joker_vD</span><span>|</span><a href="#38226905">prev</a><span>|</span><label class="collapse" for="c-38226334">[-]</label><label class="expand" for="c-38226334">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Nothing too fancy. No control-flow. No function calls. No data structures.<p>If that&#x27;s the problem statement, then you may as well perform register allocation: all you need is Sethi–Ullman&#x27;s algorithm [0][1], and it&#x27;s quite simple.<p>Register allocation only becomes complicated when the control flow comes into the picture, especially the loops. Even then, there are some more or less obvious ways to do it, if you don&#x27;t want to do graph colouring after Chaitin et al. (remember, people had to write register allocators before Chaitin&#x27;s publication in 1981). For instance, you can do what the very first FORTRAN compiler did: you look at registerts as a cache for memory, in which case the Bélády&#x27;s algorithm can be used for spilling. And with loops over arrays you can leverage the knowledge that you&#x27;re looping over arrays quite nicely [2].<p>[0] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sethi%E2%80%93Ullman_algorithm" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sethi%E2%80%93Ullman_algorithm</a><p>[1] <a href="https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;321607.321620" rel="nofollow noreferrer">https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;321607.321620</a><p>[2] <a href="https:&#x2F;&#x2F;archive.computerhistory.org&#x2F;resources&#x2F;text&#x2F;Fortran&#x2F;102663113.05.01.acc.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;archive.computerhistory.org&#x2F;resources&#x2F;text&#x2F;Fortran&#x2F;1...</a></div><br/><div id="38226371" class="c"><input type="checkbox" id="c-38226371" checked=""/><div class="controls bullet"><span class="by">titzer</span><span>|</span><a href="#38226334">parent</a><span>|</span><label class="collapse" for="c-38226371">[-]</label><label class="expand" for="c-38226371">[2 more]</label></div><br/><div class="children"><div class="content">The syntax-tree driven approach is considerably simpler than Sethi-Ullman, and faster. If you read the blog post, you can see it&#x27;s based on a 1990 paper that references the 1970 paper that introduced the Sethi-Ullman algorithm. So neither the blog author (hi Max) nor the authors of the 1990 paper were unaware of it.</div><br/><div id="38226965" class="c"><input type="checkbox" id="c-38226965" checked=""/><div class="controls bullet"><span class="by">lboasso</span><span>|</span><a href="#38226334">root</a><span>|</span><a href="#38226371">parent</a><span>|</span><label class="collapse" for="c-38226965">[-]</label><label class="expand" for="c-38226965">[1 more]</label></div><br/><div class="children"><div class="content">It would be great to have a simple Virgil x86-64 backend based only on the destination-driven code generation technique, and compare the performance of the generated code (and compilation speed) with the official optimizing x86-64 backend. 
Would the implementation effort be comparable to the JVM backend?<p>BTW I really like the design of Virgil described in &quot;Harmonizing Classes, Functions, Tuples,and Type Parameters in Virgil III&quot;, bravo!</div><br/></div></div></div></div></div></div></div></div></div></div></div></body></html>