<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1701766854762" as="style"/><link rel="stylesheet" href="styles.css?v=1701766854762"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/seveibar/pragmaticversioning">Pragmatic Versioning – An Alternative to Semver</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>seveibar</span> | <span>75 comments</span></div><br/><div><div id="38528448" class="c"><input type="checkbox" id="c-38528448" checked=""/><div class="controls bullet"><span class="by">k__</span><span>|</span><a href="#38524146">next</a><span>|</span><label class="collapse" for="c-38528448">[-]</label><label class="expand" for="c-38528448">[1 more]</label></div><br/><div class="children"><div class="content">Similar goal, different approach:<p><a href="https:&#x2F;&#x2F;gitlab.com&#x2F;staltz&#x2F;comver&#x2F;-&#x2F;blob&#x2F;master&#x2F;README.md" rel="nofollow noreferrer">https:&#x2F;&#x2F;gitlab.com&#x2F;staltz&#x2F;comver&#x2F;-&#x2F;blob&#x2F;master&#x2F;README.md</a></div><br/></div></div><div id="38524146" class="c"><input type="checkbox" id="c-38524146" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38528448">prev</a><span>|</span><a href="#38527279">next</a><span>|</span><label class="collapse" for="c-38524146">[-]</label><label class="expand" for="c-38524146">[19 more]</label></div><br/><div class="children"><div class="content">&gt; In Semantic Versioning, there is no way to release or communicate a LTS&#x2F;&quot;long term support&quot; version of a package. In Pragmatic Versioning, this is solved with a BIGRELEASE version, which has meaning that can be controlled by the package author.<p>That doesn&#x27;t make sense to me.<p>With semantic versioning the way you communicate a LTS version of a package is you declare that in your documentation. Django (which doesn&#x27;t fully use SemVer, but is still a good example here) does that on this page: <a href="https:&#x2F;&#x2F;www.djangoproject.com&#x2F;download&#x2F;#supported-versions" rel="nofollow noreferrer">https:&#x2F;&#x2F;www.djangoproject.com&#x2F;download&#x2F;#supported-versions</a><p>&quot;In Pragmatic Versioning, this is solved with a BIGRELEASE version, which has meaning that can be controlled by the package author&quot; - that doesn&#x27;t appear to address the need for LTS communication at all. It feels like the situation is exactly the same as SemVer: if you want to do LTS you have to represent that outside of the version number.</div><br/><div id="38524446" class="c"><input type="checkbox" id="c-38524446" checked=""/><div class="controls bullet"><span class="by">SrslyJosh</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38524194">next</a><span>|</span><label class="collapse" for="c-38524446">[-]</label><label class="expand" for="c-38524446">[4 more]</label></div><br/><div class="children"><div class="content">At first I was confused because of how similar this sounds to semver, but it&#x27;s really just changing the granularity from (major, minor, patch) to (release, major, minor), where &quot;major&quot; versions break compatibility in both schemes.</div><br/><div id="38524935" class="c"><input type="checkbox" id="c-38524935" checked=""/><div class="controls bullet"><span class="by">dbingham</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524446">parent</a><span>|</span><a href="#38527301">next</a><span>|</span><label class="collapse" for="c-38524935">[-]</label><label class="expand" for="c-38524935">[2 more]</label></div><br/><div class="children"><div class="content">(release, major, minor) is honestly how versions often get used in the wild.  Especially in CD contexts where every change is versioned and deployed and the meaning between patch and minor gets a little lost.</div><br/><div id="38528269" class="c"><input type="checkbox" id="c-38528269" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524935">parent</a><span>|</span><a href="#38527301">next</a><span>|</span><label class="collapse" for="c-38528269">[-]</label><label class="expand" for="c-38528269">[1 more]</label></div><br/><div class="children"><div class="content">I would still like this proposal to formalise having an optional PATCH in there though:<p><pre><code>    BIGRELEASE.MAJOR.MINOR[.PATCH]
</code></pre>
That way one can lock the version to get only actual bugfixes, with no other change:<p><pre><code>    gem &#x27;foo&#x27;, &#x27;~&gt; 2.3.4.5&#x27;
</code></pre>
would get 2.3.4.5 and up but none† of 2.3.5, and it&#x27;s up to the project to decide if they want to do any release like that.<p>† excluding any 2.3.5 prerelease as well</div><br/></div></div></div></div><div id="38527301" class="c"><input type="checkbox" id="c-38527301" checked=""/><div class="controls bullet"><span class="by">seveibar</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524446">parent</a><span>|</span><a href="#38524935">prev</a><span>|</span><a href="#38524194">next</a><span>|</span><label class="collapse" for="c-38527301">[-]</label><label class="expand" for="c-38527301">[1 more]</label></div><br/><div class="children"><div class="content">Yep, originally I wrote BIGRELEASE.MAJOR.MINOR but I didn&#x27;t want to confuse the terms. (The first commit shows this: <a href="https:&#x2F;&#x2F;github.com&#x2F;seveibar&#x2F;pragmaticversioning&#x2F;commit&#x2F;70b76ff9e264b77de6792b8210a15d5a3fbb67e3">https:&#x2F;&#x2F;github.com&#x2F;seveibar&#x2F;pragmaticversioning&#x2F;commit&#x2F;70b76...</a>) Good read :)</div><br/></div></div></div></div><div id="38524194" class="c"><input type="checkbox" id="c-38524194" checked=""/><div class="controls bullet"><span class="by">natbennett</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38524446">prev</a><span>|</span><a href="#38527427">next</a><span>|</span><label class="collapse" for="c-38524194">[-]</label><label class="expand" for="c-38524194">[6 more]</label></div><br/><div class="children"><div class="content">“There’s no way to…” is maybe imprecise phrasing but this is a real problem.<p>Marketing departments really want to use that first number for Big Important Releases and <i>only</i> Big Important Releases.<p>I have seen products get their version incremented from 2.x.x 3.0.0 to indicate that an entirely different product (that could be deployed alongside the first but was otherwise unrelated) was being launched.</div><br/><div id="38525469" class="c"><input type="checkbox" id="c-38525469" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524194">parent</a><span>|</span><a href="#38524619">next</a><span>|</span><label class="collapse" for="c-38525469">[-]</label><label class="expand" for="c-38525469">[2 more]</label></div><br/><div class="children"><div class="content">So just tack on a number -  marketing.breaking.feature.patch - or market on the feature number (Solaris 11 uname will happily tell you its real version is 5.11)</div><br/><div id="38525947" class="c"><input type="checkbox" id="c-38525947" checked=""/><div class="controls bullet"><span class="by">CSMastermind</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38525469">parent</a><span>|</span><a href="#38524619">next</a><span>|</span><label class="collapse" for="c-38525947">[-]</label><label class="expand" for="c-38525947">[1 more]</label></div><br/><div class="children"><div class="content">Okay I now very strongly support renaming the numbers to be more explicit whether we add more of them or not.<p>Literally calling the numbers &#x27;breaking&#x27; and &#x27;feature&#x27; would have made things more clear.</div><br/></div></div></div></div><div id="38524619" class="c"><input type="checkbox" id="c-38524619" checked=""/><div class="controls bullet"><span class="by">ajmurmann</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524194">parent</a><span>|</span><a href="#38525469">prev</a><span>|</span><a href="#38524436">next</a><span>|</span><label class="collapse" for="c-38524619">[-]</label><label class="expand" for="c-38524619">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also seen the opposite where an organization night be hesitant to release a new major because it comes with long contractual support obligations.</div><br/><div id="38524956" class="c"><input type="checkbox" id="c-38524956" checked=""/><div class="controls bullet"><span class="by">WorldMaker</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524619">parent</a><span>|</span><a href="#38524436">next</a><span>|</span><label class="collapse" for="c-38524956">[-]</label><label class="expand" for="c-38524956">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve also seen too much of marketing is watching the project iterate too closely, it&#x27;s a Ship of Theseus, and they never know when to declare a &quot;Big Release&quot; anyway. In six months all of the planks are different, but it happened so slowly for marketing they still think it is the same ship. Projects just get stuck in 1.x marketing version because marketing has no idea where major releases should go. They want always up to date SaaS but then are confused they can&#x27;t market it like the big Waterfall adventures of yesterday.<p>At least with semver they might be forced to say something. I&#x27;ve done that a few times where the marketing version number displayed in the app is effectively just 1.{semver major}.{semver minor} and &quot;just tell us when you want to bump that 1 to a 2 or something&quot; getting the response &quot;well, it hasn&#x27;t really changed all that much from 1.0, has it?&quot; and then pulling out the receipts of something like 30+ semver breaking differences in X months.</div><br/></div></div></div></div><div id="38524436" class="c"><input type="checkbox" id="c-38524436" checked=""/><div class="controls bullet"><span class="by">mlhpdx</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524194">parent</a><span>|</span><a href="#38524619">prev</a><span>|</span><a href="#38527427">next</a><span>|</span><label class="collapse" for="c-38524436">[-]</label><label class="expand" for="c-38524436">[1 more]</label></div><br/><div class="children"><div class="content">That doesn&#x27;t sound like an issue with semver (or pragmatic).  There is no versioning convention that will prevent people from being people.  A rigid, automated (magical) versioning _system_ might do that, but not a convention&#x2F;standard.<p>I find semver extremely helpful, both as an author and consumer. It may make me think a little for some packages about where I want to pin things, but at least it makes the mechanics of pinning them sensible.<p>Edit: packets -&gt; packages</div><br/></div></div></div></div><div id="38527427" class="c"><input type="checkbox" id="c-38527427" checked=""/><div class="controls bullet"><span class="by">seveibar</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38524194">prev</a><span>|</span><a href="#38525390">next</a><span>|</span><label class="collapse" for="c-38527427">[-]</label><label class="expand" for="c-38527427">[1 more]</label></div><br/><div class="children"><div class="content">This is a great critique, and something important to address if &quot;pragmatic versioning&quot; actually becomes a thing. I think one solution is to have &quot;LTS Pragmatic Versioning&quot; as a subtype e.g. LTS.ANNOUNCE.INCREMENT could be &quot;LTS Pragmatic Versioning&quot;, if you&#x27;re not committing to LTS you can just use the more vague base &quot;Pragmatic Versioning&quot; until&#x2F;unless you&#x27;re willing to commit to more as a package author. The main tension here is some package authors will want to indicate LTS, and others won&#x27;t (I might only commit to LTS for 10-20% of my packages, since every change needs a tiny bit of extra evaluation)</div><br/></div></div><div id="38525390" class="c"><input type="checkbox" id="c-38525390" checked=""/><div class="controls bullet"><span class="by">coldtea</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38527427">prev</a><span>|</span><a href="#38524377">next</a><span>|</span><label class="collapse" for="c-38525390">[-]</label><label class="expand" for="c-38525390">[3 more]</label></div><br/><div class="children"><div class="content">&gt;<i>That doesn&#x27;t make sense to me. With semantic versioning the way you communicate a LTS version of a package is you declare that in your documentation</i><p>So, TFA&#x27;s statement that &quot;In Semantic Versioning, there is no way to release or communicate a LTS&#x2F;&quot;long term support&quot; version of a package&quot; does make sense to you after all.<p>You can&#x27;t do it in the versioning, you need to do it in the docuementation.</div><br/><div id="38526046" class="c"><input type="checkbox" id="c-38526046" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38525390">parent</a><span>|</span><a href="#38524377">next</a><span>|</span><label class="collapse" for="c-38526046">[-]</label><label class="expand" for="c-38526046">[2 more]</label></div><br/><div class="children"><div class="content">What didn&#x27;t make sense to me is that it says &quot;there&#x27;s no way to indicate LTS in SemVer&quot; (which I agree with)... and then fails to make the case that this new versioning system solves that problem.</div><br/><div id="38527378" class="c"><input type="checkbox" id="c-38527378" checked=""/><div class="controls bullet"><span class="by">seveibar</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38526046">parent</a><span>|</span><a href="#38524377">next</a><span>|</span><label class="collapse" for="c-38527378">[-]</label><label class="expand" for="c-38527378">[1 more]</label></div><br/><div class="children"><div class="content">Yea I think more specificity is needed, SemVer is an actual spec with well-defined terms and this is more of an early concept. The tricky thing to maneuver is many package authors will not want to commit to an LTS, so what do you do? In pragmatic versioning, there&#x27;s an available mechanism in the versioning scheme available to package authors, but not a guarantee to package consumers.</div><br/></div></div></div></div></div></div><div id="38524377" class="c"><input type="checkbox" id="c-38524377" checked=""/><div class="controls bullet"><span class="by">herpdyderp</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38525390">prev</a><span>|</span><a href="#38525481">next</a><span>|</span><label class="collapse" for="c-38524377">[-]</label><label class="expand" for="c-38524377">[2 more]</label></div><br/><div class="children"><div class="content">Also<p>&gt; BIGRELEASE version, which has meaning that can be controlled by the package author<p>So BIGRELEASE doesn&#x27;t actually convey LTS at all. Meaning, Pragmatic Versioning does not solve LTS any more than Semver does.</div><br/><div id="38528414" class="c"><input type="checkbox" id="c-38528414" checked=""/><div class="controls bullet"><span class="by">HelloNurse</span><span>|</span><a href="#38524146">root</a><span>|</span><a href="#38524377">parent</a><span>|</span><a href="#38525481">next</a><span>|</span><label class="collapse" for="c-38528414">[-]</label><label class="expand" for="c-38528414">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t expect too much from version numbering schemes; they can follow sufficiently objective conventions (breaking changes for typical usage or not, worth announcing according to the authors or not) but not convey complex information.<p>There is no way to tell which ones in a set of equally major versions are LTS or not using version numbers because there are often too many; for example Java has major version numbers for major language features and standard library additions and removals, with reasonably relevant versions currently spanning from 8 (1.8 in the old numbering) to 21, three or four of them LTS and the others transitional.<p>There is also no way to tell obsolete LTS versions from current ones using version numbers, without explicit documentation committing to dates or making EOL announcement.</div><br/></div></div></div></div><div id="38525481" class="c"><input type="checkbox" id="c-38525481" checked=""/><div class="controls bullet"><span class="by">nosefurhairdo</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38524377">prev</a><span>|</span><a href="#38525977">next</a><span>|</span><label class="collapse" for="c-38525481">[-]</label><label class="expand" for="c-38525481">[1 more]</label></div><br/><div class="children"><div class="content">How about the following scenario:<p>Package A is SemVer 1.2.3, package B is PragVer 1.2.3. both A and B have big release with breaking changes and marketing hype, so now they&#x27;re both at 2.0.0. It is later found that in version 1 of both packages there is a bug requiring a breaking change in order to fix. B (pragmatic) can apply the fix to version 1 branch and release it as 1.3.0. How does A (semantic) make a breaking change on version 1 and version it correctly?<p>TL;DR Pragmatic Versioning enables breaking changes on LTS versions.</div><br/></div></div><div id="38525977" class="c"><input type="checkbox" id="c-38525977" checked=""/><div class="controls bullet"><span class="by">yardstick</span><span>|</span><a href="#38524146">parent</a><span>|</span><a href="#38525481">prev</a><span>|</span><a href="#38527279">next</a><span>|</span><label class="collapse" for="c-38525977">[-]</label><label class="expand" for="c-38525977">[1 more]</label></div><br/><div class="children"><div class="content">Yeah it doesn’t grok for me either.<p>If I do a big release, but API hasn’t changed, am I going from:<p>10.50.1<p>To<p>A) 11.50.1<p>B) 11.0.0<p>?</div><br/></div></div></div></div><div id="38527279" class="c"><input type="checkbox" id="c-38527279" checked=""/><div class="controls bullet"><span class="by">avodonosov</span><span>|</span><a href="#38524146">prev</a><span>|</span><a href="#38528313">next</a><span>|</span><label class="collapse" for="c-38527279">[-]</label><label class="expand" for="c-38527279">[2 more]</label></div><br/><div class="children"><div class="content">The biggest issue with semver is that it encourages compatibility breakages under the false promise that increased major version number saves the users from the dependency hell.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;semver&#x2F;semver&#x2F;issues&#x2F;771">https:&#x2F;&#x2F;github.com&#x2F;semver&#x2F;semver&#x2F;issues&#x2F;771</a><p>SemVer is a product of Ruby community.<p>In 2000s Ruby library authors were breaking compatibility left and right, neglecting elementary compatibility practices. If you were working on an application, every time when you update dependencies, the application would break.<p>So (in 2011 ?) they came out with this &quot;manifesto&quot; (Why such a big name? This scheme of versioning was well established in linkers and sonames of Unix-like systems for decades - it goes back to at least 1987 paper &quot;Shared Libraries in SunOS&quot;).<p>It&#x27;s a good thing SemVer acknowledged finally that compatibility is a serious matter. Only that it&#x27;s better to discourage compatibility breakages. An in cases when it&#x27;s really needed (I agree such cases exists), there are things to take care of in addition to simply increasing major version num.</div><br/><div id="38528435" class="c"><input type="checkbox" id="c-38528435" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#38527279">parent</a><span>|</span><a href="#38528313">next</a><span>|</span><label class="collapse" for="c-38528435">[-]</label><label class="expand" for="c-38528435">[1 more]</label></div><br/><div class="children"><div class="content">From your issue link:<p>&gt; Then commons-logging changes its API incompatibly and is released as commons-logging 2.0.1. Authentication adopts commons-logging 2.0.1 while other libraries still depend on 1.1.1<p>&gt; Now my-application is broken, because the dependency tree includes two versions of commons-logging which share packages, class &#x2F; functions names, and thus can not be loaded simultaneously.<p>I absolutely don&#x27;t see how this is a problem with semver, it is not the responsibility of semver to tell a language how packages should be isolated and loaded. That is a problem of a) the language and b) dependency resolution in the package manager.<p>&gt; SemVer is a product of Ruby community.<p>Bundler, by design, does not allow the above, instead having a flat, consistent vision of dependencies.<p>NPM though, allows that, allowing nested dependencies, by virtue of the ES6 module system importing to a variable in a lexical scope. Go also allows that, by virtue of its imports being scoped to a package (or file, I can&#x27;t recall).<p>Ruby has side-effectful load&#x2F;require decoupled from the open class system - which is what bundler is designed around -, but can do that kind of isolation too! In fact, I&#x27;ve done it: <a href="https:&#x2F;&#x2F;github.com&#x2F;lloeki&#x2F;pak">https:&#x2F;&#x2F;github.com&#x2F;lloeki&#x2F;pak</a><p>Unless packages leak to globals each version is oblivious to the one next to it. Unless package dependents communicate with one another using objects from the packages they can happily live in their own little isolated world. Now if they do, then it&#x27;s like hitting a HTTP &#x2F;api&#x2F;v1 with an HTTP &#x2F;api&#x2F;v2 client and somehow wishing things will work. Either the package (which should not leak globals &#x2F; disallow cross-version communication) or the language (which should not allow leaking globals &#x2F; detect incompatible communication).<p>None of this is the responsibility of semver. In fact, semver would help the language provide tooling to detect that kind of &quot;hey this instance is from foo-1.0 but you&#x27;re trying to consume it in foo-2.0&quot;.</div><br/></div></div></div></div><div id="38528313" class="c"><input type="checkbox" id="c-38528313" checked=""/><div class="controls bullet"><span class="by">liampulles</span><span>|</span><a href="#38527279">prev</a><span>|</span><a href="#38524323">next</a><span>|</span><label class="collapse" for="c-38528313">[-]</label><label class="expand" for="c-38528313">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve seen and used marketing-led versioning for internal systems a few times. The major version is used purely for promoting team progress (e.g. Product 2.0).<p>The purist in me balks, but the pragmatic cynic is happy to have a tool in the belt.</div><br/></div></div><div id="38524323" class="c"><input type="checkbox" id="c-38524323" checked=""/><div class="controls bullet"><span class="by">herpdyderp</span><span>|</span><a href="#38528313">prev</a><span>|</span><a href="#38526751">next</a><span>|</span><label class="collapse" for="c-38524323">[-]</label><label class="expand" for="c-38524323">[11 more]</label></div><br/><div class="children"><div class="content">This sounds similar to how TypeScript versions are named and it is a huge pain to me. Can I upgrade from 5.2.2 to 5.3.2 without everything breaking? Who knows. I thought I could, but I was wrong. Semver (when followed correctly, of course) would&#x27;ve conveyed this information instantly.<p>I don&#x27;t care about the branding, I just want my code to work. (Disclaimer: I am obviously not in marketing.)</div><br/><div id="38524357" class="c"><input type="checkbox" id="c-38524357" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#38524323">parent</a><span>|</span><a href="#38526751">next</a><span>|</span><label class="collapse" for="c-38524357">[-]</label><label class="expand" for="c-38524357">[10 more]</label></div><br/><div class="children"><div class="content">To be fair, Semver also falls apart relatively regularly, where a major version upgrade is easy and fine, but a minor upgrade trips you up.<p>Even if an API stays exactly the same, something about what it returns could subtly change, so there&#x27;s really no replacement for extensive testing.</div><br/><div id="38526322" class="c"><input type="checkbox" id="c-38526322" checked=""/><div class="controls bullet"><span class="by">chipsrafferty</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38524357">parent</a><span>|</span><a href="#38524435">next</a><span>|</span><label class="collapse" for="c-38526322">[-]</label><label class="expand" for="c-38526322">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Even if an API stays exactly the same, something about what it returns could subtly change<p>Where I work, we call that a breaking change.  If a consumer of our API codes for a particular response, and we change that response, then we could break their application.<p>No one wants to have to validate deeply nested objects to test if they do indeed return the thing we promised to return in our contract...</div><br/><div id="38527528" class="c"><input type="checkbox" id="c-38527528" checked=""/><div class="controls bullet"><span class="by">pvorb</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38526322">parent</a><span>|</span><a href="#38524435">next</a><span>|</span><label class="collapse" for="c-38527528">[-]</label><label class="expand" for="c-38527528">[2 more]</label></div><br/><div class="children"><div class="content">So in your world, almost every bugfix is a breaking change, right? Either that or all of your bugs affect only side effects. That seems impractical to me.</div><br/><div id="38528181" class="c"><input type="checkbox" id="c-38528181" checked=""/><div class="controls bullet"><span class="by">lloeki</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38527528">parent</a><span>|</span><a href="#38524435">next</a><span>|</span><label class="collapse" for="c-38528181">[-]</label><label class="expand" for="c-38528181">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s all about the distinction between contract and implementation.<p>The difference with bugfixes is that pre-bugfix the intended API contract - including behaviour, not just signature -  was not respected by the implementation and post-bugfix the implementation becomes (more) correct WRT the intended contract.<p>IOW:<p>- On a semver patch bump the API contract does not change but the implementation of that contract was incorrect.<p>- On a semver minor bump the API contract receives an addendum, the previous contract is still in effect as a subset of the new contract.<p>- On a semver major bump the preexisting API contract is voided and is replaced by a new contract. The new contract may or may not include all or part of the old contract as a subset. Breaking change =&gt; major bump is an implication, not an equivalence: one is completely free to bump major purely for marketing reasons.<p>Of course, the difference between theory and practice is that they&#x27;re the same in theory: the contract is an ideal, the implementation may come close but will always fall short in some way.<p>I feel like many of both semver detractors and advocates get lost in theoreticals, reality is fuzzy, just use the damn thing. Or don&#x27;t and pick up another scheme, but be <i>abundantly clear</i> about how your versioning scheme works so that users can make sense of it and automate version requirement declarations in their dependency manager.</div><br/></div></div></div></div></div></div><div id="38524435" class="c"><input type="checkbox" id="c-38524435" checked=""/><div class="controls bullet"><span class="by">herpdyderp</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38524357">parent</a><span>|</span><a href="#38526322">prev</a><span>|</span><a href="#38527519">next</a><span>|</span><label class="collapse" for="c-38524435">[-]</label><label class="expand" for="c-38524435">[4 more]</label></div><br/><div class="children"><div class="content">&gt; Even if an API stays exactly the same, something about what it returns could subtly change<p>This means the API did in fact change. But you&#x27;re right of course, sometimes we pick the wrong number to bump (major vs minor vs patch).</div><br/><div id="38525278" class="c"><input type="checkbox" id="c-38525278" checked=""/><div class="controls bullet"><span class="by">madeofpalk</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38524435">parent</a><span>|</span><a href="#38527519">next</a><span>|</span><label class="collapse" for="c-38525278">[-]</label><label class="expand" for="c-38525278">[3 more]</label></div><br/><div class="children"><div class="content">It depends what you consider your &quot;API&quot; to be. One developer&#x27;s bug is another&#x27;s contract.<p>For Typescript in particular, which is nothing _but_ a type system, every change is going to be a breaking change.</div><br/><div id="38526861" class="c"><input type="checkbox" id="c-38526861" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38525278">parent</a><span>|</span><a href="#38526614">next</a><span>|</span><label class="collapse" for="c-38526861">[-]</label><label class="expand" for="c-38526861">[1 more]</label></div><br/><div class="children"><div class="content">&gt; One developer&#x27;s bug is another&#x27;s contract.<p>That is why you have major.minor.patch semantic versions. The documented and official contract is according to equal to major versions, and greater or equal to minor versions (and possibly the patch number as well); if you depend on a specific bug or internal function then you should use the exact full version number only, in order to avoid such a problem.<p>A bug would be one example, but another example might be the sqlite3_test_control function in SQLite.</div><br/></div></div><div id="38526614" class="c"><input type="checkbox" id="c-38526614" checked=""/><div class="controls bullet"><span class="by">bombcar</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38525278">parent</a><span>|</span><a href="#38526861">prev</a><span>|</span><a href="#38527519">next</a><span>|</span><label class="collapse" for="c-38526614">[-]</label><label class="expand" for="c-38526614">[1 more]</label></div><br/><div class="children"><div class="content">Exactly - if your API makes a mistake somewhere, someone is depending on that mistake. So even if the API says “returns the number of chickens” and now correctly returns 5 when there are 5 instead of saying 4; that may break something.</div><br/></div></div></div></div></div></div><div id="38527519" class="c"><input type="checkbox" id="c-38527519" checked=""/><div class="controls bullet"><span class="by">pvorb</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38524357">parent</a><span>|</span><a href="#38524435">prev</a><span>|</span><a href="#38524481">next</a><span>|</span><label class="collapse" for="c-38527519">[-]</label><label class="expand" for="c-38527519">[1 more]</label></div><br/><div class="children"><div class="content">Which is why I would give this versionong scheme the name &quot;honest versioning&quot;. It&#x27;s not following semver and it&#x27;s honest about it. If all semver projects took it seriously, we&#x27;d see far more v12.0.0&#x27;s and the likes. But we don&#x27;t.</div><br/></div></div><div id="38524481" class="c"><input type="checkbox" id="c-38524481" checked=""/><div class="controls bullet"><span class="by">paulryanrogers</span><span>|</span><a href="#38524323">root</a><span>|</span><a href="#38524357">parent</a><span>|</span><a href="#38527519">prev</a><span>|</span><a href="#38526751">next</a><span>|</span><label class="collapse" for="c-38524481">[-]</label><label class="expand" for="c-38524481">[1 more]</label></div><br/><div class="children"><div class="content">If a minor version only adds features then it shouldn&#x27;t trip one up. That&#x27;s the idea anyway.</div><br/></div></div></div></div></div></div><div id="38526751" class="c"><input type="checkbox" id="c-38526751" checked=""/><div class="controls bullet"><span class="by">gorgoiler</span><span>|</span><a href="#38524323">prev</a><span>|</span><a href="#38527962">next</a><span>|</span><label class="collapse" for="c-38526751">[-]</label><label class="expand" for="c-38526751">[1 more]</label></div><br/><div class="children"><div class="content">I like this rationale.  Acknowledging that the first number is very much the product brand is wise.  Release numbers can be quite emotional things.<p>Version numbers are indeed for communicating with your users, and in particular where that communication is a one way broadcast.  In my career I’ve found that, when version broadcasting is used inside a team, it’s a sign of dysfunctional communication.  Even at FAANG scale I encourage groups of people to colocate their code and collaborate on trunk in preference to putting up hard boundaries between projects — namely having to cross repositories and integrate with each others versioned releases.<p>There’s no point hampering yourself with the one-way broadcast mode of communication unless you absolutely have to.  When you have multiple teams one-way broadcasting at each other then, well, maybe it’s time
we sat down for a chat instead?</div><br/></div></div><div id="38527962" class="c"><input type="checkbox" id="c-38527962" checked=""/><div class="controls bullet"><span class="by">hasoleju</span><span>|</span><a href="#38526751">prev</a><span>|</span><a href="#38524169">next</a><span>|</span><label class="collapse" for="c-38527962">[-]</label><label class="expand" for="c-38527962">[2 more]</label></div><br/><div class="children"><div class="content">I experience the problem Pragmatic Versioning is trying to solve. For a commercial software product there are often two root causes to change the &quot;major&quot; number in a software product version.<p>1. There was a breaking change to the API.<p>2. The company wants to signal great new features.<p>With pure Semantic Versioning the second reason can not be used alone. And breaking changes in the API are actually not good news for the users.<p>I think semantic versioning is adopted broadly because great new features often also introduce breaking API changes. So that conflict does not need to be resolved.<p>Pragmatic versioning helps solving this conflict by splitting um the &quot;major&quot; version number into two new ones for breaking changes and great new features.<p>The main advantage Semantic Versioning has is that it is the default. So seeing a version tag with three numbers means Semantic Versioning today.</div><br/><div id="38528257" class="c"><input type="checkbox" id="c-38528257" checked=""/><div class="controls bullet"><span class="by">pyrolistical</span><span>|</span><a href="#38527962">parent</a><span>|</span><a href="#38524169">next</a><span>|</span><label class="collapse" for="c-38528257">[-]</label><label class="expand" for="c-38528257">[1 more]</label></div><br/><div class="children"><div class="content">No need for marketing version and dev version to be the same. Just have a mapping</div><br/></div></div></div></div><div id="38524169" class="c"><input type="checkbox" id="c-38524169" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38527962">prev</a><span>|</span><a href="#38527032">next</a><span>|</span><label class="collapse" for="c-38524169">[-]</label><label class="expand" for="c-38524169">[4 more]</label></div><br/><div class="children"><div class="content">&quot;Democracy is the worst form of government, except all those other forms that have been tried from time to time.&quot; - attributed (but likely not accurately) to Winston Churchill<p>Looks to me like Semantic Versioning is the worst form of versioning except for everything else we&#x27;ve tried.</div><br/><div id="38526086" class="c"><input type="checkbox" id="c-38526086" checked=""/><div class="controls bullet"><span class="by">marcosdumay</span><span>|</span><a href="#38524169">parent</a><span>|</span><a href="#38524579">next</a><span>|</span><label class="collapse" for="c-38526086">[-]</label><label class="expand" for="c-38526086">[2 more]</label></div><br/><div class="children"><div class="content">Hum, no. Semver has lots of problems and many other standards work better. The ones that look like this one on the article tend to fare the best for libraries.</div><br/><div id="38527490" class="c"><input type="checkbox" id="c-38527490" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#38524169">root</a><span>|</span><a href="#38526086">parent</a><span>|</span><a href="#38524579">next</a><span>|</span><label class="collapse" for="c-38527490">[-]</label><label class="expand" for="c-38527490">[1 more]</label></div><br/><div class="children"><div class="content">Which standards work better?</div><br/></div></div></div></div><div id="38524579" class="c"><input type="checkbox" id="c-38524579" checked=""/><div class="controls bullet"><span class="by">vacuity</span><span>|</span><a href="#38524169">parent</a><span>|</span><a href="#38526086">prev</a><span>|</span><a href="#38527032">next</a><span>|</span><label class="collapse" for="c-38524579">[-]</label><label class="expand" for="c-38524579">[1 more]</label></div><br/><div class="children"><div class="content">Perhaps, but a lot of people misuse it. It&#x27;s easy to accidentally get breaking changes when some part of the chain is misused.</div><br/></div></div></div></div><div id="38524697" class="c"><input type="checkbox" id="c-38524697" checked=""/><div class="controls bullet"><span class="by">remram</span><span>|</span><a href="#38527032">prev</a><span>|</span><a href="#38526326">next</a><span>|</span><label class="collapse" for="c-38524697">[-]</label><label class="expand" for="c-38524697">[2 more]</label></div><br/><div class="children"><div class="content">Why not encode further information into the number, if that&#x27;s what you want?<p>1004.0.0 to 1005.0.0 is an api-major business-minor version bump (incompatible API). Semver-compatible.<p>1004.0.0 to 2000.0.0 is an api-major business-major version bump. There, the first number has changed, if that&#x27;s important to you. Semver-compatible.<p>1004.0.0 to 1004.1.0 can be the &quot;INCREMENT&quot; thing they also mention.<p>As a bonus, your version number is soon going to be much higher than competitors. That&#x27;s sure to impress clients. You can refer to the 9000-line easy enough.</div><br/><div id="38524949" class="c"><input type="checkbox" id="c-38524949" checked=""/><div class="controls bullet"><span class="by">cush</span><span>|</span><a href="#38524697">parent</a><span>|</span><a href="#38526326">next</a><span>|</span><label class="collapse" for="c-38524949">[-]</label><label class="expand" for="c-38524949">[1 more]</label></div><br/><div class="children"><div class="content">Needs more bitmasking</div><br/></div></div></div></div><div id="38526326" class="c"><input type="checkbox" id="c-38526326" checked=""/><div class="controls bullet"><span class="by">mattxxx</span><span>|</span><a href="#38524697">prev</a><span>|</span><a href="#38524312">next</a><span>|</span><label class="collapse" for="c-38526326">[-]</label><label class="expand" for="c-38526326">[1 more]</label></div><br/><div class="children"><div class="content">I think &quot;BIGRELEASE&quot; is not accurate representation of how semver is used. I always understood it as something that introduces a non-backwards compatible change in the API.<p>This is so that you can specify ranges of api versions that your program could be built with. For reference, here&#x27;s where I took my understanding:
<a href="https:&#x2F;&#x2F;semver.org&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;semver.org&#x2F;</a></div><br/></div></div><div id="38524312" class="c"><input type="checkbox" id="c-38524312" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38526326">prev</a><span>|</span><a href="#38524227">next</a><span>|</span><label class="collapse" for="c-38524312">[-]</label><label class="expand" for="c-38524312">[1 more]</label></div><br/><div class="children"><div class="content">Versions are a communication tool.<p>There is no best tool for all jobs.<p>Write down your communication objectives and pick a versioning scheme which fulfills them. Want to communicate api compatibility? Use server. Want to communicate a new version worth at least checking out? Bump that major version.</div><br/></div></div><div id="38524227" class="c"><input type="checkbox" id="c-38524227" checked=""/><div class="controls bullet"><span class="by">natbennett</span><span>|</span><a href="#38524312">prev</a><span>|</span><a href="#38525373">next</a><span>|</span><label class="collapse" for="c-38524227">[-]</label><label class="expand" for="c-38524227">[1 more]</label></div><br/><div class="children"><div class="content">This is great. Especially for products that need long term support, which is basically not compatible with semantic versioning. (Since LTS versions occasionally must have security fixes that are also breaking changes backported.)</div><br/></div></div><div id="38525373" class="c"><input type="checkbox" id="c-38525373" checked=""/><div class="controls bullet"><span class="by">riquito</span><span>|</span><a href="#38524227">prev</a><span>|</span><a href="#38525507">next</a><span>|</span><label class="collapse" for="c-38525373">[-]</label><label class="expand" for="c-38525373">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s the old way of versioning things, somewhat formalized.<p>With semver you live in this world where you are promised the versions to follow semantics, but human nature creeps in and we introduce breaking changes (like bugs!) without setting the version correctly.<p>With pragmatic versioning you give expectations but also convey that to upgrade you need to test that your software still works.</div><br/></div></div><div id="38525507" class="c"><input type="checkbox" id="c-38525507" checked=""/><div class="controls bullet"><span class="by">tipiirai</span><span>|</span><a href="#38525373">prev</a><span>|</span><a href="#38525348">next</a><span>|</span><label class="collapse" for="c-38525507">[-]</label><label class="expand" for="c-38525507">[1 more]</label></div><br/><div class="children"><div class="content">I love this! Looks like this would solve a common problem where product managers and marketers are running this &quot;pragmatic&quot; versioning scheme (release, major, minor), and developers are running some other &quot;internal&quot; versioning scheme that is closer to semver (major, minor, patch).<p>Wouldn&#x27;t Pragmatic Versioning work for both?</div><br/></div></div><div id="38525348" class="c"><input type="checkbox" id="c-38525348" checked=""/><div class="controls bullet"><span class="by">jmbwell</span><span>|</span><a href="#38525507">prev</a><span>|</span><a href="#38525465">next</a><span>|</span><label class="collapse" for="c-38525348">[-]</label><label class="expand" for="c-38525348">[2 more]</label></div><br/><div class="children"><div class="content">Seems like where semver focuses slightly more on the state and process of development, this thing focuses slightly more on marketing.<p>For instance, semver increments field values when the state of the API or level of compatibility with previous versions changes, or maybe just when something about the build has changed.<p>This thing appears to aim to express changes in features and functionality. Less about the mechanics of software assembly and more about reasons the vendor would want users to update.<p>It describes issues with semver similarly in terms of marketing, which might explain what seems to be some cognitive disconnect among the different ways people seem to be interpreting both systems. Semver speaks developer language, while this thing seems to speak product manager language.<p>Not sure how it’s differentiated pragmatically, except perhaps for the practical purposes of a specific role in a vendor’s organization.</div><br/><div id="38525914" class="c"><input type="checkbox" id="c-38525914" checked=""/><div class="controls bullet"><span class="by">drewcoo</span><span>|</span><a href="#38525348">parent</a><span>|</span><a href="#38525465">next</a><span>|</span><label class="collapse" for="c-38525914">[-]</label><label class="expand" for="c-38525914">[1 more]</label></div><br/><div class="children"><div class="content">Yes, and maybe that means marketing shouldn&#x27;t be using dev version numbers.<p>Marketing-Driven Development? Yuck.</div><br/></div></div></div></div><div id="38525465" class="c"><input type="checkbox" id="c-38525465" checked=""/><div class="controls bullet"><span class="by">chrisweekly</span><span>|</span><a href="#38525348">prev</a><span>|</span><a href="#38526801">next</a><span>|</span><label class="collapse" for="c-38525465">[-]</label><label class="expand" for="c-38525465">[1 more]</label></div><br/><div class="children"><div class="content">I liked the ideas behind another semver alternative called &quot;imver&quot; or &quot;Immutable Versioning&quot; (<a href="https:&#x2F;&#x2F;github.com&#x2F;imver&#x2F;imver&#x2F;blob&#x2F;master&#x2F;imver.md">https:&#x2F;&#x2F;github.com&#x2F;imver&#x2F;imver&#x2F;blob&#x2F;master&#x2F;imver.md</a>)<p>that never quite caught on. 
It&#x27;s basically just a timestamp. It requires full backwards compatibility of public APIs and behaviors (side effects) for the lifetime of the package. Read about it on an interesting 2019 blog post about monorepos and versioning: 
<a href="https:&#x2F;&#x2F;hub.packtpub.com&#x2F;why-dont-you-have-a-monorepo" rel="nofollow noreferrer">https:&#x2F;&#x2F;hub.packtpub.com&#x2F;why-dont-you-have-a-monorepo</a></div><br/></div></div><div id="38526801" class="c"><input type="checkbox" id="c-38526801" checked=""/><div class="controls bullet"><span class="by">zzo38computer</span><span>|</span><a href="#38525465">prev</a><span>|</span><a href="#38513502">next</a><span>|</span><label class="collapse" for="c-38526801">[-]</label><label class="expand" for="c-38526801">[3 more]</label></div><br/><div class="children"><div class="content">I think that &quot;major.minor&quot; is a useful feature of semantic versioning, that you can specify breaking changes vs non-breaking changes. &quot;Announcement&quot; version numbers may also be useful, although perhaps not as much, it seems to me. However, one thing I think would be useful is numbering of versions of &quot;configuration-safe&quot; upgrades.</div><br/><div id="38527439" class="c"><input type="checkbox" id="c-38527439" checked=""/><div class="controls bullet"><span class="by">seveibar</span><span>|</span><a href="#38526801">parent</a><span>|</span><a href="#38513502">next</a><span>|</span><label class="collapse" for="c-38527439">[-]</label><label class="expand" for="c-38527439">[2 more]</label></div><br/><div class="children"><div class="content">In my original commit I wrote &quot;BIGRELEASE.MAJOR.MINOR&quot; but I realized in practice many packages start to bundle multiple changes into their MAJOR and sometimes even MINOR releases. To me this started to really confuse SemVer, ANNOUNCE&#x2F;INCREMENT is comparatively a bit cleaner&#x2F;more like what they were doing in practice (see the NextJS example)</div><br/><div id="38527761" class="c"><input type="checkbox" id="c-38527761" checked=""/><div class="controls bullet"><span class="by">kijin</span><span>|</span><a href="#38526801">root</a><span>|</span><a href="#38527439">parent</a><span>|</span><a href="#38513502">next</a><span>|</span><label class="collapse" for="c-38527761">[-]</label><label class="expand" for="c-38527761">[1 more]</label></div><br/><div class="children"><div class="content">Whatever you call it, there needs to be some distinction between breaking changes and other changes. It doesn&#x27;t need to be as prominent as the marketing-oriented big release, but it needs to be in there somewhere.<p>Modern software projects have too many dependencies, and too much noise coming from each dependency. Your project is likely just one of hundreds of libraries that got pulled into my dependency graph for some reason. I want to know if, and only if, there&#x27;s a change that I need to be aware of. As for that shiny new feature that you&#x27;re really proud of, I shouldn&#x27;t even notice it unless it breaks an existing API.</div><br/></div></div></div></div></div></div><div id="38513502" class="c"><input type="checkbox" id="c-38513502" checked=""/><div class="controls bullet"><span class="by">seveibar</span><span>|</span><a href="#38526801">prev</a><span>|</span><a href="#38525239">next</a><span>|</span><label class="collapse" for="c-38513502">[-]</label><label class="expand" for="c-38513502">[3 more]</label></div><br/><div class="children"><div class="content">An early draft of an alternate system to semantic versioning (semver) that I think is more useful in practice for both package maintainers (who don&#x27;t want to evaluate every change for meaning, and want to be able to maintain large releases) and package contributors (who want to know what the maintenance period is)<p>Pragmatic versioning reflects more closely what many mature projects do in practice. Feedback welcome!</div><br/><div id="38513519" class="c"><input type="checkbox" id="c-38513519" checked=""/><div class="controls bullet"><span class="by">bensecure</span><span>|</span><a href="#38513502">parent</a><span>|</span><a href="#38525239">next</a><span>|</span><label class="collapse" for="c-38513519">[-]</label><label class="expand" for="c-38513519">[2 more]</label></div><br/><div class="children"><div class="content">It basically just says that version numbers are meaningless and purely marketing. &quot;Pragmatic&quot; yes, but in need of standardization, no. The project comes across almost as a satire, so its odd for you to treat it as serious here.</div><br/><div id="38524195" class="c"><input type="checkbox" id="c-38524195" checked=""/><div class="controls bullet"><span class="by">dbingham</span><span>|</span><a href="#38513502">root</a><span>|</span><a href="#38513519">parent</a><span>|</span><a href="#38525239">next</a><span>|</span><label class="collapse" for="c-38524195">[-]</label><label class="expand" for="c-38524195">[1 more]</label></div><br/><div class="children"><div class="content">Honestly, this is all too often how versions actually get used - that&#x27;s what makes it feel like satire.  But there&#x27;s nothing wrong with admitting that the ideal of Semantic misses the mark, looking at real world usage, and saying &quot;Okay, maybe we should formalize that in some way.&quot;  I can see that being useful, especially if people are able to say &quot;We use PragVersion rather than Semantic&quot; to communicate the reality, rather than saying &quot;We use Semantic&quot; when they are, in fact, using Prag.</div><br/></div></div></div></div></div></div><div id="38525239" class="c"><input type="checkbox" id="c-38525239" checked=""/><div class="controls bullet"><span class="by">yetanother12345</span><span>|</span><a href="#38513502">prev</a><span>|</span><a href="#38525966">next</a><span>|</span><label class="collapse" for="c-38525239">[-]</label><label class="expand" for="c-38525239">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve always been a bit baffled by these types of discussions. Doesn&#x27;t any of you have multiple versioning systems, say &quot;internal&quot; and &quot;external&quot; at the minimum?<p>One project I&#x27;m on has an internal version number of around 28-dot-something-something. This is the number for techies, and it conveys some information that end users are fully ignorant of. End users see &quot;Edition 2&quot; in stead (soon to become 3)</div><br/><div id="38525271" class="c"><input type="checkbox" id="c-38525271" checked=""/><div class="controls bullet"><span class="by">nerdponx</span><span>|</span><a href="#38525239">parent</a><span>|</span><a href="#38525966">next</a><span>|</span><label class="collapse" for="c-38525271">[-]</label><label class="expand" for="c-38525271">[1 more]</label></div><br/><div class="children"><div class="content">SemVer is intended primarily for libraries; techies <i>are</i> the end users.</div><br/></div></div></div></div><div id="38525966" class="c"><input type="checkbox" id="c-38525966" checked=""/><div class="controls bullet"><span class="by">ghshephard</span><span>|</span><a href="#38525239">prev</a><span>|</span><a href="#38513767">next</a><span>|</span><label class="collapse" for="c-38525966">[-]</label><label class="expand" for="c-38525966">[1 more]</label></div><br/><div class="children"><div class="content">A lot of the communications regarding End of Life for Support is done very effectively here:   <a href="https:&#x2F;&#x2F;endoflife.date&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;endoflife.date&#x2F;</a></div><br/></div></div><div id="38513767" class="c"><input type="checkbox" id="c-38513767" checked=""/><div class="controls bullet"><span class="by">m4dc4pXXX</span><span>|</span><a href="#38525966">prev</a><span>|</span><a href="#38527551">next</a><span>|</span><label class="collapse" for="c-38513767">[-]</label><label class="expand" for="c-38513767">[1 more]</label></div><br/><div class="children"><div class="content">Needs examples.</div><br/></div></div><div id="38527551" class="c"><input type="checkbox" id="c-38527551" checked=""/><div class="controls bullet"><span class="by">Pxtl</span><span>|</span><a href="#38513767">prev</a><span>|</span><a href="#38513579">next</a><span>|</span><label class="collapse" for="c-38527551">[-]</label><label class="expand" for="c-38527551">[1 more]</label></div><br/><div class="children"><div class="content">My approach to semver:<p>Breaking.Planned.Hotfix.Publish<p>Breaking is for breaking changes.<p>Planned is for planned changes.<p>HotFix is for emergency unplanned changes.<p>Publish is internal, in the event getting the release out the door took multiple kicks at the build server and you still want to give those distinct builds their own tags.  There&#x27;s a lot of tools that are very opinionated that anything that hits public <i>must</i> have a distinct ID, and sometimes stuff happens and the pipeline doesn&#x27;t go right on the first try.</div><br/></div></div><div id="38513579" class="c"><input type="checkbox" id="c-38513579" checked=""/><div class="controls bullet"><span class="by">catlover76</span><span>|</span><a href="#38527551">prev</a><span>|</span><label class="collapse" for="c-38513579">[-]</label><label class="expand" for="c-38513579">[11 more]</label></div><br/><div class="children"><div class="content">I am surprised more software libraries don&#x27;t simply use date versioning. What is the reason?</div><br/><div id="38528349" class="c"><input type="checkbox" id="c-38528349" checked=""/><div class="controls bullet"><span class="by">nablaone</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38523891">next</a><span>|</span><label class="collapse" for="c-38528349">[-]</label><label class="expand" for="c-38528349">[1 more]</label></div><br/><div class="children"><div class="content">We use YEAR.SPRINT.PATCH scheme, for example 23.10.1. But this is an internal SaaS version.</div><br/></div></div><div id="38523891" class="c"><input type="checkbox" id="c-38523891" checked=""/><div class="controls bullet"><span class="by">deathanatos</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38528349">prev</a><span>|</span><a href="#38524226">next</a><span>|</span><label class="collapse" for="c-38523891">[-]</label><label class="expand" for="c-38523891">[2 more]</label></div><br/><div class="children"><div class="content">It doesn&#x27;t convey useful information like Semver versioning does.<p>(Now, why things that <i>don&#x27;t</i> do Semver don&#x27;t just do DateVer in lieu of that… IDK, really. Marketing likes to take advantage of it? …&amp; then you get stuff like the OP here.)</div><br/><div id="38525434" class="c"><input type="checkbox" id="c-38525434" checked=""/><div class="controls bullet"><span class="by">catdog</span><span>|</span><a href="#38513579">root</a><span>|</span><a href="#38523891">parent</a><span>|</span><a href="#38524226">next</a><span>|</span><label class="collapse" for="c-38525434">[-]</label><label class="expand" for="c-38525434">[1 more]</label></div><br/><div class="children"><div class="content">At lot of projects honestly should just do something simple like date versioning, approximate pi, just increment a single number, ...<p>Especially those which currently use the major.minor.patch format but don&#x27;t care at all about what it usually means, that in itself can be fine but using such a version scheme is then annoyingly misleading.</div><br/></div></div></div></div><div id="38524226" class="c"><input type="checkbox" id="c-38524226" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38523891">prev</a><span>|</span><a href="#38527272">next</a><span>|</span><label class="collapse" for="c-38524226">[-]</label><label class="expand" for="c-38524226">[3 more]</label></div><br/><div class="children"><div class="content">Dates are one dimensional, monotonic, totally non-strictly ordered. There’s no room for branching. Branching is necessary anytime you want to have multiple “latest”s. This is usually major releases with ongoing bugfixes and security updates but minimal breaking changes.<p>What I’ve never seen, but seems useful, is to throw the date on the version number as the third or last number. The nice thing is you get the ordering back. Something like 4.3.20231204</div><br/><div id="38524746" class="c"><input type="checkbox" id="c-38524746" checked=""/><div class="controls bullet"><span class="by">erik_seaberg</span><span>|</span><a href="#38513579">root</a><span>|</span><a href="#38524226">parent</a><span>|</span><a href="#38527272">next</a><span>|</span><label class="collapse" for="c-38524746">[-]</label><label class="expand" for="c-38524746">[2 more]</label></div><br/><div class="children"><div class="content">As I recall, Maven tooling lets you say 4.3-SNAPSHOT and creates 4.3-2023.12.04-23.27. When you release 4.3 it will be considered newer than all the snapshot versions (and other qualified versions like 4.3-beta).</div><br/><div id="38526223" class="c"><input type="checkbox" id="c-38526223" checked=""/><div class="controls bullet"><span class="by">travisjungroth</span><span>|</span><a href="#38513579">root</a><span>|</span><a href="#38524746">parent</a><span>|</span><a href="#38527272">next</a><span>|</span><label class="collapse" for="c-38526223">[-]</label><label class="expand" for="c-38526223">[1 more]</label></div><br/><div class="children"><div class="content">Nice. That makes me realize I’ve seen it as part of nightly builds. Seems like it should just be standard though.</div><br/></div></div></div></div></div></div><div id="38527272" class="c"><input type="checkbox" id="c-38527272" checked=""/><div class="controls bullet"><span class="by">mickael-kerjean</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38524226">prev</a><span>|</span><a href="#38524041">next</a><span>|</span><label class="collapse" for="c-38527272">[-]</label><label class="expand" for="c-38527272">[1 more]</label></div><br/><div class="children"><div class="content">That&#x27;s exactly what I do on my OSS work [1]: MAJOR.date. it works great for my use case (not a lib) but I don&#x27;t count how many discussions I&#x27;ve had with people telling me: &quot;do you know semver? You should use it&quot;<p>[1]: <a href="https:&#x2F;&#x2F;demo.filestash.app&#x2F;about" rel="nofollow noreferrer">https:&#x2F;&#x2F;demo.filestash.app&#x2F;about</a></div><br/></div></div><div id="38524041" class="c"><input type="checkbox" id="c-38524041" checked=""/><div class="controls bullet"><span class="by">mostlylurks</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38527272">prev</a><span>|</span><a href="#38524173">next</a><span>|</span><label class="collapse" for="c-38524041">[-]</label><label class="expand" for="c-38524041">[1 more]</label></div><br/><div class="children"><div class="content">With semantic versioning, it&#x27;s easy to go back and provide a security update (for instance) for an earlier version of a library (which matters if the newer version is API compatible or has different dependencies or a different license or has stopped supporting the platform the user is on). If you try to do the same with date versioning, your versioning suddenly because very misleading and confusing.</div><br/></div></div><div id="38524173" class="c"><input type="checkbox" id="c-38524173" checked=""/><div class="controls bullet"><span class="by">golergka</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38524041">prev</a><span>|</span><a href="#38524038">next</a><span>|</span><label class="collapse" for="c-38524173">[-]</label><label class="expand" for="c-38524173">[1 more]</label></div><br/><div class="children"><div class="content">Because software versioning is non-linear. A security patch to a previous LTS version can be newer than a new version of the software.</div><br/></div></div><div id="38524038" class="c"><input type="checkbox" id="c-38524038" checked=""/><div class="controls bullet"><span class="by">nonameiguess</span><span>|</span><a href="#38513579">parent</a><span>|</span><a href="#38524173">prev</a><span>|</span><label class="collapse" for="c-38524038">[-]</label><label class="expand" for="c-38524038">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;ve made it pretty hard for anything downstream to declare a dependency on a version range. They can depend on a date range, but it&#x27;s not clear what basis there is for picking any particular upper bound other than &quot;last known working version.&quot;</div><br/></div></div></div></div></div></div></div></div></div></body></html>