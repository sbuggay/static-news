<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1693386064689" as="style"/><link rel="stylesheet" href="styles.css?v=1693386064689"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/Ruddle/Fomos">Fomos: Experimental OS, built with Rust</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>sbt567</span> | <span>62 comments</span></div><br/><div><div id="37319250" class="c"><input type="checkbox" id="c-37319250" checked=""/><div class="controls bullet"><span class="by">bluetomcat</span><span>|</span><a href="#37316754">next</a><span>|</span><label class="collapse" for="c-37319250">[-]</label><label class="expand" for="c-37319250">[1 more]</label></div><br/><div class="children"><div class="content">How can you achieve any level of security and safety with un-trusted cooperative apps? Any app can get hold of the CPU for an indefinite amount of time, possibly stalling the kernel and other apps. There&#x27;s a reason we are using OS-es with preemptive scheduling - any misbehaving app can be interrupted without compromising the rest of the system.</div><br/></div></div><div id="37316754" class="c"><input type="checkbox" id="c-37316754" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#37319250">prev</a><span>|</span><a href="#37318746">next</a><span>|</span><label class="collapse" for="c-37316754">[-]</label><label class="expand" for="c-37316754">[16 more]</label></div><br/><div class="children"><div class="content">This is so cool.<p>Particularly enjoyed:<p><pre><code>    In Fomos, an app is really just a function. There is nothing else ! This is a huge claim. An executable for a Unix or Windows OS is extremely complex compared to a freestanding function.
</code></pre>
I can&#x27;t even begin to imagine how cool a kernel would be written this way.<p>Correct me if I&#x27;m wrong, but I think this is how smalltalk&#x2F;squeak works?<p>I hope the author continues with this project. File system, task manager, safe memory stacks, <i>nice</i> resource sharing, ...<p>... and of course, running DOOM as a minimum proof of concept requirement! &#x2F;s.</div><br/><div id="37316987" class="c"><input type="checkbox" id="c-37316987" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#37316754">parent</a><span>|</span><a href="#37318747">next</a><span>|</span><label class="collapse" for="c-37316987">[-]</label><label class="expand" for="c-37316987">[2 more]</label></div><br/><div class="children"><div class="content">&gt;Correct me if I&#x27;m wrong, but I think this is how smalltalk&#x2F;squeak works?<p>In Smalltalk those would be classes&#x27; methods rather than freestanding functions, but yes: all objects within the image directly send messages to each other, i.e. invoke each other&#x27;s methods. Lisp machine operating systems are somewhat closer, since initially they had no object system and used freestanding functions calling each other, though later they became generic functions specialized to their arguments&#x27; classes.</div><br/><div id="37319082" class="c"><input type="checkbox" id="c-37319082" checked=""/><div class="controls bullet"><span class="by">leowbattle</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37316987">parent</a><span>|</span><a href="#37318747">next</a><span>|</span><label class="collapse" for="c-37319082">[-]</label><label class="expand" for="c-37319082">[1 more]</label></div><br/><div class="children"><div class="content">Reminds me of TempleOS, where all programs run in the same address space. Is this the same concept here?</div><br/></div></div></div></div><div id="37318747" class="c"><input type="checkbox" id="c-37318747" checked=""/><div class="controls bullet"><span class="by">progval</span><span>|</span><a href="#37316754">parent</a><span>|</span><a href="#37316987">prev</a><span>|</span><a href="#37316882">next</a><span>|</span><label class="collapse" for="c-37318747">[-]</label><label class="expand" for="c-37318747">[1 more]</label></div><br/><div class="children"><div class="content">This seems to match the definition of a unikernel. Here is another one in Rust: <a href="https:&#x2F;&#x2F;github.com&#x2F;hermit-os&#x2F;hermit-rs">https:&#x2F;&#x2F;github.com&#x2F;hermit-os&#x2F;hermit-rs</a></div><br/></div></div><div id="37316882" class="c"><input type="checkbox" id="c-37316882" checked=""/><div class="controls bullet"><span class="by">nnx</span><span>|</span><a href="#37316754">parent</a><span>|</span><a href="#37318747">prev</a><span>|</span><a href="#37317075">next</a><span>|</span><label class="collapse" for="c-37316882">[-]</label><label class="expand" for="c-37316882">[8 more]</label></div><br/><div class="children"><div class="content">What’s the difference in practice compared to every other OS where app is just a “int main() { … }” function?</div><br/><div id="37317228" class="c"><input type="checkbox" id="c-37317228" checked=""/><div class="controls bullet"><span class="by">jmull</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37316882">parent</a><span>|</span><a href="#37317018">next</a><span>|</span><label class="collapse" for="c-37317228">[-]</label><label class="expand" for="c-37317228">[2 more]</label></div><br/><div class="children"><div class="content">In a regular OS there would be a bunch of implicit things provided by the OS that the app can access, while in this OS those things are explicit in the context.<p>But I don’t think that’s really that significant… you could, e.g., enumerate all the implicit things the OS provides, express them in a structure, and now you’ve got your explicit context. The “fomos” context is only as simple as it is because the OS provides a small number of simple things. Expand those to full OS capabilities and the context will get full OS complex.<p>The odd thing about this “OS” is that a running app is just the start function called repeatedly in a loop. This makes one app call a single coherent slice of app execution. That’s kind of interesting, but makes this pretty limited. E.g., it looks like apps are entirely cooperative. It’s maybe more of a cooperative execution environment.<p>Maybe it would be good for some embedded uses?</div><br/><div id="37317460" class="c"><input type="checkbox" id="c-37317460" checked=""/><div class="controls bullet"><span class="by">lostmsu</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37317228">parent</a><span>|</span><a href="#37317018">next</a><span>|</span><label class="collapse" for="c-37317460">[-]</label><label class="expand" for="c-37317460">[1 more]</label></div><br/><div class="children"><div class="content">Seems similar to Singularity <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Singularity_%28operating_system%29" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Singularity_%28operating_syste...</a></div><br/></div></div></div></div><div id="37317018" class="c"><input type="checkbox" id="c-37317018" checked=""/><div class="controls bullet"><span class="by">ben-schaaf</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37316882">parent</a><span>|</span><a href="#37317228">prev</a><span>|</span><a href="#37316941">next</a><span>|</span><label class="collapse" for="c-37317018">[-]</label><label class="expand" for="c-37317018">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;d suggest reading the linked readme, it does a great job explaining the differences. In other operating systems apps do dynamic linking &amp; syscalls. Those don&#x27;t exist in Fomos.</div><br/></div></div><div id="37316941" class="c"><input type="checkbox" id="c-37316941" checked=""/><div class="controls bullet"><span class="by">mepian</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37316882">parent</a><span>|</span><a href="#37317018">prev</a><span>|</span><a href="#37317075">next</a><span>|</span><label class="collapse" for="c-37316941">[-]</label><label class="expand" for="c-37316941">[4 more]</label></div><br/><div class="children"><div class="content">Make two apps A and B with their respective main() functions. Add some function foo() to app A. Now try to call A&#x27;s foo() from B&#x27;s main(). How many hoops do you need to jump through in every other OS to do this?</div><br/><div id="37317116" class="c"><input type="checkbox" id="c-37317116" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37316941">parent</a><span>|</span><a href="#37317048">next</a><span>|</span><label class="collapse" for="c-37317116">[-]</label><label class="expand" for="c-37317116">[2 more]</label></div><br/><div class="children"><div class="content">None, because this exists outside the scope of an operating system. This is the domain of an executable&#x2F;linkage format and language compiler.</div><br/><div id="37317248" class="c"><input type="checkbox" id="c-37317248" checked=""/><div class="controls bullet"><span class="by">wyldfire</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37317116">parent</a><span>|</span><a href="#37317048">next</a><span>|</span><label class="collapse" for="c-37317248">[-]</label><label class="expand" for="c-37317248">[1 more]</label></div><br/><div class="children"><div class="content">Maybe the complexity lies in that possessive qualifier &quot;A&#x27;s foo()&quot; - if this foo() can manipulate the callee state in some other virtual memory domain then it might not be sufficient to link against it in B&#x27;s application.</div><br/></div></div></div></div><div id="37317048" class="c"><input type="checkbox" id="c-37317048" checked=""/><div class="controls bullet"><span class="by">xcdzvyn</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37316941">parent</a><span>|</span><a href="#37317116">prev</a><span>|</span><a href="#37317075">next</a><span>|</span><label class="collapse" for="c-37317048">[-]</label><label class="expand" for="c-37317048">[1 more]</label></div><br/><div class="children"><div class="content">The amount of (wonderfully) horrible doors this opens is awesome.</div><br/></div></div></div></div></div></div><div id="37317075" class="c"><input type="checkbox" id="c-37317075" checked=""/><div class="controls bullet"><span class="by">shrubble</span><span>|</span><a href="#37316754">parent</a><span>|</span><a href="#37316882">prev</a><span>|</span><a href="#37317204">next</a><span>|</span><label class="collapse" for="c-37317075">[-]</label><label class="expand" for="c-37317075">[2 more]</label></div><br/><div class="children"><div class="content">One thing that appears to me would be that you could still &#x27;pipe&#x27; output from one command to another, BUT the data would not be copied from one part of the pipeline to another.<p>I would imagine it could greatly speed up composable things like that...</div><br/><div id="37317094" class="c"><input type="checkbox" id="c-37317094" checked=""/><div class="controls bullet"><span class="by">keyle</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37317075">parent</a><span>|</span><a href="#37317204">next</a><span>|</span><label class="collapse" for="c-37317094">[-]</label><label class="expand" for="c-37317094">[1 more]</label></div><br/><div class="children"><div class="content">Well it would have to be for memory safety purposes, unless it would specifically be designed to allow siblings application to share the memo... Ugh that would lead to a very unsafe system and that would defeat the purpose of writing safer code in Rust!</div><br/></div></div></div></div><div id="37317204" class="c"><input type="checkbox" id="c-37317204" checked=""/><div class="controls bullet"><span class="by">im_down_w_otp</span><span>|</span><a href="#37316754">parent</a><span>|</span><a href="#37317075">prev</a><span>|</span><a href="#37318746">next</a><span>|</span><label class="collapse" for="c-37317204">[-]</label><label class="expand" for="c-37317204">[2 more]</label></div><br/><div class="children"><div class="content">Run old school classic MacOS.</div><br/><div id="37318914" class="c"><input type="checkbox" id="c-37318914" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#37316754">root</a><span>|</span><a href="#37317204">parent</a><span>|</span><a href="#37318746">next</a><span>|</span><label class="collapse" for="c-37318914">[-]</label><label class="expand" for="c-37318914">[1 more]</label></div><br/><div class="children"><div class="content">Oh, no, you&#x27;re right. That&#x27;s classic MacOS development. It calls you for each event, and you can&#x27;t block. It sucked.</div><br/></div></div></div></div></div></div><div id="37318746" class="c"><input type="checkbox" id="c-37318746" checked=""/><div class="controls bullet"><span class="by">haspok</span><span>|</span><a href="#37316754">prev</a><span>|</span><a href="#37317193">next</a><span>|</span><label class="collapse" for="c-37318746">[-]</label><label class="expand" for="c-37318746">[1 more]</label></div><br/><div class="children"><div class="content">So this is a bit like React on the OS level? Cool project, especially the cooperative scheduling part. Although I&#x27;m not sure why insist on a single function (if not for a &quot;hold my beer&quot; moment), because for any non-trivial program the single function will obviously act as the entry point of a state machine, where the state is stored in the context. I&#x27;m also not sure about redraws - is the window of a program redrawn every time the function runs?</div><br/></div></div><div id="37317193" class="c"><input type="checkbox" id="c-37317193" checked=""/><div class="controls bullet"><span class="by">tayistay</span><span>|</span><a href="#37318746">prev</a><span>|</span><a href="#37317339">next</a><span>|</span><label class="collapse" for="c-37317193">[-]</label><label class="expand" for="c-37317193">[3 more]</label></div><br/><div class="children"><div class="content">&gt; The argument that a cooperative scheduling is doomed to fail is overblown. Apps are already very much cooperative. For proof, run a version of that on your nice preemptive system : [pathological example which creates tons of threads and files]<p>The example is just too contrived. On a preemptive OS, apps typically hang in ways that don&#x27;t turn the whole thing cooperative (thread deadlock, infinite loop, etc.). Also, a  preemptive system could kill an app if it creates too many threads, files, or uses too much RAM, long before it gets effectively cooperative. Our systems are just more permissive.<p>&gt; [Sandboxing] comes free once you accept the premises.<p>and yet<p>&gt; any app can casually check the ram of another app ^^. This is going to be a hard problem to solve.<p>So no, sandboxing doesn&#x27;t come for free.<p>That said, it&#x27;s a cool idea and I wish the author success!</div><br/><div id="37317773" class="c"><input type="checkbox" id="c-37317773" checked=""/><div class="controls bullet"><span class="by">dclowd9901</span><span>|</span><a href="#37317193">parent</a><span>|</span><a href="#37317339">next</a><span>|</span><label class="collapse" for="c-37317773">[-]</label><label class="expand" for="c-37317773">[2 more]</label></div><br/><div class="children"><div class="content">In browser land, all open sites share the memory of the browser heap, and there’s no crosstalk at all. I think the way out of that particular issue is creating a closure around the function (application) that effectively acts like the application’s own context. What if an app could open an app? Or put another way, what if an app could be an OS to another app?</div><br/><div id="37318157" class="c"><input type="checkbox" id="c-37318157" checked=""/><div class="controls bullet"><span class="by">josephg</span><span>|</span><a href="#37317193">root</a><span>|</span><a href="#37317773">parent</a><span>|</span><a href="#37317339">next</a><span>|</span><label class="collapse" for="c-37318157">[-]</label><label class="expand" for="c-37318157">[1 more]</label></div><br/><div class="children"><div class="content">There’s no cross talk because you can’t peek &#x2F; poke arbitrary pointers in javascript. But you can in Rust.<p>And even then, I think modern browsers still isolate each tab in a separate process just to be safe. I don’t think they share memory.</div><br/></div></div></div></div></div></div><div id="37317339" class="c"><input type="checkbox" id="c-37317339" checked=""/><div class="controls bullet"><span class="by">vlovich123</span><span>|</span><a href="#37317193">prev</a><span>|</span><a href="#37317085">next</a><span>|</span><label class="collapse" for="c-37317339">[-]</label><label class="expand" for="c-37317339">[1 more]</label></div><br/><div class="children"><div class="content">&gt; How do you sleep, or wait asynchronously ? Just return;<p>This is a bit strange. I would think async I&#x2F;O in the style of io_uring would be fantastic but this kind of model seems to rule out anything like that. That’ll make it hard to get reasonable perf. It’s also strange to not support async as it’s a natural suspension point to hook into but you would have to give up a lot of the design where your application state has to be explicitly saved &#x2F; loaded via disk if I’m not mistaken. Seems pricy. Hopefully can be extended to support async properly.<p>In a similar vein, I suspect networking may become difficult to do (at least efficiently) for similar reasons but I’m not certain.</div><br/></div></div><div id="37317085" class="c"><input type="checkbox" id="c-37317085" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37317339">prev</a><span>|</span><a href="#37318977">next</a><span>|</span><label class="collapse" for="c-37317085">[-]</label><label class="expand" for="c-37317085">[7 more]</label></div><br/><div class="children"><div class="content">&gt; In Fomos, an app is really just a function. There is nothing else ! This is a huge claim. An executable for a Unix or Windows OS is extremely complex compared to a freestanding function.<p>I&#x27;m curious what Fomos uses as a distinction between &quot;process&quot; and &quot;executable.&quot;<p>On Linux a &quot;process&quot; is the virtual address space (containing the argv&#x2F;envp pointers, stacks, heap, signal masks, file handle table, signal handlers, and executable memory) as with some in-kernel data (uid, gid, etc) that determine what resources it is using and what resources it is allowed to use.<p>An &quot;executable&quot; is a file that contains enough bits for a loader to populate that address space when the execve syscall is performed.<p>One of the distinctions is that you do not need an executable to make a process (eg, you can call clone3 or fork just fine and start mucking with your address space as a new process) and while the kernel uses ELF and much of the userspace uses the RTLD loader from GLIBC you don&#x27;t need to use either of these things to make a process in a given executable format.<p>And finally, a statically linked executable without position independent code is &quot;just a function&quot; in the assembler sense, with just enough metadata to tell the kernel&#x27;s loader that&#x27;s what it is. But without ASLR to actually resolve symbols at runtime, it&#x27;s vulnerable to a lot of buffer overflow attacks if the addresses of dependency functions are known (return to libc is one of those, but it&#x27;s not unique).<p>I&#x27;m the first to point out the flaws in glibc and want an alternative to the Posix model of processes (particularly in the world where the distinction between processes, threads, and fibers is really fuzzy and that is clear even within Linux and Windows at the syscall level), but I&#x27;m curious what is going on in Fomos. Most of the complexity in &quot;executables&quot; in Unix is inherent (resolving symbols at runtime is hard, but also super useful, allowing arbitrary interpreters seems annoying, but is one of the strengths of Linux over Windows and MacOS, providing the kernel interface through stable syscalls is actually the super power of Linux and a dynamic context either through libc or a vtable to do the same thing is not that great, etc).</div><br/><div id="37317159" class="c"><input type="checkbox" id="c-37317159" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37317085">parent</a><span>|</span><a href="#37318485">next</a><span>|</span><label class="collapse" for="c-37317159">[-]</label><label class="expand" for="c-37317159">[4 more]</label></div><br/><div class="children"><div class="content">Thinking about it for a few more minutes, one thing that I think is the great mistake is a homogenization of executable formats (everything on Mac is Mach-O, everything on Windows is PE, everything on Linux is ELF, etc). There&#x27;s no reason we can&#x27;t have a diverse ecosystem of executable&#x2F;linkage formats - and an OS with a dirt simple model for loading in code is a great place for that.</div><br/><div id="37317717" class="c"><input type="checkbox" id="c-37317717" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#37317085">root</a><span>|</span><a href="#37317159">parent</a><span>|</span><a href="#37318485">next</a><span>|</span><label class="collapse" for="c-37317717">[-]</label><label class="expand" for="c-37317717">[3 more]</label></div><br/><div class="children"><div class="content">What would be gained by making more different formats? Also #!&#x2F;bin stuff is executable in sense and the most files in Windows that have default application set.<p>Dirt simple model works until it doesn&#x27;t. Without address space separation there is no safety between executables and cooperative scheduling is the same. Running faulty binary or simply bit flip in ram can crash the whole system instead of just that process.</div><br/><div id="37317895" class="c"><input type="checkbox" id="c-37317895" checked=""/><div class="controls bullet"><span class="by">duped</span><span>|</span><a href="#37317085">root</a><span>|</span><a href="#37317717">parent</a><span>|</span><a href="#37318485">next</a><span>|</span><label class="collapse" for="c-37317895">[-]</label><label class="expand" for="c-37317895">[2 more]</label></div><br/><div class="children"><div class="content">I mean there&#x27;s value in being able to grok it without having read &quot;Linking and Loading&quot; and we don&#x27;t want an Asimov scenario (I can&#x27;t remember if this is Foundation or the Last Question) where we just truck on assuming things work without understanding how they work. And there&#x27;s a lot of arcane knowledge in executable formats buried in mailing lists and aging&#x2F;dying engineers on how and why decisions about these formats were designed.<p>&quot;How does loading work&quot; has a simple answer: you map the executable into virtual memory and jump to the entry point. But the &quot;why does XYZ format do <i>this</i> to achieve that&quot; has a lot of nuance and design decisions - none of which are documented. Particularly things like RTLD, which is designed heavily around the design of glibc and ELF, while the designer of the next generation of AOT or JIT compiled languages for operating systems with capability based models for security might want to understand before they design the executable format and process model that may deviate from POSIX.<p>There&#x27;s space for design and research there, and a platform that makes that easy has a lot of value. While I would encourage the designer of such a platform to read the literature and understand why certain things are done the way they are, it&#x27;s valuable to question if those reasons are still valid and whether or not there&#x27;s a better way.</div><br/><div id="37318843" class="c"><input type="checkbox" id="c-37318843" checked=""/><div class="controls bullet"><span class="by">KineticLensman</span><span>|</span><a href="#37317085">root</a><span>|</span><a href="#37317895">parent</a><span>|</span><a href="#37318485">next</a><span>|</span><label class="collapse" for="c-37318843">[-]</label><label class="expand" for="c-37318843">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I can&#x27;t remember if this is Foundation or the Last Question<p>Foundation. The Galactic Empire makes use of atomic energy and other technologies that were created in the distant past and the technicians can only (sometimes) repair but not create. &#x27;The Last Question&#x27; has a question that remains unanswered throughout human history, which isn&#x27;t quite the same thing.</div><br/></div></div></div></div></div></div></div></div><div id="37318485" class="c"><input type="checkbox" id="c-37318485" checked=""/><div class="controls bullet"><span class="by">dejv</span><span>|</span><a href="#37317085">parent</a><span>|</span><a href="#37317159">prev</a><span>|</span><a href="#37317816">next</a><span>|</span><label class="collapse" for="c-37318485">[-]</label><label class="expand" for="c-37318485">[1 more]</label></div><br/><div class="children"><div class="content">Did you take a look on how Zircon (Fuchsia) is handling this? It is quite interesting.</div><br/></div></div><div id="37317816" class="c"><input type="checkbox" id="c-37317816" checked=""/><div class="controls bullet"><span class="by">dee-bee</span><span>|</span><a href="#37317085">parent</a><span>|</span><a href="#37318485">prev</a><span>|</span><a href="#37318977">next</a><span>|</span><label class="collapse" for="c-37317816">[-]</label><label class="expand" for="c-37317816">[1 more]</label></div><br/><div class="children"><div class="content">&gt; providing the kernel interface through stable syscalls is actually the super power of Linux<p>I thought that it was drivers? Linux isn&#x27;t particularly unique for having a stable abi (and the utility of such a decision is highly questionable). The driver support however is extraordinary and undeniable.</div><br/></div></div></div></div><div id="37318977" class="c"><input type="checkbox" id="c-37318977" checked=""/><div class="controls bullet"><span class="by">tralarpa</span><span>|</span><a href="#37317085">prev</a><span>|</span><a href="#37316763">next</a><span>|</span><label class="collapse" for="c-37318977">[-]</label><label class="expand" for="c-37318977">[4 more]</label></div><br/><div class="children"><div class="content">Is it actually possible to implement security in this OS without a complete redesign and basically redoing what all other existing OS have already done?<p>I am aware of two ways to enforce security for applications running on the same hardware:<p>(1) at runtime. All current platforms do this by isolating processes using virtual memory.<p>(2) at loadtime. The loader verifies that the code does not do arbitrary memory accesses. Usually enforced by only allowing bytecode with a limited instruction set (e.g., no pointer arithmetic) for a virtual machine (JVM, Smalltalk) instead of binaries containing arbitrary machine code.<p>The author of Fomos doesn&#x27;t want context switching, memory isolation, etc. And Rust compilers don&#x27;t produce bytecode. Is there another way?</div><br/><div id="37319204" class="c"><input type="checkbox" id="c-37319204" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#37318977">parent</a><span>|</span><a href="#37319092">next</a><span>|</span><label class="collapse" for="c-37319204">[-]</label><label class="expand" for="c-37319204">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capability-based_addressing" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Capability-based_addressing</a> ?</div><br/></div></div><div id="37319092" class="c"><input type="checkbox" id="c-37319092" checked=""/><div class="controls bullet"><span class="by">lugu</span><span>|</span><a href="#37318977">parent</a><span>|</span><a href="#37319204">prev</a><span>|</span><a href="#37316763">next</a><span>|</span><label class="collapse" for="c-37319092">[-]</label><label class="expand" for="c-37319092">[2 more]</label></div><br/><div class="children"><div class="content">Wild guess: you could have a single address space shared by all &quot;programs&quot; while using virtual memory to restreint visibility on which page is accessible at a certain time. Like, at runtime, resort on a segfault to check some types of security tokens the caller would to check they are allowed to access the page and make the call. No idea how practical this would be.</div><br/><div id="37319141" class="c"><input type="checkbox" id="c-37319141" checked=""/><div class="controls bullet"><span class="by">tralarpa</span><span>|</span><a href="#37318977">root</a><span>|</span><a href="#37319092">parent</a><span>|</span><a href="#37316763">next</a><span>|</span><label class="collapse" for="c-37319141">[-]</label><label class="expand" for="c-37319141">[1 more]</label></div><br/><div class="children"><div class="content">&gt; which page is accessible at a certain time<p>Sounds like a context switch to me :) (at least for the MMU registers)</div><br/></div></div></div></div></div></div><div id="37316763" class="c"><input type="checkbox" id="c-37316763" checked=""/><div class="controls bullet"><span class="by">ilaksh</span><span>|</span><a href="#37318977">prev</a><span>|</span><a href="#37318723">next</a><span>|</span><label class="collapse" for="c-37316763">[-]</label><label class="expand" for="c-37316763">[1 more]</label></div><br/><div class="children"><div class="content">Would be interested to hear the plans for security in more detail.<p>But in general I think these types of experiments show that operating systems could be improved with greenfield designs.<p>Reminds me a tiny bit of Mirage OS. <a href="https:&#x2F;&#x2F;mirage.io&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;mirage.io&#x2F;</a></div><br/></div></div><div id="37318723" class="c"><input type="checkbox" id="c-37318723" checked=""/><div class="controls bullet"><span class="by">doctor_eval</span><span>|</span><a href="#37316763">prev</a><span>|</span><a href="#37317504">next</a><span>|</span><label class="collapse" for="c-37318723">[-]</label><label class="expand" for="c-37318723">[1 more]</label></div><br/><div class="children"><div class="content">I’m terms of cooperative multitasking I suspect this is not the same as what we had in Classic MacOS in the sense that we now have a zillion cores, so presumably one or two non yielding processes don’t actually hold the whole system up.<p>I’d also assume that a function that is misbehaved (doesn’t return) could be terminated if the system runs out of cores.<p>My point is that cooperative multitasking doesn’t necessarily equate to poor performance. Time sharing was originally a way to distribute a huge monolithic CPU among multiple users. Now that single user, multi core CPUs are ubiquitous, it’s past time that we think about other ways to use them.<p>I’m really excited that this project exists.</div><br/></div></div><div id="37317504" class="c"><input type="checkbox" id="c-37317504" checked=""/><div class="controls bullet"><span class="by">nitinreddy88</span><span>|</span><a href="#37318723">prev</a><span>|</span><a href="#37317069">next</a><span>|</span><label class="collapse" for="c-37317504">[-]</label><label class="expand" for="c-37317504">[2 more]</label></div><br/><div class="children"><div class="content">Redox is full fledged OS written in rust by Pop OS developer<p><a href="https:&#x2F;&#x2F;github.com&#x2F;redox-os&#x2F;redox">https:&#x2F;&#x2F;github.com&#x2F;redox-os&#x2F;redox</a></div><br/><div id="37319006" class="c"><input type="checkbox" id="c-37319006" checked=""/><div class="controls bullet"><span class="by">forgotpwd16</span><span>|</span><a href="#37317504">parent</a><span>|</span><a href="#37317069">next</a><span>|</span><label class="collapse" for="c-37319006">[-]</label><label class="expand" for="c-37319006">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s also of another architecture. Bit more conventional although still differs from mainstream systems and having some interesting features.</div><br/></div></div></div></div><div id="37317069" class="c"><input type="checkbox" id="c-37317069" checked=""/><div class="controls bullet"><span class="by">monocasa</span><span>|</span><a href="#37317504">prev</a><span>|</span><a href="#37318626">next</a><span>|</span><label class="collapse" for="c-37317069">[-]</label><label class="expand" for="c-37317069">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not sure you can be an exokernel and cooperatively scheduled.  The only thing an exokernel does enforce multiplextion boundaries on hardware resources.  Yeah, it&#x27;ll be six of one in a lot of IO bound workloads, but IO bound workloads aren&#x27;t the only kind of CPU workloads.<p>And to be fair, exokernels are probably one of the least understood forms of kernel.  I feel like professors&#x2F;textbooks&#x2F;papers are legally required to explain the concept poorly.</div><br/></div></div><div id="37318626" class="c"><input type="checkbox" id="c-37318626" checked=""/><div class="controls bullet"><span class="by">xialvjun</span><span>|</span><a href="#37317069">prev</a><span>|</span><a href="#37317132">next</a><span>|</span><label class="collapse" for="c-37318626">[-]</label><label class="expand" for="c-37318626">[5 more]</label></div><br/><div class="children"><div class="content">So there is no &quot;kernel space and user space&quot;? Then how to protect apps, like prevent bad app read other app&#x27;s user password with pointer calculation.</div><br/><div id="37318807" class="c"><input type="checkbox" id="c-37318807" checked=""/><div class="controls bullet"><span class="by">goombacloud</span><span>|</span><a href="#37318626">parent</a><span>|</span><a href="#37318669">next</a><span>|</span><label class="collapse" for="c-37318807">[-]</label><label class="expand" for="c-37318807">[1 more]</label></div><br/><div class="children"><div class="content">The next logical step would be to only support wasm programs ;)</div><br/></div></div><div id="37318669" class="c"><input type="checkbox" id="c-37318669" checked=""/><div class="controls bullet"><span class="by">rootsu</span><span>|</span><a href="#37318626">parent</a><span>|</span><a href="#37318807">prev</a><span>|</span><a href="#37318677">next</a><span>|</span><label class="collapse" for="c-37318669">[-]</label><label class="expand" for="c-37318669">[2 more]</label></div><br/><div class="children"><div class="content">As per the readme, security is not implemented yet.</div><br/><div id="37318839" class="c"><input type="checkbox" id="c-37318839" checked=""/><div class="controls bullet"><span class="by">kukkamario</span><span>|</span><a href="#37318626">root</a><span>|</span><a href="#37318669">parent</a><span>|</span><a href="#37318677">next</a><span>|</span><label class="collapse" for="c-37318839">[-]</label><label class="expand" for="c-37318839">[1 more]</label></div><br/><div class="children"><div class="content">Well there is also that small issue that implementing security for this design is pretty much impossible without destroying performance and end result is quite standard operating system.<p>Polling style scheduling will just be so slow if calling each executable always involves context switch. And then cooperative scheduling isn&#x27;t really possible if some process doesn&#x27;t play nice.</div><br/></div></div></div></div><div id="37318677" class="c"><input type="checkbox" id="c-37318677" checked=""/><div class="controls bullet"><span class="by">hnben</span><span>|</span><a href="#37318626">parent</a><span>|</span><a href="#37318669">prev</a><span>|</span><a href="#37317132">next</a><span>|</span><label class="collapse" for="c-37318677">[-]</label><label class="expand" for="c-37318677">[1 more]</label></div><br/><div class="children"><div class="content">i guess, that since each app is a function, each app only has access to the parameters it was called with.</div><br/></div></div></div></div><div id="37317132" class="c"><input type="checkbox" id="c-37317132" checked=""/><div class="controls bullet"><span class="by">jonjacky</span><span>|</span><a href="#37318626">prev</a><span>|</span><a href="#37318777">next</a><span>|</span><label class="collapse" for="c-37317132">[-]</label><label class="expand" for="c-37317132">[2 more]</label></div><br/><div class="children"><div class="content">This looks very interesting, but it wasn&#x27;t clear to me how to run this, in particular, how the demo at the top of the README was run.<p>Does this repo build a standalone OS the runs on a bare machine, or does it run in a VM like QEMU, or is it a Rust application program that runs hosted on a conventional OS?</div><br/><div id="37317294" class="c"><input type="checkbox" id="c-37317294" checked=""/><div class="controls bullet"><span class="by">xpe</span><span>|</span><a href="#37317132">parent</a><span>|</span><a href="#37318777">next</a><span>|</span><label class="collapse" for="c-37317294">[-]</label><label class="expand" for="c-37317294">[1 more]</label></div><br/><div class="children"><div class="content">I also do not know. Perhaps worth asking over at <a href="https:&#x2F;&#x2F;github.com&#x2F;Ruddle&#x2F;Fomos&#x2F;issues">https:&#x2F;&#x2F;github.com&#x2F;Ruddle&#x2F;Fomos&#x2F;issues</a></div><br/></div></div></div></div><div id="37318777" class="c"><input type="checkbox" id="c-37318777" checked=""/><div class="controls bullet"><span class="by">sph</span><span>|</span><a href="#37317132">prev</a><span>|</span><a href="#37316931">next</a><span>|</span><label class="collapse" for="c-37318777">[-]</label><label class="expand" for="c-37318777">[1 more]</label></div><br/><div class="children"><div class="content">Finally, someone that tries non-UNIX alternative concepts with their hobby OS...</div><br/></div></div><div id="37316931" class="c"><input type="checkbox" id="c-37316931" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#37318777">prev</a><span>|</span><a href="#37318957">next</a><span>|</span><label class="collapse" for="c-37316931">[-]</label><label class="expand" for="c-37316931">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a cool idea, was just thinking if a program is just a function, can I just replace any function with a malicious code acting as dependency of another function?  Or how would I require a specific function through signature? I guess me as a developer working on Fomos, would have to declare fully qualified dependencies in a manifest and then be able to call by function name my dependencies in my code? But then what about versioning? Do I have to bundle in my app all my dependencies? But cool idea</div><br/><div id="37317209" class="c"><input type="checkbox" id="c-37317209" checked=""/><div class="controls bullet"><span class="by">xpe</span><span>|</span><a href="#37316931">parent</a><span>|</span><a href="#37318957">next</a><span>|</span><label class="collapse" for="c-37317209">[-]</label><label class="expand" for="c-37317209">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not following. How does program-as-a-function matter in this regard? Isn&#x27;t it a question of security and permissions? In most operating systems, compilation, linking, and run-time libraries determine dependencies. (I don&#x27;t know how much of this will differ in something like Fomos.)</div><br/><div id="37317326" class="c"><input type="checkbox" id="c-37317326" checked=""/><div class="controls bullet"><span class="by">lnxg33k1</span><span>|</span><a href="#37316931">root</a><span>|</span><a href="#37317209">parent</a><span>|</span><a href="#37318957">next</a><span>|</span><label class="collapse" for="c-37317326">[-]</label><label class="expand" for="c-37317326">[1 more]</label></div><br/><div class="children"><div class="content">Probably you&#x27;re right, it&#x27;s about the same thing as it is now. I was thinking in this terms: If a program A depends on a function D, this function is another program D, when I run program A, it looks for function D, now normally in compile time I have a full path to dependency, now instead a system has a set of functions running, let&#x27;s say that one of those is function D, how do I ensure as a user that function D is not mimicking something it is not? And I guess it&#x27;s the same of right now, just make sure to don&#x27;t run malicious software, but I was also thinking that probably it could be much harder to track programs as functions reusable from other functions(apps)</div><br/></div></div></div></div></div></div><div id="37318957" class="c"><input type="checkbox" id="c-37318957" checked=""/><div class="controls bullet"><span class="by">EspressoGPT</span><span>|</span><a href="#37316931">prev</a><span>|</span><a href="#37317255">next</a><span>|</span><label class="collapse" for="c-37318957">[-]</label><label class="expand" for="c-37318957">[1 more]</label></div><br/><div class="children"><div class="content">Is it blazingly fast, though?</div><br/></div></div><div id="37317255" class="c"><input type="checkbox" id="c-37317255" checked=""/><div class="controls bullet"><span class="by">xpe</span><span>|</span><a href="#37318957">prev</a><span>|</span><a href="#37317559">next</a><span>|</span><label class="collapse" for="c-37317255">[-]</label><label class="expand" for="c-37317255">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Apps do not need a standard library, any OS functionality is given to the app through the Context.<p>Don&#x27;t <i>need</i> I can follow. But some apps will have dependencies -- some might even be tantamount to a standard library in other OSes. The Context provides all that too?</div><br/></div></div><div id="37317559" class="c"><input type="checkbox" id="c-37317559" checked=""/><div class="controls bullet"><span class="by">NooneAtAll3</span><span>|</span><a href="#37317255">prev</a><span>|</span><a href="#37317714">next</a><span>|</span><label class="collapse" for="c-37317559">[-]</label><label class="expand" for="c-37317559">[3 more]</label></div><br/><div class="children"><div class="content">Can someone explain to me what FB in the Context does?<p>it&#x27;s... an array of pixels?  
does that imply all apps must draw themselves?</div><br/><div id="37318987" class="c"><input type="checkbox" id="c-37318987" checked=""/><div class="controls bullet"><span class="by">Zecc</span><span>|</span><a href="#37317559">parent</a><span>|</span><a href="#37317681">next</a><span>|</span><label class="collapse" for="c-37318987">[-]</label><label class="expand" for="c-37318987">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like it&#x27;s a framebuffer, and yes the apps draw themselves.<p>Looking at the source code of the cursor app [0], we can see it draws the mouse cursor and skips the rest. The transparent console app [1] is doing something more complicated which I haven&#x27;t tried to fully understand, but which definitely involves massaging pixels and even temporarily saves pixel data in ctx.store.b1 and ctx.store.b2 so it looks like some kind of double buffering.<p><pre><code>  [0]: https:&#x2F;&#x2F;github.com&#x2F;Ruddle&#x2F;Fomos&#x2F;blob&#x2F;cba0460af59e63f46c7646f8a2f29d574ff0d722&#x2F;app_cursor&#x2F;src&#x2F;main.rs#L75
  [1]: https:&#x2F;&#x2F;github.com&#x2F;Ruddle&#x2F;Fomos&#x2F;blob&#x2F;cba0460af59e63f46c7646f8a2f29d574ff0d722&#x2F;app_console&#x2F;src&#x2F;main.rs#L384</code></pre></div><br/></div></div><div id="37317681" class="c"><input type="checkbox" id="c-37317681" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37317559">parent</a><span>|</span><a href="#37318987">prev</a><span>|</span><a href="#37317714">next</a><span>|</span><label class="collapse" for="c-37317681">[-]</label><label class="expand" for="c-37317681">[1 more]</label></div><br/><div class="children"><div class="content">or ask other apps to draw for them.</div><br/></div></div></div></div><div id="37317714" class="c"><input type="checkbox" id="c-37317714" checked=""/><div class="controls bullet"><span class="by">j16sdiz</span><span>|</span><a href="#37317559">prev</a><span>|</span><a href="#37318322">next</a><span>|</span><label class="collapse" for="c-37317714">[-]</label><label class="expand" for="c-37317714">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;sandbox&quot; is just some compile time check. 
As soon as you play with raw pointers, everything breaks down.<p>A good experiment, but nothing useful. Maybe the author can generate some new ideas from this.</div><br/></div></div><div id="37318322" class="c"><input type="checkbox" id="c-37318322" checked=""/><div class="controls bullet"><span class="by">cozzyd</span><span>|</span><a href="#37317714">prev</a><span>|</span><a href="#37317480">next</a><span>|</span><label class="collapse" for="c-37318322">[-]</label><label class="expand" for="c-37318322">[1 more]</label></div><br/><div class="children"><div class="content">Fear of missing out system?</div><br/></div></div><div id="37317480" class="c"><input type="checkbox" id="c-37317480" checked=""/><div class="controls bullet"><span class="by">Cloudef</span><span>|</span><a href="#37318322">prev</a><span>|</span><a href="#37316705">next</a><span>|</span><label class="collapse" for="c-37317480">[-]</label><label class="expand" for="c-37317480">[1 more]</label></div><br/><div class="children"><div class="content">Now add DOM and HTML parsing and you&#x27;ll have a web browser</div><br/></div></div></div></div></div></div></div></body></html>