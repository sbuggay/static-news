<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1688029269275" as="style"/><link rel="stylesheet" href="styles.css?v=1688029269275"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.mitchellhanberg.com/the-comprehensive-guide-to-elixirs-for-comprehension/">The Comprehensive Guide to Elixir&#x27;s List Comprehension (2022)</a> <span class="domain">(<a href="https://www.mitchellhanberg.com">www.mitchellhanberg.com</a>)</span></div><div class="subtext"><span>clessg</span> | <span>18 comments</span></div><br/><div><div id="36514960" class="c"><input type="checkbox" id="c-36514960" checked=""/><div class="controls bullet"><span class="by">pawelduda</span><span>|</span><a href="#36516598">next</a><span>|</span><label class="collapse" for="c-36514960">[-]</label><label class="expand" for="c-36514960">[2 more]</label></div><br/><div class="children"><div class="content">I usually avoided comprehensions because they felt like an odd part of Elixir syntax. But more complex nested data transformations can get  verbose and the the article shows the difference in favor of comprehensions that makes me wanna try them more often. I could think of cases where it would make my code leaner and more readable, but not before it clicked for me.<p>Most important part is they&#x27;re expressions so you can mix and match them with function calls<p>Anyway, bookmarking the article because it&#x27;s the best explainer of this feature I recall and will gladly pass it to others :)</div><br/><div id="36516145" class="c"><input type="checkbox" id="c-36516145" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36514960">parent</a><span>|</span><a href="#36516598">next</a><span>|</span><label class="collapse" for="c-36516145">[-]</label><label class="expand" for="c-36516145">[1 more]</label></div><br/><div class="children"><div class="content">It works well in templated text, though.</div><br/></div></div></div></div><div id="36516598" class="c"><input type="checkbox" id="c-36516598" checked=""/><div class="controls bullet"><span class="by">sjtgraham</span><span>|</span><a href="#36514960">prev</a><span>|</span><a href="#36513138">next</a><span>|</span><label class="collapse" for="c-36516598">[-]</label><label class="expand" for="c-36516598">[1 more]</label></div><br/><div class="children"><div class="content">The bitstring example is a really great use case for parsing binary protocols. I&#x27;ve been looking at implementing QUIC in Elixir&#x2F;Erlang and I&#x27;ll be taking a look at this for parsing the packets coming in off the wire.</div><br/></div></div><div id="36513138" class="c"><input type="checkbox" id="c-36513138" checked=""/><div class="controls bullet"><span class="by">sarchertech</span><span>|</span><a href="#36516598">prev</a><span>|</span><a href="#36515534">next</a><span>|</span><label class="collapse" for="c-36513138">[-]</label><label class="expand" for="c-36513138">[9 more]</label></div><br/><div class="children"><div class="content">I love comprehensions as long as they are used in moderation. There’s a tendency for people who just learn them to try to replace every Enum.map.</div><br/><div id="36513251" class="c"><input type="checkbox" id="c-36513251" checked=""/><div class="controls bullet"><span class="by">mhanberg</span><span>|</span><a href="#36513138">parent</a><span>|</span><a href="#36516042">next</a><span>|</span><label class="collapse" for="c-36513251">[-]</label><label class="expand" for="c-36513251">[6 more]</label></div><br/><div class="children"><div class="content">I generally default to a comprehension unless it becomes illegible.<p>Disclaimer: I am the author of the article and am in the pocket of Big Comprehension</div><br/><div id="36514067" class="c"><input type="checkbox" id="c-36514067" checked=""/><div class="controls bullet"><span class="by">freedomben</span><span>|</span><a href="#36513138">root</a><span>|</span><a href="#36513251">parent</a><span>|</span><a href="#36514162">next</a><span>|</span><label class="collapse" for="c-36514067">[-]</label><label class="expand" for="c-36514067">[2 more]</label></div><br/><div class="children"><div class="content">Interesting, I use `map` all the time and `for` rarely.  I&#x27;m not necessarily disagreeing with you as I see this as more of a style preference.<p>The map approach feels a lot more functional to me and is easy to chain.  The `for` method feels a bit awkward.  But that said I much prefer Ruby to Python.  If I had the opposite preference, I&#x27;d probably like the `for` in Elixir more.</div><br/><div id="36514808" class="c"><input type="checkbox" id="c-36514808" checked=""/><div class="controls bullet"><span class="by">square_usual</span><span>|</span><a href="#36513138">root</a><span>|</span><a href="#36514067">parent</a><span>|</span><a href="#36514162">next</a><span>|</span><label class="collapse" for="c-36514808">[-]</label><label class="expand" for="c-36514808">[1 more]</label></div><br/><div class="children"><div class="content">I agree with you: I prefer map and reduce unless I specifically need a comprehension because of multiple input collections. IMO for with many conditions etc. becomes too hard to understand, and you have to keep too many things in mind vs. a filter |&gt; map. Regardless, I don&#x27;t mind its presence, and it definitely has come in handy at times. Yet another reason to enjoy Elixir&#x27;s approach to language design!</div><br/></div></div></div></div><div id="36514162" class="c"><input type="checkbox" id="c-36514162" checked=""/><div class="controls bullet"><span class="by">nickpeterson</span><span>|</span><a href="#36513138">root</a><span>|</span><a href="#36513251">parent</a><span>|</span><a href="#36514067">prev</a><span>|</span><a href="#36516042">next</a><span>|</span><label class="collapse" for="c-36514162">[-]</label><label class="expand" for="c-36514162">[3 more]</label></div><br/><div class="children"><div class="content">I generally just use for loops but I’m in the pocket of Big Ignorance.</div><br/><div id="36515993" class="c"><input type="checkbox" id="c-36515993" checked=""/><div class="controls bullet"><span class="by">PKop</span><span>|</span><a href="#36513138">root</a><span>|</span><a href="#36514162">parent</a><span>|</span><a href="#36516042">next</a><span>|</span><label class="collapse" for="c-36515993">[-]</label><label class="expand" for="c-36515993">[2 more]</label></div><br/><div class="children"><div class="content">Elixir doesn&#x27;t have for loops</div><br/><div id="36517308" class="c"><input type="checkbox" id="c-36517308" checked=""/><div class="controls bullet"><span class="by">arrowsmith</span><span>|</span><a href="#36513138">root</a><span>|</span><a href="#36515993">parent</a><span>|</span><a href="#36516042">next</a><span>|</span><label class="collapse" for="c-36517308">[-]</label><label class="expand" for="c-36517308">[1 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    for x &lt;- 1..10 do
      IO.puts x
    end
</code></pre>
Isn&#x27;t that a for loop?</div><br/></div></div></div></div></div></div></div></div><div id="36516042" class="c"><input type="checkbox" id="c-36516042" checked=""/><div class="controls bullet"><span class="by">manusachi</span><span>|</span><a href="#36513138">parent</a><span>|</span><a href="#36513251">prev</a><span>|</span><a href="#36516915">next</a><span>|</span><label class="collapse" for="c-36516042">[-]</label><label class="expand" for="c-36516042">[1 more]</label></div><br/><div class="children"><div class="content">A real world example of relatively complex filter conditions + flattened transformations simplified with comprehension I usually bring up is: <a href="https:&#x2F;&#x2F;github.com&#x2F;hexpm&#x2F;bob&#x2F;blob&#x2F;177a4354a25cb4f2f2f0349ccdb1a1f5220497ba&#x2F;lib&#x2F;bob&#x2F;job&#x2F;docker_checker.ex#L53-L63">https:&#x2F;&#x2F;github.com&#x2F;hexpm&#x2F;bob&#x2F;blob&#x2F;177a4354a25cb4f2f2f0349ccd...</a></div><br/></div></div><div id="36516915" class="c"><input type="checkbox" id="c-36516915" checked=""/><div class="controls bullet"><span class="by">troupo</span><span>|</span><a href="#36513138">parent</a><span>|</span><a href="#36516042">prev</a><span>|</span><a href="#36515534">next</a><span>|</span><label class="collapse" for="c-36516915">[-]</label><label class="expand" for="c-36516915">[1 more]</label></div><br/><div class="children"><div class="content">Somehow `for` doesn&#x27;t read as comprehension to me. In Erlang I used to use comprehensions extensively. In Elixir I almost never do, and only use Enum.map</div><br/></div></div></div></div><div id="36515534" class="c"><input type="checkbox" id="c-36515534" checked=""/><div class="controls bullet"><span class="by">hlieberman</span><span>|</span><a href="#36513138">prev</a><span>|</span><label class="collapse" for="c-36515534">[-]</label><label class="expand" for="c-36515534">[5 more]</label></div><br/><div class="children"><div class="content">I think comprehensions make a little bit more sense in the Erlang world than in the Elixir one, just because of the more functional style.  Still, I don&#x27;t think there&#x27;s anything wrong with them in Elixir either; just a bit odd in context, like a nice wood-grain-veneer MP3 player.</div><br/><div id="36516164" class="c"><input type="checkbox" id="c-36516164" checked=""/><div class="controls bullet"><span class="by">throwawaymaths</span><span>|</span><a href="#36515534">parent</a><span>|</span><a href="#36515693">next</a><span>|</span><label class="collapse" for="c-36516164">[-]</label><label class="expand" for="c-36516164">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I think comprehensions make a little bit more sense in the Erlang world<p>They make a ton of sense (way more than they do for Erlang) in the context of EEx, which is part of the standard Elixir distribution, and a first class part of the language</div><br/></div></div><div id="36515693" class="c"><input type="checkbox" id="c-36515693" checked=""/><div class="controls bullet"><span class="by">mhanberg</span><span>|</span><a href="#36515534">parent</a><span>|</span><a href="#36516164">prev</a><span>|</span><label class="collapse" for="c-36515693">[-]</label><label class="expand" for="c-36515693">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not really following your comment about &quot;more functional style&quot;.<p>Which are you saying is more functional? And why?</div><br/><div id="36515928" class="c"><input type="checkbox" id="c-36515928" checked=""/><div class="controls bullet"><span class="by">giraffe_lady</span><span>|</span><a href="#36515534">root</a><span>|</span><a href="#36515693">parent</a><span>|</span><label class="collapse" for="c-36515928">[-]</label><label class="expand" for="c-36515928">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not the one you asked but elixir&#x27;s heavy use of piping data through a series of functions is a hallmark of a certain approach to functional programming. It&#x27;s not &quot;more functional&quot; since that doesn&#x27;t really make sense per se, but for a lot of people when they think of FP this is the fundamental orientation they have in mind, rather than like function composition or whatever.<p>Erlang doesn&#x27;t have a first class pipe macro or special form I don&#x27;t think, and its standard library isn&#x27;t built with this in mind, with consistent data-first argument order. So again it&#x27;s not &quot;less functional&quot; but it doesn&#x27;t much use one of the most recognizable idioms of functional programming and the only uniquely functional one many people may be familiar with.<p>I don&#x27;t know if this is what they meant but it makes sense to me. In elixir piping streams is an ergonomic and similarly performant solution, with the tradeoffs discussed in the article. There&#x27;s a lot of use case overlap. If the language didn&#x27;t have comprehensions it wouldn&#x27;t be very painful for most people, I don&#x27;t think. Where erlang without them would be a pain in the ass it really has no other general purpose tool for this.</div><br/><div id="36516095" class="c"><input type="checkbox" id="c-36516095" checked=""/><div class="controls bullet"><span class="by">mhanberg</span><span>|</span><a href="#36515534">root</a><span>|</span><a href="#36515928">parent</a><span>|</span><label class="collapse" for="c-36516095">[-]</label><label class="expand" for="c-36516095">[1 more]</label></div><br/><div class="children"><div class="content">I interpreted their message as saying Erlang is more functional than Elixir, which didn&#x27;t really make sense to me personally. (I think they are both the same amount of &quot;functional&quot;)</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></body></html>