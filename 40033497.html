<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1713171651646" as="style"/><link rel="stylesheet" href="styles.css?v=1713171651646"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://www.ralfj.de/blog/2024/04/14/bubblebox.html">Sandboxing all the things with Flatpak and BubbleBox</a> <span class="domain">(<a href="https://www.ralfj.de">www.ralfj.de</a>)</span></div><div class="subtext"><span>fanf2</span> | <span>77 comments</span></div><br/><div><div id="40034293" class="c"><input type="checkbox" id="c-40034293" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#40037983">next</a><span>|</span><label class="collapse" for="c-40034293">[-]</label><label class="expand" for="c-40034293">[2 more]</label></div><br/><div class="children"><div class="content">Cannot mention sandboxing flatpak without mentioning FlatSeal[0]. Offers a super convenient GUI to set per app configurations.<p>[0] <a href="https:&#x2F;&#x2F;flathub.org&#x2F;apps&#x2F;com.github.tchx84.Flatseal" rel="nofollow">https:&#x2F;&#x2F;flathub.org&#x2F;apps&#x2F;com.github.tchx84.Flatseal</a></div><br/><div id="40036502" class="c"><input type="checkbox" id="c-40036502" checked=""/><div class="controls bullet"><span class="by">Timber-6539</span><span>|</span><a href="#40034293">parent</a><span>|</span><a href="#40037983">next</a><span>|</span><label class="collapse" for="c-40036502">[-]</label><label class="expand" for="c-40036502">[1 more]</label></div><br/><div class="children"><div class="content">Flatseal is awesome. Don&#x27;t know if I would be using Flatpak&#x27;s sandboxing feature (or even Flatpaks at all!) without it.</div><br/></div></div></div></div><div id="40037983" class="c"><input type="checkbox" id="c-40037983" checked=""/><div class="controls bullet"><span class="by">slooonz</span><span>|</span><a href="#40034293">prev</a><span>|</span><a href="#40033903">next</a><span>|</span><label class="collapse" for="c-40037983">[-]</label><label class="expand" for="c-40037983">[1 more]</label></div><br/><div class="children"><div class="content">Shameless self-plug : <a href="https:&#x2F;&#x2F;sloonz.github.io&#x2F;posts&#x2F;sandboxing-1&#x2F;" rel="nofollow">https:&#x2F;&#x2F;sloonz.github.io&#x2F;posts&#x2F;sandboxing-1&#x2F;</a><p>Which you can see it as the longer form documentation of bubblebox (explaining in excruciating details how to sandbox desktop applications with flatpak).<p>(not affiliated to the author, written prior to bubblebox — but I’m happy to see that someone took up the job of making a true solution of implementing the ideas I laid out in my blog posts series !)</div><br/></div></div><div id="40033903" class="c"><input type="checkbox" id="c-40033903" checked=""/><div class="controls bullet"><span class="by">boustrophedon</span><span>|</span><a href="#40037983">prev</a><span>|</span><a href="#40035888">next</a><span>|</span><label class="collapse" for="c-40033903">[-]</label><label class="expand" for="c-40033903">[1 more]</label></div><br/><div class="children"><div class="content">Since the author mentioned rewriting it in Rust, I recently added support to my library extrasafe that allows you to sandbox <i>your own</i> code: <a href="https:&#x2F;&#x2F;harrystern.net&#x2F;extrasafe-user-namespaces.html" rel="nofollow">https:&#x2F;&#x2F;harrystern.net&#x2F;extrasafe-user-namespaces.html</a><p>So if you wanted to call ffmpeg or some other C library with complicated user-provided data, you can use extrasafe&#x27;s Isolates (along with its seccomp and Landlock features) to sandbox the call. I&#x27;m not really sure how suited it is for rewriting something like bubblewrap or firejail, but it might be interesting to try.</div><br/></div></div><div id="40035888" class="c"><input type="checkbox" id="c-40035888" checked=""/><div class="controls bullet"><span class="by">rustcleaner</span><span>|</span><a href="#40033903">prev</a><span>|</span><a href="#40037830">next</a><span>|</span><label class="collapse" for="c-40035888">[-]</label><label class="expand" for="c-40035888">[10 more]</label></div><br/><div class="children"><div class="content">Just wanted to add, though obliquely relevant to the OP, I have daily driven Qubes OS 4.1 for at least 12 months now and have been thoroughly impressed.  It actually makes me feel safe[r] in my online computing today.  8chan or Discord -delivered 0-day blowing up in one of the respective qubes should not lead to exfiltration of my Robinhood credentials, my aunt&#x27;s baking recipes, or my super secret hacker darknet forum libressl key.  :^)<p>You want a beefy system.  If you want to pass GPUs through, you need more than one in the system.  CPU core count is important yes, but I cannot emphasize enough: RAM RAM RAM.  Yes I do have automatic1111 running with GPU in my Qubes tower.  Yes I can spin up a WinServ2022 Datacenter qube for Siemens NX 10, with full GPU support.</div><br/><div id="40037561" class="c"><input type="checkbox" id="c-40037561" checked=""/><div class="controls bullet"><span class="by">tholdem</span><span>|</span><a href="#40035888">parent</a><span>|</span><a href="#40036934">next</a><span>|</span><label class="collapse" for="c-40037561">[-]</label><label class="expand" for="c-40037561">[3 more]</label></div><br/><div class="children"><div class="content">One thing that steered me away from QubesOS was that the templates used for all VMs were not hardened at all, instead, the Qubes Fedora template for example were less secure than a normal Fedora install. The template uses passwordless sudo and SELinux is completely removed. Security is about layers and the default templates are lacking in that sense. I want to make initial compromise as hard as possible. For QubesOS reasoning for not needing hardened templates to make sense, I would need to have a completely separate AppVM for each application and I don&#x27;t think QubesOS was meant to be used like that.</div><br/><div id="40037780" class="c"><input type="checkbox" id="c-40037780" checked=""/><div class="controls bullet"><span class="by">minitech</span><span>|</span><a href="#40035888">root</a><span>|</span><a href="#40037561">parent</a><span>|</span><a href="#40038175">next</a><span>|</span><label class="collapse" for="c-40037780">[-]</label><label class="expand" for="c-40037780">[1 more]</label></div><br/><div class="children"><div class="content">(SELinux is enabled as of Fedora 39.)<p>&gt; I would need to have a completely separate AppVM for each application and I don&#x27;t think QubesOS was meant to be used like that.<p>I think that’s a decent starting point, actually. Not only that, but also separate disposable VMs for individual tasks, like reading a PDF.</div><br/></div></div><div id="40038175" class="c"><input type="checkbox" id="c-40038175" checked=""/><div class="controls bullet"><span class="by">fsflover</span><span>|</span><a href="#40035888">root</a><span>|</span><a href="#40037561">parent</a><span>|</span><a href="#40037780">prev</a><span>|</span><a href="#40036934">next</a><span>|</span><label class="collapse" for="c-40038175">[-]</label><label class="expand" for="c-40038175">[1 more]</label></div><br/><div class="children"><div class="content">&gt; The template uses passwordless sudo<p>This is easy to change:<p><a href="https:&#x2F;&#x2F;www.qubes-os.org&#x2F;doc&#x2F;vm-sudo&#x2F;#replacing-passwordless-root-access-with-dom0-user-prompt" rel="nofollow">https:&#x2F;&#x2F;www.qubes-os.org&#x2F;doc&#x2F;vm-sudo&#x2F;#replacing-passwordless...</a><p>and<p><a href="https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;replacing-passwordless-root-with-a-dom0-prompt&#x2F;19074&#x2F;18" rel="nofollow">https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;replacing-passwordless-root-wit...</a><p>See also: <a href="https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;passwordless-sudo-selinux-understanding-security-logic&#x2F;22446&#x2F;2" rel="nofollow">https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;passwordless-sudo-selinux-under...</a><p>Although I&#x27;m convinced that passwordless sudo helps a lot to make life easier for new Qubes users.<p>&gt; For QubesOS reasoning for not needing hardened templates to make sense, I would need to have a completely separate AppVM for each application and I don&#x27;t think QubesOS was meant to be used like that.<p>This is not necessary. You can group your apps with the same trust level in the same VM. Again, it&#x27;s especially helpful to the new users. Advanced users like you, with strict threat models, can use minimal VMs to compartmentalize much more.</div><br/></div></div></div></div><div id="40036934" class="c"><input type="checkbox" id="c-40036934" checked=""/><div class="controls bullet"><span class="by">fbdab103</span><span>|</span><a href="#40035888">parent</a><span>|</span><a href="#40037561">prev</a><span>|</span><a href="#40037059">next</a><span>|</span><label class="collapse" for="c-40036934">[-]</label><label class="expand" for="c-40036934">[4 more]</label></div><br/><div class="children"><div class="content">I am this close to rebuilding my machine in Qubes. Is 32GB enough RAM or am I going to be seeing usability issues?<p>The proliferation of AI tools really wants me to grab more of this wild-west code, but obvious security concerns there. Am I going to take a huge hit in performance if I am running this stuff in a virtual machine like llamafile which runs on the CPU?<p>Secondary GPU for pass through is less appealing, but I suppose I can stomach it. Is there a good guide on how you configured this? Many moons ago, before Proton was so good, I had looked into doing GPU pass through, but quickly gave up on the technical complexity.<p>Anything else notable? Problems getting web cams or microphones working? I assume you cannot screen share across Qubes.</div><br/><div id="40038093" class="c"><input type="checkbox" id="c-40038093" checked=""/><div class="controls bullet"><span class="by">fsflover</span><span>|</span><a href="#40035888">root</a><span>|</span><a href="#40036934">parent</a><span>|</span><a href="#40037692">next</a><span>|</span><label class="collapse" for="c-40038093">[-]</label><label class="expand" for="c-40038093">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Is 32GB enough RAM or am I going to be seeing usability issues?<p>It should be sufficient for quite some time, until you run 15+ VMs simultaneously or so. I reach this limit only when I open too many https links each in its own VM.<p>&gt; Am I going to take a huge hit in performance if I am running this stuff in a virtual machine like llamafile which runs on the CPU?<p>Anything relying on GPU gets significantly slower on Qubes (without the passthrough); ordinary apps relying in CPU are fast  though.<p>&gt; I assume you cannot screen share across Qubes.<p>You can: <a href="https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;while-video-streaming-google-meet-e-g-how-to-share-the-screen-of-a-different-qube-or-perhaps-hvm&#x2F;24782" rel="nofollow">https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;while-video-streaming-google-me...</a><p>&gt; Secondary GPU for pass through is less appealing, but I suppose I can stomach it. Is there a good guide on how you configured this?<p><a href="https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;create-a-gaming-hvm&#x2F;19000" rel="nofollow">https:&#x2F;&#x2F;forum.qubes-os.org&#x2F;t&#x2F;create-a-gaming-hvm&#x2F;19000</a><p>&gt; Problems getting web cams or microphones working?<p>These work reliable for me.</div><br/></div></div><div id="40037692" class="c"><input type="checkbox" id="c-40037692" checked=""/><div class="controls bullet"><span class="by">Dalewyn</span><span>|</span><a href="#40035888">root</a><span>|</span><a href="#40036934">parent</a><span>|</span><a href="#40038093">prev</a><span>|</span><a href="#40037507">next</a><span>|</span><label class="collapse" for="c-40037692">[-]</label><label class="expand" for="c-40037692">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Secondary GPU for pass through is less appealing, but I suppose I can stomach it.<p>Anyone using an Intel CPU from the past ~13 years or an AMD APU or Zen 4 CPU <i>should</i> have an iGPU to render the host with, unless they specifically opted out, leaving the GPU free for passthroughing.</div><br/></div></div><div id="40037507" class="c"><input type="checkbox" id="c-40037507" checked=""/><div class="controls bullet"><span class="by">damsalor</span><span>|</span><a href="#40035888">root</a><span>|</span><a href="#40036934">parent</a><span>|</span><a href="#40037692">prev</a><span>|</span><a href="#40037059">next</a><span>|</span><label class="collapse" for="c-40037507">[-]</label><label class="expand" for="c-40037507">[1 more]</label></div><br/><div class="children"><div class="content">Screen sharing works across the planet nowadays</div><br/></div></div></div></div><div id="40037059" class="c"><input type="checkbox" id="c-40037059" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40035888">parent</a><span>|</span><a href="#40036934">prev</a><span>|</span><a href="#40037830">next</a><span>|</span><label class="collapse" for="c-40037059">[-]</label><label class="expand" for="c-40037059">[2 more]</label></div><br/><div class="children"><div class="content">Wouldn&#x27;t passing through GPUs automatically provide enough information to tie all your VMs together? Unless someone has found a way to make GPUs pretend to be common consumer GPUs and not report any individualized fingerprints, then I would think that any online service that has GPU access can easily fingerprint you. Plus, in my experience VMs also tend to report a lot of system information that makes it apparent what hypervisor and virtual devices you are using.<p>Sure, each VM may be isolated in the sense that they each have their own apps and isolated file systems... but that is exactly what sandboxing does, except without the overhead of complete virtualization at each layer. I&#x27;d guess that Windows Sandbox would provide the same security in a much more efficient manner. On Linux, the integrated sandboxing solutions should also provide isolation like a VM but with better performance.<p>I understand Qubes design decision, but honestly think it is a bit antiquated and cumbersome when in reality you don&#x27;t gain much compared to other solutions.</div><br/><div id="40037905" class="c"><input type="checkbox" id="c-40037905" checked=""/><div class="controls bullet"><span class="by">fransje26</span><span>|</span><a href="#40035888">root</a><span>|</span><a href="#40037059">parent</a><span>|</span><a href="#40037830">next</a><span>|</span><label class="collapse" for="c-40037905">[-]</label><label class="expand" for="c-40037905">[1 more]</label></div><br/><div class="children"><div class="content">&gt; bit antiquated and cumbersome when in reality you don&#x27;t gain much compared to other solutions.<p>What would be other&#x2F;better solutions that can be used for the same goal?</div><br/></div></div></div></div></div></div><div id="40037830" class="c"><input type="checkbox" id="c-40037830" checked=""/><div class="controls bullet"><span class="by">chme</span><span>|</span><a href="#40035888">prev</a><span>|</span><a href="#40035158">next</a><span>|</span><label class="collapse" for="c-40037830">[-]</label><label class="expand" for="c-40037830">[9 more]</label></div><br/><div class="children"><div class="content">I would love to see a Linux distribution picking up on the concept of NixOS, with its content-addressed-package store and then use overlayfs and bubblewrap to create process local FHS compatible root file systems with only the dependencies of each process inside.</div><br/><div id="40037994" class="c"><input type="checkbox" id="c-40037994" checked=""/><div class="controls bullet"><span class="by">sham1</span><span>|</span><a href="#40037830">parent</a><span>|</span><a href="#40038035">next</a><span>|</span><label class="collapse" for="c-40037994">[-]</label><label class="expand" for="c-40037994">[4 more]</label></div><br/><div class="children"><div class="content">Well, both Guix System and NixOS can do this, where they construct a containerised environment with FHS layout. IIRC neither uses overlayfs and they do the namespaces by themselves instead of relying on Bubblewrap, but inside the container you get exactly what you&#x27;d expect.<p>At least in Guix it&#x27;s `guix shell -CF`, where `-C` is of course the `--container` flag, and `-F` for `--emulate-fhs`. I&#x27;d imagine that `nix-shell` works the same way, but I&#x27;m more familiar with guix than nix, so I can only speak for that.</div><br/><div id="40038043" class="c"><input type="checkbox" id="c-40038043" checked=""/><div class="controls bullet"><span class="by">chme</span><span>|</span><a href="#40037830">root</a><span>|</span><a href="#40037994">parent</a><span>|</span><a href="#40038035">next</a><span>|</span><label class="collapse" for="c-40038043">[-]</label><label class="expand" for="c-40038043">[3 more]</label></div><br/><div class="children"><div class="content">I only ever tried NixOS, but the FHS stuff there seems to only be about getting Steam and other proprietary software to work. I would suggest to have this per default, so that the only application that actually sees the real file system would be PID1.</div><br/><div id="40038095" class="c"><input type="checkbox" id="c-40038095" checked=""/><div class="controls bullet"><span class="by">sham1</span><span>|</span><a href="#40037830">root</a><span>|</span><a href="#40038043">parent</a><span>|</span><a href="#40038035">next</a><span>|</span><label class="collapse" for="c-40038095">[-]</label><label class="expand" for="c-40038095">[2 more]</label></div><br/><div class="children"><div class="content">That is an interesting idea, but I don&#x27;t really see what the purpose would really be.<p>As you said, having these kinds of FHS containers really is only actually useful for proprietary software, with free software being adaptable for a &quot;non-standard&quot; filesystem. Of course, it&#x27;s sometimes helpful to do this even for free software, which is of course why this is an option, but I do struggle to see what would be the idea with making it the default for all non-PID1 apps in such a system.<p>All I could really reckon is that it might be easier for user familiarity, but at least in my experience, one gets used to the new layout pretty quickly. You&#x27;d ideally be configuring the whole system in either Nix language or Scheme anyway, so things like `&#x2F;etc` are a bit superfluous, and since you can get `&#x2F;bin&#x2F;sh` and `&#x2F;usr&#x2F;bin&#x2F;env` symlinked for things that expect it, most things should work anyway. Well, unless done poorly, but nothing one couldn&#x27;t patch.</div><br/><div id="40038139" class="c"><input type="checkbox" id="c-40038139" checked=""/><div class="controls bullet"><span class="by">chme</span><span>|</span><a href="#40037830">root</a><span>|</span><a href="#40038095">parent</a><span>|</span><a href="#40038035">next</a><span>|</span><label class="collapse" for="c-40038139">[-]</label><label class="expand" for="c-40038139">[1 more]</label></div><br/><div class="children"><div class="content">In NixOS you have only one central package store `&#x2F;nix&#x2F;store`, so all packages need to be installed there. This is necessary, because the software is patched to use that path. IMO patching it this way is a bit hacky, when there a better options.<p>If overlayfs is used, the software would not require patching, so you could have multiple package stores if you like. Maybe a package store in `~&#x2F;.nix&#x2F;store` as well. This would allow with a immutable rootfs (e.g. immutable `&#x2F;nix&#x2F;store`) to still install packages per user, or even per project a different package store.</div><br/></div></div></div></div></div></div></div></div><div id="40038035" class="c"><input type="checkbox" id="c-40038035" checked=""/><div class="controls bullet"><span class="by">INTPenis</span><span>|</span><a href="#40037830">parent</a><span>|</span><a href="#40037994">prev</a><span>|</span><a href="#40037869">next</a><span>|</span><label class="collapse" for="c-40038035">[-]</label><label class="expand" for="c-40038035">[2 more]</label></div><br/><div class="children"><div class="content">I understood some of those words.<p>But I&#x27;ve been using Atomic Fedora for the last 2 years and my whole work flow has shifted to using containers for everything CLI, I can have specific container images for work on qemu images, or terraform for example. And everything else like Steam games, VLC, Firefox all run in Flatpaks.<p>So the end goal is to not make any modifications to the host image.</div><br/><div id="40038123" class="c"><input type="checkbox" id="c-40038123" checked=""/><div class="controls bullet"><span class="by">chme</span><span>|</span><a href="#40037830">root</a><span>|</span><a href="#40038035">parent</a><span>|</span><a href="#40037869">next</a><span>|</span><label class="collapse" for="c-40038123">[-]</label><label class="expand" for="c-40038123">[1 more]</label></div><br/><div class="children"><div class="content">&gt; So the end goal is to not make any modifications to the host image.<p>IMO the goal should not be to have a immutable host image, but to have a immutable rootfs of each process. Immutable host base images might contain libraries or software that is not required by the application, they are more difficult to update, because they need to be updated as a unit, and probably require a reboot.<p>To make this stable, you need to hack around with A&#x2F;B partitions for a fallback. IMO this would not be necessary if we had every package just installed under its checksum under `&#x2F;pkgs` or what ever, an then use overlayfs to create a file system customized for every process. All that is required here to revert back is the old &#x27;profile&#x27; and then start the old packages from the `&#x2F;pkgs`. Like NixOS does it.<p>However NixOS doesn&#x27;t use overlayfs, they use symlinks and patching of the paths in the sources to archive it.<p>Using overlayfs would also allow changing the package path (`&#x2F;pkgs` here, or nixos package store `&#x2F;nix&#x2F;store`) at runtime, because the software would not require patches, so people could install an additional store in their home directory for instance.</div><br/></div></div></div></div><div id="40037869" class="c"><input type="checkbox" id="c-40037869" checked=""/><div class="controls bullet"><span class="by">bjackman</span><span>|</span><a href="#40037830">parent</a><span>|</span><a href="#40038035">prev</a><span>|</span><a href="#40035158">next</a><span>|</span><label class="collapse" for="c-40037869">[-]</label><label class="expand" for="c-40037869">[2 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t do the special package manager thing but aside from that I think the &quot;immutable distros&quot; like Fedora Silverblue are in this vein no?</div><br/><div id="40038026" class="c"><input type="checkbox" id="c-40038026" checked=""/><div class="controls bullet"><span class="by">chme</span><span>|</span><a href="#40037830">root</a><span>|</span><a href="#40037869">parent</a><span>|</span><a href="#40035158">next</a><span>|</span><label class="collapse" for="c-40038026">[-]</label><label class="expand" for="c-40038026">[1 more]</label></div><br/><div class="children"><div class="content">I would consider Fedora Silverblue&#x2F;CoreOS, NixOS and even flatpak as a sort of hacky way to implement that. I don&#x27;t know of any PoC for this. I would guess that there might be some research budget available for that approach.</div><br/></div></div></div></div></div></div><div id="40035158" class="c"><input type="checkbox" id="c-40035158" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#40037830">prev</a><span>|</span><a href="#40034347">next</a><span>|</span><label class="collapse" for="c-40035158">[-]</label><label class="expand" for="c-40035158">[24 more]</label></div><br/><div class="children"><div class="content">I like bwrap, but I dislike Flatpak because it leads to obscure dependency management.<p>AFAIK, in a scenario similar to the xz hack, it is hard to verify whether all apps are running compromised &#x2F; patched versions of xz and dependencies.<p>In contrast, regular package managers solve this problem pretty well.<p>Therefore, I want bwrap or similar sandboxing + Nix &#x2F; Guix.</div><br/><div id="40035218" class="c"><input type="checkbox" id="c-40035218" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40035158">parent</a><span>|</span><a href="#40035389">next</a><span>|</span><label class="collapse" for="c-40035218">[-]</label><label class="expand" for="c-40035218">[14 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; In contrast, regular package managers solve this problem pretty well.<p>Except the upstream dev&#x27;s are sick of dealing with &quot;It doesn&#x27;t work in my distro&quot; ... there are plenty of instances of these sorts of pissing matches.<p>bwrap, flatpack, containers... were really talking about software distribution. I dont think any of these solutions &quot;solve&quot; the problem, we&#x27;re just putting all the bullshit in one bag, not getting rid of it.</div><br/><div id="40035459" class="c"><input type="checkbox" id="c-40035459" checked=""/><div class="controls bullet"><span class="by">p9fus</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035218">parent</a><span>|</span><a href="#40035315">next</a><span>|</span><label class="collapse" for="c-40035459">[-]</label><label class="expand" for="c-40035459">[2 more]</label></div><br/><div class="children"><div class="content">&gt; bwrap, flatpack, containers... were really talking about software distribution. I dont think any of these solutions &quot;solve&quot; the problem, we&#x27;re just putting all the bullshit in one bag, not getting rid of it.<p>I agree, personally I prefer flatpaks more often then not because they &quot;just work&quot; for most programs I use (that aren&#x27;t on the terminal) but Its far from an elegant solution, still, I do generally like a lot of the work their doing like the various xdg-desktop-portal permissions that are standardising a lot of common &quot;desktop&quot; interactions</div><br/><div id="40037518" class="c"><input type="checkbox" id="c-40037518" checked=""/><div class="controls bullet"><span class="by">tracker1</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035459">parent</a><span>|</span><a href="#40035315">next</a><span>|</span><label class="collapse" for="c-40037518">[-]</label><label class="expand" for="c-40037518">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m with you on this.  Even if I can dig into issues that come up and have, if just rather but most of the time.  Not to mention that flatpak, AppImage and docker leave my Host pretty unscathed and allow updates to go much more reliably.</div><br/></div></div></div></div><div id="40035315" class="c"><input type="checkbox" id="c-40035315" checked=""/><div class="controls bullet"><span class="by">hx8</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035218">parent</a><span>|</span><a href="#40035459">prev</a><span>|</span><a href="#40036924">next</a><span>|</span><label class="collapse" for="c-40035315">[-]</label><label class="expand" for="c-40035315">[9 more]</label></div><br/><div class="children"><div class="content">&gt; Except the upstream dev&#x27;s are sick of dealing with &quot;It doesn&#x27;t work in my distro&quot;<p>99&#x2F;100 it does work on their distro, they just need to handle their libraries better.  Identify the packages they need to support the software, or if no packages exist then they need to compile the libraries themselves. The entire point of Linux distributions is to do this job for the user.  Sometimes the distro will fall short, so you need to have the basic understanding to handle it yourself.<p>Of course, Linux users aren&#x27;t as tech savvy as they were 20 years ago.</div><br/><div id="40036250" class="c"><input type="checkbox" id="c-40036250" checked=""/><div class="controls bullet"><span class="by">zer00eyz</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035315">parent</a><span>|</span><a href="#40035417">next</a><span>|</span><label class="collapse" for="c-40036250">[-]</label><label class="expand" for="c-40036250">[1 more]</label></div><br/><div class="children"><div class="content">&gt;&gt; The entire point of Linux distributions is to do this job for the user.<p>You would think, but we have some fair conflicts between distros and upstream software.<p>Bottles is throwing the gauntlets down and said &quot;we dont care about your bug if your NOT using the flat pack, if you got it from your distro its your distorts bug&quot;. A lot of other bits of software are moving this way because they just dont have the bandwidth to support the disros&#x27; nonsense (in their eyes)<p>Some software maintainers are looking at flatpack as a way to right size the effort in supporting users.</div><br/></div></div><div id="40035417" class="c"><input type="checkbox" id="c-40035417" checked=""/><div class="controls bullet"><span class="by">akdev1l</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035315">parent</a><span>|</span><a href="#40036250">prev</a><span>|</span><a href="#40036924">next</a><span>|</span><label class="collapse" for="c-40035417">[-]</label><label class="expand" for="c-40035417">[7 more]</label></div><br/><div class="children"><div class="content">&gt; so you need to have the basic understanding to handle it yourself<p>No they don’t. This idea that people need to become System Administrators to use Linux really needs to die.</div><br/><div id="40035677" class="c"><input type="checkbox" id="c-40035677" checked=""/><div class="controls bullet"><span class="by">nextos</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035417">parent</a><span>|</span><a href="#40035876">next</a><span>|</span><label class="collapse" for="c-40035677">[-]</label><label class="expand" for="c-40035677">[3 more]</label></div><br/><div class="children"><div class="content">You are bringing up a valid problem, but I think this needs to be fixed at UI level.<p>There are GUIs getting developed for e.g. NixOS that lower the barrier to use the OS pretty dramatically.<p>I agree things need to be simpler, but it would be nice to keep the capability to generate a bill of materials for each package.<p>IMHO, Flatpak is a regression in some of these aspects.</div><br/><div id="40036894" class="c"><input type="checkbox" id="c-40036894" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035677">parent</a><span>|</span><a href="#40035876">next</a><span>|</span><label class="collapse" for="c-40036894">[-]</label><label class="expand" for="c-40036894">[2 more]</label></div><br/><div class="children"><div class="content">I really love the theory of NixOS... an entire OS that is declaritively (or dynamically) defined. But the nix language itself does not seem like the right approach. A lot of packages just break out into command line scripting because of its limitations. As much as I&#x27;ve despised the JavaScript ecosystem in the past, it seems like TypeScript with Deno which has built-in JSON&#x2F;TOML&#x2F;INI&#x2F;YAML and sandboxing would be a better language to handle automatic system configuration overall... plus, you&#x27;d have the advantage of a web app to manage your system config(s), sort of like what fish does.</div><br/><div id="40038107" class="c"><input type="checkbox" id="c-40038107" checked=""/><div class="controls bullet"><span class="by">michaelmrose</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40036894">parent</a><span>|</span><a href="#40035876">next</a><span>|</span><label class="collapse" for="c-40038107">[-]</label><label class="expand" for="c-40038107">[1 more]</label></div><br/><div class="children"><div class="content">Why not guile with guix?</div><br/></div></div></div></div></div></div><div id="40035876" class="c"><input type="checkbox" id="c-40035876" checked=""/><div class="controls bullet"><span class="by">freeone3000</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035417">parent</a><span>|</span><a href="#40035677">prev</a><span>|</span><a href="#40035788">next</a><span>|</span><label class="collapse" for="c-40035876">[-]</label><label class="expand" for="c-40035876">[1 more]</label></div><br/><div class="children"><div class="content">The administration should be taken care of by the distro, but, it isn’t. Fedora Stream might be the solution here.</div><br/></div></div><div id="40035788" class="c"><input type="checkbox" id="c-40035788" checked=""/><div class="controls bullet"><span class="by">hx8</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035417">parent</a><span>|</span><a href="#40035876">prev</a><span>|</span><a href="#40036924">next</a><span>|</span><label class="collapse" for="c-40035788">[-]</label><label class="expand" for="c-40035788">[2 more]</label></div><br/><div class="children"><div class="content">This idea that we need to spoon feed simple solutions to users of free software really needs to die.  If you&#x27;re giving code away you don&#x27;t owe your users much.</div><br/><div id="40036957" class="c"><input type="checkbox" id="c-40036957" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035788">parent</a><span>|</span><a href="#40036924">next</a><span>|</span><label class="collapse" for="c-40036957">[-]</label><label class="expand" for="c-40036957">[1 more]</label></div><br/><div class="children"><div class="content">The idea of spoon feeding simple but incredible solutions for free can be very rewarding for maintainers, and can also generate a monetary reward as well. There are projects that I happily donate to because they create value for me. How many terms of service have you read of apps that you pay for? It seems that many apps you pay don&#x27;t just take your money, but your privacy and rights away too. Developers creating something in the open can inspire and help make communities of people working on a shared goal, that attracts quality individuals from all over the world to help. It brings people that are excited about your goals and that came to your project because it was something they could find and appreciate. I&#x27;d say, you don&#x27;t get the same from closed-source software. You also can&#x27;t achieve the same by being an asshole to potential contributors just because you feel like it. Sure, it is an option, but if you want to actually build something... not just for you, but a dream, then it is a bad choice to not try to build a healthy community.</div><br/></div></div></div></div></div></div></div></div><div id="40036924" class="c"><input type="checkbox" id="c-40036924" checked=""/><div class="controls bullet"><span class="by">danmur</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035218">parent</a><span>|</span><a href="#40035315">prev</a><span>|</span><a href="#40037727">next</a><span>|</span><label class="collapse" for="c-40036924">[-]</label><label class="expand" for="c-40036924">[1 more]</label></div><br/><div class="children"><div class="content">pissing matches and missing patches (sorry couldn&#x27;t resist)</div><br/></div></div><div id="40037727" class="c"><input type="checkbox" id="c-40037727" checked=""/><div class="controls bullet"><span class="by">goodpoint</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035218">parent</a><span>|</span><a href="#40036924">prev</a><span>|</span><a href="#40035389">next</a><span>|</span><label class="collapse" for="c-40037727">[-]</label><label class="expand" for="c-40037727">[1 more]</label></div><br/><div class="children"><div class="content">Security-oriented distributions solve the problem of managing vulnerabilities.</div><br/></div></div></div></div><div id="40035389" class="c"><input type="checkbox" id="c-40035389" checked=""/><div class="controls bullet"><span class="by">curt15</span><span>|</span><a href="#40035158">parent</a><span>|</span><a href="#40035218">prev</a><span>|</span><a href="#40035370">next</a><span>|</span><label class="collapse" for="c-40035389">[-]</label><label class="expand" for="c-40035389">[3 more]</label></div><br/><div class="children"><div class="content">Typical package managers also can&#x27;t tell you if an app bundles its own library. Whether an app runs on a flatpak runtime or directly on your host system, some reliable eyeballs need to inspect the app&#x27;s bill of materials.</div><br/><div id="40035402" class="c"><input type="checkbox" id="c-40035402" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035389">parent</a><span>|</span><a href="#40035370">next</a><span>|</span><label class="collapse" for="c-40035402">[-]</label><label class="expand" for="c-40035402">[2 more]</label></div><br/><div class="children"><div class="content">The package manager can&#x27;t, but the distro can. AIUI it&#x27;s perfectly common for flatpaks to bundle things in, whereas ex. Debian has explicit policies against doing so (with caveats, yes, but generally).</div><br/><div id="40035542" class="c"><input type="checkbox" id="c-40035542" checked=""/><div class="controls bullet"><span class="by">curt15</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40035402">parent</a><span>|</span><a href="#40035370">next</a><span>|</span><label class="collapse" for="c-40035542">[-]</label><label class="expand" for="c-40035542">[1 more]</label></div><br/><div class="children"><div class="content">&gt;The package manager can&#x27;t, but the distro can.<p>The package manager is a technology, while the distro is a set of people and policies. It&#x27;s fairer to compare distros with Flathub, the most popular repository for flatpaks (although not the only one; for example, Red Hat maintains its own flatpak remote for RHEL customers). And yes, Debian likely has stricter rules than Flathub. But those don&#x27;t apply to any software you might require outside the distros&#x27; repos -- just take a look at Google Chrome, probably one of the most popular DEBs or RPMs; it&#x27;s full of bundled libraries.</div><br/></div></div></div></div></div></div><div id="40036416" class="c"><input type="checkbox" id="c-40036416" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40035158">parent</a><span>|</span><a href="#40035370">prev</a><span>|</span><a href="#40035410">next</a><span>|</span><label class="collapse" for="c-40036416">[-]</label><label class="expand" for="c-40036416">[4 more]</label></div><br/><div class="children"><div class="content">I dislike bwrap because it is built around a CLI-arg based approached for sandboxing. Even the wrappers that allow config-based sandboxes just end up transcribing a file to CLI args. I&#x27;d prefer it actually have an API of sorts. Instead, it seems like it was never meant to be nothing more than a quick and dirty tool for basic sandboxing in a pinch.</div><br/><div id="40036976" class="c"><input type="checkbox" id="c-40036976" checked=""/><div class="controls bullet"><span class="by">eikenberry</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40036416">parent</a><span>|</span><a href="#40035410">next</a><span>|</span><label class="collapse" for="c-40036976">[-]</label><label class="expand" for="c-40036976">[3 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;d prefer it actually have an API of sorts.<p>The CLI and its commands with parameters is an API. Additionally, IMO, it can work pretty well if done right. But opinions vary.</div><br/><div id="40037082" class="c"><input type="checkbox" id="c-40037082" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40035158">root</a><span>|</span><a href="#40036976">parent</a><span>|</span><a href="#40035410">next</a><span>|</span><label class="collapse" for="c-40037082">[-]</label><label class="expand" for="c-40037082">[2 more]</label></div><br/><div class="children"><div class="content">Command line flags aren&#x27;t an efficient way to pass 20+ args to a program. Sure, it works but that is why I get the feeling it was only ever designed for quick and dirty sandboxing.</div><br/></div></div></div></div></div></div><div id="40035410" class="c"><input type="checkbox" id="c-40035410" checked=""/><div class="controls bullet"><span class="by">akdev1l</span><span>|</span><a href="#40035158">parent</a><span>|</span><a href="#40036416">prev</a><span>|</span><a href="#40034347">next</a><span>|</span><label class="collapse" for="c-40035410">[-]</label><label class="expand" for="c-40035410">[1 more]</label></div><br/><div class="children"><div class="content">you can build flatpaks as OCI containers using nix.<p>I’m not sure how that helps the issue of bundling dependencies though.</div><br/></div></div></div></div><div id="40034347" class="c"><input type="checkbox" id="c-40034347" checked=""/><div class="controls bullet"><span class="by">jamesponddotco</span><span>|</span><a href="#40035158">prev</a><span>|</span><a href="#40034920">next</a><span>|</span><label class="collapse" for="c-40034347">[-]</label><label class="expand" for="c-40034347">[6 more]</label></div><br/><div class="children"><div class="content">If anyone want to look further into sandboxing applications on Linux, you can also look at AppArmor and the sandboxing features built into systemd.<p>I love this repository for bases for AppArmor profiles[1], really good work. Never found a repository as good for systemd, but there are a few around.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;roddhjav&#x2F;apparmor.d">https:&#x2F;&#x2F;github.com&#x2F;roddhjav&#x2F;apparmor.d</a></div><br/><div id="40035395" class="c"><input type="checkbox" id="c-40035395" checked=""/><div class="controls bullet"><span class="by">darby_eight</span><span>|</span><a href="#40034347">parent</a><span>|</span><a href="#40034920">next</a><span>|</span><label class="collapse" for="c-40035395">[-]</label><label class="expand" for="c-40035395">[5 more]</label></div><br/><div class="children"><div class="content">Is there any indication Linux is going to adopt a pledge&#x2F;unveil api in the near future? It&#x27;s hard to place faith in systems like app armor that rely on system administrators to implement security guarantees.</div><br/><div id="40037410" class="c"><input type="checkbox" id="c-40037410" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40034347">root</a><span>|</span><a href="#40035395">parent</a><span>|</span><a href="#40035647">next</a><span>|</span><label class="collapse" for="c-40037410">[-]</label><label class="expand" for="c-40037410">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;d say that&#x27;s a weird request as pledge&#x2F;unveil are significantly less secure, even coming close to security theater IMO. Something like AppArmor can protect against a threat without having to rely on the developer to have done the right thing.<p>Pledge&#x2F;unveil would not help with the xz issue. AppArmor would.</div><br/><div id="40038056" class="c"><input type="checkbox" id="c-40038056" checked=""/><div class="controls bullet"><span class="by">planede</span><span>|</span><a href="#40034347">root</a><span>|</span><a href="#40037410">parent</a><span>|</span><a href="#40035647">next</a><span>|</span><label class="collapse" for="c-40038056">[-]</label><label class="expand" for="c-40038056">[1 more]</label></div><br/><div class="children"><div class="content">I would say that they are different tools for different purposes. Sure, with pledge&#x2F;unveil&#x2F;seccomp you trust the process to do the right thing, it&#x27;s really about restricting against threats external to the process. But it allows the process to have different privileges at different parts of the program, while external restrictions are not that flexible.<p>I think it makes sense to use both. Use external restrictions to only give capabilities that the process will ever need, and within the process drop capabilities when they are no longer needed.</div><br/></div></div></div></div><div id="40035647" class="c"><input type="checkbox" id="c-40035647" checked=""/><div class="controls bullet"><span class="by">boustrophedon</span><span>|</span><a href="#40034347">root</a><span>|</span><a href="#40035395">parent</a><span>|</span><a href="#40037410">prev</a><span>|</span><a href="#40034920">next</a><span>|</span><label class="collapse" for="c-40035647">[-]</label><label class="expand" for="c-40035647">[2 more]</label></div><br/><div class="children"><div class="content">Linux has seccomp and landlock, which are basically harder-to-use versions of pledge&#x2F;unveil.</div><br/><div id="40035698" class="c"><input type="checkbox" id="c-40035698" checked=""/><div class="controls bullet"><span class="by">PlutoIsAPlanet</span><span>|</span><a href="#40034347">root</a><span>|</span><a href="#40035647">parent</a><span>|</span><a href="#40034920">next</a><span>|</span><label class="collapse" for="c-40035698">[-]</label><label class="expand" for="c-40035698">[1 more]</label></div><br/><div class="children"><div class="content">Someone has combined those things to port Pledge to Linux.<p><a href="https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;pledge">https:&#x2F;&#x2F;github.com&#x2F;jart&#x2F;pledge</a></div><br/></div></div></div></div></div></div></div></div><div id="40034920" class="c"><input type="checkbox" id="c-40034920" checked=""/><div class="controls bullet"><span class="by">Intralexical</span><span>|</span><a href="#40034347">prev</a><span>|</span><a href="#40037130">next</a><span>|</span><label class="collapse" for="c-40034920">[-]</label><label class="expand" for="c-40034920">[3 more]</label></div><br/><div class="children"><div class="content">I kinda think having a tool to invoke `bwrap` is overkill for most cases. Applications I want to launch more than once just get a launcher script with `--bind &quot;$(dirname &quot;$(realpath &quot;${BASH_SOURCE[0]}&quot;)&quot;)&#x2F;FakeHome&quot; ~` or other flags as appropriate. Same for tools that I don&#x27;t want to install account-wide. Opening a terminal emulator in a `bwrap` sandbox and then using it to launch other applications and create new windows feels like using a VM, except it&#x27;s all running natively.<p>It&#x27;s also quite useful to have aliases&#x2F;functions in `.bashrc` for `--tmpfs ~` or `--bind &quot;$(mktemp -d)&quot; ~`, `--bind &quot;$PWD&quot; &quot;$PWD&quot;`, `--ro-bind &quot;$PWD&quot; &quot;$PWD&quot;`, etc., with varying levels of access to X11&#x2F;DBus etc. You can quickly test how a code change behaves on a clean install, instantly see what configuration files something uses by running it in a clean sandbox and then running `tree`, and check on your first time using a new program that it isn&#x27;t going to do anything crazy.<p>I usually use some variant of `sandboxed-dir bash` or `sandboxed-rodir bash`, which I&#x27;ve `alias`ed to `bwrap` with flags as the names describe, whenever I&#x27;m about to either run `rm -rf` [1] or otherwise touch files which I&#x27;d rather not accidentally destroy. The BubbleWrap sandbox isn&#x27;t useful just for security, but also for keeping configurations isolated&#x2F;clean, and protecting against all manner of errors both in software and between the keyboard and chair.<p>---<p>[1]: `<i>echo</i> rm -rvfi`, actually. See what you&#x27;re doing <i>before</i> you run it for real, especially if there&#x27;s a glob in there. And then the `bwrap --dev-bind &#x2F; &#x2F; --tmpfs ~ --bind &quot;$PWD&quot; &quot;$PWD&quot; bash` makes absolutely sure you&#x27;re not going to do anything other than what you said you&#x27;d do.</div><br/><div id="40035440" class="c"><input type="checkbox" id="c-40035440" checked=""/><div class="controls bullet"><span class="by">akdev1l</span><span>|</span><a href="#40034920">parent</a><span>|</span><a href="#40037130">next</a><span>|</span><label class="collapse" for="c-40035440">[-]</label><label class="expand" for="c-40035440">[2 more]</label></div><br/><div class="children"><div class="content">&gt; I kinda think having a tool to invoke `bwrap` is overkill for most cases.<p>It sounds like you built yourself some tooling that consists of miscellaneous shell scripts&#x2F;functions&#x2F;aliases.</div><br/><div id="40035924" class="c"><input type="checkbox" id="c-40035924" checked=""/><div class="controls bullet"><span class="by">1oooqooq</span><span>|</span><a href="#40034920">root</a><span>|</span><a href="#40035440">parent</a><span>|</span><a href="#40037130">next</a><span>|</span><label class="collapse" for="c-40035924">[-]</label><label class="expand" for="c-40035924">[1 more]</label></div><br/><div class="children"><div class="content">a good engineer understands the value of not using something you never read the manual for. and how simple it feels after you did read the manual.</div><br/></div></div></div></div></div></div><div id="40037130" class="c"><input type="checkbox" id="c-40037130" checked=""/><div class="controls bullet"><span class="by">Arnavion</span><span>|</span><a href="#40034920">prev</a><span>|</span><a href="#40036214">next</a><span>|</span><label class="collapse" for="c-40037130">[-]</label><label class="expand" for="c-40037130">[1 more]</label></div><br/><div class="children"><div class="content">I just use a Podman container to sandbox all the &quot;closed-source &#x2F; not from my distro&#x27;s repo&quot; software. <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34634584">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34634584</a><p>Normally this is Ubuntu &#x2F; Debian, but if I had TFA&#x27;s specific problem of &quot;I want the software to use my distro&#x27;s &#x2F;usr&quot; I&#x27;d use a container with the base image of my distro.<p>I don&#x27;t bother sharing dbus, but if you did want to share (a subset of) it as TFA does, then yes xdg-dbus-proxy is a necessity.</div><br/></div></div><div id="40036214" class="c"><input type="checkbox" id="c-40036214" checked=""/><div class="controls bullet"><span class="by">its-summertime</span><span>|</span><a href="#40037130">prev</a><span>|</span><a href="#40034799">next</a><span>|</span><label class="collapse" for="c-40036214">[-]</label><label class="expand" for="c-40036214">[1 more]</label></div><br/><div class="children"><div class="content">&gt; filesystems=~&#x2F;.XCompose:ro<p>Doesn&#x27;t ibus manage that for you? none of my programs have access to this file but I&#x27;m still able to use the changes I&#x27;ve made (as long as I restart ibus after changes)</div><br/></div></div><div id="40034799" class="c"><input type="checkbox" id="c-40034799" checked=""/><div class="controls bullet"><span class="by">ptx</span><span>|</span><a href="#40036214">prev</a><span>|</span><a href="#40034070">next</a><span>|</span><label class="collapse" for="c-40034799">[-]</label><label class="expand" for="c-40034799">[3 more]</label></div><br/><div class="children"><div class="content">Why do the global overrides for Flatpak need &quot;!~&#x2F;.ssh&quot; when they already have &quot;!home&quot;? Doesn&#x27;t the latter deny access to the whole home directory? (If not, I would have expected many more entries in that deny list.)</div><br/><div id="40034855" class="c"><input type="checkbox" id="c-40034855" checked=""/><div class="controls bullet"><span class="by">szundi</span><span>|</span><a href="#40034799">parent</a><span>|</span><a href="#40036434">next</a><span>|</span><label class="collapse" for="c-40034855">[-]</label><label class="expand" for="c-40034855">[1 more]</label></div><br/><div class="children"><div class="content">One change on home does not affect the ssh files. Probably failsafe for user error.</div><br/></div></div><div id="40036434" class="c"><input type="checkbox" id="c-40036434" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40034799">parent</a><span>|</span><a href="#40034855">prev</a><span>|</span><a href="#40034070">next</a><span>|</span><label class="collapse" for="c-40036434">[-]</label><label class="expand" for="c-40036434">[1 more]</label></div><br/><div class="children"><div class="content">Good question... Flatpak seems !~&#x2F;.ssh &amp; !home as two different things... so !home will not block access to an app configured to access ~&#x2F;.ssh.</div><br/></div></div></div></div><div id="40034070" class="c"><input type="checkbox" id="c-40034070" checked=""/><div class="controls bullet"><span class="by">alhadrad</span><span>|</span><a href="#40034799">prev</a><span>|</span><a href="#40035357">next</a><span>|</span><label class="collapse" for="c-40034070">[-]</label><label class="expand" for="c-40034070">[1 more]</label></div><br/><div class="children"><div class="content"><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29316024">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=29316024</a></div><br/></div></div><div id="40035062" class="c"><input type="checkbox" id="c-40035062" checked=""/><div class="controls bullet"><span class="by">anthk</span><span>|</span><a href="#40035357">prev</a><span>|</span><a href="#40036395">next</a><span>|</span><label class="collapse" for="c-40035062">[-]</label><label class="expand" for="c-40035062">[2 more]</label></div><br/><div class="children"><div class="content">Bwrap + microdistro = minichroot everywhere.  That&#x27;s how I run mosh under Hyperbola GNU&#x2F;Linux.</div><br/><div id="40035461" class="c"><input type="checkbox" id="c-40035461" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40035062">parent</a><span>|</span><a href="#40036395">next</a><span>|</span><label class="collapse" for="c-40035461">[-]</label><label class="expand" for="c-40035461">[1 more]</label></div><br/><div class="children"><div class="content">Is microdistro a specific thing or a generic name for an approach? It doesn&#x27;t obviously turn up in web search</div><br/></div></div></div></div><div id="40036395" class="c"><input type="checkbox" id="c-40036395" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40035062">prev</a><span>|</span><a href="#40034842">next</a><span>|</span><label class="collapse" for="c-40036395">[-]</label><label class="expand" for="c-40036395">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m really frustrated with Flatpak.<p>I thought it was going to be an exciting secure sandboxing solution, but found out the people running it just make terrible choices overall. Apps don&#x27;t use their conventional names, so chromium ends up become org.chromium.Chromium &amp; Visual Studio Code is com.visualstudio.code. They use fuse for mounts, which isn&#x27;t necessary in modern Linux kernels that support nonroot overlays (think Podman).<p>The whole point of sandboxing is to allow it to &quot;hide&quot; your real file system, and only mount what you need or permit access through D-Bus.. however, you&#x27;ll find several apps that default to host access and access to all your &#x2F;dev. They only provide a few device options as well... so, if you just want to give access to a webcam, well you have to provide all of &#x2F;dev in most cases. Flatpak leaks all kinds of info about its sandbox too, so any app can easily determine its sandbox.<p>If you want to setup custom mounts, for example to mount a specific host directory into a different sandbox directory, well you can&#x27;t. It has to be a direct mapping from your host except it prevents you from mapping &#x2F;etc&#x2F; directories. To work around this for sandboxed home directories, you can use a persistent directory mapping.. but now, you&#x27;ll be trying to access your files in `~&#x2F;.var&#x2F;apps&#x2F;org.chromium.Chromium&#x2F;Downloads`.<p>They also use a file forwarding concept, which doesn&#x27;t work well when mixing arguments and files. For example, try using org.vim.Vim to pass arguments and open a file from the command line. Or, try editing system files with Flatpak where you need sudo or some privilege elevation. Why doesn&#x27;t org.vim.Vim get aliased and work like regular vim?<p>The typical solution suggested to fix anything is to add `org.freedesktop.Flatpak=talk` to the session bus, and use flatpak-spawn from within the sandbox. Many users do this not knowing the consequences. This is generally terrible advice as it will give any app in the sandbox complete host access. But what happens when you need access to host tools or native messaging apps from inside the Sandbox? Again, the top answers are to use flatpak-spawn.<p>They have &quot;SDK Extensions&quot; for a few apps which are like binary dependencies, but many tools needed for things like Visual Studio Code just don&#x27;t exist. Try using the Ansible extension in VS Code for example. Packaging them is a nightmare because they use a hodgepodge of tools&#x2F;scripts inside a random GitHub repo to manually get all the Rust crates, node modules, python packages, etc. and add them to a nonstandard file inside your build manifest. It makes no sense why they never added this functionality to the builder itself. Development seems to be stalling.<p>If you do build an app, good luck getting it on Flathub without some authoritarian mod telling you they don&#x27;t like your app (see the Popcorn Time decision).<p>Now, there are some good things. The build manifest is pretty neat. I like the idea of having a simple manifest to build apps that integrates with build tools, but the externals scripts it relies on makes it suck.<p>Sandboxing isn&#x27;t a unique concept. I can see an enthusiastic Rust&#x2F;C&#x2F;C++&#x2F;Go&#x2F;Typescript developer or developers doing the same thing 100x better. IMO sandboxed apps shouldn&#x27;t even know they are sandboxed. Each app should have a clean environment and ideally you&#x27;d pick and choose what files&#x2F;folders you want to give the app access to while it is running, and not let the app builder decide for you. Also, the user should pick and choose where to mount directories if they choose to do so.. not make ~&#x2F;Documents mount to ~&#x2F;Documents... what if I want to mount &#x2F;mnt&#x2F;dev&#x2F;docs to ~&#x2F;Documents. If you care about this stuff, then you may end up frustrated like me.</div><br/><div id="40038057" class="c"><input type="checkbox" id="c-40038057" checked=""/><div class="controls bullet"><span class="by">slooonz</span><span>|</span><a href="#40036395">parent</a><span>|</span><a href="#40034842">next</a><span>|</span><label class="collapse" for="c-40038057">[-]</label><label class="expand" for="c-40038057">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Each app should have a clean environment and ideally you&#x27;d pick and choose what files&#x2F;folders you want to give the app access to while it is running, and not let the app builder decide for you. Also, the user should pick and choose where to mount directories if they choose to do so<p>That’s… what bubblebox is ?</div><br/></div></div></div></div><div id="40034842" class="c"><input type="checkbox" id="c-40034842" checked=""/><div class="controls bullet"><span class="by">codedokode</span><span>|</span><a href="#40036395">prev</a><span>|</span><label class="collapse" for="c-40034842">[-]</label><label class="expand" for="c-40034842">[9 more]</label></div><br/><div class="children"><div class="content">It surprises me that Linux has no proper and detailed sandboxing out of the box. Are Linux users running untrusted closed-source applications and potentially backdoored open-source programs with full privileges? Maybe they should just post their root password online, it won&#x27;t get worse anyway.</div><br/><div id="40035952" class="c"><input type="checkbox" id="c-40035952" checked=""/><div class="controls bullet"><span class="by">rustcleaner</span><span>|</span><a href="#40034842">parent</a><span>|</span><a href="#40035448">next</a><span>|</span><label class="collapse" for="c-40035952">[-]</label><label class="expand" for="c-40035952">[4 more]</label></div><br/><div class="children"><div class="content">Security is in terrible shape.  Right now for power-consumers the most secure OSes for access control are GrapheneOS (AOSP) and Qubes OS.  Windows (with privsep) and desktop Linux are (were) good at stopping drive-by printer driver installs but terrible at keeping your browser running rogue glowware exfiltrating blackmail to use against you (or planting felony charges to leverage).  Qubes puts everything in boxes and you keep the spam and ham in separate boxes, and Graphene gives you Android&#x27;s use of SELinux as well as Storage Scopes (it&#x27;s like unveil()).</div><br/><div id="40037423" class="c"><input type="checkbox" id="c-40037423" checked=""/><div class="controls bullet"><span class="by">DEADMINCE</span><span>|</span><a href="#40034842">root</a><span>|</span><a href="#40035952">parent</a><span>|</span><a href="#40036896">next</a><span>|</span><label class="collapse" for="c-40037423">[-]</label><label class="expand" for="c-40037423">[1 more]</label></div><br/><div class="children"><div class="content">Graphene is nice but only works on Pixel hardware. e&#x2F;OS is a good alternative. Qubes isn&#x27;t really about access control so much as it is about having disposable vms for doing sensitive things.</div><br/></div></div><div id="40036896" class="c"><input type="checkbox" id="c-40036896" checked=""/><div class="controls bullet"><span class="by">Borealid</span><span>|</span><a href="#40034842">root</a><span>|</span><a href="#40035952">parent</a><span>|</span><a href="#40037423">prev</a><span>|</span><a href="#40035448">next</a><span>|</span><label class="collapse" for="c-40036896">[-]</label><label class="expand" for="c-40036896">[2 more]</label></div><br/><div class="children"><div class="content">I wish I could use Graphene without needing to buy into their anti-OSS stance and ideology, though.<p>The core idea is sound, but I frequently see:<p>- MicroG is &quot;insecure&quot; because it requires &quot;signature spoofing&quot; (reality: LineageOS allows only MicroG to replace only Google Play Services - I wouldn&#x27;t consider that &quot;insecure&quot; and the Graphene devs never explain further)<p>- Open source software is less secure than closed source software (reality: mixed bag)<p>- F-Droid is &quot;insecure&quot; (I can&#x27;t address this one because I don&#x27;t understand the point of view and I&#x27;ve never seen it clarified)<p>- GrapheneOS executes Google Play Services in a &quot;sandbox without any special permissions&quot; (reality: there is a repository full of code that allows sandboxed Google Play to behave in a way other apps can&#x27;t within the sandbox)<p>- Automatically installing updates is necessary to &quot;be secure&quot; (reality: updates might add or remove vulnerabilities. Failing to update when a vulnerability exists is insecure, but updating automatically is not a clear win for a savvy, aware user)<p>- System backups are not a part of a security policy (reality: having the ability to restore a backup is necessary to mitigate damage caused by an exploit)<p>- Pixel devices are the only &quot;sufficiently secure&quot; phones (reality: it might be convenient targeting a single platform, but there are plenty of phones now that provide the technical capabilities Graphene requires)<p>- Privacy is not part of security (reality: security is classic CIA - Confidentiality, Integrity, Availability. If you can&#x27;t keep confidentiality you&#x27;re missing one of the pillars)<p>- Complying with Google&#x27;s Compatibility Test Suite is &quot;more secure&quot; than deviating from it (reality: the CTS is designed to favor app developers over end users. The app developers might or might not be better at looking out for users&#x27; interests than the users themselves)<p>Everything I&#x27;m representing as a GrapheneOS dev position I&#x27;ve heard straight from the horse&#x27;s mouth on their forum and&#x2F;or in their documentation. I think sometimes they hold opinions which aren&#x27;t 100% aligned with what I&#x27;d consider a maximally secure system.<p>That said, they have delivered a pretty solid OS if you can live with its various compromises. The one that really grates on me is the last one: I don&#x27;t want an OS that chooses an app developer&#x27;s &quot;don&#x27;t copy this file&quot; flag over my desire to copy it!<p>EDIT: formatting</div><br/><div id="40037019" class="c"><input type="checkbox" id="c-40037019" checked=""/><div class="controls bullet"><span class="by">timeflex</span><span>|</span><a href="#40034842">root</a><span>|</span><a href="#40036896">parent</a><span>|</span><a href="#40035448">next</a><span>|</span><label class="collapse" for="c-40037019">[-]</label><label class="expand" for="c-40037019">[1 more]</label></div><br/><div class="children"><div class="content">I tried GrapheneOS recently and switched back just because I lost my automatic backups. The backup solution and syncing should have been solved before some of the other design choices IMO. I was also disappointed to see that there is no way to prevent the warning message on each boot, which seems to delay the startup (or at least none that I could find).<p>Other than that, I could be content with it.. it may not be perfect, but it felt good to know that I wasn&#x27;t tied into the Google eco system. I liked their contacts and location sandboxing.<p>I&#x27;ve heard some complaints about GrapheneOS&#x27;s choices and wish that there was more communication from the lead developers about their design choices, just to understand them a bit better. However, I do think some users are just reactionary overall to some things. They hear Chromium and just assume it is worse, but honestly have no clue from a development perspective. All your complaints sound legit though and I too would like to know the answers, because you bring up very valid points.<p>There has been some drama in the F-Droid community, and I too tried alternatives, but in the end... my favorite apps all recommend F-Droid, and I find using F-Droid 10x easier than the alternative of managing apps from random locations. I believe the biggest complaint with F-Droid is that it is a single-point of failure or compromise since they sign the packages and updates can get delayed, however, in reality adding random Git repos to Obtanium or whatever is just as insecure. I believe Fdroid even does some security scanning too, but I could be wrong... which is an added bonus.</div><br/></div></div></div></div></div></div><div id="40035448" class="c"><input type="checkbox" id="c-40035448" checked=""/><div class="controls bullet"><span class="by">yjftsjthsd-h</span><span>|</span><a href="#40034842">parent</a><span>|</span><a href="#40035952">prev</a><span>|</span><a href="#40035085">next</a><span>|</span><label class="collapse" for="c-40035448">[-]</label><label class="expand" for="c-40035448">[2 more]</label></div><br/><div class="children"><div class="content">Linux has lots of sandboxing features. Many Linux distros only use them minimally because the value proposition is poor: Most distros <i>don&#x27;t</i> ship closed-source applications and in the last 30 years there have only ever been a tiny number of backdoored open source packages. OTOH, sandboxing tends to break the kind of complex workflows that users are fond of.<p>Another angle to point out is that some distros do bake in more protective features; consider Fedora using SELinux. Then, again, keep considering SELinux and observe how many things it breaks the moment you set a single foot off the trodden path.</div><br/><div id="40037897" class="c"><input type="checkbox" id="c-40037897" checked=""/><div class="controls bullet"><span class="by">danieldk</span><span>|</span><a href="#40034842">root</a><span>|</span><a href="#40035448">parent</a><span>|</span><a href="#40035085">next</a><span>|</span><label class="collapse" for="c-40037897">[-]</label><label class="expand" for="c-40037897">[1 more]</label></div><br/><div class="children"><div class="content"><i>Linux has lots of sandboxing features.</i><p>The issue is often not the individual features, but delivering them as a consistent, usable package. Though Flatpak is getting there, but it&#x27;s a long road, you don&#x27;t just need some kernel sandboxing features, but also toolkit extensions to make files available to sandboxed applications (portals), etc.<p><i>Many Linux distros only use them minimally because the value proposition is poor: Most distros don&#x27;t ship closed-source applications</i><p>That&#x27;s kind of putting your head in the sand. A lot of users need closed-source applications for work, such as Slack, Zoom, Chrome, Obsidian, JetBrains IDEs (the non-open source flavors), or for fun (Games, Steam, Spotify). Some have web apps, but the generally work less well.<p><i>a tiny number of backdoored open source packages</i><p>Backdoored applications are not the only issue. Also non-backdoored applications with vulnerabilities, basically any client, etc. The saving grace of the Linux desktop is that it&#x27;s not much of an interesting target due to relatively low popularity. Otherwise actors would be hunting for vulnerabilities in RSS readers, chat clients, etc. (remember that the surface is not only the application itself, but also any image&#x2F;video decoding libraries, etc.).<p><i>OTOH, sandboxing tends to break the kind of complex workflows that users are fond of.</i><p>That&#x27;s an issue, especially for Linux power users. For most users, sandboxing can be done without too many issues (see e.g. sandboxed Mac apps).</div><br/></div></div></div></div><div id="40035085" class="c"><input type="checkbox" id="c-40035085" checked=""/><div class="controls bullet"><span class="by">cherryteastain</span><span>|</span><a href="#40034842">parent</a><span>|</span><a href="#40035448">prev</a><span>|</span><a href="#40035434">next</a><span>|</span><label class="collapse" for="c-40035085">[-]</label><label class="expand" for="c-40035085">[1 more]</label></div><br/><div class="children"><div class="content">Linux is a kernel. Let alone sandboxing, it does not even have an init process or bootloader by default. You can install all the utilities expected of a modern desktop OS if you want, and most distros will do it for you.</div><br/></div></div><div id="40035434" class="c"><input type="checkbox" id="c-40035434" checked=""/><div class="controls bullet"><span class="by">striking</span><span>|</span><a href="#40034842">parent</a><span>|</span><a href="#40035085">prev</a><span>|</span><label class="collapse" for="c-40035434">[-]</label><label class="expand" for="c-40035434">[1 more]</label></div><br/><div class="children"><div class="content">Not every app needs to be run with &quot;full privileges&quot; (or &quot;as root&quot; as some might call it), but it does usually end up being a binary decision on most distros if you&#x27;re not careful. Either it can change everything or it can only affect the entire user profile it&#x27;s running under. Bwrap and friends allow you to do a lot of extra isolation and get much more granular, but non-root console-only apps are generally safe to run (and safer still to run under their own user instead of yours).</div><br/></div></div></div></div></div></div></div></div></div></body></html>