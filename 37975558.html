<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1698224463499" as="style"/><link rel="stylesheet" href="styles.css?v=1698224463499"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">A Philosophy of Software Design</a> <span class="domain">(<a href="https://web.stanford.edu">web.stanford.edu</a>)</span></div><div class="subtext"><span>belter</span> | <span>40 comments</span></div><br/><div><div id="38009389" class="c"><input type="checkbox" id="c-38009389" checked=""/><div class="controls bullet"><span class="by">avindroth</span><span>|</span><a href="#38009674">next</a><span>|</span><label class="collapse" for="c-38009389">[-]</label><label class="expand" for="c-38009389">[5 more]</label></div><br/><div class="children"><div class="content">John Ousterhout, Carson Gross (htmx, <a href="https:&#x2F;&#x2F;grugbrain.dev" rel="nofollow noreferrer">https:&#x2F;&#x2F;grugbrain.dev</a>), and Rich Hickey are my favorite people on complexity. John Ousterhout was notably my professor for operating systems @ Stanford. He taught not just ways to design software, but also ways to live.<p>Carson’s work is also directly influenced by Ousterhout, as referenced at the end of his article.<p>For John Ousterhout, I suggest looking at the class website:
<a href="https:&#x2F;&#x2F;web.stanford.edu&#x2F;~ouster&#x2F;cs190-winter23&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;web.stanford.edu&#x2F;~ouster&#x2F;cs190-winter23&#x2F;</a><p>For Carson Gross, I suggest his book, Hypermedia Systems: <a href="https:&#x2F;&#x2F;hypermedia.systems&#x2F;" rel="nofollow noreferrer">https:&#x2F;&#x2F;hypermedia.systems&#x2F;</a></div><br/><div id="38010715" class="c"><input type="checkbox" id="c-38010715" checked=""/><div class="controls bullet"><span class="by">exclipy</span><span>|</span><a href="#38009389">parent</a><span>|</span><a href="#38009744">next</a><span>|</span><label class="collapse" for="c-38010715">[-]</label><label class="expand" for="c-38010715">[2 more]</label></div><br/><div class="children"><div class="content">Rich Hickey is the odd one out. What do you see in someone who shuns static typing? Static typing is the clearest way to reduce complexity.</div><br/><div id="38010764" class="c"><input type="checkbox" id="c-38010764" checked=""/><div class="controls bullet"><span class="by">synthc</span><span>|</span><a href="#38009389">root</a><span>|</span><a href="#38010715">parent</a><span>|</span><a href="#38009744">next</a><span>|</span><label class="collapse" for="c-38010764">[-]</label><label class="expand" for="c-38010764">[1 more]</label></div><br/><div class="children"><div class="content">static typing is a way to manage complexity, Rich Hickey is about avoiding complexity</div><br/></div></div></div></div><div id="38009744" class="c"><input type="checkbox" id="c-38009744" checked=""/><div class="controls bullet"><span class="by">codeflo</span><span>|</span><a href="#38009389">parent</a><span>|</span><a href="#38010715">prev</a><span>|</span><a href="#38009674">next</a><span>|</span><label class="collapse" for="c-38009744">[-]</label><label class="expand" for="c-38009744">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m a fan of Ousterhout&#x27;s writing; &quot;A philosophy of software design&quot; clarified a lot of my thinking around complexity.<p>I find the &quot;Grug Brain&quot; stuff pretentious and dishonest. &quot;Me not smart. Me like simple things. Me not believe in hype. Hence why me invent complex new frontend framework, and then me hype it up beyond reason.&quot;<p>(To be clear what I&#x27;m saying, my point is not that HTMX is overhyped -- it might be, but then so is everything. It&#x27;s specifically the hypocrisy of the &quot;we&#x27;re against hypes&quot; hype that makes me cringe.)</div><br/><div id="38010427" class="c"><input type="checkbox" id="c-38010427" checked=""/><div class="controls bullet"><span class="by">cryptography</span><span>|</span><a href="#38009389">root</a><span>|</span><a href="#38009744">parent</a><span>|</span><a href="#38009674">next</a><span>|</span><label class="collapse" for="c-38010427">[-]</label><label class="expand" for="c-38010427">[1 more]</label></div><br/><div class="children"><div class="content">Do you think this would be beneficial for a somewhat perplexed CTO of a newly seed-funded startup? Or would it be wiser for me to concentrate on my current responsibilities and return to this book when my mind is clearer? I&#x27;m feeling a bit overwhelmed and under pressure, and I&#x27;m concerned that reading this book might add to the chaos. I would appreciate your input.</div><br/></div></div></div></div></div></div><div id="38009674" class="c"><input type="checkbox" id="c-38009674" checked=""/><div class="controls bullet"><span class="by">mparnisari</span><span>|</span><a href="#38009389">prev</a><span>|</span><a href="#38009366">next</a><span>|</span><label class="collapse" for="c-38009674">[-]</label><label class="expand" for="c-38009674">[6 more]</label></div><br/><div class="children"><div class="content">His book is awesome! One takeaway I had: code reviews matter. If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader thinks it’s not obvious, then it’s not obvious.</div><br/><div id="38010034" class="c"><input type="checkbox" id="c-38010034" checked=""/><div class="controls bullet"><span class="by">DoingIsLearning</span><span>|</span><a href="#38009674">parent</a><span>|</span><a href="#38010552">next</a><span>|</span><label class="collapse" for="c-38010034">[-]</label><label class="expand" for="c-38010034">[1 more]</label></div><br/><div class="children"><div class="content">I think the issue is _when_ you make the review. Psychologically suggesting a breaking change  after someone invested in a bunch of tests and verification will raise their defenses up.<p>I think there is value in doing a review (specially with junior team members) on their &#x27;design intent&#x27; early on, as soon as a prototype&#x2F;skeleton is up. Proposing a change then is met with a lot less friction.</div><br/></div></div><div id="38010552" class="c"><input type="checkbox" id="c-38010552" checked=""/><div class="controls bullet"><span class="by">bryanrasmussen</span><span>|</span><a href="#38009674">parent</a><span>|</span><a href="#38010034">prev</a><span>|</span><a href="#38009753">next</a><span>|</span><label class="collapse" for="c-38010552">[-]</label><label class="expand" for="c-38010552">[1 more]</label></div><br/><div class="children"><div class="content">&gt;One takeaway I had: code reviews matter. If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader thinks it’s not obvious, then it’s not obvious.<p>ok, what about if you have code and you think this is not obvious because edge case for browser X version Y therefore I will leave a long comment specifying why it is the way it is and when and under what conditions in the future it should be removed - but the reviewer thinks it is obvious and please remove the comment.<p>As a general rule reviewers concerns should be addressed, but I have had some experiences in which what the reviewer wanted made the code worse, or even would possibly introduce hard to find bugs.</div><br/></div></div><div id="38009753" class="c"><input type="checkbox" id="c-38009753" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#38009674">parent</a><span>|</span><a href="#38010552">prev</a><span>|</span><a href="#38010016">next</a><span>|</span><label class="collapse" for="c-38009753">[-]</label><label class="expand" for="c-38009753">[1 more]</label></div><br/><div class="children"><div class="content">But don&#x27;t forget that there are two reasons why something will not be obvious: It may not be obvious because the meaning is obfuscated, or it may not be obvious because it relies on the reader understanding certain ideas, concepts or technologies.</div><br/></div></div><div id="38010016" class="c"><input type="checkbox" id="c-38010016" checked=""/><div class="controls bullet"><span class="by">laurent_du</span><span>|</span><a href="#38009674">parent</a><span>|</span><a href="#38009753">prev</a><span>|</span><a href="#38009366">next</a><span>|</span><label class="collapse" for="c-38010016">[-]</label><label class="expand" for="c-38010016">[2 more]</label></div><br/><div class="children"><div class="content">If I ask my kids or my girlfriend to review my code, nothing will be obvious to them. Doesn&#x27;t mean that my code is the problem. The idea that the reviewer is always right makes no sense.</div><br/><div id="38010598" class="c"><input type="checkbox" id="c-38010598" checked=""/><div class="controls bullet"><span class="by">glun</span><span>|</span><a href="#38009674">root</a><span>|</span><a href="#38010016">parent</a><span>|</span><a href="#38009366">next</a><span>|</span><label class="collapse" for="c-38010598">[-]</label><label class="expand" for="c-38010598">[1 more]</label></div><br/><div class="children"><div class="content">Your family is not the intended audience for the code. If the reviewer isn’t either, then they have no business reviewing your code.</div><br/></div></div></div></div></div></div><div id="38009366" class="c"><input type="checkbox" id="c-38009366" checked=""/><div class="controls bullet"><span class="by">fzil</span><span>|</span><a href="#38009674">prev</a><span>|</span><a href="#38009905">next</a><span>|</span><label class="collapse" for="c-38009366">[-]</label><label class="expand" for="c-38009366">[1 more]</label></div><br/><div class="children"><div class="content">Probably the best book I’ve read on this subject. There’s a lecture by the author[1] as a quick overview of what the book is about.<p>[1]: <a href="https:&#x2F;&#x2F;youtu.be&#x2F;bmSAYlu0NcY" rel="nofollow noreferrer">https:&#x2F;&#x2F;youtu.be&#x2F;bmSAYlu0NcY</a></div><br/></div></div><div id="38009905" class="c"><input type="checkbox" id="c-38009905" checked=""/><div class="controls bullet"><span class="by">rgoulter</span><span>|</span><a href="#38009366">prev</a><span>|</span><a href="#38009921">next</a><span>|</span><label class="collapse" for="c-38009905">[-]</label><label class="expand" for="c-38009905">[1 more]</label></div><br/><div class="children"><div class="content">One thing I liked about the book was it emphasised the conceptual difference between &#x27;interface&#x27; and &#x27;implementation&#x27;. &quot;Interface&quot; is &quot;what you need to know to use the module&quot;.<p>Some module is &quot;complex&quot; if you need to know more than the interface suggests in order to use that module (e.g. you have to know implementation details); or if the interface requires irrelevant details.</div><br/></div></div><div id="38009921" class="c"><input type="checkbox" id="c-38009921" checked=""/><div class="controls bullet"><span class="by">dang</span><span>|</span><a href="#38009905">prev</a><span>|</span><a href="#38009766">next</a><span>|</span><label class="collapse" for="c-38009921">[-]</label><label class="expand" for="c-38009921">[1 more]</label></div><br/><div class="children"><div class="content">Related. Others?<p><i>A Philosophy of Software Design – Book Summary and Notes</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31248641">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31248641</a> - May 2022 (34 comments)<p><i>A Philosophy of Software Design, 2nd Edition</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28975872">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=28975872</a> - Oct 2021 (1 comment)<p><i>Book Review: A Philosophy of Software Design (2020)</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27686818">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=27686818</a> - June 2021 (61 comments)<p><i>Book Review: A Philosophy of Software Design</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18331219">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=18331219</a> - Oct 2018 (51 comments)<p><i>Notes on “A Philosophy of Software Design”</i> - <a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17906662">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17906662</a> - Sept 2018 (32 comments)</div><br/></div></div><div id="38009766" class="c"><input type="checkbox" id="c-38009766" checked=""/><div class="controls bullet"><span class="by">a_c</span><span>|</span><a href="#38009921">prev</a><span>|</span><a href="#38010321">next</a><span>|</span><label class="collapse" for="c-38009766">[-]</label><label class="expand" for="c-38009766">[4 more]</label></div><br/><div class="children"><div class="content">Haven&#x27;t read the book yet but it seems to be about design principles, abstraction, divide and conquer, single responsibility and the like. Man made objects tend to be single-purposed and interact with few other components. Over the years I have come to appreciate the nature more and more. In nature, things are always multi-purposed and exist in a web of relationship. A bat is a pollinator, pest control, fertilizer and food source all at the same time. But if we are to replicate the role of bat, we need seed, pesticide and artificial fertilizer. And if we want to grow only one kind of crop, we will need even more control. See monoculture [1]<p>In software, every named domain can and will grow into its own forest. There was only nginx(or apache) serving html. There wasn&#x27;t &quot;frontend&quot; and &quot;backend&quot;. Nginx served also the analytics. Now they all seem to mean its own thing. There are and always will be manual interacting with the software. What we do is first manually interact, and then write automated script, and then manually interact and make demo video, and then manually interact and make tutorial, and then manually interact and illustrate the user journey, etc. Telemetry is &quot;engineering&quot;, analytics is &quot;product&quot;. The division goes on forever. Man made concept grows into isolated forest. The more division, hence specialisation, we have, the more gluing we need. People seem to talk more about infinite scaling is a fool&#x27;s errand. I say so is specialising without seeing the forest first.<p>I find occasionally zoom into other direction immensely helpful and refreshing.<p>[1] <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Monoculture" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Monoculture</a></div><br/><div id="38009823" class="c"><input type="checkbox" id="c-38009823" checked=""/><div class="controls bullet"><span class="by">rTX5CMRXIfFG</span><span>|</span><a href="#38009766">parent</a><span>|</span><a href="#38010511">next</a><span>|</span><label class="collapse" for="c-38009823">[-]</label><label class="expand" for="c-38009823">[2 more]</label></div><br/><div class="children"><div class="content">That’s because your example, a bat, is a high level of abstraction. If you dig into the cellular level things start becoming very single-purpose, even more so down to the atomic level, and so on. The architecture of recursive composition usually done in building large software was found in nature first.</div><br/><div id="38010147" class="c"><input type="checkbox" id="c-38010147" checked=""/><div class="controls bullet"><span class="by">jkrubin</span><span>|</span><a href="#38009766">root</a><span>|</span><a href="#38009823">parent</a><span>|</span><a href="#38010511">next</a><span>|</span><label class="collapse" for="c-38010147">[-]</label><label class="expand" for="c-38010147">[1 more]</label></div><br/><div class="children"><div class="content">Bats are single celled?</div><br/></div></div></div></div><div id="38010511" class="c"><input type="checkbox" id="c-38010511" checked=""/><div class="controls bullet"><span class="by">matheusiacono</span><span>|</span><a href="#38009766">parent</a><span>|</span><a href="#38009823">prev</a><span>|</span><a href="#38010321">next</a><span>|</span><label class="collapse" for="c-38010511">[-]</label><label class="expand" for="c-38010511">[1 more]</label></div><br/><div class="children"><div class="content">&gt; People seem to talk more about infinite scaling is a fool&#x27;s errand. I say so is specialising without seeing the forest first.<p>I started first disagreeing with your point, but I think this last sentences captured what sticked to me. That&#x27;s similar to the rule of three practice (three strikes and you refactor).<p>I find it&#x27;s always hard to keep the whole team aware of the forest, maybe that&#x27;s why I&#x27;ve seen many premature specialization.<p>How do we keep a team aware of the forest?</div><br/></div></div></div></div><div id="38010321" class="c"><input type="checkbox" id="c-38010321" checked=""/><div class="controls bullet"><span class="by">mbwgh</span><span>|</span><a href="#38009766">prev</a><span>|</span><a href="#38009341">next</a><span>|</span><label class="collapse" for="c-38010321">[-]</label><label class="expand" for="c-38010321">[1 more]</label></div><br/><div class="children"><div class="content">In addition to &#x27;A philosophy of Software Design&#x27;, I would also recommend the less well known &#x27;Object-Oriented Design Heuristics&#x27;.<p>It came out at the same time as the GoF book, but I think it is still relevant today and similar in spirit to Ousterhout&#x27;s book.</div><br/></div></div><div id="38009341" class="c"><input type="checkbox" id="c-38009341" checked=""/><div class="controls bullet"><span class="by">rzmmm</span><span>|</span><a href="#38010321">prev</a><span>|</span><a href="#38009324">next</a><span>|</span><label class="collapse" for="c-38009341">[-]</label><label class="expand" for="c-38009341">[1 more]</label></div><br/><div class="children"><div class="content">I think Ousterhout has interesting approach for software complexity and it&#x27;s causes. In a nutshell, he suggests it&#x27;s composed of (cognitive) dependencies between the software components, and obscurity. If anyone has more reading suggestions which have focus on software complexity, I&#x27;d like to hear about them.</div><br/></div></div><div id="38009324" class="c"><input type="checkbox" id="c-38009324" checked=""/><div class="controls bullet"><span class="by">gumby</span><span>|</span><a href="#38009341">prev</a><span>|</span><a href="#38009687">next</a><span>|</span><label class="collapse" for="c-38009324">[-]</label><label class="expand" for="c-38009324">[1 more]</label></div><br/><div class="children"><div class="content">When I think of philosophy of software I think of the operative semantics of programming languages, model semantics, Quine, Church, Barwise &amp; Perry, et al.</div><br/></div></div><div id="38009687" class="c"><input type="checkbox" id="c-38009687" checked=""/><div class="controls bullet"><span class="by">buzzwords</span><span>|</span><a href="#38009324">prev</a><span>|</span><a href="#38009451">next</a><span>|</span><label class="collapse" for="c-38009687">[-]</label><label class="expand" for="c-38009687">[5 more]</label></div><br/><div class="children"><div class="content">Is this good going to be readable on Kindle? It might be just me, but some software engineering books are hard to read on Kindle due to codes sections could end up with strange format.</div><br/><div id="38009984" class="c"><input type="checkbox" id="c-38009984" checked=""/><div class="controls bullet"><span class="by">pamoroso</span><span>|</span><a href="#38009687">parent</a><span>|</span><a href="#38009699">next</a><span>|</span><label class="collapse" for="c-38009984">[-]</label><label class="expand" for="c-38009984">[2 more]</label></div><br/><div class="children"><div class="content">No problem on Kindle, the book is mostly text and has only a handful of short code snippets.</div><br/><div id="38010123" class="c"><input type="checkbox" id="c-38010123" checked=""/><div class="controls bullet"><span class="by">buzzwords</span><span>|</span><a href="#38009687">root</a><span>|</span><a href="#38009984">parent</a><span>|</span><a href="#38009699">next</a><span>|</span><label class="collapse" for="c-38010123">[-]</label><label class="expand" for="c-38010123">[1 more]</label></div><br/><div class="children"><div class="content">Thank you</div><br/></div></div></div></div><div id="38009699" class="c"><input type="checkbox" id="c-38009699" checked=""/><div class="controls bullet"><span class="by">mparnisari</span><span>|</span><a href="#38009687">parent</a><span>|</span><a href="#38009984">prev</a><span>|</span><a href="#38009451">next</a><span>|</span><label class="collapse" for="c-38009699">[-]</label><label class="expand" for="c-38009699">[2 more]</label></div><br/><div class="children"><div class="content">I read it on kindle just fine</div><br/><div id="38010126" class="c"><input type="checkbox" id="c-38010126" checked=""/><div class="controls bullet"><span class="by">buzzwords</span><span>|</span><a href="#38009687">root</a><span>|</span><a href="#38009699">parent</a><span>|</span><a href="#38009451">next</a><span>|</span><label class="collapse" for="c-38010126">[-]</label><label class="expand" for="c-38010126">[1 more]</label></div><br/><div class="children"><div class="content">Thank you</div><br/></div></div></div></div></div></div><div id="38009451" class="c"><input type="checkbox" id="c-38009451" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38009687">prev</a><span>|</span><label class="collapse" for="c-38009451">[-]</label><label class="expand" for="c-38009451">[13 more]</label></div><br/><div class="children"><div class="content">An alternative viewpoint on software:<p><a href="https:&#x2F;&#x2F;www4.di.uminho.pt&#x2F;~jno&#x2F;ps&#x2F;pdbc.pdf" rel="nofollow noreferrer">https:&#x2F;&#x2F;www4.di.uminho.pt&#x2F;~jno&#x2F;ps&#x2F;pdbc.pdf</a><p>Rather then using blurry fuzzy concepts about software. This book is called &quot;Program design by calculation&quot;.<p>Which is to view software through the theoretical lens of math, science and engineering rather then &quot;philosophy&quot;.<p>Should software design be interpreted using the blurry and hand wavy concepts of philosophy and literature? or should it be theoretically laid out completely with all primitives formally specified like newtons laws of motion? Can we model software in a very formal way and come to make EXACT statements and conclusions about program design rather then a bunch of opinionated takes?<p>Unfortunately, like all hard sciences pdbc is much harder to understand then a &quot;philosophy&quot; so most people end up switching majors to philosophy.<p>Or Perhaps it&#x27;s not about the challenge... you just prefer the philosophical approach over the theoretical one. Your preference is very valid.<p>But to you I would ask: can you build a bridge, a car, or an airliner with philosophy? Or do you need hard formal theory and sciences? If we don&#x27;t have hard and formal theory about software design are we being limited in what we can build?</div><br/><div id="38010558" class="c"><input type="checkbox" id="c-38010558" checked=""/><div class="controls bullet"><span class="by">xoac</span><span>|</span><a href="#38009451">parent</a><span>|</span><a href="#38009696">next</a><span>|</span><label class="collapse" for="c-38010558">[-]</label><label class="expand" for="c-38010558">[1 more]</label></div><br/><div class="children"><div class="content">You seem to think that this is some sort of battle between the wordcels and the shape rotators or whatever, it&#x27;s not. Extremely smart people have been in these fields for thousands of years and they didn&#x27;t think that math and philosophy are opposites or in some tension. Even a cursory familiarity with the history of math and philo will reveal this.</div><br/></div></div><div id="38009696" class="c"><input type="checkbox" id="c-38009696" checked=""/><div class="controls bullet"><span class="by">lvturner</span><span>|</span><a href="#38009451">parent</a><span>|</span><a href="#38010558">prev</a><span>|</span><a href="#38010172">next</a><span>|</span><label class="collapse" for="c-38009696">[-]</label><label class="expand" for="c-38009696">[10 more]</label></div><br/><div class="children"><div class="content">Do the business requirements (fundamental assumptions around design to be more generic) of a bridge, car or airliner change dramatically over time?<p>I&#x27;d argue not.<p>Software design, in my opinion, is both a science and an art so my stance is that we need both the formal theory and science as well as the philosophy and that they shouldn&#x27;t be viewed as mutually exclusive.</div><br/><div id="38009932" class="c"><input type="checkbox" id="c-38009932" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38009696">parent</a><span>|</span><a href="#38009832">next</a><span>|</span><label class="collapse" for="c-38009932">[-]</label><label class="expand" for="c-38009932">[5 more]</label></div><br/><div class="children"><div class="content">Mathematics and science can both be viewed as very fleshed out and practical branches philosophy, so they certainly aren&#x27;t mutually exclusive.</div><br/><div id="38010042" class="c"><input type="checkbox" id="c-38010042" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38009932">parent</a><span>|</span><a href="#38009832">next</a><span>|</span><label class="collapse" for="c-38010042">[-]</label><label class="expand" for="c-38010042">[4 more]</label></div><br/><div class="children"><div class="content">Everything on the face of the earth falls under philosophy. It&#x27;s the biggest non-category ever.<p>I&#x27;m basically talking about &quot;philosophy&quot; the way the book uses the word. Which in short is just the authors opinionated take on software masquerading as something a bit more &quot;official&quot; then just an opinion. I mean would you call your own opinions on software design a &quot;philosophy&quot;?</div><br/><div id="38010055" class="c"><input type="checkbox" id="c-38010055" checked=""/><div class="controls bullet"><span class="by">ludston</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38010042">parent</a><span>|</span><a href="#38009832">next</a><span>|</span><label class="collapse" for="c-38010055">[-]</label><label class="expand" for="c-38010055">[3 more]</label></div><br/><div class="children"><div class="content">Yes probably. The only real difference between an opinion and a philosophy are the number of people that believe it.</div><br/><div id="38010438" class="c"><input type="checkbox" id="c-38010438" checked=""/><div class="controls bullet"><span class="by">xoac</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38010055">parent</a><span>|</span><a href="#38010098">next</a><span>|</span><label class="collapse" for="c-38010438">[-]</label><label class="expand" for="c-38010438">[1 more]</label></div><br/><div class="children"><div class="content">You can only have this take if you know absolutely nothing about philosophy.</div><br/></div></div><div id="38010098" class="c"><input type="checkbox" id="c-38010098" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38010055">parent</a><span>|</span><a href="#38010438">prev</a><span>|</span><a href="#38009832">next</a><span>|</span><label class="collapse" for="c-38010098">[-]</label><label class="expand" for="c-38010098">[1 more]</label></div><br/><div class="children"><div class="content">Right, what about &quot;formal theory&quot;? Let&#x27;s say number theory? That&#x27;s a concept independent of belief. And that&#x27;s the difference I&#x27;m getting at here.</div><br/></div></div></div></div></div></div></div></div><div id="38009832" class="c"><input type="checkbox" id="c-38009832" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38009696">parent</a><span>|</span><a href="#38009932">prev</a><span>|</span><a href="#38010172">next</a><span>|</span><label class="collapse" for="c-38009832">[-]</label><label class="expand" for="c-38009832">[4 more]</label></div><br/><div class="children"><div class="content">&gt;Software design, in my opinion, is both a science and an art so my stance is that we need both the formal theory and science as well as the philosophy and that they shouldn&#x27;t be viewed as mutually exclusive.<p>What formal theory have you ever used for designing your software? I would argue you&#x27;ve never used anything. Every abstraction you&#x27;ve ever made was likely a gut feeling, an instinct or following some vague hand wavy rule of thumb.<p>At best we use type theory for type correctness and complexity theory to calculate efficiency. That&#x27;s basically as far as it goes with &quot;theory&quot; and these two things aren&#x27;t even about &quot;software design&quot;.<p>Software design in practice as most engineers use it today is, practically speaking (key phrase), 100% art. Sometimes people come up with big fancy words like &quot;dependency injection&quot; or stupid Acronyms like SOLID to create the illusion of formal theory, but these things are nothing of the sort. It&#x27;s just tips and tricks.<p>The plane, the car, the bridge? Those things use both design and formal theory... software design as most engineers use it, again, does not use ANY formal theory, it&#x27;s almost just purely design all the way down.</div><br/><div id="38009973" class="c"><input type="checkbox" id="c-38009973" checked=""/><div class="controls bullet"><span class="by">lvturner</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38009832">parent</a><span>|</span><a href="#38010172">next</a><span>|</span><label class="collapse" for="c-38009973">[-]</label><label class="expand" for="c-38009973">[3 more]</label></div><br/><div class="children"><div class="content">Just because it doesn&#x27;t use formal theory now --- does not mean it&#x2F;we shouldn&#x27;t use it. I&#x27;m talking about needs, not haves.</div><br/><div id="38010082" class="c"><input type="checkbox" id="c-38010082" checked=""/><div class="controls bullet"><span class="by">corethree</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38009973">parent</a><span>|</span><a href="#38010172">next</a><span>|</span><label class="collapse" for="c-38010082">[-]</label><label class="expand" for="c-38010082">[2 more]</label></div><br/><div class="children"><div class="content">Well in all other engineering fields although they are used in conjunction. The two concepts are practically more or less mutually exclusive. There&#x27;s no room for &quot;design&quot; when finding the shortest distance between two points because the shortest distance between two points is done via calculation using formal theory.<p>Things like user-friendliness can be &quot;philosophical&quot;. You can separately and selectively apply theory and design where applicable, but they cannot in actuality be unionized in some unholy grafting.<p>I would say for the topic at hand; Of how to organize and abstract your code, if we ever find a complete formal theory for that, much of design will go out the window and what&#x27;s left is mostly a calculation.</div><br/><div id="38010185" class="c"><input type="checkbox" id="c-38010185" checked=""/><div class="controls bullet"><span class="by">lvturner</span><span>|</span><a href="#38009451">root</a><span>|</span><a href="#38010082">parent</a><span>|</span><a href="#38010172">next</a><span>|</span><label class="collapse" for="c-38010185">[-]</label><label class="expand" for="c-38010185">[1 more]</label></div><br/><div class="children"><div class="content">I see what you are driving at and I think we are looking at the problem from slightly different lenses yet still drawing much the same conclusions.<p>There&#x27;s no room for design in finding the shortest distance between two points, but there is room for design in picking which points you wish to find the distance on -- I think perhaps for meaningful discussion on this specific topic my definition of &quot;Software Design&quot; is too broad-scope ;)</div><br/></div></div></div></div></div></div></div></div></div></div><div id="38010172" class="c"><input type="checkbox" id="c-38010172" checked=""/><div class="controls bullet"><span class="by">auggierose</span><span>|</span><a href="#38009451">parent</a><span>|</span><a href="#38009696">prev</a><span>|</span><label class="collapse" for="c-38010172">[-]</label><label class="expand" for="c-38010172">[1 more]</label></div><br/><div class="children"><div class="content">That book has its very own philosophy, in particular that &quot;pointfree&quot; (pointless?) programming is a good thing. No, it isn&#x27;t.</div><br/></div></div></div></div></div></div></div></div></div></body></html>