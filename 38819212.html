<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1704013264123" as="style"/><link rel="stylesheet" href="styles.css?v=1704013264123"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://lips.js.org/">LIPS: Scheme based Lisp interpreter in JavaScript</a> <span class="domain">(<a href="https://lips.js.org">lips.js.org</a>)</span></div><div class="subtext"><span>aragonite</span> | <span>24 comments</span></div><br/><div><div id="38819737" class="c"><input type="checkbox" id="c-38819737" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#38819732">next</a><span>|</span><label class="collapse" for="c-38819737">[-]</label><label class="expand" for="c-38819737">[18 more]</label></div><br/><div class="children"><div class="content">Looks great, however note that it doesn&#x27;t do tail calls, which are required on conforming implementations.</div><br/><div id="38820328" class="c"><input type="checkbox" id="c-38820328" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#38819737">parent</a><span>|</span><a href="#38820405">next</a><span>|</span><label class="collapse" for="c-38820328">[-]</label><label class="expand" for="c-38820328">[2 more]</label></div><br/><div class="children"><div class="content">I suspect it does tail calls on Safari as Safari is the ONLY browser to completely implement ES6+ and implement proper tail calls (I&#x27;d note that it&#x27;s not the only ES6+ compliant implementation, but most of the rest are aimed at microcontrollers or embedding).</div><br/><div id="38820523" class="c"><input type="checkbox" id="c-38820523" checked=""/><div class="controls bullet"><span class="by">lvncelot</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820328">parent</a><span>|</span><a href="#38820405">next</a><span>|</span><label class="collapse" for="c-38820523">[-]</label><label class="expand" for="c-38820523">[1 more]</label></div><br/><div class="children"><div class="content">Huh, that in turn means that - server-side or for scripts - this should run better on Bun than on Node (or Deno), because Bun is based on JavaScriptCore and actually handles taill call optimization well[1]<p>[1] <a href="https:&#x2F;&#x2F;www.onsclom.net&#x2F;posts&#x2F;javascript-tco" rel="nofollow">https:&#x2F;&#x2F;www.onsclom.net&#x2F;posts&#x2F;javascript-tco</a></div><br/></div></div></div></div><div id="38820405" class="c"><input type="checkbox" id="c-38820405" checked=""/><div class="controls bullet"><span class="by">cfiggers</span><span>|</span><a href="#38819737">parent</a><span>|</span><a href="#38820328">prev</a><span>|</span><a href="#38820296">next</a><span>|</span><label class="collapse" for="c-38820405">[-]</label><label class="expand" for="c-38820405">[6 more]</label></div><br/><div class="children"><div class="content">I might be confused, but do you mean &quot;it doesn&#x27;t do tail call <i>optimization</i>&quot;? &quot;Doing tail calls&quot; is a bit of a strange phrase, if I understand the concept of what a tail call is—I&#x27;m under the impression that a tail call is just a call, that happens to be the final action in its scope. If a language can do &quot;calls&quot; at all then it can &quot;do tail calls.&quot;</div><br/><div id="38820489" class="c"><input type="checkbox" id="c-38820489" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820405">parent</a><span>|</span><a href="#38820697">next</a><span>|</span><label class="collapse" for="c-38820489">[-]</label><label class="expand" for="c-38820489">[2 more]</label></div><br/><div class="children"><div class="content">Yes, you&#x27;re correct about the more general meaning. But in the Scheme world &quot;doing tail calls&quot; means something like being &quot;properly tail recursive&quot; (see <a href="https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;manual&#x2F;html_node&#x2F;Tail-Calls.html" rel="nofollow">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;guile&#x2F;manual&#x2F;html_node&#x2F;Tail-Cal...</a> for more details). It&#x27;s not appropriate to call it an optimization because it&#x27;s a foundational property of the language.</div><br/><div id="38820835" class="c"><input type="checkbox" id="c-38820835" checked=""/><div class="controls bullet"><span class="by">cfiggers</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820489">parent</a><span>|</span><a href="#38820697">next</a><span>|</span><label class="collapse" for="c-38820835">[-]</label><label class="expand" for="c-38820835">[1 more]</label></div><br/><div class="children"><div class="content">Got it. Thanks for giving more of the language-specific context on that.</div><br/></div></div></div></div><div id="38820697" class="c"><input type="checkbox" id="c-38820697" checked=""/><div class="controls bullet"><span class="by">kryptiskt</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820405">parent</a><span>|</span><a href="#38820489">prev</a><span>|</span><a href="#38822447">next</a><span>|</span><label class="collapse" for="c-38820697">[-]</label><label class="expand" for="c-38820697">[2 more]</label></div><br/><div class="children"><div class="content">It&#x27;s best to call it &quot;Tail Call Elimination&quot;. It&#x27;s not a nice-to-have optimization in Scheme as using tail calls is the only way to iterate (<i>do</i> is a convenience built on tail calls), it&#x27;s a necessity for any non-toy Scheme implementation.</div><br/><div id="38822462" class="c"><input type="checkbox" id="c-38822462" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820697">parent</a><span>|</span><a href="#38822447">next</a><span>|</span><label class="collapse" for="c-38822462">[-]</label><label class="expand" for="c-38822462">[1 more]</label></div><br/><div class="children"><div class="content">Tail call elimination isn&#x27;t a very good term.<p>- The only optimization that completely eliminates calls is inlining, so it is misleading. An optimized tail call still has some trappings of a call, like a control transfer somewhere else, with arguments.<p>- In Scheme lingo, the procedure calls so optimized are called tail calls; they are <i>produced</i>, and thus not eliminated. When the goto is taken, the procedure is said to be making a tail call, or tail calling. In assembly language, if you hand coded such a goto, you might put in a comment saying &quot;this is a tail call&quot;, so it&#x27;s not just Scheme lingo.</div><br/></div></div></div></div><div id="38822447" class="c"><input type="checkbox" id="c-38822447" checked=""/><div class="controls bullet"><span class="by">kazinator</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820405">parent</a><span>|</span><a href="#38820697">prev</a><span>|</span><a href="#38820296">next</a><span>|</span><label class="collapse" for="c-38822447">[-]</label><label class="expand" for="c-38822447">[1 more]</label></div><br/><div class="children"><div class="content">In Scheme slang, a tail call is a procedure call that has been turned into a kind of goto, and so doesn&#x27;t require a new stack frame or return linkage.<p>The term &quot;tail call optimization&quot; still makes sense, but refers to the <i>production</i> of tail calls out procedure calls that occur in the tail position, not to the <i>reduction&#x2F;elimination</i> of tail calls.</div><br/></div></div></div></div><div id="38820296" class="c"><input type="checkbox" id="c-38820296" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#38819737">parent</a><span>|</span><a href="#38820405">prev</a><span>|</span><a href="#38820382">next</a><span>|</span><label class="collapse" for="c-38820296">[-]</label><label class="expand" for="c-38820296">[4 more]</label></div><br/><div class="children"><div class="content">Sorry, I don&#x27;t quite understand what you mean by &#x27;doesn&#x27;t do tail calls&#x27;, I tried the stupid fib and it ran fine (well, okay, slowly but fine). Does it translate to JS and depend on the implementation to provide tail call optimisation&#x2F;elimination?</div><br/><div id="38820515" class="c"><input type="checkbox" id="c-38820515" checked=""/><div class="controls bullet"><span class="by">sctb</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820296">parent</a><span>|</span><a href="#38820317">next</a><span>|</span><label class="collapse" for="c-38820515">[-]</label><label class="expand" for="c-38820515">[1 more]</label></div><br/><div class="children"><div class="content">Apparently this is a tree-walking interpreter, so JavaScript&#x27;s handling of tail calls is not directly relevant.</div><br/></div></div><div id="38820317" class="c"><input type="checkbox" id="c-38820317" checked=""/><div class="controls bullet"><span class="by">ckcheng</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820296">parent</a><span>|</span><a href="#38820515">prev</a><span>|</span><a href="#38820382">next</a><span>|</span><label class="collapse" for="c-38820317">[-]</label><label class="expand" for="c-38820317">[2 more]</label></div><br/><div class="children"><div class="content">Curious, did you run it in Safari on Mac?</div><br/><div id="38821131" class="c"><input type="checkbox" id="c-38821131" checked=""/><div class="controls bullet"><span class="by">tmtvl</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820317">parent</a><span>|</span><a href="#38820382">next</a><span>|</span><label class="collapse" for="c-38821131">[-]</label><label class="expand" for="c-38821131">[1 more]</label></div><br/><div class="children"><div class="content">Ew, no, I ran it on Firefox on LineageOS.</div><br/></div></div></div></div></div></div><div id="38820382" class="c"><input type="checkbox" id="c-38820382" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38819737">parent</a><span>|</span><a href="#38820296">prev</a><span>|</span><a href="#38819732">next</a><span>|</span><label class="collapse" for="c-38820382">[-]</label><label class="expand" for="c-38820382">[5 more]</label></div><br/><div class="children"><div class="content">Seems like TCO is is hard to do in browser JS, that&#x27;s surprising. It&#x27;s kind of a deal killer for basing a functional language on. JVM too for that matter.</div><br/><div id="38821223" class="c"><input type="checkbox" id="c-38821223" checked=""/><div class="controls bullet"><span class="by">hajile</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820382">parent</a><span>|</span><a href="#38820436">next</a><span>|</span><label class="collapse" for="c-38821223">[-]</label><label class="expand" for="c-38821223">[2 more]</label></div><br/><div class="children"><div class="content">Not hard at all. Chrome had it implemented, removed it, then added it back, but only for WASM.<p>They disliked that it didn&#x27;t leave stack frames in some cases.<p>Apple refused to break the JS backward-compatibility guarantee and implemented as-per the spec and Chrome refused to turn on their implementation for users unless it added a special keyword to identify it as a tail call.<p>Chrome dev&#x27;s emotional investment and resulting stubbornness has split the JS community and made their implementation incompatible with the spec. They are 100% in the wrong here.</div><br/><div id="38822491" class="c"><input type="checkbox" id="c-38822491" checked=""/><div class="controls bullet"><span class="by">baq</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38821223">parent</a><span>|</span><a href="#38820436">next</a><span>|</span><label class="collapse" for="c-38822491">[-]</label><label class="expand" for="c-38822491">[1 more]</label></div><br/><div class="children"><div class="content">In the meantime on the backend we’re looking at stack traces cut apart with trampolines and living with it…</div><br/></div></div></div></div><div id="38820436" class="c"><input type="checkbox" id="c-38820436" checked=""/><div class="controls bullet"><span class="by">gleenn</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820382">parent</a><span>|</span><a href="#38821223">prev</a><span>|</span><a href="#38819732">next</a><span>|</span><label class="collapse" for="c-38820436">[-]</label><label class="expand" for="c-38820436">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m sorry you are so attached to implementation details but that hardly detracts from the general usability of a language. Clojure is hosted both on the JVM and JavaScript and is, all things considered, both usable and popular enough of a Lisp and it definitely doesn&#x27;t have TCO. You can bail out to using &quot;loop&quot; if you&#x27;re that perf sensitive.</div><br/><div id="38820900" class="c"><input type="checkbox" id="c-38820900" checked=""/><div class="controls bullet"><span class="by">imglorp</span><span>|</span><a href="#38819737">root</a><span>|</span><a href="#38820436">parent</a><span>|</span><a href="#38819732">next</a><span>|</span><label class="collapse" for="c-38820900">[-]</label><label class="expand" for="c-38820900">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not an implementation detail if you can&#x27;t do recursion in constant stack space. The underlying VM should allow all CS primitives, and the guest can add constraints as it wants.</div><br/></div></div></div></div></div></div></div></div><div id="38819732" class="c"><input type="checkbox" id="c-38819732" checked=""/><div class="controls bullet"><span class="by">feeley</span><span>|</span><a href="#38819737">prev</a><span>|</span><a href="#38819786">next</a><span>|</span><label class="collapse" for="c-38819732">[-]</label><label class="expand" for="c-38819732">[2 more]</label></div><br/><div class="children"><div class="content">How does it compare to <a href="https:&#x2F;&#x2F;try.gambitscheme.org" rel="nofollow">https:&#x2F;&#x2F;try.gambitscheme.org</a> ?</div><br/></div></div><div id="38820169" class="c"><input type="checkbox" id="c-38820169" checked=""/><div class="controls bullet"><span class="by">it</span><span>|</span><a href="#38819786">prev</a><span>|</span><a href="#38821039">next</a><span>|</span><label class="collapse" for="c-38820169">[-]</label><label class="expand" for="c-38820169">[1 more]</label></div><br/><div class="children"><div class="content">I like the idea, but got this when I tried to run it on my Mac:<p>&gt; lips
node:internal&#x2F;modules&#x2F;esm&#x2F;resolve:853
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), null);</div><br/></div></div><div id="38821039" class="c"><input type="checkbox" id="c-38821039" checked=""/><div class="controls bullet"><span class="by">elwell</span><span>|</span><a href="#38820169">prev</a><span>|</span><label class="collapse" for="c-38821039">[-]</label><label class="expand" for="c-38821039">[1 more]</label></div><br/><div class="children"><div class="content">I like ClojureScript.</div><br/></div></div></div></div></div></div></div></body></html>