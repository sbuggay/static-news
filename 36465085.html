<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1687683650533" as="style"/><link rel="stylesheet" href="styles.css?v=1687683650533"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://xeiaso.net/blog/nosleep">Time is not a synchronization primitive</a> <span class="domain">(<a href="https://xeiaso.net">xeiaso.net</a>)</span></div><div class="subtext"><span>todsacerdoti</span> | <span>24 comments</span></div><br/><div><div id="36465418" class="c"><input type="checkbox" id="c-36465418" checked=""/><div class="controls bullet"><span class="by">pmontra</span><span>|</span><a href="#36465413">next</a><span>|</span><label class="collapse" for="c-36465418">[-]</label><label class="expand" for="c-36465418">[2 more]</label></div><br/><div class="children"><div class="content">I agree that it is no synchronization primitive and that even if it was, it&#x27;s very fragile. However I found it in nearly every project I worked on, in backend tests, frontend tests and even in integration tests where the library driving the browser should take care of waiting for elements to appear on screen. Modals and browser dialogs are particularly good at breaking stuff.<p>The dynamic is: developers write the the test and it usually works on their machines. If it does not there is a chance that they figure out what&#x27;s wrong and  rewrite it in the proper way. Tests often work locally, where the CPU and disk are nearly 100% available to run them. Sometimes they fail on CI systems. Developers scratch their heads and attempt the easy fix of adding a sleep of 1 second. That almosts always work and it took 5 minutes, code, commit, test run. They know that it stinks but they have stuff to do. Every few months somebody attempts to remove some of those sleeps with mixed and often unsuccessful results. Integration tests are particularly nasty.</div><br/><div id="36466179" class="c"><input type="checkbox" id="c-36466179" checked=""/><div class="controls bullet"><span class="by">lionkor</span><span>|</span><a href="#36465418">parent</a><span>|</span><a href="#36465413">next</a><span>|</span><label class="collapse" for="c-36466179">[-]</label><label class="expand" for="c-36466179">[1 more]</label></div><br/><div class="children"><div class="content">and thus you end up with slow software</div><br/></div></div></div></div><div id="36465413" class="c"><input type="checkbox" id="c-36465413" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#36465418">prev</a><span>|</span><a href="#36465420">next</a><span>|</span><label class="collapse" for="c-36465413">[-]</label><label class="expand" for="c-36465413">[9 more]</label></div><br/><div class="children"><div class="content">Did a devops elective last semester; I was surprised to hear that sleeping to wait for the system to come up was &quot;common in the industry&quot;. 30 seconds was the magic number, which was somehow always either mostly a waste or not enough when I tried to use it.<p>For similar reasons, we similarly can&#x27;t keep making sleep-sort faster by scaling the sleeps down.</div><br/><div id="36466165" class="c"><input type="checkbox" id="c-36466165" checked=""/><div class="controls bullet"><span class="by">bandrami</span><span>|</span><a href="#36465413">parent</a><span>|</span><a href="#36465459">next</a><span>|</span><label class="collapse" for="c-36466165">[-]</label><label class="expand" for="c-36466165">[1 more]</label></div><br/><div class="children"><div class="content">This bleeds into the Init Wars (sorrows, prayers), but there was this idea for a while that every service was going to be directly queryable by the run control system so that there would never be a need for magic sleep numbers. The result fell rather short of the ideal (particularly on the teardown side of things) but it did at least help admins get a firmer handle on exactly <i>where</i> we were (and still are, for the most part) using magic waits of &quot;long enough&quot;.</div><br/></div></div><div id="36465459" class="c"><input type="checkbox" id="c-36465459" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#36465413">parent</a><span>|</span><a href="#36466165">prev</a><span>|</span><a href="#36465582">next</a><span>|</span><label class="collapse" for="c-36465459">[-]</label><label class="expand" for="c-36465459">[4 more]</label></div><br/><div class="children"><div class="content">Sleeping on error is a valid pattern when combined with retries. Consider if that would be a long-starting external process that sets up the listener (or even a remote server spinning up). I.e. something we have no control over and that has no ability to signal us it&#x27;s ready. In such case, sleeping a little then trying to connect (and repeating) would be simple, effective and economical solution.</div><br/><div id="36465559" class="c"><input type="checkbox" id="c-36465559" checked=""/><div class="controls bullet"><span class="by">mindcrime</span><span>|</span><a href="#36465413">root</a><span>|</span><a href="#36465459">parent</a><span>|</span><a href="#36466004">next</a><span>|</span><label class="collapse" for="c-36465559">[-]</label><label class="expand" for="c-36465559">[1 more]</label></div><br/><div class="children"><div class="content"><i>Sleeping on error is a valid pattern when combined with retries.</i><p>Agreed. Just note that it can sometimes (often?) be a good idea to add a small stochastic element to the sleep time, and&#x2F;or do something similar to the exponential back-off[1] approach that Ethernet (among other things) uses.<p>[1]: <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exponential_backoff" rel="nofollow noreferrer">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exponential_backoff</a></div><br/></div></div><div id="36466004" class="c"><input type="checkbox" id="c-36466004" checked=""/><div class="controls bullet"><span class="by">hayley-patton</span><span>|</span><a href="#36465413">root</a><span>|</span><a href="#36465459">parent</a><span>|</span><a href="#36465559">prev</a><span>|</span><a href="#36465582">next</a><span>|</span><label class="collapse" for="c-36466004">[-]</label><label class="expand" for="c-36466004">[2 more]</label></div><br/><div class="children"><div class="content">That was &quot;more sophisticated&quot; and I was given a sample script without a loop. (I got Terraform to wait in a retry loop, which was apparently too complex.)</div><br/><div id="36466021" class="c"><input type="checkbox" id="c-36466021" checked=""/><div class="controls bullet"><span class="by">xena</span><span>|</span><a href="#36465413">root</a><span>|</span><a href="#36466004">parent</a><span>|</span><a href="#36465582">next</a><span>|</span><label class="collapse" for="c-36466021">[-]</label><label class="expand" for="c-36466021">[1 more]</label></div><br/><div class="children"><div class="content">Yeah for the record I&#x27;m not talking about delay loops, I&#x27;m talking about hardcoded sleeps in test code that cause random failures when unspoken invariants change. DevOps is a unique blend of hellfire that is almost unfair to compare to everything else in the industry. I&#x27;m glad I don&#x27;t work in DevOps anymore.</div><br/></div></div></div></div></div></div><div id="36465582" class="c"><input type="checkbox" id="c-36465582" checked=""/><div class="controls bullet"><span class="by">FireBeyond</span><span>|</span><a href="#36465413">parent</a><span>|</span><a href="#36465459">prev</a><span>|</span><a href="#36465555">next</a><span>|</span><label class="collapse" for="c-36465582">[-]</label><label class="expand" for="c-36465582">[2 more]</label></div><br/><div class="children"><div class="content">I ended up writing a function that would sleep and retry according to the Fibonacci sequence up to a given total elapsed time, so you could set it to a max timeout of 60s, for example, but if the system came up in 8 seconds, you&#x27;d be waiting not much longer than that (11 seconds, technically).</div><br/><div id="36465606" class="c"><input type="checkbox" id="c-36465606" checked=""/><div class="controls bullet"><span class="by">wiml</span><span>|</span><a href="#36465413">root</a><span>|</span><a href="#36465582">parent</a><span>|</span><a href="#36465555">next</a><span>|</span><label class="collapse" for="c-36465606">[-]</label><label class="expand" for="c-36465606">[1 more]</label></div><br/><div class="children"><div class="content">I do this too occasionally — Fibonacci is easy to implement, and it&#x27;s an exponential backoff (with a lower exponent than 2, which is also easy to implement ;) )</div><br/></div></div></div></div><div id="36465555" class="c"><input type="checkbox" id="c-36465555" checked=""/><div class="controls bullet"><span class="by">bheadmaster</span><span>|</span><a href="#36465413">parent</a><span>|</span><a href="#36465582">prev</a><span>|</span><a href="#36465420">next</a><span>|</span><label class="collapse" for="c-36465555">[-]</label><label class="expand" for="c-36465555">[1 more]</label></div><br/><div class="children"><div class="content">&gt; we similarly can&#x27;t keep making sleep-sort faster by scaling the sleeps down.<p>Technically, we can, at least to a certain limit - as long as the total time needed to schedule the sleeps is less than the shortest sleep duration, sleepsort will still work. Though we&#x27;re just offloading the sorting to the scheduler, which has to implement the sorting algorithm anyway...</div><br/></div></div></div></div><div id="36465420" class="c"><input type="checkbox" id="c-36465420" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#36465413">prev</a><span>|</span><a href="#36465484">next</a><span>|</span><label class="collapse" for="c-36465420">[-]</label><label class="expand" for="c-36465420">[3 more]</label></div><br/><div class="children"><div class="content">It&#x27;s a weird example, because it moves listener creation elsewhere, which is not always possible (e.g. consider if the goroutine would be spawning an external program instead of setting up the listener of its own).<p>Go has excellent primitive for this, a channel:<p><pre><code>    &#x2F;&#x2F; Setup a channel. We&#x27;ll send one and only one messsage over it, then close it.
    &#x2F;&#x2F; The message will be either an error (if something went wrong)
    &#x2F;&#x2F; or nil, if everything is fine and we can proceed.
    ready := make(chan error)

    go func() {
        &#x2F;&#x2F; No matter how this goroutine exits, when it exits the channel will be closed
        defer close(ready)

        &#x2F;&#x2F; Do whatever we must: open a socket, run a subprocess, or something else
        lis, err := net.Listen(...)
        if err != nil {
            &#x2F;&#x2F; Let it be known we&#x27;ve failed
            ready &lt;- err
            return
        }
        defer lis.Close()

        &#x2F;&#x2F; Announce the &quot;parent&quot; goroutine we&#x27;re ready, without errors
        ready &lt;- nil
        ...
    }()

    &#x2F;&#x2F; Here, we block and wait for our &quot;child&quot; goroutine to tell
    &#x2F;&#x2F; us something or at least die and close the socket.
    &#x2F;&#x2F; You can extend this and e.g. use `select` if you want to implement a timeout
    err, ok := &lt;-ready
    if err != nil {
        return fmt.Errorf(&quot;failed to start listener goroutine: %w&quot;, err)
    } else if !ok {
        return errors.New(&quot;listener goroutine died unexpectedly&quot;)
    }
</code></pre>
If there are multiple tasks and the case is not complex, then use sync.WaitGroup to count the children and a shared variable to convey the error status.</div><br/><div id="36465488" class="c"><input type="checkbox" id="c-36465488" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#36465420">parent</a><span>|</span><a href="#36465484">next</a><span>|</span><label class="collapse" for="c-36465488">[-]</label><label class="expand" for="c-36465488">[2 more]</label></div><br/><div class="children"><div class="content">Multiple languages have channels, I’m not sure why people only discuss this in terms of Go.<p>.NET and Rust are the first two I can name off the top of my head.</div><br/><div id="36465497" class="c"><input type="checkbox" id="c-36465497" checked=""/><div class="controls bullet"><span class="by">drdaeman</span><span>|</span><a href="#36465420">root</a><span>|</span><a href="#36465488">parent</a><span>|</span><a href="#36465484">next</a><span>|</span><label class="collapse" for="c-36465497">[-]</label><label class="expand" for="c-36465497">[1 more]</label></div><br/><div class="children"><div class="content">True. Go just puts them in a spotlight, recommending them as <i>the</i> synchronization primitive for many use cases.</div><br/></div></div></div></div></div></div><div id="36465484" class="c"><input type="checkbox" id="c-36465484" checked=""/><div class="controls bullet"><span class="by">lloydatkinson</span><span>|</span><a href="#36465420">prev</a><span>|</span><a href="#36465851">next</a><span>|</span><label class="collapse" for="c-36465484">[-]</label><label class="expand" for="c-36465484">[8 more]</label></div><br/><div class="children"><div class="content">The weird anime furry conversation thing is weirdly off putting.</div><br/><div id="36465684" class="c"><input type="checkbox" id="c-36465684" checked=""/><div class="controls bullet"><span class="by">burnished</span><span>|</span><a href="#36465484">parent</a><span>|</span><a href="#36465514">next</a><span>|</span><label class="collapse" for="c-36465684">[-]</label><label class="expand" for="c-36465684">[1 more]</label></div><br/><div class="children"><div class="content">Yeah its weird, but the author consistently produces well polished and effective documents. You see that sort of conversational technique used in other places to great effect so the odd bit really is just the furry stickers part.<p>And I guess I feel that we should be accepting of a little weirdness as an audience, especially considering the quality? I don&#x27;t have that idea all figured out but the two concepts feel related.</div><br/></div></div><div id="36465514" class="c"><input type="checkbox" id="c-36465514" checked=""/><div class="controls bullet"><span class="by">becquerel</span><span>|</span><a href="#36465484">parent</a><span>|</span><a href="#36465684">prev</a><span>|</span><a href="#36465986">next</a><span>|</span><label class="collapse" for="c-36465514">[-]</label><label class="expand" for="c-36465514">[2 more]</label></div><br/><div class="children"><div class="content">Conversely, it makes me trust the author&#x27;s expertise deeply. Our industry would be nowhere without furries.</div><br/><div id="36465625" class="c"><input type="checkbox" id="c-36465625" checked=""/><div class="controls bullet"><span class="by">sk0g</span><span>|</span><a href="#36465484">root</a><span>|</span><a href="#36465514">parent</a><span>|</span><a href="#36465986">next</a><span>|</span><label class="collapse" for="c-36465625">[-]</label><label class="expand" for="c-36465625">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t know about the industry as a whole, but at least the (early) Rust community evangelism seemed to have a lot of them involved.</div><br/></div></div></div></div><div id="36465986" class="c"><input type="checkbox" id="c-36465986" checked=""/><div class="controls bullet"><span class="by">protomolecule</span><span>|</span><a href="#36465484">parent</a><span>|</span><a href="#36465514">prev</a><span>|</span><a href="#36465839">next</a><span>|</span><label class="collapse" for="c-36465986">[-]</label><label class="expand" for="c-36465986">[1 more]</label></div><br/><div class="children"><div class="content">The &quot;I see, thanks&quot; part definitely is.</div><br/></div></div></div></div><div id="36465851" class="c"><input type="checkbox" id="c-36465851" checked=""/><div class="controls bullet"><span class="by">sakras</span><span>|</span><a href="#36465484">prev</a><span>|</span><label class="collapse" for="c-36465851">[-]</label><label class="expand" for="c-36465851">[1 more]</label></div><br/><div class="children"><div class="content">The implementers of Google Spanner would like to have a word!</div><br/></div></div></div></div></div></div></div></body></html>