<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1712653274363" as="style"/><link rel="stylesheet" href="styles.css?v=1712653274363"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://kerkour.com/distributed-sqlite">Distributed SQLite: Paradigm shift or hype?</a> <span class="domain">(<a href="https://kerkour.com">kerkour.com</a>)</span></div><div class="subtext"><span>mooreds</span> | <span>84 comments</span></div><br/><div><div id="39976236" class="c"><input type="checkbox" id="c-39976236" checked=""/><div class="controls bullet"><span class="by">benbjohnson</span><span>|</span><a href="#39977459">next</a><span>|</span><label class="collapse" for="c-39976236">[-]</label><label class="expand" for="c-39976236">[5 more]</label></div><br/><div class="children"><div class="content">LiteFS author here. I don&#x27;t disagree with any points in the article but perhaps a reframing could help. I previously wrote a tool called Litestream that would do disaster recovery for a single-node SQLite server and I still think it&#x27;s a great default option for people starting new projects. Unless you&#x27;re doing very database-specific things, most SQL will carry over between SQLite and Postgres and MySQL, especially if you add ORMs in the mix. Pick the one that gets you writing code the fastest and you can switch down the road if you need it.<p>Rather than a paradigm shift or hype, I see distributed SQLite as an extension of a path that devs can go down. With Litestream, the most common complaint I got was that devs were worried that they couldn&#x27;t horizontally scale with SQLite and they&#x27;d be stuck. While you probably won&#x27;t hit vertical scaling limits of SQLite on most projects, it still caused concern. So LiteFS became a &quot;next step&quot; that a dev could take if they ever got to that point. It doesn&#x27;t need to be your starting point.<p>As for the &quot;hacky&quot; solution of txid, I&#x27;m not sure why that&#x27;s hacky. Your application isn&#x27;t required to use it or the optional built-in proxy but it&#x27;s available if it fits your application&#x27;s needs. It also works for plugging legacy applications into distributed SQLite without retrofitting the code. The proposed solution of caching seems orthogonal to the discussion of distributed application data. I don&#x27;t think any database provider would suggest to avoid caching when it&#x27;s appropriate but there&#x27;s plenty of downsides of caching. Hell, it&#x27;s one of the two hardest problems in computer science.</div><br/><div id="39976909" class="c"><input type="checkbox" id="c-39976909" checked=""/><div class="controls bullet"><span class="by">TheCapeGreek</span><span>|</span><a href="#39976236">parent</a><span>|</span><a href="#39977459">next</a><span>|</span><label class="collapse" for="c-39976909">[-]</label><label class="expand" for="c-39976909">[4 more]</label></div><br/><div class="children"><div class="content">&gt;most SQL will carry over between SQLite and Postgres and MySQL, especially if you add ORMs in the mix<p>I think this goes underappreciated, or rather the opposite is overstated.<p>Sure there are some edge cases that don&#x27;t work the same, but most apps won&#x27;t hit those.<p>My _biggest_ gripe with SQLite so far is the lack of column reordering like other DBs. And my simplistic understanding is that the others do it exactly the same way as you&#x27;d do it manually with SQLite - table gets _replaced_ with an identical table with the data correctly ordered and the data is shoved into the new table.</div><br/><div id="39977049" class="c"><input type="checkbox" id="c-39977049" checked=""/><div class="controls bullet"><span class="by">dkjaudyeqooe</span><span>|</span><a href="#39976236">root</a><span>|</span><a href="#39976909">parent</a><span>|</span><a href="#39977459">next</a><span>|</span><label class="collapse" for="c-39977049">[-]</label><label class="expand" for="c-39977049">[3 more]</label></div><br/><div class="children"><div class="content">Why would you want to recorder columns? SQLite reads in a whole record at a time to access any column.</div><br/><div id="39977494" class="c"><input type="checkbox" id="c-39977494" checked=""/><div class="controls bullet"><span class="by">masklinn</span><span>|</span><a href="#39976236">root</a><span>|</span><a href="#39977049">parent</a><span>|</span><a href="#39977132">next</a><span>|</span><label class="collapse" for="c-39977494">[-]</label><label class="expand" for="c-39977494">[1 more]</label></div><br/><div class="children"><div class="content">Because as in structs padding slack can lead to a surprising amount of overhead.</div><br/></div></div><div id="39977132" class="c"><input type="checkbox" id="c-39977132" checked=""/><div class="controls bullet"><span class="by">anacrolix</span><span>|</span><a href="#39976236">root</a><span>|</span><a href="#39977049">parent</a><span>|</span><a href="#39977494">prev</a><span>|</span><a href="#39977459">next</a><span>|</span><label class="collapse" for="c-39977132">[-]</label><label class="expand" for="c-39977132">[1 more]</label></div><br/><div class="children"><div class="content">Not true.</div><br/></div></div></div></div></div></div></div></div><div id="39977459" class="c"><input type="checkbox" id="c-39977459" checked=""/><div class="controls bullet"><span class="by">datadeft</span><span>|</span><a href="#39976236">prev</a><span>|</span><a href="#39975852">next</a><span>|</span><label class="collapse" for="c-39977459">[-]</label><label class="expand" for="c-39977459">[1 more]</label></div><br/><div class="children"><div class="content">I think this is a false dichotomy to try to frame there is a Sqlite vs Postgres situation going on. Sqlite is amazing super fast single writer database without network service so it can be used locally as a library mostly while Postgres is a full fledged RDBMS. Both have use-cases that the given service is a better option and there are many other software products out there to be used for similar purposes.<p>Notable SQLite use cases: <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;famous.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;famous.html</a><p>Postgres does not have a similar page: <a href="https:&#x2F;&#x2F;www.postgresql.org&#x2F;about&#x2F;press&#x2F;faq&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.postgresql.org&#x2F;about&#x2F;press&#x2F;faq&#x2F;</a></div><br/></div></div><div id="39975852" class="c"><input type="checkbox" id="c-39975852" checked=""/><div class="controls bullet"><span class="by">zackify</span><span>|</span><a href="#39977459">prev</a><span>|</span><a href="#39977090">next</a><span>|</span><label class="collapse" for="c-39975852">[-]</label><label class="expand" for="c-39975852">[19 more]</label></div><br/><div class="children"><div class="content">I think this skips one mega benefit for apps.<p>I’ve been using liteFS in production for a couple months.<p>Your web app is able to resolve db queries instantly.<p>You don’t need loading states if you’re using complex charts and other frontend JS that waits for data.<p>All the data is resolved so fast and you can just return all your data like more traditional apps, and the load times are insane.<p>If you’re multi region you can deploy one app instance there. Instead of 2-3. Postgres read replica, maybe something like redis.<p>It really replaces both of those, assuming you have a read heavy app it works great.</div><br/><div id="39975904" class="c"><input type="checkbox" id="c-39975904" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#39975852">parent</a><span>|</span><a href="#39976976">next</a><span>|</span><label class="collapse" for="c-39975904">[-]</label><label class="expand" for="c-39975904">[13 more]</label></div><br/><div class="children"><div class="content">I think you always need loading states to account for slow network, or am I missing something?</div><br/><div id="39976470" class="c"><input type="checkbox" id="c-39976470" checked=""/><div class="controls bullet"><span class="by">LVB</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975904">parent</a><span>|</span><a href="#39975920">next</a><span>|</span><label class="collapse" for="c-39976470">[-]</label><label class="expand" for="c-39976470">[1 more]</label></div><br/><div class="children"><div class="content">&gt;to account for slow network<p>Or a slow anything else, e.g., SQLite queries. This thread has focused on the network aspects, and they do stand out since there can be such a large gap between a network call vs a local SSD read. But we&#x27;re still talking about a database, which could be huge (presumably it&#x27;s the main, single DB for the whole app). And there is still all of the actual SQLite work that needs to happen to execute a query, plus opportunities for really bad performance b&#x2F;c of bad queries, lack of indexes, all the usual suspects. Not to mention the load on the owning process itself. So, I&#x27;m agreeing that a loading state is needed.</div><br/></div></div><div id="39975920" class="c"><input type="checkbox" id="c-39975920" checked=""/><div class="controls bullet"><span class="by">datadrivenangel</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975904">parent</a><span>|</span><a href="#39976470">prev</a><span>|</span><a href="#39976976">next</a><span>|</span><label class="collapse" for="c-39975920">[-]</label><label class="expand" for="c-39975920">[11 more]</label></div><br/><div class="children"><div class="content">The SQLite database is located on the application server, so there is no network between the DB and the app.</div><br/><div id="39975930" class="c"><input type="checkbox" id="c-39975930" checked=""/><div class="controls bullet"><span class="by">shepherdjerred</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975920">parent</a><span>|</span><a href="#39976976">next</a><span>|</span><label class="collapse" for="c-39975930">[-]</label><label class="expand" for="c-39975930">[10 more]</label></div><br/><div class="children"><div class="content">Assuming you&#x27;re serving a frontend that makes network calls to a backend, you&#x27;ll need to handle loading states in the frontend regardless of how the backend retrieves its data.</div><br/><div id="39975935" class="c"><input type="checkbox" id="c-39975935" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975930">parent</a><span>|</span><a href="#39976976">next</a><span>|</span><label class="collapse" for="c-39975935">[-]</label><label class="expand" for="c-39975935">[9 more]</label></div><br/><div class="children"><div class="content">The idea is that you&#x27;re not doing that.</div><br/><div id="39975951" class="c"><input type="checkbox" id="c-39975951" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975935">parent</a><span>|</span><a href="#39976976">next</a><span>|</span><label class="collapse" for="c-39975951">[-]</label><label class="expand" for="c-39975951">[8 more]</label></div><br/><div class="children"><div class="content">Unless your database is in the browser, you are always going to be at mercy of network latencies talking to the backend.</div><br/><div id="39975956" class="c"><input type="checkbox" id="c-39975956" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975951">parent</a><span>|</span><a href="#39976676">next</a><span>|</span><label class="collapse" for="c-39975956">[-]</label><label class="expand" for="c-39975956">[6 more]</label></div><br/><div class="children"><div class="content">You&#x27;re just saying, even if all you were doing was fetching a static JSON blob from the memory of the frontend server, you&#x27;d still want load states, right? (That makes sense, I&#x27;m just checking my understanding.)</div><br/><div id="39975978" class="c"><input type="checkbox" id="c-39975978" checked=""/><div class="controls bullet"><span class="by">danappelxx</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975956">parent</a><span>|</span><a href="#39976676">next</a><span>|</span><label class="collapse" for="c-39975978">[-]</label><label class="expand" for="c-39975978">[5 more]</label></div><br/><div class="children"><div class="content">Yup, exactly. Phones change wifi networks, routers drop packets, load balancers get overloaded. Hard to fully eliminate tail latencies.</div><br/><div id="39976029" class="c"><input type="checkbox" id="c-39976029" checked=""/><div class="controls bullet"><span class="by">simonw</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975978">parent</a><span>|</span><a href="#39976676">next</a><span>|</span><label class="collapse" for="c-39976029">[-]</label><label class="expand" for="c-39976029">[4 more]</label></div><br/><div class="children"><div class="content">The key here is to make a single API call to the backend which then runs 100+ SQL queries at once and combines the results into a single JSON response - that way you&#x27;re only paying the network cost once.<p>See <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;np1queryprob.html" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;np1queryprob.html</a><p>I&#x27;ve implemented GraphQL on top of SQLite and found it to be an amazingly good match, because the biggest weakness of GraphQL is that it makes it easy to accidentally trigger 100s of queries in one request and with SQLite that really doesn&#x27;t matter.</div><br/><div id="39976155" class="c"><input type="checkbox" id="c-39976155" checked=""/><div class="controls bullet"><span class="by">willsmith72</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39976029">parent</a><span>|</span><a href="#39976556">next</a><span>|</span><label class="collapse" for="c-39976155">[-]</label><label class="expand" for="c-39976155">[2 more]</label></div><br/><div class="children"><div class="content">that doesn&#x27;t eliminate need for loading states at all, and is already solved by things like react server components or remix (see waterfall removal graphic <a href="https:&#x2F;&#x2F;remix.run&#x2F;" rel="nofollow">https:&#x2F;&#x2F;remix.run&#x2F;</a>)<p>i think this discussion is confusing the use of sqlite in local-first apps, where there&#x27;s no loading states because the database is in the browser. you can use sqlite on your server, but you still need a &quot;loading state&quot;.<p>even with postgres, if your data and server are colocated, the time between the 2 is already almost 0<p>now maybe the argument is your servers are deployed globally each with an sqlite db. that&#x27;s not all that different from global postgres read replicas</div><br/><div id="39976164" class="c"><input type="checkbox" id="c-39976164" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39976155">parent</a><span>|</span><a href="#39976556">next</a><span>|</span><label class="collapse" for="c-39976164">[-]</label><label class="expand" for="c-39976164">[1 more]</label></div><br/><div class="children"><div class="content">If the data and the server are colocated on the same machine, the database network overhead is almost zero. But that&#x27;s not necessarily true otherwise. For an HTTP request that incurs a single query, you can round it to zero, but you have to be careful not to write request handlers that incur lots of queries if you&#x27;re trying to stay below the 100ms threshold.</div><br/></div></div></div></div><div id="39976556" class="c"><input type="checkbox" id="c-39976556" checked=""/><div class="controls bullet"><span class="by">rapnie</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39976029">parent</a><span>|</span><a href="#39976155">prev</a><span>|</span><a href="#39976676">next</a><span>|</span><label class="collapse" for="c-39976556">[-]</label><label class="expand" for="c-39976556">[1 more]</label></div><br/><div class="children"><div class="content">&gt; I&#x27;ve implemented GraphQL on top of SQLite and found it to be an amazingly good match<p>Could you give a pointer to the repository, or is this part of Datasette?</div><br/></div></div></div></div></div></div></div></div><div id="39976676" class="c"><input type="checkbox" id="c-39976676" checked=""/><div class="controls bullet"><span class="by">az09mugen</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975951">parent</a><span>|</span><a href="#39975956">prev</a><span>|</span><a href="#39976976">next</a><span>|</span><label class="collapse" for="c-39976676">[-]</label><label class="expand" for="c-39976676">[1 more]</label></div><br/><div class="children"><div class="content">You can with sqlite in webassembly</div><br/></div></div></div></div></div></div></div></div></div></div></div></div><div id="39976976" class="c"><input type="checkbox" id="c-39976976" checked=""/><div class="controls bullet"><span class="by">boxed</span><span>|</span><a href="#39975852">parent</a><span>|</span><a href="#39975904">prev</a><span>|</span><a href="#39975899">next</a><span>|</span><label class="collapse" for="c-39976976">[-]</label><label class="expand" for="c-39976976">[2 more]</label></div><br/><div class="children"><div class="content">You can run postgres on the same host as the web server too. Isn&#x27;t that going to get you most of that same benefit in speed?</div><br/><div id="39977417" class="c"><input type="checkbox" id="c-39977417" checked=""/><div class="controls bullet"><span class="by">yurishimo</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39976976">parent</a><span>|</span><a href="#39975899">next</a><span>|</span><label class="collapse" for="c-39977417">[-]</label><label class="expand" for="c-39977417">[1 more]</label></div><br/><div class="children"><div class="content">It is. I do this on plenty of hobby Laravel apps.</div><br/></div></div></div></div><div id="39975899" class="c"><input type="checkbox" id="c-39975899" checked=""/><div class="controls bullet"><span class="by">bgdkbtv</span><span>|</span><a href="#39975852">parent</a><span>|</span><a href="#39976976">prev</a><span>|</span><a href="#39977090">next</a><span>|</span><label class="collapse" for="c-39975899">[-]</label><label class="expand" for="c-39975899">[3 more]</label></div><br/><div class="children"><div class="content">How is it for writes? Would a CRM type system benefit from liteFS setup?</div><br/><div id="39975943" class="c"><input type="checkbox" id="c-39975943" checked=""/><div class="controls bullet"><span class="by">thomasfromcdnjs</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975899">parent</a><span>|</span><a href="#39975957">next</a><span>|</span><label class="collapse" for="c-39975943">[-]</label><label class="expand" for="c-39975943">[1 more]</label></div><br/><div class="children"><div class="content">In Fly&#x27;s implementation;<p>&gt; LiteFS’ use of FUSE limits the write throughput to about 100 transactions per second so write-heavy applications may not be a good fit.<p><a href="https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;faq&#x2F;#what-are-the-tradeoffs-of-using-litefs">https:&#x2F;&#x2F;fly.io&#x2F;docs&#x2F;litefs&#x2F;faq&#x2F;#what-are-the-tradeoffs-of-us...</a></div><br/></div></div><div id="39975957" class="c"><input type="checkbox" id="c-39975957" checked=""/><div class="controls bullet"><span class="by">linsomniac</span><span>|</span><a href="#39975852">root</a><span>|</span><a href="#39975899">parent</a><span>|</span><a href="#39975943">prev</a><span>|</span><a href="#39977090">next</a><span>|</span><label class="collapse" for="c-39975957">[-]</label><label class="expand" for="c-39975957">[1 more]</label></div><br/><div class="children"><div class="content">The article says &quot;LiteFS supports roughly 100 writes per second&quot;.</div><br/></div></div></div></div></div></div><div id="39977090" class="c"><input type="checkbox" id="c-39977090" checked=""/><div class="controls bullet"><span class="by">samwillis</span><span>|</span><a href="#39975852">prev</a><span>|</span><a href="#39976966">next</a><span>|</span><label class="collapse" for="c-39977090">[-]</label><label class="expand" for="c-39977090">[2 more]</label></div><br/><div class="children"><div class="content">The paradigm shift that&#x27;s going to come with distributed SQLite isn&#x27;t to the edge, it&#x27;s going to be to users devices. I believe the DX of building Local-first apps is going to hit the criticality point in the next year or so and its popularity is going to explode.<p>With dynamic partial replication you can synchronise a subset of your database to a SQLite db on your users device, eliminating the network from the ui interaction loop. Then with the emerging eventually constant syncing systems, many using CRDTs, it&#x27;s possible to have conflict free eventual consistency. Just read and write to a local database and it will sync with your central server or other clients in the background, both in realtime or after working offline.<p>I work on one such system at ElectricSQL, but there are many people building variants of this such as Evolu, SQLsync, CR-SQLite, and PowerSync.<p>That&#x27;s all not to say SQLite on the edge isn&#x27;t really damn cool!</div><br/><div id="39977124" class="c"><input type="checkbox" id="c-39977124" checked=""/><div class="controls bullet"><span class="by">azeirah</span><span>|</span><a href="#39977090">parent</a><span>|</span><a href="#39976966">next</a><span>|</span><label class="collapse" for="c-39977124">[-]</label><label class="expand" for="c-39977124">[1 more]</label></div><br/><div class="children"><div class="content">All of this makes me think we&#x27;ll just be building meteor apps but with sqlite instead of mongo and minimongo whaha</div><br/></div></div></div></div><div id="39976966" class="c"><input type="checkbox" id="c-39976966" checked=""/><div class="controls bullet"><span class="by">tutfbhuf</span><span>|</span><a href="#39977090">prev</a><span>|</span><a href="#39977353">next</a><span>|</span><label class="collapse" for="c-39976966">[-]</label><label class="expand" for="c-39976966">[3 more]</label></div><br/><div class="children"><div class="content">We have so many distributed X applications nowadays that all try to solve the same problem, either in the same or different ways. I think we first have to come up with a simple, distributed, open-source storage solution. In the cloud, we have things like AWS S3, which is a very reliable distributed storage, but for self-hosting, we have:<p>Ceph, with which I have much experience, is a very solid and quite bulletproof storage solution that offers S3 protocol and FS. However, maintaining it in the long run is really challenging. You better become a Ceph expert.<p>SeaweedFS struggles with managing large data groups. It&#x27;s inspired by an outdated Facebook study (Haystack) and is intended for storing and sharing large images. However, I think it&#x27;s only average—it has poor documentation, underwhelming performance, and a confusing set of components to install. Its design allows each server process to use one big file for storage, bypassing slow file metadata operations. It offers various access points through gateways.<p>MinIO has evolved a lot recently, making it hard to evaluate. MinIO relies on many small databases. Currently, it&#x27;s phasing out some features, like the gateway, and mainly consists of two parts: a command line interface (CLI) and a server. While MinIO&#x27;s setup is complex, SeaweedFS&#x27;s setup is much simpler. MinIO also seems to be moving from an open-source model towards a more commercial one, but I have not closely followed this transition.<p>All of these solutions are not simple enough to be the base for a distributed database application. What we really need would be something like an Ext4 successor, let&#x27;s call it Ext5, with native distributed storage capabilities in the most dead-simple way. ZFS is another good candidate. ZFS has already solved the problem of how to distribute storage across multiple hard drives within one server very well, but it still lacks a good solution on how to distribute storage across different hard drives on different servers connected via a network.<p>Yes, I know there is the CAP theorem, so it is really a hard challenge to solve, but I think we can do better in terms of self-hosted solutions.</div><br/><div id="39977519" class="c"><input type="checkbox" id="c-39977519" checked=""/><div class="controls bullet"><span class="by">moritzruth</span><span>|</span><a href="#39976966">parent</a><span>|</span><a href="#39977075">next</a><span>|</span><label class="collapse" for="c-39977519">[-]</label><label class="expand" for="c-39977519">[1 more]</label></div><br/><div class="children"><div class="content">There is also <i>Garage</i>: <a href="https:&#x2F;&#x2F;garagehq.deuxfleurs.fr&#x2F;" rel="nofollow">https:&#x2F;&#x2F;garagehq.deuxfleurs.fr&#x2F;</a></div><br/></div></div><div id="39977075" class="c"><input type="checkbox" id="c-39977075" checked=""/><div class="controls bullet"><span class="by">dikei</span><span>|</span><a href="#39976966">parent</a><span>|</span><a href="#39977519">prev</a><span>|</span><a href="#39977353">next</a><span>|</span><label class="collapse" for="c-39977075">[-]</label><label class="expand" for="c-39977075">[1 more]</label></div><br/><div class="children"><div class="content">&gt; While MinIO&#x27;s setup is complex, SeaweedFS&#x27;s setup is much simpler.<p>Are you sure you are not talking in reverse?<p>I find Minio single binary deployment very easy, and you also complained about SeaweedFS&#x27;s complexity in the previous paragraph.</div><br/></div></div></div></div><div id="39977353" class="c"><input type="checkbox" id="c-39977353" checked=""/><div class="controls bullet"><span class="by">banish-m4</span><span>|</span><a href="#39976966">prev</a><span>|</span><a href="#39976900">next</a><span>|</span><label class="collapse" for="c-39977353">[-]</label><label class="expand" for="c-39977353">[1 more]</label></div><br/><div class="children"><div class="content">Don&#x27;t get caught up in marriage to a particular tech flavor. Instead, architect and use a generic db adapter pattern that translates a more generic SQL&#x2F;GraphQL flavor into whatever is necessary and efficient underneath for that particular DBMS or store. Meta does this for many warm storage services. It makes changing underlying DBMSes and scalability architectures much easier to develop and reason about than if every app has to know everything about its backend(s).</div><br/></div></div><div id="39976900" class="c"><input type="checkbox" id="c-39976900" checked=""/><div class="controls bullet"><span class="by">throwaway2037</span><span>|</span><a href="#39977353">prev</a><span>|</span><a href="#39975763">next</a><span>|</span><label class="collapse" for="c-39976900">[-]</label><label class="expand" for="c-39976900">[3 more]</label></div><br/><div class="children"><div class="content"><p><pre><code>    &gt; While SQLite is a really amazing database, most teams will benefit from avoiding it and going the PostgreSQL way instead.

    &gt; Bazillions of engineering hours have been spent to make Postgres the best backend database and choosing SQLite will inevitably force you to reinvent what Postgres already had for many years, in a fragile and buggy way.
</code></pre>
Could the same not also be said for MS SQL Server, Oracle, Sybase, MySQL, or MariaDB?  The author offers no supporting evidence for this statement.<p>Rewrite that: &quot;Bazillions of engineering hours have been spent to make XYZ the best backend database...&quot;</div><br/><div id="39977326" class="c"><input type="checkbox" id="c-39977326" checked=""/><div class="controls bullet"><span class="by">klysm</span><span>|</span><a href="#39976900">parent</a><span>|</span><a href="#39977442">next</a><span>|</span><label class="collapse" for="c-39977326">[-]</label><label class="expand" for="c-39977326">[1 more]</label></div><br/><div class="children"><div class="content">Without giving evidence, I do agree that Postgres is a better database that serves the general case better. I use both in production for different purposes, but postgresql makes a lot more sense then SQLite as our primary database</div><br/></div></div><div id="39977442" class="c"><input type="checkbox" id="c-39977442" checked=""/><div class="controls bullet"><span class="by">znpy</span><span>|</span><a href="#39976900">parent</a><span>|</span><a href="#39977326">prev</a><span>|</span><a href="#39975763">next</a><span>|</span><label class="collapse" for="c-39977442">[-]</label><label class="expand" for="c-39977442">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Rewrite that: &quot;Bazillions of engineering hours have been spent to make XYZ the best backend database...&quot;<p>What you&#x27;re saying (and what the author is saying) however is clashing with the reality of so many developers using sqlite and being happy with it.<p>I&#x27;d suggest to rewrite it another way:<p>&gt; Bazillion of developers think they&#x27;ll need a full-fledged database for their new project while sqlite will cover most of their needs.</div><br/></div></div></div></div><div id="39975763" class="c"><input type="checkbox" id="c-39975763" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39976900">prev</a><span>|</span><a href="#39975879">next</a><span>|</span><label class="collapse" for="c-39975763">[-]</label><label class="expand" for="c-39975763">[2 more]</label></div><br/><div class="children"><div class="content">This is kind of missing the point. I can only speak for the company that sponsors LiteFS (I don&#x27;t think any edge computing companies put &#x27;otoolep up to doing rqlite, for instance). We love Postgres. Most of our users use Postgres. And Postgres works fine in edge&#x2F;backhaul configurations; companies were doing geographically distributed Postgres read replicas long, long before we came around. That&#x27;s where we got the idea.<p>The idea of LiteFS is:<p>* Most apps are read-heavy, and some of them are overwhelmingly read-heavy.<p>* If you&#x27;re read-heavy and can thus get away with it, there&#x27;s a pretty significant performance win in replacing the networked n-tier architecture with SQLite, because Postgres round trips add up over the lifecycle of any given request.<p>* In fact, that&#x27;s so much the case that --- as Richard Hipp has been pointing out for over a decade --- you can blow off the N+1 problem and just write natural queries.<p>I think Ben Johnson would be the first to tell you that LiteFS isn&#x27;t a perfect fit for every application. We have systems that use both Postgres and LiteFS.<p>Meanwhile, you have to dig to find it on our web page! It&#x27;s an open source project that works everywhere Linux does. Dial back the cynicism a bit! :)<p>A plug here for:<p><a href="https:&#x2F;&#x2F;kerkour.com&#x2F;sqlite-for-servers" rel="nofollow">https:&#x2F;&#x2F;kerkour.com&#x2F;sqlite-for-servers</a><p>Same author, and one of the best SQLite articles ever.</div><br/><div id="39976166" class="c"><input type="checkbox" id="c-39976166" checked=""/><div class="controls bullet"><span class="by">codegangsta</span><span>|</span><a href="#39975763">parent</a><span>|</span><a href="#39975879">next</a><span>|</span><label class="collapse" for="c-39976166">[-]</label><label class="expand" for="c-39976166">[1 more]</label></div><br/><div class="children"><div class="content">Man! I can’t agree more. It does seem foreign right now, but I truly do believe edge computing will become another “CDN” type abstraction, but it will take time for folks to catch up.<p>Can’t wait for the day that projects like litefs are just a default that nobody knows about, lol.<p>Go from “technology nobody knows about” to “technology nobody knows about, but runs the world.”</div><br/></div></div></div></div><div id="39975879" class="c"><input type="checkbox" id="c-39975879" checked=""/><div class="controls bullet"><span class="by">icpmacdo</span><span>|</span><a href="#39975763">prev</a><span>|</span><a href="#39976207">next</a><span>|</span><label class="collapse" for="c-39975879">[-]</label><label class="expand" for="c-39975879">[1 more]</label></div><br/><div class="children"><div class="content">Among the various free backend hosting options currently available, does Cloudflare stand out as the best choice with its offerings such as Workers and D1? I would love to hear users experiences with these services or if there any informative resources that discuss the costs associated with scaling applications on the infra?</div><br/></div></div><div id="39976207" class="c"><input type="checkbox" id="c-39976207" checked=""/><div class="controls bullet"><span class="by">skybrian</span><span>|</span><a href="#39975879">prev</a><span>|</span><a href="#39975905">next</a><span>|</span><label class="collapse" for="c-39976207">[-]</label><label class="expand" for="c-39976207">[3 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t believe Cloudflare D1 has read replicas yet? They describe how it will work in detail in a blog post [1], but in the future tense.<p>&gt; We’re actively working on global read replication and realizing the above proposal (share feedback In the #d1 channel on our Developer Discord).<p>Perhaps it will be out by the time the book is finished.<p>[1] <a href="https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;building-d1-a-global-database" rel="nofollow">https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;building-d1-a-global-database</a></div><br/><div id="39976242" class="c"><input type="checkbox" id="c-39976242" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#39976207">parent</a><span>|</span><a href="#39975905">next</a><span>|</span><label class="collapse" for="c-39976242">[-]</label><label class="expand" for="c-39976242">[2 more]</label></div><br/><div class="children"><div class="content">D1 is still pretty limited in my experience. No read replicas really kills any of the meaningful benefit of the architecture, and being built off of a (mostly) SQLite-compliant API makes me nervous as it isn&#x27;t really SQLite at all.<p>Last year&#x27;s major Cloudflare outage really was the final straw for me with regards to D1. I don&#x27;t mean that as a knock at Cloudflare at all, the situation sounded horrible and I appreciate how the entire team responded to it. I just worry that internal responses to fundamental infrastructure issues will leave newer projects like D1 on ice for a year or two.</div><br/><div id="39976452" class="c"><input type="checkbox" id="c-39976452" checked=""/><div class="controls bullet"><span class="by">rozenmd</span><span>|</span><a href="#39976207">root</a><span>|</span><a href="#39976242">parent</a><span>|</span><a href="#39975905">next</a><span>|</span><label class="collapse" for="c-39976452">[-]</label><label class="expand" for="c-39976452">[1 more]</label></div><br/><div class="children"><div class="content">D1 (the ability to query your database at the edge) didn&#x27;t get knocked offline during that outage though?</div><br/></div></div></div></div></div></div><div id="39975905" class="c"><input type="checkbox" id="c-39975905" checked=""/><div class="controls bullet"><span class="by">galaxyLogic</span><span>|</span><a href="#39976207">prev</a><span>|</span><a href="#39976825">next</a><span>|</span><label class="collapse" for="c-39975905">[-]</label><label class="expand" for="c-39975905">[3 more]</label></div><br/><div class="children"><div class="content">What portion of writes typically have to go to the primary server? If users are local then their data maybe is often local as well.  In other words not all writes need to first go the central server from where they are distributed back to all edge-databases.<p>I can see that the organization running the application needs a global view of all data. But regional users perhaps don&#x27;t. Often they just need to know their own data.<p>Write first to edge then copy to central database rather than write first to central database then trickle down to the site from where the write originated in. Just wondering what portion of applications could use this alternative design.</div><br/><div id="39976231" class="c"><input type="checkbox" id="c-39976231" checked=""/><div class="controls bullet"><span class="by">rmbyrro</span><span>|</span><a href="#39975905">parent</a><span>|</span><a href="#39976533">next</a><span>|</span><label class="collapse" for="c-39976231">[-]</label><label class="expand" for="c-39976231">[1 more]</label></div><br/><div class="children"><div class="content">This could work in very small projects. Still very risky.<p>Say you flag a write as &quot;local&quot;. Later, some other place in your app starts relying on this write in another locality. If you don&#x27;t update your write spec from &quot;local&quot; to &quot;primary&quot;, you don&#x27;t have a consistent database anymore, but you will make decisions thinking that you do.<p>Now consider a team of 10. Or 20...<p>Mayhem can spiral very quickly from there.</div><br/></div></div><div id="39976533" class="c"><input type="checkbox" id="c-39976533" checked=""/><div class="controls bullet"><span class="by">znkr</span><span>|</span><a href="#39975905">parent</a><span>|</span><a href="#39976231">prev</a><span>|</span><a href="#39976825">next</a><span>|</span><label class="collapse" for="c-39976533">[-]</label><label class="expand" for="c-39976533">[1 more]</label></div><br/><div class="children"><div class="content">It’s been done and it becomes quite complicated very quickly. Then it becomes necessary to manage that complexity and you end up with something like Spanner.</div><br/></div></div></div></div><div id="39976825" class="c"><input type="checkbox" id="c-39976825" checked=""/><div class="controls bullet"><span class="by">infogulch</span><span>|</span><a href="#39975905">prev</a><span>|</span><a href="#39976948">next</a><span>|</span><label class="collapse" for="c-39976825">[-]</label><label class="expand" for="c-39976825">[1 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re willing to accept eventual consistency (a big ask, but acceptable in some scenarios) then there are options like marmot [1] that replicate cdc over nats.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;maxpert&#x2F;marmot">https:&#x2F;&#x2F;github.com&#x2F;maxpert&#x2F;marmot</a></div><br/></div></div><div id="39976948" class="c"><input type="checkbox" id="c-39976948" checked=""/><div class="controls bullet"><span class="by">superhx</span><span>|</span><a href="#39976825">prev</a><span>|</span><a href="#39976464">next</a><span>|</span><label class="collapse" for="c-39976948">[-]</label><label class="expand" for="c-39976948">[1 more]</label></div><br/><div class="children"><div class="content">Is there a distributed version of SQLite that keeps its embedded library feature? For example, it could use EBS and S3 for shared storage, allowing for distributed read and write access, and possibly even multiple concurrent reads and writes.<p>Should this be available, numerous lightweight web applications could operate without having to set up a separate PostgreSQL or MySQL database.</div><br/></div></div><div id="39976464" class="c"><input type="checkbox" id="c-39976464" checked=""/><div class="controls bullet"><span class="by">internetter</span><span>|</span><a href="#39976948">prev</a><span>|</span><a href="#39975981">next</a><span>|</span><label class="collapse" for="c-39976464">[-]</label><label class="expand" for="c-39976464">[5 more]</label></div><br/><div class="children"><div class="content">Something I&#x27;ve been thinking about is partitioning my SQLite. Instead of storing all user&#x27;s data in one mega table, what if I made a SQLite database for each user? Provided users never talk to each other, I think this might work?</div><br/><div id="39976475" class="c"><input type="checkbox" id="c-39976475" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39976464">parent</a><span>|</span><a href="#39976747">next</a><span>|</span><label class="collapse" for="c-39976475">[-]</label><label class="expand" for="c-39976475">[1 more]</label></div><br/><div class="children"><div class="content">You can attach to databases dynamically in queries and join across them. I probably wouldn&#x27;t (in an ordinary data model) do per-user, but I would consider it for different functional areas.</div><br/></div></div><div id="39976747" class="c"><input type="checkbox" id="c-39976747" checked=""/><div class="controls bullet"><span class="by">config_yml</span><span>|</span><a href="#39976464">parent</a><span>|</span><a href="#39976475">prev</a><span>|</span><a href="#39976655">next</a><span>|</span><label class="collapse" for="c-39976747">[-]</label><label class="expand" for="c-39976747">[1 more]</label></div><br/><div class="children"><div class="content">You can slice it and dice it any way you want, really. The constraint is often what data needs to be written within a transaction. You&#x27;ll have to figure our a way to reliably apply a consistent schema to all these database files somehow and keep track of them.</div><br/></div></div><div id="39976655" class="c"><input type="checkbox" id="c-39976655" checked=""/><div class="controls bullet"><span class="by">sorenbs</span><span>|</span><a href="#39976464">parent</a><span>|</span><a href="#39976747">prev</a><span>|</span><a href="#39976535">next</a><span>|</span><label class="collapse" for="c-39976655">[-]</label><label class="expand" for="c-39976655">[1 more]</label></div><br/><div class="children"><div class="content">This setup can work great and even support elements that are shared between users, if you also give those elements their own DB. I’m working on a prototype to support this natively in Prisma.</div><br/></div></div><div id="39976535" class="c"><input type="checkbox" id="c-39976535" checked=""/><div class="controls bullet"><span class="by">danr4</span><span>|</span><a href="#39976464">parent</a><span>|</span><a href="#39976655">prev</a><span>|</span><a href="#39975981">next</a><span>|</span><label class="collapse" for="c-39976535">[-]</label><label class="expand" for="c-39976535">[1 more]</label></div><br/><div class="children"><div class="content">I believe this is what one of the companies mentioned in the article, Turso, can help you do. a per-tenant database.</div><br/></div></div></div></div><div id="39975981" class="c"><input type="checkbox" id="c-39975981" checked=""/><div class="controls bullet"><span class="by">geenat</span><span>|</span><a href="#39976464">prev</a><span>|</span><a href="#39975618">next</a><span>|</span><label class="collapse" for="c-39975981">[-]</label><label class="expand" for="c-39975981">[3 more]</label></div><br/><div class="children"><div class="content">WAL2 + BEGIN CONCURRENT<p>...to pretty much eliminate write contention. I know, it sucks these aren&#x27;t built in yet.<p>Also if we got some sort of router + map reduce helper (Vitess, Citus -like) it&#x27;d make massively distributed SQLite a lot more viable. Setups that don&#x27;t hammer a single master would make all the difference.<p>Postgres&#x27; main disadvantage at scale is all the additional machinery required (backups, failover, proxy, no DDL replication with built-in logical replication .... UGH!!), even when you&#x27;re using Citus. Feels like it forces you into k8s with the amount of orchestration you need to run.</div><br/><div id="39976050" class="c"><input type="checkbox" id="c-39976050" checked=""/><div class="controls bullet"><span class="by">raggi</span><span>|</span><a href="#39975981">parent</a><span>|</span><a href="#39975618">next</a><span>|</span><label class="collapse" for="c-39976050">[-]</label><label class="expand" for="c-39976050">[2 more]</label></div><br/><div class="children"><div class="content">this does not eliminate write contention, it just moves a bunch of the problem into the application as now you have to resolve conflicts yourself</div><br/><div id="39976098" class="c"><input type="checkbox" id="c-39976098" checked=""/><div class="controls bullet"><span class="by">alberth</span><span>|</span><a href="#39975981">root</a><span>|</span><a href="#39976050">parent</a><span>|</span><a href="#39975618">next</a><span>|</span><label class="collapse" for="c-39976098">[-]</label><label class="expand" for="c-39976098">[1 more]</label></div><br/><div class="children"><div class="content">&gt; just moves a bunch of the problem into the application<p>Would you mind elaborating</div><br/></div></div></div></div></div></div><div id="39975618" class="c"><input type="checkbox" id="c-39975618" checked=""/><div class="controls bullet"><span class="by">west0n</span><span>|</span><a href="#39975981">prev</a><span>|</span><a href="#39975991">next</a><span>|</span><label class="collapse" for="c-39975618">[-]</label><label class="expand" for="c-39975618">[1 more]</label></div><br/><div class="children"><div class="content">See some development frameworks for local-first apps support both SQLite and PostgreSQL. The advantage of using PostgreSQL is that when you add a cloud option to your local-first app, the migration becomes much easier.</div><br/></div></div><div id="39975991" class="c"><input type="checkbox" id="c-39975991" checked=""/><div class="controls bullet"><span class="by">xray2</span><span>|</span><a href="#39975618">prev</a><span>|</span><a href="#39976175">next</a><span>|</span><label class="collapse" for="c-39975991">[-]</label><label class="expand" for="c-39975991">[4 more]</label></div><br/><div class="children"><div class="content">Most apps never need to scale. Also, worried about scaling? Just use an ORM that allows you to switch from SQLite to Postgres. It’s as simple as that.</div><br/><div id="39976587" class="c"><input type="checkbox" id="c-39976587" checked=""/><div class="controls bullet"><span class="by">mind-blight</span><span>|</span><a href="#39975991">parent</a><span>|</span><a href="#39976175">next</a><span>|</span><label class="collapse" for="c-39976587">[-]</label><label class="expand" for="c-39976587">[3 more]</label></div><br/><div class="children"><div class="content">Unless your using database specific features. One of the biggest advantages for Postgres is how incredible the ecosystem is. It doesn&#x27;t work for everything, but I have an OEM, multiple kinds of text search (vector, inverted indexes, trigrams), recursive and graph-like queries (though that&#x27;s admittedly less of an issue if n+1 isn&#x27;t a problem), row-level acls, locks, etc.<p>It&#x27;s really nice to have all of that power available in one piece of infrastructure.</div><br/><div id="39976709" class="c"><input type="checkbox" id="c-39976709" checked=""/><div class="controls bullet"><span class="by">victorbjorklund</span><span>|</span><a href="#39975991">root</a><span>|</span><a href="#39976587">parent</a><span>|</span><a href="#39976175">next</a><span>|</span><label class="collapse" for="c-39976709">[-]</label><label class="expand" for="c-39976709">[2 more]</label></div><br/><div class="children"><div class="content">Not really a problem if you go from sqlite to postgres. Which sqlite feature is missing from
Postgres?</div><br/><div id="39977233" class="c"><input type="checkbox" id="c-39977233" checked=""/><div class="controls bullet"><span class="by">cnity</span><span>|</span><a href="#39975991">root</a><span>|</span><a href="#39976709">parent</a><span>|</span><a href="#39976175">next</a><span>|</span><label class="collapse" for="c-39977233">[-]</label><label class="expand" for="c-39977233">[1 more]</label></div><br/><div class="children"><div class="content">This is saying: &quot;just don&#x27;t try to solve hard data storage problems&quot;. Not all applications are CRUD.</div><br/></div></div></div></div></div></div></div></div><div id="39976175" class="c"><input type="checkbox" id="c-39976175" checked=""/><div class="controls bullet"><span class="by">emmanueloga_</span><span>|</span><a href="#39975991">prev</a><span>|</span><a href="#39976601">next</a><span>|</span><label class="collapse" for="c-39976175">[-]</label><label class="expand" for="c-39976175">[1 more]</label></div><br/><div class="children"><div class="content">Also I think sqlite would not be a good fit if any sort of slow workers &#x2F; background jobs are required.</div><br/></div></div><div id="39976601" class="c"><input type="checkbox" id="c-39976601" checked=""/><div class="controls bullet"><span class="by">nurettin</span><span>|</span><a href="#39976175">prev</a><span>|</span><a href="#39975778">next</a><span>|</span><label class="collapse" for="c-39976601">[-]</label><label class="expand" for="c-39976601">[1 more]</label></div><br/><div class="children"><div class="content">The only way I know for doing concurrent writes in sqlite is to open a transaction, accumulate a bunch of writes and then commit them. Otherwise it is dog slow. And it has to be a single process, or you get data corruption. Has this changed somehow?</div><br/></div></div><div id="39975778" class="c"><input type="checkbox" id="c-39975778" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39976601">prev</a><span>|</span><a href="#39976058">next</a><span>|</span><label class="collapse" for="c-39975778">[-]</label><label class="expand" for="c-39975778">[10 more]</label></div><br/><div class="children"><div class="content">this page just says &#x27;Forbidden&#x27;</div><br/><div id="39976307" class="c"><input type="checkbox" id="c-39976307" checked=""/><div class="controls bullet"><span class="by">runlaszlorun</span><span>|</span><a href="#39975778">parent</a><span>|</span><a href="#39975980">next</a><span>|</span><label class="collapse" for="c-39976307">[-]</label><label class="expand" for="c-39976307">[1 more]</label></div><br/><div class="children"><div class="content">not workinf for me currently either. i’m on safari&#x2F;ios.</div><br/></div></div><div id="39975980" class="c"><input type="checkbox" id="c-39975980" checked=""/><div class="controls bullet"><span class="by">evgpbfhnr</span><span>|</span><a href="#39975778">parent</a><span>|</span><a href="#39976307">prev</a><span>|</span><a href="#39975780">next</a><span>|</span><label class="collapse" for="c-39975980">[-]</label><label class="expand" for="c-39975980">[3 more]</label></div><br/><div class="children"><div class="content">Yeah, says Forbidden in firefox or curl but loads in chromium - welcome to the open web of browser interoperability etc etc where servers now just decide your user agent or tls handshake or whatever is fishy.</div><br/><div id="39976150" class="c"><input type="checkbox" id="c-39976150" checked=""/><div class="controls bullet"><span class="by">MobiusHorizons</span><span>|</span><a href="#39975778">root</a><span>|</span><a href="#39975980">parent</a><span>|</span><a href="#39976015">next</a><span>|</span><label class="collapse" for="c-39976150">[-]</label><label class="expand" for="c-39976150">[1 more]</label></div><br/><div class="children"><div class="content">also doesn&#x27;t work on desktop safari for me</div><br/></div></div><div id="39976015" class="c"><input type="checkbox" id="c-39976015" checked=""/><div class="controls bullet"><span class="by">kragen</span><span>|</span><a href="#39975778">root</a><span>|</span><a href="#39975980">parent</a><span>|</span><a href="#39976150">prev</a><span>|</span><a href="#39975780">next</a><span>|</span><label class="collapse" for="c-39976015">[-]</label><label class="expand" for="c-39976015">[1 more]</label></div><br/><div class="children"><div class="content">thank you!</div><br/></div></div></div></div><div id="39975780" class="c"><input type="checkbox" id="c-39975780" checked=""/><div class="controls bullet"><span class="by">tptacek</span><span>|</span><a href="#39975778">parent</a><span>|</span><a href="#39975980">prev</a><span>|</span><a href="#39976058">next</a><span>|</span><label class="collapse" for="c-39975780">[-]</label><label class="expand" for="c-39975780">[5 more]</label></div><br/><div class="children"><div class="content">I updated Chrome and reloaded.</div><br/></div></div></div></div><div id="39976058" class="c"><input type="checkbox" id="c-39976058" checked=""/><div class="controls bullet"><span class="by">russellbeattie</span><span>|</span><a href="#39975778">prev</a><span>|</span><a href="#39976261">next</a><span>|</span><label class="collapse" for="c-39976058">[-]</label><label class="expand" for="c-39976058">[3 more]</label></div><br/><div class="children"><div class="content">I wonder if SQLite will ever be modified to allow concurrent writes. Right now it locks the whole DB on write [1]. But since SQLite usage is rapidly expanding from its embedded db roots, one has to wonder if the devs have considered creating some sort of SQLite daemon, or if the underlying architecture would have to be changed so drastically it wouldn&#x27;t be worth it.<p>1. <a href="https:&#x2F;&#x2F;www.sqlite.org&#x2F;faq.html#q5" rel="nofollow">https:&#x2F;&#x2F;www.sqlite.org&#x2F;faq.html#q5</a></div><br/><div id="39976764" class="c"><input type="checkbox" id="c-39976764" checked=""/><div class="controls bullet"><span class="by">feverzsj</span><span>|</span><a href="#39976058">parent</a><span>|</span><a href="#39976279">next</a><span>|</span><label class="collapse" for="c-39976764">[-]</label><label class="expand" for="c-39976764">[1 more]</label></div><br/><div class="children"><div class="content">In most SQL implementation, modification of row is table level locking anyway, so you can put tables in different sqlite db files and achieve same &quot;concurrent&quot; writes.</div><br/></div></div></div></div><div id="39976261" class="c"><input type="checkbox" id="c-39976261" checked=""/><div class="controls bullet"><span class="by">_heimdall</span><span>|</span><a href="#39976058">prev</a><span>|</span><a href="#39975833">next</a><span>|</span><label class="collapse" for="c-39976261">[-]</label><label class="expand" for="c-39976261">[2 more]</label></div><br/><div class="children"><div class="content">SQLite is neither shift nor hype, its a misunderstanding of underlying architecture challenges.<p>SQLite has pros and cons, like anything else. When it comes to web frameworks and app platforms, to fundamental problem is that many committed fully to server less&#x2F;edge and ignored the los of persistent storage. You just can&#x27;t use a local database when using serverless, or any type of distributed compute&#x2F;rendering for that matter.<p>Databases are centralized by design, you can dodge some of that complexity with clever synchronization protocols but you are still limited to having a single primary DB at the end of the day.<p>For read-heavy use cases, tools like Turso can be invaluable. If database writes are more common, you&#x27;ll always be limited by network latency. More importantly for most modern web apps, whether you render HTML in the browser or a server you can&#x27;t avoid loading states. IMO you might as well lean on the platform and use server rendering whenever persistent state is involved.</div><br/></div></div><div id="39975833" class="c"><input type="checkbox" id="c-39975833" checked=""/><div class="controls bullet"><span class="by">geenat</span><span>|</span><a href="#39976261">prev</a><span>|</span><a href="#39976134">next</a><span>|</span><label class="collapse" for="c-39975833">[-]</label><label class="expand" for="c-39975833">[3 more]</label></div><br/><div class="children"><div class="content">&quot;Something went wrong! Try reloading the page. If the problem persists, please update your web browser to the latest version.&quot;<p>RIP website.<p>edit: it&#x27;s back</div><br/><div id="39975877" class="c"><input type="checkbox" id="c-39975877" checked=""/><div class="controls bullet"><span class="by">ec109685</span><span>|</span><a href="#39975833">parent</a><span>|</span><a href="#39975839">next</a><span>|</span><label class="collapse" for="c-39975877">[-]</label><label class="expand" for="c-39975877">[1 more]</label></div><br/><div class="children"><div class="content">Should have used SQLite.</div><br/></div></div></div></div><div id="39976134" class="c"><input type="checkbox" id="c-39976134" checked=""/><div class="controls bullet"><span class="by">throwaway458864</span><span>|</span><a href="#39975833">prev</a><span>|</span><a href="#39976414">next</a><span>|</span><label class="collapse" for="c-39976134">[-]</label><label class="expand" for="c-39976134">[2 more]</label></div><br/><div class="children"><div class="content">Something can be both hype and useful. Paradigm shift, no, because there&#x27;s no fundamental architectural difference from any other replicated sql database.<p>Sqlite only really works as a throwaway database. For that it&#x27;s pretty great. Although <i>a lot</i> of the current use cases for sqlite could have just been a .ini file.</div><br/></div></div><div id="39976414" class="c"><input type="checkbox" id="c-39976414" checked=""/><div class="controls bullet"><span class="by">Animats</span><span>|</span><a href="#39976134">prev</a><span>|</span><label class="collapse" for="c-39976414">[-]</label><label class="expand" for="c-39976414">[3 more]</label></div><br/><div class="children"><div class="content">SQLite is getting a lot heavier. This is becoming more like MySQL or Postgres.</div><br/><div id="39976446" class="c"><input type="checkbox" id="c-39976446" checked=""/><div class="controls bullet"><span class="by">internetter</span><span>|</span><a href="#39976414">parent</a><span>|</span><a href="#39976432">next</a><span>|</span><label class="collapse" for="c-39976446">[-]</label><label class="expand" for="c-39976446">[1 more]</label></div><br/><div class="children"><div class="content">No it&#x27;s not. SQLite is still the only &quot;serverless&quot; database of those three. Nothing has changed, aside from the companies selling variants of it, but that&#x27;s not SQLite&#x27;s fault</div><br/></div></div><div id="39976432" class="c"><input type="checkbox" id="c-39976432" checked=""/><div class="controls bullet"><span class="by">voidfunc</span><span>|</span><a href="#39976414">parent</a><span>|</span><a href="#39976446">prev</a><span>|</span><label class="collapse" for="c-39976432">[-]</label><label class="expand" for="c-39976432">[1 more]</label></div><br/><div class="children"><div class="content">The fate of all projects if they continue on long enough.</div><br/></div></div></div></div></div></div></div></div></div></body></html>