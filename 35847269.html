<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1683450053292" as="style"/><link rel="stylesheet" href="styles.css?v=1683450053292"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/RedisLabs/redisraft/blob/master/docs/Introduction.md">RedisRaft</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>anhldbk</span> | <span>21 comments</span></div><br/><div><div id="35848828" class="c"><input type="checkbox" id="c-35848828" checked=""/><div class="controls bullet"><span class="by">ruuda</span><span>|</span><a href="#35847707">next</a><span>|</span><label class="collapse" for="c-35848828">[-]</label><label class="expand" for="c-35848828">[2 more]</label></div><br/><div class="children"><div class="content">I would love to see a Jepsen test of this when it&#x27;s ready. The Redis Cluster evaluation [1] was a great read.<p>[1]: <a href="https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;283-jepsen-redis" rel="nofollow">https:&#x2F;&#x2F;aphyr.com&#x2F;posts&#x2F;283-jepsen-redis</a></div><br/><div id="35848855" class="c"><input type="checkbox" id="c-35848855" checked=""/><div class="controls bullet"><span class="by">danw1979</span><span>|</span><a href="#35848828">parent</a><span>|</span><a href="#35847707">next</a><span>|</span><label class="collapse" for="c-35848855">[-]</label><label class="expand" for="c-35848855">[1 more]</label></div><br/><div class="children"><div class="content">“What would Kyle have to say about this ?”  was the first thought that came to my mind.</div><br/></div></div></div></div><div id="35847707" class="c"><input type="checkbox" id="c-35847707" checked=""/><div class="controls bullet"><span class="by">TheDong</span><span>|</span><a href="#35848828">prev</a><span>|</span><a href="#35848927">next</a><span>|</span><label class="collapse" for="c-35847707">[-]</label><label class="expand" for="c-35847707">[2 more]</label></div><br/><div class="children"><div class="content">Linking to the introduction bypasses the prominent note in the readme:<p>&gt; RedisRaft is still being developed and is not yet ready for any real production use. Please do not use it for any mission critical purpose at this time.</div><br/><div id="35848885" class="c"><input type="checkbox" id="c-35848885" checked=""/><div class="controls bullet"><span class="by">noobdev9000</span><span>|</span><a href="#35847707">parent</a><span>|</span><a href="#35848927">next</a><span>|</span><label class="collapse" for="c-35848885">[-]</label><label class="expand" for="c-35848885">[1 more]</label></div><br/><div class="children"><div class="content">This is essentially a complete fabrication. If it&#x27;s on public repo, ready or not, someone will use it for prod.</div><br/></div></div></div></div><div id="35848927" class="c"><input type="checkbox" id="c-35848927" checked=""/><div class="controls bullet"><span class="by">jwr</span><span>|</span><a href="#35847707">prev</a><span>|</span><a href="#35848710">next</a><span>|</span><label class="collapse" for="c-35848927">[-]</label><label class="expand" for="c-35848927">[2 more]</label></div><br/><div class="children"><div class="content">A gentle reminder that FoundationDB exists and has this nailed down really well. They are just bad at marketing, so it&#x27;s not in fashion. But do check it out if you want a distributed database with strict serializable semantics, that works.</div><br/><div id="35849283" class="c"><input type="checkbox" id="c-35849283" checked=""/><div class="controls bullet"><span class="by">geenat</span><span>|</span><a href="#35848927">parent</a><span>|</span><a href="#35848710">next</a><span>|</span><label class="collapse" for="c-35849283">[-]</label><label class="expand" for="c-35849283">[1 more]</label></div><br/><div class="children"><div class="content">Strongly consistent FoundationDB = Likely similar write performance to CockroachDB or TiDB when you avoid secondary indexes.<p>Secondary indexes in &quot;distributed strongly consistent&quot; systems is what ruins performance: because each index is +1 write to another &quot;index table&quot; (... +1 raft quorum check!).<p>I don&#x27;t think FoundationDB has &quot;secondary indexes&quot; to begin with, so one may never run into the +1 write per index issue.. it&#x27;s just a layer on top of TiKV (equivalent to RocksDB in CockroachDB).</div><br/></div></div></div></div><div id="35848710" class="c"><input type="checkbox" id="c-35848710" checked=""/><div class="controls bullet"><span class="by">bullen</span><span>|</span><a href="#35848927">prev</a><span>|</span><a href="#35847894">next</a><span>|</span><label class="collapse" for="c-35848710">[-]</label><label class="expand" for="c-35848710">[1 more]</label></div><br/><div class="children"><div class="content">I made my own distributed JSON over HTTP database back in 2016.<p>It has been running in a intercontinental production environment with 100% read uptime since 2017.<p>It&#x27;s 2000 lines of code: <a href="http:&#x2F;&#x2F;root.rupy.se" rel="nofollow">http:&#x2F;&#x2F;root.rupy.se</a> (this test env. has 3 nodes: fem, six and sju)</div><br/></div></div><div id="35847894" class="c"><input type="checkbox" id="c-35847894" checked=""/><div class="controls bullet"><span class="by">361994752</span><span>|</span><a href="#35848710">prev</a><span>|</span><a href="#35848086">next</a><span>|</span><label class="collapse" for="c-35847894">[-]</label><label class="expand" for="c-35847894">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ve been watching this project for a long time. It was supposed to be released with Redis 7[1]. But I guess this is not true anymore. And there is no public roadmap saying when it will be production ready.<p>[1] <a href="https:&#x2F;&#x2F;www.zdnet.com&#x2F;article&#x2F;redis-labs-unveils-redis-database-7-0&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.zdnet.com&#x2F;article&#x2F;redis-labs-unveils-redis-datab...</a></div><br/></div></div><div id="35848086" class="c"><input type="checkbox" id="c-35848086" checked=""/><div class="controls bullet"><span class="by">solatic</span><span>|</span><a href="#35847894">prev</a><span>|</span><a href="#35848523">next</a><span>|</span><label class="collapse" for="c-35848086">[-]</label><label class="expand" for="c-35848086">[2 more]</label></div><br/><div class="children"><div class="content">Why choose this over etcd? Especially if it&#x27;s a limitation &#x2F; non-goal to support all Redis commands, or to respond with Redis-like quick performance? Why not go with the battle-hardened (it&#x27;s the backing datastore in Kubernetes), proven option?</div><br/><div id="35848160" class="c"><input type="checkbox" id="c-35848160" checked=""/><div class="controls bullet"><span class="by">kbumsik</span><span>|</span><a href="#35848086">parent</a><span>|</span><a href="#35848523">next</a><span>|</span><label class="collapse" for="c-35848160">[-]</label><label class="expand" for="c-35848160">[1 more]</label></div><br/><div class="children"><div class="content">I am not sure neither. But this might overcome the etcd&#x27;s soft storage limit of 8GB? [1]<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;etcd-io&#x2F;etcd&#x2F;issues&#x2F;9771">https:&#x2F;&#x2F;github.com&#x2F;etcd-io&#x2F;etcd&#x2F;issues&#x2F;9771</a></div><br/></div></div></div></div><div id="35848523" class="c"><input type="checkbox" id="c-35848523" checked=""/><div class="controls bullet"><span class="by">Cardinal7167</span><span>|</span><a href="#35848086">prev</a><span>|</span><a href="#35848806">next</a><span>|</span><label class="collapse" for="c-35848523">[-]</label><label class="expand" for="c-35848523">[1 more]</label></div><br/><div class="children"><div class="content">But raft isn’t strongly consistent, it has known liveness issues.<p><a href="https:&#x2F;&#x2F;decentralizedthoughts.github.io&#x2F;2020-12-12-raft-liveness-full-omission&#x2F;" rel="nofollow">https:&#x2F;&#x2F;decentralizedthoughts.github.io&#x2F;2020-12-12-raft-live...</a></div><br/></div></div><div id="35848806" class="c"><input type="checkbox" id="c-35848806" checked=""/><div class="controls bullet"><span class="by">decide1000</span><span>|</span><a href="#35848523">prev</a><span>|</span><a href="#35848865">next</a><span>|</span><label class="collapse" for="c-35848806">[-]</label><label class="expand" for="c-35848806">[3 more]</label></div><br/><div class="children"><div class="content">I am looking at KeyDB and consider to use it as replacement of Redis. Besides some speed improvements it has good looking replication and cluster solutions. <a href="https:&#x2F;&#x2F;docs.keydb.dev&#x2F;docs&#x2F;cluster-spec" rel="nofollow">https:&#x2F;&#x2F;docs.keydb.dev&#x2F;docs&#x2F;cluster-spec</a></div><br/><div id="35848826" class="c"><input type="checkbox" id="c-35848826" checked=""/><div class="controls bullet"><span class="by">Simpliplant</span><span>|</span><a href="#35848806">parent</a><span>|</span><a href="#35848865">next</a><span>|</span><label class="collapse" for="c-35848826">[-]</label><label class="expand" for="c-35848826">[2 more]</label></div><br/><div class="children"><div class="content">We thought the same and deployed KeyDB to production as a replacement for big Redis deployment (200+ GB memory) and we ran into many unpleasent issues with it - very high replication latency, instability, random crashes, memory leaks, etc. So I&#x27;d advise you to do thorough testing before you use it in production.</div><br/><div id="35848876" class="c"><input type="checkbox" id="c-35848876" checked=""/><div class="controls bullet"><span class="by">decide1000</span><span>|</span><a href="#35848806">root</a><span>|</span><a href="#35848826">parent</a><span>|</span><a href="#35848865">next</a><span>|</span><label class="collapse" for="c-35848876">[-]</label><label class="expand" for="c-35848876">[1 more]</label></div><br/><div class="children"><div class="content">We start tests in the coming week. Current memory of Redis use is about 70gb. Thanks a lot for your comment. I hope to create a stable KeyDB environment as it would solve some of our problems we have with Redis replication. The issues you describe sound scary.</div><br/></div></div></div></div></div></div><div id="35848865" class="c"><input type="checkbox" id="c-35848865" checked=""/><div class="controls bullet"><span class="by">geenat</span><span>|</span><a href="#35848806">prev</a><span>|</span><a href="#35847708">next</a><span>|</span><label class="collapse" for="c-35848865">[-]</label><label class="expand" for="c-35848865">[1 more]</label></div><br/><div class="children"><div class="content">Game changer if you can turn raft checks on&#x2F;off on a per-query basis, like scylladb &#x2F; cassandra.</div><br/></div></div><div id="35847708" class="c"><input type="checkbox" id="c-35847708" checked=""/><div class="controls bullet"><span class="by">mperham</span><span>|</span><a href="#35848865">prev</a><span>|</span><a href="#35848250">next</a><span>|</span><label class="collapse" for="c-35847708">[-]</label><label class="expand" for="c-35847708">[4 more]</label></div><br/><div class="children"><div class="content">AWS’ new MemoryDB also seems to be a strongly consistent Redis cluster service. Anyone know how they compare?<p><a href="https:&#x2F;&#x2F;aws.amazon.com&#x2F;memorydb&#x2F;features&#x2F;" rel="nofollow">https:&#x2F;&#x2F;aws.amazon.com&#x2F;memorydb&#x2F;features&#x2F;</a></div><br/><div id="35847995" class="c"><input type="checkbox" id="c-35847995" checked=""/><div class="controls bullet"><span class="by">kbumsik</span><span>|</span><a href="#35847708">parent</a><span>|</span><a href="#35848026">next</a><span>|</span><label class="collapse" for="c-35847995">[-]</label><label class="expand" for="c-35847995">[1 more]</label></div><br/><div class="children"><div class="content">MemoryDB has a single node (primary node) strong consistency.<p>MemoryDB seems to have a very similar architecture to that of AWS Aurora, which separates a storage layer and compute nodes and consistency is implemented not by communicating between compute nodes but by offering a consistent distributed storage layer. This architecture usually don&#x27;t have a multi-node strong consistency by itself and can have replicas.<p>This means that in MemoryDB only the primary node is strongly consistent but the replica nodes don&#x27;t.<p>Instead, in my experience, those kinds of AWS offerings have less operational headaches because the storage remains safe even the primary node fails and you don&#x27;t need to worry about managing distributed nodes.<p>Edit: add pros</div><br/></div></div><div id="35848026" class="c"><input type="checkbox" id="c-35848026" checked=""/><div class="controls bullet"><span class="by">phamilton</span><span>|</span><a href="#35847708">parent</a><span>|</span><a href="#35847995">prev</a><span>|</span><a href="#35847877">next</a><span>|</span><label class="collapse" for="c-35848026">[-]</label><label class="expand" for="c-35848026">[1 more]</label></div><br/><div class="children"><div class="content">My understanding of MemoryDB is that it basically replaces the AOF with a distributed log (it might be Kafka&#x2F;kinesis, but it could just be backed by the same data layer as aurora). The biggest win there is that acknowledged writes are not lost if the writer node dies. A reader can replay the log and get fully caught up as it is promoted during a failover.<p>This comes at a cost though and writes are slower than traditional redis.</div><br/></div></div></div></div></div></div></div></div></div></body></html>