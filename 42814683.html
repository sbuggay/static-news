<!DOCTYPE html><html lang="en"><head><title>Static News</title><meta charSet="utf-8"/><meta name="description" content="Static delayed Hacker News."/><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1d1f21"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="application-name" content="Static News"/><meta name="apple-mobile-web-app-title" content="Static News"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="#1d1f21"/><link rel="preload" href="styles.css?v=1737795674365" as="style"/><link rel="stylesheet" href="styles.css?v=1737795674365"/></head><body><div id="container"><div id="inner"><header><a href="/">Static News</a><a href="/about">about</a></header><div id="content"><div><div id="title"><a href="https://github.com/davidlattimore/wild">Wild – A fast linker for Linux</a> <span class="domain">(<a href="https://github.com">github.com</a>)</span></div><div class="subtext"><span>hkalbasi</span> | <span>157 comments</span></div><br/><div><div id="42815005" class="c"><input type="checkbox" id="c-42815005" checked=""/><div class="controls bullet"><span class="by">pzmarzly</span><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42815005">[-]</label><label class="expand" for="c-42815005">[43 more]</label></div><br/><div class="children"><div class="content">Ever since mold relicensed from AGPL to MIT (as part of mold 2.0 release), the worldwide need for making another fast linker has been greatly reduced, so I wasn&#x27;t expecting a project like this to appear. And definitely wasn&#x27;t expecting it to already be 2x faster than mold in some cases. Will keep an eye on this project to see how it evolves, best of luck to the author.</div><br/><div id="42815606" class="c"><input type="checkbox" id="c-42815606" checked=""/><div class="controls bullet"><span class="by">estebank</span><span>|</span><a href="#42815005">parent</a><span>|</span><a href="#42819826">next</a><span>|</span><label class="collapse" for="c-42815606">[-]</label><label class="expand" for="c-42815606">[14 more]</label></div><br/><div class="children"><div class="content">Note that Mold has no interest in becoming incremental, so there is a big reason there for another linker to exist. I find it kind of embarrassing that MS&#x27; linker has been incremental by default for decades, yet there&#x27;s no production ready incremental linker on Linux yet.</div><br/><div id="42818469" class="c"><input type="checkbox" id="c-42818469" checked=""/><div class="controls bullet"><span class="by">jcelerier</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815606">parent</a><span>|</span><a href="#42817110">next</a><span>|</span><label class="collapse" for="c-42818469">[-]</label><label class="expand" for="c-42818469">[5 more]</label></div><br/><div class="children"><div class="content">OTOH even lld, fast but fairly slower than mold, is already incredibly faster than MS&#x27;s linker even without the incrmeentality. Like, I&#x27;m routinely linking hundreds of megabytes in less than a second anyways, not sure incrementality is that much worth it</div><br/><div id="42818743" class="c"><input type="checkbox" id="c-42818743" checked=""/><div class="controls bullet"><span class="by">cyco130</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42818469">parent</a><span>|</span><a href="#42817110">next</a><span>|</span><label class="collapse" for="c-42818743">[-]</label><label class="expand" for="c-42818743">[4 more]</label></div><br/><div class="children"><div class="content">Not a rhetorical question: Could it be that part of the speed difference is due to the  file system speed? I was shocked when I saw how much modern(ish) Windows file systems were slower than modern(ish) Linux ones.</div><br/><div id="42819213" class="c"><input type="checkbox" id="c-42819213" checked=""/><div class="controls bullet"><span class="by">leeoniya</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42818743">parent</a><span>|</span><a href="#42817110">next</a><span>|</span><label class="collapse" for="c-42819213">[-]</label><label class="expand" for="c-42819213">[3 more]</label></div><br/><div class="children"><div class="content">it&#x27;s usually windows defender and virus scanning that causes these massive slowdowns.</div><br/><div id="42820396" class="c"><input type="checkbox" id="c-42820396" checked=""/><div class="controls bullet"><span class="by">miki123211</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819213">parent</a><span>|</span><a href="#42819849">next</a><span>|</span><label class="collapse" for="c-42820396">[-]</label><label class="expand" for="c-42820396">[1 more]</label></div><br/><div class="children"><div class="content">And as a result of this, if you want to optimize your program to be fast on Windows, you will make very different optimization decisions than on other platforms.<p>For example, Windows runs virus scans on close(), which makes it very slow. This means that sometimes it makes sense to have one or more background threads exclusively dedicated to closing files.<p>There&#x27;s a good talk on this at <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=qbKGw8MQ0i8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=qbKGw8MQ0i8</a></div><br/></div></div><div id="42819849" class="c"><input type="checkbox" id="c-42819849" checked=""/><div class="controls bullet"><span class="by">berti</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819213">parent</a><span>|</span><a href="#42820396">prev</a><span>|</span><a href="#42817110">next</a><span>|</span><label class="collapse" for="c-42819849">[-]</label><label class="expand" for="c-42819849">[1 more]</label></div><br/><div class="children"><div class="content">That’s exactly the problem “Dev Drive” is intended to solve I believe. I haven’t tried it myself.<p><a href="https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;dev-drive&#x2F;" rel="nofollow">https:&#x2F;&#x2F;learn.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;dev-drive&#x2F;</a></div><br/></div></div></div></div></div></div></div></div><div id="42817110" class="c"><input type="checkbox" id="c-42817110" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815606">parent</a><span>|</span><a href="#42818469">prev</a><span>|</span><a href="#42817268">next</a><span>|</span><label class="collapse" for="c-42817110">[-]</label><label class="expand" for="c-42817110">[1 more]</label></div><br/><div class="children"><div class="content">Additionally the way precompiled headers are handled in Visual C++ and C++ Builder have always been much better than traditional UNIX compilers, and now we have modules as well.</div><br/></div></div><div id="42817268" class="c"><input type="checkbox" id="c-42817268" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815606">parent</a><span>|</span><a href="#42817110">prev</a><span>|</span><a href="#42816198">next</a><span>|</span><label class="collapse" for="c-42817268">[-]</label><label class="expand" for="c-42817268">[1 more]</label></div><br/><div class="children"><div class="content">It has to be a candidate for the longest biggest gap in build tooling ever.</div><br/></div></div></div></div><div id="42819826" class="c"><input type="checkbox" id="c-42819826" checked=""/><div class="controls bullet"><span class="by">integricho</span><span>|</span><a href="#42815005">parent</a><span>|</span><a href="#42815606">prev</a><span>|</span><a href="#42819089">next</a><span>|</span><label class="collapse" for="c-42819826">[-]</label><label class="expand" for="c-42819826">[1 more]</label></div><br/><div class="children"><div class="content">what is the status of Windows support in mold? reading the github issues leads to a circular confusion, the author first planned to support it, then moved Windows support to the sold linker, but then sold got archived recently so in the end there is no Windows support or did I just misunderstand the events?</div><br/></div></div><div id="42819089" class="c"><input type="checkbox" id="c-42819089" checked=""/><div class="controls bullet"><span class="by">panzi</span><span>|</span><a href="#42815005">parent</a><span>|</span><a href="#42819826">prev</a><span>|</span><a href="#42816517">next</a><span>|</span><label class="collapse" for="c-42819089">[-]</label><label class="expand" for="c-42819089">[8 more]</label></div><br/><div class="children"><div class="content">Why does AGPL Vs MIT matter for a linker?</div><br/><div id="42819957" class="c"><input type="checkbox" id="c-42819957" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819089">parent</a><span>|</span><a href="#42819229">next</a><span>|</span><label class="collapse" for="c-42819957">[-]</label><label class="expand" for="c-42819957">[2 more]</label></div><br/><div class="children"><div class="content">Corps want to be able to release and use tools that take away the freedoms that GPL-family licenses provide. Often this results in duplication of effort.<p>This is not theoretical; it happens quite frequently. For toolchains, in particular I&#x27;m aware of how Apple (not that they&#x27;re unique in this) has &quot;blah blah open source&quot; downloads, but often they do not actually correspond with the binaries. And not just &quot;not fully reproducible but close&quot; but &quot;entirely new and incompatible features&quot;.<p>The ARM64 saga is a notable example, which went on for at least <i>six months</i> (at least Sept 2013 to March 2014). XCode 5 shipped with a closed-source compiler only for all that time.</div><br/><div id="42820078" class="c"><input type="checkbox" id="c-42820078" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819957">parent</a><span>|</span><a href="#42819229">next</a><span>|</span><label class="collapse" for="c-42820078">[-]</label><label class="expand" for="c-42820078">[1 more]</label></div><br/><div class="children"><div class="content">So they donate money instead of code? The project somehow benefits from the switch to MIT?</div><br/></div></div></div></div><div id="42819229" class="c"><input type="checkbox" id="c-42819229" checked=""/><div class="controls bullet"><span class="by">zelcon</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819089">parent</a><span>|</span><a href="#42819957">prev</a><span>|</span><a href="#42816517">next</a><span>|</span><label class="collapse" for="c-42819229">[-]</label><label class="expand" for="c-42819229">[5 more]</label></div><br/><div class="children"><div class="content">Corps don&#x27;t want to have to release the source code for their internal forks. They could also potentially be sued for everything they link using it because the linked binaries could be &quot;derivative works&quot; according to a judge who doesn&#x27;t know anything.</div><br/><div id="42820180" class="c"><input type="checkbox" id="c-42820180" checked=""/><div class="controls bullet"><span class="by">pwdisswordfishz</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819229">parent</a><span>|</span><a href="#42819466">next</a><span>|</span><label class="collapse" for="c-42820180">[-]</label><label class="expand" for="c-42820180">[1 more]</label></div><br/><div class="children"><div class="content">They don&#x27;t have to release source for <i>internal</i> forks.</div><br/></div></div><div id="42819466" class="c"><input type="checkbox" id="c-42819466" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819229">parent</a><span>|</span><a href="#42820180">prev</a><span>|</span><a href="#42816517">next</a><span>|</span><label class="collapse" for="c-42819466">[-]</label><label class="expand" for="c-42819466">[3 more]</label></div><br/><div class="children"><div class="content">I think you should get new lawyers if this is their understanding of how software licenses work.</div><br/><div id="42819928" class="c"><input type="checkbox" id="c-42819928" checked=""/><div class="controls bullet"><span class="by">mgsloan2</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819466">parent</a><span>|</span><a href="#42816517">next</a><span>|</span><label class="collapse" for="c-42819928">[-]</label><label class="expand" for="c-42819928">[2 more]</label></div><br/><div class="children"><div class="content">See for example <a href="https:&#x2F;&#x2F;opensource.google&#x2F;documentation&#x2F;reference&#x2F;using&#x2F;agpl-policy" rel="nofollow">https:&#x2F;&#x2F;opensource.google&#x2F;documentation&#x2F;reference&#x2F;using&#x2F;agpl...</a><p>&gt; Code licensed under the GNU Affero General Public License (AGPL) MUST NOT be used at Google.</div><br/><div id="42819962" class="c"><input type="checkbox" id="c-42819962" checked=""/><div class="controls bullet"><span class="by">jenadine</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42819928">parent</a><span>|</span><a href="#42816517">next</a><span>|</span><label class="collapse" for="c-42819962">[-]</label><label class="expand" for="c-42819962">[1 more]</label></div><br/><div class="children"><div class="content">It’s their loss</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42816517" class="c"><input type="checkbox" id="c-42816517" checked=""/><div class="controls bullet"><span class="by">easythrees</span><span>|</span><a href="#42815005">parent</a><span>|</span><a href="#42819089">prev</a><span>|</span><a href="#42815102">next</a><span>|</span><label class="collapse" for="c-42816517">[-]</label><label class="expand" for="c-42816517">[6 more]</label></div><br/><div class="children"><div class="content">Wait a minute, it’s possible to relicense something from GPL to MIT?</div><br/><div id="42817285" class="c"><input type="checkbox" id="c-42817285" checked=""/><div class="controls bullet"><span class="by">prmoustache</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42816517">parent</a><span>|</span><a href="#42816559">next</a><span>|</span><label class="collapse" for="c-42817285">[-]</label><label class="expand" for="c-42817285">[4 more]</label></div><br/><div class="children"><div class="content">Yes if you are the only developper and never received nor accepted external contributions or if you managed to get permission from every single person who contributed or replaced their code with your own.</div><br/><div id="42817374" class="c"><input type="checkbox" id="c-42817374" checked=""/><div class="controls bullet"><span class="by">computably</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42817285">parent</a><span>|</span><a href="#42816559">next</a><span>|</span><label class="collapse" for="c-42817374">[-]</label><label class="expand" for="c-42817374">[3 more]</label></div><br/><div class="children"><div class="content">&gt; or if you managed to get permission from every single person who contributed<p>This makes it sound more difficult than it actually is (logistically); it&#x27;s not uncommon for major projects to require contributors to sign a CLA before accepting PRs.</div><br/><div id="42817562" class="c"><input type="checkbox" id="c-42817562" checked=""/><div class="controls bullet"><span class="by">mrighele</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42817374">parent</a><span>|</span><a href="#42816559">next</a><span>|</span><label class="collapse" for="c-42817562">[-]</label><label class="expand" for="c-42817562">[2 more]</label></div><br/><div class="children"><div class="content">That depends on how old and big is the project. For example Linux is &quot;stuck&quot; on GPL2 and even if they wanted to move to something else it wouldn&#x27;t be feasible to get permission from all the people involved. Some contributors passed away making it even more difficult.</div><br/><div id="42817874" class="c"><input type="checkbox" id="c-42817874" checked=""/><div class="controls bullet"><span class="by">LeFantome</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42817562">parent</a><span>|</span><a href="#42816559">next</a><span>|</span><label class="collapse" for="c-42817874">[-]</label><label class="expand" for="c-42817874">[1 more]</label></div><br/><div class="children"><div class="content">Not exactly “stuck” since they very explicitly do not want to move to GPL 3.</div><br/></div></div></div></div></div></div></div></div><div id="42816559" class="c"><input type="checkbox" id="c-42816559" checked=""/><div class="controls bullet"><span class="by">DrillShopper</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42816517">parent</a><span>|</span><a href="#42817285">prev</a><span>|</span><a href="#42815102">next</a><span>|</span><label class="collapse" for="c-42816559">[-]</label><label class="expand" for="c-42816559">[1 more]</label></div><br/><div class="children"><div class="content">Yes.  Generally you need permissions from contributors (either asking them directly or requiring a contribution agreement that assigns copyright for contributions to either the author or the org hosting the project), but you can relicense from any license to any other license.<p>That doesn&#x27;t extinguish the prior versions under the prior license, but it does allow a project to change its license.</div><br/></div></div></div></div><div id="42815102" class="c"><input type="checkbox" id="c-42815102" checked=""/><div class="controls bullet"><span class="by">secondcoming</span><span>|</span><a href="#42815005">parent</a><span>|</span><a href="#42816517">prev</a><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42815102">[-]</label><label class="expand" for="c-42815102">[13 more]</label></div><br/><div class="children"><div class="content">Maybe I&#x27;m holding it wrong, but mold isn&#x27;t faster at all if you&#x27;re using LTO, which you probably should be.</div><br/><div id="42815904" class="c"><input type="checkbox" id="c-42815904" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815102">parent</a><span>|</span><a href="#42815189">next</a><span>|</span><label class="collapse" for="c-42815904">[-]</label><label class="expand" for="c-42815904">[3 more]</label></div><br/><div class="children"><div class="content">Mold will be faster than LLD even using LTO, but all of its benefits will be absolutely swamped by the LTO process, which is, more or less, recompiling the entire program from high-level LLVM-IR. That&#x27;s extremely expensive and dwarfs any linking advantages.<p>So the benefit will be barely noticable. As another comment points out, LTO should only be used when you need a binary optimized to within an inch of its life, such as a release copy, or a copy for performance testing.</div><br/><div id="42817272" class="c"><input type="checkbox" id="c-42817272" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815904">parent</a><span>|</span><a href="#42815189">next</a><span>|</span><label class="collapse" for="c-42817272">[-]</label><label class="expand" for="c-42817272">[2 more]</label></div><br/><div class="children"><div class="content">Username checks out.<p>And factual.</div><br/><div id="42819468" class="c"><input type="checkbox" id="c-42819468" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42817272">parent</a><span>|</span><a href="#42815189">next</a><span>|</span><label class="collapse" for="c-42819468">[-]</label><label class="expand" for="c-42819468">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;m waiting for &#x27;linker-guy to weigh in, personally.</div><br/></div></div></div></div></div></div><div id="42815189" class="c"><input type="checkbox" id="c-42815189" checked=""/><div class="controls bullet"><span class="by">0x457</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815102">parent</a><span>|</span><a href="#42815904">prev</a><span>|</span><a href="#42816403">next</a><span>|</span><label class="collapse" for="c-42815189">[-]</label><label class="expand" for="c-42815189">[1 more]</label></div><br/><div class="children"><div class="content">I think we&#x27;re talking about non-release builds here. In those, you don&#x27;t want to use LTO, you just want to get that binary as fast as possible.</div><br/></div></div><div id="42816403" class="c"><input type="checkbox" id="c-42816403" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815102">parent</a><span>|</span><a href="#42815189">prev</a><span>|</span><a href="#42815221">next</a><span>|</span><label class="collapse" for="c-42816403">[-]</label><label class="expand" for="c-42816403">[1 more]</label></div><br/><div class="children"><div class="content">Agreed. Both fast and small are desirable for sandboxed (least authority) isomorphic (client and server) microservices with WebAssembly &amp; related tech.</div><br/></div></div><div id="42816102" class="c"><input type="checkbox" id="c-42816102" checked=""/><div class="controls bullet"><span class="by">Arelius</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42815102">parent</a><span>|</span><a href="#42815221">prev</a><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42816102">[-]</label><label class="expand" for="c-42816102">[6 more]</label></div><br/><div class="children"><div class="content">Yeah, if you&#x27;re development process requires LTO you may be holding it wrong....<p>Specifically, if LTO is so important that you need to be using it during development, you likely have a very exceptional case, or you have some big architectural issues that are causing much larger performance regressions then they should be.</div><br/><div id="42816339" class="c"><input type="checkbox" id="c-42816339" checked=""/><div class="controls bullet"><span class="by">benatkin</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42816102">parent</a><span>|</span><a href="#42816648">next</a><span>|</span><label class="collapse" for="c-42816339">[-]</label><label class="expand" for="c-42816339">[1 more]</label></div><br/><div class="children"><div class="content">Being able to choose a middle ground between development&#x2F;debug builds and production builds is becoming increasingly important. This is especially true when developing in the browser, when often something appears to be slow in development mode but is fine in production mode.<p>WebAssembly and lightweight MicroVMs are enabling FaaS with real time code generation but the build toolchain makes it less appealing, when you don&#x27;t want it to take half a minute to build or to be slow.</div><br/></div></div><div id="42816648" class="c"><input type="checkbox" id="c-42816648" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42816102">parent</a><span>|</span><a href="#42816339">prev</a><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42816648">[-]</label><label class="expand" for="c-42816648">[4 more]</label></div><br/><div class="children"><div class="content">If you&#x27;re debugging, and your bug only reproduces with LTO enabled, you don&#x27;t have much of a choice...</div><br/><div id="42817282" class="c"><input type="checkbox" id="c-42817282" checked=""/><div class="controls bullet"><span class="by">paulddraper</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42816648">parent</a><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42817282">[-]</label><label class="expand" for="c-42817282">[3 more]</label></div><br/><div class="children"><div class="content">Sure, for that 1% of the time.</div><br/><div id="42817685" class="c"><input type="checkbox" id="c-42817685" checked=""/><div class="controls bullet"><span class="by">thesz</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42817282">parent</a><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42817685">[-]</label><label class="expand" for="c-42817685">[2 more]</label></div><br/><div class="children"><div class="content">...which takes these remaining 99% of a development time...</div><br/><div id="42819472" class="c"><input type="checkbox" id="c-42819472" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42815005">root</a><span>|</span><a href="#42817685">parent</a><span>|</span><a href="#42814960">next</a><span>|</span><label class="collapse" for="c-42819472">[-]</label><label class="expand" for="c-42819472">[1 more]</label></div><br/><div class="children"><div class="content">Surely your LTO bugs are not so easy to fix that they take less time to resolve than linking itself does.</div><br/></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div id="42814960" class="c"><input type="checkbox" id="c-42814960" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42815005">prev</a><span>|</span><a href="#42815776">next</a><span>|</span><label class="collapse" for="c-42814960">[-]</label><label class="expand" for="c-42814960">[8 more]</label></div><br/><div class="children"><div class="content">I looked at this before, is it ready for production? I thought not based on the readme, so I&#x27;m still using mold.<p>For those on macOS, Apple released a new linker about a year or two ago (which is why the mold author stopped working on their macOS version), and if you&#x27;re using it with Rust, put this in your config.toml:<p><pre><code>    [target.aarch64-apple-darwin]
    rustflags = [ 
        &quot;-C&quot;,
        &quot;link-arg=-fuse-ld=&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;ld&quot;,
        &quot;-C&quot;,
        &quot;link-arg=-ld_new&quot;,
    ]</code></pre></div><br/><div id="42815620" class="c"><input type="checkbox" id="c-42815620" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42814960">parent</a><span>|</span><a href="#42814999">next</a><span>|</span><label class="collapse" for="c-42815620">[-]</label><label class="expand" for="c-42815620">[2 more]</label></div><br/><div class="children"><div class="content">No, the author is pretty clear that it shouldn&#x27;t be used for production yet</div><br/><div id="42816269" class="c"><input type="checkbox" id="c-42816269" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42814960">root</a><span>|</span><a href="#42815620">parent</a><span>|</span><a href="#42814999">next</a><span>|</span><label class="collapse" for="c-42816269">[-]</label><label class="expand" for="c-42816269">[1 more]</label></div><br/><div class="children"><div class="content">Great, I&#x27;ll keep a look out but will hold off on using it for now.</div><br/></div></div></div></div><div id="42814999" class="c"><input type="checkbox" id="c-42814999" checked=""/><div class="controls bullet"><span class="by">brink</span><span>|</span><a href="#42814960">parent</a><span>|</span><a href="#42815620">prev</a><span>|</span><a href="#42818677">next</a><span>|</span><label class="collapse" for="c-42814999">[-]</label><label class="expand" for="c-42814999">[1 more]</label></div><br/><div class="children"><div class="content">I don&#x27;t even use mold for production. It&#x27;s for development.</div><br/></div></div><div id="42818677" class="c"><input type="checkbox" id="c-42818677" checked=""/><div class="controls bullet"><span class="by">bla3</span><span>|</span><a href="#42814960">parent</a><span>|</span><a href="#42814999">prev</a><span>|</span><a href="#42817303">next</a><span>|</span><label class="collapse" for="c-42818677">[-]</label><label class="expand" for="c-42818677">[1 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t the new linked just the default these days? I&#x27;m not sure adding that has any effect.</div><br/></div></div><div id="42817303" class="c"><input type="checkbox" id="c-42817303" checked=""/><div class="controls bullet"><span class="by">newman314</span><span>|</span><a href="#42814960">parent</a><span>|</span><a href="#42818677">prev</a><span>|</span><a href="#42815776">next</a><span>|</span><label class="collapse" for="c-42817303">[-]</label><label class="expand" for="c-42817303">[3 more]</label></div><br/><div class="children"><div class="content">Can you confirm that&#x27;s still the right location for Sequioa?<p>I have the command line tools installed and I only have &#x2F;usr&#x2F;bin&#x2F;ld and &#x2F;usr&#x2F;bin&#x2F;ld-classic</div><br/><div id="42817326" class="c"><input type="checkbox" id="c-42817326" checked=""/><div class="controls bullet"><span class="by">satvikpendem</span><span>|</span><a href="#42814960">root</a><span>|</span><a href="#42817303">parent</a><span>|</span><a href="#42819481">next</a><span>|</span><label class="collapse" for="c-42817326">[-]</label><label class="expand" for="c-42817326">[1 more]</label></div><br/><div class="children"><div class="content">Then it&#x27;d be the &#x2F;usr&#x2F;bin&#x2F;ld as I believe my solution was for before they moved the linker it seems.</div><br/></div></div><div id="42819481" class="c"><input type="checkbox" id="c-42819481" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42814960">root</a><span>|</span><a href="#42817303">parent</a><span>|</span><a href="#42817326">prev</a><span>|</span><a href="#42815776">next</a><span>|</span><label class="collapse" for="c-42819481">[-]</label><label class="expand" for="c-42819481">[1 more]</label></div><br/><div class="children"><div class="content">&#x2F;usr&#x2F;bin&#x2F;ld will correctly invoke the right linker, it&#x27;s a stub to look at your developer dir and reexec.</div><br/></div></div></div></div></div></div><div id="42815776" class="c"><input type="checkbox" id="c-42815776" checked=""/><div class="controls bullet"><span class="by">kryptiskt</span><span>|</span><a href="#42814960">prev</a><span>|</span><a href="#42814963">next</a><span>|</span><label class="collapse" for="c-42815776">[-]</label><label class="expand" for="c-42815776">[12 more]</label></div><br/><div class="children"><div class="content">What would be refreshing would be a C&#x2F;C++ compiler that did away with the intermediate step of linking and built the whole program as a unit. LTO doesn&#x27;t even have to be a thing if the compiler can see the entire program in the first place. It would still have to save some build products so that incremental builds are possible, but not as object files, the compiler would need metadata to know of the origin and dependencies of all the generated code so it would be able to replace the right things.<p>External libs are most often linked dynamically these days, so they don&#x27;t need to be built from source, so eliminating the linker doesn&#x27;t pose a problem for non-open source dependencies. And if that&#x27;s not enough letting the compiler also consume object files could provide for legacy use cases or edge cases where you must statically link to a binary.</div><br/><div id="42817207" class="c"><input type="checkbox" id="c-42817207" checked=""/><div class="controls bullet"><span class="by">dapperdrake</span><span>|</span><a href="#42815776">parent</a><span>|</span><a href="#42816272">next</a><span>|</span><label class="collapse" for="c-42817207">[-]</label><label class="expand" for="c-42817207">[7 more]</label></div><br/><div class="children"><div class="content">SQLite3 just concatenation everything together into one compilation unit.  So, more people have been using this than probably know about it.<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;amalgamation.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;amalgamation.html</a></div><br/><div id="42818061" class="c"><input type="checkbox" id="c-42818061" checked=""/><div class="controls bullet"><span class="by">jdxcode</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42817207">parent</a><span>|</span><a href="#42818178">next</a><span>|</span><label class="collapse" for="c-42818061">[-]</label><label class="expand" for="c-42818061">[5 more]</label></div><br/><div class="children"><div class="content">I totally see the point of this, but still, you have to admit this is pretty funny:<p>&gt; Developers sometimes experience trouble debugging the quarter-million line amalgamation source file because some debuggers are only able to handle source code line numbers less than 32,768 [...] To circumvent this limitation, the amalgamation is also available in a split form, consisting of files &quot;sqlite3-1.c&quot;, &quot;sqlite3-2.c&quot;, and so forth, where each file is less than 32,768 lines in length</div><br/><div id="42819503" class="c"><input type="checkbox" id="c-42819503" checked=""/><div class="controls bullet"><span class="by">yellowapple</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42818061">parent</a><span>|</span><a href="#42818178">next</a><span>|</span><label class="collapse" for="c-42819503">[-]</label><label class="expand" for="c-42819503">[4 more]</label></div><br/><div class="children"><div class="content">That would imply that such debuggers are storing line numbers as not just 16-bit numbers (which is probably sensible, considering that source files longer than that are uncommon), but as <i>signed</i> 16-bit numbers.  I can&#x27;t fathom a situation where line numbers would ever be negative.</div><br/><div id="42820102" class="c"><input type="checkbox" id="c-42820102" checked=""/><div class="controls bullet"><span class="by">eredengrin</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42819503">parent</a><span>|</span><a href="#42819971">next</a><span>|</span><label class="collapse" for="c-42820102">[-]</label><label class="expand" for="c-42820102">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s not that uncommon of a convention to strictly use signed numbers unless doing bit manipulation, eg the Google C++ Style Guide.</div><br/></div></div><div id="42819971" class="c"><input type="checkbox" id="c-42819971" checked=""/><div class="controls bullet"><span class="by">makapuf</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42819503">parent</a><span>|</span><a href="#42820102">prev</a><span>|</span><a href="#42820009">next</a><span>|</span><label class="collapse" for="c-42819971">[-]</label><label class="expand" for="c-42819971">[1 more]</label></div><br/><div class="children"><div class="content">Maybe somewhere some line <i>offset</i> is stored as i16? (I don&#x27;t understand why anyway but..)</div><br/></div></div><div id="42820009" class="c"><input type="checkbox" id="c-42820009" checked=""/><div class="controls bullet"><span class="by">usefulcat</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42819503">parent</a><span>|</span><a href="#42819971">prev</a><span>|</span><a href="#42818178">next</a><span>|</span><label class="collapse" for="c-42820009">[-]</label><label class="expand" for="c-42820009">[1 more]</label></div><br/><div class="children"><div class="content">Cue C or C++ should-I-prefer-signed-or-unsigned-integers debate</div><br/></div></div></div></div></div></div><div id="42818178" class="c"><input type="checkbox" id="c-42818178" checked=""/><div class="controls bullet"><span class="by">dapperdrake</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42817207">parent</a><span>|</span><a href="#42818061">prev</a><span>|</span><a href="#42816272">next</a><span>|</span><label class="collapse" for="c-42818178">[-]</label><label class="expand" for="c-42818178">[1 more]</label></div><br/><div class="children"><div class="content">*concatenates<p>Apologies for the typo.  And now it is too late to edit the post.</div><br/></div></div></div></div><div id="42816272" class="c"><input type="checkbox" id="c-42816272" checked=""/><div class="controls bullet"><span class="by">almostgotcaught</span><span>|</span><a href="#42815776">parent</a><span>|</span><a href="#42817207">prev</a><span>|</span><a href="#42814963">next</a><span>|</span><label class="collapse" for="c-42816272">[-]</label><label class="expand" for="c-42816272">[4 more]</label></div><br/><div class="children"><div class="content">People trot this out like it&#x27;s some kind of brilliant insight all the time and I always laugh.<p>First of all UNITY_BUILD is supported in CMake for a long time - try it out and please report back how many ODR violations your code base has.<p>Secondly, if you think any compiler is meaningfully doing anything optimal (&quot;whole program analysis&quot;) on a TU scale greater than say ~50kloc (ie ~10 files) relative to compiling individually you&#x27;re dreaming. Let alone on a codebase with millions of lines. Maybe inlining functions at most but you should have those in a header already.</div><br/><div id="42816510" class="c"><input type="checkbox" id="c-42816510" checked=""/><div class="controls bullet"><span class="by">nn3</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42816272">parent</a><span>|</span><a href="#42816830">next</a><span>|</span><label class="collapse" for="c-42816510">[-]</label><label class="expand" for="c-42816510">[1 more]</label></div><br/><div class="children"><div class="content">&gt;Secondly, if you think any compiler is meaningfully doing anything optimal &gt;&gt;(&quot;whole program analysis&quot;) on a TU scale greater than say ~50kloc (ie ~10 files) &gt;relative to compiling individually you&#x27;re dreaming.<p>That&#x27;s wrong.  gcc generates summaries of function properties and propagate those up and down the call tree, which for LTO is then build in a distributed way. It does much more than mere inlining, but even advanced analysis like points to analysis.<p><a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gccint&#x2F;IPA.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gccint&#x2F;IPA.html</a>
<a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gccint&#x2F;IPA-passes.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gccint&#x2F;IPA-passes.html</a><p>It scales to millions of lines of code because it&#x27;s partioned.</div><br/></div></div><div id="42816830" class="c"><input type="checkbox" id="c-42816830" checked=""/><div class="controls bullet"><span class="by">jcalvinowens</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42816272">parent</a><span>|</span><a href="#42816510">prev</a><span>|</span><a href="#42817217">next</a><span>|</span><label class="collapse" for="c-42816830">[-]</label><label class="expand" for="c-42816830">[1 more]</label></div><br/><div class="children"><div class="content">&gt; if you think any compiler is meaningfully doing anything optimal (&quot;whole program analysis&quot;) on a TU scale greater than say ~50kloc (ie ~10 files) relative to compiling individually you&#x27;re dreaming.<p>You can build the Linux kernel with LTO: simply diff the LTO vs non-LTO outputs and it will be obvious you&#x27;re wrong.</div><br/></div></div><div id="42817217" class="c"><input type="checkbox" id="c-42817217" checked=""/><div class="controls bullet"><span class="by">dapperdrake</span><span>|</span><a href="#42815776">root</a><span>|</span><a href="#42816272">parent</a><span>|</span><a href="#42816830">prev</a><span>|</span><a href="#42814963">next</a><span>|</span><label class="collapse" for="c-42817217">[-]</label><label class="expand" for="c-42817217">[1 more]</label></div><br/><div class="children"><div class="content">SQLite3 may be a counter-example:<p><a href="https:&#x2F;&#x2F;sqlite.org&#x2F;amalgamation.html" rel="nofollow">https:&#x2F;&#x2F;sqlite.org&#x2F;amalgamation.html</a></div><br/></div></div></div></div></div></div><div id="42814963" class="c"><input type="checkbox" id="c-42814963" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42815776">prev</a><span>|</span><a href="#42816737">next</a><span>|</span><label class="collapse" for="c-42814963">[-]</label><label class="expand" for="c-42814963">[7 more]</label></div><br/><div class="children"><div class="content">There’s been a lot of interest in faster linkers spurred by the adoption and popularity of rust.<p>Even modest statically linked rust binaries can take a couple of minutes in the link stage of compilation in release mode (using mold). It’s not a rust-specific issue but an amalgam of (usually) strictly static linking, advanced link-time optimizations enabled by llvm like LTO and bolt, and a general dissatisfaction with compile times in the rust community. Rust’s (clinically) strong relationship with(read: dependency on) LLVM makes it the most popular language where LLVM link-time magic has been most heavily universally adopted; you could face these issues with C++ but it wouldn’t be chalked up to the language rather than your toolchain.<p>I’ve been eyeing wild for some time as I’m excited by the promise of an optimizing <i>incremental</i> linker, but to be frank, see zero incentive to even fiddle with it until it can actually, you know, link incrementally.</div><br/><div id="42817147" class="c"><input type="checkbox" id="c-42817147" checked=""/><div class="controls bullet"><span class="by">pjmlp</span><span>|</span><a href="#42814963">parent</a><span>|</span><a href="#42815523">next</a><span>|</span><label class="collapse" for="c-42817147">[-]</label><label class="expand" for="c-42817147">[1 more]</label></div><br/><div class="children"><div class="content">C++ can be rather faster to compile than Rust, because some compilers do have incremental compilation, and incremental linking.<p>Additionally, the acceptance of binary libraries across the C and C++ ecosystem, means that more often than not, you only need to care about compiling you own application, and not the world, every time you clone a repo, or switch development branch.</div><br/></div></div><div id="42815523" class="c"><input type="checkbox" id="c-42815523" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42814963">parent</a><span>|</span><a href="#42817147">prev</a><span>|</span><a href="#42816737">next</a><span>|</span><label class="collapse" for="c-42815523">[-]</label><label class="expand" for="c-42815523">[5 more]</label></div><br/><div class="children"><div class="content">I solved this by using Wasm. Your outer application shell calls into Wasm business logic, only the inner logic needs to get recompiled, the outer app shell doesn&#x27;t even need to restart.</div><br/><div id="42815568" class="c"><input type="checkbox" id="c-42815568" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42814963">root</a><span>|</span><a href="#42815523">parent</a><span>|</span><a href="#42816920">next</a><span>|</span><label class="collapse" for="c-42815568">[-]</label><label class="expand" for="c-42815568">[2 more]</label></div><br/><div class="children"><div class="content">I don’t think I can use wasm with simd or syscalls, which is the bulk of my work.</div><br/><div id="42816000" class="c"><input type="checkbox" id="c-42816000" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42814963">root</a><span>|</span><a href="#42815568">parent</a><span>|</span><a href="#42816920">next</a><span>|</span><label class="collapse" for="c-42816000">[-]</label><label class="expand" for="c-42816000">[1 more]</label></div><br/><div class="children"><div class="content">I haven&#x27;t used SIMD in Rust (or Wasm). Syscalls can be passed into the Wasm env.<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;arch&#x2F;wasm32&#x2F;index.html#simd" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;arch&#x2F;wasm32&#x2F;index.html#simd</a><p><a href="https:&#x2F;&#x2F;nickb.dev&#x2F;blog&#x2F;authoring-a-simd-enhanced-wasm-library-with-rust&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nickb.dev&#x2F;blog&#x2F;authoring-a-simd-enhanced-wasm-librar...</a><p>Could definitely be more effort than it is worth just to speed up compilation.</div><br/></div></div></div></div><div id="42816920" class="c"><input type="checkbox" id="c-42816920" checked=""/><div class="controls bullet"><span class="by">SkiFire13</span><span>|</span><a href="#42814963">root</a><span>|</span><a href="#42815523">parent</a><span>|</span><a href="#42815568">prev</a><span>|</span><a href="#42816737">next</a><span>|</span><label class="collapse" for="c-42816920">[-]</label><label class="expand" for="c-42816920">[2 more]</label></div><br/><div class="children"><div class="content">How is this different than dynamically linking the business logic library?</div><br/><div id="42818155" class="c"><input type="checkbox" id="c-42818155" checked=""/><div class="controls bullet"><span class="by">sitkack</span><span>|</span><a href="#42814963">root</a><span>|</span><a href="#42816920">parent</a><span>|</span><a href="#42816737">next</a><span>|</span><label class="collapse" for="c-42818155">[-]</label><label class="expand" for="c-42818155">[1 more]</label></div><br/><div class="children"><div class="content">Very similar, but Wasm has additional safety properties and affordances. I am trying to get away from dynamic libs as an app extension mechanism. It is especially nice when application extension is open to end users, they won&#x27;t be able to crash your application shell.<p><a href="https:&#x2F;&#x2F;wasmtime.dev&#x2F;" rel="nofollow">https:&#x2F;&#x2F;wasmtime.dev&#x2F;</a> <a href="https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime">https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;wasmtime</a></div><br/></div></div></div></div></div></div></div></div><div id="42816737" class="c"><input type="checkbox" id="c-42816737" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#42814963">prev</a><span>|</span><a href="#42817472">next</a><span>|</span><label class="collapse" for="c-42816737">[-]</label><label class="expand" for="c-42816737">[8 more]</label></div><br/><div class="children"><div class="content">2008: Gold, a new linker, intended to be faster than Gnu LD<p>2015(?): Lld a drop in replacement linker, at least 2x as fast as Gold<p>2021: mold, a new linker, several times faster than lld<p>2025: wild, a new linker...</div><br/><div id="42819983" class="c"><input type="checkbox" id="c-42819983" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42816737">parent</a><span>|</span><a href="#42817077">next</a><span>|</span><label class="collapse" for="c-42819983">[-]</label><label class="expand" for="c-42819983">[1 more]</label></div><br/><div class="children"><div class="content">Rarely mentioned: all of these occur at the cost of not implementing a very large number of useful features used by real-world programs.</div><br/></div></div><div id="42817077" class="c"><input type="checkbox" id="c-42817077" checked=""/><div class="controls bullet"><span class="by">wolfd</span><span>|</span><a href="#42816737">parent</a><span>|</span><a href="#42819983">prev</a><span>|</span><a href="#42817811">next</a><span>|</span><label class="collapse" for="c-42817077">[-]</label><label class="expand" for="c-42817077">[3 more]</label></div><br/><div class="children"><div class="content">I’m not sure if you’re intending to leave a negative or positive remark, or just a brief history, but the fact that people are still managing to squeeze better performance into linkers is very encouraging to me.</div><br/><div id="42817366" class="c"><input type="checkbox" id="c-42817366" checked=""/><div class="controls bullet"><span class="by">ajb</span><span>|</span><a href="#42816737">root</a><span>|</span><a href="#42817077">parent</a><span>|</span><a href="#42817811">next</a><span>|</span><label class="collapse" for="c-42817366">[-]</label><label class="expand" for="c-42817366">[2 more]</label></div><br/><div class="children"><div class="content">Certainly no intention to be negative. Not having run the numbers, I don&#x27;t know if the older ones got slower over time due to more features, or the new ones are squeezing out <i>new</i> performance gains. I guess it&#x27;s also partly that the bigger codebases scaled up so much over this period, so that there are gains to be had that weren&#x27;t interesting before.</div><br/><div id="42817965" class="c"><input type="checkbox" id="c-42817965" checked=""/><div class="controls bullet"><span class="by">wolfd</span><span>|</span><a href="#42816737">root</a><span>|</span><a href="#42817366">parent</a><span>|</span><a href="#42817811">next</a><span>|</span><label class="collapse" for="c-42817965">[-]</label><label class="expand" for="c-42817965">[1 more]</label></div><br/><div class="children"><div class="content">Good question, I always wonder the same thing. <a href="https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Mold-Linker-2024-Performance" rel="nofollow">https:&#x2F;&#x2F;www.phoronix.com&#x2F;news&#x2F;Mold-Linker-2024-Performance</a> seems to show that that the newer linkers still outperform their predecessors, even after maturing. But of course this doesn’t show the full picture.</div><br/></div></div></div></div></div></div><div id="42817811" class="c"><input type="checkbox" id="c-42817811" checked=""/><div class="controls bullet"><span class="by">cbmuser</span><span>|</span><a href="#42816737">parent</a><span>|</span><a href="#42817077">prev</a><span>|</span><a href="#42816811">next</a><span>|</span><label class="collapse" for="c-42817811">[-]</label><label class="expand" for="c-42817811">[2 more]</label></div><br/><div class="children"><div class="content">Gold is slated for removal from binutils for version 2.44.0, so it&#x27;s officially dead.</div><br/><div id="42819494" class="c"><input type="checkbox" id="c-42819494" checked=""/><div class="controls bullet"><span class="by">saagarjha</span><span>|</span><a href="#42816737">root</a><span>|</span><a href="#42817811">parent</a><span>|</span><a href="#42816811">next</a><span>|</span><label class="collapse" for="c-42819494">[-]</label><label class="expand" for="c-42819494">[1 more]</label></div><br/><div class="children"><div class="content">Where is the effort going now? lld?</div><br/></div></div></div></div><div id="42816811" class="c"><input type="checkbox" id="c-42816811" checked=""/><div class="controls bullet"><span class="by">dundarious</span><span>|</span><a href="#42816737">parent</a><span>|</span><a href="#42817811">prev</a><span>|</span><a href="#42817472">next</a><span>|</span><label class="collapse" for="c-42816811">[-]</label><label class="expand" for="c-42816811">[1 more]</label></div><br/><div class="children"><div class="content">For windows, there is also [The RAD Linker](<a href="https:&#x2F;&#x2F;github.com&#x2F;EpicGamesExt&#x2F;raddebugger?tab=readme-ov-file#the-rad-linker">https:&#x2F;&#x2F;github.com&#x2F;EpicGamesExt&#x2F;raddebugger?tab=readme-ov-fi...</a>) though quite early days.</div><br/></div></div></div></div><div id="42817472" class="c"><input type="checkbox" id="c-42817472" checked=""/><div class="controls bullet"><span class="by">fuzztester</span><span>|</span><a href="#42816737">prev</a><span>|</span><a href="#42817059">next</a><span>|</span><label class="collapse" for="c-42817472">[-]</label><label class="expand" for="c-42817472">[1 more]</label></div><br/><div class="children"><div class="content">Related, and a good one, though old:<p>The book Linkers and Loaders by John Levine.<p>Last book in the list here:<p><a href="https:&#x2F;&#x2F;www.johnlevine.com&#x2F;books.phtml" rel="nofollow">https:&#x2F;&#x2F;www.johnlevine.com&#x2F;books.phtml</a><p>I had read it some years ago, and found it quite interesting.<p>It&#x27;s a standard one in the field.<p>He has also written some other popular computer books (see <i>link</i> above - pun not intended, but noticed).</div><br/></div></div><div id="42817059" class="c"><input type="checkbox" id="c-42817059" checked=""/><div class="controls bullet"><span class="by">bjourne</span><span>|</span><a href="#42817472">prev</a><span>|</span><a href="#42817921">next</a><span>|</span><label class="collapse" for="c-42817059">[-]</label><label class="expand" for="c-42817059">[7 more]</label></div><br/><div class="children"><div class="content">What a coincidence. :) Just an hour ago I compared the performance of wild, mold, and (plain-old) ld on a C project I&#x27;m working on. 23 kloc and 172 files. Takes about 23.4 s of user time to compile with gcc+ld, 22.5 s with gcc+mold, and 21.8 s with gcc+wild. Which leads me to believe that link time shouldn&#x27;t be that much of a problem for well-structured projects.</div><br/><div id="42817186" class="c"><input type="checkbox" id="c-42817186" checked=""/><div class="controls bullet"><span class="by">davidlattimore</span><span>|</span><a href="#42817059">parent</a><span>|</span><a href="#42817193">next</a><span>|</span><label class="collapse" for="c-42817186">[-]</label><label class="expand" for="c-42817186">[3 more]</label></div><br/><div class="children"><div class="content">It sounds like you&#x27;re building from scratch. In that case, the majority of the time will be spent compiling code, not linking. The case for fast linkers is strongest when doing iterative development. i.e. when making small changes to your code then rebuilding and running the result. With a small change, there&#x27;s generally very little work for the compiler to do, but linking is still done from scratch, so tends to dominate.</div><br/><div id="42820402" class="c"><input type="checkbox" id="c-42820402" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#42817059">root</a><span>|</span><a href="#42817186">parent</a><span>|</span><a href="#42819031">next</a><span>|</span><label class="collapse" for="c-42820402">[-]</label><label class="expand" for="c-42820402">[1 more]</label></div><br/><div class="children"><div class="content">Exactly. But also even in build-from-scratch use-case when there&#x27;s a multitude of binaries to be built - think 10s or 100s of (unit, integration, performance) test binaries or utilities that come along with the main release binary etc. Faster linkers giving even a modest 10% speedup per binary will quickly accumulate and will obviously scale much better.</div><br/></div></div><div id="42819031" class="c"><input type="checkbox" id="c-42819031" checked=""/><div class="controls bullet"><span class="by">commandersaki</span><span>|</span><a href="#42817059">root</a><span>|</span><a href="#42817186">parent</a><span>|</span><a href="#42820402">prev</a><span>|</span><a href="#42817193">next</a><span>|</span><label class="collapse" for="c-42819031">[-]</label><label class="expand" for="c-42819031">[1 more]</label></div><br/><div class="children"><div class="content">Yep in my case I have 11 * 450MB executables that take about 8 minutes to compile and link. But for small iterative programming cycles using the standard linker with g++, it takes about 30 seconds to link (If I remember correctly). I tried mold and shaved 25% of that time, which didn&#x27;t seem worth the change overall; attempted wild a year ago but ran into issues, but will revisit at some point.</div><br/></div></div></div></div><div id="42817193" class="c"><input type="checkbox" id="c-42817193" checked=""/><div class="controls bullet"><span class="by">wolf550e</span><span>|</span><a href="#42817059">parent</a><span>|</span><a href="#42817186">prev</a><span>|</span><a href="#42817177">next</a><span>|</span><label class="collapse" for="c-42817193">[-]</label><label class="expand" for="c-42817193">[1 more]</label></div><br/><div class="children"><div class="content">The linker time is important when building something like Chrome, not small projects.</div><br/></div></div><div id="42817177" class="c"><input type="checkbox" id="c-42817177" checked=""/><div class="controls bullet"><span class="by">searealist</span><span>|</span><a href="#42817059">parent</a><span>|</span><a href="#42817193">prev</a><span>|</span><a href="#42817070">next</a><span>|</span><label class="collapse" for="c-42817177">[-]</label><label class="expand" for="c-42817177">[1 more]</label></div><br/><div class="children"><div class="content">Fast linkers are mostly useful in incremental compilation scenarios to cut down on the edit cycle.</div><br/></div></div><div id="42817070" class="c"><input type="checkbox" id="c-42817070" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#42817059">parent</a><span>|</span><a href="#42817177">prev</a><span>|</span><a href="#42817921">next</a><span>|</span><label class="collapse" for="c-42817070">[-]</label><label class="expand" for="c-42817070">[1 more]</label></div><br/><div class="children"><div class="content">How about ld.lld?</div><br/></div></div></div></div><div id="42817921" class="c"><input type="checkbox" id="c-42817921" checked=""/><div class="controls bullet"><span class="by">1vuio0pswjnm7</span><span>|</span><a href="#42817059">prev</a><span>|</span><a href="#42817138">next</a><span>|</span><label class="collapse" for="c-42817921">[-]</label><label class="expand" for="c-42817921">[1 more]</label></div><br/><div class="children"><div class="content">&quot;These benchmark were run on David Lattimore&#x27;s laptop (2020 model System76 Lemur pro), which has 4 cores (8 threads) and 42 GB of RAM.&quot;<p><a href="https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33330499">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33330499</a><p>NB. This is not to suggest wild is bloated.  The issue if any is the software being developed with it and the computers of those who might use such software.</div><br/></div></div><div id="42817138" class="c"><input type="checkbox" id="c-42817138" checked=""/><div class="controls bullet"><span class="by">ndesaulniers</span><span>|</span><a href="#42817921">prev</a><span>|</span><a href="#42818212">next</a><span>|</span><label class="collapse" for="c-42817138">[-]</label><label class="expand" for="c-42817138">[3 more]</label></div><br/><div class="children"><div class="content">Can it link the Linux kernel yet? Was a useful milestone for LLD.</div><br/><div id="42818165" class="c"><input type="checkbox" id="c-42818165" checked=""/><div class="controls bullet"><span class="by">davidlattimore</span><span>|</span><a href="#42817138">parent</a><span>|</span><a href="#42818212">next</a><span>|</span><label class="collapse" for="c-42818165">[-]</label><label class="expand" for="c-42818165">[2 more]</label></div><br/><div class="children"><div class="content">Not yet. The Linux kernel uses linker scripts, which Wild doesn&#x27;t yet support. I&#x27;d like to add support for linker scripts at some point, but it&#x27;s some way down the priority list.</div><br/><div id="42820173" class="c"><input type="checkbox" id="c-42820173" checked=""/><div class="controls bullet"><span class="by">oguz-ismail</span><span>|</span><a href="#42817138">root</a><span>|</span><a href="#42818165">parent</a><span>|</span><a href="#42818212">next</a><span>|</span><label class="collapse" for="c-42820173">[-]</label><label class="expand" for="c-42820173">[1 more]</label></div><br/><div class="children"><div class="content">Does it at least support -Ttext, -Tdata, etc.?</div><br/></div></div></div></div></div></div><div id="42818212" class="c"><input type="checkbox" id="c-42818212" checked=""/><div class="controls bullet"><span class="by">juujian</span><span>|</span><a href="#42817138">prev</a><span>|</span><a href="#42816069">next</a><span>|</span><label class="collapse" for="c-42818212">[-]</label><label class="expand" for="c-42818212">[2 more]</label></div><br/><div class="children"><div class="content">Is it too late to ask what a linker is?</div><br/><div id="42818401" class="c"><input type="checkbox" id="c-42818401" checked=""/><div class="controls bullet"><span class="by">nappy-doo</span><span>|</span><a href="#42818212">parent</a><span>|</span><a href="#42816069">next</a><span>|</span><label class="collapse" for="c-42818401">[-]</label><label class="expand" for="c-42818401">[1 more]</label></div><br/><div class="children"><div class="content">I&#x27;ll ELI5:<p>Compilers take the code the programmer writes, and turns it into things called object files. Object files are close to executable by the target processor, but not completely. There are little places where the code needs to be rewritten to handle access to subroutines, access operating system functionality, and other things.<p>A linker combines all these object files, does the necessary rewriting, and generates something that the operating system can use.<p>It&#x27;s the final step in building an executable.<p>--<p>More complicatedly: a linker is a little Turing machine that runs over the object files. Some can do complicated things like rewriting code, or optimizing across function calls. But, fundamentally, they plop all the object files together and follow little scripts (or rewrites) that clean up the places the compiler couldn&#x27;t properly insert instructions because the compiler doesn&#x27;t know the final layout of the program.</div><br/></div></div></div></div><div id="42816069" class="c"><input type="checkbox" id="c-42816069" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#42818212">prev</a><span>|</span><a href="#42817318">next</a><span>|</span><label class="collapse" for="c-42816069">[-]</label><label class="expand" for="c-42816069">[7 more]</label></div><br/><div class="children"><div class="content">That looks promising. In Rust to begin with and with the goal of being fast and support incremental linking.<p>To use it with Rust, this can probbaly also work using gcc as linker driver.<p>In project&#x27;s .cargo&#x2F;config.toml:<p><pre><code>    [target.x86_64-unknown-linux-gnu]
    rustflags = [&quot;-C&quot;, &quot;link-arg=-fuse-ld=wild&quot;]
</code></pre>
Side note, but why does Rust need to plug into gcc or clang for that? Some missing functionality?</div><br/><div id="42817056" class="c"><input type="checkbox" id="c-42817056" checked=""/><div class="controls bullet"><span class="by">davidlattimore</span><span>|</span><a href="#42816069">parent</a><span>|</span><a href="#42816486">next</a><span>|</span><label class="collapse" for="c-42817056">[-]</label><label class="expand" for="c-42817056">[3 more]</label></div><br/><div class="children"><div class="content">Unfortunately gcc doesn&#x27;t accept arbitrary linkers via the `-fuse-ld=` flag. The only linkers it accepts are bfd, gold lld and mold. It is possible to use gcc to invoke wild as the linker, but currently to do that, you need to create a directory containing the wild linker and rename the binary (or a symlink) to &quot;ld&quot;, then pass `-B&#x2F;path&#x2F;to&#x2F;directory&#x2F;containing&#x2F;wild` to gcc.<p>As for why Rust uses gcc or clang to invoke the linker rather than invoking the linker directly - it&#x27;s because the C compiler knows what linker flags are needed on the current platform in order to link against libc and the C runtime. Things like `Scrt1.o`, `crti.o`, `crtbeginS.o`, `crtendS.o` and `crtn.o`.</div><br/><div id="42818920" class="c"><input type="checkbox" id="c-42818920" checked=""/><div class="controls bullet"><span class="by">inkyoto</span><span>|</span><a href="#42816069">root</a><span>|</span><a href="#42817056">parent</a><span>|</span><a href="#42817154">next</a><span>|</span><label class="collapse" for="c-42818920">[-]</label><label class="expand" for="c-42818920">[1 more]</label></div><br/><div class="children"><div class="content">&gt; It is possible to use gcc to invoke wild as the linker, but currently to do that, you need to create a directory containing the wild linker and rename the binary (or a symlink) to &quot;ld&quot;, then pass `-B&#x2F;path&#x2F;to&#x2F;directory&#x2F;containing&#x2F;wild` to gcc.<p>Instead of renaming and passing -B in, you can also modify the GCC «spec» file&#x27;s «%linker» section to make it point to a linker of your choice, i.e.<p><pre><code>  %linker:
  &#x2F;scratch&#x2F;bin&#x2F;wild %{wild_options}
</code></pre>
Linking options can be amended in the «%link_command» section.<p>It is possible to either modify the default «spec» file («gcc -dumpspecs») or pass your own along via «-specs=my-specs-file». I have found custom «spec» files to be very useful in the past.<p>The «spec» file format is documented at <a href="https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Spec-Files.html" rel="nofollow">https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Spec-Files.html</a></div><br/></div></div><div id="42817154" class="c"><input type="checkbox" id="c-42817154" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#42816069">root</a><span>|</span><a href="#42817056">parent</a><span>|</span><a href="#42818920">prev</a><span>|</span><a href="#42816486">next</a><span>|</span><label class="collapse" for="c-42817154">[-]</label><label class="expand" for="c-42817154">[1 more]</label></div><br/><div class="children"><div class="content">Ah, good to know, thanks!<p>May be it&#x27;s worth filing a feature request for gcc to have parity with clang for arbitrary linkers?</div><br/></div></div></div></div><div id="42816486" class="c"><input type="checkbox" id="c-42816486" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42816069">parent</a><span>|</span><a href="#42817056">prev</a><span>|</span><a href="#42817318">next</a><span>|</span><label class="collapse" for="c-42816486">[-]</label><label class="expand" for="c-42816486">[3 more]</label></div><br/><div class="children"><div class="content">Because Rust compiler generates IR bytecode, not machine code.</div><br/><div id="42816604" class="c"><input type="checkbox" id="c-42816604" checked=""/><div class="controls bullet"><span class="by">shmerl</span><span>|</span><a href="#42816069">root</a><span>|</span><a href="#42816486">parent</a><span>|</span><a href="#42817318">next</a><span>|</span><label class="collapse" for="c-42816604">[-]</label><label class="expand" for="c-42816604">[2 more]</label></div><br/><div class="children"><div class="content">That&#x27;s the reason to use llvm as part of Rust compiler toolchain, not to use gcc or clang as linker manager?</div><br/><div id="42817419" class="c"><input type="checkbox" id="c-42817419" checked=""/><div class="controls bullet"><span class="by">sedatk</span><span>|</span><a href="#42816069">root</a><span>|</span><a href="#42816604">parent</a><span>|</span><a href="#42817318">next</a><span>|</span><label class="collapse" for="c-42817419">[-]</label><label class="expand" for="c-42817419">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re right, @davidlattimore seems to have answered that.</div><br/></div></div></div></div></div></div></div></div><div id="42817318" class="c"><input type="checkbox" id="c-42817318" checked=""/><div class="controls bullet"><span class="by">KerrAvon</span><span>|</span><a href="#42816069">prev</a><span>|</span><a href="#42816049">next</a><span>|</span><label class="collapse" for="c-42817318">[-]</label><label class="expand" for="c-42817318">[3 more]</label></div><br/><div class="children"><div class="content">I&#x27;m curious: what&#x27;s the theory behind why this would be faster than mold in the non-incremental case? &quot;Because Rust&quot; is a fine explanation for a bunch of things, but doesn&#x27;t explain expected performance benefits.<p>&quot;Because there&#x27;s low hanging concurrent fruit that Rust can help us get?&quot; would be interesting but that&#x27;s not explicitly stated or even implied.</div><br/><div id="42818238" class="c"><input type="checkbox" id="c-42818238" checked=""/><div class="controls bullet"><span class="by">davidlattimore</span><span>|</span><a href="#42817318">parent</a><span>|</span><a href="#42816049">next</a><span>|</span><label class="collapse" for="c-42818238">[-]</label><label class="expand" for="c-42818238">[2 more]</label></div><br/><div class="children"><div class="content">I&#x27;m not actually sure, mostly because I&#x27;m not really familiar with the Mold codebase. One clue is that I&#x27;ve heard that Mold gets about a 10% speedup by using a faster allocator (mimalloc). I&#x27;ve tried using mimalloc with Wild and didn&#x27;t get any measurable speedup. This suggests to me that Mold is probably making heavier use of the allocator than Wild is. With Wild, I&#x27;ve certainly tried to optimise the number of heap allocations.<p>But in general, I&#x27;d guess just different design decisions. As for how this might be related to Rust - I&#x27;m certain that were Wild ported from Rust to C or C++, that it would perform very similarly. However, code patterns that are fine in Rust due to the borrow checker, would be footguns in languages like C or C++, so maintaining that code could be tricky. Certainly when I&#x27;ve coded in C++ in the past, I&#x27;ve found myself coding more defensively, even at a small performance cost, whereas with Rust, I&#x27;m  able to be a lot bolder because I know the compiler has got my back.</div><br/><div id="42820415" class="c"><input type="checkbox" id="c-42820415" checked=""/><div class="controls bullet"><span class="by">menaerus</span><span>|</span><a href="#42817318">root</a><span>|</span><a href="#42818238">parent</a><span>|</span><a href="#42816049">next</a><span>|</span><label class="collapse" for="c-42820415">[-]</label><label class="expand" for="c-42820415">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Mold gets about a 10% speedup by using a faster allocator (mimalloc). I&#x27;ve tried using mimalloc with Wild and didn&#x27;t get any measurable speedup<p>Perhaps it is worth repeating the experiment with heavy MLoC codebases. jmalloc or mimalloc.</div><br/></div></div></div></div></div></div><div id="42816346" class="c"><input type="checkbox" id="c-42816346" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#42816049">prev</a><span>|</span><a href="#42814926">next</a><span>|</span><label class="collapse" for="c-42816346">[-]</label><label class="expand" for="c-42816346">[4 more]</label></div><br/><div class="children"><div class="content">The real issue is actually runtime ELF (and PE) which are obsolete on modern hardware architecture.</div><br/><div id="42816474" class="c"><input type="checkbox" id="c-42816474" checked=""/><div class="controls bullet"><span class="by">bmacho</span><span>|</span><a href="#42816346">parent</a><span>|</span><a href="#42814926">next</a><span>|</span><label class="collapse" for="c-42816474">[-]</label><label class="expand" for="c-42816474">[3 more]</label></div><br/><div class="children"><div class="content">What do you mean by this?</div><br/><div id="42817495" class="c"><input type="checkbox" id="c-42817495" checked=""/><div class="controls bullet"><span class="by">sylware</span><span>|</span><a href="#42816346">root</a><span>|</span><a href="#42816474">parent</a><span>|</span><a href="#42814926">next</a><span>|</span><label class="collapse" for="c-42817495">[-]</label><label class="expand" for="c-42817495">[2 more]</label></div><br/><div class="children"><div class="content">ELF(COFF) should now be only an assembler output format on modern large hardware architecture.<p>On modern large hardware architecture, for executable files&#x2F;dynamic libraries, ELF(PE[+]) has overkill complexity.<p>I am personnally using a executable file format of my own I do wrap into an &quot;ELF capsule&quot; on linux kernel. With position independent code, you kind of only need memory mapped segments (which dynamic libraries are in this very format). I have two very simple partial linkers I wrote in plain and simple C, one for risc-v assembly, one for x86_64 assembly, which allow me to link into such executable file some simple ELF object files (from binutils GAS).<p>There is no more centralized &quot;ELF loader&quot;.<p>Of course, there are tradeoffs, 1 billion times worth it in regards of the accute simplicity of the format.<p>(I even have a little vm which allows me to interpret simple risc-v binaries on x86_64).</div><br/><div id="42820018" class="c"><input type="checkbox" id="c-42820018" checked=""/><div class="controls bullet"><span class="by">o11c</span><span>|</span><a href="#42816346">root</a><span>|</span><a href="#42817495">parent</a><span>|</span><a href="#42814926">next</a><span>|</span><label class="collapse" for="c-42820018">[-]</label><label class="expand" for="c-42820018">[1 more]</label></div><br/><div class="children"><div class="content">You&#x27;re giving up a <i>lot</i> if you stop using a format that supports multiple mapping, relro, dynamic relocations, ...</div><br/></div></div></div></div></div></div></div></div><div id="42814926" class="c"><input type="checkbox" id="c-42814926" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#42816346">prev</a><span>|</span><a href="#42814864">next</a><span>|</span><label class="collapse" for="c-42814926">[-]</label><label class="expand" for="c-42814926">[15 more]</label></div><br/><div class="children"><div class="content">I think the optimal approach for development would be to not produce a traditional linked executable at all, but instead just place the object files in memory, and then produce a loader executable that hooks page faults in those memory areas and on-demand mmaps the relevant object elsewhere, applies relocations to it, and then moves it in place with mremap.<p>Symbols would be resolved based on an index where only updated object files are reindexed. It could also eagerly relocate in the background, in order depending on previous usage data.<p>This would basically make a copyless lazy incremental linker.</div><br/><div id="42815621" class="c"><input type="checkbox" id="c-42815621" checked=""/><div class="controls bullet"><span class="by">95014_refugee</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815180">next</a><span>|</span><label class="collapse" for="c-42815621">[-]</label><label class="expand" for="c-42815621">[1 more]</label></div><br/><div class="children"><div class="content">This makes some very naïve assumptions about the relationships between entities in a program; in particular that you can make arbitrary assertions about the representation of already-allocated datastructures across multiple versions of a component, that the program&#x27;s compositional structure morphs in understandable ways, and that you can pause a program in a state where a component can actually be replaced.<p>By the time you have addressed these, you&#x27;ll find yourself building a microkernel system with a collection of independent servers and well-defined interaction protocols. Which isn&#x27;t necessarily a terrible way to assemble something, but it&#x27;s not quite where you&#x27;re trying to go...</div><br/></div></div><div id="42815180" class="c"><input type="checkbox" id="c-42815180" checked=""/><div class="controls bullet"><span class="by">fsfod</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815621">prev</a><span>|</span><a href="#42815042">next</a><span>|</span><label class="collapse" for="c-42815180">[-]</label><label class="expand" for="c-42815180">[3 more]</label></div><br/><div class="children"><div class="content">You can sort of do that with some of LLVM&#x27;s JIT systems <a href="https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;JITLink.html" rel="nofollow">https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;JITLink.html</a>, I&#x27;m surprised that no one has yet made a edit and continue system using it.</div><br/><div id="42815305" class="c"><input type="checkbox" id="c-42815305" checked=""/><div class="controls bullet"><span class="by">all2</span><span>|</span><a href="#42814926">root</a><span>|</span><a href="#42815180">parent</a><span>|</span><a href="#42817971">next</a><span>|</span><label class="collapse" for="c-42815305">[-]</label><label class="expand" for="c-42815305">[1 more]</label></div><br/><div class="children"><div class="content">My parens sense is tingling. This sounds like a lisp-machine, or just standard lisp development environment.</div><br/></div></div><div id="42817971" class="c"><input type="checkbox" id="c-42817971" checked=""/><div class="controls bullet"><span class="by">samatman</span><span>|</span><a href="#42814926">root</a><span>|</span><a href="#42815180">parent</a><span>|</span><a href="#42815305">prev</a><span>|</span><a href="#42815042">next</a><span>|</span><label class="collapse" for="c-42817971">[-]</label><label class="expand" for="c-42817971">[1 more]</label></div><br/><div class="children"><div class="content">They have! It&#x27;s called Julia and it&#x27;s great.</div><br/></div></div></div></div><div id="42815042" class="c"><input type="checkbox" id="c-42815042" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815180">prev</a><span>|</span><a href="#42815279">next</a><span>|</span><label class="collapse" for="c-42815042">[-]</label><label class="expand" for="c-42815042">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like dynamic linking, sort of.</div><br/></div></div><div id="42815279" class="c"><input type="checkbox" id="c-42815279" checked=""/><div class="controls bullet"><span class="by">eseidel</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815042">prev</a><span>|</span><a href="#42815660">next</a><span>|</span><label class="collapse" for="c-42815279">[-]</label><label class="expand" for="c-42815279">[1 more]</label></div><br/><div class="children"><div class="content">Sounds like Apple&#x27;s old ZeroLink from the aughts?</div><br/></div></div><div id="42815660" class="c"><input type="checkbox" id="c-42815660" checked=""/><div class="controls bullet"><span class="by">jjmarr</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815279">prev</a><span>|</span><a href="#42815895">next</a><span>|</span><label class="collapse" for="c-42815660">[-]</label><label class="expand" for="c-42815660">[4 more]</label></div><br/><div class="children"><div class="content">Isn&#x27;t this how dynamic linking works? If you really want to reduce build times, you should be making your hot path in the build a shared library, so you don&#x27;t have to relink so long as you&#x27;re not changing the interface.</div><br/><div id="42816581" class="c"><input type="checkbox" id="c-42816581" checked=""/><div class="controls bullet"><span class="by">hinkley</span><span>|</span><a href="#42814926">root</a><span>|</span><a href="#42815660">parent</a><span>|</span><a href="#42815895">next</a><span>|</span><label class="collapse" for="c-42816581">[-]</label><label class="expand" for="c-42816581">[3 more]</label></div><br/><div class="children"><div class="content">But do rust’s invariants work across dynamic links?<p>I thought a lot of its proofs were done at compile time not link time.</div><br/><div id="42818056" class="c"><input type="checkbox" id="c-42818056" checked=""/><div class="controls bullet"><span class="by">pas</span><span>|</span><a href="#42814926">root</a><span>|</span><a href="#42816581">parent</a><span>|</span><a href="#42818263">next</a><span>|</span><label class="collapse" for="c-42818056">[-]</label><label class="expand" for="c-42818056">[1 more]</label></div><br/><div class="children"><div class="content">The proof can be done on the whole code (in memory, incremental, etc), and then the modules emitted as dynamically loadable objects.</div><br/></div></div><div id="42818263" class="c"><input type="checkbox" id="c-42818263" checked=""/><div class="controls bullet"><span class="by">Nullabillity</span><span>|</span><a href="#42814926">root</a><span>|</span><a href="#42816581">parent</a><span>|</span><a href="#42818056">prev</a><span>|</span><a href="#42815895">next</a><span>|</span><label class="collapse" for="c-42818263">[-]</label><label class="expand" for="c-42818263">[1 more]</label></div><br/><div class="children"><div class="content">Yesn&#x27;t.<p>Rust is perfectly happy to emit&#x2F;use dynamic links.[0] It&#x27;s just that the primary C use case (distributing and updating the main app and its libraries separately) ends up being unsafe since Rust&#x27;s ABI is unstable (so compiler versions, libraries, etc must match <i>exactly</i>).<p>Avoiding static relinking during development is pretty much <i>the</i> use where it does work. In fact, Bevy recommends this as part of its setup guide![1]<p>Practice paints a slightly less rosy picture, though; since the feature is exercised quite rarely, not all libraries work well with it in practice.[2]<p>[0]: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;linkage.html#r-link.dylib" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;linkage.html#r-link.dyli...</a><p>[1]: <a href="https:&#x2F;&#x2F;bevyengine.org&#x2F;learn&#x2F;quick-start&#x2F;getting-started&#x2F;setup&#x2F;#dynamic-linking" rel="nofollow">https:&#x2F;&#x2F;bevyengine.org&#x2F;learn&#x2F;quick-start&#x2F;getting-started&#x2F;set...</a><p>[2]: For example, <a href="https:&#x2F;&#x2F;github.com&#x2F;linebender&#x2F;bevy_vello&#x2F;issues&#x2F;84">https:&#x2F;&#x2F;github.com&#x2F;linebender&#x2F;bevy_vello&#x2F;issues&#x2F;84</a></div><br/></div></div></div></div></div></div><div id="42815895" class="c"><input type="checkbox" id="c-42815895" checked=""/><div class="controls bullet"><span class="by">cbsmith</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815660">prev</a><span>|</span><a href="#42815474">next</a><span>|</span><label class="collapse" for="c-42815895">[-]</label><label class="expand" for="c-42815895">[1 more]</label></div><br/><div class="children"><div class="content">That sounds a lot like traditional dynamic language runtimes. You kind of get that for free with Smalltalk&#x2F;LISP&#x2F;etc.</div><br/></div></div><div id="42815474" class="c"><input type="checkbox" id="c-42815474" checked=""/><div class="controls bullet"><span class="by">ignoramous</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815895">prev</a><span>|</span><a href="#42815434">next</a><span>|</span><label class="collapse" for="c-42815474">[-]</label><label class="expand" for="c-42815474">[1 more]</label></div><br/><div class="children"><div class="content">&gt; <i>Symbols would be resolved based on an index where only updated object files are reindexed. It could also eagerly relocate in the background, in order depending on previous usage data.</i><p>Not exactly this, but Google&#x27;s <i>Propeller</i> fixes up (&quot;relinks&quot;) Basic Blocks (hot code as traced from PGO) in native code at runtime (like an optimizing JIT compiler would): <a href="https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;propeller-a-profile-guided-relinking-optimizer-for-warehouse-scale-applications&#x2F;" rel="nofollow">https:&#x2F;&#x2F;research.google&#x2F;pubs&#x2F;propeller-a-profile-guided-reli...</a></div><br/></div></div><div id="42815434" class="c"><input type="checkbox" id="c-42815434" checked=""/><div class="controls bullet"><span class="by">checker659</span><span>|</span><a href="#42814926">parent</a><span>|</span><a href="#42815474">prev</a><span>|</span><a href="#42815894">next</a><span>|</span><label class="collapse" for="c-42815434">[-]</label><label class="expand" for="c-42815434">[1 more]</label></div><br/><div class="children"><div class="content">Linker overlays?</div><br/></div></div></div></div><div id="42814864" class="c"><input type="checkbox" id="c-42814864" checked=""/><div class="controls bullet"><span class="by">throwaway106382</span><span>|</span><a href="#42814926">prev</a><span>|</span><a href="#42815156">next</a><span>|</span><label class="collapse" for="c-42814864">[-]</label><label class="expand" for="c-42814864">[29 more]</label></div><br/><div class="children"><div class="content">&gt; Mold is already very fast, however it doesn&#x27;t do incremental linking and the author has stated that they don&#x27;t intend to. Wild doesn&#x27;t do incremental linking yet, but that is the end-goal. By writing Wild in Rust, it&#x27;s hoped that the complexity of incremental linking will be achievable.<p>Can someone explain what is so special about Rust for this?</div><br/><div id="42814952" class="c"><input type="checkbox" id="c-42814952" checked=""/><div class="controls bullet"><span class="by">senkora</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42814975">next</a><span>|</span><label class="collapse" for="c-42814952">[-]</label><label class="expand" for="c-42814952">[13 more]</label></div><br/><div class="children"><div class="content">I assume that he is referring to &quot;fearless concurrency&quot;, the idea that Rust makes it possible to write more complex concurrent programs than other languages because of the safety guarantees:<p><a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch16-00-concurrency.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch16-00-concurrency.html</a><p>So the logic would go:<p>1. mold doesn&#x27;t do incremental linking because it is too complex to do it while still being fast (concurrent).<p>2. Rust makes it possible to write very complex fast (concurrent) programs.<p>3. A new linker written in Rust can do incremental linking while still being fast (concurrent).<p>EDIT: I meant this originally, but comments were posted before I added it so I want to be clear that this part is new: (Any of those three could be false; I take no strong position on that. But I believe that this is the motivating logic.)</div><br/><div id="42814991" class="c"><input type="checkbox" id="c-42814991" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814952">parent</a><span>|</span><a href="#42814984">next</a><span>|</span><label class="collapse" for="c-42814991">[-]</label><label class="expand" for="c-42814991">[11 more]</label></div><br/><div class="children"><div class="content">Actually a lot of the hacks that mold uses to be the fastest linker would be, ironically, harder to reproduce with rust because they’re antithetical to its approach. Eg Mold intentionally eschews used resource collection to speed up execution (it’ll be cleaned up by the os when the process exits) while rust has a strong RAII approach here that would introduce slowdowns.</div><br/><div id="42815472" class="c"><input type="checkbox" id="c-42815472" checked=""/><div class="controls bullet"><span class="by">junon</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814991">parent</a><span>|</span><a href="#42815635">next</a><span>|</span><label class="collapse" for="c-42815472">[-]</label><label class="expand" for="c-42815472">[1 more]</label></div><br/><div class="children"><div class="content">You can absolutely introduce free-less allocators and the like, as well as use `ManuallyDrop` or `Box::leak`. Rust just asks that you&#x27;re explicit about it.</div><br/></div></div><div id="42815635" class="c"><input type="checkbox" id="c-42815635" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814991">parent</a><span>|</span><a href="#42815472">prev</a><span>|</span><a href="#42815095">next</a><span>|</span><label class="collapse" for="c-42815635">[-]</label><label class="expand" for="c-42815635">[1 more]</label></div><br/><div class="children"><div class="content">Nothing about Rust requires the use of the heap or RAII.<p>Also, if wild is indeed faster than mold even without incrementalism, as the benchmarks show, then it seems quite silly to go around making the argument that it&#x27;s harder to write a fast linker in Rust.  It&#x27;s apparently not <i>that</i> hard.</div><br/></div></div><div id="42815095" class="c"><input type="checkbox" id="c-42815095" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814991">parent</a><span>|</span><a href="#42815635">prev</a><span>|</span><a href="#42815034">next</a><span>|</span><label class="collapse" for="c-42815095">[-]</label><label class="expand" for="c-42815095">[5 more]</label></div><br/><div class="children"><div class="content">Depends on how things are approached.<p>You could, for example, take advantage of bump arena allocator in rust which would allow the linker to have just 1 alloc&#x2F;dealloc.  Mold is still using more traditional allocators under the covers which won&#x27;t be as fast as a bump allocator. (Nothing would stop mold from doing the same).</div><br/><div id="42815432" class="c"><input type="checkbox" id="c-42815432" checked=""/><div class="controls bullet"><span class="by">cma</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42815095">parent</a><span>|</span><a href="#42815034">next</a><span>|</span><label class="collapse" for="c-42815432">[-]</label><label class="expand" for="c-42815432">[4 more]</label></div><br/><div class="children"><div class="content">Traditional allocators are fast if you never introduce much fragmentation with free, though you may still get some gaps and have some other overhead and not be quite as fast.  But why couldn&#x27;t you just LD_PRELOAD a malloc for mold that worked as a bump&#x2F;stack&#x2F;arena allocator and just ignored free if anything party stuff isn&#x27;t making that many allocations?</div><br/><div id="42815581" class="c"><input type="checkbox" id="c-42815581" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42815432">parent</a><span>|</span><a href="#42815034">next</a><span>|</span><label class="collapse" for="c-42815581">[-]</label><label class="expand" for="c-42815581">[3 more]</label></div><br/><div class="children"><div class="content">&gt; Traditional allocators are fast<p>Really it&#x27;s allocators in general. Allocations are perceived as expensive only because they are mostly dependent on the amortized cost of prior deallocations. As an extreme example, even GCs can be fast if you avoid deallocation because most typically have a long-lived object heap that rarely gets collected - so if you keep things around that can be long-lived (pooling) their cost mostly goes away.</div><br/><div id="42816089" class="c"><input type="checkbox" id="c-42816089" checked=""/><div class="controls bullet"><span class="by">cogman10</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42815581">parent</a><span>|</span><a href="#42815034">next</a><span>|</span><label class="collapse" for="c-42816089">[-]</label><label class="expand" for="c-42816089">[2 more]</label></div><br/><div class="children"><div class="content">Slight disagreement here.<p>Allocation is perceived as slow because it is.  Getting memory from the OS is somewhat expensive because a page of memory needs to be allocated and stored off.  Getting memory from traditional allocators is expensive because freespace needs to be tracked.  When you say &quot;I need 5 bytes&quot; the allocator needs to find 5 free bytes to give back to you.<p>Bump allocators are fast because the operation of &quot;I need 5 bytes&quot; is incrementing the allocation pointer forward by 5 bytes and maybe doing a new page allocation if that&#x27;s exhausted.<p>GC allocators are fast because they are generally bump allocators!  The only difference is that when exhaustion happens the GC says &quot;I need to run a GC&quot;.<p>Traditional allocators are a bit slower because they are typically something like an arena with skiplists used to find free space.  When you free up memory, that skiplist needs to be updated.<p>But further, unlike bump and GC allocators another fault of traditional allocators is they have a tendency to scatter memory which has a negative impact on CPU cache performance.  With the assumption that related memory tends to be allocated at the same time, GCs and bump allocators will colocate memory.  But, because of the skiplist, traditional allocators will scattershot allocations to avoid free memory fragmentation.<p>All this said, for most apps this doesn&#x27;t matter a whole lot.  However, if you are doing a CPU&#x2F;memory intense operation then this is stuff to know.</div><br/><div id="42818240" class="c"><input type="checkbox" id="c-42818240" checked=""/><div class="controls bullet"><span class="by">zamalek</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42816089">parent</a><span>|</span><a href="#42815034">next</a><span>|</span><label class="collapse" for="c-42818240">[-]</label><label class="expand" for="c-42818240">[1 more]</label></div><br/><div class="children"><div class="content">&gt; Getting memory from traditional allocators is expensive because freespace needs to be tracked.<p>If you&#x27;ve never deallocated then there is no free space to track, hence the cost of allocation is _mostly_ (per my above comment) affected by the amortized cost of deallocations. The cost becomes extremely apparent with GCs because a failed allocation is usually what triggers a collection (and subsequently any deallocations that need to happen).<p>Still, your comment goes into detail that I probably should have.</div><br/></div></div></div></div></div></div></div></div></div></div><div id="42815034" class="c"><input type="checkbox" id="c-42815034" checked=""/><div class="controls bullet"><span class="by">Philpax</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814991">parent</a><span>|</span><a href="#42815095">prev</a><span>|</span><a href="#42814984">next</a><span>|</span><label class="collapse" for="c-42815034">[-]</label><label class="expand" for="c-42815034">[3 more]</label></div><br/><div class="children"><div class="content">I mean, that&#x27;s pretty easy to do in Rust: <a href="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;struct.ManuallyDrop.html" rel="nofollow">https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;struct.ManuallyDrop.html</a><p>Also see various arena allocator crates, etc.</div><br/><div id="42815101" class="c"><input type="checkbox" id="c-42815101" checked=""/><div class="controls bullet"><span class="by">ComputerGuru</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42815034">parent</a><span>|</span><a href="#42814984">next</a><span>|</span><label class="collapse" for="c-42815101">[-]</label><label class="expand" for="c-42815101">[2 more]</label></div><br/><div class="children"><div class="content">Not really. You would have to either wrap any standard library types in newtypes with ManuallyDrop implemented or (for some) use a custom allocator. And if you want to free some things in one go but not others that gets much harder, especially when you look at how easy a language like zig makes it.<p>And if you intentionally leak everything it is onerous to get the borrow checker to realize that unless you use a leaked box for all declaration&#x2F;allocations, which introduces both friction and performance regressions (due to memory access patterns) because the use of custom allocators doesn’t factor into lifetime analysis.<p>(Spoken as a die-hard rust dev that still thinks it’s the better language than zig for most everything.)</div><br/><div id="42815448" class="c"><input type="checkbox" id="c-42815448" checked=""/><div class="controls bullet"><span class="by">Aurornis</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42815101">parent</a><span>|</span><a href="#42814984">next</a><span>|</span><label class="collapse" for="c-42815448">[-]</label><label class="expand" for="c-42815448">[1 more]</label></div><br/><div class="children"><div class="content">&gt; You would have to either wrap any standard library types in newtypes with ManuallyDrop implemented<p>ManuallyDrop would presumably be implemented on large data structures where it matters, not on every single type involved in the program.</div><br/></div></div></div></div></div></div></div></div><div id="42814984" class="c"><input type="checkbox" id="c-42814984" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814952">parent</a><span>|</span><a href="#42814991">prev</a><span>|</span><a href="#42814975">next</a><span>|</span><label class="collapse" for="c-42814984">[-]</label><label class="expand" for="c-42814984">[1 more]</label></div><br/><div class="children"><div class="content">Both mold and lld are already very heavily concurrent. There is no fear at all there.</div><br/></div></div></div></div><div id="42814975" class="c"><input type="checkbox" id="c-42814975" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42814952">prev</a><span>|</span><a href="#42816061">next</a><span>|</span><label class="collapse" for="c-42814975">[-]</label><label class="expand" for="c-42814975">[3 more]</label></div><br/><div class="children"><div class="content">That’s puzzling to me too. Rust is a great language, and probably makes developing Wild faster. But the complexity of incremental linking doesn’t stem from the linker’s implementation language. It stems from all the tracking, reserved spacing, and other issues required to link a previously linked binary (or at least parts of it) a second time.</div><br/><div id="42815923" class="c"><input type="checkbox" id="c-42815923" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814975">parent</a><span>|</span><a href="#42815683">next</a><span>|</span><label class="collapse" for="c-42815923">[-]</label><label class="expand" for="c-42815923">[1 more]</label></div><br/><div class="children"><div class="content">Rust allows your to enforce more invariants at compile time, so implementing a complex system where you are likely to make a mistake and violate those invariants is easier.</div><br/></div></div><div id="42815683" class="c"><input type="checkbox" id="c-42815683" checked=""/><div class="controls bullet"><span class="by">tialaramex</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814975">parent</a><span>|</span><a href="#42815923">prev</a><span>|</span><a href="#42816061">next</a><span>|</span><label class="collapse" for="c-42815683">[-]</label><label class="expand" for="c-42815683">[1 more]</label></div><br/><div class="children"><div class="content">I would guess the idea is that in Rust the complexity is cheaper on a &quot;per unit&quot; basis so you can afford more complexity. So yes, it is a more complicated problem than the previous linkers, but, in Rust maybe you can get that done anyway.</div><br/></div></div></div></div><div id="42816061" class="c"><input type="checkbox" id="c-42816061" checked=""/><div class="controls bullet"><span class="by">wffurr</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42814975">prev</a><span>|</span><a href="#42814925">next</a><span>|</span><label class="collapse" for="c-42816061">[-]</label><label class="expand" for="c-42816061">[1 more]</label></div><br/><div class="children"><div class="content">I went looking for some writing by the author about <i>how</i> he made wild fast, but couldn&#x27;t find much: <a href="https:&#x2F;&#x2F;davidlattimore.github.io&#x2F;" rel="nofollow">https:&#x2F;&#x2F;davidlattimore.github.io&#x2F;</a></div><br/></div></div><div id="42814925" class="c"><input type="checkbox" id="c-42814925" checked=""/><div class="controls bullet"><span class="by">dralley</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42816061">prev</a><span>|</span><a href="#42815564">next</a><span>|</span><label class="collapse" for="c-42814925">[-]</label><label class="expand" for="c-42814925">[2 more]</label></div><br/><div class="children"><div class="content">I assume they&#x27;re referring to thread-safety and the ability to more aggressively parallelize.</div><br/><div id="42815000" class="c"><input type="checkbox" id="c-42815000" checked=""/><div class="controls bullet"><span class="by">compiler-guy</span><span>|</span><a href="#42814864">root</a><span>|</span><a href="#42814925">parent</a><span>|</span><a href="#42815564">next</a><span>|</span><label class="collapse" for="c-42815000">[-]</label><label class="expand" for="c-42815000">[1 more]</label></div><br/><div class="children"><div class="content">Mold and lld are already very heavily parallelized. It’s one of the things that makes them very fast already.</div><br/></div></div></div></div><div id="42815564" class="c"><input type="checkbox" id="c-42815564" checked=""/><div class="controls bullet"><span class="by">the_duke</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42814925">prev</a><span>|</span><a href="#42816644">next</a><span>|</span><label class="collapse" for="c-42815564">[-]</label><label class="expand" for="c-42815564">[1 more]</label></div><br/><div class="children"><div class="content">Rust has a pretty good incremental caching compiler that makes debug builds relatively fast.<p>Linking is often a very notable bottleneck for debug binaries and mold can make a big difference.<p>So interest in speeding up linking for Rust is expected.</div><br/></div></div><div id="42816644" class="c"><input type="checkbox" id="c-42816644" checked=""/><div class="controls bullet"><span class="by">panstromek</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42815564">prev</a><span>|</span><a href="#42815031">next</a><span>|</span><label class="collapse" for="c-42816644">[-]</label><label class="expand" for="c-42816644">[1 more]</label></div><br/><div class="children"><div class="content">Apart from what others said, maybe he plans to use Salsa or something like that. Rust has a few popular libraries for doing this.</div><br/></div></div><div id="42815031" class="c"><input type="checkbox" id="c-42815031" checked=""/><div class="controls bullet"><span class="by">IshKebab</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42816644">prev</a><span>|</span><a href="#42814958">next</a><span>|</span><label class="collapse" for="c-42815031">[-]</label><label class="expand" for="c-42815031">[1 more]</label></div><br/><div class="children"><div class="content">There are two main factors:<p>1. Rust&#x27;s well designed type system and borrow checker makes writing code that works just easier. It has the &quot;if it compiles it works&quot; property (not unique to Rust; people say this about e.g. Haskell too).<p>2. Rust&#x27;s type system - especially its trait system can be used to enforce safety constraints statically. The obvious one is the Send and Sync traits for thread safety, but there are others, e.g. the Fuchsia network code statically guarantees deadlocks are impossible.<p>Mold is written in C++ which is extremely error prone in comparison.</div><br/></div></div><div id="42814958" class="c"><input type="checkbox" id="c-42814958" checked=""/><div class="controls bullet"><span class="by">devit</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42815031">prev</a><span>|</span><a href="#42815091">next</a><span>|</span><label class="collapse" for="c-42814958">[-]</label><label class="expand" for="c-42814958">[1 more]</label></div><br/><div class="children"><div class="content">It&#x27;s feasible to write complex correct programs with optimal performance in Rust, unlike any other programming language (complex+correct is not feasible in C&#x2F;C++&#x2F;assembly&#x2F;Zig&#x2F;etc., optimal performance not possible in any other language).</div><br/></div></div><div id="42815056" class="c"><input type="checkbox" id="c-42815056" checked=""/><div class="controls bullet"><span class="by">manoweb</span><span>|</span><a href="#42814864">parent</a><span>|</span><a href="#42814916">prev</a><span>|</span><a href="#42815156">next</a><span>|</span><label class="collapse" for="c-42815056">[-]</label><label class="expand" for="c-42815056">[1 more]</label></div><br/><div class="children"><div class="content">That is baffling. Maybe the author assumes that a language with many safeguards will lead to keeping complexity under control for a difficult task.<p>By the way I had to lookup what incremental linking is, in practice I think it means that code from libraries and modules that have not changed won’t need to be re-packed each time which ch will save time for frequent development builds, it’s actually ingenious</div><br/></div></div></div></div></div></div></div></div></div></body></html>